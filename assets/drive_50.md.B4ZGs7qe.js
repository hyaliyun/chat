import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},N={class:"review-content"};function E(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const A=c(k,[["render",E],["__scopeId","data-v-a1a3c620"]]),z=JSON.parse('[{"question":"# Question: Implement Huffman Coding for Data Compression Given an input file, implement the Huffman Coding algorithm to encode the file\'s content and then decode the file back to its original content to verify that the lossless compression works correctly. The main tasks are to: 1. Calculate the frequency of each character. 2. Build the Huffman tree. 3. Generate Huffman codes. 4. Encode the input file. 5. Decode the encoded file and verify the original content. Your task is to implement the following two functions: **Function 1: encode_file** ```python def encode_file(input_filename: str, encoded_filename: str) -> None: Encodes the content of the input file using Huffman Coding and stores the encoded result in a binary file along with the Huffman tree structure. :param input_filename: The name of the file to be encoded :param encoded_filename: The name of the file to store the encoded content pass ``` **Function 2: decode_file** ```python def decode_file(encoded_filename: str, decoded_filename: str) -> None: Decodes the content of the encoded file using Huffman Coding and stores the decoded result in a new file. :param encoded_filename: The name of the file with the encoded content :param decoded_filename: The name of the file to store the decoded content pass ``` # Input and Output Formats 1. **Input (encode_file)**: - `input_filename`: Path to the input file containing the text to be encoded. - `encoded_filename`: Path to the output file where the encoded binary data and Huffman tree will be stored. 2. **Output (encode_file)**: - The function should compress the content of the input file using Huffman Coding and save the binary encoded data and tree to the specified output file. 3. **Input (decode_file)**: - `encoded_filename`: Path to the encoded file containing the binary Huffman coded data and tree. - `decoded_filename`: Path to the output file where the decoded text will be stored. 4. **Output (decode_file)**: - The function should decode the binary Huffman coded data and save the original text into the specified output file. # Constraints 1. Assume all input files contain only ASCII characters (0-127). 2. The size of the input file will not exceed 1MB. # Performance Requirements 1. Ensure that the encoding and decoding processes are efficient and complete in a reasonable time for the input file size limit. 2. Minimize the memory usage while storing the Huffman tree and encoded data. # Example Suppose `input.txt` contains: `hello huffman` - Encode the file: ```python encode_file(\'input.txt\', \'encoded.bin\') ``` - Decode the file and verify the content: ```python decode_file(\'encoded.bin\', \'decoded.txt\') ``` - After decoding, `decoded.txt` should contain: `hello huffman` Implement the `encode_file` and `decode_file` functions to achieve the tasks as described. Make sure to handle edge cases and optimize your code for performance.","solution":"import heapq import os from collections import defaultdict, Counter import pickle class Node: def __init__(self, char=None, freq=None, left=None, right=None): self.char = char self.freq = freq self.left = left self.right = right def __lt__(self, other): return self.freq < other.freq def build_huffman_tree(text): frequency = Counter(text) priority_queue = [Node(char, freq) for char, freq in frequency.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = Node(left=node1, right=node2, freq=node1.freq + node2.freq) heapq.heappush(priority_queue, merged) return priority_queue[0] if priority_queue else None def build_codes(node, prefix=\'\', codebook={}): if node: if node.char is not None: codebook[node.char] = prefix build_codes(node.left, prefix + \'0\', codebook) build_codes(node.right, prefix + \'1\', codebook) return codebook def encode_text(text, codebook): return \'\'.join(codebook[char] for char in text) def pad_encoded_text(encoded_text): extra_padding = 8 - len(encoded_text) % 8 for _ in range(extra_padding): encoded_text += \'0\' padded_info = \\"{0:08b}\\".format(extra_padding) encoded_text = padded_info + encoded_text return encoded_text def to_bytearray(padded_encoded_code): if len(padded_encoded_code) % 8 != 0: raise ValueError(\\"Encoded text length is not a multiple of 8.\\") byte_array = bytearray() for i in range(0, len(padded_encoded_code), 8): byte_byte = padded_encoded_code[i:i+8] byte_array.append(int(byte_byte, 2)) return byte_array def encode_file(input_filename: str, encoded_filename: str) -> None: with open(input_filename, \'r\') as file: text = file.read() huffman_tree = build_huffman_tree(text) codebook = build_codes(huffman_tree) encoded_text = encode_text(text, codebook) padded_encoded_text = pad_encoded_text(encoded_text) byte_array = to_bytearray(padded_encoded_text) with open(encoded_filename, \'wb\') as file: pickle.dump((huffman_tree, byte_array), file) def remove_padding(padded_encoded_text): padded_info = padded_encoded_text[:8] extra_padding = int(padded_info, 2) encoded_text = padded_encoded_text[8:] encoded_text = encoded_text[:-extra_padding] return encoded_text def decode_text(encoded_text, tree): decoded_text = [] current_node = tree for bit in encoded_text: if bit == \'0\': current_node = current_node.left else: current_node = current_node.right if current_node.char is not None: decoded_text.append(current_node.char) current_node = tree return \'\'.join(decoded_text) def decode_file(encoded_filename: str, decoded_filename: str) -> None: with open(encoded_filename, \'rb\') as file: huffman_tree, byte_array = pickle.load(file) bit_string = \'\'.join(format(byte, \'08b\') for byte in byte_array) encoded_text = remove_padding(bit_string) decoded_text = decode_text(encoded_text, huffman_tree) with open(decoded_filename, \'w\') as file: file.write(decoded_text)"},{"question":"You are given the implementation of a BST Iterator that allows for in-order traversal of a binary search tree (BST). Your task is to extend this functionality by implementing the following additional methods: 1. **peek()**: This method should return the next element in the in-order traversal without advancing the iterator. 2. **is_empty()**: This method should return true if there are no more elements to be iterated, otherwise false. 3. **reset()**: This method should reset the iterator to the initial state as if it hasn\'t been used to traverse the tree yet. # Function Specifications 1. `peek() -> int`: * **Description**: Returns the next element in the in-order traversal without moving the iterator. * **Constraints**: Assumes that `has_next()` would return true before `peek()` is called. * **Output**: An integer representing the next element in in-order traversal. 2. `is_empty() -> bool`: * **Description**: Checks if there are no more elements left in the iterator. * **Output**: A boolean value indicating if the iterator is empty. 3. `reset() -> None`: * **Description**: Resets the state of the iterator to the beginning of the traversal. * **Output**: None. # Example Usage ```python Assume class BSTIterator is already defined as above. # Example to construct a binary search tree class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(7) iterator = BSTIterator(root) # Existing methods print(iterator.has_next()) # should return True print(iterator.next()) # should return 1 # New methods to implement print(iterator.peek()) # should return 2 print(iterator.is_empty()) # should return False iterator.reset() print(iterator.next()) # should return 1 ``` # Requirements * Your implementation must have efficient time complexity for all the new methods. * Ensure that your iterator still adheres to the constraints and characteristics of in-order traversal. * Handle edge cases such as an empty tree or single-node trees correctly.","solution":"# Definition of a simple TreeNode for BST class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Definition of the BSTIterator class class BSTIterator: def __init__(self, root: TreeNode): self.root = root self.stack = [] self._leftmost_inorder(root) self.initial_stack = list(self.stack) # Save initial state to support reset() def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements in the BSTIterator\\") topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val def peek(self) -> int: if not self.has_next(): raise StopIteration(\\"No more elements in the BSTIterator\\") topmost_node = self.stack[-1] return topmost_node.val def is_empty(self) -> bool: return not self.has_next() def reset(self) -> None: self.stack = list(self.initial_stack)"},{"question":"You are tasked with implementing efficient functions to compute the n-th Fibonacci number. This involves understanding and utilizing dynamic programming and iterative techniques for optimization. The scenarios assume all inputs are valid non-negative integers. **Part 1: Dynamic Programming** Write a function `fib_dp(n: int) -> int` that computes the n-th Fibonacci number using dynamic programming. This approach should store intermediate results in a list or array. **Part 2: Iterative Approach** Write a function `fib_iterative(n: int) -> int` that computes the n-th Fibonacci number using an iterative approach. This approach should use constant space for the calculations. # Input Format Each function should take a single integer `n` (0 ≤ n ≤ 10^6). # Output Format Both functions should return a single integer that is the n-th Fibonacci number. # Constraints * `0 ≤ n ≤ 10^6` * Your solution should be optimized for large values of n and run in O(n) time complexity. * Dynamic programming solutions should use O(n) space, whereas iterative solutions should use O(1) space. # Example Usage ```python print(fib_dp(10)) # Should output 55 print(fib_iterative(10)) # Should output 55 print(fib_dp(1000)) # Should output 43466557686937456435688527675040625802564660517371780402481729089536555417949 print(fib_iterative(1000)) # Should output 43466557686937456435688527675040625802564660517371780402481729089536555417949 ``` # Notes * Consider handling large values efficiently. * Ensure proper validation for the input constraints. * Expect solutions to be tested for performance accuracy.","solution":"def fib_dp(n: int) -> int: Computes the n-th Fibonacci number using dynamic programming. :param n: An integer index n where 0 <= n <= 10^6 :returns: The n-th Fibonacci number if n == 0: return 0 elif n == 1: return 1 fibs = [0] * (n + 1) fibs[0], fibs[1] = 0, 1 for i in range(2, n + 1): fibs[i] = fibs[i - 1] + fibs[i - 2] return fibs[n] def fib_iterative(n: int) -> int: Computes the n-th Fibonacci number using an iterative approach. :param n: An integer index n where 0 <= n <= 10^6 :returns: The n-th Fibonacci number if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Objective Implement a function to find the index of a target element in a sorted array using binary search. # Problem Statement You are given a sorted (in non-decreasing order) integer array `nums` and an integer `target`. Implement the function `binary_search(nums: List[int], target: int) -> int` to search for `target` in `nums`. If the target exists, return its index. Otherwise, return `-1`. # Function Signature ```python def binary_search(nums: List[int], target: int) -> int: ``` Input - `nums`: A list of integers sorted in non-decreasing order, where `1 <= len(nums) <= 10^4` and `-10^4 <= nums[i] <= 10^4`. - `target`: An integer `-10^4 <= target <= 10^4`. Output - The integer index of the target in the array, or `-1` if the target is not found. # Constraints - You must implement the function using binary search. - The algorithm should run in O(log n) time complexity. # Example ```python # Example 1 nums = [-1, 0, 3, 5, 9, 12] target = 9 print(binary_search(nums, target)) # Output: 4 # Example 2 nums = [-1, 0, 3, 5, 9, 12] target = 2 print(binary_search(nums, target)) # Output: -1 # Example 3 nums = [5] target = 5 print(binary_search(nums, target)) # Output: 0 ``` # Explanation In the first example, the array is `[-1, 0, 3, 5, 9, 12]` and the target is `9`. The algorithm should correctly identify that `9` is at index `4`. In the second example, the algorithm should return `-1` as `2` is not present in the array. In the third example, the array has only one element `5` which is the target, so the index `0` should be returned.","solution":"from typing import List def binary_search(nums: List[int], target: int) -> int: Uses binary search to find the index of the target element in a sorted array. Returns -1 if target does not exist in the array. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"You are tasked with implementing a function that increments a number represented as an array of its digits. The digits are stored in a big-endian format, meaning the most significant digit is at the start of the list. Your function should handle potential edge cases such as carries propogating through the entire number (`[9, 9, 9]` becoming `[1, 0, 0, 0]`). # Function Signature ```python def increment_number(digits: List[int]) -> List[int]: pass ``` # Input * A non-empty list of non-negative integers `digits` where each element is a digit (0-9). * The length of the array `digits` is at most 10^4. # Output * A list of integers representing the digits of the incremented number. # Constraints * No leading zeros will be present in the input list except for the number zero itself. * Do not use built-in methods to convert the entire list to an integer. # Example 1 ```python digits = [1, 2, 3] Incremented number = [1, 2, 4] ``` # Example 2 ```python digits = [4, 3, 2, 1] Incremented number = [4, 3, 2, 2] ``` # Example 3 ```python digits = [9, 9, 9] Incremented number = [1, 0, 0, 0] ``` # Explanation * For the input `[1, 2, 3]`, the digits represent the number 123 which becomes 124 when incremented. * For the input `[4, 3, 2, 1]`, the digits represent the number 4321 which becomes 4322 when incremented. * For the input `[9, 9, 9]`, the digits represent the number 999 which becomes 1000 when incremented.","solution":"from typing import List def increment_number(digits: List[int]) -> List[int]: Increments the number represented by the list of digits. Parameters: digits (List[int]): A list of digits representing a number in big-endian format. Returns: List[int]: A list of digits representing the incremented number. n = len(digits) # Start from the last digit for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we exit the loop, it means all digits were 9 return [1] + [0] * n"},{"question":"# FizzBuzz - Extended Version You are tasked with implementing a function to generate a modified FizzBuzz sequence. In this version, you need to replace the numbers based on multiple divisors and words provided as input. The function should be flexible to handle various combinations of divisor-word pairs. **Function Specifications**: * `def extended_fizzbuzz(n: int, replacements: List[Tuple[int, str]]) -> List[Union[int, str]]:` - **Input**: - `n` (int): The length of the sequence to generate (must be >= 1). - `replacements` (List[Tuple[int, str]]): A list of pairs where each pair consists of a divisor (int) and a word (str). - **Output**: - A list of length `n` with numbers replaced by words according to the given replacements. **Constraints**: * `n` will be at least 1. * Each divisor in `replacements` will be unique and at least 1. * The length of `replacements` will be at most 10. * The combined length of words in `replacements` will not exceed 100 characters. **Example**: ```python def extended_fizzbuzz(n, replacements): pass # Example print(extended_fizzbuzz(15, [(3, \'Fizz\'), (5, \'Buzz\')])) # Output: [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] print(extended_fizzbuzz(10, [(2, \'Two\'), (5, \'Five\')])) # Output: [1, \'Two\', 3, \'Two\', \'Five\', \'Two\', 7, \'Two\', 9, \'TwoFive\'] ``` **Implementation Notes**: * Iterate from 1 to `n`. * Replace numbers based on given divisor-word pairs. * Concatenate words if multiple conditions are met for any number. * Handle edge cases such as invalid inputs appropriately.","solution":"from typing import List, Tuple, Union def extended_fizzbuzz(n: int, replacements: List[Tuple[int, str]]) -> List[Union[int, str]]: Generates a modified FizzBuzz sequence based on given replacements. Args: n (int): The length of the sequence to generate. replacements (List[Tuple[int, str]]): A list of pairs where each pair consists of a divisor (int) and a word (str). Returns: List[Union[int, str]]: The FizzBuzz sequence containing integers and/or replacement words. result = [] for i in range(1, n + 1): word = \'\' for divisor, replacement in replacements: if i % divisor == 0: word += replacement if word: result.append(word) else: result.append(i) return result"},{"question":"# Closest Value in a Binary Search Tree **Problem Statement**: Given a non-empty Binary Search Tree (BST) and a target floating point value, write a function to find the value in the BST that is closest to the target value. **Function Signature**: ```python def closest_value(root, target): :type root: TreeNode :type target: float :rtype: int ``` **Input/Output**: - `root` (TreeNode): A non-empty BST. - `target` (float): A target value for which we need to find the closest value in the BST. - Returns (int): The value in the BST that is closest to the target. **Constraints**: - The given target value is a floating point number. - It is guaranteed that there will be only one unique value in the BST that is closest to the target. **Performance Requirements**: - The solution should efficiently handle large trees and should not exceed O(N) time complexity where N is the number of nodes in the tree. **Example**: Given the BST: ``` 4 / 2 5 / 1 3 ``` And the target value `3.714286`: Calling `closest_value(root, 3.714286)` should return `4`. # Scenario: Imagine you are working with a recommendation system that utilizes a large dataset of numerical values organized as a BST. For an incoming query with a specific value, you need to return the closest available value in the dataset to provide the most relevant recommendation. Implement the `closest_value` function that traverses the BST and efficiently finds the nearest value to the given target.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def closest_value(root, target): Finds the value in the BST that is closest to the target. :param root: TreeNode, the root of the BST. :param target: float, the target value. :return: int, the value in the BST that is closest to the target. closest = root.val while root: if abs(root.val - target) < abs(closest - target): closest = root.val if target < root.val: root = root.left else: root = root.right return closest"},{"question":"# Polynomial Arithmetic and String Representation You have been provided with the implementation of Monomial and Polynomial classes. Your task is to utilize these classes to perform various polynomial operations and generate a formatted string representation of the polynomials after performing these operations. Task: 1. Implement a function called `add_polynomials` that takes two polynomials (each represented as a list of tuples) and returns their sum. Each tuple consists of a dictionary representing the variables and an integer representing the coefficient. 2. Implement a function called `pretty_polynomial` that takes a polynomial (represented as a list of tuples) and returns a formatted string representation of that polynomial. Example: Given the polynomials: - Polynomial A: `[( {1: 1}, 2 ), ( {2: 3, 1: -1}, 3 ), ( {}, -2)]` - Polynomial B: `[( {1: 1}, 1 ), ( {2: 3, 1: -1}, -3 ), ( {}, 4)]` Polynomials are represented as: - Polynomial A: `2(a_1) + 3(a_1)**(-1)(a_2)**3 - 2` - Polynomial B: `(a_1) - 3(a_1)**(-1)(a_2)**3 + 4` Their sum is: - Polynomial A + B: `[( {1: 1}, 3 ), ( {}, 2)]` - Result: `3(a_1) + 2` For the `pretty_polynomial` function: - Input: `[( {1: 1}, 3 ), ( {}, 2)]` - Output: `\\"3(a_1) + 2\\"` # Function Signatures: ```python from typing import List, Dict, Tuple def add_polynomials(poly1: List[Tuple[Dict[int, int], int]], poly2: List[Tuple[Dict[int, int], int]]) -> List[Tuple[Dict[int, int], int]]: pass def pretty_polynomial(poly: List[Tuple[Dict[int, int], int]]) -> str: pass ``` Constraints: 1. There will be no zero coefficients in the input polynomials. 2. Both polynomials will be well-formed. 3. The variables in monomials will be greater than zero. # Note: - Use the implemented classes Monomial and Polynomial to handle internal operations where required. - Ensure to handle cases where resulting polynomial might have zero coefficients, they should not appear in the final string representation.","solution":"from typing import List, Dict, Tuple from collections import defaultdict def add_polynomials(poly1: List[Tuple[Dict[int, int], int]], poly2: List[Tuple[Dict[int, int], int]]) -> List[Tuple[Dict[int, int], int]]: # Create a dictionary to store the combined polynomial terms term_dict = defaultdict(int) # Add terms from the first polynomial for vars_dict, coeff in poly1: vars_tuple = tuple(sorted(vars_dict.items())) term_dict[vars_tuple] += coeff # Add terms from the second polynomial for vars_dict, coeff in poly2: vars_tuple = tuple(sorted(vars_dict.items())) term_dict[vars_tuple] += coeff # Form the result list filtering out zero coefficients result = [(dict(vars_tuple), coeff) for vars_tuple, coeff in term_dict.items() if coeff != 0] return result def pretty_polynomial(poly: List[Tuple[Dict[int, int], int]]) -> str: terms = [] for vars_dict, coeff in poly: # Coefficient part if coeff == 1: coeff_str = \\"\\" elif coeff == -1: coeff_str = \\"-\\" else: coeff_str = str(coeff) # Variables part var_parts = [] for var, exp in sorted(vars_dict.items()): if exp == 1: var_parts.append(f\\"a_{var}\\") else: var_parts.append(f\\"a_{var}**{exp}\\") if var_parts: term_str = f\\"{coeff_str}{\'\'.join(var_parts)}\\" else: term_str = coeff_str if coeff_str else \\"0\\" terms.append(term_str) # Join terms with plus sign result = \\" + \\".join(terms).replace(\\" + -\\", \\" - \\") return result if result else \\"0\\""},{"question":"You are given a singly linked list. Your task is to write a function `find_missing_number(head, n)` that identifies the missing number in a list of integers from 1 to n. The list should originally contain numbers from 1 to n, but one number is missing. **Input:** * `head`: The head node of the singly linked list containing the numbers from 1 to n with one number missing. * `n`: An integer representing the total number of elements that should be in the list (including the missing one). **Output:** * Return the missing number. **Constraints:** * 1 <= n <= 10^5 * The values in the list are integers from 1 to n with one missing. **Example:** ```python # Define the ListNode class for linked list construction class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Here\'s an example of constructing a linked list: # Suppose n = 5, and the numbers are [1, 2, 4, 5] missing number is 3 node4 = ListNode(5) node3 = ListNode(4, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) # Now `node1` is the head of the linked list def find_missing_number(head, n): # Implement the function here pass print(find_missing_number(node1, 5)) # Output should be 3 ``` # Notes: 1. Consider edge cases such as the smallest and largest possible inputs. 2. Aim for an efficient solution considering the constraints.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def find_missing_number(head, n): This function finds the missing number in the linked list of numbers from 1 to n. :param head: ListNode, the head node of the linked list :param n: int, the total number of numbers that should be in the list (including the missing one) :return: int, the missing number total_sum = n * (n + 1) // 2 # Sum of first n natural numbers current_sum = 0 current = head while current: current_sum += current.val current = current.next return total_sum - current_sum"},{"question":"# Question: Topological Sorting of a Directed Graph Given the provided representation of a Directed Graph through the `DirectedGraph`, `Node`, and `DirectedEdge` classes, implement a function to perform topological sorting of the nodes. Topological sorting is only applicable to Directed Acyclic Graphs (DAGs). If a cycle exists, your function should return an error message indicating that the graph contains a cycle. Function Signature ```python def topological_sort(graph: DirectedGraph) -> List[str]: ``` Input - `graph`: An instance of the `DirectedGraph` class. Output - A list of node names (`List[str]`) representing the nodes in topologically sorted order. - If a cycle is detected, return an error message: `\\"Graph contains a cycle\\"`. Constraints - The graph can have up to 1000 nodes (vertices). - The graph can have up to 5000 edges. Example ```python # Example 1 graph_dict_1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'D\'], \'D\': [] } graph_1 = DirectedGraph(graph_dict_1) print(topological_sort(graph_1)) # Possible output: [\'A\', \'C\', \'B\', \'D\'] # Example 2 (contains cycle) graph_dict_2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } graph_2 = DirectedGraph(graph_dict_2) print(topological_sort(graph_2)) # Output: \\"Graph contains a cycle\\" ``` Hints 1. To detect cycles, consider using a depth-first search (DFS). 2. Using a stack to store the topological order upon completing the DFS for each node can simplify the implementation.","solution":"from typing import List, Dict class DirectedGraph: def __init__(self, graph_dict: Dict[str, List[str]]): self.graph_dict = graph_dict def topological_sort(graph: DirectedGraph) -> List[str]: def dfs(node): if node in permanent_mark: return False if node in temporary_mark: return True temporary_mark.add(node) for neighbor in graph.graph_dict.get(node, []): if dfs(neighbor): return True temporary_mark.remove(node) permanent_mark.add(node) result.append(node) return False permanent_mark = set() temporary_mark = set() result = [] for node in graph.graph_dict: if node not in permanent_mark: if dfs(node): return \\"Graph contains a cycle\\" return result[::-1]"},{"question":"Scenario You are working as a software developer at a company that deals with real-time data analysis. One of the core operations your system performs is sorting data points for further processing. Due to memory constraints, you need to ensure that the sorting algorithm you use operates in-place. Task Given the context, the company allows for a suboptimal time complexity as long as memory usage is kept to a minimum. Thus, you\'d implement Selection Sort, noting its simplicity and in-place nature. Prompt Write a function `custom_selection_sort`, which sorts a list of integers in ascending order using the Selection Sort algorithm. The function signature is: ```python def custom_selection_sort(arr: list) -> list: ``` Function Description: - **Input**: A list `arr` of integers, where `1 <= len(arr) <= 500`. - **Output**: Returns a new list of integers sorted in ascending order. Make sure to: - Handle edge cases, such as an empty list or lists with duplicate values. - Ensure that the function runs within reasonable time limits given the constraints. Examples ```python assert custom_selection_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert custom_selection_sort([5, 3, 4, 2, 1]) == [1, 2, 3, 4, 5] assert custom_selection_sort([]) == [] assert custom_selection_sort([4, 4, 4, 4]) == [4, 4, 4, 4] ``` **Note**: Ensure your implementation is efficient and correct. Consider edge cases, and do not use built-in sorting functions.","solution":"def custom_selection_sort(arr: list) -> list: Sorts a list of integers in ascending order using the Selection Sort algorithm. n = len(arr) for i in range(n): # Find the minimum element in remaining unsorted array min_index = i for j in range(i+1, n): if arr[j] < arr[min_index]: min_index = j # Swap the found minimum element with the first element arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"# Scenario You are a software engineer tasked with ensuring that a new system\'s process scheduling does not encounter deadlocks due to resource-lock cycles. You are given the dependency graph of processes and need to determine if any cycles exist. # Task Write a function `detect_cycle(graph: Dict[str, List[str]]) -> bool` that takes a directed graph (represented as an adjacency list) and returns `True` if there is at least one cycle, otherwise `False`. # Input * A dictionary `graph` where keys are process names (strings), and values are lists of process names (strings) that the key process depends on. # Output * A boolean value indicating whether the graph contains a cycle (`True`) or not (`False`). # Constraints * The process names are unique. * The graph can contain up to 1000 processes and 5000 dependencies. # Function Signature ```python def detect_cycle(graph: Dict[str, List[str]]) -> bool: ``` # Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(detect_cycle(graph)) # Output: True ``` # Explanation In the given example: - There is a cycle: B -> D -> E -> B. # Hints 1. Use depth-first search (DFS) and keep track of traversal states (white, gray, black) for each process. 2. If you encounter a gray node during DFS, a cycle is detected.","solution":"def detect_cycle(graph): Detect if a cycle exists in the graph. Args: graph (dict): A dictionary representing the graph where keys are nodes and values are lists of nodes that the key node has edges to. Returns: bool: True if a cycle is detected, False otherwise. # States: 0 = unvisited, 1 = visiting, 2 = visited state = {node: 0 for node in graph} def dfs(node): if state[node] == 1: # Currently visiting this node, so we found a cycle return True if state[node] == 2: # Already visited this node, no cycle from here return False state[node] = 1 # Mark the node as visiting for neighbour in graph[node]: if dfs(neighbour): return True state[node] = 2 # Mark the node as visited return False for node in graph: if state[node] == 0: # Unvisited node if dfs(node): return True return False"},{"question":"# Coding Challenge: Summarize Continuous Ranges Given a sorted list of unique integers, write a function `summarize_ranges` that condenses the list into a summary of continuous ranges. If a single number or non-continuous number appears, it should be included as itself. Input: - A list of sorted integers without duplicates. Output: - A list of strings representing the summarized ranges. Example: For the input `[0, 1, 2, 4, 5, 7]`, the output should be `[\\"0-2\\", \\"4-5\\", \\"7\\"]`. Provide a solution that correctly handles the following edge cases: - A single-element list, like `[5]`. - Lists that have no continuous ranges, like `[3, 6, 9]`. - Lists where all elements form one range, like `[1, 2, 3, 4, 5]`. Constraints: - All elements in the input list are unique. - The input list is sorted in ascending order. - The input list has at least one element. ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: # Your implementation here pass # Example usage: # print(summarize_ranges([0, 1, 2, 4, 5, 7])) # Expected: [\\"0-2\\", \\"4-5\\", \\"7\\"] ``` Your task is to implement the `summarize_ranges` function ensuring it handles all mentioned edge cases effectively.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] summary = [] start = array[0] for i in range(1, len(array)): if array[i] != array[i-1] + 1: end = array[i-1] if start == end: summary.append(f\\"{start}\\") else: summary.append(f\\"{start}-{end}\\") start = array[i] # Add the last range if start == array[-1]: summary.append(f\\"{start}\\") else: summary.append(f\\"{start}-{array[-1]}\\") return summary"},{"question":"# Integer Decomposition Using Dynamic Programming You are provided with an integer `n` and need to determine the number of ways to decompose it into sums of positive integers. You are required to implement the function `number_of_partitions(n)` which computes the number of decompositions of the integer `n`. Input - An integer `n` (1 ≤ n ≤ 1000). Output - An integer representing the number of ways to decompose `n`. Function Signature ```python def number_of_partitions(n: int) -> int: ``` Constraints - The function must handle all inputs within the given range efficiently. - You must use a Dynamic Programming approach to solve the problem. Example ```python print(number_of_partitions(4)) # Output: 5 # Explanation: # 4 can be decomposed as: # 4 # 3 + 1 # 2 + 2 # 2 + 1 + 1 # 1 + 1 + 1 + 1 print(number_of_partitions(7)) # Output: 15 # Explanation: # 7 can be decomposed as: # 7 # 6 + 1 # 5 + 2 # 5 + 1 + 1 # 4 + 3 # 4 + 2 + 1 # 4 + 1 + 1 + 1 # 3 + 3 + 1 # 3 + 2 + 2 # 3 + 2 + 1 + 1 # 3 + 1 + 1 + 1 + 1 # 2 + 2 + 2 + 1 # 2 + 2 + 1 + 1 + 1 # 2 + 1 + 1 + 1 + 1 + 1 # 1 + 1 + 1 + 1 + 1 + 1 + 1 ``` Implement the function `number_of_partitions(n)` such that it returns the correct number of decompositions for a given integer `n` using dynamic programming.","solution":"def number_of_partitions(n: int) -> int: Returns the number of ways to decompose a number n into sums of positive integers. # Create a list to store the number of ways to partition each number from 0 to n # We need n+1 entries because we include 0 in the list dp = [0] * (n + 1) # There is exactly one way to partition 0, which is not to partition at all dp[0] = 1 # Iterate over each number from 1 to n for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n]"},{"question":"Context You are tasked with enhancing the efficiency of a Krishnamurthy number detection algorithm. The initial implementation calculates the factorial of each digit repeatedly, which can be optimized. Problem Statement Write a function `optimized_krishnamurthy_number(n)` that determines whether a given number `n` is a Krishnamurthy number in a more efficient manner. The function should precompute the factorial values of digits from 0 to 9 to avoid redundant calculations. Function Signature ```python def optimized_krishnamurthy_number(n: int) -> bool: pass ``` Input - **n (int)**: A non-negative integer to be checked (0 <= n <= 10^7). Output - **(bool)**: Returns `True` if `n` is a Krishnamurthy number, otherwise returns `False`. Constraints - The function must handle edge case where n = 0. - Avoid recomputing the factorial for the same digit multiple times. - Ensure the implementation is as efficient as possible. Example ```python assert optimized_krishnamurthy_number(145) == True assert optimized_krishnamurthy_number(40585) == True assert optimized_krishnamurthy_number(357) == False ``` Hint You might want to use a list to store precomputed factorial values for digits 0 through 9.","solution":"def optimized_krishnamurthy_number(n: int) -> bool: Determines whether a given number n is a Krishnamurthy number. # Precompute factorials for digits 0 to 9 factorial = [1] * 10 for i in range(2, 10): factorial[i] = factorial[i - 1] * i def sum_of_digit_factorials(num): total = 0 while num > 0: digit = num % 10 total += factorial[digit] num //= 10 return total return sum_of_digit_factorials(n) == n"},{"question":"# Matrix Rotation Challenge Context You are working as a software engineer at a company that specializes in image processing. One of the common operations in image transformation is rotating an image represented as a pixel matrix. You are tasked with implementing a function to rotate a square image (n x n matrix) by 90 degrees clockwise. Task Write a function `rotate(mat)` to rotate an n x n 2D matrix by 90 degrees clockwise in-place. Input - `mat` (2D list of integers): An n x n matrix representing the image. Output - The function should modify the input matrix in-place to achieve the rotation. Constraints - The matrix `mat` will always be square (n x n) where 1 <= n <= 1000. Examples 1. For the matrix: ``` [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Your function should modify it to: ``` [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` 2. For the matrix: ``` [ [1] ] ``` Your function should leave it unchanged: ``` [ [1] ] ``` Implementation Guidelines 1. You need to reverse the matrix vertically. 2. Then transpose the matrix by swapping elements across the main diagonal. Edge Cases 1. Ensure your function works for an empty matrix. 2. Handle small-sized matrices gracefully (e.g., 1x1).","solution":"def rotate(mat): Rotate the given n x n 2D matrix by 90 degrees clockwise in-place. n = len(mat) # Reverse the matrix vertically mat.reverse() # Transpose the matrix by swapping elements across the main diagonal for i in range(n): for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j]"},{"question":"# Assessing Linked List Implementation Skills Given the provided snippets that define nodes for both singly and doubly linked lists, your task is to implement a **doubly linked list** with efficient insertion, deletion, and traversal operations. Your implementation should handle edge cases gracefully. Detailed Requirements: 1. **Class Definitions**: - Implement a class `DoublyLinkedList` with the following methods: - **`insert_at_head(value)`**: Inserts a new node with the given value at the head of the list. - **`insert_at_tail(value)`**: Inserts a new node with the given value at the tail of the list. - **`delete_node(value)`**: Deletes the first node found with the specified value. - **`traverse()`**: Returns a list of node values in forward order. - **`traverse_backward()`**: Returns a list of node values in backward order. 2. **Function Specifications**: - **input**: - `insert_at_head(value)` and `insert_at_tail(value)` will take an integer value. - `delete_node(value)` will take an integer value. - **output**: - `traverse()` and `traverse_backward()` should return a list of integers representing the node values. 3. **Constraints**: - Your methods should handle the case where the list is initially empty. - Deletion attempts for non-existent values should result in no operation, not errors. - Ensure memory is managed correctly to avoid leaks (consider possible enhancements with garbage collection if working in an unmanaged language). Example Scenario: ```python dll = DoublyLinkedList() dll.insert_at_head(1) dll.insert_at_tail(2) dll.insert_at_head(0) print(dll.traverse()) # Output: [0, 1, 2] print(dll.traverse_backward()) # Output: [2, 1, 0] dll.delete_node(1) print(dll.traverse()) # Output: [0, 2] ``` Implement the `DoublyLinkedList` class according to the above specifications. Make sure your solution is efficient and handles all edge cases.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def traverse(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def traverse_backward(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"# Word Search Data Structure You are tasked with implementing a data structure that supports adding words and searching them efficiently. You need to create two classes, one using a Trie and the other using a Hashmap-based list. Both classes should implement the following methods: 1. `add_word(word: str) -> None`: Adds a word to the data structure. 2. `search(word: str) -> bool`: Searches for a word in the data structure, where `.` can denote any character. **Input:** - `word`: A string of lowercase alphabets and possibly containing \\".\\" only for the `search` method. **Output:** - Returns `True` if the word exists in the data structure, otherwise `False`. **Constraints:** - `1 <= word.length <= 100` - All words are composed of lowercase English letters. **Example Usage:** ``` wordDict = WordDictionary() wordDict.add_word(\\"bad\\") wordDict.add_word(\\"dad\\") wordDict.add_word(\\"mad\\") print(wordDict.search(\\"pad\\")) # Output: False print(wordDict.search(\\"bad\\")) # Output: True print(wordDict.search(\\".ad\\")) # Output: True print(wordDict.search(\\"b..\\")) # Output: True wordDict2 = WordDictionary2() wordDict2.add_word(\\"bad\\") wordDict2.add_word(\\"dad\\") wordDict2.add_word(\\"mad\\") print(wordDict2.search(\\"pad\\")) # Output: False print(wordDict2.search(\\"bad\\")) # Output: True print(wordDict2.search(\\".ad\\")) # Output: True print(wordDict2.search(\\"b..\\")) # Output: True ``` Implement the classes `WordDictionary` (Trie-based) and `WordDictionary2` (Dictionary-based) with the specified methods. **Guidelines:** 1. Ensure your `search` function efficiently handles the wildcard character \\".\\". 2. Consider edge cases such as an empty string or repetitive characters. 3. Optimize for performance to handle up to 1000 words with searches containing multiple wildcards.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root) class WordDictionary2: def __init__(self): self.word_map = {} def add_word(self, word: str) -> None: length = len(word) if length not in self.word_map: self.word_map[length] = [] self.word_map[length].append(word) def search(self, word: str) -> bool: length = len(word) if length not in self.word_map: return False for candidate in self.word_map[length]: match = True for i in range(length): if word[i] != \'.\' and word[i] != candidate[i]: match = False break if match: return True return False"},{"question":"**Check Path in Directed Graph** Given a directed graph, implement a function `is_path_exist` to determine if there is a path from a source vertex to a target vertex. # Function Signature ```python def is_path_exist(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: pass ``` # Input - `vertex_count` (int): Number of vertices in the graph, [1 <= vertex_count <= 10^3]. - `edges` (List[Tuple[int, int]]): List of directed edges in the graph where each edge is represented as a tuple (source, target) with 1 <= len(edges) <= 10^4. - `source` (int): Source vertex. - `target` (int): Target vertex. # Output - Returns `True` if there is a path from `source` to `target`. - Returns `False` otherwise. # Constraints - Vertices are indexed from 0 to `vertex_count-1`. # Example Input: ```python vertex_count = 5 edges = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3), (3, 4)] source = 1 target = 4 ``` Output: ```python True ``` # Note 1. The edges list represents a series of directed links between vertices. 2. You must use DFS to solve this problem. 3. Take care to avoid incorrect handling of cycles and revisited nodes.","solution":"from typing import List, Tuple def is_path_exist(vertex_count: int, edges: List[Tuple[int, int]], source: int, target: int) -> bool: Determines if there is a path from source vertex to target vertex in a directed graph :param vertex_count: Number of vertices in the graph :param edges: List of directed edges in the graph :param source: Source vertex :param target: Target vertex :return: True if path exists, False otherwise # Create a graph in the form of an adjacency list graph = {i: [] for i in range(vertex_count)} for u, v in edges: graph[u].append(v) # Use a set to track visited nodes to avoid cycles and infinite loops visited = set() def dfs(v): if v == target: return True visited.add(v) for neighbor in graph[v]: if neighbor not in visited: if dfs(neighbor): return True return False return dfs(source)"},{"question":"# Question: Permutations of a List Given a list of distinct integers, write a function that returns all possible permutations of the list. However, this time you need to implement it using a recursive approach without using any auxiliary space other than the recursion stack. # Input - A list of distinct integers (1 <= len(list) <= 10). # Output - A list containing all the permutations of the input list. # Constraints - The input list contains only distinct integers. - The function should efficiently handle lists up to length 10. - No auxiliary data structures like arrays or lists should be used outside of the recursion stack. # Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: pass ``` # Example **Input**: `[1, 2, 3]` **Output**: ``` [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` # Explanation In the given example, the function should generate all the permutations of the list `[1, 2, 3]`, which includes every possible arrangement of these three integers.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Returns all possible permutations of a list of distinct integers. def permute(current, remaining): if not remaining: result.append(current) return for i in range(len(remaining)): permute(current + [remaining[i]], remaining[:i] + remaining[i + 1:]) result = [] permute([], nums) return result"},{"question":"You have been tasked with enhancing the performance of the Shell Sort algorithm by adjusting the gap sequence. Provide an optimized implementation of Shell Sort using the Hibbard\'s gap sequence. # Requirements 1. **Function Signature**: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` 2. **Input**: * A list of integers, `arr` (0 <= len(arr) <= 10^5) 3. **Output**: * A sorted list of integers. # Example ```python print(optimized_shell_sort([12, 34, 54, 2, 3])) # Output: [2, 3, 12, 34, 54] print(optimized_shell_sort([7, -5, 3, 9, 1, 0])) # Output: [-5, 0, 1, 3, 7, 9] ``` # Constraints * Avoid using built-in sort functions. * Expect that all elements are within the range of -10^6 to 10^6. * The solution should work efficiently for up to 100,000 elements. # Notes Hibbard\'s gap sequence is defined as: 1, 3, 7, 15, ..., which can be represented as 2^k - 1 for k = 1, 2, 3, ... # Implementation Details 1. Generate the gap sequence using Hibbard’s method up to the size of the array. 2. Apply the Shell Sort method using these gaps. 3. Ensure that your algorithm is handling edge cases effectively, such as empty arrays or arrays with one element.","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Shell sort algorithm using Hibbard\'s gap sequence. n = len(arr) if n == 0: return arr # Generate Hibbard\'s gap sequence: 1, 3, 7, 15, ..., 2^k - 1 gaps = [] k = 1 while (gap := (1 << k) - 1) < n: # same as 2^k - 1 gaps.append(gap) k += 1 gaps = gaps[::-1] # reverse to start with the largest gap # Shell Sort using the generated gap sequence for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Anagram Checker Objective: Write a function `optimized_is_anagram` to determine if one string is an anagram of another. This challenge will test your ability to solve fundamental string manipulation problems efficiently, considering space and time complexity. Input/Output Format: - **Input**: - Two strings `s` and `t`, consisting of lowercase alphabets. - **Output**: - `True` if `t` is an anagram of `s`; `False` otherwise. Constraints: - The strings will contain only lowercase alphabets. - Both strings will have lengths between 1 and 100,000. Performance Requirements: - Aim for linear time complexity, O(n), where n is the length of the strings. - Aim for linear space complexity, O(n). Function Signature: ```python def optimized_is_anagram(s: str, t: str) -> bool: pass ``` Example: 1. **Input**: `s = \\"anagram\\", t = \\"nagaram\\"` **Output**: `True` 2. **Input**: `s = \\"rat\\", t = \\"car\\"` **Output**: `False` # Scenario: Imagine working on text-processing software that needs to determine whether two entries are permutations of one another. This could be used in applications from spell-checking to pattern recognition. To identify the relationship between these two pieces of text, implement the function that checks if one string can be rearranged to form the other. Note: Consider edge cases such as strings of different lengths and identical strings. Optimize for both speed and memory efficiency.","solution":"def optimized_is_anagram(s: str, t: str) -> bool: Determines if string t is an anagram of string s. if len(s) != len(t): return False # Initialize an array to count occurrences of each character char_counts = [0] * 26 # There are 26 possible characters (all lowercase letters) # Count characters in s for char in s: char_counts[ord(char) - ord(\'a\')] += 1 # Decrease count for characters in t for char in t: char_counts[ord(char) - ord(\'a\')] -= 1 # If all counts are zero, then t is an anagram of s return all(count == 0 for count in char_counts)"},{"question":"# Question Scenario: You are tasked with developing a feature in a text processing application that assists users in identifying the minimum number of deletions required to make two given strings identical. This feature is crucial for optimizing text comparison and deduplication processes, significantly improving performance and accuracy. Problem: Given two strings, `word1` and `word2`, write a function `min_deletions_to_make_identical` that computes the minimum number of steps required to make the two strings identical by only deleting characters. Function Signature: ```python def min_deletions_to_make_identical(word1: str, word2: str) -> int: ``` Input: - `word1`: A string consisting of lowercase English letters (1 <= len(word1) <= 1000) - `word2`: A string consisting of lowercase English letters (1 <= len(word2) <= 1000) Output: - Returns an integer representing the minimum number of deletions required. Constraints: - Both strings only contain lowercase English letters. - Strings can be of different lengths. - Optimal solution in terms of time and space complexity is preferred. Example: 1. Input: ```python word1 = \\"sea\\" word2 = \\"eat\\" ``` Output: ```python 2 ``` Explanation: \\"sea\\" becomes \\"ea\\" (1 deletion), \\"eat\\" becomes \\"ea\\" (1 deletion), total deletions = 2. 2. Input: ```python word1 = \\"leetcode\\" word2 = \\"etco\\" ``` Output: ```python 4 ``` Explanation: The longest common subsequence is \\"etco\\". - Deletions needed for \\"leetcode\\" to become \\"etco\\" = 4 (\\"le\\", \\"d\\", \\"e\\", \\"e\\"). - Deletions needed for \\"etco\\" to stay as \\"etco\\" = 0. Performance Requirements: - Expected time complexity: O(len(word1) * len(word2)) - Expected space complexity: O(len(word1) * len(word2)) Implement the function `min_deletions_to_make_identical` that meets the requirements above.","solution":"def min_deletions_to_make_identical(word1: str, word2: str) -> int: Computes the minimum number of deletions required to make two strings identical. m, n = len(word1), len(word2) # Create a DP table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp table for i in range(1, m + 1): for j in range(1, n + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Length of longest common subsequence lcs_length = dp[m][n] # Number of deletions needed to make the strings identical return (m - lcs_length) + (n - lcs_length)"},{"question":"# Two Sum - Coding Challenge You are given an array of integers `nums` and an integer `target`. Write a function `find_two_sum` that returns a tuple of two indices `(i, j)` such that `nums[i] + nums[j] == target`. You can assume that there will always be one unique solution, and you may not use the same element twice. * **Input Format**: * `nums` - List of integers. * `target` - An integer representing the sum target. * **Output Format**: * A tuple of two indices `(i, j)` where `i and j` are distinct and `nums[i] + nums[j] == target`. * **Constraints**: * Length of `nums` will be at most `10^4`. * Elements of `nums` will be integers within the range `[-10^9, 10^9]`. * **Example**: ```python nums = [2, 7, 11, 15] target = 9 # Because nums[0] + nums[1] = 2 + 7 = 9 # Output: (0, 1) nums = [3, 2, 4] target = 6 # Because nums[1] + nums[2] = 2 + 4 = 6 # Output: (1, 2) ``` * **Performance Requirements**: * Solution must run in O(n) time and use O(n) additional space. **To Implement**: ```python def find_two_sum(nums, target): dic = {} for i, num in enumerate(nums): if num in dic: return dic[num], i dic[target - num] = i return None ``` Ensure your solution handles edge cases and performs efficiently for large inputs.","solution":"def find_two_sum(nums, target): Finds two indices such that the elements at those indices add up to the target. Args: nums (list): List of integers. target (int): Target sum. Returns: tuple: A tuple of two indices. dic = {} for i, num in enumerate(nums): if num in dic: return dic[num], i dic[target - num] = i return None"},{"question":"# Flatten Multi-dimensional Arrays Problem Statement You are given an array that may contain nested arrays. Your task is to write a function that produces a single resultant array where all nested arrays are flattened into a single-level array. Additionally, you will also write a generator function that produces the flattened elements one by one. # Function Signatures: ```python def flatten(input_arr: list) -> list: pass def flatten_iter(input_arr: list): pass ``` # Input: - `input_arr`: A list that can contain nested lists of arbitrary depth. # Output: - The `flatten` function should return a single-level list containing all elements of the nested lists in their original order. - The `flatten_iter` function should return an iterator that yields each element of the nested lists one by one in their original order. # Constraints: - The input array can be of arbitrary depth. - Elements inside the array can be of any data type. # Examples: ```python # Example 1: assert flatten([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert list(flatten_iter([1, [2, [3, 4], 5], 6])) == [1, 2, 3, 4, 5, 6] # Example 2: assert flatten([[], [1], [2, [[], 3]], 4]) == [1, 2, 3, 4] assert list(flatten_iter([[], [1], [2, [[], 3]], 4])) == [1, 2, 3, 4] # Example 3: assert flatten([]) == [] assert list(flatten_iter([])) == [] ``` # Guidelines: 1. **Handling Strings**: Ensure that strings are not treated as iterables for further flattening. 2. **Deeply Nested Structures**: The solution must handle deeply nested structures efficiently without causing a stack overflow. 3. **Iterative Approach**: Explore using an iterative approach for the generator function to yield elements one by one.","solution":"def flatten(input_arr: list) -> list: Returns a single-level list containing all elements of the nested lists in their original order. result = [] for item in input_arr: if isinstance(item, list): result.extend(flatten(item)) # Recursively flatten the nested list else: result.append(item) return result def flatten_iter(input_arr: list): Yields each element of the nested lists one by one in their original order. for item in input_arr: if isinstance(item, list): yield from flatten_iter(item) # Recursively yield elements of the nested list else: yield item"},{"question":"# Question: Implementing a Doubly Linked List with Additional Features Given the class `DoublyLinkedListNode`, implement a class `DoublyLinkedList` that supports the following operations: 1. `append(value)`: Adds a node with the specified `value` at the end of the list. 2. `prepend(value)`: Adds a node with the specified `value` at the beginning of the list. 3. `insert(index, value)`: Inserts a node with the specified `value` at the given `index` (0-based). If the `index` is out of bounds, it should throw an appropriate error. 4. `find(value)`: Returns the index of the first node with the specified `value`. If the value is not found, return -1. 5. `delete(index)`: Deletes the node at the specified `index`. If the `index` is out of bounds, it should throw an appropriate error. Expected Input and Output Formats * **append(value)**: - **Input**: `value` (integer or string) - **Output**: None * **prepend(value)**: - **Input**: `value` (integer or string) - **Output**: None * **insert(index, value)**: - **Input**: `index` (integer), `value` (integer or string) - **Output**: None * **find(value)**: - **Input**: `value` (integer or string) - **Output**: `index` (integer) * **delete(index)**: - **Input**: `index` (integer) - **Output**: None Constraints * Assume the values in the linked list are unique. * Handle edge cases like empty list, adding at boundary indices, and removing from boundary indices. * Consider performance efficiency and strive to maintain efficient operations. Example: ```python dll = DoublyLinkedList() dll.append(10) dll.append(20) print(dll.find(10)) # Output: 0 print(dll.find(20)) # Output: 1 dll.prepend(5) dll.insert(1, 15) dll.delete(2) print(dll.find(20)) # Output: 2 print(dll.find(15)) # Output: 1 ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def append(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: self.head.prev = new_node new_node.next = self.head self.head = new_node def insert(self, index, value): if index < 0: raise IndexError(\\"Index out of bounds\\") new_node = DoublyLinkedListNode(value) if index == 0: self.prepend(value) return current = self.head for _ in range(index - 1): if current is None: raise IndexError(\\"Index out of bounds\\") current = current.next if current.next is None: self.append(value) else: new_node.next = current.next new_node.prev = current current.next.prev = new_node current.next = new_node def find(self, value): current = self.head index = 0 while current: if current.value == value: return index current = current.next index += 1 return -1 def delete(self, index): if index < 0 or not self.head: raise IndexError(\\"Index out of bounds\\") current = self.head if index == 0: self.head = current.next if self.head: self.head.prev = None if current == self.tail: self.tail = None return for _ in range(index): if current is None: raise IndexError(\\"Index out of bounds\\") current = current.next if current is self.tail: self.tail = current.prev self.tail.next = None else: current.prev.next = current.next current.next.prev = current.prev"},{"question":"Path Existence in a Directed Graph Using DFS **Scenario**: You are given a social network modeled as a directed graph where each user is represented as a node, and a directed edge represents a \\"follow\\" relationship. Your task is to determine if a message can be propagated from one user (source) to another user (target). **Task**: Write a function `is_reachable` in the `Graph` class that determines if there is a directed path from a given source node to a target node using Depth First Search (DFS). **Function Signature**: ```python def is_reachable(self, source: int, target: int) -> bool: ``` **Input**: * An integer `source` representing the starting node. * An integer `target` representing the destination node. **Output**: * Return a boolean `True` if there is a path from `source` to `target`. Otherwise, return `False`. **Constraints**: * The graph can have at most `10,000` nodes. * The graph is directed, meaning each edge has a direction. * Multiple edges from one node to another or self-loops might be present. **Example**: ```python graph = Graph(4) graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) assert graph.is_reachable(1, 3) == True assert graph.is_reachable(3, 1) == False ``` **Notes**: * Implement the function such that it leverages Depth First Search to find the path. * Consider edge cases such as source equals target, disconnected nodes, or graphs with no edges.","solution":"class Graph: def __init__(self, nodes): self.graph = {i: [] for i in range(nodes)} def add_edge(self, u, v): self.graph[u].append(v) def is_reachable(self, source: int, target: int) -> bool: visited = set() return self._dfs(source, target, visited) def _dfs(self, current, target, visited): if current == target: return True visited.add(current) for neighbor in self.graph[current]: if neighbor not in visited: if self._dfs(neighbor, target, visited): return True return False"},{"question":"1-Sparse Recovery Algorithm You\'re tasked with implementing a function that verifies if a given stream of integer tuples, each comprising a number and a sign (+ or -), is 1-sparse. The stream is considered 1-sparse if the summation of elements cancels out to yield only a single unique number. Your function will receive a list of tuples and must return this unique number if the stream is 1-sparse. Otherwise, it should return `None`. **Function Signature:** ```python def one_sparse(array: List[Tuple[int, str]]) -> Union[int, None]: pass ``` Parameters: * `array` (List[Tuple[int, str]]): A list where each element is a tuple. The first value of the tuple is a non-negative integer and the second value is a string either \'+\' or \'-\'. Returns: * `int`: The unique number if the stream is 1-sparse. * `None`: If the stream is not 1-sparse. Constraints: * The integers in the tuples are non-negative and fit in 32-bit representation. * The sign will always be either \'+\' or \'-\'. * The stream will have at least one tuple. Example: ```python # Example 1 array1 = [(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')] print(one_sparse(array1)) # Output: 4 # Example 2 array2 = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')] print(one_sparse(array2)) # Output: 2 # Example 3 array3 = [(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')] print(one_sparse(array3)) # Output: None ``` Explanation: 1. For array1, the numbers 2 and 3 cancel out perfectly, leaving 4 as the unique element. 2. For array2, only the number 2 is present throughout all operations. 3. For array3, the sum cannot reduce to a single unique number, hence it is not 1-sparse. You must handle edge cases such as complete cancellation of all elements resulting in no unique number or incorrect handling of sign operations. Note: Do not use any predefined libraries for bitwise operations or summation that lead to circumventing essential algorithmic steps.","solution":"def one_sparse(array): count_map = {} for number, sign in array: if sign == \'+\': count_map[number] = count_map.get(number, 0) + 1 elif sign == \'-\': count_map[number] = count_map.get(number, 0) - 1 unique_elements = [key for key, value in count_map.items() if value != 0] if len(unique_elements) == 1: return unique_elements[0] else: return None"},{"question":"You have been hired to create a resource allocation system to help companies maximize their profit given a set of resources, each defined by a profit value and a weight (which could indicate cost, resource usage, etc.). Your task is to write a function that determines the maximum profit achievable with the given resource constraints. **Function Specification**: ```python def maximize_profit(items, capacity): Given a list of items, each with a profit and weight, and a maximum capacity, return the maximum profit that can be obtained by selecting a subset of items fitting into the capacity. :param items: List[Tuple[int, int]] - a list of tuples, each representing an item with profit and weight. :param capacity: int - the maximum capacity (weight) that can be accommodated. :return: int - the maximum profit achievable. pass ``` **Input**: * `items`: a list of tuples where each tuple contains two integers. The first integer is the profit of the item and the second integer is the weight of the item (1 ≤ weight ≤ 1000, 0 ≤ profit ≤ 10^5). * `capacity`: an integer representing the maximum weight that can be accommodated (1 ≤ capacity ≤ 1000). **Output**: * Return a single integer representing the maximum profit that can be obtained without exceeding the given capacity. **Example**: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(maximize_profit(items, capacity)) # Output: 80 (items with profits 50 and 30) ``` **Constraints**: * You must use dynamic programming to solve this problem. * The function should handle the edge cases described in the analysis above. You must ensure that your implementation is efficient and can handle the upper limits of the input sizes within reasonable time constraints.","solution":"def maximize_profit(items, capacity): Given a list of items, each with a profit and weight, and a maximum capacity, return the maximum profit that can be obtained by selecting a subset of items fitting into the capacity. :param items: List[Tuple[int, int]] - a list of tuples, each representing an item with profit and weight. :param capacity: int - the maximum capacity (weight) that can be accommodated. :return: int - the maximum profit achievable. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): profit = items[i - 1][0] weight = items[i - 1][1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + profit) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"Context: You are developing a feature for a custom search engine that needs to output all possible combinations of search filters. Each filter can either be applied or not applied, thus generating all possible combinations of the filters. You need to implement a function to generate these combinations. Task: Write a function `generate_subsets` that generates all possible subsets (combinations of elements) from a given list of unique integers. Function Signature: ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: pass ``` Input: - `nums`: A list of distinct integers `[a1, a2, ..., an]` (0 <= n <= 10). Output: - A set of tuples, each tuple representing a unique subset of the input list. Constraints: - The input list will have distinct integers. - You must return the unique subsets as a set of tuples. - The order within a subset does not matter, but each subset should be represented as a tuple. Example: ```python Example 1: Input: nums = [1, 2, 3] Output: {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} Example 2: Input: nums = [] Output: {()} ``` Notes: - Use bit manipulation to generate the subsets for the input list. - Ensure your solution works efficiently within the given constraints.","solution":"from typing import List, Set, Tuple from itertools import chain, combinations def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Generates all possible subsets (combinations of elements) from a given list of unique integers. # Generate all possible combinations of the input list res = set(chain.from_iterable(combinations(nums, r) for r in range(len(nums) + 1))) return res"},{"question":"Problem Description Implement a **QueueScheduler** class that uses a modified priority queue to manage tasks based on their priorities as provided in the code snippet above. This queue should support dynamic updates of task priorities and provide an efficient way to execute and remove the highest priority task. Requirements 1. **Initialize QueueScheduler**: The class should initialize an empty priority queue. 2. **Add Task**: Add a task to the queue with a given priority. 3. **Execute Task**: Remove and return the task with the highest priority (highest number). 4. **Update Task Priority**: Update the priority of an existing task in the queue without adding a new task. 5. The class should handle error scenarios such as attempting to execute a task from an empty queue. Expected Function Signatures ```python class QueueScheduler: def __init__(self): # Initializes an empty priority queue. pass def add_task(self, task: str, priority: int) -> None: # Adds a new task with the given priority to the queue. pass def execute_task(self) -> str: # Removes and returns the task with the highest priority. # Raises an exception if the queue is empty. pass def update_task_priority(self, task: str, new_priority: int) -> None: # Updates the priority of an existing task. # If the task does not exist, raises an exception. pass ``` Input and Output Format 1. `add_task(task: str, priority: int) -> None` * **Input**: `task` (string) - name of the task `priority` (int) - priority of the task * **Output**: None 2. `execute_task() -> str` * **Input**: No input * **Output**: `task` (string) - name of the removed task 3. `update_task_priority(task: str, new_priority: int) -> None` * **Input**: `task` (string) - name of the task `new_priority` (int) - new priority for the task * **Output**: None Constraints 1. The priority is represented by an integer, where a higher number indicates a higher priority. 2. There should not be duplicate tasks in the queue. 3. The number of tasks in the queue should not exceed 10^4. Ensure your implementation handles edge cases such as: - Adding tasks with the same priority. - Executing a task when the queue is empty. - Updating the priority for tasks that do not exist in the queue.","solution":"import heapq class Task: def __init__(self, priority, task): self.priority = priority self.task = task def __lt__(self, other): # Reverse comparison to make heapq a max-heap based on priority return self.priority > other.priority class QueueScheduler: def __init__(self): self.pq = [] self.entry_finder = {} # mapping of tasks to entries self.REMOVED = \'<removed-task>\' def add_task(self, task: str, priority: int) -> None: if task in self.entry_finder: self.update_task_priority(task, priority) else: entry = Task(priority, task) self.entry_finder[task] = entry heapq.heappush(self.pq, entry) def execute_task(self) -> str: while self.pq: entry = heapq.heappop(self.pq) if entry.task != self.REMOVED: del self.entry_finder[entry.task] return entry.task raise KeyError(\'execute_task from an empty priority queue\') def update_task_priority(self, task: str, new_priority: int) -> None: if task not in self.entry_finder: raise KeyError(\'Task not found\') self.remove_task(task) self.add_task(task, new_priority) def remove_task(self, task: str) -> None: entry = self.entry_finder.pop(task) entry.task = self.REMOVED # mark the entry as removed"},{"question":"# Segment Tree Challenge: Context: You are tasked with maintaining and querying a dynamic array efficiently. You need to design a segment tree that supports the following operations in logarithmic time: 1. **Range Query**: Compute the result of applying a commutative function over a specific range of the array. 2. **Update Element**: Update a specific element in the array. Task: Implement a class `SegmentTree` to support these operations. Use the given function for the operations. The function is guaranteed to be commutative. # Function Signatures: ```python class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]) -> None: pass def update(self, index: int, value: Any) -> None: pass def query(self, left: int, right: int) -> Any: pass ``` # Input and Output: - `__init__`: Initializes the segment tree. - **Parameters**: - `arr`: A list of elements. - `function`: A commutative function taking two arguments, used for combining elements. - `update`: - **Parameters**: - `index`: Index of the element to be updated. - `value`: The new value for the element. - `query`: - **Parameters**: - `left`: Start index of the range. - `right`: End index of the range (inclusive). - **Returns**: The result of applying the function on the range [left, right]. # Constraints: - The array length will be up to 10^5. - Elements in the array can be of any type that the function can operate. - The indices for the update and query functions are valid. # Examples: ```python # Example 1 arr = [2, 4, 5, 3, 4] max_func = max mytree = SegmentTree(arr, max_func) print(mytree.query(2, 4)) # Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Output: 6 # Example 2 arr = [4, 5, 2, 3, 4, 43, 3] sum_func = lambda a, b: a + b mytree = SegmentTree(arr, sum_func) print(mytree.query(0, 6)) # Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Output: 52 # Example 3 arr = [(1, 2), (4, 6), (4, 5)] tuple_add = lambda a, b: (a[0] + b[0], a[1] + b[1]) mytree = SegmentTree(arr, tuple_add) print(mytree.query(0, 2)) # Output: (9, 13) mytree.update(2, (-1, 2)) print(mytree.query(0, 2)) # Output: (4, 10) ``` Implement the class `SegmentTree` with the above specifications.","solution":"from typing import List, Callable, Any class SegmentTree: def __init__(self, arr: List[Any], function: Callable[[Any, Any], Any]) -> None: self.n = len(arr) self.tree = [None] * (2 * self.n) self.function = function # Build the tree # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[i * 2], self.tree[i * 2 + 1]) def update(self, index: int, value: Any) -> None: # Set value at the specified index and then update the rest of the tree pos = index + self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, left: int, right: int) -> Any: # Get the result of the function from the range [left, right] left += self.n right += self.n res = None while left <= right: if left % 2 == 1: if res is None: res = self.tree[left] else: res = self.function(res, self.tree[left]) left += 1 if right % 2 == 0: if res is None: res = self.tree[right] else: res = self.function(res, self.tree[right]) right -= 1 left //= 2 right //= 2 return res"},{"question":"**Context**: Consider a scenario where you are tasked with designing a resource allocation system for a data center. The data center needs to allocate various resources (servers, storage units, etc.) to tasks in a cost-effective manner. The goal is to ensure that all required resources are allocated by selecting from a pool of available resource groups, each with an associated cost. **Problem**: Given a universe ( U ) of ( n ) elements and a collection of ( m ) subsets ( S ), where each subset ( S_i ) has an associated cost, write a function `optimal_set_allocation` to find the minimum cost subcollection of ( S ) that covers all elements of ( U ). **Function Signature**: ```python def optimal_set_allocation(universe, subsets, costs): Args: universe (set): Universe of elements subsets (dict): Subsets of U {S1:elements, S2:elements, ...} costs (dict): Costs of each subset in S - {S1:cost, S2:cost, ...} Returns: list: The least cost subcollection of subsets pass ``` **Input Format**: - `universe`: A set of unique integers representing the universe ( U ). - `subsets`: A dictionary where keys are strings representing subset names and values are sets of unique integers. - `costs`: A dictionary where keys are strings representing subset names and values are integers representing the cost associated with the subset. **Output Format**: - A list of strings representing the subset names in the selected subcollection that covers the entire universe with the minimum total cost. **Constraints**: - The universe ( U ) will have a maximum of 20 elements. - There will be at most 30 subsets. **Performance**: - The solution should optimally solve for at most 20 elements in the universe and 30 subsets. **Examples**: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} print(optimal_set_allocation(universe, subsets, costs)) # Output Example: [\'S2\', \'S3\'] ``` **Requirements**: 1. Ensure the function handles edge cases gracefully. 2. Aim for clarity and efficiency in your algorithm. 3. Avoid hardcoding for specific inputs; write a generalized solution.","solution":"from itertools import combinations def optimal_set_allocation(universe, subsets, costs): # Initialize the minimum cost and the corresponding covering sets min_cost = float(\'inf\') best_combination = [] # Check all possible combinations of the subsets for r in range(1, len(subsets) + 1): for combo in combinations(subsets.keys(), r): # Combine the elements and the costs of the current combination combined_elements = set.union(*[subsets[c] for c in combo]) combined_cost = sum([costs[c] for c in combo]) # If it covers the universe and is cheaper, update the best combination if combined_elements == universe and combined_cost < min_cost: min_cost = combined_cost best_combination = combo return list(best_combination)"},{"question":"Scenario You are tasked with optimizing a text processing function. Specifically, you need to find the first non-repeating character in a given string and return its index. Problem Statement Write a function `first_unique_char` that takes a string `s` and returns the index of the first non-repeating character in it. If none exists, return -1. Function Signature ```python def first_unique_char(s: str) -> int: pass ``` Input - A string `s` (1 <= len(s) <= 10^5) containing only lowercase English letters. Output - An integer representing the index of the first non-repeating character, or -1 if no such character exists. Constraints * Optimize the function to run in O(n) time complexity. * You may use extra space of O(1) since the string consists only of lowercase English letters. Examples ```python # Example 1: s = \\"leetcode\\" # The first non-repeating character is \'l\', which is at index 0. print(first_unique_char(s)) # Output: 0 # Example 2: s = \\"loveleetcode\\" # The first non-repeating character is \'v\', which is at index 2. print(first_unique_char(s)) # Output: 2 # Example 3: s = \\"aabb\\" # There are no non-repeating characters. print(first_unique_char(s)) # Output: -1 ``` Notes * Consider using data structures like dictionaries to keep track of character counts and their respective indexes. * Ensure that your implementation handles edge cases, such as strings where all characters repeat or only one character exists.","solution":"def first_unique_char(s: str) -> int: from collections import Counter # Count the occurrence of each character in the string count = Counter(s) # Iterate through the string to find the first character with a count of 1 for index, char in enumerate(s): if count[char] == 1: return index # If no unique character is found, return -1 return -1"},{"question":"# In-Order Successor in BST Context You\'re working on a software that uses a Binary Search Tree (BST) to store and retrieve sorted data efficiently. One of the features you need to implement is to find the in-order successor of a given node in the tree. The in-order successor of a node is the node with the smallest key greater than the key of the input node. Problem Statement Write a function `successor(root, node)` that takes the `root` of a Binary Search Tree and a node `node` within the tree and returns the in-order successor of the given node. If the node has no in-order successor, return `None`. Input * `root`: A TreeNode representing the root of a Binary Search Tree. * `node`: A TreeNode for which the in-order successor needs to be found. Output * Returns the in-order successor TreeNode. If there is no successor, return `None`. Constraints * The tree is a valid binary search tree. * All node values are unique. * Both `root` and `node` are valid references to TreeNode objects in the BST. Performance Requirements * The solution should have a time complexity of O(h) where h is the height of the tree. * The space complexity should be O(1). Example Given the BST: ``` 20 / 10 30 / 5 15 / 3 7 17 ``` For the input node with value `10`, the output should be node with value `15`. Edge Cases 1. The given node is the largest in the tree (e.g., node with value `30` in the above diagram) – the output should be `None`. 2. The given node is the root. 3. The BST is empty.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def successor(root, node): Returns the in-order successor of the given node in the BST. # If the node has a right child, the successor is the leftmost node in the right subtree. if node.right: node = node.right while node.left: node = node.left return node # If the node has no right child, go up the tree until we find a node that is a left child of its parent. successor = None while root: if node.value < root.value: successor = root root = root.left elif node.value > root.value: root = root.right else: break return successor"},{"question":"# Question: Reverse a Singly Linked List - Advanced Challenge Context You are working for a tech company that frequently deals with data processing tasks involving linked lists. One of the commonly performed operations is reversing a singly linked list to perform various analytics. Task Write a function that takes the head of a singly linked list and returns the head of the reversed linked list. Function Signature ```python def reverse_list(head: ListNode) -> ListNode: :param head: ListNode - The head of the singly linked list :return: ListNode - The head of the reversed singly linked list ``` Input * `head`: The head node of a singly linked list. This node has the following attributes: * `val`: An integer value stored in the node. * `next`: A reference to the next node in the list, or `None` if it is the last node. Output * Return the new head of the reversed linked list. Constraints * The number of nodes in the list is in the range `[0, 5000]`. * `-10000 <= Node.val <= 10000` Performance Requirements * Your solution should handle both iterative and recursive approaches to reverse the list efficiently. Example ```python # Example usage: # Input: 1 -> 2 -> 3 -> 4 -> 5 -> None # Output: 5 -> 4 -> 3 -> 2 -> 1 -> None # Explanation: # The input list 1 -> 2 -> 3 -> 4 -> 5 becomes 5 -> 4 -> 3 -> 2 -> 1 after the reversal. ``` Note Ensure your implementation handles both empty lists and single element lists correctly without causing runtime errors.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list(head: ListNode) -> ListNode: Reverses the singly linked list. :param head: ListNode - The head of the singly linked list :return: ListNode - The head of the reversed singly linked list prev = None current = head while current is not None: next_temp = current.next current.next = prev prev = current current = next_temp return prev"},{"question":"You are given an array of integers that you need to sort in ascending order. To achieve this, implement the `cocktail_shaker_sort` function using the Cocktail Shaker Sort algorithm, described below. Cocktail Shaker Sort is an improved version of Bubble Sort that extends the sorting pass from one direction to both directions. It sorts in both left-to-right and right-to-left passes in each iteration. # Function Signature ```python def cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (an array of integers) - The array that needs to be sorted. # Output * Returns the sorted array in ascending order. # Constraints * The algorithm must perform in-place sorting. * It should handle edge cases like empty array, single element array, and already sorted arrays efficiently. # Sample Input/Output Example 1: **Input:** ```python arr = [3, 1, 2, 4, 5] ``` **Output:** ```python [1, 2, 3, 4, 5] ``` Example 2: **Input:** ```python arr = [5, 4, 3, 2, 1] ``` **Output:** ```python [1, 2, 3, 4, 5] ``` Example 3: **Input:** ```python arr = [] ``` **Output:** ```python [] ``` # Implementation Requirements 1. Implement the `cocktail_shaker_sort` function. 2. Ensure the function has an early termination mechanism if no swaps are detected during a pass. 3. Consider edge cases mentioned in the analysis.","solution":"from typing import List def cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts an array in ascending order using the Cocktail Shaker Sort algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 while start <= end: swapped = False # Traverse the array from left to right like in Bubble Sort for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, the array is sorted if not swapped: break # Update the end point to last swapped element end -= 1 # Reset the swapped flag for the next stage swapped = False # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # If no elements were swapped, the array is sorted if not swapped: break # Update the start point to first swapped element start += 1 return arr # Example usage # arr = [3, 1, 2, 4, 5] # sorted_arr = cocktail_shaker_sort(arr) # print(sorted_arr) # Output: [1, 2, 3, 4, 5]"},{"question":"Scenario: You are developing a payment system where users can pay for goods using multiple denominations of coins. To enhance the system, you need to implement a feature that determines the number of ways to provide exact change for any given amount using available coin denominations. Task: You are required to write a Python function `count_ways(coins, value)` that takes in a list of integers `coins` representing the available coin denominations and an integer `value` representing the total amount to make change for. Function Signature: ```python def count_ways(coins: List[int], value: int) -> int: ``` Input: - `coins`: A list of positive integers where each integer represents a coin denomination. - `value`: A non-negative integer representing the total amount for which change is to be made. Output: - Returns an integer representing the number of ways to make change for the given amount using the provided coin denominations. Constraints: - The number of coins (length of `coins` list) will not exceed 100. - The `value` will not exceed 10,000. Example: ```python assert count_ways([1, 2, 5], 5) == 4 # Explanation: # The four ways to make change for 5 using [1, 2, 5] are: # [1, 1, 1, 1, 1], [1, 1, 1, 2], [1, 2, 2], [5] assert count_ways([2, 5, 3, 6], 10) == 5 # Explanation: # The five ways to make change for 10 using [2, 5, 3, 6] are: # [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] assert count_ways([], 4) == 0 # Explanation: # No coins available to make change, so the output is 0 ``` Notes: - Your implementation should make use of a dynamic programming approach for building up the solution. - Consider edge cases such as an empty coin array, a zero value, or extremely large inputs within the constraints.","solution":"from typing import List def count_ways(coins: List[int], value: int) -> int: Returns the number of ways to make change for the given amount using the provided coin denominations. # Initialize a list dp with length (value + 1) that contains zeros dp = [0] * (value + 1) # There is exactly one way to make up amount 0 (use no coins) dp[0] = 1 # Iterate over each coin for coin in coins: # Update the dp table for all amounts that can be reached with the current coin for amount in range(coin, value + 1): dp[amount] += dp[amount - coin] # The result is the number of ways to make the specified amount using the available coins return dp[value]"},{"question":"# Priority Queue Implementation Challenge Background You are tasked with enhancing the functionality of a priority queue data structure. This priority queue is used in a system for scheduling tasks with varying levels of importance. Each task has a priority, and the most critical tasks need to be processed first. Your goal is to implement a priority queue that supports efficient insertion and extraction of elements based on their priority. We will start with the initial implementation provided and add functionalities to address certain limitations. Task 1. Modify the existing `PriorityQueue` class to create a new version called `EfficientPriorityQueue` where: - **Insertion** operation is optimized to work in logarithmic time. - **Extraction** operation remains efficient. 2. Implement methods for: - Merging two priority queues. - Updating the priority of an existing element. Constraints - The priority queue should handle elements with integer priorities. - Elements can have equal priorities. - Implement a binary heap for the priority queue to achieve optimized insertion and extraction. Input and Output 1. **Method Signature**: * `class EfficientPriorityQueue:` * `def __init__(self):` * `def size(self) -> int:` * `def push(self, item, priority: int) -> None:` * `def pop(self) -> int:` * `def merge(self, other_queue: \'EfficientPriorityQueue\') -> None:` * `def update_priority(self, item, new_priority: int) -> None:` 2. **Example**: ```python pq = EfficientPriorityQueue() pq.push(4, 1) pq.push(5, 3) pq.push(6, 2) print(pq.pop()) # Output: 5 print(pq.pop()) # Output: 6 pq2 = EfficientPriorityQueue() pq2.push(7, 4) pq2.push(8, 3) pq.merge(pq2) print(pq.pop()) # Output: 7 print(pq.pop()) # Output: 8 pq.update_priority(4, 5) ``` Notes: - You can utilize the `heapq` module in Python for the binary heap-based implementation. - Remember to handle edge cases and invalid operations. Good luck!","solution":"import heapq class EfficientPriorityQueue: def __init__(self): self.heap = [] self.entry_finder = {} self.REMOVED = \'<removed>\' self.counter = 0 def size(self) -> int: return len(self.heap) def push(self, item, priority: int) -> None: if item in self.entry_finder: self.remove_item(item) count = self.counter entry = [priority, count, item] self.entry_finder[item] = entry heapq.heappush(self.heap, entry) self.counter += 1 def remove_item(self, item): entry = self.entry_finder.pop(item) entry[-1] = self.REMOVED def pop(self) -> int: while self.heap: priority, count, item = heapq.heappop(self.heap) if item is not self.REMOVED: del self.entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def merge(self, other_queue: \'EfficientPriorityQueue\') -> None: for priority, count, item in other_queue.heap: if item is not self.REMOVED: self.push(item, priority) def update_priority(self, item, new_priority: int) -> None: self.push(item, new_priority)"},{"question":"Problem Statement You are required to implement an RSA-based encryption and decryption system with key pair generation capabilities. The focus is on secure key generation, encryption, and decryption mechanisms. Given a specific bit length for the modulus (n), generate the public and private keys, and be able to encrypt and decrypt data securely. Function Signatures 1. `def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]:` 2. `def encrypt(data: int, e: int, n: int) -> int:` 3. `def decrypt(data: int, d: int, n: int) -> int:` Input and Output Formats 1. `generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]`: - **Input**: An integer `k` (bit length for modulus `n`), `seed` for randomness (optional). - **Output**: A tuple `(n, e, d)` where `n` is the modulus, `e` is the public key exponent, and `d` is the private key exponent. 2. `encrypt(data: int, e: int, n: int) -> int`: - **Input**: An integer `data` (plaintext to be encrypted), `e` (public key exponent), `n` (modulus). - **Output**: An integer representing the encrypted data. 3. `decrypt(data: int, d: int, n: int) -> int`: - **Input**: An integer `data` (ciphertext to be decrypted), `d` (private key exponent), `n` (modulus). - **Output**: An integer representing the decrypted data (original plaintext). Constraints * The value of `k` (key size) should be at least 16 bits. * The method for generating primes should ensure a high level of security and randomness. * The encryption and decryption should work seamlessly, ensuring data integrity. Example ```python # Example usage import random # Generating keys n, e, d = generate_key(16, seed=random.randint(1, 100)) # Original data data = 42 # Encryption encrypted = encrypt(data, e, n) # Decryption decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Notes 1. Ensure that the key generation is robust and securely generates appropriate prime numbers. 2. Use Python\'s `pow` with three arguments for optimized modular exponentiation. 3. Consider edge cases such as generating valid primes and handling modular inverses correctly.","solution":"import random from typing import Tuple, Optional from sympy import isprime, nextprime def generate_key(k: int, seed: Optional[int] = None) -> Tuple[int, int, int]: if k < 16: raise ValueError(\\"Bit length must be at least 16.\\") if seed is not None: random.seed(seed) def generate_prime_candidate(bit_length): candidate = random.getrandbits(bit_length) candidate |= (1 << (bit_length - 1)) | 1 return candidate def generate_prime(bit_length): candidate = generate_prime_candidate(bit_length) while not isprime(candidate): candidate = generate_prime_candidate(bit_length) return candidate bit_length = k // 2 p = generate_prime(bit_length) q = generate_prime(bit_length) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used Fermat prime d = pow(e, -1, phi) # Modular multiplicative inverse return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Quick Sort Implementation with Random Pivot **Objective**: Implement a variation of Quick Sort where the pivot is chosen randomly. This reduces the likelihood of encountering the worst-case time complexity. Function Signature Implement a function with the following signature: ```python def quick_sort_random(arr, simulation=False): Perform Quick Sort with random pivot selection. Arguments: arr -- list of numbers to sort. simulation -- if True, print the array at each iteration. Returns: A new list sorted in ascending order. ``` Input * `arr`: A list of `n` integers where (1 leq n leq 10^5). * `simulation`: A boolean flag which, if set to `True`, should print the array at each iteration/step of the sort. Output * A new list containing the elements of `arr` sorted in ascending order. Constraints * The function must be implemented using Quick Sort with randomly chosen pivots. * The returned list should be a new sorted list, not a modification of the input list. * You should ensure the function works efficiently for large input sizes. Example ```python arr = [9, 12, 3, 21, 44] sorted_arr = quick_sort_random(arr) print(sorted_arr) # Output: [3, 9, 12, 21, 44] ``` **Note**: Focus on the correctness of partitioning with a random pivot and ensuring that the function can handle edge cases such as empty arrays and arrays with duplicate elements.","solution":"import random def quick_sort_random(arr, simulation=False): Perform Quick Sort with random pivot selection. Arguments: arr -- list of numbers to sort. simulation -- if True, print the array at each iteration. Returns: A new list sorted in ascending order. if len(arr) <= 1: return arr def partition(arr, low, high): pivot_index = random.randint(low, high) pivot = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low for j in range(low, high): if arr[j] < pivot: arr[i], arr[j] = arr[j], arr[i] i += 1 arr[i], arr[high] = arr[high], arr[i] return i def quick_sort_helper(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort_helper(arr, low, pi - 1) quick_sort_helper(arr, pi + 1, high) if simulation: print(arr) result = arr.copy() quick_sort_helper(result, 0, len(result) - 1) return result"},{"question":"# Maximum Subarray Sum **Scenario**: You are given a list of integers that represent daily stock price changes. To maximize your financial gain from these changes, you wish to find the maximum sum of any contiguous subarray within this list. **Task**: Write a function `find_max_subarray_sum(nums)` that implements Kadane\'s algorithm to find the maximum sum of any contiguous subarray. **Function Signature**: ```python def find_max_subarray_sum(nums: List[int]) -> int: ``` **Input**: - `nums: List[int]`: A list of integers representing daily stock price changes. The list is guaranteed to contain at least one element and its length will not exceed 10^5. **Output**: - Returns the maximum sum obtainable from a contiguous subarray of `nums`. **Constraints**: - The input list will have at least one element and no more than 100,000 elements. - Your solution should have a time complexity of O(n) and space complexity O(1). **Example**: ```python # Example 1 nums = [2, 1, -3, 4, -1, 2, 1, -5, 4] # Expected output: 6 # Explanation: The subarray [4, -1, 2, 1] has the largest sum = 6 print(find_max_subarray_sum(nums)) # Example 2 nums = [-2, -3, -1, -5] # Expected output: -1 # Explanation: The subarray [-1] has the largest sum = -1 print(find_max_subarray_sum(nums)) ``` **Special Notes**: - Consider edge cases where the list contains both positive and negative numbers, as well as cases where all numbers are negative.","solution":"def find_max_subarray_sum(nums): Finds the maximum sum of any contiguous subarray using Kadane\'s algorithm. Args: nums: List[int] - List of integers representing daily stock price changes. Returns: int - Maximum sum of any contiguous subarray. max_so_far = nums[0] max_ending_here = nums[0] for num in nums[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"# Question: You are given a singly linked list where each node contains a single character. Your task is to implement a function that takes the head of this linked list and removes all duplicate elements from the list without using any additional data structures (i.e., no sets, lists, or other containers). # Example: Given the linked list: ``` A -> A -> B -> C -> D -> C -> F -> G ``` After removing duplicates, it should become: ``` A -> B -> C -> D -> F -> G ``` # Function Signature: ```python def remove_duplicates(head: Node) -> None: # Implement the function here ``` # Input: * The input is the head of a linked list, where each node contains a single character (a string of length 1). * The provided Node class and other helper functions should be used as provided. # Output: * The function does not return anything; it should modify the linked list in place. # Constraints: * Do not use any additional data structures (sets, lists, etc.). * The nodes of the linked list contain only uppercase English letters. ```python class Node: def __init__(self, val: str): self.val = val self.next = None def print_linked_list(head: Node) -> None: string = \\"\\" current = head while current: string += current.val + \\" -> \\" if current.next else current.val current = current.next print(string) # Example to test the function a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_duplicates(a1) print_linked_list(a1) # Expected: A -> B -> C -> D -> F -> G ``` # Performance Requirements: * Your implementation should run in O(N^2) time complexity or better where N is the number of nodes in the linked list. * Use of extra memory for storing any kind of collection (like arrays or sets) is not allowed.","solution":"class Node: def __init__(self, val: str): self.val = val self.next = None def remove_duplicates(head: Node) -> None: Removes all duplicate elements from the linked list without using any additional data structures. current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Caesar Cipher Implementation and Edge Case Handling Problem Description Julius Caesar used a cipher to encrypt his confidential information by shifting letters in the alphabet. Your task is to implement an enhanced version of the Caesar Cipher that not only shifts the alphabet characters but also correctly handles non-alphabet characters without altering them. Function Signature ```python def enhanced_caesar_cipher(s: str, k: int) -> str: ``` Input * `s`: A string to be encrypted (1 ≤ `len(s)` ≤ 10^5) * `k`: An integer for the shift amount (0 ≤ `k` ≤ 1000) Output * A string that represents the encrypted version of the input `s` using a Caesar Cipher with a shift of `k`. Constraints 1. Input string contains ASCII characters. 2. Shift amount `k` can be any non-negative integer, including values greater than 25, which should be handled by taking modulo 26. Example ```python # Example 1 s = \\"Hello, World!\\" k = 3 # Expected Output: \\"Khoor, Zruog!\\" # Example 2 s = \\"abcdef\\" k = 26 # Expected Output: \\"abcdef\\" # Example 3 s = \\"Python 3.8.6\\" k = 52 # Expected Output: \\"Python 3.8.6\\" ``` Notes * Non-alphabetical characters should remain unchanged. * Ensure the function is efficient and can handle the upper limit of input constraints. * Provide comprehensive edge case coverage including very small and very large values for `k`.","solution":"def enhanced_caesar_cipher(s: str, k: int) -> str: def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) else: return c k = k % 26 return \'\'.join(shift_char(c, k) for c in s)"},{"question":"# Flatten Nested Arrays You are given an array that may contain nested arrays of arbitrary depth. Your task is to implement a function that will flatten such a structure and return a one-dimensional array containing all the elements in the original order. Function Signature Implement the following function: ```python def flatten_nested_array(input_arr: list) -> list: pass ``` Input - **input_arr**: A possibly nested list of elements. The elements can be of any data type including strings, numbers, and other lists. Output - Return a one-dimensional list containing all elements from the input array in their original order. Constraints - Do not use any libraries that might trivialize the task (e.g., itertools). - The solution should efficiently handle deeply nested arrays up to a reasonable depth (~1000 layers). Example ```python # Example 1 input_arr = [1, [2, [3, 4]], [5]] print(flatten_nested_array(input_arr)) # Output: [1, 2, 3, 4, 5] # Example 2 input_arr = [\'a\', [\'b\', [\'c\', \'d\']], [\'e\', [ \'f\', \'g\']]] print(flatten_nested_array(input_arr)) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\'] # Example 3 input_arr = [[], [[], []]] print(flatten_nested_array(input_arr)) # Output: [] # Example 4 input_arr = [\'a\', [1, 2.0, [\'b\', [3]]], \'c\'] print(flatten_nested_array(input_arr)) # Output: [\'a\', 1, 2.0, \'b\', 3, \'c\'] ``` **Note**: Please define your function logic without directly copying the given snippets, ensuring it fully adheres to this question\'s requirements and constraints.","solution":"def flatten_nested_array(input_arr: list) -> list: This function takes a list which may contain nested lists of arbitrary depth and returns a flattened list. result = [] def flatten(arr): for item in arr: if isinstance(item, list): flatten(item) else: result.append(item) flatten(input_arr) return result # Example usage: # print(flatten_nested_array([1, [2, [3, 4]], [5]])) # Output: [1, 2, 3, 4, 5] # print(flatten_nested_array([\'a\', [\'b\', [\'c\', \'d\']], [\'e\', [\'f\', \'g\']]])) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\']"},{"question":"# Keyboard Row Words Checker Problem Statement You are given a list of words, and you need to filter and return those which can be typed using letters of the alphabet on only one row of a standard American QWERTY keyboard layout. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: ``` Input - `words` (List[str]): A list containing the words to filter. Output - List[str]: A list of words that can be typed using one row of the keyboard. Constraints - All words consist only of alphabets. - The function should be case insensitive. Performance Requirements - Your solution should be efficient enough to handle up to 10⁴ words, each up to 10 characters long. Examples ```python >>> find_keyboard_row([\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"]) [\\"Alaska\\", \\"Dad\\"] >>> find_keyboard_row([\\"omk\\", \\"him\\", \\"mexico\\"]) [] ``` Hints - Use sets to represent the keys available on each row of the keyboard. - Convert each word to lowercase and check if it is entirely contained within any of the keyboard rows. Scenario You are building a typing trainer software that helps users get familiar with typing using different keyboard rows. As part of this, you need to filter out words that can be typed using only one row of the keyboard, making it easier for learners to practice row-specific typing.","solution":"from typing import List def find_keyboard_row(words: List[str]) -> List[str]: rows = [ set(\\"qwertyuiop\\"), set(\\"asdfghjkl\\"), set(\\"zxcvbnm\\") ] def can_be_typed(word): lower_word = set(word.lower()) return any(lower_word <= row for row in rows) return [word for word in words if can_be_typed(word)]"},{"question":"**Question**: Design a function `ladder_length` which computes the length of the shortest transformation sequence from a starting word (`begin_word`) to a target word (`end_word`), given a list of allowable transformations (`word_list`). # Input: - `begin_word`: A string, the starting word. - `end_word`: A string, the target word. - `word_list`: A list of strings, containing the allowable transformations. # Output: - Return an integer, representing the length of the shortest transformation sequence. If no sequence exists, return -1. # Constraints: - All words are of the same length. - All words contain only lowercase alphabets. - `begin_word` and `end_word` are non-empty and their lengths are the same. # Example: ```python begin_word = \\"hit\\" end_word = \\"cog\\" word_list = [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"] ``` One of the shortest transformation sequences is `hit -> hot -> dot -> dog -> cog`, thus the function should return **5**. # Notes: - If the transformation isn\'t possible, return -1. - Utilize an efficient approach such as Bidirectional BFS to tackle the problem. # Function Signature: ```python def ladder_length(begin_word, end_word, word_list): # Your code here ```","solution":"from collections import deque, defaultdict def ladder_length(begin_word, end_word, word_list): if end_word not in word_list: return -1 L = len(begin_word) all_combo_dict = defaultdict(list) for word in word_list: for i in range(L): intermediate_word = word[:i] + \'*\' + word[i+1:] all_combo_dict[intermediate_word].append(word) queue = deque([(begin_word, 1)]) visited = set() visited.add(begin_word) while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \'*\' + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == end_word: return level + 1 if word not in visited: visited.add(word) queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] # Clear to avoid loops return -1"},{"question":"# Separate Chaining Hash Table Enhancement You are given a basic implementation of a `SeparateChainingHashTable` class designed to manage key-value pairs using a hash table with separate chaining for collision resolution. Your task is to enhance the provided implementation. Specifically, you need to implement a resize mechanism that adjusts the size of the hash table dynamically based on the load factor. Additionally, add a method to return all keys currently stored in the hash table. Requirements: 1. Implement a method `resize(new_size)` to adjust the size of the hash table: - `new_size`: New size of the hash table (must be a positive integer). - Rehash all existing elements to the newly resized hash table. 2. Implement a method `keys()` to return a list of all keys currently stored in the hash table. Expected Behavior: 1. When the number of elements exceeds 70% of the table size, the table should expand to double its current size. 2. When the number of elements drops below 20% of the table size, the table should shrink to half its current size. 3. The `resize` operation must rehash all the elements into the new resized table. 4. The `keys` method should return all keys without duplicates. # Function Signature: ```python class SeparateChainingHashTable: def resize(self, new_size: int): pass def keys(self) -> List: pass ``` # Example Usage: ```python table = SeparateChainingHashTable(size=11) # Inserting elements table.put(\'apple\', \'fruit\') table.put(\'car\', \'vehicle\') table.put(\'python\', \'language\') assert table.keys() == [\'apple\', \'car\', \'python\'] # Exceeding load factor limit should trigger resize for i in range(10): table.put(f\'key_{i}\', f\'value_{i}\') assert table.size > 11 # Reducing elements for i in range(10): table.del_(f\'key_{i}\') assert table.size < 11 ``` # Constraints: - Assume keys are strings and values are arbitrary objects. - The `resize` function should carefully handle actual resizing logic to avoid performance bottlenecks.","solution":"class SeparateChainingHashTable: def __init__(self, size=11): self.size = size self.count = 0 self.table = [[] for _ in range(size)] self.load_factor = 0.7 self.shrink_factor = 0.2 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.count += 1 if self.count / self.size > self.load_factor: self.resize(2 * self.size) def get(self, key): index = self.hash(key) bucket = self.table[index] for k, v in bucket: if k == key: return v return None def del_(self, key): index = self.hash(key) bucket = self.table[index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.count -= 1 if self.count / self.size < self.shrink_factor: new_size = max(11, self.size // 2) if new_size != self.size: self.resize(new_size) return return None def resize(self, new_size): if new_size < 1: raise ValueError(\\"New size must be a positive integer\\") old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def keys(self): all_keys = [] for bucket in self.table: for key, _ in bucket: all_keys.append(key) return all_keys"},{"question":"Problem Statement: You are given a sorted array of integers, which is uniformly distributed. Your task is to implement a function `find_element` that utilizes interpolation search to return the index of a specified search key within the array. If the search key is not present in the array, the function should return -1. # Input: * A sorted list of integers (n ≥ 0), where all elements are uniformly distributed. * An integer representing the search key. # Output: * The index of the search key in the list if it is found. * -1 if the search key is not found. # Constraints: * The input list size will not exceed 10^6. * The elements in the list are guaranteed to be uniformly distributed. # Performance Requirements: * The solution should efficiently handle uniformly distributed data. * Average case should demonstrate close to O(log(log(n))) time complexity. # Example: Input: ```python nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] key = 70 ``` Output: ```python 6 ``` Input: ```python nums = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] key = 75 ``` Output: ```python -1 ``` # Function Signature: ```python def find_element(nums: List[int], key: int) -> int: pass ``` # Notes: * Make sure to handle the edge cases such as an empty list or the key being outside the range of the array elements. * An efficient interpolation search should be implemented considering the average case scenario for the given constraints of uniformly distributed data.","solution":"def find_element(nums, key): Finds the index of the search key in a sorted, uniformly distributed list using interpolation search. Parameters: nums (list): A sorted list of integers. key (int): The search key. Returns: int: The index of the search key if found, otherwise -1. if not nums: return -1 low, high = 0, len(nums) - 1 while low <= high and key >= nums[low] and key <= nums[high]: if low == high: if nums[low] == key: return low else: return -1 # Probing the position with interpolation formula pos = low + ((key - nums[low]) * (high - low) // (nums[high] - nums[low])) # Condition of target found if nums[pos] == key: return pos # If key is larger, key is in the upper part if nums[pos] < key: low = pos + 1 # If key is smaller, key is in the lower part else: high = pos - 1 return -1"},{"question":"You are given a directed graph class that can add edges, perform DFS, and check if the graph is strongly connected. Your task is to enhance the functionality of this class to add features required to determine if the graph is **Strongly Connected Components (SCC)** more efficiently using **Kosaraju\'s Algorithm**. # Constraints * The number of vertices (V) will be in the range [1, 10^5]. * The number of edges (E) will be in the range [0, 10^6]. # Input and Output **Function to Implement**: You need to implement the following function: ```python class Graph: def is_strongly_connected(self) -> bool: ``` **Input Format**: The number of vertices (V) is provided at class initialization. The `add_edge(source, target)` function will be called any number of times to add directed edges between vertices. **Output Format**: Return `True` if the graph is strongly connected, `False` otherwise. # Example ```python # Example 1: g = Graph(5) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 0) g.add_edge(1, 3) g.add_edge(3, 4) assert g.is_strongly_connected() == False # Example 2: g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) g.add_edge(3, 0) assert g.is_strongly_connected() == True ``` # Explanation * In the first example, there is no way to reach node 4 from the other nodes, so the graph isn\'t strongly connected. * In the second example, you can reach any node from any other node either directly or through a series of directed edges, so it is strongly connected. # Additional Notes * Use Kosaraju’s Algorithm for the implementation, which involves two passes of DFS. * Ensure you understand edge cases such as when graphs have no edges or single node.","solution":"class Graph: def __init__(self, vertices): Initializes the graph with the given number of vertices. self.V = vertices self.graph = [[] for _ in range(vertices)] def add_edge(self, source, target): Adds a directed edge from the source to the target. self.graph[source].append(target) def _dfs(self, v, visited): A method to perform depth-first search starting from vertex v. visited[v] = True for neighbor in self.graph[v]: if not visited[neighbor]: self._dfs(neighbor, visited) def _transpose(self): Returns the transpose of the graph. g_t = Graph(self.V) for i in range(self.V): for j in self.graph[i]: g_t.add_edge(j, i) return g_t def is_strongly_connected(self): Checks if the graph is strongly connected using Kosaraju\'s Algorithm. # Step 1: Do DFS from any vertex (we pick vertex 0) and check if all vertices are visited. visited = [False] * self.V self._dfs(0, visited) if any(not visit for visit in visited): return False # Step 2: Get the transpose of the graph g_t = self._transpose() # Step 3: Do DFS on the transposed graph starting from the same vertex visited = [False] * self.V g_t._dfs(0, visited) if any(not visit for visit in visited): return False return True"},{"question":"Extended Word Search using Trie You are given a set of words and need to design an efficient data structure to store these words and perform search operations. The search can be for a literal word or using a wildcard `.` which can match any single letter. You must implement the following: **Class Structure**: `AdvancedWordDictionary` **Methods**: - `add_word(word: str) -> None`: Adds a word to the data structure. - `search(word: str) -> bool`: Returns `True` if the word or pattern exists in the data structure; otherwise `False`. Requirements 1. The search method must support wildcard `.`: - Examples: - `search(\\"bad\\")` should return `True` if \\"bad\\" was added. - `search(\\"b..\\")` should return `True` if there is any word of length 3 that starts with \'b\' and ends with any two letters. 2. Your implementation should efficiently handle both the addition of words and search queries. Input and Output * **add_word**: * Input: `word` (a non-empty string consisting only of lowercase English letters, 1 ≤ |word| ≤ 25) * Output: None * **search**: * Input: `word` (a string with possible `.`, 1 ≤ |word| ≤ 25) * Output: `True` if match; `False` otherwise You will be judged on the following: 1. **Correctness**: Your implementations correctly add words and perform searches. 2. **Efficiency**: Your solution should be efficient in terms of both time and space complexity. 3. **Handling Edge Cases**: Solutions should manage various edge cases effectively (e.g., empty words, word with only wildcards). ```python class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AdvancedWordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root) ``` **Example Usage**: ```python aw_dict = AdvancedWordDictionary() aw_dict.add_word(\\"bad\\") aw_dict.add_word(\\"dad\\") aw_dict.add_word(\\"mad\\") print(aw_dict.search(\\"pad\\")) # Outputs: False print(aw_dict.search(\\"bad\\")) # Outputs: True print(aw_dict.search(\\".ad\\")) # Outputs: True print(aw_dict.search(\\"b..\\")) # Outputs: True ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AdvancedWordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current = self.root for char in word: if char not in current.children: current.children[char] = TrieNode() current = current.children[char] current.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i + 1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Question: A binary integer is represented as a string of bits (0s and 1s). You are allowed to flip exactly one bit from 0 to 1. Write a function to find the length of the longest sequence of 1s you could create following this rule. **Function Signature**: ```python def longest_sequence_of_1s(bits: str) -> int: ``` **Input**: - `bits (str)`: A string representation of the binary number. The length of `bits` is between 1 and 1,000,000. **Output**: - An integer representing the length of the longest sequence of 1s that can be created by flipping exactly one bit from 0 to 1. **Constraints**: - You must flip exactly one bit. - The binary string will only contain \'0\'s and \'1\'s. - The input string length can be up to 1,000,000 characters. **Examples**: ``` Example 1: Input: \\"11011101111\\" Output: 8 Example 2: Input: \\"1111\\" Output: 5 Example 3: Input: \\"1000001\\" Output: 2 ``` **Performance Requirements**: - The algorithm should run in linear time relative to the length of the binary string and should use a constant amount of additional space. **Important Points**: - Consider large inputs and ensure the solution is optimized for performance. - Your solution should handle edge cases effectively.","solution":"def longest_sequence_of_1s(bits: str) -> int: Returns the length of the longest sequence of 1s that can be created by flipping exactly one bit from 0 to 1. max_len = 0 previous_segment = 0 current_segment = 0 has_zero = False for bit in bits: if bit == \'1\': current_segment += 1 elif bit == \'0\': has_zero = True # Calculate max length max_len = max(max_len, previous_segment + current_segment + 1) # Move to next segment previous_segment = current_segment current_segment = 0 # Final calculation in case there are no more zeros at the end max_len = max(max_len, previous_segment + current_segment + 1) # Handle the case where there were no zeros to flip if not has_zero: max_len = len(bits) + 1 return max_len"},{"question":"Advanced Binary Search As a developer, you are assisting with search functionality in a large database. You have a sorted list of timestamps, and you are tasked to efficiently find the exact index of a timestamp or the nearest timestamp if the exact match is not found. **Function Signature**: ```python def advanced_binary_search(array: List[int], target: int) -> int: :param array: List[int] : List of sorted timestamps :param target: int : The timestamp you are searching for :return: int : The index of the exact timestamp or the nearest timestamp ``` # Requirements: 1. **Input**: * `array` is a list of sorted integers (`List[int]`) representing timestamps. * `target` is the timestamp (`int`) you are searching for. 2. **Output**: * Return the index (`int`) of the exact timestamp if found. * If the exact timestamp is not found, return the index of the nearest timestamp. * If the array is empty, return `-1`. 3. **Optimization**: * The solution should run in O(log n) time complexity. 4. Implementation should be robust to handle edge cases like an empty array and boundary conditions. # Example: ```python assert advanced_binary_search([1, 3, 5, 7, 9], 6) == 2 # Nearest timestamp to 6 is 5 at index 2 assert advanced_binary_search([1, 3, 5, 7, 9], 5) == 2 # Exact match assert advanced_binary_search([1, 3, 5, 7, 9], 10) == 4 # Nearest is 9 at index 4 assert advanced_binary_search([], 4) == -1 # Empty array returns -1 ``` Analyze all test cases and confirm correct and efficient implementation of the function.","solution":"from typing import List def advanced_binary_search(array: List[int], target: int) -> int: Perform a binary search to find the exact index of a timestamp or the nearest timestamp. :param array: List[int] : List of sorted timestamps :param target: int : The timestamp you are searching for :return: int : The index of the exact timestamp or the nearest timestamp if not array: return -1 # Return -1 if the array is empty left, right = 0, len(array) - 1 best_index = -1 best_diff = float(\'inf\') while left <= right: mid = left + (right - left) // 2 if array[mid] == target: return mid elif array[mid] < target: left = mid + 1 else: right = mid - 1 # Check if the current middle element is closer to the target if abs(array[mid] - target) < best_diff: best_diff = abs(array[mid] - target) best_index = mid # If two distances to target are equal, choose the smaller value elif abs(array[mid] - target) == best_diff: if array[mid] < array[best_index]: best_index = mid return best_index"},{"question":"Context You are working on a legacy codebase for a card game company. The company\'s stack-based card shuffling algorithm needs verifying function to check whether cards are in a sequence. The sequence can start from any card but must proceed consecutively by one. Problem Statement Implement a function `is_consecutive(stack)` that checks if a stack of integers contains a sequence of consecutive integers starting from the bottom of the stack. You may use either an auxiliary stack or queue to facilitate this. Function Signature ```python def is_consecutive(stack): Determines if the given stack contains a sequence of consecutive integers from bottom to top. :param stack: List[int] - a stack represented as a list where the first element is the bottom of the stack. :return: bool - True if the stack contains consecutive integers, False otherwise. ``` Input * `stack` (List[int]): A list representing a stack of integers. The first element of the list is the bottom of the stack, the last element is the top. Constraints: * The length of `stack` will be between 0 and 10^5. * Elements in `stack` are integers within the range [-10^9, 10^9]. Output * Return `True` if the stack consists of consecutive integers starting from the bottom; otherwise, return `False`. Examples ```python # Example 1 stack = [3, 4, 5, 6, 7] assert is_consecutive(stack) == True # Example 2 stack = [3, 4, 6, 7] assert is_consecutive(stack) == False # Example 3 stack = [3, 2, 1] assert is_consecutive(stack) == False # Example 4 stack = [] assert is_consecutive(stack) == True # Example 5 stack = [5] assert is_consecutive(stack) == True ``` Additional Notes 1. You must ensure that the stack remains in its original order after your function completes. 2. Efficiently handle the edge cases such as small stacks or empty stacks. 3. Consider memory usage and aim for optimization where feasible.","solution":"def is_consecutive(stack): Determines if the given stack contains a sequence of consecutive integers from bottom to top. :param stack: List[int] - a stack represented as a list where the first element is the bottom of the stack. :return: bool - True if the stack contains consecutive integers, False otherwise. if len(stack) <= 1: return True for i in range(1, len(stack)): if stack[i] != stack[i - 1] + 1: return False return True"},{"question":"# Priority Queue Implementation A software company asks you to design a task manager that prioritizes tasks based on their urgency. Implement a class **`PriorityQueue`** using a linear array which maintains the order of tasks based on their priority. The higher the number means higher priority (less urgent). Your task is to implement the `PriorityQueue` class with the following requirements: 1. **Attributes**: * The internal list `priority_queue_list` to hold the tasks and their priorities. 2. **Functions**: * **Initialization** - `__init__(self, items=None, priorities=None)`: Initialize an empty queue or one seeded with given items and priorities. * **size(self)** - Returns the number of tasks in the queue. * **push(self, item, priority=None)** - Inserts `item` with an optional `priority` into the queue. * **pop(self)** - Removes and returns the item with the highest priority, i.e., the least urgent task. # Input * The `PriorityQueue` class needs to handle initialization, insertion, and removal of tasks. * Methods might need an item and priority as parameters. # Output * The `pop` method should return the least urgent task available in the queue or raise an appropriate exception if the queue is empty. # Example ``` pq = PriorityQueue() pq.push(\'Task1\', priority=2) pq.push(\'Task2\', priority=1) pq.push(\'Task3\', priority=3) print(pq.pop()) # Output: Task2 (since it has the highest priority, i.e., least urgent) print(pq.pop()) # Output: Task1 print(pq.size()) # Output: 1 ``` # Constraints * You can assume the uniqueness of items, however, priorities can be duplicated. * Handle the case where `pop` is called on an empty queue by raising an appropriate exception. # Notes: * Your implementation should ensure that all operations besides insertion are efficient. * Prioritize the correctness of the order in the queue and handling edge cases during pop operations.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.priority_queue_list) def push(self, item, priority): self.priority_queue_list.append((priority, item)) self.priority_queue_list.sort(key=lambda x: x[0]) # Ensure smallest priority is first def pop(self): if self.priority_queue_list: priority, item = self.priority_queue_list.pop(0) return item else: raise Exception(\\"Pop from empty priority queue\\")"},{"question":"Context You are helping a social media platform analyze its user interaction graph. The platform represents users as vertices and interactions as directed edges. Your task is to write a function that identifies and returns the number of strongly connected components (SCCs) in this directed graph using Kosaraju\'s algorithm. Problem Statement Write a function `find_scc` that takes an integer `V` (the number of vertices) and a list of pairs `edges` representing directed edges, and returns the number of strongly connected components in the given graph. Function Signature ```python def find_scc(V: int, edges: List[Tuple[int, int]]) -> int: ``` Input * `V`: An integer `V` (2 ≤ V ≤ 10^4) - The number of vertices in the graph. * `edges`: A list of pairs of integers where each pair (u, v) represents a directed edge from vertex `u` to vertex `v`. Output * Returns an integer representing the number of strongly connected components in the graph. Example ```python V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] print(find_scc(V, edges)) # Output: 2 ``` Constraints * All vertex indices `u` and `v` are in the range [0, V-1]. * The graph is directed, and edges can be self-loops. Notes * Make sure to handle large graph inputs efficiently. * Carefully consider edge cases such as disconnected subgraphs or graphs with no edges.","solution":"from typing import List, Tuple def find_scc(V: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque def dfs(graph, vertex, visited, stack): visited[vertex] = True for neighbor in graph[vertex]: if not visited[neighbor]: dfs(graph, neighbor, visited, stack) stack.append(vertex) def reverse_graph(graph): reversed_graph = defaultdict(list) for vertex in graph: for neighbor in graph[vertex]: reversed_graph[neighbor].append(vertex) return reversed_graph def fill_order(graph, V): visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(graph, i, visited, stack) return stack def dfs_with_stack(graph, stack): visited = [False] * V component_count = 0 while stack: vertex = stack.pop() if not visited[vertex]: component_stack = deque([vertex]) while component_stack: node = component_stack.pop() visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: component_stack.append(neighbor) component_count += 1 return component_count graph = defaultdict(list) for u, v in edges: graph[u].append(v) stack = fill_order(graph, V) reversed_graph = reverse_graph(graph) return dfs_with_stack(reversed_graph, stack)"},{"question":"# Question: Implement an Optimized Sorting Mechanism You are tasked with developing an optimized sorting system for a small autonomous robot that sorts various payloads. This robot uses a small amount of in-place storage. Based on this constraint, you should implement a function `optimized_selection_sort` that leverages the principles of Selection Sort but includes enhancements to handle specific scenarios efficiently. # Requirements: 1. Implement the function `optimized_selection_sort(arr)` with the same functionality as the provided `selection_sort`, but optimize it to handle nearly sorted arrays more efficiently. 2. Your implementation should: - Maintain the in-place sorting property. - Be optimized to reduce unnecessary comparisons if the array is already sorted or nearly sorted, wherever possible. 3. Include detailed comments documenting how your optimization improves over the basic selection sort. # Input: - An array of integers `arr` with a length between 1 and 10,000. - The array could be sorted, nearly sorted, or randomly ordered. # Output: - The sorted array. # Constraints: - You may only use in-place memory (O(1) extra space). - Performance should be considered where possible, although exact improvements are flexible as long as they are justified. # Scenario: In a high-precision assembly line, the sorting robot is responsible for preparing parts in a sorted order quickly and efficiently, especially when the parts are already mostly ordered. Improving the algorithm helps to maintain the assembly line\'s operational flow without unnecessary delays. # Example: ```python def optimized_selection_sort(arr): # Your implementation here pass # Example usage arr = [3, 2, 1, 4, 5] print(optimized_selection_sort(arr)) # Output: [1, 2, 3, 4, 5] ```","solution":"def optimized_selection_sort(arr): Performs optimized selection sort on the input array, attempting to minimize unnecessary comparisons for nearly sorted arrays. n = len(arr) for i in range(n): min_index = i is_sorted = True for j in range(i + 1, n): # Check if the rest of the array is sorted to optimize if arr[j - 1] > arr[j]: is_sorted = False # Find the minimum element in the unsorted portion of the array if arr[j] < arr[min_index]: min_index = j # If already sorted, break out to save time if is_sorted: break # Swap the found minimum element with the first element arr[i], arr[min_index] = arr[min_index], arr[i] return arr"},{"question":"Enhanced Pigeonhole Sort Given an array of integers, implement an enhanced version of the pigeonhole sort that can handle arrays containing negative numbers and ensure space efficiency. Your function should be named `enhanced_pigeonhole_sort`. Function Signature ```python def enhanced_pigeonhole_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers `arr` where -10^6 <= arr[i] <= 10^6 and 0 <= len(arr) <= 10^6. Output - A list of integers sorted in non-decreasing order. Constraints - The function should handle arrays containing negative integers. - The function should be optimized for both time and space complexity. - You should handle edge cases such as empty arrays and arrays with all identical elements. Example ```python assert enhanced_pigeonhole_sort([8, 3, -2, 7, 1, -5, 3]) == [-5, -2, 1, 3, 3, 7, 8] assert enhanced_pigeonhole_sort([0, 5, 3, 0, 5, 3, 3]) == [0, 0, 3, 3, 3, 5, 5] assert enhanced_pigeonhole_sort([]) == [] assert enhanced_pigeonhole_sort([5]) == [5] ``` # Prompt Implement the function `enhanced_pigeonhole_sort` to sort the given array of integers, effectively managing space and runtime constraints. Ensure that your solution handles negative values correctly and works efficiently for the given input size and range constraints.","solution":"def enhanced_pigeonhole_sort(arr): if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for x in arr: holes[x - min_val] += 1 sorted_arr = [] for i in range(size): sorted_arr.extend([i + min_val] * holes[i]) return sorted_arr"},{"question":"# Integer-Byte Conversion: Endian Management **Scenario**: You are writing a system that interacts with different network protocols and file formats. Given the need to handle both big-endian and little-endian systems, you need to ensure correct conversion between integers and their byte representations. **Task**: Implement the functions necessary for these conversions, considering signed integers, edge cases such as zero, and optimizing for performance. Function Specifications: 1. `int_to_bytes_signed_big_endian(num: int) -> bytes`: - Converts a signed integer into its big-endian byte representation. - Inputs: - `num`: integer (positive or negative) - Outputs: - `bytes`: byte representation in big-endian order. 2. `int_to_bytes_signed_little_endian(num: int) -> bytes`: - Converts a signed integer into its little-endian byte representation. - Inputs: - `num`: integer (positive or negative) - Outputs: - `bytes`: byte representation in little-endian order. 3. `bytes_signed_big_endian_to_int(bytestr: bytes) -> int`: - Converts a big-endian byte representation back to a signed integer. - Inputs: - `bytestr`: bytes in big-endian order. - Outputs: - `int`: the integer representation. 4. `bytes_signed_little_endian_to_int(bytestr: bytes) -> int`: - Converts a little-endian byte representation back to a signed integer. - Inputs: - `bytestr`: bytes in little-endian order. - Outputs: - `int`: the integer representation. Constraints: - Valid byte strings for conversion: ensure all values are within valid byte range (0-255). - Assume integer size fits within modern memory limits but test edge cases. - Efficiency: Aim for solutions with optimal time and space complexity. **Examples**: ```python assert int_to_bytes_signed_big_endian(258) == b\'x01x02\' assert int_to_bytes_signed_little_endian(-257) == b\'xffxfe\' assert bytes_signed_big_endian_to_int(b\'x00x01\') == 1 assert bytes_signed_little_endian_to_int(b\'x01xff\') == -255 ``` **Notes**: - Remember to handle possible edge cases diligently. - Ensure your implementation is efficient with time and space usage.","solution":"def int_to_bytes_signed_big_endian(num: int) -> bytes: Converts a signed integer into its big-endian byte representation. if num == 0: return b\'x00\' # Determine the number of bytes needed num_bytes = (abs(num).bit_length() + 7) // 8 # Convert to big endian format return num.to_bytes(num_bytes, byteorder=\'big\', signed=True) def int_to_bytes_signed_little_endian(num: int) -> bytes: Converts a signed integer into its little-endian byte representation. if num == 0: return b\'x00\' # Determine the number of bytes needed num_bytes = (abs(num).bit_length() + 7) // 8 # Convert to little endian format return num.to_bytes(num_bytes, byteorder=\'little\', signed=True) def bytes_signed_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte representation back to a signed integer. return int.from_bytes(bytestr, byteorder=\'big\', signed=True) def bytes_signed_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte representation back to a signed integer. return int.from_bytes(bytestr, byteorder=\'little\', signed=True)"},{"question":"# Flatten Nested Structures You are tasked with implementing a function that flattens complex nested iterables (such as lists, tuples, sets, etc.) into a single one-dimensional list. This function should maintain the order of elements as they appear in the nested structure. This type of task is often necessary in data preprocessing steps, especially when dealing with hierarchical data from files such as JSON, XML, or other nested formats. Input - An iterable (list, tuple, set, etc.) that may contain nested iterables with any depth. Output - A one-dimensional list of all elements in the original nested iterable, maintaining their order. Constraints - Your solution must handle iterables containing non-iterable items like integers, floats, strings, etc. - Strings should not be split, i.e., \\"hello\\" should be treated as a single item, not as \'h\', \'e\', \'l\', \'l\', \'o\'. - `None` values should be preserved in the output. Performance - The function should run efficiently within O(n) time, where n is the number of elements including nested elements. Example Input: ```python [1, [2, 3, [4, 5]], \'hello\', (6, 7, [8, 9, [10]]), None, {11, 12}, [13, {14, 15}]] ``` Output: ```python [1, 2, 3, 4, 5, \'hello\', 6, 7, 8, 9, 10, None, 11, 12, 13, 14, 15] ``` Function Signature ```python def flatten_nested_iterables(nested_iterable): # Your code here ``` # Notes 1. Do not use any in-built functions like `flat`, though list comprehensions can be used if necessary. 2. Ensure that you do proper type-checking to avoid splitting strings into characters. 3. The function should be recursive if possible to help demonstrate your understanding of such algorithms.","solution":"def flatten_nested_iterables(nested_iterable): This function takes a nested iterable and flattens it into a one-dimensional list. flattened_list = [] def flatten(item): if isinstance(item, (list, tuple, set)): for sub_item in item: flatten(sub_item) else: flattened_list.append(item) flatten(nested_iterable) return flattened_list"},{"question":"# Linked List Intersection Given two singly linked lists, find and return the node at which the two lists intersect. If the two linked lists have no intersection at all, return `None`. **Function Signature**: ```python def intersection(h1: Node, h2: Node) -> Node: # implementation goes here ``` # Input: - Two head nodes, `h1` and `h2`, representing the start of two singly linked lists. # Output: - The intersection node if it exists, or `None` if there is no intersection. # Constraints: - The linked lists must retain their original structure after the function returns. - It is not allowed to modify the linked lists. - Time complexity should be (O(N + M)), where (N) and (M) are the lengths of the two linked lists. # Example: Input: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` Output: ``` Node with value 7 ``` # Explanation: In the example, the node with value 7 is the first common node (by reference, not by value) between the two linked lists. # Testing: For testing, you may consider preparing a few scenarios: 1. Lists with empty nodes. 2. Lists that intersect at the head. 3. Lists that do not intersect. 4. Lists with varying lengths and an intersection at different points. Your function should correctly handle all these scenarios. Here is a sample test class you can use to verify your implementation: ```python import unittest class TestLinkedListIntersection(unittest.TestCase): def test_intersection(self): # create linked list as: # 1 -> 3 -> 5 # # 7 -> 9 -> 11 # / # 2 -> 4 -> 6 a1 = Node(1) b1 = Node(3) c1 = Node(5) d = Node(7) a2 = Node(2) b2 = Node(4) c2 = Node(6) e = Node(9) f = Node(11) a1.next = b1 b1.next = c1 c1.next = d a2.next = b2 b2.next = c2 c2.next = d d.next = e e.next = f self.assertEqual(7, intersection(a1, a2).val) self.assertIsNone(intersection(Node(1), Node(2))) if __name__ == \'__main__\': unittest.main() ``` Implement the `intersection` function to pass the above test cases.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def intersection(h1, h2): Finds the intersection point of two singly linked lists, if it exists. :param h1: Node - Head node of the first linked list :param h2: Node - Head node of the second linked list :return: Node - The intersection node or None if no intersection exists # Initialize two pointers for the two linked lists p1, p2 = h1, h2 # Traverse the lists; when reaching the end of either list, move to the head of the other list while p1 is not p2: p1 = p1.next if p1 else h2 p2 = p2.next if p2 else h1 # If the two pointers meet, that\'s the intersection, else both will reach None return p1"},{"question":"# GCD and LCM Evaluation Objective Create a function that efficiently calculates the GCD and LCM of two numbers while handling various potential edge cases. Demonstrate not only your capability to implement these fundamental algorithms but also your ability to handle errors and optimize operations. Function Specifications 1. **Function Name**: `evaluate_gcd_lcm` 2. **Input**: ```python def evaluate_gcd_lcm(a: int, b: int) -> Tuple[int, int]: ``` - `a`: An integer (positive or negative). - `b`: An integer (positive or negative). 3. **Output**: - A tuple where the first element is the GCD of `a` and `b`, and the second is their LCM. Constraints - If `a` or `b` is zero, handle by returning an error message. - Ensure handling of negative integers properly. Performance Requirements - The implementation should be efficient enough to handle very large integers. - For finding LCM, avoid overflow whenever possible. Example Scenarios 1. **Example 1** ```python evaluate_gcd_lcm(12, 15) ``` **Output**: ```python (3, 60) ``` 2. **Example 2** ```python evaluate_gcd_lcm(-7, 28) ``` **Output**: ```python (7, 28) ``` 3. **Edge Case** ```python evaluate_gcd_lcm(0, 5) ``` **Output**: ```python \'Error: One or both input values are zero\' ``` Hints: - Use Euclidean Algorithm for finding GCD. - Use the relation LCM(a, b) = abs(a*b) / GCD(a, b). - Handle inputs and outputs properly to ensure robust performance and avoid common pitfalls like division by zero.","solution":"import math from typing import Tuple, Union def evaluate_gcd_lcm(a: int, b: int) -> Union[Tuple[int, int], str]: Returns the GCD and LCM of two integers a and b. If either a or b is zero, returns an error message. if a == 0 or b == 0: return \\"Error: One or both input values are zero\\" gcd = math.gcd(a, b) lcm = abs(a * b) // gcd return (gcd, lcm)"},{"question":"Scenario Imagine you are a software engineer tasked with searching specific values within a large list of uniformly distributed sensor readings. For efficiency, you decided to use the interpolation search algorithm. You need to implement a function that takes a sorted list of readings and a search key, and returns the index of the key if found, or `-1` if the key is not present. Task Implement the `interpolation_search` function using Python, adhering to the following specifications. Input Specification * The function takes in two parameters: * A sorted list of integers `array` (1 ≤ length ≤ 10^5) representing the uniformly distributed sensor readings. * An integer `search_key` that you need to search for within the list. Output Specification * The function should return an integer: * The index of `search_key` in `array` if found. * `-1` if `search_key` is not present in `array`. Constraints * You may assume the input list is sorted in non-decreasing order. * The sensor readings and search keys are all integers within the range [-10^9, 10^9]. Requirements * The solution should optimize performance for large inputs where possible. * Handle edge cases gracefully, including situations where the list has extreme values, or repetitive elements. Function Signature ```python from typing import List def interpolation_search(array: List[int], search_key: int) -> int: ``` Example ```python assert interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) == 2 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) == -1 assert interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) == -1 ```","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if pos < 0 or pos >= len(array): return -1 if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Question Title: Validate Robot Round Trip # Problem Statement: You are tasked to write a function that checks if a robot\'s movement sequence leads it back to its original starting position on a 2D grid. The robot starts at the position `(0, 0)`. The movement sequence is represented by a string consisting of the characters: * \'R\' (Right): Move right by one unit. * \'L\' (Left): Move left by one unit. * \'U\' (Up): Move up by one unit. * \'D\' (Down): Move down by one unit. Write a function `validate_round_trip(movement: str) -> bool` that takes a string `movement`, representing the robot\'s movement sequence, and returns a boolean value - `True` if the robot returns to its starting position `(0, 0)`, and `False` otherwise. # Function Signature: ```python def validate_round_trip(movement: str) -> bool: ``` # Input: * A single string `movement` that represents the movement sequence. * It is guaranteed that the string is non-empty and only contains \'R\', \'L\', \'U\', and \'D\' characters. # Output: * A boolean value - `True` if the robot returns to the starting position, else `False`. # Examples: 1. Example 1: * Input: `\\"UD\\"` * Output: `True` * Explanation: The robot moves up and then down, returning to the start. 2. Example 2: * Input: `\\"LL\\"` * Output: `False` * Explanation: The robot moves left twice and does not return to the start. 3. Example 3: * Input: `\\"URDL\\"` * Output: `True` * Explanation: The robot moves right, up, left, and down, forming a circle back to the start. # Constraints: * Input string length is in reasonable bounds to fit in memory. * The input string contains only \'R\', \'L\', \'U\', and \'D\'. # Notes: * Handle the edge cases diligently such as repeated moves in one direction and validation for all potential combinations for larger strings. * Aim for an efficient solution both in time and space complexities.","solution":"def validate_round_trip(movement: str) -> bool: x, y = 0, 0 for move in movement: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return (x, y) == (0, 0)"},{"question":"# AVL Tree: Find Kth Smallest Element Objective: You are given a partially implemented AVL tree class. Your task is to enhance this class by implementing an efficient method to find the k-th smallest element in the AVL tree. This involves writing a function that takes an integer k and returns the k-th smallest element in the tree. Background: The k-th smallest element in a tree is the k-th element in the in-order traversal of the tree. Given the properties of AVL trees, you can efficiently calculate this by leveraging the balanced nature and Height info of the tree. Function Signature: ```python def find_kth_smallest(self, k: int) -> int: ``` Input: - An integer `k` (1 ≤ k ≤ number of nodes in the tree) Output: - The k-th smallest element in the AVL tree. Constraints: - You can assume that `1 ≤ k ≤ total number of nodes in the tree`. Implementation Hints: - Consider leveraging the in-order traversal method. - Think about how `k` relates to the structure and properties of the AVL tree. Example: Given the following AVL tree: ``` 20 / 10 30 / / 5 25 40 ``` - `find_kth_smallest(3)` should return `20`. - `find_kth_smallest(1)` should return `5`. Implementation: The method can be added to the AvlTree class provided in the code snippets. ```python def find_kth_smallest(self, k: int) -> int: # Helper function: In-order traversal def inorder_traverse(node, elements): if not node: return inorder_traverse(node.left, elements) elements.append(node.val) inorder_traverse(node.right, elements) elements = [] inorder_traverse(self.node, elements) return elements[k - 1] ``` Task: * Implement the `find_kth_smallest` method in the `AvlTree` class. Update the AvlTree class as needed to support this functionality. * Ensure your implementation is efficient, taking full advantage of the AVL tree\'s self-balancing properties.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.height = 1 self.size = 1 class AvlTree: def __init__(self): self.node = None def insert(self, key): if not self.node: self.node = TreeNode(key) else: self.node = self._insert(self.node, key) def _insert(self, root, key): if not root: return TreeNode(key) elif key < root.value: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self._get_height(root.left), self._get_height(root.right)) root.size = 1 + self._get_size(root.left) + self._get_size(root.right) balance = self._get_balance(root) if balance > 1 and key < root.left.value: return self._right_rotate(root) if balance < -1 and key > root.right.value: return self._left_rotate(root) if balance > 1 and key > root.left.value: root.left = self._left_rotate(root.left) return self._right_rotate(root) if balance < -1 and key < root.right.value: root.right = self._right_rotate(root.right) return self._left_rotate(root) return root def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) z.size = 1 + self._get_size(z.left) + self._get_size(z.right) y.size = 1 + self._get_size(y.left) + self._get_size(y.right) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) z.size = 1 + self._get_size(z.left) + self._get_size(z.right) y.size = 1 + self._get_size(y.left) + self._get_size(y.right) return y def _get_height(self, node): if not node: return 0 return node.height def _get_size(self, node): if not node: return 0 return node.size def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def find_kth_smallest(self, k: int) -> int: def _find_kth_smallest(node, k): if not node: return None left_size = self._get_size(node.left) if k <= left_size: return _find_kth_smallest(node.left, k) elif k == left_size + 1: return node.value else: return _find_kth_smallest(node.right, k - left_size - 1) return _find_kth_smallest(self.node, k)"},{"question":"# Filtering Array Values within Limits Background You are given a dataset represented as an array of numerical values. The task is to filter this array to include only elements that fall within a specified minimum and maximum limit. If no limits are provided, the function should automatically use the minimum and maximum values present in the array. Objective Write a function `filter_with_limits` that accepts an array and optional minimum and maximum limit values. The function should return a new array containing only elements that lie within the specified range `[min_lim, max_lim]`. If `min_lim` or `max_lim` is not provided, use the smallest or largest values in the array, respectively. Function Signature ```python def filter_with_limits(arr: List[int], min_lim: Union[int, None] = None, max_lim: Union[int, None] = None) -> List[int]: pass ``` Input Format - `arr`: A list of integers. - `min_lim`: Optional; an integer or `None`. - `max_lim`: Optional; an integer or `None`. Output Format - A list of integers containing only elements from the input array that lie between the given limits (inclusive). Constraints - The length of the array `n` will be in the range [0, 10^6]. - The value of each element in the array will be in the range [-10^9, 10^9]. - `min_lim` and `max_lim`, if provided, will also be in the range [-10^9, 10^9]. Examples Example 1: ```python assert filter_with_limits([1,2,3,4,5], None, 3) == [1, 2, 3] ``` Example 2: ```python assert filter_with_limits([10, 20, 30, 40, 50], 15, 35) == [20, 30] ``` Example 3: ```python assert filter_with_limits([], 1, 10) == [] ``` Notes - Ensure to handle edge cases where the array might be empty. - Consider scenarios where all elements are outside the given limits.","solution":"from typing import List, Union def filter_with_limits(arr: List[int], min_lim: Union[int, None] = None, max_lim: Union[int, None] = None) -> List[int]: Filters the array to include only elements within the specified min and max limits. :param arr: List of integers to filter. :param min_lim: Optional; minimum limit (inclusive). :param max_lim: Optional; maximum limit (inclusive). :return: List of integers within the specified limits. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"# Binary Exponentiation Background Binary exponentiation is a method to quickly compute large powers of a number using the idea of divide-and-conquer. Rather than sequentially multiplying the base, it breaks the problem down exponentially, ensuring a logarithmic number of multiplications. For added utility, this method can also handle modular arithmetic to prevent overflow using large numbers. Problem Statement Implement a function `modular_exponentiation` that computes `a` raised to the power `n`, optionally taking a modulus `mod`. Your function should use an iterative approach similar to the provided `power` function. Function Signature ```python def modular_exponentiation(a: int, n: int, mod: int = None) -> int: pass ``` Input - `a` (integer): The base of the exponentiation. - `n` (integer): The exponent to which the base `a` is raised. - `mod` (integer, optional): The modulus to apply during the computation, if provided. Output - Return an integer representing `a` raised to the power `n`, optionally modulo `mod`. Constraints - You must use an iterative approach (not recursion). - The values of `a` and `n` will be such that 0 ≤ `a` ≤ 10^9 and 0 ≤ `n` ≤ 10^9. - If `mod` is provided, 1 ≤ `mod` ≤ 10^9. Example ```python assert modular_exponentiation(2, 10) == 1024 assert modular_exponentiation(2, 10, 1000) == 24 assert modular_exponentiation(3, 0) == 1 assert modular_exponentiation(5, 5, 13) == 8 ``` Explanation 1. `modular_exponentiation(2, 10)` returns `1024` because (2^{10} = 1024). 2. `modular_exponentiation(2, 10, 1000)` returns `24` because (2^{10} mod 1000 = 1024 mod 1000 = 24). 3. `modular_exponentiation(3, 0)` returns `1` due to the property that any number raised to `0` is `1`. 4. `modular_exponentiation(5, 5, 13)` returns `8` because (5^5 = 3125) and (3125 mod 13 = 8). Implement the function to meet the provided constraints and handle edge cases appropriately.","solution":"def modular_exponentiation(a: int, n: int, mod: int = None) -> int: Computes a raised to the power n using iterative binary exponentiation. If mod is provided, returns the result modulo mod. result = 1 # Initialize result base = a # The base we will be multiplying exponent = n if mod is not None: base = base % mod # Handle large base values while exponent > 0: if exponent % 2 == 1: # If exponent is odd result = result * base if mod is None else (result * base) % mod exponent = exponent // 2 # Divide exponent by 2 base = base * base if mod is None else (base * base) % mod return result"},{"question":"# Coding Challenge: As a software engineer, you\'ve been tasked with implementing a function to remove the minimum element from a stack. The stack is provided to you and you need to perform this operation adhering to the LIFO principle. **Function Specification**: - **Function Name**: `remove_min` - **Input**: A list representing a stack (e.g., `[2, 8, 3, -6, 7, 3]` where `2` is the bottom and `3` is the top). - **Output**: The same list representing the stack after removing the smallest element. **Constraints**: 1. The stack may contain up to `10^5` elements. 2. The stack may include negative and positive integers. 3. If the stack is empty, return the empty stack. 4. Maintain the order of remaining elements adhering to their original relative positions. # Example Given the stack: ``` bottom [2, 8, 3, -6, 7, 3] top ``` After calling `remove_min(stack)`, the updated stack should be: ``` bottom [2, 8, 3, 7, 3] top ``` # Requirements for Solution 1. **Edge Cases**: Handle empty stack and remove only one occurrence if multiple minimum values are present. 2. **Performance**: Ensure the function executes efficiently within the given constraints. Create the function `remove_min(stack)` that modifies the input stack by removing its minimum element. Avoid using any standard library functions that directly solve the problem.","solution":"def remove_min(stack): Removes the minimum element from the stack. :param stack: List representing the stack :return: The same stack with the smallest element removed if not stack: return stack min_value = min(stack) min_index = stack.index(min_value) # Remove the element at the found index stack.pop(min_index) return stack"},{"question":"# Question You are tasked with implementing a function that approximates the cube root of a given positive number using the Newton-Raphson method. This function should return a result with the specified precision. Requirements: 1. **Function Signature**: `def cube_root(n: float, epsilon: float = 0.001) -> float:` 2. **Input**: * `n` (float): a positive number whose cube root is to be calculated. * `epsilon` (float): a precision factor indicating the maximum allowable error from the actual cube root. Default is 0.001. 3. **Output**: * A float value which is an approximation of the cube root of `n` with an absolute error not exceeding `epsilon`. Constraints: * `n` is a positive float greater than or equal to 1.0. * `1e-10 ≤ epsilon ≤ 1e-1`. Performance Requirements: * The algorithm should converge efficiently for the given precision requirements. Scenario Consider an application where you need to quickly compute the volume of a large cube given its side length (which could be approximated), but the built-in cubic root function is unavailable due to hardware limitations. Your function should efficiently approximate the cube root to facilitate such calculations. Example ``` # Example 1: n = 27.0 epsilon = 0.001 Result: 2.999502909230548 # Example 2: n = 64.0 epsilon = 0.0001 Result: 3.999974349437587 ``` Write the function `cube_root` to achieve this.","solution":"def cube_root(n: float, epsilon: float = 0.001) -> float: Approximates the cube root of a given positive number using the Newton-Raphson method. guess = n / 2.0 while abs(guess**3 - n) > epsilon: guess = guess - (guess**3 - n) / (3 * guess**2) return guess"},{"question":"# Question You are given a list of integers and a maximum number of allowed occurrences for each element. Write a function `limit_occurrences` that constructs a new list by retaining each element only up to the given number of times, preserving the original order of the input list. Function Signature ```python def limit_occurrences(arr: List[int], max_occurrences: int) -> List[int]: pass ``` Input - `arr`: A list of integers `arr` where (0 leq text{len}(arr) leq 10^6). - `max_occurrences`: An integer (0 leq text{max_occurrences} leq 10^6); the maximum number of permitted occurrences for each element. Output - The function should return a list of integers from the input list, where each element appears at most `max_occurrences` times. Constraints - The function should run efficiently with a time complexity of (O(n)). - The function should use optimal space, keeping in mind the constraints. Examples ```python assert limit_occurrences([1,2,3,1,2,1,2,3], 2) == [1, 2, 3, 1, 2, 3] assert limit_occurrences([1,1,1,1,1], 1) == [1] assert limit_occurrences([], 2) == [] assert limit_occurrences([1,2,3], 0) == [] ``` Note 1. If `max_occurrences` is `0`, the returned list should be empty. 2. Handle edge cases such as an empty input list or very large lists efficiently.","solution":"from typing import List def limit_occurrences(arr: List[int], max_occurrences: int) -> List[int]: if max_occurrences == 0: return [] occurrence_count = {} result = [] for elem in arr: if elem not in occurrence_count: occurrence_count[elem] = 0 if occurrence_count[elem] < max_occurrences: result.append(elem) occurrence_count[elem] += 1 return result"},{"question":"Scenario You have been hired to implement a scheduling system that prioritizes tasks based on their urgency. Tasks with the highest urgency should be handled first. To achieve this, you will use a min heap data structure to maintain a dynamic list of tasks, allowing you to efficiently insert new tasks and retrieve the most urgent one. Task Your job is to complete the implementation of a `TaskScheduler` class, which will internally use a `BinaryHeap` to manage tasks. Each task has an associated urgency value. Requirements 1. Implement the `add_task` method to insert a task into the scheduler, maintaining the heap property. 2. Implement the `get_most_urgent_task` method to remove and return the task with the highest urgency (the smallest urgency value). 3. Ensure that your solution handles edge cases, such as attempting to get a task from an empty scheduler. Input and Output Formats **Method**: `add_task(task)` * **Input**: `task` (an integer urgency value) * **Output**: None **Method**: `get_most_urgent_task()` * **Input**: None * **Output**: `task` (the integer urgency value of the most urgent task, or `None` if there are no tasks) Constraints * Task urgency values are positive integers. * You may assume a maximum of 10^5 tasks at any time. * The methods should run efficiently given the constraints. ```python class TaskScheduler: def __init__(self): self.heap = BinaryHeap() def add_task(self, task): Add a new task to the scheduler. self.heap.insert(task) def get_most_urgent_task(self): Retrieve and remove the task with the highest urgency. if self.heap.current_size == 0: return None return self.heap.remove_min() ``` Your implementation should make use of the provided `BinaryHeap` class efficiently. Ensure correctness by considering possible edge cases and performance requirements.","solution":"class BinaryHeap: def __init__(self): self.heap_list = [0] self.current_size = 0 def insert(self, key): self.heap_list.append(key) self.current_size += 1 self._perc_up(self.current_size) def remove_min(self): if self.current_size == 0: return None root = self.heap_list[1] self.heap_list[1] = self.heap_list[self.current_size] self.heap_list.pop() self.current_size -= 1 self._perc_down(1) return root def _perc_up(self, i): while i // 2 > 0: if self.heap_list[i] < self.heap_list[i // 2]: self.heap_list[i], self.heap_list[i // 2] = self.heap_list[i // 2], self.heap_list[i] i = i // 2 def _perc_down(self, i): while (i * 2) <= self.current_size: mc = self._min_child(i) if self.heap_list[i] > self.heap_list[mc]: self.heap_list[i], self.heap_list[mc] = self.heap_list[mc], self.heap_list[i] i = mc def _min_child(self, i): if (i * 2 + 1) > self.current_size: return i * 2 else: if self.heap_list[i * 2] < self.heap_list[i * 2 + 1]: return i * 2 else: return i * 2 + 1 class TaskScheduler: def __init__(self): self.heap = BinaryHeap() def add_task(self, task): Add a new task to the scheduler. self.heap.insert(task) def get_most_urgent_task(self): Retrieve and remove the task with the highest urgency. return self.heap.remove_min()"},{"question":"You are required to implement the Zigzag Iterator to traverse two given lists in an alternating order. The iterator should return the elements of the first list and the second list in a zigzag manner until both lists are fully traversed. If one list is longer than the other, continue just with the remaining elements of the longer list once the shorter list is exhausted. # Function Signature: ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): pass def next(self) -> int: pass def has_next(self) -> bool: pass ``` # Constraints: * The input lists `v1` and `v2` can contain between (0) and (10^4) integer elements each. * Each element in `v1` and `v2` can be any integer within the range of ([-10^6, 10^6]). # Requirements: * Implement the Zigzag Iterator using the provided function signatures. * The `__init__` method initializes the iterator with two lists `v1` and `v2`. * The `next()` method should return the next element in the zigzag iteration. * The `has_next()` method should return `True` if there are more elements to iterate, and `False` otherwise. # Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` # Detailed Explanation: * **Initialization**: You are given two lists `v1` and `v2`. Initialize any internal data structures necessary to maintain the current state of the iterator. * **Next Method**: This method should return the next element in the zigzag sequence. * **Has Next Method**: This method should check whether any elements are left to iterate in either of the lists. Utilize the initial code snippet provided for reference but avoid direct dependency on it. Tailor the implementation to ensure correctness, efficiency, and adherence to given constraints.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): self.v1 = v1 self.v2 = v2 self.queue = [(len(v1), v1), (len(v2), v2)] self.ptr1, self.ptr2, self.turn = 0, 0, 0 def next(self) -> int: if self.ptr1 < len(self.v1) and (self.turn == 0 or self.ptr2 >= len(self.v2)): self.turn = 1 result = self.v1[self.ptr1] self.ptr1 += 1 else: self.turn = 0 result = self.v2[self.ptr2] self.ptr2 += 1 return result def has_next(self) -> bool: return self.ptr1 < len(self.v1) or self.ptr2 < len(self.v2)"},{"question":"# Context Merge Sort is a popular sorting algorithm known for its efficiency and simplicity. In this task, you are required to implement the Merge Sort algorithm to sort an array of integers in ascending order. # Problem Statement You need to implement the following functions: 1. `merge_sort(arr)`: which takes an array of integers and returns it sorted in ascending order. 2. `merge(left, right, merged)`: which merges two sorted arrays (`left` and `right`) into an array `merged`. # Detailed Instructions: Function 1: merge_sort(arr) * **Input**: - `arr` (list[int]): A list of integers. * **Output**: - A sorted list of integers. Function 2: merge(left, right, merged) * **Input**: - `left` (list[int]): A sorted list of integers. - `right` (list[int]): A sorted list of integers. - `merged` (list[int]): An empty list which will store the merged result of `left` and `right`. * **Output**: None (The result should be stored in `merged`). # Constraints: - You must implement these functions using recursion. - You must handle the case for edge inputs like empty lists or lists with a single element. - Your solution should be efficient with a time complexity of O(n log(n)) and space complexity of O(n). # Example: ```python arr = [38, 27, 43, 3, 9, 82, 10] print(merge_sort(arr)) # Output: [3, 9, 10, 27, 38, 43, 82] arr = [17, 3, 44, 25, 1] print(merge_sort(arr)) # Output: [1, 3, 17, 25, 44] arr = [] print(merge_sort(arr)) # Output: [] arr = [1] print(merge_sort(arr)) # Output: [1] ``` Your solution should demonstrate your understanding of the Merge Sort algorithm and correctly handle all edge cases. Validate your solution with the given example test cases.","solution":"def merge_sort(arr): Sorts the array using the merge sort algorithm. if len(arr) <= 1: return arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) merged = [] merge(left_half, right_half, merged) return merged def merge(left, right, merged): Merges two sorted arrays into a single sorted array. i = j = 0 while i < len(left) and j < len(right): if left[i] <= right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 while i < len(left): merged.append(left[i]) i += 1 while j < len(right): merged.append(right[j]) j += 1"},{"question":"# Scenario A software application requires efficient string manipulation functions. As a part of this application, you are required to implement a function that can reverse a string. Your solution must balance between performance and readability. # Task Write a function `reverse_string(s: str) -> str` that takes a string `s` and returns its reverse. Optimize for both performance and readability. # Requirements 1. **Input**: A string `s` (0 <= len(s) <= 10^6). 2. **Output**: A string that is the reverse of `s`. # Constraints - Avoid using excessive memory. - Consider different methods for achieving this and choose an optimal approach. - Handle edge cases like empty strings and single-character strings gracefully. # Example ```python # Given: s = \\"hello\\" # You should return: \\"olleh\\" # Given: s = \\"\\" # You should return: \\"\\" # Given: s = \\"a\\" # You should return: \\"a\\" ``` # Notes - Implement the solution using the most appropriate method based on the analysis provided.","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string s. return s[::-1]"},{"question":"# Filtering Array within Boundaries You are given an array of integers and two optional integer bounds: a minimum and a maximum. Your task is to implement a function `filter_within_bounds(arr, min_lim=None, max_lim=None)` that returns a new list containing elements from the input list that fall within these bounds, inclusive of the boundaries. - If a boundary is not provided, you should consider the unbound limit for that side of the range. - If both boundaries are provided, include only the elements that lie within or exactly at these bounds. Function Signature ```python def filter_within_bounds(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` Input * `arr`: List of integers (1 <= len(arr) <= 10^6); array of integers to be filtered. * `min_lim`: Optional integer; minimum boundary (inclusive). * `max_lim`: Optional integer; maximum boundary (inclusive). Output * List of integers containing the values of `arr` that lie between the provided boundaries inclusive. Example ```python filter_within_bounds([2, 8, 5, 4, 7], None, 5) -> [2, 5, 4] filter_within_bounds([2, 8, 5, 4, 7], 3, 7) -> [5, 4, 7] filter_within_bounds([2, 8, 5, 4, 7], 2, 10) -> [2, 8, 5, 4, 7] filter_within_bounds([2, 8, 5, 4, 7], None, None) -> [2, 8, 5, 4, 7] filter_within_bounds([2, 8, 5, 4, 7], 3, None) -> [8, 5, 4, 7] filter_within_bounds([], 1, 5) -> [] ``` Constraints * Implement the function to run efficiently for large input arrays up to 1 million elements.","solution":"from typing import List, Optional def filter_within_bounds(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Returns a list containing elements from arr that are between min_lim and max_lim inclusive. If min_lim or max_lim is not provided, treats that boundary as unbounded. return [x for x in arr if (min_lim is None or x >= min_lim) and (max_lim is None or x <= max_lim)]"},{"question":"# Inverse Matrix Finder You are tasked with implementing a function that finds the inverse of a given n x n invertible matrix. The matrix will be represented as a list of lists, where each inner list represents a row of the matrix. # Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` # Input - `matrix`: A list of `n` lists, each containing `n` float numbers representing the elements of the matrix. It is guaranteed that the matrix is invertible (i.e., its determinant is non-zero). # Output - Returns a list of `n` lists, each containing `n` floats, representing the inverse of the input matrix. - If the input matrix is not squared or is singular (determinant = 0), return `[[error_code]]` where `error_code` is -1, -2, or -4 respectively for invalid, non-square, and singular matrices. # Constraints - `2 <= n <= 10` # Examples ```python matrix = [ [4, 7], [2, 6] ] # The inverse of the matrix should be: # [ # [0.6, -0.7], # [-0.2, 0.4] # ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] ``` # Notes 1. Your solution should not use any external libraries like numpy. 2. You need to handle basic validation to check if the provided matrix is square and its determinant is non-zero. 3. Consider edge cases such as very small matrices (e.g., 2x2) as special implementations might be required. # Performance Considerations - The function should efficiently handle the given constraints; however, it’s acceptable for the function to be slower for upper bounds (i.e., close to n = 10) due to the cubic time complexity. # Implementation Details 1. Implement a helper function `get_determinant` to compute the determinant of the matrix. 2. Implement a helper function `get_matrix_of_minors` for creating the matrix of minors. 3. Implement a helper function `get_minor` that calculates the minor of an element. 4. Implement a helper function `transpose_and_multiply` to transpose and multiply the matrix by the determinant reciprocal. Write the `invert_matrix` function based on these helper functions to combine steps and minimize redundant computations.","solution":"from typing import List def get_determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] # Base case for 2x2 matrix if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1)**c) * matrix[0][c] * get_determinant(get_minor(matrix, 0, c)) return determinant def get_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j + 1:] for row in (matrix[:i] + matrix[i + 1:])] def get_matrix_of_minors(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) minors_matrix = [] for i in range(n): minors_row = [] for j in range(n): minor = get_minor(matrix, i, j) minors_row.append(get_determinant(minor)) minors_matrix.append(minors_row) return minors_matrix def transpose_and_multiply(matrix: List[List[float]], factor: float) -> List[List[float]]: n = len(matrix) transposed_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): transposed_matrix[i][j] = matrix[j][i] * factor return transposed_matrix def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) # Check if the matrix is square if any(len(row) != n for row in matrix): return [[-2]] # Non-square matrix error code determinant = get_determinant(matrix) if determinant == 0: return [[-4]] # Singular matrix error code # Get matrix of minors minors = get_matrix_of_minors(matrix) # Convert to cofactor matrix cofactors = [] for i in range(n): cofactor_row = [] for j in range(n): sign = (-1) ** (i + j) cofactor_row.append(minors[i][j] * sign) cofactors.append(cofactor_row) # Transpose the cofactor matrix and multiply by 1/determinant adjugate = transpose_and_multiply(cofactors, 1 / determinant) return adjugate"},{"question":"Context You are hired as a developer at a technology company to optimize their task scheduling system. They are currently using a linked list-based queue which works well but takes up more memory due to the need for managing pointers. You are tasked with implementing a memory-efficient Queue using a circular array that avoids the need for dynamic resizing. Task Implement a `CircularArrayQueue` that efficiently uses memory and supports constant-time `enqueue`, `dequeue`, and `peek` operations. Your implementation should inherit from the provided `AbstractQueue` base class. Function Definitions 1. **`__init__(self, capacity: int = 10)`**: Initializes the queue with a given capacity. 2. **`enqueue(self, value)`**: Adds a new item to the rear of the queue. 3. **`dequeue(self)`**: Removes and returns the front item from the queue. 4. **`peek(self)`**: Returns the front element without removing it. 5. **`__iter__(self)`**: Iterates over the queue elements from front to rear. Constraints - **Capacity**: You need to handle at most 10^5 elements. - **Performance**: The operations should run in O(1) time. - **Space**: The solution should be space-efficient and not overly allocate memory. ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): Initialize with a given capacity. super().__init__() self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 def __iter__(self): probe = self._front while self._size > 0: yield self._array[probe] probe = (probe + 1) % self._capacity def enqueue(self, value): if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] ``` Evaluate your code against the stated constraints and test it thoroughly to ensure it meets efficiency requirements.","solution":"class CircularArrayQueue: def __init__(self, capacity=10): Initialize with a given capacity. self._array = [None] * capacity self._capacity = capacity self._front = 0 self._rear = 0 self._size = 0 def __iter__(self): Iterate over the queue elements from front to rear. index = self._front num_elements = self._size while num_elements > 0: yield self._array[index] index = (index + 1) % self._capacity num_elements -= 1 def enqueue(self, value): Adds a new item to the rear of the queue. if self._size == self._capacity: raise OverflowError(\\"Queue is full\\") self._array[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): Removes and returns the front item from the queue. if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._array[self._front] self._array[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): Returns the front element without removing it. if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._array[self._front] def is_empty(self): Checks if the queue is empty. return self._size == 0 def size(self): Returns the number of items in the queue. return self._size"},{"question":"# Diffie-Hellman Key Exchange with Enhanced Verification In the field of secure communications, the Diffie-Hellman key exchange method allows two parties to share a common secret key over a non-secure channel. Your task is to implement a function that performs the key exchange process while ensuring all prerequisites of Diffie-Hellman are met robustly, and provides detailed information about each step of the computation. Function Signature ```python def diffie_hellman_key_exchange_enhanced(a: int, p: int, validate: bool = True) -> bool: Perform Diffie-Hellman key exchange with enhanced verification. Args: a (int): A primitive root of prime number p. p (int): A large prime number. validate (bool): If True, perform validation of inputs and verbose output of steps. Returns: bool: True if key exchange is successful and shared keys match, otherwise False. ``` # Input and Output - **Input**: - `a` is expected to be a primitive root of the prime number `p`. - `p` should be a large prime number. - `validate` is a boolean flag that, when set to True, will ensure verbose validation and step-by-step demonstration. - **Output**: - The function should return `True` if the exchange is successful and both parties compute the same shared secret key. - It should return `False` otherwise. # Constraints - `p` should be a reasonably large prime number greater than 1. - `a` should be a valid primitive root of `p`. # Implementation Notes 1. **Validation**: - Confirm if `p` is prime. If not, return `False`. - Ensure `a` is a primitive root of `p`. If not, return `False`. 2. **Verbose Steps**: - If `validate` is `True`, print detailed steps including private keys of both parties, their public keys, and the shared secret keys calculated by both. 3. **Core Algorithm**: - Generate private keys for Alice and Bob. - Compute their corresponding public keys. - Exchange the public keys (simulated in function). - Compute the shared secret keys for Alice and Bob and compare. # Example Usage ```python result = diffie_hellman_key_exchange_enhanced(5, 23, validate=True) assert result == True # Example scenario assuming 5 as a valid primitive root of 23. ``` Implement this function ensuring thorough validation and detailed output when requested.","solution":"from sympy import isprime, primitive_root def diffie_hellman_key_exchange_enhanced(a: int, p: int, validate: bool = True) -> bool: Perform Diffie-Hellman key exchange with enhanced verification. Args: a (int): A primitive root of prime number p. p (int): A large prime number. validate (bool): If True, perform validation of inputs and verbose output of steps. Returns: bool: True if key exchange is successful and shared keys match, otherwise False. # Helper function to generate the public key def generate_public_key(base, private_key, prime_modulus): return pow(base, private_key, prime_modulus) # Helper function to generate the shared secret key def generate_shared_secret(public_key, private_key, prime_modulus): return pow(public_key, private_key, prime_modulus) if validate: if not isprime(p): print(\\"p is not a prime number.\\") return False if primitive_root(p) != a: print(\\"a is not a primitive root of p.\\") return False # Simulated private keys for Alice and Bob alice_private_key = 6 # This should normally be randomly generated bob_private_key = 15 # This should normally be randomly generated # Generate public keys alice_public_key = generate_public_key(a, alice_private_key, p) bob_public_key = generate_public_key(a, bob_private_key, p) if validate: print(f\\"Private Key Alice: {alice_private_key}\\") print(f\\"Private Key Bob: {bob_private_key}\\") print(f\\"Public Key Alice: {alice_public_key}\\") print(f\\"Public Key Bob: {bob_public_key}\\") # Generate shared secret keys alice_shared_secret = generate_shared_secret(bob_public_key, alice_private_key, p) bob_shared_secret = generate_shared_secret(alice_public_key, bob_private_key, p) if validate: print(f\\"Shared Secret Key Alice: {alice_shared_secret}\\") print(f\\"Shared Secret Key Bob: {bob_shared_secret}\\") # Successful key exchange if shared secrets match return alice_shared_secret == bob_shared_secret"},{"question":"# Question: Implement Advanced Modular Arithmetic using Binary Exponentiation You are tasked with implementing a function that efficiently computes a **modular inverse** given two integers, `a` and `m`, where `m` is a prime number. The modular inverse is defined such that ( a times a^{-1} equiv 1 mod m ). Constraints: * (1 leq a < m leq 10^9) * `m` is guaranteed to be a prime number. # Input Two integers, `a` and `m`. # Output Return the modular inverse of `a` modulo `m`. If a modular inverse does not exist, return -1. # Requirements 1. Your function should account for large values efficiently. 2. Apply the properties of binary exponentiation and Fermat\'s Little Theorem, which states: For a prime number `m`, (a^{m-1} equiv 1 mod m). Therefore, (a^{m-2} mod m) is the modular inverse of `a`. Expected Function Signature ```python def modular_inverse(a: int, m: int) -> int: pass ``` # Example ```python assert modular_inverse(3, 11) == 4 # Because 3*4 % 11 == 1 assert modular_inverse(10, 17) == 12 # Because 10*12 % 17 == 1 assert modular_inverse(13, 19) == 3 # Because 13*3 % 19 == 1 ``` # Notes * Ensure accurate handling of large numbers and edge cases. * You cannot use Python\'s built-in `pow` function or similar functions for this task; implement the necessary logic yourself. * Binary exponentiation should be used to solve this problem efficiently.","solution":"def modular_inverse(a: int, m: int) -> int: Returns the modular inverse of a modulo m using binary exponentiation. If no modular inverse exists, return -1. Assumes that m is a prime number. def binary_exponentiation(base, exp, mod): Performs binary exponentiation of base raised to the power exp modulo mod. result = 1 base = base % mod while exp > 0: if (exp % 2) == 1: # If exp is odd, multiply base with the result result = (result * base) % mod exp = exp >> 1 # Divide the exponent by 2 base = (base * base) % mod # Square the base return result # Using Fermat\'s Little Theorem to calculate the modular inverse # a^(-1) % m = a^(m-2) % m, since m is a prime number if a == 0: return -1 # Inverse does not exist for a = 0 return binary_exponentiation(a, m - 2, m)"},{"question":"# Problem Description You have been provided with a utility function that splits a file path into two parts: the directory part and the file name part. The function utilizes the `rpartition` method, which works well with the `/` separator. However, you need to enhance this function to handle paths with different directory separators, including both `/` and ``, and ensure it works correctly for all edge cases. # Requirements 1. **Function Signature**: Implement the function `def split_advanced(path: str) -> [str, str]:` 2. **Input**: A string `path` that represents the file path. The path may include either `/` or `` as directory separators. 3. **Output**: A list of two strings: - The directory part. - The file name part. # Specifications 1. If no directory separator is present, the directory part should be an empty string, and the entire path should be returned as the file name. 2. Handle corner cases such as empty strings appropriately. # Examples ```python # Example 1 input_path = \\"https://algorithms/unix/test.py\\" expected_output = [\\"https://algorithms/unix\\", \\"test.py\\"] assert split_advanced(input_path) == expected_output # Example 2 input_path = \\"algorithmsunixtest.py\\" expected_output = [\\"algorithmsunix\\", \\"test.py\\"] assert split_advanced(input_path) == expected_output # Example 3 input_path = \\"test.py\\" expected_output = [\\"\\", \\"test.py\\"] assert split_advanced(input_path) == expected_output # Example 4 input_path = \\"\\" expected_output = [\\"\\", \\"\\"] assert split_advanced(input_path) == expected_output ``` # Constraints 1. The input path string will be a valid string containing characters printable in UTF-8. 2. The function should handle both forward slash `/` and backslash `` as separators. # Objective Modify the given snippet to handle the specified constraints and test the function with various inputs to ensure correctness.","solution":"def split_advanced(path: str) -> [str, str]: Splits the path into directory part and file name part, handling both \'/\' and \'\' as separators. Parameters: path (str): The path to be split. Returns: list: A list containing the directory part and the file name part. if not path: return [\\"\\", \\"\\"] # Handling both \'/\' and \'\' as directory separators separators = [\'/\', \'\'] max_index = -1 for sep in separators: index = path.rfind(sep) if index > max_index: max_index = index # If no separator is found if max_index == -1: return [\\"\\", path] # Splitting using the last occurrence of the chosen separator dir_part = path[:max_index] file_part = path[max_index + 1:] return [dir_part, file_part]"},{"question":"# Question You are given two non-negative integers, `a` and `b`. Your task is to write a function `add_without_plus` that adds these two integers without using the \'+\' operator or any other arithmetic operators (like \'-\', \'*\', \'/\', etc.). The function should utilize bitwise operations to achieve the addition. Function Signature ```python def add_without_plus(a: int, b: int) -> int: pass ``` Input * Two non-negative integers `a` and `b` where `0 <= a, b <= 10^9`. Output * An integer which is the sum of `a` and `b`. Example ```python assert add_without_plus(2, 3) == 5 assert add_without_plus(0, 0) == 0 assert add_without_plus(123, 456) == 579 ``` Constraints * You are **not allowed to use** any arithmetic operators such as `+`, `-`, `*`, or `/`. * You must utilize bitwise operations (`&`, `|`, `^`, `<<`, `>>`).","solution":"def add_without_plus(a: int, b: int) -> int: Adds two non-negative integers a and b without using the \'+\' operator or any other arithmetic operators by using bitwise operations. while b != 0: carry = a & b a = a ^ b b = carry << 1 return a"},{"question":"# Inorder Traversal with Additional Twist **Scenario**: You are working with a binary tree and need to perform an inorder traversal. However, during the traversal, you realize an additional requirement where nodes need to store a pointer to their parent. Implement an **inorder traversal** function for a binary tree where each node has an additional pointer to its parent. Ensure your function returns both the result list of the inorder traversal and reassigns the parent pointers during the traversal. Function Signature ```python def inorder_with_parents(root: Node) -> List[int]: Perform an inorder traversal on the binary tree, updating parent pointers and returning the list of node values in inorder sequence. pass ``` Input - `root`: The root node of the binary tree (Node). Output - List of integers representing the node values in order of an inorder traversal. Node Class ```python class Node: def __init__(self, val, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent ``` Constraints * The tree nodes contain unique integer values. * The parent pointer should be updated as you traverse the tree in an inorder fashion. Example Input: ```python n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_with_parents(n1) == [25, 50, 75, 100, 125, 150, 175] assert n2.parent == n1 assert n3.parent == n1 assert n4.parent == n2 assert n5.parent == n2 assert n6.parent == n3 assert n7.parent == n3 ```","solution":"class Node: def __init__(self, val, left=None, right=None, parent=None): self.val = val self.left = left self.right = right self.parent = parent def inorder_with_parents(root: Node) -> list: result = [] def inorder_traverse(node, parent): if not node: return node.parent = parent inorder_traverse(node.left, node) result.append(node.val) inorder_traverse(node.right, node) inorder_traverse(root, None) return result"},{"question":"You are tasked with implementing the Pigeonhole Sort algorithm from scratch. This specific algorithm is ideal for sorting integers where the number of elements is close to the range of possible key values. Given a list of integers, your goal is to sort the list using the Pigeonhole Sort. # Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: Sorts a list of integers using the Pigeonhole Sort algorithm. Parameters: arr (List[int]): The list of integers to be sorted. Returns: List[int]: The sorted list. ``` # Input - A list of integers `arr` where 1 <= len(arr) <= 10^6 and -10^6 <= arr[i] <= 10^6. # Output - A list of integers sorted in non-decreasing order. # Constraints - Your implementation should run in O(n + Range) time complexity and O(Range) space complexity. # Example: Example 1 ```python arr = [8, 3, 2, 7, 4, 6, 8] print(pigeonhole_sort(arr)) # Output: [2, 3, 4, 6, 7, 8, 8] ``` Example 2 ```python arr = [1] print(pigeonhole_sort(arr)) # Output: [1] ``` Example 3 ```python arr = [] print(pigeonhole_sort(arr)) # Output: [] ``` # Notes - Handle empty input gracefully. - Ensure that your solution adequately addresses all edge cases such as arrays with all identical elements. - Consider the space efficiency of your solution, especially for large ranges.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 pigeonholes = [0] * size for num in arr: pigeonholes[num - min_val] += 1 sorted_arr = [] for i in range(size): while pigeonholes[i] > 0: sorted_arr.append(i + min_val) pigeonholes[i] -= 1 return sorted_arr"},{"question":"# Question You have been hired by a company that deals with processing and comparing text data. As part of their functionality, they need to determine how similar two pieces of text are by calculating the edit distance between them. You are required to implement a function `optimized_edit_distance` that computes the edit distance between two given strings. They have provided you with an initial implementation that uses O(length_a * length_b) space, but given the large size of text they process, you need to optimize this to use O(min(length_a, length_b)) space. # Task Write a function `optimized_edit_distance(word_a: str, word_b: str) -> int` that computes the edit distance between two strings `word_a` and `word_b` using O(min(length_a, length_b)) space. Input: - `word_a` (str): The first word. - `word_b` (str): The second word. Output: - (int): The edit distance between `word_a` and `word_b`. # Constraints * 0 ≤ length of `word_a`, `word_b` ≤ 10^4 * The input strings will consist only of lowercase alphabetic characters. # Example: ```python assert optimized_edit_distance(\\"food\\", \\"money\\") == 4 assert optimized_edit_distance(\\"\\", \\"\\") == 0 assert optimized_edit_distance(\\"abcdefgh\\", \\"abcdefg\\") == 1 assert optimized_edit_distance(\\"kitten\\", \\"sitting\\") == 3 ``` Your implementation should be efficient in terms of space, maintaining O(min(length_a, length_b)) complexity. Make sure to handle edge cases such as empty strings correctly.","solution":"def optimized_edit_distance(word_a, word_b): Returns the edit distance between word_a and word_b using O(min(len(word_a), len(word_b))) space. len_a, len_b = len(word_a), len(word_b) if len_a == 0: return len_b if len_b == 0: return len_a if len_a < len_b: word_a, word_b = word_b, word_a len_a, len_b = len_b, len_a previous_row = list(range(len_b + 1)) for i in range(1, len_a + 1): current_row = [i] + [0] * len_b for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: cost = 0 else: cost = 1 current_row[j] = min( current_row[j - 1] + 1, previous_row[j] + 1, previous_row[j - 1] + cost ) previous_row = current_row return previous_row[-1]"},{"question":"You are provided with a list of integers and two optional numeric bounds, `min_lim` and `max_lim`. Your task is to write a function `filter_in_range` that returns a new list containing only the elements of the input list that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Function Signature ```python def filter_in_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` # Input - `arr` (List[int]): The input list of integers. It is guaranteed to contain at least one element. - `min_lim` (int, optional): The minimum bound (inclusive). If not specified, use the smallest element in the list. - `max_lim` (int, optional): The maximum bound (inclusive). If not specified, use the largest element in the list. # Output - Returns a new list containing elements from `arr` that are in the range [min_lim, max_lim]. # Constraints - The list `arr` will have at most 10^6 elements. - Each element in `arr` will be an integer within the range [-10^6, 10^6]. - The algorithm should run in O(n) time. # Examples ```python assert filter_in_range([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filter_in_range([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert filter_in_range([1, 2, 3, 4, 5], 3, None) == [3, 4, 5] assert filter_in_range([1, 2, 3, 4, 5], None, None) == [1, 2, 3, 4, 5] assert filter_in_range([], 1, 5) == [] ``` # Note - Be sure to handle edge cases such as empty lists and None values for `min_lim` or `max_lim`. # Contextual Scenario Imagine you are working with sensor data that provides a large array of integer values representing measurements. You need to focus only on data points within a specific range of interest to ensure accurate and relevant analysis. This function will help you filter out irrelevant data efficiently, considering the constraints and requirements mentioned above.","solution":"from typing import List, Optional def filter_in_range(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: if not arr: return [] # Determine effective min and max limits if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) # Filter the list based on the determined limits return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"**Objective**: Implement a function to merge k sorted linked lists into one sorted linked list, demonstrating comprehension of heap data structures. Given `k` sorted linked lists, you are required to merge them into a single sorted list while maintaining the sorted order. Function Signature ```python def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ``` Input * `lists`: A list of k sorted linked lists, where each list is represented as a linked list node (`ListNode`). Output * Return the head of the merged sorted linked list. Example ```python Input: lists = [ 1 -> 4 -> 5, 1 -> 3 -> 4, 2 -> 6 ] Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 ``` Constraints 1. The total number of nodes across all linked lists will not exceed `10^4`. 2. ListNode is defined as: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Performance Requirements * The solution should run in O(N log k) time and use O(k) space for the heap operations. Implementation Steps 1. Utilize a min-heap (or priority queue) to keep track of the smallest elements among the k linked lists. 2. Maintain a dummy node to build the result merged list. 3. Iterate until the heap is empty, continuously extracting the smallest node and pushing its next node into the heap. 4. Return the merged linked list starting from the dummy node\'s next. Good luck!","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __lt__(self, other): # This is necessary for the priority queue to compare ListNodes return self.val < other.val def merge_k_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] # Initialize the heap for head in lists: if head: heapq.heappush(min_heap, head) dummy = ListNode() current = dummy # Extract the smallest element from the heap and add to the result list while min_heap: smallest_node = heapq.heappop(min_heap) current.next = smallest_node current = current.next if smallest_node.next: heapq.heappush(min_heap, smallest_node.next) return dummy.next"},{"question":"# Bubble Sort Assessment Question Scenario You are working on an educational tool to teach sorting algorithms. Your task is to implement the Bubble Sort algorithm to sort a list of integers in ascending order. Additionally, you need to simulate and print each step of the sorting process if the `simulation` parameter is set to `True`. Function Signature ```python def bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` Input 1. `arr` - a list of integers (1 <= len(arr) <= 1000) 2. `simulation` - a boolean flag indicating whether to print the simulation of each sorting step (default is False) Output - Returns the sorted list of integers. Constraints - The list may contain both positive and negative integers. - You should not use any built-in Python sorting functions or libraries. - The function should handle edge cases effectively, such as empty lists or lists with one element. - Efficiency is important, but for this exercise, we prioritize correct implementation over optimal performance on large inputs. Performance Requirements - The code must handle the input size within the given constraints without running into performance issues. Example ```python assert bubble_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert bubble_sort([1, 2, 3, 4]) == [1, 2, 3, 4] assert bubble_sort([], True) == [] assert bubble_sort([-1, -3, -2, 5, 6]) == [-3, -2, -1, 5, 6] ``` Implementation Example Implement the Bubble Sort function considering the `simulation` parameter: ```python def bubble_sort(arr, simulation=False): def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True iteration = 0 if simulation: print(\\"iteration\\", iteration, \\":\\", *arr) x = -1 while swapped: swapped = False x += 1 for i in range(1, n-x): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True if simulation: iteration += 1 print(\\"iteration\\", iteration, \\":\\", *arr) return arr ```","solution":"from typing import List def bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: Perform Bubble Sort on a list of integers. Args: arr: List[int] - a list of integers to be sorted simulation: bool - a flag indicating if each step should be printed Returns: List[int] - the sorted list of integers n = len(arr) if n <= 1: return arr # No sorting needed for empty or single element list def swap(i, j): arr[i], arr[j] = arr[j], arr[i] if simulation: print(f\\"initial: {arr}\\") for x in range(n): swapped = False for i in range(1, n - x): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True if simulation: print(f\\"iteration {x + 1}, step {i}: {arr}\\") if not swapped: break return arr"},{"question":"You are tasked with designing a new feature for a combinatorics-driven application. The feature involves generating all possible permutations of a list of distinct numbers. Considering efficiency and readability, ensure your implementation can handle reasonably sized input lists efficiently. Problem Statement Given a collection of distinct numbers, return all permutations using a recursive backtracking method. The function should return the complete list of permutations. Function Signature ```python def generate_permutations(nums: List[int]) -> List[List[int]]: ``` Input - `nums`: A list of distinct integers, where 1 <= len(nums) <= 8. Output - Returns a list of lists, where each inner list is a unique permutation of the input list. Constraints - The function should use a recursive approach. - Consider edge cases as outlined in the analysis. - Handle up to len(nums) = 8 efficiently. Example ```python assert generate_permutations([1,2,3]) == [ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ] ``` Requirements - Implement a solution using the recursive backtracking approach. - Carefully manage recursion depth and memory usage.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Generates all permutations of a list of distinct numbers using recursive backtracking. def backtrack(start, end): if start == end: permutations.append(nums[:]) for i in range(start, end): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1, end) nums[start], nums[i] = nums[i], nums[start] permutations = [] backtrack(0, len(nums)) return permutations"},{"question":"# Question: Markov Chain Simulation **Context**: You are building a simulation for a simplistic weather prediction model using a Markov Chain. The states of weather are described using a dictionary where the keys represent states (e.g., \'Sunny\', \'Rainy\') and the values are another dictionary mapping potential next states with their associated probabilities. For instance: ```python weather_chain = { \'Sunny\': {\'Sunny\': 0.8, \'Rainy\': 0.2}, \'Rainy\': {\'Sunny\': 0.4, \'Rainy\': 0.6} } ``` **Task**: Write a function to simulate the weather for a specified number of days starting from a given initial state using the provided Markov Chain. **Function Signature**: ```python def simulate_weather(chain: dict, initial_state: str, days: int) -> list: Simulate weather for a given number of days starting from an initial state. :param chain: Dictionary representing weather state transitions. :param initial_state: Starting weather state. :param days: Number of days to simulate. :return: List representing the sequence of weather states. pass ``` **Input/Output**: - **Input**: - `chain`: A dictionary representing the Markov Chain transitions. - `initial_state`: A string representing the starting state. - `days`: An integer representing the number of days to simulate. - **Output**: - Returns a list of length `days`, representing the sequence of weather states. **Example**: ```python chain = { \'Sunny\': {\'Sunny\': 0.8, \'Rainy\': 0.2}, \'Rainy\': {\'Sunny\': 0.4, \'Rainy\': 0.6} } simulate_weather(chain, \'Sunny\', 5) # Example Output: [\'Sunny\', \'Sunny\', \'Rainy\', \'Sunny\', \'Sunny\'] # (Note: The output sequence may vary due to randomness in the transitions) ``` **Constraints**: * Ensure the probabilities for state transitions sum up to 1. * The input chain dictionary will always have valid states and transitions. * The number of days (days) is a non-negative integer (0 ≤ days ≤ 100). **Implementation Notes**: - Utilize the provided functions `__choose_state` and `next_state`. - Ensure to handle edge cases such as zero days simulation correctly.","solution":"import random def simulate_weather(chain: dict, initial_state: str, days: int) -> list: def choose_state(current_state, transition_dict): Helper function to choose the next state based on the transition probabilities. states, probabilities = zip(*transition_dict.items()) return random.choices(states, probabilities)[0] sequence = [] current_state = initial_state for _ in range(days): sequence.append(current_state) current_state = choose_state(current_state, chain[current_state]) return sequence"},{"question":"**Description**: You are given a non-negative number represented as an array of digits. Write a function that increments the number by one and returns the resulting array of digits. The digits are stored in big-endian format (most significant digit first), and each array element contains a single digit (0-9). You should return the result as another array of digits. **Function Signature**: ```python def increment_digits(digits: List[int]) -> List[int]: ``` **Input**: - `digits` (List[int]): A list of integers representing the number to increment. Each integer `d` in `digits` satisfies 0 <= d <= 9. The input array will not be empty. **Output**: - List[int]: The resulting array of digits after incrementing the original number by one. **Constraints**: - Do not use any libraries or built-in functions related to big integers. - Handle the carry appropriately. **Example**: ```python >>> increment_digits([1, 2, 3]) [1, 2, 4] >>> increment_digits([9, 9, 9]) [1, 0, 0, 0] >>> increment_digits([0]) [1] ``` **Performance Requirements**: - The solution should operate in O(n) time complexity. - Minimize additional space usage, ideally O(1) extra space.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Increment the given array of digits by one and return the resulting array of digits. n = len(digits) # Traverse from the end of the list to the beginning for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we\'ve gone through all digits and all were 9, we prepend a 1 at the start return [1] + [0] * n"},{"question":"**Question**: You are given the function definition for checking if two strings `s` and `t` are isomorphic. You need to implement this function to demonstrate your understanding of character mapping and order preservation in strings. # Function Specification: ```python def is_isomorphic(s: str, t: str) -> bool: Determines if strings s and t are isomorphic. :param s: The first input string. :param t: The second input string. :return: True if the strings are isomorphic, False otherwise. ``` # Input and Output: * `s`: A string containing only printable ASCII characters (0 <= len(s) <= 10^4). * `t`: A string containing only printable ASCII characters (0 <= len(t) <= 10^4). Your function should return a boolean value: * `True` if the input strings `s` and `t` are isomorphic. * `False` otherwise. # Constraints: * Both strings should map each character from `s` to `t` only once. * Characters from `s` should map to unique characters in `t`. * The character order must be preserved. # Examples: 1. `is_isomorphic(\\"egg\\", \\"add\\")` should return `True`. 2. `is_isomorphic(\\"foo\\", \\"bar\\")` should return `False`. 3. `is_isomorphic(\\"paper\\", \\"title\\")` should return `True`. # Explanation: 1. In the first example, \'e\' -> \'a\', \'g\' -> \'d\'. All characters are mapped uniquely, and the order is preserved. 2. In the second example, \'f\' -> \'b\', \'o\' -> \'a\', but the second \'o\' in `foo` cannot map to \'r\' because \'o\' should map to \'a\'. 3. In the third example, \'p\' -> \'t\', \'a\' -> \'i\', \'e\' -> \'l\', \'r\' -> \'e\', mapping is maintained, and they are isomorphic. Implement the function to check the isomorphism of two strings.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False s_to_t = {} t_to_s = {} for char_s, char_t in zip(s, t): if char_s in s_to_t and s_to_t[char_s] != char_t: return False if char_t in t_to_s and t_to_s[char_t] != char_s: return False s_to_t[char_s] = char_t t_to_s[char_t] = char_s return True"},{"question":"You are given a matrix (A) of size (n times n) where (n) is an integer. You need to compute the power of the matrix (A^p) where (p) is also an integer. The matrix exponentiation should be performed using efficient algorithms instead of direct multiplication to ensure better performance. # Tasks: 1. Implement the following functions: - `multiply(matA: List[List[int]], matB: List[List[int]]) -> List[List[int]]` - `identity(n: int) -> List[List[int]]` - `matrix_exponentiation(mat: List[List[int]], p: int) -> List[List[int]]` # Function Specifications: Function 1: multiply - **Input**: Two (n times n) square matrices `matA` and `matB`. - **Output**: Their product as another (n times n) matrix. - **Example**: ```python multiply([[1, 2], [3, 4]], [[5, 6], [7, 8]]) returns [[19, 22], [43, 50]] ``` Function 2: identity - **Input**: An integer `n`. - **Output**: The identity matrix of size (n times n). - **Example**: ```python identity(3) returns [[1, 0, 0], [0, 1, 0], [0, 0, 1]] ``` Function 3: matrix_exponentiation - **Input**: A square matrix `mat` and an integer `p` (power). - **Output**: The matrix `mat` raised to power `p`. - **Example**: ```python matrix_exponentiation([[1, 1], [1, 0]], 5) returns [[8, 5], [5, 3]] ``` # Constraints: - (1 le n le 100) - (0 le p le 10^9) - Matrix elements are integers in the range ([-10^9, 10^9]) # Performance Requirements: - The function must handle large power values efficiently with a time complexity of (O(d^3 log(p))), where (d) is the dimension of the square matrix.","solution":"from typing import List def multiply(matA: List[List[int]], matB: List[List[int]]) -> List[List[int]]: n = len(matA) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += matA[i][k] * matB[k][j] return result def identity(n: int) -> List[List[int]]: result = [[0] * n for _ in range(n)] for i in range(n): result[i][i] = 1 return result def matrix_exponentiation(mat: List[List[int]], p: int) -> List[List[int]]: n = len(mat) result = identity(n) base = mat while p > 0: if p % 2 == 1: result = multiply(result, base) base = multiply(base, base) p //= 2 return result"},{"question":"# Question: Find the Mode of a List You are tasked with writing a function that finds the mode of a list, which is the most frequently occurring element(s). If multiple elements have the same highest frequency, the function should return all of them. Task: Implement a function `find_mode(arr: List[int]) -> List[int]` that takes a list of integers and returns a list of integers which are the mode(s) of the input list. Input: - `arr`: A list of integers where 0 <= len(arr) <= 10^6 and -10^6 <= arr[i] <= 10^6. Output: - A list of integers which are the mode(s) of the input list. The order of the result does not matter. Function Signature: ```python from typing import List def find_mode(arr: List[int]) -> List[int]: # Your implementation here ``` Example: ```python assert find_mode([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_mode([4, 4, 1, 2, 2, 3, 4]) == [4] assert find_mode([3, 3, 3, 2, 5, 5, 7, 7]) == [3] assert find_mode([]) == [] assert find_mode([10, 20, 30, 40, 50, 60]) == [10, 20, 30, 40, 50, 60] ``` Constraints: - Ensure your solution runs efficiently with a time complexity of O(n) where `n` is the length of the input list. - Handle an empty list gracefully by returning an empty result. Additional Information: - Ensure the implementation correctly handles large lists and varying element ranges.","solution":"from typing import List from collections import Counter def find_mode(arr: List[int]) -> List[int]: if not arr: return [] counter = Counter(arr) max_frequency = max(counter.values()) return [num for num, freq in counter.items() if freq == max_frequency]"},{"question":"# Coding Challenge: Context: You have been provided with an abstract stack class that can either be implemented using an array (dynamic size) or a linked list. You need to implement a custom stack named `CustomStack` that combines the advantages of both array-based and linked-list-based implementations. Problem Statement: Design and implement a `CustomStack` that uses a dynamic array but ensures minimal memory usage and efficient reallocations. The custom stack should maintain a minimum array size of `10` and should grow or shrink in size by doubling or halving respectively when it reaches limits or goes below a certain threshold. Requirements: 1. **Initialization**: Initialize the stack with a minimum size of `10`. 2. **Push Operation**: Push the element onto the stack, resizing the array if necessary. 3. **Pop Operation**: Pop the element from the stack, resizing the array if necessary. 4. **Peek Operation**: Return the top element without removing it. 5. **Is_Empty Operation**: Check if the stack is empty. 6. **Additional Operations**: * `size`: Returns the current number of elements in the stack. * `capacity`: Returns the current capacity of the underlying array. Input Format: - `push(value: int) -> None`: Pushes value onto the stack. - `pop() -> int`: Pops the top value from the stack. Raises an error if the stack is empty. - `peek() -> int`: Returns the top value without removing it. Raises an error if the stack is empty. - `is_empty() -> bool`: Returns True if the stack is empty, otherwise False. - `size() -> int`: Returns the number of elements in the stack. - `capacity() -> int`: Returns the current capacity of the underlying array. Constraints: - Values pushed onto the stack are integers. - You should raise an error if `pop()` or `peek()` is called on an empty stack. Example: ```python # Creating a CustomStack stack = CustomStack() # Performing operations stack.push(1) stack.push(2) print(stack.peek()) # Output: 2 print(stack.size()) # Output: 2 stack.pop() # Removes 2 print(stack.peek()) # Output: 1 print(stack.is_empty()) # Output: False stack.pop() # Removes 1 print(stack.is_empty()) # Output: True ``` Implementation Notes: - Ensure array resizing maintains efficient memory usage. - Handle edge cases such as popping from an empty stack gracefully.","solution":"class CustomStack: def __init__(self): self._minimum_capacity = 10 self._stack = [None] * self._minimum_capacity self._size = 0 def push(self, value: int) -> None: if self._size == self.capacity(): self._resize(self.capacity() * 2) self._stack[self._size] = value self._size += 1 def pop(self) -> int: if self.is_empty(): raise IndexError(\\"Pop from an empty stack\\") value = self._stack[self._size - 1] self._stack[self._size - 1] = None self._size -= 1 if self._size > 0 and self._size == self.capacity() // 4 and self.capacity() > self._minimum_capacity: self._resize(self.capacity() // 2) return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Peek from an empty stack\\") return self._stack[self._size - 1] def is_empty(self) -> bool: return self._size == 0 def size(self) -> int: return self._size def capacity(self) -> int: return len(self._stack) def _resize(self, new_capacity: int) -> None: new_stack = [None] * new_capacity for i in range(self._size): new_stack[i] = self._stack[i] self._stack = new_stack"},{"question":"You are tasked with implementing a function to calculate the trimmed mean of an array of numbers. The trimmed mean is calculated by ignoring a certain percentage of the highest and lowest values and then computing the mean of the remaining values. Function Signature ```python def trimmed_mean(arr: List[int], percentage: float) -> float: Calculate trimmed mean of array excluding given percentage of highest and lowest values ``` Input - `arr`: a list of integers, representing the dataset. - `percentage`: a float between 0 and 100, representing the total percentage of data to exclude from both ends of the sorted dataset. Output - A float representing the trimmed mean, computed by excluding the given percentage of the highest and lowest values. Constraints - `2 <= len(arr) <= 10^6` - `0 <= percentage < 100` - The resulting subarray after exclusion must contain at least one element. Requirements - The function should work efficiently for large datasets. - Handle edge cases appropriately (e.g., when the array is very small). Example ```python assert abs(trimmed_mean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 20) - 5.5) < 1e-9 assert abs(trimmed_mean([6, 2, 4, 9, 3, 1, 7, 8, 5], 0) - 5.0) < 1e-9 assert abs(trimmed_mean([1, 1, 1, 1, 1], 40) - 1.0) < 1e-9 ``` # Scenario Consider you are developing software for an athletic event scoring system. You need to calculate the average score for athletes while ignoring the top and bottom 10% of scores to avoid outliers. Implement the `trimmed_mean` function that accurately performs this trimming and computes the mean for you.","solution":"from typing import List def trimmed_mean(arr: List[int], percentage: float) -> float: Calculate trimmed mean of array excluding given percentage of highest and lowest values. if not 0 <= percentage < 100: raise ValueError(\\"Percentage must be in the range [0, 100).\\") n = len(arr) if n < 2: raise ValueError(\\"Array must contain at least 2 elements.\\") trimmed_count = int(n * percentage / 100 / 2) # If the entire array would be trimmed, adjust to keep at least one element if n - 2 * trimmed_count < 1: raise ValueError(\\"The resulting subarray after trimming must contain at least one element.\\") sorted_arr = sorted(arr) trimmed_arr = sorted_arr[trimmed_count:n - trimmed_count] return sum(trimmed_arr) / len(trimmed_arr)"},{"question":"You\'ve been hired by a parallel computing firm to help them optimize their data sorting algorithms. They are particularly interested in the Bitonic Sort algorithm due to its efficiency on parallel hardware. However, for your trial task, you are asked to implement the non-parallel version of Bitonic Sort to demonstrate your understanding. Write a Python function `bitonic_sort` that sorts an array of integers using the Bitonic Sort algorithm. Your implementation should sort the array in both increasing order and decreasing order, based on a boolean input parameter `reverse`. # Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: ``` # Input - `arr`: A list of integers. The length of the array must be a power of 2. - `reverse`: A boolean flag. If `True`, sort in descending order; otherwise, sort in ascending order. Default is `False`. # Output - Return a list of integers sorted in the specified order. # Constraints - The length of the array `arr` should be a positive integer and a power of 2. - `1 <= len(arr) <= 2^10` # Example ```python bitonic_sort([12, 4, 78, 90, 45, 23, 56, 44]) # Output: [4, 12, 23, 44, 45, 56, 78, 90] bitonic_sort([12, 4, 78, 90, 45, 23, 56, 44], reverse=True) # Output: [90, 78, 56, 45, 44, 23, 12, 4] ``` # Notes 1. Ensure your solution handles edge cases such as arrays with a single element or already sorted arrays. 2. Raise a `ValueError` if the input array\'s length is not a power of 2. 3. Pay close attention to the efficiency of your recursive function calls.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def compare_and_swap(arr: List[int], i: int, j: int, direction: bool): if direction == (arr[i] > arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) # sort in ascending order bitonic_sort_recursive(arr, low + k, k, False) # sort in descending order bitonic_merge(arr, low, cnt, direction) if len(arr) & (len(arr) - 1) != 0: raise ValueError(\\"The length of the array must be a power of 2.\\") bitonic_sort_recursive(arr, 0, len(arr), not reverse) return arr"},{"question":"# Array Pair Sum Problem Given an array of integers, write a function `pair_sum_indices` that returns the indices of the two numbers such that they add up to a specific target sum. You may assume that each input would have exactly one solution, and you may not use the same element twice. Function Signature ```python def pair_sum_indices(array: List[int], target: int) -> Optional[Tuple[int, int]]: pass ``` Input - `array` (List[int]): A list of integers. - `target` (int): The target sum integer. Output - Returns a tuple `(index1, index2)` where: * `index1` and `index2` are the indices of the two numbers in the array that add up to the target. * If no such pair exists, returns `None`. Constraints - The input list will have at least 2 elements. - Each input will have exactly one solution. - The same element may not be used twice. Example ```python assert pair_sum_indices([2, 7, 11, 15], 9) == (0, 1) assert pair_sum_indices([1, 4, 5, 3], 8) == (2, 3) assert pair_sum_indices([10, 29, 30, 21], 50) == (1, 3) ``` Performance Requirements - The function should run in O(n) time complexity and use O(n) additional space complexity. Scenario Imagine you are working with financial software where you need to find pairs of transactions that, when combined, match a given suspicious transaction value. This function will help in identifying those transaction pairs efficiently.","solution":"from typing import List, Optional, Tuple def pair_sum_indices(array: List[int], target: int) -> Optional[Tuple[int, int]]: Returns the indices of the two numbers in the array that add up to the target sum. Each input is assumed to have exactly one solution, and no element can be used twice. lookup = {} for i, num in enumerate(array): complement = target - num if complement in lookup: return (lookup[complement], i) lookup[num] = i return None"},{"question":"Implementing Improved Merge Sort Scenario: You are tasked with optimizing an e-commerce platform\'s backend system for efficiently sorting large lists of products based on their prices. The platform often needs to handle sorting jobs that involve millions of entries. To achieve this, you\'ll use the merge sort algorithm due to its favorable time complexity and stability. Task Synopsis: Given an unsorted list of integers representing product prices, implement the merge sort algorithm to sort the list in ascending order. However, the challenge is to optimize memory usage by ensuring minimal creation of temporary arrays. # Function Signature: ```python def merge_sort_optimized(arr: list) -> list: pass ``` # Input Format: - `arr`: A list of integers representing product prices. # Output Format: - A sorted list of integers in ascending order. # Constraints: - The number of elements in the array (`n`) can be up to `10^6`. # Performance Requirements: - The solution should run efficiently within the time complexity of O(n log n) and should handle large input sizes without running into memory issues. # Example: ```python # Example 1: input: [12, 4, 5, 6, 7, 3, 1, 15] output: [1, 3, 4, 5, 6, 7, 12, 15] # Example 2: input: [5, 9, 2, 6, 4, 0, -1, 11] output: [-1, 0, 2, 4, 5, 6, 9, 11] ``` # Instructions: 1. Create a function `merge_sort_optimized` that implements the merge sort algorithm. 2. Optimize the function to minimize additional memory usage. 3. Ensure the function is robust and correctly handles edge cases such as empty lists or lists with a single element. 4. You are not allowed to use built-in sorting functions.","solution":"def merge_sort_optimized(arr): if len(arr) <= 1: return arr mid = len(arr) // 2 left = merge_sort_optimized(arr[:mid]) right = merge_sort_optimized(arr[mid:]) return merge(left, right) def merge(left, right): merged_array = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: merged_array.append(left[left_index]) left_index += 1 else: merged_array.append(right[right_index]) right_index += 1 while left_index < len(left): merged_array.append(left[left_index]) left_index += 1 while right_index < len(right): merged_array.append(right[right_index]) right_index += 1 return merged_array"},{"question":"Suppose you are given an integer. Write a function to determine the number of digits in the integer using logarithmic methods. Your function should handle both positive and negative integers gracefully. You should ensure that zero is also accounted for correctly. **Function Signature**: ```python def num_digits(n: int) -> int: ``` # Input * An integer `n` such as `-1000`, `0`, `453`. # Output * An integer representing the number of digits in the given number `n`. # Example ```python print(num_digits(12345)) # Output: 5 print(num_digits(-54321)) # Output: 5 print(num_digits(0)) # Output: 1 print(num_digits(7)) # Output: 1 print(num_digits(-8)) # Output: 1 ``` # Constraints 1. The input integer `n` can be any valid integer in Python, including negative values. 2. The function should return the count of numeric digits without considering the negative sign. # Notes * You may not directly use iterative loops or convert the number to a string to count its length. Instead, you must leverage logarithmic properties to achieve the goal. * Ensure the solution is efficient and runs in constant time. Explain your approach clearly and provide the necessary code to solve the problem.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the integer `n` using logarithmic methods. Handles both positive and negative integers, and zero. if n == 0: return 1 n = abs(n) return math.floor(math.log10(n)) + 1"},{"question":"# Permutations Generation Task Context: You are given a list of distinct integers. Your task is to write a function that generates all possible permutations of the list. You should implement two versions of this function: one that returns all permutations at once, and another that acts as an iterator, yielding one permutation at a time. Requirements: 1. **Function Name**: `generate_permutations` 2. **Input**: A list of distinct integers: `List[int]` 3. **Output**: A list of lists, where each inner list is a permutation of the input list. 4. **Function Name**: `generate_permutations_iter` 5. **Input**: A list of distinct integers: `List[int]` 6. **Output**: An iterator that yields one permutation of the input list at a time. Constraints: * Implementations should aim for optimal performance given the factorial nature of the problem. * Do not use in-built library functions for permutations (e.g., `itertools.permutations`). Examples: 1. **Example 1**: * **Input**: `[1, 2, 3]` * **Output**: ```python [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] ``` 2. **Example 2**: * **Input**: `[0, 1]` * **Output**: ```python [ [0, 1], [1, 0] ] ``` Write your functions below: ```python def generate_permutations(elements: List[int]) -> List[List[int]]: Generates all permutations of the input list and returns them as a list of lists. # Your implementation here def generate_permutations_iter(elements: List[int]) -> Iterator[List[int]]: Yields one permutation of the input list at a time. # Your implementation here ```","solution":"from typing import List, Iterator def generate_permutations(elements: List[int]) -> List[List[int]]: def permute(current, remaining, results): if not remaining: results.append(current[:]) else: for i in range(len(remaining)): next_elem = remaining[i] current.append(next_elem) permute(current, remaining[:i] + remaining[i+1:], results) current.pop() results = [] permute([], elements, results) return results def generate_permutations_iter(elements: List[int]) -> Iterator[List[int]]: def permute(current, remaining): if not remaining: yield current[:] else: for i in range(len(remaining)): next_elem = remaining[i] current.append(next_elem) yield from permute(current, remaining[:i] + remaining[i+1:]) current.pop() yield from permute([], elements)"},{"question":"# Coding Exercise **Problem Statement**: You are given a singly linked list and an integer k. Implement a function `find_kth_to_last` that returns the kth-to-last element of the list. If the list has fewer than `k` elements, the function should return `None`. **Function Signature**: ```python def find_kth_to_last(head: Node, k: int) -> Node: pass ``` **Input**: - `head`: The head node of a singly linked list. - `k`: Positive integer representing the kth position from the end of the list. **Output**: - The `Node` object at the kth position from the end; if `k` is out of bounds, return `None`. **Constraints**: - k is a positive integer. - The list contains at least 0 elements. **Examples**: 1. If the list is 1 -> 2 -> 3 -> 4 -> 5 and k=2, the function should return the node with value 4. 2. If the list is 1 -> 2 and k=3, the function should return `None`. **Edge Cases to Consider**: - Empty list (head is None) - k is greater than the length of the list. *Note*: You must implement the optimal solution in terms of both time and space complexity. # Solution Template: ```python class Node(): def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head, k): # Write your code here pass def print_linked_list(head): string = \\"\\" while head.next: string += head.val + \\" -> \\" head = head.next string += head.val print(string) def test(): a1 = Node(\\"1\\") a2 = Node(\\"2\\") a3 = Node(\\"3\\") a4 = Node(\\"4\\") a5 = Node(\\"5\\") a1.next = a2 a2.next = a3 a3.next = a4 a4.next = a5 # Test example 1 kth = find_kth_to_last(a1, 2) try: assert kth.val == \\"4\\" except AssertionError as e: e.args += (\\"Expecting 4, got %s\\" % kth.val,) raise # Test example 2 kth = find_kth_to_last(a1, 6) try: assert kth is None except AssertionError as e: e.args += (\\"Expecting None, got %s\\" % kth,) raise print(\\"all passed.\\") if __name__ == \'__main__\': test() ```","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def find_kth_to_last(head, k): if not head or k <= 0: return None first = head second = head # Move first k nodes ahead for _ in range(k): if not first: return None first = first.next # Move both first and second pointers until first reaches the end while first: first = first.next second = second.next return second"},{"question":"Scenario: You are working with a combinatorial problem where you need to calculate the number of ways to choose k items from a set of n distinct items. This mathematical problem can be represented using the binomial coefficient C(n, k), which gives the total number of possible combinations. Problem Statement: You are required to implement a function to compute the binomial coefficient C(n, k) using a recursive approach. The function should handle basic edge cases such as n = k and k = 0 efficiently, and leverage the properties of binomial coefficients to reduce the complexity where possible. Implement the function `recursive_binomial_coefficient(n, k)` that: 1. Takes two non-negative integers n and k as input (with the constraint that n >= k). 2. Returns the value of the binomial coefficient C(n, k). 3. Raises a ValueError if k > n. 4. Uses recursive strategy and the property C(n, k) = C(n, n-k) to optimize the calculation. Input: * Two integers n and k such that 0 <= k <= n. Output: * An integer representing the binomial coefficient C(n, k). Constraints: * 0 ≤ k ≤ n ≤ 1000 (You can assume that n and k will be within a reasonable range to prevent deep recursion) * The result will fit in a standard integer type. Example: ```python >>> recursive_binomial_coefficient(5, 0) 1 >>> recursive_binomial_coefficient(8, 2) 28 >>> recursive_binomial_coefficient(500, 300) 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` Notes: - You should ensure your implementation is efficient to handle large inputs within the provided constraints. - Consider potential optimization strategies as mentioned in the principles and characteristics sections to enhance performance.","solution":"def recursive_binomial_coefficient(n, k): Returns the binomial coefficient C(n, k) using a recursive approach. if k > n: raise ValueError(\\"k cannot be greater than n\\") if k == 0 or k == n: return 1 k = min(k, n - k) return recursive_binomial_coefficient(n - 1, k - 1) + recursive_binomial_coefficient(n - 1, k)"},{"question":"# Minimum Spanning Tree Problem Imagine you are the chief engineer responsible for designing a minimum cost network to connect several cities. Each possible connection between two cities has a direct construction cost associated with it. Your job is to implement an algorithm that determines the minimum total construction cost required to connect all the cities. **Problem Statement**: Implement the function `minimum_spanning_tree` that accepts the number of cities and a list of potential connections between them, returning the minimum cost to connect all cities. **Function Signature**: ```python def minimum_spanning_tree(num_cities: int, connections: List[Tuple[int, int, int]]) -> int: ``` **Parameters**: - `num_cities` (`int`): The number of cities (vertices) (indexed from 0 to num_cities-1). - `connections` (`List[Tuple[int, int, int]]`): A list of tuples, where each tuple contains three integers representing a bidirectional road between two cities and its associated cost. If a road connects city `u` and city `v` with cost `w`, it is represented as `(u, v, w)`. **Return**: - Return the minimum total cost to connect all cities. If it is not possible to connect all cities, return -1. **Constraints**: - All cities will be connected directly or indirectly by the roads. - `1 <= num_cities <= 1000` - `1 <= len(connections) <= 100000` - The cost (`w`) will be a positive integer and within a reasonable range. **Example**: ```python assert minimum_spanning_tree(5, [(0, 1, 3), (0, 2, 8), (1, 3, 5), (2, 3, 2), (2, 4, 4), (3, 4, 6)]) == 14 assert minimum_spanning_tree(3, [(0, 1, 20), (1, 2, 100), (0, 2, 20)]) == 40 assert minimum_spanning_tree(4, [(0, 1, 1), (1, 2, 1), (2, 3, 1)]) == 3 ``` **Explanation**: Implement `minimum_spanning_tree` using Kruskal\'s algorithm employing the Disjoint Set data structure. Be sure to handle edge cases such as disconnected graphs correctly.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, node1, node2): root1 = self.find(node1) root2 = self.find(node2) if root1 != root2: if self.rank[root1] > self.rank[root2]: self.parent[root2] = root1 elif self.rank[root1] < self.rank[root2]: self.parent[root1] = root2 else: self.parent[root2] = root1 self.rank[root1] += 1 def minimum_spanning_tree(num_cities: int, connections: List[Tuple[int, int, int]]) -> int: if num_cities == 0: return -1 uf = UnionFind(num_cities) connections.sort(key=lambda x: x[2]) # Sort by cost total_cost = 0 edges_used = 0 for u, v, cost in connections: if uf.find(u) != uf.find(v): uf.union(u, v) total_cost += cost edges_used += 1 if edges_used == num_cities - 1: return total_cost else: return -1"},{"question":"# Scenario You have been given the responsibility to analyze and evaluate data structures in hierarchical formats. In your tasks, you often need to determine the maximum depth of binary trees representing hierarchical data. # Task Write a function `max_depth(root)` that calculates the maximum depth of a binary tree. You should implement the solution using a depth-first search (DFS) approach without recursion. # Function Signature ```python def max_depth(root: TreeNode) -> int: pass ``` # Input - A binary tree `root` which is represented using `TreeNode` class. - The `TreeNode` class is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - An integer representing the maximum depth of the binary tree. # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - The nodes\' values are in the range `[-10^5, 10^5]`. # Performance Requirements - Your function must run in `O(n)` time complexity. - Your function must be iterative and use an effective traversal strategy. # Example ```python # Example Tree Structure # 1 # / # 2 3 # / # 4 5 tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) assert max_depth(tree) == 3 ``` # Explanation The binary tree in the example has the following structure: 1. The root node is `1`, which has two children: `2` and `3`. 2. Node `2` has two children: `4` and `5`. 3. Nodes `3`, `4`, and `5` are leaf nodes. The maximum depth of this tree is `3`.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_depth(root: TreeNode) -> int: if not root: return 0 stack = [(root, 1)] # Stack will store tuples of (node, current_depth) max_depth = 0 while stack: node, depth = stack.pop() if node: max_depth = max(max_depth, depth) if node.left: stack.append((node.left, depth + 1)) if node.right: stack.append((node.right, depth + 1)) return max_depth"},{"question":"# Question: Exchange Sort Implementation Objective In this task, you are required to implement the Exchange Sort algorithm from scratch. The algorithm should sort a given list of integers in ascending order. Instructions 1. Implement the `exchange_sort` function that takes a list of integers as input and returns a new list sorted in ascending order. 2. Your implementation should handle all edge cases, including empty lists, single-element lists, already sorted lists, and lists with duplicate elements. 3. Ensure your implementation is an in-place sort, meaning the original list is sorted without using additional memory apart from a few auxiliary variables. Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: # your code here ``` Input * A list of integers, `arr`, resulting between `0 <= len(arr) <= 1000`. Each integer `arr[i]` is within the range `-10^9 <= arr[i] <= 10^9`. Output * A list of integers sorted in ascending order. Example ```python >>> exchange_sort([3, 1, 2]) [1, 2, 3] >>> exchange_sort([-1, -5, 0]) [-5, -1, 0] >>> exchange_sort([1]) [1] >>> exchange_sort([]) [] >>> exchange_sort([3, 3, 3]) [3, 3, 3] ``` Constraints * You should aim to write a simple, clear, and correct implementation. * Focus on handling edge cases properly as specified. * No external libraries are permitted; you must implement the sort manually. Performance Considerations * Note that performance is less of a concern due to the educational purpose and the simplicity of the task.","solution":"def exchange_sort(arr): Sorts a list of integers in ascending order using the exchange sort algorithm. Args: arr (list): A list of integers Returns: list: A new list with sorted integers in ascending order n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: # Swap the elements arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"You are given a string as your input. Your task is to write a function `remove_duplicates_preserve_order(s)` that deletes any reoccurring character and returns a new string without duplicate characters while maintaining the original order of first occurrences of each character. Function Signature: ```python def remove_duplicates_preserve_order(s: str) -> str: ``` Input: - A single string `s` consisting of ASCII characters (0 <= len(s) <= 10^6). Output: - A string with duplicate characters removed, maintaining the original order of the first occurrence of each character. Constraints: - Your solution should have linear time complexity. - Your solution should handle edge cases gracefully. Example: ```python assert remove_duplicates_preserve_order(\\"google\\") == \\"gole\\" assert remove_duplicates_preserve_order(\\"programming\\") == \\"progamin\\" assert remove_duplicates_preserve_order(\\"\\") == \\"\\" assert remove_duplicates_preserve_order(\\"aAaA\\") == \\"aA\\" ``` Notes: - The function should be case-sensitive. For example, \\"aA\\" should be considered as containing two distinct characters \'a\' and \'A\'. - If the input string is empty, the function should return an empty string.","solution":"def remove_duplicates_preserve_order(s: str) -> str: Removes duplicate characters from a string, preserving the order of the first occurrence. Parameters: s (str): The input string. Returns: str: A new string with duplicates removed. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Coding Problem: Efficient Integer and Byte Conversion Context: In computing, converting between integers and their byte representations is crucial for operations such as network communications, file storage, and low-level hardware interactions. Big-endian and little-endian formats determine how the byte sequence is ordered. Task: Implement efficient conversion functions between integers and their byte representations for both big-endian and little-endian formats. The current big-endian implementation uses inefficient `deque.appendleft()`, and the function does not support negative integers or edge cases like zero effectively. Requirements: 1. Implement the following functions: * `int_to_bytes_big_endian(num: int) -> bytes` * `int_to_bytes_little_endian(num: int) -> bytes` * `bytes_big_endian_to_int(bytestr: bytes) -> int` * `bytes_little_endian_to_int(bytestr: bytes) -> int` 2. Ensure that the functions handle the following: * Zero correctly, returning an empty byte sequence. * Negative integers, ensuring proper two\'s complement representation. Input/Output Formats: * `int_to_bytes_big_endian(num: int) -> bytes`: * Input: Integer `num` (can be positive or negative). * Output: `bytes` object representing the integer in big-endian format. * `int_to_bytes_little_endian(num: int) -> bytes`: * Input: Integer `num` (can be positive or negative). * Output: `bytes` object representing the integer in little-endian format. * `bytes_big_endian_to_int(bytestr: bytes) -> int`: * Input: `bytes` object. * Output: Integer reconstructed from the bytes in big-endian format. * `bytes_little_endian_to_int(bytestr: bytes) -> int`: * Input: `bytes` object. * Output: Integer reconstructed from the bytes in little-endian format. Constraints: * The integer values can be in the range of -2^63 to 2^63 - 1. * Handle edge cases like zero and empty bytes gracefully. Example: ``` num = 305419896 # Big-Endian Conversion big_endian_bytes = int_to_bytes_big_endian(num) # big_endian_bytes should be b\'x12x34x56x78\' reconstructed_num_be = bytes_big_endian_to_int(big_endian_bytes) # reconstructed_num_be should be 305419896 # Little-Endian Conversion little_endian_bytes = int_to_bytes_little_endian(num) # little_endian_bytes should be b\'x78x56x34x12\' reconstructed_num_le = bytes_little_endian_to_int(little_endian_bytes) # reconstructed_num_le should be 305419896 ``` Performance Considerations: Ensure that your solutions are optimized in terms of time and space complexity. Aim for O(log(num)) time complexity for integer to bytes conversion and O(n) time complexity for bytes to integer conversion.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: if num == 0: return b\'\' num_bytes = (num.bit_length() + 7) // 8 return num.to_bytes(num_bytes, \'big\', signed=True) def int_to_bytes_little_endian(num: int) -> bytes: if num == 0: return b\'\' num_bytes = (num.bit_length() + 7) // 8 return num.to_bytes(num_bytes, \'little\', signed=True) def bytes_big_endian_to_int(bytestr: bytes) -> int: return int.from_bytes(bytestr, \'big\', signed=True) def bytes_little_endian_to_int(bytestr: bytes) -> int: return int.from_bytes(bytestr, \'little\', signed=True)"},{"question":"Implement Encode and Decode Functions for Strings Context You are working on a system where you need to reliably transmit lists of strings over a network. To facilitate this, you must encode the list of strings into a single string, send the encoded string, and decode it back to the original list of strings. Task Write two functions `encode` and `decode` that will implement the required functionality: 1. **Encode Function**: * **Input**: A list of strings `List[str]`. * **Output**: A single encoded string `str`. 2. **Decode Function**: * **Input**: A single encoded string `str`. * **Output**: A list of strings `List[str]`. Constraints * Strings can contain any characters including digits and punctuation. * Both methods should be as efficient as possible with respect to time and space complexity. Input/Output Specifications * **Encode**: * Example input: `[\\"hello\\", \\"world\\"]` * Expected output: `5:hello5:world` * **Decode**: * Example input: `5:hello5:world` * Expected output: `[\\"hello\\", \\"world\\"]` Implementation Details Make sure to handle the following edge cases: * Empty list of strings. * Strings containing delimiter `\\":\\"`. * Zero-length strings. Provide thorough error handling and assume that the input will always be correctly formatted and free of deliberate errors.","solution":"def encode(strs): Encodes a list of strings to a single string. Each string is encoded by its length and the string itself. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. It uses the length specified before each string to parse the original strings. result = [] i = 0 while i < len(s): # Get the length of the next string j = s.find(\':\', i) length = int(s[i:j]) # Get the string of the specified length i = j + 1 result.append(s[i:i + length]) i += length return result"},{"question":"You are tasked with implementing a variant of the Union-Find data structure to solve the \\"number of distinct regions\\" problem on a 2D grid dynamically as land is added in different positions. Your implementation should support the following operations: 1. **Add Land**: Add a land to the grid (transforming a cell from water to land). 2. **Count Islands**: After every addition of land, count the number of distinct islands (a connected group of lands, horizontally or vertically). Given a grid of dimensions `m x n` initially filled with water, implement the function `num_islands(positions: List[Tuple[int, int]]) -> List[int]` which returns a list where the i-th element is the number of islands after the i-th land addition. **Input Format:** * `positions`: A list of tuples where each tuple `(x, y)` indicates the position of land being added to the initially water-filled grid. **Output Format:** * A list of integers where each integer is the count of islands after each add land operation. **Constraints:** * All positions are valid and within boundaries `[0, m-1]` and `[0, n-1]`. * Operations are in order and there are no duplicates in the positions list. # Example ```python positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands(positions)) ``` **Expected Output:** ``` [1, 1, 2, 3] ``` # Explanation: 1. Initially, the grid is: ``` 0 0 0 0 0 0 0 0 0 ``` 2. After addLand(0, 0): ``` 1 0 0 0 0 0 0 0 0 (Number of islands = 1) ``` 3. After addLand(0, 1): ``` 1 1 0 0 0 0 0 0 0 (Number of islands = 1) ``` 4. After addLand(1, 2): ``` 1 1 0 0 0 1 0 0 0 (Number of islands = 2) ``` 5. After addLand(2, 1): ``` 1 1 0 0 0 1 0 1 0 (Number of islands = 3) ``` Implement the `num_islands` function using the provided `Union` data structure.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size: int): self.parent = [i for i in range(size)] self.rank = [1] * size self.count = 0 def find(self, x: int) -> int: if x != self.parent[x]: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x: int, y: int) -> bool: rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 return True return False def add_count(self): self.count += 1 def get_count(self): return self.count def num_islands(positions: List[Tuple[int, int]]) -> List[int]: if not positions: return [] m, n = max(x for x, y in positions) + 1, max(y for x, y in positions) + 1 uf = UnionFind(m * n) water = [[False]*n for _ in range(m)] result = [] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: if not water[x][y]: water[x][y] = True uf.add_count() index = x * n + y for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and water[nx][ny]: uf.union(index, nx * n + ny) result.append(uf.get_count()) return result"},{"question":"# Question: Merge Sort Implementation Merge Sort is a classic divide-and-conquer sorting algorithm used for ordering elements in an array. Your task is to implement the merge sort algorithm based on the following requirements: Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers of size `0 <= len(arr) <= 10^5` Output - Returns a new list containing the sorted elements of `arr`. # Requirements 1. Implement the `merge_sort` algorithm that follows the principles outlined in the analysis. 2. Implement a helper function `merge` that merges two sorted subarrays into a single sorted array. # Constraints 1. Your function must not use any built-in sort functions. 2. Ensure the algorithm handles edge cases like empty arrays, arrays with a single element, and arrays with duplicate values correctly. 3. Aim for a time complexity of O(n log(n)) and space complexity of O(n). # Example ```python assert merge_sort([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]) == [1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9] assert merge_sort([10]) == [10] assert merge_sort([]) == [] ``` # Scenario Imagine you are working on a large software project that processes huge datasets. One of the core functionalities is to sort records quickly and efficiently. By implementing merge sort, you ensure that your sorting mechanism is both stable and scalable. Please write the function with a clear, concise, and well-documented code.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Performs the merge sort on the input list of integers. Parameters: arr (List[int]): A list of integers to be sorted. Returns: List[int]: A new list containing the sorted elements of `arr`. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted subarrays into a single sorted array. Parameters: left (List[int]): A sorted list of integers. right (List[int]): Another sorted list of integers. Returns: List[int]: A merged and sorted list of integers. merged = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: merged.append(left[left_index]) left_index += 1 else: merged.append(right[right_index]) right_index += 1 # Append any remaining elements merged.extend(left[left_index:]) merged.extend(right[right_index:]) return merged mid = len(arr) // 2 left = merge_sort(arr[:mid]) right = merge_sort(arr[mid:]) return merge(left, right)"},{"question":"# Scenario You are developing a text segmentation feature for a language processing tool. The tool should be able to split an input string into valid words based on a given dictionary. The aim is to evaluate the number of valid sentences that can be constructed. # Task Write a function `count_sentences(s: str, dictionary: Set[str]) -> int` that takes in a string `s` and a set of dictionary words `dictionary`, and returns the total number of different sentences that can be formed from the string such that each word in the sentence is found in the dictionary. Input * `s`: A string composed of lowercase alphabets, 1 <= |s| <= 100. * `dictionary`: A set of lowercase words. Output * An integer representing the number of valid sentences that can be formed. # Constraints * The words in the dictionary will also be lowercase. * Words can be reused in a single sentence. # Examples 1. `s = \\"appletablet\\"`, `dictionary = {\\"apple\\", \\"app\\", \\"let\\", \\"tablet\\", \\"table\\", \\"t\\", \\"able\\"}` *Output: 4* Valid sentences: - \\"apple\\" \\"tablet\\" - \\"applet\\", \\"able\\" \\"t\\" - \\"apple\\", \\"table\\", \\"t\\" - \\"app\\", \\"let\\", \\"able\\", \\"t\\" 2. `s = \\"thing\\"`, `dictionary = {\\"thing\\"}` *Output: 1* Valid sentences: - \\"thing\\" # Notes * Consider edge cases such as when no sentences can be formed or when `s` is an empty string. * Optimize your solution for scalability. Consider using techniques such as memoization or dynamic programming to enhance performance.","solution":"def count_sentences(s: str, dictionary: set) -> int: Returns the number of valid sentences that can be formed from the string s such that each word in the sentence is found in the dictionary. n = len(s) dp = [0] * (n + 1) dp[0] = 1 # There\'s one way to form an empty string for i in range(1, n + 1): for j in range(i): if s[j:i] in dictionary: dp[i] += dp[j] return dp[n]"},{"question":"# Scenario You are developing a data processing tool that needs to flatten nested data structures. Arrays (lists in Python) may include deeply nested arrays, and your tool must produce a single-level output array irrespective of the nesting depth. # Task Write a function `flatten_array(input_list)` that takes a potentially deeply nested list as input and returns a single-level list containing all elements from the nested structure. The function should maintain the order of elements as they appear in the nested structure. # Input and Output Format - **Input**: A single argument `input_list` which is a list potentially containing nested lists. - **Output**: A single-level list containing all elements from the nested input list. # Constraints - A string should not be split into characters. - You may not use any third-party libraries. - Recursion depth is guaranteed not to exceed the Python limit. # Example ```python flatten_array([1, [2, [3, 4, [5]]], 6]) # Output: [1, 2, 3, 4, 5, 6] flatten_array([\'a\', [\'b\', [\'c\', \'d\', [\'e\']]], \'f\']) # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] ``` # Performance Expectations - Your solution should handle lists with up to 10,000 total elements within a reasonable time frame.","solution":"def flatten_array(input_list): Flattens a potentially deeply nested list into a single-level list containing all elements in order. result = [] def flatten_helper(lst): for item in lst: if isinstance(item, list): flatten_helper(item) else: result.append(item) flatten_helper(input_list) return result"},{"question":"# Problem Description You are given a list of integers (lst) and an integer (N). Your task is to create a new list such that each number in (lst) appears at most (N) times and retains the original order of its first occurrences. Function Signature ```python def limit_repeating_elements(lst: List[int], N: int) -> List[int]: ``` # Input - `lst`: A list of integers. - `N`: An integer representing the maximum number of occurrences for each element in the list. # Output - A list of integers where each element from `lst` appears at most (N) times, maintaining its original order. # Constraints - (0 leq text{len}(lst) leq 10^5) - (-10^9 leq text{element of lst} leq 10^9) - (0 leq N leq text{len}(lst)) # Requirements - Your solution should have a time complexity of (O(n)) where (n) is the size of the list. # Example 1. **Input**: lst = [1, 2, 3, 1, 2, 1, 2, 3], N = 2 **Output**: [1, 2, 3, 1, 2, 3] 2. **Input**: lst = [1, 1, 1, 1], N = 2 **Output**: [1, 1] 3. **Input**: lst = [1, 2, 3], N = 0 **Output**: [] # Notes - The order of elements should be maintained as in the original list. - Think about efficient ways to track the occurrences of each element using appropriate data structures.","solution":"from typing import List def limit_repeating_elements(lst: List[int], N: int) -> List[int]: Returns a list where each element from `lst` appears at most `N` times, maintaining its original order. result = [] occurrences = {} for number in lst: if number not in occurrences: occurrences[number] = 0 if occurrences[number] < N: result.append(number) occurrences[number] += 1 return result"},{"question":"# Question You are given a 2D grid representing a map with \'1\'s (land) and \'0\'s (water). An island is a maximal set of connected \'1\'s in four directions (up, down, left, right) surrounded by water. Write a function `num_islands(grid)` that returns the number of islands in the grid. # Requirements 1. Implement the function `num_islands(grid)`. 2. Expected input and output formats: - Input: A 2D list of characters, `grid`, where `grid[i][j]` is either \'1\' (land) or \'0\' (water). - Output: An integer representing the number of islands. 3. You may assume that: - `grid` will have at most 300 rows and 300 columns. - All four edges of the grid are all surrounded by water. # Constraints - The time complexity should be O(m * n) where `m` is the number of rows and `n` is the number of columns in the grid. - The space complexity should also be considered as O(m * n) due to the recursion stack in depth-first search. **Example 1:** ```plaintext Input: grid = [ [\'1\',\'1\',\'1\',\'1\',\'0\'], [\'1\',\'1\',\'0\',\'1\',\'0\'], [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'0\',\'0\',\'0\',\'0\',\'0\'] ] Output: 1 ``` **Example 2:** ```plaintext Input: grid = [ [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'0\',\'0\',\'1\',\'0\',\'0\'], [\'0\',\'0\',\'0\',\'1\',\'1\'] ] Output: 3 ``` Implement the function with careful consideration of edge cases, performance bottlenecks, and error scenarios mentioned in the algorithm analysis. ```python def num_islands(grid): # [Your code here] ```","solution":"def num_islands(grid): if not grid or not grid[0]: return 0 num_rows = len(grid) num_cols = len(grid[0]) num_islands = 0 def dfs(row, col): if row < 0 or col < 0 or row >= num_rows or col >= num_cols or grid[row][col] == \'0\': return grid[row][col] = \'0\' # mark as visited dfs(row - 1, col) # up dfs(row + 1, col) # down dfs(row, col - 1) # left dfs(row, col + 1) # right for row in range(num_rows): for col in range(num_cols): if grid[row][col] == \'1\': num_islands += 1 dfs(row, col) return num_islands"},{"question":"Objective: Design a function to sort an array using a more efficient algorithm than Exchange Sort. Task: Write a function called `improved_sort(arr)` which sorts an array of integers `arr` in ascending order. Your implementation should use a more efficient sorting algorithm with a better time complexity, such as QuickSort or MergeSort. Function Signature: ```python def improved_sort(arr: List[int]) -> List[int]: pass ``` Input: - An array of integers `arr` where `1 <= len(arr) <= 10^5` and `-10^9 <= arr[i] <= 10^9`. Output: - Returns a sorted array of integers in ascending order. Constraints: - Your solution must have a time complexity of O(n log n) on average. - Your solution must use an in-place sorting algorithm if possible to keep space complexity to a minimum. Example: ```python input: [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] output: [1, 1, 2, 3, 3, 4, 5, 5, 6, 9] ``` Note: You cannot use Python\'s built-in `sorted()` function; you must implement the sorting algorithm yourself. Context: Given the analysis above, Exchange Sort was found to be inefficient for large arrays. Your task is to implement a sorting algorithm with an improved time complexity that handles large datasets efficiently and sorts them in ascending order.","solution":"from typing import List def improved_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using QuickSort. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return improved_sort(left) + middle + improved_sort(right)"},{"question":"Context You are implementing a library that provides various mathematical functions. One of the functions you need to implement is a factorial function that includes the option to calculate the factorial modulo a given number. # Question Write a Python function `optimized_factorial` that: * Calculates the factorial of a non-negative integer `n`. * Optionally computes the result modulo a positive integer `mod`. * Uses an efficient iterative approach to ensure minimal memory usage. Function Signature ```python def optimized_factorial(n: int, mod: int = None) -> int: pass ``` Input * An integer `n` where `0 <= n <= 10^5`. * An optional integer `mod` where `1 <= mod <= 10^9`. Output * The factorial of `n`, optionally modulo `mod`. Constraints * The function should handle large values of `n` efficiently without causing overflow due to large factorial values. * The function should perform input validation and raise a `ValueError` if constraints are violated. * Provide the most optimized solution possible with respect to time and space complexity. Example ```python assert optimized_factorial(5) == 120 assert optimized_factorial(5, 13) == 3 assert optimized_factorial(0) == 1 assert optimized_factorial(1) == 1 assert optimized_factorial(10, 1000) == 800 ``` Notes * Ensure that your function is robust and handles all edge cases, including the optimal handling of the modulo operation to prevent overflow. * Add meaningful comments to explain the logic and any assumptions made.","solution":"def optimized_factorial(n: int, mod: int = None) -> int: Calculates the factorial of a non-negative integer `n`. Optionally computes the result modulo a positive integer `mod`. Args: n (int): Non-negative integer representing the factorial to compute. mod (int, optional): Positive integer for modulo operation. Returns: int: Factorial of `n`, optionally mod `mod`. Raises: ValueError: If n is negative or if mod is not a positive integer. if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and mod <= 0: raise ValueError(\\"mod must be a positive integer\\") result = 1 for i in range(2, n + 1): result *= i if mod is not None: result %= mod return result"},{"question":"# Tree Structure Visualization and Functions Given the tree structure represented as a dictionary of lists, implement a function to visualize the tree structure in a human-readable form. Each key in the dictionary represents a node, and its value is a list containing either more nested elements (signifying further sub-nodes) or ending elements. Extend the tree utilities with additional functionalities: 1. `find_node`: Locate and return all paths to a specific node. 2. `add_node`: Add a new node under a specified parent node. 3. `delete_node`: Remove a node and all its children, preserving the structure. # Requirements: 1. **Function Names**: `tree_print`, `find_node`, `add_node`, `delete_node`. 2. **Input/Output**: * `tree_print(tree: Dict[str, List[Union[str, list]]]) -> None`: Print tree structure. * `find_node(tree: Dict[str, List[Union[str, list]]], node: str) -> List[List[str]]`: Returns all paths to a specific node. * `add_node(tree: Dict[str, List[Union[str, list]]], parent: str, child: str) -> bool`: Add a child node under the specified parent. Returns `True` if successful, else `False`. * `delete_node(tree: Dict[str, List[Union[str, list]]], node: str) -> bool`: Recursively deletes the specified node and its children. Returns `True` if successful, else `False`. # Constraints: 1. Duplicate keys/nodes are not permitted. 2. Node values will be either strings or lists containing further nested structures. Example: ```python # Given tree dictionary tree = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, [\'Jill\', \'Sports\', 1]], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, [\'Quin\', \'Computer\', 3]], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } # Example outputs tree_print(tree) # Output visualization of the tree, following the structure rules. find_node(tree, \'Computer\') # [[\'b\', \'Computer\'], [\'d\', \'Computer\'], [\'d\', \'Quin\', \'Computer\'], [\'f\', \'Computer\']] add_node(tree, \'b\', [\'New\', \'Node\']) # Returns True if added successfully. delete_node(tree, \'e\') # Returns True if deleted successfully. ```","solution":"def tree_print(tree, level=0): for key, value in tree.items(): print(\\" \\" * level + str(key)) if isinstance(value, list): for sub in value: if isinstance(sub, list): tree_print({sub[0]: sub[1:]}, level + 1) else: print(\\" \\" * (level + 1) + str(sub)) def find_node(tree, target): paths = [] def _find(tree, target, current_path): for key, value in tree.items(): if key == target: paths.append(current_path + [key]) if isinstance(value, list): for i, sub in enumerate(value): if sub == target: paths.append(current_path + [key, target]) elif isinstance(sub, list): sub_tree = {sub[0]: sub[1:]} _find(sub_tree, target, current_path + [key]) _find(tree, target, []) return paths def add_node(tree, parent, child): def _add(tree, parent, child): for key, value in tree.items(): if key == parent: value.append(child) return True if isinstance(value, list): for sub in value: if isinstance(sub, list): sub_tree = {sub[0]: sub[1:]} if _add(sub_tree, parent, child): return True return False return _add(tree, parent, child) def delete_node(tree, target): found = False def _delete(tree, target): nonlocal found for key, value in list(tree.items()): if key == target: found = True del tree[key] return if isinstance(value, list): for i in range(len(value)): if isinstance(value[i], list) and value[i][0] == target: found = True del value[i] return elif isinstance(value[i], list): _delete({value[i][0]: value[i][1:]}, target) if found: del value[i] return _delete(tree, target) return found"},{"question":"Context You are developing a function to simulate a simple arithmetic operation in a non-traditional format. Specifically, you need to add one to a number represented as an array of its digits. Problem Statement Write a function `plus_one_alternative` that takes a list of non-negative integers representing a number (in big-endian format) and returns a new list that represents the number after adding one to it. Specifications * **Input**: A list of integers `digits` where each integer is a digit (0-9). * **Output**: A list of integers that represents the number after adding one. Constraints * The input list will not contain any negative numbers. * The list may be empty, in which case you should return [1]. * You should handle the carry over (when a digit becomes 10, it should become 0 and the next significant digit should increase by one). Examples ```python plus_one_alternative([1, 2, 3]) # Output: [1, 2, 4] plus_one_alternative([1, 9, 9]) # Output: [2, 0, 0] plus_one_alternative([9, 9, 9]) # Output: [1, 0, 0, 0] plus_one_alternative([]) # Output: [1] ``` Function Signature ```python def plus_one_alternative(digits: List[int]) -> List[int]: pass ``` You should focus on implementing the function efficiently, ensuring that it properly handles carry over and edge cases such as the list being empty or containing only nines.","solution":"from typing import List def plus_one_alternative(digits: List[int]) -> List[int]: if not digits: return [1] n = len(digits) for i in range(n-1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"Graph Traversal Assessment Question # Context In social networks, it is common to want to explore connections between users. Imagine you are given a social network graph where each node represents a user, and each edge represents a connection between two users. You need to implement graph traversal to help find all users connected to a particular user. # Task Write a function that performs a breadth-first search (BFS) traversal on a graph and returns the list of nodes in the order they are visited. Use this traversal to explore connections starting from a given user. # Function Signature ```python def bfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]: pass ``` # Input - `graph`: A dictionary where keys are node identifiers (integers) and values are lists of adjacent nodes (integers). - `start`: The starting node identifier (integer). # Output - Return a list of node identifiers (integers) in the order they are visited during the BFS traversal. # Constraints - The graph is unweighted and undirected. - Node identifiers are unique and represented as integers. - Assume that the graph is connected and contains at least one node. # Example ```python graph = { 1: [2, 3], 2: [1, 4, 5], 3: [1, 6, 7], 4: [2], 5: [2], 6: [3], 7: [3] } start = 1 # Expected output: [1, 2, 3, 4, 5, 6, 7] output = bfs_traversal(graph, start) print(output) # Output: [1, 2, 3, 4, 5, 6, 7] ``` # Notes - Ensure that the function visits each node only once. - Use a queue data structure to manage the BFS process. - Test your implementation with various graph structures including linear, star, and complete graphs to verify correctness and performance.","solution":"from collections import deque from typing import Dict, List def bfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]: Performs a breadth-first search (BFS) traversal on a graph and returns the list of nodes in the order they are visited. :param graph: A dictionary representing the graph where keys are node identifiers and values are lists of adjacent node identifiers. :param start: The starting node identifier. :return: A list of node identifiers in the order they are visited. visited = set() queue = deque([start]) result = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) result.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return result"},{"question":"# Question Context You are managing a database of user records stored in a Binary Search Tree (BST). Each user record is identified by a unique integer ID. Due to some business logic changes, you need to delete specific user records from this BST. Write a function to delete a node from the BST with the given key (user ID). If the node does not exist, return the original BST unchanged. Task Implement the function `delete_node` such that it modifies the BST to remove the node with the specified key. Ensure the tree properties are upheld after deletion. Input * A reference to the root node of a BST. * An integer `key` representing the user ID to be deleted. Output * The root of the possibly updated BST. Constraints 1. Each node in the BST has a unique integer value. 2. The function should be efficient with a time complexity target of O(height of tree). 3. You may assume the BST is valid and the input node keys are distinct. Example Input ``` root = [5,3,6,2,4,null,7] key = 3 ``` Output ``` A valid modified BST such as [5,4,6,2,null,null,7] or [5,2,6,null,4,null,7]. ``` Implementation Template ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def delete_node(self, root, key): :type root: TreeNode :type key: int :rtype: TreeNode # Implement the function to delete the node with the given key in the BST pass ``` Additional Test Cases 1. Deleting a non-existent node. 2. Deleting the root node of a single-node tree. 3. Deleting a node with only one child. 4. Deleting a node with two children.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: def delete_node(self, root, key): :type root: TreeNode :type key: int :rtype: TreeNode if not root: return root # Find the node to be deleted if key < root.val: root.left = self.delete_node(root.left, key) elif key > root.val: root.right = self.delete_node(root.right, key) else: # Node with only one child or no child if not root.left: return root.right elif not root.right: return root.left # Node with two children: Get the inorder successor temp = self.minValueNode(root.right) root.val = temp.val root.right = self.delete_node(root.right, temp.val) return root def minValueNode(self, node): current = node while current.left: current = current.left return current"},{"question":"# Question: You are tasked with implementing your version of RSA key generation and encrypt/decrypt operations. Using the information provided, complete the functions to meet the following requirements: Part 1: Generate Key Implement the `generate_key(bits)` function. - **Input**: `bits` - an integer, the number of bits in the modulus `n`. - **Output**: A tuple `(n, e, d)` - where `n` is the modulus, `e` is the public exponent, and `d` is the private exponent. Part 2: Encrypt Data Implement the `encrypt(data, e, n)` function. - **Input**: `data` - an integer to be encrypted, `e` - the public exponent, `n` - the modulus. - **Output**: The encrypted integer. Part 3: Decrypt Data Implement the `decrypt(data, d, n)` function. - **Input**: `data` - an encrypted integer, `d` - the private exponent, `n` - the modulus. - **Output**: The decrypted integer. Constraints: - You should generate prime numbers such that the bit length of `p` and `q` sum up to the bit length of `n`. - Ensure that `p` and `q` are not equal. - `data` to be encrypted should be smaller than `n`. - Optimize for performance where possible. # Example Usage: ```python n, e, d = generate_key(16) data = 20 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` # Additional Requirements: - Handle potential errors gracefully. - Include comments to explain the key parts of your implementation.","solution":"import random from sympy import isprime, mod_inverse def generate_prime(bits): while True: prime_candidate = random.getrandbits(bits) if isprime(prime_candidate): return prime_candidate def generate_key(bits): Generate RSA key pair. Parameters: bits (int): number of bits in modulus n Returns: tuple: (n, e, d) where n is the modulus, e is the public exponent, and d is the private exponent. half_bits = bits // 2 p = generate_prime(half_bits) q = generate_prime(half_bits) while p == q: q = generate_prime(half_bits) n = p * q phi = (p - 1) * (q - 1) e = 65537 # commonly used prime number for e d = mod_inverse(e, phi) return n, e, d def encrypt(data, e, n): Encrypt integer data using the public exponent and modulus. Parameters: data (int): integer to be encrypted e (int): public exponent n (int): modulus Returns: int: encrypted integer if data >= n: raise ValueError(\\"Data must be smaller than the modulus n\\") return pow(data, e, n) def decrypt(data, d, n): Decrypt integer data using the private exponent and modulus. Parameters: data (int): encrypted integer d (int): private exponent n (int): modulus Returns: int: decrypted integer return pow(data, d, n)"},{"question":"You are given an array of integers and need to perform efficient range queries on the array. One possible solution to this is to use a segment tree. Your task is to implement a segment tree that supports an arbitrary associative function. # Implementation Details You need to implement a class named `SegmentTree` that supports the following methods: - **`__init__(self, arr, function)`**: Constructor that initializes the segment tree with the array `arr` and the associative function `function`. The function should take two arguments and return a value of the same type. - **`make_tree(self, i, l, r)`**: A helper recursive function to build the segment tree from the given array. - **`__query(self, i, L, R, l, r)`**: A private method to perform range queries. - **`query(self, L, R)`**: A public method to query the range from index `L` to `R` (inclusive). # Constraints 1. The input function for combining the results must be associative (e.g., addition, minimum, maximum). 2. The input array will have a length of at most `10^5`. 3. The values in the array and the results of the function should fit within standard Python integers. # Input and Output Format **Input**: - The `__init__` method takes an array `arr` of integers and an associative function `function`. - The `query` method takes two integers `L` and `R`. **Output**: - The `query` method returns the result of applying the function over the specified range `[L, R]`. # Example ```python # Example 1 arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr, max) print(segment_tree.query(2, 4)) # Output: 5 (max in range [5, 3, 4]) # Example 2 arr = [4, 5, 2, 3, 4, 43, 3] segment_tree = SegmentTree(arr, sum) print(segment_tree.query(1, 6)) # Output: 60 (sum in range [5, 2, 3, 4, 43, 3]) ``` # Performance Requirements - Building the tree should not exceed O(N) time complexity. - Querying the tree should not exceed O(log N) time complexity.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.func = function self.tree = [None] * (2 * self.n) self._build_tree() def _build_tree(self): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = self.arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.func(self.tree[i * 2], self.tree[i * 2 + 1]) def __query(self, l, r): l += self.n r += self.n + 1 result = None while l < r: if l % 2: if result is None: result = self.tree[l] else: result = self.func(result, self.tree[l]) l += 1 if r % 2: r -= 1 if result is None: result = self.tree[r] else: result = self.func(result, self.tree[r]) l //= 2 r //= 2 return result def query(self, L, R): return self.__query(L, R)"},{"question":"# String Matching: Implement `strStr()` You are tasked with implementing the function `strStr(haystack, needle)` which receives two inputs: `haystack` and `needle`. The goal is to find the first occurrence of the string `needle` within the string `haystack` and return its index. If the `needle` is not part of the `haystack`, return -1. Function Signature: ```python def strStr(haystack: str, needle: str) -> int: pass ``` # Input: * `haystack`: A string of length `n` (1 ≤ n ≤ 10^4). * `needle`: A string of length `m` (0 ≤ m ≤ 10^4). # Output: * An integer representing the starting index of the first occurrence of `needle` within `haystack`, or -1 if `needle` is not present. # Key Constraints: * The `haystack` and `needle` are made only of printable ASCII characters. * The `needle` can be an empty string and in such case, the function should return 0. # Performance Requirements: While a brute force approach is acceptable for initial implementation, consider optimizing your solution to handle larger inputs efficiently. # Example Scenarios: Example 1: Input: `haystack = \\"hello\\"`, `needle = \\"ll\\"` Output: `2` Example 2: Input: `haystack = \\"aaaaa\\"`, `needle = \\"bba\\"` Output: `-1` Example 3: Input: `haystack = \\"\\"`, `needle = \\"a\\"` Output: `-1` Example 4: Input: `haystack = \\"abc\\"`, `needle = \\"\\"` Output: `0` # Additional Notes: * Think about edge cases like empty strings, non-overlapping characters from `haystack` and `needle`. * Optimize for both time and space complexity where possible. For larger inputs, explore more efficient algorithms beyond the brute force solution. * Ensure that your solution handles all the described edge cases properly.","solution":"def strStr(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack or -1 if needle is not part of haystack. # Edge case: if needle is an empty string, return 0 if not needle: return 0 # Length of the needle and haystack m, n = len(needle), len(haystack) # Iterate through the haystack for i in range(n - m + 1): if haystack[i:i+m] == needle: return i return -1"},{"question":"# Scenario You are developing a file management tool that needs to join directory paths and filenames to create a full path dynamically. While doing so, you have to ensure that slashes are correctly handled to avoid typographical errors in the generated paths. # Problem Statement Write a function `enhanced_join_with_slash(base, suffix)` that joins two strings representing paths/URLs and returns the combined path ensuring: 1. Exactly one slash between the base and suffix. 2. No trailing slashes at the end of the resulting path. 3. No double slashes in between. # Function Signature ```python def enhanced_join_with_slash(base: str, suffix: str) -> str: pass ``` # Input * `base` (string): The base path or URL. * `suffix` (string): The suffix part to be joined. # Output * (string): The combined full path as described above. # Constraints * The input strings can be any valid path/URL components. * Both inputs are non-null. * Handle both Windows (``) and Unix (`/`) style paths. # Example ```python assert enhanced_join_with_slash(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert enhanced_join_with_slash(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert enhanced_join_with_slash(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert enhanced_join_with_slash(\\"http://algorithms.com\\", \\"/part\\") == \\"http://algorithms.com/part\\" assert enhanced_join_with_slash(\\"\\", \\"myfile.txt\\") == \\"myfile.txt\\" assert enhanced_join_with_slash(\\"pathtodir\\", \\"file\\") == \\"pathtodirfile\\" ``` # Notes * If the base path is an empty string, the result should be simply the suffix. * If the suffix is an empty string, the result should be simply the base without trailing slashes. * Ensure cross-platform compatibility by considering both Unix-like and Windows path formats.","solution":"def enhanced_join_with_slash(base: str, suffix: str) -> str: Joins the base path/URL with the suffix ensuring a single slash between them, no trailing slashes at the end, and no double slashes in between. # Ensure base ends without any trailing slash base = base.rstrip(\'/\') # Ensure suffix starts without any leading slash suffix = suffix.lstrip(\'/\') # If either base or suffix is an empty string, return the non-empty component if base == \\"\\": return suffix if suffix == \\"\\": return base # Join with a single slash return f\\"{base}/{suffix}\\""},{"question":"Context & Scenario You have been hired by a company to help improve their inventory management system. One part of the system involves sorting a list of product prices to assist in price analysis. The existing system is using a very basic and inefficient sorting algorithm called \\"Exchange Sort\\". Your task is to replace it with a more efficient algorithm to handle the large datasets typically encountered in the system. Task Implement the `quick_sort` function to sort an array of numbers in ascending order. Your implementation should use the Quick Sort algorithm, which has a better average-case time complexity compared to the existing Exchange Sort. Function Signature ```python def quick_sort(arr): Sorts an array of numbers in ascending order using Quick Sort algorithm. Args: - arr (List[int]): A list of integers to be sorted. Returns: - List[int]: The sorted list of integers. ``` Input - `arr`: A list of integers (0 ≤ len(arr) ≤ 10^5, -10^5 ≤ arr[i] ≤ 10^5). Output - A list of integers sorted in ascending order. Constraints - You cannot use Python\'s built-in sorting functions. - The function should handle edge cases gracefully. - Aim for an average-case time complexity of (O(n log n)) and a space complexity of (O(log n)) due to recursion. Examples 1. Input: `[3, 6, 8, 10, 1, 2, 1]` Output: `[1, 1, 2, 3, 6, 8, 10]` 2. Input: `[1]` Output: `[1]` 3. Input: `[10, 7, 8, 9, 1, 5]` Output: `[1, 5, 7, 8, 9, 10]` # Notes - To ensure optimal performance, consider choosing the pivot using a method that reduces the chances of worst-case time complexity, such as ‘median-of-three’ or a randomized approach.","solution":"def quick_sort(arr): Sorts an array of numbers in ascending order using Quick Sort algorithm. Args: - arr (List[int]): A list of integers to be sorted. Returns: - List[int]: The sorted list of integers. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"# **Question Title: Implement Huffman Coding for File Compression** **Scenario**: You are asked to implement a class that can compress and decompress text files using Huffman Coding. As a file compression algorithm, Huffman Coding is widely used to reduce file sizes without losing any original information. **Objective**: Implement methods to read a file, compute the frequency of each character, build a Huffman tree, generate the corresponding binary codes for each character, and compress/decompress the file accordingly. # **Function Implementation Requirements**: 1. **Method name**: `encode_file` * **Description**: Compress the input file using Huffman Coding and write the encoded data to the output file. * **Input**: * `file_in_name` (string): The path to the input file to be compressed. * `file_out_name` (string): The path to the output file where compressed data will be written. * **Output**: None 2. **Method name**: `decode_file` * **Description**: Decompress the encoded input file using the Huffman tree and write the original data to the output file. * **Input**: * `file_in_name` (string): The path to the input file to be decompressed. * `file_out_name` (string): The path to the output file where the decompressed data will be written. * **Output**: None # **Constraints**: * The input file size can be up to 10 MB. * Characters in the file are limited to ASCII values (0-255). # **Example**: Suppose the input file \\"input.txt\\" contains: ``` AAAABBBCCDAA ``` Encoding this using Huffman coding would result in a compressed file (say compressed.huff) with a reduced size. Decoding the compressed file should regenerate the original content in a new file. **Steps**: 1. Calculate the frequency of each character in the input file. 2. Construct a Huffman Tree based on character frequencies. 3. Generate binary codes for each character by traversing the Huffman Tree. 4. Encode the input file\'s contents using the generated codes and write it to the output file. 5. To decode, read the Huffman Tree and binary codes from the compressed file and reconstruct the original data. # Implementation: You are provided with a partially implemented Huffman coding class. Your task is to complete the `encode_file` and `decode_file` methods to ensure they function correctly as described. **Note**: Ensure you handle cases where there are multiple character frequencies and the accuracy of data encoding/decoding.","solution":"import heapq class Node: def __init__(self, char, freq): self.char = char self.freq = freq self.left = None self.right = None def __lt__(self, other): return self.freq < other.freq class HuffmanCoding: def __init__(self): self.huffman_codes = {} self.reverse_mapping = {} def build_frequency_dict(self, text): frequency = {} for char in text: if char not in frequency: frequency[char] = 0 frequency[char] += 1 return frequency def build_huffman_tree(self, frequency): priority_queue = [Node(char, freq) for char, freq in frequency.items()] heapq.heapify(priority_queue) while len(priority_queue) > 1: node1 = heapq.heappop(priority_queue) node2 = heapq.heappop(priority_queue) merged = Node(None, node1.freq + node2.freq) merged.left = node1 merged.right = node2 heapq.heappush(priority_queue, merged) return heapq.heappop(priority_queue) def build_codes_helper(self, node, current_code): if node is None: return if node.char is not None: self.huffman_codes[node.char] = current_code self.reverse_mapping[current_code] = node.char return self.build_codes_helper(node.left, current_code + \\"0\\") self.build_codes_helper(node.right, current_code + \\"1\\") def build_codes(self, root): self.build_codes_helper(root, \\"\\") def get_encoded_text(self, text): encoded_text = \\"\\" for char in text: encoded_text += self.huffman_codes[char] return encoded_text def pad_encoded_text(self, encoded_text): extra_padding = 8 - len(encoded_text) % 8 for i in range(extra_padding): encoded_text += \\"0\\" padded_info = \\"{0:08b}\\".format(extra_padding) encoded_text = padded_info + encoded_text return encoded_text def get_byte_array(self, padded_encoded_text): if len(padded_encoded_text) % 8 != 0: print(\\"Encoded text not padded properly\\") exit(0) byte_array = bytearray() for i in range(0, len(padded_encoded_text), 8): byte = padded_encoded_text[i:i+8] byte_array.append(int(byte, 2)) return byte_array def encode_file(self, file_in_name, file_out_name): with open(file_in_name, \'r\') as file: text = file.read().rstrip() frequency = self.build_frequency_dict(text) huffman_tree_root = self.build_huffman_tree(frequency) self.build_codes(huffman_tree_root) encoded_text = self.get_encoded_text(text) padded_encoded_text = self.pad_encoded_text(encoded_text) byte_array = self.get_byte_array(padded_encoded_text) with open(file_out_name, \'wb\') as output: output.write(byte_array) def remove_padding(self, padded_encoded_text): padded_info = padded_encoded_text[:8] extra_padding = int(padded_info, 2) padded_encoded_text = padded_encoded_text[8:] encoded_text = padded_encoded_text[:-1 * extra_padding] return encoded_text def decode_text(self, encoded_text): current_code = \\"\\" decoded_text = \\"\\" for bit in encoded_text: current_code += bit if current_code in self.reverse_mapping: character = self.reverse_mapping[current_code] decoded_text += character current_code = \\"\\" return decoded_text def decode_file(self, file_in_name, file_out_name): with open(file_in_name, \'rb\') as file: bit_string = \\"\\" byte = file.read(1) while byte: byte = ord(byte) bits = bin(byte)[2:].rjust(8, \'0\') bit_string += bits byte = file.read(1) encoded_text = self.remove_padding(bit_string) decoded_text = self.decode_text(encoded_text) with open(file_out_name, \'w\') as output: output.write(decoded_text)"},{"question":"You have a stack of integers, and you need to remove the smallest integer from the stack using the given `remove_min` function. # Implement the following function: ```python def remove_min(stack): Removes the smallest value from the stack. Parameters: stack (list): A stack represented as a list of integers, where the last element is the top of the stack. Returns: list: The stack with the smallest value removed. # Your code here ``` # Input - The input parameter `stack` is a list of integers where the last element denotes the top of the stack. The length of `stack` will be at most 10^4. # Output - The function should return a stack (list) with the smallest value removed. # Constraints - If the stack is empty, return the empty stack. - Do not use any built-in Python functions or libraries that directly solve the problem (e.g., `min`, `sorted`). # Example ```python stack = [2, 8, 3, -6, 7, 3] print(remove_min(stack)) # Output: [2, 8, 3, 7, 3] stack = [] print(remove_min(stack)) # Output: [] stack = [1, 1, 1] print(remove_min(stack)) # Output: [1, 1] ``` # Explanation In the first example, the smallest value is `-6`. After removing it, the stack remains in the same order minus the `-6`. # Additional Requirements - Ensure that the algorithm has a time complexity of O(n) and a space complexity of O(n). - You may assume that the stack contains integers only.","solution":"def remove_min(stack): Removes the smallest value from the stack. Parameters: stack (list): A stack represented as a list of integers, where the last element is the top of the stack. Returns: list: The stack with the smallest value removed. if not stack: return stack min_value = float(\'inf\') min_index = -1 # Find the minimum value and its index for i in range(len(stack)): if stack[i] < min_value: min_value = stack[i] min_index = i # Create a new stack excluding the minimum value return [stack[i] for i in range(len(stack)) if i != min_index]"},{"question":"**Title**: Efficient GCD and LCM with Edge Case Handling **Objective**: In this question, you must implement functions to calculate the greatest common divisor (GCD) and the least common multiple (LCM) of two integers. Additionally, you will implement a function to count trailing zeroes in the binary representation of an integer. Lastly, you will optimize your GCD implementation using bitwise operations. **Description**: 1. Implement a function `gcd(a, b)` that computes the greatest common divisor of two integers `a` and `b` using the Euclidean algorithm. 2. Implement a function `lcm(a, b)` that computes the least common multiple of two integers `a` and `b` using the relationship lcm(a, b) = abs(a * b) / gcd(a, b). 3. Implement a function `trailing_zeroes(x)` that computes the number of trailing zeroes in the binary representation of an integer `x`. 4. Implement a function `gcd_bit(a, b)` that computes the greatest common divisor of two integers `a` and `b` using bitwise operations. **Function Signatures**: ```python def gcd(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def trailing_zeroes(x: int) -> int: pass def gcd_bit(a: int, b: int) -> int: pass ``` **Input and Output Formats**: - `gcd(a, b)`: - **Input**: Two integers `a`, `b` - **Output**: A single integer representing the GCD of `a` and `b` - `lcm(a, b)`: - **Input**: Two integers `a`, `b` - **Output**: A single integer representing the LCM of `a` and `b` - `trailing_zeroes(x)`: - **Input**: One integer `x` - **Output**: A single integer representing the count of trailing zeroes in binary representation of `x` - `gcd_bit(a, b)`: - **Input**: Two integers `a`, `b` - **Output**: A single integer representing the GCD of `a` and `b` computed using bitwise operations **Constraints**: - Inputs will be within the range of -10^9 to 10^9. - Ensure to handle edge cases such as zero inputs and negative integers appropriately. - Avoid using built-in functions like `math.gcd`. **Examples**: ```python # Example 1 assert gcd(48, 18) == 6 assert lcm(4, 5) == 20 assert trailing_zeroes(40) == 3 assert gcd_bit(48, 18) == 6 # Example 2 assert gcd(-48, 18) == 6 assert lcm(4, 5) == 20 assert trailing_zeroes(32) == 5 assert gcd_bit(-48, 18) == 6 ```","solution":"def gcd(a: int, b: int) -> int: Computes the greatest common divisor of a and b using the Euclidean algorithm while b: a, b = b, a % b return abs(a) def lcm(a: int, b: int) -> int: Computes the least common multiple of a and b using the relationship lcm(a, b) = abs(a * b) / gcd(a, b) return abs(a * b) // gcd(a, b) def trailing_zeroes(x: int) -> int: Computes the number of trailing zeroes in the binary representation of x if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bit(a: int, b: int) -> int: Computes the greatest common divisor of a and b using bitwise operations if a == 0: return abs(b) if b == 0: return abs(a) # Make both numbers positive a, b = abs(a), abs(b) shift = trailing_zeroes(a | b) # Remove all factors of 2 from both numbers a >>= trailing_zeroes(a) while b != 0: b >>= trailing_zeroes(b) if a > b: a, b = b, a b -= a return a << shift"},{"question":"You are to design a data structure named `EnhancedRandomizedSet` which enhances the existing `RandomizedSet` implementation to include the following additional operations: 1. **insert(val)**: Inserts an element `val` into the set if not already present. Returns `True` if the element was successfully inserted, `False` otherwise. 2. **remove(val)**: Removes an element `val` from the set if present. Returns `True` if the element was successfully removed, `False` otherwise. 3. **get_random()**: Returns a random element from current set of elements. Each element must have the same probability of being returned. 4. **contains(val)**: Returns `True` if the element `val` exists in the set, `False` otherwise. 5. **size()**: Returns the number of elements currently in the set. # Input and Output Format Your EnhancedRandomizedSet class should provide the following methods: 1. **insert(val: int) -> bool** - **Input**: An integer `val`. - **Output**: A boolean indicating success (True) or failure (False). 2. **remove(val: int) -> bool** - **Input**: An integer `val`. - **Output**: A boolean indicating success (True) or failure (False). 3. **get_random() -> int** - **Output**: Returns a random integer from the set. 4. **contains(val: int) -> bool** - **Input**: An integer `val`. - **Output**: A boolean indicating if the element exists in the set (True) or not (False). 5. **size() -> int** - **Output**: Returns the number of elements in the set. # Example ```python ers = EnhancedRandomizedSet() print(\\"insert 5: \\", ers.insert(5)) # Output: True print(\\"insert 10: \\", ers.insert(10)) # Output: True print(\\"contains 5: \\", ers.contains(5)) # Output: True print(\\"contains 15: \\", ers.contains(15)) # Output: False print(\\"size: \\", ers.size()) # Output: 2 print(\\"remove 5: \\", ers.remove(5)) # Output: True print(\\"remove 5: \\", ers.remove(5)) # Output: False print(\\"size: \\", ers.size()) # Output: 1 print(\\"random: \\", ers.get_random()) # Output: 10 (since only 10 is left) ``` # Constraints * All insert, remove, get_random, contains, and size operations must run in average O(1) time. * The set must handle negative integers and large integers within the constraints of a typical 32-bit integer range.","solution":"import random class EnhancedRandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val): if val in self.dict: return False self.dict[val] = len(self.list) self.list.append(val) return True def remove(self, val): if val not in self.dict: return False # Move the last element to the place of the element to remove last_element = self.list[-1] idx_to_replace = self.dict[val] self.list[idx_to_replace] = last_element self.dict[last_element] = idx_to_replace # Remove the last element self.list.pop() del self.dict[val] return True def get_random(self): return random.choice(self.list) def contains(self, val): return val in self.dict def size(self): return len(self.list)"},{"question":"# Scenario You are developing a file management system that needs to process various file paths. One crucial task is to split full paths into their directory and file parts to better manage and organize files. You need to implement a function that takes a path string and returns the directory path and the file name separately. # Task Write a Python function called `split_path` which accepts a single string argument representing a path and splits it into the directory and file name, returning a list of two strings. # Example - For the input path `https://example.com/resources/data.csv`, the output should be: ```python [\'https://example.com/resources\', \'data.csv\'] ``` - For the input path `documents/project/report.docx`, the output should be: ```python [\'documents/project\', \'report.docx\'] ``` # Input and Output Formats - **Input**: A single string that represents a file path. - **Output**: A list of two strings, where the first string is the directory path and the second string is the file name. # Constraints - The path will always contain at least one \'/\'. - Do not handle paths containing backslashes (``). - The function should handle both URLs and file paths. # Function Signature ```python def split_path(path: str) -> list[str]: pass ``` # Performance Requirements - The function should operate with a time complexity of O(n) where n is the length of the input path. - Space complexity should be O(n) for storing parts of the path. # Testing Ensure to test your function with paths of: - Various lengths. - Paths ending with \'/\'. - Paths with no directory (e.g., \'filename\'). - Complex directory structures.","solution":"def split_path(path: str) -> list[str]: Splits a given path into directory path and file name. Args: - path (str): The full path as a string. Returns: - list[str]: A list containing the directory path and the file name. import os directory, file_name = os.path.split(path) return [directory, file_name]"},{"question":"# Selection Sort and Prime Check Integration Objective Your task is to combine the Selection Sort algorithm with a functionality to check the prime numbers within the list. Problem Statement Implement a function `selection_sort_and_count_primes(arr: List[int]) -> Tuple[List[int], int]` that performs the following tasks: 1. Sort the input list `arr` using the Selection Sort algorithm. 2. Count and return the number of prime numbers in the list after sorting. Input * `arr`: A list of integers, where each integer will fit within the standard 32-bit signed integer range. Output * A tuple `(sorted_list, prime_count)`, where: * `sorted_list`: A list of integers sorted in ascending order. * `prime_count`: An integer representing the total number of prime numbers in the sorted list. Function Signature ```python from typing import List, Tuple def selection_sort_and_count_primes(arr: List[int]) -> Tuple[List[int], int]: pass ``` # Constraints 1. The length of `arr` will not exceed 10^3. 2. Each element within `arr` will be a non-negative integer. Example ```python # Example 1: arr = [29, 10, 14, 37, 13] output = selection_sort_and_count_primes(arr) # Expected output: ([10, 13, 14, 29, 37], 3) # Example 2: arr = [5, 4, 3, 2, 1] output = selection_sort_and_count_primes(arr) # Expected output: ([1, 2, 3, 4, 5], 3) ``` Notes * Ensure your function adheres to the given function signature. * Optimize your prime checking logic for efficiency. # Hints * Use a helper function to check if a number is prime. * Take care of edge cases such as lists containing the number `0` and `1`.","solution":"from typing import List, Tuple def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def selection_sort_and_count_primes(arr: List[int]) -> Tuple[List[int], int]: Sorts the list using Selection Sort and counts the prime numbers in the list. n = len(arr) prime_count = 0 for i in range(n): # Find the minimum element in remaining unsorted array min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] # Count prime if this is the final position assignment of the element if is_prime(arr[i]): prime_count += 1 return (arr, prime_count)"},{"question":"# Bucket Sort with Custom Bucket Allocation You are tasked with implementing a bucket sort algorithm to sort a list of floating-point numbers in the range [0, 1). Instead of using a fixed number of buckets, your implementation should allow the number of buckets to be a parameter to accommodate various input distributions more flexibly. # Function Signature ```python def bucket_sort(arr: List[float], bucket_count: int) -> List[float]: \'\'\' Sorts an array of floating-point numbers using bucket sort. Parameters: arr (List[float]): The list of floating-point numbers to be sorted. bucket_count (int): The number of buckets to be used for sorting. Returns: List[float]: The sorted list. \'\'\' ``` # Expected Input and Output Format Input: - A list `arr` containing `n` floating-point numbers in the range [0, 1). - An integer `bucket_count` indicating the number of buckets to be used. Output: - A sorted list of the input numbers. # Constraints - `0 <= len(arr) <= 10^6` - `0 < bucket_count <= len(arr)` for non-empty array # Example ```python # Example 1 arr = [0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] bucket_count = 5 print(bucket_sort(arr, bucket_count)) # Output: [0.12, 0.17, 0.21, 0.23, 0.26, 0.39, 0.68, 0.72, 0.78, 0.94] # Example 2 arr = [0.5, 0.5, 0.5] bucket_count = 2 print(bucket_sort(arr, bucket_count)) # Output: [0.5, 0.5, 0.5] ``` # Scenario Context You are developing an algorithm for a data visualization tool that handles decimal data points between 0 and 1 (non-inclusive) and requires them sorted for rendering purposes. Given the possibility of varying data distributions, the number of buckets will be dynamically adjusted to ensure optimal performance. Implement the `bucket_sort` function to provide a efficient sorting mechanism using bucket sort with a flexible number of buckets.","solution":"from typing import List def bucket_sort(arr: List[float], bucket_count: int) -> List[float]: Sorts an array of floating-point numbers using bucket sort. Parameters: arr (List[float]): The list of floating-point numbers to be sorted. bucket_count (int): The number of buckets to be used for sorting. Returns: List[float]: The sorted list. if not arr: return arr # Create buckets buckets = [[] for _ in range(bucket_count)] # Distribute input array values into buckets for num in arr: index = min(int(num * bucket_count), bucket_count - 1) buckets[index].append(num) # Sort individual buckets and concatenate results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Problem: Balanced Brackets Checker You are given a string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', and you need to determine if the input string is valid. A valid string meets the following criteria: 1. Each opening bracket must be closed by the same type of bracket. 2. Opening brackets must be closed in the correct order. 3. An empty string is considered valid. Implement a function `is_valid(s: str) -> bool` to check if the input string is valid. Input - A single string `s` that consists of characters \'(\', \')\', \'{\', \'}\', \'[\', \']\'. Output - Returns `True` if the string is valid, and `False` otherwise. Constraints - The string length will not exceed 10,000 characters. Examples 1. `is_valid(\\"()\\")` should return `True` 2. `is_valid(\\"()[]{}\\")` should return `True` 3. `is_valid(\\"(]\\")` should return `False` 4. `is_valid(\\"([)]\\")` should return `False` 5. `is_valid(\\"{[]}\\")` should return `True` # Hints - Use a stack data structure to track open brackets. - When encountering a closing bracket, check if it matches the top of the stack.","solution":"def is_valid(s: str) -> bool: Checks if the input string containing brackets is valid. # A stack to hold opening brackets stack = [] # A mapping of closing to opening brackets bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: # Get the top element from the stack if it isn\'t empty; otherwise, set a dummy value top_element = stack.pop() if stack else \'#\' # If the mapping for the opening bracket doesn\'t match the character, it\'s invalid if bracket_map[char] != top_element: return False else: # If it\'s an opening bracket, push it onto the stack stack.append(char) # If the stack is empty, all elements were properly closed return not stack"},{"question":"# ZigZag Iterator Question **Context**: You are tasked with implementing a data structure that take multiple lists and iterates over them in a round-robin fashion. This is useful in situations where data from different sources needs to be processed in an interleaved manner, ensuring that elements from each source are fairly distributed. **Problem Statement**: Design a class `ZigZagIterator` that supports the following two operations: 1. `next()`: Returns the next element in the interleaved order. 2. `has_next()`: Returns a boolean indicating whether any elements are remaining. The constructor receives two lists of integers. The iterator should output elements from the two lists alternately, and when one list is exhausted, continue with elements from the remaining list. **Function Signature**: ```python class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): def next(self) -> int: def has_next(self) -> bool: ``` **Input**: - The constructor receives two lists `v1` and `v2` of integers. **Output**: - `next()` returns the next integer from the two lists in interleaved order. - `has_next()` returns `True` if there is still a next element available, otherwise `False`. **Example**: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) output = [] while it.has_next(): output.append(it.next()) # Outputshould be: [1, 3, 2, 4, 5, 6] ``` **Constraints**: - None of the inputs are `None`. - Each list contains at most 1000 elements. - Each element in the list is a non-negative integer. **Performance Requirements**: - The `next()` and `has_next()` methods should run in O(1) time. **Note**: Consider the edge cases mentioned above while implementing your solution.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): self.data = [] idx1, idx2 = 0, 0 len1, len2 = len(v1), len(v2) # Interleave the two lists while idx1 < len1 or idx2 < len2: if idx1 < len1: self.data.append(v1[idx1]) idx1 += 1 if idx2 < len2: self.data.append(v2[idx2]) idx2 += 1 self.index = 0 def next(self) -> int: result = self.data[self.index] self.index += 1 return result def has_next(self) -> bool: return self.index < len(self.data)"},{"question":"# Rotate Right - Singly Linked List Problem Statement Given a singly linked list, rotate the list to the right by `k` places, where `k` is a non-negative integer. You need to implement this functionality efficiently. Function Signature ```python def rotate_right(head: \'ListNode\', k: int) -> \'ListNode\': ``` Input - `head`: The head of the singly linked list (type `ListNode`). - `k`: Non-negative integer, denotes the number of places to rotate the list (type `int`). Output - Returns the head of the rotated linked list (type `ListNode`). Details - A singly linked list is given where each node contains an integer value and a pointer to the next node. - Perform the rotation in-place. - The resulting linked list should be rotated to the right by `k` places. Example ``` Input: head = 1->2->3->4->5->NULL, k = 2 Output: 4->5->1->2->3->NULL ``` ``` Input: head = 0->1->2->NULL, k = 4 Output: 2->0->1->NULL ``` Constraints - If `k` is greater than or equal to the length of the list, rotate `k` modulo the length of the list. - The values in the nodes are within the range of 32-bit integers. Edge Cases - Handling of empty list (`head` is `None`). - Single node list. - `k` is zero (output is same as input). Performance Requirements - Time Complexity: O(n) - Space Complexity: O(1) Implementation Note The implementation must ensure that the linked list is handled correctly, considering circular linking and breaking the loop appropriately to get the desired result.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Calculate the length of the list and establish the end pointer length = 1 end = head while end.next: end = end.next length += 1 # Effective rotation k = k % length if k == 0: return head # Make it a circular list end.next = head # Find the new end of the rotated list new_end = head for _ in range(length - k - 1): new_end = new_end.next # The new head is the next node of the new end new_head = new_end.next new_end.next = None return new_head"},{"question":"You are tasked to implement a function that performs regular expression matching with support for `.` and `*` as described below. Your function should match the entire input string against the provided pattern. # Requirements - **Function Name**: `is_match` - **Input**: - `s` (`str`): The input string to match. Length is in the range [0, 1000]. - `p` (`str`): The pattern string to match against, containing the characters `a-z`, `.`, and `*`. Length is in the range [0, 1000]. - **Output**: - Boolean (`True`/`False`) indicating whether the input string matches the pattern. # Special Matching Rules - `.` Matches any single character. - `*` Matches zero or more of the preceding element. # Constraints - The matching must cover the entire input string (not partial). # Examples 1. `is_match(\\"aa\\", \\"a\\")` → `False` 2. `is_match(\\"aa\\", \\"aa\\")` → `True` 3. `is_match(\\"aaa\\", \\"aa\\")` → `False` 4. `is_match(\\"aa\\", \\"a*\\")` → `True` 5. `is_match(\\"aa\\", \\".*\\")` → `True` 6. `is_match(\\"ab\\", \\".*\\")` → `True` 7. `is_match(\\"aab\\", \\"c*a*b\\")` → `True` # Edge Cases to Consider - Empty input string and/or pattern. - Patterns containing consecutive `*` or `.` characters. - Patterns with `*` characters but no preceding element (e.g., `*a*`). # Function Signature ```python def is_match(s: str, p: str) -> bool: ``` # Example Explanation Consider the example `is_match(\\"aab\\", \\"c*a*b\\")`: - `c*` matches 0 occurrences of \'c\' - `a*` matches 2 occurrences of \'a\' - `b` matches \'b\' Hence, the output is `True`.","solution":"def is_match(s: str, p: str) -> bool: Implement a function that performs regex matching with support for \'.\' and \'*\'. # Define function for regex matching def dp(i, j): if j == len(p): return i == len(s) first_match = i < len(s) and (p[j] == s[i] or p[j] == \'.\') if j + 1 < len(p) and p[j + 1] == \'*\': return dp(i, j + 2) or (first_match and dp(i + 1, j)) else: return first_match and dp(i + 1, j + 1) return dp(0, 0)"},{"question":"Given a positive integer (n), write a function to find all of its primitive roots. If no primitive root exists, the function should return an empty list. # Function Signature ```python def find_primitive_root(n: int) -> List[int]: ``` # Input - `n`: A positive integer (n (1 leq n leq 10^5)). # Output - A list of integers that are the primitive roots of (n), if any exist. # Constraints - (1 leq n leq 10^5) - Handle edge cases such as (n = 1), (n) being composite, and prime. # Performance Requirements - Ensure the implementation is efficient with respect to time complexity, potentially involving optimizations or efficient caching. # Example ```python assert find_primitive_root(9) == [2, 5] assert find_primitive_root(1) == [0] assert find_primitive_root(10) == [] ``` # Additional Notes - Ensure the function properly handles all edge cases, like (n) being 1 and non-prime numbers. - The function should consider optimization opportunities for performance due to constraints.","solution":"from math import gcd from typing import List def find_primitive_root(n: int) -> List[int]: Finds all primitive roots of given positive integer n. if n <= 1: return [] # Check if n is a prime number def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True # Function to find prime factors of a number def prime_factors(num): factors = set() while num % 2 == 0: factors.add(2) num //= 2 for i in range(3, int(num**0.5)+1, 2): while num % i == 0: factors.add(i) num //= i if num > 2: factors.add(num) return factors if not is_prime(n): return [] # Find the primitive root of a prime n phi = n - 1 factors = prime_factors(phi) def is_primitive_root(g): for factor in factors: if pow(g, phi // factor, n) == 1: return False return True primitive_roots = [] for g in range(2, n): if is_primitive_root(g): primitive_roots.append(g) return primitive_roots"},{"question":"# Implementing a Doubly Linked List with Ordered Insertion You are asked to implement a doubly linked list that maintains the elements in a sorted order. The doubly linked list should support the operations of inserting elements while keeping the list sorted, deleting elements, and displaying the list in both forward and backward directions. Function Specification: **Class: DoublyLinkedList** * **Methods**: 1. **insert(value: int) -> None**: Insert a new node with the given value in its correct sorted position. 2. **delete(value: int) -> None**: Delete the first occurrence of the node with the given value. If the node does not exist, no action should be taken. 3. **display_forward() -> List[int]**: Return a list of all elements in the linked list in forward traversal order. 4. **display_backward() -> List[int]**: Return a list of all elements in the linked list in backward traversal order. Input Constraints: * The values will be integers. * The list will be initially empty. * Operations will be called in any order. Example Usage: ```python dll = DoublyLinkedList() dll.insert(5) dll.insert(3) dll.insert(7) print(dll.display_forward()) # Output: [3, 5, 7] print(dll.display_backward()) # Output: [7, 5, 3] dll.delete(5) print(dll.display_forward()) # Output: [3, 7] print(dll.display_backward()) # Output: [7, 3] dll.delete(10) # No action, as 10 is not in the list. print(dll.display_forward()) # Output: [3, 7] print(dll.display_backward()) # Output: [7, 3] ``` Constraints: * The list should remain sorted after each insertion. * Handle cases where the list becomes empty after deletions. * Aim for efficient operations with minimal traversals.","solution":"class Node: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert(self, value: int) -> None: new_node = Node(value) if self.head is None: self.head = self.tail = new_node return current = self.head while current is not None and current.value < value: prev = current current = current.next if current == self.head: new_node.next = self.head self.head.prev = new_node self.head = new_node elif current is None: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node else: new_node.next = current new_node.prev = current.prev current.prev.next = new_node current.prev = new_node def delete(self, value: int) -> None: current = self.head while current is not None and current.value != value: current = current.next if current is None: return if current.prev is not None: current.prev.next = current.next else: # current is the head self.head = current.next if current.next is not None: current.next.prev = current.prev else: # current is the tail self.tail = current.prev def display_forward(self) -> list: result = [] current = self.head while current is not None: result.append(current.value) current = current.next return result def display_backward(self) -> list: result = [] current = self.tail while current is not None: result.append(current.value) current = current.prev return result"},{"question":"You are given a list of unique integers and a target integer. Your task is to determine the number of comparisons made during a linear search for the target integer in the list. The target integer may or may not be present in the list. Implement the function `count_linear_search_comparisons(array, target)` to achieve this. Input * `array`: A list of unique integers (1 ≤ length of array ≤ 1000). * `target`: An integer to search for within the array. Output * An integer representing the number of comparisons made during the search. Constraints * The elements in the array are unique. * The length of the array is between 1 and 1000 inclusive. Example ```python array = [10, 15, 30, 20, 5] target = 20 print(count_linear_search_comparisons(array, target)) # Output: 4 array = [1, 2, 3, 4, 5] target = 6 print(count_linear_search_comparisons(array, target)) # Output: 5 ``` Explanation In the first example, the function makes 4 comparisons before finding the target 20 at index 3. In the second example, the function makes 5 comparisons before concluding the target 6 is not in the list, returning 5 as it checks each element once.","solution":"def count_linear_search_comparisons(array, target): Returns the number of comparisons made during a linear search for the target integer in the list. comparisons = 0 for element in array: comparisons += 1 if element == target: break return comparisons"},{"question":"# Problem: Constructing Valid File Paths and URLs You are working on a project that involves managing file paths and constructing URLs dynamically. It is important that these paths and URLs are constructed correctly to avoid issues related to incorrect file locations or broken links. Task: Write a function, `join_with_slash`, that takes two strings, `base` and `suffix`, and returns a combined path or URL, ensuring only a single slash is used to separate them. Function Signature: ```python def join_with_slash(base: str, suffix: str) -> str: ``` Input: * `base` (str): The initial part of the path or URL. It may or may not end with a slash. * `suffix` (str): The additional part to be combined with the base. It may or may not start with a slash. Output: * (str): A combined path or URL that uses exactly one slash to join the base and suffix. Constraints: * Both `base` and `suffix` are non-empty strings. * The combined length of `base` and `suffix` does not exceed 10^6. * The inputs do not contain any characters that are invalid in file paths or URLs. Example: ```python assert join_with_slash(\\"http://example.com\\", \\"path/to/resource\\") == \\"http://example.com/path/to/resource\\" assert join_with_slash(\\"http://example.com/\\", \\"/path/to/resource/\\") == \\"http://example.com/path/to/resource\\" assert join_with_slash(\\"folder/subdir\\", \\"file.txt\\") == \\"folder/subdir/file.txt\\" assert join_with_slash(\\"folder/subdir/\\", \\"/file.txt/\\") == \\"folder/subdir/file.txt\\" ``` Edge Cases: * Ensure that if the `base` ends with a slash and the `suffix` starts with a slash, only one slash should separate them in the result. * If the `base` ends without a slash and `suffix` starts without a slash, a single slash should separate them. Write the `join_with_slash` function to handle these requirements appropriately and return the expected results.","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins two parts of a path or URL with a single slash. Ensures there is only one slash between the base and the suffix. if base.endswith(\'/\') and suffix.startswith(\'/\'): return base[:-1] + suffix elif not base.endswith(\'/\') and not suffix.startswith(\'/\'): return base + \'/\' + suffix else: return base + suffix"},{"question":"# Context: You are developing a system that frequently needs to insert and delete elements while occasionally retrieving a random element. To optimize performance, you\'ve decided to design a custom data structure that supports these operations efficiently. # Objective: Implement a `RandomizedSet` class that should meet the following requirements: * `insert(val)`: Inserts an item `val` to the set if it is not already present. Returns `True` if the item was not present, `False` otherwise. * `remove(val)`: Removes an item `val` from the set if it is present. Returns `True` if the item was present, `False` otherwise. * `random_element()`: Returns a random element from the current set of elements. Each element must have the same probability of being returned. # Requirements: 1. All operations (`insert`, `remove`, and `random_element`) must operate in average O(1) time. 2. Handle all valid edge cases, such as inserting duplicate values and removing nonexistent values. 3. If `random_element()` is called on an empty set, you can assume that the behavior is undefined (you do not need to handle it explicitly). # Input/Output Format: * **Insert Function Input**: `val` (Any valid integer) * **Insert Function Output**: `True` if the item was not present, `False` otherwise. * **Remove Function Input**: `val` (Any valid integer) * **Remove Function Output**: `True` if the item was present, `False` otherwise. * **random_element Function Output**: A random integer from the set. # Code Template: ```python import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.elements = [] self.index_map = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns True if the set did not already contain the specified element. if val in self.index_map: return False self.elements.append(val) self.index_map[val] = len(self.elements) - 1 return True def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the set contained the specified element. if val not in self.index_map: return False index = self.index_map[val] last_element = self.elements[-1] self.elements[index] = last_element self.index_map[last_element] = index self.elements.pop() del self.index_map[val] return True def random_element(self) -> int: Gets a random element from the set. return random.choice(self.elements) # Example of usage randomizedSet = RandomizedSet() print(randomizedSet.insert(1)) # Returns True print(randomizedSet.remove(2)) # Returns False print(randomizedSet.insert(2)) # Returns True print(randomizedSet.random_element()) # Returns either 1 or 2 print(randomizedSet.remove(1)) # Returns True print(randomizedSet.insert(2)) # Returns False print(randomizedSet.random_element()) # Returns 2 ``` Validate the correct implementation by testing against various inputs, ensuring efficiency and correct handling of edge cases.","solution":"import random class RandomizedSet: def __init__(self): Initialize your data structure here. self.elements = [] self.index_map = {} def insert(self, val: int) -> bool: Inserts a value to the set. Returns True if the set did not already contain the specified element. if val in self.index_map: return False self.elements.append(val) self.index_map[val] = len(self.elements) - 1 return True def remove(self, val: int) -> bool: Removes a value from the set. Returns True if the set contained the specified element. if val not in self.index_map: return False index = self.index_map[val] last_element = self.elements[-1] self.elements[index] = last_element self.index_map[last_element] = index self.elements.pop() del self.index_map[val] return True def random_element(self) -> int: Gets a random element from the set. return random.choice(self.elements)"},{"question":"# Graph Pathfinding Question You are tasked with implementing a function to find the shortest path between two nodes in a directed, weighted graph. The graph is represented as an adjacency list, where each node points to a list of tuples representing the connected nodes and the respective edge weights. Input * An adjacency list `graph` where `graph[u]` is a list of tuples `(v, w)`, with `v` representing a node and `w` representing the edge weight from `u` to `v`. * Two nodes, `start` and `end`, representing the start and end points for the path. Output * A list of nodes representing the shortest path from `start` to `end`. If no path exists, return an empty list. Constraints * The graph will have at most `1000` nodes. * Edge weights are positive integers. * The graph is directed and may contain cycles. Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 4)], \'B\': [(\'C\', 2), (\'D\', 5)], \'C\': [(\'D\', 1)], \'D\': [] } start = \'A\' end = \'D\' # Expected Output: [\'A\', \'B\', \'C\', \'D\'] ``` Notes * Consider using an efficient pathfinding algorithm such as Dijkstra\'s algorithm to handle weighted edges. * Pay attention to edge cases such as no available path and cycles in the graph.","solution":"import heapq def shortest_path(graph, start, end): Finds the shortest path in a directed, weighted graph from start to end. # Priority queue to store (distance, node, path) priority_queue = [(0, start, [start])] visited = set() while priority_queue: current_distance, current_node, path = heapq.heappop(priority_queue) if current_node in visited: continue visited.add(current_node) # If we reach the end node, return the path if current_node == end: return path # Explore the neighbors for neighbor, weight in graph.get(current_node, []): if neighbor not in visited: heapq.heappush(priority_queue, (current_distance + weight, neighbor, path + [neighbor])) # If no path found, return an empty list return []"},{"question":"**Context:** You are a software engineer tasked with managing a large-scale database system that requires efficient data storage and quick retrieval. Using a B-tree as the backbone for your data structure, you are to implement the insertion and search functionalities, ensuring that the tree remains balanced and efficient under heavy usage. # Problem Statement: Implement the BTree class with methods to insert and search keys efficiently. The B-tree should maintain its properties as a balanced tree where each node except the root has a minimum number of keys, and keys within nodes are ordered. # Function Descriptions: 1. **insert_key(self, key: int) -> None**: * Inserts a given key into the B-tree. * Handles cases where nodes need splitting. 2. **find(self, key: int) -> bool**: * Searches for a given key in the B-tree. * Returns `True` if the key is found; `False` otherwise. # Input and Output: * **Input**: * `insert_key(self, key: int) -> None` - Inserts a key into the B-tree. - `key`: The integer value to insert. * `find(self, key: int) -> bool` - Searches for a key in the B-tree. - `key`: The integer value to search. - Returns `True` if the key is found; `False` otherwise. # Constraints: * Only non-negative integer keys will be provided. * Handle multiple insertions and searches efficiently. * The degree of the B-tree (t) will be given as an input parameter at the time of instantiation. # Example Usage: ```python # Create a B-tree with degree 3 btree = BTree(t_val=3) # Insert keys btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Search for keys print(btree.find(6)) # Output: True print(btree.find(15)) # Output: False ``` # Implementation Note: Ensure your implementation handles edge cases related to node splitting and maintains the properties of the B-tree effectively.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, False otherwise self.keys = [] # List of keys in the node self.children = [] # List of children BTreeNode references def insert_non_full(self, key): i = len(self.keys) - 1 if self.leaf: self.keys.append(0) while i >= 0 and self.keys[i] > key: self.keys[i + 1] = self.keys[i] i -= 1 self.keys[i + 1] = key else: while i >= 0 and self.keys[i] > key: i -= 1 if len(self.children[i + 1].keys) == 2 * self.t - 1: self.split_child(i + 1) if self.keys[i + 1] < key: i += 1 self.children[i + 1].insert_non_full(key) def split_child(self, i): t = self.t y = self.children[i] z = BTreeNode(t, y.leaf) self.children.insert(i + 1, z) self.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t - 1)] y.keys = y.keys[:t - 1] if not y.leaf: z.children = y.children[t:(2 * t)] y.children = y.children[:t] def search(self, key): i = 0 while i < len(self.keys) and key > self.keys[i]: i += 1 if i < len(self.keys) and self.keys[i] == key: return True if self.leaf: return False return self.children[i].search(key) class BTree: def __init__(self, t_val): self.root = BTreeNode(t_val, True) self.t = t_val def insert_key(self, key): root = self.root if len(root.keys) == 2 * self.t - 1: temp = BTreeNode(self.t, False) self.root = temp temp.children.insert(0, root) temp.split_child(0) temp.insert_non_full(key) else: root.insert_non_full(key) def find(self, key): return self.root.search(key)"},{"question":"# Hailstone Sequence Analyzer Context The hailstone sequence is a mathematical sequence defined as follows: * Start with any positive integer n. * If n is 1, the sequence is complete. * If n is even, the next number in the sequence is n / 2. * If n is odd, the next number in the sequence is 3n + 1. * Repeat the process with the new value of n. Objective Write a function that generates the hailstone sequence starting from a given positive integer n. Additionally, analyze the sequence to determine the number of steps it takes to reach 1 and the maximum value encountered during the sequence. Function Signature ```python def analyze_hailstone(n: int) -> Tuple[List[int], int, int]: Generate the hailstone sequence from n and analyze its properties. Parameters: n (int): The starting integer Returns: Tuple: List[int]: The hailstone sequence int: The number of steps to reach 1 int: The maximum value encountered in the sequence ``` Input * A single integer, n (1 ≤ n ≤ 10^6). * You may assume n is always a positive integer. Output * A tuple consisting of: - A list containing the hailstone sequence starting with n and ending with 1. - An integer representing the number of steps it takes for the sequence to reach 1. - An integer representing the maximum value encountered in the sequence. Constraints * Your implementation should efficiently handle the edge cases and constraints on n up to 10^6. * Implement validation checks to handle edge cases like unexpected non-positive inputs gracefully. Example ```python analyze_hailstone(7) # Output: ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 16, 52) analyze_hailstone(1) # Output: ([1], 0, 1) ``` Explanation In the first example: - The sequence starting at 7 is [7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]. - It takes 16 steps to reach 1. - The maximum value encountered in this sequence is 52. In the second example: - The sequence starting at 1 is simply [1]. - It takes 0 steps to reach 1 (since it starts at 1). - The maximum value encountered in this sequence is 1. Implement the function as per the given specifications and ensure to handle edge cases accurately.","solution":"from typing import List, Tuple def analyze_hailstone(n: int) -> Tuple[List[int], int, int]: Generate the hailstone sequence from n and analyze its properties. Parameters: n (int): The starting integer Returns: Tuple: List[int]: The hailstone sequence int: The number of steps to reach 1 int: The maximum value encountered in the sequence if n <= 0: raise ValueError(\\"Input must be a positive integer.\\") sequence = [] steps = 0 max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > max_value: max_value = n steps += 1 sequence.append(1) # Append the final 1 to the sequence return sequence, steps, max_value"},{"question":"You are given a chaotic queue. Each person in the queue is described by a pair of integers (h, k), where: - h is the height of the person. - k is the number of people standing in front of this person with a height greater than or equal to h. Your task is to write an algorithm to reconstruct the queue such that the conditions are met for each person. # Inputs and Outputs **Input**: - A list of `n` pairs of integers. Each pair `(h, k)` represents a person\'s height `h` and the number of people `k` in front of the person who have a height greater than or equal to `h`. - The number of people `n` is less than 1,100. **Output**: - A list of `n` pairs of integers representing the reconstructed queue. # Constraints - All pairs are valid integers. - There may be multiple valid outputs. Return any of them. # Example **Input**: ```python [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] ``` **Output**: ```python [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] ``` # Function Signature ```python def reconstruct_queue(people: List[List[int]]) -> List[List[int]]: pass ``` # Assumptions and Requirements - You can assume all inputs are valid. - Try to optimize for time and space within the given constraints. *Performance Requirement:* Your solution should aim to reconstruct the queue in less than O(n^2) time complexity if possible. # Tips - Think about how to best use sorting to simplify the problem. - Consider using a greedy approach for efficiency.","solution":"def reconstruct_queue(people): Reconstruct the queue given the list of people described by their height and the number of people in front of them with a greater height. :param people: List[List[int]] - A list of pairs where each pair (h, k) represents a person\'s height \'h\' and the number \'k\' of people with height greater than or equal to \'h\' in front of this person. :return: List[List[int]] - The reconstructed queue. # Sort the list with two key points: # 1. Sort by height in descending order. # 2. For people with the same height, sort by the number of people in front in ascending order. people.sort(key=lambda x: (-x[0], x[1])) # Initialize an empty list to hold the reconstructed queue. queue = [] # Insert each person into the queue using their \'k\' value as the position index. for person in people: queue.insert(person[1], person) return queue"},{"question":"# Question You are tasked with writing a function that manipulates a stack by switching successive pairs of numbers starting from the bottom. If there are an odd number of elements in the stack, the value at the top (`stack[-1]`) should remain unmoved. Given the following initial stack values: ``` bottom [3, 8, 17, 9, 1, 10] top ``` Your function should transform it to: ``` bottom [8, 3, 9, 17, 10, 1] top ``` If the stack is: ``` bottom [3, 8, 17, 9, 1] top ``` It should transform to: ``` bottom [8, 3, 9, 17, 1] top ``` You need to implement two versions of this function: 1. `first_switch_pairs` which uses another stack as auxiliary storage. 2. `second_switch_pairs` which uses a queue as auxiliary storage. **Function Signatures:** ```python def first_switch_pairs(stack: list) -> list: pass def second_switch_pairs(stack: list) -> list: pass ``` # Input * `stack` (List[int]): A list of integers representing the stack, with indices increasing from bottom to top. # Output * Each function returns the stack after switching pairs of elements as described. # Constraints 1. The input stack can be empty or have up to 10^5 elements. 2. Elements of the stack are integers in the range of [-10^9, 10^9]. # Performance Requirements * Solutions should have a time complexity of O(n) and space complexity of O(n). # Example Example 1: ```python stack = [3, 8, 17, 9, 1, 10] result = first_switch_pairs(stack) print(result) # Output: [8, 3, 9, 17, 10, 1] result = second_switch_pairs(stack) print(result) # Output: [8, 3, 9, 17, 10, 1] ``` Example 2: ```python stack = [3, 8, 17, 9, 1] result = first_switch_pairs(stack) print(result) # Output: [8, 3, 9, 17, 1] result = second_switch_pairs(stack) print(result) # Output: [8, 3, 9, 17, 1] ```","solution":"def first_switch_pairs(stack: list) -> list: if not stack: return stack n = len(stack) aux_stack = [] # Move all elements to auxiliary stack while rearranging pairs for i in range(n): if i % 2 == 0 and i + 1 < n: aux_stack.append(stack[i+1]) aux_stack.append(stack[i]) elif i % 2 == 0: aux_stack.append(stack[i]) return aux_stack def second_switch_pairs(stack: list) -> list: if not stack: return stack from collections import deque queue = deque(stack) n = len(stack) aux_stack = [] # Rearrange pairs using the queue for i in range(n): if i % 2 == 0 and i + 1 < n: aux_stack.append(queue.popleft()) aux_stack.append(queue.popleft()) aux_stack[-2], aux_stack[-1] = aux_stack[-1], aux_stack[-2] elif i % 2 == 0: aux_stack.append(queue.popleft()) return aux_stack"},{"question":"In a given binary tree, you need to find all the root-to-leaf paths and return them as a list of strings. Each string should represent the path concatenated with \'->\' between consecutive nodes. # Problem Statement Write a function `binary_tree_paths` that takes in the root of a binary tree and returns a list of all root-to-leaf paths. # Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: ``` # Input - `root`: a `TreeNode` object which is the root of the binary tree. A `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output - A list of strings, where each string represents a root-to-leaf path in the binary tree. # Constraints - The number of nodes in the tree is in the range `[0, 1000]`. - -100 <= Node.val <= 100 # Examples ```python Input: root = [1,2,3,null,5] Output: [\\"1->2->5\\", \\"1->3\\"] Input: root = [1] Output: [\\"1\\"] ``` # Notes - The output can be in any order. - If the tree is empty, return an empty list. # Additional Considerations - Ensure to handle null nodes when constructing paths. - Utilize a recursive DFS approach similar to the provided code snippet to traverse the tree and build paths.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: if not root: return [] def dfs(node: TreeNode, path: str, paths: List[str]): if not node.left and not node.right: paths.append(path) if node.left: dfs(node.left, path + \'->\' + str(node.left.val), paths) if node.right: dfs(node.right, path + \'->\' + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"Finding the Range of a Target in a Sorted Array Objective: Implement a more efficient algorithm to find the starting and ending positions of a given target value in a sorted array of integers. If the target is not found, return [-1, -1] Input: - `nums` (List[int]): A sorted list of integers. - `target` (int): An integer representing the target value to be found in the list. Output: - Return a list of two integers [start, end] where \'start\' is the first index of the target value in the list and \'end\' is the last index of the target value. If the target is not found, return [-1, -1]. Constraints: - The array is sorted in ascending order. - Try to achieve a time complexity better than (O(n)). - Use an in-place solution with (O(1)) space complexity beyond the input. Performance Requirements: - The implemented solution should optimize the array traversal to avoid unnecessary checks. Example: ```python Input: nums = [5,7,7,8,8,8,10], target = 8 Output: [3,5] Input: nums = [5,7,7,8,8,8,10], target = 11 Output: [-1, -1] Input: nums = [], target = 8 Output: [-1, -1] ``` Explanation: - In the first example, the target value `8` starts at index 3 and ends at index 5. - In the second example, the target value `11` is not present in the array. - In the third example, the input array is empty, hence the target `8` is not found. Function Signature: ```python def search_range(nums: List[int], target: int) -> List[int]: pass ```","solution":"def search_range(nums, target): Finds the starting and ending positions of a target value in a sorted array. Parameters: nums (List[int]): A sorted list of integers. target (int): The target value to find in the list. Returns: List[int]: A list containing the starting and ending positions of the target value, or [-1, -1] if the target is not found. def find_left(nums, target): Binary search helper to find the left boundary of the target. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] < target: left = mid + 1 else: right = mid - 1 return left def find_right(nums, target): Binary search helper to find the right boundary of the target. left, right = 0, len(nums) - 1 while left <= right: mid = left + (right - left) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 return right left_index = find_left(nums, target) right_index = find_right(nums, target) if left_index <= right_index and left_index < len(nums) and nums[left_index] == target: return [left_index, right_index] return [-1, -1]"},{"question":"# Task Implement an in-place version of the matrix rotation and inversion functions that achieve the same results as the provided functions but without using additional space for a new matrix. # Function Signatures ```python def rotate_clockwise_inplace(matrix: List[List[int]]) -> None: pass def rotate_counterclockwise_inplace(matrix: List[List[int]]) -> None: pass def top_left_invert_inplace(matrix: List[List[int]]) -> None: pass def bottom_left_invert_inplace(matrix: List[List[int]]) -> None: pass ``` # Input - A square matrix (list of lists) of integers, where each sublist is of equal length, representing rows of the matrix. # Output - The functions should modify the input matrix in place and return `None`. # Constraints - The input matrices will be non-empty square matrices with dimensions N x N (1 ≤ N ≤ 1000). # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] rotate_clockwise_inplace(matrix) # matrix after rotation should now be: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3], # ] rotate_counterclockwise_inplace(matrix) # matrix after counterclockwise rotation should now be back to initial state: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9], # ] top_left_invert_inplace(matrix) # matrix after top-left inversion should be: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9], # ] bottom_left_invert_inplace(matrix) # matrix after bottom-left inversion should be back to initial state: # [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9], # ] ``` # Note Ensure that your solution modifies the matrix in place and handles all edge cases effectively.","solution":"from typing import List def rotate_clockwise_inplace(matrix: List[List[int]]) -> None: n = len(matrix) # Step 1: Transpose for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse() def rotate_counterclockwise_inplace(matrix: List[List[int]]) -> None: n = len(matrix) # Step 1: Transpose for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each column for j in range(n): for i in range(n//2): matrix[i][j], matrix[n-1-i][j] = matrix[n-1-i][j], matrix[i][j] def top_left_invert_inplace(matrix: List[List[int]]) -> None: n = len(matrix) for i in range(n): for j in range(i+1, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] def bottom_left_invert_inplace(matrix: List[List[int]]) -> None: n = len(matrix) for i in range(n): for j in range(i): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]"},{"question":"Given an `n x m` matrix, implement a function `transpose_diagonal(matrix)` that transposes the matrix along its main diagonal, i.e., the element at position [i, j] should move to position [j, i]. # Input: * `matrix`: A list of lists representing the `n x m` matrix. (1 ≤ n, m ≤ 1000) # Output: * Return the transposed matrix as a list of lists. # Constraints: * The input matrix can be non-square. * Do not use any external libraries for this task. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = transpose_diagonal(matrix) # Output: [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] ``` # Note: 1. Consider the complexities involved while iterating through the matrix. 2. Ensure to handle edge cases like empty matrix or single element matrix. 3. Thoroughly test your implementation with various matrix sizes before submission.","solution":"def transpose_diagonal(matrix): Transposes an n x m matrix along its main diagonal. The element at position [i, j] moves to position [j, i]. Args: matrix (list of lists): The n x m matrix to transpose. Returns: list of lists: The transposed m x n matrix. if not matrix or not matrix[0]: return [] n = len(matrix) m = len(matrix[0]) transposed_matrix = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): transposed_matrix[j][i] = matrix[i][j] return transposed_matrix"},{"question":"# Matrix Multiplication Assessment You are tasked with implementing a matrix multiplication function. Matrix multiplication is a fundamental operation in various computations. Your goal is to correctly and efficiently multiply two compatible matrices. Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: pass ``` Input * `multiplicand` (List[List[int]]): A 2D list representing the first matrix with dimensions m x n. * `multiplier` (List[List[int]]): A 2D list representing the second matrix with dimensions n x p. Output * Returns a 2D list (matrix) which is the product of the given matrices with dimensions m x p. Constraints * 1 <= m, n, p <= 100 * Elements in matrices are integers in the range `[-1000, 1000]`. Edge Cases * Throw an exception if the matrices are not compatible for multiplication (i.e., the number of columns in `multiplicand` does not equal the number of rows in `multiplier`). * Handle matrices with dimensions of 1x1. * Handle cases where one or both matrices contain only zeros. Performance Requirements * Aim for a solution with a time complexity of O(n³). Example ```python # Example 1 multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] # Multiple result should be: # [ # [19, 22], # [43, 50] # ] print(multiply(multiplicand, multiplier)) # Example 2 - Case with zero matrix multiplicand = [ [0, 0], [0, 0] ] multiplier = [ [9, 8], [7, 6] ] # Multiple result should be: # [ # [0, 0], # [0, 0] # ] print(multiply(multiplicand, multiplier)) ```","solution":"def multiply(multiplicand: list, multiplier: list) -> list: if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Matrices are not compatible for multiplication\\") m = len(multiplicand) n = len(multiplicand[0]) p = len(multiplier[0]) # Initialize result matrix with zeroes result = [[0 for _ in range(p)] for _ in range(m)] # Perform multiplication for i in range(m): for j in range(p): for k in range(n): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Given `n` pairs of parentheses, write a function `generate_parenthesis(n)` to generate all combinations of well-formed parentheses. # Function Signature ```python def generate_parenthesis(n: int) -> List[str]: pass ``` # Input * An integer `n` (1 <= n <= 9) representing the number of pairs of parentheses. # Output * A list of strings, each string being a valid combination of `n` pairs of well-formed parentheses. # Constraints 1. The length of the output list will be the nth Catalan number. 2. The order of the strings in the output does not matter. 3. The size of n will be constrained so that the number of valid combinations does not exceed time limitations. # Example For `n = 3`, the expected output (order may vary) is: ```python [ \\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\" ] ``` # Scenario Imagine you are coding a system to help a compiler verify that braces and parentheses in code snippets are balanced. Generating well-formed parentheses can be used as part of test cases to validate such a system. Implement a function that generates all possible combinations of balanced parentheses for a given number of pairs.","solution":"from typing import List def generate_parenthesis(n: int) -> List[str]: Function to generate all combinations of well-formed parentheses. def backtrack(s=\'\', left=0, right=0): if len(s) == 2 * n: res.append(s) return if left < n: backtrack(s + \'(\', left + 1, right) if right < left: backtrack(s + \')\', left, right + 1) res = [] backtrack() return res"},{"question":"Scenario You are tasked with developing a pathfinding utility that calculates the shortest distance from each empty room in a grid to the nearest gate. Each empty room should be updated with its distance to the nearest gate. If a room is unreachable, it should remain as INF (2147483647). Problem Description Given a `m x n` 2D grid filled with -1 (walls), 0 (gates), and INF (2147483647 representing empty rooms), write a function that fills each empty room with the distance to its nearest gate. Function Signature ```python def walls_and_gates(rooms: List[List[int]]) -> None: Modifies the grid \'rooms\' in place. ``` Input * `rooms`: a 2D list of integers where: * -1 represents a wall or an obstacle. * 0 represents a gate. * INF (2147483647) represents an empty room. Output * The function should modify the input list `rooms` in place without returning anything. Constraints * The distance between two adjacent cells is always 1. * The number of rows (`m`) and columns (`n`) in the grid are at most 100. Example For the input grid: ``` INF -1 0 INF INF INF INF -1 INF -1 INF -1 0 -1 INF INF ``` The modified grid should be: ``` 3 -1 0 1 2 2 1 -1 1 -1 2 -1 0 -1 3 4 ``` Notes * Consider edge cases such as a grid with no gates, all cells being walls, or gates completely surrounded by walls. * For optimization, consider using BFS as an alternative approach to DFS.","solution":"from collections import deque from typing import List INF = 2147483647 def walls_and_gates(rooms: List[List[int]]) -> None: Modifies the grid \'rooms\' in place. if not rooms: return m, n = len(rooms), len(rooms[0]) queue = deque() # Initialize a queue with all gate positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) # Perform BFS from each gate directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"Context You are working on a web crawler that collects data from various websites. Your task is to implement a function that extracts and returns the domain name from a given URL. This function will help in categorizing and organizing the collected data based on domains. Function Definition Write a function `extract_domain(url)` that takes a URL string as input and returns the domain name as a string. You are not allowed to use any built-in libraries such as `re` for regular expressions or `urlparse`. The only allowed built-in string method is `split()`. Input/Output Specifications - **Input**: A single URL string `url`. - **Output**: A string representing the domain name. Constraints - The URL will always be a valid URL string but can vary in structure (e.g., with or without \'http\', \'https\', \'www\'). - The URL will not contain query parameters or fragments (i.e., no \'?\' or \'#\'). Examples ```python extract_domain(\\"http://github.com/SaadBenn\\") == \\"github\\" extract_domain(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" extract_domain(\\"https://www.cnet.com\\") == \\"cnet\\" extract_domain(\\"https://blog.github.com\\") == \\"blog\\" extract_domain(\\"github.com/SaadBenn\\") == \\"github\\" extract_domain(\\"www.zombie-bites.com\\") == \\"zombie-bites\\" ``` Performance Requirements - Your implementation should run efficiently with an O(n) time complexity, where n is the length of the URL string.","solution":"def extract_domain(url): Extract the domain name from the given URL. Parameters: url (str): The URL string from which to extract the domain name. Returns: str: The domain name extracted from the URL. # Split by \\"://\\" to handle schemas like http://, https:// parts = url.split(\\"://\\") if len(parts) > 1: remainder_url = parts[1] else: remainder_url = parts[0] # Split by \'/\' to handle the path segment domain_with_possible_www = remainder_url.split(\'/\')[0] # Split by \'.\' to extract the actual domain name domain_parts = domain_with_possible_www.split(\'.\') # If domain starts with \\"www.\\", remove it if domain_parts[0] == \'www\': domain_parts.pop(0) # Return the second last or last part as domain name domain_name = domain_parts[0] return domain_name"},{"question":"# Egg Dropping Problem with Dynamic Programming You are tasked with solving the egg dropping problem using dynamic programming. You are given K eggs and access to a building with N floors. Your objective is to determine the minimum number of attempts required to find the highest floor from which an egg can be dropped without breaking. # Specifications 1. **Inputs**: - `K`: The number of eggs (1 ≤ K ≤ 100) - `N`: The number of floors (1 ≤ N ≤ 1000) 2. **Output**: - Minimum number of attempts required to find the critical floor `F`. # Requirements 1. Implement a function `egg_drop(n, k)` following the algorithm described. Use dynamic programming to find the solution. 2. The function should return an integer representing the minimum number of attempts. # Constraints 1. You must consider edge cases, including: - Minimum and maximum values for K and N. - Every drop must account for both the scenarios where the egg breaks or doesn\'t. # Example Input ```python egg_drop(2, 10) ``` Output ```python 4 ``` Explanation With 2 eggs and 10 floors, the function should perform optimally and figure out the critical floor with the minimum number of trials, which is 4 in this case. # Hints 1. Use a bottom-up approach to fill the table that tracks the minimum number of attempts. 2. Think about how you could apply the \\"worst-case scenario\\" logic at each step to ensure you are covering all potential outcomes. Implement the following function to solve this problem: ```python INT_MAX = 32767 def egg_drop(n, k): # Your implementation here pass ```","solution":"def egg_drop(K, N): Find the minimum number of attempts required to find the highest floor from which an egg can be dropped without breaking using K eggs and N floors. :param K: number of eggs :param N: number of floors :return: minimum number of attempts # A 2D list where dp[i][j] represents the minimum number of attempts # needed for i eggs and j floors. dp = [[0 for x in range(N + 1)] for x in range(K + 1)] # We need one trial for one floor and zero trials for zero floors. for i in range(1, K + 1): dp[i][0] = 0 dp[i][1] = 1 # We need j trials for one egg and j floors. for j in range(1, N + 1): dp[1][j] = j # Fill the rest of the entries in the table using the optimal substructure property for i in range(2, K + 1): for j in range(2, N + 1): dp[i][j] = float(\'inf\') for x in range(1, j + 1): res = 1 + max(dp[i - 1][x - 1], dp[i][j - x]) if res < dp[i][j]: dp[i][j] = res return dp[K][N]"},{"question":"You are tasked with solving a grid-based problem where cells can be walls, gates, or empty rooms. Your task is to update each empty room with the distance to its nearest gate. If it is impossible to reach a gate, it should retain its initial value of `INF` (2147483647). Problem Description You are given an `m x n` 2D grid initialized with these possible values: * `-1` representing a wall or an obstacle. * `0` representing a gate. * `INF` (2147483647) representing an empty room. Your job is to fill each empty room with the distance to its nearest gate. Use a more optimal solution than the provided DFS approach (hint: consider BFS for more efficiency). Input * `rooms`: An `m x n` list of lists of integers where each integer represents a room\'s state (`-1`, `0`, or `2147483647`). Output * The function should modify the `rooms` grid in-place, filling each empty room with the shortest distance to a gate. Constraints * `1 <= m, n <= 250` * The grid contains at least one cell. Example ```python rooms = [ [2147483647, -1, 0, 2147483647], [2147483647, 2147483647, 2147483647, -1], [2147483647, -1, 2147483647, -1], [0, -1, 2147483647, 2147483647] ] # After calling your function, the rooms grid should be: # [ # [3, -1, 0, 1], # [2, 2, 1, -1], # [1, -1, 2, -1], # [0, -1, 3, 4] # ] ``` Implement the function `walls_and_gates(rooms: List[List[int]]) -> None:` to solve the problem as described.","solution":"from collections import deque def walls_and_gates(rooms): Modify the grid \'rooms\' in-place, filling each empty room with the shortest distance to a gate. if not rooms: return m, n = len(rooms), len(rooms[0]) INF = 2147483647 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] queue = deque() # Collect all gate positions for i in range(m): for j in range(n): if rooms[i][j] == 0: queue.append((i, j)) while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy # If the new position is within bounds and an empty room, # and the new distance is less than the current recorded distance if 0 <= nx < m and 0 <= ny < n and rooms[nx][ny] == INF: rooms[nx][ny] = rooms[x][y] + 1 queue.append((nx, ny))"},{"question":"# Question Context You are tasked with finding out which character was added to a given string after it has been shuffled and an additional character inserted into it. This problem often surfaces in cases dealing with data integrity checks and cryptographic validations. Task Write a function `find_difference(s, t)` that determines the extra character added to the shuffled string `t` from string `s`. Assume string `t` is derived by shuffling `s` and then adding one more letter at a random position. Function Signature ```python def find_difference(s: str, t: str) -> str: ``` Input * `s` (string): A string consisting of only lowercase letters. * `t` (string): A modification of the string `s` with one extra character included and the order of characters shuffled. Output * Return the single additional character present in `t` that was not in `s`. Constraints 1. Both `s` and `t` contain only lowercase English letters. 2. `t` will always contain exactly one extra character than `s`. Example ```python # Example 1: s = \\"abcd\\" t = \\"abcde\\" # Output: \'e\' # Example 2: s = \\"xyz\\" t = \\"zyxw\\" # Output: \'w\' ``` Explanation In the first example, string `t` contains all characters of `s` plus one extra character \'e\'. The function should return \'e\'. Similarly, for the second example, all characters of `s` are found in `t` plus an additional character \'w\'. Note: Your solution should handle different lengths of strings efficiently, keeping in mind the constraints and properties mentioned.","solution":"def find_difference(s: str, t: str) -> str: from collections import Counter # Count character frequencies in both strings count_s = Counter(s) count_t = Counter(t) # Identify and return the additional character in t for char in count_t: if count_t[char] != count_s.get(char, 0): return char"},{"question":"# Context You are developing a web scraping tool that needs to analyze and parse URLs quickly. One of the requirements is to extract the main domain name from given URLs. Given certain constraints regarding the environment, you cannot use advanced libraries such as `re` (regular expressions) or `urlparse`. # Task Write a function `domain_name(url)` that extracts and returns the main domain name from a given URL string using only basic string manipulation methods like `split`. Consider various URL formats, including those with \\"http\\", \\"https\\", \\"www\\", and without these parts. # Input and Output Formats * **Input**: A string `url` representing a URL. * **Output**: A string representing the domain name extracted from the URL. # Constraints 1. The URL will always have a valid format (no invalid URLs). 2. The returned domain name does not include subdomains (e.g., \\"www\\"). # Examples ```python domain_name(\\"http://github.com/SaadBenn\\") == \\"github\\" domain_name(\\"http://www.zombie-bites.com\\") == \\"zombie-bites\\" domain_name(\\"https://www.cnet.com\\") == \\"cnet\\" domain_name(\\"https://codeforces.com\\") == \\"codeforces\\" domain_name(\\"http://example.org\\") == \\"example\\" domain_name(\\"www.alternative.me\\") == \\"alternative\\" domain_name(\\"example.net\\") == \\"example\\" ``` # Notes * Do not use `re` (regular expressions) or `urlparse` in your solution. * Remember to handle edge cases where \\"www\\" is not present in the URL.","solution":"def domain_name(url): Extracts the main domain name from a given URL string using only basic string manipulation methods like `split`. # Removing \\"http://\\", \\"https://\\" or \\"www\\" from the url if url.startswith(\\"http://\\"): url = url[7:] elif url.startswith(\\"https://\\"): url = url[8:] if url.startswith(\\"www.\\"): url = url[4:] # We assume everything before the first \\"/\\" is the domain domain = url.split(\'/\')[0] # We assume the domain might have subdomains, split by \\".\\" # The main domain is the first part from the last \\".\\" domain = domain.split(\'.\') return domain[0]"},{"question":"# Problem: Enhanced FizzBuzz Create a function `enhanced_fizzbuzz(li: List[int]) -> List[Union[int, str]]` that takes a list of integers as input and returns a corresponding list where each integer is processed according to the FizzBuzz rules: 1. If the integer is a multiple of 3, replace it with \\"Fizz\\". 2. If the integer is a multiple of 5, replace it with \\"Buzz\\". 3. If the integer is a multiple of both 3 and 5, replace it with \\"FizzBuzz\\". 4. Otherwise, keep the integer unchanged. Additionally, if the given list contains any non-integer types, the function should raise a `TypeError`. Input * `li`: A list of integers for which FizzBuzz rules need to be applied. Output * Returns a list where each element has been processed according to the FizzBuzz rules, maintaining the original order of the list. Constraints * The list can contain elements from -10^6 to 10^6. * The list\'s length can range from 1 to 10^6. Example ```python # Example 1 li = [3, 5, 15, 7, 9, 10, -3, -5, -15] output = enhanced_fizzbuzz(li) # Expected output: [\\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\", 7, \\"Fizz\\", \\"Buzz\\", \\"Fizz\\", \\"Buzz\\", \\"FizzBuzz\\"] # Example 2 li = [1, 2, 4] output = enhanced_fizzbuzz(li) # Expected output: [1, 2, 4] # Example 3 li = [3, \'5\', 15] output = enhanced_fizzbuzz(li) # Expected output: TypeError ``` Requirements * Implement the function `enhanced_fizzbuzz` in Python. * The function should handle and raise appropriate errors. * Code should aim to be optimal within the provided constraints.","solution":"from typing import List, Union def enhanced_fizzbuzz(li: List[int]) -> List[Union[int, str]]: Function to process a list according to the FizzBuzz rules. :param li: List of integers :return: List with each element processed according to FizzBuzz rules result = [] for item in li: if not isinstance(item, int): raise TypeError(f\\"All elements must be integers, found {type(item).__name__} instead.\\") if item % 15 == 0: result.append(\\"FizzBuzz\\") elif item % 3 == 0: result.append(\\"Fizz\\") elif item % 5 == 0: result.append(\\"Buzz\\") else: result.append(item) return result"},{"question":"Search in a Row-wise and Column-wise Sorted Matrix You are given a matrix where each row and each column is sorted in non-decreasing order. Your task is to implement a function to search for a given key in this matrix and return its location if found. Function Signature ```python def search_in_a_sorted_matrix(mat: List[List[int]], key: int) -> Tuple[int, int]: pass ``` Input: - `mat`: A list of lists of integers representing the matrix (1 ≤ m, n ≤ 1000). - `key`: An integer to search for in the matrix. Output: - A tuple `(row_index, column_index)` representing the one-based position of the key in the matrix. - If the key is not found, return `(-1, -1)`. Constraints: - The matrix dimensions and elements are such that 1 ≤ m, n ≤ 1000. - Elements of the matrix and the key are integers within the range `-10^6` to `10^6`. Examples: ```python # Example 1 mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_in_a_sorted_matrix(mat, key) == (2, 3) # Example 2 mat = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 10 assert search_in_a_sorted_matrix(mat, key) == (-1, -1) # Example 3 mat = [] key = 10 assert search_in_a_sorted_matrix(mat, key) == (-1, -1) ``` Explanation: - In Example 1, the key `13` is found in row `2` and column `3` of the given matrix. - In Example 2, the key `10` is not found so the function returns `(-1, -1)`. - In Example 3, the matrix is empty so the function returns `(-1, -1)`. Implement the function `search_in_a_sorted_matrix` to solve the problem.","solution":"from typing import List, Tuple def search_in_a_sorted_matrix(mat: List[List[int]], key: int) -> Tuple[int, int]: if not mat or not mat[0]: return (-1, -1) rows = len(mat) cols = len(mat[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if mat[row][col] == key: return (row + 1, col + 1) elif mat[row][col] > key: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Question You need to implement a ResizableHashTable class that builds upon the provided HashTable class. Your task is to add and improve functionality to manage the resizing of the underlying storage array effectively. Additionally, you need to allow for dynamic expansion and contraction of the hash table based on the load factor. Requirements: 1. Enhance the `ResizableHashTable` class such that it shrinks the hash table size when the load factor falls below a specified threshold (e.g., 1/3 of the current size). 2. Implement this shrink behavior alongside the given `put` function with unit tests for verification. 3. The resize should halve the current size while maintaining a minimum size of 8. Function Signatures: ```python class ResizableHashTable(HashTable): def __init__(self): pass def put(self, key, value): pass def __resize(self): pass ``` Behavior: - The hash table should double its size when the current load factor is greater than or equal to 2/3. - The hash table should shrink its size when the load factor falls below 1/3, but only if the current size is greater than the minimum size of 8. - Ensure proper rehashing of elements during resizing operations to maintain correct hashing and placements. Input Format: A series of `put` and `get` operations. - `ResizableHashTable.put(key, value)` - `ResizableHashTable.get(key)` Output: A series of values corresponding to the `get` operations. Example: Suppose the following sequence of operations on the table: ```python ht = ResizableHashTable() ht.put(1, \'a\') ht.put(12, \'b\') # This will cause a collision ht.put(23, \'c\') # Another collision with keys 1 and 12 ht.get(1) # returns \'a\' ht.get(12) # returns \'b\' ht.get(23) # returns \'c\' ``` After performing several put operations, the `put` method should automatically trigger the resizing mechanism based on load factor thresholds. Note: Your implementation should ensure efficient operations and correct resizing behavior in response to changing load factors.","solution":"class ResizableHashTable: def __init__(self, initial_capacity=8): self.capacity = initial_capacity self.size = 0 self.buckets = [[] for _ in range(initial_capacity)] def _hash(self, key): return hash(key) % self.capacity def put(self, key, value): if self.size / self.capacity >= 2 / 3: self.__resize(self.capacity * 2) bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: bucket[i] = (key, value) return bucket.append((key, value)) self.size += 1 def get(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for k, v in bucket: if k == key: return v return None def delete(self, key): bucket_index = self._hash(key) bucket = self.buckets[bucket_index] for i, (k, v) in enumerate(bucket): if k == key: del bucket[i] self.size -= 1 if self.size / self.capacity < 1 / 3 and self.capacity > 8: self.__resize(max(self.capacity // 2, 8)) return v return None def __resize(self, new_capacity): old_buckets = self.buckets self.capacity = new_capacity self.buckets = [[] for _ in range(self.capacity)] self.size = 0 for bucket in old_buckets: for key, value in bucket: self.put(key, value)"},{"question":"# Context Exchange Sort is a simple comparison-based sorting algorithm that is similar to Bubble Sort in principle. Despite its simplicity, it has a quadratic time complexity which makes it inefficient for large arrays. However, understanding how it works can help solidify your grasp on the mechanics of sorting algorithms. # Problem Statement Implement a variation of the Exchange Sort algorithm to sort an array of integers in non-increasing (descending) order. # Function Signature ```python def descending_exchange_sort(lst: List[int]) -> List[int]: pass ``` # Expected Input and Output Formats * **Input**: * A list of integers, `lst` (0 <= len(lst) <= 10^4, -10^9 <= lst[i] <= 10^9). * **Output**: * A list of integers sorted in non-increasing order. # Constraints * Utilize the principles of Exchange Sort but modify the comparison to create non-increasing order. * Aim for clarity in your implementation as performance is inherently limited by the chosen algorithm. * Handling of edge cases like empty arrays and arrays with repetitive elements is necessary. # Example Input: ```python lst = [3, 1, 4, 1, 5, 9, 2] ``` Output: ```python [9, 5, 4, 3, 2, 1, 1] ``` # Special Requirements * Your solution should not use Python\'s built-in sorting functions. * The solution must follow the principle of Exchange Sort.","solution":"def descending_exchange_sort(lst): Sorts an array of integers in non-increasing (descending) order using Exchange Sort. Parameters: lst (List[int]): A list of integers to be sorted. Returns: List[int]: A list of integers sorted in non-increasing order. n = len(lst) for i in range(n - 1): for j in range(i + 1, n): if lst[i] < lst[j]: lst[i], lst[j] = lst[j], lst[i] return lst"},{"question":"# Prompt You are given an array of integers that may contain both positive and negative numbers. Your task is to implement a **Counting Sort** algorithm that can handle this input efficiently. The goal is to return a new sorted array without altering the original array. # Function Signature ```python def custom_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` such as `[-5, -1, 2, 0, 3, -2]`. # Output * A new list of integers sorted in non-decreasing order. # Constraints * The elements of `arr` are in the range of [-1000, 1000]. * The size of `arr` is at most 10^6. # Requirements * The solution should have a time complexity of O(n + k) where n is the length of the array and k is the range of the input array. * Ensure that the implementation is stable (maintains the relative order of equal elements). # Example ```python assert custom_counting_sort([1, -2, 3, -2, 0]) == [-2, -2, 0, 1, 3] assert custom_counting_sort([5, 3, 2, 1, 4]) == [1, 2, 3, 4, 5] assert custom_counting_sort([0, 0, 0, 0]) == [0, 0, 0, 0] assert custom_counting_sort([]) == [] assert custom_counting_sort([-5, -1, 2, 0, 3, -2]) == [-5, -2, -1, 0, 2, 3] ``` # Notes * Consider all edge cases such as arrays containing all identical numbers, arrays being empty, and varying array sizes. * Ensure that negative numbers are correctly handled.","solution":"from typing import List def custom_counting_sort(arr: List[int]) -> List[int]: Perform counting sort on the given list of integers and return a new sorted list. This function handles both positive and negative integers. if not arr: return [] min_value = min(arr) max_value = max(arr) range_of_elements = max_value - min_value + 1 count = [0] * range_of_elements output = [0] * len(arr) for num in arr: count[num - min_value] += 1 for i in range(1, len(count)): count[i] += count[i - 1] for num in reversed(arr): output[count[num - min_value] - 1] = num count[num - min_value] -= 1 return output"},{"question":"**Scenario**: You are tasked with writing a function that simulates an iterator for a Binary Search Tree (BST). This iterator should allow you to traverse the BST in ascending order efficiently. **Function to Implement**: `BSTIterator` **Class Definition**: * `class BSTIterator`: This class will include methods to initialize the iterator, check if there are more elements, and get the next element in the traversal. **Method Specifications**: 1. **`__init__(self, root: TreeNode) -> None`**: This constructor initializes the BSTIterator object. It accepts the `root` node of the BST. - **Input**: The `root` node of the BST. 2. **`has_next(self) -> bool`**: This method returns `True` if there is a next smallest number in the BST, otherwise `False`. - **Output**: Boolean value indicating if there are more elements to traverse. 3. **`next(self) -> int`**: This method returns the next smallest number in the BST. - **Output**: The next smallest integer value from the BST. **Constraints**: - The number of nodes in the BST will be in the range `[0, 10^4]`. - `-10^5 <= Node.val <= 10^5` - Time complexity of the `next` method should be on average O(1). - Space complexity should depend linearly on the height of the BST. **Example**: ```python # Assuming TreeNode class is already defined as: # class TreeNode: # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Initialize BSTIterator iterator = BSTIterator(root) # Traverse the BST result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [3, 7, 9, 15, 20] ``` **Your Task**: Implement the `BSTIterator` class as described. Ensure to handle edge cases and optimize for performance as much as possible within the given constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode) -> None: self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val"},{"question":"# Determine the Sorted Status of a Linked List You are provided a linked list, and your task is to determine if the linked list is sorted in non-decreasing order. A linked list is considered sorted if for every node, the value of the node is less than or equal to the value of the next node in the sequence. An empty linked list is considered sorted by definition. Implement the following function: ```python def is_sorted(head): Determines if a linked list is sorted in non-decreasing order. Args: head (Node): The head node of the linked list. Returns: bool: True if the linked list is sorted, False otherwise. ``` # Input - `head`: A `Node` object representing the head of the linked list. Each `Node` contains an integer value and a reference to the next node (or `None` if it is the last node in the list). # Output - Return `True` if the linked list is sorted in non-decreasing order, otherwise return `False`. # Constraints - You do not need to handle circular linked lists. - You should assume that linked list nodes are properly linked. - The values in the node can be any valid integer. - The function should run in linear time, O(n), and use constant space, O(1). # Example Consider the following linked list: - Null : The list is empty and hence sorted. - 1 -> 2 -> 3 -> 4 : The list is sorted. - 1 -> 2 -> -1 -> 3 : The list is not sorted. # Additional Notes - You may assume that the input linked list will not have duplicate references (no two nodes point to the same next node except the tail pointing to `None`). - Properly handle edge cases, such as when the linked list is empty or has only one element.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def is_sorted(head): Determines if a linked list is sorted in non-decreasing order. Args: head (Node): The head node of the linked list. Returns: bool: True if the linked list is sorted, False otherwise. if not head: return True current = head while current.next: if current.value > current.next.value: return False current = current.next return True"},{"question":"# Question: Implement Iterative and Recursive Postorder Tree Traversal You are given the structure of a binary tree node. Implement both an iterative and a recursive function to perform postorder traversal of a binary tree. The functions should return a list of node values in postorder sequence. Function 1: Iterative Approach ```python def iterative_postorder(root: Node) -> List[int]: Given the root of a binary tree, return the postorder traversal of its nodes\' values using an iterative approach. Args: root (Node): The root node of the binary tree. Returns: List[int]: A list of integers corresponding to the node values in postorder. pass ``` Function 2: Recursive Approach ```python def recursive_postorder(root: Node) -> List[int]: Given the root of a binary tree, return the postorder traversal of its nodes\' values using a recursive approach. Args: root (Node): The root node of the binary tree. Returns: List[int]: A list of integers corresponding to the node values in postorder. pass ``` Constraints: * The number of nodes in the tree is in the range `0 <= n <= 10^4`. * `-10^5 <= Node.val <= 10^5` Example: ```python # Example Tree: # 1 # # 2 # / # 3 root = Node(1, None, Node(2, Node(3))) assert iterative_postorder(root) == [3, 2, 1] assert recursive_postorder(root) == [3, 2, 1] ``` Notes: 1. You must ensure the functions handle all edge cases (e.g., empty tree, single-node tree). 2. The expected output should match the postorder traversal of the nodes. 3. Pay attention to the time and space complexity of your solutions.","solution":"from typing import List, Optional class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def iterative_postorder(root: Optional[Node]) -> List[int]: Given the root of a binary tree, return the postorder traversal of its nodes\' values using an iterative approach. Args: root (Node): The root node of the binary tree. Returns: List[int]: A list of integers corresponding to the node values in postorder. if not root: return [] stack, output = [root], [] while stack: node = stack.pop() output.append(node.val) if node.left: stack.append(node.left) if node.right: stack.append(node.right) return output[::-1] def recursive_postorder(root: Optional[Node]) -> List[int]: Given the root of a binary tree, return the postorder traversal of its nodes\' values using a recursive approach. Args: root (Node): The root node of the binary tree. Returns: List[int]: A list of integers corresponding to the node values in postorder. def recurse(node, output): if not node: return recurse(node.left, output) recurse(node.right, output) output.append(node.val) result = [] recurse(root, result) return result"},{"question":"Optimized String Matching We would like you to implement an optimized string matching algorithm using the Rabin-Karp approach. This question will test your understanding of rolling hash and efficient string searching techniques. # Function Signature Implement the function `find_pattern(text: str, pattern: str) -> int`: # Inputs - **text** (*str*): A string where we want to search for the pattern. - **pattern** (*str*): A string pattern that we\'re searching for within the text. # Outputs - **int**: The starting index of the first occurrence of the pattern in the text. If the pattern is not found, return -1. # Constraints 1. 0 <= len(text) <= 10^5 2. 0 <= len(pattern) <= 10^5 3. The function should handle both uppercase and lowercase letters. Treat \'A\' and \'a\' as different characters for hashing. # Performance Requirements The function should be efficient with an average time complexity close to O(N + M), where N is the length of the input text and M is the length of the pattern. # Example ```python def find_pattern(text, pattern): # Your implementation here... # Example Scenario print(find_pattern(\\"hello world\\", \\"world\\")) # Output: 6 print(find_pattern(\\"hello world\\", \\"planet\\")) # Output: -1 print(find_pattern(\\"\\", \\"abc\\")) # Output: -1 print(find_pattern(\\"abc\\", \\"\\")) # Output: -1 ``` # Special Considerations - Ensure that your function gracefully handles edge cases such as empty strings and cases where the pattern is longer than the text. - Thoroughly test the hash function\'s collision handling mechanism to avoid false positives during pattern matching. - Consider encapsulating the hash management within a class similar to `RollingHash` for clean and maintainable code structure.","solution":"def find_pattern(text: str, pattern: str) -> int: if not pattern: return -1 if not text: return -1 if len(pattern) > len(text): return -1 # Base constants for the Rabin-Karp algorithm prime = 101 d = 256 n = len(text) m = len(pattern) # Hash values for pattern and text p_hash = 0 t_hash = 0 h = 1 # Precompute the highest power of d (d^(m-1)) for i in range(m - 1): h = (h * d) % prime # Calculate initial hash values for pattern and text for i in range(m): p_hash = (d * p_hash + ord(pattern[i])) % prime t_hash = (d * t_hash + ord(text[i])) % prime # Sliding window for text for i in range(n - m + 1): if p_hash == t_hash: # Hashes match, now compare actual substrings if text[i:i + m] == pattern: return i if i < n - m: # Calculate hash for next substring t_hash = (d * (t_hash - ord(text[i]) * h) + ord(text[i + m])) % prime if t_hash < 0: t_hash += prime return -1"},{"question":"Problem Statement Given a list of integers, create a function that returns a histogram representing the frequency of each number in the list. A histogram is an accurate representation of the distribution of data, showing the frequency of each number as the value against the number itself as the key. # Function Signature: ```python def get_histogram(input_list: list) -> dict: ``` # Input: - `input_list` (List[int]): A list containing integer elements, which can be unordered and may contain duplicates. # Output: - Returns a `dict` where the keys are the unique integers from the input list and the values are the counts of their occurrences. # Constraints: - The elements in the list are integers between -10^6 and 10^6. - The list can have up to 10^6 elements. # Examples: 1. `get_histogram([3, 3, 2, 1])` should return `{1: 1, 2: 1, 3: 2}` 2. `get_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7])` should return `{2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1}` 3. `get_histogram([])` should return `{}` (an empty dictionary for an empty input list) # Scenario: You are a data analyst working on preparing a report that involves analyzing the distribution of survey responses. You need to write a function to quickly visualize the number of times each response was given by using a histogram. # Requirements: - Your solution should have a time complexity of O(n) and a space complexity of O(k), where n is the number of elements in the list and k is the number of unique elements. - Consider edge cases such as an empty list, and lists containing all identical elements, and single-element lists.","solution":"def get_histogram(input_list): Returns a histogram as a dictionary where keys are the unique integers in the input_list and values are their counts of occurrences. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"# Path Splitting Function – Enhanced Version **Objective**: Implement a function that splits a given path into its directory and file components, with additional features to handle multiple OS path separators, trailing separators, and edge cases like empty strings and None inputs. **Function Signature**: ```python def enhanced_split(path: str) -> tuple[str, str]: pass ``` **Input Format**: - `path`: A string representing a file path or URL. **Output Format**: - Returns a tuple containing two strings: - The first string is the directory part of the path. - The second string is the file part of the path. **Constraints**: - Handle paths with both `/` and `` as path separators. - If the path is empty or None, return two empty strings as the directory and file parts. - Ensure that paths ending with a separator correctly separate into the directory and an empty file part. **Performance Requirements**: - Aim for O(n) time complexity. - Ensure space complexity is O(n). **Examples**: 1. `input: \\"https://algorithms/unix/test.py\\"` `output: (\\"https://algorithms/unix\\", \\"test.py\\")` 2. `input: \\"algorithmsunixtest.py\\"` `output: (\\"algorithmsunix\\", \\"test.py\\")` 3. `input: \\"C:UsersDocuments\\"` `output: (\\"C:UsersDocuments\\", \\"\\")` 4. `input: \\"\\"` `output: (\\"\\", \\"\\")` 5. `input: None` `output: (\\"\\", \\"\\")` **Context**: Imagine you are developing a file system exploration tool where paths from different operating systems may need standardizing and splitting for directory navigation and file manipulation tasks.","solution":"import os def enhanced_split(path: str) -> tuple[str, str]: Splits a given path into directory and file components. Parameters: path (str): A string representing a file path or URL. Returns: tuple: A tuple containing two strings - the directory part and the file part. if path is None or path == \\"\\": return \\"\\", \\"\\" # Normalize the path separator to \'/\' normalized_path = path.replace(\'\', \'/\') # Use rsplit to split from the rightmost separator for directory and file part dir_part, sep, file_part = normalized_path.rpartition(\'/\') # Handle case where path ends with a separator if sep and not file_part: return dir_part, \\"\\" return dir_part, file_part"},{"question":"# Context A leetcode problem involves generating all possible subsets of a given list of distinct integers. This problem assesses your understanding of bit manipulation and the ability to generate power sets efficiently. # Task Write a function `generate_subsets(nums)` that takes in a list of distinct integers and returns a set of all possible subsets of the input list. # Function Signature ```python def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: ``` # Input * `nums`: A list of distinct integers. (1 <= len(nums) <= 16) # Output * A set of tuples representing all unique subsets of the given input list. # Constraints * The input contains only distinct integers. * The length of the input list will not exceed 16. # Performance * Your solution should aim for a time complexity of O(n * 2^n) and a space complexity of O(2^n). # Example ```python # Input nums = [1, 2, 3] # Expected Output { (), (1,), (2,), (3,), (1, 2,), (1, 3,), (2, 3,), (1, 2, 3,), } ``` # Additional Instructions Include this function implementation within your solution and ensure to handle edge cases.","solution":"from typing import List, Set, Tuple def generate_subsets(nums: List[int]) -> Set[Tuple[int]]: Function to generate all possible subsets of a list of distinct integers. res = set() n = len(nums) # There are 2^n subsets for a set of size n for i in range(2**n): subset = [] for j in range(n): # Check if the j-th bit in i is set if i & (1 << j): subset.append(nums[j]) res.add(tuple(subset)) return res"},{"question":"# Cycle Detection in a Directed Graph **Context**: In a software build system, different tasks need to be executed, with certain tasks being dependent on the completion of others. This can be represented as a directed graph where nodes are tasks and edges indicate dependencies. You must ensure there are no circular dependencies, which would prevent some tasks from ever being completed. **Problem Statement**: You need to write a function `has_cycle(graph: dict) -> bool` that determines if a given directed graph contains a cycle. The graph is represented as a dictionary where keys are task identifiers (nodes), and values are lists of dependent tasks (edges). **Function Signature**: ```python def has_cycle(graph: dict) -> bool: pass ``` **Input**: - A dictionary `graph` where keys are strings representing tasks and values are lists of strings representing dependencies. **Output**: - A boolean value `True` if there is at least one cycle in the graph, `False` otherwise. **Constraints**: - The graph is a directed graph with no self-loops. - The input graph will not necessarily be connected. - The number of vertices and edges is ( n ), where ( 1 leq n leq 10^4 ). **Example**: ```python graph1 = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } graph2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [] } assert has_cycle(graph1) == True assert has_cycle(graph2) == False ``` **Explanation**: - In `graph1`, there is a cycle: `B -> D -> E -> B`, so the function should return `True`. - In `graph2`, there are no cycles, so the function should return `False`. **Note**: You must use a graph traversal algorithm with a mechanism to detect cycles efficiently. Consider the use of depth-first search (DFS) and tracking node states during traversal to identify cycles.","solution":"def has_cycle(graph: dict) -> bool: Detects if the directed graph contains a cycle. Parameters: graph (dict): A dictionary representation of the directed graph where keys are nodes, and values are lists of dependent nodes. Returns: bool: True if the graph contains a cycle, otherwise False. # states: 0 = unvisited, 1 = visiting, 2 = visited states = {} def dfs(node): if states[node] == 1: # currently visiting, found a cycle return True if states[node] == 2: # already visited, no cycle from this node return False # Mark the node as visiting states[node] = 1 # Visit all the dependent nodes for neighbor in graph.get(node, []): if dfs(neighbor): return True # Mark the node as visited states[node] = 2 return False # Initialize states for all nodes as unvisited for node in graph: states[node] = 0 # Check each node for cycles for node in graph: if states[node] == 0: # unvisited if dfs(node): return True return False"},{"question":"Efficient Task Scheduling Priority Queue Scenario You are developing a task scheduler where tasks must be executed based on their priorities. Higher priority tasks should be executed before lower priority ones. Implement a priority queue class using a more efficient data structure to solve this problem. Requirements 1. The task scheduler should support adding tasks with given priorities. 2. The scheduler should allow tasks to be executed in order of their priority. 3. Your implementation should provide better average-case performance for insertion compared to the linear array method. Implementation Details * **Class Name**: `EfficientPriorityQueue` * **Methods**: 1. `__init__(self)`: Initialize your priority queue. 2. `push(self, task: str, priority: int)`: Add a new task with the given priority. 3. `pop(self) -> str`: Remove and return the task with the highest priority. If the queue is empty, raise an `IndexError`. * **Expected Input and Output**: * Input: `push(\\"task1\\", 5)`, `push(\\"task2\\", 1)`, `push(\\"task3\\", 3)` * Output: `pop() -> \\"task1\\"`, `pop() -> \\"task3\\"`, `pop() -> \\"task2\\"` * **Constraints**: - Do not use the standard library\'s `heapq` or similar utilities; implement the underlying data structure yourself. - Ensure insertion and extraction are as efficient as possible. * **Performance Requirements**: - Aim for average-case insertion and extraction times of O(log n). Example ```python class EfficientPriorityQueue: def __init__(self): # Initialize your data structure here. pass def push(self, task: str, priority: int): # Add the task with given priority. pass def pop(self) -> str: # Remove and return the task with the highest priority. pass # Example Usage: pq = EfficientPriorityQueue() pq.push(\\"task1\\", 5) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 3) print(pq.pop()) # Output: task1 print(pq.pop()) # Output: task3 print(pq.pop()) # Output: task2 ``` Note: You are free to choose and implement any efficient priority queue data structure that satisfies the constraints and performance requirements.","solution":"class EfficientPriorityQueue: def __init__(self): self.heap = [] def push(self, task: str, priority: int): self.heap.append((priority, task)) self._sift_up(len(self.heap) - 1) def pop(self) -> str: if not self.heap: raise IndexError(\\"pop from an empty priority queue\\") self._swap(0, len(self.heap) - 1) highest_priority_task = self.heap.pop() self._sift_down(0) return highest_priority_task[1] def _sift_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[index][0] > self.heap[parent][0]: self._swap(index, parent) self._sift_up(parent) def _sift_down(self, index): child = 2 * index + 1 if child >= len(self.heap): return if child + 1 < len(self.heap) and self.heap[child + 1][0] > self.heap[child][0]: child += 1 if self.heap[index][0] < self.heap[child][0]: self._swap(index, child) self._sift_down(child) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Scenario In a document retrieval system, you are working on a feature that ranks documents based on their relevance to a user\'s search query. One common technique for measuring relevance is based on cosine similarity between the document term vectors. # Task Implement a function `compute_cosine_similarity(vectors)` that takes a list of 2-element tuples, where each tuple contains two vectors for which similarity must be calculated. Return a list of the cosine similarity scores for these vector pairs. # Specifications * **Input**: A list of tuples, each tuple containing two equal-length vectors (e.g., `[(vec1, vec2), (vec3, vec4), ...]`). * **Output**: A list of cosine similarity scores. * **Constraints**: - Each vector will have at least one element. - The maximum vector length is 1000. - Elements in the vectors are integers or floats. - Raise a ValueError if any pair contains vectors of unequal length. # Example ```python # Input vector_pairs = [ ([1, 2, 3], [4, 5, 6]), ([1, 0, -1], [-1, 0, 1]), ([1, 1, 1], [0, 0, 0]) ] # Output [0.9746318461970762, -1.0, ValueError] ``` # Requirements * Use the previously defined `cosine_similarity` function for each pair\'s similarity computation. * Ensure the function is optimized and handles any edge cases gracefully.","solution":"from math import sqrt from typing import List, Tuple, Union def compute_cosine_similarity(vectors: List[Tuple[List[float], List[float]]]) -> List[Union[float, ValueError]]: Compute the cosine similarity for each pair of vectors in the input list. Args: vectors (List[Tuple[List[float], List[float]]]): A list of tuples, each containing two vectors. Returns: List[Union[float, ValueError]]: A list of cosine similarity scores or ValueError for each pair. def cosine_similarity(vec1, vec2): if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) magnitude1 = sqrt(sum(v1 * v1 for v1 in vec1)) magnitude2 = sqrt(sum(v2 * v2 for v2 in vec2)) if magnitude1 == 0 or magnitude2 == 0: return 0.0 return dot_product / (magnitude1 * magnitude2) similarities = [] for vec1, vec2 in vectors: try: similarity = cosine_similarity(vec1, vec2) similarities.append(similarity) except ValueError as e: similarities.append(e) return similarities"},{"question":"**Incrementing Array Representation of Large Numbers** **Problem Statement**: You are given an array of digits where each element is a single digit (0 to 9) representing a non-negative integer in a big-endian format. Your task is to write a function to increment the large number by one. The result should be an array of digits again maintaining the big-endian format. Write a function `increment_large_number(digits: List[int]) -> List[int]` which increments the given large number represented as an array by one. **Input**: * `digits`: A list of integers where each element is a single digit (0-9). * The list will represent a non-negative integer (no leading zeros unless the number is `0`). **Output**: * A list of integers representing the incremented number. **Constraints**: * The function should handle the case where carrying over leads to extending the size of the array (e.g., [9, 9] becomes [1, 0, 0]). * You may assume the list is not empty. * Optimize the function for both time and space complexity. **Examples**: Example 1: ```python Input: digits = [1, 2, 3] Output: [1, 2, 4] ``` Example 2: ```python Input: digits = [9, 9, 9] Output: [1, 0, 0, 0] ``` **Additional Notes**: * Think through edge cases like when all digits are `9`. * Minimize additional space usage where possible. Provide the code that fulfills these requirements and efficiently handles the increment operation on the provided array.","solution":"def increment_large_number(digits): Increment the number represented by a list of digits by one. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 return [1] + digits"},{"question":"**Question: Remove Duplicate Characters** You are given a string as input. Your task is to write a function that removes any repeating characters in the string and returns the resulting string with only the first occurrences of each character preserved and the order maintained. # Input: * A string `s` with a maximum length of 10^5 characters, consisting of lowercase English letters. # Output: * A string where each character from the input appears only once, and only the first occurrences are preserved, in the same order as the original string. # Constraints: * The function must have a time complexity of O(n), where n is the length of the input string. * The function must handle edge cases such as empty strings and non-repeating characters efficiently. # Example: ```python assert remove_duplicates(\\"google\\") == \\"gole\\" assert remove_duplicates(\\"character\\") == \\"charte\\" assert remove_duplicates(\\"abcd\\") == \\"abcd\\" assert remove_duplicates(\\"\\") == \\"\\" ``` Your implementation should consider performance and edge cases, ensuring the solution is optimized for the constraints provided.","solution":"def remove_duplicates(s: str) -> str: Returns a new string with all duplicate characters from the original string \'s\' removed, preserving only the first occurrences and maintaining the original order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Question **Objective**: Implement a more efficient version of the binomial coefficient calculation using dynamic programming (memoization). This will help reduce the number of redundant calculations and the depth of the recursion stack, thereby improving performance. # Problem Statement Implement the function `memoized_binomial_coefficient(n, k)` that computes the binomial coefficient C(n, k) using memoization to improve efficiency over the given recursive approach. # Function Signature ```python def memoized_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input - `n` (int): The number of elements in the set. - `k` (int): The number of elements to choose. # Output - Returns (int): The binomial coefficient C(n, k). # Constraints - 0 <= k <= n <= 1000 # Performance Requirements - The algorithm should run efficiently within the given constraints. - The solution should avoid deep recursion and excessive memory usage associated with large recursion stacks. # Example 1. For `memoized_binomial_coefficient(5, 0)`, it should return `1`. 2. For `memoized_binomial_coefficient(8, 2)`, it should return `28`. 3. For `memoized_binomial_coefficient(20, 10)`, it should return `184756`. ```python def memoized_binomial_coefficient(n: int, k: int) -> int: # Implementation here pass ``` # Notes * Use a dictionary or list for memoization to store intermediate results. * The function should handle invalid inputs by raising appropriate exceptions. * Ensure the function is well-tested with various edge cases and typical inputs.","solution":"def memoized_binomial_coefficient(n, k): Computes the binomial coefficient C(n, k) using memoization. memo = {} def binomial(n, k): if k > n: return 0 if k == 0 or k == n: return 1 if (n, k) in memo: return memo[(n, k)] # Recursive case result = binomial(n-1, k-1) + binomial(n-1, k) memo[(n, k)] = result return result return binomial(n, k)"},{"question":"# Question: String Reversal with Performance Focus You are tasked with writing a function to reverse strings. However, there are several implementations possible. Your job is to write a function `reverse_string(s: str) -> str` that optimizes for performance considering time and space complexity. Requirements: 1. **Input Format**: The function accepts a single string `s` (0 ≤ len(s) ≤ 10^5) consisting of ASCII characters. 2. **Output Format**: The function returns a new string that is the reverse of `s`. 3. **Constraints**: * The implementation should avoid unnecessary performance costs. * Aim to have a time complexity of O(n) and space complexity of O(n). * No built-in functions like `reversed()` or slicing (`[::-1]`) should be used. 4. Consider edge cases like empty strings or single-character strings. Example ```python assert reverse_string(\\"hello\\") == \\"olleh\\" assert reverse_string(\\"a\\") == \\"a\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"racecar\\") == \\"racecar\\" assert reverse_string(\\"abcd\\") == \\"dcba\\" ``` You need to achieve the best efficiency while handling all edge cases effectively.","solution":"def reverse_string(s: str) -> str: Reverses the input string s without using built-in reversed() or slicing. n = len(s) result = [\'\'] * n # allocation for the result string for i in range(n): result[i] = s[n - i - 1] return \'\'.join(result)"},{"question":"# Question: Implement a Cycle Sort Function You are required to implement the Cycle Sort algorithm to sort an array of integers in non-decreasing order. The algorithm should be implemented as an in-place sort with minimal memory usage. # Function Signature: ```python def cycle_sort(arr: list) -> list: pass ``` # Inputs: - An unsorted list of integers `arr` where ( 1 leq text{len(arr)} leq 1000 ) and elements ( arr[i] ) are bounded by ( -10^6 leq arr[i] leq 10^6 ). # Outputs: - Return the sorted list of integers in non-decreasing order (sorted in-place). # Constraints: - The function should run using ( O(1) ) additional memory. - The sorting should be done in place. - The implementation should handle edge cases such as empty arrays or arrays with all identical elements correctly. # Example: ```python # Example 1 arr = [3, 1, 2, 4] assert cycle_sort(arr) == [1, 2, 3, 4] # Example 2 arr = [-1, 5, 3, 2, 0] assert cycle_sort(arr) == [-1, 0, 2, 3, 5] # Example 3 arr = [5, 5, 5, 5] assert cycle_sort(arr) == [5, 5, 5, 5] # Example 4 arr = [10] assert cycle_sort(arr) == [10] # Example 5 arr = [] assert cycle_sort(arr) == [] ``` *Note: Ensure that the function handles arrays containing large values and verify if your implementation minimizes the number of write operations.*","solution":"def cycle_sort(arr: list) -> list: Sorts an array using Cycle Sort algorithm in-place and returns the sorted array. n = len(arr) # Traverse the array to find cycles to rotate for start in range(n - 1): item = arr[start] # Find where to put the item pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # Skip duplicate elements if pos == start: continue # Skip duplicate elements while item == arr[pos]: pos += 1 # Place the item at its correct position arr[pos], item = item, arr[pos] # Rotate rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"**Scenario**: You’ve been tasked with maintaining an inventory management system, which must support frequent insertions, deletions, and access operations. Given the constraints of the system, you decide to use a doubly linked list for efficient inserts and deletes but also need to implement a function for fetching the most recently accessed item and the least recently accessed item in the list. **Task**: Implement a doubly linked list in Python with the following operations: 1. **insert_at_head(value)**: Insert a node with the given value at the head of the list. 2. **insert_at_tail(value)**: Insert a node with the given value at the tail of the list. 3. **delete_node(value)**: Delete the first occurrence of a node with the given value. 4. **get_recently_accessed()**: Return the value of the head node. 5. **get_least_recently_accessed()**: Return the value of the tail node. **Input and Output Formats**: - `insert_at_head(value)`, `insert_at_tail(value)`, and `delete_node(value)` do not return any value. - `get_recently_accessed()` and `get_least_recently_accessed()` return the respective node values as integers. If the list is empty, return `None`. **Constraints**: - You can assume that the values are unique for simplicity. - Avoid using additional libraries for the linked list implementation. - Your solution should handle frequent operations efficiently. Example: ```python # Assuming we create an instance of DoublyLinkedList: dll = DoublyLinkedList() dll.insert_at_head(10) dll.insert_at_tail(20) dll.insert_at_head(30) dll.delete_node(20) # The list will be: [30, 10] print(dll.get_recently_accessed()) # Output should be 30 print(dll.get_least_recently_accessed()) # Output should be 10 ```","solution":"class Node: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = Node(value) if self.head is None: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value): new_node = Node(value) if self.tail is None: self.head = new_node self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def get_recently_accessed(self): if self.head: return self.head.value return None def get_least_recently_accessed(self): if self.tail: return self.tail.value return None"},{"question":"**Merge Sort Variation Implementation** You have been tasked with improving the performance of the merge sort implementation provided. The original implementation has a recursive merge sort coupled with a support function for merging. The goal is to implement an iterative version of merge sort to avoid the additional space usage associated with recursive function calls. # Problem Statement Write a function `iterative_merge_sort(arr: List[int]) -> List[int]` that sorts an array of integers in non-decreasing order using an iterative (non-recursive) approach to the merge sort algorithm. # Input - A list of integers, `arr`, where `1 <= len(arr) <= 100000`. # Output - A list of integers sorted in non-decreasing order. # Constraints - Your solution must run in O(n log n) time complexity. - Your solution must have an O(n) space complexity due to auxiliary storage. # Performance Requirements - The sorting function should efficiently handle arrays up to the maximum length as specified. # Example ```python # Input arr = [38, 27, 43, 3, 9, 82, 10] # Output sorted_arr = [3, 9, 10, 27, 38, 43, 82] ``` # Approach Use an iterative approach to implement the merging phase: 1. Start by considering each element as a sorted subarray. 2. Iteratively merge subarrays of increasing size until the whole array is sorted. ```python def iterative_merge_sort(arr): # Your implementation here ``` *HINT*: You may utilize a loop to iteratively merge subarrays. Be careful with boundary conditions and edge cases, such as when you have an odd subarray length remaining.","solution":"def iterative_merge_sort(arr): Perform an iterative merge sort on the provided array. :param arr: List of integers to be sorted :return: Sorted list of integers in non-decreasing order if len(arr) <= 1: return arr width = 1 n = len(arr) while width < n: for i in range(0, n, 2 * width): left = arr[i:i + width] right = arr[i + width:i + 2 * width] arr[i:i + 2 * width] = merge(left, right) width *= 2 return arr def merge(left, right): Merge two sorted lists into one sorted list. :param left: First sorted list. :param right: Second sorted list. :return: Merged sorted list. result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result"},{"question":"# Level Order Traversal with Custom Depth Output You are tasked with writing a function to perform a level order traversal on a binary tree, but with a twist. Besides returning the nodes\' values at each level from top to bottom, you should also return the depth (level number) of each level. Function Signature ```python def custom_level_order(root) -> List[Tuple[int, List[int]]]: pass ``` Input - `root`: The root of the binary tree. The tree node is represented as a class with properties `val`, `left`, and `right`. Output - List of tuples, where each tuple contains an integer representing the level number (starting from 0 for the root level) and a list of integers representing the node values at that level. Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - The node values are within the integer range. Example ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None # Example: # Given binary tree [3,9,20,null,null,15,7], # 3 # / # 9 20 # / # 15 7 # Should return: # [(0, [3]), (1, [9, 20]), (2, [15, 7])] root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(custom_level_order(root)) # Output: [(0, [3]), (1, [9, 20]), (2, [15, 7])] ```","solution":"from collections import deque from typing import List, Tuple, Optional class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def custom_level_order(root: Optional[TreeNode]) -> List[Tuple[int, List[int]]]: if not root: return [] result = [] queue = deque([(root, 0)]) while queue: level_nodes = [] current_level = queue[0][1] while queue and queue[0][1] == current_level: node, level = queue.popleft() level_nodes.append(node.val) if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) result.append((current_level, level_nodes)) return result"},{"question":"# Bit Operation Metrics Calculator You are tasked with implementing a metrics calculator that makes use of the four primary bit-manipulation functions provided. This calculator will determine specific properties of an input integer by manipulating its individual bits. # Problem Statement Given a non-negative integer `num`, implement a function `calculate_metrics(num: int) -> Dict[str, int]` that computes and returns a dictionary with three metrics: 1. `\\"set_bits\\"`: The number of bits set to 1 in the binary representation of `num`. 2. `\\"clear_bits\\"`: The number of bits set to 0 in the binary representation of `num`. 3. `\\"most_significant_bit_position\\"`: The position of the most significant bit set to 1. # Requirements 1. The function should leverage the provided bit manipulation functions (`get_bit`, `set_bit`, `clear_bit`, `update_bit`). 2. Ensure that your function runs efficiently with a time complexity close to O(log n), where n is the value of `num`. 3. Handle edge cases, such as `num` being zero, appropriately. # Input and Output Format * **Input**: A single integer `num` (0 <= num <= 10^9). * **Output**: A dictionary with three keys corresponding to the computed metrics. # Example ```python assert calculate_metrics(13) == { \\"set_bits\\": 3, \\"clear_bits\\": 29, \\"most_significant_bit_position\\": 3 } ``` Explanation: - Binary representation of 13 is \'1101\', which has three set bits (1\'s) and twenty-nine clear bits (0\'s) when considering a 32-bit integer. - The most significant bit set to 1 is at position 3 (0-indexed). # Function Signature ```python def calculate_metrics(num: int) -> Dict[str, int]: pass ```","solution":"def calculate_metrics(num: int) -> dict: Given a non-negative integer num, returns a dictionary with bit manipulation metrics: \'set_bits\': Number of bits set to 1. \'clear_bits\': Number of bits set to 0. \'most_significant_bit_position\': Position of the most significant bit set to 1. if num == 0: return { \\"set_bits\\": 0, \\"clear_bits\\": 32, \\"most_significant_bit_position\\": -1 } set_bits = 0 clear_bits = 0 most_significant_bit_position = -1 temp = num position = 0 while temp > 0: if temp & 1: set_bits += 1 most_significant_bit_position = position else: clear_bits += 1 temp >>= 1 position += 1 clear_bits += 32 - position # Accounting for remaining bits in a 32-bit number return { \\"set_bits\\": set_bits, \\"clear_bits\\": clear_bits, \\"most_significant_bit_position\\": most_significant_bit_position }"},{"question":"# Context: You are tasked with improving and generalizing the `ZigZagIterator` to handle an arbitrary number of lists. This will allow for more flexible data processing scenarios. # Problem Statement: Implement a class `GeneralZigZagIterator` that takes any number of lists and provides a mechanism to iterate through them in a round-robin (zigzag) fashion. # Function Signature: ```python class GeneralZigZagIterator: def __init__(self, *args): Initialize your data structure here. :param args: List of lists to be iterated over in a zigzag fashion. def next(self): :return: The next integer in the zigzag order. :rtype: int def has_next(self): :return: True if there are more elements to be iterated over, False otherwise. :rtype: bool ``` # Input: - The constructor receives an arbitrary number of lists. Each list contains integers. # Output: - `next` method returns the next integer in the zigzag order. - `has_next` method returns True if there are elements left to iterate, else returns False. # Constraints: - The input lists can vary in length and can include empty lists. - You should not assume any order or constraints on the size of the lists. # Examples: ```python l1 = [1, 2, 3] l2 = [4, 5, 6, 7, 8] l3 = [9, 10] it = GeneralZigZagIterator(l1, l2, l3) while it.has_next(): print(it.next()) # Output: [1, 4, 9, 2, 5, 10, 3, 6, 7, 8] ``` # Notes: - Implement the `GeneralZigZagIterator` without altering the input lists. - Pay close attention to handling edge cases such as empty lists or lists of varying lengths.","solution":"class GeneralZigZagIterator: def __init__(self, *args): Initialize your data structure here. :param args: List of lists to be iterated over in a zigzag fashion. self.lists = [lst for lst in args if lst] self.pointers = [0] * len(self.lists) self.idx = 0 def next(self): :return: The next integer in the zigzag order. :rtype: int if not self.has_next(): raise Exception(\\"No more elements\\") while self.pointers[self.idx] >= len(self.lists[self.idx]): self.idx = (self.idx + 1) % len(self.lists) result = self.lists[self.idx][self.pointers[self.idx]] self.pointers[self.idx] += 1 self.idx = (self.idx + 1) % len(self.lists) return result def has_next(self): :return: True if there are more elements to be iterated over, False otherwise. :rtype: bool return any(pointer < len(lst) for pointer, lst in zip(self.pointers, self.lists))"},{"question":"# Consecutive Sequence Check Using Stacks Assume you are given a stack of integers. You need to determine whether these integers form a sequence of consecutive values, starting from the bottom of the stack to the top. Implement a function `is_consecutive(stack)` that takes a stack as input and returns `True` if the stack contains a consecutive sequence of integers, `False` otherwise. Function Signature ```python def is_consecutive(stack: List[int]) -> bool: pass ``` Input - **stack** (List[int]): A list of integers representing the stack, where the last element is the top of the stack. Output - **bool**: Returns `True` if the stack contains a consecutive sequence of integers starting from the bottom, otherwise `False`. Constraints - Do not use any pre-built sorting functions. - Restore the original stack order after checking. - Elements of the stack can be any integers, both positive and negative. Example ```python assert is_consecutive([3, 4, 5, 6, 7]) == True assert is_consecutive([3, 4, 6, 7]) == False assert is_consecutive([3, 2, 1]) == False ``` # Implementation Requirements 1. You may use an auxiliary stack or queue. 2. The solution should handle edge cases where: - Stack contains a single element. - Stack has interrupted sequences. - Stack with all elements in non-consecutive order. 3. Ensure optimal performance and consider the time and space complexity constraints discussed. Scenario Consider this problem in a scenario where you are verifying a sequence in a game. You have a stack of cards where each card has a distinct number. A valid move in the game is to pick cards forming a consecutive sequence. This function will help determine if the sequence of cards picked up forms a valid consecutive sequence.","solution":"from typing import List def is_consecutive(stack: List[int]) -> bool: Determines whether the given stack of integers forms a consecutive sequence from the bottom to the top. if not stack: return False temp_stack = [] # Copy stack to temp_stack to reverse order while stack: temp_stack.append(stack.pop()) # Check consecutive sequence prev = temp_stack[-1] is_consecutive = True while temp_stack: current = temp_stack.pop() if current != prev: is_consecutive = False stack.append(current) # Restore original stack order prev += 1 return is_consecutive"},{"question":"You are tasked to implement an efficient function that calculates the result of raising a base integer to the power of an exponent integer, and then taking the modulo of this result with another integer. This operation is crucial in various applications such as cryptography and large number computations. # Function Signature ```python def fast_power(base: int, exponent: int, mod: int) -> int: \'\'\' Function to compute (base ^ exponent) % mod. Parameters: base (int): The base integer to be raised. exponent (int): The exponent integer. mod (int): The modulus integer. Returns: int: The result of (base ^ exponent) % mod. \'\'\' ``` # Input * `base`: An integer, `0 <= base <= 10^9`. * `exponent`: An integer, `0 <= exponent <= 10^9`. * `mod`: An integer, `1 <= mod <= 10^9`. # Output * Return an integer, representing `(base ^ exponent) % mod`. # Constraints * The base and exponent are non-negative integers. * The mod is a positive integer. * Implement the function so that it handles very large values efficiently. # Example Example 1: Input: ```plaintext base = 2 exponent = 10 mod = 1000 ``` Output: ```plaintext 24 ``` Explanation: 2^10 is 1024. 1024 % 1000 is 24. Example 2: Input: ```plaintext base = 7 exponent = 256 mod = 13 ``` Output: ```plaintext 9 ``` Explanation: 7^256 % 13 (using fast exponentiation) is 9.","solution":"def fast_power(base: int, exponent: int, mod: int) -> int: Function to compute (base ^ exponent) % mod using fast exponentiation. result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Scenario You are given a singly linked list where each node contains a value and a pointer to the next node. The list may contain duplicate values, and your task is to remove the duplicates effectively. # Task **Write a Python function `remove_duplicates(head)` that removes all duplicate values from the linked list in an efficient manner.** # Function Signature ```python def remove_duplicates(head): pass ``` # Input - `head`: The head node of the singly linked list. Each node contains an integer value and a pointer to the next node. # Output - The function should modify the linked list in place and return the head of the modified linked list, which has all duplicates removed. # Constraints - The function should handle: - An empty linked list (i.e., `head` is None). - Lists with up to 10^4 elements. - Assume list elements are within the range −10^3 to 10^3. - Aim for the most efficient solution in terms of time complexity (hint: consider using auxiliary storage). # Example ```python # Example of a Node class class Node(): def __init__(self, val=None): self.val = val self.next = None def print_linked_list(head): string = \\"\\" while head: string += str(head.val) + \\" -> \\" head = head.next print(string[:-4]) # Setup linked list: 1 -> 2 -> 3 -> 2 -> 1 head = Node(1) head.next = Node(2) head.next.next = Node(3) head.next.next.next = Node(2) head.next.next.next.next = Node(1) # Remove duplicates remove_duplicates(head) # Expected Output: 1 -> 2 -> 3 print_linked_list(head) ``` # Notes - Your implementation must efficiently handle long lists. - You should aim for a solution with O(N) time complexity, ideally with O(N) space complexity.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head): Removes duplicates from a linked list. :param head: The head node of the linked list. :return: The head node of the modified linked list. if not head: return head current = head seen_values = set() seen_values.add(current.val) while current.next: if current.next.val in seen_values: current.next = current.next.next else: seen_values.add(current.next.val) current = current.next return head"},{"question":"**Problem Description:** You are given a number, and you need to find the next higher number using the exact same set of digits as the original number. If no such number exists (i.e., the input number is the highest possible permutation), return `-1`. Function Signature ```python def next_bigger(num: int) -> int: pass ``` Input * An integer: `num` (1 ≤ `num` ≤ 10^9) Output * An integer which is the next greater permutation of `num`, or `-1` if no higher permutation exists. Examples ``` next_bigger(38276) -> 38627 next_bigger(99999) -> -1 next_bigger(12345) -> 12354 next_bigger(54321) -> -1 next_bigger(5) -> -1 ``` Constraints * Do not use libraries that directly implement permutations. * The solution should handle both optimal time and space complexity. * Consider edge cases like numbers with all identical digits or numbers already in descending order.","solution":"def next_bigger(num: int) -> int: Returns the next bigger number with the same set of digits as num. digits = list(str(num)) # 1. Find the first digit that can be increased i = len(digits) - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, return -1 if i == -1: return -1 # 2. Find the smallest digit on the right side of the found digit that is larger than the found digit j = len(digits) - 1 while digits[j] <= digits[i]: j -= 1 # 3. Swap the two digits digits[i], digits[j] = digits[j], digits[i] # 4. Reverse the digits to the right of the former position i digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\'\'.join(digits))"},{"question":"# Ternary Search Challenge **Context**: Given a sorted array of integers, you need to implement the ternary search algorithm to find the index of a specific element. Ternary search is a divide and conquer algorithm that recursively divides an array into three equal parts until the desired element is found. **Task**: Write a function `ternary_search` that performs a ternary search for a given key in a sorted array. **Function Signature**: ```python def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: pass ``` **Input**: - `left`: An integer representing the starting index of the array (initially 0). - `right`: An integer representing the ending index of the array (initially n-1, where n is the length of the array). - `key`: The element to be searched in the array. - `arr`: A list of integers sorted in ascending order. **Output**: - Return the index of the element if found. - Return -1 if the element is not found. **Constraints**: - The array will have at most 10⁴ elements. - Elements in the array range from -10⁴ to 10⁴. **Example**: ```python arr = [1, 3, 5, 7, 9, 11, 13] key = 9 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: 4 arr = [2, 4, 6, 8, 10, 12, 14] key = 5 print(ternary_search(0, len(arr) - 1, key, arr)) # Output: -1 ``` **Explanation**: - For the first example, the key 9 is found at index 4. - For the second example, the key 5 is not present in the array, so the function returns -1. **Performance Requirements**: - The solution should have a time complexity of O(log₃(N)) and a space complexity of O(1). Implement the `ternary_search` function to pass the given test cases.","solution":"from typing import List def ternary_search(left: int, right: int, key: int, arr: List[int]) -> int: while left <= right: third_part = (right - left) // 3 mid1 = left + third_part mid2 = right - third_part if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"**Context**: You are working on a project involving singly linked lists, and you encounter situations where you only have access to a specific node within the list (not the head) but need to delete that node. Your goal is to implement an efficient method to delete this given node. **Task**: Write a function to delete a node (except the tail) in a singly linked list when given only access to that node. **Function Signature**: ```python def delete_node(node): # Your code here ``` # Input: - `node` (Node): A reference to the node that needs to be deleted. It\'s guaranteed that the node is not the tail. # Output: - The function should modify the linked list in place, and does not return anything. If the node is the tail or the node is `None`, the function should raise a `ValueError`. # Constraints: - The node is part of a valid singly linked list and is not the tail node. # Requirements: - **Performance**: The function must perform the deletion in constant time, O(1). # Example: Suppose you have a linked list 1 -> 2 -> 3 -> 4 -> 5 and you are given the node with the value 3. After calling `delete_node(node)`, the linked list should become 1 -> 2 -> 4 -> 5 (the node with the value 3 is deleted). **Example Code**: ```python class Node: def __init__(self, x): self.val = x self.next = None head = Node(1) head.next = Node(2) node = head.next.next = Node(3) head.next.next.next = Node(4) ``` **Notes**: - Properly handle invalid or edge-case inputs by raising appropriate exceptions. - Ensure the function does not attempt to delete the tail node.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): Delete the given node (except the tail) from the singly linked list. Parameters: node (Node): A reference to the node that needs to be deleted. Raises: ValueError: If the node is the tail or None. if node is None or node.next is None: raise ValueError(\\"Cannot delete the tail node or None node.\\") # Copy the next node\'s data to the current node node.val = node.next.val # Bypass the next node node.next = node.next.next"},{"question":"**Problem Description**: You are implementing a feature for a math library that involves calculating factorials. The factorial of a non-negative integer ( n ), denoted ( n! ), is defined as the product of all positive integers less than or equal to ( n ). You need to write a function that calculates the factorial both iteratively and recursively. Additionally, the function should handle an optional parameter `mod` to return the result modulo `mod`. **Function Signature**: ```python def factorial_iter(n: int, mod: int = None) -> int: pass def factorial_recur(n: int, mod: int = None) -> int: pass ``` **Input**: - `n`: A non-negative integer (0 ≤ n ≤ 10^5). - `mod`: (Optional) A positive integer for performing the modulus operation. If not provided, no modulus operation is performed. **Output**: - An integer which is the factorial of `n`, modulo `mod` if provided. **Constraints**: - `n` is guaranteed to be a non-negative integer. - If `mod` is supplied, it is guaranteed to be a positive integer. **Requirements**: 1. Implement the `factorial_iter` function using an iterative approach. 2. Implement the `factorial_recur` function using a recursive approach. 3. Both functions should handle the provided `mod` parameter. **Examples**: ```python # Example 1: result = factorial_iter(5) assert result == 120 # Example 2: result = factorial_iter(5, mod=3) assert result == 0 # Example 3: result = factorial_recur(5) assert result == 120 # Example 4: result = factorial_recur(5, mod=3) assert result == 0 ``` **Explanation**: - In the first example, `5!` is `120`. - In the second example, `5! % 3` is `0`. - In the third example, `5!` calculated recursively is `120`. - In the fourth example, `5! % 3` calculated recursively is `0`.","solution":"def factorial_iter(n: int, mod: int = None) -> int: Calculate the factorial of n iteratively. If mod is provided, return the result modulo mod. result = 1 for i in range(2, n+1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: Calculate the factorial of n recursively. If mod is provided, return the result modulo mod. if n == 0 or n == 1: return 1 else: result = n * factorial_recur(n - 1, mod) if mod: result %= mod return result"},{"question":"# Factor Combination Finder Given a positive integer `n`, write a function `find_factor_combinations(n: int) -> List[List[int]]` that returns all possible combinations of its factors, except 1 and the number itself. # Input * `n` (int): A positive integer. # Output * A list of lists of integers, where each list represents a combination of `n`\'s factors. # Constraints * `1 <= n <= 10^5` * Factors should be greater than 1 and less than `n`. # Performance requirements * Your implementation should efficiently handle the constraints, with a focus on minimizing time and space complexity. # Example Input ```plaintext 12 ``` Output ```plaintext [ [2, 6], [2, 2, 3], [3, 4] ] ``` Input ```plaintext 32 ``` Output ```plaintext [ [2, 16], [2, 2, 8], [2, 2, 2, 4], [2, 2, 2, 2, 2], [2, 4, 4], [4, 8] ] ``` # Note You may assume that `n` is always positive. Factors should be greater than 1 and less than `n`. Your solution should demonstrate both iterative and recursive approaches.","solution":"from typing import List def find_factor_combinations(n: int) -> List[List[int]]: def backtrack(start, remaining, path): if remaining == 1: if len(path) > 1: result.append(path[:]) return for i in range(start, remaining + 1): if remaining % i == 0: path.append(i) backtrack(i, remaining // i, path) path.pop() result = [] backtrack(2, n, []) return result"},{"question":"# Question: You are designing a warehouse management system that needs to sort lists of items by their prices to facilitate various operations. Your task is to implement a variant of the Selection Sort algorithm which, instead of moving the minimum element to the beginning, moves the maximum element to the end of the list. Implement a function `selection_sort_descending(arr)` that sorts a given list in ascending order but with the operation of continuously moving the maximum element to the end of the unsorted part of the list. This is essentially the inverse iteration of the traditional Selection Sort. # Function Signature ```python def selection_sort_descending(arr: List[int]) -> List[int]: Sorts an array in ascending order using a modified selection sort algorithm. Parameters: arr (List[int]): List of integers to sort. Returns: List[int]: Sorted list of integers. ``` # Input * An array `arr` of integers. The array can be empty, or contain up to 1000 integers ranging from -10^6 to 10^6. # Output * A list of integers sorted in ascending order. # Example ```python >>> selection_sort_descending([64, 25, 12, 22, 11]) [11, 12, 22, 25, 64] >>> selection_sort_descending([5]) [5] >>> selection_sort_descending([]) [] ``` # Constraints * You must implement the sorting in-place. * Do not use any built-in sorting functions. * Optimize your code to handle up to the maximum input size efficiently. # Edge Cases to Consider 1. Receiving an empty list as input. 2. Lists with a single element. 3. Lists where all elements are identical. 4. Lists with negative and positive numbers mixed.","solution":"from typing import List def selection_sort_descending(arr: List[int]) -> List[int]: n = len(arr) for i in range(n-1): # Find the index of the maximum element in the remaining unsorted part max_index = 0 for j in range(1, n-i): if arr[j] > arr[max_index]: max_index = j # Swap it with the element at the end of the unsorted part arr[max_index], arr[n-i-1] = arr[n-i-1], arr[max_index] return arr"},{"question":"# Scenario: You are working on a project involving genealogy tracking, where you need to locate the lowest common ancestor of two individuals in a family tree stored as a binary tree. Given the tree structure, students need to identify the common ancestor efficiently. # Question: Implement a function `find_lowest_common_ancestor` to find the lowest common ancestor (LCA) in a given binary tree. # Function Signature: ```python def find_lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: ``` # Input: - `root` (TreeNode): The root node of the binary tree. - `p` (TreeNode): The first target node for which the LCA is to be found. - `q` (TreeNode): The second target node for which the LCA is to be found. # Output: - TreeNode: The lowest common ancestor node of given nodes `p` and `q`. # Constraints: - The tree is non-empty. - Values of `p` and `q` are guaranteed to be distinct. - All TreeNode values are unique. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right root = TreeNode(3) root.left = TreeNode(5) root.right = TreeNode(1) root.left.left = TreeNode(6) root.left.right = TreeNode(2) root.left.right.left = TreeNode(7) root.left.right.right = TreeNode(4) root.right.left = TreeNode(0) root.right.right = TreeNode(8) p = root.left # Node with value 5 q = root.right # Node with value 1 assert find_lowest_common_ancestor(root, p, q).val == 3 ``` # Performance Considerations: - The solution should optimize for both time and space complexities, aiming for O(N) time complexity and O(H) space complexity, where H is the height of the tree.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Function to find the lowest common ancestor (LCA) of two given nodes in a binary tree. # If we reach a leaf node or find either p or q, we return the root (base case) if root is None or root == p or root == q: return root # Recur for left and right subtrees left = find_lowest_common_ancestor(root.left, p, q) right = find_lowest_common_ancestor(root.right, p, q) # If both the left and right subtree return non-None, it means p and q are found # in different branches, so root is their LCA if left and right: return root # Otherwise, return the non-None node return left if left else right"},{"question":"# Scenario You are given two strings, \\"haystack\\" and \\"needle\\". Your task is to determine the index of the first occurrence of the needle in the haystack. If the needle is not a part of the haystack, return -1. # Problem Write a function `find_needle(haystack: str, needle: str) -> int` that: - Takes in two strings: - `haystack`: The target string in which to search. - `needle`: The substring to search for. - Returns an integer: - The index of the first occurrence of the needle in the haystack. - -1 if the needle is not found within the haystack. # Input - `haystack`: A string of length (N) where (0 leq N leq 10^5). - `needle`: A string of length (M) where (0 leq M leq 10^4). # Output - An integer representing the starting index of the first occurrence of needle in haystack or -1 if needle is not part of haystack. # Constraints - If `needle` is an empty string, return 0 (as by definition, it is found at the beginning of any string including an empty string). - The function must run efficiently for large strings due to constraint limitations. # Example ```python def find_needle(haystack: str, needle: str) -> int: # Your code goes here # Example 1 haystack = \\"hello\\" needle = \\"ll\\" print(find_needle(haystack, needle)) # Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" print(find_needle(haystack, needle)) # Output: -1 ``` # Notes - Consider improving the algorithm to be more efficient than (O(N cdot M)) if possible. - Handle edge cases properly, such as when the needle is longer than the haystack or when either string is empty.","solution":"def find_needle(haystack: str, needle: str) -> int: Returns the index of the first occurrence of `needle` in `haystack`. If `needle` is not found, returns -1. If `needle` is an empty string, return 0. if needle == \\"\\": return 0 haystack_length = len(haystack) needle_length = len(needle) if needle_length > haystack_length: return -1 for i in range(haystack_length - needle_length + 1): if haystack[i:i + needle_length] == needle: return i return -1"},{"question":"You are tasked with analyzing the distribution of scores in a large dataset. You need to implement a function that calculates the histogram of the given scores. Function Signature ```python def calculate_histogram(scores: list) -> dict: Calculate the histogram of the given list of scores. :param scores: A list containing integer scores. :return: A dictionary where the keys are the unique scores and the values are their counts. pass ``` # Input * `scores` (list of integers): Contains the scores which need to be analyzed. The list can be of any length from 0 to 10^6. # Output * A dictionary with unique scores as keys and their counts as values. # Constraints * The scores are all non-negative integers. * The list may contain from 0 to 10^6 elements. * The integer scores are limited by the range [0, 10^6]. # Example ```python calculate_histogram([3, 3, 2, 1]) # Expected output: {1: 1, 2: 1, 3: 2} calculate_histogram([2, 3, 5, 5, 5, 6, 4, 3, 7]) # Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} calculate_histogram([]) # Expected output: {} ``` Additional Considerations - Ensure efficiency for the upper limit constraints. - Consider edge cases, such as empty lists and lists with a single repeated value.","solution":"def calculate_histogram(scores: list) -> dict: Calculate the histogram of the given list of scores. :param scores: A list containing integer scores. :return: A dictionary where the keys are the unique scores and the values are their counts. histogram = {} for score in scores: if score in histogram: histogram[score] += 1 else: histogram[score] = 1 return histogram"},{"question":"# Diffie-Hellman with Error Handling You are to implement a function in Python that ensures the secure exchange of keys between two parties using the Diffie-Hellman key exchange protocol. The primes and coprimes must be validated, and any inconsistency or error in input should result in a clear and descriptive error message. Finally, ensure that the shared key computed by both parties is identical. The function should include detailed step-by-step debug logs. # Objective To gain proficiency in handling cryptographic key exchange algorithms and practice robust error handling with appropriate debug logs. # Requirements: 1. **Implement** a function `diffie_hellman_secure(a: int, p: int, verbose: bool = False) -> None` which: - Validates whether `p` is a prime number. - Checks if `a` is a primitive root of `p`. - Executes the Diffie-Hellman key exchange while securely handling private and public keys for both Alice and Bob. - Compares both shared keys from Alice and Bob to ensure they match. - Provides verbose debug logs if `verbose` is set to `True`. # Input: - `a (int)`: An integer candidate for the primitive root. - `p (int)`: A prime number acting as the modulo base. - `verbose (bool)`: Optional flag for detailed logging. # Output: - If invalid input is detected, print an appropriate error message. - If valid, print the private keys, public keys, and the shared secret key with debug logs if `verbose` is `True`. # Example Usage: ```python diffie_hellman_secure(a=2, p=11, verbose=True) ``` # Assumptions: 1. Both `a` and `p` should be positive integers. 2. Implement required helper functions if needed using the provided snippets as references. # Constraints: 1. `1 <= a < p <= 10^5` 2. Your solution must handle up to p = 10^5 efficiently.","solution":"import random from sympy import isprime, primerange def diffie_hellman_secure(a: int, p: int, verbose: bool = False) -> None: if not is_valid_prime(p): print(f\\"Error: {p} is not a prime number.\\") return if not is_primitive_root(a, p): print(f\\"Error: {a} is not a primitive root of {p}.\\") return # Generate private keys for Alice and Bob private_key_alice = random.randint(1, p - 1) private_key_bob = random.randint(1, p - 1) # Generate public keys for Alice and Bob public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Generate the shared secret key for Alice and Bob shared_key_alice = pow(public_key_bob, private_key_alice, p) shared_key_bob = pow(public_key_alice, private_key_bob, p) if verbose: print(f\\"Prime p: {p}\\") print(f\\"Primitive root a: {a}\\") print(f\\"Alice\'s private key: {private_key_alice}\\") print(f\\"Bob\'s private key: {private_key_bob}\\") print(f\\"Alice\'s public key: {public_key_alice}\\") print(f\\"Bob\'s public key: {public_key_bob}\\") print(f\\"Alice\'s shared key: {shared_key_alice}\\") print(f\\"Bob\'s shared key: {shared_key_bob}\\") if shared_key_alice == shared_key_bob: print(f\\"Shared key: {shared_key_alice}\\") else: print(\\"Error: The shared keys do not match.\\") def is_valid_prime(n: int) -> bool: return isprime(n) def is_primitive_root(a: int, p: int) -> bool: required_set = set(num for num in range(1, p) if gcd(num, p) == 1) actual_set = set(pow(a, powers, p) for powers in range(1, p)) return required_set == actual_set def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a"},{"question":"You are working on a system that requires frequent and efficient conversion of numbers between various bases. Your task is to implement two functions that convert an integer to a specified base and convert a number in a specified base to its integer equivalent. # Function Signature ```python def int_to_base(num: int, base: int) -> str: Convert an integer to a specified base. :param num: The integer to be converted. :param base: The base to convert the integer to (2-36). :return: A string representing the number in the specified base. pass def base_to_int(str_num: str, base: int) -> int: Convert a number in a specified base to its integer equivalent. :param str_num: The string representation of the number in the given base. :param base: The base of the given number (2-36). :return: The integer value of the number. pass ``` # Constraints - The base will be between 2 and 36, inclusive. - The input number for `int_to_base` can be any integer (positive, negative, or zero). - The input string for `base_to_int` will be a valid representation of a number in the given base. - Letters in the input string for `base_to_int` can be either uppercase or lowercase, and they should be treated equivalently (e.g., \'a\' == \'A\'). # Examples ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(255, 16) == \'FF\' assert int_to_base(-42, 7) == \'-60\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'FF\', 16) == 255 assert base_to_int(\'a\', 16) == 10 assert base_to_int(\'Z\', 36) == 35 ``` # Performance Requirements - Ensure the solution is efficient enough to handle large integers and long input strings with minimal lag.","solution":"def int_to_base(num: int, base: int) -> str: Convert an integer to a specified base. :param num: The integer to be converted. :param base: The base to convert the integer to (2-36). :return: A string representing the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(reversed(result)) def base_to_int(str_num: str, base: int) -> int: Convert a number in a specified base to its integer equivalent. :param str_num: The string representation of the number in the given base. :param base: The base of the given number (2-36). :return: The integer value of the number. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36.\\") str_num = str_num.strip().upper() digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" num = 0 negative = str_num[0] == \'-\' if negative: str_num = str_num[1:] for char in str_num: num = num * base + digits.index(char) return -num if negative else num"},{"question":"# Linked List Operations **Scenario**: Consider a typical text editor with an undo functionality, which allows the user to revert to previous states of the document. This can be efficiently managed using a doubly linked list, where each node represents a state of the document. Your task is to implement a doubly linked list to model this functionality. **Requirements**: 1. Implement a `DoublyLinkedList` class that supports the following operations: - Insert a node at the beginning. - Insert a node at the end. - Delete a node from the beginning. - Delete a node from the end. - Traverse the list forward and backward. - Display the current state of the list. **Constraints**: * Nodes will contain integer values. * The list can be empty initially. * Operations should handle edge cases gracefully (e.g., deleting from an empty list). **Input/Output**: - Implement each operation as a method in the `DoublyLinkedList` class. - The methods should not take additional input other than the required value for insertion. - For methods that delete nodes, return the value of the deleted node. - For traversal methods, return a list of values representing the order of nodes. **Example**: ```python class DoublyLinkedList: def __init__(self): # constructor implementation def insert_at_beginning(self, value): # method implementation def insert_at_end(self, value): # method implementation def delete_from_beginning(self): # method implementation def delete_from_end(self): # method implementation def traverse_forward(self): # method implementation def traverse_backward(self): # method implementation def display(self): # method implementation # Example usage dll = DoublyLinkedList() dll.insert_at_beginning(10) dll.insert_at_end(20) dll.insert_at_beginning(5) print(dll.traverse_forward()) # Output: [5, 10, 20] print(dll.traverse_backward()) # Output: [20, 10, 5] print(dll.delete_from_beginning()) # Output: 5 print(dll.delete_from_end()) # Output: 20 dll.display() # Should display the current state of the list ``` Implement the above methods to maintain the doubly linked list and its operations as per the given requirements.","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_beginning(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_end(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_from_beginning(self): if self.head is None: return None value = self.head.value if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None return value def delete_from_end(self): if self.tail is None: return None value = self.tail.value if self.head == self.tail: self.head = self.tail = None else: self.tail = self.tail.prev self.tail.next = None return value def traverse_forward(self): current = self.head result = [] while current: result.append(current.value) current = current.next return result def traverse_backward(self): current = self.tail result = [] while current: result.append(current.value) current = current.prev return result def display(self): forward = self.traverse_forward() backward = self.traverse_backward() print(\\"Forward: \\", forward) print(\\"Backward: \\", backward) # Example usage dll = DoublyLinkedList() dll.insert_at_beginning(10) dll.insert_at_end(20) dll.insert_at_beginning(5) print(dll.traverse_forward()) # Output: [5, 10, 20] print(dll.traverse_backward()) # Output: [20, 10, 5] print(dll.delete_from_beginning()) # Output: 5 print(dll.delete_from_end()) # Output: 20 dll.display() # Should display the current state of the list"},{"question":"# Coding Challenge: Next Higher Permutation Objective: Write a Python function that takes a non-negative integer and returns the next higher permutation of its digits. If no such permutation exists (i.e., the given number is the highest permutation possible), return -1. Function Signature: ```python def next_higher_permutation(num: int) -> int: ``` Input: - `num`: A non-negative integer `0 <= num <= 10^9`. Output: - An integer representing the next higher permutation of the digits of `num`, or -1 if no higher permutation exists. # Requirements: 1. The function should be efficient, with time complexity approximately O(n), where n is the number of digits in the input number. 2. Handle edge cases properly: - Numbers with repeated digits. - Single-digit numbers. - Numbers where all digits are the same. - Numbers in descending order. # Example Scenarios: ```python next_higher_permutation(38276) should return 38627 next_higher_permutation(54321) should return -1 next_higher_permutation(1528452) should return 1528524 next_higher_permutation(999) should return -1 next_higher_permutation(5) should return -1 ``` # Constraints: - You can assume the input integer is within the range of a 32-bit signed integer. - The function should handle both small and large integers efficiently. - Minimize memory usage where possible. # Testing: Ensure thorough unit tests that cover: 1. Typical cases with varied digits. 2. Edge cases with no possible higher permutation. 3. Large numbers up to the given constraint.","solution":"def next_higher_permutation(num: int) -> int: digits = list(str(num)) length = len(digits) # Step 1: Find the largest index i such that digits[i] < digits[i + 1] i = length - 2 while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such i exists, the permutation is the highest if i == -1: return -1 # Step 2: Find the largest index j greater than i such that digits[i] < digits[j] j = length - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the value of digits[i] with digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence from digits[i + 1] up to the last element digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"# Question: Fibonacci Sequence Optimizations You have learned three different algorithms to calculate the n-th Fibonacci number: 1. Recursive (Slow and inefficient) 2. Dynamic Programming (Efficient in time, but uses extra space) 3. Iterative (Efficient in both time and space) Given the following requirements, implement a new function `fib_optimized` to calculate the n-th Fibonacci number efficiently, minimizing both time and space complexities: Requirements: * **Function Signature**: `def fib_optimized(n: int) -> int:` * **Input**: * `n` (integer): The position in the Fibonacci sequence (0-indexed). Constraints: 0 <= n <= 10^7. * **Output**: * `int`: The n-th Fibonacci number. * **Constraints**: * Minimize both time and space complexities. * Handle edge cases where n is 0 or 1. * Ensure the function runs efficiently for very large values of n (up to 10 million). Write the `fib_optimized` function in Python. Example: ```python assert fib_optimized(10) == 55 assert fib_optimized(20) == 6765 assert fib_optimized(100) == 354224848179261915075 ``` Explanation: Your solution should use an approach that is efficient in both time and space, such as the iterative method seen above or further optimizations. Compute the result without using excessive space for large inputs.","solution":"def fib_optimized(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach that is efficient in both time and space. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Encoding and Decoding of Strings Context A common problem when transmitting data over networks is that the data might contain special characters or varying lengths which can cause issues during processing. To circumvent this, a robust encoding and decoding mechanism is necessary. Task You are required to implement two functions, `encode` and `decode`, to encode a list of strings into a single string and then decode that single string back into the original list of strings. Requirements - The `encode` function should concatenate strings in such a way that each string is prefixed by its length and a special delimiter `\':\'`. - The `decode` function should parse this single string back to the list of original strings by reading each string length and splitting appropriately. Input and Output Formats * `encode`: - **Input**: `List[str]` - a list of strings to be encoded. - **Output**: `str` - a single encoded string. * `decode`: - **Input**: `str` - an encoded string. - **Output**: `List[str]` - a decoded list of strings. Constraints * All characters in the strings are printable ASCII characters. * The length of each string and the number of strings are reasonably bounded by typical limitations (e.g., each string length <= 1000, number of strings <= 100). Examples Here\'s how your functions should behave: ```python assert decode(encode([\\"hello\\", \\"world\\"])) == [\\"hello\\", \\"world\\"] assert decode(encode([\\"4:len\\", \\":\\"])) == [\\"4:len\\", \\":\\"] assert decode(encode([\\"\\"])) == [\\"\\"] ``` Implementation Define the following functions: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Implementation here def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Implementation here ``` Your implementation should handle all edge cases and ensure accurate encoding/decoding.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] strs, i = [], 0 while i < len(s): # Find the position of delimiter \':\' j = i while s[j] != \':\': j += 1 # The length of the next string length = int(s[i:j]) # The next string strs.append(s[j + 1: j + 1 + length]) # Move to the next segment i = j + 1 + length return strs"},{"question":"# Question: Implement an Efficient Stack with Minimum Element Retrieval You are required to implement a stack that supports push, pop, and retrieving the minimum element in constant time. This implementation should extend from the abstract stack class provided. You must choose either the array-based implementation or the linked list-based implementation as the foundation for your stack. **Function Specifications**: 1. **push(value: int) -> None**: Adds the element `value` to the top of the stack. 2. **pop() -> int**: Removes the element from the top of the stack and returns it. 3. **peek() -> int**: Returns the element from the top of the stack without removing it. 4. **get_min() -> int**: Returns the minimum element in the stack. **Input and Output Format**: 1. The stack will store integer values. 2. The `push` method will be called with an integer value to add to the stack. 3. The `pop` and `peek` methods will return integer values from the stack. 4. The `get_min` method will return the minimum integer value currently in the stack. **Constraints**: 1. All operations must be performed in constant time, O(1). 2. The stack must handle multiple elements and manage edge cases like empty stack scenarios. 3. The stack must allow the initial size to be user-defined for the array-based implementation, with a default size of 10. **Example**: ```python stack = MinStack(10) stack.push(5) stack.push(3) stack.push(7) print(stack.get_min()) # Output: 3 stack.pop() print(stack.get_min()) # Output: 3 stack.pop() print(stack.get_min()) # Output: 5 stack.push(2) print(stack.get_min()) # Output: 2 stack.pop() print(stack.pop()) # Output: 5 ```","solution":"class MinStack: def __init__(self, size: int = 10): self.stack = [] self.min_stack = [] self.size = size def push(self, value: int) -> None: self.stack.append(value) if not self.min_stack or value <= self.min_stack[-1]: self.min_stack.append(value) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") value = self.stack.pop() if value == self.min_stack[-1]: self.min_stack.pop() return value def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"get_min from empty stack\\") return self.min_stack[-1]"},{"question":"You are provided with a function `delete_node` that removes a node from a singly linked list. However, the function requires modifications to handle an updated set of requirements. Requirements: 1. **Function Signature**: ```python def delete_node(node): ``` 2. **Input**: A single `Node` which represents the node to be deleted. The node is guaranteed to be part of a non-empty linked list. Your function should handle various edge cases defined below. 3. **Output**: None. The function should modify the linked list in place. 4. **Edge Cases**: - The node is the only node in the list. - The node is the tail node. - The node is `None`. 5. **Constraints**: - Handle invalid nodes by raising an appropriate exception. - Do not change the handling efficiency of the node deletion. Expanded Requirements: Modify the provided `delete_node` function to: - Raise `ValueError` if the node is `None`. - Raise `ValueError` if the node is the only node in the list. - Raise `ValueError` if the node is the tail node. # Example ```python # Make linked list 1 -> 2 -> 3 -> 4 head = Node(1) node2 = Node(2) node3 = Node(3) tail = Node(4) head.next = node2 node2.next = node3 node3.next = tail # After delete_node(node3), linked list should become 1 -> 2 -> 4. delete_node(node3) # After deletion, the list traversal should return: 1, 2, 4 assert head.val == 1 assert head.next.val == 2 assert head.next.next.val == 4 # Delete the tail node should raise ValueError try: delete_node(tail) except ValueError: print(\\"Cannot delete the tail node\\") # Delete when node is None should raise ValueError try: delete_node(None) except ValueError: print(\\"Node is None\\") # Delete the only node in the list should raise ValueError single_node_list = Node(10) try: delete_node(single_node_list) except ValueError: print(\\"Cannot delete the only node in the list\\") ``` Write the modified `delete_node` function addressing the given requirements and constraints. Ensure your code handles the specified edge cases.","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def delete_node(node): Deletes a node from a singly linked list. Modifies the linked list in place. Handles edge cases by raising exceptions. - Raises ValueError if the node is None. - Raises ValueError if the node is the only node in the list. - Raises ValueError if the node is the tail node. if node is None: raise ValueError(\\"Node is None\\") if node.next is None: raise ValueError(\\"Cannot delete the tail node\\") # Copy the data from the next node to the current node and skip the next node next_node = node.next node.val = next_node.val node.next = next_node.next"},{"question":"You are given a singly linked list and an integer `k` that represents the number of positions you need to rotate the list to the right. Implement the function `rotate_right(head, k)` to perform the rotation. Function Signature: ```python def rotate_right(head: ListNode, k: int) -> ListNode: :param head: ListNode - The head of the singly linked list :param k: int - Number of positions to rotate the list to the right :return: ListNode - The new head of the rotated list ``` Input: * `head`: The head of a singly linked list. * `k`: A non-negative integer denoting the number of positions to rotate the list. Output: - Return the head of the rotated singly linked list. Constraints: - The number of nodes in the list is in the range [0, 50]. - 0 <= k <= 100. Example: ```python # Assuming ListNode class is already defined as in the prompt. # Example 1: # Input: head = [1->2->3->4->5], k = 2 # Output: [4->5->1->2->3] # Example 2: # Input: head = [0->1->2], k = 4 # Output: [2->0->1] ``` Explanation: 1. In Example 1, rotating the list `[1, 2, 3, 4, 5]` by 2 places to the right gives `[4, 5, 1, 2, 3]`. 2. In Example 2, rotating the list `[0, 1, 2]` by 4 places to the right is equivalent to rotating it by 1 place (since 4 modulo 3 is 1), resulting in `[2, 0, 1]`. Notes: - Do not create extra arrays or modify the node values; manipulate nodes’ pointers only. - Handle edge cases such as when the list is empty or contains only one node, and when k equals 0 or a multiple of the length of the list.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def rotate_right(head: ListNode, k: int) -> ListNode: if not head or not head.next or k == 0: return head # Calculate the length of the list current, length = head, 1 while current.next: current = current.next length += 1 # Find the actual number of rotations needed k = k % length if k == 0: return head # Find the new tail (length - k) element slow, fast = head, head for _ in range(k): fast = fast.next while fast.next: slow = slow.next fast = fast.next # Perform the rotation new_head = slow.next slow.next = None fast.next = head return new_head"},{"question":"The `Union-Find` data structure, also known as Disjoint Set, is efficient for unifying sets and checking element connectivity. In this exercise, you will enhance the existing implementation and use it to solve a grid-based problem. Write a function `num_islands(positions: List[List[int]]) -> List[int]` that simulates sequentially adding land to a 2D grid and counts the number of islands after each addition. An \\"island\\" is a group of connected 1s (land) surrounded by water (0s). Connections are allowed only vertically and horizontally. # Requirements: 1. Implement the `Union-Find` class with methods for `add`, `root`, and `unite`. 2. Use the `Union-Find` class to solve the given problem: * `num_islands(positions: List[List[int]]) -> List[int]`: Given a list of land positions to add (each represented as `[row, col]`), return a list representing the number of islands after each addition. # Input: - `positions`: A list of land addition operations, where each operation is represented as a list of two integers `[row, col]` indicating the coordinates of the land to be added. # Output: - A list of integers where the i-th element is the number of islands after performing the i-th add-land operation. # Example: ```python # Given a 3x3 grid, positions = [[0,0], [0,1], [1,2], [2,1]] positions = [[0, 0], [0, 1], [1, 2], [2, 1]] assert num_islands(positions) == [1, 1, 2, 3] # Explanation: # Initially, the grid is filled with water: # 0 0 0 # 0 0 0 # 0 0 0 # After adding land at [0,0], the grid looks like: # 1 0 0 # 0 0 0 # 0 0 0 # Number of islands = 1 # After adding land at [0,1], the grid looks like: # 1 1 0 # 0 0 0 # 0 0 0 # Number of islands = 1 # After adding land at [1,2], the grid looks like: # 1 1 0 # 0 0 1 # 0 0 0 # Number of islands = 2 # After adding land at [2,1], the grid looks like: # 1 1 0 # 0 0 1 # 0 1 0 # Number of islands = 3 ``` # Constraints: - The grid size is not given, but it is considered finite and the input positions fit within this grid. - Coordinates of positions are unique. - The positions list can have up to 10,000 elements. Implement the `num_islands` function efficiently using the principles of Union-Find.","solution":"from typing import List, Tuple, Dict class UnionFind: def __init__(self): self.parent = {} self.rank = {} def add(self, p: Tuple[int, int]): if p not in self.parent: self.parent[p] = p self.rank[p] = 0 def root(self, p: Tuple[int, int]) -> Tuple[int, int]: if self.parent[p] != p: self.parent[p] = self.root(self.parent[p]) # Path compression return self.parent[p] def unite(self, p: Tuple[int, int], q: Tuple[int, int]): rootP = self.root(p) rootQ = self.root(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 def num_islands(positions: List[List[int]]) -> List[int]: uf = UnionFind() directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] island_count = 0 result = [] for pos in positions: p = tuple(pos) if p in uf.parent: result.append(island_count) continue uf.add(p) island_count += 1 for d in directions: q = (p[0] + d[0], p[1] + d[1]) if q in uf.parent: if uf.root(p) != uf.root(q): uf.unite(p, q) island_count -= 1 result.append(island_count) return result"},{"question":"Scenario You are developing a system to analyze survey data. Each respondent in your survey has a unique ID, but due to a data processing error, some IDs have been recorded twice. However, there is guaranteed to be exactly one correct survey entry that appears only once while every other survey ID appears twice. You need to write a function to identify that unique survey ID efficiently. Question Write a function `find_unique_survey_id` that takes a list of integers representing survey IDs and returns the unique survey ID that appears only once. If all survey IDs appear twice or the input list is empty, the function should return 0. # Function Signature ```python def find_unique_survey_id(survey_ids: List[int]) -> int: ``` # Input Format - A list, `survey_ids`, containing integers representing survey IDs. - Constraints: - The length of `survey_ids` is in the range [0, 10^6]. - Each integer in `survey_ids` (survey ID) is at most 32 bits. # Output Format - An integer representing the unique survey ID, or 0 if no such ID exists. # Example ```python # Example 1 assert find_unique_survey_id([4, 2, 2, 1, 4]) == 1 # Example 2 assert find_unique_survey_id([4, 4, 2, 2]) == 0 # Example 3 assert find_unique_survey_id([]) == 0 ``` # Performance Requirements - The solution must have a linear runtime complexity, O(n). - The solution must have a constant space complexity, O(1). # Additional Notes Ensure your solution handles edge cases, such as an empty list and lists where no unique survey ID is present.","solution":"from typing import List def find_unique_survey_id(survey_ids: List[int]) -> int: Returns the unique survey ID that appears only once. If all survey IDs appear twice or the input list is empty, returns 0. if not survey_ids: return 0 unique_id = 0 for id in survey_ids: unique_id ^= id if survey_ids.count(unique_id) == 1: return unique_id else: return 0"},{"question":"# Problem: Enhanced Counting Sort Implementation Given an array of numbers, implement an enhanced version of Counting Sort that can sort both positive and negative integers efficiently. Ensure that your implementation is stable and handles large ranges of numbers. Input * An array of integers `arr` (e.g., it can contain both positive and negative integers). * The length of `arr` is always within the range [1, 10^5]. * The value of elements in `arr` can be as large as 10^9 in magnitude. Output * Return a sorted array in non-decreasing order. Sample Input ```python arr = [4, -1, -2, 7, 1, 3, -2, 0, -3, 3, 2, 1] ``` Sample Output ```python [-3, -2, -2, -1, 0, 1, 1, 2, 3, 3, 4, 7] ``` Constraints * The input array will only contain integers. * Your implementation should be able to handle large ranges effectively, but won\'t be tested on ranges exceeding the total length by more than a factor of 10. Implementation Details 1. Ensure that your function name is `enhanced_counting_sort`. 2. Input to the function will be a list of integers. 3. The function should return a list of integers sorted in non-decreasing order. 4. Optimize your implementation to ensure it can handle up to 100,000 integers efficiently. ```python def enhanced_counting_sort(arr): # [Your implementation here] pass # Example usage: arr = [4, -1, -2, 7, 1, 3, -2, 0, -3, 3, 2, 1] print(enhanced_counting_sort(arr)) # Outputs: [-3, -2, -2, -1, 0, 1, 1, 2, 3, 3, 4, 7] ```","solution":"def enhanced_counting_sort(arr): if not arr: return arr # Finding the range of the array min_val = min(arr) max_val = max(arr) range_val = max_val - min_val + 1 # Initializing the count array count = [0] * range_val # Count occurrence of each element for num in arr: count[num - min_val] += 1 # Rebuild the sorted array sorted_arr = [] for i in range(range_val): while count[i] > 0: sorted_arr.append(i + min_val) count[i] -= 1 return sorted_arr # Example usage: arr = [4, -1, -2, 7, 1, 3, -2, 0, -3, 3, 2, 1] print(enhanced_counting_sort(arr)) # Outputs: [-3, -2, -2, -1, 0, 1, 1, 2, 3, 3, 4, 7]"},{"question":"Context: You are given an array of integers where each integer may appear more than once. You need to find and return the index of a given query integer. If the query integer is not found in the array, the function should return -1. Additionally, you should enhance the linear search to handle an additional constraint—stopping the search as soon as you find the first element greater than the query integer (assuming the array is partially sorted). Task: Write a function `enhanced_linear_search(array, query)` that takes in two parameters: - `array`: a list of integers. - `query`: an integer to search for. The function should return the index of the first occurrence of `query` in the array. If the `query` is not found, return -1. If during the search, you encounter an integer greater than the `query`, you should stop and return -1 immediately. Input: - `array` (list of integers): the array in which to search. - `query` (integer): the integer to find in the array. Output: - (integer): The index of the `query` in the array or -1 if not found. Constraints: - The array is not guaranteed to be fully sorted, but integers greater than the query should indicate that if found during the search, further searching is futile. - Assume that the integers in the array and query are all within the range of -10^9 to 10^9. - The length of the array will not exceed 10^6 elements. Examples: - `enhanced_linear_search([1, 4, 5, 6, 9], 5) -> 2` - `enhanced_linear_search([1, 3, 3, 4, 6, 7], 4) -> 3` - `enhanced_linear_search([1, 4, 5, 7, 8], 6) -> -1` - `enhanced_linear_search([], 5) -> -1` - `enhanced_linear_search([2, 3, 6, 7, 10], 5) -> -1` Note: - The function should handle large datasets efficiently. - Returning the index of the first occurrence of the query integer is mandatory if found without encountering a greater integer. - Ensure the function stops processing as soon as it finds an element greater than the query during its linear scan.","solution":"def enhanced_linear_search(array, query): Returns the index of the first occurrence of the query integer in the array. If the query is not found or a greater integer is encountered during the search, the function returns -1. for index, value in enumerate(array): if value == query: return index if value > query: return -1 return -1"},{"question":"# Rabin-Karp Algorithm Implementation You are required to improve and implement the Rabin-Karp algorithm to locate the first occurrence of a given pattern string within a target text string. The current provided function returns an index within the text where the pattern starts or -1 if the pattern is not found. # Input * `pattern`: A non-empty string containing the pattern to be searched in the text. * `text`: A potentially empty string where the pattern needs to be located. # Output * An integer representing the starting index of the first occurrence of the pattern in the text. If the pattern is not found, return -1. # Constraints * 1 <= len(pattern) <= 100 * 0 <= len(text) <= 10^5 * Both `pattern` and `text` only contain lowercase English letters. # Requirements 1. Refactor and complete the `rabin_karp` function. 2. Ensure it handles common edge cases effectively. 3. Optimize the code for minimizing time complexity where possible. 4. Return correct starting position or -1 if the pattern is not present. # Example Input ```python pattern = \\"abc\\" text = \\"ababcabc\\" ``` Output ``` 2 ``` Explanation The pattern \\"abc\\" first appears from the index 2 in the text \\"ababcabc\\". # Code Template ```python class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word for i in range(0, size_word): self.hash += (ord(self.text[i]) - ord(\\"a\\")+1)*(26**(size_word - i -1)) self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end <= len(self.text) - 1: self.hash -= (ord(self.text[self.window_start]) - ord(\\"a\\")+1)*26**(self.size_word-1) self.hash *= 26 self.hash += ord(self.text[self.window_end])- ord(\\"a\\")+1 self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def rabin_karp(pattern, text): if pattern == \\"\\" or text == \\"\\" or len(pattern) > len(text): return -1 rolling_hash = RollingHash(text, len(pattern)) pattern_hash = RollingHash(pattern, len(pattern)) for i in range(len(text) - len(pattern) + 1): if rolling_hash.hash == pattern_hash.hash: if rolling_hash.window_text() == pattern: return i rolling_hash.move_window() return -1 ``` Provide an implementation for the `rabin_karp` function using this template.","solution":"class RollingHash: def __init__(self, text, size_word): self.text = text self.hash = 0 self.size_word = size_word self.base = 26 self.mod = 10**9 + 7 for i in range(size_word): self.hash = (self.hash * self.base + ord(self.text[i]) - ord(\'a\') + 1) % self.mod self.window_start = 0 self.window_end = size_word def move_window(self): if self.window_end < len(self.text): old_char_value = (ord(self.text[self.window_start]) - ord(\'a\') + 1) * pow(self.base, self.size_word - 1, self.mod) self.hash = (self.hash - old_char_value) * self.base + (ord(self.text[self.window_end]) - ord(\'a\') + 1) self.hash %= self.mod self.window_start += 1 self.window_end += 1 def window_text(self): return self.text[self.window_start:self.window_end] def rabin_karp(pattern, text): if not pattern or not text or len(pattern) > len(text): return -1 m = len(pattern) n = len(text) rolling_hash = RollingHash(text, m) pattern_hash = RollingHash(pattern, m) pattern_hash_value = pattern_hash.hash for i in range(n - m + 1): if rolling_hash.hash == pattern_hash_value: if rolling_hash.window_text() == pattern: return i rolling_hash.move_window() return -1"},{"question":"# Randomized Set Operations A **social media application** requires storing a user\'s unique friends list and being able to do the following operations very efficiently: * **Insert**: Add a friend to the list if not already present. * **Remove**: Remove a friend from the list if present. * **Get Random Friend**: Select and return a random friend from the list with equal probability. You have to implement these functionalities in average O(1) time. # Instructions Implement the `RandomizedSet` class: 1. **`insert(val: int) -> bool`**: Inserts a friend (integer value) to the list if not already in the list. Returns `True` if the friend was added, `False` otherwise. 2. **`remove(val: int) -> bool`**: Removes a friend (integer value) from the list if present. Returns `True` if the friend was removed, `False` otherwise. 3. **`get_random() -> int`**: Returns a random friend from the list. Each friend should have an equal probability of being returned. # Constraints * All friends\' IDs are integers within the range `1 <= val <= 10^6`. * At most `2 * 10^6` calls will be made to `insert`, `remove`, and `get_random`. # Example ```python # Initialize the RandomizedSet random_set = RandomizedSet() # Insert friends print(random_set.insert(1)) # Returns True print(random_set.insert(2)) # Returns True print(random_set.insert(2)) # Returns False # Remove a friend print(random_set.remove(2)) # Returns True print(random_set.remove(2)) # Returns False # Get random friend print(random_set.get_random()) # Returns either 1 with equal probability ``` # Note - Ensure that the implementation handles edge cases such as attempting random selection from an empty set.","solution":"import random class RandomizedSet: def __init__(self): Initialize the data structure. self.data = {} self.list = [] def insert(self, val: int) -> bool: Inserts a value to the set if not already present. Returns True if the value was inserted, False otherwise. if val in self.data: return False self.data[val] = len(self.list) self.list.append(val) return True def remove(self, val: int) -> bool: Removes a value from the list if present. Returns True if the value was removed, False otherwise. if val not in self.data: return False index = self.data[val] last_element = self.list[-1] self.list[index] = last_element self.data[last_element] = index self.list.pop() del self.data[val] return True def get_random(self) -> int: Returns a random value from the list. return random.choice(self.list)"},{"question":"# Question: Histogram Calculation As a data analyst, you\'ve been given a list of numbers and tasked with visualizing the distribution of these numbers using a histogram. A histogram represents the frequency of each unique element within a list. Your task is to write a function `get_histogram` that takes a list of integers and returns a dictionary where the keys are the unique integers from the list, and the values are the counts of each integer\'s occurrences. Function Signature ```python def get_histogram(input_list: list) -> dict: pass ``` Input * `input_list` (list): A list of integers. The list can be empty and includes repeated integers. Output * `dict`: A dictionary where each key is a unique integer from `input_list`, and its corresponding value is the number of times that integer appears in `input_list`. Constraints * The input list will contain integers between -10^5 and 10^5. * The length of the input list will not exceed 10^6 elements. Performance Requirements * Your function should run efficiently with a time complexity of O(n), where n is the number of elements in the `input_list`. * The space complexity should be O(k), where k is the number of unique elements in the `input_list`. Example ```python # Example 1 input_list = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] # Expected Output: {} ``` Guidelines 1. Ensure your function adheres to the constraints and performance requirements. 2. Consider handling any edge cases, such as an empty input list. 3. Avoid using built-in library methods specific to creating histograms to ensure you understand the mechanics of the algorithm. Implement your solution in the function `get_histogram`.","solution":"def get_histogram(input_list: list) -> dict: This function takes a list of integers and returns a histogram in the form of a dictionary where the keys are the unique integers from the list, and the values are the counts of each integer\'s occurrences. histogram = {} for number in input_list: if number in histogram: histogram[number] += 1 else: histogram[number] = 1 return histogram"},{"question":"**Matrix Inversion Function** Given a square matrix, the task is to implement a function that computes its inverse. This problem requires a deep understanding of matrix operations and determinants. Your implementation should be robust and efficiently handle edge cases. # Function Signature ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` # Input - `matrix`: A list of lists representing an n x n square matrix of floats. # Output - Returns an n x n matrix which is the inverse of the input matrix. - If the matrix is not invertible (det = 0) or not valid, output an appropriate error matrix with the following structure: - [ [-1] ] if the input is not a matrix. - [ [-2] ] if the matrix is not square. - [ [-3] ] if the matrix size is less than 2. - [ [-4] ] if the matrix is singular (i.e., determinant = 0). # Constraints - n ∈ [2, 50] # Example ```python # Example 1: matrix = [ [4, 7], [2, 6] ] # Expected Output: # [ # [0.6, -0.7], # [-0.2, 0.4] # ] # Example 2: matrix = [ [1, 2, 3], [0, 1, 4], [5, 6, 0] ] # Expected Output: # [ # [-24, 18, 5], # [20, -15, -4], # [-5, 4, 1] # ] ``` # Notes - You can use helper functions to break down the task into smaller segments (like computing determinants, matrix of minors, cofactors, etc.). - Consider edge cases and ensure the function handles different possible matrix conditions gracefully. - Avoid unnecessary recomputations where possible to optimize performance. - Use appropriate error handling and clear comments for the expected behavior in edge cases.","solution":"from typing import List def get_matrix_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [ [row[k] for k in range(len(matrix)) if k != j] for row in (matrix[r] for r in range(len(matrix)) if r != i) ] def get_matrix_determinant(matrix: List[List[float]]) -> float: if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1) ** c) * matrix[0][c] * get_matrix_determinant(get_matrix_minor(matrix, 0, c)) return determinant def get_matrix_inverse(matrix: List[List[float]]) -> List[List[float]]: determinant = get_matrix_determinant(matrix) if determinant == 0: return [[-4]] if len(matrix) == 2: return [ [matrix[1][1] / determinant, -1 * matrix[0][1] / determinant], [-1 * matrix[1][0] / determinant, matrix[0][0] / determinant] ] cofactors = [] for r in range(len(matrix)): cofactorRow = [] for c in range(len(matrix)): minor = get_matrix_minor(matrix, r, c) cofactorRow.append(((-1) ** (r + c)) * get_matrix_determinant(minor)) cofactors.append(cofactorRow) cofactors = list(map(list, zip(*cofactors))) for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / determinant return cofactors def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: if not all(isinstance(row, list) for row in matrix): return [[-1]] if len(matrix) < 2 or not all(len(row) == len(matrix) for row in matrix): return [[-2 if len(matrix) != len(matrix[0]) else -3]] try: return get_matrix_inverse(matrix) except Exception: return [[-4]]"},{"question":"# Question: Efficient Insert Position in a Sorted Array You are given a sorted array of distinct integers and a target value. Write a function `efficient_insert_position` that determines the index at which the target value should be inserted to maintain the sorted order of the array. Function Signature ```python def efficient_insert_position(array: List[int], target: int) -> int: ``` Input * `array` (List[int]): A sorted list of distinct integers. The length of the array `n` satisfies 0 ≤ n ≤ 10^5. * `target` (int): The value to be inserted. Output * Returns an integer, the index where the target value should be inserted. Constraints * You should achieve time complexity of O(log n). * The sorted array does not contain duplicate values. * The implementation should handle border cases such as empty input array. Examples 1. `efficient_insert_position([1, 3, 5, 6], 5)` should return 2. 2. `efficient_insert_position([1, 3, 5, 6], 2)` should return 1. 3. `efficient_insert_position([1, 3, 5, 6], 7)` should return 4. 4. `efficient_insert_position([1, 3, 5, 6], 0)` should return 0. 5. `efficient_insert_position([], 5)` should return 0. Implementation Notes 1. Utilize binary search to find the appropriate index for insertion. 2. Ensure that the function handles all edge cases efficiently, including an empty array and target values less than or greater than all elements of the array.","solution":"from typing import List def efficient_insert_position(array: List[int], target: int) -> int: Determines the index at which the target value should be inserted to maintain the sorted order of the array using binary search. left, right = 0, len(array) while left < right: mid = (left + right) // 2 if array[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Binary Heap Application: Medians of Sliding Window Given an array of integers `nums` and an integer `k`, where `k` is the sliding window size, the task is to return the median value in the window as it slides from the beginning to the end of the array. The median is the middle value in an ordered list; if the list is even-sized, the median is the average of the two middle values. # Function Signature ```python def sliding_window_median(nums: List[int], k: int) -> List[float]: pass ``` # Input - `nums`: List of integers (0 <= len(nums) <= 10^5), (−10^4 <= nums[i] <= 10^4). - `k`: Integer (1 <= k <= len(nums)). # Output - Return a list of float, where each float represents the median of the sliding window. # Example ```python nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 # Expected Output: [1, -1, -1, 3, 5, 6] nums = [1, 4, 2, 3] k = 4 # Expected Output: [2.5] ``` # Constraints - Use a binary heap (min-heap or max-heap) to manage the elements within the sliding window efficiently. - Both the initialization and each sliding step should be optimized for performance. # Scenario Imagine you are working as a data analyst, and one of your tasks is to analyze a stream of integer data. You need to quickly determine the median of the data as it comes in chunks of size `k`. This can be particularly useful in finance for detecting trends or anomalies in moving datasets.","solution":"import heapq import bisect from typing import List def sliding_window_median(nums: List[int], k: int) -> List[float]: def median(window): if k % 2 == 0: return (window[k//2 - 1] + window[k//2]) / 2 else: return window[k//2] if not nums or k == 0: return [] medians = [] window = sorted(nums[:k]) for i in range(k, len(nums) + 1): medians.append(median(window)) if i == len(nums): break window.remove(nums[i - k]) bisect.insort(window, nums[i]) return medians"},{"question":"# Context You are tasked with implementing a dynamic algorithm for solving a problem involving matrix operations in a scientific computing application. As part of this, you need to create a function that efficiently computes the n-th power of a matrix by exploiting properties of matrix multiplication and the identity matrix. # Objective Write a function `matrix_exponentiation(matrix: list, exponent: int) -> list` that raises a given square matrix to a specified power efficiently using the method of repeated squaring. # Input and Output Formats * **Input**: * `matrix`: A list of lists representing a square matrix (n x n) where each element is an integer. * `exponent`: An integer representing the power to which the matrix is to be raised. (0 ≤ exponent ≤ 10^9). * **Output**: * A list of lists representing the resulting square matrix of size n x n after raising the input matrix to the given power. # Constraints * The dimension of the matrix (n x n) will be 1 ≤ n ≤ 100. * The matrix elements and exponent will be integers. * Assume that the function has access to utility functions for identity matrix generation and matrix multiplication if needed. # Requirements * The implementation should be optimized for large exponent values. * Ensure your solution can handle edge cases, such as raising the matrix to power 0 (which should return the identity matrix). * Implement the function avoiding unnecessary computations and ensure clear and efficient handling of matrix operations. ```python def matrix_exponentiation(matrix: list, exponent: int) -> list: # Your implementation here pass ``` # Example ```python # Example 1 matrix = [ [2, 0], [0, 2] ] exponent = 3 # Calling matrix_exponentiation(matrix, exponent) should return: # [ # [8, 0], # [0, 8] # ] # Example 2 matrix = [ [1, 2], [3, 4] ] exponent = 2 # Calling matrix_exponentiation(matrix, exponent) should return: # [ # [7, 10], # [15, 22] # ] ``` # Notes * You may use the provided utility functions `multiply` and `identity` for matrix multiplication and identity matrix creation if needed. * Consider handling large exponent values efficiently with minimal multiplications.","solution":"def identity_matrix(size): Creates an identity matrix of given size. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_multiply(A, B): Multiplies two matrices A and B. size = len(A) result = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): result[i][j] = sum(A[i][k] * B[k][j] for k in range(size)) return result def matrix_exponentiation(matrix, exponent): Computes the matrix to the power of the exponent using repeated squaring. size = len(matrix) # Identity matrix result = identity_matrix(size) def power(matrix, exponent): if exponent == 0: return identity_matrix(size) elif exponent == 1: return matrix else: half_power = power(matrix, exponent // 2) half_power = matrix_multiply(half_power, half_power) if exponent % 2: return matrix_multiply(half_power, matrix) else: return half_power return power(matrix, exponent)"},{"question":"# Coding Assessment: 0/1 Knapsack Problem Context You are helping a company optimize the items they can pack into their delivery truck to maximize the value of the items delivered. The truck has a fixed capacity which limits the total weight of items it can carry. Task Implement a function `get_maximum_value(items, capacity)` that calculates the maximum summarized value of the items that can be fit in the delivery truck as described below. Function Signature ```python def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` Input - `items` (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers - the first integer is the value of the item and the second integer is the weight of the item. - `capacity` (int): An integer representing the maximum capacity of the truck. Output - Returns an integer representing the maximum value that the delivery truck can carry. Constraints - All item values and weights are positive integers. - The capacity is a non-negative integer. - The solution needs to handle up to 1000 items and a maximum capacity of 1000. Example ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 assert get_maximum_value(items, capacity) == 80 # (items valued 50 and 30 can both be fit in the truck) ``` Edge Cases 1. If no item is provided, the maximum value is 0. 2. If the truck capacity is zero, the maximum value is 0. 3. Items with weights more than the truck\'s capacity should not be included in the final count.","solution":"from typing import List, Tuple def get_maximum_value(items: List[Tuple[int, int]], capacity: int) -> int: # Initialize a list to store the max value at each weight capacity from 0 to capacity. dp = [0] * (capacity + 1) # Iterate over each item for value, weight in items: # Update the dp array in reverse to avoid overwriting results from the same iteration. for w in range(capacity, weight - 1, -1): dp[w] = max(dp[w], dp[w - weight] + value) return dp[capacity]"},{"question":"# Scenario: Calendar Event Management You are designing a calendar application that allows users to input various time intervals corresponding to events (e.g., meetings, appointments). Each event is defined by its start and end times (in minutes from the start of the day). One of the core functionalities of the application is to check if new events overlap with existing ones and merge overlapping events to avoid conflicts. # Task Implement a function `merge_events(events)` that takes a list of events (intervals) and merges any overlapping events. # Function Signature ```python def merge_events(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` # Input * `events`: A list of tuples where each tuple consists of two integers representing the start and end times of an event. The list may be empty. # Output * A list of tuples where each tuple represents a merged event without overlaps. # Constraints * 0 <= start, end <= 1440 (number of minutes in a day) * Assume end > start for all intervals. * Do not mutate the original list. * Aim to achieve an O(n log n) time complexity. # Example ```python events = [(10, 20), (15, 25), (30, 40)] print(merge_events(events)) # Expected output: [(10, 25), (30, 40)] events = [(10, 20), (25, 35), (40, 50)] print(merge_events(events)) # Expected output: [(10, 20), (25, 35), (40, 50)] ``` # Guidelines 1. Sort the events by their start time. 2. Merge overlapping events. 3. Return the merged list of events.","solution":"from typing import List, Tuple def merge_events(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not events: return [] # Sort events by start time events.sort(key=lambda x: x[0]) merged_events = [events[0]] for current_event in events[1:]: last_merged_event = merged_events[-1] # Check if the current event overlaps with the last merged event if current_event[0] <= last_merged_event[1]: # If they overlap, merge them by updating the end time of the last merged event merged_events[-1] = (last_merged_event[0], max(last_merged_event[1], current_event[1])) else: # If they do not overlap, just add the current event to merged_events merged_events.append(current_event) return merged_events"},{"question":"Context You are working on a historical education software that teaches students about Roman numerals. One of the features required is the ability to convert integer numbers into their Roman numeral equivalents. A Roman numeral is represented by a combination of the following symbols: `I (1), V (5), X (10), L (50), C (100), D (500), M (1000)`. Roman numerals are generally written from largest to smallest from left to right. For example, the numeral for two is written as `II` in Roman numeral, just two one\'s added together. Twelve is written as `XII`, which is simply `X (10)` + `II (2)`. The numeral for twenty-seven is written as `XXVII`, which is `XX (20)` + `V (5)` + `II (2)`. However, the numeral for four is not `IIII`. Instead, the number four is written as `IV`. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as `IX`. Write a function to convert a given integer within the range 1 to 3999 to a Roman numeral. Function Signature ```python def int_to_roman(num: int) -> str: :param num: An integer, guaranteed to be within the range from 1 to 3999. :return: The Roman numeral representation of num as a string. pass ``` Input Format - A single integer `num`, where 1 <= num <= 3999. Output Format - A single string representing the Roman numeral equivalent of the input integer. Constraints - The input will be a valid integer within the specified range. - Only correct Roman numeral representations should be produced. Example ```python assert int_to_roman(1994) == \\"MCMXCIV\\" assert int_to_roman(58) == \\"LVIII\\" assert int_to_roman(9) == \\"IX\\" ``` Ensure that your solution is efficient, understandable, and correctly follows the constraints provided.","solution":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. :param num: An integer within the range from 1 to 3999. :return: The Roman numeral representation of num as a string. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): count = num // val[i] roman_numeral += syms[i] * count num -= val[i] * count return roman_numeral"},{"question":"# Coding Challenge: Base Conversion Verification **Scenario**: You are working on a project that requires converting numbers between different bases frequently. While standard libraries provide some facilities, you need to implement custom solutions to handle specific base ranges and formats, ensuring the integrity of conversion is maintained. To verify your solutions, you will write a function to convert an integer to any base and another function to convert it back to an integer from that base. # Task: Implement two functions: 1. `int_to_base(num: int, base: int) -> str`: Converts an integer to its string representation in a given base. 2. `base_to_int(str_to_convert: str, base: int) -> int`: Converts a string representation of a number in a given base back to a decimal integer. # Input: 1. `int_to_base(num: int, base: int) -> str` - `num` (int): The integer number to be converted. - `base` (int): The base to which the number should be converted. The base must be between 2 and 36. 2. `base_to_int(str_to_convert: str, base: int) -> int` - `str_to_convert` (str): The string representation of the number in the given base. - `base` (int): The base of the number in `str_to_convert`. The base must be between 2 and 36. # Output: 1. `int_to_base(num: int, base: int) -> str` - Return the string representation of the number in the specified base. 2. `base_to_int(str_to_convert: str, base: int) -> int` - Return the decimal integer representation of the number in the given base. # Constraints: - Base range (2 <= base <= 36). - Number range (-2147483648 <= num <= 2147483647). - The input string for `base_to_int` should only contain valid characters for the given base. # Examples: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-10, 16) == \'-A\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'FF\', 16) == 255 assert base_to_int(\'-A\', 16) == -10 ``` # Notes: - You must handle negative numbers correctly. - Ensure that all edge cases are considered, especially when dealing with the minimum and maximum possible values. - Aim for an efficient implementation that minimizes both time and space complexity.","solution":"def int_to_base(num: int, base: int) -> str: if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \\"\\" if num < 0: sign = \\"-\\" num = -num result = \\"\\" while num: result = digits[num % base] + result num //= base return sign + result def base_to_int(str_to_convert: str, base: int) -> int: if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" val = {char: index for index, char in enumerate(digits)} str_to_convert = str_to_convert.upper() negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] result = 0 for char in str_to_convert: if char not in val or val[char] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") result = result * base + val[char] return -result if negative else result"},{"question":"# Problem Objective You are tasked with writing a function that determines the number of valid sentences that can be made from a given string, such that each word in the sentence is contained in a provided dictionary. Each call to the function should compute a fresh count of sentences. # Function Signature ```python def count_sentences(s: str, word_dict: set) -> int: pass ``` # Input 1. `s` (str): A non-empty string composed of lowercase English letters. 2. `word_dict` (set): A set of strings, each string being a valid word. # Output - Returns an integer representing the number of valid sentences that can be formed from the input string. # Constraints - 1 <= len(s) <= 1000 - 1 <= len(word_dict) <= 100 - Each word in `word_dict` has a length of 1 to 10. - The words and input string are composed only of lowercase English letters. # Example Input ```python s = \\"appletablet\\" word_dict = {\\"apple\\", \\"table\\", \\"t\\", \\"applet\\", \\"able\\"} ``` Output ``` 3 ``` # Details Given the input, the valid sentences are: 1. \\"apple\\" + \\"table\\" + \\"t\\" 2. \\"apple\\" + \\"tablet\\" 3. \\"applet\\" In this case, count should return 3. Considerations - Some strings may not be splittable using the given dictionary. - Implement memoization to avoid redundant calculations and improve efficiency. # Implementation Implement the `count_sentences` function which should use a recursive approach with memoization. Each recursive call should store and reuse results to avoid recalculating partitions of the string.","solution":"def count_sentences(s: str, word_dict: set) -> int: memo = {} def dfs(start): if start == len(s): return 1 if start in memo: return memo[start] count = 0 for end in range(start + 1, len(s) + 1): if s[start:end] in word_dict: count += dfs(end) memo[start] = count return count return dfs(0)"},{"question":"You are given a linked list where each node contains an integer value and a reference to the next node. Write a function to detect and return the first node where a cycle begins. If there is no cycle, return `None`. # Function Signature ```python def detectCycle(head: Node) -> Node: :param head: Node object which is the head of the linked list :return: Node object where the cycle begins or None if no cycle ``` # Example Example 1 Input: ``` head = [3,2,0,-4], pos = 1 ``` where `pos` is the index of the node (0-based) that connects to the last node to form a cycle. Output: ``` Node with value 2 ``` Example 2 Input: ``` head = [1,2], pos = 0 ``` Output: ``` Node with value 1 ``` Example 3 Input: ``` head = [1], pos = -1 ``` Output: ``` None ``` # Constraints - The number of nodes in the list is in the range `[0, 10000]`. - `-100000 <= Node.val <= 100000` - `pos` is -1 if there is no cycle in the linked list. # Notes - The function must run in O(n) time and use O(1) extra space. # Implementation Implement the solution using Floyd\'s Cycle-Finding Algorithm (Tortoise and Hare).","solution":"class Node: def __init__(self, val=0, next=None): self.val = val self.next = next def detectCycle(head: Node) -> Node: Detect the start of a cycle in a linked list using Floyd\'s Tortoise and Hare algorithm. :param head: Node object which is the head of the linked list :return: Node object where the cycle begins or None if no cycle if not head or not head.next: return None slow = head fast = head # First step: determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break # If there is no cycle if not fast or not fast.next: return None # Second step: find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Context You are helping a data analyst who frequently needs to compute the sum of all possible k x k sub-regions in a given n x n matrix. To automate this task efficiently, you\'ve been asked to write a function that computes these sums. Your implementation should consider time efficiency and handle edge cases gracefully. Task Write a function `optimized_sum_sub_squares(matrix, k)` in Python that takes a square matrix (2D list) and an integer k, and returns a 2D list containing the sums of all sub-squares of size k x k. Input - `matrix`: A list of lists (2D list) representing a square matrix of size `n x n` where 1 <= n <= 1000. - `k`: An integer representing the size of the sub-square, where 1 <= k <= n. Output - A 2D list (containing integers) representing the sum of each sub-square of size `k x k`. Constraints - If k > n, return an empty list since it is impossible to have any k x k sub-square in such a case. Performance Requirements - Optimize the approach to minimize time complexity wherever possible. Scenario You are required to handle cases where `k` might be equal to `n`, increasing the complexity due to larger sub-regions. Think about how you can reduce redundant calculations by leveraging optimized techniques. Example ```python # Example matrix matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] k = 2 # Expected Output [ [14, 22, 30], [46, 54, 62], [78, 86, 94] ] # Explaination # The sums of 2x2 sub-squares are calculated and stored in the resulting matrix. ``` Write your function `optimized_sum_sub_squares` below. ```python def optimized_sum_sub_squares(matrix, k): # Your implementation here ```","solution":"def optimized_sum_sub_squares(matrix, k): n = len(matrix) if k > n: return [] # Auxiliary matrix to store the sum of sub-matrixes aux = [[0] * (n + 1) for _ in range(n + 1)] # Building the auxiliary sum matrix for i in range(1, n + 1): for j in range(1, n + 1): aux[i][j] = (matrix[i - 1][j - 1] + aux[i - 1][j] + aux[i][j - 1] - aux[i - 1][j - 1]) # Now calculate the sum of kxk sub-square using the auxiliary matrix result = [] for i in range(k, n + 1): row_result = [] for j in range(k, n + 1): total_sum = (aux[i][j] - aux[i - k][j] - aux[i][j - k] + aux[i - k][j - k]) row_result.append(total_sum) result.append(row_result) return result"},{"question":"# Prime Check Function **Objective**: Write a function `is_probable_prime(n: int, k: int) -> bool` to determine if a number is probably prime using the Miller-Rabin primality test. **Function Signature**: ```python def is_probable_prime(n: int, k: int) -> bool: ``` **Input**: - `n` (int): An integer number to check for primality. - `k` (int): The number of iterations to perform, higher value results in more accuracy (recommend k >= 5). **Output**: - (bool): Return True if `n` is probably a prime number, otherwise False. **Constraints**: - `1 <= n <= 10^18` - `1 <= k <= 100` **Performance Requirements**: - The function should execute efficiently for large values up to (10^{18}). **Scenario**: You are developing a cryptographic application that requires checking the primality of large numbers efficiently. Implement a probabilistic algorithm (the Miller-Rabin primality test) that works well for large integers and can provide a high degree of confidence with multiple iterations. **Miller-Rabin Test Summary**: 1. **Handle small or trivial cases** directly (e.g. n <= 3). 2. **Write n-1 as (2^s times d)** (where `d` is odd). 3. **Witness loop**: Repeat `k` times: - Randomly pick a base `a` in the range [2, n-2]. - Calculate remainders (using modular exponentiation). - Check composite conditions. 4. **Return result**: If all iterations passed, return True (probably prime), else return False (composite). **Reference**: The Miller-Rabin test provides a probabilistic method to efficiently gauge the primality of a number. ```python # You may use random module, directly available in Python: # import random def is_probable_prime(n: int, k: int) -> bool: # Implement the Miller-Rabin test here pass ```","solution":"import random def is_probable_prime(n: int, k: int) -> bool: Determines if a number n is probably a prime using the Miller-Rabin primality test. :param n: The number to check for primality. :param k: The number of iterations for accuracy. :return: True if n is probably prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0: return False # Write (n - 1) as 2^s * d s = 0 d = n - 1 while d % 2 == 0: d //= 2 s += 1 def miller_test(a: int, d: int, n: int, s: int) -> bool: Performs the Miller test for a given base a. :param a: The base to test with. :param d: Odd component of n-1. :param n: The number to test. :param s: The exponent of 2 in the decomposition of n-1. :return: False if composite, True if probably prime. x = pow(a, d, n) if x == 1 or x == n - 1: return True for _ in range(s - 1): x = pow(x, 2, n) if x == n - 1: return True return False for _ in range(k): a = random.randint(2, n - 2) if not miller_test(a, d, n, s): return False return True"},{"question":"# Question: Optimized Cocktail Shaker Sort You are given an array of integers that you need to sort using an optimized version of the Cocktail Shaker Sort algorithm. **Function Signature**: ```python def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: ``` **Input**: * An array of integers, `arr` with length ( N ) where ( 1 leq N leq 10^6 ). **Output**: * A sorted array of integers. **Constraints**: * Your function should have a time complexity of ( O(N log N) ) in the average case. * Your function should handle edge cases such as empty lists, single-element lists, and already sorted lists efficiently. **Performance Requirement**: * Your solution should be capable of handling arrays with up to ( 10^6 ) elements within acceptable time limits. **Scenario**: You are sorting a list of prices from a database of electronic products. The list should be ordered to facilitate further data analysis on pricing trends. Ensure your implementation is as efficient as possible, particularly given the large size of the dataset.","solution":"from typing import List def optimized_cocktail_shaker_sort(arr: List[int]) -> List[int]: Sorts the given array using an optimized sorting algorithm. return sorted(arr)"},{"question":"Context You are tasked with developing a utility for converting numbers between different numeral base systems, specifically bases ranging from 2 (binary) to 36 (hexatrigesimal). This utility is essential for several computing applications, such as data validation cross-references in cryptography and custom positional numeral systems in digital computing environments. Problem Statement You need to implement two functions, `int_to_base(num, base)` and `base_to_int(str_to_convert, base)`, that complete the integer-to-base conversion and base-to-integer conversion, respectively. Function Details 1. **int_to_base(num, base)** * **Input**: * `num` (integer): the number to be converted. * `base` (integer): the base to which `num` will be converted. * **Output**: * (string): the base representation of `num`. * **Constraints**: * The `base` parameter will be between 2 and 36, inclusive. * For negative numbers, the base representation should represent the negative value accurately. * **Example**: - `int_to_base(5, 2)` should return `\'101\'`. - `int_to_base(-10, 16)` should return `\'-A\'`. 2. **base_to_int(str_to_convert, base)** * **Input**: * `str_to_convert` (string): the base representation of a number. * `base` (integer): the base in which `str_to_convert` is given. * **Output**: * (integer): the decimal (base 10) integer equivalent of `str_to_convert`. * **Constraints**: * Input string `str_to_convert` includes only valid characters for bases up to 36. * **Example**: - `base_to_int(\'101\', 2)` should return `5`. - `base_to_int(\'-A\', 16)` should return `-10`. Additional Notes * You may assume that the input values are always valid according to the constraints. * Performance and efficiency are key, especially considering potentially large integer values. * Focus on clear and correct handling of edge cases like zero and negative numbers.","solution":"def int_to_base(num, base): Convert an integer to a string in the specified base. Parameters: - num: an integer number to be converted. - base: the base to convert the number to, ranging from 2 to 36. Returns: - A string representing the number in the specified base. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(result[::-1]) def base_to_int(str_to_convert, base): Convert a string in a specified base to an integer. Parameters: - str_to_convert: a string representing the number in the given base. - base: the base of the provided number string, ranging from 2 to 36. Returns: - An integer that is the base 10 equivalent of the provided string. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36, inclusive.\\") str_to_convert = str_to_convert.strip().upper() if str_to_convert == \'\': raise ValueError(\\"Input string must not be empty.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] value = 0 for char in str_to_convert: if char not in digits[:base]: raise ValueError(f\\"Invalid character {char} for base {base}\\") value = value * base + digits.index(char) if negative: value = -value return value"},{"question":"# Programming Assessment Problem Statement You are given the basic node structure for a singly linked list and a doubly linked list. Implement a **Doubly Linked List** with the following functionality: 1. Add a new node with a given value at the beginning of the list. 2. Add a new node with a given value at the end of the list. 3. Remove the node from the beginning of the list. 4. Remove the node from the end of the list. 5. Search for an element by its value and return its position (0-indexed) or -1 if the value is not found. Input and Output Formats - **Input**: - For insertion methods: `add_to_start(value)` and `add_to_end(value)`, where `value` is an integer. - For removal methods: `remove_from_start()` or `remove_from_end()`, both of which do not require arguments. - For search method: `search(value)` where `value` is an integer. - **Output**: - For insertion and removal methods, output is not required. - For search method, return the 0-based position of the value or -1 if the value is not found. Constraints - Values inserted will be integers. - You may assume that remove methods will not be called on an empty list. # Sample Usage ```python dll = DoublyLinkedList() dll.add_to_start(10) # List: 10 dll.add_to_end(20) # List: 10 <-> 20 dll.add_to_start(5) # List: 5 <-> 10 <-> 20 assert dll.search(10) == 1 assert dll.search(20) == 2 assert dll.search(15) == -1 dll.remove_from_start() # List: 10 <-> 20 dll.remove_from_end() # List: 10 assert dll.search(10) == 0 assert dll.search(20) == -1 ``` # Task Implement the `DoublyLinkedList` class with the specified methods. ```python class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_to_start(self, value): # Your code here def add_to_end(self, value): # Your code here def remove_from_start(self): # Your code here def remove_from_end(self): # Your code here def search(self, value): # Your code here ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_to_start(self, value): new_node = Node(value) if self.head is None: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def add_to_end(self, value): new_node = Node(value) if self.tail is None: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def remove_from_start(self): if self.head is None: return if self.head == self.tail: self.head = self.tail = None else: self.head = self.head.next self.head.prev = None def remove_from_end(self): if self.tail is None: return if self.tail == self.head: self.tail = self.head = None else: self.tail = self.tail.prev self.tail.next = None def search(self, value): current = self.head position = 0 while current: if current.value == value: return position current = current.next position += 1 return -1"},{"question":"**Objective**: Implement a function to validate a binary tree for two properties: it needs to be a valid Binary Search Tree (BST) and it has to be height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than 1. Function Signature and Input: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_BST_and_balanced(root: TreeNode) -> bool: :type root: TreeNode :rtype: bool ``` Input: * `root`: the root node of the binary tree of type `TreeNode`. Output: * Returns `True` if the binary tree is both a valid BST and height-balanced, otherwise `False`. Constraints: * The number of nodes in the tree is in the range `[0, 10^4]`. * `-10^5 <= Node.val <= 10^5` Performance Requirements: * Ensure that the time complexity is O(N) where N is the number of nodes in the tree. * Aim for an optimal space complexity, leveraging recursion efficiently. Edge Cases: * Empty tree (should return `True`). * Single node tree (should return `True`). * Edge cases where the tree is almost fully skewed to the left or right. * Edge cases where the node values do not follow the BST properties strictly. Examples: 1. Example 1: ```python tree = TreeNode(2) tree.left = TreeNode(1) tree.right = TreeNode(3) print(is_valid_BST_and_balanced(tree)) # True ``` 2. Example 2: ```python tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) print(is_valid_BST_and_balanced(tree)) # False ``` **Context**: This problem will test the students\' understanding of both BST properties and balanced tree concepts. They need to implement an efficient solution that combines both validations in a single traversal to meet the performance constraints.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_valid_BST_and_balanced(root: TreeNode) -> bool: def helper(node): # Base case: An empty node/subtree is BST and is balanced with height -1 if not node: return True, -1, float(\'-inf\'), float(\'inf\') # Recursively validate the left and right subtrees left_is_bst, left_height, left_max, left_min = helper(node.left) right_is_bst, right_height, right_max, right_min = helper(node.right) # Check BST property if not left_is_bst or not right_is_bst or left_max >= node.val or node.val >= right_min: return False, 0, 0, 0 # Check balanced property if abs(left_height - right_height) > 1: return False, 0, 0, 0 # Current node is a valid BST and balanced curr_height = max(left_height, right_height) + 1 curr_max = max(node.val, right_max) curr_min = min(node.val, left_min) return True, curr_height, curr_max, curr_min is_bst_and_balanced, _, _, _ = helper(root) return is_bst_and_balanced"},{"question":"You are given a singly linked list and you need to remove all duplicate elements from it. You have to implement the function: `remove_dups(head)`. # Function Signature ```python def remove_dups(head: Node) -> None: Removes duplicate elements from the linked list. Parameters: head (Node): The head of the singly linked list Returns: None ``` # Input * `head`: A reference to the head node of a singly linked list where each node contains a non-null value of string type. # Output * The function should modify the linked list in place and not return anything. After execution, the linked list should only contain unique elements. # Constraints * The linked list can contain a maximum of 10^5 nodes. * All node values are strings, each with a length of at most 100 characters. # Performance Requirements * The solution should efficiently handle large lists within time and space constraints. # Example ```python # Constructing the linked list: A -> A -> B -> C -> D -> C -> F -> G a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) print_linked_list(a1) # Output should be: A -> B -> C -> D -> F -> G ``` # Additional Notes: * Implement the provided `Node` class for defining the linked list structure. * Implement the `print_linked_list(head)` function to help verify the result.","solution":"class Node: def __init__(self, value: str): self.value = value self.next = None def remove_dups(head: Node) -> None: if not head: return seen = set() current = head seen.add(current.value) while current.next: if current.next.value in seen: current.next = current.next.next else: seen.add(current.next.value) current = current.next def print_linked_list(head: Node) -> None: current = head while current: print(current.value, end=\\" -> \\" if current.next else \\"n\\") current = current.next # Debugging function added here (not required by the original task) def from_list(vals): Helper function to create a linked list from a Python list. if not vals: return None head = Node(vals[0]) current = head for val in vals[1:]: current.next = Node(val) current = current.next return head"},{"question":"Scenario You are working on a software system that processes large text datasets. One of the functionalities required is to reverse the strings of text data efficiently and effectively. You are tasked with implementing this functionality while considering various edge cases and performance constraints. Problem Statement Implement a function `reverse_string(s: str) -> str` that takes a string `s` and returns the string reversed. Ensure that your solution is efficient both in terms of time and space complexity. Input Format * A string `s` where `1 <= len(s) <= 10^6`. Output Format * A string which is the reverse of the input string `s`. Constraints * You must handle edge cases such as empty strings and single-character strings. * Aim to implement a solution that is both time and space efficient. * Avoid using excessive additional data structures to save memory (e.g., avoid deep recursion if possible). Example Test Cases 1. **Input**: `\\"hello\\"` **Output**: `\\"olleh\\"` 2. **Input**: `\\"\\"` **Output**: `\\"\\"` 3. **Input**: `\\"a\\"` **Output**: `\\"a\\"` 4. **Input**: `\\"OpenAI\\"` **Output**: `\\"IAnepO\\"` 5. **Input**: `\\"racecar\\"` **Output**: `\\"racecar\\"` # Requirements * Implement the function in a way that handles large strings efficiently. * Write additional test cases to validate edge cases and performance with maximum possible input size. ```python def reverse_string(s: str) -> str: # Your implementation here ```","solution":"def reverse_string(s: str) -> str: Returns the reversed string of the input string s. return s[::-1]"},{"question":"# Question: Matrix Key Search You are given a matrix of integers `mat` of size `m x n` where each row and column is sorted in non-decreasing order. Write a function `search_in_sorted_matrix` that returns the row and column indices of a given key if the key is present in the matrix, otherwise returns `None`. Your solution should aim for O(m + n) time complexity where m is the number of rows and n is the number of columns. Input: 1. `mat`: A list of lists of integers representing the `m x n` matrix. 2. `key`: An integer you want to search within the matrix. Output: - If the key is found, return a tuple `(row_index, col_index)` corresponding to the 1-based index position of the key within the matrix. - If the key is not found, return `None`. Example: ```python def main(): matrix = [ [1, 3, 5, 7], [2, 4, 6, 8], [3, 6, 9, 12], [4, 8, 12, 16] ] key = 6 result = search_in_sorted_matrix(matrix, key) print(result) # Output should be: (2, 3) if __name__ == \\"__main__\\": main() ``` Constraints: - 1 <= m, n <= 1000 - -10^4 <= mat[i][j], key <= 10^4 - You can assume the matrix is non-empty and properly sorted. Implement the function `search_in_sorted_matrix(mat, key)`.","solution":"def search_in_sorted_matrix(mat, key): Search for a key in a sorted matrix and return its position. Parameters: - mat: List[List[int]] - The sorted matrix. - key: int - The key to search for. Returns: - Tuple[int, int] - The 1-based index position of the key or None if not found. if not mat or not mat[0]: return None rows, cols = len(mat), len(mat[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if mat[row][col] == key: return (row + 1, col + 1) elif mat[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Cocktail Shaker Sort Implementation **Scenario**: You are working on a simple software project management tool that requires efficient data processing of small datasets. One operation involves sorting tasks based on their priority levels. Although the data sets are small, they may be nearly sorted, hence an optimized approach for these cases is beneficial. **Problem Statement**: Implement a function `cocktail_shaker_sort(tasks)` to sort an array of task priority levels using the Cocktail Shaker Sort algorithm. # Function Signature ```python def cocktail_shaker_sort(tasks: List[int]) -> List[int]: Sorts the tasks in ascending order based on priority levels using the Cocktail Shaker Sort algorithm. Args: tasks (List[int]): A list of integers representing priority levels of tasks. Returns: List[int]: The sorted list of task priority levels. ``` # Input: - `tasks`: A list of integers representing the priority levels of tasks. (0 <= len(tasks) <= 10^4, -10^5 <= tasks[i] <= 10^5) # Output: - Return a sorted list of integers in non-decreasing order. # Constraints: - The list may be empty. - The function should run within acceptable time limits given the constraints. - No additional storage other than the input list should be used for sorting. # Example: ```python tasks = [4, 3, 2, 1, 5] print(cocktail_shaker_sort(tasks)) # Output: [1, 2, 3, 4, 5] tasks = [1, 2, 3, 4, 5] print(cocktail_shaker_sort(tasks)) # Output: [1, 2, 3, 4, 5] ```","solution":"def cocktail_shaker_sort(tasks): Sorts the tasks in ascending order based on priority levels using the Cocktail Shaker Sort algorithm. Args: tasks (List[int]): A list of integers representing priority levels of tasks. Returns: List[int]: The sorted list of task priority levels. n = len(tasks) if n == 0: return tasks swapped = True start = 0 end = n - 1 while swapped: swapped = False for i in range(start, end): if tasks[i] > tasks[i + 1]: tasks[i], tasks[i + 1] = tasks[i + 1], tasks[i] swapped = True if not swapped: break swapped = False end -= 1 for i in range(end, start, -1): if tasks[i] < tasks[i - 1]: tasks[i], tasks[i - 1] = tasks[i - 1], tasks[i] swapped = True start += 1 return tasks"},{"question":"# Base Conversion Algorithm Implementation Objective Implement functions to convert integers between different numeral systems. This task assesses your understanding of algorithms and their application in base conversions. Ensure robust handling of edge cases, efficiency, and correctness. Task 1. **Function**: `int_to_base(num, base)` * **Input**: - `num`: an integer number to be converted (could be negative). - `base`: the base to convert the number to (2 ≤ base ≤ 36). * **Output**: a string representing the converted number in the specified base. 2. **Function**: `base_to_int(str_to_convert, base)` * **Input**: - `str_to_convert`: a string representing a number in the specified base. - `base`: the base of the number given as a string (2 ≤ base ≤ 36). * **Output**: the decimal integer result of converting the string to base 10. Constraints - The input integer range is from `-10^6` to `10^6`. - The given base will always be in the range `2` ≤ `base` ≤ `36`. - The string input for the `base_to_int` function will always be correctly formatted for the given base. Detailed Example 1. Example 1: - Input: `int_to_base(5, 2)` - Output: `\'101\'` 2. Example 2: - Input: `base_to_int(\'F\', 16)` - Output: `15` 3. Example 3: - Input: `int_to_base(-31, 16)` - Output: `\'-1F\'` 4. Example 4: - Input: `base_to_int(\'-1F\', 16)` - Output: `-31` Implementation Notes - For `int_to_base`, handle negative numbers by appending a `-` sign to the beginning of the result string. - For `base_to_int`, manage the negative sign properly in the string representation of the number. - Consider edge cases like zero and the smallest possible integer. Implement the functions in Python: ```python import string def int_to_base(num, base): # Your implementation def base_to_int(str_to_convert, base): # Your implementation ``` Remember to test your code against various test cases for correctness and efficiency.","solution":"import string def int_to_base(num, base): Converts an integer `num` to a string in the specified `base`. if num == 0: return \'0\' if num < 0: return \'-\' + int_to_base(-num, base) digits = string.digits + string.ascii_uppercase result = \'\' while num > 0: result = digits[num % base] + result num //= base return result def base_to_int(str_to_convert, base): Converts a string `str_to_convert` in the specified `base` to an integer. if str_to_convert[0] == \'-\': return -base_to_int(str_to_convert[1:], base) digits = string.digits + string.ascii_uppercase value = 0 for char in str_to_convert: value = value * base + digits.index(char) return value"},{"question":"# Question: Merge K Sorted Linked Lists You are given an array of `k` sorted linked lists. Each of these linked lists is in non-decreasing order. Your task is to merge all these linked lists into one sorted linked list and return its head. Implement `merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]` that takes in a list of `k` sorted linked lists and merges them into one sorted linked list. # Input: - `lists`: A list containing the heads of `k` sorted linked lists. Each linked list may have between `0` and `5000` nodes. # Output: - A single linked list that merges all the input linked lists in non-decreasing order. # Constraints: - The total number of nodes across all input linked lists will not exceed `50000`. # Example: Example 1: ```plaintext Input: lists = [[1, 4, 5], [1, 3, 4], [2, 6]] Output: [1, 1, 2, 3, 4, 4, 5, 6] ``` - Explanation: The lists are [1->4->5, 1->3->4, 2->6]. The merged list is 1->1->2->3->4->4->5->6. Example 2: ```plaintext Input: lists = [] Output: [] ``` - Explanation: The input list is empty. Example 3: ```plaintext Input: lists = [[]] Output: [] ``` - Explanation: The input list contains one empty linked list. # Note - The above code snippets use heap-based and priority queue-based approaches to merge k sorted linked lists, achieving a time complexity of O(N log k). Implement an efficient solution considering optimal time and space complexity.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None min_heap = [] # Initialize the heap for i, head in enumerate(lists): if head: heapq.heappush(min_heap, (head.val, i, head)) dummy = ListNode() current = dummy while min_heap: val, idx, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, idx, node.next)) return dummy.next"},{"question":"You are required to implement a Binary Search Tree (BST) and provide functionalities for insertion, deletion, and search operations. The tree should remain balanced to ensure efficient operations. You must handle both the average and edge cases effectively. # Function Signatures ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: # Implement this function to insert a value into the BST def delete(self, val: int) -> None: # Implement this function to delete a value from the BST def search(self, val: int) -> bool: # Implement this function to search for a value in the BST ``` # Input and Output Formats * **insert(val: int) -> None**: Insert `val` into the BST. If the value already exists, it should not be inserted again. * **delete(val: int) -> None**: Delete `val` from the BST. If the value does not exist, do nothing. * **search(val: int) -> bool**: Return `True` if `val` exists in the BST, otherwise `False`. # Constraints * Values for all functions will be integers. * Assume no duplicate values will need to be handled explicitly for insertion. * The BST can hold values within the range of `-10^6` to `10^6`. # Examples ```python # Example usage: bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) print(bst.search(3)) # Output: True print(bst.search(10)) # Output: False bst.delete(3) print(bst.search(3)) # Output: False # Example operations will collectively test the efficiency and correct handling of edge conditions within the provided constraints. ``` # Performance Requirements Your implementation should aim to maintain the balance of the tree to ensure that: * Insertion, search, and deletion operations have an average-case time complexity of O(log n).","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, val: int) -> None: self.root = self._insert(self.root, val) def _insert(self, root: TreeNode, val: int) -> TreeNode: if not root: return TreeNode(val) elif val < root.val: root.left = self._insert(root.left, val) elif val > root.val: root.right = self._insert(root.right, val) return root def delete(self, val: int) -> None: self.root = self._delete(self.root, val) def _delete(self, root: TreeNode, val: int) -> TreeNode: if not root: return root if val < root.val: root.left = self._delete(root.left, val) elif val > root.val: root.right = self._delete(root.right, val) else: if not root.left: return root.right elif not root.right: return root.left temp_val = self._minValueNode(root.right).val root.val = temp_val root.right = self._delete(root.right, temp_val) return root def _minValueNode(self, node: TreeNode) -> TreeNode: current = node while current.left: current = current.left return current def search(self, val: int) -> bool: return self._search(self.root, val) def _search(self, root: TreeNode, val: int) -> bool: if not root: return False if val == root.val: return True elif val < root.val: return self._search(root.left, val) else: return self._search(root.right, val)"},{"question":"# Problem Description **Context**: You are designing software for a city visualization project. One of the key features is to dynamically generate the skyline based on the building information provided. The skyline is the outer contour of the city when viewed from a distance. **Task**: Write a Python function, `build_skyline(buildings)`, that takes a list of buildings as input and produces the city\'s skyline as a list of key points. # Function Signature ```python def build_skyline(buildings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: pass ``` # Input - A list of N buildings represented as tuples `(Li, Ri, Hi)`, where: - `Li`: left x-coordinate of the ith building. - `Ri`: right x-coordinate of the ith building. - `Hi`: height of the ith building. - Constraints: - `0 ≤ Li, Ri ≤ 10^7`. - `0 < Hi ≤ 10^7`. - `Ri > Li`. - `1 ≤ N ≤ 10^4`. # Output - A list of key points which uniquely defines the skyline. Each key point is a tuple `(xi, yi)`, where: - `xi`: x-coordinate of the key point. - `yi`: height of the skyline at that x-coordinate. - The list must be sorted by the x-coordinate. - Ensure no consecutive points have the same height. # Example Input ```python buildings = [(2, 9, 10), (3, 7, 15), (5, 12, 12), (15, 20, 10), (19, 24, 8)] ``` Output ```python [(2, 10), (3, 15), (7, 12), (12, 0), (15, 10), (20, 8), (24, 0)] ``` # Notes - There will be no overlaps or gaps between buildings; all buildings will touch each other or overlap. - The last key point will always have a height of 0, marking the termination of the skyline. - Consecutive horizontal lines of equal height must be merged into one continuous line in the output.","solution":"from typing import List, Tuple import heapq def build_skyline(buildings: List[Tuple[int, int, int]]) -> List[Tuple[int, int]]: # Create an event queue with start and end points events = [] for (left, right, height) in buildings: events.append((left, -height, right)) # Building starts events.append((right, 0, 0)) # Building ends # Sort the events by x axis, then by height events.sort(key = lambda x: (x[0], x[1])) result = [] max_heap = [(0, float(\'inf\'))] # (height, end_position) prev_height = 0 for x, neg_height, end in events: if neg_height: # If it\'s not zero, it means it\'s a start event heapq.heappush(max_heap, (neg_height, end)) else: # Else it\'s an end event max_heap = [(h, e) for h, e in max_heap if e != x] heapq.heapify(max_heap) # Take the height of the tallest building that is currently active curr_height = -max_heap[0][0] if curr_height != prev_height: result.append((x, curr_height)) prev_height = curr_height return result"},{"question":"Optimal Sales Strategy A steel business wants to maximize its revenue by selling rods that can be cut into different lengths. You are tasked with developing a function that determines the maximum revenue obtainable for a rod of length `n` when given a list where the `i-th` element represents the price of a rod piece of length `i+1`. Function Signature ```python def maximize_revenue(prices: List[int]) -> int: pass ``` # Input - `prices`: A list of integers where `prices[i]` represents the price of a rod piece of length `i+1`. # Output - Returns an integer representing the maximum obtainable revenue for a rod of length `n` where `n` is the length of the `prices` list. # Constraints - 0 <= n <= 1000 (Where `n` is the length of `prices` list) - 1 <= prices[i] <= 10^4 # Example ```python # Example 1 prices = [1, 5, 8, 9, 10, 17, 17, 20] print(maximize_revenue(prices)) # Output: 22 ``` Explanation - For the prices list `[1, 5, 8, 9, 10, 17, 17, 20]`, the maximum obtainable value is obtained by cutting the rod into pieces of lengths [2, 6] which add up to 22 (5+17). # Comprehensive Requirements - Consider all possible ways to cut the rod into smaller lengths and calculate the associated total revenue. - Use dynamic programming to avoid redundant calculations and improve efficiency. - Ensure the solution efficiently handles the upper constraint limits.","solution":"from typing import List def maximize_revenue(prices: List[int]) -> int: n = len(prices) if n == 0: return 0 # Create a dp array for storing maximum revenue for each length dp = [0] * (n + 1) # Iterate over each possible rod length for i in range(1, n + 1): max_revenue = 0 # Find the best revenue by trying all different cuts for j in range(i): max_revenue = max(max_revenue, prices[j] + dp[i - j - 1]) dp[i] = max_revenue return dp[n]"},{"question":"<|Analysis Begin|> # Algorithm Analysis Core Identification * **Algorithm/Data Structure**: Pattern matching using backtracking. * **Complexity**: The time complexity is O(n^m) where n is the length of the string and m is the length of the pattern; because for every character in the pattern, there could be n possible choices during the first iteration of backtracking. * **Principles**: The algorithm attempts to map each character in the pattern to a substring in the string recursively. It ensures a bijection (one-to-one and onto mapping) between the characters of the pattern and parts of the string. Characteristics & Applications * **Properties**: The critical property required is that there must be a one-to-one correspondence between the characters in the pattern and the non-empty substrings in the string. * **Common Use Cases**: Suitable for scenarios where pattern matching is required with constraints on the mapping, like in certain parsing tasks, advanced search functionalities, or certain types of encodings/decodings. * **Strengths/Limitations**: * **Strengths**: * Can handle arbitrary mappings as long as they maintain the bijection. * Flexible and can address various pattern matching problems with the right modifications. * **Limitations**: * Can become highly inefficient for longer inputs due to its exponential time complexity. * Recursive overhead can be substantial, leading to stack overflow for very large inputs. Implementation Challenges * **Edge Cases**: * Patterns longer than the string. * Repeating patterns within the string not matching expected bijection. * Empty pattern or empty string to start with. * **Performance Bottlenecks**: * Extensive recursion leading to large call stack. * Excessive backtracking due to multiple choice paths. * **Error Scenarios**: Errors might arise if bijection constraints are violated during recursion, leading to incorrect results. * **Optimization Points**: * Memoization to avoid redundant calculations. * Pruning the search space by early termination rules. * Iterative approaches or alternative dynamic programming solutions might optimize performance. <|Analysis End|> <|Question Begin|> # Problem: Pattern Matching with Bijection In this problem, you will implement a function to determine if a given pattern matches a string such that there is a bijection (one-to-one correspondence) between characters in the pattern and non-empty substrings in the string. # Function Signature ```python def pattern_match(pattern: str, string: str) -> bool: pass ``` # Input * `pattern`: A string consisting of lowercase English letters. * `string`: A string consisting of lowercase English letters. # Output * Return `True` if the pattern matches the string with a bijection, otherwise return `False`. # Constraints * 1 <= len(pattern), len(string) <= 20 # Examples 1. `pattern = \\"abab\\"`, `string = \\"redblueredblue\\"` - Output: `True`, because \'a\' can be mapped to \\"red\\" and \'b\' can be mapped to \\"blue\\". 2. `pattern = \\"aaaa\\"`, `string = \\"asdasdasdasd\\"` - Output: `True`, because \'a\' can be mapped to \\"asd\\". 3. `pattern = \\"aabb\\"`, `string = \\"xyzabcxzyabc\\"` - Output: `False`, because no consistent mapping exists. # Hints * Use a dictionary to keep track of the mappings between the pattern characters and the substrings of the string. * Recursively try to build these mappings and backtrack if a valid bijection is not possible. # Implementation Given the constraints, it is recommended to use a backtracking approach to explore all potential bijections between the pattern and the string. Implement the function below: ```python def pattern_match(pattern, string): :type pattern: str :type string: str :rtype: bool def backtrack(pattern, string, dic): if len(pattern) == 0 and len(string) > 0: return False if len(pattern) == len(string) == 0: return True for end in range(1, len(string)-len(pattern)+2): if pattern[0] not in dic and string[:end] not in dic.values(): dic[pattern[0]] = string[:end] if backtrack(pattern[1:], string[end:], dic): return True del dic[pattern[0]] elif pattern[0] in dic and dic[pattern[0]] == string[:end]: if backtrack(pattern[1:], string[end:], dic): return True return False return backtrack(pattern, string, {}) ``` Good luck!","solution":"def pattern_match(pattern, string): Determines if a given pattern matches a string with a bijection. :type pattern: str :type string: str :rtype: bool def backtrack(pattern, string, mapping, used): if not pattern: return not string char = pattern[0] if char in mapping: word = mapping[char] if not string.startswith(word): return False return backtrack(pattern[1:], string[len(word):], mapping, used) for end in range(1, len(string) - len(pattern) + 2): word = string[:end] if word in used: continue mapping[char] = word used.add(word) if backtrack(pattern[1:], string[end:], mapping, used): return True del mapping[char] used.remove(word) return False return backtrack(pattern, string, {}, set())"},{"question":"# Scenario You are a software developer tasked to assist with the implementation of a plagiarism detection tool. Your job is to locate the first occurrence of a specific term within large pieces of text efficiently. To achieve this, you decide to use the Rabin-Karp algorithm, an efficient string searching algorithm using hashing methods. # Challenging Task Implement the `rabin_karp` function using the Rabin-Karp algorithm in Python. You are given `text` from which you want to find the first occurrence of the `word`. # Function Signature ```python def rabin_karp(word: str, text: str) -> int: ``` # Input * `word` (str): The substring to be searched within `text`. * `text` (str): The text in which to search for `word`. # Output * Returns an integer representing the starting index of the first occurrence of `word` in `text`. If the word is not present, return `-1`. # Constraints * `1 <= len(word) <= 1000` * `1 <= len(text) <= 10^6` * All characters in `word` and `text` are lowercase English letters. # Performance Requirement * Aim to achieve a time complexity that is linear on average (O(n)).","solution":"def rabin_karp(word: str, text: str) -> int: Implements the Rabin-Karp algorithm to find the starting index of the first occurrence of the \'word\' in the \'text\'. If the word is not found, returns -1. len_word = len(word) len_text = len(text) if len_word > len_text: return -1 base = 256 mod = 10**9 + 7 def hash_val(s, length): h = 0 for i in range(length): h = (h * base + ord(s[i])) % mod return h hash_word = hash_val(word, len_word) hash_text = hash_val(text, len_word) if hash_word == hash_text: if text[:len_word] == word: return 0 base_pow_len = pow(base, len_word - 1, mod) for i in range(1, len_text - len_word + 1): hash_text = (hash_text - ord(text[i - 1]) * base_pow_len) % mod hash_text = (hash_text * base + ord(text[i + len_word - 1])) % mod if hash_text == hash_word: if text[i:i + len_word] == word: return i return -1"},{"question":"# Context You are developing a utility library for numeric operations, and one of the functions you need to implement is one that returns the number of digits in an integer. This function will be used in multiple settings including logging, validation, and generating keys for database entries. The implementation should be highly efficient to handle frequent calls. # Task Write a function `num_digits(n)` that returns the number of digits in the given integer `n`. The function should have: 1. Constant time complexity (O(1)). 2. Handle both positive and negative integers. 3. Correctly count the number of digits in the number zero. # Function Signature ```python def num_digits(n: int) -> int: pass ``` # Input * `n`: An integer (from -10<sup>18</sup> to 10<sup>18</sup>). # Output * An integer representing the number of digits in the number `n`. # Example ```python assert num_digits(12345) == 5 assert num_digits(-12345) == 5 assert num_digits(0) == 1 assert num_digits(9876543210) == 10 ``` # Constraints * The input number `n` can range from -10<sup>18</sup> to 10<sup>18</sup>, inclusive. * You are not allowed to use string conversion to derive the number of digits. # Notes Ensure that the function is optimized to handle frequent calls effectively while maintaining constant time complexity.","solution":"def num_digits(n: int) -> int: Returns the number of digits in the given integer `n`, handling both positive and negative integers, including zero. if n == 0: return 1 n = abs(n) return len(str(n))"},{"question":"Create a function that counts the number of \'1\' bits (also known as the Hamming weight) in the binary representation of an unsigned 32-bit integer. You need to implement this function using Brian Kernighan\'s Algorithm in both iterative and recursive approaches. Your function should handle typical scenarios and edge cases efficiently. # Function Signature ```python def hamming_weight_recursive(n: int) -> int: pass def hamming_weight_iterative(n: int) -> int: pass ``` # Input - An unsigned 32-bit integer `n` (0 <= n <= 2^32 - 1). # Output - An integer representing the number of \'1\' bits in the binary representation of `n`. # Constraints - You must use Brian Kernighan\'s Algorithm. - The input will always be within the range of a 32-bit unsigned integer. # Example ```python assert hamming_weight_recursive(11) == 3 assert hamming_weight_iterative(11) == 3 assert hamming_weight_recursive(128) == 1 # 128 in binary is 10000000 assert hamming_weight_iterative(128) == 1 assert hamming_weight_recursive(4294967295) == 32 # all bits set to 1 assert hamming_weight_iterative(4294967295) == 32 ``` # Guidance 1. Implement both the iterative and recursive versions of the function. 2. Consider edge cases such as when `n` is 0 or when it is a power of two. 3. Ensure that your solution efficiently handles the upper bound of the input range (i.e., 2^32 - 1).","solution":"def hamming_weight_recursive(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given unsigned 32-bit integer using recursion. Brian Kernighan\'s Algorithm is used. if n == 0: return 0 return 1 + hamming_weight_recursive(n & (n - 1)) def hamming_weight_iterative(n: int) -> int: Returns the number of \'1\' bits in the binary representation of the given unsigned 32-bit integer using iteration. Brian Kernighan\'s Algorithm is used. count = 0 while n: n &= n - 1 count += 1 return count"},{"question":"# Roman Numeral Decimal Conversion Problem Statement Given a string representing a Roman numeral, convert it to an integer. You need to write a function called `roman_to_int` that takes a Roman numeral string as input and returns its corresponding integer value. Expected Input and Output * **Input**: A single string `s`, where `1 <= len(s) <= 15`. The string is guaranteed to be a valid Roman numeral within the range from 1 to 3999. * **Output**: An integer representing the converted Roman numeral. Constraints * The input Roman numeral string will always represent a number in the valid range (1 to 3999). * The function should adhere to the following performance requirements: - **Time Complexity**: O(n), where n is the length of the string. - **Space Complexity**: O(1), not including the input string. Detailed Requirements 1. The valid Roman numerals are: \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\' used to encode values 1, 5, 10, 50, 100, 500, 1000 respectively. 2. Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not \'IIII\', it is \'IV\'. The numeral for nine is not \'VIIII\', it is \'IX\'. 3. The rules for Roman numerals are as follows: * \'I\' can be placed before \'V\' (5) and \'X\' (10) to make 4 and 9. * \'X\' can be placed before \'L\' (50) and \'C\' (100) to make 40 and 90. * \'C\' can be placed before \'D\' (500) and \'M\' (1000) to make 400 and 900. Use these rules to create conversions in your function. Function Signature ```python def roman_to_int(s: str) -> int: ``` Example ```python # Example 1: # Input: \\"III\\" # Output: 3 # Example 2: # Input: \\"IV\\" # Output: 4 # Example 3: # Input: \\"IX\\" # Output: 9 # Example 4: # Input: \\"LVIII\\" # Output: 58 # Example 5: # Input: \\"MCMXCIV\\" # Output: 1994 ``` Hints Consider the special cases for subtractive combinations and build a mapping of Roman numerals to integers for easy lookup. Traverse the string, checking against these mappings to compute the final value.","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral string to an integer. roman_to_integer = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): current_value = roman_to_integer[char] if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"# Full Path Resolver Write a function `full_resolved_path(path)` that takes a single argument, a string representing a filesystem path, and returns the absolute path. This function should: 1. Handle paths starting with `~` by expanding them to the user’s home directory. 2. Convert relative paths to absolute paths using the current working directory. 3. Maintain compatibility with the operating system\'s path conventions. **Function Signature** ```python def full_resolved_path(path: str) -> str: pass ``` **Input** - A single string `path` (0 ≤ len(path) ≤ 1000) representing a file path. It could be: - Relative path (e.g., `docs/file.txt`) - Path with user home directory (e.g., `~/file.txt`) - Absolute path (e.g., `/home/user/docs/file.txt` on Unix or `C:Usersdocsfile.txt` on Windows). **Output** - A single string representing the absolute path. **Constraints** - The function should not check if the file actually exists; it should only resolve the path. - Must work across different operating systems (Unix-like systems and Windows). **Examples** ```python # Example 1 print(full_resolved_path(\\"~/downloads\\")) # On Unix, it might return /home/username/downloads # On Windows, it might return C:Usersusernamedownloads # Example 2 print(full_resolved_path(\\"docs/file.txt\\")) # On Unix if current dir is /home/username/projects, it might return /home/username/projects/docs/file.txt # On Windows if current dir is C:Usersusernameprojects, it might return C:Usersusernameprojectsdocsfile.txt # Example 3 print(full_resolved_path(\\"/absolute/path/to/file\\")) # Should return /absolute/path/to/file as it is already an absolute path. ``` **Notes** - Make sure to thoroughly test edge cases like mixed path separators and empty strings.","solution":"import os def full_resolved_path(path: str) -> str: Resolves the full absolute path from a relative or home-based path. return os.path.abspath(os.path.expanduser(path))"},{"question":"**Cycle Detection in Linked List** # Description You are given a singly linked list where you need to detect whether there is a cycle. If a cycle exists, return the node at which the cycle begins. Implement the function using Floyd’s Cycle-Finding Algorithm (Tortoise and Hare Algorithm). # Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: ``` # Input - A single parameter, `head`, which represents the head of the linked list of type `Node`. # Output - Return the `Node` where the cycle begins. If no cycle exists, return `None`. # Constraints - Consider the maximum length of the linked list up to 10^4 nodes. - There are no duplicate values in the linked list nodes. - Assume the linked list does not contain negative values. # Example Input: ```plaintext A -> B -> C -> D -> E -> C ``` Output: ```plaintext C (Node where the cycle begins) ``` # Additional Notes - The function should be tested with different scenarios including lists with and without cycles. - Ensure edge cases like empty lists and single nodes are handled. # Hints - Use Floyd\'s cycle-finding algorithm to achieve this in O(n) time and O(1) space. # Example Test Suite ```python class TestSuite(unittest.TestCase): def test_first_cyclic_node(self): # Test case 1: Cycle exists head = Node(\'A\') head.next = Node(\'B\') curr = head.next cyclic_node = Node(\'C\') curr.next = cyclic_node curr = curr.next curr.next = Node(\'D\') curr = curr.next curr.next = Node(\'E\') curr = curr.next curr.next = cyclic_node self.assertEqual(\'C\', first_cyclic_node(head).val) # Test case 2: No cycle head = Node(\'1\') head.next = Node(\'2\') head.next.next = Node(\'3\') head.next.next.next = Node(\'4\') head.next.next.next.next = Node(\'5\') self.assertEqual(None, first_cyclic_node(head)) # Test case 3: Single node without cycle head = Node(\'A\') self.assertEqual(None, first_cyclic_node(head)) if __name__ == \'__main__\': unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def first_cyclic_node(head: Node) -> Node: if not head or not head.next: return None slow = head fast = head # Phase 1: Determine if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: # No cycle return None # Phase 2: Find the entry point to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"Prime Number Summation and Count Introduction: Prime numbers are fundamental in number theory and have many applications in cryptography, algorithms, and scientific computations. In this task, you will write a Python function that identifies prime numbers from a list and computes specific outputs based on them. Task: You are provided with a list of integers. Your job is to: 1. Filter out the prime numbers from the list. 2. Return the sum of these prime numbers. 3. Return the count of these prime numbers. Function Signature: ```python def sum_and_count_primes(numbers: list) -> tuple: # Your code here ``` Input: * `numbers`: A list of integers. `1 <= len(numbers) <= 10^5` - Each integer in the list can be between `-10^6` and `10^6`. Output: * Returns a tuple with two elements: - The sum of prime numbers in the list. - The count of prime numbers in the list. Example: ```python assert sum_and_count_primes([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == (17, 4) assert sum_and_count_primes([-10, -3, 0, 1, 2]) == (2, 1) ``` Constraints: 1. You must utilize the provided `prime_check` function for checking the primality of numbers. 2. The function should handle large lists efficiently within the provided constraints. 3. Consider edge cases like negative numbers and zero which are not prime.","solution":"def prime_check(n): Check if a number is a prime or not. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False p = 3 while p * p <= n: if n % p == 0: return False p += 2 return True def sum_and_count_primes(numbers: list) -> tuple: Identifies prime numbers from a list and computes the sum and count of primes. Args: numbers: List of integers. Returns: A tuple containing the sum of prime numbers and the count of prime numbers in the list. prime_sum = 0 prime_count = 0 for number in numbers: if prime_check(number): prime_sum += number prime_count += 1 return (prime_sum, prime_count)"},{"question":"# Binary Search Tree Modifications Scenario: You have been provided with a basic implementation of a Binary Search Tree (BST) that supports insertion, search, size, and traversal (preorder, inorder, postorder). However, this BST does not yet support deletion operations. In real-world applications, being able to delete nodes from the tree is crucial. Your task is to add a **delete** operation to the existing BST class. The delete operation should maintain the properties of the BST. Additionally, implement a method for level order traversal, which will help in verifying the structure of the tree after deletions. Function Signatures: 1. `def delete(self, data):` 2. `def level_order(self):` Requirements: 1. The `delete` method should take a value (`data`) and remove the node with the value from the BST, maintaining the BST properties. Ensure to handle all edge cases, such as: - Node to be deleted has no children. - Node to be deleted has one child. - Node to be deleted has two children (use the in-order successor or in-order predecessor). 2. The `level_order` method should print the tree\'s node values in a level-order manner, where nodes are visited level by level from left to right, starting from the root. This method helps to verify that the tree maintains the correct structure after deletions. Input/Output - `delete` method: * **Input:** An integer representing the value to be deleted. * **Output:** None (modifies the tree in place). - `level_order` method: * **Input:** None. * **Output:** Prints the node values level by level. Constraints: - Assume all node values are unique. - The BST initially does not contain any nodes. - You must use the provided BST class definition and your new methods should be defined within this class. Example: ```python # Creating the BST bst = BST() bst.insert(10) bst.insert(5) bst.insert(20) bst.insert(3) bst.insert(7) bst.insert(15) bst.insert(30) # Performing level order traversal bst.level_order() # Output: 10 5 20 3 7 15 30 # Deleting a node with two children bst.delete(20) # Performing level order traversal after delete bst.level_order() # Output: 10 5 30 3 7 15 ```","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.val = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = Node(key) else: self._insert(root.left, key) else: if root.right is None: root.right = Node(key) else: self._insert(root.right, key) def delete(self, key): self.root = self._delete_node(self.root, key) def _delete_node(self, root, key): if root is None: return root if key < root.val: root.left = self._delete_node(root.left, key) elif key > root.val: root.right = self._delete_node(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp_val = self._min_value_node(root.right).val root.val = temp_val root.right = self._delete_node(root.right, temp_val) return root def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def level_order(self): if not self.root: return queue = [self.root] while queue: current = queue.pop(0) print(current.val, end=\' \') if current.left: queue.append(current.left) if current.right: queue.append(current.right) # Auxiliary methods for testing def collect_level_order(bst): result = [] if not bst.root: return result queue = [bst.root] while queue: current = queue.pop(0) result.append(current.val) if current.left: queue.append(current.left) if current.right: queue.append(current.right) return result"},{"question":"# Question: Implementing Sparse Cholesky Decomposition Context In numerical analysis, solving large systems of linear equations efficiently is crucial, especially when dealing with matrices that have many zero entries (sparse matrices). The Cholesky decomposition is one such technique, but standard implementations may not leverage sparsity, leading to unnecessary computations. You are to implement a sparse Cholesky matrix decomposition by optimizing the given approach. Task Create a function `sparse_cholesky_decomposition(A, tol)`, which performs Cholesky decomposition optimized for sparse matrices. The function should: 1. Handle sparse matrices efficiently. 2. Return `None` if the matrix is not positive-definite. 3. Maintain numerical stability with a specified tolerance `tol`. Function Signature ```python def sparse_cholesky_decomposition(A: List[List[float]], tol: float) -> List[List[float]]: pass ``` Input - `A` (List[List[float]]): Hermitian positive-definite matrix. - `tol` (float): Tolerance level for numerical stability (e.g., `1e-9`). Output - Returns the lower triangle matrix `V` such that ( V times V^T = A ), or `None` if the matrix `A` is not positive-definite. Constraints - The matrix ( A ) is sparse and contains many zero elements. - The dimensions of the matrix ( A ) are ( n times n ) where ( 2 leq n leq 500 ). Example ```python A = [ [4, 12, 0], [12, 37, -43], [0, -43, 98] ] tol = 1e-9 sparse_cholesky_decomposition(A, tol) => [[2.0, 0.0, 0.0], [6.0, 1.0, 0.0], [0.0, 5.0, 3.0]] ```","solution":"def sparse_cholesky_decomposition(A, tol): Performs Cholesky decomposition for a sparse matrix. :param A: List[List[float]], a symmetric positive-definite matrix :param tol: float, tolerance level for numerical stability :return: List[List[float]], lower triangular matrix or None if not positive-definite import math n = len(A) V = [[0.0] * n for _ in range(n)] for i in range(n): for j in range(i + 1): sum_v = sum(V[i][k] * V[j][k] for k in range(j)) if i == j: # Diagonal elements V[i][j] = A[i][i] - sum_v if V[i][j] < tol: return None V[i][j] = math.sqrt(V[i][j]) else: if V[j][j] < tol: return None V[i][j] = (A[i][j] - sum_v) / V[j][j] return V"},{"question":"You are given a list of integers `nums` and an integer `target`. Your task is to implement a function `two_sum` that returns the indices of the two numbers such that they add up to `target`. The function should have the following signature: ```python def two_sum(nums: List[int], target: int) -> Tuple[int, int]: # Your code here ``` # Input Format - A list of integers `nums` containing n elements where 2 <= n <= 10^5. - An integer `target`. # Output Format - A tuple containing two integers which are the indices of the two numbers in `nums` that add up to `target`. # Constraints 1. Each input list will have exactly one solution. 2. You may not use the same element twice. 3. The solution must have an average time complexity of O(n). # Example ```python # Example 1 nums = [2, 7, 11, 15] target = 9 # Output: (0, 1) # Example 2 nums = [3, 2, 4] target = 6 # Output: (1, 2) # Example 3 nums = [3, 3] target = 6 # Output: (0, 1) ``` # Performance Requirements The function must handle lists containing up to 100,000 integers efficiently. # Edge Cases - Check for negative values in the array. - Handle cases where the input list length is exactly 2. # Scenario You are tasked with implementing this function as part of a larger financial services suite where finding pairs of transactions that sum up to a specific amount is a common requirement.","solution":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Return the indices of the two numbers in nums that add up to target. num_map = {} # To store number and its index for index, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], index) num_map[num] = index"},{"question":"# Pigeonhole Sort Implementation You are given an array of integers where the range of the integers can vary but is known to include an extensive but feasible span. Your task is to implement the pigeonhole sort algorithm to sort the array in increasing order. # Requirements 1. Function Signature: `def pigeonhole_sort(arr: List[int]) -> List[int]:` 2. The function should handle the edge cases properly. 3. Assume that the number of elements and the range will be such that the algorithm remains practical, according to its strengths. # Input - A list of integers `arr` where the number of integers `n` and the range of integers `Range` are such that `n` is smaller or similar to `Range`. # Output - A sorted list of integers. # Constraints - 1 <= len(arr) <= 10^5 - -10^4 <= arr[i] <= 10^4 for any i - The range of integers (max element - min element) `Range` <= 2 * 10^4 # Example Example 1: ```python Input: arr = [8, 3, 2, 7, 4] Output: [2, 3, 4, 7, 8] ``` Example 2: ```python Input: arr = [3, 3, 2, 1, 3] Output: [1, 2, 3, 3, 3] ``` Example 3: ```python Input: arr = [] Output: [] ``` **Instructions**: Implement the pigeonhole sort algorithm using the constraints provided. Ensure efficiency in time and space complexity according to the properties of Pigeonhole Sort. Handle edge cases effectively and test your function rigorously.","solution":"from typing import List def pigeonhole_sort(arr: List[int]) -> List[int]: if not arr: return [] min_val = min(arr) max_val = max(arr) size = max_val - min_val + 1 holes = [0] * size for num in arr: holes[num - min_val] += 1 sorted_arr = [] for index in range(size): while holes[index] > 0: sorted_arr.append(index + min_val) holes[index] -= 1 return sorted_arr"},{"question":"**Problem Statement**: You are given two words `word_a` and `word_b`. Your task is to write a function `edit_distance_optimized` to calculate the minimum number of operations required to transform `word_a` into `word_b`. You need to implement the function using a space-optimized dynamic programming approach to ensure efficiency for large strings. Function Signature: ```python def edit_distance_optimized(word_a: str, word_b: str) -> int: ``` Input: * `word_a` (string): First word (0 ≤ |word_a| ≤ 2000) * `word_b` (string): Second word (0 ≤ |word_b| ≤ 2000) Output: * Returns an integer representing the minimum number of operations required to transform `word_a` into `word_b`. Constraints: * You may only use two rows of the DP matrix to actively store states during computation. * You cannot use additional libraries; stick to basic Python functionalities. Example: ```python assert edit_distance_optimized(\\"FOOD\\", \\"MONEY\\") == 4 assert edit_distance_optimized(\\"\\", \\"ABCD\\") == 4 assert edit_distance_optimized(\\"ABCDE\\", \\"AECBD\\") == 3 assert edit_distance_optimized(\\"INTENTION\\", \\"EXECUTION\\") == 5 ``` Explanation: To convert \\"FOOD\\" to \\"MONEY\\": 1. FOOD -> MOOD (substitution of F with M) 2. MOOD -> MOND (substitution of O with N) 3. MOND -> MONED (insertion of E) 4. MONED -> MONEY (substitution of D with Y) The correct transformation ends up using 4 operations.","solution":"def edit_distance_optimized(word_a: str, word_b: str) -> int: Returns the minimum number of operations required to transform word_a into word_b. Uses a space-optimized dynamic programming approach. # Early return if one of the words is empty if len(word_a) == 0: return len(word_b) if len(word_b) == 0: return len(word_a) # Swap to ensure word_a is smaller or equal to word_b for optimized memory usage if len(word_a) > len(word_b): word_a, word_b = word_b, word_a # Initialize two rows for DP previous_row = list(range(len(word_b) + 1)) current_row = [0] * (len(word_b) + 1) # Fill the DP table for i in range(1, len(word_a) + 1): current_row[0] = i for j in range(1, len(word_b) + 1): if word_a[i - 1] == word_b[j - 1]: current_row[j] = previous_row[j - 1] else: current_row[j] = min( previous_row[j] + 1, # Deletion current_row[j - 1] + 1, # Insertion previous_row[j - 1] + 1 # Substitution ) # Copy current_row to previous_row (since current_row will be modified) previous_row[:] = current_row[:] return previous_row[len(word_b)]"},{"question":"# Coding Assessment: Advanced String Reversal Given the distinct methods of string reversal listed below, implement a function `custom_string_reverse(s, method)` where `s` is a string and `method` is one of `\'recursive\'`, `\'iterative\'`, `\'pythonic\'`, or `\'ultra_pythonic\'`. The function should reverse the input string `s` according to the specified method. Function signature: ```python def custom_string_reverse(s: str, method: str) -> str: pass ``` Input: - `s`: A string containing alphanumeric characters and spaces (1 ≤ |s| ≤ 1000). - `method`: A string representing the reversal technique (`\'recursive\'`, `\'iterative\'`, `\'pythonic\'`, `\'ultra_pythonic\'`). Output: - Returns the reversed string. Constraints: - Ensure efficient handling of the input within the provided constraints. - Assume valid inputs always. Performance Requirements: - Aim for the best time and space complexity possible for each method. # Examples: ```python print(custom_string_reverse(\\"hello world\\", \\"recursive\\")) # Output: \\"dlrow olleh\\" print(custom_string_reverse(\\"reverse me\\", \\"iterative\\")) # Output: \\"em esrever\\" print(custom_string_reverse(\\"sample text\\", \\"pythonic\\")) # Output: \\"txet elpmas\\" print(custom_string_reverse(\\"example\\", \\"ultra_pythonic\\")) # Output: \\"elpmaxe\\" ``` # Notes: - Focus on accurately implementing each text reversal technique. - Consider any edge cases such as empty strings or strings with only spaces.","solution":"def custom_string_reverse(s: str, method: str) -> str: def recursive_reverse(s: str) -> str: if len(s) == 0: return s return s[-1] + recursive_reverse(s[:-1]) def iterative_reverse(s: str) -> str: reversed_str = \\"\\" for char in s: reversed_str = char + reversed_str return reversed_str def pythonic_reverse(s: str) -> str: return s[::-1] def ultra_pythonic_reverse(s: str) -> str: return \'\'.join(reversed(s)) methods = { \'recursive\': recursive_reverse, \'iterative\': iterative_reverse, \'pythonic\': pythonic_reverse, \'ultra_pythonic\': ultra_pythonic_reverse } if method in methods: return methods[method](s) else: raise ValueError(\\"Invalid method provided\\")"},{"question":"**Question:** Implement an optimized version of the binomial coefficient calculation that avoids excessive recursion by using memoization. Your function should correctly handle large inputs that could stress recursion limits. The function signature is: ```python def binomial_coefficient(n: int, k: int) -> int: ``` # Input - **n**: a non-negative integer where n represents the total number of items. - **k**: a non-negative integer where k is the number of items to choose, 0 <= k <= n. # Output - Returns the binomial coefficient C(n, k) as a non-negative integer. # Constraints - n >= k - Both n and k are non-negative integers. # Example ```python assert binomial_coefficient(5, 0) == 1 assert binomial_coefficient(8, 2) == 28 assert binomial_coefficient(5, 2) == 10 ``` # Notes - Utilize memoization (caching) to enhance the performance of the recursive approach. - Be cautious to handle large values of n and k efficiently. - Consider edge cases, such as n = 0, k = 0 and other boundary conditions. ```python # Example implementation with memoization. def binomial_coefficient(n: int, k: int, memo=None) -> int: if memo is None: memo = {} if (n, k) in memo: return memo[(n, k)] if k == 0 or k == n: return 1 if k > n: raise ValueError(\'Invalid inputs, ensure that n >= k\') if k > n // 2: k = n - k result = binomial_coefficient(n - 1, k - 1, memo) + binomial_coefficient(n - 1, k, memo) memo[(n, k)] = result return result ```","solution":"def binomial_coefficient(n: int, k: int, memo=None) -> int: Calculate the binomial coefficient C(n, k) using memoization. Args: n (int): The total number of items. k (int): The number of items to choose. Returns: int: The binomial coefficient C(n, k). if memo is None: memo = {} if (n, k) in memo: return memo[(n, k)] if k == 0 or k == n: return 1 if k > n: raise ValueError(\'Invalid inputs, ensure that n >= k\') if k > n // 2: k = n - k result = binomial_coefficient(n - 1, k - 1, memo) + binomial_coefficient(n - 1, k, memo) memo[(n, k)] = result return result"},{"question":"# Question: Efficient Cumulative Sum Calculator You are tasked with implementing a data structure that supports two fundamental operations efficiently: 1. **Update Operation**: Set the value of an element in the array. 2. **Query Operation**: Compute the prefix sum of the array up to a given index. For this purpose, you will implement a Fenwick Tree (also known as a Binary Indexed Tree). Requirements: 1. **Initialization**: * Function: `__init__(self, arr)` * Input: A list of integers `arr`. * Task: Initialize the Fenwick Tree with the given list. 2. **Update Operation**: * Function: `update(self, index, value)` * Input: An integer `index` within the range `[0, len(arr)-1]` and an integer `value`. * Task: Update the array such that `arr[index] = value`. 3. **Query Operation**: * Function: `query(self, index)` * Input: An integer `index` within the range `[0, len(arr)-1]`. * Output: Return the sum of elements from `arr[0]` to `arr[index]`. Use the provided template to complete the solution: ```python class FenwickTree: def __init__(self, arr): pass def update(self, index, value): pass def query(self, index): pass ``` Example: ```python # Example usage arr = [1, 2, 3, 4, 5] ft = FenwickTree(arr) print(ft.query(4)) # Output: 15 (sum of elements 1 to 5) ft.update(2, 6) print(ft.query(4)) # Output: 18 (array becomes [1, 2, 6, 4, 5]) ``` Constraints: * `arr` will have a length of at most `10^5`. * Each `update` and `query` call will be performed within `10^5` times. * Initial array values and update values are integers between `-10^9` and `10^9`.","solution":"class FenwickTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr[:] for i in range(self.n): self._add(i + 1, arr[i]) def _add(self, index, value): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index, value): diff = value - self.arr[index] self.arr[index] = value self._add(index + 1, diff) def query(self, index): sum_ = 0 index += 1 while index > 0: sum_ += self.tree[index] index -= index & -index return sum_"},{"question":"# Question Context You are working on a project that involves searching for specific values in large data tables. The tables are organized in a way that each row and column is sorted in non-decreasing order. To optimize the search operations, you need to implement an efficient search algorithm. Task Write a function `search_key_in_matrix(matrix, key)` that searches for `key` in a given 2D matrix where each row and each column is sorted in non-decreasing order. If the key is found, return a tuple `(row_index, col_index)` indicating the position of the key in the matrix. If the key is not found, return `None`. # Function Signature ```python def search_key_in_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: pass ``` Input - `matrix`: A list of lists (2D matrix) where each row and each column is sorted in non-decreasing order. - `key`: The integer value you need to search for in the matrix. Output - If the key is found, the function should return a tuple `(row_index, col_index)` representing the indices of the row and column where the key is located. Indices are 0-based. - If the key is not found, return `None`. Constraints - Each element in the matrix is a unique integer. - 1 <= len(matrix) <= 1000 - 1 <= len(matrix[0]) <= 1000 - -10^9 <= matrix[i][j] <= 10^9 Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert search_key_in_matrix(matrix, key) == (1, 2) assert search_key_in_matrix(matrix, 10) == None ``` # Performance Requirements - The solution must have a time complexity of O(m + n), where m is the number of rows and n is the number of columns in the matrix. - Space complexity should be O(1). Notes 1. Carefully handle the edge cases. 2. Ensure your implementation is efficient, as the on-the-spot search speed is crucial for large matrices.","solution":"from typing import List, Optional, Tuple def search_key_in_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: if not matrix or not matrix[0]: return None rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Question: Efficient Removal of Duplicates from Singly Linked List You are given a singly linked list where each node contains an integer value. Your task is to implement a function that removes duplicate values from this list while preserving the order of the remaining elements. Input - `head`: Reference to the head node of the singly linked list. Output - Returns the `head` of the modified linked list with duplicates removed. Function Signature ```python def remove_duplicates(head: Node) -> Node: pass ``` # Constraints 1. Node values are between `-10^5` and `10^5`. 2. The length of the linked list `N` is between 0 and `10^5`. # Requirements - The function should be efficient with a time complexity of O(N) and a reasonable space complexity. - You should avoid using extra space if possible (other than the input list). # Example **Input** ```python # Representation of list: 1 -> 3 -> 2 -> 3 -> 4 -> 2 -> 5 class Node(): def __init__(self, val = None): self.val = val self.next = None a = Node(1) b = Node(3) c = Node(2) d = Node(3) e = Node(4) f = Node(2) g = Node(5) a.next = b b.next = c c.next = d d.next = e e.next = f f.next = g head = remove_duplicates(a) print_linked_list(head) # Expected output: 1 -> 3 -> 2 -> 4 -> 5 ``` **Output** ```plaintext 1 -> 3 -> 2 -> 4 -> 5 ``` # Note - Provide appropriate error and edge case handling. - If space allows, aim to implement the solution such that it balances the complexities efficiently.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates(head: Node) -> Node: if head is None: return head current = head seen_values = set([current.val]) while current.next is not None: if current.next.val in seen_values: current.next = current.next.next # Remove the duplicate node else: seen_values.add(current.next.val) current = current.next return head"},{"question":"# Problem: Wildcard Pattern Matching You are given two strings, `s` and `p`. You need to implement a function `is_match(s, p)` that checks if the entire string `s` matches the pattern `p`. The pattern may include the wildcard characters `.` and `*`, where: - `.` matches any single character. - `*` matches zero or more of the preceding element. Implement this function using dynamic programming to efficiently solve the problem. Function Signature ```python def is_match(s: str, p: str) -> bool: # Your implementation here ``` Input - `s` (1 ≤ len(s) ≤ 200): a string consisting of lowercase English letters. - `p` (1 ≤ len(p) ≤ 200): a string containing lowercase English letters and the characters `.` and `*`. Output - Return `True` if `s` matches the pattern `p`, `False` otherwise. Constraints - The pattern `p` is guaranteed to be a valid pattern where `*` always comes after another valid character or `.`. Example ```python print(is_match(\\"aa\\", \\"a\\")) # Output: False print(is_match(\\"aa\\", \\"a*\\")) # Output: True print(is_match(\\"ab\\", \\".*\\")) # Output: True print(is_match(\\"aab\\", \\"c*a*b\\")) # Output: True print(is_match(\\"mississippi\\", \\"mis*is*p*.\\")) # Output: False ``` Use the given dynamic programming approach as a reference to implement your solution. Ensure your implementation is robust to handle various edge cases and optimizes performance wherever possible.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p, False otherwise. The pattern p can include \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. m, n = len(s), len(p) # dp[i][j] means whether s[0..i-1] matches p[0..j-1] dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True # dp[0][j] depends on p[j-1] for j in range(2, n + 1): dp[0][j] = dp[0][j - 2] if p[j - 1] == \'*\' else False for i in range(1, m + 1): for j in range(1, n + 1): if p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] if p[j - 2] in {s[i - 1], \'.\'} else False) else: dp[i][j] = dp[i - 1][j - 1] if p[j - 1] in {s[i - 1], \'.\'} else False return dp[m][n]"},{"question":"You have been hired by a tech company that specializes in financial modeling. Often their models require the calculation of Fibonacci numbers due to their nature in certain predictive algorithms. Therefore, it is essential for you to be able to implement efficient methods to compute these numbers. # Problem Statement Given a number `n`, you need to write a function that returns the n-th Fibonacci number. You should implement the Fibonacci number generation in two different ways: using dynamic programming and an iterative approach. The solution must be efficient and able to handle larger values of n (up to 10,000). # Function Signature ```python def fibonacci_dynamic(n: int) -> int: pass def fibonacci_iterative(n: int) -> int: pass ``` # Input * An integer `n` (0 ≤ n ≤ 10,000). # Output * An integer that is the n-th Fibonacci number. # Example ```python assert fibonacci_dynamic(10) == 55 assert fibonacci_iterative(10) == 55 ``` # Constraints * You must handle edge cases such as `n` being 0 or 1. * Ensure your solution is time efficient to handle inputs as large as 10,000. * Include error handling for invalid inputs (e.g., negative values). # Notes * The dynamic programming approach should use a list to store Fibonacci numbers up to `n`. * The iterative approach should minimize space complexity by only keeping track of the last two Fibonacci numbers.","solution":"def fibonacci_dynamic(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 fib = [0] * (n + 1) fib[1] = 1 for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n] def fibonacci_iterative(n: int) -> int: if n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 if n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Question: Generate Unique Permutations of a List with Duplicates Given a list of numbers that may contain duplicates, write a function that returns all possible unique permutations of the list. The function should handle the possibility of duplicate numbers in the input list and must ensure that no duplicate permutations appear in the output. Function Signature ```python def permute_unique(nums: List[int]) -> List[List[int]]: ``` # Input - `nums`: A list of integers which may contain duplicates. (1 <= len(nums) <= 8) # Output - A list of lists, where each inner list is a unique permutation of the given `nums`. # Constraints - The length of `nums` will not exceed 8, to ensure manageable computation within reasonable time limits. - The integers in `nums` can be both positive, negative, and zero. # Example ```python print(permute_unique([1,1,2])) # Output: [ # [1, 1, 2], # [1, 2, 1], # [2, 1, 1] # ] print(permute_unique([3, 3, 3])) # Output: [ # [3, 3, 3] # ] ``` # Performance Requirements - The function should be optimized to avoid generating and discarding duplicate permutations repeatedly. - Aim to use efficient data structures to manage and filter permutations dynamically. # Scenario You have been given a task in a combinatorial optimization project where you need to enumerate all unique sequences of resource allocations to determine which configurations yield the best results. Implement the function to generate these unique sequences efficiently.","solution":"from typing import List from itertools import permutations def permute_unique(nums: List[int]) -> List[List[int]]: Generate all unique permutations of the input list of numbers. :param nums: List of integers which may contain duplicates. :return: A list of unique permutations. return list(map(list, set(permutations(nums))))"},{"question":"# Scenario: You are working on a scientific computational library that assists researchers in performing numerical computations efficiently. One key feature of your library is matrix operations, specifically matrix inversion. Given the importance of dealing with matrix inversions optimally and correctly, you need to implement this functionality accurately. # Task: Write a function `invert_matrix(matrix: List[List[float]]) -> List[List[float]]` that takes a square matrix (n x n) as an input and returns its inverse if it exists. If the matrix is not invertible, your function should return a special error code matrix as specified below. # Requirements: 1. The function should validate the input matrix for the following conditions: * It should be a square matrix. * It should be at least 2x2 dimensions. * It should have a non-zero determinant. 2. If any of the above conditions fail, return one of the following error code matrices: * [[-1]] if the input is not a valid matrix. * [[-2]] if the matrix is not square. * [[-3]] if the matrix is too small (less than 2x2). * [[-4]] if the matrix is singular (determinant is 0). 3. Implement the inversion algorithm for both the 2x2 case and the general case using the steps outlined: * Calculate the matrix of minors. * Create the cofactor matrix. * Adjugate the matrix. * Multiply by the reciprocal of the determinant of the original matrix. # Input: * `matrix: List[List[float]]` - a list of lists where each sublist represents a row in the matrix. The matrix contains floating-point numbers. # Output: * `List[List[float]]` - the inverse of the input matrix or an error code matrix. # Constraints: * Assume that the size of the matrix is at most 10x10. # Example: ```python matrix = [ [4, 7], [2, 6] ] output = invert_matrix(matrix) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] ``` # Note: * Be mindful of numerical precision issues. * Check for division by zero when handling the determinant.","solution":"from typing import List def determinant(matrix: List[List[float]], n: int) -> float: if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(n): det += ((-1) ** c) * matrix[0][c] * determinant(get_minor(matrix, 0, c), n - 1) return det def get_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: minor = [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] return minor def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: # Check if matrix is not a list or if it\'s not a valid 2D list if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] # Check if matrix is square if any(len(row) != len(matrix) for row in matrix): return [[-2]] n = len(matrix) # Check if matrix is at least 2x2 if n < 2 or any(len(row) < 2 for row in matrix): return [[-3]] det = determinant(matrix, n) # Check if matrix is singular if det == 0: return [[-4]] # Function to get the cofactor matrix def cofactor(matrix: List[List[float]], n: int) -> List[List[float]]: C = [] for r in range(n): row = [] for c in range(n): minor = get_minor(matrix, r, c) cof = ((-1) ** (r + c)) * determinant(minor, n - 1) row.append(cof) C.append(row) return C # Function to transpose matrix def transpose(matrix: List[List[float]], n: int) -> List[List[float]]: return [[matrix[j][i] for j in range(n)] for i in range(n)] cofactor_matrix = cofactor(matrix, n) adjugate_matrix = transpose(cofactor_matrix, n) # Divide each element by determinant to get the inverse inverse_matrix = [[adjugate_matrix[r][c] / det for c in range(n)] for r in range(n)] return inverse_matrix"},{"question":"You are given an array of integers representing the stock prices of a company over `n` days. You need to implement a structure that supports the following operations efficiently: 1. `update(index, value)`: Update the stock price at a given day `index` to `value`. 2. `get_sum(range_start, range_end)`: Compute the total stock price from day `range_start` to day `range_end` inclusive. To achieve this, you need to implement a `StockPrices` class using a Fenwick Tree. The class should be initialized with an array of stock prices, and should support the above operations with the following specifications: Input/Output Formats # Class Definition ```python class StockPrices: def __init__(self, prices: List[int]): # Initializes the data structure with the given stock prices. def update(self, index: int, value: int): # Updates the stock price at the specified index to the new value. def get_sum(self, range_start: int, range_end: int) -> int: # Returns the sum of stock prices in the specified range [range_start, range_end]. ``` # Example ```python # Initialize the stock prices prices = [100, 200, 300, 400, 500] sp = StockPrices(prices) # Update stock price on day 2 to 250 sp.update(1, 250) # Get sum of stock prices from day 1 to day 3 output = sp.get_sum(0, 2) print(output) # Output should be 650 (100 + 250 + 300) ``` Constraints * `0 <= index, range_start, range_end < n` * `1 <= n <= 10^5` * `1 <= prices[i] <= 10^4` * At most 10^5 calls will be made to `update` and `get_sum` methods in total. Use the Fenwick Tree to ensure that the update and get_sum operations are performed in O(log n) time.","solution":"from typing import List class StockPrices: def __init__(self, prices: List[int]): self.n = len(prices) self.tree = [0] * (self.n + 1) self.prices = prices[:] for i in range(self.n): self._update_tree(i + 1, prices[i]) def _update_tree(self, index: int, value: int): while index <= self.n: self.tree[index] += value index += index & -index def update(self, index: int, value: int): difference = value - self.prices[index] self.prices[index] = value self._update_tree(index + 1, difference) def _query_tree(self, index: int) -> int: sum = 0 while index > 0: sum += self.tree[index] index -= index & -index return sum def get_sum(self, range_start: int, range_end: int) -> int: return self._query_tree(range_end + 1) - self._query_tree(range_start)"},{"question":"# Scenario You are tasked with developing a utility function for a text analysis application. One of the required functionalities is to determine repetitive patterns within texts. The specific problem you need to solve involves given strings A and B, finding out how many times the string A needs to be repeated in order for B to be a substring of the repeated version of A. # Problem Statement Implement a function `repeat_string(A: str, B: str) -> int` that accepts two strings, A and B, and returns the minimum number of times A must be repeated so that B becomes a substring of the repeated version of A. If no such solution exists, the function should return -1. # Input * `A` (1 ≤ len(A) ≤ 10000): The base string to be repeated. * `B` (1 ≤ len(B) ≤ 10000): The target substring. # Output * An integer representing the minimum number of repetitions required, or -1 if B cannot be a substring of any number of repetitions of A. # Constraints * The length of string B can be up to 10000, and the length of A can also be up to 10000. * Assume the input strings contain only lowercase English letters. # Example ```python A = \\"abcd\\" B = \\"cdabcdab\\" assert repeat_string(A, B) == 3 A = \\"abc\\" B = \\"cabcabca\\" assert repeat_string(A, B) == 4 A = \\"a\\" B = \\"aa\\" assert repeat_string(A, B) == 2 A = \\"a\\" B = \\"b\\" assert repeat_string(A, B) == -1 ``` # Notes 1. Consider edge cases where B is already a substring of A, and where the strings have very little in common. 2. Optimize your solution to handle the maximum input sizes efficiently.","solution":"def repeat_string(A: str, B: str) -> int: Determines the minimum number of times string A needs to be repeated such that B is a substring of the repeated string A. Parameters: A (str): The base string to be repeated. B (str): The target substring. Returns: int: The minimum number of repetitions needed, or -1 if B cannot be a substring of the repeated A. # Calculate the minimum number of times A needs to be repeated initially n = len(A) m = len(B) repeated_A = A * ((m // n) + 2) for i in range(1, (m // n) + 3): if B in repeated_A[:i*n]: return i return -1"},{"question":"Decode Ways You are given a message containing digits from \'0\' to \'9\'. The digits are encoded using the following mapping: \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. Your task is to write a function that determines the total number of ways to decode the given message. Consider the following examples: - For the encoded message \\"12\\", it could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). The number of ways to decode \\"12\\" is 2. - For the encoded message \\"226\\", it could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). The number of ways to decode \\"226\\" is 3. # Input A string `enc_mes` consisting of digits \'0\' to \'9\'. # Output An integer representing the total number of ways to decode the message. # Constraints - The input string will not be empty and will contain digits only. - The input string will not have leading zeros unless the entire string is \\"0\\". # Example ```python num_decodings(\\"12\\") # Output: 2 num_decodings(\\"226\\") # Output: 3 num_decodings(\\"10\\") # Output: 1 num_decodings(\\"0\\") # Output: 0 num_decodings(\\"30\\") # Output: 0 ``` # Requirements - Implement the function `num_decodings(enc_mes)` returning an integer. # Solution Template ```python def num_decodings(enc_mes): :type enc_mes: str :rtype: int # Your code here ```","solution":"def num_decodings(enc_mes): Given an encoded message containing digits, determine the number of ways to decode it. :param enc_mes: str - The encoded message :return: int - The number of ways to decode the message if not enc_mes or enc_mes[0] == \'0\': return 0 n = len(enc_mes) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if enc_mes[0] != \'0\' else 0 for i in range(2, n + 1): if enc_mes[i-1] != \'0\': dp[i] += dp[i-1] if 10 <= int(enc_mes[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Implementing and Analyzing Selection Sort Context You have been hired by a data analysis firm to help clean and sort various datasets. One of your initial tasks is to implement and enhance basic sorting algorithms that can be used as educational tools for new hires. Task Description Your task is to implement a function `selection_sort(videos, simulation=False)` that sorts a given list of numbers using the selection sort algorithm. The function should: - Sort the list in ascending order. - Optionally simulate and print each iteration of the sorting process if the `simulation` parameter is set to `True`. Function Signature ```python def selection_sort(videos: List[int], simulation: bool=False) -> List[int]: pass # To be implemented by students ``` Input - `videos`: A list of integers representing durations of videos in seconds. - `simulation`: A boolean flag that indicates whether to print the list at the end of each iteration of the outer loop. Output - Returns the sorted list of integers. Constraints - The list can contain between 0 and 10^3 integers. - Each integer can range between -10^3 to 10^3. Example ```python >>> selection_sort([64, 34, 25, 12, 22, 11, 90], simulation=True) iteration 0 : 11 34 25 12 22 64 90 iteration 1 : 11 12 25 34 22 64 90 iteration 2 : 11 12 22 34 25 64 90 iteration 3 : 11 12 22 25 34 64 90 iteration 4 : 11 12 22 25 34 64 90 iteration 5 : 11 12 22 25 34 64 90 iteration 6 : 11 12 22 25 34 64 90 >>> [11, 12, 22, 25, 34, 64, 90] ```","solution":"from typing import List def selection_sort(videos: List[int], simulation: bool=False) -> List[int]: n = len(videos) for i in range(n): min_index = i for j in range(i+1, n): if videos[j] < videos[min_index]: min_index = j videos[i], videos[min_index] = videos[min_index], videos[i] if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, videos))}\\") return videos"},{"question":"# Problem: Dynamic Programming Binomial Coefficient You are required to implement a function to compute the binomial coefficient ( C(n, k) ) using a dynamic programming approach. The binomial coefficient represents the number of ways to choose ( k ) items from ( n ) items without considering the order. **Function Signature**: ```python def dp_binomial_coefficient(n: int, k: int) -> int: pass ``` # Input and Output **Input**: * An integer, ( n ) (1 ≤ ( n ) ≤ 1000): The total number of items. * An integer, ( k ) (0 ≤ ( k ) ≤ ( n )): The number of items to choose. **Output**: * An integer representing the computed binomial coefficient ( C(n, k) ). # Constraints * Ensure that the function is efficient and can handle the upper limits of the inputs. # Example ```python assert dp_binomial_coefficient(5, 0) == 1 assert dp_binomial_coefficient(8, 2) == 28 assert dp_binomial_coefficient(500, 300) == 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Additional Information * An iterative approach using dynamic programming will improve the performance by eliminating the excessive function call overhead associated with recursion. * Utilize a 2D array (or similar structure) to store intermediate results and build up the solution from known base cases. # Example Explanation For ( dp_binomial_coefficient(8, 2) ): * Start by initializing a 2D array of size ( (n+1) times (k+1) ). * Fill in base cases where ( C(i, 0) = 1 ) and ( C(i, i) = 1 ). * Use the recurrence relationship ( C(i, j) = C(i-1, j-1) + C(i-1, j) ) to fill in the array. * Return the value at ( dp[n][k] ).","solution":"def dp_binomial_coefficient(n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using a dynamic programming approach. Args: - n: number of items. - k: number of items to choose. Returns: The binomial coefficient C(n, k) which is the number of ways to choose k items from n items. if k > n: return 0 # Base case: C(n, k) is 0 if k > n # Create a 2D array to store results of subproblems dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)] # Populate the table according to the binomial coefficient recurrence relation for i in range(n + 1): for j in range(min(i, k) + 1): # Base cases if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][k]"},{"question":"Path Detection in Directed Graph **Scenario**: You\'re working on a network analysis tool that needs to determine if there exists a path between two nodes in a directed graph. Based on the structure provided, write a function to check the reachability between nodes. **Task**: Implement a function `is_reachable(graph, vertex_count, source, target)` where: * `graph` is a list of tuples representing the directed edges of the graph. Each tuple (a, b) indicates an edge from node `a` to node `b`. * `vertex_count` is an integer representing the number of vertices in the graph. * `source` and `target` are integers representing the source and target nodes respectively. The function should return `True` if there is a path from `source` to `target`, otherwise return `False`. **Constraints**: * The graph can have up to 10^3 vertices and 10^4 edges. * Each vertex is represented by an integer from 0 to vertex_count-1. * There can be multiple edges and self-loops. * You should handle disconnected graphs and isolated nodes efficiently. **Example**: ```python def is_reachable(graph, vertex_count, source, target): # Your implementation here # Example usage: graph = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] vertex_count = 4 source = 1 target = 3 print(is_reachable(graph, vertex_count, source, target)) # Output: True graph = [(0, 1), (0, 2), (1, 2), (2, 0), (2, 3), (3, 3)] vertex_count = 4 source = 3 target = 1 print(is_reachable(graph, vertex_count, source, target)) # Output: False ``` **Note**: - Ensure robustness against different edge cases such as graphs with no edges, self-loops, and isolated vertices.","solution":"def is_reachable(graph, vertex_count, source, target): from collections import deque, defaultdict if source == target: return True adj_list = defaultdict(list) for u, v in graph: adj_list[u].append(v) visited = [False] * vertex_count queue = deque([source]) while queue: current = queue.popleft() if current == target: return True if not visited[current]: visited[current] = True for neighbor in adj_list[current]: if not visited[neighbor]: queue.append(neighbor) return False"},{"question":"**Scenario**: You are working on an educational software that teaches various sorting algorithms interactively. Your task is to implement the Pancake Sort algorithm. Given a set of unsorted data, your implementation should demonstrate how to sort the data using the flipping technique described in Pancake Sorting. **Function Specification**: **Function Name**: `pancake_sort` **Input**: A list of integers, `arr` **Output**: A new list of integers that is sorted in ascending order. **Constraints**: * The length of `arr` will be within the range [0, 1000]. * Elements in `arr` will be in the range of -10000 to 10000. **Performance Requirements**: * The solution should have a time complexity of O(N^2) and space complexity of O(1). Implement the `pancake_sort` function using the following template: ```python def pancake_sort(arr): Pancake Sort Algorithm to sort the given array. :param arr: List[int] - A list of integers to be sorted :return: List[int] - The sorted list of integers # Your code here ``` **Example**: ```python >>> pancake_sort([3, 2, 4, 1]) [1, 2, 3, 4] >>> pancake_sort([10, 5, 2, 7]) [2, 5, 7, 10] >>> pancake_sort([]) [] >>> pancake_sort([1]) [1] ```","solution":"def pancake_sort(arr): Pancake Sort Algorithm to sort the given array. :param arr: List[int] - A list of integers to be sorted :return: List[int] - The sorted list of integers def flip(sublist, k): left = 0 while left < k: sublist[left], sublist[k] = sublist[k], sublist[left] left += 1 k -= 1 if not arr: return [] n = len(arr) for current_size in range(n, 1, -1): max_index = arr.index(max(arr[:current_size])) if max_index != current_size - 1: if max_index != 0: flip(arr, max_index) flip(arr, current_size - 1) return arr"},{"question":"# Question: Implement Transitive Closure Using Alternative Methods You have been given a directed graph represented by an adjacency list. The goal is to compute the transitive closure of this graph, which is a matrix indicating the reachability from every vertex to every other vertex. Input * The first line contains an integer `n` (1 ≤ n ≤ 100), the number of vertices. * The next `n` lines each contain space-separated integers, representing the adjacency list for each vertex `i` (0 ≤ i < n). Output * Output an `n x n` matrix where the entry at row `i` and column `j` is 1 if there is a path from vertex `i` to vertex `j`, otherwise 0. Constraints * The graph might be sparse or dense. * The number of vertices `n` will not exceed 100, but it should be handled efficiently. Implementation Requirements You are required to implement the transitive closure not using recursive DFS but instead employing the Floyd-Warshall algorithm, which is based on dynamic programming and often used for this purpose. Example **Input** ``` 4 1 2 2 3 ``` **Output** ``` 1 0 0 0 1 1 0 0 1 1 1 0 1 1 1 1 ``` Solution ```python def floyd_warshall_transitive_closure(graph_adjacency_list, vertex_count): # Initialize closure matrix closure = [[0] * vertex_count for _ in range(vertex_count)] # Fill initial reachability from adjacency list for i in range(vertex_count): closure[i][i] = 1 # Self-reachability for j in graph_adjacency_list[i]: closure[i][j] = 1 # Floyd-Warshall algorithm for k in range(vertex_count): for i in range(vertex_count): for j in range(vertex_count): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure # Read input n = int(input()) graph = [] for _ in range(n): graph.append(list(map(int, input().split()))) # Get transitive closure result = floyd_warshall_transitive_closure(graph, n) # Print result for row in result: print(\' \'.join(map(str, row))) ```","solution":"def floyd_warshall_transitive_closure(graph_adjacency_list, vertex_count): Computes the transitive closure of a directed graph using Floyd-Warshall algorithm. :param graph_adjacency_list: List of lists, where each sublist represents the adjacency list of a vertex. :param vertex_count: The number of vertices in the graph. :return: An n x n matrix representing the transitive closure of the graph. # Initialize closure matrix closure = [[0] * vertex_count for _ in range(vertex_count)] # Fill initial reachability from adjacency list for i in range(vertex_count): closure[i][i] = 1 # Self-reachability for j in graph_adjacency_list[i]: closure[i][j] = 1 # Floyd-Warshall algorithm to compute transitive closure for k in range(vertex_count): for i in range(vertex_count): for j in range(vertex_count): closure[i][j] = closure[i][j] or (closure[i][k] and closure[k][j]) return closure # Function to convert the result matrix to the specified format for output def format_output(matrix): return \'n\'.join(\' \'.join(map(str, row)) for row in matrix)"},{"question":"You are given a training dataset of labeled vectors, and you need to implement an enhanced nearest neighbor classifier with improved performance for high-dimensional datasets by incorporating a dimensionality reduction step. The dataset and vectors are provided in the form of tuples and a dictionary, respectively. # Enhanced Nearest Neighbor Classifier Function Signature: ```python def nearest_neighbor_classifier(x: tuple, tSet: dict) -> any: ``` # Input: - `x`: A tuple representing the input vector of length `d`. - `tSet`: A dictionary where: - Keys are tuples representing vectors of length `d`. - Values are the labels associated with each vector. # Output: - Returns the label from the training set that is closest to the input vector `x`. # Constraints: - Each vector dimension `d` will be at most 1000. - The dictionary will contain up to 10,000 vectors. - Vectors will contain integer values ranging from -1000 to 1000. # Required Steps: 1. **Dimensionality Reduction**: Implement Principal Component Analysis (PCA) or another suitable technique to reduce the dimensions of the vectors before calculating distances. 2. **Distance Calculation**: Compute the Euclidean distance between vectors. 3. **Nearest Neighbor Search**: Find and return the label of the nearest vector from the training set based on the reduced dimensions. # Performance Requirements: - The implementation should aim to optimize both time and space efficiency, especially for datasets with high dimensions and a large number of vectors. # Example: ```python tSet = { (2, 3, 1): \'A\', (1, 0, 4): \'B\', (2, 1, 3): \'C\' } x = (2, 2, 2) assert nearest_neighbor_classifier(x, tSet) == \'A\' ```","solution":"import numpy as np from sklearn.decomposition import PCA from sklearn.preprocessing import StandardScaler def nearest_neighbor_classifier(x: tuple, tSet: dict) -> any: Performs nearest neighbor classification with dimensionality reduction using PCA. Parameters: x (tuple): Input vector. tSet (dict): Training set where keys are tuples (vectors) and values are labels. Returns: any: The label of the nearest neighbor to the input vector. # Convert input data to numpy arrays for processing vectors = np.array(list(tSet.keys())) labels = list(tSet.values()) x = np.array(x).reshape(1, -1) # Standardizing the features scaler = StandardScaler() scaled_vectors = scaler.fit_transform(vectors) scaled_x = scaler.transform(x) # Apply PCA and reduce to 2 dimensions (can be adjusted as needed) pca = PCA(n_components=2) pca.fit(scaled_vectors) reduced_vectors = pca.transform(scaled_vectors) reduced_x = pca.transform(scaled_x) # Calculate Euclidean distance between reduced_x and all reduced_vectors distances = np.linalg.norm(reduced_vectors - reduced_x, axis=1) # Find the index of the minimum distance nearest_index = np.argmin(distances) # Return the corresponding label return labels[nearest_index]"},{"question":"You are given a set of cities connected by roads. Each road has a travel cost associated with it. Your task is to determine the minimum travel cost from a given city to all other cities using Dijkstra\'s algorithm. # Function Signature ```python def find_minimum_travel_costs(num_cities: int, roads: List[Tuple[int, int, int]], start_city: int) -> List[int]: pass ``` # Input - `num_cities` (1 <= num_cities <= 100): An integer representing the total number of cities. - `roads`: A list of tuples where each tuple (u, v, w) represents a road from city `u` to city `v` with a travel cost `w` (1 <= u, v <= num_cities; 0 <= w <= 100). - `start_city` (1 <= start_city <= num_cities): An integer representing the starting city. # Output - A list of integers where the i-th integer represents the minimum travel cost from the start city to the i-th city. If a city is unreachable, return `float(\'inf\')` for that city. # Constraints - Only cities connected by roads should be considered. Disconnected cities should have a travel cost of `float(\'inf\')`. - Travel costs are non-negative. # Example ```python num_cities = 5 roads = [(1, 2, 2), (1, 3, 5), (2, 3, 1), (3, 4, 2), (2, 4, 4)] start_city = 1 print(find_minimum_travel_costs(num_cities, roads, start_city)) # Output: [0, 2, 3, 5, inf] ``` # Notes - We assume that city numbers are 1-indexed. - The destination city can be the same as the source city, where the cost would be 0. # Implementation Details - Use Dijkstra\'s algorithm as a basis as illustrated in the provided snippet. - Adapt the algorithm to use appropriate data structures to ensure expected performance based on the input constraints.","solution":"import heapq from typing import List, Tuple def find_minimum_travel_costs(num_cities: int, roads: List[Tuple[int, int, int]], start_city: int) -> List[int]: def dijkstra(start, graph): dist = [float(\'inf\')] * num_cities dist[start] = 0 priority_queue = [(0, start)] # (cost, node) while priority_queue: current_cost, u = heapq.heappop(priority_queue) if current_cost > dist[u]: continue for v, weight in graph[u]: cost = current_cost + weight if cost < dist[v]: dist[v] = cost heapq.heappush(priority_queue, (cost, v)) return dist # Building the graph as an adjacency list graph = [[] for _ in range(num_cities)] for u, v, w in roads: graph[u-1].append((v-1, w)) graph[v-1].append((u-1, w)) # assuming the roads are bidirectional start_city -= 1 return dijkstra(start_city, graph)"},{"question":"# OrderedStack Enhancement As a software engineer at a financial software company, your role involves optimizing data structures to ensure both efficiency and correctness. An integral component of your application is maintaining a list of stock prices that allows quick access to the highest price in the last N trades. You are given an `OrderedStack` which maintains its elements in ascending order (the highest element on top). However, the current implementation is suboptimal for very large data sets. Enhance the given `OrderedStack` such that: 1. The `push` operation remains efficient. 2. The stack maintains its order as before. 3. Ensure the additional operations for checking if a new element should be added are minimized. Implement a class `OptimizedOrderedStack` with the following methods: 1. **push(item)**: Insert a new item into the stack maintaining the order. 2. **pop()**: Remove the top element from the stack. 3. **peek()**: Return the top element of the stack without removing it. 4. **is_empty()**: Check if the stack is empty. 5. **size()**: Return the number of elements in the stack. # Input and Output * **Input**: * `push(item)` - `item` is an integer to be added to the stack. * `pop()` - No input. * `peek()` - No input. * `is_empty()` - No input. * `size()` - No input. * **Output**: * `push(item)` - No output. * `pop()` - Returns the popped integer. * `peek()` - Returns the top integer. * `is_empty()` - Returns a boolean. * `size()` - Returns an integer. # Constraints * All `push` operations result in elements that fit into memory (i.e., no memory overflow). * Interactions with the stack can be in any sequence or combination. * Aim to optimize time complexity wherever possible. # Example ```python stack = OptimizedOrderedStack() stack.push(10) stack.push(5) stack.push(20) print(stack.peek()) # Output: 20 print(stack.pop()) # Output: 20 print(stack.peek()) # Output: 10 print(stack.size()) # Output: 2 print(stack.is_empty()) # Output: False stack.pop() stack.pop() print(stack.is_empty()) # Output: True ```","solution":"from bisect import insort class OptimizedOrderedStack: def __init__(self): self.stack = [] def push(self, item): Insert a new item into the stack maintaining the order. insort(self.stack, item) def pop(self): Remove the top element from the stack. if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): Return the top element of the stack without removing it. if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): Check if the stack is empty. return len(self.stack) == 0 def size(self): Return the number of elements in the stack. return len(self.stack)"},{"question":"Implement an Array Sorting Algorithm **Context**: You are a software engineer in a company where minimizing the number of write operations to the disk is crucial due to the hardware limitations. Your task is to sort an array of integers with minimal writes, ensuring that each element is placed in its correct position with minimal data movement. **Task**: Implement the Cycle Sort algorithm. Given an array of integers, write a function `cycle_sort(arr: List[int]) -> List[int]` that sorts the array in ascending order. Input: * A list of integers `arr` where `1 <= len(arr) <= 5000` and `-10^6 <= arr[i] <= 10^6`. Output: * The sorted list of integers. # Constraints: * You must use the Cycle Sort algorithm. * Implement the sort in-place to achieve O(1) space complexity. * Your solution should handle arrays with duplicate elements appropriately. # Example: ```python # Example 1: Input: [7, 3, 5, 1, 3, 9, 8] Output: [1, 3, 3, 5, 7, 8, 9] # Example 2: Input: [7, 3, 5, 1, 0, -2, 8] Output: [-2, 0, 1, 3, 5, 7, 8] ``` Requirements: 1. Ensure that the algorithm handles edge cases such as arrays with duplicate elements, already sorted arrays, and arrays with negative integers. 2. Minimize the number of write operations and explicitly show how you achieve this in your implementation. 3. Your implementation should be efficient enough to handle the largest constraints specified.","solution":"def cycle_sort(arr): Sort an array using Cycle Sort algorithm. This method will sort the array in ascending order and minimizes the number of writes to the list. :param arr: List[int], the input array of integers :return: List[int], the sorted array n = len(arr) # Traverse array elements and put them at the correct positions for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the correct position for the current item pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If item is already in the correct position if pos == cycle_start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Put the item to the correct position if pos != cycle_start: arr[pos], item = item, arr[pos] # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"# Question: Integer to Roman Numeral Conversion Given an integer, convert it into its corresponding Roman numeral. Your function should be able to handle integers in the range from 1 to 3999 inclusive. # Requirements: * Implement the function `convert_to_roman(n: int) -> str`. * The function should take a single integer as input and return a string representing the Roman numeral. * The input integer will always be in the range from 1 to 3999. # Example: ```python assert convert_to_roman(1) == \\"I\\" assert convert_to_roman(1994) == \\"MCMXCIV\\" assert convert_to_roman(3999) == \\"MMMCMXCIX\\" ``` # Constraints: * The input will always be a positive integer within the range from 1 to 3999. * The solution should be efficient with O(1) time complexity. # Performance: * Be mindful of the time and space complexities, ensuring that your solution runs efficiently for the given range. # Scenario: Imagine you are developing a numbering system for a digital library that uses Roman numerals for section headings and numbering. You must implement a function to convert standard integer numbers to their corresponding Roman numeral representations.","solution":"def convert_to_roman(n: int) -> str: Converts an integer to its corresponding Roman numeral representation. :param n: Integer to be converted (1 <= n <= 3999) :return: A string representing the Roman numeral # List of tuples representing Roman numerals and their integer values val = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\') ] roman_numeral = \\"\\" # Iterate through the value-symbol pairs for value, symbol in val: while n >= value: roman_numeral += symbol n -= value return roman_numeral"},{"question":"# Diffie-Hellman Key Exchange Implementation Background: Diffie-Hellman Key Exchange is a cryptographic method enabling two parties to securely share a common secret key over an unsecured channel. This method is foundational in securing communication protocols like SSL/TLS. Task: Implement a more secured version of the Diffie-Hellman Key Exchange, ensuring both `p` (prime number) and `a` (primitive root) are appropriately validated. The goal is to complete the key exchange between two parties (Alice and Bob) and verify that they generate the same shared secret key. Function Signature: ```python def diffie_hellman_key_exchange_v2(a: int, p: int) -> bool: pass ``` Input: - `a`: An integer, proposed as a primitive root. - `p`: An integer, proposed as a large prime number. Output: - Returns `True` if a common secret key is successfully generated and agreed upon by both parties, otherwise `False`. Constraints: - `2 <= p <= 10^9` - `1 <= a < p` Requirements: 1. Verify that `p` is a prime number. 2. Verify that `a` is a primitive root of `p`. 3. Generate private and public keys for both Alice and Bob. 4. Calculate and verify the shared secret key for both parties. 5. Add appropriate error handling and edge case considerations. Example: ```python # Example 1 a = 2 p = 23 result = diffie_hellman_key_exchange_v2(a, p) print(result) # Expected Output: True # Example 2 a = 10 p = 8 result = diffie_hellman_key_exchange_v2(a, p) print(result) # Expected Output: False (since 8 is not a prime) ``` Notes: - Use efficient algorithms for primality testing and primitive root checking. - Ensure robustness and performance within given constraints.","solution":"import random def is_prime(n): Return True if n is a prime number. if n == 2 or n == 3: return True if n <= 1 or n % 2 == 0: return False if n < 9: return True if n % 3 == 0: return False r = int(n**0.5) step = 2 for f in range(5, r + 1, step): if n % f == 0: return False step = 6 - step return True def gcd(a, b): while b: a, b = b, a % b return a def find_primitive_root(p): Find a primitive root for prime p if p == 2: return 1 phi = p - 1 factors = set() n = phi i = 2 while i * i <= n: while n % i == 0: factors.add(i) n //= i i += 1 if n > 1: factors.add(n) for g in range(2, p): flag = False for factor in factors: if pow(g, phi // factor, p) == 1: flag = True break if not flag: return g return -1 def diffie_hellman_key_exchange_v2(a: int, p: int) -> bool: if not is_prime(p): return False if find_primitive_root(p) != a: return False # Private keys for Alice and Bob private_key_alice = random.randint(2, p - 2) private_key_bob = random.randint(2, p - 2) # Public keys public_key_alice = pow(a, private_key_alice, p) public_key_bob = pow(a, private_key_bob, p) # Shared secret keys shared_secret_alice = pow(public_key_bob, private_key_alice, p) shared_secret_bob = pow(public_key_alice, private_key_bob, p) return shared_secret_alice == shared_secret_bob"},{"question":"# Isomorphic Strings Check Scenario: You are developing a tool that checks if two given words are structurally identical in terms of character mapping. Specifically, you must ensure that if you can transform the first word into the second word, then each character of the first word maps to exactly one character in the second word and vice versa. This transformation should preserve the order of characters. Task: Write a function `is_isomorphic` that determines if two strings `s` and `t` are isomorphic according to the constraints described. Function Signature: ```python def is_isomorphic(s: str, t: str) -> bool: ``` Input: * `s` (string): First string to compare. * `t` (string): Second string to compare. Constraints: * Both `s` and `t` are of length n where 0 <= n <= 50000. * `s` and `t` contain only ASCII characters. Output: * Returns `True` if strings `s` and `t` are isomorphic; otherwise, returns `False`. Examples: 1. **Example 1**: * **Input**: `s = \\"egg\\", t = \\"add\\"` * **Output**: `True` 2. **Example 2**: * **Input**: `s = \\"foo\\", t = \\"bar\\"` * **Output**: `False` 3. **Example 3**: * **Input**: `s = \\"paper\\", t = \\"title\\"` * **Output**: `True` Make sure your function handles edge cases such as strings of differing lengths and accurately maintains the character mapping consistency.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False map_s_to_t = {} map_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in map_s_to_t: if map_s_to_t[char_s] != char_t: return False else: map_s_to_t[char_s] = char_t if char_t in map_t_to_s: if map_t_to_s[char_t] != char_s: return False else: map_t_to_s[char_t] = char_s return True"},{"question":"# Question: Implement a class `BinaryHeap` that simulates a min heap with the following operations: 1. __Insert Method__: Insert a new element into the heap. 2. __Remove Minimum Method__: Remove the minimum element from the heap. 3. __Heapify Method__: Create a heap from an arbitrary list of elements. Function Signatures: ```python class BinaryHeap: def insert(self, val: int) -> None: pass def remove_min(self) -> int: pass def heapify(self, arr: list) -> None: pass ``` Constraints: * The `heapify` method should have a time complexity of O(N), where N is the number of elements in the input list. * All values will be integers. * The data structure should handle edge cases gracefully, such as inserting into an empty heap or removing from a heap with one element. Example Usage: ```python # Create an instance of BinaryHeap heap = BinaryHeap() # Insert elements into the heap heap.insert(5) heap.insert(3) heap.insert(8) heap.insert(1) # Remove the minimum element assert heap.remove_min() == 1 # Insert more elements heap.insert(2) # Remove the minimum element assert heap.remove_min() == 2 # Create a heap from an arbitrary list heap.heapify([9, 7, 5, 3, 1]) assert heap.remove_min() == 1 assert heap.remove_min() == 3 ``` Notes: * The `BinaryHeap` class should inherit from an abstract class `AbstractHeap` which has the following abstract methods: `perc_up`, `insert`, `perc_down`, `min_child`, and `remove_min`. * Ensure that your implementations for `insert` and `remove_min` methods maintain the min-heap property. * The `heapify` method should construct a valid min-heap from the input list.","solution":"import heapq class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val: int) -> None: Insert a new element into the heap. heapq.heappush(self.heap, val) def remove_min(self) -> int: Remove the minimum element from the heap and return it. if not self.heap: raise IndexError(\\"remove_min from empty heap\\") return heapq.heappop(self.heap) def heapify(self, arr: list) -> None: Create a heap from an arbitrary list of elements. self.heap = arr[:] heapq.heapify(self.heap)"},{"question":"# Stooge Sort Extension Challenge Stooge Sort is an inefficient comparison-based sorting algorithm primarily used for educational purposes. Given its high time complexity, it is not suitable for practical use, but it can be a great way to test your understanding of recursive functions and divide-and-conquer strategies. Problem Description You are given an array of integers that you need to sort using the Stooge Sort algorithm. However, to challenge your understanding further, modify the Stooge Sort algorithm to count and return the number of swaps made while sorting the array. Function Signature You need to implement the following function: ```python def stoogesort_with_swap_count(arr, l, h): Performs Stooge Sort on a given array segment and returns the number of swaps made. Args: arr (list): The list of integers to sort. l (int): The starting index of the segment to sort. h (int): The ending index of the segment to sort. Returns: int: The total number of swaps made during the sorting process. pass ``` Input and Output * **Input**: An integer array `arr` of length `n`. * **Output**: An integer representing the number of swaps made during the Stooge Sort process. Constraints * 1 <= n <= 1000 * -10^5 <= arr[i] <= 10^5 Examples Example 1: ``` Input: arr = [4, 3, 2, 1] Output: 6 Explanation: 6 swaps are required to make the array sorted using Stooge Sort. ``` Example 2: ``` Input: arr = [5, 3, 4, 1, 2] Output: 7 Explanation: 7 swaps are required to make the array sorted using Stooge Sort. ``` Additional Notes Consider edge cases like an already sorted array, an array with duplicate elements, or large input sizes within given constraints. Provide solid reasoning and comments in your code to demonstrate your complete understanding of the Stooge Sort algorithm and the modifications you made.","solution":"def stoogesort_with_swap_count(arr, l, h): Performs Stooge Sort on a given array segment and returns the number of swaps made. Args: arr (list): The list of integers to sort. l (int): The starting index of the segment to sort. h (int): The ending index of the segment to sort. Returns: int: The total number of swaps made during the sorting process. swaps = 0 if l >= h: return 0 # If the element at l is greater than the element at h, swap them if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] swaps += 1 # If there are more than two elements, recursively sort the first 2/3 and last 2/3 and first 2/3 again if h - l + 1 > 2: third = (h - l + 1) // 3 swaps += stoogesort_with_swap_count(arr, l, h - third) swaps += stoogesort_with_swap_count(arr, l + third, h) swaps += stoogesort_with_swap_count(arr, l, h - third) return swaps"},{"question":"Coding Assessment Question # Scenario Your colleagues have been working with large datasets recently and frequently need to get the most common elements in their data. They utilized an existing method but found it was cumbersome to use when adapting to various data types. As a result, you have been tasked to enhance the function for better flexibility and functionality. # Problem Statement Write a function `find_modes(arr)` that receives an array and returns the list of most frequent elements in the array. You should ensure it works efficiently, even for large inputs. You also need to handle different data types (integers, strings, etc.) gracefully. # Function Signature ```python def find_modes(arr: List[Union[int, str]]) -> List[Union[int, str]]: pass ``` # Input * `arr`: List of elements which can be integers or strings. The list can be empty ([]). # Output * A list of the most frequent elements. If there are multiple elements with the highest frequency, return all of them. The order of elements in the resulting list does not matter. # Constraints * The length of `arr` will not exceed 10^5. * The elements in `arr` are either all integers or all strings - not mixed. # Examples ```python assert find_modes([1, 1, 2, 2, 3, 4]) == [1, 2] assert find_modes([\\"apple\\", \\"banana\\", \\"apple\\", \\"orange\\", \\"banana\\", \\"banana\\"]) == [\\"banana\\"] assert find_modes([]) == [] assert find_modes([5]) == [5] ``` # Performance Expectations Given the constraints of the problem, the solution should handle the worst case scenario efficiently with a complexity of O(n) in terms of both time and space. # Hints - Consider using a dictionary to store element frequencies. - Ensure you handle edge cases such as empty arrays or arrays where all elements are unique.","solution":"from typing import List, Union from collections import Counter def find_modes(arr: List[Union[int, str]]) -> List[Union[int, str]]: if not arr: return [] # Count the frequency of each element in the array count = Counter(arr) # Find the maximum frequency max_freq = max(count.values()) # Get all elements that have the maximum frequency modes = [key for key, freq in count.items() if freq == max_freq] return modes"},{"question":"# Question Implement a function called `optimized_cosine_similarity` that calculates the cosine similarity between two vectors but also incorporates precomputation for scenarios where the same vectors might be used frequently. The function should handle the essential calculations just as described for `cosine_similarity`, but use precomputed norms if provided. If the norms are not provided, compute them inside the function. # Function Signature ```python def optimized_cosine_similarity(vec1, vec2, norm1=None, norm2=None): pass ``` # Input - Two lists of integers or floats `vec1` and `vec2`. - Two optional float values `norm1` and `norm2` representing the precomputed norms of `vec1` and `vec2`, respectively. # Output - A float value representing the cosine similarity between the two vectors. # Constraints - All vectors will have positive lengths. - The function should raise a `ValueError` if the two vectors have different lengths. - If provided, `norm1` and `norm2` should be non-zero. # Example ```python normalized_vec1 = [3, 4] normalized_vec2 = [4, -7] # Precompute norms norm_1 = _l2_distance(normalized_vec1) norm_2 = _l2_distance(normalized_vec2) print(optimized_cosine_similarity(normalized_vec1, normalized_vec2)) # without norms # output: -0.8553712554124616 print(optimized_cosine_similarity(normalized_vec1, normalized_vec2, norm_1, norm_2)) # with norms # output: -0.8553712554124616 ``` # Performance Requirements - The solution should maintain a time complexity of (O(n)), and it should be as efficient as possible in terms of space usage, leveraging precomputed norms where available.","solution":"import math from typing import List, Optional def l2_distance(vec: List[float]) -> float: Compute the L2 distance (Euclidean norm) of a vector. return math.sqrt(sum([x**2 for x in vec])) def optimized_cosine_similarity(vec1: List[float], vec2: List[float], norm1: Optional[float] = None, norm2: Optional[float] = None) -> float: Compute the cosine similarity between two vectors, optionally using precomputed norms. :param vec1: First vector. :param vec2: Second vector. :param norm1: Precomputed norm of the first vector. :param norm2: Precomputed norm of the second vector. :return: Cosine similarity between vec1 and vec2. :raises ValueError: If the vectors have different lengths. if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") if norm1 is None: norm1 = l2_distance(vec1) if norm2 is None: norm2 = l2_distance(vec2) if norm1 == 0 or norm2 == 0: raise ValueError(\\"Norm values must be non-zero\\") dot_product = sum([x*y for x, y in zip(vec1, vec2)]) return dot_product / (norm1 * norm2)"},{"question":"# Red-Black Tree Range Query Background The Red-Black Tree is an efficient data structure for maintaining a balanced binary search tree with logarithmic insertion, deletion, and search operations. This ensures that operations on the tree always perform within acceptable time complexities. However, sometimes specific queries on the tree, such as finding all elements within a given range, are also required. Task You are tasked with writing a function that processes the Red-Black Tree to return all elements within a specified range [low, high]. Function Signature ```python def range_query(tree: RBTree, low: int, high: int) -> list: pass ``` Input - `tree`: An instance of `RBTree`. - `low`: An integer representing the lower bound of the range (inclusive). - `high`: An integer representing the upper bound of the range (inclusive). Output - A list of integers representing the values within the specified range in ascending order. Constraints 1. The values in the Red-Black Tree are unique. 2. 0 <= low <= high <= 10^6. 3. The number of nodes in the tree is at most 10000. Example Given a tree having elements 1, 5, 7, 8, 10, 12, and the range [5, 10], the function should return [5, 7, 8, 10]. ```python rb_tree = RBTree() elements = [1, 5, 7, 8, 10, 12] for element in elements: node = RBNode(element, 1) rb_tree.insert(node) print(range_query(rb_tree, 5, 10)) # Output: [5, 7, 8, 10] ```","solution":"class RBNode: def __init__(self, key, color, left=None, right=None, parent=None): self.key = key self.color = color # 1 for red, 0 for black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL def insert(self, key): node = RBNode(key, 1) node.left = self.TNULL node.right = self.TNULL node.parent = None self._insert(node) def _insert(self, node): parent = None current = self.root while current != self.TNULL: parent = current if node.key < current.key: current = current.left else: current = current.right node.parent = parent if parent is None: self.root = node elif node.key < parent.key: parent.left = node else: parent.right = node node.color = 1 self._fix_insert(node) def _fix_insert(self, k): while k.parent and k.parent.color == 1: if k.parent == k.parent.parent.right: u = k.parent.parent.left if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.left: k = k.parent self._right_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self._left_rotate(k.parent.parent) else: u = k.parent.parent.right if u.color == 1: u.color = 0 k.parent.color = 0 k.parent.parent.color = 1 k = k.parent.parent else: if k == k.parent.right: k = k.parent self._left_rotate(k) k.parent.color = 0 k.parent.parent.color = 1 self._right_rotate(k.parent.parent) self.root.color = 0 def _left_rotate(self, x): y = x.right x.right = y.left if y.left != self.TNULL: y.left.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def _right_rotate(self, x): y = x.left x.left = y.right if y.right != self.TNULL: y.right.parent = x y.parent = x.parent if x.parent is None: self.root = y elif x == x.parent.right: x.parent.right = y else: x.parent.left = y y.right = x x.parent = y # Function to run a range query on the RBTree def range_query(self, low, high): result = [] self._range_query_helper(self.root, low, high, result) return result # Helper function for the range query def _range_query_helper(self, node, low, high, result): if node == self.TNULL: return if low < node.key: self._range_query_helper(node.left, low, high, result) if low <= node.key <= high: result.append(node.key) if high > node.key: self._range_query_helper(node.right, low, high, result) def range_query(tree: RBTree, low: int, high: int) -> list: return tree.range_query(low, high)"},{"question":"Context: You are working for a company that analyzes communication networks. To understand the structure of these networks, it is crucial to identify the strongly connected components (SCCs) in the directed graphs representing these networks. The SCCs can help in understanding clusters within the network, such as tightly-knit groups of individuals or entities. Task: Implement a function `find_sccs(graph)` that takes a directed graph as input and returns all the strongly connected components in the graph. Use Tarjan\'s algorithm to achieve this. Function Signature: ```python def find_sccs(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` Input: * `graph`: A dictionary where keys are vertex identifiers (integers) and values are lists of integers, representing the adjacency list of the graph. For example: ```python { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3] } ``` Output: * A list of lists containing the vertex identifiers in each SCC. Each SCC should be represented as a list of integers. For the example input graph, one possible output could be: ```python [ [0, 1, 2], [3, 4, 5] ] ``` Constraints: * The input graph will have at most 10^4 vertices. * The graph can contain cycles, self-loops, and may consist of multiple disconnected components. Performance Requirements: * The implementation should run in O(V + E) time complexity. * Space complexity should also be considered, keeping it within O(V). Example: ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5], 5: [3] } print(find_sccs(graph)) # Output: [[3, 4, 5], [0, 1, 2]] or [[0, 1, 2], [3, 4, 5]] ``` *Note: The order of SCCs and the order of vertices within an SCC may vary.* Edge Cases to Consider: * Graph with no edges. * Graph with a single vertex. * Graph with multiple isolated vertices. * Graph with complex nested SCCs. Implement the function ensuring that these edge cases are handled.","solution":"def find_sccs(graph): Find strongly connected components (SCCs) in a directed graph using Tarjan\'s Algorithm. Parameters: graph (Dict[int, List[int]]): A dictionary representing the adjacency list of the graph. Returns: List[List[int]]: A list of lists, each sublist contains the vertices of an SCC. index = 0 stack = [] indices = {} lowlink = {} on_stack = set() sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlink[node] = index index += 1 stack.append(node) on_stack.add(node) for neighbor in graph.get(node, []): if neighbor not in indices: # Neighbor has not been visited yet, recurse on it strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif neighbor in on_stack: # Neighbor is on the stack and hence in the current SCC lowlink[node] = min(lowlink[node], indices[neighbor]) # If node is a root node, pop the SCC from the stack if lowlink[node] == indices[node]: scc = [] while stack: n = stack.pop() on_stack.remove(n) scc.append(n) if n == node: break sccs.append(scc) for node in graph: if node not in indices: strongconnect(node) return sccs"},{"question":"You are given a list of integers `array` which is sorted in ascending order but rotated at some unknown pivot. You need to write two functions `search_rotate` and `search_rotate_recur` to find the index of a given integer `val` in this array. If `val` is found, return its index. Otherwise, return -1. Your algorithm should have a time complexity of O(log n). Function Signature 1. `search_rotate(array: List[int], val: int) -> int` 2. `search_rotate_recur(array: List[int], low: int, high: int, val: int) -> int` Input - `array`: List of integers of length `n` (1 ≤ n ≤ 1000), sorted and then rotated. - `val`: An integer for which to search in the array. Output - Return the index of the target `val` in the rotated array if found, otherwise -1. Examples 1. `search_rotate([4, 5, 6, 7, 0, 1, 2], 0)` should return `4`. 2. `search_rotate([4, 5, 6, 7, 0, 1, 2], 3)` should return `-1`. 3. `search_rotate_recur([4, 5, 6, 7, 0, 1, 2], 0, 6, 1)` should return `5`. 4. `search_rotate_recur([4, 5, 6, 7, 0, 1, 2], 0, 6, 8)` should return `-1`. Notes - Consider using an iterative approach for `search_rotate` and a recursive approach for `search_rotate_recur`. - Ensure you handle edge cases such as single element arrays correctly. - Do not use Python\'s built-in `index()` method. Constraints - You must implement the solution with a time complexity of O(log n).","solution":"from typing import List def search_rotate(array: List[int], val: int) -> int: low, high = 0, len(array) - 1 while low <= high: mid = low + (high - low) // 2 if array[mid] == val: return mid if array[low] <= array[mid]: # left half is sorted if array[low] <= val < array[mid]: high = mid - 1 else: low = mid + 1 else: # right half is sorted if array[mid] < val <= array[high]: low = mid + 1 else: high = mid - 1 return -1 def search_rotate_recur(array: List[int], low: int, high: int, val: int) -> int: if low > high: return -1 mid = low + (high - low) // 2 if array[mid] == val: return mid if array[low] <= array[mid]: # left half is sorted if array[low] <= val < array[mid]: return search_rotate_recur(array, low, mid - 1, val) else: return search_rotate_recur(array, mid + 1, high, val) else: # right half is sorted if array[mid] < val <= array[high]: return search_rotate_recur(array, mid + 1, high, val) else: return search_rotate_recur(array, low, mid - 1, val)"},{"question":"# Nearest Neighbor Classification Given the implementation of the nearest neighbor algorithm provided, your task is to complete and optimize the `nearest_neighbor_improved` function. This function should classify an input vector `x` by finding the nearest neighbor within a given training set `tSet` (dictionary where keys are tuples representing feature vectors and values are respective labels). # Requirements: - Function Name: `nearest_neighbor_improved` - Arguments: * `x`: A tuple representing the feature vector to classify. * `tSet`: A dictionary where keys are tuples representing training feature vectors, and values are their respective labels. - Returns: The label of the nearest neighbor\'s vector in the training set. # Constraints: 1. Ensure input vectors are of the same length. 2. Handle scenarios where the training set is empty or contains elements of varying lengths. # Input Format: - `x` : `(float, float, ..., float)` – Tuple with the feature vector to classify. - `tSet` : `{(float, float, ..., float): str, ...}` – Dictionary representing the training data. # Output Format: - `str` – The label of the nearest neighbor. # Performance Requirements: - Optimize the distance calculation. - Ensure the function handles edge cases and error scenarios gracefully. # Scenario: You are working on an image recognition system where each image is represented as a feature vector. You need to classify a new image based on its feature vector by finding the most similar image within the already labeled training set. # Example: ```python def test_nearest_neighbor_improved(): x = (1.0, 2.0, 1.5) tSet = { (1.0, 2.0, 1.0): \'cat\', (2.0, 3.0, 2.0): \'dog\', (0.0, 1.0, 0.5): \'mouse\' } assert nearest_neighbor_improved(x, tSet) == \'cat\' test_nearest_neighbor_improved() ``` Complete the `nearest_neighbor_improved` function considering the above requirements and constraints.","solution":"import math def euclidean_distance(v1, v2): Calculate and return the Euclidean distance between two vectors. return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def nearest_neighbor_improved(x, tSet): Classify the input vector x by finding the nearest neighbor in tSet. Arguments: x -- A tuple representing the feature vector to classify. tSet -- A dictionary where keys are tuples representing training feature vectors, and values are the respective labels. Returns: The label of the nearest neighbor\'s vector in the training set. if not tSet: raise ValueError(\\"Training set is empty\\") nearest_label = None min_distance = float(\'inf\') for vector, label in tSet.items(): if len(vector) != len(x): raise ValueError(\\"Inconsistent vector lengths between input vector and training set\\") distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Context: As the head of a cybersecurity project, you need to develop an encryption system using the RSA algorithm. The primary focus is designing a robust key generation mechanism while ensuring encryption and decryption of data works seamlessly based on the generated keys. # Task: You are required to implement the RSA key generation function and the corresponding encryption and decryption functions in Python. The pre-implemented functions for prime generation and modular exponentiation are given, but their performance is not optimal. Your job includes optimizing and refining these functions. # Specifications: 1. **Function Signature**: - `def generate_key(k: int, seed: int = None) -> tuple:` - `def encrypt(data: int, e: int, n: int) -> int:` - `def decrypt(data: int, d: int, n: int) -> int:` 2. **Input/Output**: - **generate_key**: - Input: Integer `k` representing the number of bits in `n`; Optional integer `seed` for randomization. - Output: Tuple of integers `(n, e, d)` representing the RSA keys. - **encrypt**: - Input: Integer `data` to be encrypted, integers `e` and `n` (public keys). - Output: Integer representing encrypted data. - **decrypt**: - Input: Integer encrypted `data`, integers `d` and `n` (private keys). - Output: Integer representing decrypted original data. 3. **Constraints**: - `data` must be a non-negative integer less than `n`. - `k` must be sufficient to generate secure keys (e.g., at least 16 bits). - Ensure optimized computation and correct handling of edge cases. # Optimization Requirements: 1. Use efficient prime-checking algorithms like Miller-Rabin for `is_prime`. 2. Implement the Extended Euclidean Algorithm for modular inverses. # Example Usage: ```python # Generate keys n, e, d = generate_key(16) # Sample data to encrypt data = 42 # Encrypt the data encrypted_data = encrypt(data, e, n) # Decrypt the data decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data ``` # Deliverables: Submit the implementation of the three functions ensuring the encryption and decryption process work correctly and efficiently. Test thoroughly with edge cases and performance considerations.","solution":"import random from sympy import isprime from math import gcd def generate_large_prime(bits): while True: p = random.getrandbits(bits) if isprime(p): return p def mod_inverse(e, phi): gcd, x, y = extended_gcd(e, phi) if gcd != 1: raise Exception(\'Modular inverse does not exist\') else: return x % phi def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def generate_key(k, seed=None): if seed is not None: random.seed(seed) half_k = k // 2 p = generate_large_prime(half_k) q = generate_large_prime(half_k) while p == q: q = generate_large_prime(half_k) n = p * q phi = (p - 1) * (q - 1) e = 65537 while gcd(e, phi) != 1: e = random.randint(2, phi - 1) d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Question: Integer Partition Count **Scenario**: Given a positive integer `n`, write a function to compute the number of ways `n` can be partitioned into sums of non-negative integers. This problem is fundamental in combinatorial mathematics and has varied applications, including in optimization and theoretical computer science. **Function Signature**: ```python def partition_count(n: int) -> int: Calculate the number of ways to partition the integer n into non-negative integers. :param n: Positive integer to be partitioned. :return: Number of possible partitions. ``` **Input**: - A single integer `n` where ( 1 leq n leq 1000 ). **Output**: - An integer representing the number of ways to partition `n`. **Constraints**: - Optimize the function to run in ( O(n^2) ) time and use ( O(n^2) ) space. - Consider edge cases such as the smallest possible input. **Examples**: 1. Input: `4` - Output: `5` - Explanation: Possible partitions are `4`, `3+1`, `2+2`, `2+1+1`, `1+1+1+1`. 2. Input: `7` - Output: `15` - Explanation: Examples of partitions include `7`, `6+1`, `5+2`, `4+3`, `4+2+1`, etc. **Additional Notes**: - Ensure the solution handles large values efficiently (e.g., near the upper constraint limit). - Document the function to explain the dynamic programming approach and how the 2D array is utilized.","solution":"def partition_count(n: int) -> int: Calculate the number of ways to partition the integer n into non-negative integers. :param n: Positive integer to be partitioned. :return: Number of possible partitions. # Initialize a 2D list to store the number of ways to partition dp = [[0] * (n + 1) for _ in range(n + 1)] # There\'s exactly one way to partition 0: with the empty partition for i in range(n + 1): dp[i][0] = 1 # Populate the dp table such that dp[i][j] means: # the number of ways to partition j using integers up to i for i in range(1, n + 1): for j in range(1, n + 1): if j >= i: dp[i][j] = dp[i-1][j] + dp[i][j-i] else: dp[i][j] = dp[i-1][j] return dp[n][n]"},{"question":"You are tasked with implementing a module that converts between integers and byte arrays using two endian formats: big-endian and little-endian. Your implementation should handle conversion for 64-bit unsigned integers. Write the following functions in Python: 1. `int_to_bytes_big_endian(num: int) -> bytes` 2. `int_to_bytes_little_endian(num: int) -> bytes` 3. `bytes_big_endian_to_int(bytestr: bytes) -> int` 4. `bytes_little_endian_to_int(bytestr: bytes) -> int` Function Descriptions: * **int_to_bytes_big_endian(num)**: * **Input**: An integer `num` (0 <= num < 2^64) * **Output**: A byte representation of `num` in big-endian format. * **int_to_bytes_little_endian(num)**: * **Input**: An integer `num` (0 <= num < 2^64) * **Output**: A byte representation of `num` in little-endian format. * **bytes_big_endian_to_int(bytestr)**: * **Input**: A byte array `bytestr` where the bytes are ordered in big-endian format. * **Output**: The corresponding integer. * **bytes_little_endian_to_int(bytestr)**: * **Input**: A byte array `bytestr` where the bytes are ordered in little-endian format. * **Output**: The corresponding integer. Constraints: * The integer values are non-negative and within 64-bit unsigned range. * Do not use built-in libraries that handle byte conversion (e.g., `int.to_bytes()` or `int.from_bytes()`). Performance Requirements: * Space and time complexity should be O(N), where N is the number of bytes.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its big-endian byte representation. result = bytearray(8) for i in range(8): result[7 - i] = num & 0xFF num >>= 8 return bytes(result) def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its little-endian byte representation. result = bytearray(8) for i in range(8): result[i] = num & 0xFF num >>= 8 return bytes(result) def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte representation to its integer value. result = 0 for i in range(8): result = (result << 8) | bytestr[i] return result def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte representation to its integer value. result = 0 for i in range(7, -1, -1): result = (result << 8) | bytestr[i] return result"},{"question":"Design a data structure called `RandomizedSetOptimized` that supports the following operations efficiently in O(1) average time complexity: 1. **insert(val)**: Inserts the item `val` into the set if it is not already present. Returns `True` if insert was successful, otherwise return `False`. 2. **remove(val)**: Removes the item `val` from the set if it is present. Returns `True` if remove was successful, otherwise return `False`. 3. **get_random()**: Returns a random element from the current set of elements. Each element must have the same probability of being returned. Implement the `RandomizedSetOptimized` class with the following methods, fulfilling the performance constraints mentioned. # Input and Output * **input**: * `insert(val: int) -> bool` * `remove(val: int) -> bool` * `get_random() -> int` * **output**: * `True` or `False` for `insert` and `remove`. * an integer element for `get_random`. # Constraints * `val` can be an integer within the range of `-10^9` to `10^9`. * At most `2*10^4` calls will be made to the insert, remove, and get_random methods. # Example ```python # Example 1 rs = RandomizedSetOptimized() print(rs.insert(1)) # Expected output: True print(rs.insert(1)) # Expected output: False print(rs.insert(2)) # Expected output: True print(rs.remove(1)) # Expected output: True print(rs.remove(1)) # Expected output: False print(rs.get_random()) # Expected output: 2 # Example 2 rso = RandomizedSetOptimized() print(rso.insert(10)) # Expected Output: True print(rso.insert(20)) # Expected Output: True print(rso.remove(10)) # Expected Output: True print(rso.insert(10)) # Expected Output: True print(rso.get_random()) # Expected Output: 10 or 20 ``` Note Ensure to handle edge cases such as operations on an empty set or trying to delete elements that do not exist in the set.","solution":"import random class RandomizedSetOptimized: def __init__(self): self.data = [] self.data_map = {} def insert(self, val: int) -> bool: if val in self.data_map: return False self.data_map[val] = len(self.data) self.data.append(val) return True def remove(self, val: int) -> bool: if val not in self.data_map: return False last_element = self.data[-1] idx_to_remove = self.data_map[val] # Move the last element to the place idx_to_remove self.data[idx_to_remove] = last_element self.data_map[last_element] = idx_to_remove # Remove the last element from list self.data.pop() del self.data_map[val] return True def get_random(self) -> int: return random.choice(self.data)"},{"question":"# Problem: Strongly Connected Components in a Directed Graph Scenario You are given a directed graph, and you need to find its strongly connected components (SCCs). Two nodes are in the same SCC if there is a path in both directions between them. Task Implement a function `find_sccs(graph)` that takes a directed graph represented as an adjacency list and returns a list of lists, where each inner list contains the nodes of a single SCC. Function Signature ```python def find_sccs(graph: Dict[int, List[int]]) -> List[List[int]]: ``` Input - `graph`: A dictionary where keys are integers representing nodes and values are lists representing the directed edges from the key node. Output - A list of lists of integers, where each inner list denotes a strongly connected component. Constraints - The graph contains at least 1 node and at most 10000 nodes. - The number of edges is also bounded by 10000. Example ```python graph = { 0: [1], 1: [2], 2: [0, 3], 3: [4], 4: [5, 7], 5: [6], 6: [4], 7: [8], 8: [7] } print(find_sccs(graph)) # Output could be: [[0, 1, 2], [3], [4, 5, 6], [7, 8]] ``` Explanation - Nodes `0`, `1`, and `2` form one SCC because each can reach each other. - Node `3` forms its own SCC since it has no back edges to itself. - Nodes `4`, `5`, and `6` form another SCC. - Nodes `7` and `8` form yet another SCC.","solution":"def find_sccs(graph): Finds all the strongly connected components in a directed graph. Parameters: graph (dict): A dictionary where keys are integers representing nodes and values are lists representing the directed edges from the key node. Returns: list: A list of lists where each inner list denotes a strongly connected component. index = 0 stack = [] indices = {} lowlinks = {} on_stack = {} sccs = [] def strongconnect(node): nonlocal index indices[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in graph[node]: if neighbor not in indices: strongconnect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack[neighbor]: lowlinks[node] = min(lowlinks[node], indices[neighbor]) if lowlinks[node] == indices[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) for node in graph: if node not in indices: strongconnect(node) return sccs"},{"question":"# Clone an Undirected Graph You have been provided a class `UndirectedGraphNode` that represents a node in an undirected graph and three functions: `clone_graph1`, `clone_graph2`, and `clone_graph`. Each function is an implementation of cloning an undirected graph using different traversal algorithms (BFS and DFS). Your task is to implement a function `clone_graph_with_custom_order` to clone an undirected graph using a specific custom visit order. The custom visit order is given as a list of node labels, dictating the sequence in which nodes should be visited and copied. # Function Signature ```python def clone_graph_with_custom_order(node: \'UndirectedGraphNode\', visit_order: List[int]) -> \'UndirectedGraphNode\': pass ``` # Input - `node` is the starting node of the graph to be cloned. - `visit_order` is a list of integer labels representing the custom order in which nodes should be visited and cloned. # Output - Returns the starting node of the cloned graph. # Constraints - Node labels are unique and non-negative integers. - The graph may contain cycles. - `visit_order` will contain all node labels present in the graph. # Example **Input:** ```python n0 = UndirectedGraphNode(0) n1 = UndirectedGraphNode(1) n2 = UndirectedGraphNode(2) n0.neighbors = [n1, n2] n1.neighbors = [n2] n2.neighbors = [n2] visit_order = [0, 1, 2] clone_graph_with_custom_order(n0, visit_order) ``` **Output:** - A new graph starting from a node with the label `0`, maintaining the same structure but created by visiting nodes in the order `[0, 1, 2]`. **Note:** - Pay special attention to cycles within the graph. - Verify that the custom visit order is respected during cloning. # Clarifications - You may assume that if the `visit_order` contains a node which appears isolated due to the traversal sequence, it should still be visited and cloned as instructed. - You may use provided helper methods and classes directly in your implementation or create additional ones if necessary.","solution":"from typing import List class UndirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] def clone_graph_with_custom_order(node: \'UndirectedGraphNode\', visit_order: List[int]) -> \'UndirectedGraphNode\': if not node: return None label_to_node = {node.label: node} stack = [node] while stack: n = stack.pop() for neighbor in n.neighbors: if neighbor.label not in label_to_node: label_to_node[neighbor.label] = neighbor stack.append(neighbor) clones = {label: UndirectedGraphNode(label) for label in visit_order} for label in visit_order: original_node = label_to_node[label] cloned_node = clones[label] cloned_node.neighbors = [clones[neighbor.label] for neighbor in original_node.neighbors if neighbor.label in clones] return clones[visit_order[0]]"},{"question":"# Question: Computing Extended GCD and LCM with Additional Functionalities You are tasked to design a comprehensive function suite to compute the Greatest Common Divisor (GCD), Least Common Multiple (LCM), and the number of trailing zeros in the binary form of a number. Additionally, you are to compute the GCD using bitwise operations for optimization. - **Input**: - Two integers `a` and `b` for GCD and LCM computation. - A single integer `x` for trailing zero computation. - **Output**: - An integer representing the GCD of `a` and `b`. - An integer representing the LCM of `a` and `b`. - An integer representing the number of trailing zeros in the binary form of `x`. - An integer representing the GCD of `a` and `b` computed using bitwise operations. - **Constraints**: - `a, b` should be positive integers. - `x` should be a non-negative integer. - The computation of LCM should be in terms of the absolute value. - Consider edge cases for any zero input values. Function Signatures: ```python def gcd(a: int, b: int) -> int: pass def lcm(a: int, b: int) -> int: pass def trailing_zero(x: int) -> int: pass def gcd_bit(a: int, b: int) -> int: pass ``` Example: ```python print(gcd(8, 12)) # Output: 4 print(lcm(8, 12)) # Output: 24 print(trailing_zero(40)) # Output: 3 print(gcd_bit(8, 12)) # Output: 4 ``` Performance Requirements: - Ensure your functions are optimized for large integer values. - Minimize division operations where possible. - Validate input to handle edge cases gracefully. Implement these functions in Python and ensure they pass basic test cases provided in the problem statements above.","solution":"def gcd(a: int, b: int) -> int: Compute the GCD of two integers using the Euclidean algorithm. while b: a, b = b, a % b return a def lcm(a: int, b: int) -> int: Compute the LCM of two integers using their GCD. The formula is: lcm(a, b) = abs(a*b) // gcd(a, b) return abs(a * b) // gcd(a, b) def trailing_zero(x: int) -> int: Count the number of trailing zeros in the binary representation of x. if x == 0: return 0 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count def gcd_bit(a: int, b: int) -> int: Compute the GCD of two integers using bitwise operations. if a == 0: return b if b == 0: return a # Finding common factors of 2 k = trailing_zero(a | b) a >>= trailing_zero(a) while b != 0: b >>= trailing_zero(b) if a > b: a, b = b, a b -= a return a << k"},{"question":"# Moving Average of Stream of Integers Context: Imagine you are given a stream of integers representing data from a live monitoring system. You need to maintain the average of the last `n` elements from this stream efficiently. To achieve this, you are required to implement a data structure that can process these stream values in real-time. Task: Implement a class `MovingAverage` that calculates the moving average of the last `n` values in a sliding window of integers. Your implementation should support the following operations: 1. **Initialization (`__init__(self, size: int) -> None`)**: Initialize the `MovingAverage` object with a window size. 2. **Adding a new value (`next(self, val: int) -> float`)**: Process a new integer value and return the moving average of the last `n` values. # Example: ```python m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.66667 print(m.next(5)) # Output: 6.0 ``` The instantiation `m = MovingAverage(3)` initializes the moving average with a window size of 3. - Adding value `1` results in an average of `1`. - Adding value `10` results in an average of `(1 + 10) / 2 = 5.5`. - Adding value `3` results in an average of `(1 + 10 + 3) / 3 = 4.66667`. - Adding value `5` removes `1` (since the window is size 3), and the average becomes `(10 + 3 + 5) / 3 = 6`. Constraints: - The window size `n` is a positive integer between 1 and 1000 inclusive. - All input values will be in the range of `-10^5` to `10^5`. - Each `next` call will process the new value in O(1) time given optimal summation and size considerations. Your task is to complete the `MovingAverage` class to satisfy the requirements as specified.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage object with a window size. self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Process a new integer value and return the moving average of the last `n` values. if len(self.queue) >= self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"Merging Multiple Sorted Linked Lists You are given an array of `k` sorted linked lists. Each linked list is represented by its head node. Your task is to merge these `k` sorted linked lists into one sorted linked list and return its head. Input: - `lists` (List[Node]): An array of `k` head nodes of the sorted linked lists. Output: - `Node`: The head node of the merged and sorted linked list. Constraints: - The total number of nodes across all linked lists won\'t exceed `10000`. - The value of `k` is such that `1 <= k <= 1000`. - Each node value is between `-10^4` and `10^4`. Performance Requirements: Your solution should be efficient with respect to time and space complexity. # Function Signature: ```python class Node: def __init__(self, x): self.val = x self.next = None def merge_k_lists(lists: List[Node]) -> Node: pass ``` Example: Example 1: ```plaintext Input: lists = [1->4->5, 1->3->4, 2->6] Output: 1->1->2->3->4->4->5->6 ``` Example 2: ```plaintext Input: lists = [] Output: None ``` Example 3: ```plaintext Input: lists = [[]] Output: None ``` Notes: - You can use the provided `Node` class for the implementation. - Consider the edge cases such as when some linked lists are empty or there is only one linked list. - Aim for an efficient solution that leverages appropriate data structures for managing the node comparisons and merges.","solution":"import heapq class Node: def __init__(self, x): self.val = x self.next = None def merge_k_lists(lists): Merge k sorted linked lists and return the head of the merged sorted list. min_heap = [] # Initialize the heap with the head of the linked lists for i, node in enumerate(lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = Node(0) current = dummy while min_heap: value, index, node = heapq.heappop(min_heap) current.next = Node(value) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, index, node.next)) return dummy.next"},{"question":"# Question You are required to implement the `optimized_counting_sort` function which sorts an array of integers, possibly containing negative numbers, using an optimized version of Counting Sort. # Function Signature ```python def optimized_counting_sort(arr: List[int]) -> List[int]: Sorts the given array of integers using an optimized version of Counting Sort. :param arr: List[int] - the array of integers to sort, can contain negative numbers. :return: List[int] - the sorted array. ``` # Input * `arr`: List of integers (it can include negative numbers) # Output * The function should return a new list of integers that is the sorted version of `arr`. # Constraints * The size of the array `arr` will be between 0 and 10^6. * The elements in `arr` will be between -10^6 and 10^6. # Performance Requirements * The implementation should have a time complexity of O(n + k) where `n` is the number of elements and `k` is the range of the input numbers. * The implementation uses auxiliary space of O(k). # Example ```python # Example 1 print(optimized_counting_sort([5, 2, 9, -3, -1, 7])) # Output: [-3, -1, 2, 5, 7, 9] # Example 2 print(optimized_counting_sort([3, 1, 2, 0, -1, -2])) # Output: [-2, -1, 0, 1, 2, 3] ``` # Explanation - **Example 1**: The algorithm adjusts for negative numbers and sorts the array correctly. - **Example 2**: The algorithm sorts the array including handling cases where the minimum integer is negative. **Note**: Ensure your implementation efficiently handles large arrays with a wide range of integers.","solution":"from typing import List def optimized_counting_sort(arr: List[int]) -> List[int]: Sorts the given array of integers using an optimized version of Counting Sort. :param arr: List[int] - the array of integers to sort, can contain negative numbers. :return: List[int] - the sorted array. if not arr: return [] # Find the range of the numbers min_val = min(arr) max_val = max(arr) # Range of numbers range_of_elements = max_val - min_val + 1 # Create count array count_array = [0] * range_of_elements # Store the count of each element for num in arr: count_array[num - min_val] += 1 # Store the cumulative count for i in range(1, range_of_elements): count_array[i] += count_array[i - 1] # Place the elements in sorted order output_array = [0] * len(arr) for num in reversed(arr): output_array[count_array[num - min_val] - 1] = num count_array[num - min_val] -= 1 return output_array"},{"question":"Implement an Efficient Counting Sort Function **Objective**: You are required to implement an efficient sorting function using the Counting Sort algorithm. Your function should handle arrays with potentially negative integers and return a sorted array. **Function Signature**: ```python def efficient_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input & Output: - **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^5` and all elements lie within the range `-10^6` to `10^6`. - **Output**: A list of integers sorted in non-decreasing order. # Constraints: 1. You must handle arrays that include negative numbers. 2. The provided array will not be empty. 3. Aim to achieve an optimal time complexity close to O(n + k) and space complexity with respect to k. # Example: ```python Example 1: Input: arr = [4,2,2,8,3,3,1] Output: [1,2,2,3,3,4,8] Example 2: Input: arr = [-1, -2, -3, -4, 0, 1, 2, 3] Output: [-4, -3, -2, -1, 0, 1, 2, 3] Example 3: Input: arr = [1, 4, 1, 2, 7, 5, 2] Output: [1, 1, 2, 2, 4, 5, 7] Example 4: Input: arr = [1000000, 999999, -1000000, -999999] Output: [-1000000, -999999, 999999, 1000000] ``` # Performance Requirements: 1. Your implementation should be able to sort arrays of length up to 100,000 within a reasonable time frame. 2. Adjust for the range of values within the provided constraints efficiently.","solution":"def efficient_counting_sort(arr): Sorts an array using the Counting Sort algorithm, accommodating negative values. if not arr: return [] # Find the range of the input array min_val = min(arr) max_val = max(arr) # Create a count array with the size of the range of values in the input list range_size = max_val - min_val + 1 count = [0] * range_size # Store the count of each element in the count array for num in arr: count[num - min_val] += 1 # Reconstruct the sorted list sorted_arr = [] for i, cnt in enumerate(count): sorted_arr.extend([i + min_val] * cnt) return sorted_arr"},{"question":"You are working with very large vectors that are sparse, meaning they contain many zeros. To store these vectors efficiently and compute their dot product, you need to implement the following functions: 1. **vector_to_index_value_list(vector)**: Convert a given vector into a list of index-value pairs, excluding zero elements. 2. **dot_product(iv_list1, iv_list2)**: Calculate the dot product of two vectors represented as index-value lists. # Function Signatures ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: pass def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: pass ``` # Input 1. **vector**: A list of floats representing a sparse vector. 2. **iv_list1, iv_list2**: Lists of tuples where each tuple contains an index and a float value, representing the non-zero elements of the sparse vectors. # Output 1. **vector_to_index_value_list**: A list of tuples with the index and value of non-zero elements from the input vector. 2. **dot_product**: A float representing the dot product of two sparse vectors. # Constraints - The length of the vectors can be very large (up to (10^6)). - The vectors are highly sparse, with up to 99% of elements being zero. - Ensure your solution is optimized for both time and space complexity. # Example ```python vector1 = [1., 0., 0., 2.] vector2 = [0., 2., 1., 0.] iv_list1 = vector_to_index_value_list(vector1) # [(0, 1.0), (3, 2.0)] iv_list2 = vector_to_index_value_list(vector2) # [(1, 2.0), (2, 1.0)] result = dot_product(iv_list1, iv_list2) print(result) # Output should be 0.0 ``` # Notes - Consider edge cases where the vectors are empty or contain no non-zero elements. - Ensure the dot product function handles vectors of different lengths correctly. Good luck!","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Convert a given vector into a list of index-value pairs, excluding zero elements. return [(i, val) for i, val in enumerate(vector) if val != 0.0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Calculate the dot product of two vectors represented as index-value lists. index_map1 = {index: value for index, value in iv_list1} index_map2 = {index: value for index, value in iv_list2} common_indices = set(index_map1.keys()).intersection(set(index_map2.keys())) return sum(index_map1[idx] * index_map2[idx] for idx in common_indices)"},{"question":"Context You are provided with a dictionary mapping digits to letters (just like on the telephone buttons). Write a function to generate all possible letter combinations that a given digit string could represent. Function Signature ```python def letter_combinations(digits: str) -> List[str]: ``` Input * `digits` (str): A string containing digits (2-9) inclusive. Output * `List[str]`: A list of all possible letter combinations that the input digit string could represent. Constraints * The input string will be non-empty with length between 1 and 4. * Digits will be between \'2\' and \'9\' inclusive. Example ```python Input: \\"23\\" Output: [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] ``` Requirements * Implement an efficient solution considering the constraints. * Handle edge cases correctly, such as an empty input. * Maintain a clean code structure and comment on key parts.","solution":"from typing import List def letter_combinations(digits: str) -> List[str]: if not digits: return [] # Mapping of digits to corresponding letters on telephone buttons. digit_to_char = { \'2\': \'abc\', \'3\': \'def\', \'4\': \'ghi\', \'5\': \'jkl\', \'6\': \'mno\', \'7\': \'pqrs\', \'8\': \'tuv\', \'9\': \'wxyz\' } def backtrack(index: int, path: str): # If the path length is the same as digits, we have a complete combination if index == len(digits): combinations.append(path) return # Get the letters corresponding to the current digit possible_letters = digit_to_char[digits[index]] for letter in possible_letters: backtrack(index + 1, path + letter) combinations = [] backtrack(0, \\"\\") return combinations"},{"question":"# Matrix Transformation Challenge In this coding challenge, you are required to implement a function to transform a given matrix by rotating it 180 degrees. The transformation should maintain the matrix\'s elements, but rearrange them such that the matrix appears to have been rotated 180 degrees. Input Format * A list of lists, where each sub-list represents a row in a 2D matrix. Output Format * A new list of lists representing the transformed matrix. Example # Input ``` matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] ``` # Output ``` [[9, 8, 7], [6, 5, 4], [3, 2, 1]] ``` Constraints * The matrix will always have at least one element. * Elements of the matrix are integers. Function Signature ```python def rotate_180(matrix: List[List[int]]) -> List[List[int]]: pass ``` Notes Think carefully about how to rearrange the elements. Consider the indices and how they should map from the original matrix to the new matrix. Provide a comprehensive solution that works efficiently for small as well as large matrices. Your implementation should handle edge cases such as non-square and 1x1 matrices appropriately.","solution":"from typing import List def rotate_180(matrix: List[List[int]]) -> List[List[int]]: Rotates the given matrix by 180 degrees. # Rotate the matrix by reversing the rows and then reversing each row return [row[::-1] for row in matrix[::-1]]"},{"question":"# Coding Challenge: Robust Path Joining Function As a software developer, you need to develop a function that ensures proper joining of base paths (URLs or filesystem paths) and their suffixes. This function must normalize the slashes between the base and suffix while considering both common and edge cases. Requirements: 1. The function should take two strings as input: - **base**: A base URL or filesystem path. - **suffix**: A suffix to be appended to the base. 2. The function should output a normalized path string by: - Removing any trailing slashes from the base. - Removing any leading slashes from the suffix. - Joining the two components with a single slash. 3. Handle edge cases such as: - Empty strings for either base or suffix. - Multiple consecutive slashes within the inputs. Function Signature: ```python def join_paths(base: str, suffix: str) -> str: pass ``` Input Constraints: - Both `base` and `suffix` are non-null strings. - Length of `base`, `suffix` <= 1000. Output Format: - A single string representing the normalized combined path. Example: ```python # Example 1 print(join_paths(\\"path/to/dir\\", \\"file\\")) # Expected Output: \\"path/to/dir/file\\" # Example 2 print(join_paths(\\"path/to/dir/\\", \\"/file\\")) # Expected Output: \\"path/to/dir/file\\" # Example 3 print(join_paths(\\"\\", \\"file\\")) # Expected Output: \\"file\\" # Example 4 print(join_paths(\\"http://algorithms.com/\\", \\"part\\")) # Expected Output: \\"http://algorithms.com/part\\" ``` Implement the function so it meets the above requirements effectively and efficiently.","solution":"def join_paths(base: str, suffix: str) -> str: Joins a base path with a suffix ensuring proper normalization of slashes between them. Args: - base (str): The base path (e.g., URL or filesystem path). - suffix (str): The suffix to be appended to the base. Returns: - str: Normalized combined path. if not base: return suffix.lstrip(\'/\') if not suffix: return base.rstrip(\'/\') base = base.rstrip(\'/\') suffix = suffix.lstrip(\'/\') return f\\"{base}/{suffix}\\""},{"question":"# Comb Sort Implementation and Optimization Challenge **Scenario**: Comb Sort is an improvement on Bubble Sort, often giving better performance by initially comparing elements far apart and allowing them to move across a greater distance. You have been tasked to not only implement Comb Sort but also to optimize it for the best possible performance for average use cases. **Task**: 1. Implement the Comb Sort algorithm as described in the provided analysis. 2. Optimize your implementation for better performance using any of the following: - Experiment with different values for the shrink factor. - Optimize the gap calculations. - Any other valid optimization techniques you find effective. **Function Specifications**: * **Function Name**: `optimized_comb_sort` * **Input**: A list of integers `arr` where `1 <= len(arr) <= 10^5`. * **Output**: The sorted list of integers in non-decreasing order. **Constraints**: * You must use in-place sorting (modify the input list). * Aim to minimize the worst-case runtime complexity. * Your implementation should handle large datasets efficiently. **Example**: ```python def optimized_comb_sort(arr): # Your optimized code here arr = [5, 3, 8, 4, 2] print(optimized_comb_sort(arr)) # Output: [2, 3, 4, 5, 8] large_arr = [i for i in range(100000, 0, -1)] print(optimized_comb_sort(large_arr)) # Output: [1, 2, 3, ..., 100000] ``` Focus on achieving the best possible performance for average use cases and provide a brief explanation of any optimizations you implemented and why they work.","solution":"def optimized_comb_sort(arr): Performs an optimized comb sort on the given list of integers. n = len(arr) gap = n # initial gap size shrink = 1.3 # shrink factor sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False return arr"},{"question":"# Question: Longest Substring without Repeating Characters **Scenario & Context:** You are working on a text processing application where it’s critical to identify the longest segments of text without any repeating characters. This is to ensure data integrity and uniqueness in dynamically generated keys. **Task:** Write a function that accepts a string as input and returns the length of the longest substring without repeating characters, along with the actual substring. **Function Signature:** ```python def find_longest_unique_substring(s: str) -> (int, str): pass ``` # Input - `s` (str): The input string which may contain any valid ASCII characters. # Output - A tuple `(int, str)`: The first element is the length of the longest unique substring, and the second element is the longest substring itself. # Constraints - The function should handle strings of arbitrary length up to reasonable memory constraints. - Execution time should be optimized to handle large strings efficiently. # Example ```python assert find_longest_unique_substring(\\"abcabcbb\\") == (3, \\"abc\\") assert find_longest_unique_substring(\\"bbbbb\\") == (1, \\"b\\") assert find_longest_unique_substring(\\"pwwkew\\") == (3, \\"wke\\") assert find_longest_unique_substring(\\"\\") == (0, \\"\\") assert find_longest_unique_substring(\\"abcdefg\\") == (7, \\"abcdefg\\") ``` # Requirements 1. **Edge Cases**: Handle cases where the input string is empty or contains all identical characters effectively. 2. **Performance**: Ensure the function performs efficiently with O(n) complexity. 3. **Correctness**: Avoid errors arising from incorrect index updates or character set handling. **Bonus**: Can you optimize your solution to handle very large inputs without significant performance degradation?","solution":"def find_longest_unique_substring(s: str) -> (int, str): Returns the length of the longest substring without repeating characters, along with the actual substring. char_index_map = {} longest = 0 start = 0 longest_substring = \\"\\" for end in range(len(s)): char = s[end] if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = end if end - start + 1 > longest: longest = end - start + 1 longest_substring = s[start:end+1] return longest, longest_substring"},{"question":"Context: You are developing a new integrated development environment (IDE) and need to implement a feature that checks if the code has balanced parentheses, braces, and brackets. This is critical before further syntax and semantic analysis can proceed, ensuring the code structure is properly organized. Problem Statement: Write a function `is_code_valid(code: str) -> bool` that determines whether a given string containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', is a valid sequence. This means every opening character must have a corresponding closing character in the correct order. Function Signature: ```python def is_code_valid(code: str) -> bool: ``` Input: - A single string `code` containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. - Length of string `code` will be in the range `[0, 10^4]`. Output: - Return `True` if the input string is valid, `False` otherwise. Examples: ```python assert is_code_valid(\\"()\\") == True assert is_code_valid(\\"()[]{}\\") == True assert is_code_valid(\\"(]\\") == False assert is_code_valid(\\"([)]\\") == False assert is_code_valid(\\"{[]}\\") == True ``` Constraints: - An empty string is considered valid. Requirements: - Handle all edge cases as described in the analysis. - Ensure the implementation is efficient with a time complexity of O(n) and space complexity of O(n).","solution":"def is_code_valid(code: str) -> bool: stack = [] matching_parentheses = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in code: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return False else: return False return stack == []"},{"question":"# Task: Reversing a Subsection of a Singly Linked List You are provided with a singly linked list and two integer positions `m` and `n` (1-based). Your task is to reverse the linked list from position `m` to `n`. Maintain the rest of the list as is. # Input * The head of the singly linked list. * Two integers `m` and `n` representing the start and end positions for reversal. # Output * The head of the modified list after reversing the segment from `m` to `n`. # Constraints * 1 <= m <= n <= length of the list * The list contains at least one node. * Optimize for O(n) time complexity. # Example **Input**: ``` List: 1 -> 2 -> 3 -> 4 -> 5 m = 2, n = 4 ``` **Output**: ``` List: 1 -> 4 -> 3 -> 2 -> 5 ``` # Implementation Details Implement the function `reverse_subsection_list(head, m, n)`: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_subsection_list(head, m, n): :type head: ListNode :type m: int :type n: int :rtype: ListNode pass ``` 1. Traverse the list to the m-th node. 2. Reverse the nodes from m to n. 3. Reconnect the reversed segment back to the rest of the list. 4. Return the head of the modified list. Ensure to handle edge cases such as the reversal impacting the head node and the scenario where m equals n (no reversal needed).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_subsection_list(head, m, n): Reverses a subsection of a singly linked list from position m to n (1-based). :type head: ListNode :type m: int :type n: int :rtype: ListNode if m == n: return head dummy = ListNode(0) dummy.next = head prev = dummy # Move prev to the node just before the start of the section to reverse for _ in range(m - 1): prev = prev.next # Start will point to the first node in the section to be reversed start = prev.next # Then will point to the node that will be reversed then = start.next # Reverse the section from m to n for _ in range(n - m): start.next = then.next then.next = prev.next prev.next = then then = start.next return dummy.next"},{"question":"# Pangram Checker Optimization Challenge You are given the task of optimizing the pangram check algorithm. The original algorithm iterates through each character in the English alphabet and checks if that character is present in the input string. Your job is to implement a more efficient version of this algorithm using data structures that provide faster membership testing and allow early termination when possible. Problem Statement Write a function `optimized_check_pangram(input_string: str) -> bool` that checks if a given string is a pangram. The function should efficiently verify that the string contains every letter of the English alphabet at least once. Input * A single string `input_string` containing any printable characters. Output * Return `True` if the input string is a pangram, otherwise return `False`. Constraints * The input string will have a maximum length of 10^5 characters. * The input string can contain spaces, punctuation, and numbers, which should be ignored. * The check should be case-insensitive. Performance Requirements * The solution should work efficiently even for the largest input sizes. Example 1. `optimized_check_pangram(\\"The quick brown fox jumps over the lazy dog\\")` should return `True`. 2. `optimized_check_pangram(\\"Sphinx of black quartz, judge my vow\\")` should return `True`. 3. `optimized_check_pangram(\\"Hello World\\")` should return `False`. Special Notes * Focus on using appropriate data structures such as sets to enhance performance. * Consider the possibility of early termination once the pangram condition has been met.","solution":"def optimized_check_pangram(input_string: str) -> bool: Check if the input string is a pangram. A pangram is a sentence containing every letter of the English alphabet at least once. alphabet_set = set(\'abcdefghijklmnopqrstuvwxyz\') input_set = set(input_string.lower()) # Remove non-alphabetic characters from the set input_set = {char for char in input_set if char.isalpha()} return alphabet_set.issubset(input_set)"},{"question":"# Question: Implement an Extended Radix Sort with Custom Digit Length Radix Sort is a sorting algorithm that sorts numbers based on their individual digits. The stable and efficient nature of Radix Sort for large datasets with known ranges makes it particularly useful. # Task: You are to extend the radix sort algorithm to allow it to handle numbers of custom digit lengths and sort them not in base 10 but in a base specified by the user. Implement the function `custom_radix_sort(arr, base, digit_length)` which sorts the input list of non-negative integers `arr` in ascending order by their digits in the specified base and for a given digit length. Function Signature: ```python def custom_radix_sort(arr: List[int], base: int, digit_length: int) -> List[int]: pass ``` Input: - `arr`: A list of non-negative integers. - `base`: An integer representing the base in which the sorting is to be applied (greater than 1). - `digit_length`: An integer specifying the maximum digit length in this base for the given problem context. Output: - Returns a list of integers sorted in ascending order. Constraints: - You should handle typical edge cases such as empty lists and all identical elements. - Assume all numbers in `arr` fits within the given `digit_length` when expressed in the provided `base`. - You should not use Python\'s built-in sort functions or `sorted()` method. Example: ```python >>> custom_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], 10, 3) [2, 24, 45, 66, 75, 90, 170, 802] >>> custom_radix_sort([12, 3, 345, 23, 1, 234], 8, 3) [1, 3, 12, 23, 234, 345] ``` Ensure your implementation is efficient and passes the performance benchmarks for the given constraints. **Note**: You may assume that the digit_length provided is sufficient to express all the numbers in the array in the specified base.","solution":"def custom_radix_sort(arr, base, digit_length): Sort a list of integers based on their digits in a specified base using Radix Sort. Parameters: arr (List[int]): List of non-negative integers to be sorted. base (int): The base in which the sorting should be applied. digit_length (int): The number of digits to consider for each number in the specified base. Returns: List[int]: The sorted list of integers. def counting_sort(arr, exp, base): n = len(arr) output = [0] * n count = [0] * base for i in range(n): index = (arr[i] // exp) % base count[index] += 1 for i in range(1, base): count[i] += count[i - 1] for i in range(n - 1, -1, -1): index = (arr[i] // exp) % base output[count[index] - 1] = arr[i] count[index] -= 1 for i in range(n): arr[i] = output[i] exp = 1 for _ in range(digit_length): counting_sort(arr, exp, base) exp *= base return arr"},{"question":"You are tasked to implement a classic coding problem known as \\"FizzBuzz\\" with an additional challenge. Given a positive integer N, return a list containing the integers from 1 to N, replacing: * Multiples of 3 with the string \\"Fizz\\". * Multiples of 5 with the string \\"Buzz\\". * Multiples of both 3 and 5 with the string \\"FizzBuzz\\". **However**, you are required to implement this in a way that optimizes space usage, replacing the need to store the entire result list in memory. Your function should ideally use a constant amount of extra space, i.e., O(1) additional space complexity. # Input * An integer `N` where `N >= 1`. # Output * A list of integers and/or strings according to the rules described above. # Constraints * The function should handle values of N up to (10^6). * **Performance requirement**: Your solution should run efficiently even for large values of N. # Example **Input**: ```python N = 15 ``` **Output**: ```python [1, 2, \'Fizz\', 4, \'Buzz\', \'Fizz\', 7, 8, \'Fizz\', \'Buzz\', 11, \'Fizz\', 13, 14, \'FizzBuzz\'] ``` # Function Signature ```python def fizzbuzz_optimized(N: int) -> list: pass ``` # Notes * You must not use more than O(1) additional space beyond the input and output. * Think carefully about how you can emit the results without storing them all at once.","solution":"def fizzbuzz_optimized(N): Returns a list of integers from 1 to N, where multiples of 3 are replaced with \\"Fizz\\", multiples of 5 with \\"Buzz\\", and multiples of both 3 and 5 with \\"FizzBuzz\\". result = [] for i in range(1, N + 1): if i % 15 == 0: result.append(\'FizzBuzz\') elif i % 3 == 0: result.append(\'Fizz\') elif i % 5 == 0: result.append(\'Buzz\') else: result.append(i) return result"},{"question":"**Problem Statement**: You are given a `n x n` matrix (square matrix) with integer values. Your task is to write a function `matrix_transformations` that performs multiple matrix transformations: rotating 90 degrees clockwise, rotating 90 degrees counterclockwise, inverting across the top left diagonal, and inverting across the bottom left diagonal. # Input - An integer `n` (1 ≤ n ≤ 100) representing the number of rows and columns of the matrix. - A 2D list `matrix` of integers with size `n x n`. # Output - Return a dictionary with four keys: - `clockwise`: the matrix after rotating 90 degrees clockwise. - `counterclockwise`: the matrix after rotating 90 degrees counterclockwise. - `top_left_invert`: the matrix after inverting across the top left diagonal. - `bottom_left_invert`: the matrix after inverting across the bottom left diagonal. # Example ```python def matrix_transformations(n, matrix): ... # Example Case matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] result = matrix_transformations(3, matrix) print(result[\'clockwise\']) # Output: # [[7, 4, 1], # [8, 5, 2], # [9, 6, 3]] print(result[\'counterclockwise\']) # Output: # [[3, 6, 9], # [2, 5, 8], # [1, 4, 7]] print(result[\'top_left_invert\']) # Output: # [[1, 4, 7], # [2, 5, 8], # [3, 6, 9]] print(result[\'bottom_left_invert\']) # Output: # [[9, 6, 3], # [8, 5, 2], # [7, 4, 1]] ``` # Constraints - Your solution should not exceed ( O(n^2) ) time complexity. - You must implement the function `matrix_transformations` to meet the specified performance. # Notes - You may assume that the matrix will always be a perfect square matrix with dimensions `n x n`. Good luck and happy coding!","solution":"def matrix_transformations(n, matrix): def rotate_clockwise(mat): return [[mat[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_counterclockwise(mat): return [[mat[j][n - i - 1] for j in range(n)] for i in range(n)] def invert_top_left(mat): return [[mat[j][i] for j in range(n)] for i in range(n)] def invert_bottom_left(mat): return [[mat[n - j - 1][n - i - 1] for j in range(n)] for i in range(n)] transformations = { \'clockwise\': rotate_clockwise(matrix), \'counterclockwise\': rotate_counterclockwise(matrix), \'top_left_invert\': invert_top_left(matrix), \'bottom_left_invert\': invert_bottom_left(matrix) } return transformations"},{"question":"# House Robber Problem with Enhanced Challenge You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, but the only constraint stopping you from robbing each of them is that adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money at each house, determine the maximum amount of money you can rob tonight without alerting the police. Additionally, to make the problem more challenging, let\'s extend it to a circular street where the first house is next to the last house. You need to adapt the existing algorithm to account for this scenario. **Function Signature:**: ```python def house_robber_circular(houses: List[int]) -> int: # Your implementation here pass ``` # Input: * A list of non-negative integers, `houses`, where `houses[i]` represents the amount of money at the i-th house. # Output: * An integer representing the maximum amount of money you can rob without alerting the police. # Constraints: 1. The number of houses (`n`) will not exceed 10^4. 2. The amount of money in any house will not exceed 10^4. # Example: ```python # Example 1: houses = [2, 3, 2] house_robber_circular(houses) # Output: 3 # Example 2: houses = [1, 2, 3, 1] house_robber_circular(houses) # Output: 4 # Example 3: houses = [] house_robber_circular(houses) # Output: 0 ``` **Explanation**: - Example 1: Robbing house 1 or house 3 results in the maximum amount of 3. - Example 2: Robbing house 2 and house 4 results in the maximum amount of 4. - Example 3: No houses to rob, so the output is 0. # Additional Notes: - Think about how you can reuse the previous linear solution to handle the circular street case. - Consider breaking the problem into simpler sub-problems (e.g., rob houses from 1 to n-1 or from 2 to n) and then find the maximum profit from these scenarios.","solution":"from typing import List def house_robber_linear(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] prev1, prev2 = 0, 0 for house in houses: current = max(house + prev2, prev1) prev2 = prev1 prev1 = current return prev1 def house_robber_circular(houses: List[int]) -> int: if not houses: return 0 if len(houses) == 1: return houses[0] # Calculate maximum money by excluding the first house or the last house return max(house_robber_linear(houses[:-1]), house_robber_linear(houses[1:]))"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: Custom implementation of Monomial and Polynomial classes. * **Type**: Data Structure for representing and manipulating mathematical expressions. * **Main Purpose**: Allow operations like addition, subtraction, multiplication, division, and substitution on monomials and polynomials. # Complexity * **Time Complexity**: * Monomial operations (addition, subtraction, multiplication, division) - O(n), where n is the number of variables. * Polynomial operations - O(m * n), where m and n are the number of monomials in the polynomials being operated on. * **Space Complexity**: O(m * k), where m is the number of monomials and k is the number of variables in each monomial. # Principles * **Core Operational Steps**: * Each monomial is represented by a dictionary of variables and their corresponding powers. * Arithmetic operations are implemented to handle variable matching and coefficient manipulation. * Polynomials are represented as sets of monomials, with operations designed to manage these sets and perform arithmetic. # Characteristics & Applications * **Properties**: * Arithmetic operations consider variable exponents. * Supports rational numbers using Python\'s Fraction class. * Ensures operations maintain mathematical integrity (e.g., monomial addition only valid for same variables). * **Common Use Cases**: Algebraic manipulation in computer algebra systems, symbolic mathematics calculations, polynomial arithmetic operations. * **Strengths/Limitations**: * **Strengths**: * Handles a wide range of arithmetic operations. * Supports fractional coefficients. * Designed to reject invalid operations to ensure mathematical correctness. * **Limitations**: * Limited to basic arithmetic operations; does not support operations like polynomial factorization. * Performance could degrade with very large polynomials or many variables. # Implementation Challenges * **Edge Cases**: * Handling empty monomials/polynomials. * Operations with zero coefficients. * Ensuring valid state after operations. * **Performance Bottlenecks**: * Multiplication and division on high-degree polynomials. * Managing memory with large polynomial expressions. * **Error Scenarios**: * Invalid operations between non-comparable monomials. * Division by zero in monomial coefficients. * **Optimization Points**: * Simplify inner loops for large operations. * Memoization for repeated operations on the same polynomials. <|Analysis End|> <|Question Begin|> # Polynomial Arithmetic You are provided with custom implementations for Monomial and Polynomial classes, representing mathematical terms and expressions respectively. Each monomial consists of variables raised to powers, while polynomials are collections of such monomials. Your task is to implement a new function for the Polynomial class that returns the derivative of the polynomial with respect to a given variable. # Function Signature ```python def derivative(self, var: int) -> Polynomial: Compute the derivative of the polynomial with respect to the given variable. :param var: The variable with respect to which to differentiate. :return: A new Polynomial object representing the derivative. ``` # Input - `var`: An integer representing the variable index (e.g., `1` for (a_1)). # Output - Returns a `Polynomial` object representing the derivative. # Constraints - The polynomial and monomials adhere to the structure provided in the Monomial and Polynomial classes. - The variable must exist in at least one of the monomials of the polynomial. # Requirements - Implement the `derivative` function within the `Polynomial` class. - Correctly handle derivative rules, particularly the power rule. - Ensure output is simplified by eliminating any zero coefficients or unnecessary terms. # Examples ```python p = Polynomial([ Monomial({1:3}, 4), Monomial({2:2}, -1.5), Monomial({1:1, 2:1}, 2), Fraction(3,7) ]) print(p.derivative(1)) # Expected Output: Polynomial([Monomial({1:2}, 12), Monomial({1:0, 2:1}, 2)]) p2 = Polynomial([ Monomial({1:2}, 6), Monomial({1: 1}, 4), ]) print(p2.derivative(1)) # Expected Output: Polynomial([Monomial({1:1}, 12), Monomial({}, 4)]) ``` 1. **Initialization**: Initialize variables and collections as needed for the calculations. 2. **Power Rule Application**: Apply the power rule for each monomial component. 3. **Coefficient Multiplication**: Adjust coefficients based on the power reduction. 4. **Simplification**: Ensure the output is simplified with no zero terms. # Notes - The focus is on correctly applying mathematical principles to derive accurate results. - Assume basic operations (addition, multiplication, etc.) on Monomial and Polynomial are available. - Polynomials with no remaining terms after differentiation should return a polynomial equivalent to zero. |Question End|>","solution":"from fractions import Fraction from typing import List, Dict class Monomial: def __init__(self, variables: Dict[int, int], coefficient: Fraction): self.variables = variables # Dictionary where key is variable and value is its exponent self.coefficient = coefficient def __repr__(self): return f\\"{self.coefficient} * \\" + \\" * \\".join([f\\"{var}^{exp}\\" for var, exp in self.variables.items()]) def derivative(self, var: int): if var in self.variables and self.variables[var] > 0: new_coeff = self.coefficient * self.variables[var] new_vars = self.variables.copy() if new_vars[var] == 1: del new_vars[var] else: new_vars[var] -= 1 return Monomial(new_vars, new_coeff) else: return None class Polynomial: def __init__(self, monomials: List[Monomial]): self.monomials = monomials # List of Monomial objects def __repr__(self): return \\" + \\".join([mon.__repr__() for mon in self.monomials]) def derivative(self, var: int) -> \'Polynomial\': new_monomials = [] for monomial in self.monomials: derived_monomial = monomial.derivative(var) if derived_monomial is not None and derived_monomial.coefficient != 0: new_monomials.append(derived_monomial) if not new_monomials: return Polynomial([Monomial({}, Fraction(0))]) return Polynomial(new_monomials)"},{"question":"# Priority Queue Improvement You are given a class `PriorityQueue` that implements a priority queue using a linear array. Your task is to improve its performance by re-implementing it using a binary heap. The priority queue should still support the same operations (`push` and `pop`). # Function Signatures ```python class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority) def size(self): Return size of the priority queue return len(self.priority_queue_list) def push(self, item, priority): Push the item in the queue with the given priority. pass def pop(self): Remove and return the item with the highest priority. pass ``` # Requirements 1. **Push**: This should insert the item into the priority queue while maintaining the heap property. 2. **Pop**: This should remove and return the item with the highest priority while maintaining the heap property. # Constraints - You may assume that the input will consist solely of integers and the priority will also be an integer. - Handle the case when pop is called on an empty queue gracefully by raising an appropriate exception. # Example ```python pq = PriorityQueue() pq.push(\\"task1\\", 2) pq.push(\\"task2\\", 1) pq.push(\\"task3\\", 5) print(pq.pop()) # Should print: task3 print(pq.pop()) # Should print: task1 print(pq.pop()) # Should print: task2 ``` **Note**: Ensure your implementation is efficient and handles edge cases as discussed.","solution":"class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) def __lt__(self, other): return self.priority > other.priority # max-heap class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority) def size(self): Return size of the priority queue return len(self.priority_queue_list) def push(self, item, priority): Push the item in the queue with the given priority. heapq.heappush(self.priority_queue_list, PriorityQueueNode(item, priority)) def pop(self): Remove and return the item with the highest priority. if not self.priority_queue_list: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self.priority_queue_list).data import heapq import itertools"},{"question":"# Problem: Modified Climbing Stairs You are climbing a staircase that requires `steps` number of steps to reach to the top. However, you can take 1, 2, or 3 steps at a time. Write a function `climb_stairs_modified` that computes the number of distinct ways you can reach to the top. Function Signature: ```python def climb_stairs_modified(steps: int) -> int: ``` Input: * `steps` (int): A positive integer representing the total number of steps to climb to the top. Output: * (int): The number of distinct ways to reach the top. Constraints: * The function should handle large values of `steps` efficiently. * Your solution must use O(1) additional space. Example: ```python climb_stairs_modified(3) # Returns 4 climb_stairs_modified(4) # Returns 7 ``` Explanation: For `steps = 3`, you have the following distinct ways: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 4. 3 steps For `steps = 4`, you have the following distinct ways: 1. 1 step + 1 step + 1 step + 1 step 2. 1 step + 1 step + 2 steps 3. 1 step + 2 steps + 1 step 4. 2 steps + 1 step + 1 step 5. 2 steps + 2 steps 6. 1 step + 3 steps 7. 3 steps + 1 step Implement the `climb_stairs_modified` function considering efficiency in both time and space.","solution":"def climb_stairs_modified(steps): Compute the number of distinct ways to reach the top of a staircase where you can take 1, 2, or 3 steps at a time. if steps == 0: return 0 if steps == 1: return 1 if steps == 2: return 2 if steps == 3: return 4 a, b, c = 1, 2, 4 for _ in range(4, steps + 1): a, b, c = b, c, a + b + c return c"},{"question":"# Question You are provided with a 2D grid of characters representing a map of \'1\'s (land) and \'0\'s (water). Your task is to write a function `num_islands` to determine the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You must ensure all four edges of the grid are surrounded by water. Function Signature: ```python def num_islands(grid: List[List[str]]) -> int: ``` Input: - `grid`: A 2D list of characters where \'1\' represents land and \'0\' represents water. Output: - Returns an integer representing the number of distinct islands. Constraints: - The input grid is guaranteed to be a rectangular matrix. - The grid dimensions will be at most 300x300. Examples: Example 1: ```python grid = [ [\'1\',\'1\',\'1\',\'1\',\'0\'], [\'1\',\'1\',\'0\',\'1\',\'0\'], [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'0\',\'0\',\'0\',\'0\',\'0\'] ] assert num_islands(grid) == 1 ``` Example 2: ```python grid = [ [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'1\',\'1\',\'0\',\'0\',\'0\'], [\'0\',\'0\',\'1\',\'0\',\'0\'], [\'0\',\'0\',\'0\',\'1\',\'1\'] ] assert num_islands(grid) == 3 ``` Note: Be mindful of edge cases like empty grids, grids with only water, or grids with a single line of land or water.","solution":"def num_islands(grid): Returns the number of islands in the given grid. if not grid: return 0 def dfs(x, y): # If out of bounds or at a water cell, return if x < 0 or x >= len(grid) or y < 0 or y >= len(grid[0]) or grid[x][y] == \'0\': return # Mark the cell as visited by setting it to \'0\' grid[x][y] = \'0\' # Run DFS on all four adjacent cells dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == \'1\': count += 1 dfs(i, j) return count"},{"question":"You are given an integer `a` and a non-negative integer `n`. Your task is to implement a function that computes `a^n` using the method of binary exponentiation or exponentiation by squaring. Implement both iterative and recursive versions of the algorithm. If a modulo `mod` is provided (a positive integer), return the result of `a^n % mod`. Function Signatures: ```python def iterative_power(a: int, n: int, mod: int = None) -> int: # implementation here pass def recursive_power(a: int, n: int, mod: int = None) -> int: # implementation here pass ``` Input: - `a` (integer): Base of the exponentiation. - `n` (non-negative integer): Exponent. - `mod` (optional, positive integer): A modulus value. Output: - Returns the result of `a^n` or `a^n % mod`. Constraints: 1. `1 <= a <= 10^5` 2. `0 <= n <= 10^9` 3. `1 <= mod <= 10^9` (if provided) Example: ```python iterative_power(3, 5) # returns 243 (since 3^5 = 243) iterative_power(2, 10, 1000) # returns 24 (since 2^10 % 1000 = 1024 % 1000 = 24) recursive_power(3, 4) # returns 81 (since 3^4 = 81) recursive_power(2, 10, 16) # returns 0 (since 2^10 % 16 = 1024 % 16 = 0) ``` Notes: 1. Ensure to handle large values efficiently using binary exponentiation. 2. Validate edge cases such as `n = 0` and `n = 1`.","solution":"def iterative_power(a: int, n: int, mod: int = None) -> int: result = 1 base = a while n > 0: if n % 2 == 1: result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result def recursive_power(a: int, n: int, mod: int = None) -> int: if n == 0: return 1 half_power = recursive_power(a, n // 2, mod) half_power = (half_power * half_power) % mod if mod else half_power * half_power if n % 2 != 0: return (half_power * a) % mod if mod else half_power * a return half_power"},{"question":"# Problem: Optimized Matrix Operation You are tasked with implementing a variation of matrix multiplication that leverages sparsity for optimization. Sparse matrices are a type of matrix where most of the elements are zero. Given two sparse matrices, the goal is to multiply them efficiently by avoiding unnecessary multiplications involving zeroes. **Task**: Implement the function `sparse_multiply(matA: dict, matB: dict, n: int) -> dict` that multiplies two sparse matrices. The sparse matrices will be represented by dictionaries where keys are tuples `(i, j)` indicating the positions of non-zero elements, and values are the corresponding non-zero elements. The matrices are square and of size `n x n`. **Input**: - `matA` (dict): Dictionary representation of sparse matrix A. - `matB` (dict): Dictionary representation of sparse matrix B. - `n` (int): The dimension of the matrices. **Output**: - Returns a dictionary that represents the resulting sparse matrix after multiplication. **Constraints**: - The size of matrices (n) will be between 1 and 1000. - The matrices can have up to 1000 non-zero elements. **Example**: ```python matA = {(0, 0): 1, (0, 1): 2} matB = {(0, 1): 3, (1, 0): 4} n = 2 # Expected output {(0, 1): 3, (0, 0): 8} print(sparse_multiply(matA, matB, n)) ``` **Notes**: - You must ensure your solution handles matrices efficiently, considering the sparsity and avoiding unnecessary operations. - Clearly handle scenarios where resulting matrix elements are zero and should be omitted from the dictionary representation. - Pay attention to performance constraints.","solution":"def sparse_multiply(matA: dict, matB: dict, n: int) -> dict: Multiplies two sparse matrices efficiently and returns the result as a sparse matrix. Parameters: - matA (dict): Dictionary representation of sparse matrix A. - matB (dict): Dictionary representation of sparse matrix B. - n (int): The dimension of the matrices. Returns: - dict: Sparse matrix result of the multiplication. result = {} for (i, k_A), value_A in matA.items(): for (k_B, j), value_B in matB.items(): if k_A == k_B: # Ensure the inner indices are the same if (i, j) not in result: result[(i, j)] = 0 result[(i, j)] += value_A * value_B # Remove zero entries from the result result = {key: value for key, value in result.items() if value != 0} return result"},{"question":"**Context**: You are working on a text processing application that needs to validate if certain text blocks follow a given pattern. The pattern and text blocks have specific requirements for formatting, and ensuring this consistency is crucial for subsequent parsing steps. **Task**: Implement a function `does_follow_pattern(pattern: str, text: str) -> bool` that determines if the given text follows the specific pattern. Function Signature: ```python def does_follow_pattern(pattern: str, text: str) -> bool: ``` Input - `pattern`: a string consisting only of lowercase letters. - `text`: a string consisting of lowercase words separated by single spaces. Output - Returns `True` if `text` follows the same pattern as `pattern`. - Returns `False` otherwise. Constraints - Assume pattern contains only lowercase letters, and text contains lowercase words separated by a single space. - The length of the pattern and the number of words in the text should be equal for the pattern to match. Example ```python assert does_follow_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert does_follow_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert does_follow_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == False assert does_follow_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` **Note**: Consider edge cases such as empty strings, unequal lengths between pattern and text, and multiple mappings of pattern characters to different words.","solution":"def does_follow_pattern(pattern: str, text: str) -> bool: words = text.split() if len(pattern) != len(words): return False pattern_to_word = {} word_to_pattern = {} for p, w in zip(pattern, words): if p in pattern_to_word: if pattern_to_word[p] != w: return False if w in word_to_pattern: if word_to_pattern[w] != p: return False pattern_to_word[p] = w word_to_pattern[w] = p return True"},{"question":"You are tasked with writing a function that finds all numbers within a specified range that exhibit a unique property: when each digit of the number is raised to the power corresponding to its position (starting from 1), the sum of these powered digits equals the original number. For example, 89 is such a number because (8^1 + 9^2 = 89). # Function Signature ```python def sum_dig_pow(low: int, high: int) -> list: ``` # Input - `low` (int): The lower boundary of the range (inclusive). - `high` (int): The upper boundary of the range (inclusive). # Output - Returns a list of integers within the range [low, high] that satisfy the described property. # Constraints - (1 leq low leq high leq 10^6) # Example ```python assert sum_dig_pow(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sum_dig_pow(1, 100) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] assert sum_dig_pow(50, 150) == [89, 135] ``` # Additional Notes - Your solution should aim to be as efficient as possible due to the potentially large input range. - Consider edge cases such as ranges where no numbers satisfy the property, and very small or very large ranges. # Testing Ensure your implementation passes a variety of test cases that include: - Small ranges with several results. - Large ranges with few results. - Edge cases where the range limits (low and high) are very close or identical.","solution":"def sum_dig_pow(low: int, high: int) -> list: Returns a list of numbers within the range [low, high] where each digit of the number raised to the power corresponding to its position (starting from 1) sums up to the number itself. result = [] for num in range(low, high + 1): str_num = str(num) sum_of_powers = sum(int(digit) ** (index + 1) for index, digit in enumerate(str_num)) if sum_of_powers == num: result.append(num) return result"},{"question":"You are working on a vending machine software that needs to compute the number of ways a specific amount of change can be returned using an infinite supply of given coin denominations. Implement a function `count_change_ways` that takes a list of coin denominations and a target value, and returns the number of ways to make the given value using these coin denominations. # Function Signature ```python def count_change_ways(coins: List[int], value: int) -> int: pass ``` # Input - `coins` (List[int]): A list of integers where each integer represents the denomination of a coin. - `value` (int): An integer representing the total amount of change to make. # Output - Returns an integer representing the number of ways to make the change for the given `value` using the supplied coin denominations. # Constraints - 0 <= value <= 10^6 - 1 <= len(coins) <= 100 - 1 <= coins[i] <= 10^6 # Example Input: ```python coins = [1, 2, 3] value = 4 ``` Output: ```python 4 ``` Explanation: There are four ways to make the change for 4 units using [1, 2, 3]: - [1, 1, 1, 1] - [1, 1, 2] - [2, 2] - [1, 3] # Notes 1. Consider edge cases such as: - `value` = 0 (should return 1 as there\'s only one way to make zero amount with no coins). - Empty coin array where there are no ways to make change except for the zero amount. - Coins whose denomination is larger than the `value`. 2. Ensure the solution has a time complexity of O(n * m) and a space complexity of O(n) as detailed in the initial algorithm.","solution":"def count_change_ways(coins, value): Computes the number of ways a specific amount of change can be made using the given coin denominations. Args: coins (List[int]): List of coin denominations. value (int): The target value to make using the coins. Returns: int: Number of ways to make the target value. # Initialize DP array where dp[i] will be storing the number of ways to make amount i dp = [0] * (value + 1) # There is one way to make the amount 0 dp[0] = 1 # Iterate over each coin for coin in coins: for amount in range(coin, value + 1): dp[amount] += dp[amount - coin] return dp[value]"},{"question":"You are given a linked list, and your task is to determine if there is a cycle in it. To determine this, you must implement the \\"Floyd\'s Tortoise and Hare\\" algorithm which uses a two-pointer technique. Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head): :type head: Node :rtype: bool pass ``` Expected Input and Output * **Input**: A singly linked list represented by its head node. * The `Node` class definition is provided. * Each node has an integer value (`val`) and a pointer to the next node (`next`). * **Output**: A boolean value * Return `True` if the list has a cycle. * Return `False` otherwise. Constraints * The number of nodes in the list is between 0 and 10^4. * The values of the nodes are integers in the range [-10^5, 10^5]. # Example Consider the function testing with the following examples: 1. **Example 1**: * Input: head is a linked list with nodes [3, 2, 0, -4], where the cycle starts back at head.next. * Output: True (since there is a cycle). 2. **Example 2**: * Input: head is a linked list with nodes [1, 2], where the cycle starts back at head. * Output: True (since there is a cycle). 3. **Example 3**: * Input: head is a linked list with nodes [1], with no cycle. * Output: False (since there is no cycle). # Additional Notes * Optimize for both time and space. * Ensure that modification of the linked list structure is avoided during the cycle detection process. * Consider edge cases such as empty linked list or a single node with no next pointer.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head): Determines if a linked list has a cycle using Floyd\'s Tortoise and Hare algorithm. :type head: Node :rtype: bool if head is None: return False slow = head fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"**Question**: You have been given a class definition for a binary tree node and a task: Design the function `max_height` that takes the root node of a binary tree and returns its maximum depth. The function should handle edge cases appropriately, such as an empty tree. # Input Format: - A binary tree root node where each node contains integer values. # Output Format: - Return an integer representing the maximum depth of the tree. # Constraints: - The binary tree node class provided has attributes `val`, `left`, and `right`. Example: Consider the following binary tree: ``` 10 / 12 15 / / 25 30 36 100 ``` Function Call: ```python root = TreeNode(10) root.left = TreeNode(12) root.right = TreeNode(15) root.left.left = TreeNode(25) root.left.left.right = TreeNode(100) root.left.right = TreeNode(30) root.right.left = TreeNode(36) print(max_height(root)) ``` Expected Output: ``` 4 ``` # Explanation: 1. The longest path is `10 -> 12 -> 25 -> 100`. There are 4 nodes, hence the depth is 4.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_height(root): Returns the maximum depth of the binary tree rooted at `root`. if root is None: return 0 else: left_height = max_height(root.left) right_height = max_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Cocktail Shaker Sort Implementation Background: You are given an array of integers and are required to sort it in ascending order. You need to implement the Cocktail Shaker Sort algorithm, an improvement upon the basic Bubble Sort that traverses the array in both directions to push both largest and smallest elements into their sorted positions more effectively. Task: Write a function `cocktail_shaker_sort(arr: list) -> list` that implements the Cocktail Shaker Sort algorithm to sort an array of integers. Input: - A single list `arr` of integers. (0 ≤ len(arr) ≤ 1000) Output: - A list of integers sorted in non-decreasing order. Requirements: - Your implementation must be an in-place sort (should not use additional storage beyond a constant amount of extra space). - Your function must handle edge cases appropriately, including empty arrays and arrays with only one element. Example: ```python def cocktail_shaker_sort(arr: list) -> list: Sort the given list using the Cocktail Shaker Sort algorithm. def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True while swapped: swapped = False for i in range(1, n): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True if swapped == False: break swapped = False for i in range(n-1,0,-1): if arr[i - 1] > arr[i]: swap(i - 1, i) swapped = True return arr # Example Usage: # Input: [3, 0, 2, 5, -1, 4, 1] # Output: [-1, 0, 1, 2, 3, 4, 5] print(cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1])) # Output: [-1, 0, 1, 2, 3, 4, 5] ``` Constraints: - Ensure the function correctly handles edge cases like empty or singleton arrays. Consider the computational complexity and aim to achieve an efficient implementation.","solution":"def cocktail_shaker_sort(arr: list) -> list: Sort the given list using the Cocktail Shaker Sort algorithm. def swap(i, j): arr[i], arr[j] = arr[j], arr[i] n = len(arr) swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: swap(i, i + 1) swapped = True if not swapped: break swapped = False end -= 1 # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: swap(i, i - 1) swapped = True start += 1 return arr"},{"question":"**Title**: Determine Bipartiteness of a Graph using BFS **Objective**: Write a function to determine whether a given undirected graph is bipartite. **Prompt**: You are given an undirected graph as an adjacency list. A graph is called bipartite if its vertices can be divided into two disjoint and independent sets U and V such that every edge connects a vertex in U to one in V. Your task is to determine if the given graph is bipartite. **Function Signature**: ```python def is_bipartite(graph: List[List[int]]) -> bool: pass ``` **Input**: - `graph`: A list of lists, where `graph[i]` contains the list of vertices adjacent to vertex `i`. **Output**: - Return `True` if the graph is bipartite, otherwise return `False`. **Constraints**: - The number of vertices (n) in the graph will be in the range [1, 1000]. - The number of edges will be at most 10^5. - The graph has no self-loops or multiple edges. **Example**: ```python assert is_bipartite([[1,3], [0,2], [1,3], [0,2]]) == True # (Graph can be divided into {0,2} and {1,3}) assert is_bipartite([[1,2,3], [0,2], [0,1,3], [0,2]]) == False # (Graph cannot be divided as required) ``` **Explanation**: 1. In the first example, vertices are divided into two sets: {0,2} and {1,3} and no edges exist within the same set. 2. In the second example, vertex 0 is connected to vertices 1, 2, and 3 making it impossible to divide it into two sets where no two connected vertices are in the same set. **Notes**: - Use BFS to determine the bipartiteness of the graph. - Enumerate all vertices since the graph might be disconnected.","solution":"from collections import deque from typing import List def is_bipartite(graph: List[List[int]]) -> bool: # Initial color of each vertex, -1 indicates uncolored color = [-1] * len(graph) # Process each component of the graph for start in range(len(graph)): if color[start] == -1: # unvisited node queue = deque([start]) color[start] = 0 # Start coloring the first node with color 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: # If the neighbor has not been colored # Assign the neighbor the opposite color color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighbor has same color return False return True"},{"question":"# Longest Common Prefix **Given**: An array of strings containing N strings, each of length M. **Objective**: Write a function to find the longest common prefix (LCP) string amongst an array of strings. **Function Signature**: ```python def longest_common_prefix(strs: List[str]) -> str: ``` **Input**: * An array of N (0 <= N <= 10^5) strings, each with a maximum length M (0 <= M <= 200). **Output**: * A single string that represents the longest common prefix amongst the array of strings. * If no common prefix exists, return an empty string. **Constraints**: * Do not use Python\'s built-in string functions that might trivialize the solution (e.g., `startswith()`, `commonprefix()` from `os.path`, etc.) **Examples**: 1. **Example 1**: * **Input**: `[\\"flower\\",\\"flow\\",\\"flight\\"]` * **Output**: `\\"fl\\"` 2. **Example 2**: * **Input**: `[\\"dog\\",\\"racecar\\",\\"car\\"]` * **Output**: `\\"\\"` (No common prefix) **Details**: * Focus on edge cases like arrays with empty strings or completely different strings. * Consider performance constraints and aim for an efficient solution. * Handle both small and large input sizes proficiently. **Scenario**: Imagine you\'re implementing an auto-completion feature for a text editor. The system receives an array of words (strings) entered by the user. To provide relevant suggestions, you need to find the longest common prefix shared by these words. Your task is to implement the `longest_common_prefix` function to enable this feature efficiently.","solution":"from typing import List def longest_common_prefix(strs: List[str]) -> str: if not strs: return \\"\\" min_length = min(len(s) for s in strs) lcp = [] for i in range(min_length): current_char = strs[0][i] for s in strs: if s[i] != current_char: return \'\'.join(lcp) lcp.append(current_char) return \'\'.join(lcp)"},{"question":"**Scenario**: You are building an application that processes large datasets containing numbers, and you need a reliable and efficient way to sort these numbers quickly. You\'ve decided to use the Merge Sort algorithm due to its predictable performance and stability. **Task**: Implement the Merge Sort algorithm to sort a list of integers in ascending order. **Function Signature**: ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` where `1 <= len(arr) <= 10^6`. # Output * A list of integers sorted in ascending order. # Constraints * Elements of `arr` are in the range `-10^9` to `10^9`. * Your solution should not modify the input list directly. * Ensure your implementation handles large datasets efficiently. # Performance Requirements * Your solution should have a time complexity of O(n log n). * Memory usage should be considered, and any unnecessary space should be avoided. # Example **Input**: ```python arr = [38, 27, 43, 3, 9, 82, 10] ``` **Output**: ```python [3, 9, 10, 27, 38, 43, 82] ``` # Additional Notes * Consider edge cases such as very small or very large lists. * Test your implementation thoroughly to ensure it handles all edge cases and large inputs efficiently.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts a list of integers in ascending order using the merge sort algorithm. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_arr = [] i = j = 0 # Merge the two sorted halves while i < len(left) and j < len(right): if left[i] < right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # If there are remaining elements in left or right, add them sorted_arr.extend(left[i:]) sorted_arr.extend(right[j:]) return sorted_arr # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half)"},{"question":"# Scenario The Collatz conjecture proposes an integer sequence where you start with any positive integer n. If the number is even, you divide it by 2, and if the number is odd, you triple it and add 1. This process is repeated until the sequence reaches the value 1. Regardless of the starting integer, this conjecture suggests that the sequence will always end at 1. # Task You are required to implement a function that generates the Collatz (or Hailstone) sequence for a given starting number n. Additionally, compute the length of the sequence and the peak value (the highest number in the sequence). # Function Signature ```python def generate_collatz_sequence(n: int) -> (List[int], int, int): :param n: The starting point of Collatz sequence (1 <= n <= 10^6) :return: A tuple containing: - The full Collatz sequence as a list of integers. - The length of the sequence. - The peak value reached in the sequence. ``` # Input * An integer `n` where `1 <= n <= 1,000,000`. # Output * A tuple comprising: * A list of integers representing the Collatz sequence starting from n. * An integer indicating the length of the sequence. * An integer representing the peak value reached in the sequence. # Constraints * Handle the input `n` within the range efficiently. * Ensure correctness for edge cases such as n = 1. # Examples ```python # Example 1 n = 5 # Collatz sequence: [5, 16, 8, 4, 2, 1] # Sequence length: 6 # Peak value: 16 assert generate_collatz_sequence(5) == ([5, 16, 8, 4, 2, 1], 6, 16) # Example 2 n = 1 # Collatz sequence: [1] # Sequence length: 1 # Peak value: 1 assert generate_collatz_sequence(1) == ([1], 1, 1) ```","solution":"from typing import List, Tuple def generate_collatz_sequence(n: int) -> Tuple[List[int], int, int]: Generates the Collatz sequence starting from n, the length of the sequence, and the peak value. :param n: The starting point of Collatz sequence (1 <= n <= 10^6) :return: A tuple containing: - The full Collatz sequence as a list of integers. - The length of the sequence. - The peak value reached in the sequence. sequence = [] peak_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 if n > peak_value: peak_value = n sequence.append(1) # Adding the last element 1 to the sequence return sequence, len(sequence), peak_value"},{"question":"Scenario: You are a software engineer working on a text-processing tool that needs to check if one string is a circular (rotational) permutation of another string. This functionality is needed for a variety of applications including data encryption, text similarity analysis, and constructing circular data structures. Task: Write a function `is_rotated(s1: str, s2: str) -> bool` that determines if `s2` is a rotational permutation of `s1`. Constraints: - Both input strings `s1` and `s2` consist of lowercase letters only, with lengths in the range `[0, 10000]`. - The function should handle edge cases such as empty strings correctly. - The function should be optimized for performance both in time and space complexity. Input: - A string `s1`. - A string `s2`. Output: - A boolean value, `True` if `s2` is a rotated version of `s1`, `False` otherwise. Example: ```python assert is_rotated(\\"hello\\", \\"llohe\\") == True assert is_rotated(\\"hello\\", \\"helol\\") == False assert is_rotated(\\"waterbottle\\", \\"erbottlewat\\") == True assert is_rotated(\\"\\", \\"\\") == True assert is_rotated(\\"abc\\", \\"\\") == False assert is_rotated(\\"abc\\", \\"cba\\") == False ``` Notes: - Consider both efficiency and simplicity in your implementation. Aim for the solution to have a time complexity of O(N) and space complexity of O(N). - Ensure your solution handles all edge cases appropriately and provides a robust check for string rotations.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determine if s2 is a rotational permutation of s1. Args: s1 (str): The base string. s2 (str): The string to check if it is a rotated version of s1. Returns: bool: True if s2 is a rotated version of s1, False otherwise. if len(s1) != len(s2): return False combined = s1 + s1 return s2 in combined"},{"question":"<|Analysis Begin|> **Algorithm/Data Structure**: Priority Queue implemented using a linear array. **Complexity**: * **Insertion**: O(n) - Because we may need to shift all elements in the worst case. * **Extraction (pop)**: O(1) - We directly remove the last element in the array. **Principles**: * The Priority Queue is a data structure where each element has a \\"priority\\" associated with it. * Elements are ordered such that removal of the smallest priority element (or highest, depending on the implementation) is efficient. * In this implementation, priorities determine the order in which elements are stored in the list—higher priorities come before lower priorities. **Properties**: * **Sorting Stability**: This implementation is stable as it preserves the order of elements with the same priority. * **Traversal Order**: Insertion ensures that elements are ordered by their priority. **Common Use Cases**: * Scheduling tasks where each task has a certain priority. * Algorithms like Dijkstra, A*, and Prim\'s MST algorithm. * Handling events in simulations. **Strengths/Limitations**: * **Strengths**: Simple to implement and easy to understand. * **Limitations**: Inefficient insert operation (O(n)) as compared to more optimized data structures like binary heaps where the insertion is O(log n). **Implementation Challenges**: * **Edge Cases**: * Attempting to pop from an empty priority queue which should be handled gracefully. * Handling duplicate priorities and ensuring the correct order of items. * **Performance Bottlenecks**: * Insertion in worst cases when the inserted element has the lowest priority as it needs to traverse and shift all other elements. * **Error Scenarios**: * Popping from an empty queue can lead to an error which must be handled appropriately. * **Optimization Points**: * Using a data structure such as a binary heap can improve insertion time. * Optimizing the underlying array operations, such as using a deque structure. <|Analysis End|> <|Question Begin|> # Priority Queue Enhancement You are given a priority queue implemented using a linear array. This priority queue supports insertion of elements with a","solution":"class PriorityQueue: def __init__(self): self.queue = [] def is_empty(self): return len(self.queue) == 0 def insert(self, item, priority): Inserts an item with its corresponding priority. self.queue.append((item, priority)) self.queue.sort(key=lambda x: x[1]) # Sort by priority def pop(self): Removes and returns the element with the highest priority. if self.is_empty(): raise IndexError(\\"pop from an empty priority queue\\") return self.queue.pop(0)[0] def peek(self): Returns the element with the highest priority without removing it. if self.is_empty(): raise IndexError(\\"peek from an empty priority queue\\") return self.queue[0][0] def size(self): Returns the number of elements in the priority queue. return len(self.queue)"},{"question":"# Advanced Cryptographic Algorithm Assessment You are working for a cryptography firm and have been tasked with enhancing the efficiency and reliability of certain fundamental algorithms. These algorithms are critical for the proper functioning of cryptographic protocols and ensuring the security of encrypted communications. # Problem Statement You are given three functions: `find_order`, `euler_totient`, and `find_primitive_root`. Your task is to implement an optimized version of a primitive root finding algorithm and ensure thorough testing. Task 1. **Improve** the `find_primitive_root` function: * Optimize it for better performance with large ( n ). * Ensure the function handles all edge cases gracefully. 2. **Implement a test suite**: * Design test cases for evaluating the correctness and performance of: * **find_order** * **euler_totient** * **find_primitive_root** # Function Definitions - `find_order(a: int, n: int) -> int`: Returns the order (smallest positive integer ( k )) of integer ( a ) modulo ( n ). Output -1 if no order exists. - `euler_totient(n: int) -> int`: Returns the Euler\'s Totient function value ( phi(n) ) which counts the number of integers between 1 and ( n ) coprime to ( n ). - `find_primitive_root(n: int) -> List[int]`: Returns a list of all primitive roots of ( n ). For ( n = 1 ), return [0]. # Input and Output Formats - **Input**: A single integer ( n ) for which primitive roots must be found. - **Output**: A list of integers representing all primitive roots of ( n ). Return an empty list if no primitive roots exist. # Constraints - ( 1 leq n leq 10^6 ) # Performance Requirements - Ensure that your implementation has time complexity better than ( O(n^2 log n) ). # Example ```python assert find_primitive_root(10) == [3, 7] assert find_primitive_root(17) == [3, 5, 6, 7, 10, 11, 12, 14] assert find_primitive_root(1) == [0] ``` # Notes - Your improved `find_primitive_root` function should efficiently handle the maximum constraint. - Consider precomputation or caching techniques for optimization. - Use `math.gcd` effectively to ensure numbers are coprime.","solution":"import math from typing import List def find_order(a: int, n: int) -> int: Returns the order (smallest positive integer k) of integer a modulo n. Output -1 if no order exists. if math.gcd(a, n) != 1: return -1 # No order if a and n are not coprime k = 1 value = a % n while value != 1: value = (value * a) % n k += 1 if k > n: # Upper bound to prevent infinite loop return -1 return k def euler_totient(n: int) -> int: Euler\'s Totient function value φ(n) which counts the number of integers between 1 and n coprime to n. result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_root(n: int) -> List[int]: Returns a list of all primitive roots of n. For n = 1, return [0]. Return an empty list if no primitive roots exist. if n == 1: return [0] phi = euler_totient(n) factors = [] # Find prime factors of phi p = 2 temp = phi while p * p <= temp: if temp % p == 0: factors.append(p) while temp % p == 0: temp //= p p += 1 if temp > 1: factors.append(temp) def is_primitive_root(g, n, phi, factors): for factor in factors: if pow(g, phi // factor, n) == 1: return False return True primitive_roots = [] for g in range(1, n): if math.gcd(g, n) == 1 and is_primitive_root(g, n, phi, factors): primitive_roots.append(g) return primitive_roots"},{"question":"# Coding Assessment: Enhanced Insertion Sort **Scenario:** You are developing a book inventory system for a small library. Each book is represented by an object that has a title, author, and publication year. The librarian wants to maintain an alphabetically sorted list of book titles as books are added to or removed from the inventory. Additionally, the system should be able to simulate each step of the sorting process for review purposes. **Task:** Implement an enhanced insertion sort function that can sort a list of book objects by their titles. The function should also be capable of printing each step of the sorting process if simulation is activated. **Function Signature:** ```python def enhanced_insertion_sort(books, simulate=False): ``` **Input:** - `books`: List of book objects, where each book object is a dictionary with keys `title`, `author`, and `year`. - `simulate`: Boolean flag to indicate whether to print each step of the sorting process. Default is False. **Output:** - A list of book objects sorted alphabetically by titles. **Constraints:** - Title comparison is case-insensitive. - Each step in the simulation should print the current iteration in the following format: `iteration <i>: <list_of_titles>`, where `<list_of_titles>` is the list of book titles at the current sorting step. **Example Book Object:** ```python books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949} ] ``` **Example Call:** ```python sorted_books = enhanced_insertion_sort(books, simulate=True) ``` **Assessment Requirements:** - Implement the insertion sort algorithm to sort books by title. - Incorporate a simulation mode that prints each step of the sorting process. - Ensure the sort is case-insensitive when comparing titles. - Handle typical edge cases such as an empty list or list with one book.","solution":"def enhanced_insertion_sort(books, simulate=False): Sorts a list of book objects by their titles using an enhanced insertion sort algorithm. Args: books (list): List of book objects, where each book is a dictionary with keys `title`, `author`, and `year`. simulate (bool): Boolean flag to indicate whether to print each step of the sorting process. Default is False. Returns: list: A list of book objects sorted alphabetically by titles. for i in range(1, len(books)): key_book = books[i] key_title = key_book[\'title\'].lower() j = i - 1 # Move elements of books[0..i-1], that are greater than key_book, to one position ahead of their current position while j >= 0 and books[j][\'title\'].lower() > key_title: books[j + 1] = books[j] j -= 1 books[j + 1] = key_book if simulate: print(f\\"iteration {i}: {[book[\'title\'] for book in books]}\\") return books"},{"question":"Sorting Log Files You are a part of a development team that works on a logging system. One of your colleagues implemented a basic insertion sort algorithm but it lacks some optimizations. You need to enhance this algorithm to sort log files more efficiently. Problem Statement Given an array of log strings, where each log string contains a unique identifier followed by the log content, your task is to sort the logs. The logs can contain both letters and numbers. Your sorting algorithm should prioritize letter-logs over number-logs. Letter-logs are sorted lexicographically by content, and ties are broken by the identifiers. Number-logs should retain their original order from the input. Write a function `sort_logs(logs: List[str]) -> List[str]` that sorts an array of logs based on the described rules. Detailed Requirements 1. Identify if a log is a letter-log or a number-log. 2. Sort letter-logs by their content lexicographically; if contents are the same, sort by their identifiers. 3. Number-logs should remain in their original order. 4. Use the insertion sort algorithm and optimize where possible. Input Format - The function `sort_logs` takes a list of strings `logs` where each string follows the format \\"identifier content\\". Output Format - The function returns a list of sorted log strings. Constraints - The array `logs` contains at most 100 elements. - Each log string contains at most 100 characters. - Each log string is composed of letters, digits, and spaces. - The identifier is guaranteed to be unique and not empty. Examples Example 1: ```python logs = [\\"dig1 8 1 5 1\\", \\"let1 art can\\", \\"dig2 3 6\\", \\"let2 own kit dig\\", \\"let3 art zero\\"] sort_logs(logs) ``` Expected output: ```python [\\"let1 art can\\", \\"let3 art zero\\", \\"let2 own kit dig\\", \\"dig1 8 1 5 1\\", \\"dig2 3 6\\"] ``` Explanation: - The letter-logs \\"let1 art can\\", \\"let3 art zero\\", and \\"let2 own kit dig\\" are sorted by content. - The number-logs \\"dig1 8 1 5 1\\" and \\"dig2 3 6\\" remain in the same order. Example 2: ```python logs = [\\"a1 9 2 3 1\\", \\"g1 act car\\", \\"zo4 4 7\\", \\"ab1 off key dog\\", \\"a8 act zoo\\"] sort_logs(logs) ``` Expected output: ```python [\\"g1 act car\\", \\"a8 act zoo\\", \\"ab1 off key dog\\", \\"a1 9 2 3 1\\", \\"zo4 4 7\\"] ```","solution":"from typing import List def sort_logs(logs: List[str]) -> List[str]: def get_key(log: str): identifier, rest = log.split(\\" \\", 1) # Check if it\'s a digit log or letter log is_digit = rest[0].isdigit() # Return tuple with key for sorting: (numeric flag, rest content for letter-logs, identifier) return (is_digit, rest if not is_digit else None, identifier if not is_digit else None) # Using insertion sort in a way that takes our custom comparison into account for i in range(1, len(logs)): key_log = logs[i] key = get_key(key_log) j = i - 1 while j >= 0 and get_key(logs[j]) > key: logs[j + 1] = logs[j] j -= 1 logs[j + 1] = key_log return logs"},{"question":"# Question: Linear Search with Range Query **Context**: Imagine you are developing a search feature for a small dataset. The user can query the system for an element but also specify a range within the array where the element is expected to be found. This optimizes the search by only scanning a part of the array rather than its entirety. **Task**: Write a function `range_linear_search` that takes four parameters: - `array`: a list of integers, - `query`: an integer to be searched within the array, - `start`: the starting index of the range, - `end`: the ending index of the range (inclusive). The function should return the index of the first occurrence of the query element within the specified range `[start, end]`. If the element is not found within the range, return `-1`. **Input Format**: - An integer list `array` with `1 <= len(array) <= 1000`. - An integer `query` that needs to be searched. - Two integers `start` and `end` where `0 <= start <= end < len(array)`. **Output Format**: - An integer representing the index of the query within the range or `-1` if not found. **Constraints**: - `array` does not contain mixed data types. - The `start` and `end` indices will always denote a valid range within the array. **Example**: ```python def range_linear_search(array, query, start, end): for i in range(start, end + 1): if array[i] == query: return i return -1 # Example usage: array = [4, 7, 6, 9, 7, 2] query = 7 start = 1 end = 4 print(range_linear_search(array, query, start, end)) # Output: 1 ``` **Explanation**: In the provided example: - The array is `[4, 7, 6, 9, 7, 2]`. - The function searches for the element `7` within the range `[1, 4]`. - The first occurrence of `7` within this range is at index `1`.","solution":"def range_linear_search(array, query, start, end): Searches for the query element in the array within the specified range [start, end]. Parameters: - array: List of integers to search within. - query: Integer element to find. - start: Starting index of the search range. - end: Ending index of the search range (inclusive). Returns: - Index of the first occurrence of query within the range, or -1 if not found. for i in range(start, end + 1): if array[i] == query: return i return -1"},{"question":"# Problem: Maximum Sliding Window Given an array `nums` and a number `k`, there is a sliding window of size `k` that moves along the array from the very left to the very right. You are required to implement a function that finds the maximum value in each sliding window. Function Signature: ```python def max_sliding_window(nums: List[int], k: int) -> List[int]: ``` Input: - `nums`: A list of integers (e.g., `nums = [1, 3, -1, -3, 5, 3, 6, 7]`) - `k`: A positive integer representing the window size (e.g., `k = 3`) Output: - A list of integers representing the maximum values in each sliding window (e.g., for the above example, the output should be `[3, 3, 5, 5, 6, 7]`) Constraints: - 1 ≤ len(nums) ≤ 10^5 - 1 ≤ k ≤ len(nums) Requirements: - **Efficiency** is crucial: An optimal solution should have a time complexity of (O(n)) and a space complexity of (O(k)). - Handle all edge cases effectively. Scenario: Imagine you are working on a real-time analytics dashboard that processes financial data coming in as a stream. You need to calculate rolling maximums over a fixed timeframe to highlight peak values dynamically. Example: ```python nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 assert max_sliding_window(nums, k) == [3, 3, 5, 5, 6, 7] ``` Implement the `max_sliding_window` function to achieve the desired output by effectively managing the sliding window and optimizing for both performance and correctness.","solution":"from collections import deque from typing import List def max_sliding_window(nums: List[int], k: int) -> List[int]: Returns the maximum values in each sliding window of size k. if not nums or k == 0: return [] n = len(nums) if k == 1: return nums deque_indices = deque() result = [] for i in range(n): # Remove elements not within the sliding window if deque_indices and deque_indices[0] < i - k + 1: deque_indices.popleft() # Remove indices whose corresponding values are less than nums[i] while deque_indices and nums[deque_indices[-1]] < nums[i]: deque_indices.pop() deque_indices.append(i) # Start to add to results only when the first window is completed if i >= k - 1: result.append(nums[deque_indices[0]]) return result"},{"question":"**Scenario**: You are participating in a competitive programming contest where you are challenged to solve permutation-related problems. One such problem involves finding the next higher permutation of a given positive integer. **Problem Statement**: Given a number, find the next higher number that can be formed by rearranging its digits. If no such number exists (i.e., the digits are in descending order), return `-1`. **Requirements**: 1. The function should be named `next_bigger`. 2. The function should take a single parameter `num`, which is a non-negative integer. 3. The function should return an integer, the next higher permutation of digits, or `-1` if it is not possible. **Input**: * `num` (integer): A non-negative integer. (1 ≤ num ≤ 10^9) **Output**: * (integer): The next permutation of digits or `-1`. **Performance Constraints**: * The solution should have a time complexity of O(n), where n is the number of digits in `num`. **Example Cases**: * Example 1: - Input: 38276 - Output: 38627 * Example 2: - Input: 99999 - Output: -1 * Example 3: - Input: 54321 - Output: -1 * Example 4: - Input: 12345 - Output: 12354 * Example 5: - Input: 1528452 - Output: 1528524 **Additional Instructions**: * Ensure your code handles edge cases, such as when all digits are the same or in descending order. * Write at least 3 additional test cases to thoroughly validate your solution.","solution":"def next_bigger(num): Finds the next higher number that can be formed by rearranging the digits of the given number. If no such number exists, returns -1. digits = list(str(num)) n = len(digits) i = n - 2 # Step 1: Find the first digit that is smaller than the digit next to it, from right to left while i >= 0 and digits[i] >= digits[i + 1]: i -= 1 # If no such digit is found, digits are in descending order, return -1 if i == -1: return -1 # Step 2: Find the smallest digit on right side of `i`, which is larger than digits[i] j = n - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digits digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after position `i` to get the next higher permutation digits[i + 1:] = reversed(digits[i + 1:]) return int(\'\'.join(digits))"},{"question":"# Coding Challenge You are given a sorted integer array `array` and a target integer value `val`. Your task is to write a function `search_insert(array, val)` that finds the index at which `val` should be inserted to maintain the sorted order of the array. If `val` is already present in the array, the function should return the index of `val`. Function Signature ```python def search_insert(array: List[int], val: int) -> int: ``` Input * `array`: A list of integers (sorted in ascending order) * `val`: An integer value Output * An integer representing the index to insert `val` into `array`. Examples ```python assert search_insert([1, 3, 5, 6], 5) == 2 assert search_insert([1, 3, 5, 6], 2) == 1 assert search_insert([1, 3, 5, 6], 7) == 4 assert search_insert([1, 3, 5, 6], 0) == 0 ``` Constraints 1. The array will have no more than 10^4 elements. 2. Each element in the array will be an integer within the range [-10^4, 10^4]. 3. The array will always be sorted in ascending order. 4. The target integer `val` can be any integer within the range [-10^4, 10^4]. Explanation Use binary search to determine the correct insertion point for `val` in `array`. Consider edge cases such as `array` being empty, as well as possible duplicate element scenarios.","solution":"from typing import List def search_insert(array: List[int], val: int) -> int: Finds the index at which `val` should be inserted to maintain the sorted order of the array. If `val` is already present in the array, returns the index of `val`. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: low = mid + 1 else: high = mid - 1 return low"},{"question":"# Question: Clone an Undirected Graph You are given an undirected graph serialized as a string. Each node in the graph contains a label and a list of its neighbors. Your task is to write a function `clone_graph(node)` that returns a deep copy of the given graph. Input * The function takes a single argument `node`, which is an instance of `UndirectedGraphNode`, representing an arbitrary starting node of a graph. Output * The function should return the node of the newly cloned graph. Example Given the serialized graph `{0,1,2#1,2#2,2}` (illustrated below), an example usage is: ```python # Example graph: # 1 # / # / # 0 --- 2 # / # _/ # Assume \'graph\' is initialized as per the serialized string. cloned_graph = clone_graph(graph) ``` The `cloned_graph` should have the same structure as the original `graph`. Constraints * Each node label is unique and the graph might contain self-loops. * The algorithm should work efficiently for graphs with up to `10^4` nodes. # Notes * Your solution should handle edge cases like an empty graph or a graph consisting entirely of self-loops. * Ensure that the graph traversal does not enter an infinite loop by properly managing visited nodes. Implement the function `clone_graph(node)` utilizing one of the graph traversal techniques (BFS or DFS) you prefer. Make sure to test your function with various edge cases and graph structures.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph(node): Clone an undirected graph starting from the given node. if not node: return None node_map = {} def dfs(current_node): if current_node in node_map: return node_map[current_node] clone = UndirectedGraphNode(current_node.label) node_map[current_node] = clone for neighbor in current_node.neighbors: clone.neighbors.append(dfs(neighbor)) return clone return dfs(node)"},{"question":"# Problem Description You are given a set of distinct integers in an array. Your task is to write a function that returns all possible subsets of this array, including the empty subset and the array itself. The subsets must be returned as a set of tuples. # Function Signature ```python def find_subsets(nums: List[int]) -> Set[Tuple[int]]: :param nums: List of distinct integers :return: Set of tuples, where each tuple represents a subset ``` # Constraints - All integers in `nums` are distinct. - The length of `nums` does not exceed 20. # Input - A list of integers `nums`. # Output - A set of tuples where each tuple is a subset of `nums`. # Example ```python nums = [1, 2, 3] output = find_subsets(nums) # Output: {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} ``` # Performance Requirements - The solution should have a time complexity of O(n * 2^n) where `n` is the length of the input array. # Important Considerations - Generate subsets using bit manipulation as the core technique. - Take care to handle the case where the input array is empty. # Additional Notes - Ensure your function handles corner cases gracefully. - Focus on the correctness of the bitwise operations to ensure all subsets are generated.","solution":"from typing import List, Set, Tuple def find_subsets(nums: List[int]) -> Set[Tuple[int]]: Returns all possible subsets of a list of distinct integers. Subsets are returned as a set of tuples. result = set() n = len(nums) # There are 2^n possible subsets total_subsets = 1 << n for i in range(total_subsets): subset = [] for j in range(n): # Check if the j-th element is in the i-th subset if i & (1 << j): subset.append(nums[j]) result.add(tuple(subset)) return result"},{"question":"# Given Problem: You are to implement a program capable of calculating the factorial of a number with support for modulo operation. Further, calculate its time complexity. # Requirements: Your implementation must include: 1. A function that calculates the factorial iteratively. 2. A function that calculates the factorial recursively. 3. Both functions must accept an optional `mod` argument to return the result modulo a specified integer. # Function Definitions: You are required to implement the following two functions: ```python def factorial(n: int, mod: int = None) -> int: Calculate the factorial of a non-negative integer n iteratively. Optionally, calculate it modulo mod. Parameters: - n (int): A non-negative integer whose factorial is to be computed. - mod (int, optional): A positive integer for modulo operation. Returns: - int: The factorial of n modulo mod if mod is specified, otherwise the factorial of n. def factorial_recur(n: int, mod: int = None) -> int: Calculate the factorial of a non-negative integer n recursively. Optionally, calculate it modulo mod. Parameters: - n (int): A non-negative integer whose factorial is to be computed. - mod (int, optional): A positive integer for modulo operation. Returns: - int: The factorial of n modulo mod if mod is specified, otherwise the factorial of n. ``` # Constraints: - 0 <= n <= 100 - 1 <= mod <= 10^9 (if mod is specified) - Expected **time complexity**: O(n) for both implementations. - Expected **space complexity**: O(1) for iterative, O(n) for recursive due to call stack. # Examples: - `factorial(5)` should return `120` - `factorial(5, 3)` should return `120 % 3 = 0` - `factorial_recur(4)` should return `24` - `factorial_recur(4, 5)` should return `24 % 5 = 4` # Edge Cases to Consider: - `factorial(0)` should return `1` - `factorial(0, 7)` should return `1` - Proper handling of invalid inputs should raise a `ValueError`.","solution":"def factorial(n: int, mod: int = None) -> int: Calculate the factorial of a non-negative integer n iteratively. Optionally, calculate it modulo mod. Parameters: - n (int): A non-negative integer whose factorial is to be computed. - mod (int, optional): A positive integer for modulo operation. Returns: - int: The factorial of n modulo mod if mod is specified, otherwise the factorial of n. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result def factorial_recur(n: int, mod: int = None) -> int: Calculate the factorial of a non-negative integer n recursively. Optionally, calculate it modulo mod. Parameters: - n (int): A non-negative integer whose factorial is to be computed. - mod (int, optional): A positive integer for modulo operation. Returns: - int: The factorial of n modulo mod if mod is specified, otherwise the factorial of n. if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if not isinstance(mod, int) or mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") if n == 0: return 1 result = n * factorial_recur(n - 1, mod) if mod: result %= mod return result"},{"question":"# Question: Preorder Tree Traversal You are given a binary tree with the following class definition for its nodes: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` Implement two functions to perform a preorder traversal of the binary tree: 1. An iterative function `preorder_iterative(root)` that returns the list of node values in preorder. 2. A recursive function `preorder_recursive(root)` with the same functionality. Function Signature ```python def preorder_iterative(root: Node) -> List[int]: pass def preorder_recursive(root: Node) -> List[int]: pass ``` Input * `root`: The root node of the binary tree, which can be `None` if the tree is empty. Output * A list of integers representing the node values in preorder traversal. Constraints * The binary tree can have up to `10^5` nodes. * Node values are unique integers. * Functions must handle large depths efficiently without causing stack overflow. Performance Requirements * Both functions must operate within O(n) time complexity. # Example ```python # Binary Tree: # 1 # / # 2 3 # / / # 4 5 6 7 root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) assert preorder_iterative(root) == [1, 2, 4, 5, 3, 6, 7] assert preorder_recursive(root) == [1, 2, 4, 5, 3, 6, 7] ``` Implement the functions based on the specifications above.","solution":"from typing import List class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_iterative(root: Node) -> List[int]: Iterative implementation of the preorder tree traversal. if not root: return [] stack = [root] preorder_list = [] while stack: node = stack.pop() preorder_list.append(node.val) # Push right first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return preorder_list def preorder_recursive(root: Node) -> List[int]: Recursive implementation of the preorder tree traversal. def traverse(node): if not node: return preorder_list.append(node.val) traverse(node.left) traverse(node.right) preorder_list = [] traverse(root) return preorder_list"},{"question":"Given the root of a binary tree, write a function to invert the tree, producing its mirror image. You should implement the function `invert_tree` which takes as input the root of the tree and returns the root of the inverted tree. # Input and Output - **Input**: The input is the root node of a binary tree. - **Output**: The function should return the root of the mirrored (inverted) binary tree. # Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: pass ``` # Constraints - The number of nodes in the tree is in the range [0, 1000]. - `-100 <= Node.val <= 100` for each node in the binary tree. # Example ```python # Example 1: # Input: # 4 # / # 2 7 # / / # 1 3 6 9 root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(7) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(6) root.right.right = TreeNode(9) # Output: # 4 # / # 7 2 # / / # 9 6 3 1 inverted_root = invert_tree(root) ``` # Note Do not create a new tree; invert the existing tree. # Explanation: Inverting involves swapping the left and right children of every node in the tree. Ensure your solution is efficient and consider all edge cases, such as trees that are empty or have a single node.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping the left and right children of each node. :param root: TreeNode, the root of the binary tree to be inverted :return: TreeNode, the root of the inverted binary tree if root is None: return None # Recursively invert the left and right subtrees left_inverted = invert_tree(root.left) right_inverted = invert_tree(root.right) # Swap the inverted subtrees root.left = right_inverted root.right = left_inverted return root"},{"question":"# Question: Find the Intersection Node in Linked Lists Scenario You are given two singly linked lists that may or may not intersect at some point. Your task is to determine the node at which the intersection of the two linked lists begins. Intersection is defined by reference, not value. Problem Statement Write a function `find_intersection(headA: Node, headB: Node) -> Optional[Node]` that takes two `Node` objects representing the head of two singly linked lists and returns the intersection node, if present. If no intersection exists, return `None`. Input - `headA`: The head of the first singly linked list. - `headB`: The head of the second singly linked list. Output - The intersection node or `None` if there is no intersection. Constraints - The number of nodes in both lists is in the range `[0, 10000]`. - Node values are between `-100000` and `100000`. - The lists may or may not intersect. - Nodes are identified by their reference. Example ```python # Define the Node class class Node: def __init__(self, x): self.val = x self.next = None # Example linked lists # List1: 3 -> 7 -> 8 -> 10 # | # List2: 1 ----| node1 = Node(3) node2 = Node(7) node3 = Node(8) node4 = Node(10) node5 = Node(1) node1.next = node2 node2.next = node3 node3.next = node4 node5.next = node2 result = find_intersection(node1, node5) assert result.val == 7 # They intersect at node with value 7 ``` Notes 1. You must not change the original linked lists. 2. Consider edge cases like non-intersecting lists or one of the lists being empty. 3. Aim for a solution with `O(N + M)` time complexity and `O(1)` space complexity.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_intersection(headA: Node, headB: Node) -> Node: Find the node where two singly linked lists intersect. :param headA: The head of the first singly linked list. :param headB: The head of the second singly linked list. :return: The intersection node, or None if there is no intersection. if not headA or not headB: return None # Initialize two pointers at the heads of each list a_pointer, b_pointer = headA, headB # Traverse both lists while a_pointer != b_pointer: # Move to the next node or to the head of the other list if at the end a_pointer = a_pointer.next if a_pointer else headB b_pointer = b_pointer.next if b_pointer else headA # Either they meet at intersection node or both become None which means no intersection return a_pointer"},{"question":"# Bubble Sort Enhancement Task Objective As a programmer, your task is to enhance and implement a Bubble Sort algorithm for a given integer array. Additionally, you need to include a feature to count the number of comparisons performed during the sorting process. Problem Statement Write a function `enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]` that performs the following: 1. Sorts the given array `arr` in ascending order using the Bubble Sort algorithm. 2. Prints the intermediate array state after each iteration if `simulation` is set to `True`. 3. Returns a tuple containing: - The sorted array. - The total number of comparisons made during the sorting process. Input - A list of integers `arr`. - A boolean `simulation`. Output - A tuple consisting of the sorted list of integers and an integer representing total comparisons. Constraints - The array length (N) will be in the range (0 leq N leq 10^3). - Each integer in the array will be in the range ( -10^3 leq text{arr[i]} leq 10^3 ). Example ```python input_array = [64, 34, 25, 12, 22, 11, 90] simulation = True sorted_array, comparisons = enhanced_bubble_sort(input_array, simulation) # Expected Output: # iteration 0 : 64 34 25 12 22 11 90 # iteration 1 : 34 64 25 12 22 11 90 # iteration 2 : 34 25 64 12 22 11 90 # iteration 3 : 34 25 12 64 22 11 90 # iteration 4 : 34 25 12 22 64 11 90 # iteration 5 : 34 25 12 22 11 64 90 # iteration 6 : 25 34 12 22 11 64 90 # iteration 7 : 25 12 34 22 11 64 90 # iteration 8 : 25 12 22 34 11 64 90 # iteration 9 : 25 12 22 11 34 64 90 # iteration 10: 12 25 22 11 34 64 90 # iteration 11: 12 22 25 11 34 64 90 # iteration 12: 12 22 11 25 34 64 90 # iteration 13: 12 11 22 25 34 64 90 # iteration 14: 11 12 22 25 34 64 90 # Sorted Array: [11, 12, 22, 25, 34, 64, 90] # Total Comparisons: 21 ```","solution":"from typing import List, Tuple def enhanced_bubble_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: Sort the given array using Bubble Sort algorithm and count the number of comparisons. Parameters: arr (List[int]): The list of integers to sort. simulation (bool): If True, print the array state after each iteration. Returns: Tuple containing the sorted array and the total number of comparisons made. n = len(arr) total_comparisons = 0 for i in range(n): swapped = False for j in range(1, n - i): total_comparisons += 1 if arr[j - 1] > arr[j]: arr[j - 1], arr[j] = arr[j], arr[j - 1] swapped = True if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") if not swapped: break return arr, total_comparisons"},{"question":"Coding Question # Problem Statement You have been provided with two functions, `first_switch_pairs` and `second_switch_pairs`, which rearrange elements in a stack by switching successive pairs starting from the bottom. Your task is to write a function `switch_pairs` that combines the approach used in these functions to efficiently switch pairs in a stack. The function should handle both odd and even lengths of the stack. Function Signature ```python def switch_pairs(stack: list) -> list: # Your implementation here pass ``` # Input * `stack`: A list of integers, where the last element is considered the top of the stack. # Output * Returns the modified stack with successive pairs switched. # Constraints 1. The stack will contain up to 10^4 elements. 2. The stack elements will be within the integer range [-10^6, 10^6]. # Example ```python stack = [3, 8, 17, 9, 1, 10] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 10, 1] stack = [3, 8, 17, 9, 1] print(switch_pairs(stack)) # Output: [8, 3, 9, 17, 1] ``` # Explanation * In the first example, the pairs (3, 8), (17, 9), and (1, 10) are switched. * In the second example, pairs (3, 8) and (17, 9) are switched, leaving 1 at the top since the stack length is odd. # Performance Requirements * Ensure that the function runs efficiently within the given input size constraints. * Consider both time and space complexity in your solution.","solution":"def switch_pairs(stack: list) -> list: Switches successive pairs in the stack starting from the bottom. n = len(stack) for i in range(0, n - 1, 2): # Swap elements at index i and i+1 stack[i], stack[i+1] = stack[i+1], stack[i] return stack"},{"question":"You are climbing a stair case. It takes `n` number of steps to reach the top. Each time you can either climb 1 step or 2 steps. In how many distinct ways can you climb to the top? # Function Signature ```python def climb_stairs(n: int) -> int: Calculates the number of distinct ways to climb a staircase with `n` steps, where each step taken is either 1 step or 2 steps. :param n: An integer representing the number of steps to the top. :return: An integer representing the number of distinct ways to reach the top. ``` # Input * The input parameter will be a single integer `n` (1 ≤ n ≤ 10^5). # Output * Return a single integer representing the number of distinct ways to reach the top. # Constraints * The value of `n` will be a positive integer within the range given. # Example * Example 1: * Input: `n = 2` * Output: `2` * Explanation: There are two ways to climb to the top: (1 step + 1 step) or (2 steps) * Example 2: * Input: `n = 3` * Output: `3` * Explanation: There are three ways to climb to the top: (1 step + 1 step + 1 step), (1 step + 2 steps), or (2 steps + 1 step) # Additional Notes * Focus on optimizing the space complexity of your solution. * Think about how dynamic programming principles can help avoid redundant calculations for overlapping subproblems.","solution":"def climb_stairs(n: int) -> int: Calculates the number of distinct ways to climb a staircase with `n` steps, where each step taken is either 1 step or 2 steps. :param n: An integer representing the number of steps to the top. :return: An integer representing the number of distinct ways to reach the top. if n == 1: return 1 elif n == 2: return 2 prev, curr = 1, 2 for i in range(3, n + 1): prev, curr = curr, prev + curr return curr"},{"question":"You are given a directed graph with `V` vertices numbered from `0` to `V-1` and a list of edges where each edge is represented as a pair of vertices `[u, v]` indicating a directed edge from vertex `u` to vertex `v`. Your task is to determine if there exists a path from vertex `source` to vertex `target`. # Requirements Implement the function `is_reachable(V, edges, source, target)` which takes: - `V`: An integer representing the number of vertices. - `edges`: A list of pairs of integers representing the edges of the graph. - `source`: An integer representing the starting vertex. - `target`: An integer representing the target vertex. Return `True` if there is a path from `source` to `target`, otherwise return `False`. # Example ```python V = 4 edges = [[0, 1], [0, 2], [1, 2], [2, 0], [2, 3], [3, 3]] source = 1 target = 3 Output: True Explanation: There is a path from vertex 1 to vertex 3 (1 -> 2 -> 3). ``` # Constraints - `1 <= V <= 10^4` - `0 <= edges.length <= 10^5` - `0 <= source, target < V` # Function Signature ```python def is_reachable(V: int, edges: List[List[int]], source: int, target: int) -> bool: pass ``` # Notes - Consider handling the edge cases such as source and target being the same vertex or the graph being disconnected. - Optimizing the implementation to handle large graphs efficiently will be crucial.","solution":"from collections import deque, defaultdict def is_reachable(V, edges, source, target): Determine if there exists a path from vertex `source` to vertex `target` in a directed graph. Parameters: V (int): Number of vertices. edges (list of list of int): List of edges in the graph. source (int): Starting vertex. target (int): Target vertex. Returns: bool: True if there is a path from `source` to `target`, otherwise False. if source == target: return True # Build adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Use BFS to check the path existence from source to target visited = [False] * V queue = deque([source]) visited[source] = True while queue: current = queue.popleft() for neighbor in graph[current]: if neighbor == target: return True if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return False"},{"question":"<|Analysis Begin|> # Algorithm/Data Structure Analysis Core Identification * **Algorithm/Data Structure**: Kruskal\'s Algorithm using a Disjoint Set (Union-Find). * **Type**: Graph algorithm for Minimum Spanning Tree (MST). * **Main Purpose**: To find the subset of edges that form a tree including every vertex, where the total weight of the edges is minimized. Complexity * **Time Complexity**: * Sorting of the edges: O(E log E), where E is the number of edges. * Union-Find operations: O(E log V), with path compression and union by rank (inverse Ackermann function). * **Space Complexity**: O(V), where V is the number of vertices, for storing the parent array and the size array in the Disjoint Set. Principles * **Core Operational Steps**: 1. Sort all the edges in non-decreasing order of their weight. 2. Initialize each vertex as its own set in the Disjoint Set. 3. For each sorted edge, check if the two vertices of the edge belong to the same set. * If they do not, include the edge in the MST and merge the sets. * Else, discard the edge. 4. Stop when we have included (V-1) edges in the MST. Characteristics & Applications * **Properties**: - Produces a Minimum Spanning Tree. - Works on undirected weighted graphs. - Greedy algorithm. * **Common Use Cases**: - Network design (e.g., designing least-cost networks). - Approximation algorithms for NP-hard problems such as the travelling salesman problem. - Cluster analysis in machine learning. * **Strengths/Limitations**: * **Strengths**: - Simple and intuitive, easy to implement. - Efficient with sparse graphs (when E is significantly less than V^2). * **Limitations**: - Not the most efficient for dense graphs. - Requires sorting of edges, which can be time-consuming for large graphs. Implementation Challenges * **Edge Cases**: - Empty graph (0 vertices). - Graph with no edges (no possible MST). - Graph with disconnected components (invalid input for MST). * **Performance Bottlenecks**: - Sorting the edges is a major time complexity contributor. - Union-Find operations, if not optimized with path compression and union by rank. * **Error Scenarios**: - Incorrect handling of edges (such as converting from 1-indexed to 0-indexed). - Failing to check for already connected components before merging in Union-Find. * **Optimization Points**: - Use efficient data structures for Union-Find with path compression and union by rank. - Validate inputs before processing. - Optimize edge cases handling. <|Analysis End|> <|Question Begin|> # Coding Assessment Question **Objective**: Implement Kruskal\'s Algorithm to find the Minimum Spanning Tree of a given undirected weighted graph. # Problem Statement You are given an undirected graph with `n` vertices and `m` edges. Each edge has a weight associated with it. Your task is to compute the sum of the weights of the edges in the Minimum Spanning Tree of the given graph. # Function Signature ```python def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: pass ``` # Input The function `minimum_spanning_tree` has: - `vertex_count` (int): The number of vertices `n` in the graph. - `edges` (List[Tuple[int, int, int]]): A list of `m` tuples where each tuple represents an edge in the form (u, v, weight) with `u` and `v` as the indices of the vertices connected by the edge and `weight` as the weight of that edge. Constraints: - 1 ≤ `vertex_count` ≤ 10^4 - 0 ≤ `m` ≤ 10^5 - 1 ≤ `weight` ≤ 10^6 # Output The function should return an integer representing the sum of the weights of the Minimum Spanning Tree (MST). # Example ```python print(minimum_spanning_tree(5, [(1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6)])) # Output: 14 print(minimum_spanning_tree(3, [(2, 1, 20), (3, 1, 20), (2, 3, 100)])) # Output: 40 ``` # Edge Cases to Consider - Graph with no edges should return 0. - Graph with multiple components should raise an exception or handle gracefully since MST can\'t be formed. # Notes - The vertices indices in the input are 1-indexed, but you might need to convert them to 0-indexed for easier implementation. - Your solution should aim to be efficient in terms of both time and space.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_spanning_tree(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: if vertex_count <= 0 or not edges: return 0 edges.sort(key=lambda x: x[2]) uf = UnionFind(vertex_count) mst_weight = 0 edge_count = 0 for u, v, weight in edges: u -= 1 v -= 1 if uf.find(u) != uf.find(v): uf.union(u, v) mst_weight += weight edge_count += 1 if edge_count == vertex_count - 1: break if edge_count != vertex_count - 1: raise ValueError(\\"The input graph does not contain a valid MST\\") return mst_weight"},{"question":"# Coding Task: Enhanced Interpolation Search You are required to implement an enhanced version of the Interpolation Search algorithm. Your implementation should handle all potential edge cases, including but not limited to division by zero, non-numeric inputs, and non-sorted arrays. Additionally, implement and utilize a pre-validation function to ensure the array is sorted in ascending order. **Function Signature**: ```python def enhanced_interpolation_search(array: List[int], search_key: int) -> int: ``` **Input**: - `array` (List[int]): A list of integers where you need to search for the `search_key`. - `search_key` (int): The integer value that needs to be searched in the `array`. **Output**: - Returns the index of `search_key` if found in `array`; otherwise, returns `-1`. **Constraints**: - The function should return `-1` if the input array is empty or not sorted in ascending order. - You can assume the array will only contain integers and the `search_key` will be an integer. - Implement error handling for any potential division by zero scenarios. **Examples**: ```python >>> enhanced_interpolation_search([-25, -12, -1, 10, 12, 15, 20, 41, 55], -1) 2 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], 55) -1 >>> enhanced_interpolation_search([5, 10, 12, 14, 17, 20, 21], -5) -1 >>> enhanced_interpolation_search([], 10) -1 >>> enhanced_interpolation_search([10, 5, 20, 15], 10) -1 ``` # Notes: - Ensure that the array is sorted in ascending order and contains at least one element. If these conditions are not met, the function must return `-1`. - If `search_key` is not present in the `array`, return `-1`. - Pay careful attention to edge cases such as division by zero or search keys outside the range of the array.","solution":"from typing import List def enhanced_interpolation_search(array: List[int], search_key: int) -> int: def is_sorted(arr: List[int]) -> bool: return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) # Return -1 if array is empty or not sorted if not array or not is_sorted(array): return -1 low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: # Handle division by zero case here if array[low] == array[high]: if array[low] == search_key: return low break # Interpolation formula pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) # Ensure pos is within bounds if pos < 0 or pos >= len(array): return -1 # Check if we found the search_key if array[pos] == search_key: return pos # If search_key is larger, search in the upper part if array[pos] < search_key: low = pos + 1 # If search_key is smaller, search in the lower part else: high = pos - 1 return -1"},{"question":"# Subtree Check Algorithm You are given two binary trees, `big` and `small`. Your task is to determine whether the `small` tree is a subtree of the `big` tree. Implement the function `is_subtree(big, small)` that returns a boolean indicating whether `small` is a subtree of `big`. Input Format - `big`: The root node of the larger binary tree. - `small`: The root node of the smaller binary tree. Each tree node has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output Format - Return `True` if `small` is a subtree of `big`, otherwise return `False`. Constraints - The number of nodes in both trees will be in the range of [0, 10000]. - Tree node values are unique integers. Example 1 ```text Input: big = [3, 4, 5, 1, 2], small = [4, 1, 2] Output: True ``` Example 2 ```text Input: big = [3, 4, 5, 1, 2, None, None, None, None, 0], small = [4, 1, 2] Output: False ``` Follow-up What if one tree is significantly larger than the other? Consider optimizing to handle such scenarios. Solution Template Here\'s a code structure you can use to start the implementation: ```python import collections class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): def comp(p, q): if p is None and q is None: return True if p is not None and q is not None: return p.val == q.val and comp(p.left, q.left) and comp(p.right, q.right) return False if not small: return True if not big: return False queue = collections.deque() queue.append(big) while queue: node = queue.popleft() if node: if node.val == small.val and comp(node, small): return True queue.append(node.left) queue.append(node.right) return False ``` Implement this function and ensure it passes all provided test cases.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(big, small): def are_identical(root1, root2): if not root1 and not root2: return True if root1 and root2 and root1.val == root2.val: return (are_identical(root1.left, root2.left) and are_identical(root1.right, root2.right)) return False if not small: return True if not big: return False if are_identical(big, small): return True return is_subtree(big.left, small) or is_subtree(big.right, small)"},{"question":"# Scenario Imagine you are developing a function to compare user preferences based on their interaction vectors in a recommendation system. You need a reliable measure to determine the similarity between their preferences. # Question Write a function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between two equally sized vectors, `vec1` and `vec2`. These vectors represent user interactions, such as ratings or click counts on different content items. The function should handle invalid input and edge cases appropriately. Specifications - **Input**: - `vec1`, `vec2`: Lists of integers or floats representing the interaction vectors. Both lists must have the same length. - **Output**: - A float value representing the cosine similarity between the two vectors. Constraints - Lengths of `vec1` and `vec2` are between 1 and 10^6. - All elements in the vectors are real numbers and could be positive or negative. Requirements - Constraints on performance: the solution must run in linear time relative to the length of the vectors. - The function should handle invalid input and edge cases: - Raise a `ValueError` if vectors `vec1` and `vec2` have different lengths. - Handle cases where vectors contain all zeros appropriately and avoid division by zero errors. # Example ```python assert cosine_similarity([1, 1, 1], [1, 2, -1]) == 0.47140452079103173 assert cosine_similarity([0, 0, 0], [1, 2, -1]) == ValueError: \\"Cannot compute cosine similarity of zero vectors.\\" assert cosine_similarity([1, 2], [1, 2, 3]) == ValueError: \\"The two vectors must be the same length.\\" ``` Implement your function as specified above.","solution":"import math def cosine_similarity(vec1, vec2): Calculates the cosine similarity between two equally sized vectors. Parameters: - vec1: A list of floats or integers representing the first vector. - vec2: A list of floats or integers representing the second vector. Returns: - A float value representing the cosine similarity between the two vectors. if len(vec1) != len(vec2): raise ValueError(\\"The two vectors must be the same length.\\") dot_product = sum(x * y for x, y in zip(vec1, vec2)) magnitude_v1 = math.sqrt(sum(x * x for x in vec1)) magnitude_v2 = math.sqrt(sum(y * y for y in vec2)) if magnitude_v1 == 0 or magnitude_v2 == 0: raise ValueError(\\"Cannot compute cosine similarity of zero vectors.\\") return dot_product / (magnitude_v1 * magnitude_v2)"},{"question":"Given a non-negative number represented as an array of digits in big-endian format (most significant digit first), write a function `plusOne` to increment the number by one. The function should return the resulting array of digits. # Function Signature ```python def plusOne(digits: List[int]) -> List[int]: pass ``` # Input * A list of non-negative integers, where each integer is between 0 and 9, representing a non-negative number. # Output * A list of non-negative integers representing the number incremented by one. # Constraints * The input array will not be empty. * There will be no leading zeros except the number `0` itself. # Performance Requirements * The function should run in O(n) time complexity where n is the length of the input array. * The space complexity should not exceed O(1) additional space, aside from input storage. # Example Example 1 Input: `[1, 2, 3]` Output: `[1, 2, 4]` Explanation: The given number is 123, and incrementing by one gives 124. Example 2 Input: `[9, 9, 9]` Output: `[1, 0, 0, 0]` Explanation: The given number is 999, and incrementing by one gives 1000. # Edge Cases * When the input contains all 9s, resulting in a carry over that extends the list length. * When the input is a single digit less than 9. # Scenario A popular feedback and reputation company handles large volumes of numerical data stored in digit lists. To ensure accurate historical records and statistics, they often need to increment these numbers efficiently. Your task is to write robust logic for this scenario.","solution":"from typing import List def plusOne(digits: List[int]) -> List[int]: Increments the integer represented by the list of digits by one and returns the resulting list of digits. n = len(digits) # Traverse the list from the end to the start. for i in range(n - 1, -1, -1): # If the current digit is less than 9, simply increment it and return the result. if digits[i] < 9: digits[i] += 1 return digits # If the current digit is 9, set it to 0. digits[i] = 0 # If all the digits were 9, we need to add a leading 1. return [1] + digits"},{"question":"# Question: Implement a Method to Count Red Nodes in a Red-Black Tree Given the implementation of a Red-Black Tree (RBTree) class, write a method named `count_red_nodes` that counts the number of red nodes in the tree. You need to add this method to the given `RBTree` class. Function Signature ```python def count_red_nodes(self) -> int: Count the number of red nodes in the Red-Black Tree. Return: int: The count of red nodes in the tree. ``` Input * There are no direct inputs to the method. However, it operates on the Red-Black Tree object which has nodes with colors and values. * Each node of the RBTree is represented by an instance of the `RBNode` class having the attribute `color` where `1` represents red and `0` represents black. Output * Return the integer value indicating the number of red nodes in the Red-Black Tree. Constraints * The method should be implemented as part of the provided RBTree class. * You may assume the tree follows the properties of a red-black tree. Example ```python if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) # All nodes are initially red. rb.insert(node) assert rb.count_red_nodes() == 8 # After insertions and balancing, the count should reflect actual red nodes. ``` **Note**: You may utilize the existing methods and structures within the provided `RBTree` class for traversal or any related tasks necessary for implementing the `count_red_nodes` method. Explanation The count of red nodes should reflect the nodes currently in the red state after the balancing insertions. Even though all nodes start as red upon insertion, the Red-Black Tree properties and balancing can alter their colors.","solution":"class RBNode: def __init__(self, data, color, left=None, right=None, parent=None): self.data = data self.color = color # 1 for Red, 0 for Black self.left = left self.right = right self.parent = parent class RBTree: def __init__(self): self.TNULL = RBNode(0, 0) self.root = self.TNULL # Insert method and other helper methods would go here def count_red_nodes(self) -> int: Count the number of red nodes in the Red-Black Tree. Return: int: The count of red nodes in the tree. def count_red(node): if node is None or node == self.TNULL: return 0 red_count = 1 if node.color == 1 else 0 return red_count + count_red(node.left) + count_red(node.right) return count_red(self.root)"},{"question":"**Question: Linked List Palindrome Checker** **Objective**: Write a function to check if a singly linked list is a palindrome using three different methods. Implement the following function: ```python def check_palindrome_linked_list(head): :param head: ListNode - the head node of a singly linked list :return: (bool, int) - returns a tuple where the first element indicates if the linked list is a palindrome using each of the three methods and the second element indicates the method used (1 for reverse method, 2 for stack method, 3 for dictionary method) pass ``` # Task Requirements 1. Implement the given function to determine if a singly linked list is a palindrome. 2. Use the three methods provided: - **Method 1**: (is_palindrome) Reverse the second half of the list and compare. - **Method 2**: (is_palindrome_stack) Use a stack to compare the second half of the list. - **Method 3**: (is_palindrome_dict) Use a dictionary to map node values to their positions. 3. The function should return a tuple containing: - A boolean indicating if the linked list is a palindrome. - An integer in {1, 2, 3} indicating which method was used. 4. You can assume the linked list nodes have an integer `val` attribute and a `next` attribute pointing to the next node. # Input - The `head` of the singly linked list. # Output - A tuple `(is_palindrome, method)`: - `is_palindrome` : `True` if the linked list is a palindrome, otherwise `False`. - `method`: An integer: - `1` if the first method was used. - `2` if the second method was used. - `3` if the third method was used. # Constraints - The linked list can be empty. - Node values are integers. - Implement the function in Python. # Performance Requirements - Your implementation should be optimized for both time and space where possible. - Consider edge cases like empty linked lists and single element lists. # Example ```python class ListNode: def __init__(self, x): self.val = x self.next = None # Example use: # Input: 1 -> 2 -> 3 -> 2 -> 1 # The expected output for this list should be (True, method) for any method which demonstrates it being palindrome. ```","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def check_palindrome_linked_list(head): def reverse_list(node): prev = None while node: next_node = node.next node.next = prev prev = node node = next_node return prev def is_palindrome(head): if not head or not head.next: return True slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next second_half_start = reverse_list(slow) first_half_start = head while second_half_start: if second_half_start.val != first_half_start.val: return False second_half_start = second_half_start.next first_half_start = first_half_start.next return True def is_palindrome_stack(head): if not head or not head.next: return True slow = fast = head stack = [] while fast and fast.next: stack.append(slow.val) slow = slow.next fast = fast.next.next if fast: slow = slow.next while slow: top = stack.pop() if slow.val != top: return False slow = slow.next return True def is_palindrome_dict(head): if not head or not head.next: return True values = [] node = head while node: values.append(node.val) node = node.next return values == values[::-1] if is_palindrome(head): return (True, 1) if is_palindrome_stack(head): return (True, 2) if is_palindrome_dict(head): return (True, 3) return (False, 1) # Default to method 1 for returning False"},{"question":"# IP Address Binary Representation **Context** You are tasked with creating a utility to help network engineers convert IPv4 addresses from their common dotted-decimal notation to a binary representation. This will help in tasks like subnetting, network analysis, and IP address management. **Objective** Write a function `decimal_to_binary_ip(ip: str) -> str` that converts a given IPv4 address in dotted-decimal notation to its binary representation. **Function Specification** - **Input**: A string `ip`, representing an IPv4 address in dot-decimal notation, e.g., `\\"192.168.1.1\\"`. - **Output**: A string, which is the binary representation of the input IP address, with each octet separated by a dot, e.g., `\\"11000000.10101000.00000001.00000001\\"`. **Constraints** - The input string will always be a valid IPv4 address. - The IPv4 address comprises exactly four octets, each ranging from 0 to 255. **Example Cases** - Example 1: - Input: `\\"192.0.2.1\\"` - Output: `\\"11000000.00000000.00000010.00000001\\"` - Example 2: - Input: `\\"255.255.255.255\\"` - Output: `\\"11111111.11111111.11111111.11111111\\"` - Example 3: - Input: `\\"0.0.0.0\\"` - Output: `\\"00000000.00000000.00000000.00000000\\"` **Implementation** Use the provided utility function `decimal_to_binary_util(val: str) -> str` to convert a single decimal octet to its binary representation. Then, implement `decimal_to_binary_ip(ip: str) -> str` to convert each octet in the given IP address using this utility function. **Performance Requirement** - The solution should correctly handle all valid IPv4 addresses as per the constraints with efficient time complexity. ```python def decimal_to_binary_util(val): Convert 8-bit decimal number to binary representation :type val: str :rtype: str bits = [128, 64, 32, 16, 8, 4, 2, 1] val = int(val) binary_rep = \'\' for bit in bits: if val >= bit: binary_rep += str(1) val -= bit else: binary_rep += str(0) return binary_rep def decimal_to_binary_ip(ip): Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util values = ip.split(\'.\') binary_list = [] for val in values: binary_list.append(decimal_to_binary_util(val)) return \'.\'.join(binary_list) # Example usage print(decimal_to_binary_ip(\\"192.0.2.1\\")) # Output: \\"11000000.00000000.00000010.00000001\\" print(decimal_to_binary_ip(\\"255.255.255.255\\")) # Output: \\"11111111.11111111.11111111.11111111\\" print(decimal_to_binary_ip(\\"0.0.0.0\\")) # Output: \\"00000000.00000000.00000000.00000000\\" ```","solution":"def decimal_to_binary_util(val): Convert 8-bit decimal number to binary representation :type val: str or int :rtype: str val = int(val) return f\'{val:08b}\' def decimal_to_binary_ip(ip): Convert dotted-decimal ip address to binary representation with help of decimal_to_binary_util :type ip: str :rtype: str values = ip.split(\'.\') binary_list = [decimal_to_binary_util(val) for val in values] return \'.\'.join(binary_list)"},{"question":"# Unique Paths in a Grid Objective Implement a robust function to count the number of unique paths from the top-left corner to the bottom-right corner of an `m x n` grid, moving only to the right or down at each step. Function Signature ```python def count_paths(m: int, n: int) -> int: pass ``` Input * `m` (int): Number of rows in the grid (1 <= m <= 1000). * `n` (int): Number of columns in the grid (1 <= n <= 1000). Output * An integer representing the number of unique paths from the top-left corner to the bottom-right corner of the grid. Constraints * You are allowed to move only right or down from any cell in the grid. * The `count_paths` function should handle input validation and raise appropriate exceptions for invalid inputs. * Optimize space usage where possible while ensuring the function is efficient for large grids. Example ```python assert count_paths(3, 7) == 28 assert count_paths(1, 1) == 1 assert count_paths(5, 10) == 715 assert count_paths(0, 3) == -1 # Invalid input handled ``` Additional Context In a scenario where a robot needs to navigate from the top-left to the bottom-right of a grid, the robot can only travel to the right or downwards. Your task is to compute how many unique paths the robot can take to reach its destination.","solution":"def count_paths(m: int, n: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. Moving is only allowed to the right or down. # Validate input if m <= 0 or n <= 0: raise ValueError(\\"Grid dimensions must be greater than 0\\") # Create a 2D list to store the number of paths to each cell dp = [[0] * n for _ in range(m)] # There\'s only one way to reach any cell in the first row (moving right only) for j in range(n): dp[0][j] = 1 # There\'s only one way to reach any cell in the first column (moving down only) for i in range(m): dp[i][0] = 1 # Fill in the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"# Problem: Compute Maximum Depth of a Binary Tree Given a binary tree, your task is to write a function to compute its maximum depth. The definition for a binary tree node is given as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` # Task Implement the function: ```python def max_height(root: TreeNode) -> int: Given the root of a binary tree, return its maximum depth. Args: root (TreeNode): Root node of the binary tree. Returns: int: The maximum depth of the binary tree. ``` # Input - `root`: The root of the binary tree which is an instance of `TreeNode`. # Output - `int`: The maximum depth of the binary tree. # Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-100 <= Node.val <= 100`. # Example ```python # Example tree: # 10 # / # 12 15 # / / #25 30 36 tree = TreeNode(10) tree.left = TreeNode(12) tree.right = TreeNode(15) tree.left.left = TreeNode(25) tree.left.right = TreeNode(30) tree.right.left = TreeNode(36) assert max_height(tree) == 3 ``` # Requirements - Use an iterative approach and a queue for level-order traversal. - Ensure your implementation handles all edge cases, such as empty trees. # Performance Expectations - Your solution should run efficiently within the time and space constraints provided (O(N) time complexity and O(W) space complexity).","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_height(root: TreeNode) -> int: Given the root of a binary tree, return its maximum depth. Args: root (TreeNode): Root node of the binary tree. Returns: int: The maximum depth of the binary tree. if not root: return 0 from collections import deque queue = deque([(root, 1)]) # (node, current_depth) max_depth = 0 while queue: node, depth = queue.popleft() max_depth = max(max_depth, depth) if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) return max_depth"},{"question":"# Bucket Sort Implementation Challenge You are asked to implement a more efficient and optimized version of the bucket sort algorithm that can handle a wider array of inputs more effectively, particularly addressing some of the performance limitations discussed below. Objective Write a function `optimized_bucket_sort(arr)` that sorts an array of non-negative integers using the bucket sort algorithm with an improved approach. Function Signature ```python def optimized_bucket_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of non-negative integers where (0 leq arr[i] leq 10^6) and (0 leq len(arr) leq 10^5). Output - A list of integers sorted in non-decreasing order. Constraints - Optimize to handle uneven distributions and prevent extreme worst-case scenarios. - Use a more efficient sorting algorithm within buckets if necessary. - Consider edge cases like empty arrays, arrays with identical elements, and large range values. Example ```python assert optimized_bucket_sort([3, 6, 9, 1]) == [1, 3, 6, 9] assert optimized_bucket_sort([1, 4, 1, 2, 7, 5, 2]) == [1, 1, 2, 2, 4, 5, 7] assert optimized_bucket_sort([]) == [] assert optimized_bucket_sort([5]) == [5] ``` # Notes - You may assume that the elements are uniformly or nearly uniformly distributed over the range. - Consider using an algorithm other than insertion sort to sort the buckets if it results in better performance for large inputs.","solution":"from typing import List def optimized_bucket_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] # Find maximum value to determine bucket size max_value = max(arr) # The number of buckets we will use num_buckets = len(arr) # Create buckets buckets = [[] for _ in range(num_buckets)] # Insert elements into their respective buckets for num in arr: index = num * num_buckets // (max_value + 1) buckets[index].append(num) # Sort individual buckets using a more efficient sorting algorithm - Timsort (Python\'s sorted uses Timsort) sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"Objective: Write a function `is_merge` that determines if a given string `s` can be formed by merging two other strings `part1` and `part2` while maintaining their character order. Function Signature: ```python def is_merge(s: str, part1: str, part2: str) -> bool: pass ``` Input: - `s` (str): The target string you need to form. - `part1` (str): The first part of the string. - `part2` (str): The second part of the string. Output: - `bool`: Returns `True` if `s` can be formed by merging `part1` and `part2`, otherwise returns `False`. Constraints: - The length of `s`, `part1`, and `part2` will not exceed 100. - All characters in `s`, `part1`, and `part2` are lowercase English letters. Performance Requirements: - Aim for a linear or polynomial time complexity solution. - Minimize space complexity where possible. Example: ```python is_merge(\\"codewars\\", \\"cdw\\", \\"oears\\") # returns: True is_merge(\\"codewars\\", \\"cod\\", \\"wars\\") # returns: False ``` Description: To solve this problem effectively, consider implementing a dynamic programming approach that stores intermediate results to avoid redundant calculations. This can significantly enhance the efficiency of the solution. Use a table to track whether substrings of `s` up to a certain point can be formed by merging substrings of `part1` and `part2`.","solution":"def is_merge(s, part1, part2): Determines if string s can be formed by merging part1 and part2 maintaining their character order. lenS, lenP1, lenP2 = len(s), len(part1), len(part2) if lenS != (lenP1 + lenP2): return False # Create a 2D dp array dp = [[False] * (lenP2 + 1) for _ in range(lenP1 + 1)] # Initialize the first cell as True dp[0][0] = True # Fill the dp array for i in range(lenP1 + 1): for j in range(lenP2 + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] |= dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] |= dp[i][j - 1] return dp[lenP1][lenP2]"},{"question":"# Context: You are tasked with implementing a sorting algorithm utilizing radix sort. The goal is to sort an unsorted list of non-negative integers efficiently. Given it\'s a non-comparison-based sorting algorithm, focus on its distinctive mechanism of sorting digit by digit. # Task: Write a Python function `custom_radix_sort` that takes a list of non-negative integers and returns a sorted list using the radix sort algorithm. Ensure your implementation handles typical edge cases like an empty list or a list where all elements are the same. Your function should be optimized to handle moderately large lists efficiently. # Function Signature: ```python def custom_radix_sort(arr: List[int]) -> List[int]: ``` # Input: * `arr`: A list of non-negative integers (0 ≤ arr[i] ≤ 10^9). # Output: * A list of integers sorted in ascending order. # Constraints: * 1 ≤ len(arr) ≤ 10^6 * 0 ≤ arr[i] ≤ 10^9 # Performance: * Your solution should have a time complexity of O(nk + n) and space complexity of O(k + n). # Example: ```python assert custom_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) == [2, 24, 45, 66, 75, 90, 170, 802] assert custom_radix_sort([3, 3, 3, 3, 3]) == [3, 3, 3, 3, 3] assert custom_radix_sort([]) == [] ``` # Special Considerations: Make sure your function handles: * A list that might be empty. * A list where all numbers are identical. * Numbers with different lengths (e.g., single and multi-digit numbers).","solution":"from typing import List def custom_radix_sort(arr: List[int]) -> List[int]: if len(arr) == 0: return [] def counting_sort(arr, exp): n = len(arr) output = [0] * n count = [0] * 10 # Count the number of occurrences for each digit for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count so that count[i] contains the actual position of this digit in output for i in range(1, 10): count[i] += count[i - 1] # Build the output array i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr, so that arr contains sorted numbers according to the current digit for i in range(n): arr[i] = output[i] # Find the maximum number to determine the number of digits max_num = max(arr) # Do counting sort for every digit exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 return arr"},{"question":"# Background Bogo Sort is a highly inefficient sorting algorithm that works by randomly shuffling the array until it finds a sorted permutation. While it is not practical for real-world tasks due to its extreme inefficiency, it poses an interesting algorithmic challenge and demonstrates the importance of effective algorithm design. This exercise will help you explore the algorithm\'s characteristics and its unusual approach to sorting. # Task Write a Python function called `efficient_sort(arr: List[int]) -> List[int]` that attempts to implement a more efficient sorting algorithm to replace Bogo Sort. You are free to implement a sorting algorithm of your choice (e.g., Quick Sort, Merge Sort, etc.). # Requirements 1. **Input**: A list of integers, `arr`, which may be empty or populated with unsorted integers. 2. **Output**: A list of integers, sorted in ascending order. 3. **Constraints**: * The input list can have up to (10^6) elements. * The integers in `arr` can be any value within the typical range of 32-bit integers. 4. **Performance**: Your solution should aim for an average-case time complexity of O(n log n). # Examples *Example 1:* ```python efficient_sort([3, 2, 1]) # Expected Output: [1, 2, 3] ``` *Example 2:* ```python efficient_sort([10, 7, 8, 9, 1, 5]) # Expected Output: [1, 5, 7, 8, 9, 10] ``` *Example 3:* ```python efficient_sort([]) # Expected Output: [] ``` *Example 4:* ```python efficient_sort([2]) # Expected Output: [2] ``` # Notes - You should focus on implementing the sorting algorithm efficiently, keeping the constraints in mind. - While Bogo Sort has been discussed for educational purposes, your implementation should use a more practical algorithm. - Make sure your code handles edge cases, such as empty arrays and arrays with one element, appropriately.","solution":"from typing import List def efficient_sort(arr: List[int]) -> List[int]: Returns the list of integers sorted in ascending order. Implements the Merge Sort algorithm for efficient sorting. if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_list = [] left_index, right_index = 0, 0 # Merge the two lists while left_index < len(left) and right_index < len(right): if left[left_index] < right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # If there are remaining elements in left or right, extend the sorted_list sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list # Split the list into halves mid = len(arr) // 2 left_half = efficient_sort(arr[:mid]) right_half = efficient_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"# Nested Dictionary Traversal Problem **Context**: You are working on a project that involves displaying hierarchical data stored in nested dictionaries. Your task is to implement a function that prints the contents of the nested dictionary such that the hierarchy is visually clear. Requirements: * Create a function `nested_dict_print(tree)` that takes a nested dictionary as input. * Ensure all elements are printed on separate lines. * Sub-level elements should be indented to represent their hierarchical relationship. Input: * A nested dictionary `tree` with strings as keys and values may be strings or other dictionaries. Output: * Printed console output of the dictionary\'s hierarchical structure. Example: Given the nested dictionary: ```python tree = { \'a\': {\'Adam\': {\'Book\': 4}}, \'b\': {\'Bill\': {\'Computer\': 5, \'TV\': 6}, \'Jill\': {\'Sports\': 1}}, \'c\': {\'Bill\': {\'Sports\': 3}}, \'d\': {\'Adam\': {\'Computer\': 3}, \'Quin\': 3}, \'e\': {\'Quin\': {\'Book\': 5, \'TV\': 2}}, \'f\': {\'Adam\': {\'Computer\': 7}} } ``` Calling `nested_dict_print(tree)` should produce: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Constraints: * Assume the hierarchy depth does not exceed a reasonable level for recursion (e.g., depth of 100). * Nested levels may vary in structure and depth.","solution":"def nested_dict_print(tree, indent=0): Recursively prints a nested dictionary with an hierarchical structure. for key, value in tree.items(): print(\' \' * indent + str(key)) if isinstance(value, dict): nested_dict_print(value, indent + 2) else: print(\' \' * (indent + 2) + \'-> \' + str(value))"},{"question":"Context: You have been tasked with implementing a feature for a text processing software that can efficiently find the longest palindromic substring within any given string. A palindrome is a sequence of characters that reads the same backward as forward. Problem Statement: Write a function named `find_longest_palindromic_substring(s)` that takes a single argument: - `s`: a non-empty string of lowercase alphabets. Your function must return the longest palindromic substring within `s`. If there are multiple substrings of the same maximum length, return the one that appears first. Requirements: 1. **Input**: A single string `s` with a maximum length of 1000 characters. 2. **Output**: A string representing the longest palindromic substring. Constraints: - Time Complexity: Must be O(n). - Space Complexity: Should be as efficient as possible given the need to handle edge cases for linear space. Examples: ```plaintext Example 1: Input: \\"babad\\" Output: \\"bab\\" (or \\"aba\\", as both are valid palindromic substrings of the same length) Example 2: Input: \\"cbbd\\" Output: \\"bb\\" Example 3: Input: \\"a\\" Output: \\"a\\" Example 4: Input: \\"ac\\" Output: \\"a\\" (or \\"c\\", as they are both valid single character palindromic substrings) ``` Special Instructions: - Make sure to handle input strings of even and odd lengths effectively. - Ensure that your solution is not only correct but also optimized for performance, especially given the constraint on the length of string `s`. Note: Do not use any libraries or built-in functions that directly solve the problem. Your solution should demonstrate understanding and application of Manacher’s algorithm.","solution":"def find_longest_palindromic_substring(s): Function to find the longest palindromic substring in a given string. if not s: return \\"\\" def preprocess(s): Preprocesses the string by adding boundaries. Example: \\"aba\\" => \\"^#a#b#a#\\" t = \\"#\\".join(\\"^{}\\".format(s)) return t def manachers_algorithm(s): Manacher\'s algorithm to find the longest palindromic substring in linear time. T = preprocess(s) P = [0] * len(T) C = 0 # Center of the current right-most palindrome R = 0 # Right edge of the current right-most palindrome for i in range(1, len(T) - 1): mirr = 2 * C - i # Current mirrored position of i if i < R: P[i] = min(R - i, P[mirr]) # Attempt to expand palindrome centered at i while T[i + (P[i] + 1)] == T[i - (P[i] + 1)]: P[i] += 1 # If palindrome centered at i expands past R, adjust C and R if i + P[i] > R: C, R = i, i + P[i] # Find the maximum palindrome in P max_len, center_index = max((n, i) for i, n in enumerate(P)) # Extract the palindrome without the added boundaries start = (center_index - max_len) // 2 return s[start:start + max_len] return manachers_algorithm(s)"},{"question":"Context Traffic management authorities are implementing a system to optimize traffic light timings to reduce congestion in a busy city. The city is modeled as a directed graph where intersections are nodes, and roads with specific travel times are edges. They need a program to calculate the shortest travel time from a central hub to all other intersections to determine optimal traffic light timings dynamically. Task Implement a function `shortest_travel_times(road_network: List[List[int]], source: int) -> List[int]` that uses Dijkstra\'s algorithm to find the shortest travel time from the source intersection to all other intersections in the city. Input Format - `road_network`: A 2D list `n x n` where `n` is the number of intersections. The element `road_network[i][j]` represents the travel time from intersection `i` to intersection `j`. If there\'s no road between two intersections, the travel time will be 0. - `source`: An integer representing the source intersection (the central hub). Output Format - A list of `n` integers where the `i-th` element represents the shortest travel time from the source intersection to the `i-th` intersection. If an intersection is not reachable, the travel time should be infinity. Constraints 1. `1 ≤ n ≤ 1000` — Number of intersections. 2. `0 ≤ travel_time ≤ 1000` — Travel time of the roads. 3. No negative travel times in the graph. You must optimize the algorithm to handle up to 1000 intersections efficiently. Example Input: ```python road_network = [ [0, 10, 0, 30, 100], [10, 0, 50, 0, 0], [0, 50, 0, 20, 10], [30, 0, 20, 0, 60], [100, 0, 10, 60, 0] ] source = 0 ``` Output: ``` [0, 10, 50, 30, 60] ``` Explanation: The shortest travel time from the central hub (intersection 0) to each intersection is calculated using Dijkstra\'s algorithm.","solution":"import heapq from typing import List def shortest_travel_times(road_network: List[List[int]], source: int) -> List[int]: n = len(road_network) distances = [float(\'inf\')] * n distances[source] = 0 priority_queue = [(0, source)] # (distance, intersection) while priority_queue: current_distance, current_intersection = heapq.heappop(priority_queue) if current_distance > distances[current_intersection]: continue for neighbor, travel_time in enumerate(road_network[current_intersection]): if travel_time > 0: # If there\'s a road distance = current_distance + travel_time if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Priority Queue Implementation Context: A priority queue is a data structure where each element has a priority assigned to it. Elements are served based on their priority rather than just their order in the queue. Implementing an efficient priority queue is crucial for various applications such as task scheduling, discrete event simulation, and algorithm optimizations (e.g., Dijkstra\'s shortest path algorithm). Task: You are required to implement a priority queue that supports the following operations: 1. **push(item, priority)**: Inserts `item` into the priority queue with the specified `priority`. If no priority is specified, the `item` value itself is used as the priority. 2. **pop()**: Removes and returns the item with the lowest priority from the priority queue. 3. **size()**: Returns the number of elements in the priority queue. 4. **peek()**: Returns the item with the lowest priority without removing it from the queue. Constraints: - Items and priorities will be integers. - The priority queue must maintain the order of elements based on their priority. Input and Output: - **push(item, priority)**: - Input: `item` (int), `priority` (int, optional) - Output: None - **pop()**: - Input: None - Output: The item (int) with the lowest priority. - **size()**: - Input: None - Output: Number of elements (int) in the priority queue. - **peek()**: - Input: None - Output: The item (int) with the lowest priority. Example: ```python pq = PriorityQueue() pq.push(5) pq.push(1) pq.push(3, 0) print(pq.size()) # Output: 3 print(pq.peek()) # Output: 3 print(pq.pop()) # Output: 3 print(pq.pop()) # Output: 1 print(pq.pop()) # Output: 5 print(pq.size()) # Output: 0 ``` Requirements: - Ensure efficient implementation of the push and pop operations. - Handle edge cases (e.g., popping from an empty queue) gracefully with appropriate error messages.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._index = 0 def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self._queue, (priority, self._index, item)) self._index += 1 def pop(self): if self.size() == 0: raise IndexError(\\"pop from an empty priority queue\\") return heapq.heappop(self._queue)[2] def size(self): return len(self._queue) def peek(self): if self.size() == 0: raise IndexError(\\"peek from an empty priority queue\\") return self._queue[0][2]"},{"question":"# Binary Tree Paths Coding Challenge Context You are given a binary tree and need to generate all paths from the root to each leaf node. Each path should be represented as a string with node values separated by arrows (`\'->\'`). Function Signature ```python def binary_tree_paths(root): Generate all root-to-leaf paths in a binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: List[str]: A list of strings, where each string represents a unique root-to-leaf path. ``` Input * `root`: The root node of the binary tree (an instance of TreeNode). Output * A list of strings, where each string represents a unique path from the root to a leaf. Constraints 1. The number of nodes in the tree is in the range [0, 1000]. 2. Each node\'s value is a non-negative integer. 3. If the tree is empty, return an empty list. Example Consider the following binary tree: ``` 1 / 2 3 5 ``` * The function should return: `[\\"1->2->5\\", \\"1->3\\"]` Additional Information * Ensure to handle edge cases like an empty tree and single-node trees. * Avoid deep recursion to prevent stack overflow issues on deep trees.","solution":"# Definition for a binary tree node. class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root): Generate all root-to-leaf paths in a binary tree. Parameters: root (TreeNode): The root node of the binary tree. Returns: List[str]: A list of strings, where each string represents a unique root-to-leaf path. def dfs(node, path, paths): if node: path += str(node.val) if not node.left and not node.right: # if leaf node paths.append(path) else: path += \'->\' dfs(node.left, path, paths) dfs(node.right, path, paths) paths = [] dfs(root, \'\', paths) return paths"},{"question":"# Finding Two Unique Numbers in a List Given an array of integers `nums`, where exactly two elements appear only once and all the other elements appear exactly twice, write a function `find_two_unique_numbers(nums)` that returns the two elements that appear only once. The function should meet the following constraints: - **Time Complexity**: O(N) - **Space Complexity**: O(1) # Example: ```python nums = [1, 2, 1, 3, 2, 5] assert find_two_unique_numbers(nums) == [3, 5] or find_two_unique_numbers(nums) == [5, 3] ``` # Input: - `nums`: List[int] - A list of integers with the conditions mentioned above. (e.g., `[1, 2, 1, 3, 2, 5]`). # Output: - List[int] - A list containing the two elements that appear only once. The order of the elements in the output does not matter. # Constraints: - The input array will have `2n + 2` elements, where `n` is the number of pairs of duplicate elements. - Elements of the array can be negative. # Implementation Details 1. Use XOR to cancel out the pairs and isolate `A^B`. 2. Find a bit position where `A` and `B` differ (this can be the rightmost differing bit). 3. Divide all the numbers into two groups based on the above bit position. 4. Use XOR in each group to isolate `A` and `B`. Write your solution below: ```python def find_two_unique_numbers(nums): # Your code here pass # Example test case print(find_two_unique_numbers([1, 2, 1, 3, 2, 5])) # Output: [3, 5] or [5, 3] ```","solution":"def find_two_unique_numbers(nums): Returns the two elements in nums that appear only once. # Step 1: XOR all numbers to get A^B, where A and B are the two unique numbers. xor = 0 for num in nums: xor ^= num # Step 2: Find any bit that is set in xor (which means A and B differ at this bit). # We use this bit to partition the numbers into two groups. diff_bit = xor & -xor # This extracts the rightmost set bit. # Step 3: Use the diff_bit to divide numbers into two groups and find A and B. a = 0 b = 0 for num in nums: if num & diff_bit: a ^= num # This will end up being one unique number. else: b ^= num # This will end up being the other unique number. return [a, b]"},{"question":"# Sparse Matrix Multiplication Challenge Scenario You are working on a scientific computing project where you need to optimize the performance of matrix multiplications. Given the nature of the data, the matrices involved are usually sparse, meaning most of the elements are zero. Your task is to implement a function that multiplies two sparse matrices efficiently. Task Description Write a function `multiply_sparse_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` that takes two sparse matrices `A` and `B` (both represented as 2D lists) and returns their product matrix `C` in an efficient manner. Requirements 1. Assume that the number of columns in matrix `A` is equal to the number of rows in matrix `B`. 2. Your implementation should take advantage of the sparsity of the matrices to minimize unnecessary calculations. 3. The function should handle edge cases such as matrices with all elements being zero. Function Signature ```python from typing import List def multiply_sparse_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` Input - `A`: A list of lists where each inner list represents a row in the matrix. It is guaranteed that within the list, the number of columns is uniform. - `B`: A list of lists where each inner list represents a row in the matrix. It is also guaranteed that within the list, the number of columns is uniform. Output - A list of lists where each inner list represents a row in the resultant matrix `C`. Constraints - 1 <= len(A), len(B) <= 1000 - -10^5 <= A[i][j], B[i][j] <= 10^5 - Number of columns in `A` should be equal to the number of rows in `B`. Example ```python A = [ [1, 0, 0], [-1, 0, 3] ] B = [ [7, 0, 0], [0, 0, 0], [0, 0, 1] ] assert multiply_sparse_matrices(A, B) == [ [7, 0, 0], [-7, 0, 3] ] ``` Evaluation Your submission will be evaluated based on: 1. **Correctness**: Producing the correct result for a variety of test cases. 2. **Efficiency**: Efficiently handling large and sparse matrices. 3. **Code Quality**: Readability and maintainability of the code.","solution":"from typing import List def multiply_sparse_matrices(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: # Get the dimensions of matrices A and B m, k = len(A), len(A[0]) k2, n = len(B), len(B[0]) # Resultant matrix of dimensions m x n C = [[0] * n for _ in range(m)] # Intermediate representation of non-zero elements in B. non_zero_B = {} for i in range(k2): for j in range(n): if B[i][j] != 0: if i not in non_zero_B: non_zero_B[i] = {} non_zero_B[i][j] = B[i][j] # Loop over each element in A. for i in range(m): for j in range(k): if A[i][j] != 0: if j in non_zero_B: for col in non_zero_B[j]: C[i][col] += A[i][j] * non_zero_B[j][col] return C"},{"question":"# Maximum Subarray Sum with Restrictions Write a Python function `max_subarray_with_atleast_k(array, k)` that finds the maximum sum of any contiguous subarray of size `k` or more within a one-dimensional numeric array. Function Signature ```python def max_subarray_with_atleast_k(array: List[int], k: int) -> int: ``` Input * `array`: A list of integers `array` (1 ≤ len(array) ≤ 10^5, -10^4 ≤ array[i] ≤ 10^4). * `k`: An integer `k` (1 ≤ k ≤ len(array)). Output * Return an integer value representing the maximum sum of any contiguous subarray of size `k` or more. Constraints * The array must contain at least `k` elements. * At least one subarray of size `k` or more must be viable. Example ```python array = [1, 2, -3, 4, 5, -7, 23] k = 3 print(max_subarray_with_atleast_k(array, k)) # Should return 25 ``` Explanation For the given array `[1, 2, -3, 4, 5, -7, 23]` and `k = 3`, the subarray `[4, 5, -7, 23]` is the contiguous subarray of size 3 or more that has the maximum sum, which is 25. Hints * Consider modifying Kadane\'s algorithm to accommodate the size restriction. * Calculate maximum sums for subarrays of size exactly `k` first, then extend them and compare.","solution":"from typing import List def max_subarray_with_atleast_k(array: List[int], k: int) -> int: def kadane(array): max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global n = len(array) if n == 0: return 0 max_sum = float(\'-inf\') current_sum = sum(array[:k]) kadane_residue = [0] * n kadane_residue[k-1] = current_sum for end in range(k, n): current_sum = current_sum + array[end] - array[end - k] kadane_residue[end] = max(kadane_residue[end - 1] + array[end], current_sum) max_sum = max(max_sum, kadane_residue[end]) max_k_sum = kasum = sum(array[:k]) for i in range(k, n): kasum += array[i] - array[i-k] max_k_sum = max(max_k_sum, kasum) return max(max_sum, max_k_sum)"},{"question":"# Code Assessment Question As part of your exam, you are asked to implement a sorting function using bucket sort. Given a list of floating-point numbers within the range `[0, 1)`, your task is to implement the bucket sort algorithm described below. Consider the following constraints: 1. The function should handle edge cases, such as an empty list or a list with all identical elements. 2. The input list can be large, but the number of buckets will be equal to the number of elements in the list. # Function Signature ```python def bucket_sort_floats(arr: List[float]) -> List[float]: pass ``` # Input - `arr`: A list of `n` floating-point numbers within the range `[0, 1)`. # Output - Returns a new list with the floating-point numbers sorted in ascending order. # Constraints - `0 <= n <= 10^5` - Each element in the array will be in the range `[0, 1)`. # Example ```python >>> bucket_sort_floats([0.25, 0.36, 0.58, 0.41, 0.19, 0.21, 0.40, 0.55]) [0.19, 0.21, 0.25, 0.36, 0.40, 0.41, 0.55, 0.58] >>> bucket_sort_floats([0.3, 0.1, 0.4, 0.7, 0.8]) [0.1, 0.3, 0.4, 0.7, 0.8] >>> bucket_sort_floats([]) [] ``` # Note * Ensure that your function is both efficient and handles the constraints effectively. * Document any assumptions you make and explain how you handle edge cases within your code implementation.","solution":"from typing import List def bucket_sort_floats(arr: List[float]) -> List[float]: if len(arr) == 0: return arr # Number of buckets n = len(arr) buckets = [[] for _ in range(n)] # Put array elements in different buckets for num in arr: index = int(n * num) buckets[index].append(num) # Sort individual buckets and concatenate results sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"# Priority Queue Task Scheduler As a software engineer, you are tasked with designing a task scheduling system using a priority queue. Each task will have a priority, which determines the order in which tasks should be executed. Higher-priority tasks should be executed before lower-priority tasks. Your objective is to implement the `TaskScheduler` class, which uses a priority queue for task management. The class should provide methods to add tasks, remove the task with the highest priority, and retrieve the size of the queue. Class Definition: ```python class TaskScheduler: def __init__(self): Initialize an empty task scheduler. pass def add_task(self, task, priority): Add a task to the scheduler with a given priority. :param task: A string representing the task. :param priority: An integer representing the task\'s priority. pass def remove_highest_priority_task(self): Remove and return the task with the highest priority. If the queue is empty, return None. :return: A string representing the highest priority task or None if the queue is empty. pass def get_size(self): Return the number of tasks in the scheduler. :return: An integer representing the number of tasks. pass ``` Constraints: 1. `add_task` and `remove_highest_priority_task` methods should operate with the complexity of O(n) for adding and O(1) for removing respectively. 2. All tasks and their priorities must be managed correctly according to the priority queue rules. 3. Handle edge cases where the queue might be empty. Example Usage: ```python scheduler = TaskScheduler() scheduler.add_task(\\"Task 1\\", 3) scheduler.add_task(\\"Task 2\\", 1) scheduler.add_task(\\"Task 3\\", 2) print(scheduler.get_size()) # Output: 3 print(scheduler.remove_highest_priority_task()) # Output: \\"Task 1\\" print(scheduler.get_size()) # Output: 2 print(scheduler.remove_highest_priority_task()) # Output: \\"Task 3\\" print(scheduler.get_size()) # Output: 1 print(scheduler.remove_highest_priority_task()) # Output: \\"Task 2\\" print(scheduler.get_size()) # Output: 0 print(scheduler.remove_highest_priority_task()) # Output: None ``` Implement the `TaskScheduler` class using the `PriorityQueue` class from the code snippet provided above.","solution":"import heapq class TaskScheduler: def __init__(self): Initialize an empty task scheduler. self.task_queue = [] self.task_counter = 0 def add_task(self, task, priority): Add a task to the scheduler with a given priority. :param task: A string representing the task. :param priority: An integer representing the task\'s priority. # We are using a negative priority because heapq is a min-heap and we need a max-heap heapq.heappush(self.task_queue, (-priority, self.task_counter, task)) self.task_counter += 1 def remove_highest_priority_task(self): Remove and return the task with the highest priority. If the queue is empty, return None. :return: A string representing the highest priority task or None if the queue is empty. if not self.task_queue: return None return heapq.heappop(self.task_queue)[2] def get_size(self): Return the number of tasks in the scheduler. :return: An integer representing the number of tasks. return len(self.task_queue)"},{"question":"You are given a string `s` and your task is to write a function `atbash_cipher(s)` that applies the Atbash cipher to the input string `s`. The Atbash cipher is a substitution cipher where each letter of the alphabet is mapped to its reverse (e.g., \'a\' maps to \'z\', \'b\' maps to \'y\', etc.). Non-alphabetic characters (such as spaces, punctuation, etc.) should remain unchanged. # Function Signature ```python def atbash_cipher(s: str) -> str: ``` # Input * `s`: A string containing printable ASCII characters. The length of the string is between 1 and 10^5 characters. # Output * Returns a new string where each alphabetic character has been replaced with its Atbash cipher equivalent. # Constraints * The string `s` will contain only printable ASCII characters. # Example Example 1 ```python s = \\"Attack at dawn\\" print(atbash_cipher(s)) ``` **Output**: ``` \\"Zggzxp zg wzdm\\" ``` Example 2 ```python s = \\"Hello, World!\\" print(atbash_cipher(s)) ``` **Output**: ``` \\"Svool, Dliow!\\" ``` # Performance Requirements * The function should run in O(n) time where `n` is the length of the input string. # Additional Notes * Ensure that your solution handles both uppercase and lowercase letters correctly. * Non-alphabetic characters should not be altered. * Remember to preserve the original case of each letter.","solution":"def atbash_cipher(s: str) -> str: Applies the Atbash cipher to the input string. Parameters: s (str): The string to be encoded with the Atbash cipher. Returns: str: The encoded string with the Atbash cipher. result = [] for char in s: if char.isalpha(): if char.islower(): result.append(chr(219 - ord(char))) # \'a\' = 97, \'z\' = 122 else: result.append(chr(155 - ord(char))) # \'A\' = 65, \'Z\' = 90 else: result.append(char) return \'\'.join(result)"},{"question":"Minimum Distance To Equal Strings Objective Write a Python function to determine the minimum number of steps required to make two given strings equal by deleting characters. Use dynamic programming to achieve an efficient solution. Description Given two strings `word1` and `word2`, your task is to find the minimum number of steps required to make `word1` and `word2` identical, where in each step you can delete one character from either string. Your approach should use dynamic programming to optimize the calculation and avoid redundant comparisons. Function Signature ```python def min_distance(word1: str, word2: str) -> int: ``` Input - `word1`: A string of length `n` (1 ≤ `n` ≤ 1000). - `word2`: A string of length `m` (1 ≤ `m` ≤ 1000). Output - An integer representing the minimum number of steps required to make both strings equal. Constraints - Performance should be optimized to handle the maximum input size efficiently. - The solution should utilize dynamic programming concepts. Example **Example 1:** ``` Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` **Example 2:** ``` Input: word1 = \\"intention\\", word2 = \\"execution\\" Output: 8 Explanation: Minimum steps to make strings equal includes deleting characters to adjust to their common subsequence. ``` Notes - Ensure to handle edge cases such as empty strings or strings with no common characters. - Improve space complexity wherever possible.","solution":"def min_distance(word1: str, word2: str) -> int: Function to determine the minimum number of steps required to make two given strings equal by deleting characters. n, m = len(word1), len(word2) # Create a DP table with dimensions (n+1) x (m+1) dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j # If word1 is empty, we need to delete all characters of word2 elif j == 0: dp[i][j] = i # If word2 is empty, we need to delete all characters of word1 elif word1[i - 1] == word2[j - 1]: # If characters match, no deletion required dp[i][j] = dp[i - 1][j - 1] else: # Take the minimum deletion from either string dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"**Problem Context:** You are tasked with implementing a modified version of the Shell Sort algorithm. The modification involves introducing a custom gap sequence rather than using the traditional n/2 reduction approach. **Problem Statement:** Write a function `optimized_shell_sort` that sorts an array of integers using the Shell Sort algorithm with a custom-defined gap sequence. The gap sequence to be used is defined as [701, 301, 132, 57, 23, 10, 4, 1]. This sequence is known to generally perform better than the simple n/2 sequence. **Function Signature:** ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` **Input:** * `arr` - A list of integers to be sorted (0 <= len(arr) <= 10^5 and -10^6 <= arr[i] <= 10^6). **Output:** * The function should return the sorted list of integers. **Constraints:** * Use the gap sequence [701, 301, 132, 57, 23, 10, 4, 1]. * The algorithm should sort the array in-place, i.e., use constant additional space (O(1) space complexity). * The solution should be efficient to handle large lists up to length 10^5. # Example: ``` Input: [9, 8, 3, 7, 5, 6, 4, 1] Output: [1, 3, 4, 5, 6, 7, 8, 9] Input: [1, 2, 3, 4, 5, 6, 7, 8, 9] Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Notes: * The function must sort the array in ascending order. * Take care to handle edge cases such as an empty array or an array with a single element. Good luck, and aim to create an optimized and efficient solution!","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: gaps = [701, 301, 132, 57, 23, 10, 4, 1] for gap in gaps: for i in range(gap, len(arr)): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Regular Expression Matching Using Dynamic Programming Problem Description You are asked to implement a function that determines if a given string matches a pattern. The pattern may contain special characters: - `.` which matches any single character. - `*` which matches zero or more of the preceding element. The function should cover the entire input string, i.e., from the beginning to the end. Function Signature ```python def is_match(s: str, p: str) -> bool: Determines if the given string s matches the pattern p. Parameters: s (str): The string to be matched. p (str): The pattern containing regex like \'.\' and \'*\'. Returns: bool: True if the string matches the pattern, False otherwise. ``` Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints - Input strings `s` and `p` should have lengths in the range `[0, 1000]`. - The pattern `p` contains only lowercase English letters, \'.\', and \'*\'. - The input string `s` contains only lowercase English letters. Performance Requirements - Time complexity should be (O(n times m)) where (n) is the length of the input string `s` and (m) is the length of the pattern `p`. - Space complexity should be (O(n times m)) due to the DP table usage. Start by setting up a DP table and initializing it. Then, iterate through each character of the string and the pattern to fill up the table based on the rules for `.` and `*`.","solution":"def is_match(s: str, p: str) -> bool: Determines if the given string s matches the pattern p. Parameters: s (str): The string to be matched. p (str): The pattern containing regex like \'.\' and \'*\'. Returns: bool: True if the string matches the pattern, False otherwise. # Initialize a DP table with False dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # An empty string matches an empty pattern dp[0][0] = True # Fill the first row for patterns like a*, a*b*, a*b*c* for j in range(1, len(p) + 1): if p[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] # Fill the rest of the DP table for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (p[j - 2] == s[i - 1] or p[j - 2] == \'.\')) # The result is in the bottom-right cell of the DP table return dp[len(s)][len(p)]"},{"question":"# Connectivity Query Evaluation with Union-Find You are given a 2D grid initially filled with water (represented by `0`), and a series of addLand operations that turn certain water cells into land (represented by `1`). Implement a function that processes these operations and returns the number of islands after each operation. An island is defined as a group of land cells connected horizontally or vertically. Given a list of positions for the addLand operations, return an array where each element is the count of islands after the corresponding operation. Function signature: ```python def num_islands(positions: List[List[int]]) -> List[int]: ... ``` Input: - A list `positions` of addLand operations, where each element is a list of two integers `[x, y]` representing the cell to turn into land. Output: - A list of integers where each element is the number of islands after the corresponding operation. Constraints: - The grid size is unbounded. Use dynamic allocation as positions are added. - Implement your solution with an efficient approach to handle up to 10^4 operations within reasonable performance limits. Example: ```python positions = [[0, 0], [0, 1], [1, 2], [2, 1]] assert num_islands(positions) == [1, 1, 2, 3] ``` Description: 1. At the start, the 2D grid is entirely filled with water (`0`). 2. Add land operations are performed on specific cells. 3. Each operation may unite cells into forming islands, and we need to count the number of distinct islands after each operation. 4. Use the Union-Find structure to manage connected components dynamically, leveraging path compression and union by size/rank optimizations.","solution":"def num_islands(positions): Returns the number of islands after each land addition operation. Positions is a list of [x, y] coordinates indicating the cells to turn into land. parent = {} rank = {} count = 0 results = [] def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): nonlocal count root_x = find(x) root_y = find(y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 count -= 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for x, y in positions: if (x, y) in parent: results.append(count) continue count += 1 parent[(x, y)] = (x, y) rank[(x, y)] = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if (nx, ny) in parent: union((x, y), (nx, ny)) results.append(count) return results"},{"question":"# Segment Tree Range Minimum Query **Scenario**: You are tasked to build a range minimum query (RMQ) system for an analytics platform that needs to handle multiple range minimum queries and point updates on large datasets efficiently. The analytics platform receives time-series data that requires frequent querying and updating. Your job is to implement this system using a Segment Tree data structure. # Objective: Implement a function `build_segment_tree(arr: List[int]) -> SegmentTree` that constructs a segment tree from a given list of integers where the tree supports: - Updating a particular index\'s value. - Querying the minimum value in a given range. # Function Definitions: ```python class SegmentTree: def __init__(self, arr: List[int]): Initialize and build the segment tree. # Your implementation here def update(self, index: int, value: int) -> None: Update the element at index \'index\' with \'value\'. # Your implementation here def query(self, left: int, right: int) -> int: Return the minimum value in the range [left, right]. # Your implementation here ``` # Constraints: 1. `1 <= len(arr) <= 10^5` 2. `-10^9 <= arr[i] <= 10^9` 3. `0 <= index < len(arr)` 4. `0 <= left <= right < len(arr)` # Example: ```python # Example usage arr = [2, 4, 5, 3, 4] segment_tree = SegmentTree(arr) print(segment_tree.query(2, 4)) # Output: 3 (the minimum of [5, 3, 4]) segment_tree.update(3, 6) print(segment_tree.query(0, 3)) # Output: 2 (the minimum of [2, 4, 5, 6]) ``` # Notes: - You may assume the array will not be empty. - Focus on optimizing both the update and query operations.","solution":"class SegmentTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (4 * self.n) self.build_tree(arr, 0, 0, self.n - 1) def build_tree(self, arr, node, start, end): if start == end: self.tree[node] = arr[start] else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 self.build_tree(arr, left_node, start, mid) self.build_tree(arr, right_node, mid + 1, end) self.tree[node] = min(self.tree[left_node], self.tree[right_node]) def update(self, index, value): self._update(0, 0, self.n - 1, index, value) def _update(self, node, start, end, idx, value): if start == end: self.tree[node] = value else: mid = (start + end) // 2 left_node = 2 * node + 1 right_node = 2 * node + 2 if start <= idx <= mid: self._update(left_node, start, mid, idx, value) else: self._update(right_node, mid + 1, end, idx, value) self.tree[node] = min(self.tree[left_node], self.tree[right_node]) def query(self, left, right): return self._query(0, 0, self.n - 1, left, right) def _query(self, node, start, end, L, R): if R < start or end < L: return float(\'inf\') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_query = self._query(2 * node + 1, start, mid, L, R) right_query = self._query(2 * node + 2, mid + 1, end, L, R) return min(left_query, right_query)"},{"question":"# Context You\'re given a task to analyze the strongly connected components in a directed graph using Kosaraju’s algorithm. An SCC is a maximal subgraph such that any two vertices are reachable from each other. This problem is critical in various applications like cycle detection, module dependency resolution, and understanding subgroup structures in complex networks. # Problem Statement Write a function `find_scc` that takes the number of vertices `V`, and an adjacency list `adj` representing a directed graph. Implement Kosaraju\'s algorithm to find and return the number of strongly connected components in the graph. # Function Signature ```python def find_scc(V: int, adj: List[List[int]]) -> int: ``` # Input * `V` (1 ≤ V ≤ 10^5): An integer representing the number of vertices. * `adj`: A list of lists where `adj[i]` contains all vertices that have a directed edge from vertex `i`. # Output * Returns an integer representing the number of strongly connected components. # Constraints * The graph may contain self-loops or multiple edges between the same pair of vertices. * The graph may be disconnected. # Example ```python # Example 1 V = 6 adj = [ [2], # 0 [0], # 1 [3], # 2 [1, 4],# 3 [5], # 4 [4], # 5 ] assert find_scc(V, adj) == 2 # SCCs: {0, 1, 2, 3} and {4, 5} # Example 2 V = 5 adj = [ [1], # 0 [2], # 1 [0], # 2 [4], # 3 [], # 4 ] assert find_scc(V, adj) == 3 # SCCs: {0, 1, 2}, {3}, {4} ``` Ensure your implementation efficiently handles the constraints and edge cases mentioned in the analysis. Perform rigorous testing to verify correctness.","solution":"from typing import List def find_scc(V: int, adj: List[List[int]]) -> int: def dfs(v, visited, stack): visited[v] = True for neighbour in adj[v]: if not visited[neighbour]: dfs(neighbour, visited, stack) stack.append(v) def reverse_graph(): rev_adj = [[] for _ in range(V)] for v in range(V): for neighbour in adj[v]: rev_adj[neighbour].append(v) return rev_adj def fill_order(): visited = [False] * V stack = [] for v in range(V): if not visited[v]: dfs(v, visited, stack) return stack def dfs_util(v, visited, rev_adj): visited[v] = True for neighbour in rev_adj[v]: if not visited[neighbour]: dfs_util(neighbour, visited, rev_adj) stack = fill_order() rev_adj = reverse_graph() visited = [False] * V count = 0 while stack: v = stack.pop() if not visited[v]: dfs_util(v, visited, rev_adj) count += 1 return count"},{"question":"# Summary You are given an undirected graph represented as an adjacency list and need to find paths between specified nodes. Implement graph traversal functions to assess your understanding of recursive backtracking algorithms and their applications. # Requirement Implement the following function: ```python def enhanced_find_shortest_path(graph, start, end): Find the shortest path between two nodes in an undirected graph using BFS. :param graph: dict, represents the adjacency list of an undirected graph. :param start: node, the start node :param end: node, the end node :return: list representing the shortest path from start to end or None if no path exists. # Your code here ``` # Example Input and Output Example 1: ```python graph = { \'A\': [\'B\', \'C\', \'D\'], \'B\': [\'A\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'A\'], \'E\': [\'B\'], \'F\': [\'C\'] } start = \'A\' end = \'F\' assert enhanced_find_shortest_path(graph, start, end) == [\'A\', \'C\', \'F\'] ``` Example 2: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' end = \'F\' assert enhanced_find_shortest_path(graph, start, end) == [\'A\', \'C\', \'F\'] ``` # Constraints and Considerations - The graph is an undirected graph. - The nodes are represented as strings. - You may assume that the start and end nodes will be present in the graph. - Optimize your implementation for both time and space complexity. - Handle the case where no path exists gracefully by returning `None`. # Performance Requirements Your solution should be efficient enough to handle large graphs with several thousand nodes and edges efficiently. **Note**: Use Breadth-First Search (BFS) to ensure optimal path selection, taking advantage of its ability to explore the shortest path in unweighted graphs.","solution":"from collections import deque def enhanced_find_shortest_path(graph, start, end): Find the shortest path between two nodes in an undirected graph using BFS. :param graph: dict, represents the adjacency list of an undirected graph. :param start: node, the start node :param end: node, the end node :return: list representing the shortest path from start to end or None if no path exists. if start == end: return [start] queue = deque([(start, [start])]) visited = set() while queue: current_node, path = queue.popleft() visited.add(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: if neighbor == end: return path + [neighbor] queue.append((neighbor, path + [neighbor])) visited.add(neighbor) return None"},{"question":"Find the Extra Character Given two strings `s` and `t` which consist of only lowercase letters. String `t` is generated by random shuffling string `s` and then adding one more letter at a random position. Your task is to write a function `find_difference(s: str, t: str) -> str` that finds the letter that was added in `t`. # Input * `s`: A string of lowercase letters, 1 <= len(s) <= 10^4 * `t`: A string of lowercase letters such that len(t) = len(s) + 1 # Output * The letter that was added to string `t` # Example ```python assert find_difference(\\"abcd\\", \\"abecd\\") == \'e\' assert find_difference(\\"\\", \\"y\\") == \'y\' assert find_difference(\\"a\\", \\"aa\\") == \'a\' ``` # Constraints * Both strings consist of only lowercase Latin letters (a-z). * `t` is guaranteed to have exactly one extra character compared to `s`. # Performance Requirements * Your solution should have O(n) time complexity and O(1) space complexity. # Testing and Edge Cases Ensure your implementation handles: * Empty `s` with one character in `t`. * Duplicate characters in `s`. * Large strings up to the maximum length constraint.","solution":"def find_difference(s: str, t: str) -> str: Find the extra character in \'t\' which is not in \'s\'. s_count = [0] * 26 t_count = [0] * 26 for char in s: s_count[ord(char) - ord(\'a\')] += 1 for char in t: t_count[ord(char) - ord(\'a\')] += 1 for i in range(26): if t_count[i] > s_count[i]: return chr(i + ord(\'a\'))"},{"question":"**Problem Statement:** You are working on a digital formatting tool that needs to estimate the width of number fields in a tabular display system. This tool must quickly determine the number of digits in various integers to allocate appropriate space for their display. Your task is to implement a function `count_digits_in_list(numbers)` that takes a list of integers and returns a new list where each element corresponds to the number of digits in the respective integer from the input list. # Function Signature ```python def count_digits_in_list(numbers: List[int]) -> List[int]: pass ``` # Input * `numbers` - A list of integers. The list will have at most 10^5 elements, and each integer will be in the range [-10^18, 10^18]. # Output * A list of integers where each element is the digit count of the corresponding integer from the input list. # Constraints * You must solve the problem with a time complexity of O(n), where n is the length of the input list. # Example ```python # Example 1 numbers = [1234, 56, -7890, 0, 3] assert count_digits_in_list(numbers) == [4, 2, 4, 1, 1] # Example 2 numbers = [99, -1000000] assert count_digits_in_list(numbers) == [2, 7] ``` # Notes * Ensure your function handles negative integers correctly by using their absolute values. * Efficiently use Python libraries if necessary, but avoid unnecessary overhead to maintain the required time complexity.","solution":"from typing import List def count_digits_in_list(numbers: List[int]) -> List[int]: Returns a list where each element corresponds to the number of digits in the respective integer from the input list. return [len(str(abs(num))) if num != 0 else 1 for num in numbers]"},{"question":"# Task You\'re given two two-dimensional matrices represented as lists of lists. Your task is to implement a function `optimized_multiply` to compute the product of these matrices using an optimized approach with a specific focus on reducing the time complexity from (O(n^3)) to (O(n^{log_2 7})). # Implementation Details 1. **Function Signature**: ```python def optimized_multiply(multiplicand: list, multiplier: list) -> list: ``` 2. **Input**: - `multiplicand`: A list of lists representing a matrix of size (m times n). - `multiplier`: A list of lists representing a matrix of size (n times p). 3. **Output**: - A list of lists representing the resultant matrix of size (m times p). 4. **Constraints**: - 1 <= m, n, p <= 500. - The elements of the matrices will be integers within the range ([-10^3, 10^3]). 5. **Edge Cases**: - Matrices with incompatible dimensions should raise an exception. - Ensure the matrices are rectangular (all rows are of equal length). # Example ```python # Example input: multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # Example output: # [ # [58, 64], # [139, 154] # ] ``` # Guidelines 1. Implement Strassen\'s Algorithm to optimize the matrix multiplication. 2. Handle edge cases appropriately. 3. Ensure that your solution can handle up to the maximum constraints efficiently.","solution":"def add_matrices(a, b): Adds two matrices element-wise. n = len(a) result = [[a[i][j] + b[i][j] for j in range(n)] for i in range(n)] return result def subtract_matrices(a, b): Subtracts two matrices element-wise. n = len(a) result = [[a[i][j] - b[i][j] for j in range(n)] for i in range(n)] return result def split_matrix(matrix): Splits a given matrix into four sub-matrices. n = len(matrix) mid = n // 2 a11 = [row[:mid] for row in matrix[:mid]] a12 = [row[mid:] for row in matrix[:mid]] a21 = [row[:mid] for row in matrix[mid:]] a22 = [row[mid:] for row in matrix[mid:]] return a11, a12, a21, a22 def strassen_multiply(a, b): Multiplies two matrices using Strassen\'s algorithm. n = len(a) if n <= 2: return [[a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1]], [a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1]]] a11, a12, a21, a22 = split_matrix(a) b11, b12, b21, b22 = split_matrix(b) m1 = strassen_multiply(add_matrices(a11, a22), add_matrices(b11, b22)) m2 = strassen_multiply(add_matrices(a21, a22), b11) m3 = strassen_multiply(a11, subtract_matrices(b12, b22)) m4 = strassen_multiply(a22, subtract_matrices(b21, b11)) m5 = strassen_multiply(add_matrices(a11, a12), b22) m6 = strassen_multiply(subtract_matrices(a21, a11), add_matrices(b11, b12)) m7 = strassen_multiply(subtract_matrices(a12, a22), add_matrices(b21, b22)) c11 = add_matrices(subtract_matrices(add_matrices(m1, m4), m5), m7) c12 = add_matrices(m3, m5) c21 = add_matrices(m2, m4) c22 = add_matrices(subtract_matrices(add_matrices(m1, m3), m2), m6) result = [] for i in range(len(c11)): result.append(c11[i] + c12[i]) for i in range(len(c21)): result.append(c21[i] + c22[i]) return result def padded_matrix(matrix, size): Pads the given matrix with zeros to the desired size. padded = [[0] * size for _ in range(size)] for i in range(len(matrix)): for j in range(len(matrix[i])): padded[i][j] = matrix[i][j] return padded def optimized_multiply(multiplicand, multiplier): Multiplies two matrices using Strassen\'s algorithm after padding them to be of size 2^k x 2^k. assert len(multiplicand[0]) == len(multiplier), \\"Incompatible matrix dimensions for multiplication\\" max_size = max(len(multiplicand), len(multiplicand[0]), len(multiplier[0])) size = 1 while size < max_size: size *= 2 padded_multiplicand = padded_matrix(multiplicand, size) padded_multiplier = padded_matrix(multiplier, size) result = strassen_multiply(padded_multiplicand, padded_multiplier) return [row[:len(multiplier[0])] for row in result[:len(multiplicand)]]"},{"question":"# Scenario You are tasked with analyzing a binary search tree structure to assess how sparse it is by counting the number of empty branches. An empty branch is defined as a node\'s child that is None. Your goal is to write a function that counts all such empty branches in the tree. # Problem Statement Implement a function `num_empty` that takes the root of a binary search tree as an input and returns the number of empty branches in the tree. # Function Signature ```python def num_empty(root: Node) -> int: ``` # Input - `root`: The root node of a binary search tree. If the tree is empty (i.e., the root is `None`), the function should return 1. # Output - An integer representing the number of empty branches in the tree. # Constraints - Each node in the tree has at most two children (left, right). - The tree can have any number of nodes, including zero. - Assume the input is a valid binary search tree. # Examples ```python # Example 1 # Tree: # 9 # / # 6 12 # / # 3 8 15 # / # 10 root = Node(9) root.left = Node(6) root.right = Node(12) root.left.left = Node(3) root.left.right = Node(8) root.right.right = Node(15) root.right.right.left = Node(10) assert num_empty(root) == 8 # Example 2 # Tree is empty assert num_empty(None) == 1 ``` # Requirements - Handle different tree shapes and sizes. - Ensure performance is optimal for large trees. - Consider edge cases, such as an empty tree or a tree with one node. # Additional Information - The provided `Node` class represents a node in a binary search tree: ```python class Node: def __init__(self, value): self.value = value self.left = None self.right = None ```","solution":"class Node: def __init__(self, value): self.value = value self.left = None self.right = None def num_empty(root: Node) -> int: if root is None: return 1 count = 0 if root.left is None: count += 1 else: count += num_empty(root.left) if root.right is None: count += 1 else: count += num_empty(root.right) return count"},{"question":"# Coding Challenge: Reverse Order Big Integer Addition You are provided with two numbers in two non-empty singly linked lists, where each linked list node represents a single digit. The digits are stored in **reverse order** such that the 1\'s digit is placed first. Your task is to write a function `add_two_numbers` to add these two numbers and return the sum as a linked list in the same reverse order. # Function Signature: ```python class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(l1: Node, l2: Node) -> Node: ``` # Input: * Two linked lists, `l1` and `l2`, representing two non-negative integers. * Each linked list node contains a single digit, and the digits are stored in reverse order. # Output: * Return the sum as a linked list in reverse order. # Constraints: * The numbers do not contain any leading zeros, except for the number zero itself. * The input linked list nodes will have values ranging from 0 to 9. # Example: ```python # Input: (2 -> 4 -> 3) + (5 -> 6 -> 4) # Output: 7 -> 0 -> 8 # Explanation: 342 + 465 = 807, and the digits in reverse order are 7 -> 0 -> 8. ``` # Instructions: 1. Define the Node class. 2. Write the `add_two_numbers` function. 3. Ensure you handle carry-over correctly when summing digits. 4. Consider edge cases such as lists of different lengths, all zeros, and carry-over extending the result. # Testing: You can use the following test cases to validate your implementation: ```python import unittest class TestAddTwoNumbers(unittest.TestCase): def test_examples(self): def list_to_linked_list(lst): head = Node(0) current = head for num in lst: current.next = Node(num) current = current.next return head.next def linked_list_to_list(node): result = [] while node: result.append(node.val) node = node.next return result l1 = list_to_linked_list([2, 4, 3]) l2 = list_to_linked_list([5, 6, 4]) result = add_two_numbers(l1, l2) self.assertEqual(linked_list_to_list(result), [7, 0, 8]) l1 = list_to_linked_list([9, 9, 9, 9, 9, 9, 9]) l2 = list_to_linked_list([9, 9, 9, 9]) result = add_two_numbers(l1, l2) self.assertEqual(linked_list_to_list(result), [8, 9, 9, 9, 0, 0, 0, 1]) l1 = list_to_linked_list([0]) l2 = list_to_linked_list([0]) result = add_two_numbers(l1, l2) self.assertEqual(linked_list_to_list(result), [0]) if __name__ == \\"__main__\\": unittest.main() ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def add_two_numbers(l1: Node, l2: Node) -> Node: dummy_head = Node(0) current = dummy_head carry = 0 while l1 is not None or l2 is not None or carry != 0: val1 = l1.val if l1 is not None else 0 val2 = l2.val if l2 is not None else 0 # Calculate the new carry and the current digit\'s value carry, out = divmod(val1 + val2 + carry, 10) current.next = Node(out) current = current.next if l1 is not None: l1 = l1.next if l2 is not None: l2 = l2.next return dummy_head.next"},{"question":"# Word Search II Challenge You are given a board defined by a 2D grid of characters and a list of words. Your task is to implement a function that finds all the words that can be formed on the board by performing a sequence of adjacent moves (left, right, up, down) starting from any cell. Each word should be constructed by only using cells once per word. **Function Signature**: ```python def find_words(board: List[List[str]], words: List[str]) -> List[str]: ``` **Input**: - `board`, a 2D list of characters (e.g., `[[\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\']]`) - `words`, a list of strings representing the words to be searched (e.g., `[\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"]`) **Output**: - A list of strings representing the words found on the board that exist in the given list of words. - The output list should not have any duplicates. **Constraints**: - All input characters are lowercase English letters. - The board dimensions can be a maximum of 12x12. - The total number of words does not exceed 5000. - Each word\'s length does not exceed 10 characters. **Performance Requirements**: - The solution should aim to be as efficient as possible, handling the worst-case scenarios within practical limits of memory and computation. **Example**: ```python board = [ [\'o\',\'a\',\'a\',\'n\'], [\'e\',\'t\',\'a\',\'e\'], [\'i\',\'h\',\'k\',\'r\'], [\'i\',\'f\',\'l\',\'v\'] ] words = [\\"oath\\",\\"pea\\",\\"eat\\",\\"rain\\"] print(find_words(board, words)) # Output: [\\"oath\\",\\"eat\\"] ``` Ensure you handle edge cases such as empty words list, empty board, or no words found.","solution":"from typing import List, Set def find_words(board: List[List[str]], words: List[str]) -> List[str]: def backtrack(i, j, node, prefix): char = board[i][j] curr_node = node[char] word_match = curr_node.pop(\'#\', False) if word_match: found_words.add(prefix + char) board[i][j] = \'#\' for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < len(board) and 0 <= nj < len(board[0]) and board[ni][nj] in curr_node: backtrack(ni, nj, curr_node, prefix + char) board[i][j] = char if not curr_node: node.pop(char) def build_trie(words): root = {} for word in words: node = root for char in word: node = node.setdefault(char, {}) node[\'#\'] = word return root found_words = set() trie = build_trie(words) for i in range(len(board)): for j in range(len(board[0])): if board[i][j] in trie: backtrack(i, j, trie, \\"\\") return list(found_words)"},{"question":"# Diffie-Hellman Key Exchange with Additional Security In this exercise, you are required to implement the Diffie-Hellman Key Exchange protocol with additional security checks and optimizations. The goal is to ensure the secure exchange of keys between two entities, Alice and Bob, while maintaining the integrity and efficiency of the operations. # Task: 1. **Prime Check**: Implement a function to check if a given number is prime. 2. **Euler\'s Totient Function**: Implement a function to compute the Euler\'s totient function of a given number. 3. **Primitive Root Computation**: Implement a function to find all primitive roots of a given prime number. 4. **Key Generation and Exchange**: Implement functions for Alice and Bob to generate private and public keys, exchange them, and compute the shared secret key. 5. **Enhanced Diffie-Hellman Protocol**: Combine the above components with security checks and optimizations to implement a secure key exchange. # Function Specifications: 1. Prime Check Function ```python def is_prime(n: int) -> bool: Function to check if a given number n is prime. Parameters: n (int): The number to check for primality. Returns: bool: True if n is a prime number, False otherwise. pass ``` 2. Euler\'s Totient Function ```python def euler_totient(n: int) -> int: Function to compute the Euler\'s totient function ϕ(n). Parameters: n (int): The number to compute the totient function for. Returns: int: The count of integers between 1 and n inclusive that are coprime to n. pass ``` 3. Find Primitive Roots ```python def find_primitive_roots(n: int) -> list: Function to find all primitive roots of a given prime number n. Parameters: n (int): The prime number to find primitive roots for. Returns: list: A list of all primitive roots of n. pass ``` 4. Generate Private and Public Keys ```python def generate_private_key(p: int) -> int: Function to generate a private key in the range 1 to p−1. Parameters: p (int): The prime number defining the range for the private key. Returns: int: A randomly chosen private key. pass def generate_public_key(private_key: int, a: int, p: int) -> int: Function to generate a public key using the private key, a primitive root a, and a prime number p. Parameters: private_key (int): The private key to be used for generating the public key. a (int): The primitive root. p (int): The prime number. Returns: int: The public key. pass ``` 5. Compute Shared Secret Key ```python def compute_shared_key(public_key: int, private_key: int, p: int) -> int: Function to compute the shared secret key using the public key of the other party, own private key, and prime number p. Parameters: public_key (int): The public key received from the other party. private_key (int): The private key of the user. p (int): The prime number. Returns: int: The computed shared secret key. pass ``` 6. Complete Diffie-Hellman Key Exchange Protocol ```python def diffie_hellman_key_exchange(a: int, p: int) -> bool: Function to perform the Diffie-Hellman key exchange between two parties using the given primitive root a and prime number p. Parameters: a (int): Primitive root of the prime number p. p (int): A prime number for defining the key space. Returns: bool: True if the shared keys computed by both parties match, False otherwise. pass ``` # Constraints: - The prime number p should be in the range [2, 10^9]. - The primitive root a should be a valid primitive root of p. - The calculations should ensure minimal time complexity and efficient execution. **Your task is to implement the specified functions and the complete Diffie-Hellman key exchange protocol considering the specified constraints and enhance security measures.**","solution":"import random from math import gcd def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def euler_totient(n: int) -> int: result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def find_primitive_roots(p: int) -> list: if not is_prime(p): raise ValueError(\\"p must be prime\\") totient = euler_totient(p) factors = prime_factors(totient) primitive_roots = [] for g in range(2, p): if all(pow(g, totient // f, p) != 1 for f in factors): primitive_roots.append(g) return primitive_roots def prime_factors(n: int) -> list: factors = set() d = 2 while d * d <= n: while (n % d) == 0: factors.add(d) n //= d d += 1 if n > 1: factors.add(n) return factors def generate_private_key(p: int) -> int: return random.randint(2, p - 2) def generate_public_key(private_key: int, a: int, p: int) -> int: return pow(a, private_key, p) def compute_shared_key(public_key: int, private_key: int, p: int) -> int: return pow(public_key, private_key, p) def diffie_hellman_key_exchange(a: int, p: int) -> bool: alice_private = generate_private_key(p) bob_private = generate_private_key(p) alice_public = generate_public_key(alice_private, a, p) bob_public = generate_public_key(bob_private, a, p) alice_shared = compute_shared_key(bob_public, alice_private, p) bob_shared = compute_shared_key(alice_public, bob_private, p) return alice_shared == bob_shared"},{"question":"# Cycle Sort Implementation and Application Scenario You have a large list of unique student IDs that you need to sort. These student IDs are used in a distributed system where minimizing the number of write operations to the memory is critical for performance enhancements. The optimal sorting algorithm in this case would be the Cycle Sort due to its property of minimizing memory writes. Task You are required to: 1. Implement the Cycle Sort algorithm. 2. Apply it to a list of student IDs and return the sorted list. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: Sorts an array of integers using Cycle Sort algorithm. Parameters: arr (List[int]): A list of unique integers representing student IDs. Returns: List[int]: A sorted list of student IDs. ``` Input * A list `arr` of integers representing unique student IDs. (1 <= len(arr) <= 10^5, each element in the range [1, 10^6]). Output * A sorted list of student IDs. Constraints * You must minimize the number of write operations to memory. Performance Requirement * Aim for the minimal number of writes, but keep in mind the algorithm’s O(N^2) time complexity. Example ```python assert cycle_sort([106, 34, 56, 78, 212]) == [34, 56, 78, 106, 212] assert cycle_sort([20, 10, 30, 50, 40]) == [10, 20, 30, 40, 50] ```","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"Implement the Bitonic Sort algorithm as described below. Your task is to write a function `custom_bitonic_sort` which will take a list of integers and an optional boolean argument indicating whether the list should be sorted in ascending (`True`, default) or descending (`False`) order. # Function Signature ```python def custom_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` # Input * `arr`: List of integers (size must be a power of two). * `reverse`: Boolean value indicating sort order (default is `False` for ascending). # Output * Returns a new list of integers sorted as per the `reverse` flag. # Constraints * 1 <= len(arr) <= 2**10 (1024) * The size of `arr` must be a power of two. # Instructions 1. You must ensure the input array\'s size is a power of two. If not, raise an appropriate error. 2. Implement the helper functions `compare` and `bitonic_merge` as needed. 3. Utilize recursive decomposition to sort the array. 4. Ensure your solution is efficient and handles edge cases correctly. # Example Usage ```python # Example 1 print(custom_bitonic_sort([3, 7, 2, 5, 1, 6, 4, 0])) # Output: [0, 1, 2, 3, 4, 5, 6, 7] # Example 2 print(custom_bitonic_sort([3, 7, 2, 5, 1, 6, 4, 0], reverse=True)) # Output: [7, 6, 5, 4, 3, 2, 1, 0] # Example 3 (Invalid size) print(custom_bitonic_sort([3, 7, 2, 5, 1])) # Output: ValueError: The size of input should be power of two ``` # Hints * Consider breaking the problem into smaller tasks and focus first on the bitonic merge function. * Verify the input size requirement before proceeding with sorting. * Carefully test your implementation with various edge cases mentioned.","solution":"from typing import List def custom_bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: def is_power_of_two(n: int) -> bool: return (n & (n - 1) == 0) and n != 0 def bitonic_compare_and_swap(arr: List[int], i: int, j: int, asc: bool) -> None: if (asc and arr[i] > arr[j]) or (not asc and arr[i] < arr[j]): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, asc: bool) -> None: if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, asc) bitonic_merge(arr, low, k, asc) bitonic_merge(arr, low + k, k, asc) def bitonic_sort(arr: List[int], low: int, cnt: int, asc: bool) -> None: if cnt > 1: k = cnt // 2 bitonic_sort(arr, low, k, True) bitonic_sort(arr, low + k, k, False) bitonic_merge(arr, low, cnt, asc) if not is_power_of_two(len(arr)): raise ValueError(\\"The size of input should be a power of two\\") bitonic_sort(arr, 0, len(arr), not reverse) return arr"},{"question":"# Pattern Matching Under Constraints **Objective**: Implement a function to determine if a given string follows a specified pattern using a backtracking approach. **Function Signature**: ```python def pattern_match(pattern: str, string: str) -> bool: ``` **Parameters**: - `pattern`: A non-empty string containing only lowercase letters that represents a pattern of how substrings should map. - `string`: A non-empty string containing only lowercase letters which we need to evaluate against the pattern. **Output**: - Returns `True` if the string follows the pattern according to the described rules; otherwise, returns `False`. # Constraints and Requirements: - Both `pattern` and `string` will contain only lowercase English letters. - Assume the length of `pattern` is at most 10 and the length of `string` is at most 20. - The pattern matching must consider a bijection (one-to-one mapping) between characters in the pattern and non-empty substrings in the string. - The function must efficiently handle edge cases, such as mismatched lengths and patterns without valid mappings. # Example: 1. `pattern = \\"abab\\", string = \\"redblueredblue\\"`: - Expected Output: `True` (Mapping: a -> \\"red\\", b -> \\"blue\\") 2. `pattern = \\"aaaa\\", string = \\"asdasdasdasd\\"`: - Expected Output: `True` (Mapping: a -> \\"asd\\") 3. `pattern = \\"aabb\\", string = \\"xyzabcxzyabc\\"`: - Expected Output: `False` (No valid mapping) # Instructions: 1. Implement the function `pattern_match` to solve the problem. 2. Include appropriate edge case handling and ensure your code efficiency in both time and space complexity. 3. Test your implementation with the provided examples and additional cases of your design.","solution":"def pattern_match(pattern, string): def is_match(pattern, string, pmap, smap): # If both pattern and string are exhausted, we\'ve found a valid match if not pattern and not string: return True # If only one is exhausted, but not the other, it\'s not a valid match if not pattern or not string: return False # Get the current character in the pattern p_char = pattern[0] # Try to map the current pattern character to all possible substrings in string for end in range(1, len(string) - len(pattern) + 2): sub_str = string[:end] if p_char in pmap: if pmap[p_char] != sub_str: continue # If it matches, proceed to check the rest if is_match(pattern[1:], string[end:], pmap, smap): return True else: if sub_str in smap: continue # Set the mappings and proceed pmap[p_char] = sub_str smap[sub_str] = p_char if is_match(pattern[1:], string[end:], pmap, smap): return True # Remove the mappings as they didn\'t work out del pmap[p_char] del smap[sub_str] return False return is_match(pattern, string, {}, {})"},{"question":"# Path Finding in Graphs Objective You are tasked with improving the efficiency of finding paths in an unweighted graph. Given the provided recursive and backtracking solutions, your task is to minimize memory usage while maintaining accuracy and clarity. Problem Statement You should implement an iterative function that finds all paths from a given starting node to an end node in an unweighted graph. Your solution should avoid the common pitfalls of deep recursion and manage space efficiently. Function Signature ```python def find_all_paths_iterative(graph: dict, start: str, end: str) -> list: Find all paths from start node to end node in an unweighted graph using an iterative approach. :param graph: Dict representing an adjacency list of the graph. :param start: The starting node. :param end: The end node. :return: A list of lists, where each list represents a path from start to end. pass ``` Input and Output Specifications * **Input**: * `graph`: Dictionary where keys are node names and values are lists of adjacent nodes. * `start`: String representing the starting node. * `end`: String representing the target end node. * **Output**: * List of lists, where each inner list is a path from the start node to the end node. Constraints * Nodes in the graph are represented by unique strings. * Both `start` and `end` appear in the graph. * The graph is unweighted and directed. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [] } assert find_all_paths_iterative(graph, \'A\', \'D\') == [[\'A\', \'B\', \'C\', \'D\'], [\'A\', \'B\', \'D\'], [\'A\', \'C\', \'D\']] ``` Performance Requirements * Aim to implement the solution without deep recursive calls. * Ensure efficient management of memory.","solution":"def find_all_paths_iterative(graph: dict, start: str, end: str) -> list: Find all paths from start node to end node in an unweighted graph using an iterative approach. :param graph: Dict representing an adjacency list of the graph. :param start: The starting node. :param end: The end node. :return: A list of lists, where each list represents a path from start to end. all_paths = [] stack = [(start, [start])] # stack of (current_node, path_so_far) while stack: current_node, path = stack.pop() if current_node == end: all_paths.append(path) else: for neighbor in graph.get(current_node, []): if neighbor not in path: # prevent cycles stack.append((neighbor, path + [neighbor])) return all_paths"},{"question":"Enhanced Bogo Sort Analysis Context: Imagine you\'re teaching a class on sorting algorithms, and you have just demonstrated the infamous Bogo Sort to your students, highlighting its inefficiency. To reinforce their understanding of better sorting algorithms, you want them to compare Bogo Sort with an optimized sorting algorithm on a shuffled array. Task: Write a Python function `compare_sorts(arr)` that performs the following steps: 1. Takes a list `arr` of integers. 2. Sorts the list using Bogo Sort and measures the time taken. If the Bogo Sort fails to sort the list within a reasonable time frame (e.g., after 1000 iterations), it should stop. 3. Sorts the list using a more efficient algorithm, such as Quick Sort, and measures the time taken. 4. Returns a dictionary with the time taken by each sorting algorithm and a note if Bogo Sort was terminated early. Requirements: 1. Implement the function `compare_sorts(arr: list) -> dict`. 2. Input: A list of integers. 3. Output: A dictionary with keys `\'bogo_sort_time\'`, `\'quick_sort_time\'`, and `\'bogo_sort_terminated_early\'`. 4. Ensure time measurement accuracy using the `time` module. Example: ```python from time import time def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def bogo_sort(arr, max_iterations=1000): iteration = 0 def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True while not is_sorted(arr): random.shuffle(arr) iteration += 1 if iteration >= max_iterations: return arr, False return arr, True def compare_sorts(arr): import time from copy import deepcopy arr_copy_bogo = deepcopy(arr) arr_copy_quick = deepcopy(arr) start_time = time.time() bogo_sorted, terminated_early = bogo_sort(arr_copy_bogo) bogo_sort_time = time.time() - start_time start_time = time.time() quick_sorted = quick_sort(arr_copy_quick) quick_sort_time = time.time() - start_time return { \\"bogo_sort_time\\": bogo_sort_time, \\"quick_sort_time\\": quick_sort_time, \\"bogo_sort_terminated_early\\": not terminated_early } # Example usage: arr = [3, 2, 1] print(compare_sorts(arr)) ``` Explanation: - Feel free to test and tweak the function to ensure it handles different list sizes and randomness in shuffling for a thorough comparison. - The students are required to use the `time.time()` method for measuring computation time and `deepcopy` to prevent in-place sorting side effects.","solution":"import time import random from copy import deepcopy def quick_sort(arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def bogo_sort(arr, max_iterations=1000): iteration = 0 def is_sorted(arr): for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True while not is_sorted(arr): random.shuffle(arr) iteration += 1 if iteration >= max_iterations: return arr, False return arr, True def compare_sorts(arr): arr_copy_bogo = deepcopy(arr) arr_copy_quick = deepcopy(arr) start_time = time.time() _, terminated_early = bogo_sort(arr_copy_bogo) bogo_sort_time = time.time() - start_time start_time = time.time() quick_sorted = quick_sort(arr_copy_quick) quick_sort_time = time.time() - start_time return { \\"bogo_sort_time\\": bogo_sort_time, \\"quick_sort_time\\": quick_sort_time, \\"bogo_sort_terminated_early\\": not terminated_early }"},{"question":"# Question: Circle of Friends In a social network, people can form friendships over time. We want to keep track of groups of friends such that any two individuals in the same group are friends either directly or indirectly. Two people are indirectly friends if they have a common friend. Task: Implement a function `friend_circles(operations: List[Tuple[str, int, int]]) -> List[int]` that receives a list of operations and returns a list representing the number of distinct friend circles for each operation. Each operation is either: - **(“add”, person1, person2)**: A friendship between `person1` and `person2` is formed. - **(“count”, 0, 0)**: Indicate the current count of distinct friend circles. Example: ```python operations = [ (\\"add\\", 1, 2), (\\"count\\", 0, 0), (\\"add\\", 3, 4), (\\"count\\", 0, 0), (\\"add\\", 1, 3), (\\"count\\", 0, 0) ] print(friend_circles(operations)) # Output: [1, 2, 1] ``` Input Format: - A list of tuples `operations`: Each tuple contains a string and two integers. - `person1` and `person2` are integers representing person IDs (1 <= person ID <= 1000). Output Format: - A list of integers indicating the number of distinct friend circles after each “count” operation. # Constraints: - 1 <= number of operations <= 10^4. - Person IDs range from 1 to 1000. - There may be duplicate \\"add\\" operations but \\"count\\" operations should occur at the right positions. # Note: - Performance requirements are crucial. Aim for efficient implementations leveraging the Union-Find data structure. Example Explanation: Initially, everyone is their own friend circle: - **Operation 1**: `(“add”, 1, 2)` forms a friendship between person 1 and person 2. So, there’s one friend circle. - **Operation 2**: `(“count”, 0, 0)` should return 1 as there\'s only one circle so far. - **Operation 3**: `(“add”, 3, 4)` forms another friendship between person 3 and person 4. - **Operation 4**: `(“count”, 0, 0)` returns 2 as there are two separate friend circles. - **Operation 5**: `(“add”, 1, 3)` connects the circles of 1-2 and 3-4 into a single circle. - **Operation 6**: `(“count”, 0, 0)` returns 1 as there’s now just one large friend circle. Implement the `friend_circles` function to handle the above operations efficiently!","solution":"def friend_circles(operations): parent = {} rank = {} result = [] def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def add_friendship(person1, person2): if person1 not in parent: parent[person1] = person1 rank[person1] = 0 if person2 not in parent: parent[person2] = person2 rank[person2] = 0 union(person1, person2) def count_friend_circles(): roots = set() for person in parent: roots.add(find(person)) return len(roots) for op in operations: if op[0] == \\"add\\": add_friendship(op[1], op[2]) elif op[0] == \\"count\\": result.append(count_friend_circles()) return result"},{"question":"**Scenario**: Imagine you are developing a navigation feature for a game set in a grid-based dungeon. Players can only move to cells marked as walkable (indicated by a \\"1\\" in a grid). The goal is to find the shortest path from the top-left corner to the bottom-right corner of the dungeon grid. Write a function to determine this shortest path. **Problem Statement**: You are given a 2D list representing a grid. Each cell in the grid can either be walkable (indicated by 1) or blocked (indicated by 0). You need to write a function `find_shortest_path(maze: List[List[int]]) -> int` to compute the minimum number of steps required to move from the top-left corner (0,0) to the bottom-right corner (N-1,M-1) of the grid. If it is not possible to reach the bottom-right corner, return -1. **Function Signature**: ```python def find_shortest_path(maze: List[List[int]]) -> int: ``` **Input**: * `maze` (List[List[int]]): A 2D list of integers representing the grid, where `1` denotes a walkable cell and `0` denotes a blocked cell. The grid dimensions are at least 1x1. **Output**: * Return the minimum number of steps required to reach the bottom-right corner from the top-left corner. If there is no path, return -1. **Constraints**: * You can only move up, down, left, or right. * The grid dimensions are not fixed but are given by the input list dimensions. **Example**: ```python maze1 = [ [1, 0, 1, 1, 1, 1], [1, 0, 1, 0, 1, 0], [1, 0, 1, 0, 1, 1], [1, 1, 1, 0, 1, 1] ] # Expected output: 14 maze2 = [ [1, 0, 0], [0, 1, 1], [0, 1, 1] ] # Expected output: -1 ``` **Note**: * In the first example, the shortest path goes through every step and makes 14 steps to reach the bottom-right corner. * In the second example, it is impossible to reach the bottom-right corner from the top-left corner due to blocked cells.","solution":"from collections import deque from typing import List, Tuple def find_shortest_path(maze: List[List[int]]) -> int: Finds the shortest path in a grid from the top-left corner to the bottom-right corner. Returns the minimum number of steps, or -1 if the path is not possible. rows, columns = len(maze), len(maze[0]) # If the start or end point is blocked, return -1. if maze[0][0] == 0 or maze[rows-1][columns-1] == 0: return -1 # Directions array for moving in 4 possible directions (right, left, down, up) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, current_steps) visited = set((0, 0)) while queue: current_row, current_col, current_steps = queue.popleft() # If we reached the bottom-right corner, return the steps count if current_row == rows - 1 and current_col == columns - 1: return current_steps for direction in directions: new_row, new_col = current_row + direction[0], current_col + direction[1] if 0 <= new_row < rows and 0 <= new_col < columns and (new_row, new_col) not in visited and maze[new_row][new_col] == 1: visited.add((new_row, new_col)) queue.append((new_row, new_col, current_steps + 1)) # If we exited the queue without finding the target, return -1 return -1"},{"question":"# Scenario: Consider you are working on a software tool that compares binary versions of files efficiently. One common task within this tool is to determine how many bits differ between two file version identifiers (stored as integers). # Task: Write a function that determines the minimal number of bits you need to flip to convert integer A to integer B. This function will help in identifying the difference in binary file versions. # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input: * Two integers `a` and `b` where 0 <= a, b < 2^31. # Output: * An integer representing the number of bits that differ between `a` and `b`. # Constraints: * Performance must handle up to 32-bit integers efficiently. * Consider edge cases such as `a` being equal to `b`. # Example: ```python assert count_flips_to_convert(29, 15) == 2 assert count_flips_to_convert(0, 0) == 0 assert count_flips_to_convert(64, 32) == 2 assert count_flips_to_convert(255, 0) == 8 ``` # Explanation: *Example 1*: * 29 in binary is `11101` * 15 in binary is `01111` * The differing bits are the first and fourth from the right, so the number of flips needed is 2. *Example 2*: * For `a = 0` and `b = 0`, both are zero so no flips are needed, hence output is `0`. Write an efficient solution using bit manipulation techniques.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Determines the number of bits that need to be flipped to convert integer a to integer b. Parameters: - a (int): The first integer. - b (int): The second integer. Returns: - int: The number of differing bits between a and b. # XOR a and b to find differing bits xor_ab = a ^ b # Count the number of 1s in the binary representation of the XOR result count = 0 while xor_ab: count += xor_ab & 1 xor_ab >>= 1 return count"},{"question":"# Graph Traversal with Path Tracking Objective Implement an advanced version of both Depth-First Search (DFS) and Breadth-First Search (BFS) that not only returns the visited nodes but also tracks and returns the paths taken to visit each node. Problem Statement You need to enhance the DFS and BFS functions to return the path from the start node to each visited node. This will help understand the sequence of steps taken during the traversal and can be useful in applications such as route tracing in network graphs. Requirements 1. Implement the functions `dfs_traverse_with_paths` and `bfs_traverse_with_paths` that perform graph traversal and return paths. 2. Each function should take the graph and a starting node as input. 3. Each function should output a dictionary where keys are nodes and values are lists representing the path from the start node to that particular node. Function Signature ```python def dfs_traverse_with_paths(graph, start): # Your code here pass def bfs_traverse_with_paths(graph, start): # Your code here pass ``` Input Format - `graph`: A dictionary representing an adjacency list of the graph. `graph[node] = [list_of_neighbors]` - `start`: A node from which traversal begins. Assume `start` is always a valid node in the graph. Output Format - A dictionary where each key is a node and the value is the list representing the path from the start node to the key node. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\', \'E\'], \'C\': [\'F\'], \'D\': [], \'E\': [\'F\'], \'F\': [] } start = \'A\' dfs_paths = dfs_traverse_with_paths(graph, start) print(dfs_paths) # Example Output: # {\'A\': [\'A\'], \'B\': [\'A\', \'B\'], \'D\': [\'A\', \'B\', \'D\'], \'E\': [\'A\', \'B\', \'E\'], \'F\': [\'A\', \'B\', \'E\', \'F\'], \'C\': [\'A\', \'C\']} bfs_paths = bfs_traverse_with_paths(graph, start) print(bfs_paths) # Example Output: # {\'A\': [\'A\'], \'B\': [\'A\', \'B\'], \'C\': [\'A\', \'C\'], \'D\': [\'A\', \'B\', \'D\'], \'E\': [\'A\', \'B\', \'E\'], \'F\': [\'A\', \'C\', \'F\']} ``` Constraints - All nodes in the graph have unique identifiers. - The graph is finite, i.e., it has a limited number of nodes and edges. - Assume no parallel edges or self-loops in the graph. Good luck, and focus on handling edge cases and optimizing performance where possible!","solution":"def dfs_traverse_with_paths(graph, start): Performs depth-first search on the graph from the starting node and returns the paths to each node. visited = set() paths = {} def dfs(node, path): visited.add(node) paths[node] = path for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor, path + [neighbor]) dfs(start, [start]) return paths def bfs_traverse_with_paths(graph, start): Performs breadth-first search on the graph from the starting node and returns the paths to each node. from collections import deque visited = set() paths = {} queue = deque([(start, [start])]) while queue: node, path = queue.popleft() if node not in visited: visited.add(node) paths[node] = path for neighbor in graph.get(node, []): if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return paths"},{"question":"**Question: Implement Pattern Matching with Backtracking** You are given a pattern and a string. Your task is to determine if the string follows the same pattern. Follow means there is a bijection between a letter in the pattern and a non-empty substring in the string such that each letter in the pattern maps to a unique substring. # Input * `pattern`: a string of lowercase letters representing the pattern (1 <= len(pattern) <= 10). * `string`: a string of lowercase letters representing the string to be checked (1 <= len(string) <= 20). # Output * Return `True` if the string follows the given pattern, otherwise return `False`. # Constraints * Both `pattern` and `string` consist of only lowercase English letters. * Length constraints ensure the solution is tractable even with backtracking due to manageable input sizes. # Example ```python # Example 1: pattern = \\"abab\\" string = \\"redblueredblue\\" # Returns: True # Example 2: pattern = \\"aaaa\\" string = \\"asdasdasdasd\\" # Returns: True # Example 3: pattern = \\"aabb\\" string = \\"xyzabcxyzabc\\" # Returns: False ``` # Implementation Implement a function `pattern_match(pattern, string)` that determines if the provided string follows the given pattern. ```python def pattern_match(pattern, string): :type pattern: str :type string: str :rtype: bool def backtrack(pattern, string, dic): if len(pattern) == 0 and len(string) > 0: return False if len(pattern) == len(string) == 0: return True for end in range(1, len(string)-len(pattern)+2): if pattern[0] not in dic and string[:end] not in dic.values(): dic[pattern[0]] = string[:end] if backtrack(pattern[1:], string[end:], dic): return True del dic[pattern[0]] elif pattern[0] in dic and dic[pattern[0]] == string[:end]: if backtrack(pattern[1:], string[end:], dic): return True return False return backtrack(pattern, string, {}) ``` * You need to complete the `pattern_match(pattern, string)` function, which includes the `backtrack` helper function. * Ensure that the algorithm properly handles edge cases and adheres to constraints for optimal performance. * Validate the implementation with the provided examples and consider additional edge cases to robustly test your function.","solution":"def pattern_match(pattern, string): :type pattern: str :type string: str :rtype: bool def backtrack(pattern, string, dic): if len(pattern) == 0 and len(string) > 0: return False if len(pattern) == len(string) == 0: return True for end in range(1, len(string) - len(pattern) + 2): if pattern[0] not in dic and string[:end] not in dic.values(): dic[pattern[0]] = string[:end] if backtrack(pattern[1:], string[end:], dic): return True del dic[pattern[0]] elif pattern[0] in dic and dic[pattern[0]] == string[:end]: if backtrack(pattern[1:], string[end:], dic): return True return False return backtrack(pattern, string, {})"},{"question":"# Coding Exercise: Efficient Range Sum Queries and Updates with Fenwick Tree Context Imagine you are managing the scores of participants in a game. Each participant has an initial score, and you occasionally need to update a participant\'s score or retrieve the total score up to a certain participant efficiently. A Fenwick Tree can be used to handle these operations in an efficient manner. Your task is to implement such a system using the Fenwick Tree (Binary Indexed Tree) you have learned about. Task You are required to complete the following two functions within a given class `FenwickTree` to handle score updates and prefix sum queries efficiently: 1. `update(index: int, value: int) -> None`: * Update the score of the participant at the given index with the new value. 2. `prefix_sum(index: int) -> int`: * Return the total score from the start up to (and including) the participant at the given index. Constraints * 1 ≤ index ≤ 10^5 (number of participants) * -10^6 ≤ value ≤ 10^6 (range of scores) Input and Output * **Input Format**: * You will receive a series of commands (update or prefix_sum) with their respective parameters via standard input until EOF. * **Output Format**: * For each `prefix_sum` command, output the result in a newline. Example ```python # Sample Input update 1 5 update 2 10 prefix_sum 1 prefix_sum 2 # Sample Output 5 15 ``` Implementation Skeleton Below is the skeleton code you need to complete: ```python class FenwickTree: def __init__(self, size: int): self.size = size self.bit = [0] * (size + 1) def update(self, index: int, value: int) -> None: Update the value at the given index and adjust the tree accordingly. # TODO: Implement this method def prefix_sum(self, index: int) -> int: Return the prefix sum from start up to the given index. # TODO: Implement this method # Example interaction if __name__ == \\"__main__\\": ft = FenwickTree(100000) import sys input = sys.stdin.read data = input().strip().split() idx = 0 while idx < len(data): command = data[idx] if command == \\"update\\": index = int(data[idx+1]) value = int(data[idx+2]) ft.update(index, value) idx += 3 elif command == \\"prefix_sum\\": index = int(data[idx+1]) print(ft.prefix_sum(index)) idx += 2 else: idx += 1 ``` Implement the `update` and `prefix_sum` methods in the `FenwickTree` class to provide the required functionality.","solution":"class FenwickTree: def __init__(self, size: int): self.size = size self.bit = [0] * (size + 1) def update(self, index: int, value: int) -> None: Update the value at the given index and adjust the tree accordingly. while index <= self.size: self.bit[index] += value index += index & -index def prefix_sum(self, index: int) -> int: Return the prefix sum from start up to the given index. result = 0 while index > 0: result += self.bit[index] index -= index & -index return result"},{"question":"**Background**: The Hailstone sequence, also known as the Collatz sequence, is a sequence of numbers produced from a starting positive integer n, following a specific set of rules: 1. If n is 1, the sequence ends. 2. If n is even, the next number in the sequence is n/2. 3. If n is odd, the next number in the sequence is 3n + 1. The sequence ends when it reaches the number 1. **Task**: Write a Python function `extended_hailstone(n: int) -> tuple[list[int], int]` that generates the Hailstone sequence starting from a given integer n and also returns the length of that sequence. **Function Signature**: ```python def extended_hailstone(n: int) -> tuple[list[int], int]: pass ``` **Input**: - An integer n (1 ≤ n ≤ 10^5). **Output**: - A tuple containing: - A list of integers representing the Hailstone sequence starting from n. - An integer representing the length of that sequence. **Constraints**: - Your function should handle large values of n efficiently in terms of time and space. - You can assume the input will always be within the given range. **Example**: ```python assert extended_hailstone(7) == ([7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1], 17) assert extended_hailstone(1) == ([1], 1) ``` **Note**: Consider edge cases in your implementation, such as when n is already 1.","solution":"def extended_hailstone(n: int) -> tuple[list[int], int]: Generates the Hailstone sequence starting from a given integer n and also returns the length of that sequence. Parameters: n (int): A positive integer to start the Hailstone sequence. Returns: tuple[list[int], int]: A tuple where the first element is the list of integers in the Hailstone sequence and the second element is the length of that sequence. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n //= 2 else: n = 3 * n + 1 sequence.append(1) return sequence, len(sequence)"},{"question":"# FizzBuzz with Custom Definitions **Context**: You are to modify the basic FizzBuzz algorithm to handle custom Fizz and Buzz definitions, where instead of merely multiples of 3 and 5, the function will take two additional parameters for custom divisors. **Objective**: Write a function `custom_fizzbuzz(n, fizz_div, buzz_div)` that behaves like the classic FizzBuzz but with any integers as the Fizz and Buzz divisors. Function Signature ```python def custom_fizzbuzz(n: int, fizz_div: int, buzz_div: int) -> List[str]: pass ``` Input - An integer `n` (1 ≤ n ≤ 10^6): The upper limit of the range starting from 1. - An integer `fizz_div` (1 ≤ fizz_div ≤ 10^6): The divisor for \\"Fizz\\". - An integer `buzz_div` (1 ≤ buzz_div ≤ 10^6): The divisor for \\"Buzz\\". Output - A list of strings according to the custom FizzBuzz rules: - Replace numbers divisible by `fizz_div` with \\"Fizz\\". - Replace numbers divisible by `buzz_div` with \\"Buzz\\". - Replace numbers divisible by both `fizz_div` and `buzz_div` with \\"FizzBuzz\\". - Otherwise, include the number itself in the list as a string. Example ```python print(custom_fizzbuzz(15, 2, 3)) ``` Output: ```python [\'1\', \'Fizz\', \'Buzz\', \'Fizz\', \'5\', \'FizzBuzz\', \'7\', \'Fizz\', \'Buzz\', \'Fizz\', \'11\', \'FizzBuzz\', \'13\', \'Fizz\', \'Buzz\'] ``` Constraints - The solution should have a linear time and space complexity relative to `n`. - Validate that `n`, `fizz_div`, and `buzz_div` are positive integers and handle any cases where this might not be true by raising appropriate errors.","solution":"from typing import List def custom_fizzbuzz(n: int, fizz_div: int, buzz_div: int) -> List[str]: Generates a list of numbers from 1 to n with custom FizzBuzz logic applied. Numbers divisible by fizz_div are replaced with \\"Fizz\\", divisible by buzz_div with \\"Buzz\\", and divisible by both with \\"FizzBuzz\\". if not (isinstance(n, int) and isinstance(fizz_div, int) and isinstance(buzz_div, int)): raise ValueError(\\"All inputs must be integers.\\") if n < 1 or fizz_div < 1 or buzz_div < 1: raise ValueError(\\"All inputs must be positive integers greater than 0.\\") result = [] for i in range(1, n + 1): if i % fizz_div == 0 and i % buzz_div == 0: result.append(\\"FizzBuzz\\") elif i % fizz_div == 0: result.append(\\"Fizz\\") elif i % buzz_div == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"Implement Enhanced Comb Sort You are given an array of integers. Your task is to implement an enhanced version of Comb Sort, which efficiently sorts the array in ascending order. You should account for and handle common edge cases effectively. # Function Signature ```python def enhanced_comb_sort(arr: List[int]) -> List[int]: pass ``` # Input - An array `arr` of integers (1 ≤ len(arr) ≤ 10^5). # Output - Return the sorted array in ascending order. # Constraints - You are expected to optimize your implementation to handle large datasets efficiently. - You may adjust the shrink factor or implement a different gap sequence if it improves performance. # Example ```python # Example 1: input: arr = [20, -4, -2, 45, 30] output: [-4, -2, 20, 30, 45] # Example 2: input: arr = [5, 1, 1, 2, 0, 0] output: [0, 0, 1, 1, 2, 5] ``` # Explanation For both examples, the returned array is the sorted version of the input array. # Notes - Consider performance optimizations as datasets increase. - Ensure your solution is general and does not rely on specific properties of sample inputs.","solution":"from typing import List def enhanced_comb_sort(arr: List[int]) -> List[int]: Enhanced Comb Sort function to sort an array of integers in ascending order. def get_next_gap(gap): # Shrink gap using a shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Context**: You are developing a tool that processes a list of file paths provided by users. These paths may be relative, absolute, or contain user directory shortcuts. Your task is to ensure that all paths are converted to their absolute forms so your tool can handle file operations consistently. **Problem Statement**: Write a function `normalize_file_paths` that takes a list of file paths as input, normalizes each path to its absolute form, and returns a list of absolute file paths. You should handle user directory shortcuts (`~`) in the paths and ensure all paths are converted correctly. **Function Signature**: ```python def normalize_file_paths(file_paths: list) -> list: ``` **Input**: - `file_paths` (List): A list of strings, where each string represents a file path. The paths can be relative, user-relative, or absolute. **Output**: - A list of strings where each string is the absolute path corresponding to the input paths. **Constraints**: - The input list will contain at most 10,000 paths. - Each path in the input list will be a valid path string. **Examples**: ```python # Example 1 input_paths = [\\"~/test/file.txt\\", \\"./local/file.py\\", \\"/etc/config.yaml\\"] output_paths = normalize_file_paths(input_paths) # Expected output_paths: [\\"/home/user/test/file.txt\\", \\"/full/path/to/current/directory/local/file.py\\", \\"/etc/config.yaml\\"] # Example 2 input_paths = [\\"~/docs\\", \\"../parent_dir\\"] output_paths = normalize_file_paths(input_paths) # Expected output_paths: [\\"/home/user/docs\\", \\"/full/path/to/parent_dir\\"] ``` - Assume the user\'s home directory is \\"/home/user\\". - For the paths starting with `.` or `..`, interpret them relative to the current directory which is \\"/full/path/to/current/directory\\". **Performance Requirements**: Handle up to 10,000 paths efficiently.","solution":"import os def normalize_file_paths(file_paths): This function takes a list of file paths, normalizes each to its absolute form, and returns a list of absolute file paths. absolute_paths = [] for path in file_paths: # Expand user directory shortcut \'~\' if present expanded_path = os.path.expanduser(path) # Get the absolute path absolute_path = os.path.abspath(expanded_path) absolute_paths.append(absolute_path) return absolute_paths"},{"question":"You are given a multi-level nested list that may contain other lists as elements. Your task is to write a function `flatten_deep_list` that converts this nested list into a single-level flattened list. Consider both deeply nested structures and edge cases such as empty lists, or lists containing only strings. # Input - A nested list `nested_list` that may contain other lists and/or elements. # Output - A single-level list containing all elements in a flattened manner. # Constraints - You may assume that the input contains only lists and primitive data types (integers, floats, strings, etc.). - The depth of the nested lists could be very large. # Examples Example 1 Input: ```python nested_list = [1, [2, [3, [4, 5]], 6], 7] ``` Output: ```python [1, 2, 3, 4, 5, 6, 7] ``` Example 2 Input: ```python nested_list = [\'a\', [\'b\', \'c\'], [\'d\', [\'e\', \'f\']]] ``` Output: ```python [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] ``` Example 3 Input: ```python nested_list = [] ``` Output: ```python [] ``` # Function Signature ```python def flatten_deep_list(nested_list): # your code here ``` # Important Notes - You must not use any third-party libraries. - Consider performance bottlenecks for very deeply nested lists. - Handle edge cases such as strings within lists and mixed data types appropriately.","solution":"def flatten_deep_list(nested_list): Recursively flattens a nested list into a single-level list. Parameters: nested_list (list): The nested list to be flattened. Returns: list: A single-level flattened list. flattened = [] for element in nested_list: if isinstance(element, list): flattened.extend(flatten_deep_list(element)) else: flattened.append(element) return flattened"},{"question":"# Question: Context You are tasked with finding the lowest common ancestor (LCA) in a binary search tree (BST). Your implementation should efficiently determine the LCA of two given nodes, utilizing the intrinsic properties of the BST. Objective Write a function `lowest_common_ancestor(root, p, q)` that returns the LCA of two nodes p and q in the given BST. Input * `root`: The root node of a BST. * `p`: A node in the BST. * `q`: Another node in the BST. Output * Return the node that is the lowest common ancestor of nodes `p` and `q`. Constraints * All Node values are unique. * p and q are different and both values will exist in the BST. Example Example BST: ``` 6 / 2 8 / / 0 4 7 9 / 3 5 ``` Example: * Input: `root = Node(6), p = Node(2), q = Node(8)` * Output: `Node(6)` * Input: `root = Node(6), p = Node(2), q = Node(4)` * Output: `Node(2)` Explanation In the first example, node 6 is the lowest common ancestor of nodes 2 and 8. In the second example, 2 is the lowest common ancestor of nodes 2 and 4, as 2 can be a descendant of itself. Constraints * Nodes are guaranteed to be in the tree and each node value is unique. * Your implementation should aim for O(H) time complexity. Function Signature ```python def lowest_common_ancestor(root, p, q): :type root: Node :type p: Node :type q: Node :rtype: Node ```","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root, p, q): :type root: Node :type p: Node :type q: Node :rtype: Node while root: if p.val < root.val and q.val < root.val: root = root.left elif p.val > root.val and q.val > root.val: root = root.right else: return root"},{"question":"Title: Rabin-Karp Pattern Matching Implementation # Description: You are provided with a text and a pattern. Your task is to implement the Rabin-Karp algorithm to find the first occurrence of the pattern in the text. If the pattern is found, return the starting index of the first occurrence. If the pattern is not found, return -1. # Function Signature: ```python def rabin_karp(pattern: str, text: str) -> int: pass ``` # Input: * `pattern`: A string representing the pattern to be searched for. * `text`: A string where the pattern needs to be searched. # Output: * An integer representing the starting index of the first occurrence of the pattern in the text. If the pattern is not found, return -1. # Constraints: * 0 <= len(pattern) <= 10^4 * 0 <= len(text) <= 10^5 # Examples: 1. Input: `pattern = \\"test\\"`, `text = \\"this is a test text\\"` Output: 10 2. Input: `pattern = \\"abc\\"`, `text = \\"abcdef\\"` Output: 0 3. Input: `pattern = \\"aaa\\"`, `text = \\"aaaaa\\"` Output: 0 4. Input: `pattern = \\"xyz\\"`, `text = \\"abcdefgh\\"` Output: -1 # Notes: * You should handle edge cases such as an empty pattern or text. * Think about how to handle hash collisions efficiently.","solution":"def rabin_karp(pattern: str, text: str) -> int: Implements the Rabin-Karp algorithm to find the first occurrence of the pattern in the text. if pattern == \\"\\" or text == \\"\\": return -1 base = 256 # Number of characters in the input alphabet prime = 101 # A prime number m = len(pattern) n = len(text) if m > n: return -1 pattern_hash = 0 text_hash = 0 h = 1 # h will be pow(base, m-1) % prime for i in range(m-1): h = (h * base) % prime # Calculate the hash value of pattern and first window of text for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and pattern if pattern_hash == text_hash: # Check for characters one by one if text[i:i+m] == pattern: return i # Calculate hash value for next window of text: Remove the leading digit, # add the trailing digit if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # We might get negative values of text_hash, convert it to positive if text_hash < 0: text_hash += prime return -1"},{"question":"**Context**: You\'re working for a company that deals with various data streams, which are temporarily stored in stack structures for processing. One of the common operations you need to carry out is the removal of the minimum element from these stacks without altering the order of the other elements. **Task**: Your task is to implement a function `remove_min_modified` that takes a stack (represented as a Python list) as an argument and removes the minimum element from the stack. If the stack is empty, it should simply return the empty stack. Perform this operation in the most efficient manner possible. Function Signature ```python def remove_min_modified(stack: list) -> list: # Your code here ``` Input * `stack` - a list of integers representing the input stack with the top element at the end of the list. Output * The modified stack with the minimum element removed. Constraints * The number of elements in the stack will not exceed 10^3. * The elements in the stack will be integers ranging from -10^6 to 10^6. Example ```python # Example 1 stack = [2, 8, 3, -6, 7, 3] remove_min_modified(stack) # Output: [2, 8, 3, 7, 3] # Example 2 stack = [5, 1, 1, 1, 2] remove_min_modified(stack) # Output: [5, 1, 1, 2] # Example 3 stack = [] remove_min_modified(stack) # Output: [] # Example 4 stack = [7] remove_min_modified(stack) # Output: [] ``` # Guidelines: 1. Understand that you should only remove the single, first occurrence of the smallest element. 2. Ensure that the function preserves the original order of the elements except for the removal of the minimum element. 3. Think about ways to optimize space and time efficiency given the constraints.","solution":"def remove_min_modified(stack): Removes the first occurrence of the minimum element from the stack. if not stack: return stack # Find the minimum element min_element = min(stack) # Remove the first occurrence of the minimum element stack.remove(min_element) return stack"},{"question":"You are given a code snippet defining structures for singly and doubly linked list nodes. Your task is to implement a class for both SinglyLinkedList and DoublyLinkedList with the following functionality: # SinglyLinkedList 1. **Method: insert_at_head(value)** - Description: Insert a new node with the given value at the head of the list. - Input: Integer `value`. - Output: None. 2. **Method: delete_by_value(value)** - Description: Delete the first node with the given value from the list. - Input: Integer `value`. - Output: None. 3. **Method: to_list()** - Description: Convert the linked list to a Python list of values. - Output: List of integers. # DoublyLinkedList 1. **Method: insert_at_head(value)** - Description: Insert a new node with the given value at the head of the list. - Input: Integer `value`. - Output: None. 2. **Method: delete_by_value(value)** - Description: Delete the first node with the given value from the list. - Input: Integer `value`. - Output: None. 3. **Method: to_list()** - Description: Convert the linked list to a Python list of values from head to tail. - Output: List of integers. 4. **Method: to_list_reverse()** - Description: Convert the linked list to a Python list of values from tail to head. - Output: List of integers. # Example ```python # Singly Linked List Example sll = SinglyLinkedList() sll.insert_at_head(3) sll.insert_at_head(2) sll.insert_at_head(1) print(sll.to_list()) # Output: [1, 2, 3] sll.delete_by_value(2) print(sll.to_list()) # Output: [1, 3] # Doubly Linked List Example dll = DoublyLinkedList() dll.insert_at_head(3) dll.insert_at_head(2) dll.insert_at_head(1) print(dll.to_list()) # Output: [1, 2, 3] print(dll.to_list_reverse()) # Output: [3, 2, 1] dll.delete_by_value(2) print(dll.to_list()) # Output: [1, 3] print(dll.to_list_reverse()) # Output: [3, 1] ``` # Constraints - You may assume that values in the linked list are unique. - The list should handle operations in an empty state gracefully.","solution":"class SinglyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.head = None def insert_at_head(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def delete_by_value(self, value): current = self.head previous = None while current: if current.value == value: if previous: previous.next = current.next else: self.head = current.next return previous = current current = current.next def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result class DoublyLinkedList: class Node: def __init__(self, value): self.value = value self.prev = None self.next = None def __init__(self): self.head = None self.tail = None def insert_at_head(self, value): new_node = self.Node(value) if self.head: self.head.prev = new_node new_node.next = self.head self.head = new_node else: self.head = self.tail = new_node def delete_by_value(self, value): current = self.head while current: if current.value == value: if current.prev: current.prev.next = current.next else: self.head = current.next if current.next: current.next.prev = current.prev else: self.tail = current.prev return current = current.next def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result def to_list_reverse(self): result = [] current = self.tail while current: result.append(current.value) current = current.prev return result"},{"question":"You are given an array `nums` of integers where every element appears exactly three times, except for one element which appears exactly once. Write a function `find_unique` to find and return the element that appears exactly once. Your solution must have linear runtime complexity (O(n)) and must not use extra memory beyond a constant amount (O(1)). Input Format - An integer array `nums` where 1 <= len(nums) <= 3 * 10^4 Output Format - Return the single integer that appears exactly once. Constraints - Each element in the array appears exactly three times except for one element which appears once. # Example Given the following input array: ```plaintext nums = [2, 2, 3, 2] ``` The function should return: ```plaintext 3 ``` # Notes - Consider using bitwise operations to solve this problem efficiently. - Test for edge cases such as minimal and maximal values in the array. # Function Signature ```python def find_unique(nums: List[int]) -> int: pass ```","solution":"def find_unique(nums): Finds the element in the list that appears exactly once, while every other element appears exactly three times. Args: nums (List[int]): List of integers where every element appears three times except one. Returns: int: The integer that appears exactly once. # Initialize ones and twos to 0 ones = twos = 0 for num in nums: # Update `ones` first and then use the old value of `ones` to update `twos` ones = (ones ^ num) & ~twos twos = (twos ^ num) & ~ones return ones"},{"question":"# Question: Extract All Root-to-Leaf Paths from a Binary Tree You are given a binary tree. Your task is to write a function that returns all the paths from the root to leaf nodes as a list of strings. Each path should be represented as a string with nodes\' values connected by the \'->\' symbol. Function Signature ```python def extract_paths(root: Optional[TreeNode]) -> List[str]: ``` Input - `root`: A reference to the root node of a binary tree. Each node will have a `val` (integer), `left` (reference to the left child), and `right` (reference to the right child). Output - A list of strings, where each string represents a path from the root to a leaf node. Constraints - Assume that the given tree could have at most 1000 nodes. - The tree node values are unique and range from 0 to 999. - The tree may be empty (i.e., `root` may be `None`). Scenario Your team is working on a project to visualize hierarchical data structures. As part of this, you need a function to print all paths from the root to each leaf node in a human-readable format for easy verification and debugging. Example Consider the following tree: ``` 1 / 2 3 5 ``` For this tree, your function should return: ```python [\\"1->2->5\\", \\"1->3\\"] ``` This shows the two root-to-leaf paths in the tree.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def extract_paths(root: Optional[TreeNode]) -> List[str]: if not root: return [] def dfs(node: TreeNode, path: str, paths: List[str]): if not node.left and not node.right: # If it\'s a leaf paths.append(path) return if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Pancake Sorting Algorithm Implementation Given the Pancake Sorting algorithm explained above, you are to write a function called `pancake_sort` that sorts an array of integers using the described flipping mechanism. Input * A single list of integers `arr` with length `N` (1 ≤ N ≤ 1000). Output * The sorted list of integers in non-decreasing order. Constraints * You must sort the list in place (mutate the input list). * No additional lists or arrays should be used for sorting (O(1) extra space). * The function should handle lists with both positive and negative integers. Examples ```python # Example 1 arr = [3, 6, 9, 8, 1] print(pancake_sort(arr)) # Output: [1, 3, 6, 8, 9] # Example 2 arr = [5, 10, -2, 4, -10] print(pancake_sort(arr)) # Output: [-10, -2, 4, 5, 10] ``` Write the most efficient function possible under the constraints provided. Consider edge cases like empty arrays or arrays with a single element, but note that large arrays will be tested to evaluate performance.","solution":"def pancake_sort(arr): Pancake sort an array in place. def flip(sublist, k): sublist[:k+1] = sublist[:k+1][::-1] def find_max_index(sublist, size): return max(range(size), key=lambda i: sublist[i]) n = len(arr) for current_size in range(n, 1, -1): max_index = find_max_index(arr, current_size) if max_index != current_size - 1: if max_index != 0: flip(arr, max_index) flip(arr, current_size - 1) return arr"},{"question":"Coding Question # Context: You have been tasked with analyzing a binary tree to determine specific attributes and represent it in a readable format. One of the key tasks is to find the minimum depth of the binary tree, which is defined as the shortest distance from the root node to any leaf node. Additionally, you are required to print the values of the tree in a specific format. # Problem Statement: Implement two functions to achieve the following: 1. Write a function `min_depth(root: TreeNode) -> int` which computes the minimum depth of a binary tree using a recursive approach. 2. Write a function `min_height(root: TreeNode) -> int` which computes the minimum depth of a binary tree using an iterative approach. Furthermore, write a function `print_tree(root: TreeNode) -> None` which prints the tree nodes\' values: * Pre-order traversal, where we visit the root node first, then the left subtree, and finally the right subtree. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: TreeNode) -> int: # your implementation here def min_height(root: TreeNode) -> int: # your implementation here def print_tree(root: TreeNode) -> None: # your implementation here ``` # Input Format: * `root` - The root node of the binary tree, represented as a TreeNode object. * Each TreeNode has an integer value, and pointers to its left and right child nodes. # Output Format: * For `min_depth` and `min_height`: Return the minimum depth of the binary tree as an integer. * For `print_tree`: Print the node values in pre-order traversal (one value per line). # Constraints: * The number of nodes in the binary tree is within the range [0, 10^4]. * -100 <= Node.val <= 100 # Example: For the input tree: ``` 10 / 12 15 / / 25 30 36 100 ``` * Calling `min_depth(root)` or `min_height(root)` should return `3`. * Calling `print_tree(root)` should print: ``` 10 12 25 100 30 15 36 ``` # Performance Requirements: * Ensure the time complexity is optimal within the provided constraints. * Minimize space usage where possible, particularly in the iterative approach.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth(root: TreeNode) -> int: if not root: return 0 if not root.left: return min_depth(root.right) + 1 if not root.right: return min_depth(root.left) + 1 return min(min_depth(root.left), min_depth(root.right)) + 1 def min_height(root: TreeNode) -> int: if not root: return 0 queue = deque([(root, 1)]) # (node, depth) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_tree(root: TreeNode) -> None: if not root: return def pre_order(node): if not node: return print(node.val) pre_order(node.left) pre_order(node.right) pre_order(root)"},{"question":"# Question You are given a non-negative number represented as a list of digits. Your task is to implement a function that increments the number by one. The digits are stored such that the most significant digit is at the head of the list (big-endian). # Function Signature: ```python def increment_digit_array(digits: List[int]) -> List[int]: pass ``` # Input: - A list of non-negative integers where each integer represents a digit of the number. ```python digits: List[int] ``` - The length of digits list will be between `1` and `10^4`. # Output: - Return the list representing the number after incrementing it by one. # Constraints: - The digits in the list will all be in the range from 0 to 9. - You must handle the carry-over situation correctly. - Your solution must not use built-in functions that directly convert list of digits to an integer and vice versa. # Example: Example 1: ```python Input: digits = [1, 2, 9] Output: [1, 3, 0] ``` Example 2: ```python Input: digits = [9, 9, 9] Output: [1, 0, 0, 0] ``` # Performance Requirement: - The solution must run efficiently for lists as long as `10^4` digits. # Hints: - Iterate through the list from the end towards the beginning. - Consider what needs to happen if a digit is less than 9 or is exactly 9.","solution":"from typing import List def increment_digit_array(digits: List[int]) -> List[int]: Increments the given list of digits representing a number by one and returns the new list of digits. n = len(digits) for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits else: digits[i] = 0 # If all the digits are 9, we have to add an additional digit at the start return [1] + digits"},{"question":"You are given a positive integer `n`, and your task is to determine the number of ways `n` can be partitioned into sums of positive integers. Implement the function `int_divide(n)` which returns this count. Each distinct set of numbers that sums up to `n` counts as one unique partition. Input * A single integer `n` (1 ≤ n ≤ 1000) Output * A single integer representing the number of ways `n` can be partitioned into sums of positive integers. Constraints * You must use dynamic programming to solve the problem. * Your solution should have a time complexity of O(n^2). * Your solution should have a space complexity of O(n^2). Examples Example 1: ``` Input: 4 Output: 5 Explanation: The 5 ways to partition 4 are: 4=4 4=3+1 4=2+2 4=2+1+1 4=1+1+1+1 ``` Example 2: ``` Input: 7 Output: 15 Explanation: The 15 ways to partition 7 are: 7=7 7=6+1 7=5+2 7=5+1+1 7=4+3 7=4+2+1 7=4+1+1+1 7=3+3+1 7=3+2+2 7=3+2+1+1 7=3+1+1+1+1 7=2+2+2+1 7=2+2+1+1+1 7=2+1+1+1+1+1 7=1+1+1+1+1+1+1 ``` # Implementation Implement the function `int_divide(n)` using the provided `int_divide` function as inspiration. ```python def int_divide(n): arr = [[0 for i in range(n + 1)] for j in range(n + 1)] arr[1][1] = 1 for i in range(1, n + 1): for j in range(1, n + 1): if i < j: arr[i][j] = arr[i][i] elif i == j: arr[i][j] = 1 + arr[i][j - 1] else: arr[i][j] = arr[i][j - 1] + arr[i - j][j] return arr[n][n] ```","solution":"def int_divide(n): Returns the number of ways n can be partitioned into sums of positive integers. # Initialize a 2D array to hold the number of partitions for each combination dp = [[0 for _ in range(n + 1)] for _ in range(n + 1)] # There is exactly one way to partition 0 (using no parts) for i in range(n + 1): dp[i][0] = 1 # Fill the table using dynamic programming approach for num in range(1, n + 1): for sum_val in range(1, n + 1): if sum_val >= num: dp[num][sum_val] = dp[num - 1][sum_val] + dp[num][sum_val - num] else: dp[num][sum_val] = dp[num - 1][sum_val] return dp[n][n]"},{"question":"# Context You are tasked with developing a part of a larger system that requires sorting various datasets efficiently. The datasets consist of integers, and in some cases, the numbers can be negative. You should ensure that your solution handles various edge cases and performs efficiently under the given constraints. # Task Implement a function `optimized_counting_sort` that sorts an array of integers using the Counting Sort algorithm. Your implementation should account for both positive and negative integers correctly and in an optimized manner. # Function Signature ```python def optimized_counting_sort(arr: List[int]) -> List[int]: pass ``` # Input - `arr (List[int])`: A list of integers which may include negative numbers. The length of the array `n` is such that (1 leq n leq 10^6). # Output - Returns a sorted list of integers in ascending order. # Constraints - The integers in the array can range between (-10^6) and (10^6). # Examples ```python assert optimized_counting_sort([3, -2, -1, 0, 5, -3]) == [-3, -2, -1, 0, 3, 5] assert optimized_counting_sort([4, 2, 2, 8, 3, 3, 1]) == [1, 2, 2, 3, 3, 4, 8] assert optimized_counting_sort([-5, -10, 0, -3, 8, 5, -1, 10]) == [-10, -5, -3, -1, 0, 5, 8, 10] assert optimized_counting_sort([]) == [] ``` # Requirements - Your solution should be efficient and handle the edge cases appropriately. - Use only O(k) additional space where k is dependent on the range of input values. - Ensure the function is stable and returns the sorted list in ascending order.","solution":"def optimized_counting_sort(arr): This function sorts an array of integers (which may include negatives) using the Counting Sort algorithm. if not arr: return [] min_val = min(arr) max_val = max(arr) # Range adjustment to handle negative values range_adjust = -min_val count_range = max_val - min_val + 1 # Initialize count array count = [0] * count_range # Count each element for num in arr: count[num + range_adjust] += 1 # Reconstruct the sorted array index = 0 for i in range(count_range): while count[i] > 0: arr[index] = i - range_adjust index += 1 count[i] -= 1 return arr"},{"question":"# BST Iterator Coding Question # Context You\'ve been provided with a partial implementation of a BST Iterator that iterates over a Binary Search Tree (BST) to return the elements in ascending order, typical of in-order traversal. The iterator interface includes the following methods: * `BSTIterator(TreeNode root)`: Initializes the iterator with the root of a BST. * `boolean has_next()`: Returns true if there exists a next element in the in-order traversal. * `int next()`: Returns the next smallest element in the BST. # Task Complete the implementation by adding class definitions for `TreeNode` and ensuring the BST Iterator functions as intended. # Specifications 1. **Class Definitions**: * **TreeNode Class**: - `TreeNode[int value, TreeNode* left, TreeNode* right]` * **BSTIterator Class**: - Includes methods `__init__(self, root: TreeNode)`, `has_next(self) -> bool`, `next(self) -> int`. # Input * The input will consist of a sequence of tree operations in the form: * `[\'BSTIterator\', [values]]`, where `values` is a list of integers used to create the BST. * \'BSTIterator\' call will be followed by alternating \'has_next\' and \'next\' calls. # Output * The output should consist of the results of `next()` calls. # Constraints * `0 <= number of nodes <= 10^5` * `-10^9 <= TreeNode value <= 10^9` # Example Test Case ```python # Sample Implementation (Completion Required) class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Use the provided BSTIterator implementation with TreeNodes added. # Example usage: # Input: [\\"BSTIterator\\", [7, 3, 15, None, None, 9, 20]], [\\"has_next\\"], [\\"next\\"], [\\"next\\"], [\\"has_next\\"], [\\"next\\"], [\\"has_next\\"], [\\"next\\"], [\\"has_next\\"], [\\"next\\"], [\\"has_next\\"] # Output: [None, True, 3, 7, True, 9, True, 15, True, 20, False] ``` Write a completeness function that by creating the `TreeNode` class and ensuring the `BSTIterator` traverses a BST correctly.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIterator: def __init__(self, root: TreeNode): self.stack = [] self._leftmost_inorder(root) def _leftmost_inorder(self, root): while root: self.stack.append(root) root = root.left def has_next(self) -> bool: return len(self.stack) > 0 def next(self) -> int: topmost_node = self.stack.pop() if topmost_node.right: self._leftmost_inorder(topmost_node.right) return topmost_node.val # Helper function to create binary search tree from list of values def create_bst_from_list(values): if not values: return None def insert(root, val): if not root: return TreeNode(val) if val < root.val: root.left = insert(root.left, val) else: root.right = insert(root.right, val) return root root = None for value in values: if value is not None: root = insert(root, value) return root"},{"question":"# Question: You are given two functions, `encode_rle` and `decode_rle`, which implement run-length encoding and decoding for data compression. Enhance these functions to handle a few additional constraints and optimize their performance: 1. **Enhance the run-length encoding** to include multi-digit counts. 2. **Ensure the decoding function** can handle very large counts up to `10^5`. Your task is to implement the optimized versions of `encode_rle` and `decode_rle`. Both functions should be able to correctly and efficiently handle the given constraints while maintaining function signatures. Function Signature: ```python def encode_rle(input: str) -> str: pass def decode_rle(input: str) -> str: pass ``` Input: * `input` parameter for `encode_rle` is a string containing characters to be encoded. * `input` parameter for `decode_rle` is a string containing the run-length encoded data. Output: * Return the run-length encoded string for `encode_rle`. * Return the original uncompressed string for `decode_rle`. --- Example: *Example 1*: ```python data = \\"AAAABBBCCDAA\\" encoded = encode_rle(data) print(encoded) # Should print: \\"4A3B2C1D2A\\" decoded = decode_rle(encoded) print(decoded) # Should print: \\"AAAABBBCCDAA\\" ``` *Example 2*: ```python data = \\"BBBBBBBBBBBBBBBCCCCCCCCCCCCCCCC\\" encoded = encode_rle(data) print(encoded) # Should print: \\"15B16C\\" decoded = decode_rle(encoded) print(decoded) # Should print: \\"BBBBBBBBBBBBBBBCCCCCCCCCCCCCCCC\\" ``` Constraints: 1. Character counts can go up to `10^5`. 2. Input length for both functions should be manageable within a few seconds of processing time, even for the largest counts. 3. The output string should be correctly formatted with counts directly preceding their respective characters. Good luck!","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded_str = [] count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: encoded_str.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded_str.append(f\\"{count}{current_char}\\") return \'\'.join(encoded_str) def decode_rle(input: str) -> str: import re decoded_str = [] parts = re.findall(r\'(d+)(D)\', input) for count, char in parts: decoded_str.append(char * int(count)) return \'\'.join(decoded_str)"},{"question":"You are responsible for implementing a `ZigZagIterator` to iterate over a varying number of lists in a \\"zig-zag\\" manner, meaning that you should alternate picking elements from each of the lists. # Function Specification Class ZigZagIterator Implement the following methods: 1. **`__init__(self, lists: List[List[int]]) -> None`**: * Initialize the iterator with a list of lists. Each inner list contains integers. 2. **`next(self) -> int`**: * Return the next element in the zig-zag order. It should raise a `StopIteration` exception if there are no more elements. 3. **`has_next(self) -> bool`**: * Returns `True` if there are more elements to iterate, otherwise `False`. # Example ```python lists = [[1, 2], [3, 4, 5, 6]] iterator = ZigZagIterator(lists) result = [] while iterator.has_next(): result.append(iterator.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` # Constraints * You can assume that each list contains at most `1000` elements. * The total number of elements across all lists doesn\'t exceed `5000`. * Do not use any additional built-in libraries except `collections.deque` for managing the queue. # Requirements * Ensure your implementation efficiently handles the operation complexities as outlined. * Be mindful of edge cases such as empty lists or lists with very different lengths.","solution":"from collections import deque from typing import List class ZigZagIterator: def __init__(self, lists: List[List[int]]) -> None: # Initialize the deque to hold indices and lists self.queue = deque((i, 0) for i, lst in enumerate(lists) if lst) self.lists = lists def next(self) -> int: if not self.has_next(): raise StopIteration() i, j = self.queue.popleft() val = self.lists[i][j] if j + 1 < len(self.lists[i]): self.queue.append((i, j + 1)) return val def has_next(self) -> bool: return bool(self.queue)"},{"question":"You are required to implement a function that finds the nearest neighbor of a given vector from a set of training vectors. Given a target vector `x` and a training set `tSet`, which is a dictionary of vectors as keys and labels as values, your task is to determine the label of the vector in `tSet` that is closest to `x` based on Euclidean distance. # Function Signature ```python def find_nearest_neighbor(x: tuple, tSet: dict) -> str: # Your code here ``` # Arguments * `x`: A tuple representing the target vector. All elements of the vector will be integers or floating point numbers. * `tSet`: A dictionary where: - Each key is a tuple representing a vector. - Each value is a string representing the label associated with the vector. # Returns * A string representing the label of the nearest neighbor in `tSet`. # Constraints * The target vector `x` and all keys in `tSet` will have the same length. * The training set `tSet` will contain at least one vector. * You can assume all numeric calculations will stay within the limits of standard floating point precision. # Performance Requirement * The solution should be efficient enough to handle a `tSet` with up to 10,000 vectors where each vector has a dimension up to 100. # Example ```python # Sample Input x = (3.5, -2.1) tSet = { (1.0, -1.0): \\"Label1\\", (4.5, -0.5): \\"Label2\\", (2.0, -3.0): \\"Label3\\" } # Expected Output \\"Label3\\" # Explanation The distances to vectors in `tSet` are: (1.0, -1.0): sqrt((3.5-1.0)^2 + (-2.1+1.0)^2) = sqrt(2.5^2 + 1.1^2) = sqrt(7.05) ≈ 2.66 (4.5, -0.5): sqrt((3.5-4.5)^2 + (-2.1+0.5)^2) = sqrt(-1.0^2 + (-1.6)^2) = sqrt(3.56) ≈ 1.89 (2.0, -3.0): sqrt((3.5-2.0)^2 + (-2.1+3.0)^2) = sqrt(1.5^2 + (-0.9)^2) = sqrt(3.06) ≈ 1.75 Thus, the nearest neighbor is the vector (2.0, -3.0) with label \\"Label3\\". ``` # Notes * The function should correctly handle scenarios with multiple vectors having the same minimum distance by returning the label of the first such vector found. * Consider the role of numerical stability and precision when implementing the Euclidean distance computation.","solution":"import math def euclidean_distance(v1, v2): return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def find_nearest_neighbor(x, tSet): nearest_label = None min_distance = float(\'inf\') for vector, label in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Markov Chain Modeling and Sequence Generation You are tasked with implementing an extended Markov Chain that includes an additional feature and thorough input validation. # Problem Description Design and implement a class `MarkovChain` that models a Markov Chain with the following capabilities: 1. An initialization method (`__init__`) that accepts a dictionary representing the state transitions and their corresponding probabilities. 2. A method `validate_chain` that ensures the input chain is valid (i.e., probabilities for transitions from each state sum up to 1). 3. A method `next_state` that determines the next state given the current state. 4. A method `generate_states` that yields a sequence of states starting from an initial state, up to a specified number of states. # Function Signatures ```python class MarkovChain: def __init__(self, chain: dict): # Initializes with a state transition dictionary pass def validate_chain(self) -> bool: # Validates if the Markov chain probabilities are correct pass def next_state(self, current_state: str) -> str: # Returns the next state based on the current state and transitions pass def generate_states(self, initial_state: str, num_states: int) -> list: # Generates a sequence of states starting from initial_state pass ``` # Input Format 1. The initialization method receives a dictionary `chain` where the keys are state names, and the values are dictionaries of transitions and probabilities. 2. The `next_state` method receives a string `current_state`. 3. The `generate_states` method receives a string `initial_state` and an integer `num_states`. # Output Format 1. The `validate_chain` method returns a boolean indicating the validity of the chain. 2. The `next_state` method returns a string representing the next state. 3. The `generate_states` method returns a list of strings representing the state sequence. # Constraints - The transition probabilities are floating-point numbers between 0 and 1. - The chain dictionary is non-empty. - The number of states to generate is a positive integer. # Example ```python chain = { \'A\': {\'A\': 0.3, \'B\': 0.7}, \'B\': {\'A\': 0.4, \'B\': 0.6} } mc = MarkovChain(chain) assert mc.validate_chain() == True assert mc.next_state(\'A\') in [\'A\', \'B\'] assert mc.generate_states(\'A\', 5) == [\'A\', \'B\', \'A\', \'A\', \'B\'] # Example output, actual may vary ``` **Write your code in the `MarkovChain` class and ensure it adheres to the specified signatures and behavior.**","solution":"import random class MarkovChain: def __init__(self, chain: dict): Initializes with a state transition dictionary self.chain = chain if not self.validate_chain(): raise ValueError(\\"The provided transition matrix is invalid\\") def validate_chain(self) -> bool: Validates if the Markov chain probabilities are correct for state, transitions in self.chain.items(): # Sum of probabilities for a state must be 1 if not (0.999 <= sum(transitions.values()) <= 1.001): return False return True def next_state(self, current_state: str) -> str: Returns the next state based on the current state and transitions if current_state not in self.chain: raise ValueError(f\\"State \'{current_state}\' not found in the Markov Chain\\") transitions = self.chain[current_state] next_state = random.choices(list(transitions.keys()), weights=transitions.values())[0] return next_state def generate_states(self, initial_state: str, num_states: int) -> list: Generates a sequence of states starting from initial_state if initial_state not in self.chain: raise ValueError(f\\"Initial state \'{initial_state}\' not found in the Markov Chain\\") if num_states <= 0: raise ValueError(\\"Number of states to generate must be a positive integer\\") states = [initial_state] current_state = initial_state for _ in range(num_states - 1): current_state = self.next_state(current_state) states.append(current_state) return states"},{"question":"You are tasked with reversing a string using the following constraints and properties. Your primary goal is to implement a function that meets these requirements: 1. **Recursive Reversal**: Implement a function `reverse_recursive(s: str) -> str` that reverses a given string `s` using a recursive approach. You should avoid hitting the maximum recursion depth for large strings. 2. **Iterative Reversal**: Implement a function `reverse_iterative(s: str) -> str` that reverses a given string `s` using an iterative approach. Ensure it handles large strings efficiently. 3. **Pythonic Reversal**: Implement a function `reverse_pythonic(s: str) -> str` that leverages Python\'s built-in functionalities for reversing the string. 4. **Ultra Pythonic Reversal**: Implement a function `reverse_ultra_pythonic(s: str) -> str` that uses slicing to reverse the string. # Requirements: - Ensure all implementation methods are efficient in terms of both time and space complexity. - Handle empty strings and single character strings gracefully. - The inputs can contain ASCII and Unicode characters. - Do not use any additional libraries aside from Python\'s built-in ones. # Input - A single string `s` with length ( leq 10^5 ). # Output - A single reversed string identical in length to the input. # Example ```python s = \\"Hello, world!\\" print(reverse_recursive(s)) # Output: \\"!dlrow ,olleH\\" print(reverse_iterative(s)) # Output: \\"!dlrow ,olleH\\" print(reverse_pythonic(s)) # Output: \\"!dlrow ,olleH\\" print(reverse_ultra_pythonic(s)) # Output: \\"!dlrow ,olleH\\" ``` Which identifies understanding the concept of string reversal and efficiently implements the logic using different methodologies.","solution":"def reverse_recursive(s: str) -> str: Reverses a given string `s` using a recursive approach. if len(s) <= 1: return s return reverse_recursive(s[1:]) + s[0] def reverse_iterative(s: str) -> str: Reverses a given string `s` using an iterative approach. reversed_s = [] for char in s: reversed_s.insert(0, char) return \'\'.join(reversed_s) def reverse_pythonic(s: str) -> str: Reverses a given string `s` using Python\'s built-in functions. return \'\'.join(reversed(s)) def reverse_ultra_pythonic(s: str) -> str: Reverses a given string `s` using slicing. return s[::-1]"},{"question":"# Question: Jump Search Implementation **Context**: Imagine you are working on a library of high-performance algorithms that can quickly locate elements in large datasets sorted in non-decreasing order. Jump Search is one such algorithm that is efficient for this purpose. **Task**: Write a function to implement the Jump Search algorithm. Your function should locate the position of a given target element in a sorted array. **Function Signature**: ```python def jump_search(arr, target): pass ``` **Input Parameters**: - `arr` (List[int]): A sorted list of integers. - `target` (int): The target integer to be found in `arr`. **Output**: - Returns the index of the target element if it is present in the array. If the target is not found, return -1. **Constraints**: - The list `arr` will have at least one and at most 10^6 elements. - Each element in `arr` will be an integer in the range [-10^9, 10^9]. - The `target` will be an integer in the range [-10^9, 10^9]. **Performance Requirements**: - Your implementation should run in O(√n) time complexity. **Examples**: ```python assert jump_search([1, 3, 5, 7, 9], 7) == 3 assert jump_search([1, 3, 5, 7, 9], 1) == 0 assert jump_search([1, 3, 5, 7, 9], 9) == 4 assert jump_search([1, 3, 5, 7, 9], 4) == -1 assert jump_search([], 2) == -1 ``` **Notes**: 1. Ensure that you handle edge cases such as an empty array, the target being the first or last element, and the target not being in the array. 2. Consider time complexity while deciding the block size for optimal performance.","solution":"import math def jump_search(arr, target): Perform jump search to find the target in sorted array. Parameters: arr (List[int]): A sorted list of integers. target (int): The target integer to be found in arr. Returns: int: The index of the target element if present, otherwise -1. n = len(arr) if n == 0: return -1 # Optimal block size to be jumped step = int(math.sqrt(n)) # Finding the block where the element is present (if it is present) prev = 0 while arr[min(step, n) - 1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for the target in the block beginning with prev. for i in range(prev, min(step, n)): if arr[i] == target: return i return -1"},{"question":"# Priority Queue Challenge Problem Statement: You are tasked with implementing a Priority Queue in Python using a binary heap to improve the performance over the provided linear array implementation. The core operations of the priority queue should remain the same: inserting elements with a priority and extracting the element with the highest priority. Your Task: 1. Implement a class `HeapPriorityQueue` that uses a binary heap to store elements. 2. Implement the following methods: - `push(item, priority)` - Inserts an item with the given priority. - `pop()` - Removes and returns the item with the highest priority (lowest numerical value). Method Signatures: ```python class HeapPriorityQueue: def __init__(self): pass def push(self, item, priority): pass def pop(self): pass ``` Constraints: - The `priority` values will be integers. - The input `item` can be any data type. - If `pop` is called on an empty queue, return `None`. - Aim for O(log n) complexity for both `push()` and `pop()` operations. Performance Requirements: - The `push` operation should have an average time complexity of O(log n). - The `pop` operation should have an average time complexity of O(log n). Example: ```python pq = HeapPriorityQueue() pq.push(\'apple\', 5) pq.push(\'banana\', 2) pq.push(\'cherry\', 4) print(pq.pop()) # should return \'banana\' print(pq.pop()) # should return \'cherry\' print(pq.pop()) # should return \'apple\' print(pq.pop()) # should return None ``` Implementation Notes: - You can use the `heapq` module from Python’s standard library to maintain the binary heap.","solution":"import heapq class HeapPriorityQueue: def __init__(self): self.heap = [] def push(self, item, priority): heapq.heappush(self.heap, (priority, item)) def pop(self): if not self.heap: return None return heapq.heappop(self.heap)[1]"},{"question":"# Cosine Similarity Function Implementation You are given two 1-dimensional lists (vectors) of the same length. Your task is to write a function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between these two vectors. The cosine similarity is defined as: [ text{cosine similarity} = frac{sum_{i=1}^{n} text{vec1}[i] times text{vec2}[i]}{sqrt{sum_{i=1}^{n} (text{vec1}[i])^2} times sqrt{sum_{i=1}^{n} (text{vec2}[i])^2}} ] # Function Signature: ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: pass ``` # Input: - `vec1`: A list of floats representing the first vector. Constraints: (1 leq text{len(vec1)} leq 10^5). - `vec2`: A list of floats representing the second vector. Constraints: (1 leq text{len(vec2)} leq 10^5). # Output: - Returns a single float, representing the cosine similarity between the two vectors. # Constraints: - The two input vectors will always have the same length. - The lists may contain zero values but cannot be zero vectors (i.e., both vectors being entirely zeros simultaneously). # Example: ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 0, 1], [1, 0, 0]) # Output: 0.0 ``` # Notes: - Consider edge cases carefully, such as the presence of zeros in the vectors. - Ensure the function is optimized to handle the upper limit of the input size efficiently.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Calculates the cosine similarity between two vectors. if not vec1 or not vec2 or len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same non-zero length.\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(v1 * v1 for v1 in vec1)) magnitude_vec2 = math.sqrt(sum(v2 * v2 for v2 in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: raise ValueError(\\"Vectors must not be zero vectors.\\") cosine_similarity = dot_product / (magnitude_vec1 * magnitude_vec2) return cosine_similarity"},{"question":"**Insertion Sort Animation**: You are required to extend the functionality of the provided `insertion_sort` function to include a feature that traces and prints out each pass of the sorting process using a step-by-step animation. This will help in visualizing how the Insertion Sort algorithm works. # Task Write a function `animated_insertion_sort(arr: List[int]) -> List[str]` that takes an array of integers and returns a list of strings where each string represents the state of the array at the end of each iteration of the outer loop. # Input - An array `arr` of integers `[-10^3 <= arr[i] <= 10^3]`, with `1 <= len(arr) <= 100`. # Output - A list of strings where each string represents the state of the array after each iteration of the outer loop. # Constraints - Ensure you print or simulate each step clearly. Each iteration of the output should reflect the insertion of the current element into its correct position in the sorted portion of the list. # Example: ```python input_arr = [4, 3, 2, 10, 12] output = animated_insertion_sort(input_arr) print(output) ``` The output list should be: ```python [ \\"4 3 2 10 12\\", \\"3 4 2 10 12\\", \\"2 3 4 10 12\\", \\"2 3 4 10 12\\", \\"2 3 4 10 12\\" ] ``` # Note: - The initial state of the array is the first stage of the animation. - At each step, print the state of the array after placing the current element at its correct position. # Performance Requirements Your implementation needs to handle arrays of size up to 100 efficiently, though the primary focus is on correctly simulated steps rather than the absolute speed of execution.","solution":"from typing import List def animated_insertion_sort(arr: List[int]) -> List[str]: result = [] for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key # Capture the current state of the array as a string and add to result list result.append(\\" \\".join(map(str, arr))) return result"},{"question":"Objective: Write a function to reverse a singly linked list, demonstrating your understanding of both iterative and recursive techniques. Problem Statement: Given the head of a singly linked list, reverse the list using both iterative and recursive methods. You should implement two functions: - `reverse_list_iterative(head: ListNode) -> ListNode` - `reverse_list_recursive(head: ListNode) -> ListNode` Each function should return the head of the reversed linked list. Input & Output Formats: * **Input**: * A singly linked list\'s head node, `head` (ListNode) * **Output**: * The head node of the reversed singly linked list Constraints: * The list may contain zero or more nodes. * The value of nodes need not be unique. Performance Requirements: * Both implementations should handle the reversal in O(n) time complexity. The iterative version should use O(1) space, and the recursive version will use O(n) space due to call stack. Edge Cases to Consider: * The list is empty (head is `None`). * The list contains only one node. Scenario: You are working on a text editor that maintains operations in a linked list. To implement the undo feature effectively, you need to reverse the operations stored in a linked list. Your solution must efficiently handle both iterative and recursive approaches to ensure optimal performance based on different constraints. Instructions: 1. Implement both functions as per the signatures provided. 2. Ensure that your implementation properly handles all edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def reverse_list_iterative(head: ListNode) -> ListNode: prev = None current = head while current: next_node = current.next current.next = prev prev = current current = next_node return prev def reverse_list_recursive(head: ListNode) -> ListNode: if not head or not head.next: return head new_head = reverse_list_recursive(head.next) head.next.next = head head.next = None return new_head"},{"question":"# Array Rotation Task You are given a list of integers. Your task is to rotate this array to the right by a specified number of steps. Implement a function that performs this rotation efficiently. There are multiple ways to do this, but you should aim for a solution with a time complexity of O(n) and should perform the operations in-place if possible. Function Signature ```python def rotate_array(array: List[int], k: int) -> List[int]: pass ``` Input: * `array`: A list of integers, where 1 <= len(array) <= 10^5 * `k`: A non-negative integer specifying the number of steps to rotate the array. Output: * The rotated list of integers. Constraints: * The function should handle an empty list and return an empty list if the input list is empty. * `k` can be greater than the length of the list. Ensure the rotation does not process more steps than necessary. Example: ```python # Example 1: rotate_array([1, 2, 3, 4, 5, 6, 7], 3) # Output: [5, 6, 7, 1, 2, 3, 4] # Example 2: rotate_array([1, 2], 5) # Output: [2, 1] ``` # Evaluation Criteria: * Correctness: Ensure that the final array reflects the right rotation. * Efficiency: Implement the solution with O(n) time complexity. * Space Efficiency: Aim to modify the array in-place, limiting additional space usage. * Edge Cases: Handle scenarios with empty arrays and `k` values larger than the array length.","solution":"from typing import List def rotate_array(array: List[int], k: int) -> List[int]: Rotates the elements of the array to the right by k steps. n = len(array) if n == 0: return array k = k % n def reverse(arr: List[int], start: int, end: int) -> None: while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 # Reverse the entire array reverse(array, 0, n - 1) # Reverse the first part up to k reverse(array, 0, k - 1) # Reverse the remaining part reverse(array, k, n - 1) return array"},{"question":"# Regular Expression Matching Algorithm Given a string `s` and a pattern `p` that contains `.` and `*` as regular expression symbols, implement a function `bool is_match(const char *s, const char *p)` to determine if `s` matches the entire pattern `p`. Regular Expression Rules: * `.` Matches any single character. * `*` Matches zero or more of the preceding element. Function to Implement: ```python def is_match(s: str, p: str) -> bool: pass ``` Input: * `s`: A string consisting of any characters. (1 ≤ |s| ≤ 1000) * `p`: A pattern string containing lowercase letters, `.` and `*`. (1 ≤ |p| ≤ 1000) Output: * Return `True` if the string matches the pattern, `False` otherwise. Example: ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints: * The function should handle large input sizes efficiently. * Consider relevant edge cases and ensure your solution adheres to the runtime constraints. Note: Focus on clear and efficient implementation, making sure to handle the given regular expression rules properly. Ensure your code performs well with edge cases such as empty strings and patterns or multiple consecutive `*`.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p, otherwise False. # Create a DP table with False default values. dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] # Empty string matches with empty pattern. dp[0][0] = True # Empty string match with pattern p. for j in range(1, len(p) + 1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] # Fill the table for remaining cases. for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j-1] == s[i-1] or p[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] or (dp[i-1][j] if p[j-2] == s[i-1] or p[j-2] == \'.\' else False) else: dp[i][j] = False return dp[len(s)][len(p)]"},{"question":"**Summarize Sorted Ranges** You are tasked with summarizing ranges in a sorted list of unique integers. Each contiguous range of numbers should be summarized as a single range, where a range is represented by the start and end numbers separated by a hyphen (e.g., \\"1-3\\"). If the range contains only one number, it should be represented by that number alone (e.g., \\"5\\"). Requirements * **Function Name**: `summarize_ranges` * **Input**: A sorted list of unique integers (`List[int]`). * **Output**: A list of strings representing summarized ranges (`List[str]`). Examples: 1. Given the input `[0, 1, 2, 4, 5, 7]`, return `[\\"0-2\\", \\"4-5\\", \\"7\\"]`. 2. Given the input `[0]`, return `[\\"0\\"]`. 3. Given the input `[1, 2, 3, 4, 5]`, return `[\\"1-5\\"]`. 4. Given the input `[]`, return `[]`. Constraints: - The input list will always be sorted in ascending order. - The input list will not contain duplicate elements. - The function should handle edge cases efficiently. Function Signature: ```python from typing import List def summarize_ranges(array: List[int]) -> List[str]: # Implement your solution pass ```","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for n in array[1:]: if n == end + 1: end = n else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = n end = n if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"# Question: Hierarchical Tree Representation and Custom Traversal Given a nested dictionary representing hierarchical data, your task is to implement a function `custom_tree_print` that prints each key and its sub-elements in a specifically formatted way. The tree structure allows nodes to have multiple sub-elements, where each sub-element can either be a string or another node. Expected Function Definition: ```python def custom_tree_print(tree: dict) -> None: pass ``` Input and Output Format: * **Input**: A dictionary `tree` with the following format: ```python { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } ``` * **Output**: A printed structure in the following format: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Constraints: * Each key in the dictionary has a list containing mixed data types. * Sub-elements can be strings, integers, or nested structures. * You are allowed to use standard library functions but avoid using any third-party packages. Performance Requirements: * Maintain a linear performance relative to the size of the input data. * Efficiently handle large nested structures with minimal overhead. * Ensure proper indentation in nested sub-lists. Additional Requirements: * Consider and handle edge cases such as: * Empty tree. * Non-conforming sub-elements. * Extremely large or deeply nested structures. Example Usage: ```python tree_data = { \'a\': [\'Adam\', \'Book\', 4], \'b\': [\'Bill\', \'Computer\', 5, \'TV\', 6, \'Jill\', \'Sports\', 1], \'c\': [\'Bill\', \'Sports\', 3], \'d\': [\'Adam\', \'Computer\', 3, \'Quin\', \'Computer\', 3], \'e\': [\'Quin\', \'Book\', 5, \'TV\', 2], \'f\': [\'Adam\', \'Computer\', 7] } custom_tree_print(tree_data) ``` This should produce the following output: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ```","solution":"def custom_tree_print(tree): for key, values in tree.items(): line = f\\"{key} -> \\" + \\" -> \\".join(map(str, values)) print(line)"},{"question":"# Sorting Check in Stack You are given a stack. Implement a function to check if the elements in the stack are in ascending order from bottom to top. Function Signature ```python def is_sorted(stack: List[int]) -> bool: # implementation here ``` Input * `stack`: A list of integers where the smallest element should ideally be at the bottom. Output * Return `True` if the elements are in ascending order from bottom to top; otherwise, return `False`. Constraints * The stack will contain no more than `10^6` elements. * The function should maintain the original order of elements in the stack after checking. Example ```python stack = [1, 2, 3, 4, 5] print(is_sorted(stack)) # Output: True stack = [6, 3, 5, 1, 2, 4] print(is_sorted(stack)) # Output: False ``` Context You have a number of processes that log timestamps into a stack. You want to verify that the timestamps are logged in a sequential ascending order. Implement the function to help in this validation.","solution":"from typing import List def is_sorted(stack: List[int]) -> bool: Checks if the elements in the stack are in ascending order from bottom to top. :param stack: List of integers representing the stack :return: True if the stack is sorted in ascending order from bottom to top, otherwise False for i in range(1, len(stack)): if stack[i-1] > stack[i]: return False return True"},{"question":"# Markov Chain Simulator You are required to build a Markov Chain simulator. Given an initial chain dictionary and a set of sequences of states, determine the most likely sequences that can be generated from the initial state until a specified step count. Function Signature ```python def most_likely_sequence(chain: dict, initial_state: str, steps: int) -> [str]: pass ``` Input 1. **chain**: A dictionary representing the Markov chain as given in the previous snippet. 2. **initial_state**: A string representing the starting state. 3. **steps**: An integer representing the number of steps to simulate. Output Returns a list of states representing the most likely sequence of states starting from the initial state over the given number of steps. Constraints 1. The chain\'s probabilities for any state must sum to 1. 2. The chain is a valid dictionary of dictionaries with properly formatted probabilities. 3. steps will be a positive integer. Example ```python my_chain = { \'A\': {\'A\': 0.6, \'E\': 0.4}, \'E\': {\'A\': 0.7, \'E\': 0.3} } initial_state = \'A\' steps = 3 print(most_likely_sequence(my_chain, initial_state, steps)) ``` **Expected Output**: [\'A\', \'A\', \'A\', \'A\'] # Explanation The most likely sequence from state \'A\' for 3 steps is through repeatedly selecting \'A\' itself due to its higher probability. # Notes 1. Ensure the function handles all probabilities accurately. 2. Consider edge cases where transition probabilities are equal.","solution":"def most_likely_sequence(chain: dict, initial_state: str, steps: int) -> [str]: Determines the most likely sequence of states given an initial state and steps count. :param chain: A dict representing the Markov chain. :param initial_state: A string representing the initial state. :param steps: An integer representing the number of steps. :return: A list of states representing the most likely sequence. current_state = initial_state sequence = [current_state] for _ in range(steps): next_state = max(chain[current_state], key=chain[current_state].get) sequence.append(next_state) current_state = next_state return sequence"},{"question":"# Linear Search Optimization Challenge Given an array of integers, your task is to write a function that performs an optimized search to determine whether a target value exists in the array. The function should return a tuple containing two values: 1. A boolean indicating if the target value exists in the array. 2. If the value exists, return its index; otherwise, return -1. # Input - `array`: A list of integers (both positive and negative, including zero). - `target`: An integer value to search for in the array. # Output - A tuple `(exists, index)`: - `exists`: A boolean (True if the target value exists in the array, False otherwise). - `index`: An integer (index of the target value if it exists, otherwise -1). # Constraints - The length of the array can be up to 10,000 elements. - The values in the array can range from -10^6 to 10^6. # Example ```python array = [10, 14, 26, 31, 42, 55] target = 31 returns (True, 3) array = [10, 14, 26, 31, 42, 55] target = 50 returns (False, -1) ``` # Performance Requirements - The solution should aim to reduce the number of checks against the target value as much as possible. # Function Signature ```python def optimized_search(array: List[int], target: int) -> Tuple[bool, int]: pass ``` You are not allowed to change the order of elements or use additional space beyond O(1) for variables other than the input. Consider how you might adjust or improve the linear search to fulfill these requirements effectively.","solution":"from typing import List, Tuple def optimized_search(array: List[int], target: int) -> Tuple[bool, int]: Perform an optimized linear search to find the target value in the array. :param array: List of integers to search within. :param target: The integer value to search for. :return: Tuple (exists, index) where exists is a boolean indicating if target is found, and index is the index of the target if found, otherwise -1. for idx, value in enumerate(array): if value == target: return (True, idx) return (False, -1)"},{"question":"# Scenario You are tasked to implement a part of a simulation for a software that needs to manage a directory of services efficiently using a hash table. This hash table should be capable of: 1. Storing key-value pairs. 2. Handling collisions using linear probing. 3. Resizing itself when needed to maintain efficient operations. # Question Implement a `ResizableHashTable` class to handle the directory of services. The operations supported by the `ResizableHashTable` are: 1. `put(key, value)`: Inserts a key-value pair into the hash table. 2. `get(key)`: Returns the value associated with the given key, or `None` if not present. 3. `del_(key)`: Removes the key-value pair from the hash table. 4. `__len__()`: Returns the number of key-value pairs stored in the hash table. Your implementation should ensure that: - The hash table resizes automatically when it reaches a load factor of (2/3). - Resizing operation should rehash all the existing keys to new indices. Input/Output Format * The `put`, `get`, and `del_` functions will take an integer `key` and a value `value` (in the case of `put`). * `put` function does not return anything. * `get` function returns the value associated with the key or `None` if the key is not found. * `del_` function returns `None`. * `__len__` function returns the number of active key-value pairs. Constraints * Keys are integers. * The initial size of the hash table should be 8. # Example ```python # Create a resizable hash table r_hash_table = ResizableHashTable() # Add some key-value pairs r_hash_table.put(1, \'one\') r_hash_table.put(9, \'nine\') # This will cause a linear probe # Get values print(r_hash_table.get(1)) # Output: \'one\' print(r_hash_table.get(9)) # Output: \'nine\' # Check length print(len(r_hash_table)) # Output: 2 # Delete a value r_hash_table.del_(1) print(r_hash_table.get(1)) # Output: None print(len(r_hash_table)) # Output: 1 ``` You need to implement the `ResizableHashTable` class as described with robust handling of collisions and resizing operations.","solution":"class ResizableHashTable: def __init__(self): self.initial_capacity = 8 self.capacity = self.initial_capacity self.size = 0 self.table = [None] * self.capacity def _hash(self, key): Compute the hash value for a given key. return key % self.capacity def _resize(self): Resize the hash table when the load factor exceeds the threshold. old_table = self.table self.capacity *= 2 self.table = [None] * self.capacity self.size = 0 for item in old_table: if item is not None: self.put(item[0], item[1]) def put(self, key, value): Inserts a key-value pair into the hash table. if self.size >= 2 * self.capacity // 3: self._resize() index = self._hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.capacity if self.table[index] is None: self.size += 1 self.table[index] = (key, value) def get(self, key): Returns the value associated with the given key, or None if not present. index = self._hash(key) for _ in range(self.capacity): if self.table[index] is None: return None if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % self.capacity return None def del_(self, key): Removes the key-value pair from the hash table. index = self._hash(key) for _ in range(self.capacity): if self.table[index] is None: return if self.table[index][0] == key: self.table[index] = None self.size -= 1 break index = (index + 1) % self.capacity # Rehash subsequent elements to fill the gap next_index = (index + 1) % self.capacity while self.table[next_index] is not None: rehash_key, rehash_value = self.table[next_index] self.table[next_index] = None self.size -= 1 self.put(rehash_key, rehash_value) next_index = (next_index + 1) % self.capacity def __len__(self): Returns the number of key-value pairs stored in the hash table. return self.size"},{"question":"You are given a list of integers that may include negative values. Your task is to implement the Counting Sort algorithm to sort the array in non-decreasing order. # Function Signature ```python def counting_sort(arr: List[int]) -> List[int]: ``` # Input * `arr`: List of integers (can include negative values). Length of array can be up to `10^5`. # Output * Returns a list of integers sorted in non-decreasing order. # Constraints * `-10^5 <= arr[i] <= 10^5` for any valid index `i`. * The input list may include duplicate values and can be empty. # Requirements * Your solution should handle the edge cases efficiently, including negative values and empty lists. * Ensure the algorithm runs in linear time (O(n + k)) and uses linear additional space. # Example Input ```plaintext arr = [4, 2, -1, -3, 4, 3, 0, 1] ``` Output ```plaintext [-3, -1, 0, 1, 2, 3, 4, 4] ``` Explanation The given array contains both positive and negative values. After applying Counting Sort, the resulting sorted array in non-decreasing order is returned. # Notes * The implementation should be efficient in terms of both time and space complexity. * The counting sort should be adapted to handle negative values adequately.","solution":"from typing import List def counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the range of values min_val = min(arr) max_val = max(arr) # Create the count array range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements # Store the count of each element for num in arr: count[num - min_val] += 1 # Change count[i] so that count[i] now contains the actual # position of this element in output array for i in range(1, len(count)): count[i] += count[i - 1] # Build the output array output = [0] * len(arr) for num in reversed(arr): output[count[num - min_val] - 1] = num count[num - min_val] -= 1 return output"},{"question":"# FizzBuzz with a Twist **Objective**: Implement a function to compute a modified version of the FizzBuzz problem. **Problem Statement**: Write a function `extended_fizzbuzz(n: int, multiples: dict) -> list` that returns a list of length n, where: - Numbers from 1 through n are replaced based on the given multiples. - The `multiples` dictionary contains keys as integers and values as their corresponding replacement strings. **Rules**: 1. Replace numbers with corresponding strings as specified in the `multiples` dictionary. 2. If a number matches multiple keys, concatenate the corresponding strings in increasing order of the keys. 3. If no replacements occur, include the number itself as a string. **Input**: - An integer `n` (1 <= n <= 10^5). - A dictionary `multiples` where keys are positive integers and values are non-empty strings. **Output**: - A list of strings based on the above rules. **Example**: ```python extended_fizzbuzz(15, {3: \'Fizz\', 5: \'Buzz\'}) ``` Output: ```python [\'1\', \'2\', \'Fizz\', \'4\', \'Buzz\', \'Fizz\', \'7\', \'8\', \'Fizz\', \'Buzz\', \'11\', \'Fizz\', \'13\', \'14\', \'FizzBuzz\'] ``` **Constraints**: - Optimize for both time (O(n)) and space (O(n)) complexity. - Handle edge cases such as empty multiple dictionaries, single replacements, etc. - Ensure the function gracefully handles invalid inputs with appropriate error messages. **Function Signature**: ```python def extended_fizzbuzz(n: int, multiples: dict) -> list: pass ``` **Additional Context**: Imagine a situation at a software company where the marketing department needs a customized FizzBuzz logic for certain numbers. Your task is to create a flexible implementation to meet varying requests, reflecting real-world adaptability to custom requirements.","solution":"def extended_fizzbuzz(n: int, multiples: dict) -> list: Returns a list where each number from 1 through n is replaced based on the multiples dictionary. Parameters: - n : int : The range of numbers to consider (1 to n). - multiples : dict : Dictionary with keys as multiples and values as replacement strings. Returns: - list : List of strings based on the FizzBuzz rules. result = [] for num in range(1, n + 1): replacement = \'\' for key in sorted(multiples.keys()): if num % key == 0: replacement += multiples[key] if replacement == \'\': result.append(str(num)) else: result.append(replacement) return result"},{"question":"Scenario: You\'re given the task to sort an array using the unconventional and inefficient Stooge Sort algorithm. However, in real scenarios, this algorithm isn\'t practical due to its high time complexity, so you\'ll also implement an optimized version afterward. Problem Statement: 1. Implement the Stooge Sort algorithm to sort a given array of integers in non-decreasing order. 2. Implement an optimized sorting algorithm of your choice (Merge Sort, Quick Sort, etc.) to achieve the same task more efficiently. 3. Compare the performance of both algorithms on different input sizes and summarize the findings. Constraints: - The input array can contain up to 1000 elements. - The elements of the array can range between -10^6 and 10^6. Input: - A list of integers `arr` with length `n`. Output: - Sorted list using Stooge Sort. - Sorted list using an efficient sorting algorithm. - Time taken by both algorithms for different input sizes. Function Definitions: - `stooge_sort(arr: List[int], l: int, h: int) -> List[int]`: Sort the array `arr` from index `l` to `h` using Stooge sort. - `optimized_sort(arr: List[int]) -> List[int]`: Sort the array `arr` using a more efficient sorting algorithm. - `compare_performance(arr: List[int]) -> Dict[str, float]`: Compare the performance of Stooge Sort and the optimized sort. # Example: ```python # Example Input arr = [1, 3, 64, 5, 7, 8] # Expected Output stooge_sort(arr, 0, len(arr) - 1) -> [1, 3, 5, 7, 8, 64] optimized_sort(arr) -> [1, 3, 5, 7, 8, 64] compare_performance(arr) -> {\\"stooge_sort_time\\": time_taken, \\"optimized_sort_time\\": time_taken} ``` Ensure that your implementations are thoroughly tested to validate the correctness of the sorting algorithms. Specifically, measure and compare the execution times for varied input sizes such as [10, 100, 1000] elements.","solution":"import time from typing import List, Dict def stooge_sort(arr: List[int], l: int, h: int) -> List[int]: if l >= h: return arr if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stooge_sort(arr, l, h - t) stooge_sort(arr, l + t, h) stooge_sort(arr, l, h - t) return arr def optimized_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return optimized_sort(left) + middle + optimized_sort(right) def compare_performance(arr: List[int]) -> Dict[str, float]: start_time = time.time() stooge_sort(arr.copy(), 0, len(arr) - 1) stooge_sort_time = time.time() - start_time start_time = time.time() optimized_sort(arr.copy()) optimized_sort_time = time.time() - start_time return {\\"stooge_sort_time\\": stooge_sort_time, \\"optimized_sort_time\\": optimized_sort_time}"},{"question":"# Scenario: Text Search for Substrings You\'re working on a text editor and need to implement a search function. This function should find the position of the first occurrence of a given search string within a larger text. If the search string is not found, the function should return -1. # Function Signature: ```python def find_substring(haystack: str, needle: str) -> int: ``` # Input: - `haystack` (str): The main text to search within. It can be empty. - `needle` (str): The substring to search for. It can be empty. # Output: - (int): The index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints: - Provide a solution with a time complexity of at most O((n-m+1) * m), where `n` is the length of `haystack` and `m` is the length of `needle`. - Do not use built-in string search functionalities like `str.find()` or `str.index()`. # Examples: ```python assert find_substring(\\"hello\\", \\"ll\\") == 2 assert find_substring(\\"aaaaa\\", \\"bba\\") == -1 assert find_substring(\\"\\", \\"\\") == 0 assert find_substring(\\"a\\", \\"\\") == 0 assert find_substring(\\"\\", \\"a\\") == -1 ``` # Explanation: - Example 1: The substring \\"ll\\" is found starting at index 2 in \\"hello\\". - Example 2: The substring \\"bba\\" is not found in \\"aaaaa\\". - Example 3: If both strings are empty, return 0.","solution":"def find_substring(haystack: str, needle: str) -> int: Finds the first occurrence of the substring `needle` in the string `haystack`. Returns the index of the first occurrence, or -1 if `needle` is not part of `haystack`. # Edge case: if needle is empty, return 0 as per the examples given. if needle == \\"\\": return 0 n = len(haystack) m = len(needle) if m > n: return -1 # Loop through the haystack string to find the first occurrence of needle for i in range(n - m + 1): if haystack[i:i + m] == needle: return i return -1"},{"question":"# Reconstructing a Queue Problem **Scenario:** Imagine you are at an amusement park ticket counter. People are standing in a queue, and each person has a ticket number represented by a pair of integers (h, k). Here, h refers to the person’s height, and k indicates how many people taller than or equal to this person are in front of them in the queue. Due to mild mismanagement, this queue data is given unsorted. Your task is to help the ticket counter reconstruct it correctly according to the given data. **Problem:** Write a function `reconstruct_queue` to reconstruct the queue with the given constraints. **Function Signature:** ```python def reconstruct_queue(people: List[List[int]]) -> List[List[int]]: ``` **Input:** * `people`: A list of pairs, where each pair (h, k) represents a person. The number of people is less than 1,100. **Output:** * Return the list representing the reconstructed queue according to the height and the \'k\' values. **Constraints and Performance Requirements:** * You should aim for a solution with polynomial complexity acceptable for up to 1,100 people. * Ensure your function handles all edge cases like similar heights with different \'k\' values robustly. **Example:** ```python Input: [[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]] Output: [[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] ``` **Explanation:** * `[5,0]`: No person in front taller or equal to 5. * `[7,0]`: No person in front taller or equal to 7. * `[5,2]`: Two persons `[7,0]` and `[7,1]` taller in front of `[5,2]`. * And so on... **Edge Cases to Consider:** * When all people have the same height. * When each person has a unique \'k\' value. * Large inputs up to the given limit of 1,100 people. Write your solution considering these requirements and edge cases.","solution":"from typing import List def reconstruct_queue(people: List[List[int]]) -> List[List[int]]: # Sort people first by height in descending order, # and then by the number of people in front (k) in ascending order. people.sort(key=lambda x: (-x[0], x[1])) result = [] for person in people: # Insert person at the index specified by their k value result.insert(person[1], person) return result"},{"question":"# One Edit Distance Question Problem Statement You are given two strings, `S` and `T`. Your task is to determine if they are both one edit distance apart. An edit is defined as: - Inserting a character into one string. - Removing a character from one string. - Replacing a character in one string with another character. Write a function `is_one_edit_distance(s: str, t: str) -> bool` that returns `True` if the two strings are one edit distance apart, otherwise returns `False`. # Input - Two strings `s` and `t` with lengths `0 <= len(s), len(t) <= 10^4`. # Output - Return `True` if the strings are one edit distance apart, otherwise return `False`. # Constraints - The comparison should be case-sensitive. - The algorithm has to be efficient with a time complexity of O(n), where n is the length of the shorter string. # Edge Cases to Consider 1. Both strings are empty. 2. One string is empty, and the other contains one character. 3. Strings that are already identical. 4. Strings of significantly different lengths. # Examples 1. `is_one_edit_distance(\\"ab\\", \\"acb\\")` should return `True` (insertion). 2. `is_one_edit_distance(\\"horse\\", \\"ros\\")` should return `False` (multiple edits required). 3. `is_one_edit_distance(\\"cat\\", \\"cut\\")` should return `True` (substitution). 4. `is_one_edit_distance(\\"a\\", \\"a\\")` should return `False` (no edit at all). # Note Your implementation should handle these cases efficiently and ensure correctness by rigorously checking each possible edit scenario.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: len_s = len(s) len_t = len(t) # Strings need to be almost of same length for single edit distance if abs(len_s - len_t) > 1: return False # Ensure s is the shorter string if len_s > len_t: return is_one_edit_distance(t, s) for i in range(len_s): if s[i] != t[i]: if len_s == len_t: return s[i+1:] == t[i+1:] # Replace scenario else: return s[i:] == t[i+1:] # Insert/Delete scenario # If no differences found so far, the strings are one edit away only if t has one extra character at the end return len_s + 1 == len_t"},{"question":"# Graph Cloning Challenge You are given a class representing a node in an undirected graph and three functions implementing different graph cloning algorithms—BFS, iterative DFS, and recursive DFS. Your task is to implement a new graph cloning function that combines the best practices from the provided methods. # Node Class ```python class UndirectedGraphNode: A node in an undirected graph. Contains a label and a list of neighbouring nodes (initially empty). def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): Return a shallow copy of this node (ignoring any neighbors) return UndirectedGraphNode(self.label) def add_neighbor(self, node): Adds a new neighbor self.neighbors.append(node) ``` # Requirements: 1. Implement a function `clone_graph_combined(node: UndirectedGraphNode) -> UndirectedGraphNode` that efficiently clones the input graph. 2. Ensure that the function handles all edge cases such as self-loops, disconnected nodes, and empty graphs. 3. Your function should provide performance comparable to the existing methods. 4. Include meaningful test cases to validate your implementation. # Constraints: - Nodes in the graph are labeled uniquely. - The graph could have up to 10^4 nodes and an equivalent number of edges. # Function Signature: ```python def clone_graph_combined(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ``` # Example: ```python # Creating a simple graph node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.neighbors = [node1, node2] node1.neighbors = [node2] node2.neighbors = [node2] # self-cycle # Cloning the graph cloned_node0 = clone_graph_combined(node0) assert cloned_node0 is not node0 assert cloned_node0.label == node0.label assert cloned_node0.neighbors[0].label == node0.neighbors[0].label assert cloned_node0.neighbors[1].label == node0.neighbors[1].label assert cloned_node0.neighbors[1].neighbors[0] is cloned_node0.neighbors[1] # Add more test cases as you see fit ``` # Notes: - Pay special attention to the correctness of node connections in the cloned graph. - Consider the efficiency and clarity of your implementation when using common data structures such as dictionaries and queues.","solution":"from collections import deque class UndirectedGraphNode: A node in an undirected graph. Contains a label and a list of neighbouring nodes (initially empty). def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): Return a shallow copy of this node (ignoring any neighbors) return UndirectedGraphNode(self.label) def add_neighbor(self, node): Adds a new neighbor self.neighbors.append(node) def clone_graph_combined(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None # Use a dictionary to map original nodes to their copies node_map = {} # Initialize the queue and put the first node in the queue queue = deque([node]) node_map[node] = node.shallow_copy() while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in node_map: # Clone the neighboring node and put it in the queue node_map[neighbor] = neighbor.shallow_copy() queue.append(neighbor) # Add the copy of the neighbor to the current node\'s neighbors list node_map[current].add_neighbor(node_map[neighbor]) return node_map[node]"},{"question":"# Scenario You are developing a tool that scans and processes files given by users. Part of its functionality includes correctly resolving file paths to their absolute forms so that the application can load resources regardless of the relative path input by users, and handle user-specific paths. # Task **Function to Implement**: - **Function Name**: `resolve_file_path` - **Input**: A list of file paths (strings). - **Output**: A list of corresponding absolute paths. **Constraints**: 1. Paths can be relative or contain tilde (`~`) denoting user\'s home directory. 2. Consider invalid paths and raise an appropriate exception. **Specifications**: - Use the provided `os` library functions to manage paths. - Ensure to catch any exceptions for invalid paths and handle them appropriately (e.g., return `None` for invalid paths). **Input Format**: - Function `resolve_file_path` receives a list of strings where each string denotes a file path. **Output Format**: - Returns a list of strings, each being the absolute path corresponding to the input list elements, or `None` for any invalid path. ```python def resolve_file_path(file_paths): import os result = [] for file in file_paths: try: abs_path = os.path.abspath(os.path.expanduser(file)) result.append(abs_path) except Exception as e: result.append(None) return result # Example Usage: # Input: [\\"~/file.txt\\", \\"../path/to/file\\", \\"invalid!path\\"] # Output: [\\"<absolute_path_of_home>/file.txt\\", \\"<absolute_path_of_current_dir>/path/to/file\\", None] ```","solution":"def resolve_file_path(file_paths): import os result = [] for file in file_paths: try: abs_path = os.path.abspath(os.path.expanduser(file)) result.append(abs_path) except Exception: result.append(None) return result # Example Usage: # Input: [\\"~/file.txt\\", \\"../path/to/file\\", \\"invalid!path\\"] # Output: [\\"<absolute_path_of_home>/file.txt\\", \\"<absolute_path_of_current_dir>/path/to/file\\", None]"},{"question":"# Frequency Capped List Filter You are given a list and a number N. Your task is to implement a function `cap_frequencies` that creates a new list where each element occurs at most N times while maintaining the original order of elements. Function Signature ```python def cap_frequencies(lst: list, N: int) -> list: pass ``` Input - `lst`: A list of integers. The list can contain up to 100,000 elements. - `N`: An integer (0 ≤ N ≤ 1000) representing the maximum allowed frequency of any element in the list. Output - A new list containing elements from `lst`, but with each element appearing at most `N` times. Requirements - Your solution should be optimized for performance with a time complexity of O(n). Constraints - Elements in `lst` should maintain their original order. - The function should handle edge cases where `N` is 0 or `lst` is empty. Examples ```python assert cap_frequencies([1,2,3,1,2,1,2,3], 2) == [1,2,3,1,2,3] assert cap_frequencies([1,1,1,1], 2) == [1,1] assert cap_frequencies([1,2,3,4,5], 1) == [1,2,3,4,5] assert cap_frequencies([4,4,4,4,5,5,6,6,7,7], 1) == [4,5,6,7] assert cap_frequencies([], 3) == [] assert cap_frequencies([1, 2, 3], 0) == [] ``` Explanation - In the first example, the maximum number of each element is 2. The third occurrence of `1` and `2` is dropped. - In the second example, `1` appears at most 2 times in the output list. - The third example accepts only one occurrence of each element since `N=1`. - The fourth example only allows unique occurrences of each element. - The fifth example, applied to an empty list, returns an empty list. - The sixth example where `N=0` results in an empty list regardless of input.","solution":"def cap_frequencies(lst: list, N: int) -> list: Returns a list where each element appears at most N times. if N == 0: return [] element_count = {} result = [] for item in lst: if item not in element_count: element_count[item] = 0 if element_count[item] < N: result.append(item) element_count[item] += 1 return result"},{"question":"# Question: Word Pattern Matching Objective: Write a function `word_pattern` that determines if a given string `str` follows a specific `pattern`. Your solution should ensure a bijective relationship between the characters in `pattern` and the words in `str`. Function Signature: ```python def word_pattern(pattern: str, str: str) -> bool: ``` Input: * `pattern` (str): A string of lowercase letters. * `str` (str): A string of lowercase words separated by spaces. Output: * Returns `True` if `str` follows the `pattern`, otherwise `False`. Constraints: * Each character in `pattern` must map to a unique word in `str`. * No two different characters in `pattern` can map to the same word in `str`. * Assume `pattern` and `str` are non-empty. * Words in `str` are separated by a single space. Examples: 1. Input: `pattern = \\"abba\\"`, `str = \\"dog cat cat dog\\"` Output: `True` 2. Input: `pattern = \\"abba\\"`, `str = \\"dog cat cat fish\\"` Output: `False` 3. Input: `pattern = \\"aaaa\\"`, `str = \\"dog cat cat dog\\"` Output: `False` 4. Input: `pattern = \\"abba\\"`, `str = \\"dog dog dog dog\\"` Output: `False` Scenario: Imagine you are developing a library system where each borrowed item follows a unique checkout pattern. Write a function to verify that the checkout logs align with the predefined patterns based on a bijective mapping. Requirements: * Performance should be optimized for potentially large strings (up to 1000 words). * Provide early exit for mismatched lengths or impossible mappings.","solution":"def word_pattern(pattern: str, str: str) -> bool: words = str.split() if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char in char_to_word: if char_to_word[char] != word: return False else: char_to_word[char] = word if word in word_to_char: if word_to_char[word] != char: return False else: word_to_char[word] = char return True"},{"question":"# Context You are tasked with implementing a scheduling system for a project. Tasks are prioritized such that the task with the smallest numerical identifier needs to be executed first. Your task is to develop the core data structure to support this scheduling system and to handle task insertion and removal efficiently. # Objective Implement the `BinaryHeap` class to support task prioritization using a min-heap. Your implementation will include methods to insert a new task and to remove and return the highest-priority task (i.e., the task with the lowest identifier). # Function Implementations 1. **insert(val)** - **Input**: A single integer `val` representing the task identifier. - **Output**: None - **Operation**: Insert the task into the heap. 2. **remove_min()** - **Input**: None - **Output**: An integer representing the highest-priority task identifier. - **Operation**: Remove and return the task with the lowest identifier, re-adjusting the heap to maintain the min-heap property. # Constraints - You may assume the task identifiers are distinct positive integers. - A maximum of `10^5` operations will be performed. - Direct manipulation of the heap list outside of defined methods is not allowed. # Example Usage ```python # Create an instance of the BinaryHeap class heap = BinaryHeap() # Insert tasks heap.insert(5) heap.insert(3) heap.insert(8) # Remove highest-priority task print(heap.remove_min()) # Output: 3 # Insert more tasks heap.insert(2) # Remove highest-priority task print(heap.remove_min()) # Output: 2 ``` Implement the methods in the `BinaryHeap` class to meet the above requirements.","solution":"class BinaryHeap: def __init__(self): self.heap = [] def insert(self, val): # Insert at the end and then bubble up self.heap.append(val) self._bubble_up(len(self.heap) - 1) def remove_min(self): # Replace the root with the last element and bubble down if len(self.heap) == 0: raise IndexError(\\"remove_min() called on an empty heap\\") if len(self.heap) == 1: return self.heap.pop() min_val = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return min_val def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index): min_index = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[min_index]: min_index = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[min_index]: min_index = right_child_index if min_index != index: self.heap[index], self.heap[min_index] = self.heap[min_index], self.heap[index] self._bubble_down(min_index)"},{"question":"# Linear Search Implementation and Optimization Context You are working with a team developing a new operating system. One of your tasks involves writing functions for file search operations. The simple file search must be quick and efficient, and operate on a list of filenames (an array). Task Write a function named `optimized_linear_search` that improves the linear search by reducing unnecessary comparisons. You need to ensure correctness and efficiency by adding early exit conditions or any other optimizations. Additionally, handle empty arrays and invalid inputs gracefully. Function Signature ```python def optimized_linear_search(array: list, query: str) -> int: ``` Input * `array`: A list of filenames (strings) where the search operation will be performed. * `query`: The filename (string) to be searched within the array. Output * Return the index of the first occurrence of the query in the array, or -1 if the query is not found. Constraints * The `array` can contain up to 10^5 filenames. * Each filename is a non-empty string with a maximum length of 255 characters. Scenario/Example Consider the following scenarios to help clarify the requirements: ```python # Example 1 optimized_linear_search([\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"], \\"file2.txt\\") # Output: 1 # Example 2 optimized_linear_search([\\"file1.txt\\", \\"file2.txt\\", \\"file3.txt\\"], \\"file4.txt\\") # Output: -1 # Example 3 optimized_linear_search([], \\"file2.txt\\") # Output: -1 ```","solution":"def optimized_linear_search(array: list, query: str) -> int: Returns the index of the first occurrence of query in array, or -1 if not found. if not array or not isinstance(query, str): return -1 for index, element in enumerate(array): if element == query: return index return -1"},{"question":"# Scenario You are working on a project that involves cleaning datasets represented as singly linked lists. Each node in the list contains a string value, and you need to ensure all values in the list are unique. Implement two functions to achieve this. # Problem Statement Write two functions, `remove_duplicates_with_set` and `remove_duplicates_without_set`, each removing duplicates from a singly linked list. You also need to implement a helper function `print_linked_list` to display the elements of the list. # Implementation Details 1. **Function Definitions**: - `def remove_duplicates_with_set(head: Node) -> None:` - `def remove_duplicates_without_set(head: Node) -> None:` - `def print_linked_list(head: Node) -> None:` 2. **Expected Input and Output**: - Each function takes the `head` of a singly linked list. - The list should be modified in place. - `print_linked_list` should print the list in a readable format (e.g., \\"A -> B -> C\\") 3. **Constraints**: * The linked list node values are strings. * Modify the list in place, do not return any value. * Aim to demonstrate your understanding of two approaches: - Using extra memory (e.g., a set) - Without using extra memory # Example Given the linked list: A -> A -> B -> C -> D -> C -> F -> G ```python class Node: def __init__(self, val=None): self.val = val self.next = None # Creating example linked list a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g ``` After calling `remove_duplicates_with_set(a1)`, the list should be: A -> B -> C -> D -> F -> G After calling `remove_duplicates_without_set(a1)`, the list should be (applied again for ensuring no performance degradation): A -> B -> C -> D -> F -> G # Your Task Write the body of the functions `remove_duplicates_with_set`, `remove_duplicates_without_set`, and `print_linked_list`.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_duplicates_with_set(head: Node) -> None: if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_duplicates_without_set(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: elements = [] while head: elements.append(head.val) head = head.next print(\\" -> \\".join(elements))"},{"question":"Robot Path Verification You are working on a simulation where you need to verify whether a robot, starting at the position (0, 0) on a 2D plane, returns to the starting point after executing a sequence of movements. Given a string `moves`, where each character represents a movement: - \'R\' moves the robot right. - \'L\' moves the robot left. - \'U\' moves the robot up. - \'D\' moves the robot down. Write a function `verify_robot_path(moves)` that returns `True` if the robot returns to its starting position, or `False` if it does not. # Function Signature ```python def verify_robot_path(moves: str) -> bool: ``` # Input - `moves` (1 <= len(moves) <= 10^4): A string of characters where each character is one of [\'L\', \'R\', \'U\', \'D\']. # Output - `True` if the robot returns to the starting position after all moves. - `False` otherwise. # Examples Example 1: ```python print(verify_robot_path(\\"UD\\")) # Output: True ``` Example 2: ```python print(verify_robot_path(\\"LL\\")) # Output: False ``` Example 3: ```python print(verify_robot_path(\\"\\")) # Output: True (The robot doesn\'t move) ``` # Constraints 1. The input string will only contain characters \'U\', \'D\', \'L\', \'R\'. # Performance Requirements - Your solution should run efficiently for inputs up to length 10^4. - Aim to achieve linear time complexity and constant space complexity. # Edge Cases - Handle empty move string. - Ensure the function works for the maximum string length of 10^4. # Scenario Context You are helping a robotics team to verify their simulation paths. One key requirement is to confirm whether the robot always returns to its starting position (0, 0) after executing a series of movements. Given its critical importance, your solution must handle the input efficiently and accurately.","solution":"def verify_robot_path(moves: str) -> bool: x, y = 0, 0 for move in moves: if move == \'R\': x += 1 elif move == \'L\': x -= 1 elif move == \'U\': y += 1 elif move == \'D\': y -= 1 return x == 0 and y == 0"},{"question":"Context You\'re given a list of words. Each word consists of English alphabet characters only. You have to determine which words from the list can be typed using letters from only one row of an American QWERTY keyboard. This involves understanding how to traverse strings and utilize set operations effectively. Problem Statement Implement a function `find_keyboard_row(words)` that takes a list of strings `words` and returns a new list containing only those words which can be typed using letters from only one row of an American QWERTY keyboard. Function Signature ```python def find_keyboard_row(words: List[str]) -> List[str]: pass ``` Constraints - All words contain only alphabet characters (both uppercase and lowercase). - The return order of the words should be the same as their appearance in the input list. - The input list can contain between 1 and 10⁴ words. - Each word can have a length between 1 and 100 characters. Input - A list of words, where each word is a non-empty string consisting of English alphabet characters only. Output - A list of words that can be typed using letters from only one row of an American QWERTY keyboard. Example ```python # Example 1 Input: [\\"Hello\\", \\"Alaska\\", \\"Dad\\", \\"Peace\\"] Output: [\\"Alaska\\", \\"Dad\\"] # Example 2 Input: [\\"asdf\\", \\"qwer\\", \\"zxcv\\", \\"aaaa\\"] Output: [\\"asdf\\", \\"qwer\\", \\"zxcv\\"] ``` Edge Cases - Words with mixed uppercase and lowercase letters should be treated case-insensitively. - The function should gracefully handle an empty input list and return an empty list in such cases. Guidance You should use set operations to efficiently determine if all letters of a word belong to one of the predefined sets representing keyboard rows. Note: You are not allowed to import any external libraries; use only the standard Python libraries.","solution":"def find_keyboard_row(words): row1 = set(\\"qwertyuiop\\") row2 = set(\\"asdfghjkl\\") row3 = set(\\"zxcvbnm\\") def is_single_row(word): lowercase_word = word.lower() return (set(lowercase_word) <= row1 or set(lowercase_word) <= row2 or set(lowercase_word) <= row3) return [word for word in words if is_single_row(word)]"},{"question":"# Problem Context You are traveling on a train with a strange rule: you can move either one carriage or two carriages at a time. Given a train with `carriages` number of carriages, you need to find out in how many distinct ways you can move from the start (carriage 1) to the end (carriage `carriages`). # Problem Statement Write a function `distinct_ways_to_move(carriages)` to calculate the total number of distinct ways you can move to the last carriage. # Function Signature ```python def distinct_ways_to_move(carriages: int) -> int: pass ``` # Input * **carriages**: A positive integer `carriages` representing the number of carriages in the train (`1 ≤ carriages ≤ 10^5`). # Output * Return the number of distinct ways to get to the last carriage. # Constraints * `1 ≤ carriages ≤ 100,000` * Optimize for both time and space complexity. # Examples ```python assert distinct_ways_to_move(2) == 2 # [1,1], [2] assert distinct_ways_to_move(3) == 3 # [1,1,1], [1,2], [2,1] assert distinct_ways_to_move(4) == 5 # [1,1,1,1], [1,1,2], [1,2,1], [2,1,1], [2,2] ``` # Notes * This problem is equivalent to finding the number of ways to climb stairs where you can take either 1 or 2 steps at a time. * Think about optimizing your implementation to use minimal space.","solution":"def distinct_ways_to_move(carriages: int) -> int: Returns the number of distinct ways to move to the last carriage. if carriages == 1: return 1 elif carriages == 2: return 2 prev2, prev1 = 1, 2 for _ in range(3, carriages + 1): curr = prev1 + prev2 prev2, prev1 = prev1, curr return prev1"},{"question":"# Question: Efficient Calculation of Binomial Coefficients Given positive integers (n) and (k) (where (n geq k)), write a function `iterative_binomial_coefficient` to calculate the binomial coefficient (C(n, k)) (which denotes the number of ways to choose (k) items from (n) items without regard to the order). Your function should avoid recursion to handle larger values efficiently and compute the coefficient using an iterative approach or dynamic programming. Provide an implementation that runs in (O(k)) time complexity. Function Signature ```python def iterative_binomial_coefficient(n: int, k: int) -> int: ``` Input * Two integers (n) and (k), where (n geq k geq 0). Output * An integer representing the binomial coefficient (C(n, k)). Constraints * (0 leq k leq n leq 10^6) * Input values are non-negative integers. Examples 1. `iterative_binomial_coefficient(5, 2)` should return `10` 2. `iterative_binomial_coefficient(8, 2)` should return `28` 3. `iterative_binomial_coefficient(500, 300)` should return a large integer that represents (C(500, 300)) Edge Cases * Consider (k = 0) and (n = k), which should both return `1`. * Efficiently handle large inputs within provided constraints without running into performance bottlenecks.","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Calculates the binomial coefficient C(n, k) using an iterative approach. if k > n - k: # Taking advantage of symmetry C(n, k) == C(n, n-k) k = n - k result = 1 for i in range(k): result *= (n - i) result //= (i + 1) return result"},{"question":"# Matrix Inversion Assessment Task Objective Implement a function to invert an n x n invertible matrix. The function should follow the principles outlined in the provided algorithm and must handle edge cases appropriately. Requirements - Write a function `invert_matrix(matrix: List[List[float]]) -> List[List[float]]` that: 1. Validates the input matrix ensuring it is a square and invertible matrix. 2. Uses the steps of cofactor expansion to compute the inverse. - You are provided an initial set of utilities to aid in your task, but you should write the necessary code within the `invert_matrix` function and any helper functions it requires. Input - `matrix`: A list of lists of floats representing an n x n matrix. Output - Returns a list of lists representing the inverse of the matrix, or specific error codes as nested lists if the matrix is invalid: - `[[-1]]` if the input is not a matrix. - `[[-2]]` if the matrix is not square. - `[[-3]]` if the matrix size is smaller than 2. - `[[-4]]` if the matrix is singular. # Example ```python invert_matrix([[4, 7], [2, 6]]) # Expected output: [[0.6, -0.7], [-0.2, 0.4]] invert_matrix([[1, 2], [2, 4]]) # Expected output: [[-4]] # because the determinant is 0 ``` Constraints - Matrix elements can be positive or negative floating-point numbers. - The matrix size `n` can be up to 10 (for this exercise, due to computational complexity). # Notes - Leverage the provided utilities (e.g., `array_is_matrix`, `get_determinant`, `get_minor`, `transpose_and_multiply`) to aid in implementing the main function. - Ensure your code is well-commented to explain logic and edge cases.","solution":"from typing import List def array_is_matrix(array): if not isinstance(array, list) or not all(isinstance(row, list) for row in array): return False row_length = len(array[0]) if not all(len(row) == row_length for row in array): return False return True def get_determinant(matrix: List[List[float]]) -> float: n = len(matrix) if n == 1: return matrix[0][0] elif n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(len(matrix)): determinant += ((-1)**c) * matrix[0][c] * get_determinant(get_minor(matrix, 0, c)) return determinant def get_minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose_and_multiply(matrix: List[List[float]], multiplier: float) -> List[List[float]]: transposed = [[matrix[j][i] for j in range(len(matrix))] for i in range(len(matrix))] result = [[transposed[i][j] * multiplier for j in range(len(transposed))] for i in range(len(transposed))] return result def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: if not array_is_matrix(matrix): return [[-1]] n = len(matrix) if any(len(row) != n for row in matrix): return [[-2]] if n < 2: return [[-3]] determinant = get_determinant(matrix) if determinant == 0: return [[-4]] cofactor_matrix = [] for i in range(n): cofactor_row = [] for j in range(n): minor = get_minor(matrix, i, j) cofactor_row.append(((-1) ** (i + j)) * get_determinant(minor)) cofactor_matrix.append(cofactor_row) return transpose_and_multiply(cofactor_matrix, 1 / determinant)"},{"question":"Stack Element Duplication Given a stack of integers, you are required to write a function that modifies the stack such that every value in the stack is replaced with two occurrences of that value. Implement this function using a single stack as auxiliary storage. Function Signature ```python def stack_stutter(stack: List[int]) -> List[int]: ``` Input * `stack`: A list of integers representing a stack, where the first element of the list is the bottom of the stack and the last element is the top of the stack. Output * The function should return the modified stack with each original element duplicated. Constraints * Do not use any built-in functions that directly perform this task. * The input stack can have a size up to 10^5. * The elements in the stack are integers ranging from -10^9 to 10^9. * You should only use a single additional stack for auxiliary storage. Example ```python # Input stack = [3, 7, 1, 14, 9] # Output result = [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` Guidelines 1. Write a function `stack_stutter` that takes a stack, represented as a list of integers. 2. Use a single auxiliary stack for any necessary temporary storage. 3. Ensure that the solution is efficient in terms of time and space complexity. Good luck, and make sure your code handles the edge cases efficiently!","solution":"def stack_stutter(stack): This function takes a stack represented as a list of integers and duplicates each element such that each original element appears twice consecutively. Args: stack (List[int]): The input stack of integers Returns: List[int]: The modified stack with each original element duplicated. auxiliary_stack = [] # Empty the original stack and fill the auxiliary stack with duplicated elements while stack: top = stack.pop() auxiliary_stack.append(top) auxiliary_stack.append(top) # Transfer the newly ordered elements back to the original stack while auxiliary_stack: stack.append(auxiliary_stack.pop()) return stack"},{"question":"You are given a singly linked list represented by the head node (you may assume that the list is implemented with the `Node` class shown below). Your task is to determine if the linked list has a cycle in it, using the Floyd’s Tortoise and Hare algorithm. A cycle in a linked list occurs when a node’s next pointer points back to a previous node, forming a loop. The basic idea of the algorithm involves two pointers moving at different speeds through the list, where a cycle is identified if the pointers ever meet. # Node Class Definition ```python class Node: def __init__(self, x): self.val = x self.next = None ``` # Function Signature ```python def is_cyclic(head: Node) -> bool: ``` # Input * `head`: A head node of a singly linked list. # Output * Return `True` if the linked list contains a cycle, otherwise return `False`. # Constraints * The number of nodes in the list is in the range [0, 10^4]. * Node values range from -10^5 to 10^5. # Example 1. **Example 1**: * Input: head = [3, 2, 0, -4], pos = 1 (where pos is the index in the list where the last node links back to) * Output: True 2. **Example 2**: * Input: head = [1, 2], pos = 0 * Output: True 3. **Example 3**: * Input: head = [1], pos = -1 * Output: False # Explanation The \\"pos\\" parameter is of no use to the function implementation and is only used to indicate the node where the cycle begins for the sake of explaining examples. # Instructions * Implement the function `is_cyclic(head: Node) -> bool` that follows the principles of Floyd’s Tortoise and Hare algorithm. * Ensure the function handles edge cases such as empty lists or single node lists correctly. * Your code should be efficient with a time complexity of O(n) and a space complexity of O(1).","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: Determines if a singly linked list has a cycle in it using Floyd\'s Tortoise and Hare algorithm. if not head: # If the list is empty return False slow = head fast = head while fast and fast.next: slow = slow.next # Move slow pointer by 1 step fast = fast.next.next # Move fast pointer by 2 steps if slow == fast: # If they meet, there\'s a cycle return True return False # If fast pointer reaches the end, there\'s no cycle"},{"question":"You are given a Binary Search Tree (BST) data structure for storing integer values. The height of a BST is a crucial measure, as it affects the time complexity of operations like search, insert, and delete. As such, you need to ensure that you can accurately calculate the height of a given BST. Given the following `Node` class implementing the structure of a tree node and the `BST` class that supports insertion, implement a function `height` to determine the height of a BST. ```python class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(key, self.root) def _insert(self, key, current_node): if key < current_node.value: if current_node.left is None: current_node.left = Node(key) else: self._insert(key, current_node.left) else: if current_node.right is None: current_node.right = Node(key) else: self._insert(key, current_node.right) ``` # Task: Implement the function `height(root: Node) -> int` that calculates the height of the BST. Input: - `root`: Node - the root node of a binary search tree. Output: - Returns the height of the tree. Constraints: - The number of nodes in the tree will be less than or equal to 1000. Example: ```plaintext Input: The following tree structure: 9 / 6 12 / / 3 8 10 15 / 7 18 Output: 4 # Explanation: The tree has 4 levels. ``` Note: - You must handle edge cases such as an empty tree (height 0). - Your implementation should be based on the properties of binary trees and should correctly handle all BST properties.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.value = key class BST: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = Node(key) else: self._insert(key, self.root) def _insert(self, key, current_node): if key < current_node.value: if current_node.left is None: current_node.left = Node(key) else: self._insert(key, current_node.left) else: if current_node.right is None: current_node.right = Node(key) else: self._insert(key, current_node.right) def height(root): Function to compute the height of a binary search tree (BST). :param root: root node of the BST :return: height of the BST if root is None: return 0 else: left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Task You are tasked with implementing a function that detects content similarity on a file-sharing platform. The function shall compare file content represented as vectors of numerical features and determine how similar two files are. # Objective Given two vectors, your function should compute the cosine similarity between them. The similarity ranges from -1 to 1, where: - 1 implies identical orientation (high similarity). - -1 indicates opposite orientation. - 0 denotes orthogonal orientation (no similarity). # Function Specification ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: ``` - `vec1`: A list of floating-point numbers representing the feature vector of the first file. - `vec2`: A list of floating-point numbers representing the feature vector of the second file. # Constraints 1. The vectors `vec1` and `vec2` will have a length between 1 and 10,000. 2. Each element in the vectors will be a floating-point number between -1000.0 and 1000.0. 3. The two vectors provided to the function will have the same length. # Output The function should return a single floating-point number, which is the cosine similarity between the two vectors. # Examples ```python # Example 1 print(cosine_similarity([1, 1, 1], [1, 2, -1])) # output should be 0.47140452079103173 # Example 2 print(cosine_similarity([1, 0, -1], [1, 0, -1])) # output should be 1.0 # Example 3 print(cosine_similarity([1, 2, 3], [-1, -2, -3])) # output should be -1.0 ``` # Explanation For Example 1: - Norm of vec1: sqrt(1^2 + 1^2 + 1^2) = sqrt(3) - Norm of vec2: sqrt(1^2 + 2^2 + (-1)^2) = sqrt(6) - Dot product of vec1 and vec2: 1*1 + 1*2 + 1*(-1) = 2 - Cosine similarity = 2 / (sqrt(3) * sqrt(6)) ≈ 0.47140452079103173 # Note Account for cases where the vectors might have zero magnitude since this will result in division by zero.","solution":"import math from typing import List def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: Compute the cosine similarity between two vectors. :param vec1: List of floats representing the first vector. :param vec2: List of floats representing the second vector. :return: Cosine similarity between vec1 and vec2. dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) norm_vec1 = math.sqrt(sum(v1**2 for v1 in vec1)) norm_vec2 = math.sqrt(sum(v2**2 for v2 in vec2)) # To handle the case where one or both vectors have zero magnitude if norm_vec1 == 0 or norm_vec2 == 0: return 0.0 return dot_product / (norm_vec1 * norm_vec2)"},{"question":"Problem Statement You are required to implement a variant of the Bucket Sort algorithm. The provided implementation uses insertion sort to sort elements within each bucket. However, due to its potential inefficiencies in certain scenarios, we want to replace the insertion sort with a more efficient quicksort. **Function Signature**: ```python def bucket_sort(arr: List[int]) -> List[int]: pass ``` **Input**: - `arr` is a list of non-negative integers. **Output**: - Return a list of integers sorted in non-decreasing order. **Constraints**: - Ensure that the function can handle arrays of size up to 10^4 efficiently. **Performance Requirements**: - Aim for a time complexity close to O(n log n) in the average case. **Hint**: 1. Choose the right number of buckets to balance the load. 2. Use quicksort instead of insertion sort for sorting within each bucket. **Examples**: ```python # Example 1 input = [4, 2, 2, 8, 3, 3, 1] assert bucket_sort(input) == [1, 2, 2, 3, 3, 4, 8] # Example 2 input = [9, 7, 8, 2, 3, 1, 4, 6, 5] assert bucket_sort(input) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` **Edge Cases**: - Test with an empty array: []. - Test with array containing one element: [7]. - Test with array containing duplicate elements: [5, 1, 5, 5].","solution":"from typing import List def quicksort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quicksort(left) + middle + quicksort(right) def bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] max_value = max(arr) num_buckets = len(arr) buckets = [[] for _ in range(num_buckets)] for x in arr: index = (x * (num_buckets - 1)) // max_value buckets[index].append(x) sorted_arr = [] for bucket in buckets: sorted_arr.extend(quicksort(bucket)) return sorted_arr"},{"question":"# Anagram Validation Function Given two strings `s1` and `s2`, implement a function `is_anagram(s1: str, s2: str) -> bool` to determine if `s2` is an anagram of `s1`. Input Format * `s1`: A string containing only lowercase alphabets (1 <= len(s1) <= 10^5). * `s2`: A string containing only lowercase alphabets (1 <= len(s2) <= 10^5). Output Format * Return `True` if `s2` is an anagram of `s1`, otherwise return `False`. Constraints * The strings contain only lowercase alphabets. * The function should have a time complexity of O(n) and use O(1) extra space beyond input storage. Example ```python assert is_anagram(\\"anagram\\", \\"nagaram\\") == True assert is_anagram(\\"rat\\", \\"car\\") == False assert is_anagram(\\"listen\\", \\"silent\\") == True assert is_anagram(\\"hello\\", \\"holle\\") == False ``` Performance Requirements * Your solution should handle the worst-case scenario within acceptable time limits as outlined in the constraints.","solution":"def is_anagram(s1: str, s2: str) -> bool: Returns True if s2 is an anagram of s1, otherwise False. if len(s1) != len(s2): return False count = [0] * 26 # Since there are 26 lowercase alphabets for char in s1: count[ord(char) - ord(\'a\')] += 1 for char in s2: count[ord(char) - ord(\'a\')] -= 1 for c in count: if c != 0: return False return True"},{"question":"Finding the In-order Successor in a BST You are given a Binary Search Tree (BST) and a target node. Your task is to write a function that finds the in-order successor of this node. The in-order successor of a node in a BST is the next node in the in-order traversal of the BST. Function Signature ```python def successor(root, node): Finds the in-order successor of a node in a BST. Args: root (TreeNode): The root of the BST. node (TreeNode): The target node for which to find the in-order successor. Returns: TreeNode: The in-order successor of the given node, or None if it does not exist. ``` Input - `root`: A `TreeNode` representing the root of the BST. - `node`: A `TreeNode` representing the target node within the BST to find its successor. Output - Returns the in-order successor of the node if it exists, otherwise returns `None`. Constraints - The number of nodes in the tree is at most 10^4. - Each node’s value will be a unique integer within the range -10^5 to 10^5. Example Given the following BST and target node `15`: ``` 20 / 10 30 / / 5 15 25 35 17 ``` - For target node `15`, the in-order successor would be `17`. - For target node `20`, the in-order successor would be `25`. Notes - Consider edge cases where the target node might not have an in-order successor, such as the node being the largest element in the tree. - Ensure your solution handles the given constraints efficiently.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def successor(root, node): Finds the in-order successor of a node in a BST. Args: root (TreeNode): The root of the BST. node (TreeNode): The target node for which to find the in-order successor. Returns: TreeNode: The in-order successor of the given node, or None if it does not exist. successor = None # If the node has a right child, go deep to the leftmost node in the right subtree if node.right: successor = node.right while successor.left: successor = successor.left return successor # If the node does not have a right child, traverse the tree from the root # trying to find the node and its successor while root: if node.val < root.val: successor = root root = root.left elif node.val > root.val: root = root.right else: break return successor"},{"question":"# Matrix Inversion with Custom Constraints Your task is to implement a function that inverts a given ( n times n ) matrix, but with some constraints for an educational scenario. This question assesses your understanding of matrix operations such as transpose, determinant, and cofactor calculations. # Function Signature ```python def custom_invert_matrix(matrix: List[List[float]]) -> List[List[float]]: ``` # Input * `matrix`: A list of lists representing a ( n times n ) matrix where ( 2 leq n leq 10 ) and all elements are floats. # Output * Return the inverted matrix as a list of lists of floats. * If the matrix is not invertible or any constraint is violated, return an appropriate error message: - \\"Invalid matrix: not a square matrix\\" - \\"Invalid matrix: matrix is too small\\" - \\"Invalid matrix: matrix is singular (determinant = 0)\\" # Constraints 1. The matrix is given in a proper format, meaning it will always be a list of lists and will not be empty. 2. Your implementation must handle matrices only within the range ( 2 leq n leq 10 ). # Performance * Aim for clarity and correctness. * Optimize determinant calculation and avoid redundant traversals where possible. # Examples ```python assert custom_invert_matrix([[4, 7], [2, 6]]) == [[0.6, -0.7], [-0.2, 0.4]] assert custom_invert_matrix([[1, 2], [3, 4]]) == \\"Invalid matrix: matrix is singular (determinant = 0)\\" assert custom_invert_matrix([[1, 2, 3], [0, 1, 4], [5, 6, 0]]) == [[-24.0, 18.0, 5.0], [20.0, -15.0, -4.0], [-5.0, 4.0, 1.0]] ```","solution":"from typing import List def get_determinant(matrix: List[List[float]], n: int) -> float: if n == 1: return matrix[0][0] if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] determinant = 0 for c in range(n): determinant += ((-1)**c) * matrix[0][c] * get_determinant(get_cofactor(matrix, 0, c), n-1) return determinant def get_cofactor(matrix: List[List[float]], p: int, q: int) -> List[List[float]]: n = len(matrix) temp = [[0 for _ in range(n)] for _ in range(n)] i = j = 0 for row in range(n): for col in range(n): if row != p and col != q: temp[i][j] = matrix[row][col] j += 1 if j == n - 1: j = 0 i += 1 return [row[:n-1] for row in temp[:n-1]] def adjoint(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) if n == 1: return [[1]] adj = [[0 for _ in range(n)] for _ in range(n)] sign = 1 for i in range(n): for j in range(n): temp = get_cofactor(matrix, i, j) sign = 1 if (i + j) % 2 == 0 else -1 adj[j][i] = sign * get_determinant(temp, n-1) return adj def custom_invert_matrix(matrix: List[List[float]]) -> List[List[float]]: n = len(matrix) for row in matrix: if len(row) != n: return \\"Invalid matrix: not a square matrix\\" if not (2 <= n <= 10): return \\"Invalid matrix: matrix is too small\\" determinant = get_determinant(matrix, n) if determinant == 0: return \\"Invalid matrix: matrix is singular (determinant = 0)\\" adj = adjoint(matrix) inverted_matrix = [[adj[i][j] / determinant for j in range(n)] for i in range(n)] return inverted_matrix"},{"question":"# Task: You need to implement a Trie (prefix tree), and provide functions to insert words, search for them, and display the stored words in a hierarchical structure. # Requirements: 1. Implement the Trie data structure with insert, search, and display methods. 2. The display method must print the hierarchical structure of the Trie as specified in the given format. # Functions to Implement: * `TrieNode` class with methods: * `__init__(self)`: Initializes the node. * `Trie` class with methods: * `__init__(self)`: Initializes the trie. * `insert(self, word)`: Inserts a word into the trie. * `search(self, word)`: Searches for a word in the trie and returns `True` if it exists, `False` otherwise. * `display(self)`: Displays the trie structure in the specified format: ``` a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` # Input: * Function: `insert(\\"word\\")`: A string `word` representing the word to be inserted. * Function: `search(\\"word\\")`: A string `word` representing the word to search in the Trie. # Output: * Function: `search(\\"word\\")`: Returns a boolean indicating if the word exists in the Trie. * Function: `display()`: Prints the trie\'s hierarchical structure. # Constraints: * The words to be inserted will only contain alphabet characters. * There will be no duplicate entries for the same word. # Example: ```python # Create a new trie and insert words trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"app\\") trie.insert(\\"apricot\\") # Search for words print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"banana\\")) # Output: False # Display the Trie structure trie.display() ``` # Notes: * The `display` method should exactly match the specified format. * Consider edge cases such as inserting an empty string or searching for a non-existent word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word): node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def display(self): words = [] self._dfs(self.root, \\"\\", words) for word in words: print(word) def _dfs(self, node, prefix, words): if node.is_end_of_word: words.append(prefix) for char in sorted(node.children.keys()): self._dfs(node.children[char], prefix + char, words)"},{"question":"Given the Exchange Sort algorithm described above, your task is to implement a function that sorts a list of integers using this sorting technique. You need to handle various edge cases and ensure the function remains efficient for small lists. # Function Signature ```python def exchange_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` where `0 <= len(arr) <= 1000`. * The integers can be positive or negative. # Output * A list of integers sorted in ascending order. # Constraints * The algorithm should perform in O(n²) time complexity and O(1) space complexity. # Example ```python # Example 1 input_arr = [5, 2, 9, 1, 5, 6] output_arr = exchange_sort(input_arr) print(output_arr) # Output: [1, 2, 5, 5, 6, 9] # Example 2 input_arr = [3, 0, -1, 2] output_arr = exchange_sort(input_arr) print(output_arr) # Output: [-1, 0, 2, 3] # Example 3 input_arr = [] output_arr = exchange_sort(input_arr) print(output_arr) # Output: [] ``` Ensure your implementation is optimized to handle edge cases gracefully and maintains the specified complexity constraints.","solution":"def exchange_sort(arr): Sort the list of integers `arr` using the Exchange Sort algorithm. :param List[int] arr: The list of integers to sort. :return: The sorted list. :rtype: List[int] n = len(arr) for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"# Coding Task: Advanced Bucket Sort with Custom Sorting **Context**: You have studied the basics of various sorting algorithms and have implemented bucket sort using insertion sort for internal bucket sorting. Now, it\'s time to extend your understanding and enhance bucket sort\'s efficiency by integrating dynamic strategies and advanced sorting techniques. **Task**: Implement an enhanced version of bucket sort. Your implementation should dynamically determine the number of buckets based on the input array length and use a more performant sorting algorithm for sorting elements within each bucket. **Function Signature**: ```python def enhanced_bucket_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr` (List[int]): List of non-negative integers to sort. The list can be empty. **Output**: - List[int]: Sorted list of integers. **Constraints**: - 0 <= len(arr) <= 10^5 - 0 <= arr[i] <= 10^6 **Requirements**: 1. Dynamically determine the number of buckets based on the input size. 2. Use a more efficient sorting algorithm for bucket sorting (like quicksort or mergesort) within each bucket. 3. Ensure that the input constraints are considered to avoid performance bottlenecks. 4. Handle edge cases such as empty list and non-uniformly distributed elements. **Example Test Cases**: ```python # Example 1 arr = [3, 1, 4, 1, 5, 9, 2, 6] print(enhanced_bucket_sort(arr)) # Output: [1, 1, 2, 3, 4, 5, 6, 9] # Example 2 arr = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] print(enhanced_bucket_sort(arr)) # Output: [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] # Example 3 arr = [] print(enhanced_bucket_sort(arr)) # Output: [] # Example 4 arr = [100] print(enhanced_bucket_sort(arr)) # Output: [100] ``` Provide a robust implementation that will accurately sort the array and manage performance effectively.","solution":"from typing import List import math def enhanced_bucket_sort(arr: List[int]) -> List[int]: if not arr: return [] # Determine the number of buckets we need num_buckets = math.ceil(math.sqrt(len(arr))) # Find maximum value in the array max_val = max(arr) # Create buckets and distribute the elements buckets = [[] for _ in range(num_buckets)] for num in arr: index = math.floor(num * num_buckets / (max_val + 1)) buckets[index].append(num) # Sort individual buckets using an efficient sorting algorithm for i in range(num_buckets): buckets[i].sort() # Using Python\'s Timsort (default sort) # Concatenate the sorted buckets sorted_array = [] for bucket in buckets: sorted_array.extend(bucket) return sorted_array"},{"question":"You are working on a string manipulation library, and one of the features you need to implement is rotating a string to the left by ( k ) positions. This operation rearranges the string such that the first ( k ) characters are moved to the end. You are required to write a function that performs this task efficiently. # Function Specification ```python def rotate(s: str, k: int) -> str: Rotate a given string `s` to the left by `k` positions. Parameters: s : str : The input string to be rotated. k : int : The number of positions to rotate the string to the left. Returns: str : The resulting string after rotation. ``` # Input * A string ( s ) containing only lowercase letters (1 (leq) # characters (leq 10^5)). * A non-negative integer ( k ) (0 (leq k leq 10^6)). # Output * The resulting string after being rotated ( k ) positions to the left. # Constraints * You should handle the special cases where ( k ) is zero or where ( k ) is greater than or equal to the length of the string. * The solution should be efficient in terms of both time and space complexity. # Examples 1. Input: ( s = \\"abcdef\\", k = 2 ) Output: ( \\"cdefab\\" ) 2. Input: ( s = \\"hello\\", k = 5 ) Output: ( \\"hello\\" ) 3. Input: ( s = \\"rotation\\", k = 9 ) Output: ( \\"otationr\\" ) # Additional Notes Your solution should focus on optimizing for cases where ( k ) is very large compared to the length of the string, ensuring minimal recomputation and avoiding unnecessary string duplications.","solution":"def rotate(s: str, k: int) -> str: Rotate a given string `s` to the left by `k` positions. Parameters: s : str : The input string to be rotated. k : int : The number of positions to rotate the string to the left. Returns: str : The resulting string after rotation. n = len(s) if n == 0: return s # Special case to handle empty string k = k % n # Normalizing k to be within the bounds of the string length return s[k:] + s[:k]"},{"question":"# Maximum Flow with Specific Constraints **Context:** You\'re managing a water distribution network represented as a directed graph. Each vertex represents a node (e.g., water plants, distribution points) and each edge represents a pipeline with a certain capacity. Your goal is to maximize the water flow from the main reservoir (source) to the city (sink). **Problem Statement:** Implement a function that calculates the maximum water flow from the source to the sink using the Ford-Fulkerson algorithm, where you need to address several constraints and handle potential edge cases effectively. **Function Signature:** ```python def max_water_flow(capacity: List[List[int]], source: int, sink: int) -> int: Parameters: capacity (List[List[int]]): A 2D list representing the capacity of each edge in the graph. capacity[i][j] represents the capacity of the edge from node i to node j. If there\'s no edge, capacity[i][j] is 0. source (int): The starting node (main reservoir). sink (int): The ending node (city). Returns: int: The maximum water flow from source to sink. ``` **Input Constraints:** - The number of nodes `n` in the graph is such that `2 <= n <= 200`. - Capacity values are non-negative integers and can be large (`0 <= capacity[i][j] <= 10^9`). - `0 <= source, sink < n` and `source != sink`. **Output:** - Return the maximum possible flow from the source node to the sink node. **Example:** ```python capacity = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] source = 0 sink = 5 print(max_water_flow(capacity, source, sink)) # Output: 23 ``` **Requirements:** 1. Handle large capacities without overflow issues. 2. Ensure that edges with zero capacity are treated correctly. 3. Handle disconnected components where no path exists from source to sink. 4. Optimize the algorithm to work within the given constraints efficiently.","solution":"from typing import List def bfs(C, F, source, sink, parent): A helper function that performs BFS to find an augmenting path in the residual graph. Returns True if a path is found from source to sink, otherwise False. visited = [False] * len(C) queue = [source] visited[source] = True while queue: u = queue.pop(0) for v in range(len(C)): if not visited[v] and (C[u][v] - F[u][v] > 0): # If residual capacity exists queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def max_water_flow(capacity: List[List[int]], source: int, sink: int) -> int: Calculates the maximum flow from source to sink in a flow network using the Ford-Fulkerson algorithm. n = len(capacity) # Create a residual capacity matrix and initialize flow matrix to zero C = capacity F = [[0] * n for _ in range(n)] parent = [-1] * n # Stores augmenting path max_flow = 0 # Augment the flow while there is a path from source to sink while bfs(C, F, source, sink, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') v = sink while v != source: u = parent[v] path_flow = min(path_flow, C[u][v] - F[u][v]) v = parent[v] # Update residual capacities of the edges and reverse edges along the path v = sink while v != source: u = parent[v] F[u][v] += path_flow F[v][u] -= path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Task Implement the Dinic’s algorithm for computing the maximum flow in a flow network. Given a directed graph represented by a capacity matrix, your function should find the total maximum flow from a given source to a given sink. # Description: Your implementation should include the following functions: 1. **Function**: `dinic_bfs(capacity, flow, level, source, sink)` - **Input**: * `capacity`: two-dimensional list representing the capacity matrix. * `flow`: two-dimensional list representing the current flow matrix. * `level`: list to keep track of the level of each node. * `source`: source node in the graph. * `sink`: sink node in the graph. - **Output**: returns `True` if the sink is reachable from the source; otherwise, `False`. 2. **Function**: `dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1<<63)` - **Input**: * `capacity`: two-dimensional list representing the capacity matrix. * `flow`: two-dimensional list representing the current flow matrix. * `level`: list to keep track of the level of each node. * `idx`: current node index. * `sink`: sink node in the graph. * `work`: list to keep track of the work done. * `current_flow`: current available flow. - **Output**: returns the flow sent from source to sink. 3. **Function**: `dinic(capacity, source, sink)` - **Input**: * `capacity`: two-dimensional list representing the capacity matrix. * `source`: source node in the graph. * `sink`: sink node in the graph. - **Output**: returns the total maximum flow from the source to the sink. # Constraints: - Number of vertices (V): (2 leq V leq 200) - The value of capacities: (0 leq capacity[i][j] leq 1000) # Example: ```python # Example usage capacity = [ [0, 20, 30, 10], [0, 0, 40, 10], [0, 0, 0, 20], [0, 0, 0, 0] ] source = 0 sink = 3 max_flow = dinic(capacity, source, sink) print(max_flow) # Output should be the maximum flow from source to sink ```","solution":"from collections import deque def dinic_bfs(capacity, flow, level, source, sink): Perform BFS to update level graph. Returns True if sink is reachable from source in the level graph; otherwise False. level[:] = [-1] * len(level) level[source] = 0 queue = deque([source]) while queue: u = queue.popleft() for v in range(len(capacity)): if level[v] < 0 and flow[u][v] < capacity[u][v]: level[v] = level[u] + 1 queue.append(v) return level[sink] != -1 def dinic_dfs(capacity, flow, level, idx, sink, work, current_flow=1<<63): Perform DFS to send flow in the residual graph. Returns the flow sent from source to sink. if idx == sink: return current_flow for i in range(work[idx], len(capacity)): work[idx] = i v = i if level[v] == level[idx] + 1 and flow[idx][v] < capacity[idx][v]: min_cap = min(current_flow, capacity[idx][v] - flow[idx][v]) dfs_flow = dinic_dfs(capacity, flow, level, v, sink, work, min_cap) if dfs_flow > 0: flow[idx][v] += dfs_flow flow[v][idx] -= dfs_flow return dfs_flow return 0 def dinic(capacity, source, sink): Compute maximum flow from source to sink using Dinic\'s algorithm. flow = [[0] * len(capacity) for _ in range(len(capacity))] level = [-1] * len(capacity) total_flow = 0 while dinic_bfs(capacity, flow, level, source, sink): work = [0] * len(capacity) while True: flow_sent = dinic_dfs(capacity, flow, level, source, sink, work) if flow_sent == 0: break total_flow += flow_sent return total_flow"},{"question":"You are given an array of integers where every element appears three times except for one, which appears exactly once. Implement a function `find_single_number()` that finds and returns the element that appears only once. Your algorithm should have a linear runtime complexity. You are not allowed to use extra memory for this task. # Input * `nums`: A list of integers `[n1, n2, n3, ..., nm]` where each integer appears exactly three times except for one. # Output * Return the integer that appears exactly once. # Constraints * The array will have at least 4 elements and at most (10^5) elements. * The integers are in the range `[-2^31, 2^31 - 1]`. * Your solution should have a time complexity of O(n) and space complexity of O(1). # Example ```python # Example 1 nums = [2, 2, 3, 2] assert find_single_number(nums) == 3 # Example 2 nums = [0, 1, 0, 1, 0, 1, 99] assert find_single_number(nums) == 99 ``` # Hints * Think about how you can use bitwise operations to solve the problem. * Consider how you can track counts of bits using bitwise operations to differentiate the single number from those appearing exactly three times.","solution":"def find_single_number(nums): # Initialize variables to hold the bits counts once, twice = 0, 0 for num in nums: # For `once` we add the number only if it\'s not already in `once` or `twice` once = ~twice & (once ^ num) # For `twice` we add the number only if it\'s not already in `once` or `twice` twice = ~once & (twice ^ num) return once"},{"question":"Problem Statement You are given a partially implemented B-Tree class, a balanced tree data structure that maintains sorted data and allows efficient insertion, deletion, and search operations. Your task is to extend this implementation by adding functionality to find the maximum and minimum key in the B-Tree and verify the integrity of the B-Tree structure. Requirements 1. **Find the minimum key**: - Implement the `find_min(self) -> int` method which returns the smallest key in the B-Tree. 2. **Find the maximum key**: - Implement the `find_max(self) -> int` method which returns the largest key in the B-Tree. 3. **Verify B-Tree integrity**: - Implement the `is_valid(self) -> bool` method that checks if the B-Tree satisfies all its properties (keys within nodes are sorted, children nodes are correctly linked, etc.). Input and Output Formats - `find_min`: No input; returns an integer. - `find_max`: No input; returns an integer. - `is_valid`: No input; returns a boolean. Constraints - You can assume the B-Tree already has several elements inserted when your methods are called. - You should consider the scenarios where the tree might be empty. Performance Requirements - Your solutions should operate in logarithmic time complexity for all methods in the average and worst case scenarios. Example Usage ```python btree = BTree(t_val=3) elements = [10, 20, 5, 6, 12, 30, 7, 17] for element in elements: btree.insert_key(element) print(btree.find_min()) # Output: 5 print(btree.find_max()) # Output: 30 print(btree.is_valid()) # Output: True ``` Implementation Using the provided B-Tree implementation, complete the required methods (`find_min`, `find_max`, and `is_valid`) to meet the above specifications.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, else False self.keys = [] # List of keys self.children = [] # List of children BTreeNode def find_min(self): current = self while not current.leaf: current = current.children[0] return current.keys[0] def find_max(self): current = self while not current.leaf: current = current.children[-1] return current.keys[-1] def is_valid(self): # This function should be recursively implemented to validate the B-Tree properties. if self.leaf: return True for i in range(1, len(self.keys)): if self.keys[i - 1] >= self.keys[i]: return False for i in range(len(self.children)): if not self.children[i].is_valid(): return False return True class BTree: def __init__(self, t): self.t = t # Minimum degree self.root = BTreeNode(t, True) def insert_key(self, k): root = self.root if len(root.keys) == (2 * self.t) - 1: temp = BTreeNode(self.t, False) temp.children.insert(0, root) self._split_child(temp, 0) self.root = temp self._insert_non_full(self.root, k) else: self._insert_non_full(root, k) def _insert_non_full(self, x, k): i = len(x.keys) - 1 if x.leaf: x.keys.append(0) while i >= 0 and k < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == (2 * self.t) - 1: self._split_child(x, i) if k > x.keys[i]: i += 1 self._insert_non_full(x.children[i], k) def _split_child(self, x, i): t = self.t y = x.children[i] z = BTreeNode(t, y.leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:(2 * t) - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:2 * t] y.children = y.children[0:t] def find_min(self): if not self.root or not self.root.keys: raise ValueError(\\"The tree is empty\\") return self.root.find_min() def find_max(self): if not self.root or not self.root.keys: raise ValueError(\\"The tree is empty\\") return self.root.find_max() def is_valid(self): if not self.root: return True return self.root.is_valid()"},{"question":"Given the understanding of byte-integer conversion and endianness, implement a function that takes an integer, converts it to its byte representation, and then converts it back to ensure correctness. This question requires consideration of both big-endian and little-endian formats. Function Signature ```python def validate_integer_conversion(num: int) -> bool: pass ``` Inputs and Outputs * **Input**: * An integer `num` (0 ≤ num ≤ (2^{64} - 1)). * **Output**: * A boolean value indicating whether the integer can be accurately converted to bytes and back to the original integer in both big-endian and little-endian formats. Constraints * The function should handle the complete cycle of conversion: * Integer -> Bytes (Big-endian) -> Integer * Integer -> Bytes (Little-endian) -> Integer * The function must return `True` if both conversions result in the original integer, `False` otherwise. Performance Requirements * Efficient handling of time and space complexity. * The function should work efficiently for integers close to the upper limit (2^{64} - 1). Example ```python assert validate_integer_conversion(123456789) == True assert validate_integer_conversion(0) == True assert validate_integer_conversion(2**64 - 1) == True ```","solution":"def validate_integer_conversion(num: int) -> bool: Validate that an integer can be converted to bytes and back to ensure correctness in both big-endian and little-endian formats. # Number of bytes needed to represent the integer byte_length = (num.bit_length() + 7) // 8 # Convert to bytes in big-endian format big_endian_bytes = num.to_bytes(byte_length, byteorder=\'big\') # Convert back to integer from big-endian bytes big_endian_int = int.from_bytes(big_endian_bytes, byteorder=\'big\') # Convert to bytes in little-endian format little_endian_bytes = num.to_bytes(byte_length, byteorder=\'little\') # Convert back to integer from little-endian bytes little_endian_int = int.from_bytes(little_endian_bytes, byteorder=\'little\') # Return True if both conversions return the original integer return (big_endian_int == num) and (little_endian_int == num)"},{"question":"Context Matrix exponentiation is a powerful technique used in various computational problems. One crucial application is solving linear recurrence relations, where a matrix representing the transition of states can be raised to a power to compute future states efficiently. Task Given a square matrix `mat` of dimension `n x n` and a positive integer `p`, write a function `matrix_power(mat: list, p: int) -> list` to compute the matrix raised to the power of `p` using the matrix exponentiation technique. Function Signature ```python def matrix_power(mat: list, p: int) -> list: pass ``` Input and Output * **Input**: * `mat`: A square matrix represented as a list of lists of integers. `mat[i][j]` indicates the element in the ith row and jth column. * `p`: A positive integer representing the power to which the matrix `mat` is to be raised. * **Output**: * Returns a matrix `result` of the same dimension as `mat`, such that `result` is the matrix `mat` raised to the power `p`. Constraints * The matrix dimensions will be in the range `1 <= n <= 100`. * The elements of the matrix will be integers in the range `-1000 <= mat[i][j] <= 1000`. * The exponent `p` will be a positive integer `1 <= p <= 10^9`. Performance Your function should efficiently handle large exponents up to `10^9` using the method of matrix exponentiation by repeated squaring. # Example ```python # Example 1 mat = [ [1, 2], [3, 4] ] p = 2 # Result: [ # [7, 10], # [15, 22] # ] # Example 2 mat = [ [2, 0], [0, 2] ] p = 3 # Result: [ # [8, 0], # [0, 8] # ] ```","solution":"def multiply_matrices(a, b): Multiply two square matrices a and b. n = len(a) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += a[i][k] * b[k][j] return result def matrix_power(mat, p): Compute the power of a matrix using matrix exponentiation by repeated squaring. n = len(mat) # Initialize result as identity matrix result = [[1 if i == j else 0 for j in range(n)] for i in range(n)] base = mat while p: if p % 2: result = multiply_matrices(result, base) base = multiply_matrices(base, base) p //= 2 return result"},{"question":"# Coding Challenge: 1-Sparse Non-Negative Dynamic Stream Detection Problem Statement You are provided with a stream of tuples representing numbers and their respective signs, processed in a sequential order. The stream is considered non-negative, where each tuple takes a format `(number, sign)` and `sign` can either be \'+\' (positive) or \'-\' (negative). Your task is to determine if the stream is 1-sparse; in other words, checks if canceling out the signed elements in the sequence results in exactly one unique non-zero number. Function Signature ```python def is_1_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: ``` Input - `stream`: A list of tuples, where each tuple contains an integer (0 <= number <= 2^31 - 1) and a character sign which is either \'+\', or \'-\'. Output - Returns the unique number if the input stream is 1-sparse. - Returns `None` if the stream is not 1-sparse. Example ```python # Example 1: stream = [(4,\'+\'), (2,\'+\'), (2,\'-\'), (4,\'+\'), (3,\'+\'), (3,\'-\')] print(is_1_sparse(stream)) # Output: 4 # Example 2: stream = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\')] print(is_1_sparse(stream)) # Output: 2 # Example 3: stream = [(2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (2,\'+\'), (1,\'+\')] print(is_1_sparse(stream)) # Output: None ``` Constraints 1. Ensure efficient handling such that the algorithm runs in linear time and constant space relative to the input size. 2. Handle edge cases properly, including streams that are completely balanced out and streams with no clear sparse indicators. Notes - The solution should be robust to handle a diverse set of streams, maintaining the integrity of input bounds and value conditions. - Disable sign manipulations within bit-summing if dealing with abstract ranges or large datasets for better performance.","solution":"from typing import List, Tuple, Optional def is_1_sparse(stream: List[Tuple[int, str]]) -> Optional[int]: counts = {} # Accumulate counts based on the signs for number, sign in stream: if sign == \'+\': counts[number] = counts.get(number, 0) + 1 elif sign == \'-\': counts[number] = counts.get(number, 0) - 1 non_zero_counts = {num: cnt for num, cnt in counts.items() if cnt != 0} if len(non_zero_counts) == 1: sole_number = next(iter(non_zero_counts.keys())) return sole_number else: return None"},{"question":"Scenario You are working on a data analysis application and need to filter out a list of numerical data based on given minimum or maximum thresholds. The goal is to implement a function to preprocess the data such that it includes only the numbers that fall within the specified range. Question Write a function `filtered_data` that takes a list of numerical values and filters it based on provided minimum and maximum limits. If either limit is not provided, assume there is no limit for that threshold. Function Signature ```python def filtered_data(arr: list, min_value: int = None, max_value: int = None) -> list: ``` Input * `arr` (list): A list of integers to be filtered. * `min_value` (int, optional): An integer representing the minimum threshold, inclusive. Defaults to None, meaning no lower limit. * `max_value` (int, optional): An integer representing the maximum threshold, inclusive. Defaults to None, meaning no upper limit. Output A list of integers that fall between `min_value` and `max_value` (inclusive). Constraints * The list can contain any number of elements, including zero. * If both `min_value` and `max_value` are None, the function should return the original list. Examples ```python assert filtered_data([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert filtered_data([10, 15, 20, 25, 30], 15, None) == [15, 20, 25, 30] assert filtered_data([100, 200, 300, 400, 500], 150, 450) == [200, 300, 400] assert filtered_data([], 10, 20) == [] assert filtered_data([1, 2, 3, 4, 5], 2, 4) == [2, 3, 4] ``` You are expected to consider edge cases, such as an empty input array, and ensure that the function performs efficiently with time complexity O(n).","solution":"def filtered_data(arr, min_value=None, max_value=None): Filters a list of integers based on minimum and maximum value thresholds. Parameters: arr (list): A list of integers to be filtered. min_value (int, optional): Minimum value threshold, inclusive. Defaults to None. max_value (int, optional): Maximum value threshold, inclusive. Defaults to None. Returns: list: A list of integers that fall within the specified range. if min_value is None and max_value is None: return arr filtered = [] for num in arr: if min_value is not None and num < min_value: continue if max_value is not None and num > max_value: continue filtered.append(num) return filtered"},{"question":"# Path-Finding in a Graph A common task in graph algorithms is to find paths between nodes. Given a directed graph represented as an adjacency list, your goal is to implement a function to find the shortest path between two nodes. However, instead of using the provided recursive method, you are required to implement an iterative approach using a stack to manage the traversal explicitly. Implementation Details: **Function Signature**: ```python def find_shortest_path_iterative(graph, start, end) -> list: ``` **Input**: * `graph`: A dictionary representing the adjacency list of a directed graph. Each key is a node, and its value is a list of nodes it connects to. ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } ``` * `start`: The starting node for the path search. * `end`: The target node for the path search. **Output**: * A list representing the shortest path from `start` to `end`. If no path exists, return `None`. **Constraints**: * All node values are unique. * It is guaranteed that `start` and `end` nodes exist in the graph. **Performance Requirements**: * Aim for a solution with a time complexity of O(V + E) and a space complexity of O(V). **Example**: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } assert find_shortest_path_iterative(graph, \'A\', \'E\') == [\'A\', \'C\', \'D\', \'E\'] assert find_shortest_path_iterative(graph, \'A\', \'A\') == [\'A\'] assert find_shortest_path_iterative(graph, \'A\', \'F\') == None # Assuming \'F\' is not in the graph ```","solution":"def find_shortest_path_iterative(graph, start, end): Find the shortest path in a directed graph using an iterative approach with a stack. # Use a stack to manage traversal. The stack will store tuples of (current_node, path_to_node) stack = [(start, [start])] # Use a set to keep track of visited nodes to avoid cycles visited = set() while stack: current_node, path = stack.pop() if current_node == end: return path if current_node not in visited: visited.add(current_node) for neighbor in graph.get(current_node, []): new_path = path + [neighbor] stack.append((neighbor, new_path)) # If here, no path was found return None"},{"question":"# Priority Queue Using Binary Heap **Objective**: Implement a Priority Queue using a binary heap to improve efficiency for insertion and extraction operations. # Problem Statement You are tasked with creating a more efficient Priority Queue that uses a binary heap. This will reduce the time complexity of insertions and extractions compared to the linear array implementation. # Function Specifications 1. **Insert Operation**: - Function signature: `def insert(self, item, priority):` - Inserts an item with a given priority into the priority queue. - Maintains the heap property after insertion. 2. **Extract Min Operation**: - Function signature: `def extract_min(self):` - Removes and returns the item with the lowest priority. - Maintains the heap property after extraction. # Input and Output Formats **Insert Operation**: - Input: `item` (a value to insert), `priority` (an integer priority associated with the item) - Output: None **Extract Min Operation**: - Input: None - Output: `item` (the item with the lowest priority) # Constraints - Implement a binary min-heap to represent the priority queue. - Handle edge cases such as extracting from an empty queue gracefully (e.g., return None). # Example ```python pq = PriorityQueue() pq.insert(\'task1\', 2) pq.insert(\'task2\', 1) pq.insert(\'task3\', 5) print(pq.extract_min()) # Should return \'task2\' print(pq.extract_min()) # Should return \'task1\' print(pq.extract_min()) # Should return \'task3\' print(pq.extract_min()) # Should return None ``` # Notes - Make sure to demonstrate an understanding of the heap operations such as up-heap (bubble-up) and down-heap (bubble-down) for maintaining the heap structure.","solution":"class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item, priority): Inserts an item with a given priority into the priority queue. self.heap.append((priority, item)) self._bubble_up(len(self.heap) - 1) def extract_min(self): Removes and returns the item with the lowest priority. if not self.heap: return None if len(self.heap) == 1: return self.heap.pop()[1] min_item = self.heap[0][1] self.heap[0] = self.heap.pop() # Move the last item to the root and pop the min item self._bubble_down(0) return min_item def _bubble_up(self, index): parent_index = (index - 1) // 2 if index > 0 and self.heap[index][0] < self.heap[parent_index][0]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index][0] < self.heap[smallest][0]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index][0] < self.heap[smallest][0]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._bubble_down(smallest)"},{"question":"# Fibonacci Sequence Computation Context: In mathematics, the Fibonacci numbers form a sequence defined by the relation: - F0 = 0, F1 = 1 - Fn = F(n-1) + F(n-2) for n > 1 Given a number `n`, your task is to compute the n-th Fibonacci number. Implement the most efficient algorithm from the given snippets and analyze its performance. Function Signature: ```python def compute_fibonacci(n: int) -> int: pass ``` Input: - A single integer `n` (0 ≤ n ≤ 10^7), representing the position in the Fibonacci sequence. Output: - Return the n-th Fibonacci number. Constraints: - Your implementation should efficiently handle very large `n` up to 10^7. - You are expected to use minimal auxiliary space. Requirements: - Performance: The solution should run in O(log n) time complexity. Example: ```shell Input: 10 Output: 55 Input: 20 Output: 6765 ``` Hint: - You may need to implement a solution using matrix exponentiation to achieve the required performance. Additional Notes: - Ensure your solution handles all edge cases properly, including `n = 0`. - Consider the optimization of both time and space complexity when designing your solution.","solution":"def compute_fibonacci(n: int) -> int: Compute the n-th Fibonacci number using matrix exponentiation. The result is computed in O(log n) time complexity. def multiply_matrices(a, b): return [ [ a[0][0] * b[0][0] + a[0][1] * b[1][0], a[0][0] * b[0][1] + a[0][1] * b[1][1] ], [ a[1][0] * b[0][0] + a[1][1] * b[1][0], a[1][0] * b[0][1] + a[1][1] * b[1][1] ] ] def matrix_power(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix while power > 0: if power % 2 == 1: result = multiply_matrices(result, matrix) matrix = multiply_matrices(matrix, matrix) power //= 2 return result if n == 0: return 0 elif n == 1: return 1 # Base matrix for Fibonacci F = [[1, 1], [1, 0]] # Get F^(n-1) result_matrix = matrix_power(F, n - 1) # The answer is in result_matrix[0][0] return result_matrix[0][0]"},{"question":"# Question: You are tasked with implementing a function that sorts a list of integers using an optimized version of the Bubble Sort algorithm. Your implementation should come with a special feature where if the list is large, you switch to a more efficient sorting algorithm to improve performance. Requirements: 1. **Function Signature**: ```python def enhanced_bubble_sort(arr: List[int], use_quick_sort_above: int = 20) -> List[int]: ``` 2. **Parameters**: - `arr` (List[int]): A list of integers to sort. - `use_quick_sort_above` (int): The threshold size above which a different sorting algorithm, specifically Quick Sort, should be used. The default value is 20, meaning that if the list has more than 20 elements, resort to Quick Sort. 3. **Output**: - Return the sorted list of integers. 4. **Constraints**: - The algorithm should switch to Quick Sort for efficiency if the list size exceeds the given threshold. - The implementation of both Bubble Sort and Quick Sort should be provided within the function. - List elements are within the range `[-10^6, 10^6]`. - The length of the list is in the range `[0, 10^4]`. Example: ```python input_list = [64, 25, 12, 22, 11] sorted_list = enhanced_bubble_sort(input_list) print(sorted_list) # Output: [11, 12, 22, 25, 64] ``` Hints: - Ensure correctness and efficiency by switching to Quick Sort for larger lists, leveraging its average-case O(N log N) time complexity. - Handle edge cases such as empty lists or single-element lists efficiently.","solution":"from typing import List def bubble_sort(arr: List[int]) -> List[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if not swapped: break return arr def quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr pivot = arr[len(arr)//2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right) def enhanced_bubble_sort(arr: List[int], use_quick_sort_above: int = 20) -> List[int]: if len(arr) > use_quick_sort_above: return quick_sort(arr) else: return bubble_sort(arr)"},{"question":"# Question: Reverse Specific Sections of Words in a String Scenario: You are working on a text processing module where you need to adjust the order of words in specific sections of a string. Given a string and a list of tuples where each tuple contains two indices, your task is to reverse the words between those indices inclusively for each pair. Each index specifies the position of a word in the list of words. Ensure to handle edge cases like empty strings and maintain efficient performance with bounded time and space complexities. Function Signature: ```python def reverse_sections(string: str, indices: List[Tuple[int, int]]) -> str: ``` Input: - **string (str)**: A string containing words separated by spaces. - **indices (List[Tuple[int, int]])**: A list of tuples, each containing two integers i and j where 0 <= i <= j < number of words. Output: - **str**: A new string with the specified sections of words reversed. Constraints: - 0 <= len(string) <= 10^6 - The string consists of printable ASCII characters. - There will be no leading or trailing spaces, and words are separated by a single space. Performance requirements: - Ensure the solution runs in linear time relative to the length of the string O(n). Example: ```python # Example Input string = \\"one two three four five six\\" indices = [(0, 2), (3, 5)] # Example Output \\"three two one six five four\\" ``` Steps to solve: 1. Split the string into a list of words. 2. Use a helper function to reverse the segments specified by the indices. 3. Join the words back into a single string.","solution":"from typing import List, Tuple def reverse_sections(string: str, indices: List[Tuple[int, int]]) -> str: Reverses specified sections of words in the input string based on the given indices. Args: string (str): The input string containing words separated by spaces. indices (List[Tuple[int, int]]): A list of tuples with each tuple containing two integers indicating the start and end indices of the words to be reversed. Returns: str: The string with specified sections of words reversed. words = string.split() for start, end in indices: while start < end: words[start], words[end] = words[end], words[start] start += 1 end -= 1 return \' \'.join(words)"},{"question":"# Context: You\'ve been tasked with developing software to quickly identify unique items in a large dataset. During this development, you recognize the need for an algorithm that identifies an element that appears exactly once, while all other elements appear an even number of times. To this end, you decide to leverage a bitwise XOR operation due to its efficiency in both execution time and memory usage. # Problem statement: Implement a function `find_unique_element` that takes a list of integers (where each integer appears exactly twice, except for one that appears once) and returns the integer that appears only once. Your solution must have a linear runtime complexity and use constant extra memory. # Function Signature: ```python def find_unique_element(nums: List[int]) -> int: # Your implementation here ``` # Input: * `nums` (List[int]): A list of integers where every integer appears exactly twice, except for one that appears once. * Example: `[2,2,3,4,3,4,5]` # Output: * Return the integer that appears once. * Example: 5 # Constraints: * The length of the list will be between 1 and 10^5. * All integers in the list are between -10^3 and 10^3. # Example: ```python print(find_unique_element([4,1,2,1,2])) # Output: 4 print(find_unique_element([2,2,3,4,3,4,5])) # Output: 5 ``` # Notes: * Ensure your solution uses the XOR operation to maintain linear time complexity and constant space complexity. * Handle edge cases like an empty list or a single element list gracefully.","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the element that appears exactly once in the list while all other elements appear an even number of times. Args: nums (List[int]): List of integers where each integer appears exactly twice, except for one that appears once. Returns: int: The integer that appears only once. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Find the nth Digit in an Infinite Sequence **Problem Statement:** You are given a number ( n ) which represents the position in an infinite sequence of consecutive numbers starting from 1: \\"123456789101112131415...\\". Your task is to write a function `find_nth_digit(n)` that returns the nth digit in this sequence. **Function Signature:** ```python def find_nth_digit(n: int) -> int: Finds the nth digit in an infinite sequence of consecutive numbers starting from 1. Parameters: n (int): An integer representing the position in the sequence. Returns: int: The nth digit in the sequence. ``` **Constraints:** 1. ( 1 leq n leq 2*10^9 ) # Input/Output Formats: - **Input:** A single integer ( n ) that specifies the position in the infinite string of concatenated numbers. - **Output:** A single digit that represents the nth position in the sequence. # Example: 1. Input: `n = 3` Output: `3` 2. Input: `n = 11` Output: `0` - Explanation: The 11th digit is \'0\' in the sequence \\"123456789101112...\\" # Performance Requirements: - Your solution must handle up to ( n = 2*10^9 ) efficiently both in terms of processing time and memory usage. **Scenario**: Consider that you are working on a large dataset of numbered positions and need to extract specific digits for each position without generating the entire sequence. This function would help you translate position directly to the desired digit, allowing operations on extremely large datasets effectively.","solution":"def find_nth_digit(n: int) -> int: Finds the nth digit in an infinite sequence of consecutive numbers starting from 1. Parameters: n (int): An integer representing the position in the sequence. Returns: int: The nth digit in the sequence. length = 1 count = 9 start = 1 # 1. Determine the size of the number that contains the nth digit while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # 2. Determine the exact number start += (n - 1) // length # 3. Find the exact digit in the number digit = str(start)[(n - 1) % length] return int(digit)"},{"question":"You are tasked with developing a function that determines the number of digits in the decimal (base-10) representation of an integer, which could be either positive or negative. **Function Signature**: ```python def num_digits(n: int) -> int: ``` # Input - `n` (int): An integer, which could be negative, positive, or zero. # Output - (int): The number of digits in `n`. # Constraints - -10^18 ≤ n ≤ 10^18 # Requirements - Your function must handle: - Negative numbers. - Zero correctly. - It should run as efficiently as possible, ideally in constant time O(1). # Examples 1. `num_digits(12345)` should return `5` 2. `num_digits(-12345)` should return `5` 3. `num_digits(0)` should return `1` 4. `num_digits(10000000000)` should return `11` 5. `num_digits(-1)` should return `1` # Notes - Do not use `str()` conversion for solving this problem. - Consider proper handling of edge cases, such as zero and negative numbers. - The primary method to reach these results should be exploiting mathematical logarithmic properties.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the decimal (base-10) representation of an integer. This function handles both positive and negative integers, as well as zero. if n == 0: return 1 return math.floor(math.log10(abs(n))) + 1"},{"question":"# Topological Sort Implementation Topological sorting of a directed acyclic graph (DAG) is essential for various applications like task scheduling, dependency resolution, etc. Given the importance of this algorithm, your task is to implement a function that performs topological sorting on a given directed graph using both recursive and iterative approaches. # Problem Statement Write a function `topological_sort(graph)` that accepts a directed graph as an adjacency list and returns a topological order of nodes. Your solution must handle the following: * The function should detect cycles and raise a `ValueError` with the message `\\"cycle\\"` if the graph is not a DAG. * It should use both a recursive approach and an iterative approach to implement topological sorting as prescribed. Function Signature: ```python def topological_sort(graph: dict) -> List[int]: pass ``` Input: * `graph` (dict): Adjacency list representing the directed graph where keys are nodes and values are lists of connected nodes. Output: * List[int]: A list of nodes in topological order. Constraints: * The graph will have at most 10^5 vertices and 10^5 edges. * Graph nodes are represented as integers. Example: ```python graph = { 0: [1, 2], 1: [3], 2: [3], 3: [] } topological_sort(graph) # Output: [0, 2, 1, 3] or [0, 1, 2, 3] ``` # Requirements: 1. Implement two helper functions `top_sort_recursive(graph: dict) -> List[int]` and `top_sort_iterative(graph: dict) -> List[int]`. 2. Within each helper function, handle the detection of cycles and order creation as per their respective methods outlined in the provided snippets. 3. Use the primary function `topological_sort(graph: dict) -> List[int]` to call these helpers and return their results. # Notes: - Your code should efficiently handle the provided constraints. - Ensure proper handling and raising of exceptions for cycle detection.","solution":"from typing import List, Dict def top_sort_recursive(graph: Dict[int, List[int]]) -> List[int]: visited = set() temp = set() result = [] def visit(node): if node in temp: raise ValueError(\\"cycle\\") if node not in visited: temp.add(node) for neighbor in graph.get(node, []): visit(neighbor) temp.remove(node) visited.add(node) result.append(node) for node in graph: if node not in visited: visit(node) return result[::-1] def top_sort_iterative(graph: Dict[int, List[int]]) -> List[int]: visited = set() temp = set() result = [] stack = [] def visit(node): stack.append((node, iter(graph.get(node, [])))) while stack: cur, it = stack[-1] if cur in temp: raise ValueError(\\"cycle\\") if cur not in visited: temp.add(cur) for neighbor in it: if neighbor not in visited: stack.append((neighbor, iter(graph.get(neighbor, [])))) break else: temp.remove(cur) visited.add(cur) result.append(cur) stack.pop() else: stack.pop() for node in graph: if node not in visited: visit(node) return result[::-1] def topological_sort(graph: Dict[int, List[int]]) -> List[int]: try: return top_sort_recursive(graph) except ValueError as e: pass try: return top_sort_iterative(graph) except ValueError as e: raise e"},{"question":"Your task is to write a function to reverse a string using an iterative approach without using Python\'s built-in functions like `reversed` or slicing. Your implementation should be efficient in both time and space. # Input * A non-empty string of length n (1 <= n <= 10^5). # Output * A new string which is the reverse of the input string. # Constraints * Do not use Python\'s built-in reversed() function or slicing. * Optimize for time and space - aim for O(n) time and O(n) space complexity. # Example ```python Input: \\"hello\\" Output: \\"olleh\\" Input: \\"world\\" Output: \\"dlrow\\" ``` # Function Signature ```python def reverse_string(s: str) -> str: # Your implementation here ``` # Performance Requirements Your function should handle the upper constraint efficiently, aiming for O(n) time and O(n) space complexity. Consider edge cases such as an input with a single character, or already reversed strings.","solution":"def reverse_string(s: str) -> str: Returns the reverse of the input string using an iterative approach. # Create an empty list to store the characters of the reversed string. reversed_chars = [] # Iterate over the string in reverse order and append each character to the reversed_chars list. for char in s: reversed_chars.insert(0, char) # Join the reversed characters to form the final reversed string. return \'\'.join(reversed_chars)"},{"question":"# Question: Binary Tree Serialization and Deserialization You are given a binary tree and need to design algorithms to serialize it to a string and deserialize it back to the binary tree. The serialization and deserialization should follow the preorder traversal method, where null nodes are represented by the character \\"#\\". Detailed Task: 1. **Serialization Function:** - **Function**: `def serialize(root: TreeNode) -> str` - **Input**: Takes the root node of the binary tree. - **Output**: Returns a string that represents the serialized form of the tree. 2. **Deserialization Function:** - **Function**: `def deserialize(data: str) -> TreeNode` - **Input**: Takes a string that is the serialized form of a binary tree. - **Output**: Returns the root node of the reconstructed binary tree. Constraints: - The value of TreeNode will be an integer, and can be both positive and negative. - Tree nodes can have `None` (null) children. - Serialized string must accurately reconstruct to the same tree. Performance Requirements: - Time Complexity: O(n) - Space Complexity: O(n) Scenario: You are building a system where you need to store and retrieve family tree information. Each node in the tree represents a family member. You need to ensure this family tree can be both serialized to a string for storage and deserialized back to its original structure. ```python class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): # Write your code here pass def deserialize(data): # Write your code here pass # Example root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.left = TreeNode(4) root.right.right = TreeNode(5) serialized = serialize(root) print(serialized) # Example Output: \\"1 2 # # 3 4 # # 5 # #\\" deserialized_root = deserialize(serialized) # The deserialized_root should represent the same tree structure as the original root. ``` Ensure your implementation passes the provided examples and works efficiently for large trees.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def serialize(root): def helper(node): if not node: return \\"#\\" left_serialized = helper(node.left) right_serialized = helper(node.right) return f\\"{node.val} {left_serialized} {right_serialized}\\" return helper(root) def deserialize(data): def helper(nodes): val = next(nodes) if val == \\"#\\": return None node = TreeNode(int(val)) node.left = helper(nodes) node.right = helper(nodes) return node nodes = iter(data.split()) return helper(nodes)"},{"question":"# Scenario: Markov Chain Text Generator Given a Markov chain representing letter transitions in a text, your task is to implement a function to generate a string of characters based on the provided Markov chain. Initially, you will be given a starting character, and subsequent characters will be generated using the Markov chain. The generated string should contain a specific length of characters. # Requirements * **Function**: `generate_text` * **Input**: - `chain` (dict): Markov chain dictionary where keys are states (characters) and values are dictionaries of transition probabilities for next states. - `start` (str): Single character representing the initial state. - `length` (int): Length of the desired generated string. * **Output**: A string of characters of the specified length. * **Constraints**: - The transition probabilities in the chain for any state will always sum to 1. - All characters in `start` and the Markov chain states will be single lowercase alphabets (a-z). # Performance Requirement * Your implementation should be efficient in both time and space, capable of handling up to 10,000 characters in the output string. # Example ```python chain = { \'a\': {\'a\': 0.2, \'b\': 0.8}, \'b\': {\'a\': 0.5, \'b\': 0.5} } start = \'a\' length = 10 generate_text(chain, start, length) ``` Possible output: `\\"abababaaaa\\"` (Note: This is a probabilistic result, actual output may vary) # Function Signature ```python def generate_text(chain: dict, start: str, length: int) -> str: # Implement the function here ```","solution":"import random def generate_text(chain, start, length): Generates a string of characters based on the provided Markov chain. Parameters: - chain (dict): Markov chain dictionary. - start (str): Initial state. - length (int): Desired length of the output string. Returns: - str: Generated string of the specified length. result = [start] current_state = start for _ in range(length - 1): next_state = random.choices( list(chain[current_state].keys()), weights=chain[current_state].values(), k=1 )[0] result.append(next_state) current_state = next_state return \'\'.join(result)"},{"question":"You are provided with two essential graph traversal algorithms: Depth-First Search (DFS) and Breadth-First Search (BFS). From these algorithms, you\'ll develop a customized graph traversal that satisfies a specific condition. # Task Implement a function `custom_traverse(graph, start, priority)` that traverses a graph. This function should use DFS if the priority is \'DFS\' and BFS if the priority is \'BFS\'. Additionally, the traversal should keep track of the order in which nodes are visited and return this as a list. Function Signature ```python def custom_traverse(graph: dict, start: Any, priority: str) -> List[Any]: # your code here ``` Input - `graph`: A dictionary representing the graph where `graph[node]` is a list of adjacent nodes. - `start`: The starting node for the traversal. - `priority`: A string, either \'DFS\' or \'BFS\', determining the traversal method. Output - A list of nodes in the order they were visited during the traversal. Constraints - The graph is represented as an adjacency list using a dictionary. - The graph can contain cycles. - The graph is undirected. - The graph may be disconnected. Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } print(custom_traverse(graph, \'A\', \'DFS\')) # Output might be: [\'A\', \'C\', \'F\', \'E\', \'B\', \'D\'] print(custom_traverse(graph, \'A\', \'BFS\')) # Output might be: [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] ``` **Note**: The exact order of nodes in the list can vary depending on the implementation specifics, especially in DFS. # Constraints - `1 <= |nodes| <= 10^5` - `1 <= |edges| <= 2 * 10^5`","solution":"from collections import deque def custom_traverse(graph, start, priority): Traverses the graph using either DFS or BFS based on the priority and returns the order of visited nodes. def dfs(start): visited = set() order = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.add(node) order.append(node) for neighbor in reversed(graph[node]): if neighbor not in visited: stack.append(neighbor) return order def bfs(start): visited = set() order = [] queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) order.append(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return order if priority == \'DFS\': return dfs(start) elif priority == \'BFS\': return bfs(start) else: raise ValueError(\\"Priority must be \'DFS\' or \'BFS\'\\")"},{"question":"# AVL Tree Insertion and Balance Verification Objective You are required to implement a specific function in an AVL Tree that ensures the tree remains balanced after each insertion operation. Specifically, you will write a method that inserts a value into the AVL Tree and checks if the tree remains balanced. Function Signature ```python def avl_insert_and_verify(tree: AvlTree, key: int) -> bool: Inserts `key` into the AVL Tree and verifies the balance. Parameters: tree (AvlTree): The AVL Tree instance where the key is to be inserted. key (int): The key to be inserted into the tree. Returns: bool: True if the tree remains balanced after the insertion, False otherwise. ``` Input - `tree`: An instance of `AvlTree`. - `key`: An integer key to be inserted. Output - A boolean indicating whether the AVL tree remains balanced after the insertion. Constraints - The key to be inserted is an integer. - The AVL Tree instance provided is initially balanced. - No duplicate keys will be inserted. Performance Requirements - The solution must ensure that the AVL Tree remains balanced with a time complexity of O(log n) for the insertion and balance verification. Example ```python # Example usage of avl_insert_and_verify function: avl_tree = AvlTree() print(avl_insert_and_verify(avl_tree, 10)) # Output: True (First insertion, tree remains balanced) print(avl_insert_and_verify(avl_tree, 20)) # Output: True (Second insertion, tree remains balanced) print(avl_insert_and_verify(avl_tree, 5)) # Output: True (Third insertion, tree remains balanced) # Adding more elements and checking if the tree stays balanced print(avl_insert_and_verify(avl_tree, 30)) # Output: True (Tree remains balanced) print(avl_insert_and_verify(avl_tree, 25)) # Output: True (Re-balancing has occurred if necessary) ``` Notes - To implement the method, make use of the existing `insert` method in the `AvlTree` class. - Verify the balance by checking the balance factors of all nodes post insertion. - Utilize the `in_order_traverse` method to access the nodes in a sorted manner if needed for verification.","solution":"class AvlNode: def __init__(self, key, left=None, right=None, height=1): self.key = key self.left = left self.right = right self.height = height class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AvlNode(key) if key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node # duplicates are not allowed node.height = 1 + max(self._height(node.left), self._height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._height(node.left) - self._height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._height(z.left), self._height(z.right)) y.height = 1 + max(self._height(y.left), self._height(y.right)) return y def avl_insert_and_verify(tree: AvlTree, key: int) -> bool: tree.insert(key) return is_balanced_avl_tree(tree.root) def is_balanced_avl_tree(node) -> bool: if not node: return True balance = get_balance_factor(node) if abs(balance) > 1: return False return is_balanced_avl_tree(node.left) and is_balanced_avl_tree(node.right) def get_balance_factor(node): if not node: return 0 return height(node.left) - height(node.right) def height(node): if not node: return 0 return 1 + max(height(node.left), height(node.right))"},{"question":"Scenario: You are a software engineer responsible for managing a real-time data processing system that receives streams of non-negative integers with instructed signs (either \'+\' or \'-\'). Your task is to develop a function capable of determining whether the processed stream is 1-sparse. A 1-sparse stream means that after considering the cancellations resulting from the assigned signs, only one unique number should remain with a positive net sign. Objective: Write a function `one_sparse(stream)` that processes the input stream and returns the unique remaining number if the stream is 1-sparse. If not, return `None`. Function Signature: ```python def one_sparse(stream: List[Tuple[int, str]]) -> Union[int, None]: pass ``` Input Format: * `stream` - A list of tuples, where each tuple contains: * An integer `number` (0 <= `number` <= 10^9). * A character `sign` either \'+\' or \'-\'. Output Format: * An integer representing the remaining unique number if the stream is 1-sparse, otherwise `None`. Constraints: * The stream may be of any length, including empty. * The integers in the tuples are non-negative. Performance Requirements: * The function should run in O(n) time, where n is the size of the input stream. * It should use constant space outside the input and typical integer storage. Example: ```python # Example 1 input_stream = [(4, \'+\'), (2, \'+\'), (2, \'-\'), (4, \'+\'), (3, \'+\'), (3, \'-\')] output = one_sparse(input_stream) print(output) # Output: 4 (Since 2 and 3 get removed.) # Example 2 input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\')] output = one_sparse(input_stream) print(output) # Output: 2 (No other numbers present.) # Example 3 input_stream = [(2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (2, \'+\'), (1, \'+\')] output = one_sparse(input_stream) print(output) # Output: None (Not 1-sparse.) ``` Use the provided examples to validate your solution. Ensure to handle edge cases and optimize where possible.","solution":"def one_sparse(stream): Determines if the stream is 1-sparse and returns the unique remaining number if it is. If not 1-sparse, returns None. count_map = {} for number, sign in stream: if sign == \'+\': count_map[number] = count_map.get(number, 0) + 1 elif sign == \'-\': count_map[number] = count_map.get(number, 0) - 1 unique_number = None for num, count in count_map.items(): if count > 0: if unique_number is not None: return None unique_number = num return unique_number"},{"question":"# Task You are given a directed graph class with methods to add edges and check if a path exists between two nodes using Depth First Search (DFS). The current implementation has a few errors and inefficiencies. Your task is to correct and optimize the implementation to ensure it works correctly for all edge cases. # Requirements Function Signature ```python class Graph: def __init__(self, vertex_count: int): pass def add_edge(self, source: int, target: int): pass def is_reachable(self, source: int, target: int) -> bool: pass ``` Input and Output * `__init__(self, vertex_count: int)`: Initialize the graph with the number of vertices. * `vertex_count`: An integer representing the number of vertices in the graph. * `add_edge(self, source: int, target: int)`: Add a directed edge from `source` to `target`. * `source`: An integer representing the starting vertex of the edge. * `target`: An integer representing the ending vertex of the edge. * `is_reachable(self, source: int, target: int) -> bool`: Return `True` if there is a path from `source` to `target`, otherwise return `False`. * `source`: An integer representing the source vertex. * `target`: An integer representing the target vertex. * Expected output: A boolean value indicating whether a path exists from the source to the target vertex. Constraints * The graph will have at most `10^4` vertices. * There will be at most `10^5` edges. * Assume that `source` and `target` vertices provided in the queries will always be valid indices in the range `[0, vertex_count - 1]`. Scenario Consider you are working on a navigation system that needs to find possible routes between two locations. This graph-based approach will help determine if there exists a valid path from one location to another. Performance Requirements Ensure that your solution efficiently handles large graphs within the given constraints. # Examples 1. Initializing a graph with 6 vertices, and adding edges. Checking if there is a path between nodes. ```python g = Graph(6) g.add_edge(0, 1) g.add_edge(0, 2) g.add_edge(1, 3) g.add_edge(3, 4) g.add_edge(4, 5) print(g.is_reachable(0, 5)) # Output: True print(g.is_reachable(0, 4)) # Output: True print(g.is_reachable(2, 3)) # Output: False ```","solution":"class Graph: def __init__(self, vertex_count: int): self.vertex_count = vertex_count self.adj_list = [[] for _ in range(vertex_count)] def add_edge(self, source: int, target: int): self.adj_list[source].append(target) def is_reachable(self, source: int, target: int) -> bool: visited = [False] * self.vertex_count return self._dfs(source, target, visited) def _dfs(self, current: int, target: int, visited: list) -> bool: if current == target: return True visited[current] = True for neighbor in self.adj_list[current]: if not visited[neighbor]: if self._dfs(neighbor, target, visited): return True return False"},{"question":"# Question: Efficient Calculation of LCM and Bitwise GCD Context You are tasked with improving the performance of a computationally intensive system that relies heavily on calculating the greatest common divisor (GCD) and least common multiple (LCM) of pairs of integers. For this purpose, you must implement both a more efficient GCD calculation using bitwise operations and ensure the LCM calculation leverages this optimized GCD. Task 1. Implement a function `gcd_bit_optimized(a: int, b: int) -> int` using bitwise operations. 2. Implement a function `lcm_optimized(a: int, b: int) -> int` which calculates the least common multiple using the `gcd_bit_optimized` function. Input - Two non-negative integers `a` and `b`. Output - Your `gcd_bit_optimized` function should return an integer representing the greatest common divisor of `a` and `b`. - Your `lcm_optimized` function should return an integer representing the least common multiple of `a` and `b`. Constraints - `0 <= a, b <= 10^9` - Your solution should handle the edge cases where either `a` or `b` is zero. Example ```python # Example usage of gcd_bit_optimized assert gcd_bit_optimized(48, 18) == 6 assert gcd_bit_optimized(17, 0) == 17 assert gcd_bit_optimized(0, 31) == 31 # Example usage of lcm_optimized assert lcm_optimized(15, 20) == 60 assert lcm_optimized(7, 5) == 35 ``` Notes - Ensure your functions handle all edge cases gracefully (e.g., when one of the numbers is zero). - Consider performance implications and aim to write efficient and clean code.","solution":"def gcd_bit_optimized(a, b): Returns the greatest common divisor (GCD) of two integers a and b using bitwise operations. if a == 0: return b if b == 0: return a # Finding the common power of 2 in both numbers shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a # Restore the common power of 2 return a << shift def lcm_optimized(a, b): Returns the least common multiple (LCM) of two integers a and b using the optimized GCD function. if a == 0 or b == 0: return 0 return a // gcd_bit_optimized(a, b) * b"},{"question":"**Problem Statement**: A company is developing a system for storing the state of dynamic data structures, particularly binary trees. You have been tasked with extending the current functionality by implementing an additional feature that compares two binary trees to check if they are identical or not. **Function Requirements**: Implement a function `is_identical(root1, root2)` to determine if two given binary trees are identical. Two binary trees are considered identical if they have the same structure and the same node values. - **Input**: - `root1`: The root node of the first binary tree (`TreeNode` object). - `root2`: The root node of the second binary tree (`TreeNode` object). - **Output**: - Return `True` if the two binary trees are identical; otherwise, return `False`. **Constraints**: - The number of nodes in both trees will not exceed (10^4). - Tree node values are integers and can be negative. **Sample Usage**: ```python # Example 1: # Tree 1: 1 Tree 2: 1 # / / # 2 3 2 3 # / / # 4 5 4 5 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.left.left = TreeNode(4) root1.left.right = TreeNode(5) root2 = TreeNode(1) root2.left = TreeNode(2) root2.right = TreeNode(3) root2.left.left = TreeNode(4) root2.left.right = TreeNode(5) assert is_identical(root1, root2) == True # Example 2: # Tree 1: 1 Tree 2: 1 # / # 2 2 root1 = TreeNode(1) root1.left = TreeNode(2) root2 = TreeNode(1) root2.right = TreeNode(2) assert is_identical(root1, root2) == False ``` Implement this function with a focus on correctness and efficiency, considering an average and worst-case scenario.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def is_identical(root1, root2): Determines if two binary trees are identical. :param root1: TreeNode - root node of the first binary tree :param root2: TreeNode - root node of the second binary tree :return: bool - True if the trees are identical, otherwise False # Both trees are empty if root1 is None and root2 is None: return True # One tree is empty, the other is not if root1 is None or root2 is None: return False # Both trees are non-empty, compare nodes and subtrees if root1.val != root2.val: return False return ( is_identical(root1.left, root2.left) and is_identical(root1.right, root2.right) )"},{"question":"# Polynomial Manipulation and Computation Given the classes `Monomial` and `Polynomial` that represent monomials and polynomials respectively, implement a function `simplify_polynomial` that takes a `Polynomial` object and returns a simplified version of the polynomial. The function should combine like terms and eliminate any terms with zero coefficients. Input Format * A single object of the `Polynomial` class. Output Format * A simplified `Polynomial` object with combined like terms and no zero coefficient terms. Function Signature ```python def simplify_polynomial(polynomial: Polynomial) -> Polynomial: pass ``` Constraints * The input polynomial may contain any number of variables. * The coefficients of the terms could be integers, floats, or fractions. * Ensure the efficiency of the function to handle polynomials with up to 100 monomials. Example ```python poly = Polynomial([ Monomial({1: 1}, 3), Monomial({1: 1}, 2), Monomial({2: 2}, -1), Monomial({2: 2}, 1), Monomial({}, 0) ]) simplified_poly = simplify_polynomial(poly) print(simplified_poly) ``` Output: ``` 5(a_1) + 0 ``` In this example, the input polynomial contains duplicate monomials which should be combined into a single monomial for variable `a_1`. The zero coefficient term should also be eliminated.","solution":"from collections import defaultdict class Monomial: def __init__(self, variables, coefficient): self.variables = variables # dictionary where keys are variable indices and values are their exponents self.coefficient = coefficient # the coefficient of the monomial def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash(frozenset(self.variables.items())) class Polynomial: def __init__(self, monomials): self.monomials = monomials # list of Monomial objects def __eq__(self, other): return set(self.monomials) == set(other.monomials) def __str__(self): return \' + \'.join([f\'{monomial.coefficient}{monomial.variables}\' for monomial in self.monomials]) def simplify_polynomial(polynomial: Polynomial) -> Polynomial: term_dict = defaultdict(int) for monomial in polynomial.monomials: term = frozenset(monomial.variables.items()) term_dict[term] += monomial.coefficient simplified_monomials = [] for term, coefficient in term_dict.items(): if coefficient != 0: simplified_monomials.append(Monomial(dict(term), coefficient)) return Polynomial(simplified_monomials)"},{"question":"# Question: Implement Crout Matrix Decomposition with Pivoting Given a squared matrix (A) of size (n times n), implement the Crout Matrix Decomposition with partial pivoting. This will decompose the matrix (A) into matrices (L) and (U), such that (L) is a lower triangular matrix with ones on the diagonal, (U) is an upper triangular matrix, and (P) is a permutation matrix that represents the row swaps due to pivoting, satisfying (PA = LU). # Input * A 2D list (A) of size (n times n) representing the matrix to be decomposed. * Ensure (A) is non-singular and numerical values involved do not cause overflow/underflow issues. # Output * Three 2D lists (P), (L), and (U) representing the permutation matrix, lower triangular matrix, and upper triangular matrix respectively. # Constraints * (1 leq n leq 1000) * Matrix elements are real numbers within the range of -10^6 to 10^6. # Example Input ```python [[1, 2, 3], [3, 4, 5], [6, 7, 8]] ``` Output ```python P = [[0, 0, 1], [0, 1, 0], [1, 0, 0]] L = [[1.0, 0.0, 0.0], [0.5, 1.0, 0.0], [0.1667, -5.0, 1.0]] U = [[6.0, 7.0, 8.0], [0.0, 0.5, 1.0], [0.0, 0.0, 0.3333]] ``` # Notes * Carefully handle edge cases, such as zero elements in the pivot. * Ensure that the matrix (P) correctly represents row swaps during the pivoting process. * Maintain numerical stability by implementing partial pivoting. Write code to implement this functionality.","solution":"import numpy as np def crout_pivot(A): This function performs Crout Matrix Decomposition with pivoting. Input: - A: 2D list of size n x n representing the matrix to be decomposed. Output: - P: 2D list representing the permutation matrix - L: 2D list representing the lower triangular matrix with ones on the diagonal - U: 2D list representing the upper triangular matrix n = len(A) A = np.array(A, dtype=float) P = np.eye(n) L = np.zeros((n, n)) U = np.zeros((n, n)) for i in range(n): # Partial pivoting max_row = np.argmax(abs(A[i:n, i])) + i if i != max_row: # Swap rows in A A[[i, max_row]] = A[[max_row, i]] # Swap rows in permutation matrix P[[i, max_row]] = P[[max_row, i]] # Also swap already computed rows in L if i > 0: L[[i, max_row], :i] = L[[max_row, i], :i] # Decompose the matrix for j in range(i, n): # For U U[i, j] = A[i, j] - L[i, :i] @ U[:i, j] for j in range(i + 1, n): # For L L[j, i] = (A[j, i] - L[j, :i] @ U[:i, i]) / U[i, i] # Set the diagonal of L to 1 L[i, i] = 1.0 return P.tolist(), L.tolist(), U.tolist()"},{"question":"# Linked List Cycle Detection Objective Design and implement a function to detect if a given singly linked list contains a cycle. This question assesses your ability to apply the two-pointer technique (Floyd\'s Tortoise and Hare) to solve a common problem in data structures efficiently. Function Signature ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: pass ``` Details 1. **Input**: A singly linked list represented by the head node. 2. **Output**: A boolean value: * `True` if the linked list contains a cycle. * `False` if the linked list does not contain a cycle. 3. **Constraints**: * The space complexity must be O(1), signifying no use of extra data structures like sets or dictionaries to track visited nodes. * The time complexity should be O(n), where n is the number of nodes in the linked list. Example ```python # Example 1: # Input: head = [3 -> 2 -> 0 -> -4, tail connects to node index 1] # Output: True # Example 2: # Input: head = [1 -> 2, tail connects to node index 0] # Output: True # Example 3: # Input: head = [1] # Output: False ``` Instructions 1. Your implementation will be tested against the provided examples as well as additional edge cases. 2. Handle edge cases such as an empty list and single-node lists. Code Template ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: if not head: return False runner = head walker = head while runner.next and runner.next.next: runner = runner.next.next walker = walker.next if runner == walker: return True return False ```","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head: Node) -> bool: if not head: return False runner = head walker = head while runner and runner.next: runner = runner.next.next walker = walker.next if runner == walker: return True return False"},{"question":"Problem Scenario You have been hired by a company that processes large data sets using linked lists. One frequent task is to ensure sequences are in ascending order before processing. To streamline this, you\'ll write a function that checks if a linked list is sorted. Task Write a function `is_sorted` that takes the head of a linked list as input and returns `True` if the list is sorted in non-decreasing order, `False` otherwise. An empty linked list is considered sorted. Input Format * The input will be the `head` of the linked list, where each node contains an integer `val` and a reference to the next node `next`. The linked list can have any number of nodes, including zero. Output Format * The function should return a boolean value (`True` or `False`). Constraints * The linked list\'s length can be from `0` to `10^5`. * The value of nodes\' `val` can range from `-10^9` to `10^9`. Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1 # Input: 1 -> 2 -> 3 -> 4 # Output: True # Example 2 # Input: 1 -> 2 -> -1 -> 3 # Output: False # Example 3 # Input: None # Output: True def is_sorted(head): if not head: return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True ``` Use the above function `is_sorted` to determine if the linked list is sorted. Ensure you handle edge cases such as empty linked lists and provide the correct result efficiently.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_sorted(head): Returns True if the linked list is sorted in non-decreasing order, otherwise False. if not head: # An empty list is considered sorted return True current = head while current.next: if current.val > current.next.val: return False current = current.next return True"},{"question":"# Context: You\'re working on a system for a digital data transmission base station. To ensure data integrity, you need to determine the number of bits that differ between transmitted and received data encoded as integers. This is critical for detecting and correcting mismatches. # Problem Statement: Write a function named `minimal_bit_flips` that calculates and returns the minimal number of bits needed to flip to convert integer `x` to integer `y`. # Input: - Two integers `x` and `y` (`0 <= x, y <= 2^31 - 1`). # Output: - An integer representing the minimal number of bits that need to be flipped to convert `x` to `y`. # Function Signature: ```python def minimal_bit_flips(x: int, y: int) -> int: ``` # Example: ```python # Example 1: x = 29 # (11101 in binary) y = 15 # (01111 in binary) # Output: 2 (as only the first and third bits from the right need to be flipped to match y) print(minimal_bit_flips(x, y)) # Output: 2 # Example 2: x = 1 # (00001 in binary) y = 2 # (00010 in binary) # Output: 2 (as the bits differ completely) print(minimal_bit_flips(x, y)) # Output: 2 ``` # Constraints: 1. The integers will be in the range [0, 2^31 - 1], which means they can be represented in 32 bits unsigned integers. 2. The function should handle edge cases like zero values optimally. # Performance Requirement: - Aim for a solution with O(k) time complexity where k is the number of bits (32 in this case). - Ensure the space complexity remains O(1).","solution":"def minimal_bit_flips(x: int, y: int) -> int: This function computes the number of bits that need to be flipped to convert integer x into integer y. # XOR x and y to find differing bits xor = x ^ y # Count the number of set bits in the result of XOR count = 0 while xor: count += xor & 1 xor >>= 1 return count"},{"question":"As a software engineer in a company that deals with extensive search functionalities, you are tasked with implementing a feature for a search recommendation engine. The feature needs to be efficient in suggesting search queries based on user input prefixes. **Task**: Implement a `Trie` class that supports the following operations: 1. `insert(word: str) -> None`: Inserts the word into the trie. 2. `search(word: str) -> bool`: Returns `True` if the word is in the trie, otherwise returns `False`. 3. `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the trie that starts with the given prefix, otherwise returns `False`. 4. `delete(word: str) -> None`: Deletes the word from the trie, if it exists. **Input/Output Format**: - `insert(word)`: * Input: A string `word` consisting of lowercase letters. * Output: None. - `search(word)`: * Input: A string `word` consisting of lowercase letters. * Output: Returns `True` if the word exists, otherwise `False`. - `starts_with(prefix)`: * Input: A string `prefix` consisting of lowercase letters. * Output: Returns `True` if there exists a word that starts with `prefix`, otherwise `False`. - `delete(word)`: * Input: A string `word` consisting of lowercase letters. * Output: None. **Constraints**: * 1 ≤ word.length ≤ 1000 * Words consist of lowercase English letters only. * Implement the operations with optimal time and space complexity. **Example Usage**: ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # True print(trie.search(\\"app\\")) # False print(trie.starts_with(\\"app\\")) # True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # True trie.delete(\\"apple\\") print(trie.search(\\"apple\\")) # False ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def delete(self, word: str) -> None: def delete_recursively(node, word, depth): if not node: return False if depth == len(word): if not node.is_end_of_word: return False node.is_end_of_word = False return len(node.children) == 0 char = word[depth] if char in node.children: should_delete_child = delete_recursively(node.children[char], word, depth + 1) if should_delete_child: del node.children[char] return len(node.children) == 0 return False delete_recursively(self.root, word, 0)"},{"question":"Question You are given a partially implemented `SeparateChainingHashTable` class that uses separate chaining with linked lists to handle collisions. It provides basic functionalities to insert, access, and delete elements. Your task is to complete the implementation of this class by adding the following enhancements: 1. **Rehashing Mechanism**: * When the load factor exceeds 0.75, the hash table should automatically resize to a size that is approximately double its current size plus one (to ensure odd size, reducing secondary clustering), and reinsert all existing elements. 2. **Keys Method**: * Implement a method `keys()` that returns a list of all keys currently stored in the hash table. Constraints * The input keys and values will only be of types `str`, `int`, `float`. Notes * Performance requirements: * The methods `put()` and `get()` should maintain O(1) average time complexity. * The method `del_()` should maintain O(1) average time complexity. Example ```python >>> table = SeparateChainingHashTable(size=5) >>> table.put(\'key1\', 1) >>> table.put(\'key2\', 2) >>> table.put(\'key3\', 3) >>> table.put(\'key4\', 4) >>> table.keys() [\'key1\', \'key2\', \'key3\', \'key4\'] >>> len(table) 4 >>> table.put(\'key5\', 5) >>> len(table) 5 >>> table.keys() # The table should have been resized due to exceeding the load factor. [\'key1\', \'key2\', \'key3\', \'key4\', \'key5\'] >>> table.get(\'key2\') 2 >>> table.del_(\'key2\') >>> table.get(\'key2\') None >>> len(table) 4 ``` **Your task is to:** 1. Implement the rehashing logic within the `SeparateChainingHashTable` class. 2. Add a `keys()` method to return all the keys stored in the hash table.","solution":"class SeparateChainingHashTable: def __init__(self, size=10): self.size = size self.table = [[] for _ in range(size)] self.num_elements = 0 def put(self, key, value): Insert or update the given key with its associated value in the hash table. if self.load_factor() > 0.75: self.rehash() bucket = self._hash(key) for idx, (k, v) in enumerate(self.table[bucket]): if k == key: self.table[bucket][idx] = (key, value) return self.table[bucket].append((key, value)) self.num_elements += 1 def get(self, key): Retrieve the value associated with the given key. Returns None if the key doesn\'t exist. bucket = self._hash(key) for k, v in self.table[bucket]: if k == key: return v return None def del_(self, key): Remove the given key and its associated value from the hash table. bucket = self._hash(key) for idx, (k, v) in enumerate(self.table[bucket]): if k == key: del self.table[bucket][idx] self.num_elements -= 1 return True return False def load_factor(self): Calculate and return the current load factor of the hash table. return self.num_elements / self.size def rehash(self): Rehash the hash table when the load factor exceeds the threshold. old_table = self.table new_size = self.size * 2 + 1 self.size = new_size self.table = [[] for _ in range(new_size)] self.num_elements = 0 for bucket in old_table: for key, value in bucket: self.put(key, value) def keys(self): Returns a list of all keys currently stored in the hash table. all_keys = [] for bucket in self.table: for key, value in bucket: all_keys.append(key) return all_keys def _hash(self, key): Compute the index for the given key. return hash(key) % self.size def __len__(self): return self.num_elements"},{"question":"# Task: Write a Python function that creates a histogram of character frequencies from a given string. # Scenario: In text analysis, it is often required to understand the frequency distribution of characters in a string. For instance, this can be used in cryptographic analysis to crack simple ciphers, in natural language processing to preprocess text data, and more. # Function Signature: ```python def char_histogram(input_string: str) -> dict: Get histogram representation of characters in a string. :param input_string: string with different and unordered characters :return histogram: dict with character frequencies in input_string ``` # Input: - `input_string` (str): An arbitrary string containing different characters. # Output: - A dictionary where the keys are characters and the values are the frequencies of those characters in the input string. # Constraints: - The input string may contain any characters (including letters, digits, punctuation, whitespace, etc.). - Note that character comparison should be case-sensitive (\'a\' and \'A\' are different characters). # Examples: ```python assert char_histogram(\\"hello world\\") == {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1} assert char_histogram(\\"aaaAAA\\") == {\'a\': 3, \'A\': 3} assert char_histogram(\\"\\") == {} ``` # Performance Requirements: - The function should run in O(n) time, where n is the length of the input string. - Use of additional space should be O(m), where m is the number of unique characters in the input string. # Note: Consider edge cases such as empty string input and mix of different characters including spaces and symbols.","solution":"def char_histogram(input_string: str) -> dict: Get histogram representation of characters in a string. :param input_string: string with different and unordered characters :return histogram: dict with character frequencies in input_string histogram = {} for char in input_string: if char in histogram: histogram[char] += 1 else: histogram[char] = 1 return histogram"},{"question":"You are given a list of distinct integers. Your task is to implement a function that returns all possible permutations of these integers. # Function Signature: ```python def generate_permutations(nums: List[int]) -> List[List[int]]: ``` # Input: - `nums`: A list of distinct integers, where 1 ≤ len(nums) ≤ 10. # Output: - A list of lists, where each inner list is a unique permutation of the input list `nums`. # Constraints: - Your returned list can contain the permutations in any order. # Performance Requirements: - Your solution should be able to generate permutations for `nums` up to size 10 efficiently (consider around O(n * n!) time complexity). # Example: ```python # Example 1: Input: [1, 2, 3] Output: [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] # Example 2: Input: [0, 1] Output: [ [0, 1], [1, 0] ] ``` # Task: Implement the `generate_permutations` function using a recursive depth-first search approach. Ensure that your implementation is efficient and correctly handles all edge cases.","solution":"from typing import List def generate_permutations(nums: List[int]) -> List[List[int]]: Returns all possible permutations of a list of distinct integers. def backtrack(start, end): if start == end: permutations.append(nums[:]) for i in range(start, end): nums[start], nums[i] = nums[i], nums[start] backtrack(start + 1, end) nums[start], nums[i] = nums[i], nums[start] permutations = [] backtrack(0, len(nums)) return permutations"},{"question":"# ZigZag Iterator Implementation Problem Statement You are required to implement a ZigZag Iterator that alternates between elements from two input lists. The iterator should behave such that it first returns an element from the first list, then an element from the second list, and continues to alternate between the lists. If one list runs out of elements before the other, continue to return elements from the remaining list. Function Definitions: 1. **`__init__(self, v1: List[int], v2: List[int])`**: * Initializes the iterator with two lists, `v1` and `v2`. * **Input**: * `v1` - List of integers. * `v2` - List of integers. 2. **`next(self) -> int`**: * Returns the next element in the zigzag order. * **Output**: * Next integer in the zigzag sequence. 3. **`has_next(self) -> bool`**: * Returns whether the iterator has more elements to iterate over. * **Output**: * Boolean value, `True` if there are more elements to iterate over, `False` otherwise. Constraints: * The input lists can be of different lengths. * The input lists can have up to 10^4 elements each. * The iterator methods will be called at most 2 * 10^4 times. Example: ```python # Example Usage l1 = [1, 2] l2 = [3, 4, 5, 6] it = ZigZagIterator(l1, l2) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 2, 4, 5, 6] ``` You are required to provide the implementation of the `ZigZagIterator` class described above.","solution":"from typing import List class ZigZagIterator: def __init__(self, v1: List[int], v2: List[int]): self.data = [] i = 0 while i < max(len(v1), len(v2)): if i < len(v1): self.data.append(v1[i]) if i < len(v2): self.data.append(v2[i]) i += 1 self.index = 0 def next(self) -> int: result = self.data[self.index] self.index += 1 return result def has_next(self) -> bool: return self.index < len(self.data)"},{"question":"# Scenario Imagine you are working on a singly linked list-based system in which you might sometimes need to delete nodes without knowing a reference to the head of the list. # Problem Statement Write a function to delete a node (except the tail) in a singly linked list, given only access to that node. # Your Task Create a Python function `delete_node(node)` that deletes the given node from the singly linked list. # Input - `node`: A `Node` object that is neither `None` nor the last node of the list. # Output - The function does not return a value, but it should delete the given node from the linked list. # Constraints - The node provided will not be the tail node and won\'t be a `None` node. # Example ```python class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): pass # your code here # Example Usage # Given linked list: 1 -> 2 -> 3 -> 4 # Node to delete: node with value 3 # Linked list after calling delete_node: 1 -> 2 -> 4 # Implementation for testing the code head = Node(1) node2 = head.next = Node(2) node3 = node2.next = Node(3) node4 = node3.next = Node(4) delete_node(node3) # Now the linked list should be 1 -> 2 -> 4 # Print the list to verify: 1 -> 2 -> 4 current = head while current: print(current.val, end=\\" -> \\" if current.next else \\"\\") current = current.next # Expected Output: 1 -> 2 -> 4 ``` # Additional Requirements 1. Ensure your function handles potential errors (e.g., trying to delete the tail). 2. Consider efficiency and edge cases as described in the provided analysis.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_node(node): Deletes the given node (except the tail) from the singly linked list. # We can\'t delete the node directly, but we can copy the data from the next node # into the current node and then delete the next node. if node.next: node.val = node.next.val node.next = node.next.next"},{"question":"# Assessment Question Scenario You are working for a text processing company that incorporates various symbols to enrich the displayed text. Your task is to implement a solution that, given a list of words and a list of symbols, wraps the longest matching symbol in each word with square brackets. Problem Statement Write a function `highlight_symbols(words, symbols)` that takes a list of words and a list of symbols and returns a list of words with the longest matching symbol in the words wrapped in square brackets `[ ]`. Input * `words`: A list of strings, where each string is a word (1 ≤ length of each word ≤ 100). * `symbols`: A list of strings, where each string is a symbol (1 ≤ length of each symbol ≤ 10). Output * A list of strings where each word has its longest matching symbol wrapped in square brackets. Constraints * If a word matches multiple symbols, choose the one with the longest length. * If no symbols match the word, return the word unchanged. * Symbols will not contain any characters outside \'a\' to \'z\' and \'A\' to \'Z\'. * Words are case-sensitive, meaning \'a\' is different from \'A\'. Function Signature ```python def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: pass ``` Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] highlight_symbols(words, symbols) ``` Should produce: ```python [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` Notes - Consider using efficient data structures to avoid excessive time complexity.","solution":"from typing import List def highlight_symbols(words: List[str], symbols: List[str]) -> List[str]: # Sort symbols by their length in descending order. symbols = sorted(symbols, key=len, reverse=True) result = [] for word in words: matched_symbol = None for symbol in symbols: if symbol in word: matched_symbol = symbol break if matched_symbol: word = word.replace(matched_symbol, f\'[{matched_symbol}]\', 1) result.append(word) return result"},{"question":"# Robot Movement Circle Check Context: You are designing a robot movement simulator. You need to determine if a sequence of robot moves results in the robot returning to its original starting position. The robot can move up, down, left, or right. Objective: Implement a function `does_robot_return_to_origin(moves)` that returns True if the sequence of moves returns the robot to its starting position, (0, 0), otherwise returns False. Requirements: * **Input**: A string `moves` of length n (0 <= n <= 10000), where each character is either \'U\' (up), \'D\' (down), \'L\' (left), or \'R\' (right). * **Output**: A boolean value - `True` or `False`. Constraints: * Only these four characters are valid. If the input contains other characters, ignore them. * Aim for an efficient linear solution in terms of time complexity. Example: * Example 1: * Input: \\"UD\\" * Output: True * Example 2: * Input: \\"LL\\" * Output: False * Example 3: * Input: \\"UURRDD\\" * Output: True Use these examples to validate the implementation. Edge Cases: * An empty string should return True as the robot stays at the origin by default. * A single move in any direction and its immediate opposite should return True.","solution":"def does_robot_return_to_origin(moves): Determines if a sequence of robot moves returns the robot to its starting position. :param moves: str - sequence of moves; each character is either \'U\', \'D\', \'L\', or \'R\' :return: bool - True if the robot returns to the starting position, otherwise False # Initialize position variables x, y = 0, 0 # Dictionary to map moves to coordinate changes move_dict = {\'U\': (0, 1), \'D\': (0, -1), \'L\': (-1, 0), \'R\': (1, 0)} for move in moves: if move in move_dict: dx, dy = move_dict[move] x += dx y += dy # The robot returns to starting position if both x and y are 0 return x == 0 and y == 0"},{"question":"Advanced Insertion Sort **Context**: Insertion Sort is straightforward yet powerful for small or nearly sorted datasets. To further test your understanding and improve the efficiency of the traditional Insertion Sort, you will implement an optimized version that utilizes a binary search technique to identify the correct position for each element. # Task: Implement an advanced version of `insertion_sort` function called `advanced_insertion_sort` that uses binary search to find the correct position of an element in the sorted part of the array. This should reduce the number of comparisons made. # Function Signature: ```python def advanced_insertion_sort(arr): # Your implementation here return arr ``` # Input: - `arr`: A list of integers (1 ≤ len(arr) ≤ 10^3). # Output: - The sorted list of integers. # Constraints: - The implementation should handle edge cases such as empty arrays and arrays with duplicate elements. - The function should sort the array in non-decreasing order. # Example: ```python assert advanced_insertion_sort([64, 25, 12, 22, 11]) == [11, 12, 22, 25, 64] assert advanced_insertion_sort([4, 3, 2, 10, 12, 1, 5, 6]) == [1, 2, 3, 4, 5, 6, 10, 12] assert advanced_insertion_sort([]) == [] assert advanced_insertion_sort([3]) == [3] assert advanced_insertion_sort([5, 5, 5, 5]) == [5, 5, 5, 5] ``` # Performance: - Though binary search reduces comparisons, remember that shifting elements still takes linear time, maintaining overall O(n^2) complexity. However, it may show improvements due to fewer comparisons. **Note**: The implementation should not import any external libraries for sorting.","solution":"def advanced_insertion_sort(arr): def binary_search(sub_arr, val): low, high = 0, len(sub_arr) - 1 while low <= high: mid = (low + high) // 2 if sub_arr[mid] < val: low = mid + 1 else: high = mid - 1 return low for i in range(1, len(arr)): key = arr[i] pos = binary_search(arr[:i], key) arr = arr[:pos] + [key] + arr[pos:i] + arr[i+1:] return arr"},{"question":"Given a list of integers, implement a Segment Tree supporting efficient range maximum queries and point updates. Write a class `SegmentTree` to solve this problem. Your class should support the following methods: 1. **Constructor `__init__(self, arr: List[int])`**: * Inputs: - `arr` : List of integers to initialize the segment tree. * Initializes and builds the segment tree to support range maximum queries. 2. **Method `update(self, index: int, value: int) -> None`**: * Inputs: - `index`: The position of the element in the original list to update. - `value`: The new value to be updated at the given index. * Updates the segment tree to reflect the new value at the given index. 3. **Method `query(self, left: int, right: int) -> int`**: * Inputs: - `left`: Left index of the query range. - `right`: Right index of the query range. * Returns the maximum value within the range `[left, right]`. # Example ```python # Initialize the segment tree with the array [2, 4, 5, 3, 4] seg_tree = SegmentTree([2, 4, 5, 3, 4]) # Query the maximum value from index 1 to 3 assert seg_tree.query(1, 3) == 5 # Update the value at index 2 to 6 seg_tree.update(2, 6) # Query the maximum value from index 0 to 3 assert seg_tree.query(0, 3) == 6 ``` # Constraints - `1 <= len(arr) <= 10^5` - `1 <= value, arr[i] <= 10^6` - `0 <= left, right, index < len(arr)` - `left <= right` # Notes - Ensure your implementation handles edge cases, such as querying an entire array, updating the first/last elements, and querying single-element ranges.","solution":"class SegmentTree: def __init__(self, arr): Initialize the segment tree with the given array. self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = max(self.tree[i << 1], self.tree[i << 1 | 1]) def update(self, index, value): Update the value at index in the original array. pos = index + self.n self.tree[pos] = value while pos > 1: pos >>= 1 self.tree[pos] = max(self.tree[pos << 1], self.tree[pos << 1 | 1]) def query(self, left, right): Query the maximum value in the range [left, right]. res = float(\'-inf\') left += self.n right += self.n while left <= right: if left & 1: res = max(res, self.tree[left]) left += 1 if right & 1 == 0: res = max(res, self.tree[right]) right -= 1 left >>= 1 right >>= 1 return res"},{"question":"# Scenario: You have been hired by a logistics company to optimize their transport network. They have a series of distribution nodes with varying transport capacities between them. You need to determine the maximum amount of material that can be transported from the company\'s main depot to the storage facility, given the transport limits of each route. # Problem Statement: Write a function `maximum_transport_capacity` which takes an `n x n` adjacency matrix of non-negative integers representing the transport capacities between nodes in the company’s logistics network. You need to calculate the maximum transport capacity from the main depot (node 0) to the storage facility (node n-1). # Input: - `adjacency_matrix` (List[List[int]]): An n x n matrix where `adjacency_matrix[i][j]` denotes the transport capacity from node `i` to node `j`. # Output: - Return an integer which is the maximum transport capacity from node 0 to node n-1. # Constraints: - 2 ≤ n ≤ 100 - 0 ≤ `adjacency_matrix[i][j]` ≤ 1000, for 0 ≤ i, j < n - `adjacency_matrix[i][j] = 0` if there is no direct route from node `i` to node `j`. # Example: ```python adjacency_matrix = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_transport_capacity(adjacency_matrix) == 23 ``` # Notes: - You may assume that there is at least one path from the main depot to the storage facility. - Your solution should handle large inputs efficiently within given constraints.","solution":"def maximum_transport_capacity(adjacency_matrix): from collections import deque def bfs(source, sink, parent): visited = [False] * len(adjacency_matrix) queue = deque([source]) visited[source] = True while queue: node = queue.popleft() for idx, capacity in enumerate(adjacency_matrix[node]): if not visited[idx] and capacity > 0: queue.append(idx) visited[idx] = True parent[idx] = node if idx == sink: return True return False source, sink = 0, len(adjacency_matrix) - 1 parent = [-1] * len(adjacency_matrix) max_flow = 0 while bfs(source, sink, parent): path_flow = float(\'Inf\') s = sink while s != source: path_flow = min(path_flow, adjacency_matrix[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] adjacency_matrix[u][v] -= path_flow adjacency_matrix[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"**Context**: You are developing a web scraping tool that needs to construct full URLs from a base URL and a relative path to ensure robust and reliable web address formulation. The same tool is also expected to organize downloaded files in a structured directory tree by joining directory paths with file names. **Task**: Implement a function `join_with_slash` that combines a `base path` (URL or file path) and a `suffix path` into a single path, adhering to the following requirements: - Remove any trailing slashes from the base path. - Remove any leading slashes from the suffix path. - Ensure exactly one slash separates the base and suffix paths in the result. # Function Signature ```python def join_with_slash(base: str, suffix: str) -> str: ``` # Input - `base` (str): The base path, which could be a URL or a file path. - `suffix` (str): The suffix path, which is appended to the base path. # Output - Returns a single combined path string with exactly one slash separating the base and suffix. # Constraints - Both `base` and `suffix` are non-null strings. - Base and suffix paths may contain spaces, special characters, and can be empty. - Paths may start or end with slashes. # Example ```python # Example 1 base = \\"http://algorithms.com/\\" suffix = \\"part\\" assert join_with_slash(base, suffix) == \\"http://algorithms.com/part\\" # Example 2 base = \\"path/to/dir/\\" suffix = \\"/file\\" assert join_with_slash(base, suffix) == \\"path/to/dir/file\\" # Example 3 base = \\"path/to/dir\\" suffix = \\"\\" assert join_with_slash(base, suffix) == \\"path/to/dir\\" # Example 4 base = \\"\\" suffix = \\"subdir/file\\" assert join_with_slash(base, suffix) == \\"subdir/file\\" ``` # Notes - Consider the various string manipulation techniques to ensure efficient and clean path joining. - Edge cases should be covered, such as handling empty strings or multiple slashes. - Do not use specific libraries like `os` for joining paths to focus on string manipulation skills.","solution":"def join_with_slash(base: str, suffix: str) -> str: Combines a base path and a suffix path into a single path with exactly one slash separating them. Parameters: base (str): The base path, which could be a URL or a file path. suffix (str): The suffix path, which is appended to the base path. Returns: str: The combined path with exactly one slash separating base and suffix. base = base.rstrip(\'/\') # Remove trailing slashes from base suffix = suffix.lstrip(\'/\') # Remove leading slashes from suffix return f\'{base}/{suffix}\' if base and suffix else base + suffix # Combine with one slash"},{"question":"# String Merge Challenge **Background**: You are required to determine if a given string `s` can be formed by merging two other strings `part1` and `part2`. The merge must maintain the character order from both `part1` and `part2`. **Objective**: Write a function `is_merge` that returns `True` if `s` can be formed by merging `part1` and `part2`, otherwise return `False`. **Function Signature**: ```python def is_merge(s: str, part1: str, part2: str) -> bool: ``` **Input**: - `s` (String): The target string to be formed. - `part1` (String): First string part. - `part2` (String): Second string part. **Output**: - Returns `True` if `s` can be formed by interleaving `part1` and `part2`. - Returns `False` otherwise. **Constraints**: - All strings consist of lowercase English letters. - You may assume that the input is always valid (no null values). **Examples**: 1. `is_merge(\'codewars\', \'cdw\', \'oears\')` should return `True`. 2. `is_merge(\'codewars\', \'code\', \'wars\')` should return `True`. 3. `is_merge(\'codewars\', \'cod\', \'wares\')` should return `False`. **Performance Requirements**: - The solution should aim to be both time and space efficient. - Handle cases where `len(s)` is up to 500 and `len(part1)` and `len(part2)` are each up to 250. **Edge Cases to Consider**: - Both `part1` and `part2` are empty. - Either `part1` or `part2` is empty. - Characters in `s` not appearing in `part1` or `part2`. **Hints**: - Dynamic programming can be an effective approach for optimizing your solution.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: len_s, len_p1, len_p2 = len(s), len(part1), len(part2) if len_s != len_p1 + len_p2: return False # Create a 2D DP table where dp[i][j] indicates if s up to i+j can be formed # by part1 up to i and part2 up to j. dp = [[False] * (len_p2 + 1) for _ in range(len_p1 + 1)] dp[0][0] = True # Fill the DP table. for i in range(len_p1 + 1): for j in range(len_p2 + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[len_p1][len_p2]"},{"question":"# Decoding an Encoded Message You are given a message encoded using the following scheme: * \'A\' -> 1 * \'B\' -> 2 * ... * \'Z\' -> 26 The encoded message consists of a string of digits. Your task is to determine the total number of ways to decode this string. Function Signature: `def num_decodings(encoded_message: str) -> int:` Input: * `encoded_message` (str): A string of digits representing the encoded message. Output: * Returns an integer representing the total number of ways to decode the message. Constraints: * The encoded message will only contain digits (\'0\'-\'9\'). * The length of the encoded message will be between 1 and 100. Example: ```python encoded_message = \\"12\\" assert num_decodings(encoded_message) == 2 # \\"AB\\" (1 2) or \\"L\\" (12) encoded_message = \\"226\\" assert num_decodings(encoded_message) == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), and \\"BBF\\" (2 2 6) encoded_message = \\"0\\" assert num_decodings(encoded_message) == 0 # No valid decoding encoded_message = \\"10\\" assert num_decodings(encoded_message) == 1 # \\"J\\" (10) ``` Notes: * Ensure to handle edge cases such as strings starting with \'0\' and pairs like \'30\', \'40\', ... which are invalid. * Optimize your solution for the given constraints to avoid excessive space and time complexity.","solution":"def num_decodings(encoded_message: str) -> int: Determines the total number of ways to decode an encoded message. if not encoded_message or encoded_message[0] == \'0\': return 0 n = len(encoded_message) dp = [0] * (n + 1) dp[0] = 1 # Empty string has one way to decode dp[1] = 1 # Single character string, if not \'0\', has one way to decode for i in range(2, n + 1): one_digit = int(encoded_message[i-1]) two_digits = int(encoded_message[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Hamming Weight Calculation Using Brian Kernighan\'s Algorithm Scenario: You are working on a compression algorithm and need to frequently compute the Hamming weight of various 32-bit unsigned integers. Efficiency is crucial since these computations are part of a real-time system. You decided to use Brian Kernighan\'s Algorithm due to its immediate advantage in minimizing operations required for counting bits. Task: Implement a function `hamming_weight(n: int) -> int` that takes a 32-bit unsigned integer and returns the number of \'1\' bits in its binary representation using Brian Kernighan\'s Algorithm. Requirements: 1. Implement both recursive and iterative approaches in your function. 2. Ensure that the time complexity does not exceed O(k), where k is the number of \'1\' bits. Function Signatures: ```python def hamming_weight_iter(n: int) -> int: pass def hamming_weight_recur(n: int) -> int: pass ``` Input: - One integer `n` (0 <= `n` < 2^32). Output: - A single integer representing the Hamming weight of the input. Constraints: - The input will always be a valid 32-bit unsigned integer. Examples: Example 1: ```python assert hamming_weight_iter(11) == 3 assert hamming_weight_recur(11) == 3 # Explanation: 11 in binary is 00000000000000000000000000001011, which has 3 \'1\' bits. ``` Example 2: ```python assert hamming_weight_iter(128) == 1 assert hamming_weight_recur(128) == 1 # Explanation: 128 in binary is 00000000000000000000000010000000, which has 1 \'1\' bit. ``` Example 3: ```python assert hamming_weight_iter(0) == 0 assert hamming_weight_recur(0) == 0 # Explanation: 0 in binary is 00000000000000000000000000000000, which has 0 \'1\' bits. ```","solution":"def hamming_weight_iter(n: int) -> int: Returns the Hamming weight (number of \'1\' bits) of a 32-bit unsigned integer n using Brian Kernighan\'s Algorithm in an iterative manner. count = 0 while n: n &= n - 1 # Clear the lowest set bit count += 1 return count def hamming_weight_recur(n: int) -> int: Returns the Hamming weight (number of \'1\' bits) of a 32-bit unsigned integer n using Brian Kernighan\'s Algorithm in a recursive manner. if n == 0: return 0 else: return 1 + hamming_weight_recur(n & (n - 1))"},{"question":"As a software engineer at a tech company, you\'ve been tasked with enhancing the routing efficiency in the company\'s internal network. The internal network is represented by an adjacency matrix where the entry at index `i, j` denotes the direct distance from node `i` to node `j`. You need to determine the shortest path between all pairs of nodes to update the routing tables appropriately. # Task Write a function `all_pairs_shortest_path(adjacency_matrix)` that takes a 2D list `adjacency_matrix` representing the network\'s distances and returns a 2D list where the value at index `i, j` represents the shortest distance from node `i` to node `j`. # Function Signature ```python def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: ``` # Input * `adjacency_matrix (List[List[float]])`: A 2D list of shape n*n where `adjacency_matrix[i][j]` is the distance from node `i` to node `j`. If there is no direct edge between two nodes, the corresponding entry will be `float(\'inf\')`. # Output * Returns a 2D list of shape n*n where the entry at index `i, j` is the shortest distance from node `i` to node `j` considering all possible paths. # Constraints * `1 <= n <= 100` where n is the number of nodes. * The distances are represented as floating-point values and are non-negative. If no direct path exists, the distance can be represented as `float(\'inf\')`. # Example ```python a = [[0 , 0.1 , 0.101, 0.142, 0.277], [float(\'inf\'), 0 , 0.191, 0.192, float(\'inf\')], [0.245, float(\'inf\'), 0 , 0.333, float(\'inf\')], [1.032, 0.668, 0.656, 0 , 0.151], [float(\'inf\'), 0.119, 0.352, float(\'inf\'), 0]] assert all_pairs_shortest_path(a) == [ [0 , 0.1 , 0.101, 0.142, 0.277], [0.436, 0 , 0.191, 0.192, 0.343], [0.245, 0.345, 0 , 0.333, 0.484], [0.706, 0.27 , 0.461, 0 , 0.151], [0.555, 0.119, 0.31 , 0.311, 0] ] ``` # Notes * Ensure that your solution handles edge cases such as disconnected graphs where some nodes have no path to others, and avoids creating or modifying the original matrix to maintain data integrity.","solution":"from typing import List def all_pairs_shortest_path(adjacency_matrix: List[List[float]]) -> List[List[float]]: Implement the Floyd-Warshall algorithm to find the shortest paths between all pairs of nodes in a given adjacency matrix. adjacency_matrix: 2D list representing distances between nodes. If there is no direct edge between two nodes, the corresponding entry is float(\'inf\'). Returns a 2D list with the shortest distances between each pair of nodes. # Number of nodes n = len(adjacency_matrix) # Copy the adjacency_matrix to the shortest_paths matrix to avoid modifying the original input shortest_paths = [row[:] for row in adjacency_matrix] # Apply Floyd-Warshall algorithm for k in range(n): for i in range(n): for j in range(n): if shortest_paths[i][j] > shortest_paths[i][k] + shortest_paths[k][j]: shortest_paths[i][j] = shortest_paths[i][k] + shortest_paths[k][j] return shortest_paths"},{"question":"# Question Context You are designing a transportation system that involves finding the best possible routes between cities. These cities and their direct connections are represented as an unweighted graph. You have to provide solutions for the following: 1. Find any possible route between two cities. 2. Find all possible routes between two cities. 3. Find the shortest route between two cities. Task Implement three functions `find_any_route`, `find_all_routes`, and `find_shortest_route` which achieve the above goals respectively. Functions ```python def find_any_route(graph, start, end): Find any route between two nodes. Params: - graph: dict, adjacency list representation of the graph. - start: str, starting node. - end: str, ending node. Returns: - list of nodes representing the route, or None if no route exists. pass def find_all_routes(graph, start, end): Find all possible routes between two nodes. Params: - graph: dict, adjacency list representation of the graph. - start: str, starting node. - end: str, ending node. Returns: - list of lists, where each inner list represents a route. pass def find_shortest_route(graph, start, end): Find the shortest route between two nodes. Params: - graph: dict, adjacency list representation of the graph. - start: str, starting node. - end: str, ending node. Returns: - list of nodes representing the shortest route, or None if no route exists. pass ``` Input * **graph**: Dictionary representing an unweighted graph. Keys are nodes (strings) and values are lists of adjacent nodes (strings). * **start**: String, representing the starting node. * **end**: String, representing the ending node. Output * **find_any_route**: Returns a list of nodes representing any valid route from start to end, or None if no route exists. * **find_all_routes**: Returns a list of lists, where each inner list represents a distinct route from start to end. * **find_shortest_route**: Returns a list of nodes representing the shortest route from start to end, or None if no such route exists. Examples ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'C\', \'D\'], \'C\': [\'D\'], \'D\': [\'C\'], \'E\': [\'F\'], \'F\': [\'C\'] } print(find_any_route(graph, \'A\', \'D\')) # Possible output: [\'A\', \'B\', \'D\'] print(find_all_routes(graph, \'A\', \'D\')) # Possible output: [[\'A\', \'B\', \'D\'], [\'A\', \'B\', \'C\', \'D\'], [\'A\', \'C\', \'D\']] print(find_shortest_route(graph, \'A\', \'D\')) # Output: [\'A\', \'B\', \'D\'] ``` Constraints * Nodes are case-sensitive strings and can contain alphabets only. * The graph may contain cycles. * `start` and `end` are guaranteed to be valid nodes in the graph.","solution":"def find_any_route(graph, start, end): Find any route between two nodes. Params: - graph: dict, adjacency list representation of the graph. - start: str, starting node. - end: str, ending node. Returns: - list of nodes representing the route, or None if no route exists. def dfs(node, visited): if node == end: return visited for neighbor in graph.get(node, []): if neighbor not in visited: path = dfs(neighbor, visited + [neighbor]) if path: return path return None return dfs(start, [start]) def find_all_routes(graph, start, end): Find all possible routes between two nodes. Params: - graph: dict, adjacency list representation of the graph. - start: str, starting node. - end: str, ending node. Returns: - list of lists, where each inner list represents a route. def dfs(node, visited): if node == end: return [visited] paths = [] for neighbor in graph.get(node, []): if neighbor not in visited: new_paths = dfs(neighbor, visited + [neighbor]) for path in new_paths: paths.append(path) return paths return dfs(start, [start]) def find_shortest_route(graph, start, end): Find the shortest route between two nodes. Params: - graph: dict, adjacency list representation of the graph. - start: str, starting node. - end: str, ending node. Returns: - list of nodes representing the shortest route, or None if no route exists. from collections import deque queue = deque([(start, [start])]) visited = set() while queue: node, path = queue.popleft() if node == end: return path for neighbor in graph.get(node, []): if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return None"},{"question":"# Task You are required to implement a Singly Linked List with the following functionality: 1. Insert a node at the beginning. 2. Insert a node at the end. 3. Delete a node by value. 4. Search for a value. 5. Display the linked list from head to tail. # Context Imagine you are building a task manager application where tasks can be dynamically added or removed. Using a singly linked list allows you to quickly update the list as tasks are completed or new tasks are added. # Requirements 1. **Insert at Beginning**: ```python def insert_at_beginning(self, value): pass ``` 2. **Insert at End**: ```python def insert_at_end(self, value): pass ``` 3. **Delete by Value**: ```python def delete_by_value(self, value): pass ``` 4. **Search for Value**: ```python def search(self, value): pass ``` 5. **Display**: ```python def display(self): pass ``` # Input and Output Formats - **insert_at_beginning / insert_at_end**: Function takes an integer `value` as an input. - **delete_by_value**: Function takes an integer `value` as an input. If the value exists, delete it; otherwise, do nothing. - **search**: Function takes an integer `value` as an input and returns a Boolean indicating whether the value exists in the list. - **display**: No input parameters. Outputs a list of integers representing the current state of the linked list. # Constraints - Nodes\' values are integers. - Operations will be performed in the following sequence: insertions (start and end), deletions, searches, followed by display. # Example **Operation Sequence**: 1. Insert 3 at the beginning. 2. Insert 5 at the end. 3. Search for 3 (Returns True). 4. Delete 3. 5. Search for 3 (Returns False). 6. Display (Outputs [5]). **Sample Code Framework**: ```python class SinglyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None class SinglyLinkedList(object): def __init__(self): self.head = None def insert_at_beginning(self, value): # YOUR CODE HERE pass def insert_at_end(self, value): # YOUR CODE HERE pass def delete_by_value(self, value): # YOUR CODE HERE pass def search(self, value): # YOUR CODE HERE pass def display(self): # YOUR CODE HERE pass # Example usage: # sll = SinglyLinkedList() # sll.insert_at_beginning(3) # sll.insert_at_end(5) # print(sll.search(3)) # Should return True # sll.delete_by_value(3) # print(sll.search(3)) # Should return False # sll.display() # Should output [5] ``` **Note**: You must not use any Python built-in list methods to manipulate the linked list.","solution":"class SinglyLinkedListNode(object): def __init__(self, value): self.value = value self.next = None class SinglyLinkedList(object): def __init__(self): self.head = None def insert_at_beginning(self, value): # Create a new node new_node = SinglyLinkedListNode(value) # Point the next of new node to current head new_node.next = self.head # Update head to the new node self.head = new_node def insert_at_end(self, value): # Create a new node new_node = SinglyLinkedListNode(value) if self.head is None: # List is empty, so new node becomes head self.head = new_node else: # Traverse to the last node last = self.head while last.next: last = last.next # Point the next of last node to new node last.next = new_node def delete_by_value(self, value): current = self.head prev = None # If the head is the node to be deleted if current and current.value == value: self.head = current.next return while current and current.value != value: prev = current current = current.next if current is None: return prev.next = current.next def search(self, value): current = self.head while current: if current.value == value: return True current = current.next return False def display(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"**Context:** In propositional logic, the 2-Satisfiability (2-SAT) problem is a special case of the Boolean satisfiability problem where each clause contains exactly two literals. You are required to determine if there exists a way to assign True/False values to variables to satisfy all given clauses (or report that it is unsatisfiable). **Problem Description:** You are tasked with implementing a function to solve the 2-SAT problem using the algorithm for finding Strongly Connected Components (SCC) in a directed graph. **Function Signature:** ```python def solve_2SAT(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> Optional[Dict[str, bool]]: Parameters: formula: A list of clauses where each clause is represented as a tuple with two literals. Each literal is a tuple with a variable name (str) and a Boolean indicating if it is negated. Returns: A dictionary mapping variable names to their True/False assignments if a satisfying assignment exists. Returns None if the formula is unsatisfiable. ``` **Input Format:** - `formula`: A list of clauses. Each clause is represented as a tuple containing two literals (represented as tuples): * `(name, is_neg)`, where `name` is a string identifier for the variable, and `is_neg` is a boolean indicating if the literal is negated. **Output Format:** - If the formula is satisfiable, return a dictionary mapping variable names to their assignments (true or false). - If the formula is unsatisfiable, return `None`. **Constraints:** - Each variable name is a non-empty string. - A formula can contain up to 10^4 clauses. **Example:** ```python formula_example = [((\'x\', False), (\'y\', False)), ((\'y\', True), (\'y\', True)), ((\'a\', False), (\'b\', False)), ((\'a\', True), (\'c\', True)), ((\'c\', False), (\'b\', True))] result = solve_2SAT(formula_example) print(result) # might output something like {\'x\': True, \'y\': False, \'a\': True, \'b\': False, \'c\': False} or None if unsatisfiable ``` **Evaluation Criteria:** - Correctness of the solution. - Efficiency in both time and space. - Handling of edge cases and large input sizes. **Notes:** - Ensure that your implementation accurately applies the SCC algorithm to check for satisfiability and deduce variable assignments if possible. - Think about how implications between literals can be represented in a graph and how SCCs can help determine if a valid assignment exists.","solution":"from typing import List, Tuple, Dict, Optional from collections import defaultdict, deque def solve_2SAT(formula: List[Tuple[Tuple[str, bool], Tuple[str, bool]]]) -> Optional[Dict[str, bool]]: def add_implication(graph, u, v): graph[u].append(v) def tarjan_scc(graph, num_vertices): index = 0 stack = [] indices = [-1] * num_vertices lowlinks = [-1] * num_vertices on_stack = [False] * num_vertices sccs = [] def strongconnect(v): nonlocal index indices[v] = index lowlinks[v] = index index += 1 stack.append(v) on_stack[v] = True for w in graph[v]: if indices[w] == -1: strongconnect(w) lowlinks[v] = min(lowlinks[v], lowlinks[w]) elif on_stack[w]: lowlinks[v] = min(lowlinks[v], indices[w]) if lowlinks[v] == indices[v]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == v: break sccs.append(scc) for v in range(num_vertices): if indices[v] == -1: strongconnect(v) return sccs variables = set() for clause in formula: for literal in clause: variables.add(literal[0]) var_index = {var: 2 * i for i, var in enumerate(variables)} num_vertices = 2 * len(variables) graph = defaultdict(list) for (x1, neg1), (x2, neg2) in formula: if not neg1 and not neg2: add_implication(graph, var_index[x1] ^ 1, var_index[x2]) add_implication(graph, var_index[x2] ^ 1, var_index[x1]) elif not neg1 and neg2: add_implication(graph, var_index[x1] ^ 1, var_index[x2] ^ 1) add_implication(graph, var_index[x2], var_index[x1]) elif neg1 and not neg2: add_implication(graph, var_index[x1], var_index[x2]) add_implication(graph, var_index[x2] ^ 1, var_index[x1] ^ 1) elif neg1 and neg2: add_implication(graph, var_index[x1], var_index[x2] ^ 1) add_implication(graph, var_index[x2], var_index[x1] ^ 1) sccs = tarjan_scc(graph, num_vertices) assignment = [-1] * num_vertices for scc in sccs: scc_set = set(scc) for node in scc: if assignment[node] == -1: if node ^ 1 in scc_set: return None assignment[node] = 1 assignment[node ^ 1] = 0 result = {} for var, idx in var_index.items(): result[var] = bool(assignment[idx]) return result"},{"question":"# Binary Search Coding Challenge You are implementing a search feature for a large constantly updated database. To ensure efficient query handling, you decide to use Binary Search on sorted data. Your task is to implement both iterative and recursive versions of Binary Search to find an element from the sorted dataset. Function Implementations 1. **Iterative Approach** Implement the function `binary_search(array, query)` that searches for a given query in a sorted list of integers. * **Input**: * `array`: A list of integers sorted in ascending order. * `query`: An integer to search for in the array. * **Output**: * Return the index of `query` if found. If not found, return `None`. 2. **Recursive Approach** Implement the function `binary_search_recur(array, low, high, val)` to search for a given value recursively. * **Input**: * `array`: A list of integers sorted in ascending order. * `low`: The lower index of the array subsection to search within. * `high`: The upper index of the array subsection to search within. * `val`: The integer to search for in the array. * **Output**: * Return the index of `val` if found. If not found, return `-1`. Constraints * The array will be non-empty and sorted in ascending order. * `1 <= len(array) <= 10^5` * `-10^9 <= array[i] <= 10^9` * `-10^9 <= query <= 10^9` Examples ```python # Iterative Approach print(binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 4)) # Output: 3 # Recursive Approach print(binary_search_recur([1, 2, 3, 4, 5, 6, 7, 8, 9], 0, 8, 4)) # Output: 3 ``` # Scenario You are tasked with building a real-time search feature for a large database. To ensure fast lookups, you must implement Binary Search which offers logarithmic time complexity. You should demonstrate your ability to handle both iterative and recursive search approaches effectively while considering edge cases and performance requirements.","solution":"def binary_search(array, query): Iteratively performs binary search on a sorted array to find the index of the query element. Parameters: array (list): A sorted list of integers. query (int): The integer value to search for. Returns: int: The index of the query element if found, otherwise None. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return None def binary_search_recur(array, low, high, val): Recursively performs binary search on a sorted array to find the index of the queried value. Parameters: array (list): A sorted list of integers. low (int): The lower index of the array subsection to search within. high (int): The upper index of the array subsection to search within. val (int): The integer value to search for. Returns: int: The index of the queried value if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: return binary_search_recur(array, mid + 1, high, val) else: return binary_search_recur(array, low, mid - 1, val)"},{"question":"# Question: Simplify Unix-style File Path You are given an absolute Unix-style path for a file. Your task is to simplify the path according to the Unix path resolution rules. **Example**: 1. For the path \\"/home/\\", the simplified path should be \\"/home\\". 2. For the path \\"/a/./b/../../c/\\", the simplified path should be \\"/c\\". Edge Cases: 1. The path \\"/../\\" should return \\"/\\". 2. The path \\"/home//foo/\\" should be simplified to \\"/home/foo\\". **Function Signature**: ```python def simplify_path(path: str) -> str: :param path: str - the Unix-style file path :return: str - the simplified file path * The function takes a single string `path` as input, which represents an absolute Unix-style file path. * It outputs the simplified file path as a string. **Constraints**: * The length of `path` will be at least 1 and at most 3000. * The path contains only ASCII characters and the characters `(\'a\'-\'z\', \'A\'-\'Z\', \'0\'-\'9\', \'/\', \'_\', \'.\')`. Your task is to implement the `simplify_path` function to correctly simplify the Unix-style file path as described above.","solution":"def simplify_path(path: str) -> str: Simplifies the given Unix-style path. :param path: str - the Unix-style file path :return: str - the simplified file path parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Finding Unique Element in Array Context: You are part of a development team tasked with improving the performance of data processing algorithms. A common problem involves finding a unique element in datasets where every other element appears exactly twice. Problem Statement: In a given array of integers, every element appears twice except for one. Your task is to implement a function that finds that single unique element. Function Signature: ```python def find_unique_element(nums: List[int]) -> int: ``` Input: - `nums` (List[int]): A non-empty list of integers where every element appears exactly twice except for one element which appears once. Output: - `int`: The unique element that appears only once in the array. Constraints: - You should implement the solution with a linear time complexity, O(n). - Do not use extra memory. Example: ```python >>> find_unique_element([4, 1, 2, 1, 2]) 4 >>> find_unique_element([2, 2, 1]) 1 >>> find_unique_element([7, 3, 5, 5, 3]) 7 ``` Notes: - The implementation should leverage the properties of the XOR bitwise operation, which cancels out pairs of numbers. - Focus on achieving the optimal time and space complexity as specified. Good luck!","solution":"from typing import List def find_unique_element(nums: List[int]) -> int: Finds the unique element in a list where every element appears twice except for one. Arguments: nums -- A list of integers where each integer except one occurs twice. Returns: The unique integer that appears only once. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"Diameter of a Binary Tree **Context**: Given a binary tree, you need to determine its diameter. The diameter of a binary tree is defined as the length of the longest path between any two nodes, which may or may not pass through the root. **Problem Statement**: Write a function `diameter_of_binary_tree(root: TreeNode) -> int` that, given the root of a binary tree, returns the diameter of the tree. **Input Format**: - `root`: The root node of the binary tree (an instance of `TreeNode` or `None`). **Output Format**: - Return an integer representing the diameter of the given binary tree. **Constraints**: - The number of nodes in the tree is in the range of `[0, 10^4]`. - The value of each node (`val`) is in the range `[0, 100]`. **Performance Requirements**: - Your solution should aim to traverse the tree in a single pass (O(n) time complexity). **Example**: ```python # Example Binary Tree # 1 # / # 2 3 # / # 4 5 # The diameter of this tree is 3 (path: 4 -> 2 -> 1 -> 3 or 5 -> 2 -> 1 -> 3). # Example Test Case tree = TreeNode(1) tree.left = TreeNode(2) tree.right = TreeNode(3) tree.left.left = TreeNode(4) tree.left.right = TreeNode(5) assert diameter_of_binary_tree(tree) == 3 # Edge Case tree = TreeNode(1) assert diameter_of_binary_tree(tree) == 0 ``` **Hints**: 1. Consider using recursion to determine the height of sub-trees and track the maximum diameter. 2. Develop a helper function that calculates both the height of a subtree and the diameter.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter_of_binary_tree(root): Returns the diameter of the binary tree with the given root. The diameter is the length of the longest path between any two nodes in the tree. def depth_and_diameter(node): if not node: return 0, 0 left_depth, left_diameter = depth_and_diameter(node.left) right_depth, right_diameter = depth_and_diameter(node.right) max_diameter = max(left_diameter, right_diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1, max_diameter _, diameter = depth_and_diameter(root) return diameter"},{"question":"**Task**: Implement a minimum-priority queue using a min-heap. **Scenario**: You are tasked with designing a system that assigns tasks to specific employees based on priority. Tasks with lower numeric values indicating higher importance should be processed first. # Requirements: 1. Implement a `MinHeap` class with the following methods: - `insert(item, priority)`: Inserts an item with an associated priority. - `extract_min()`: Extracts the item with the minimum priority. - `peek()`: Returns the item with the minimum priority without removing it. - `size()`: Returns the size of the heap. # Input and Output: - `insert(item, priority)` - **Input**: An `item` (string) and an associated `priority` (integer). - **Output**: None - `extract_min()` - **Input**: None - **Output**: The `item` (string) with the minimum priority. - `peek()` - **Input**: None - **Output**: The `item` (string) with the minimum priority. - `size()` - **Input**: None - **Output**: An integer representing the size of the heap. # Constraints: - Priorities will be unique integers. - You may assume that `extract_min` and `peek` will not be called on an empty heap. # Example: ```python heap = MinHeap() heap.insert(\\"task1\\", 5) heap.insert(\\"task2\\", 3) heap.insert(\\"task3\\", 9) print(heap.size()) # Output: 3 print(heap.peek()) # Output: \\"task2\\" print(heap.extract_min()) # Output: \\"task2\\" print(heap.size()) # Output: 2 print(heap.extract_min()) # Output: \\"task1\\" print(heap.extract_min()) # Output: \\"task3\\" ```","solution":"import heapq class MinHeap: def __init__(self): self._heap = [] def insert(self, item, priority): heapq.heappush(self._heap, (priority, item)) def extract_min(self): return heapq.heappop(self._heap)[1] def peek(self): return self._heap[0][1] def size(self): return len(self._heap)"},{"question":"You are given a stack represented as a list in Python, where the bottom of the stack is at index 0 and the top of the stack is the last element in the list. Your task is to write a function `third_switch_pairs` that switches successive pairs of numbers starting from the bottom of the stack. If there is an odd number of elements in the stack, the last element remains in its original position. # Function Signature ```python def third_switch_pairs(stack: list) -> list: ``` # Input * `stack` (list): A list of integers representing the stack, where the bottom of the stack is at index 0 and the top of the stack is the last element. # Output * Returns a list representing the stack after pairs of numbers have been switched. # Constraints * The input list can contain up to (10^5) integers. # Example Example 1 *Input*: `stack = [3, 8, 17, 9, 1, 10]` *Output*: `[8, 3, 9, 17, 10, 1]` Example 2 *Input*: `stack = [3, 8, 17, 9, 1]` *Output*: `[8, 3, 9, 17, 1]` Example 3 *Input*: `stack = [1]` *Output*: `[1]` # Explanation In the first example, `3` and `8` are switched, `17` and `9` are switched, and `1` and `10` are also switched. In the second example, `3` and `8` are switched, `17` and `9` are switched, but `1` stays in its position since there is an odd number of elements in the stack. # Requirements * Your solution should handle large stacks efficiently. * You should not use additional data structures other than another stack (list) or a deque (from the collections module).","solution":"def third_switch_pairs(stack: list) -> list: This function switches successive pairs of numbers in a stack starting from the bottom. If there is an odd number of elements in the stack, the last element remains in its original position. for i in range(0, len(stack) - 1, 2): stack[i], stack[i + 1] = stack[i + 1], stack[i] return stack"},{"question":"You are tasked with implementing a **Doubly Linked List** that maintains its elements in a sequence, allowing for dynamic insertions and deletions from both ends, as well as the interior of the list. The list should support the following operations efficiently: 1. **Insertion**: - **insert_at_front(value)**: Inserts a new node with the given value at the front of the list. - **insert_at_end(value)**: Inserts a new node with the given value at the end of the list. - **insert_after(node, value)**: Inserts a new node with the given value immediately after the provided node. 2. **Deletion**: - **delete_from_front()**: Removes the node at the front of the list. - **delete_from_end()**: Removes the node at the end of the list. - **delete_node(node)**: Removes the specified node from the list. 3. **Traversal**: - **get_values()**: Returns a list of all values present in the doubly linked list, following the sequence from front to end. # Implementation Details Write a class `DoublyLinkedList` and ensure your implementation covers the following aspects: - Define a `DoublyLinkedListNode` class for node representation. - Implement the doubly linked list operations for insertion, deletion, and traversal as specified. - Handle edge cases such as operations on an empty list and invalid node references. # Constraints - The list will hold up to 10^4 elements. - Values stored in the nodes will range between -10^6 to 10^6. - All node references for insertions and deletions will be valid existing nodes in the list. # Example Usage Below is an example of how your `DoublyLinkedList` class could be used: ```python dll = DoublyLinkedList() dll.insert_at_front(10) dll.insert_at_end(20) dll.insert_at_front(5) node = dll.insert_after(dll.head.next, 15) dll.delete_node(node) dll.delete_from_end() print(dll.get_values()) # Output should be [5, 10] ``` Ensure your code adheres to the specifications, passes all edge cases, and performs operations efficiently.","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_front(self, value): new_node = DoublyLinkedListNode(value) if not self.head: # If list is empty self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node return new_node def insert_at_end(self, value): new_node = DoublyLinkedListNode(value) if not self.tail: # If list is empty self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node return new_node def insert_after(self, node, value): if not node: return None new_node = DoublyLinkedListNode(value) new_node.prev = node new_node.next = node.next if node.next: node.next.prev = new_node else: self.tail = new_node # Update tail if new node is inserted at the end node.next = new_node return new_node def delete_from_front(self): if not self.head: # If list is empty return if self.head == self.tail: # If only one element self.head = self.tail = None else: self.head = self.head.next self.head.prev = None def delete_from_end(self): if not self.tail: # If list is empty return if self.tail == self.head: # If only one element self.tail = self.head = None else: self.tail = self.tail.prev self.tail.next = None def delete_node(self, node): if not node: return if node == self.head: self.delete_from_front() elif node == self.tail: self.delete_from_end() else: node.prev.next = node.next node.next.prev = node.prev def get_values(self): values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"A telecommunications company is developing a system to detect transmission errors in data packets. During transmission, a packet represented by an integer (A) can become another integer (B). To correct these errors, the system needs to determine the minimal number of bit flips required to convert (A) to (B). Write a function `count_flips_to_convert(a: int, b: int) -> int` to find the number of bits you need to flip to convert integer (A) to integer (B). # Function Signature ```python def count_flips_to_convert(a: int, b: int) -> int: ``` # Input * `a` - An integer representing the original data packet. * `b` - An integer representing the received data packet after transmission errors. # Output * Return an integer denoting the number of bits that must be flipped to transform `a` into `b`. # Constraints * The input integers can be positive, negative, or zero. * There is notably no theoretical limit on the size of integers for this problem, but in practical scenarios, assume integers fit within typical memory constraints. * Optimize for time and space efficiency. # Example 1. **Input**: `a = 29`, `b = 15` **Output**: `2` **Explanation**: Binary representation of 29 is `11101` and 15 is `01111`. Two flips are required to convert 29 to 15. 2. **Input**: `a = 1`, `b = 1` **Output**: `0` **Explanation**: Both values are the same, no flips required. 3. **Input**: `a = 0`, `b = -1` **Output**: `1` **Explanation**: Assuming a two\'s complement representation, flipping the least significant bit of 0 (binary `000...0000`) to 1 (binary `111...1111` for -1) would suffice. # Note Consider the edge cases where: - `a` and `b` are equal. - One or both input values are zero. - Input values are at the limits of integer representation. Write efficient and clean code, making sure to cover all edge cases.","solution":"def count_flips_to_convert(a: int, b: int) -> int: Calculate the number of bit flips required to convert integer A to integer B. Args: a (int): The original integer. b (int): The target integer after transmission errors. Returns: int: The number of bit flips required to convert A to B. xor_result = a ^ b return bin(xor_result).count(\'1\')"},{"question":"# Longest Common Substring Given two strings containing lowercase English alphabets, write a function to find the length of the longest common substring. A substring is a contiguous sequence of characters within a string. Input - `s1`: A string containing lowercase English alphabets (1 ≤ |s1| ≤ 1000). - `s2`: A string containing lowercase English alphabets (1 ≤ |s2| ≤ 1000). Output - Return an integer representing the length of the longest common substring. # Example ```python Input: s1 = \\"abcde\\" s2 = \\"abfce\\" Output: 2 ``` **Explanation**: The longest common substring is \\"ab\\" which has length 2. # Constraints - You may assume that the maximum length for each string does not exceed 1000. - The input strings are non-empty and consist solely of lowercase English alphabets. Function Signature ```python def longest_common_substring(s1: str, s2: str) -> int: pass ``` # Notes This question assesses: - **Understanding of dynamic programming concepts**. - **Skill in implementing efficient algorithms to solve common computational problems**. - **Ability to handle and optimize space complexity constraints**.","solution":"def longest_common_substring(s1: str, s2: str) -> int: Returns the length of the longest common substring between s1 and s2. m, n = len(s1), len(s2) # Initialize a 2D list to zero dp = [[0] * (n + 1) for _ in range(m + 1)] max_length = 0 # Build the dp table for i in range(1, m + 1): for j in range(1, n + 1): if s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 max_length = max(max_length, dp[i][j]) return max_length"},{"question":"Scenario You are part of a software development team working on a data processing application. One of the requirements of the application is to process input data lists such that any element in the list appears at most a fixed number of times N. The order of appearance of elements should be preserved. Task Write a function `limit_frequency(lst, n)` that takes a list of integers `lst` and an integer `n`, and returns a new list that contains each number in `lst` at most `n` times, without changing the order of elements. Input - `lst`: A list of integers where each integer can range from -10^6 to 10^6. - `n`: An integer representing the maximum number of occurrences for each element (0 ≤ N ≤ len(lst)). Output - Returns a list of integers with each element appearing at most `n` times, while maintaining their original order in `lst`. Constraints - The function should work efficiently for large inputs (up to 10^6 elements). Examples: 1. `limit_frequency([1, 2, 3, 1, 2, 1, 2, 3], 2)` should return `[1, 2, 3, 1, 2, 3]`. 2. `limit_frequency([4, 4, 4, 4], 1)` should return `[4]`. 3. `limit_frequency([], 3)` should return `[]`. 4. `limit_frequency([5, 5, 5, 5], 0)` should return `[]`. Note - Ensure your solution is optimal and avoids unnecessary computations. - Demonstrate your understanding by clearly commenting on the code and explaining edge cases.","solution":"def limit_frequency(lst, n): Returns a list where each element in the input list \'lst\' appears at most \'n\' times. The order of appearance of elements in the list is preserved. :param lst: List of integers. :param n: Maximum number of occurrences for each element. :return: List of integers with each element appearing at most \'n\' times. if n == 0: return [] from collections import defaultdict element_count = defaultdict(int) result = [] for elem in lst: if element_count[elem] < n: result.append(elem) element_count[elem] += 1 return result"},{"question":"Prime Number Checker Optimization **Objective**: You\'re developing a program that efficiently determines if a given number is prime. You\'ve been provided with a basic algorithm. Your task is to further optimize the solution and enhance its performance while ensuring accuracy. **Function Signature**: ```python def optimized_prime_check(n: int) -> bool: Return True if n is a prime number, else return False. ``` **Input**: - An integer `n` where ( n geq 1 ). **Output**: - Boolean `True` if `n` is a prime number, `False` otherwise. **Constraints**: 1. ( 1 leq n leq 10^{12} ) 2. Must operate in a reasonable time for large inputs. **Requirements**: 1. Reuse the core logic provided in the initial algorithm snippet. 2. Implement additional optimizations to check if `n` is prime. 3. Consider boundary conditions and edge cases. 4. Ensure the solution handles large ( n ) efficiently. **Hints**: 1. Review advanced algorithms like Miller-Rabin if you\'re looking to achieve probabilistic optimizations. 2. Consider additional modular arithmetic shortcuts where applicable. **Example**: ```python assert optimized_prime_check(1) == False assert optimized_prime_check(2) == True assert optimized_prime_check(3) == True assert optimized_prime_check(4) == False assert optimized_prime_check(29) == True assert optimized_prime_check(104729) == True assert optimized_prime_check(104730) == False ```","solution":"def optimized_prime_check(n: int) -> bool: Return True if n is a prime number, else return False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"# Problem: Merging Multiple Sorted Linked Lists You are provided with a list of `k` sorted linked lists. Your task is to merge these `k` sorted linked lists into one large sorted linked list and return its head. # Function Signature ```python def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode: pass ``` # Input - `lists`: A list of `k` linked lists, where each linked list is sorted in ascending order. Each linked list is represented by the head node of type `ListNode`. # Output - Return the head node of the merged sorted linked list. # Constraints - The total number of elements across all linked lists will not exceed 100,000. - The value of `k` will not exceed 1000. # Example ```python # Example to build linked lists and demonstrate merging lists = [ ListNode(1), ListNode(4), ListNode(5), ListNode(1), ListNode(3), ListNode(4), ListNode(2), ListNode(6) ] result = merge_k_sorted_lists(lists) # The output should be a sorted linked list containing all elements from the input. ``` # Performance Requirements - The solution must run in (O(n log k)) time complexity. - Auxiliary space used should be minimized, ideally (O(k)). # Scenario Imagine that you are managing multiple sorted data streams coming in from different sources, such as stock ticker updates from various exchanges. You need to merge these streams into one continuous sorted stream while maintaining the order of arrival of entries with the same value. Implementing this efficiently is crucial for ensuring real-time updates and minimal latency.","solution":"from typing import List import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[ListNode]) -> ListNode: # Dummy node to form the final merged list dummy = ListNode() current = dummy # Min-heap to keep track of the nodes heap = [] # Initialize the heap with the first node of each list for i, node in enumerate(lists): if node: heapq.heappush(heap, (node.val, i, node)) # Process the heap and build the resulting linked list while heap: val, i, node = heapq.heappop(heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"Problem Statement Given two strings `s` and `t`, write a function to determine if they are isomorphic. Two strings `s` and `t` are isomorphic if the characters in `s` can be replaced to get `t`. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself. Function Signature ```python def is_isomorphic(s: str, t: str) -> bool: ``` Input - `s` and `t`: Two strings of length n, where 0 <= n <= 10^4. Output - Returns `True` if the strings are isomorphic, `False` otherwise. Constraints - Characters are case sensitive, \'a\' and \'A\' are different characters. - Strings may include any printable ASCII characters. Example 1. **Example 1:** - Input: `s = \\"egg\\", t = \\"add\\"` - Output: `True` 2. **Example 2:** - Input: `s = \\"foo\\", t = \\"bar\\"` - Output: `False` 3. **Example 3:** - Input: `s = \\"paper\\", t = \\"title\\"` - Output: `True` Scenario Consider a scenario where you are building a simple encryption method where each character in a password should map uniquely to another character. Your task is to ensure that a user-defined mapping is valid by checking if two provided strings are isomorphic, maintaining encryption consistency. # Requirements 1. Your solution should be efficient with a time complexity of O(n). 2. Handle edge cases where one or both strings are empty. 3. Ensure that the method does not use excessive memory and maintains linear space complexity.","solution":"def is_isomorphic(s: str, t: str) -> bool: if len(s) != len(t): return False mapping_s_to_t = {} mapping_t_to_s = {} for char_s, char_t in zip(s, t): if char_s in mapping_s_to_t: if mapping_s_to_t[char_s] != char_t: return False else: mapping_s_to_t[char_s] = char_t if char_t in mapping_t_to_s: if mapping_t_to_s[char_t] != char_s: return False else: mapping_t_to_s[char_t] = char_s return True"},{"question":"# Coding Problem: Plagiarism Detection Using KMP Algorithm In this problem, you\'re required to implement a function that helps detect potential plagiarism in student submissions by finding instances of copied code snippets. Use the Knuth-Morris-Pratt (KMP) String Matching Algorithm to search for patterns within text files. Function Signature ```python def detect_plagiarism(submission: Sequence[str], snippet: Sequence[str]) -> List[int]: Args: submission: List of strings, where each string represents a line in the student\'s submission. snippet: List of strings, where each string represents a line in the code snippet to search for. Returns: List of integers representing the starting line numbers where the snippet is found in the submission. ``` Input * `submission`: A sequence of strings representing the submitted work, where each string is a line of the submission. * `snippet`: A sequence of strings representing the snippet of code being searched for, where each string is a line of the snippet. * Length constraints: * `1 <= len(submission) <= 10000` * `1 <= len(snippet) <= 1000` * `0 <= len(submission[i]) <= 500` * `0 <= len(snippet[i]) <= 500` Output * A list of integers indicating the starting line indices in the submission where the snippet matches. Each match should be reported as the index of the first line of the match. Constraints * For simplicity, assume all lines are treated as case-sensitive. * The match should handle multi-line snippets. * Leading or trailing white spaces in lines should be considered during matching. Example ```python submission = [ \\"def foo():\\", \\" print(\'hello world\')\\", \\" return 1\\", \\"\\", \\"foo()\\", \\"bar()\\" ] snippet = [ \\" print(\'hello world\')\\", \\" return 1\\" ] assert detect_plagiarism(submission, snippet) == [1] ``` Tips * Combine the lines of the submission and snippet into single strings with special line separators for easier processing. * Use the KMP algorithm to search for the combined snippet string within the combined submission string.","solution":"def calculate_lps(pattern): Calculate the Longest Prefix Suffix (LPS) array. lps = [0] * len(pattern) length = 0 i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def kmp_search(text, pattern): Perform KMP search of pattern in text. n = len(text) m = len(pattern) lps = calculate_lps(pattern) i = 0 j = 0 results = [] while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: results.append(i - j) # Append the index of the start of match j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return results def detect_plagiarism(submission, snippet): Detect plagiarism by finding all start positions of snippet in submission. if not submission or not snippet: return [] combined_submission = \'n\'.join(submission) combined_snippet = \'n\'.join(snippet) matches = kmp_search(combined_submission, combined_snippet) line_indices = [] for match_pos in matches: preceding_text = combined_submission[:match_pos] preceding_lines = preceding_text.split(\'n\') line_indices.append(len(preceding_lines)) return line_indices"},{"question":"# Coding Assessment: Efficient Word Storage and Search with Wildcards **Context:** You are tasked with designing a data structure to handle efficiently storing and searching words in a dynamic dataset. The words might contain wildcards represented by \\".\\", where \\".\\" can match any letter. This is particularly useful in applications such as search engines, autocomplete systems, and spell checkers. **Problem Statement:** Implement a class `AdvancedWordDictionary` with the following methods: 1. `add_word(word: str) -> None`: Adds a word to the data structure. 2. `search(word: str) -> bool`: Returns `True` if there is any word in the data structure that matches the given word (including wildcard matches), else returns `False`. You are expected to implement this with a space-efficient trie structure and consider edge cases and optimization scenarios discussed in the analysis section. **Input/Output Formats and Constraints:** - `word` is a non-empty string containing lowercase letters and \'.\'. - `add_word` will be called at most 10^4 times. - `search` will be called at most 10^4 times. - All words are of at most length 10. **Example:** ```plaintext add_word(\\"bad\\") add_word(\\"dad\\") add_word(\\"mad\\") assert search(\\"pad\\") == False assert search(\\"bad\\") == True assert search(\\".ad\\") == True assert search(\\"b..\\") == True ``` **Function Signatures:** ```python class AdvancedWordDictionary: def __init__(self): # Initialize your data structure here. pass def add_word(self, word: str) -> None: # Adds a word into the data structure. pass def search(self, word: str) -> bool: # Returns if the word is in the data structure. pass ```","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class AdvancedWordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node, index): if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children: if search_in_node(word, node.children[child], index + 1): return True return False else: if char in node.children: return search_in_node(word, node.children[char], index + 1) return False return search_in_node(word, self.root, 0)"},{"question":"You are assigned the task of implementing a function that reverses a string using recursion and iterative methods. This function should handle all edge cases gracefully. # Function Signature: ```python def reverse_string_recursive(s: str) -> str: # Implementation for reversing a string recursively pass def reverse_string_iterative(s: str) -> str: # Implementation for reversing a string iteratively pass ``` # Input: * A single string `s` (0 ≤ len(s) ≤ 10^6). # Output: * A single string which is the reversed version of the input string `s`. # Constraints: * The function should handle strings of length up to 1,000,000 efficiently. * You may assume that the input string consists of printable ASCII characters only. * Do not use any in-built Python functions for reversing the string directly (like `reversed()`, `s[::-1]`). # Performance Requirements: * Your solution should handle the worst-case scenario within a reasonable time (O(n) for the iterative solution and O(n log n) for the recursive solution). # Example: ```python assert reverse_string_recursive(\\"hello\\") == \\"olleh\\" assert reverse_string_iterative(\\"world\\") == \\"dlrow\\" assert reverse_string_recursive(\\"\\") == \\"\\" assert reverse_string_iterative(\\"a\\") == \\"a\\" ``` # Note: 1. The recursive solution should build the reversed string using a divide and conquer strategy. 2. The iterative solution should reverse the string using a two-pointer technique.","solution":"def reverse_string_recursive(s: str) -> str: Reverses a string recursively using divide and conquer strategy. if len(s) <= 1: return s mid = len(s) // 2 left = s[:mid] right = s[mid:] return reverse_string_recursive(right) + reverse_string_recursive(left) def reverse_string_iterative(s: str) -> str: Reverses a string iteratively using a two-pointer technique. chars = list(s) left, right = 0, len(chars) - 1 while left < right: chars[left], chars[right] = chars[right], chars[left] left += 1 right -= 1 return \'\'.join(chars)"},{"question":"Background You are a software developer responsible for implementing a verification system that ensures certain binary sequences meet a specific pattern: alternating bits. This entails confirming that each bit in the given integer follows the pattern 101010… or 010101… without breaking sequence. Task Write a function `check_alternating_bits(n: int) -> bool` that verifies if the binary representation of a positive integer `n` has alternating bits. Function Signature ```python def check_alternating_bits(n: int) -> bool: pass ``` Input - `n` (1 ≤ n ≤ 2^31 - 1): A positive integer. Output - Return `True` if the binary representation of `n` has alternating bits, otherwise `False`. Examples ```python check_alternating_bits(5) # Returns: True (binary 101) check_alternating_bits(7) # Returns: False (binary 111) check_alternating_bits(11) # Returns: False (binary 1011) check_alternating_bits(10) # Returns: True (binary 1010) ``` Constraints - Your solution should strive to be efficient in both time and space. - You might consider edge cases like smallest positive integers (1 and 0). - Avoid using language-specific functions that provide a binary representation shortcut. Notes - The solution should effectively address performance requirements. - You may use bitwise operations, logical expressions, and/or other relevant techniques to ensure optimal checking.","solution":"def check_alternating_bits(n: int) -> bool: Verifies if the binary representation of a positive integer n has alternating bits. current_bit = n & 1 # Get the last bit n = n >> 1 # Right shift to check the next bit while n > 0: next_bit = n & 1 # Get the next bit if current_bit == next_bit: return False current_bit = next_bit n = n >> 1 # Right shift to check the subsequent bit return True"},{"question":"You are required to implement a function that calculates the binomial coefficient in an optimized manner. The binomial coefficient ( C(n, k) ), also denoted as ( binom{n}{k} ), gives the number of ways to choose ( k ) elements from a set of ( n ) elements. # Input The function will receive two integers ( n ) and ( k ) such that ( n geq k geq 0 ). # Output The function should return an integer which is the value of the binomial coefficient ( C(n, k) ). # Constraints 1. ( 0 leq k leq n ) 2. ( n ) and ( k ) are non-negative integers. 3. The function should be optimized to handle large values of ( n ). Use techniques like memoization to avoid deep recursion and improve performance. # Function Signature ```python def optimized_binomial_coefficient(n: int, k: int) -> int: pass ``` # Example ```python print(optimized_binomial_coefficient(5, 0)) # Output: 1 print(optimized_binomial_coefficient(8, 2)) # Output: 28 print(optimized_binomial_coefficient(500, 300)) # Output: A very large number ``` # Additional Requirements 1. Consider edge cases like ( k = 0 ) triggering immediate base case returns. 2. Ensure any invalid inputs where ( n < k ) raise appropriate errors.","solution":"from math import comb def optimized_binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k) in an optimized manner using Python\'s built-in comb function. Args: n (int): The total number of items. k (int): The number of items to choose. Returns: int: The binomial coefficient. # Validate input if not (0 <= k <= n): raise ValueError(\\"Invalid inputs: k must be between 0 and n (inclusive).\\") return comb(n, k)"},{"question":"# Scenario: You are developing a filesystem for a Unix-based operating system that requires efficient path resolution. Implement a function that, given an absolute file path, returns its simplest form. # Function Definition ```python def simplify_path(path: str) -> str: Given an absolute path for a file (Unix-style), simplify it. :param path: A string representing an absolute path. :return: A string representing the simplified canonical path. ``` # Input and Output Format * **Input**: A single string `path` representing an absolute Unix file path. * **Output**: A single string which is the simplified canonical path. # Constraints and Limitations * The path string will always start with \'/\' indicating an absolute path. * The length of the input path string will not exceed 3000 characters. * The output should always start with \'/\'. # Example Cases ```python # Example 1 path = \\"/home/\\" # Output: \\"/home\\" # Example 2 path = \\"/a/./b/../../c/\\" # Output: \\"/c\\" # Example 3 path = \\"/../\\" # Output: \\"/\\" # Example 4 path = \\"/home//foo/\\" # Output: \\"/home/foo\\" ``` # Edge Cases to Consider * Paths such as \\"/../\\" should resolve to \\"/\\". * Paths containing multiple consecutive slashes should be treated as a single slash. * Input paths consisting purely of special components like \\".\\" and \\"..\\" but eventually reaching root. Implement your solution considering the performance and edge cases.","solution":"def simplify_path(path: str) -> str: Given an absolute path for a file (Unix-style), simplify it. :param path: A string representing an absolute path. :return: A string representing the simplified canonical path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'\' or part == \'.\': continue elif part == \'..\': if stack: stack.pop() else: stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Matrix Exponentiation Application in Computer Science Matrix exponentiation is frequently used in computer science, particularly in graph theory and dynamic programming. To ensure you understand the concept thoroughly, implement a function to calculate the n-th power of a given matrix. # Problem Statement: You are given a square matrix `mat` (a list of lists of integers) of size (d times d) and an integer `n`. Implement a function: ```python def matrix_exponentiation(mat: list, n: int) -> list: Returns the matrix mat raised to the power n. Parameters: mat (list): A square matrix of size d x d. n (int): The exponent to raise the matrix to. Returns: list: The resultant matrix after exponentiation. ``` # Example: ```python mat = [ [2, 0], [0, 2] ] n = 3 matrix_exponentiation(mat, n) # Output: [[8, 0], [0, 8]] ``` # Constraints: - The dimensions of the matrix (`d`) will be between 1 and 10 (inclusive). - The exponent (`n`) will be a non-negative integer ranging from 0 to 1000. - Elements of the matrix are integers ranging between (-100) and (100). # Requirements: - Implement matrix multiplication as a helper function. - Create an identity matrix as part of the implementation. - Use the method of repeated squaring to achieve efficient matrix exponentiation. - Ensure that the solution is optimized for both time- and space-efficiency given the constraints. **Note**: You are expected to write the complete function, including any helper methods that you may need for the matrix exponentiation process. Ensure you handle all relevant edge cases.","solution":"def matrix_multiply(A, B): Multiplies two matrices A and B. Parameters: A (list of lists): The first matrix. B (list of lists): The second matrix. Returns: list of lists: The resultant matrix after multiplication. d = len(A) result = [[0] * d for _ in range(d)] for i in range(d): for j in range(d): for k in range(d): result[i][j] += A[i][k] * B[k][j] return result def identity_matrix(size): Creates an identity matrix of the given size. Parameters: size (int): The size of the identity matrix. Returns: list of lists: The identity matrix. return [[1 if i == j else 0 for j in range(size)] for i in range(size)] def matrix_exponentiation(mat, n): Returns the matrix mat raised to the power n. Parameters: mat (list): A square matrix of size d x d. n (int): The exponent to raise the matrix to. Returns: list: The resultant matrix after exponentiation. if n == 0: return identity_matrix(len(mat)) elif n == 1: return mat half_power = matrix_exponentiation(mat, n // 2) half_power_squared = matrix_multiply(half_power, half_power) if n % 2 == 0: return half_power_squared else: return matrix_multiply(half_power_squared, mat)"},{"question":"# Coding Skill Assessment Question **Scenario**: A large population study requires the calculation of all possible ways to group a subset of people. In order to perform these calculations efficiently given a potentially large dataset, an optimized algorithm is necessary. **Question**: Write a Python function `calculate_combinations(n, r)` that returns the number of combinations of choosing `r` items from `n` items. Utilize memoization to optimize performance for large values of `n` and `r`. **Function Signature**: ```python def calculate_combinations(n: int, r: int) -> int: ``` **Input**: * `n` (integer): Total number of items. (0 ≤ n ≤ 1000) * `r` (integer): Number of items to choose. (0 ≤ r ≤ n) **Output**: * Returns an integer representing the number of ways to choose `r` items from `n` items. **Constraints**: * Avoid recalculating already computed combinations to save computation time. * The solution should be efficient and handle edge cases correctly. * Ensure valid inputs with `0 ≤ r ≤ n`. **Examples**: 1. `calculate_combinations(5, 2)` should return `10`. 2. `calculate_combinations(6, 3)` should return `20`. 3. `calculate_combinations(10, 0)` should return `1`. 4. `calculate_combinations(10, 10)` should return `1`. **Notes**: * Consider edge cases such as `calculate_combinations(0, 0)` or very large values of `n` and `r`. Write the function `calculate_combinations` to correctly implement this behavior, ensuring optimal performance through the use of memoization.","solution":"from functools import lru_cache @lru_cache(maxsize=None) def calculate_combinations(n: int, r: int) -> int: # Base cases if r == 0 or r == n: return 1 if r > n: return 0 # Recursive calculation with memoization return calculate_combinations(n-1, r-1) + calculate_combinations(n-1, r)"},{"question":"You are expected to implement a function that calculates the number of ways to choose \'r\' items from \'n\' items (nCr) using both recursive and iterative dynamic programming approaches. # Scenario Imagine you are designing a combinatorial calculator for a lottery system. You need to determine how many different ways players can select a subset of \'r\' numbers from a set of \'n\' total numbers. # Function Signature ```python def combination_recursive(n: int, r: int) -> int: pass def combination_iterative(n: int, r: int) -> int: pass ``` # Input - An integer `n` representing the total number of items. - An integer `r` representing the number of items to choose. # Output - An integer representing the number of combinations. # Constraints - 0 ≤ r ≤ n ≤ 1000 # Requirements 1. **Recursive Solution**: Implement the combination calculation using a recursive approach with memoization. 2. **Iterative Solution**: Implement the combination calculation using an iterative dynamic programming approach. # Example Example 1: Input: ```python combination_recursive(5, 2) ``` Output: ```python 10 ``` Explanation: There are 10 ways to choose 2 items from 5 items. Example 2: Input: ```python combination_iterative(5, 3) ``` Output: ```python 10 ``` Explanation: There are 10 ways to choose 3 items from 5 items. # Notes - You should ensure the solutions handle large inputs efficiently. - Pay attention to edge cases such as n = r, r = 0, or n = 0. - The iterative solution should be optimized for both time and space complexity.","solution":"def combination_recursive(n: int, r: int) -> int: memo = {} def comb(n, r): if r == 0 or r == n: return 1 if (n, r) in memo: return memo[(n, r)] memo[(n, r)] = comb(n-1, r-1) + comb(n-1, r) return memo[(n, r)] return comb(n, r) def combination_iterative(n: int, r: int) -> int: if r > n: return 0 C = [[0 for x in range(r+1)] for x in range(n+1)] for i in range(n+1): for j in range(min(i, r)+1): if j == 0 or j == i: C[i][j] = 1 else: C[i][j] = C[i-1][j-1] + C[i-1][j] return C[n][r]"},{"question":"You\'ve been hired by a logistics company to optimize their delivery routes. They have multiple stations represented in a matrix where each element `Matrix[i][j]` denotes the cost of moving from station `i` to station `j`. Costs are only meaningful for forward paths (i < j), and other entries are marked as -1 or Infinity (INF). Write a function `min_cost_path(cost_matrix: List[List[int]]) -> int` that calculates the minimum cost to travel from station `0` to the last station `N-1`. # Input - A 2D list `cost_matrix` where `cost_matrix[i][j]` (i < j) denotes the cost of moving from station `i` to station `j`. # Output - Return an integer, the minimum cost to reach from station `0` to station `N-1`. # Constraints - The number of stations, N, will be between 2 and 1000. - Each cost value will be an integer between 1 and 1000, or -1 to indicate an invalid path. - All i > j cases in the matrix will be -1 or INF. # Example ```python cost_matrix = [ [0, 15, 80, 90], [-1, 0, 40, 50], [-1, -1, 0, 70], [-1, -1, -1, 0] ] assert min_cost_path(cost_matrix) == 65 ``` The function should output `65` as the minimum cost to reach from station 0 to station N-1. # Explanation The minimum cost path is 0 -> 1 -> 3, with total cost 15 (0 to 1) + 50 (1 to 3) = 65.","solution":"from typing import List def min_cost_path(cost_matrix: List[List[int]]) -> int: Returns the minimum cost to travel from station 0 to station N-1. n = len(cost_matrix) # This will hold the minimum cost to reach each station from the first station min_cost = [float(\'inf\')] * n min_cost[0] = 0 # Cost to reach the first station is 0 for i in range(n): for j in range(i + 1, n): if cost_matrix[i][j] != -1 and cost_matrix[i][j] != float(\'inf\'): if min_cost[i] != float(\'inf\'): min_cost[j] = min(min_cost[j], min_cost[i] + cost_matrix[i][j]) return min_cost[-1]"},{"question":"# Atbash Cipher Implementation Challenge Problem Statement You are tasked with implementing the Atbash cipher, which is a simple substitution cipher created by reversing the alphabet. Given an input string, your function should return the encrypted string using the Atbash cipher rules. Function Signature `def atbash(s: str) -> str:` Input * A single string `s` that consists of printable ASCII characters. The length of the string is `1 <= len(s) <= 10^3`. Output * A single string - the encrypted version of the input string where each alphabet letter is replaced by its corresponding letter in the reversed alphabet. All non-alphabet characters should remain unchanged. Constraints * The input string `s` can include upper-case and lower-case English letters, numbers, spaces, and punctuation. * Remember to preserve the case for alphabetic characters. Examples 1. **Input**: `\\"Attack at dawn\\"` **Output**: `\\"Zggzxp zg wzdm\\"` 2. **Input**: `\\"Hello, World!\\"` **Output**: `\\"Svool, Dliow!\\"` 3. **Input**: `\\"abcXYZ\\"` **Output**: `\\"zyxCBA\\"` # Notes - Upper-case letters map to other upper-case letters, and lower-case letters map to other lower-case letters. - Punctuation, spaces, and numbers should remain the same without any substitution.","solution":"def atbash(s: str) -> str: Implement the Atbash cipher which is a substitution cipher reversing the alphabet. def atbash_char(c): if \'a\' <= c <= \'z\': return chr(122 - (ord(c) - 97)) # 122 is ord(\'z\'), 97 is ord(\'a\') if \'A\' <= c <= \'Z\': return chr(90 - (ord(c) - 65)) # 90 is ord(\'Z\'), 65 is ord(\'A\') return c return \'\'.join(atbash_char(c) for c in s)"},{"question":"# Problem Scenario The filing system for a large historical archive uses Roman numerals to label the files. You have been tasked with writing a function that converts numeric file identifiers into their respective Roman numeral labels. To ensure efficient processing, this function must handle integers within the range of 1 to 3999. Problem Statement Write a function `int_to_roman(num)` that converts an integer to its Roman numeral representation. The input integer will be within the range from 1 to 3999 inclusive. Function Signature ```python def int_to_roman(num: int) -> str: ``` Input - A single integer `num`, where (1 leq num leq 3999). Output - Returns a string that represents the Roman numeral of the provided integer. # Constraints - The function should have a time complexity of O(1). - The function should have a space complexity of O(1). # Example ```python print(int_to_roman(58)) # Output: \'LVIII\' print(int_to_roman(1994)) # Output: \'MCMXCIV\' ``` Consider the following: - `int_to_roman(1)` should return `\'I\'` - `int_to_roman(3999)` should return `\'MMMCMXCIX\'` You may use static predefined mappings of numeral strings for each digit place (thousands, hundreds, tens, and units) as part of your solution as outlined.","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. :param num: int - The integer to be converted to a Roman numeral (1 <= num <= 3999). :return: str - The Roman numeral representation of the input integer. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: num -= val[i] roman_numeral += syms[i] return roman_numeral"},{"question":"# Unique Character String **Objective**: Write a function that takes a string as input and returns a new string after removing all reoccurring characters. The order of first appearances should be preserved. **Function Signature**: ```python def unique_characters_string(s: str) -> str: pass ``` **Input**: * `s` (string): A string potentially containing reoccurring characters. (0 <= len(s) <= 10^6) **Output**: * (string): A new string with all reoccurring characters removed, preserving the order of their first appearances. **Constraints**: * The input string will only contain ASCII characters. * Case-sensitive: \'a\' and \'A\' are different characters. **Examples**: ```python assert unique_characters_string(\\"google\\") == \\"gole\\" assert unique_characters_string(\\"programming\\") == \\"progamin\\" assert unique_characters_string(\\"aabbcc\\") == \\"abc\\" assert unique_characters_string(\\"\\") == \\"\\" ``` **Instructions**: 1. Ensure efficiency with large input sizes. 2. Address edge cases mentioned, such as empty strings and strings with no repeating characters. 3. Optimize the string concatenation process to mitigate potential performance issues.","solution":"def unique_characters_string(s: str) -> str: Takes a string as input and returns a new string after removing all reoccurring characters. The order of first appearances is preserved. :param s: Input string :return: String with all reoccurring characters removed seen = set() unique_chars = [] for char in s: if char not in seen: seen.add(char) unique_chars.append(char) return \'\'.join(unique_chars)"},{"question":"# Question: Implement Optimized Bitonic Sort **Scenario**: You are working on optimizing the sorting algorithm for a large distributed data processing system where data volumes are immense and require efficient, scalable solutions. Given the constraints of the system, your implementation should be capable of handling large datasets by leveraging parallel processing. **Objective**: Modify the provided bitonic sort algorithm to use in-place sorting to minimize memory usage and optimize performance. Consider both parallel and non-parallel computing environments. **Task**: Implement the in-place version of the `bitonic_sort` function to minimize additional space complexity. The input list size will still be a power of 2, and the function should support sorting in both ascending and descending order. **Function Signature**: ```python def bitonic_sort(arr, reverse=False): ``` **Parameters**: * `arr` (List[int]): An array of integers to be sorted, with size being a power of 2. * `reverse` (bool): If True, sort in ascending order; if False, sort in descending order. Default is False. **Returns**: * List[int]: A new list with the elements sorted. **Constraints**: * `1 <= len(arr) <= 10^6` * Size of `arr` is always a power of 2. * Your implementation should not use additional space proportionate to the input size. **Examples**: ```python # Example 1: arr = [8, 3, 2, 7, 4, 6, 1, 5] sorted_arr = bitonic_sort(arr, reverse=False) # Sorting in ascending order print(sorted_arr) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # Example 2: arr = [8, 3, 2, 7, 4, 6, 1, 5] sorted_arr = bitonic_sort(arr, reverse=True) # Sorting in descending order print(sorted_arr) # Output: [8, 7, 6, 5, 4, 3, 2, 1] ```","solution":"def bitonic_sort(arr, reverse=False): def compare_and_swap(a, b, direction): if (arr[a] > arr[b]) == direction: arr[a], arr[b] = arr[b], arr[a] def bitonic_merge(low, cnt, direction): if cnt > 1: k = cnt // 2 for i in range(low, low + k): compare_and_swap(i, i + k, direction) bitonic_merge(low, k, direction) bitonic_merge(low + k, k, direction) def bitonic_sort_recursive(low, cnt, direction): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(low, k, True) bitonic_sort_recursive(low + k, k, False) bitonic_merge(low, cnt, direction) # Start the bitonic sort bitonic_sort_recursive(0, len(arr), not reverse) return arr"},{"question":"As a web developer, you need a utility function that constructs URLs by joining base URLs with different endpoint paths. Given that URLs and filesystem paths share a similar structure with slashes as dividers, your task is to improve the given function to handle additional scenarios, including edge cases and performance improvements. Function Signature ```python def robust_join_with_slash(base: str, suffix: str) -> str: pass ``` # Input - **base**: A string representing the base URL or file path (0 <= len(base) <= 1000). - **suffix**: A string representing the endpoint or filename to attach to the base (0 <= len(suffix) <= 1000). # Output - A string representing the concatenated full path with appropriate slashes. # Constraints - The function should handle empty strings for either `base` or `suffix`. - Either `base` or `suffix` or both can contain extra slashes which need to be removed appropriately. - Whitespaces surrounding the paths should be trimmed. - If both `base` and `suffix` are empty, return an empty string. # Example Example 1 ```python base = \\"http://example.com/\\" suffix = \\"/products\\" output = \\"http://example.com/products\\" ``` Example 2 ```python base = \\"/path/to/dir/\\" suffix = \\"file.txt\\" output = \\"/path/to/dir/file.txt\\" ``` Example 3 ```python base = \\"\\" suffix = \\"file\\" output = \\"file\\" ``` Example 4 ```python base = \\"http://example.com\\" suffix = \\"\\" output = \\"http://example.com\\" ``` # Performance Requirements Your solution should efficiently handle the input sizes up to the specified limits.","solution":"def robust_join_with_slash(base: str, suffix: str) -> str: Concatenates a base URL or file path with a suffix ensuring proper slashes are added/removed appropriately. # Strip any whitespace base = base.strip() suffix = suffix.strip() # Handle cases where either base or suffix is empty if not base and not suffix: return \\"\\" if not base: return suffix.lstrip(\'/\') if not suffix: return base.rstrip(\'/\') # Removing the trailing slash from base and leading slash from suffix return base.rstrip(\'/\') + \'/\' + suffix.lstrip(\'/\')"},{"question":"Problem Statement You are living in an apartment in a complex, and there are `steps` number of stairs leading to your floor. Each time you climb the stairs, you can either take 1 step or 2 steps. Write a function that determines the number of unique ways to reach your floor from the ground level. # Function Signature ```python def count_ways_to_climb(steps: int) -> int: pass ``` # Input - An integer `steps` (1 ≤ steps ≤ 10,000): the total number of steps. - You can assume `steps` will always be a positive integer. # Output - Return an integer representing the number of distinct ways to climb to the top of the stairs. # Constraints - The solution should be optimized for both time and space complexity. # Example ```python count_ways_to_climb(3) ``` **Output**: ```python 3 ``` Explanation: There are three ways to climb to step 3: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step # Implementation Notes - Use dynamic programming or the Fibonacci sequence relation to solve this problem. - Consider edge cases such as `steps = 1` or `steps = 2`. # Performance Requirements The function should run in O(n) time complexity and aim for O(1) space complexity.","solution":"def count_ways_to_climb(steps: int) -> int: Returns the number of unique ways to climb given number of steps, taking 1 or 2 steps at a time. if steps <= 0: return 0 if steps == 1: return 1 if steps == 2: return 2 # Initialize the variables for DP calculations # ways(n-2) and ways(n-1) prev2 = 1 prev1 = 2 # Compute the ways for steps > 2 using iterative approach for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Path Simplification Coding Challenge Problem Statement You are given an absolute path for a file (Unix-style) as a string. Your task is to simplify the path. Simplification Rules: 1. Any number of consecutive slashes (\'/\') are treated as a single slash. 2. A single dot (\'.\') means stay in the current directory, which can be ignored. 3. A double dot (\'..\') means go up to the parent directory. 4. Ensure the simplified path starts with a slash (\'/\') and does not end with an extra slash unless it\'s the root \'/\'. Examples * Input: \\"/home/\\" * Output: \\"/home\\" * Input: \\"/a/./b/../../c/\\" * Output: \\"/c\\" * Input: \\"/../\\" * Output: \\"/\\" * Input: \\"/home//foo/\\" * Output: \\"/home/foo\\" Function Signature ```python def simplify_path(path: str) -> str: pass ``` Constraints - The input path will not contain any invalid characters. - It is guaranteed to start with a \'/\'. Notes - Your implementation should have a time complexity of O(N) and a space complexity of O(N), where N is the length of the input path.","solution":"def simplify_path(path: str) -> str: Simplify the given Unix-style file path. Args: path : str : absolute path in Unix-style Returns: str : simplified path stack = [] # Split the path by \'/\' parts = path.split(\'/\') for part in parts: # If part is \'..\' then go to the parent directory if part == \'..\': if stack: stack.pop() # If part is \'.\' or empty, do nothing elif part == \'.\' or not part: continue # Otherwise add the part to the stack else: stack.append(part) # Join all parts in the stack with \'/\' simplified_path = \'/\' + \'/\'.join(stack) return simplified_path"},{"question":"# Context and Scenario Comb Sort is a relatively simple and enjoyable sorting algorithm that enhances Bubble Sort\'s efficiency by initially comparing elements that are a specific distance apart (gap). The idea is to quickly eliminate large discrepancies, then progressively reduce the gap until it eventually becomes 1, reducing the algorithm to a bubble sort. # Problem Statement Implement the Comb Sort algorithm to sort an array of integers in ascending order. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` # Input * A list of integers `arr` with `1 <= len(arr) <= 10^5` # Output * Return the sorted list of integers in ascending order. # Constraints - You should use the Comb Sort algorithm. - Your solution should be in-place, modifying the original list. - Optimize for time complexity, but ensure correctness first. # Performance requirements - Aim for the average and best-case time complexity of O(N log N). - Handle edge cases efficiently. # Example ```python assert comb_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert comb_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert comb_sort([10, -1, 3, 4, 5, 7, -10]) == [-10, -1, 3, 4, 5, 7, 10] assert comb_sort([2]) == [2] ``` # Edge cases to consider - An already sorted array - An array with all elements being identical - Small arrays with 1-2 elements","solution":"def comb_sort(arr): Sort the array using the comb sort algorithm and return the sorted list. :param arr: List[int] -> A list of integers to be sorted :return: List[int] -> The sorted list def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"Given a string as input, write a function `delete_reoccurring_characters` that deletes any reoccurring character, retaining only the first occurrence of each character in the original order, and returns the new string. The function should be efficient in both time and space complexity. Constraints - The input string will only contain ASCII characters. - The input string length will be at most (10^5). # Input - A single string `s` composed of ASCII characters. # Output - A string with all reoccurring characters removed, maintaining the order of first occurrences from the input string. # Examples ```python delete_reoccurring_characters(\\"hello\\") # Output: \\"helo\\" delete_reoccurring_characters(\\"programming\\") # Output: \\"progamin\\" ``` # Notes - Consider edge cases such as empty strings or strings where all characters are the same. - Ensure to efficiently handle the checks and string manipulations.","solution":"def delete_reoccurring_characters(s): Deletes any reoccurring character, retaining only the first occurrence of each character in the original order. :param s: Input string composed of ASCII characters :return: A string with all reoccurring characters removed, maintaining the order of first occurrences seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Bogo Sort Deep Dive and Alternative **Scenario**: You are given a list of integers and asked to sort the list using the Bogo Sort algorithm. Given its inefficiency, you are also needed to compare its performance (in terms of steps) with a classical sorting algorithm like Quick Sort. **Task**: 1. **Implement `bogo_sort`**: - Ensure it behaves as described, either endlessly shuffling or quickly finding a permutation that sorts the list. 2. **Implement `quick_sort`**: - A well-known efficient sorting algorithm, typically implemented using divide and conquer method. 3. **Analyze Performance**: - Write a function `compare_sort_performance(arr)` that: * Takes an array as input. * Sorts the array using both Bogo Sort and Quick Sort. * Records and returns the number of steps (iterations) Bogo Sort took to sort the array and compares it to Quick Sort steps. **Input Format**: * List of integers `[int, int, ..., int]`. **Output Format**: * A tuple `(bogo_steps, quick_steps)` where: * `bogo_steps` is the number of iterations it took for Bogo Sort to sort the list. * `quick_steps` is an equivalent step counter or another metric (like recursive calls) for Quick Sort. **Constraints**: * Assume list length `n` such that `1 <= n <= 10` for practical execution constraints during tests. **Function Signatures**: ```python def bogo_sort(arr: List[int], simulation: bool = False) -> List[int]: pass def quick_sort(arr: List[int]) -> List[int]: pass def compare_sort_performance(arr: List[int]) -> Tuple[int, int]: pass ``` **Additional Information**: - In Quick Sort, steps can be counted as the number of recursive calls or partitioning steps needed. - Make sure to handle edge cases like an already sorted array and an array with all elements the same.","solution":"import random from typing import List, Tuple def is_sorted(arr: List[int]) -> bool: Helper function to check if the list is sorted. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort(arr: List[int], simulation: bool = False) -> Tuple[List[int], int]: Sorts the array using Bogo Sort algorithm and returns the number of iterations. :param arr: The list of integers to sort. :param simulation: A boolean indicating if we want to count the iterations for comparison. :return: A tuple with the sorted list and number of iterations. steps = 0 while not is_sorted(arr): random.shuffle(arr) steps += 1 return (arr, steps) if simulation else arr def partition(arr: List[int], low: int, high: int) -> int: Helper function to partition the array. pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_recursive(arr: List[int], low: int, high: int, step_counter: List[int]): Recursive helper function for Quick Sort that counts steps. if low < high: pivot_index = partition(arr, low, high) step_counter[0] += 1 quick_sort_recursive(arr, low, pivot_index - 1, step_counter) quick_sort_recursive(arr, pivot_index + 1, high, step_counter) def quick_sort(arr: List[int]) -> Tuple[List[int], int]: Sorts the array using Quick Sort algorithm. :param arr: The list of integers to sort. :return: A tuple with sorted list and number of recursive calls. step_counter = [0] # To count the recursive calls quick_sort_recursive(arr, 0, len(arr) - 1, step_counter) return arr, step_counter[0] def compare_sort_performance(arr: List[int]) -> Tuple[int, int]: Compares the performance of Bogo Sort and Quick Sort. :param arr: The list of integers to sort. :return: A tuple containing the number of steps for Bogo Sort and Quick Sort. # Copy the array to avoid in-place sorting affecting other sorts bogo_arr = arr[:] quick_arr = arr[:] _, bogo_steps = bogo_sort(bogo_arr, simulation=True) _, quick_steps = quick_sort(quick_arr) return bogo_steps, quick_steps"},{"question":"# Question: Implement Iterative Merge Sort You are required to implement an iterative version of the merge sort algorithm. The algorithm should sort an array of integers in non-decreasing order. Your implementation should follow the merge sort principles but avoid the recursive approach to reduce the overhead of recursive calls. Function Signature ```python def iterative_merge_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers (0 <= len(arr) <= 10^5) Output - A list of integers sorted in non-decreasing order. Constraints - You cannot use built-in sort functions. - Aim to maintain time complexity of O(n log n) and try to optimize for space complexity where possible. Example ```python assert iterative_merge_sort([38, 27, 43, 3, 9, 82, 10]) == [3, 9, 10, 27, 38, 43, 82] assert iterative_merge_sort([5, 3, 8, 6, 2]) == [2, 3, 5, 6, 8] assert iterative_merge_sort([]) == [] assert iterative_merge_sort([1]) == [1] ``` Additional Information - Consider using iterative merging instead of recursion. - Test your implementation with different edge cases like empty arrays and arrays with minimal elements. - Ensure that your implementation works efficiently for larger datasets within the given constraints.","solution":"from typing import List def iterative_merge_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr width = 1 n = len(arr) def merge(left, right): merged = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: merged.append(left[i]) i += 1 else: merged.append(right[j]) j += 1 merged.extend(left[i:]) merged.extend(right[j:]) return merged while width < n: for i in range(0, n, 2 * width): left = arr[i:i + width] right = arr[i + width:i + 2 * width] arr[i:i + 2 * width] = merge(left, right) width *= 2 return arr"},{"question":"# Matrix Inversion Task The task is to write a function `invert_matrix` that calculates the inverse of a given n x n matrix. You may use helper functions to break down the problem into manageable steps. Input - A 2D list `matrix` representing an `n x n` matrix of integers or floats. Output - A 2D list representing the inverse of the matrix if it exists. - If the matrix is non-square, singular, or too small (0x0 or 1x1), the function should return specific error matrices: - Non-square matrix: [[-2]] - Singular matrix: [[-4]] - Too small: [[-3]] - Not a matrix: [[-1]] Constraints - The size of the matrix (n) will be in the range [2, 10] for the input. - Each element of the matrix will be an integer or float within the range [-10^3, 10^3]. Example ```python def invert_matrix(matrix: List[List[float]]) -> List[List[float]]: # Your implementation here pass # Example: matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output: [[0.6, -0.7], [-0.2, 0.4]] ``` Explanation: - For a 2x2 example provided, the inverse is calculated using the formula for the inverse of a 2x2 matrix: - The matrix inversion should handle edge cases as described and error handling properly. - Your solution should aim for readability, as performance constraints are manageable within the given range.","solution":"import numpy as np def invert_matrix(matrix): # Check if input is not a list or is empty if not isinstance(matrix, list) or len(matrix) == 0: return [[-1]] n = len(matrix) # Check if input is non-square or too small if n < 2: return [[-3]] if not all(len(row) == n for row in matrix): return [[-2]] try: # Using numpy to calculate the inverse inv_matrix = np.linalg.inv(matrix) return inv_matrix.tolist() except np.linalg.LinAlgError: # Handle singular matrix case return [[-4]]"},{"question":"# Coding Task: Design an Efficient Word Search Data Structure Objective: You are required to implement the `WordDictionary` class, which supports adding words and searching them. The search mechanism should support literal words and words containing the wildcard character `\'.\'`, which can represent any letter. Class Design: Implement the following methods in the `WordDictionary` class: 1. **add_word(word: str) -> None**: - Adds a new word to the data structure. - Example: `WordDictionary.add_word(\\"hello\\")` 2. **search(word: str) -> bool**: - Searches for a word in the data structure. A word could contain the dot character `\'.\'` which can represent any letter. - Example: `WordDictionary.search(\\"h.llo\\")` can match with \\"hello\\". Implementation Constraints: - Optimize for both time and space complexity. - Consider multiple wildcards and long strings while constructing the search logic. - Efficiently handle memory usage. Expected Function Signature: ```python class WordDictionary: def __init__(self): # Initialize the data structure here. pass def add_word(self, word: str) -> None: # Adds a word into the data structure. pass def search(self, word: str) -> bool: # Returns if the word is in the data structure. # A word could contain the dot character \'.\' to represent any letter. pass ``` # Example Usage: ```python # Initialize data structure word_dict = WordDictionary() # Adding words word_dict.add_word(\\"bad\\") word_dict.add_word(\\"dad\\") word_dict.add_word(\\"mad\\") # Searching words print(word_dict.search(\\"pad\\")) # returns False print(word_dict.search(\\"bad\\")) # returns True print(word_dict.search(\\".ad\\")) # returns True print(word_dict.search(\\"b..\\")) # returns True ``` Performance Requirements: Ensure that your implementation performs well with the following constraints: - Number of words added to the data structure will not exceed 10⁴. - Length of each word will not exceed 50.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class WordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: def search_in_node(word, node): for i, char in enumerate(word): if char == \'.\': for child in node.children.values(): if search_in_node(word[i+1:], child): return True return False else: if char not in node.children: return False node = node.children[char] return node.is_end_of_word return search_in_node(word, self.root)"},{"question":"# Context: You are tasked with designing a random sampling system for a scientific study that involves dynamically changing participant sets. Participants can join, leave, and be randomly selected for experimental tasks, all in real-time. # Problem Statement: Implement a data structure `RandomizedSet` that supports the following operations: - `insert(val: int) -> bool`: Inserts a participant `val` to the set if not already present. Returns `True` if the participant was successfully added, `False` otherwise. - `remove(val: int) -> bool`: Removes a participant `val` from the set if present. Returns `True` if the participant was successfully removed, `False` otherwise. - `random_element() -> int`: Returns a randomly selected participant from the current set with equal probability. # Constraints: - Each participant is represented by a unique integer. - All operations must have an average time complexity of O(1). # Implementation Requirements: - You must use a combination of list and dictionary to achieve the desired time complexities. - Handle necessary edge cases (e.g., empty set in `random_element`). - Maintain consistency between the list and dictionary at all times. # Function Signatures: ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> bool: pass def remove(self, val: int) -> bool: pass def random_element(self) -> int: pass ``` # Example Usage: ```python rset = RandomizedSet() print(rset.insert(1)) # True print(rset.insert(2)) # True print(rset.insert(1)) # False print(rset.remove(1)) # True print(rset.remove(3)) # False print(rset.random_element()) # 2 (with probability 1.0 since it\'s the only element) ``` Implement the `RandomizedSet` class according to the requirements above. Ensure thorough testing of your implementation, focusing on edge cases and constraint adherence.","solution":"import random class RandomizedSet: def __init__(self): self.val_to_index = {} self.values = [] def insert(self, val: int) -> bool: if val in self.val_to_index: return False self.val_to_index[val] = len(self.values) self.values.append(val) return True def remove(self, val: int) -> bool: if val not in self.val_to_index: return False # Move the last element to the place of the element to delete last_element = self.values[-1] idx_to_remove = self.val_to_index[val] self.values[idx_to_remove] = last_element self.val_to_index[last_element] = idx_to_remove # Remove the last element self.values.pop() del self.val_to_index[val] return True def random_element(self) -> int: if not self.values: raise IndexError(\\"random_element() cannot be called on an empty set\\") return random.choice(self.values)"},{"question":"You are tasked with writing a function that calculates the number of digits in the integer representation of several numbers, coming from a variety of sources such as user input, file read, or list of numbers. The function should handle both positive and negative numbers, as well as zero. Function Signature ```python def count_digits_in_list(numbers): Function to count digits for each number in the provided list. Parameters: numbers (List[int]): A list of integers. Returns: List[int]: A list containing the number of digits for the corresponding input integers. ``` Input * `numbers` - a list of integers where each integer `n` satisfies the constraint `-10^18 <= n <= 10^18` * Example: `[123, -456, 0, 78910]` Output * Returns a list of integers, each representing the number of digits in the corresponding input integer. * For the example above, expected output: `[3, 3, 1, 5]` Constraints * The input list may contain up to `10^5` elements. * Each integer is bounded between `-10^18` and `10^18`. Performance Requirements * The solution should handle the maximum constraint efficiently. # Requirements * Implement the function `count_digits_in_list(numbers)`. * Ensure your implementation handles all edge cases as discussed in the analysis. * Avoid using string conversion methods to determine the number of digits. Scenario Your function is to be integrated into a larger system that processes large datasets. Hence, it needs to be efficient and handle edge cases robustly. Example ```python assert count_digits_in_list([123, -456, 0, 78910]) == [3, 3, 1, 5] assert count_digits_in_list([20, 300, -4000, -50000, 0]) == [2, 3, 4, 5, 1] ```","solution":"def count_digits_in_list(numbers): Function to count digits for each number in the provided list. Parameters: numbers (list of int): A list of integers. Returns: list of int: A list containing the number of digits for the corresponding input integers. def count_digits(num): if num == 0: return 1 num = abs(num) count = 0 while num > 0: num //= 10 count += 1 return count return [count_digits(num) for num in numbers]"},{"question":"You are tasked with finding the maximum flow in a flow network represented by an adjacency matrix. The graph will have non-negative, integer capacities. **Function Signature:** ```python def maximum_flow(adjacency_matrix: List[List[int]]) -> int: pass ``` # Input - `adjacency_matrix`: A square matrix representing the flow capacities between the nodes in the graph. `adjacency_matrix[i][j]` represents the capacity of the edge from node `i` to node `j`. # Output - Returns the maximum possible flow from the source node (node `0`) to the sink node (last node `n-1`). # Example ```python graph = [ [0, 16, 13, 0, 0, 0], [0, 0, 10, 12, 0, 0], [0, 4, 0, 0, 14, 0], [0, 0, 9, 0, 0, 20], [0, 0, 0, 7, 0, 4], [0, 0, 0, 0, 0, 0] ] assert maximum_flow(graph) == 23 ``` # Constraints - The matrix will always be a square matrix (n times n) where (1 leq n leq 50). - All capacities will be non-negative integers not exceeding (1000). - The network will always have at least one path from the source to the sink. # Performance Requirements - The solution must efficiently compute maximum flow leveraging BFS or DFS principles. # Notes - Consider edge cases with sparse graphs or graphs with large variations in capacity values. - Ensure the implementation is robust against different types of input within constraints.","solution":"from typing import List from collections import deque def bfs(residual_graph: List[List[int]], parent: List[int]) -> bool: A breadth-first search to find an augmenting path in the residual graph. Updates the parent list to store the found path. n = len(residual_graph) visited = [False] * n queue = deque([0]) visited[0] = True while queue: current_node = queue.popleft() for neighbor, capacity in enumerate(residual_graph[current_node]): if not visited[neighbor] and capacity > 0: parent[neighbor] = current_node visited[neighbor] = True queue.append(neighbor) if neighbor == n - 1: # If we have reached the sink return True return False def maximum_flow(adjacency_matrix: List[List[int]]) -> int: n = len(adjacency_matrix) residual_graph = [row[:] for row in adjacency_matrix] parent = [-1] * n max_flow = 0 while bfs(residual_graph, parent): # Find the maximum flow through the path found by BFS path_flow = float(\'Inf\') s = n - 1 while s != 0: path_flow = min(path_flow, residual_graph[parent[s]][s]) s = parent[s] # update residual capacities of the edges and reverse edges along the path v = n - 1 while v != 0: u = parent[v] residual_graph[u][v] -= path_flow residual_graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"# Question Imagine you are implementing a playlist manager in a music streaming application. You are required to design a class implementing a doubly linked list to handle typical playlist operations. Your task is to provide functionality for adding songs, removing songs, and displaying the playlist from both directions (start to end and end to start). Requirements: 1. **Class Design**: - Implement a `DoublyLinkedListNode` class to represent each node in the list. - Implement a `DoublyLinkedList` class to manage the playlist. 2. **Functions to Implement**: - `add_song(name: str) -> None`: - Adds a song with the given name at the end of the playlist. - `remove_song(name: str) -> None`: - Removes the first occurrence of the song with the given name from the playlist. If the song is not found, do nothing. - `display_forward() -> List[str]`: - Returns a list of song names from the start to the end of the playlist. - `display_backward() -> List[str]`: - Returns a list of song names from the end to the start of the playlist. Input / Output * **add_song**: - Input: A string representing the song name. - Output: None * **remove_song**: - Input: A string representing the song name. - Output: None * **display_forward**: - Input: None - Output: A list of strings representing the song names from the start to the end. * **display_backward**: - Input: None - Output: A list of strings representing the song names from the end to the start. Constraint: * Perform all operations in O(n) time or better where n is the number of songs in the playlist. Performance Requirements: - Efficient memory usage. - Ensure the implementation can handle typical edge cases, such as empty playlists or trying to remove a non-existent song.","solution":"class DoublyLinkedListNode: def __init__(self, song_name): self.song_name = song_name self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_song(self, name: str) -> None: new_node = DoublyLinkedListNode(name) if not self.head: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def remove_song(self, name: str) -> None: current_node = self.head while current_node: if current_node.song_name == name: if current_node.prev: current_node.prev.next = current_node.next else: self.head = current_node.next if current_node.next: current_node.next.prev = current_node.prev else: self.tail = current_node.prev return current_node = current_node.next def display_forward(self) -> list: current_node = self.head result = [] while current_node: result.append(current_node.song_name) current_node = current_node.next return result def display_backward(self) -> list: current_node = self.tail result = [] while current_node: result.append(current_node.song_name) current_node = current_node.prev return result"},{"question":"# Bucket Sort Enhancement and Generalization You are tasked with improving and generalizing the given implementation of the bucket sort algorithm to handle a broader range of inputs and optimize its performance. Specifically, address the following requirements: 1. **Input and Output Formats**: * The function should accept an array of real numbers (positive, negative, and zero). * Output should be a sorted array of those numbers. 2. **Constraints**: * You must handle an array size ranging from 1 to 10^6 elements. * The numbers can be any real number between -10^6 to 10^6. 3. **Performance Requirements**: * Ensure that the sorting mechanism is efficient and handles edge cases properly. * Aim to implement any necessary improvements to enhance performance. 4. **Function Signature**: ```python def generalized_bucket_sort(arr): pass ``` **Your task:** - Adjust the bucket sort algorithm to correctly handle the full range of input values. - Replace the insertion sort within the buckets with a more efficient sorting algorithm if possible. - Ensure that your implementation optimally scales with different input sizes and value ranges. You must write the `generalized_bucket_sort` function that takes a list of real numbers and returns the sorted list. Example code usage: ```python arr = [0.23, -5.6, 89.1, 0, -1.2, 9.5, 23.3, 88] sorted_arr = generalized_bucket_sort(arr) print(sorted_arr) ``` # Ensure: - The output is correctly sorted in ascending order. - Efficient handling of edge cases like empty arrays or arrays with duplicate values.","solution":"def generalized_bucket_sort(arr): if not arr: return [] # Finding the minimum and maximum values in the array min_value = min(arr) max_value = max(arr) # Normalizing the values to bring them into the range [0, 1) bucket_count = len(arr) bucket_range = (max_value - min_value) / bucket_count + 1e-9 # Avoid division by zero # Create buckets buckets = [[] for _ in range(bucket_count)] # Distribute elements into buckets for num in arr: normalized_index = int((num - min_value) / bucket_range) buckets[normalized_index].append(num) # Sort each bucket and concatenate sorted_arr = [] for bucket in buckets: sorted_arr.extend(sorted(bucket)) return sorted_arr"},{"question":"You are given a class `RBTree` that implements a Red-Black Tree with methods for insertion, deletion, and in-order traversal. Expand the implementation to include a method for **range query**, which finds all nodes within a given range. # Task Implement a function `range_query(self, low, high)` inside the `RBTree` class. This function should return a list of node values (in ascending order) that lie within the range `[low, high]` (inclusive). # Input and Output - **Input**: An instance of `RBTree`, integers `low`, and `high`. - **Output**: A list of integers representing node values within the given range. # Constraints - The input tree may contain a mix of positive, negative integers, and zero. - `low` will always be less than or equal to `high`. - No additional data structures exceeding O(n) space usage should be used. # Example ```python if __name__ == \\"__main__\\": rb = RBTree() children = [11, 2, 14, 1, 7, 15, 5, 8, 4] for child in children: node = RBNode(child, 1) rb.insert(node) # The tree structure is now built. # Range query for nodes between 3 and 12 result = rb.range_query(3, 12) print(result) # Output should be [4, 5, 7, 8, 11] ``` # Notes Ensure that: 1. The function performs efficiently, adhering to Red-Black Tree properties. 2. The function handles edge cases like: - No nodes found within the range. - All nodes fall within the range. - Overlapping nodes just at the boundaries.","solution":"class RBNode: def __init__(self, value, color, parent=None, left=None, right=None): self.value = value self.color = color self.parent = parent self.left = left self.right = right class RBTree: def __init__(self): self.NIL_LEAF = RBNode(value=None, color=0) # Black nil leaf node self.root = self.NIL_LEAF def insert(self, node): # Simplified insertion method for testing purposes. Actual Red-Black tree # insertion would need balancing and coloring logic. if self.root == self.NIL_LEAF: self.root = node node.parent = None node.left = self.NIL_LEAF node.right = self.NIL_LEAF node.color = 1 # root must be black else: current = self.root while True: if node.value < current.value: if current.left == self.NIL_LEAF: current.left = node node.parent = current node.left = self.NIL_LEAF node.right = self.NIL_LEAF break current = current.left else: if current.right == self.NIL_LEAF: current.right = node node.parent = current node.left = self.NIL_LEAF node.right = self.NIL_LEAF break current = current.right def in_order_traversal(self, node, arr): if node != self.NIL_LEAF: self.in_order_traversal(node.left, arr) arr.append(node.value) self.in_order_traversal(node.right, arr) def range_query(self, low, high): results = [] self._range_query_helper(self.root, low, high, results) return results def _range_query_helper(self, node, low, high, results): if node == self.NIL_LEAF: return if low < node.value: self._range_query_helper(node.left, low, high, results) if low <= node.value <= high: results.append(node.value) if high > node.value: self._range_query_helper(node.right, low, high, results)"},{"question":"You are given a list of distinct integers, `nums`. Your task is to implement a function `subsets(nums)` that returns a set of all possible subsets of `nums`. The subset sets must not contain duplicate subsets, and the elements within each subset should appear in the order they appear in `nums`. **Function Signature**: ```python def subsets(nums: List[int]) -> Set[tuple]: ``` # Input * A list `nums` of distinct integers (1 ≤ length of nums ≤ 16). # Output * A set containing tuples, where each tuple is a subset of the input list `nums`. # Constraints and Performance Requirements You should ensure the solution is performant given the constraints. The function should not exceed a time complexity of O(n * 2^n) and space complexity of O(2^n), which is acceptable given the constraint on the length of `nums`. # Examples ```python nums = [1, 2, 3] subsets(nums) # Expected Output: {(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)} nums = [0] subsets(nums) # Expected Output: {(), (0,)} ``` # Explanation In the first example, `nums = [1, 2, 3]` has 2^3 = 8 possible subsets. These subsets include empty set, single element sets, double element sets, and one set containing all elements. In the second example, `nums = [0]` has 2^1 = 2 possible subsets: the empty set and the set containing the single number. Implement this function considering efficiency both in terms of computation and memory usage. Ensure you handle edge cases such as an empty input list and lists with single elements.","solution":"from typing import List, Set, Tuple def subsets(nums: List[int]) -> Set[Tuple[int]]: Returns a set of all possible subsets of the input list \'nums\'. Each subset is represented as a tuple. result = set() n = len(nums) # There are 2^n possible subsets for a set of size n for i in range(2 ** n): subset = tuple(nums[j] for j in range(n) if (i & (1 << j))) result.add(subset) return result"},{"question":"# Question: You are tasked with implementing an improved version of the Insertion Sort based on the provided `search_insert` helper function. This function uses binary search to find the correct insertion point, thus reducing the number of comparisons needed during the sorting process. Function Signature: ```python def binary_insertion_sort(array: List[int]) -> List[int]: pass ``` Input: A list of integers `array` where 1 ≤ len(array) ≤ 1000 and -10^4 ≤ array[i] ≤ 10^4 for all valid i. Output: Return the sorted list of integers. # Requirements: 1. Use the `search_insert` function provided to find the correct insertion points. 2. Ensure the sorting algorithm maintains a time complexity better than traditional Insertion Sort for large datasets, ideally aiming for O(n log n) efficiency. 3. Your solution should handle and correctly sort arrays with negative numbers, duplicates, and various lengths, including edge cases. # Example: ```python binary_insertion_sort([4, 2, 1, 3]) -> [1, 2, 3, 4] binary_insertion_sort([5, 1, 12, -5, 16]) -> [-5, 1, 5, 12, 16] binary_insertion_sort([]) -> [] binary_insertion_sort([7]) -> [7] binary_insertion_sort([8, -2, 3, 0, 3]) -> [-2, 0, 3, 3, 8] ``` # Constraints: - Ensure your sorting algorithm handles the problem constraints effectively. - Consider optimizing your insertions to leverage the binary search provided.","solution":"from typing import List def search_insert(sorted_array: List[int], target: int) -> int: Helper function that uses binary search to find the correct insertion point for the target in the sorted part of the array. low, high = 0, len(sorted_array) - 1 while low <= high: mid = (low + high) // 2 if sorted_array[mid] < target: low = mid + 1 else: high = mid - 1 return low def binary_insertion_sort(array: List[int]) -> List[int]: Sorts an array using an improved version of Insertion Sort that uses binary search to reduce the number of comparisons needed to find the correct insertion point. if len(array) <= 1: return array sorted_array = [] for value in array: insert_pos = search_insert(sorted_array, value) sorted_array.insert(insert_pos, value) return sorted_array"},{"question":"# Advanced Endianness Conversion Problem You are tasked with implementing a flexible conversion utility that can handle integers and their corresponding byte representation both in little-endian and big-endian formats. The utility should be optimized for performance and handle various edge cases effectively. Functions to Implement 1. **Little-endian to Big-endian Conversion**: ```python def little_endian_to_big_endian(bytestr: bytes) -> bytes: Convert a little-endian byte string to a big-endian byte string. Parameters: bytestr (bytes): Little-endian byte string. Returns: bytes: Big-endian byte string. pass ``` 2. **Big-endian to Little-endian Conversion**: ```python def big_endian_to_little_endian(bytestr: bytes) -> bytes: Convert a big-endian byte string to a little-endian byte string. Parameters: bytestr (bytes): Big-endian byte string. Returns: bytes: Little-endian byte string. pass ``` Constraints and Requirements * The length of the byte strings could be variable. * Optimize your solution to minimize iterative operations wherever possible. * Your implementation should correctly handle empty byte strings and ensure no data loss or corruption during conversion. Input Format * Both functions will take a single argument - a byte string (bytes). Output Format * Both functions will return a converted byte string (bytes). Example ```python # Example Inputs and Outputs little_endian_str = b\'x01x02x03x04\' big_endian_str = b\'x04x03x02x01\' assert little_endian_to_big_endian(little_endian_str) == big_endian_str assert big_endian_to_little_endian(big_endian_str) == little_endian_str ``` Be sure to include handling for edge cases, such as an empty byte string, to ensure your solution is robust.","solution":"def little_endian_to_big_endian(bytestr: bytes) -> bytes: Convert a little-endian byte string to a big-endian byte string. Parameters: bytestr (bytes): Little-endian byte string. Returns: bytes: Big-endian byte string. return bytestr[::-1] def big_endian_to_little_endian(bytestr: bytes) -> bytes: Convert a big-endian byte string to a little-endian byte string. Parameters: bytestr (bytes): Big-endian byte string. Returns: bytes: Little-endian byte string. return bytestr[::-1]"},{"question":"# Integer Decomposition with Dynamic Programming Given a positive integer `N`, write a function `int_decomposition(N)` that computes the number of different ways to decompose the integer into sums of positive integers. Each decomposition should be unique regardless of the order of the terms. For instance, the number `4` can be decomposed as follows: - `4` - `3 + 1` - `2 + 2` - `2 + 1 + 1` - `1 + 1 + 1 + 1` Thus, the result for `N=4` will be `5`. # Function Signature: ```python def int_decomposition(N: int) -> int: pass ``` # Input: - `N` (integer): A positive integer `(1 <= N <= 1000)`. # Output: - (integer): The number of different decomposition ways for `N`. # Example: ```python assert int_decomposition(4) == 5 assert int_decomposition(7) == 15 ``` # Constraints: - The function should be designed efficiently to handle the given constraints properly. - Avoid recomputation and aim for an optimized solution using dynamic programming. # Explanation: You have to count all possible ways to split the given integer using the dynamic programming approach provided in the analysis. Implement the function considering performance, accuracy, and edge cases.","solution":"def int_decomposition(N: int) -> int: Returns the number of different ways to decompose the integer N into sums of positive integers with unique decompositions regardless of the order of the terms. # dp[i][j] will store the number of ways to represent \'i\' using integers <= \'j\' dp = [[0] * (N + 1) for _ in range(N + 1)] # There is exactly one way to decompose 0: using no numbers at all. for i in range(N + 1): dp[0][i] = 1 # Fill the dp table for i in range(1, N + 1): for j in range(1, N + 1): if j > i: dp[i][j] = dp[i][i] else: dp[i][j] = dp[i][j - 1] + dp[i - j][j] return dp[N][N]"},{"question":"# Number of Digits: Advanced Analysis In many practical applications, quickly determining the number of digits in a number is crucial. For example, when formatting numbers in UI displays or performing numerical analysis, it\'s important to have an efficient mechanism to ascertain the length of the number representation. Problem Statement Your task is to implement a function `num_digits(n: int) -> int` that returns the number of digits of the given integer `n`. Input * An integer `n` where `-10^9 <= n <= 10^9`. Output * An integer representing the number of digits in the given integer `n`. Constraints * The function should run in constant time, O(1). * The function should handle zero and negative values correctly. Examples 1. `num_digits(5)` should return `1` 2. `num_digits(123456)` should return `6` 3. `num_digits(-98765)` should return `5` 4. `num_digits(0)` should return `1` # Requirements * The function must not convert the number into a string to count its digits. * Performance should be optimized for constant time complexity. Hints Consider using mathematical operations to determine the digit count efficiently. The properties of logarithms can be particularly useful in this context.","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the given integer n. if n == 0: return 1 # To handle negative numbers by taking the absolute value n = abs(n) # We add 1 to the floor of log10(n) to get the number of digits return math.floor(math.log10(n)) + 1"},{"question":"String Decoding Challenge Context You have been given an encoded string where the encoding rule is defined as follows: `k[encoded_string]`, with the encoded_string appearing exactly `k` times. Your task is to decode this string and return the original string. Nested encodings (e.g., `3[a2[c]]` which decodes to `accaccacc`) are possible and should be handled appropriately. Task Write a function `decode_string(s: str) -> str` to decode an encoded string `s`. Input - `s`: A valid encoded string (1 <= len(s) <= 30). Output - Return a decoded string. Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` Constraints * You may assume the input string is always valid; that means: - No extra white spaces. - Square brackets are well-formed and nested correctly. - Digits are only for those repeat numbers and are always positive integers. - The original input does not contain any digits. Performance Requirements - The solution should handle an input string with a maximum length of 30 efficiently within the constraints provided. Implementation You need to implement the following function: ```python def decode_string(s: str) -> str: # Your code here ```","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_string = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_string, current_num)) current_string = \'\' current_num = 0 elif char == \']\': last_string, num = stack.pop() current_string = last_string + num * current_string else: current_string += char return current_string"},{"question":"**Question**: You are given the task of developing a function to compute the binomial coefficient ( C(n, k) ) using a more efficient iterative approach as an alternative to the recursive method shown above. The binomial coefficient ( C(n, k) ) represents the number of ways to choose ( k ) elements from a set of ( n ) elements. # Function Signature: ```python def iterative_binomial_coefficient(n: int, k: int) -> int: ``` # Input: * An integer ( n ) (0 ( leq ) ( n ) ( leq ) 10^6) * An integer ( k ) (0 ( leq ) ( k ) ( leq ) ( n )) # Output: * An integer representing the binomial coefficient ( C(n, k) ). # Constraints: * Ensure that the solution is optimized for both time and space complexity given the constraints. * The function must handle large inputs efficiently. * You must not use Python\'s built-in `math.comb` or any other library function that directly computes binomial coefficients. # Examples: ```python print(iterative_binomial_coefficient(5, 0)) # Expected Output: 1 print(iterative_binomial_coefficient(8, 2)) # Expected Output: 28 print(iterative_binomial_coefficient(500, 300)) # Expected Output: A very large number ``` # Notes: * Assume `0 ≤ k ≤ n`. You do not need to handle invalid inputs as an error. * Think about optimizing your algorithm by leveraging properties of binomial coefficients, such as ( C(n, k) = C(n, n-k) ).","solution":"def iterative_binomial_coefficient(n: int, k: int) -> int: Computes the binomial coefficient C(n, k) using an iterative approach. if k > n - k: k = n - k result = 1 for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"# Caesar Cipher Decryption Imagine you have intercepted a message that was encrypted using Caesar\'s cipher. You know the shift value used for encryption. Your task is to write a function to decrypt the message to retrieve the original plaintext. Function Signature ```python def caesar_cipher_decrypt(encrypted_message: str, k: int) -> str: pass ``` Input - `encrypted_message` (str): The encrypted message using Caesar cipher that needs to be decrypted. - `k` (int): The shift value used for encryption. Output - `str`: The original decrypted message as plain text. Constraints - `0 <= len(encrypted_message) <= 10^5` - `0 <= k <= 100` Performance Requirements - The function should run efficiently even for large input sizes, with an expected time complexity of O(n). Example ```python assert caesar_cipher_decrypt(\\"def\\", 3) == \\"abc\\" assert caesar_cipher_decrypt(\\"Khoor Zruog\\", 3) == \\"Hello World\\" assert caesar_cipher_decrypt(\\"Ebiil Tloia\\", -3) == \\"Hello World\\" ``` # Scenario During a historical investigation, you come across a series of messages encoded with Caesar Cipher. You need to decode them to get information about ancient Rome\'s strategies. Your task is to implement the decrypting function. Write the function `caesar_cipher_decrypt` that: 1. Iterates over each character in the encrypted message. 2. Shifts the character back by `k` positions. 3. Wraps around the alphabet if necessary. Ensure that non-alphabetic characters remain unaffected.","solution":"def caesar_cipher_decrypt(encrypted_message: str, k: int) -> str: Decrypts a message encrypted with Caesar cipher using a given shift value. Parameters: encrypted_message (str): The encrypted message using Caesar cipher to be decrypted. k (int): The shift value used during encryption. Returns: str: The original decrypted message as plain text. decrypted_message = [] # Adjust k to be within 0-25 k = k % 26 for char in encrypted_message: if \'A\' <= char <= \'Z\': decrypted_char = chr((ord(char) - ord(\'A\') - k) % 26 + ord(\'A\')) elif \'a\' <= char <= \'z\': decrypted_char = chr((ord(char) - ord(\'a\') - k) % 26 + ord(\'a\')) else: decrypted_char = char decrypted_message.append(decrypted_char) return \'\'.join(decrypted_message)"},{"question":"# Binary Search Tree Optimization Task You are given a binary search tree (BST) implementation with several methods — `insert`, `search`, `size`, and three traversal methods (`preorder`, `inorder`, `postorder`). The current tree is prone to becoming unbalanced, resulting in operations that can approach O(N) time complexity. Your task is to refactor the given BST implementation to maintain balance automatically with every insertion and deletion. Specifically, you should implement an AVL Tree, which is a type of self-balancing binary search tree. Your AVL Tree should maintain the balance property for every insert and delete operation, ensuring that the height difference between the left and right subtrees of any node is no greater than 1. # Required Methods: 1. **Insert**: Insert a new element while keeping the tree balanced. 2. **Delete**: Remove an existing element while maintaining tree balance. 3. **Rotate**: Implement left and right rotations to maintain the balance property. 4. **Height Calculation**: Track the height of each node. 5. **Balance Factor Calculation**: Compute the balance factor of each node to decide rotations. # Input & Output * Input will consist of a sequence of operations forming a valid set of commands (insert, delete, traverse) with corresponding values. * Output should reflect the state of the AVL Tree, outputting traversal results after performing the operations. # Constraints * Elements will be unique integers. * All methods should maintain average-case O(log N) time complexity. # Example ```python # Example Sequence of Operations tree = AVLTree() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) tree.delete(15) print(tree.preorder()) # Expected Output: # [10, 6, 4, 9, 7, 18, 12, 24, 20, 30] ``` **Implement the AVLTree with the following methods:** * `insert(data)`: Insert a new element while keeping the tree balanced. * `delete(data)`: Delete an element while maintaining the tree balance. * `preorder()`: Return a list of elements in preorder traversal. * `inorder()`: Return a list of elements in inorder traversal. * `postorder()`: Return a list of elements in postorder traversal. You may assume balanced rotations (left and right) are implemented as needed.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.value = key self.height = 1 class AVLTree: def insert(self, root, key): if not root: return TreeNode(key) elif key < root.value: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and key < root.left.value: return self.rightRotate(root) if balance < -1 and key > root.right.value: return self.leftRotate(root) if balance > 1 and key > root.left.value: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and key < root.right.value: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def delete(self, root, key): if not root: return root if key < root.value: root.left = self.delete(root.left, key) elif key > root.value: root.right = self.delete(root.right, key) else: if root.left is None: temp = root.right root = None return temp elif root.right is None: temp = root.left root = None return temp temp = self.getMinValueNode(root.right) root.value = temp.value root.right = self.delete(root.right, temp.value) if root is None: return root root.height = 1 + max(self.getHeight(root.left), self.getHeight(root.right)) balance = self.getBalance(root) if balance > 1 and self.getBalance(root.left) >= 0: return self.rightRotate(root) if balance > 1 and self.getBalance(root.left) < 0: root.left = self.leftRotate(root.left) return self.rightRotate(root) if balance < -1 and self.getBalance(root.right) <= 0: return self.leftRotate(root) if balance < -1 and self.getBalance(root.right) > 0: root.right = self.rightRotate(root.right) return self.leftRotate(root) return root def leftRotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def rightRotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.getHeight(z.left), self.getHeight(z.right)) y.height = 1 + max(self.getHeight(y.left), self.getHeight(y.right)) return y def getHeight(self, root): if not root: return 0 return root.height def getBalance(self, root): if not root: return 0 return self.getHeight(root.left) - self.getHeight(root.right) def getMinValueNode(self, root): if root is None or root.left is None: return root return self.getMinValueNode(root.left) def preorder(self, root): res = [] if root: res.append(root.value) res = res + self.preorder(root.left) res = res + self.preorder(root.right) return res"},{"question":"Scenario You are tasked with implementing additional functionality for an AVL Tree, continuing from the provided code. Your task is to implement the `delete` method to allow deletion of nodes while maintaining the AVL tree properties. Function Specification You need to implement the following function within the `AvlTree` class: ```python def delete(self, key): Delete the node with the given key from the AVL tree. ``` Details - **Input**: An integer `key` representing the value of the node to be deleted. - **Output**: The tree should maintain the AVL properties (balance factors and height correctly updated) after the deletion. Constraints 1. Deleting a node should rebalance the tree if necessary. 2. The AVL tree should not have duplicate keys. 3. Assume the tree node type `TreeNode` and other helper methods (`re_balance`, `rotate_left`, `rotate_right`) are correctly implemented and available in your environment. Edge Cases - Deleting from an empty tree. - Deleting a leaf node. - Deleting a node with one child. - Deleting a node with two children (need to find the in-order predecessor or successor). Example ```python # Example of usage: avl = AvlTree() avl.insert(10) avl.insert(20) avl.insert(30) avl.insert(40) avl.insert(50) # AVL tree before deletion (In-order): [10, 20, 30, 40, 50] print(avl.in_order_traverse()) # Output: [10, 20, 30, 40, 50] avl.delete(20) # AVL tree after deleting 20 (In-order): [10, 30, 40, 50] print(avl.in_order_traverse()) # Output: [10, 30, 40, 50] ``` Implement the `delete` method within the `AvlTree` class while ensuring that the tree remains balanced after the deletion operation.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): Inserts a key into the AVL tree. self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._re_balance(node) def delete(self, key): Deletes a key from the AVL tree. self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node elif key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) return self._re_balance(node) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left) def _get_height(self, node): return node.height if node else 0 def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _re_balance(self, node): balance = self._get_balance(node) if balance > 1: if self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def _rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def in_order_traverse(self): Returns the in-order traversal of the tree. result = [] self._in_order_traverse(self.root, result) return result def _in_order_traverse(self, node, result): if node: self._in_order_traverse(node.left, result) result.append(node.key) self._in_order_traverse(node.right, result)"},{"question":"# Scenario You are building a simple lightweight compiler for a custom scripting language. One of the essential tasks is to validate the correctness of the parentheses and brackets in expressions. Your compiler verifies the paired and ordered use of parentheses, curly braces, and square brackets. # Challenge Implement a function `is_valid(s: str) -> bool` that checks if a string containing the characters \'(\', \')\', \'{\', \'}\', \'[\', and \']\' is a valid expression with correctly matched and ordered brackets. # Function Specification * **Input**: * `s` (str): A string consisting of characters \'(\', \')\', \'{\', \'}\', \'[\', and \']\', length `0 <= |s| <= 10^4`. * **Output**: * Returns `True` if the string is valid. * Returns `False` otherwise. # Constraints 1. The string contains only the characters \'(\', \')\', \'{\', \'}\', \'[\', and \']\'. 2. An empty string should return `True`. # Examples * `is_valid(\\"\\")` should return `True` * `is_valid(\\"()\\")` should return `True` * `is_valid(\\"()[]{}\\")` should return `True` * `is_valid(\\"(]\\")` should return `False` * `is_valid(\\"([)]\\")` should return `False` * `is_valid(\\"{[]}\\")` should return `True` # Notes * Consider edge cases like empty strings. * The string is valid only if all types of brackets are matched and closed correctly.","solution":"def is_valid(s: str) -> bool: Checks if the input string with parentheses, brackets, and braces is valid. stack = [] mapping = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in mapping: top_element = stack.pop() if stack else \'#\' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"# Scenario You\'re part of a search and rescue project to develop a system that looks through large datasets of coordinates. The datasets are sorted, and your task is to implement an algorithm that takes advantage of its sorted nature to efficiently find the position of a particular coordinate. # Task Write a Python function, `find_coordinate`, using binary search to determine the index of a given target coordinate in a list of sorted coordinates. # Function Signature ```python def find_coordinate(coordinates: List[float], target: float) -> int: Finds target coordinate in a sorted list of coordinates. Parameters: coordinates (List[float]): A list of floats representing sorted coordinates. target (float): The coordinate to search for. Returns: int: The index of the target coordinate in the list if found, otherwise -1. ``` # Input - `coordinates`: A list of `n` sorted floating-point numbers representing coordinates (`1 <= n <= 10^6`). - `target`: A floating-point number representing the coordinate that you need to find. # Output - Return the index of the target coordinate in the list if it is found. - Return `-1` if the target coordinate is not in the list. # Constraints - The inner workings of your function should leverage binary search. - Ensure that your solution is efficient with a time complexity of O(log n). - Handle edge cases such as empty lists and lists with one element. # Example ```python coordinates = [0.1, 0.5, 1.1, 2.0, 3.3, 5.5] target = 2.0 assert find_coordinate(coordinates, target) == 3 coordinates = [0.1, 0.5, 1.1, 2.0, 3.3, 5.5] target = 4.0 assert find_coordinate(coordinates, target) == -1 ``` # Explanation In the first example, the target `2.0` is at index 3 of the sorted list, so the function returns `3`. In the second example, the target `4.0` is not present in the list, so the function returns `-1`.","solution":"from typing import List def find_coordinate(coordinates: List[float], target: float) -> int: Finds target coordinate in a sorted list of coordinates. Parameters: coordinates (List[float]): A list of floats representing sorted coordinates. target (float): The coordinate to search for. Returns: int: The index of the target coordinate in the list if found, otherwise -1. left, right = 0, len(coordinates) - 1 while left <= right: mid = (left + right) // 2 if coordinates[mid] == target: return mid elif coordinates[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# FizzBuzz Algorithm Enhancement and Analysis You are tasked with enhancing the classic FizzBuzz problem and providing a thorough analysis of the implementation. The enhanced version should modify the result format and include robust error handling and performance optimization using generators. Problem Statement Write a Python function `fizzbuzz_enhanced(n: int) -> List[Union[int, str]]` that returns an array containing numbers from 1 to `n`, where `n` is a positive integer `n >= 1`. Replace some of the values according to the following rules: 1. If the value is a multiple of 3, use the value `\\"Fizz\\"` instead. 2. If the value is a multiple of 5, use the value `\\"Buzz\\"` instead. 3. If the value is a multiple of both 3 and 5, use the value `\\"FizzBuzz\\"` instead. 4. If none of the above conditions are met, retain the number itself. Additionally, implement the function leveraging generators for performance optimization in space complexity. Input and Output Format * **Input**: A single integer `n` (1 ≤ n ≤ 10^6). * **Output**: A list of length `n` with elements transformed as per the above rules. Constraints * You must use generators to optimize space usage. Example ```python fizzbuzz_enhanced(15) # Expected Output: # [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] ``` Additional Guidelines * Ensure that your function is robust and handles invalid inputs by raising appropriate exceptions. * Your function must efficiently handle the upper limit of the given constraints.","solution":"from typing import List, Union def fizzbuzz_enhanced(n: int) -> List[Union[int, str]]: if not isinstance(n, int) or n < 1: raise ValueError(\\"Input must be a positive integer >= 1\\") def fizzbuzz_generator(max_num: int): for i in range(1, max_num + 1): if i % 15 == 0: yield \\"FizzBuzz\\" elif i % 3 == 0: yield \\"Fizz\\" elif i % 5 == 0: yield \\"Buzz\\" else: yield i return list(fizzbuzz_generator(n))"},{"question":"You are tasked with implementing a string searching function using the Rabin-Karp algorithm with a rolling hash technique. Your function should find the first occurrence of a given pattern in a given text and return its starting index. If the pattern is not found, return `-1`. # Function Signature ```python def rabin_karp_search(pattern: str, text: str) -> int: # Your implementation here ``` # Expected Input and Output - **Input**: - `pattern`: A non-empty string (p) representing the substring to search for. - `text`: A non-empty string (t) representing the text where the search is to be performed. - **Output**: - An integer ( geq 0) representing the starting index of the first occurrence of the pattern in the text, or `-1` if the pattern is not found. # Constraints - (1 leq |pattern| leq 10^5) - (1 leq |text| leq 10^6) # Example ```python assert rabin_karp_search(\\"abc\\", \\"abdabcbabc\\") == 4 assert rabin_karp_search(\\"abc\\", \\"aaaaa\\") == -1 assert rabin_karp_search(\\"test\\", \\"this is a test\\") == 10 ``` # Performance Requirements - Your implementation should handle large inputs efficiently. - Avoid recomputation and use an optimized rolling hash mechanism to ensure the function runs in average (O(n + m)) time.","solution":"def rabin_karp_search(pattern: str, text: str) -> int: Uses the Rabin-Karp algorithm with a rolling hash technique to find the first occurrence of `pattern` in `text`. Returns the starting index of the first occurrence, or -1 if not found. # Base conditions if not pattern or not text or len(pattern) > len(text): return -1 # Prime number for modulo operation to avoid overflow prime = 101 # Values for the initial hash calculations m = len(pattern) n = len(text) base = 256 # Number of characters in the input alphabet # Initial hash values pattern_hash = 0 text_hash = 0 h = 1 # The value of `h` would be \\"pow(base, m-1) % prime\\" for i in range(m - 1): h = (h * base) % prime # Calculate the hash value of pattern and first window of text for i in range(m): pattern_hash = (base * pattern_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current window of text and pattern if pattern_hash == text_hash: # Check characters one by one to ensure no spurious hit if text[i:i + m] == pattern: return i # Calculate hash value for next window of text: Remove leading digit, add trailing digit if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # Convert negative value of text_hash to positive if text_hash < 0: text_hash = text_hash + prime return -1"},{"question":"# Crout\'s LU Decomposition Algorithm Crout\'s LU Decomposition is a powerful method for decomposing a matrix into a product of a lower triangular matrix and an upper triangular matrix. This can be particularly useful when solving systems of linear equations, inverting matrices, or determining matrix determinants. Your task is to implement a version of Crout\'s LU Decomposition. Problem Statement You need to write a function `crout_matrix_decomposition(A)` that takes a square matrix `A` (a list of lists with numeric values) as input and returns two matrices `L` and `U`. The returned matrices should meet the following criteria: 1. **L (Lower triangular matrix)**: Non-zero elements only on the diagonal and below. 2. **U (Upper triangular matrix)**: Non-zero elements only on the diagonal and above. The product of `L` and `U` should equal the original matrix `A`. Function Signature ```python def crout_matrix_decomposition(A): # Your code here ``` Input - `A`: A list of lists representing a square matrix with size `n x n`. Output - Returns a tuple of two lists of lists `(L, U)` where: - `L`: Lower triangular matrix. - `U`: Upper triangular matrix. Constraints - The matrix `A` will be a square matrix of size `2 <= n <= 50`. - The elements of the matrix `A` are integers or floats. - Perform necessary adjustments to handle zero values on the diagonal, avoiding division by zero. Example Input: ```python A = [ [1, 2, 3], [3, 4, 5], [6, 7, 8] ] ``` Output: ```python L = [ [1.0, 0.0, 0.0], [3.0, -2.0, 0.0], [6.0, -5.0, 0.0] ] U = [ [1.0, 2.0, 3.0], [0.0, 1.0, 2.0], [0.0, 0.0, 1.0] ] ``` Notes - Pay attention to the precision of floating point operations. - Ensure the matrices `L` and `U` follow the properties of lower triangular and upper triangular matrices respectively. - Handle edge cases such as matrices containing zero values that might lead to division by zero.","solution":"def crout_matrix_decomposition(A): Performs Crout\'s LU Decomposition on matrix A. Returns matrices L (lower triangular) and U (upper triangular). n = len(A) L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): # Upper Triangular Matrix U[i][i] = 1.0 # Constructing L matrix for j in range(i, n): sum_k = sum(L[j][k] * U[k][i] for k in range(i)) L[j][i] = A[j][i] - sum_k # Constructing U matrix for j in range(i+1, n): sum_k = sum(L[i][k] * U[k][j] for k in range(i)) if L[i][i] == 0: raise ZeroDivisionError(f\\"Zero pivot element found at position ({i}, {i})\\") U[i][j] = (A[i][j] - sum_k) / L[i][i] return L, U"},{"question":"# Binary Tree to Doubly Linked List Conversion Objective Write a function to convert a binary tree to a sorted doubly linked list. The tree nodes should be re-used as list nodes, maintaining their original values. Requirements * Implement a function `binary_tree_to_dll(root: TreeNode) -> TreeNode` where: * `root` is the root node of a binary tree. * The function returns the head of a doubly linked list, with nodes sorted in ascending order. Input * The function accepts the root node of a binary tree, where each node contains: * `val`: an integer representing the node\'s value. * `left`: pointer to the left child node. * `right`: pointer to the right child node. Output * The function must return the head node of the resulting doubly linked list. The list should follow: * Nodes are linked in non-decreasing order based on their values. * Each node\'s `left` pointer should point to the previous node, and `right` should point to the next node in the list. Constraints * Constraints on the binary tree: * The number of nodes in the tree is at most 10^4. * Values of the nodes are integer and can be negative. Performance Requirements * The algorithm should run efficiently with a time complexity of O(N), where N is the number of nodes in the binary tree. * The space complexity should be O(H), with H being the height of the tree due to recursive stack space. Example Scenario: You are given a binary search tree as follows: ``` 4 / 2 5 / 1 3 ``` The doubly linked list returned should be: `1 <=> 2 <=> 3 <=> 4 <=> 5`","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_to_dll(root: TreeNode) -> TreeNode: def inorder_traversal(node): nonlocal prev, head if not node: return inorder_traversal(node.left) if prev: prev.right = node node.left = prev else: head = node prev = node inorder_traversal(node.right) head, prev = None, None inorder_traversal(root) return head"},{"question":"# Context You are developing an AI system that must classify data points based on their similarity to a pre-existing labeled training set. The classification is determined by finding the nearest neighbor in the training set to the new point and returning the label of the nearest neighbor. # Problem Implement a function `nearest_neighbor_classify` that classifies a given point based on the nearest neighbor algorithm. # Function Signature ```python def nearest_neighbor_classify(point: tuple, training_set: dict) -> str: pass ``` # Input 1. `point` (tuple): A tuple representing the coordinates of the point to be classified. 2. `training_set` (dict): A dictionary where keys are tuples representing coordinates of training points, and values are strings representing labels of the respective points. # Output * Returns a string which is the label of the nearest neighbor to the input point. # Constraints * The dimensions of the input point and each key in the training set are the same. * Each element of the input tuple is a real number. * The training set will contain at least one point. * Labels in the training set are non-empty strings. # Example ```python training_set = { (1.0, 2.0): \\"A\\", (3.0, 4.0): \\"B\\", (5.0, 6.0): \\"B\\" } point = (2.0, 3.0) result = nearest_neighbor_classify(point, training_set) print(result) # Output should be \\"A\\" as (1.0, 2.0) is the closest to (2.0, 3.0) ``` # Performance Requirements * Your implementation should be efficient to handle up to (10^3) training points in reasonable time.","solution":"import math def nearest_neighbor_classify(point: tuple, training_set: dict) -> str: Classifies a given point based on the nearest neighbor algorithm. Parameters: point (tuple): A tuple representing the coordinates of the point to be classified. training_set (dict): A dictionary where keys are tuples representing coordinates of training points, and values are strings representing labels of the respective points. Returns: str: The label of the nearest neighbor to the input point. def euclidean_distance(p1, p2): return math.sqrt(sum((x - y) ** 2 for x, y in zip(p1, p2))) nearest_neighbor = None shortest_distance = float(\'inf\') for train_point, label in training_set.items(): distance = euclidean_distance(point, train_point) if distance < shortest_distance: shortest_distance = distance nearest_neighbor = label return nearest_neighbor"},{"question":"# Insertion Sort with Simulation You are working on a simulation tool for teaching sorting algorithms. Your task is to implement a function that performs the insertion sort algorithm and optionally provides a step-by-step simulation of the sorting process. Function Signature ```python def insertion_sort(arr: list, simulation: bool = False) -> list: Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list): A list of integers that needs to be sorted. simulation (bool): If true, prints the array after every iteration of the outer loop. Returns: list: The sorted list of integers. ``` Input - A list `arr` of integers, where (0 leq |arr| leq 1000). Elements of the list can be any integer. - A boolean `simulation`, defaulting to `False`. When `True`, the function should print the array after each iteration of the outer loop. Output - A list of integers in ascending order. Constraints - You must implement the insertion sort algorithm. - If `simulation` is `True`, the function should print the state of the list after each pass through the outer loop. Example ```python example: input: [4, 3, 2, 10, 12, 1, 5, 6] insertion_sort([4, 3, 2, 10, 12, 1, 5, 6], simulation=True) output: iteration 0: 4 3 2 10 12 1 5 6 iteration 1: 3 4 2 10 12 1 5 6 iteration 2: 2 3 4 10 12 1 5 6 iteration 3: 2 3 4 10 12 1 5 6 iteration 4: 2 3 4 10 12 1 5 6 iteration 5: 1 2 3 4 10 12 5 6 iteration 6: 1 2 3 4 5 10 12 6 iteration 7: 1 2 3 4 5 6 10 12 ```","solution":"def insertion_sort(arr, simulation=False): Sorts a list of integers using the insertion sort algorithm. Parameters: arr (list): A list of integers that needs to be sorted. simulation (bool): If true, prints the array after every iteration of the outer loop. Returns: list: The sorted list of integers. n = len(arr) for i in range(1, n): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position. while j >= 0 and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"iteration {i-1}: {\' \'.join(map(str, arr))}\\") return arr"},{"question":"**Question**: Implement a function that sorts a list of integers using the Gnome Sort algorithm. Your function should work efficiently within the given constraints. Additionally, write a function to check if the provided list is correctly sorted in non-decreasing order as a means of validating your sorting algorithm. **Input/Output Formats**: * **Function 1**: `gnome_sort(arr: List[int]) -> List[int]` * **Input**: A list of integers `arr` of length n (0 ≤ n ≤ 10^4) * **Output**: A sorted list of integers in non-decreasing order * **Function 2**: `is_sorted(arr: List[int]) -> bool` * **Input**: A list of integers `arr` * **Output**: Boolean value `True` if the list is sorted in non-decreasing order, `False` otherwise **Constraints**: * The list can contain both positive and negative integers. * The list can contain duplicate elements. **Examples**: ```python assert gnome_sort([34, 2, 56, 100, -3, 3, 1]) == [-3, 1, 2, 3, 34, 56, 100] assert is_sorted(gnome_sort([5, 3, 2, 8, 1])) == True assert gnome_sort([]) == [] assert gnome_sort([1]) == [1] assert is_sorted([5, 4, 3, 2, 1]) == False ```","solution":"def gnome_sort(arr): Sorts a list of integers using the Gnome Sort algorithm. pos = 0 while pos < len(arr): if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr def is_sorted(arr): Checks if a list of integers is sorted in non-decreasing order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True"},{"question":"Scenario You have been tasked to develop a feature in a messaging application that filters and groups messages having the same character combination, regardless of the order of the characters. This will help in identifying conversations that have used the same set of characters in different orders. Problem Statement Write a function `group_anagrams(messages)` that groups messages (strings) based on their anagram groups. # Function Signature ```python def group_anagrams(messages: List[str]) -> List[List[str]]: ``` # Input * `messages`: A list of strings, where each string is a message. * Constraints: * 1 <= len(messages) <= 10^4 * 0 <= len(messages[i]) <= 100, where messages[i] is a string consisting only of lowercase English letters. # Output * A list of lists, where each sublist contains strings that are anagrams of each other. The order of sublists and strings within each sublist does not matter. # Example Input: ```python [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"golang\\", \\"angle\\", \\"nagel\\"] ``` Output: ```python [ [\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"google\\"], [\\"golang\\"], [\\"angle\\", \\"nagel\\"] ] ``` # Constraints & Requirements: * You are required to achieve the solution with a time complexity of O(N * K log K). * Ensure the function handles edge cases like empty strings and single-character messages. Note Ensure your implementation is efficient and correctly handles the expected range of inputs. You may not use any external libraries or functions not explicitly allowed by standard Python libraries.","solution":"from typing import List from collections import defaultdict def group_anagrams(messages: List[str]) -> List[List[str]]: Groups messages based on their anagram groups. Args: messages (List[str]): A list of message strings. Returns: List[List[str]]: A list where each sublist contains strings that are anagrams of each other. anagram_groups = defaultdict(list) for message in messages: # Sort the characters in the message to form the key sorted_message = \'\'.join(sorted(message)) anagram_groups[sorted_message].append(message) # Return the grouped anagrams as a list of lists return list(anagram_groups.values())"},{"question":"# Matrix Key Search Challenge Given a matrix where each row is sorted in ascending order and each column is sorted in ascending order (row-wise and column-wise sorted), write a function to search for a given key. If the key is found, return its position as a tuple (row_index, column_index); otherwise, return None. Function Signature ```python def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: pass ``` Input The function takes in: 1. `matrix`: a 2D list of integers where `matrix[i][j]` denotes the element at the i-th row and j-th column. 2. `key`: the integer key that needs to be searched in the matrix. Output The function should return a tuple `(row_index, column_index)` if the key is present in the matrix; otherwise, return `None`. Constraints * The number of rows (m) and columns (n) are each in the range [1, 10^3]. * The elements of the matrix are integers in the range [-10^6, 10^6]. Performance Your solution should run in O(m + n) time. Example ```python matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 result = search_in_sorted_matrix(matrix, key) print(result) # Output: (1, 2) ``` Edge Cases to Consider * The matrix consists of just one element. * The key is not present in the matrix. * The key is present at the start or the end of the matrix. Implement the function `search_in_sorted_matrix`.","solution":"from typing import List, Optional, Tuple def search_in_sorted_matrix(matrix: List[List[int]], key: int) -> Optional[Tuple[int, int]]: if not matrix or not matrix[0]: return None rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row, col) elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Scenario: Insertion Helper in Sorted Arrays In some applications, maintaining a sorted array structure while continuously inserting new elements requires identifying the correct insertion points efficiently. One common scenario is evolving sequences in real-time data processing. # Problem Statement Write a function `find_insert_position` that takes two parameters: 1. A list of sorted integers `arr`. 2. An integer `target`. The function should return the index where the `target` should be inserted in the list `arr` to maintain its sorted order. # Function Signature ```python def find_insert_position(arr: List[int], target: int) -> int: pass ``` # Input - `arr` (List[int]): A list of integers sorted in ascending order. - `target` (int): An integer to find the insertion position. # Output - Return an integer representing the index position where the `target` should be inserted. # Constraints - 0 ≤ len(arr) ≤ 10^5 - -10^9 ≤ arr[i], target ≤ 10^9 # Examples ```python assert find_insert_position([1, 3, 5, 6], 5) == 2 assert find_insert_position([1, 3, 5, 6], 2) == 1 assert find_insert_position([1, 3, 5, 6], 7) == 4 assert find_insert_position([1, 3, 5, 6], 0) == 0 ``` # Notes - Your solution should have a time complexity of (O(log n)). - Be mindful of edge cases such as when the array is empty or the `target` is smaller/larger than all elements in `arr`. Good luck!","solution":"from typing import List def find_insert_position(arr: List[int], target: int) -> int: Finds the insertion index for `target` in the sorted list `arr`. Parameters: - arr: List[int], a list of sorted integers - target: int, the target integer to find the position for Returns: - int: the index where `target` should be inserted to maintain sorted order left, right = 0, len(arr) while left < right: mid = (left + right) // 2 if arr[mid] < target: left = mid + 1 else: right = mid return left"},{"question":"# Markov Chain Simulator You have been provided with the implementation of a simple Markov Chain using a dictionary where each key represents a state, and the value is another dictionary representing possible next states and their associated transition probabilities. Your task is to extend this implementation by adding a simulation function that generates a finite sequence of states given the initial state, the number of steps to simulate, and also report the frequency of visits to each state. Function Signature ```python def simulate_markov_chain(chain: dict, initial_state: str, steps: int) -> dict: Simulate a sequence of states in a Markov chain starting from an initial state and continuing for a given number of steps. Args: - chain (dict): The Markov chain representation. - initial_state (str): The state to start the simulation from. - steps (int): The number of steps to simulate. Returns: - dict: A dictionary representing the frequency of visits to each state. ``` Input and Output * **Input**: - `chain`: A dictionary representing the Markov chain. Each key is a state whose value is a dictionary enumerating possible next states and their transition probabilities. - `initial_state`: A string indicating the starting state for the simulation. - `steps`: An integer specifying the number of transitions (steps) to simulate. * **Output**: - A dictionary where keys are state names and values are counts/frequencies of how many times each state was visited during the simulation. Constraints * Assume all states and transitions are valid and probabilities sum to 1. * You should avoid modifying the given chain dictionary. * The number of steps will be a non-negative integer. * At least one state transition is possible from the initial state. Example ```python chain = { \'A\': {\'B\': 0.5, \'C\': 0.5}, \'B\': {\'A\': 0.2, \'C\': 0.8}, \'C\': {\'A\': 1.0} } initial_state = \'A\' steps = 10 print(simulate_markov_chain(chain, initial_state, steps)) # Output: e.g., {\'A\': 4, \'B\': 3, \'C\': 4} ```","solution":"import random def simulate_markov_chain(chain: dict, initial_state: str, steps: int) -> dict: Simulate a sequence of states in a Markov chain starting from an initial state and continuing for a given number of steps. Args: - chain (dict): The Markov chain representation. - initial_state (str): The state to start the simulation from. - steps (int): The number of steps to simulate. Returns: - dict: A dictionary representing the frequency of visits to each state. current_state = initial_state state_counts = {state: 0 for state in chain} state_counts[current_state] += 1 for _ in range(steps): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) current_state = random.choices(next_states, probabilities)[0] state_counts[current_state] += 1 return state_counts"},{"question":"**Problem Statement**: You are developing an application that processes user-specified file paths to read configuration files. To ensure robustness, you need to convert any given path to an absolute path, handling user directory shortcuts and resolving any relative path elements. Implement the function `get_absolute_path` that performs this task. **Function Signature**: ```python def get_absolute_path(file: str) -> str: ``` **Input**: - `file`: A string representing a file path. This path may use relative path components (e.g., \\"../folder/file\\") and user directory shortcuts (e.g., \\"~/file\\"). **Output**: - Returns a string which is the absolute path corresponding to the input path. **Constraints**: - The input path `file` will be a valid string that represents a file path. - You do not need to check if the file actually exists or not. **Examples**: 1. `get_absolute_path(\\"~/config.yaml\\")` should return `/home/username/config.yaml` (assuming the user\'s home directory is `/home/username`). 2. `get_absolute_path(\\"../Documents/report.doc\\")` should return `/home/username/Documents/report.doc` (assuming the current directory). **Scenario**: Imagine you are building a configuration loader for a software application. Users can specify the path to their configuration file in various ways (relative paths, user directory shortcuts, etc.). Your function, `get_absolute_path`, needs to ensure that no matter how the path is specified, it is always converted to an absolute path before any further processing.","solution":"import os def get_absolute_path(file: str) -> str: Converts a given file path to an absolute path. The function handles user directory shortcuts (~) and resolves any relative path elements. return os.path.abspath(os.path.expanduser(file))"},{"question":"You are tasked with creating an enhanced implementation of the Separate Chaining Hash Table. Your implementation should include an additional feature to handle dynamic resizing of the hash table to maintain efficient performance as the number of elements grows or shrinks. # Function Implementation 1. **Resizing**: Implement the `resize` function to double the size of the hash table when the load factor exceeds 0.75 and halve the size (but no smaller than the initial size) when the load factor drops below 0.25. 2. **Load Factor Calculation**: Implement a helper function to compute the load factor. # Input and Output - **Input**: - Insertions, deletions, and lookups via the existing methods (`put`, `del_`, `get`). - The `resize` function should be called internally during insertions and deletions to handle resizing. - **Output**: - Correctly updated hash table size and bucket structure on insertions and deletions. - Correct values retrieved or returned `None` for missing keys. # Constraints - Assume that the hash function used distributes keys uniformly. - The initial size of the hash table should be kept at 11, as in the provided class. - Use a load factor threshold of 0.75 for expanding and 0.25 for contracting. # Example ```python # creating the enhanced hash table table = EnhancedSeparateChainingHashTable() # adding values to the hash table table.put(\'key1\', \'value1\') table.put(\'key2\', \'value2\') # the hash table should resize if needed # fetching a value assert table.get(\'key1\') == \'value1\' # deleting a value table.del_(\'key1\') assert table.get(\'key1\') is None # resizing should maintain correct values assert table.get(\'key2\') == \'value2\' ``` # Code Skeleton You should define the `EnhancedSeparateChainingHashTable` class which extends the provided `SeparateChainingHashTable` class. Implement the resize functionality as specified. ```python class EnhancedSeparateChainingHashTable(SeparateChainingHashTable): def __init__(self, size=11): super().__init__(size) def put(self, key, value): super().put(key, value) if self.load_factor() > 0.75: self.resize(2 * self.size) def del_(self, key): super().del_(key) if self.load_factor() < 0.25 and self.size > 11: self.resize(max(11, self.size // 2)) def load_factor(self): return len(self) / self.size def resize(self, new_size): # Your implementation here pass ``` Complete the `resize` method and ensure all tests pass.","solution":"class EnhancedSeparateChainingHashTable: def __init__(self, size=11): self.initial_size = size self.size = size self.table = [[] for _ in range(size)] self.count = 0 def hash_function(self, key): return hash(key) % self.size def put(self, key, value): if self.load_factor() > 0.75: self.resize(2 * self.size) bucket = self.hash_function(key) for item in self.table[bucket]: if item[0] == key: item[1] = value return self.table[bucket].append([key, value]) self.count += 1 def get(self, key): bucket = self.hash_function(key) for item in self.table[bucket]: if item[0] == key: return item[1] return None def del_(self, key): if self.load_factor() < 0.25 and self.size > self.initial_size: self.resize(max(self.initial_size, self.size // 2)) bucket = self.hash_function(key) for item in self.table[bucket]: if item[0] == key: self.table[bucket].remove(item) self.count -= 1 return return None def load_factor(self): return self.count / self.size def resize(self, new_size): old_table = self.table self.size = new_size self.table = [[] for _ in range(new_size)] self.count = 0 for bucket in old_table: for key, value in bucket: self.put(key, value)"},{"question":"# Task: Polynomial Simplification and Evaluation # Context You are working on a symbolic computation library that deals with algebraic polynomials and their manipulations. To verify the correctness of your library, you need to implement a method that simplifies a given polynomial and another that evaluates the polynomial for given variable values. # Problem Description Implement a function `simplify_polynomial` that takes a `Polynomial` object as input and returns a simplified `Polynomial`. Additionally, implement a function `evaluate_polynomial` that evaluates the polynomial for given values of its variables. # Function Specifications `simplify_polynomial`: * **Input**: * `poly`: A `Polynomial` object. * **Output**: * A simplified `Polynomial` object where all like terms are combined, and any monomial with a zero coefficient is removed. * **Constraints**: * The polynomial may contain integer, float, or `Fraction` type coefficients. `evaluate_polynomial`: * **Input**: * `poly`: A `Polynomial` object. * `values`: A dictionary where keys are variable indices (integers), and values are the values to substitute (can be integer, float, or `Fraction`). * **Output**: * A numerical result (can be integer, float, or `Fraction`) after substituting the values into the polynomial. * **Constraints**: * Each variable in the `Polynomial` must be present in the `values` dictionary. * No division by zero should occur during evaluation. # Example Assume the `Polynomial` and `Monomial` classes are already defined as per the provided code snippets. ```python from fractions import Fraction poly = Polynomial([ Monomial({1: 1}, 3), Monomial({1: 1}, 2), Monomial({2: 2}, -1), Monomial({1: 2, 2: -1}) ]) # Simplify the polynomial simplified_poly = simplify_polynomial(poly) print(simplified_poly) # Expected simplified form # Evaluate the polynomial with variable assignments values = {1: 2, 2: 3} result = evaluate_polynomial(simplified_poly, values) print(result) # Expected evaluation result ``` # Implementation Implement the following functions: ```python def simplify_polynomial(poly: Polynomial) -> Polynomial: Simplify the given polynomial. # Write your code here def evaluate_polynomial(poly: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: Evaluate the polynomial with the given values. # Write your code here ``` # Notes * Ensure all like terms are combined during simplification. * Handle edge cases, such as polynomials resulting in zero. * Ensure precise handling of fractions and float values during evaluation.","solution":"from collections import defaultdict from typing import List, Dict, Union from fractions import Fraction class Monomial: def __init__(self, variables: dict, coefficient): self.variables = variables # dictionary where keys are variable indices and values are their exponents self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __hash__(self): return hash((frozenset(self.variables.items()), self.coefficient)) def __repr__(self): return f\\"Monomial(variables={self.variables}, coefficient={self.coefficient})\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials def __eq__(self, other): return self.monomials == other.monomials def __repr__(self): return f\\"Polynomial(monomials={self.monomials})\\" def simplify_polynomial(poly: Polynomial) -> Polynomial: Simplify the given polynomial. combined_terms = defaultdict(lambda: 0) for monomial in poly.monomials: variables = frozenset(monomial.variables.items()) combined_terms[variables] += monomial.coefficient simplified_monomials = [ Monomial(dict(variables), coeff) for variables, coeff in combined_terms.items() if coeff != 0 ] return Polynomial(simplified_monomials) def evaluate_polynomial(poly: Polynomial, values: Dict[int, Union[int, float, Fraction]]) -> Union[int, float, Fraction]: Evaluate the polynomial with the given values. total = 0 for monomial in poly.monomials: term_value = monomial.coefficient for var, exp in monomial.variables.items(): if var in values: term_value *= values[var] ** exp else: raise ValueError(f\\"Variable {var} not found in values\\") total += term_value return total"},{"question":"Context As a software engineer, you are tasked with implementing a feature in a navigation system that determines whether there exists a specific route from the starting point to a destination such that the exact distance traveled equals a predefined value. You need to solve this by traversing through a tree-based data structure representing the routes. Problem Statement You are given a binary tree and a target sum. Your task is to determine if there exists a root-to-leaf path such that the sum of the node values along the path equals the given target sum. Write a function `has_path_sum` that takes the root of a binary tree and an integer `target` as inputs and returns a boolean value indicating whether such a path exists. Function Signature ```python def has_path_sum(root: TreeNode, target: int) -> bool: ``` Input - `root` (`TreeNode`): The root node of a binary tree, where `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `target` (`int`): The target sum to match. Output - Returns `True` if there exists a root-to-leaf path with a sum equal to `target`, otherwise `False`. Constraints - The number of nodes in the tree is in the range `[1, 5000]`. - `-1000 <= Node.val <= 1000` - `-1000 <= target <= 1000` Examples ```python # Example 1 root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.right.right.right = TreeNode(1) target = 22 assert has_path_sum(root, target) == True # Example 2 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) target = 5 assert has_path_sum(root, target) == False # Example 3 root = TreeNode(1) root.left = TreeNode(2) target = 0 assert has_path_sum(root, target) == False ``` You may implement the function using either a recursive approach, an iterative DFS approach, or an iterative BFS approach.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root: TreeNode, target: int) -> bool: if not root: return False if not root.left and not root.right: return root.val == target return (has_path_sum(root.left, target - root.val) or has_path_sum(root.right, target - root.val))"}]'),C={name:"App",components:{PoemCard:A},data(){return{searchQuery:"",visibleCount:4,poemsData:z,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},S={class:"card-container"},L={key:0,class:"empty-state"},F=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",S,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,F)):u("",!0)])}const P=c(C,[["render",j],["__scopeId","data-v-728b9683"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/50.md","filePath":"drive/50.md"}'),B={name:"drive/50.md"},U=Object.assign(B,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
