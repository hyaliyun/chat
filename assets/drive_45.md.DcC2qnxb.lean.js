import{_ as c,o as n,c as i,a as t,m as h,t as d,C as g,M as y,U as _,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),h(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),h(d(l.poem.solution),1)])])])}const O=c(k,[["render",A],["__scopeId","data-v-57ed54c6"]]),N=JSON.parse('[{"question":"# Problem Description Given the provided implementation of an AVL Tree, your task is to complete the implementation to include the following functionalities: 1. **Delete Operation**: Implement a method to delete a key from the AVL tree while maintaining the tree\'s balance. 2. **Find Operation**: Implement a method to find a given key in the AVL tree. Return `True` if the key exists, otherwise return `False`. 3. **Pre-order Traversal**: Implement a method to perform a pre-order traversal of the AVL tree and return the elements in a list. 4. **Post-order Traversal**: Implement a method to perform a post-order traversal of the AVL tree and return the elements in a list. # Additional Details **Input and Output**: * The delete operation should take an `int` key as input and not return anything. * The find operation should take an `int` key as input and return a `bool` indicating the presence of the key. * The pre-order traversal operation should return a list of elements in pre-order. * The post-order traversal operation should return a list of elements in post-order. **Constraints**: * All keys are integers. * Input keys for insert/delete/find operations are within the range of `-10^6` to `10^6`. * Input keys are unique. **Performance Requirements**: * The implemented methods should maintain the AVL tree properties, ensuring O(log n) operations. # Implementation Complete the provided AVL tree class with the required methods. Here\'s the class header along with the imports and base structure: ```python Imports TreeNodes - assume the TreeNode class is already defined with necessary attributes. from tree.tree import TreeNode class AvlTree(object): An AVL tree. def __init__(self): self.node = None self.height = -1 self.balance = 0 def insert(self, key): # Implementation provided above. pass def delete(self, key): # To be implemented by the student. pass def find(self, key): # To be implemented by the student. pass def re_balance(self): # Implementation provided above. pass def update_heights(self, recursive=True): # Implementation provided above. pass def update_balances(self, recursive=True): # Implementation provided above. pass def rotate_right(self): # Implementation provided above. pass def rotate_left(self): # Implementation provided above. pass def in_order_traverse(self): # Implementation provided above. pass def pre_order_traverse(self): # To be implemented by the student. pass def post_order_traverse(self): # To be implemented by the student. pass ``` **Completion Requirements**: * Implement the `delete`, `find`, `pre_order_traverse`, and `post_order_traverse` methods. * Ensure the AVL tree remains balanced after each delete operation. * Conduct pre- and post-order tree traversals accurately.","solution":"class TreeNode: A node in the AVL tree. def __init__(self, key): self.left = None self.right = None self.key = key self.height = 1 class AvlTree: An AVL tree. def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and key < node.left.key: return self._rotate_right(node) # Right Right if balance < -1 and key > node.right.key: return self._rotate_left(node) # Left Right if balance > 1 and key > node.left.key: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Left if balance < -1 and key < node.right.key: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp_val = self._get_min_value_node(node.right) node.key = temp_val.key node.right = self._delete(node.right, temp_val.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left if balance > 1 and self._get_balance(node.left) >= 0: return self._rotate_right(node) # Left Right if balance > 1 and self._get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) # Right Right if balance < -1 and self._get_balance(node.right) <= 0: return self._rotate_left(node) # Right Left if balance < -1 and self._get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def find(self, key): return self._find(self.root, key) def _find(self, node, key): if not node: return False if key == node.key: return True elif key < node.key: return self._find(node.left, key) else: return self._find(node.right, key) def pre_order_traverse(self): result = [] self._pre_order(self.root, result) return result def _pre_order(self, node, result): if not node: return result.append(node.key) self._pre_order(node.left, result) self._pre_order(node.right, result) def post_order_traverse(self): result = [] self._post_order(self.root, result) return result def _post_order(self, node, result): if not node: return self._post_order(node.left, result) self._post_order(node.right, result) result.append(node.key) def _rotate_right(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _rotate_left(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _get_min_value_node(self, node): if node is None or node.left is None: return node return self._get_min_value_node(node.left)"},{"question":"Hailstone Sequence Analysis You are tasked with analyzing the Hailstone sequence (Collatz sequence) properties. To do so, you must write a function that not only generates the sequence for a given number `n`, but also determines the length of the sequence and the highest value encountered in the sequence. Function Signature ```python def hailstone_analysis(n: int) -> (int, int, list): ``` Input * An integer `n`, where `1 <= n <= 10^6`. Output * A tuple containing: 1. The length of the hailstone sequence. 2. The maximum value encountered in the sequence. 3. The hailstone sequence itself, as a list of integers. Constraints * Handle large inputs efficiently. * Ensure the function works for boundary value input cases. Performance Requirements * The function should be able to handle the upper limit efficiently (both time and space). Example ```python >>> hailstone_analysis(5) (6, 16, [5, 16, 8, 4, 2, 1]) >>> hailstone_analysis(1) (1, 1, [1]) >>> hailstone_analysis(10) (7, 16, [10, 5, 16, 8, 4, 2, 1]) ```","solution":"def hailstone_analysis(n: int) -> (int, int, list): Generate the Hailstone sequence starting from n, and return the sequence length, the maximum value in the sequence, and the sequence itself. sequence = [] max_value = n while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 max_value = max(max_value, n) sequence.append(1) # Add the final 1 to the sequence return len(sequence), max_value, sequence"},{"question":"# Array Filtering within Specified Bounds You are given a list of integers and two optional integer boundaries, `min_lim` and `max_lim`. Your task is to filter the list so that only the values within the range `[min_lim, max_lim]` are included. If a limit (`min_lim` or `max_lim`) is not provided (i.e., None), it should default to the smallest or largest value in the list, respectively. # Function Signature ```python def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: pass ``` # Input - `arr`: A list of integers. - `min_lim` (optional): An integer representing the inclusive lower bound of the range. If None, use the smallest value in `arr`. - `max_lim` (optional): An integer representing the inclusive upper bound of the range. If None, use the largest value in `arr`. # Output - Returns a new list containing only the integers in `arr` that lie within the range `[min_lim, max_lim]`. # Constraints - The length of `arr` will be between 0 and 10^6. - Elements of `arr` are within the range of -10^9 to 10^9. - `arr` contains only integers, but may be empty. # Performance Requirements - The function should run in O(n) time complexity where n is the length of the array. # Examples ```python # Example 1: # Input: arr = [1, 2, 3, 4, 5], min_lim = 2, max_lim = 4 # Output: [2, 3, 4] print(limit([1, 2, 3, 4, 5], 2, 4)) # Example 2: # Input: arr = [10, 20, 30, 40, 50], min_lim = 20, max_lim = None # Output: [20, 30, 40, 50] print(limit([10, 20, 30, 40, 50], 20, None)) # Example 3: # Input: arr = [0, -10, 5, 7], min_lim = None, max_lim = 5 # Output: [0, -10, 5] print(limit([0, -10, 5, 7], None, 5)) # Example 4: # Input: arr = [1, 2, 3], min_lim = 5, max_lim = 10 # Output: [] print(limit([1, 2, 3], 5, 10)) # Example 5: # Input: arr = [], min_lim = 1, max_lim = 3 # Output: [] print(limit([], 1, 3)) ``` Implement the `limit` function to achieve the described functionality.","solution":"def limit(arr: list, min_lim: int = None, max_lim: int = None) -> list: Filters the array so that only values within the range [min_lim, max_lim] are included. If min_lim is None, it uses the smallest value in the array. If max_lim is None, it uses the largest value in the array. if not arr: return [] if min_lim is None: min_lim = min(arr) if max_lim is None: max_lim = max(arr) return [x for x in arr if min_lim <= x <= max_lim]"},{"question":"You are given an array of integers representing frequencies of elements. You need to efficiently perform two types of operations on this array: 1. Update the frequency of a specific element in the array. 2. Retrieve the prefix sum, which is the sum of frequencies from the beginning of the array up to a given index. To achieve this, implement a Fenwick Tree (Binary Indexed Tree). # Task Write a class `FenwickTree` with the following methods: - `__init__(self, freq: List[int])`: Initializes the Fenwick Tree with the given frequency array. - `update(self, index: int, value: int)`: Updates the frequency of the element at the specified index to the new value provided. - `prefix_sum(self, index: int) -> int`: Returns the sum of the frequencies from the start of the array up to the specified index. # Input - `freq`: A list of integers representing the initial frequencies. - `index`: An integer within the range of the list\'s length, indicating the position of the element to update. - `value`: An integer representing the new frequency value. - For `prefix_sum`, an integer `index` within the range of the list\'s length, indicating the end of the range for which prefix sum needs to be calculated. # Output - For `update`, no output is expected. - For `prefix_sum`, return the sum of the frequencies from the start of the array up to the specified index. # Constraints - The array `freq` can have up to `100,000` elements. - The frequency values and updated values can be any integer within the range of `[-1,000,000, 1,000,000]`. # Example ```python # Example usage: freq = [1, 7, 3, 0, 7, 8, 3] fenwick_tree = FenwickTree(freq) # Update the frequency at index 3 fenwick_tree.update(3, 5) # Query the prefix sum up to index 4 result = fenwick_tree.prefix_sum(4) # Expected output: 1 + 7 + 3 + 5 + 7 = 23 ``` # Performance Requirement - Both operations (update and prefix_sum) should be performed in O(log n) time complexity.","solution":"class FenwickTree: def __init__(self, freq): Initializes the Fenwick Tree with the given frequency array. self.n = len(freq) self.tree = [0] * (self.n + 1) self.original = [0] * self.n for i in range(self.n): self.update(i, freq[i]) def update(self, index, value): Updates the frequency of the element at the specified index to the new value provided. delta = value - self.original[index] self.original[index] = value index += 1 while index <= self.n: self.tree[index] += delta index += index & -index def prefix_sum(self, index): Returns the sum of the frequencies from the start of the array up to the specified index. sum = 0 index += 1 while index > 0: sum += self.tree[index] index -= index & -index return sum"},{"question":"# Topological Sorting in a Directed Acyclic Graph **Problem Statement**: Topological Sorting of a Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge `u -> v`, vertex `u` comes before `v` in the ordering. **Your task** is to implement a function `topological_sort(graph)` that performs a topological sort on the given graph. Function Signature ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: ``` Input * `graph`: A dictionary where keys are nodes and values are lists of nodes representing directed edges from the key to each of the nodes in the list. Assume the graph is a DAG. Output * Returns a list of nodes representing the topological order. Constraints * The graph does not contain any cycles. * There are at most 10^4 nodes in the graph. * Each node has at most 10^3 edges. Example ```python graph = { 1: [2, 3], 2: [4], 3: [4], 4: [] } assert topological_sort(graph) == [1, 2, 3, 4] or [1, 3, 2, 4] ``` Requirements * Implement the function using a modification of DFS to accomplish the topological sort. * Account for edge cases with varying graph structures. Scenario Imagine you are working on a task scheduler system where tasks depend on the completion of other tasks. To execute the tasks, you need to determine an order of execution that satisfies all dependencies. Your implemented function will assist in generating such an execution plan by leveraging topological sorting of a DAG.","solution":"def topological_sort(graph): Perform a topological sort on the given graph. :param graph: Dictionary where keys are nodes and values are lists of nodes representing directed edges. :type graph: Dict[int, List[int]] :return: A list of nodes representing the topological order. :rtype: List[int] def dfs(node): # Mark the current node as visited (temporary mark). visited.add(node) # Visit all the adjacent nodes. for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor) # Add the current node to the topological order (post-order). topo_order.append(node) visited = set() topo_order = [] # Call the dfs function starting from all nodes to cover disconnected parts of the graph. for node in graph: if node not in visited: dfs(node) # Since we are appending in post-order, we need to reverse to get the correct topological sort. return topo_order[::-1]"},{"question":"# Scenario You are working on a data cleaning pipeline, and one of the tasks requires you to remove duplicate entries from a list to ensure subsequent processing steps operate on unique data. Additionally, to improve efficiency, any improvements on the original approach would be greatly appreciated. # Task Implement a function `remove_duplicates_optimized(array)` that removes duplicates from the array while demonstrating better performance than the original O(N^2) time complexity. # Input Format: - The input is a list `array` containing elements of any data type. # Output Format: - The function returns a list with duplicates removed, preserving the original order of first occurrence. # Constraints: - The function should handle generic lists, including mixed types. - Aim to improve the time complexity from O(N^2) to O(N). # Example: ```python Input: [1, 1, 1, 2, 2, 3, 4, 4, \\"hey\\", \\"hey\\", \\"hello\\", True, True] Output: [1, 2, 3, 4, \'hey\', \'hello\', True] ``` # Notes: - The order of elements in the output list should match their first occurrence in the input list. - Consider using data structures that provide better performance for membership checking. # Your Code: ```python def remove_duplicates_optimized(array): # Implement your optimized duplication removal algorithm here pass ```","solution":"def remove_duplicates_optimized(array): Removes duplicates from the array while preserving the original order of first occurrence. Parameters: array (list): The input list containing elements of any data type. Returns: list: A new list with duplicates removed, retaining original order. seen = set() result = [] for item in array: if item not in seen: seen.add(item) result.append(item) return result"},{"question":"# Context You are tasked to solve a problem involving efficient manipulation of a dataset represented as a binary number. Each bit in the binary number represents a specific setting or flag. Using bit operations, you need to retrieve, modify, and query these flags efficiently. # Problem Statement Write a series of bitwise manipulation functions to handle the following tasks: 1. Retrieve the status of a particular setting (bit). 2. Enable a specific setting (bit). 3. Disable a specific setting (bit). 4. Update a specific setting (bit) to a given value. Implement the following functions: 1. `get_bit(num: int, i: int) -> bool` - **Input**: An integer `num` and an index `i`. - **Output**: A boolean indicating whether the ith bit is set. 2. `set_bit(num: int, i: int) -> int` - **Input**: An integer `num` and an index `i`. - **Output**: An integer with the ith bit set to `1`. 3. `clear_bit(num: int, i: int) -> int` - **Input**: An integer `num` and an index `i`. - **Output**: An integer with the ith bit cleared to `0`. 4. `update_bit(num: int, i: int, bit: int) -> int` - **Input**: An integer `num`, an index `i`, and a `bit` value (0 or 1). - **Output**: An integer reflecting the change of the ith bit to the `bit` value. # Constraints - `0 <= i < 32` (you can assume standard 32-bit integers). - `num` is a non-negative integer. - `bit` is either `0` or `1`. # Example For an 8-bit binary number `10101100` (`num = 172` in decimal): - `get_bit(172, 2)` returns `True`. - `set_bit(172, 1)` returns `174`. - `clear_bit(172, 3)` returns `164`. - `update_bit(172, 3, 1)` returns `172`. Use these functions to manipulate binary data efficiently in a larger dataset or low-level data processing scenario.","solution":"def get_bit(num: int, i: int) -> bool: Returns the boolean status of the ith bit in num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the ith bit in num to 1 and returns the new number. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the ith bit in num (sets it to 0) and returns the new number. return num & ~(1 << i) def update_bit(num: int, i: int, bit: int) -> int: Updates the ith bit in num to the given bit (0 or 1) and returns the new number. mask = ~(1 << i) num_cleared = num & mask return num_cleared | (bit << i)"},{"question":"Consider a series of readings/time stamps or sequential data points given within a specified range `[lo, hi]`. Your task is to identify the gaps (missing ranges) in this sequence. Write a function `detect_gaps(arr, lo, hi)` that: 1. Takes in: * a sorted list of integers `arr` representing the sequence. * an integer `lo` representing the lower bound of the range. * an integer `hi` representing the upper bound of the range. 2. Returns a list of tuples where each tuple represents a missing range `(start, end)` indicating missing integers between `lo` and `hi`. # Input * `arr`: a list of integers `arr` sorted in ascending order. * `lo`: an integer defining the lower bound of the range. * `hi`: an integer defining the upper bound of the range. # Output A list of tuples representing the missing ranges. # Constraints * All elements in `arr` will be within the range `[lo, hi]`. * `lo` and `hi` are integers such that `-10^6 <= lo <= hi <= 10^6`. # Example ```python assert detect_gaps([3, 5], 1, 10) == [(1, 2), (4, 4), (6, 10)] assert detect_gaps([], 1, 5) == [(1, 5)] assert detect_gaps([2, 3, 7], 1, 10) == [(1, 1), (4, 6), (8, 10)] ``` # Explanation 1. In the first example, the given sequence `[3, 5]` with bounds `[1, 10]` is missing: * 1 to 2, * 4, * 6 to 10. 2. For an empty array `[]` with bounds `[1, 5]`, the missing range is the entire range itself i.e., `(1, 5)`.","solution":"def detect_gaps(arr, lo, hi): Detects missing ranges in a sorted list of integers within a specified range. Parameters: arr (list): A sorted list of integers. lo (int): The lower bound of the range. hi (int): The upper bound of the range. Returns: list: A list of tuples representing the missing ranges. gaps = [] prev = lo - 1 # Initialize to one less than the lower bound for num in arr: if num > prev + 1: gaps.append((prev + 1, num - 1)) prev = num if prev < hi: gaps.append((prev + 1, hi)) return gaps"},{"question":"Implement Robust Exchange Sort Context You have been hired to work on a legacy system where you need to implement a sorting algorithm leveraging Exchange Sort. However, the system also requires handling of diverse cases, ensuring error robustness and optimization of edge scenarios. Your task involves not only writing the algorithm but also preparing it to handle extreme inputs effectively. Task Write a function `robust_exchange_sort` in Python that sorts a given list of integers using Exchange Sort, but also addresses edge cases and ensures optimal handling of these scenarios. Function Signature ```python def robust_exchange_sort(arr: list[int]) -> list[int]: ``` Input * A list of integers `arr`. Output * A sorted list of integers. Constraints * The input list length ( n ) will range from ( 0 ) to ( 10^3 ). * The elements of the list are integers. Requirements * Ensure that your solution handles edge cases efficiently (e.g., empty array, single element array, arrays with all identical elements). * Your implementation must maintain ( O(1) ) additional space complexity. * The function should be resilient to extreme values and provide correct outputs for all inputs within given constraints. * No use of Python built-in sort functions. Example ```python print(robust_exchange_sort([])) # Output: [] print(robust_exchange_sort([3])) # Output: [3] print(robust_exchange_sort([4, 2, 2, 3, 1])) # Output: [1, 2, 2, 3, 4] print(robust_exchange_sort([7, -2, 0, 15, 4, -1])) # Output: [-2, -1, 0, 4, 7, 15] print(robust_exchange_sort([5, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 5] ``` Performance * Your solution should aim to handle array sizes up to ( 10^3 ) efficiently.","solution":"def robust_exchange_sort(arr: list[int]) -> list[int]: n = len(arr) # Edge case: if the list is empty or has one element, it\'s already sorted if n <= 1: return arr for i in range(n - 1): for j in range(i + 1, n): if arr[i] > arr[j]: arr[i], arr[j] = arr[j], arr[i] return arr"},{"question":"You are given a non-negative integer `num`. Your task is to write a function `next_bigger(num)` that finds the smallest number greater than `num` using the same set of digits. If no such number exists, the function should return -1. # Input * A non-negative integer `num`. # Output * The smallest integer greater than `num` that can be formed with its digits, or -1 if no such number exists. # Constraints * The input number `num` will be in the range of [0, 10^9]. # Example ```python def next_bigger(num): # Your implementation here ``` Examples ```python next_bigger(38276) # returns 38627 next_bigger(12345) # returns 12354 next_bigger(1528452) # returns 1528524 next_bigger(138654) # returns 143568 next_bigger(54321) # returns -1 next_bigger(999) # returns -1 next_bigger(5) # returns -1 ``` # Additional Notes 1. **Edge Cases**: Ensure your solution covers cases where no larger permutation is possible, such as consecutive identical digits (e.g., 999) or single-digit numbers. 2. **Efficiency**: Aim for a solution that operates within linear time complexity with respect to the length of the number.","solution":"def next_bigger(num): Finds the smallest number greater than `num` using the same set of digits. Returns -1 if no such number exists. digits = list(str(num)) i = len(digits) - 2 # Step 1: Find the rightmost digit that is smaller than the digit next to it while i >= 0 and digits[i] >= digits[i+1]: i -= 1 # If no such digit is found, return -1 if i == -1: return -1 # Step 2: Find the smallest digit on the right side of the found digit which is larger than the found digit j = len(digits) - 1 while digits[j] <= digits[i]: j -= 1 # Step 3: Swap the found digit with the smallest larger digit found digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the digits after the original position of the found digit digits = digits[:i+1] + sorted(digits[i+1:]) return int(\\"\\".join(digits))"},{"question":"# Context: You are designing a system that requires frequent conversion of numbers between different numeral systems. Efficient and accurate conversion routines are crucial for ensuring data integrity and simplifying the development of system components interacting with various numeric representations. # Problem Statement: Implement two functions: `int_to_base` and `base_to_int`. **Function 1: `int_to_base(num, base)`** * **Input**: * `num` (int): An integer number to convert. Can be negative. * `base` (int): Base to convert the number to. Between 2 and 36 inclusive. * **Output**: * (str) A string representing the number in the specified base. * **Constraints**: * If `num` is 0, return \'0\'. * Supports bases from 2 to 36. For bases > 10, use uppercase letters \'A\' to \'Z\' to represent values 10 to 35. * **Example**: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-15, 16) == \'-F\' ``` **Function 2: `base_to_int(string, base)`** * **Input**: * `string`: A string representing a number in the specified base. Can have negative sign. * `base` (int): The base of the number in the string. Between 2 and 36 inclusive. * **Output**: * (int) An integer representing the number in base 10. * **Constraints**: * Supports bases from 2 to 36. * The input string can contain invalid characters, treat them as 0 and raise a ValueError exception. * **Example**: ```python assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'-F\', 16) == -15 ``` Implement these functions considering performance, edge cases, and data validation effectively.","solution":"def int_to_base(num, base): Converts an integer to a string in the specified base (2-36). :param num: int - The number to be converted :param base: int - The base to convert the number to :return: str - The converted number in string form if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if num == 0: return \'0\' digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" sign = \'-\' if num < 0 else \'\' num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base result.reverse() return sign + \'\'.join(result) def base_to_int(string, base): Converts a string in the specified base to an integer. :param string: str - The number in string form :param base: int - The base of the number in the string :return: int - The converted number as an integer if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" digit_map = {char: index for index, char in enumerate(digits)} sign = -1 if string[0] == \'-\' else 1 if string[0] in [\'-\', \'+\']: string = string[1:] result = 0 power = 1 for char in reversed(string): if char not in digit_map or digit_map[char] >= base: raise ValueError(f\\"Invalid character \'{char}\' for base {base}\\") result += digit_map[char] * power power *= base return sign * result"},{"question":"# Question Scenario You are tasked with developing a system that needs to handle financial transactions through a vending machine. As part of verifying the number of ways to provide change, you are given a set of coin denominations and a value. Task Implement a function `count(coins, value)` that determines the number of distinct ways to make change for the given `value` using the provided `coins`. Input - `coins` (list of int): A list of distinct integer denominations, (1 leq coins[i] leq 50), and the size of coins list, (1 leq len(coins) leq 50). - `value` (int): The amount for which you need to find the change combinations, (0 leq value leq 1000). Output - Return the number of ways to make the change for the given `value`. Example ```python # Example 1 coins = [1, 2, 3] value = 4 # Expected Output: 4 # Explanation: The four ways are [1, 1, 1, 1], [1, 1, 2], [2, 2], [1, 3] # Example 2 coins = [2, 5, 3, 6] value = 10 # Expected Output: 5 # Explanation: The five ways are [2, 2, 2, 2, 2], [2, 2, 3, 3], [2, 2, 6], [2, 3, 5], [5, 5] ``` Constraints - Ensure that your solution doesn\'t exceed the time complexity of (O(n times m)) and space complexity of (O(n)). Function Signature ```python def count(coins, value): pass ```","solution":"def count(coins, value): Returns the number of distinct ways to make change for the given value using the provided coins. # Initialize a list to store the number of ways to make each amount dp = [0] * (value + 1) dp[0] = 1 # There\'s 1 way to make 0 value (no coins) # Iterate over each coin for coin in coins: # Update the dp array from coin value up to the target value for i in range(coin, value + 1): dp[i] += dp[i - coin] return dp[value]"},{"question":"Given a non-empty string, determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together. Implement the function `repeat_substring(s)` that returns True if the string can be constructed by repeating a substring, otherwise returns False. Function Signature ```python def repeat_substring(s: str) -> bool: ``` Input - `s`: A non-empty string composed of lowercase English letters (1 ≤ len(s) ≤ 10000). Output - Returns a boolean value, `True` if the string can be constructed by repeating a substring, otherwise `False`. Examples ```python assert repeat_substring(\\"abab\\") == True assert repeat_substring(\\"aba\\") == False assert repeat_substring(\\"abcabcabcabc\\") == True ``` Constraints - You need to ensure your solution works efficiently for strings up to length 10000. # Context and Guidelines The problem deals with checking the structural repetition in a string. The primary algorithm involves string manipulation and slicing. Given that the length could be up to 10000, aim for an O(n) time complexity solution to handle larger inputs efficiently. - Consider both trivial (e.g., single character strings) and non-trivial edge cases. - Test the function\'s performance with strings with varying lengths and patterns.","solution":"def repeat_substring(s: str) -> bool: Determine if the string s can be constructed by taking a substring of it and appending multiple copies of the substring together. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: if s[:i] * (n // i) == s: return True return False"},{"question":"# Question: Implement and Extend a RandomizedSet You are given a partial implementation of a `RandomizedSet` data structure which supports `insert`, `remove`, and fetching a random element in average O(1) time. Your task is to: 1. Implement a function that returns whether the `RandomizedSet` is empty. 2. Modify the `remove` method to return `True` if the element was successfully removed and `False` otherwise. 3. Implement a function `get_all_elements` that returns a list of all elements in the `RandomizedSet`. # Function Signatures ```python class RandomizedSet: def __init__(self): pass def insert(self, val: int) -> None: pass def remove(self, val: int) -> bool: pass def random_element(self) -> int: pass def is_empty(self) -> bool: pass def get_all_elements(self) -> List[int]: pass ``` # Input - `RandomizedSet()` initializes an empty `RandomizedSet`. - `insert(val)` inserts an element `val` into the set. - `remove(val)` removes an element `val` from the set. - `random_element()` returns a random element from the set. - `is_empty()` returns `True` if the set is empty, `False` otherwise. - `get_all_elements()` returns a list of all elements currently in the set. # Output - `insert(val)` modifies the set without returning a value. - `remove(val)` returns `True` if `val` was removed, `False` otherwise. - `random_element()` returns any element from the set uniformly at random. - `is_empty()` returns a boolean indicating whether the set is empty. - `get_all_elements()` returns a list of all elements in the set. # Constraints - Elements are non-negative integers. - At most 10^4 operations will be performed. - For simplicity, you can assume that `random_element()` will not be called on an empty set. # Example ```python rset = RandomizedSet() print(rset.is_empty()) # True rset.insert(1) print(rset.is_empty()) # False print(rset.get_all_elements()) # [1] print(rset.remove(1)) # True print(rset.get_all_elements()) # [] print(rset.remove(1)) # False print(rset.is_empty()) # True ``` # Additional Notes Ensure all operations maintain the expected average O(1) time complexity. Be careful with edge cases such as removing non-existent elements and random access of elements.","solution":"import random class RandomizedSet: def __init__(self): self.dict = {} self.list = [] def insert(self, val: int) -> None: if val not in self.dict: self.dict[val] = len(self.list) self.list.append(val) def remove(self, val: int) -> bool: if val in self.dict: last_element, idx = self.list[-1], self.dict[val] self.list[idx], self.dict[last_element] = last_element, idx self.list.pop() del self.dict[val] return True return False def random_element(self) -> int: return random.choice(self.list) def is_empty(self) -> bool: return len(self.list) == 0 def get_all_elements(self) -> list: return self.list[:]"},{"question":"# Background Context You are given various documents where you need to detect specific keywords efficiently. In this task, you\'ll implement a function to search for a list of words in a given text board, ensuring robust handling of large datasets through effective use of data structures and algorithms. # Task Implement a function `find_keywords(text_matrix: List[List[str]], keywords: List[str]) -> List[str]` that takes a 2D list of characters (`text_matrix`) and a list of words (`keywords`). Your function should return a list of words from `keywords` that can be found in `text_matrix` by searching row-wise, column-wise, and diagonally. # Parameters - `text_matrix` (List[List[str]]): The 2D grid of characters. - `keywords` (List[str]): List of words to search within the text matrix. # Constraints - All characters in `keywords` and `text_matrix` are lowercase English letters. - 1 <= len(keywords) <= 1000 - 1 <= len(text_matrix), len(text_matrix[0]) <= 100 # Output Return the list of valid words found in the text matrix. # Example Input/Output Input ```python text_matrix = [ [\'t\', \'h\', \'i\', \'s\'], [\'a\', \'w\', \'o\', \'r\'], [\'t\', \'e\', \'s\', \'t\'], [\'h\', \'e\', \'l\', \'l\'] ] keywords = [\\"this\\", \\"test\\", \\"hell\\", \\"word\\"] ``` Output ```python [\\"this\\", \\"test\\", \\"hell\\"] ``` # Explanation The words \\"this\\", \\"test\\", and \\"hell\\" can be found in the text matrix, whereas \\"word\\" cannot. # Note * You may move in all 8 possible directions (horizontally, vertically, and diagonally). * Words must be constructed from letters of sequentially adjacent cell, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. * The same cell may not be used more than once within a single word.","solution":"from typing import List def find_keywords(text_matrix: List[List[str]], keywords: List[str]) -> List[str]: rows = len(text_matrix) cols = len(text_matrix[0]) if rows > 0 else 0 # Directions: right, down, left, up, top-right, bottom-right, bottom-left, top-left directions = [(0, 1), (1, 0), (0, -1), (-1, 0), (-1, 1), (1, 1), (1, -1), (-1, -1)] def is_valid(x, y): return 0 <= x < rows and 0 <= y < cols def search(word): for r in range(rows): for c in range(cols): if text_matrix[r][c] == word[0]: # Found first letter for dx, dy in directions: nr, nc = r, c i = 0 while i < len(word) and is_valid(nr, nc) and text_matrix[nr][nc] == word[i]: nr += dx nc += dy i += 1 if i == len(word): # Found the word return True return False result = [] for word in keywords: if search(word): result.append(word) return result"},{"question":"# Unique Character Finder Scenario Given the increasing importance of text analysis in different fields such as sentiment analysis, information retrieval, and linguistics, it\'s essential to identify unique characters from strings efficiently. You are required to improve the solution by implementing a more optimal algorithm that finds the index of the first non-repeating character in a given string. Specifications * **Function**: `firstUniqueChar(s: str) -> int` * **Input**: - `s`: A string of lowercase English letters (1 <= len(s) <= 105). * **Output**: - Return the index of the first non-repeating character. - If no such character exists, return -1. Constraints * Ensure the solution runs at linear time complexity O(n). * Utilize only constant extra space O(1) if possible. * Do not modify the input string. Examples ```python print(firstUniqueChar(\\"leetcode\\")) # Output: 0 print(firstUniqueChar(\\"loveleetcode\\")) # Output: 2 print(firstUniqueChar(\\"aabb\\")) # Output: -1 ``` Notes * The solution should efficiently handle large input strings.","solution":"def firstUniqueChar(s: str) -> int: Returns the index of the first non-repeating character in the string `s`. If no such character exists, returns -1. # Dictionary to store frequency of each character char_count = {} # First pass: count the frequencies for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first unique character for index, char in enumerate(s): if char_count[char] == 1: return index return -1"},{"question":"# Objective Design a function to solve the \\"House Robber\\" dynamic programming problem with the constraints provided. # Problem Description You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. The only constraint stopping you from robbing each of them is that adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses are broken into on the same night. Given a list of non-negative integers representing the amount of money of each house, determine the maximum amount of money you can rob tonight without alerting the police. # Function Signature ```python def house_robber(houses: List[int]) -> int: ``` # Input * `houses`: A list of non-negative integers of length `n` (0 ≤ n ≤ 10^4), representing the money stashed in each house. # Output * Return an integer representing the maximum amount of money you can rob without alerting the police. # Constraints * You cannot rob two adjacent houses. * The list can be empty, in which case you should return 0. * Edge cases such as lists with single elements or all zero values need to be handled. # Example ```python assert house_robber([2, 7, 9, 3, 1]) == 12 # Rob houses with amounts 2, 9, and 1 assert house_robber([1, 2, 3, 1]) == 4 # Rob houses with amounts 1 and 3 assert house_robber([0]) == 0 # With a single house having 0 money assert house_robber([]) == 0 # No houses to rob assert house_robber([2, 1, 1, 2]) == 4 # Rob houses with amounts 2 and 2 ``` # Performance Your solution should be optimized for speed with a linear time complexity O(n) and space complexity O(1).","solution":"from typing import List def house_robber(houses: List[int]) -> int: if not houses: return 0 n = len(houses) if n == 1: return houses[0] prev1, prev2 = 0, 0 for money in houses: current = max(prev1, prev2 + money) prev2 = prev1 prev1 = current return prev1"},{"question":"# Context: You are tasked with writing a function to filter an array of numerical values by given thresholds. This will help filter out out-of-bounds values effectively. Your function should be robust against various edge cases and optimize for performance. # Task: Write a function `efficient_limit` to achieve the same purpose as the original `limit` function, while addressing its identified performance bottlenecks and improving overall efficiency. # Function Signature: ```python def efficient_limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: pass ``` # Input: 1. `arr` (List[int]): An array of integers. (0 ≤ len(arr) ≤ 10^6) 2. `min_lim` (Optional[int]): The minimum threshold (inclusive). `None` indicates no minimum threshold. 3. `max_lim` (Optional[int]): The maximum threshold (inclusive). `None` indicates no maximum threshold. # Output: * A list containing elements from the input array that are within the specified thresholds. # Constraints: 1. `-10^9 ≤ arr[i] ≤ 10^9` for all elements in `arr`. 2. min_lim and max_lim, if provided, will also lie within the range `-10^9` to `10^9`. # Example: ```python efficient_limit([1, 2, 3, 4, 5], None, 3) # Output: [1, 2, 3] efficient_limit([12, 4, 56, 3, 7, 8], 5, 10) # Output: [7, 8] efficient_limit([-5, 0, 5, 10, 15, 20], -5, 10) # Output: [-5, 0, 5, 10] efficient_limit([], 0, 10) # Output: [] ``` # Notes: - If `min_lim` is `None`, consider all elements smaller than `max_lim`. - If `max_lim` is `None`, consider all elements larger than `min_lim`. - Ensure the solution is optimized for large inputs, using linear time complexity wherever possible.","solution":"from typing import List, Optional def efficient_limit(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters an array to include only elements within the given thresholds. :param arr: List of integers to be filtered. :param min_lim: Minimum threshold (inclusive). None indicates no minimum threshold. :param max_lim: Maximum threshold (inclusive). None indicates no maximum threshold. :return: A list of integers within the specified thresholds. if min_lim is None and max_lim is None: return arr # No filtering needed if no limits are set result = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): result.append(num) return result"},{"question":"# Number Base Conversion Problem You have been tasked to implement functions for integer base conversions. You need to write two functions, `int_to_base` and `base_to_int`. **int_to_base Function** This function converts a given integer to its representation in a specified base. - **Function Signature**: `def int_to_base(num: int, base: int) -> str` - **Input**: - `num` (int): The integer value to be converted. It can be negative. - `base` (int): The base for the conversion. Should be between 2 and 36. - **Output**: - A string representing the number in the given base. - **Constraints**: - The base must be between 2 and 36. - The function should handle negative numbers properly. **base_to_int Function** This function converts a given string representation of a number in a specified base back to an integer. - **Function Signature**: `def base_to_int(str_to_convert: str, base: int) -> int` - **Input**: - `str_to_convert` (str): The string representation of the number. - `base` (int): The base of the number in the string. Should be between 2 and 36. - **Output**: - The integer value of the string in the specified base. - **Constraints**: - The base must be between 2 and 36. - The input string should represent a non-negative number. - The input string should contain valid characters for the specified base. Implement the two functions `int_to_base` and `base_to_int` as described. Ensure to handle edge cases and optimize for performance. **Example** ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-255, 16) == \'-FF\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'FF\', 16) == 255 ```","solution":"def int_to_base(num: int, base: int) -> str: Converts an integer to its representation in a specified base. Parameters: num (int): The integer value to be converted. It can be negative. base (int): The base for the conversion. Should be between 2 and 36. Returns: str: A string representing the number in the given base. if not (2 <= base <= 36): raise ValueError(\\"base must be between 2 and 36\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" is_negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if is_negative: result.append(\'-\') return \'\'.join(result[::-1]) def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation of a number in a specified base back to an integer. Parameters: str_to_convert (str): The string representation of the number. base (int): The base of the number in the string. Should be between 2 and 36. Returns: int: The integer value of the string in the specified base. if not (2 <= base <= 36): raise ValueError(\\"base must be between 2 and 36\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" value_map = {char: index for index, char in enumerate(digits)} result = 0 is_negative = str_to_convert[0] == \'-\' for char in str_to_convert[is_negative:]: if char.upper() not in value_map or value_map[char.upper()] >= base: raise ValueError(f\\"Invalid character {char} for base {base}\\") result = result * base + value_map[char.upper()] return -result if is_negative else result"},{"question":"# Question: Longest Common Prefix in DNA Sequences **Scenario**: Biologists frequently work with sequences of DNA, which are long strings composed of the characters \'A\', \'C\', \'G\', and \'T\'. When comparing a set of DNA sequences, it\'s often useful to find the longest common prefix (LCP) among them, which can highlight conserved motifs or sets of common properties. **Task**: Write a Python function to find the longest common prefix string amongst an array of DNA sequences. If there is no common prefix, the function should return an empty string \\"\\". # Function Signature: ```python def longest_common_dna_prefix(sequences: List[str]) -> str: ``` # Inputs: - `sequences`: a list of strings, where each string represents a DNA sequence. All strings are non-empty and consist solely of the characters \'A\', \'C\', \'G\', and \'T\'. # Output: - A string representing the longest common prefix among all DNA sequences in the input list. # Constraints: - The number of DNA sequences will not exceed 1000. - The length of each DNA sequence will not exceed 10,000 characters. # Example: ```python Example 1: Input: [\\"ACGTACGT\\", \\"ACGTAGCA\\", \\"ACGT\\"] Output: \\"ACGT\\" Example 2: Input: [\\"ACG\\", \\"TCGA\\", \\"GGT\\"] Output: \\"\\" ``` # Note: Make sure your function handles edge cases like: - Empty list of sequences (though not mentioned in inputs, handling it gracefully as an extra precaution), - Very long sequences (up to the given constraint), - Sequences with no common prefix. # Performance Requirement: - Your function should efficiently handle inputs up to the constraints outlined.","solution":"from typing import List def longest_common_dna_prefix(sequences: List[str]) -> str: if not sequences: return \\"\\" # Start with the prefix as the first sequence prefix = sequences[0] for seq in sequences[1:]: # Compare the current prefix with the sequence and shorten it if necessary while seq[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] if not prefix: break return prefix # Return the longest common prefix found"},{"question":"# AVL Tree Implementation and Balance Operations Context An AVL Tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one. If at any time they differ by more than one, re-balancing is done to restore this property. Task Your task is to implement and test the AVL Tree insertion and balancing operations. Write a function `insert_avl(avl_tree, key)` that inserts a `key` into the given `avl_tree` and then balances the tree if necessary. You should use the provided AVL Tree class and its methods for this purpose. # Function Signature ```python def insert_avl(avl_tree: AvlTree, key: int) -> None: ... ``` # Parameters - `avl_tree` (AvlTree): The root of the AVL tree where the key should be inserted. - `key` (int): The value to be inserted into the AVL tree. Example Consider the following example: ```python tree = AvlTree() insert_avl(tree, 10) insert_avl(tree, 20) insert_avl(tree, 30) print(tree.in_order_traverse()) # Output should be [10, 20, 30] ``` Constraints - Assume the keys are unique integers. - You should handle the insertion process in such a way that the AVL tree properties are maintained (balance factor of each node is -1, 0, or 1). Notes - Ensure the balance factors are correctly updated after each insertion. - Handle edge cases such as inserting into an empty tree or causing rotations that affect multiple levels of the tree. - Focus on correct re-balancing using single and double rotations as needed.","solution":"class AvlNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return AvlNode(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1: if key < node.left.key: return self.right_rotate(node) else: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1: if key > node.right.key: return self.left_rotate(node) else: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def in_order_traverse(self): return self._in_order_traverse(self.root) def _in_order_traverse(self, node): res = [] if node: res = self._in_order_traverse(node.left) res.append(node.key) res = res + self._in_order_traverse(node.right) return res def insert_avl(avl_tree: AvlTree, key: int) -> None: avl_tree.insert(key)"},{"question":"Context You are creating a personal finance application where you often need to perform arithmetic operations on large financial figures without exceeding memory limits or hitting performance issues. To enhance your understanding of bitwise operations, you have decided to implement a function that can add two integers without using the \'+\' operator. Task Implement a function `add_bitwise_operator` that takes two non-negative integers and returns their sum using bitwise operations only. The function should handle all edge cases such as very large integers and zero correctly. Function Signature ```python def add_bitwise_operator(x: int, y: int) -> int: pass ``` Input * Two non-negative integers `x` and `y`. Output * An integer representing the sum of `x` and `y`. Constraints * Do not use the \'+\' operator directly. * Inputs will be non-negative integers. * Ensure the function operates efficiently for large values of x and y. Performance Requirements * The function should have a time complexity of O(n), where n is the number of bits in the input numbers. * The space complexity should be O(1). Example ```python assert add_bitwise_operator(2, 3) == 5 assert add_bitwise_operator(10, 22) == 32 assert add_bitwise_operator(0, 123456789) == 123456789 ```","solution":"def add_bitwise_operator(x: int, y: int) -> int: Returns the sum of x and y using bitwise operations only. while y != 0: carry = x & y x = x ^ y y = carry << 1 return x"},{"question":"You are a software developer working on an e-commerce platform that requires sorting lists of product prices. To ensure a robust and efficient sorting function, you decide to implement and validate the Bubble Sort algorithm described above. Specifically, you should write a function that sorts a given list of integers corresponding to product prices, and ensure the correctness through handling all possible edge cases. # Function Signature Implement the function `bubble_sort(arr: List[int], simulation: bool = False) -> List[int]`. # Input * `arr`: A list of integers representing the prices of products. * `simulation`: An optional boolean flag (default False) indicating whether to print the intermediate steps of the sorting process. # Output * A sorted list of integers in ascending order. # Constraints * 0 <= len(arr) <= 10^3 * -10^6 <= arr[i] <= 10^6 (for any element in arr) # Performance Requirements * The function should perform significantly well with input size up to 1000 within reasonable time limits. # Example ```python # Example 1 prices = [64, 34, 25, 12, 22, 11, 90] sorted_prices = bubble_sort(prices) print(sorted_prices) # Output: [11, 12, 22, 25, 34, 64, 90] # Example 2 prices = [5, 1, 4, 2, 8] sorted_prices = bubble_sort(prices, True) # Expected console output: # iteration 0 : 5 1 4 2 8 # iteration 1 : 1 5 4 2 8 # iteration 2 : 1 4 5 2 8 # iteration 3 : 1 4 2 5 8 # iteration 4 : 1 2 4 5 8 # Final output: [1, 2, 4, 5, 8] # Example 3 prices = [] sorted_prices = bubble_sort(prices) print(sorted_prices) # Output: [] ``` # Notes * The printed iterations are only for the case when `simulation` is set to `True`. Otherwise, the function performs sorting without additional console output. * Ensure your implementation does not assume the input list will only contain numeric types, handle edge cases appropriately.","solution":"from typing import List def bubble_sort(arr: List[int], simulation: bool = False) -> List[int]: n = len(arr) for i in range(n): swapped = False for j in range(0, n-i-1): if arr[j] > arr[j+1]: arr[j], arr[j+1] = arr[j+1], arr[j] swapped = True if simulation: print(f\\"iteration {i} : {\' \'.join(map(str, arr))}\\") if not swapped: break return arr"},{"question":"Scenario: You are tasked with developing a utility function that finds the nth digit in the concatenated sequence of all natural numbers. For instance, the sequence of natural numbers starts as \\"1234567891011121314...\\" Task: Write a function `find_nth_digit(n: int) -> int` that returns the nth digit of this infinite sequence. Input: * A single integer `n` (1 ≤ n ≤ 2 * 10^9) representing the position in the sequence. Output: * A single integer representing the nth digit in the sequence. Constraints: * Your solution should have a time complexity of O(log(n)) and a constant space complexity. Example: ```python assert find_nth_digit(11) == 0 # The sequence is \\"123456789101112...\\", 0 is the 11th digit. assert find_nth_digit(3) == 3 # The sequence is \\"123456789...\\", 3 is the 3rd digit. assert find_nth_digit(15) == 2 # The sequence is \\"123456789101112131415...\\", 2 is the 15th digit. ``` Performance Requirements: Given the large possible value of `n`, ensure your solution efficiently calculates the result without unnecessary computations. Additional Notes: Implementation should handle edge cases where `n` pushes the bounds of standard numerical ranges gracefully, ensuring robustness.","solution":"def find_nth_digit(n: int) -> int: Returns the nth digit in the concatenated sequence of all natural numbers. length, count, start = 1, 9, 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"Implement a Binary Search Tree You are tasked with implementing a Binary Search Tree (BST) data structure in Python. Your implementation should support the following operations: 1. **Insertion**: Insert a new value into the BST. 2. **Search**: Check whether a value exists in the BST. 3. **Deletion**: Remove a value from the BST, maintaining the BST properties. 4. **In-order Traversal**: Return the in-order traversal of the BST. Function Signatures - `insert(self, root: TreeNode, val: int) -> TreeNode` - `search(self, root: TreeNode, val: int) -> bool` - `delete(self, root: TreeNode, val: int) -> TreeNode` - `in_order_traversal(self, root: TreeNode) -> list` Input and Output Requirements * **Input**: - `root`: The root node of the BST. - `val`: The value to be inserted, searched, or deleted. * **Output**: - For `insert`: Return the root of the modified BST. - For `search`: Return `True` if the value exists in the BST, otherwise `False`. - For `delete`: Return the root of the modified BST. - For `in_order_traversal`: Return a list of values representing the in-order traversal of the BST. * **Constraints**: - Values to be inserted will be integers. - Ensure you handle edge cases such as empty trees, duplicate inserts, and deletion of nodes with zero, one, and two children. Scenario You are building a small in-memory database using a Binary Search Tree for efficient data storage and retrieval. Implement the required BST functionalities to support common database operations: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def insert(self, root: TreeNode, val: int) -> TreeNode: # Write your code here def search(self, root: TreeNode, val: int) -> bool: # Write your code here def delete(self, root: TreeNode, val: int) -> TreeNode: # Write your code here def in_order_traversal(self, root: TreeNode) -> list: # Write your code here ``` You are expected to write the code for the methods `insert`, `search`, `delete`, and `in_order_traversal` in the `BinarySearchTree` class.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BinarySearchTree: def insert(self, root: TreeNode, val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: root.left = self.insert(root.left, val) elif val > root.val: root.right = self.insert(root.right, val) return root def search(self, root: TreeNode, val: int) -> bool: if root is None: return False if val == root.val: return True elif val < root.val: return self.search(root.left, val) else: return self.search(root.right, val) def delete(self, root: TreeNode, val: int) -> TreeNode: if root is None: return root if val < root.val: root.left = self.delete(root.left, val) elif val > root.val: root.right = self.delete(root.right, val) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.find_min(root.right) root.val = temp.val root.right = self.delete(root.right, temp.val) return root def find_min(self, root: TreeNode) -> TreeNode: while root.left is not None: root = root.left return root def in_order_traversal(self, root: TreeNode) -> list: res = [] if root is not None: res = self.in_order_traversal(root.left) res.append(root.val) res = res + self.in_order_traversal(root.right) return res"},{"question":"# Question: Enhanced Linear Search You are working on a project where you need to handle a large data set. Sometimes, you need to perform searches within this dataset based on specific conditions. Using the linear search algorithm, write a function that extends its capabilities to include not just exact matches, but also the ability to find elements based on a given predicate. Function Signature ```python def enhanced_linear_search(array: list, predicate: callable) -> int: Find the index of the first element in the array that satisfies the given predicate. If no elements satisfy the predicate, return -1. ``` Input * `array` (list): A list of elements of any type. * `predicate` (callable): A function that takes an element of the array as input and returns a boolean. This function will define your search criterion. Output * (int): The index of the first element that satisfies the predicate condition or -1 if no such element exists. Constraints * The `array` can be empty; handle this case appropriately. * The `predicate` function is assumed to be valid and will not throw any exceptions. * The function should aim for O(n) time complexity and O(1) additional space complexity. Example ```python # Example usage: array = [1, 2, 3, 4, 5, 6] predicate = lambda x: x % 2 == 0 # Find the first even number print(enhanced_linear_search(array, predicate)) # Output: 1 ``` In this example, the `predicate` function is used to find the first even number in the array, which in this case is at index 1.","solution":"def enhanced_linear_search(array: list, predicate: callable) -> int: Find the index of the first element in the array that satisfies the given predicate. If no elements satisfy the predicate, return -1. for index, element in enumerate(array): if predicate(element): return index return -1"},{"question":"Enhanced Heap Sort Implement an enhanced heap sort algorithm that can sort arrays in both ascending and descending orders. Your implementation should include the option of using either a max heap or a min heap based on user preference. Additionally, your program should simulate the sorting process and print each iteration step to help understand the sorting process better. Function Signature ```python def enhanced_heap_sort(arr: List[int], order: str = \\"ascending\\", heap_type: str = \\"max\\", simulation: bool = False) -> List[int]: Enhanced heap sort function that can sort using both max heap and min heap for ascending or descending order. Parameters: - arr: List[int] : The array to be sorted. - order: str : The order of sorting (\'ascending\' or \'descending\'). Default is \'ascending\'. - heap_type: str : The type of heap to use (\'max\' or \'min\'). Default is \'max\'. - simulation: bool : If True, prints the array at each iteration step. Default is False. Returns: - List[int] : The sorted array. ``` Input * `arr`: A list of integers that needs to be sorted. * `order`: A string either \\"ascending\\" or \\"descending\\" that specifies the order of sorting. By default, it is \\"ascending\\". * `heap_type`: A string either \\"max\\" or \\"min\\" that specifies the type of heap to use. By default, it is \\"max\\". * `simulation`: A boolean indicating whether to print the array at each iteration step. By default, it is `False`. Output * Returns a sorted list of integers in the specified order using the specified heap type. Constraints * The `order` parameter must be either \\"ascending\\" or \\"descending\\". * The `heap_type` parameter must be either \\"max\\" or \\"min\\". * The length of the input array `arr` is between `0` and `10^5`. Example ```python # Example 1 arr = [3, 2, 5, 1, 7, 4, 6] print(enhanced_heap_sort(arr, order=\'ascending\', heap_type=\'min\', simulation=True)) # Example output of iterations (for ascending min heap): # Iteration 0: [3, 2, 5, 1, 7, 4, 6] # Iteration 1: [1, 2, 5, 3, 7, 4, 6] # Iteration 2: [1, 2, 5, 3, 7, 4, 6] # ... # Sorted output: [1, 2, 3, 4, 5, 6, 7] arr = [15, 10, 20, 25, 30, 5] print(enhanced_heap_sort(arr, order=\'descending\', heap_type=\'max\', simulation=True)) # Example output of iterations (for descending max heap): # Iteration 0: [15, 10, 20, 25, 30, 5] # Iteration 1: [30, 25, 20, 15, 10, 5] # Iteration 2: [30, 25, 20, 15, 10, 5] # ... # Sorted output: [30, 25, 20, 15, 10, 5] ```","solution":"from typing import List def enhanced_heap_sort(arr: List[int], order: str = \\"ascending\\", heap_type: str = \\"max\\", simulation: bool = False) -> List[int]: def heapify(arr, n, i): if heap_type == \'max\': largest = i # Initialize largest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is greater than root if left < n and arr[i] < arr[left]: largest = left # See if right child of root exists and is greater than root if right < n and arr[largest] < arr[right]: largest = right # Change root, if needed if largest != i: arr[i], arr[largest] = arr[largest], arr[i] # swap # Heapify the root. heapify(arr, n, largest) else: # min heap smallest = i # Initialize smallest as root left = 2 * i + 1 # left = 2*i + 1 right = 2 * i + 2 # right = 2*i + 2 # See if left child of root exists and is less than root if left < n and arr[i] > arr[left]: smallest = left # See if right child of root exists and is less than root if right < n and arr[smallest] > arr[right]: smallest = right # Change root, if needed if smallest != i: arr[i], arr[smallest] = arr[smallest], arr[i] # swap # Heapify the root. heapify(arr, n, smallest) def build_heap(arr, n): # Build a maxheap or minheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) def heap_sort(arr): n = len(arr) build_heap(arr, n) if simulation: print(\\"Initial heap build:\\", arr) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] # swap heapify(arr, i, 0) if simulation: print(f\\"Iteration {n-i}: {arr}\\") if order == \'ascending\': if heap_type == \'max\': heap_sort(arr) else: heap_sort(arr) arr.reverse() else: # descending if heap_type == \'min\': heap_sort(arr) else: heap_sort(arr) arr.reverse() return arr"},{"question":"You are tasked with developing functions to find paths and the shortest path between two nodes in an undirected, unweighted graph. The graph is represented as an adjacency list. Implement the following functions: 1. **find_path(graph, start, end)** - **Input**: - `graph`: A dictionary where keys are node labels, and values are lists of adjacent nodes. - `start`: Start node for the path. - `end`: End node for the path. - **Output**: - A single path (as a list of nodes) from `start` to `end`, or `None` if no path exists. 2. **find_all_paths(graph, start, end)** - **Input**: - `graph`: A dictionary where keys are node labels, and values are lists of adjacent nodes. - `start`: Start node for the paths. - `end`: End node for the paths. - **Output**: - A list of lists, where each inner list represents a different path from `start` to `end`. Return an empty list if no paths exist. 3. **find_shortest_path(graph, start, end)** - **Input**: - `graph`: A dictionary where keys are node labels, and values are lists of adjacent nodes. - `start`: Start node for the path. - `end`: End node for the path. - **Output**: - The shortest path (as a list of nodes) from `start` to `end`. Return `None` if no path exists. # Constraints - The graph will have a maximum of 1000 nodes. - The graph is undirected and unweighted. - Nodes are labelled with unique strings. # Example Input: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' end = \'F\' ``` Output for `find_path(graph, start, end)`: ```python [\'A\', \'C\', \'F\'] (or any other valid path like [\'A\', \'B\', \'E\', \'F\']) ``` Output for `find_all_paths(graph, start, end)`: ```python [[\'A\', \'B\', \'E\', \'F\'], [\'A\', \'C\', \'F\']] ``` Output for `find_shortest_path(graph, start, end)`: ```python [\'A\', \'C\', \'F\'] ``` # Notes - Ensure that your solutions handle edge cases correctly, such as when nodes start or end do not exist in the graph or when no path exists. - Avoid revisiting nodes within the same path to prevent cycles. - Efficiency is important. Aim for an optimal solution that considers worst-case scenarios.","solution":"from collections import deque def find_path(graph, start, end, path=[]): path = path + [start] if start == end: return path if start not in graph: return None for node in graph[start]: if node not in path: newpath = find_path(graph, node, end, path) if newpath: return newpath return None def find_all_paths(graph, start, end, path=[]): path = path + [start] if start == end: return [path] if start not in graph: return [] paths = [] for node in graph[start]: if node not in path: newpaths = find_all_paths(graph, node, end, path) for newpath in newpaths: paths.append(newpath) return paths def find_shortest_path(graph, start, end): if start not in graph or end not in graph: return None queue = deque([(start, [start])]) while queue: node, path = queue.popleft() for adjacent in graph[node]: if adjacent not in path: if adjacent == end: return path + [adjacent] else: queue.append((adjacent, path + [adjacent])) return None"},{"question":"# Question: Implement Improved Square Root Calculation using Newton\'s Method You are tasked with improving the given `square_root` function to handle additional constraints and edge cases. The function should accurately find the square root of a given positive number N within a specified precision epsilon. Ensure your implementation addresses edge cases and optimizes convergence. Function Signature ```python def improved_square_root(n: float, epsilon: float = 0.001) -> float: ``` # Input * An integer or floating-point number `n` (where `n >= 0`). * An optional floating-point number `epsilon` representing the maximum allowable error in the result (default is 0.001). # Output * The function should return a floating-point number representing the approximate square root of `n` within an error margin of `epsilon`. # Constraints * The input `n` will be a non-negative number. * `epsilon` will be a small positive number (0.0001 ≤ `epsilon` ≤ 1.0). # Requirements * Your solution should handle edge cases such as `n = 0` and very small/large values of `n`. * Ensure the function converges efficiently and avoid infinite loops. * The function should raise a `ValueError` for negative inputs and inappropriate `epsilon` values. # Example ```python assert improved_square_root(5, 0.001) ≈ 2.236 # Within the error margin of 0.001 assert improved_square_root(0) == 0 assert improved_square_root(1) == 1 assert improved_square_root(4) == 2 ``` # Hint Consider using adaptive initial guesses and handle edge cases explicitly at the start of your function.","solution":"def improved_square_root(n: float, epsilon: float = 0.001) -> float: Approximates the square root of a non-negative number n with a permissible error of epsilon. :param n: The number to find the square root of (n >= 0). :param epsilon: The permissible error margin (0.0001≤epsilon≤1.0). :return: The approximate square root of n. if n < 0: raise ValueError(\\"Cannot compute the square root of a negative number.\\") if not (0.0001 <= epsilon <= 1.0): raise ValueError(\\"Epsilon must be between 0.0001 and 1.0.\\") # Edge case for zero if n == 0: return 0 # Initial guess can be n/2 for n >= 1 and n for 0 < n < 1 guess = n / 2 if n >= 1 else n while True: next_guess = (guess + n / guess) / 2 if abs(guess - next_guess) < epsilon: return next_guess guess = next_guess"},{"question":"You are asked to implement a data structure called `Trie` which supports three different methods: `insert()`, `search()`, and `starts_with()`. The Trie should be optimized for storing and querying strings where common prefixes are shared. # Function Definitions 1. **insert(word: str)**: Insert a string `word` into the Trie. 2. **search(word: str) -> bool**: Returns `True` if the string `word` is in the Trie, otherwise returns `False`. 3. **starts_with(prefix: str) -> bool**: Returns `True` if there is any string in the Trie that starts with the given prefix, otherwise returns `False`. # Input and Output - **Input**: - `insert(word: str)`: A string `word` which only consists of lowercase letters (`a-z`). - `search(word: str) -> bool`: A string `word` which only consists of lowercase letters (`a-z`). - `starts_with(prefix: str) -> bool`: A string `prefix` which only consists of lowercase letters (`a-z`). Note: The strings for `insert`, `search`, and `starts_with` methods will have a length between `1` and `1000`. # Example ```python trie = Trie() trie.insert(\\"apple\\") assert trie.search(\\"apple\\") == True # returns True assert trie.search(\\"app\\") == False # returns False assert trie.starts_with(\\"app\\") == True # returns True trie.insert(\\"app\\") assert trie.search(\\"app\\") == True # returns True ``` # Constraints & Expectations - You can assume that all strings are composed of lowercase letters ‘a’ to ‘z’. - The insert, search, and starts_with operations must have a time complexity of O(n), where n is the length of the input string. - Aim for a space-efficient solution. Write your implementation of the Trie class accordingly.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str): node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True"},{"question":"You are given a linked list represented by a series of `Node` objects. Your task is to implement a function `is_cyclic(head)` that determines if the linked list has a cycle in it. A linked list is said to contain a cycle if there is a node that can be reached again by continuously following the `next` pointers. Note that the cycle can be as small as a single node linking to itself. # Input Format - A single argument `head`, which is the head `Node` of the linked list. Each `Node` has a property `val` (value of the node) and `next` (pointer to the next node). # Output Format - Return a boolean value: - `True` if there is a cycle in the linked list. - `False` if there is not. # Constraints - Do not use extra space (e.g., keep the space complexity O(1)). - Your solution should be able to handle lists with up to 10^5 nodes efficiently. - Consider various edge cases, such as empty lists and single-node lists. # Example ```python class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head): # Your code here # Example 1: # Input: head = [1 -> 2 -> 3 - # ^-------/ # Output: True # Example 2: # Input: head = [1 -> 2 -> 3 -> None] # Output: False ``` # Scenario Imagine you are a software engineer, and part of your job involves maintaining linked lists that track various sequences of operations in a system. To debug and maintain these lists effectively, it is crucial to ensure that your linked lists do not have unintended cycles that can cause infinite loops in your system\'s logic. Write a function `is_cyclic(head)` that accurately detects cycles in such linked lists.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def is_cyclic(head): Detects if the linked list has a cycle. Parameters: head (Node): The head node of the linked list. Returns: bool: True if there is a cycle in the list, False otherwise. if not head: return False slow = fast = head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Gnome Sorting Challenge You have been hired as a software engineer to help improve and implement robust functionalities in sorting arrays. One of the tasks is to implement the Gnome Sort algorithm and then optimize it. Implement the Gnome Sort algorithm adhering to the typical operations as specified. Furthermore, optimize the implementation to handle large datasets efficiently by incorporating another sorting algorithm for arrays larger than a certain threshold. # Function Signature ```python def optimized_gnome_sort(arr: List[int]) -> List[int]: # Your implementation here ``` # Input - An array of integers `arr` (1 <= len(arr) <= 10^5; -10^6 <= arr[i] <= 10^6) # Output - Sorted array of integers in non-decreasing order. # Constraints - You must use Gnome Sort for small arrays (threshold can be set to 20). - For larger arrays, use a more efficient sorting algorithm such as MergeSort or QuickSort. # Example ```python assert optimized_gnome_sort([34, 2, 10, -9]) == [-9, 2, 10, 34] assert optimized_gnome_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_gnome_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Scenario Imagine you are working on a feature that sorts dynamically generated leaderboard scores every minute. Small changes happen frequently. However, when a large number of scores are updated in a short span, your sort function should handle this efficiently without degrading performance. # Task Implement the function `optimized_gnome_sort(arr: List[int]) -> List[int]` that executes Gnome Sort for small datasets but dynamically switches to an optimized sorting algorithm for larger ones.","solution":"from typing import List def gnome_sort(arr: List[int]) -> List[int]: n = len(arr) pos = 0 while pos < n: if pos == 0 or arr[pos] >= arr[pos - 1]: pos += 1 else: arr[pos], arr[pos - 1] = arr[pos - 1], arr[pos] pos -= 1 return arr def optimized_gnome_sort(arr: List[int], threshold: int = 20) -> List[int]: if len(arr) <= threshold: return gnome_sort(arr) else: return sorted(arr) # Using Python\'s built-in Timsort algorithm"},{"question":"You are tasked with writing a function that encrypts a given string using Caesar\'s cipher. The cipher involves shifting each letter by a fixed number of positions in the alphabet. If the shift takes the letter past \'z\' or \'Z\', it should wrap around to the beginning of the alphabet. # Function Signature ```python def caesar_cipher(s: str, k: int) -> str: pass ``` # Parameters * `s (str)`: A string containing the plaintext to be encrypted. The string may contain lowercase and/or uppercase letters as well as non-alphabetic characters such as digit or punctuation. * `k (int)`: The number of positions to shift each letter. The shift value can be positive or negative. # Returns * `str`: A string representing the encrypted text. # Constraints * 1 <= length of `s` <= 1000 * -26 <= `k` <= 26 # Requirements 1. The function should maintain the case of each letter while shifting. 2. Non-alphabetic characters should remain unchanged. 3. Your implementation should handle both positive and negative shift values. 4. The solution should have a time complexity of O(n) where n is the length of the string. # Example ```python assert caesar_cipher(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" assert caesar_cipher(\\"abcxyz\\", -3) == \\"xyzuvw\\" assert caesar_cipher(\\"ABCXYZ\\", 4) == \\"EFGBCD\\" assert caesar_cipher(\\"Encrypt123!\\", 1) == \\"Fodszqu123!\\" ``` # Explanation 1. **Example 1**: * Input: `(\\"Hello, World!\\", 3)` * \'H\' becomes \'K\', \'e\' becomes \'h\', \'l\' becomes \'o\', and so forth. * Non-alphabetic characters (, and !) remain unchanged. 2. **Example 2**: * Input: `(\\"abcxyz\\", -3)` * \'a\' becomes \'x\', \'b\' becomes \'y\', \'c\' becomes \'z\', and \'x\' becomes \'u\'.","solution":"def caesar_cipher(s: str, k: int) -> str: def shift_char(c, k): if \'a\' <= c <= \'z\': return chr((ord(c) - ord(\'a\') + k) % 26 + ord(\'a\')) elif \'A\' <= c <= \'Z\': return chr((ord(c) - ord(\'A\') + k) % 26 + ord(\'A\')) return c k = k % 26 return \'\'.join(shift_char(c, k) for c in s)"},{"question":"# Resizable Hash Table Implementation and Extension Context: You are tasked with creating a hash table that not only handles basic hashing mechanics but also dynamically resizes itself as the number of entries increases significantly. This ensures that the hash table operations remain efficient. The provided base implementation leverages linear probing for collision resolution and includes a resizing mechanism when the load factor exceeds 2/3 of the table\'s capacity. Objective: Extend and optimize the base ResizableHashTable class provided above. Your task is to refactor and enhance the `ResizableHashTable` class. This may include improving the hash function, implementing a quadratic probing strategy for better collision resolution, and ensuring it maintains its efficiency as the table grows. # Task: 1. **Enhance the hash function** to provide a more distributed and efficient key mapping. Consider using a combination of bit-shifting and primes. 2. **Implement quadratic probing** for collision resolution to minimize primary clustering issues. 3. Include additional methods for: * Retrieving all keys (`keys` method) - returns a list of keys present in the table. * Retrieving all values (`values` method) - returns a list of values present in the table. * Computing the current load factor (`load_factor` method) - returns the current load factor. # Function Specifications: Add or modify the methods in the `ResizableHashTable` class as follows: 1. **hash**: ```python def hash(self, key): # Improved hash function pass ``` 2. **_rehash**: ```python def _rehash(self, old_hash, i): # Quadratic probing formula pass ``` 3. **keys**: ```python def keys(self): # Returns a list of current keys in the hash table pass ``` 4. **values**: ```python def values(self): # Returns a list of current values in the hash table pass ``` 5. **load_factor**: ```python def load_factor(self): # Computes the current load factor pass ``` # Constraints: * Keys will be non-negative integers. * Value assignments are unique for each key. * Load factor should not exceed 0.67. # Examples: ```python table = ResizableHashTable() table[1] = \'one\' table[21] = \'21\' table[14] = \'fourteen\' assert table.keys() == [1, 21, 14] assert table.values() == [\'one\', \'21\', \'fourteen\'] assert abs(table.load_factor() - 0.25) < 1e-7 del table[1] assert table.keys() == [21, 14] assert abs(table.load_factor() - 0.167) < 1e-7 ``` Focus on making the hash table both efficient and robust. Ensure your deliverables pass all the provided examples and are optimally performant.","solution":"class ResizableHashTable: def __init__(self): self.size = 16 self.count = 0 self.keys_array = [None] * self.size self.values_array = [None] * self.size def hash(self, key): Uses a combination of bit-shifting and a large prime number to evenly distribute keys. return (key * 31) % self.size def _rehash(self, old_hash, i): Quadratic probing formula to find the next slot in case of a collision. return (old_hash + i**2) % self.size def __setitem__(self, key, value): hash_value = self.hash(key) slot = hash_value i = 1 while self.keys_array[slot] is not None and self.keys_array[slot] != key: slot = self._rehash(hash_value, i) i += 1 if self.keys_array[slot] is None: self.count += 1 self.keys_array[slot] = key self.values_array[slot] = value if self.load_factor() > 0.67: self._resize() def __getitem__(self, key): hash_value = self.hash(key) slot = hash_value i = 1 while self.keys_array[slot] is not None: if self.keys_array[slot] == key: return self.values_array[slot] slot = self._rehash(hash_value, i) i += 1 raise KeyError(\\"Key not found.\\") def __delitem__(self, key): hash_value = self.hash(key) slot = hash_value i = 1 while self.keys_array[slot] is not None: if self.keys_array[slot] == key: self.keys_array[slot] = None self.values_array[slot] = None self.count -= 1 return slot = self._rehash(hash_value, i) i += 1 raise KeyError(\\"Key not found.\\") def keys(self): return [key for key in self.keys_array if key is not None] def values(self): return [self.values_array[i] for i in range(self.size) if self.keys_array[i] is not None] def load_factor(self): return self.count / self.size def _resize(self): old_keys = self.keys_array old_values = self.values_array self.size *= 2 self.count = 0 self.keys_array = [None] * self.size self.values_array = [None] * self.size for key, value in zip(old_keys, old_values): if key is not None: self[key] = value"},{"question":"You are given two non-negative integers ( num1 ) and ( num2 ). Your task is to implement a function `extended_gcd(num1, num2)` that applies the Extended Euclidean Algorithm to determine three values: ( s ), ( t ), and ( g ). These satisfy the equation: [ num1 cdot s + num2 cdot t = g ] where ( g ) is the greatest common divisor of ( num1 ) and ( num2 ). # Input - Two non-negative integers `num1` and `num2`. # Output - Three integers ( s ), ( t ), and ( g ). # Constraints - ( 0 leq num1, num2 leq 10^9 ) # Example **Example 1:** ```plaintext Input: num1 = 30, num2 = 20 Output: s = 1, t = -1, g = 10 Explanation: 30 * 1 + 20 * -1 = 10 ``` **Example 2:** ```plaintext Input: num1 = 0, num2 = 1 Output: s = 0, t = 1, g = 1 Explanation: 0 * 0 + 1 * 1 = 1 ``` **Example 3:** ```plaintext Input: num1 = 9, num2 = 28 Output: s = -3, t = 1, g = 1 Explanation: 9 * -3 + 28 * 1 = 1 ``` # Requirements - Your implementation of the function should use the Extended Euclidean Algorithm. - The implementation needs to handle large values efficiently. - Ensure proper handling of edge cases, such as when one or both input numbers are zero. # Notes - The provided examples demonstrate how the equation (num1 cdot s + num2 cdot t = g ) holds true. - Maximum performance is expected, considering constraints are large. Write the function `extended_gcd(num1, num2)` to solve the problem.","solution":"def extended_gcd(num1, num2): Applies the Extended Euclidean Algorithm to determine integers s, t, and g. s and t satisfy the equation: num1 * s + num2 * t = g, where g is the greatest common divisor of num1 and num2. Args: num1: First non-negative integer. num2: Second non-negative integer. Returns: Tuple of integers (s, t, g). if num1 == 0: return 0, 1, num2 else: x1, y1, g = extended_gcd(num2 % num1, num1) x = y1 - (num2 // num1) * x1 y = x1 return x, y, g"},{"question":"# Instructions As a professional programmer, you are tasked with optimizing security systems in a series of warehouses. Each warehouse has a certain amount of digital currency stored. They are set up such that hacking into two adjacent warehouses in one night will automatically trigger an alarm and alert the authorities. Given a list of non-negative integers representing the amount of digital currency in each warehouse, write a Python function `warehouse_security` to compute the maximum amount of currency you can hack without setting off the alarms. Function Signature: ```python def warehouse_security(warehouses: List[int]) -> int: ``` Input: - `warehouses` (List[int]): A list of non-negative integers where each integer represents the currency stored in a warehouse. Output: - Return an integer that represents the maximum amount of currency you can hack without triggering any alarms. Constraints: - The length of `warehouses` is between 0 and 10^4. - Each element in `warehouses` is between 0 and 10^4. Example: ```python assert warehouse_security([2, 7, 9, 3, 1]) == 12 assert warehouse_security([1, 2, 3, 1]) == 4 assert warehouse_security([0, 0, 0, 0]) == 0 ``` Explanation: - In the first example, the optimal hacking plan is to hack house 1 (7) and house 3 and 5 (9 + 1), thus 7 + 9 + 1 = 17. - In the second example, the optimal hacking plan is to hack house 1 (2) and house 3 (3), thus 2 + 3 = 5. Note: - Ensure the program handles edge cases efficiently such as empty input lists and large lists. - The function should run efficiently for large inputs up to the constraint limits.","solution":"from typing import List def warehouse_security(warehouses: List[int]) -> int: if not warehouses: return 0 if len(warehouses) == 1: return warehouses[0] if len(warehouses) == 2: return max(warehouses) n = len(warehouses) dp = [0] * n dp[0] = warehouses[0] dp[1] = max(warehouses[0], warehouses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + warehouses[i]) return dp[-1]"},{"question":"**Question: Efficiently Sort and Remove Duplicates** You work for a software firm where it\'s common to handle large lists of unsorted numbers. Often, you need to sort these lists and remove any duplicate entries. As the datasets can get quite large, a bubble sort is inefficient. Instead, you decide to use a comb sort algorithm for initial sorting and deduplicate afterwards. # Task: Write a function `sort_and_remove_duplicates(arr)` that: * Sorts the given list `arr` of integers in ascending order. * Removes any duplicates, ensuring each element appears only once. # Function Signature: ```python def sort_and_remove_duplicates(arr: List[int]) -> List[int]: ``` # Input: * `arr`: A list of integers, with a length `n`, where `0 <= n <= 10^6`. # Output: * A list of sorted integers with duplicates removed. # Constraints: * Your implementation should ensure an average-case time complexity better than O(N^2) whenever possible (focus on efficient sorting/deduplication). * You should aim to use only O(1) additional space for deduplication logic beyond the sorted array. # Example: ```python print(sort_and_remove_duplicates([4, 6, 2, 4, 3, 2, 1])) # Output: [1, 2, 3, 4, 6] print(sort_and_remove_duplicates([5, 4, -1, -1, 0, 5, 4])) # Output: [-1, 0, 4, 5] ``` # Edge Cases: * An empty list should return an empty list. * A list with a single element should return a list with that same element.","solution":"def comb_sort(arr): Function to perform comb sort on the provided array. gap = len(arr) shrink = 1.3 sorted = False while not sorted: gap = int(gap / shrink) if gap <= 1: gap = 1 sorted = True i = 0 while i + gap < len(arr): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] sorted = False i += 1 return arr def sort_and_remove_duplicates(arr): Function to sort the array in ascending order and remove duplicates. if len(arr) == 0: return arr arr = comb_sort(arr) # Removing duplicates result = [arr[0]] for i in range(1, len(arr)): if arr[i] != arr[i - 1]: result.append(arr[i]) return result"},{"question":"Key Concept: Stack Implementation and Application You have been provided with the abstract definition of a stack and its two implementations: `ArrayStack` and `LinkedListStack`. Your task is to implement a new class called `MinStack` that extends the `ArrayStack` or `LinkedListStack` and supports retrieving the minimum element in constant time. This new stack should be able to: 1. Push an element onto the stack. 2. Pop an element from the stack. 3. Retrieve the minimum element in the stack at any time. Requirements: 1. **Class Name**: `MinStack` 2. **Input/Output**: * `push(item)`: Adds an item to the top of the stack. * `pop()`: Removes an item from the top of the stack and returns it. * `get_min()`: Returns the minimum element in the stack without removing it. 3. **Constraints**: * You can use the abstract definitions provided and either `ArrayStack` or `LinkedListStack` as the base class. * The `get_min()` operation must run in O(1) time. 4. **Performance**: Aim to implement with minimal time complexity for each operation. Example: ```python s = MinStack() s.push(3) s.push(5) assert s.get_min() == 3 s.push(2) s.push(1) assert s.get_min() == 1 s.pop() assert s.get_min() == 2 ``` Implement the `MinStack` class according to the specifications above.","solution":"class ArrayStack: def __init__(self): self._data = [] def push(self, item): self._data.append(item) def pop(self): if not self.is_empty(): return self._data.pop() raise IndexError(\'pop from empty stack\') def is_empty(self): return len(self._data) == 0 class MinStack(ArrayStack): def __init__(self): super().__init__() self._min = [] def push(self, item): super().push(item) if not self._min or item <= self._min[-1]: self._min.append(item) def pop(self): item = super().pop() if item == self._min[-1]: self._min.pop() return item def get_min(self): if not self._min: raise IndexError(\'get_min from empty stack\') return self._min[-1]"},{"question":"Problem Statement You are given a sorted array of integers, and you need to implement a function `find_first_and_last_occurrence` that returns the first and last occurrence of a target value in the array using binary search. If the target value is not found in the array, return [-1, -1]. # Function Signature ```python def find_first_and_last_occurrence(array: List[int], target: int) -> List[int]: pass ``` # Input - `array`: A list of integers sorted in ascending order. The length of the array (N) is such that `1 <= N <= 10^6`. - `target`: An integer value for which you need to find the first and last occurrence in the array. # Output - A list containing two integer values: - The index of the first occurrence of `target` in the array. - The index of the last occurrence of `target` in the array. - If the target is not found, return `[-1, -1]`. # Constraints - The solution should have a time complexity of O(log N). # Example Example 1: ```python array = [2, 4, 4, 4, 5, 6, 7] target = 4 ``` Output: ```python [1, 3] ``` Example 2: ```python array = [1, 2, 3, 4, 5, 6, 7] target = 8 ``` Output: ```python [-1, -1] ``` Example 3: ```python array = [1, 1, 1, 1, 1] target = 1 ``` Output: ```python [0, 4] ``` # Note You need to implement the `find_first_and_last_occurrence` function efficiently using binary search or a modified version of binary search that accommodates the requirement of finding both the first and last index.","solution":"from typing import List def find_first_and_last_occurrence(array: List[int], target: int) -> List[int]: def binary_search(left, right, find_first): result = -1 while left <= right: mid = left + (right - left) // 2 if array[mid] == target: result = mid if find_first: right = mid - 1 else: left = mid + 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result first_occurrence = binary_search(0, len(array) - 1, True) if first_occurrence == -1: return [-1, -1] last_occurrence = binary_search(0, len(array) - 1, False) return [first_occurrence, last_occurrence]"},{"question":"**Context:** You are working on a data analysis project dealing with binary data sequences. One critical part of your analysis is to identify an optimal transformation within these sequences to enhance the structure of data for further processing. **Problem Statement:** You are given a binary array (an array consisting of 0s and 1s). Your task is to write a function that determines the index of a 0 that, when changed to a 1, will maximize the length of the longest contiguous segment of 1s in the array. If there are multiple possible answers, return any one of them. If there is no 0 in the array, the function should return -1. **Function Signature:** ```python def max_ones_index(arr: List[int]) -> int: pass ``` **Input:** * `arr`: A list of integers containing only 0s and 1s. **Output:** * An integer representing the index of a 0 that can be replaced with a 1 to get the longest contiguous sequence of 1s. If there is no 0 in the array, return -1. **Constraints:** * The length of the input array will be between 1 and 10^6. * The array will contain at least one 0. **Example:** ```python # Example 1: arr = [1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1] print(max_ones_index(arr)) # Output: 3 # Example 2: arr = [1, 1, 1, 1] print(max_ones_index(arr)) # Output: -1 # Example 3: arr = [0, 1, 1, 1, 0] print(max_ones_index(arr)) # Output: 0 or 4 ``` **Performance Requirements:** * Your solution should run in O(n) time complexity and O(1) space complexity. **Notes:** * Make sure your implementation caters to edge cases like arrays with only one 0 or arrays where 0s are clustered towards the beginning or end. * Although there might be multiple valid answers for some inputs, your function needs to return only one correct index.","solution":"from typing import List def max_ones_index(arr: List[int]) -> int: max_len = 0 max_index = -1 # Variables to keep track of the current window of 1s current_len = 0 prev_zero_index = -1 second_prev_zero_index = -1 for i in range(len(arr)): if arr[i] == 1: current_len += 1 else: # Calculate the length of 1s by flipping the previous zero if prev_zero_index != -1: current_length_with_flip = current_len - (second_prev_zero_index + 1 if second_prev_zero_index != -1 else 0) if current_length_with_flip > max_len: max_len = current_length_with_flip max_index = prev_zero_index # Update the positions for zeros current_len = i - prev_zero_index second_prev_zero_index = prev_zero_index prev_zero_index = i # Final check after the loop exits if the last segment had the max length if prev_zero_index != -1: current_length_with_flip = current_len - (second_prev_zero_index + 1 if second_prev_zero_index != -1 else 0) if current_length_with_flip > max_len: max_index = prev_zero_index return max_index"},{"question":"Scenario You\'ve been hired as a consultant for a city\'s traffic management system. The city has a complex road network with roads that can have varying travel times, including roadworks that might introduce negative travel times. You need to develop a system that can assess whether there are any shortest paths from the central dispatch center to any other points in the city, and crucially, ensure there are no negative travel cycles that could result in unrealistic travel times. Problem Statement Implement the `bellman_ford` function to determine whether there exists a valid shortest path from the central dispatch center to any other point in the city. The function should also indicate whether the city road network contains any negative-weight cycles reachable from the central dispatch center. Function Signature ```python def bellman_ford(graph: Dict[str, Dict[str, int]], source: str) -> bool: ``` Input * `graph` (Dict[str, Dict[str, int]]): A dictionary representing the directed graph, where keys are node identifiers and values are dictionaries with adjacent nodes as keys and edge weights as values. Weights can be negative. * `source` (str): The starting node (central dispatch center). Output * `bool`: Return `True` if no negative-weight cycles exist for reachable vertices from the source; `False` otherwise. Constraints * Graph can have up to 1000 vertices and 10000 edges. * Edge weights range from -1000 to 1000. * Use 0 for node distance to itself. Example ```python graph = { \'A\': {\'B\': 6, \'E\': 7}, \'B\': {\'C\': 5, \'D\': -4, \'E\': 8}, \'C\': {\'B\': -2}, \'D\': {\'A\': 2, \'C\': 7}, \'E\': {\'B\': -3} } source = \'A\' print(bellman_ford(graph, source)) # Output: True ``` Notes * Ensure to initialize correctly and check all necessary conditions. * Think about edge cases like disconnected nodes and graphs with no edges. * Consider performance implications and any optimizations you might need.","solution":"def bellman_ford(graph, source): Implements the Bellman-Ford algorithm to detect negative-weight cycles in a graph and find the shortest path from a source node. Parameters: graph (dict): A dictionary representing the directed graph, with edge weights. source (str): The starting node. Returns: bool: True if no negative-weight cycles exist, False otherwise. # Initialize distance to all vertices as infinite and distance to source as 0 distance = {node: float(\'inf\') for node in graph} distance[source] = 0 # Relax edges |V|-1 times for _ in range(len(graph) - 1): for u in graph: for v in graph[u]: if distance[u] != float(\'inf\') and distance[u] + graph[u][v] < distance[v]: distance[v] = distance[u] + graph[u][v] # Check for negative-weight cycles for u in graph: for v in graph[u]: if distance[u] != float(\'inf\') and distance[u] + graph[u][v] < distance[v]: return False # Negative cycle detected return True"},{"question":"# ZigZagIterator Extension # Context You\'re given two lists, and you need to process their elements in a round-robin fashion. Specifically, you should return elements alternately from the first and second list. If one list runs out of elements, continue with the remaining elements of the other list. For example, given lists `[1, 2]` and `[3, 4, 5, 6]`, the output should be `[1, 3, 2, 4, 5, 6]`. # Problem Statement Extend the provided `ZigZagIterator` class to handle N lists instead of just two. # Requirements 1. Implement the `__init__` method to accept a list of lists. 2. Implement the `next` method to return the next element in the zigzag iteration. 3. Implement the `has_next` method to return a boolean indicating if any elements are left to iterate. # Input - The `__init__` method will receive a list of lists: `lists` where each sublist is a list of integers. - `next` method returns the next integer in the zigzag order. - `has_next` returns a boolean indicating if there are any elements left to iterate. # Output - `__init__(self, lists: List[List[int]])` initializes the object with a list of lists. - `next() -> int` returns the next element. - `has_next() -> bool` returns whether elements remain to iterate. # Constraints - Number of lists N: 1 ≤ N ≤ 1000 - Length of each list ≤ 5000 - Elements in each list: -1000 ≤ Element ≤ 1000 # Example Usage ```python lists = [[1, 2, 3], [4, 5, 6, 7], [8, 9]] it = ZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Your Task Implement the extended `ZigZagIterator` class as per the problem statement. Focus on efficiency and readability.","solution":"class ZigZagIterator: def __init__(self, lists): self.lists = [lst for lst in lists if lst] # filter out empty lists self.iterators = [iter(lst) for lst in self.lists] self.queue = [i for i in range(len(self.lists))] def next(self): if not self.has_next(): raise StopIteration() i = self.queue.pop(0) next_elem = next(self.iterators[i]) # If there are more elements in this iterator, add it back to the queue if len(self.lists[i]) > 1: self.queue.append(i) self.lists[i] = self.lists[i][1:] return next_elem def has_next(self): return bool(self.queue)"},{"question":"Non-negative 1-sparse Recovery Scenario Imagine you are working for a signal processing firm where you need to determine unique dominant signals from a stream of signed integers. Your job is to write a function that determines whether the stream can be reduced to a single unique number – a process known as 1-sparse recovery. If possible, the function should return this unique number; otherwise, it should return `None`. Problem Statement Write a Python function `one_sparse(array: List[Tuple[int, str]]) -> int` to determine if the given stream of tuples of integers and their signs (+/-) can be reduced to a unique integer. Function Signature ```python def one_sparse(array: List[Tuple[int, str]]) -> int: ``` Input * `array`: A list of tuples. Each tuple consists of an integer and a character `+` or `-` denoting the sign. Output * Returns an integer if the stream is 1-sparse, otherwise returns `None`. Examples 1. **Input**: `[(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')]` * **Output**: `4` 2. **Input**: `[(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')]` * **Output**: `2` 3. **Input**: `[(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')]` * **Output**: `None` Constraints * Each integer in the tuple will be non-negative. * The sign will be either `+` or `-`. Performance Requirements * Time Complexity should be ( O(n) ). * Space Complexity should be ( O(1) ) excluding input space.","solution":"def one_sparse(array): count_dict = {} # Go through each tuple and update the counts based on the sign for num, sign in array: if sign == \'+\': if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 elif sign == \'-\': if num in count_dict: count_dict[num] -= 1 else: count_dict[num] = -1 # Determine if there is exactly one unique positive integer unique_num = None for num, count in count_dict.items(): if count > 0: if unique_num is not None: return None # More than one positive unique number unique_num = num return unique_num"},{"question":"# Problem: Generate Next Higher Number with Same Digits Given a number, write a function `next_bigger` to determine the next higher number which has the exact same set of digits as the original number. If no such number exists, your function should return -1. Function Signature: ```python def next_bigger(num: int) -> int: ``` Input: * an integer `num` where `1 <= num <= 10^9` Output: * an integer which is the next higher number with the same set of digits, or -1 if no such number exists Constraints: * The function must handle numbers up to 10^9 efficiently. * The function should aim for a solution with a time complexity of O(n) where n is the number of digits. * The function should handle edge cases such as numbers with all digits in descending order, single digits, or repeated digits. Example: ```python assert next_bigger(38276) == 38627 assert next_bigger(12345) == 12354 assert next_bigger(54321) == -1 assert next_bigger(9999) == -1 assert next_bigger(1) == -1 ``` Explanation: 1. **Example 1**: - Input: 38276 - Output: 38627 - Explanation: 38627 is the next highest number that can be formed with the digits 38276. 2. **Example 2**: - Input: 54321 - Output: -1 - Explanation: There is no next highest number that can be formed with the digits in 54321 since they are in descending order. You are asked to implement and test the function to ensure that it meets the provided requirements.","solution":"def next_bigger(num: int) -> int: digits = list(str(num)) n = len(digits) # Step 1: Find largest index i such that digits[i] < digits[i + 1] for i in range(n - 2, -1, -1): if digits[i] < digits[i + 1]: break else: # If no such i exists, this is the largest permutation return -1 # Step 2: Find largest index j such that j > i and digits[j] > digits[i] for j in range(n - 1, i, -1): if digits[j] > digits[i]: break # Step 3: Swap digits[i] and digits[j] digits[i], digits[j] = digits[j], digits[i] # Step 4: Reverse the sequence from digits[i + 1] to end digits = digits[:i + 1] + digits[i + 1:][::-1] return int(\\"\\".join(digits))"},{"question":"# Matrix Inversion Challenge Context Matrix inversion is a fundamental operation in various mathematical and computational applications, such as solving systems of linear equations, graphics transformations, and statistical analysis. One method of inverting a matrix involves the computation of the matrix of minors, cofactors, and adjugates, followed by multiplication with the reciprocal of the determinant. Objective Write a function `matrix_inverse(m)` that takes a non-singular square matrix `m` as its input and returns its inverse. You must handle matrices up to 3x3 and assume inputs will always be valid non-singular square matrices of integers. Input - A list of lists where each sublist represents a row in the matrix. The matrix will have a size between 2x2 and 3x3 inclusively. Output - A list of lists representing the inverse of the input matrix. Constraints - The matrix will always be a valid square matrix with absolute values of elements being integers not exceeding 100. - The determinant of the matrix will always be non-zero (thus the matrix is invertible). Examples ```python matrix = [ [4, 7], [2, 6] ] print(matrix_inverse(matrix)) # Expected Output: [[0.6, -0.7], # [-0.2, 0.4]] matrix = [ [3, 0, 2], [2, 0, -2], [0, 1, 1] ] print(matrix_inverse(matrix)) # Expected Output: [[0.2, 0.2, 0], # [-0.2, 0.3, 1], # [0.2, -0.3, 0]] ``` Notes 1. Efficient implementation using exact arithmetic may require using fractions to avoid floating-point errors. 2. Handle the inversion process by creating appropriate helper functions as needed. 3. Consider combining multiple steps to reduce redundant traversals of the matrix.","solution":"import numpy as np def matrix_inverse(m): Returns the inverse of a given 2x2 or 3x3 matrix using numpy. matrix = np.array(m) return np.linalg.inv(matrix).tolist()"},{"question":"Objective Write a function `find_grades_threshold` that utilizes the ternary search algorithm to find the minimum score a student needs to achieve in order to be in the top `P` percentile of a sorted list of grades. Function Signature ```python def find_grades_threshold(grades: List[int], P: float) -> int: pass ``` Input * A sorted list of integers `grades` in ascending order representing student grades. * A float `P` representing the top percentile to evaluate (with P ranging from 0 to 100). Output * An integer representing the minimum score required to be in the top `P` percentile of the provided sorted list of grades. Constraints * If the grades list is empty, return `-1`. * The grades list will have at most 10^6 elements. * The P percentile input will be a valid float between 0 and 100 inclusive. * The grades contain only non-negative integers. # Example ```python grades = [45, 50, 53, 55, 60, 65, 70, 75, 80, 85, 90, 95] P = 20.0 find_grades_threshold(grades, P) ``` * In this case, the function should return `85`, the minimum score required to be in the top 20% percentile. # Explanation You need to find the threshold score that separates the top `P` percent of grades. Ensure your solution is efficient and leverages the ternary search principle.","solution":"from typing import List def find_grades_threshold(grades: List[int], P: float) -> int: if not grades: return -1 n = len(grades) if P == 0: return grades[0] if P == 100: return grades[-1] # Calculate the index threshold for the P percentile threshold_index = int(n * (1 - P / 100)) return grades[threshold_index]"},{"question":"# Hailstone Problem Consider the following Hailstone sequence generation process: 1. Start with any positive integer `n`. 2. If `n` is 1, stop the process. 3. If `n` is even, the next number in the sequence is `n/2`. 4. If `n` is odd, the next number in the sequence is `3n + 1`. 5. Repeat the process until `n` becomes 1. Write a function `longest_hailstone_sequence` that finds the starting number `n` (where 1 ≤ `n` ≤ `m`) which produces the longest Hailstone sequence, along with the sequence itself. # Function Signature ```python def longest_hailstone_sequence(m: int) -> (int, list): ``` # Input - `m`: An integer (1 ≤ `m` ≤ 10,000) representing the upper limit of the range from 1 to `m`. # Output - A tuple containing: - An integer representing the starting number within the range producing the longest Hailstone sequence. - A list representing the longest Hailstone sequence for that starting number. # Constraints - Consider all numbers from 1 up to `m`. - Avoid recalculating sequences for numbers that have already been encountered by leveraging memoization or other optimization techniques. # Example ```python longest_hailstone_sequence(10) # Output: (9, [9, 28, 14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]) ``` # Explanation Among numbers from 1 to 10, starting number 9 produces the longest Hailstone sequence that consists of 20 numbers.","solution":"def hailstone_sequence(n: int) -> list: Generates the Hailstone sequence starting from integer n. sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence def longest_hailstone_sequence(m: int) -> (int, list): Finds the starting number (1 ≤ n ≤ m) which produces the longest Hailstone sequence. longest_length = 0 result_starting_num = 0 result_sequence = [] for i in range(1, m + 1): sequence = hailstone_sequence(i) if len(sequence) > longest_length: longest_length = len(sequence) result_starting_num = i result_sequence = sequence return result_starting_num, result_sequence"},{"question":"Generalized Anagram Detector **Context**: You are part of a team developing a text analysis tool, and one of the requirements is to check if two given strings are anagrams. An anagram is when one string can be rearranged to form the other using all the original characters exactly once. Unlike the previous implementation which only considers lowercase English letters, you\'ll need to account for strings that may involve any printable ASCII characters. **Task**: Implement a generalized function to determine if two strings are anagrams of each other. The function must handle any printable ASCII characters. **Function Signature**: ```python def generalized_anagram(s1: str, s2: str) -> bool: pass ``` **Input**: * `s1 (str)`: First input string, 0 <= len(s1) <= 10^5 * `s2 (str)`: Second input string, 0 <= len(s2) <= 10^5 **Output**: * `bool`: `True` if the strings are anagrams of each other, `False` otherwise. **Constraints**: * The function should compare character frequency distributions and must handle cases where the input strings may include any printable ASCII characters. * Performance requirements stipulate linear time complexity relative to the length of the input strings. **Examples**: ```python print(generalized_anagram(\\"apple\\", \\"pleap\\")) # True print(generalized_anagram(\\"apple\\", \\"cherry\\")) # False print(generalized_anagram(\\"123\\", \\"231\\")) # True print(generalized_anagram(\\"Apple\\", \\"apple\\")) # False ``` **Notes**: * Strings are considered case-sensitive; hence, \\"Apple\\" and \\"apple\\" are not considered anagrams. * Handle edge cases such as empty strings correctly.","solution":"from collections import Counter def generalized_anagram(s1: str, s2: str) -> bool: Returns True if s1 and s2 are anagrams of each other, False otherwise. # Anagrams must have the same length if len(s1) != len(s2): return False # Use Counter to count occurrences of each character return Counter(s1) == Counter(s2)"},{"question":"# Scenario You are working on a recommendation system that suggests similar items to users based on their interaction history represented as vectors. To achieve this, you need to compare different item vectors to see how similar they are. One common metric used for this purpose is cosine similarity, which measures the cosine of the angle between two vectors in a multi-dimensional space. # Problem Statement Write a function `cosine_similarity(vec1, vec2)` that calculates the cosine similarity between two given 1-dimensional lists of numbers. Each list represents a vector, and the two vectors must have the same length. The cosine similarity is defined as: [ text{cosine_similarity} = frac{{sum_{i=1}^{N} (vec1[i] cdot vec2[i])}}{{sqrt{sum_{i=1}^{N} (vec1[i]^2)} cdot sqrt{sum_{i=1}^{N} (vec2[i]^2)}}} ] Function Signature ```python def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: ``` Input * `vec1: List[float]` - A list of floating point numbers representing the first vector. * `vec2: List[float]` - A list of floating point numbers representing the second vector. It must have the same length as `vec1`. Output * Returns a floating-point number representing the cosine similarity between the two vectors. Constraints * The length of the vectors will be between 1 and 1000 inclusive. * All elements of the vectors will be between -100 and 100 inclusive. Example ```python cosine_similarity([1, 1, 1], [1, 2, -1]) # Output: 0.47140452079103173 cosine_similarity([0, 1, 0], [1, 0, 0]) # Output: 0.0 cosine_similarity([3, 45, 7, 2], [2, 54, 13, 15]) # Output: 0.97228425171235 ``` # Notes * Ensure to handle the case where the vectors might contain zeros but are not zero vectors themselves. * Raise a `ValueError` if the input vectors do not have the same length. * The function should handle floating-point arithmetic accurately to avoid numerical instability issues.","solution":"from typing import List import math def cosine_similarity(vec1: List[float], vec2: List[float]) -> float: if len(vec1) != len(vec2): raise ValueError(\\"Vectors must be of the same length\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) magnitude_vec1 = math.sqrt(sum(v1**2 for v1 in vec1)) magnitude_vec2 = math.sqrt(sum(v2**2 for v2 in vec2)) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"# Question: Implement and Enhance Radix Sort to Handle Negative Numbers You are tasked with implementing an enhanced version of the Radix Sort algorithm provided. The provided Radix Sort implementation sorts lists of non-negative integers. Extend this functionality to handle lists that include both non-negative and negative integers while preserving the stability of the sorting. **Function Signature:** ```python def enhanced_radix_sort(array: List[int], simulation: bool = False) -> List[int]: pass ``` # Input: - `array`: A list of integers which can include both negative and non-negative integers. (e.g., `[-5, -1, 3, 0, 2, -2, 8, -3, 7]`) - `simulation`: A boolean flag to print the intermediate steps for educational purposes. Default is `False`. # Output: - Return a list of integers sorted in ascending order. # Constraints: - The list can contain up to (10^5) elements. - The integers can be both positive and negative with values ranging between (-10^6) and (10^6). # Requirements: 1. Your implementation should maintain the stability of the sort. 2. You should use radix sort principles for sorting. 3. Optimize for time and space complexity. 4. Handle edge cases, such as empty lists and lists with identical numbers. # Examples: ```python assert enhanced_radix_sort([]) == [] assert enhanced_radix_sort([3, 3, 3]) == [3, 3, 3] assert enhanced_radix_sort([-5, -1, 3, 0, 2, -2, 8, -3, 7]) == [-5, -3, -2, -1, 0, 2, 3, 7, 8] assert enhanced_radix_sort([5, -10, 0]) == [-10, 0, 5] ```","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool): n = len(arr) output = [0] * n count = [0] * 10 # Count occurrences of digits for i in range(n): index = arr[i] // exp count[(index % 10)] += 1 # Update count to have position info for i in range(1, 10): count[i] += count[i - 1] # Build the output array for i in range(n - 1, -1, -1): index = arr[i] // exp output[count[(index % 10)] - 1] = arr[i] count[(index % 10)] -= 1 if simulation: print(f\\"After processing digit at exp={exp}: {output}\\") # Copy output to arr for i in range(n): arr[i] = output[i] def radix_sort(arr: List[int], simulation: bool) -> List[int]: max1 = max(arr) exp = 1 # Perform counting sort for each digit position while max1 // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 def enhanced_radix_sort(array: List[int], simulation: bool = False) -> List[int]: if not array: return array # Separate into positive and negative arrays positives = [num for num in array if num >= 0] negatives = [-num for num in array if num < 0] # Work with absolute values for negatives if negatives: radix_sort(negatives, simulation) # Sort absolute values of negatives negatives = [-num for num in reversed(negatives)] # Convert back to negative and reverse for proper order if positives: radix_sort(positives, simulation) return negatives + positives"},{"question":"# String Reversal Challenge Write a Python function that reverses a given string in the most efficient manner. You are provided with several implementations but your task is to implement the function by choosing the method you believe to be the most optimal in terms of time and space complexity. # Function Signature ```python def reverse_string(s: str) -> str: pass ``` # Input - `s` (str): A non-empty string containing only ASCII characters. # Output - `reverse_string(s)` should return a new string that is the reverse of `s`. # Constraints - The length of the string ( 1 leq text{len}(s) leq 10^6 ) - The function should handle large inputs efficiently in terms of both time and space. # Example ```python assert reverse_string(\\"abcdef\\") == \\"fedcba\\" assert reverse_string(\\"12345\\") == \\"54321\\" assert reverse_string(\\"\\") == \\"\\" assert reverse_string(\\"a\\") == \\"a\\" ``` # Notes - You may assume the function will receive valid input as described. # Performance Requirements Your function should run in linear time and space complexity.","solution":"def reverse_string(s: str) -> str: Returns the reversed string of the input string s. return s[::-1]"},{"question":"- Generate All Possible Subsets You are given a set of distinct integers represented by a list `nums`. Your task is to write a function `subsets(nums)` that generates all possible subsets (the power set) from the given list. The solution set must not contain duplicate subsets. The order of subsets does not matter. Function Signature ```python def subsets(nums: List[int]) -> List[List[int]]: ``` Parameters * `nums` (List[int]): A list of distinct integers. Returns * `List[List[int]]`: A list of lists, where each list is a possible subset of the given list `nums`. Examples ```python >>> subsets([1, 2, 3]) [[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]] >>> subsets([0]) [[], [0]] ``` Constraints * The length of the list `nums` does not exceed 15. * Each element in `nums` is a distinct integer. * The result should include the empty subset. Performance Requirement Given an input list of length `n`, the algorithm should run in O(2^n) time complexity and use O(n * 2^n) space complexity.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: Generates all possible subsets of the given list of distinct integers. result = [] def backtrack(start, path): result.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) backtrack(0, []) return result"},{"question":"Context You are a software engineer tasked with creating utility functions for managing and querying binary tree structures. The goal is to develop robust functions that can efficiently handle various binary tree operations. Problem Statement **Function 1: Minimum Depth Calculation** Write a function `min_depth_v2(root)` to determine the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. Your function must handle edge cases, such as when only one subtree is present. ```python def min_depth_v2(root): :type root: TreeNode :rtype: int # Your implementation here ``` **Input Format**: - `root`: A `TreeNode` object representing the root of the binary tree. A `TreeNode` contains attributes `val`, `left`, and `right`. **Output Format**: - Return an integer representing the minimum depth of the binary tree. Constraints - The number of nodes in the tree is in the range [0, 10^4]. - -1000 <= Node.val <= 1000 **Example**: - Given the binary tree `[3, 9, 20, null, null, 15, 7]`, calling `min_depth_v2(root)` should return `2`. - Given the binary tree `[1, 2, null, 3, null, 4, null, 5]`, calling `min_depth_v2(root)` should return `5`. Instructions 1. Ensure your function correctly handles trees with missing children. 2. Aim for a solution with a time complexity of `O(n)` and space complexity of `O(h)` or better. **Function 2: Tree Printing Function** Improve the `print_tree` function to print the tree nodes in a level-order traversal, ensuring that each level is printed on a new line. ```python def print_tree_v2(root): :type root: TreeNode :rtype: None # Your implementation here ``` **Input Format**: - `root`: A `TreeNode` object representing the root of the binary tree. **Output Format**: - Print the tree nodes in a level-order format, each level on a new line. **Example**: - For the sample tree `[10, 12, 15, 25, 30, 36]`, the output should be: ``` 10 12 15 25 30 36 ``` **Instructions**: 1. Ensure each level is printed on a new line. 2. Handle cases with missing children gracefully. Try to implement these functions while considering edge cases, performance bottlenecks, and potential optimizations discussed in the analysis.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def min_depth_v2(root): :type root: TreeNode :rtype: int if not root: return 0 from collections import deque queue = deque([(root, 1)]) while queue: node, depth = queue.popleft() if not node.left and not node.right: return depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1)) def print_tree_v2(root): :type root: TreeNode :rtype: None if not root: return from collections import deque queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) print(\\" \\".join(map(str, current_level)))"},{"question":"You are given two strings `str1` and `str2` consisting of only lowercase letters. String `str2` is formed by shuffling string `str1` and then adding one more letter at a random position. Write a function to determine the letter added in `str2`. **Function Signature** ```python def find_added_letter(str1: str, str2: str) -> str: ``` **Input** * `str1`: A string of length n composed of lowercase alphabet letters (1 <= n <= 10^5). * `str2`: A string of length n + 1 composed of lowercase alphabet letters. **Output** * Returns the character that was added to `str2`. **Constraints** * Both strings contain only lowercase English letters. * String `str2` is a permutation of string `str1` with exactly one additional character. **Examples** ```python assert find_added_letter(\\"abcd\\", \\"abecd\\") == \'e\' assert find_added_letter(\\"xyz\\", \\"xyaz\\") == \'a\' assert find_added_letter(\\"a\\", \\"aa\\") == \'a\' ``` **Explanation** 1. For the input `str1 = \\"abcd\\"` and `str2 = \\"abecd\\"`, the added letter is \'e\'. 2. For the input `str1 = \\"xyz\\"` and `str2 = \\"xyaz\\"`, the added letter is \'a\'. 3. For the input `str1 = \\"a\\"` and `str2 = \\"aa\\"`, the added letter is \'a\'. # Additional Notes * Consider all edge cases such as the smallest input size. * Ensure the solution handles the maximum input size efficiently.","solution":"def find_added_letter(str1: str, str2: str) -> str: Determine the extra letter added in str2. :param str1: Original string :param str2: Modified string with one additional letter :return: The added letter from collections import Counter count1 = Counter(str1) count2 = Counter(str2) for char in count2: if count2[char] != count1.get(char, 0): return char"},{"question":"Design and implement a function to perform a modified level order traversal on a binary tree. Instead of returning the values of nodes level by level, group the nodes based on their distance from the root and return the sums of the node values at each distance level. # Input: - A binary tree represented by its root node `root`. # Output: - A list of sums of node values at each distance level. Each element in the list corresponds to the sum of nodes\' values at that level. # Constraints: - The number of nodes in the tree will be in the range [0, 10^4]. - -1000 <= Node value <= 1000. # Example: ```plaintext Given binary tree: 3 / 9 20 / 15 7 The output should be: [ 3, # Sum of level 0 29, # Sum of level 1 (9 + 20) 22 # Sum of level 2 (15 + 7) ] ``` # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_sum(root: TreeNode) -> List[int]: # Your code here ``` # Requirements: - Avoid using excessive memory, optimize the solution as necessary. - Handle edge cases such as an empty tree or a single-node tree properly.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] from collections import deque queue = deque([(root, 0)]) level_sum = {} while queue: node, level = queue.popleft() if level in level_sum: level_sum[level] += node.val else: level_sum[level] = node.val if node.left: queue.append((node.left, level + 1)) if node.right: queue.append((node.right, level + 1)) return [level_sum[level] for level in sorted(level_sum.keys())]"},{"question":"In a given Binary Search Tree (BST), every node has a \'val\' attribute, which is an integer. Your task is to write a function `find_inorder_successor(root, node)` that finds the in-order successor of a given node in the BST. # Function Signature ```python def find_inorder_successor(root, node): # Your code here ``` # Input - `root`: The root node of the BST. - `node`: The node for which the in-order successor is to be found. # Output - Returns the in-order successor of the given node in the BST. - If the node has no in-order successor, return `None`. # Constraints - Assume `root` is not null. - `node` will always be a valid node within the BST. - The BST will have unique integer values. # Example Consider the following BST: ``` 20 / 10 30 / 5 15 40 ``` - For node 10, the in-order successor is 15. - For node 15, the in-order successor is 20. - For node 30, the in-order successor is 40. - For node 40, the in-order successor is `None`. ```python # Example Usage root = TreeNode(20) root.left = TreeNode(10) root.left.left = TreeNode(5) root.left.right = TreeNode(15) root.right = TreeNode(30) root.right.right = TreeNode(40) node = root.left # Node with value 10 print(find_inorder_successor(root, node).val) # Output: 15 node = root.right.right # Node with value 40 print(find_inorder_successor(root, node)) # Output: None ``` # Notes - Students should handle the function such that it correctly interprets and navigates through the tree structure to find the in-order successor. - No additional storage for structures like lists or arrays should be used.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_inorder_successor(root, node): Finds the in-order successor of the given node in the BST. # If the node has a right child, the successor is the leftmost node in the right subtree. if node.right: successor = node.right while successor.left: successor = successor.left return successor # If the node doesn\'t have a right child, traverse the tree from the root. successor = None current = root while current: if node.val < current.val: successor = current current = current.left elif node.val > current.val: current = current.right else: break return successor"},{"question":"Implement and Use a Trie You are working on a predictive text feature for a new messaging app. To help power this feature, you need to implement a Trie data structure that supports efficient string insertions and searches. The Trie should support the following operations: 1. **Insert a word** into the trie. 2. **Search for a word** in the trie to check if it exists. 3. **Check if there is any word in the trie that starts with a given prefix**. Function Definitions You need to implement the following class: ```python class Trie: def __init__(self): # Initializes the Trie. def insert(self, word: str) -> None: Inserts a word into the trie. def search(self, word: str) -> bool: Returns if the word is in the trie. def starts_with(self, prefix: str) -> bool: Returns if there is any word in the trie that starts with the given prefix. ``` Input and Output Formats * `insert(word: str) -> None`: Inserts the word into the trie. `word` will consist only of lowercase English letters (`a-z`) and have length of at most 100. * `search(word: str) -> bool`: Returns `True` if the word is found in the trie, `False` otherwise. * `starts_with(prefix: str) -> bool`: Returns `True` if there is any word in the trie that starts with the given prefix. The `prefix` will also consist only of lowercase English letters and have length of at most 100. Constraints 1. You may assume that all inputs consist of lowercase letters a-z. 2. The number of calls to `insert`, `search`, and `starts_with` combined will not exceed 10^4. Example Usage ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Returns True print(trie.search(\\"app\\")) # Returns False print(trie.starts_with(\\"app\\")) # Returns True trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Returns True ``` Using the constraints and a clear understanding of how Trie works, implement the Trie class with the methods `insert`, `search`, and `starts_with` to manage text prediction operations efficiently.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: current_node = self.root for char in word: if char not in current_node.children: return False current_node = current_node.children[char] return current_node.is_end_of_word def starts_with(self, prefix: str) -> bool: current_node = self.root for char in prefix: if char not in current_node.children: return False current_node = current_node.children[char] return True"},{"question":"# Serialize and Deserialize an N-ary Tree **Context:** Serialization and deserialization of data structures is a common problem in computer science, often used in contexts such as data transmission and storage. Unlike standard binary trees, N-ary trees have nodes that can have an arbitrary number of children. This task focuses on implementing a solution to handle serialization and deserialization for an N-ary tree. **Task:** Write two functions `serialize_nary_tree(root)` and `deserialize_nary_tree(data)` for an N-ary tree, demonstrated with the following N-ary tree structure. ```python class NaryNode(object): def __init__(self, x): self.val = x self.children = [] ``` **Specifications:** 1. **Serialization**: * Converts an N-ary tree into a string representation. * Use a specific delimiter (e.g., space) to distinguish different levels and nodes. * Use a predetermined character (e.g., \\"#\\") to denote null or the end of children for a node. 2. **Deserialization**: * Reconstructs the N-ary tree from the string representation. * Processes the string using the same delineation rules used in serialization. **Function Signatures**: ```python def serialize_nary_tree(root: NaryNode) -> str: pass def deserialize_nary_tree(data: str) -> NaryNode: pass ``` **Input/Output Examples**: * Example 1: * Input: N-ary Tree with root value 1, having three children (2, 3, 4). * Output: Serialized string \\"1 2 # 3 # 4 # #\\" * Example 2: * Input: Serialized string \\"1 2 5 # 6 # # 3 # 4 7 8 # 9 # 10 # # #\\" * Output: Reconstructed N-ary tree with the correct structure. **Constraints**: * The methods should handle edge cases like empty trees. * The serialized string should not contain unnecessary spaces or delimiters. * Optimized for both time and space complexity.","solution":"class NaryNode(object): def __init__(self, x): self.val = x self.children = [] def serialize_nary_tree(root): Serialize an N-ary tree to a string. if not root: return \\"\\" result = [] def dfs(node): result.append(str(node.val)) for child in node.children: dfs(child) result.append(\\"#\\") dfs(root) return \' \'.join(result) def deserialize_nary_tree(data): Deserialize a string to an N-ary tree. if not data: return None tokens = iter(data.split()) root_val = next(tokens) root = NaryNode(int(root_val)) def dfs(node): for val in tokens: if val == \\"#\\": return child = NaryNode(int(val)) node.children.append(child) dfs(child) dfs(root) return root"},{"question":"# Coding Challenge: Moving Average with Efficient Updates Scenario You are developing a real-time monitoring system that calculates the moving average of sensor readings received every second. The system needs to be highly efficient to handle high-frequency data streams. Task Implement a class `EfficientMovingAverage` that improves upon the provided `MovingAverage` class by maintaining a running sum to enable O(1) updates and average calculations. Requirements * The class should have the following methods: * `__init__(self, size: int)`: Initialize the data structure with the specified size (window size). * `next(self, val: int) -> float`: Add the next integer value `val` from the stream and return the current moving average. Constraints * The window size `size` will be in the range [1, 1000]. * The integer values `val` will be in the range [-10^4, 10^4]. Example ```python if __name__ == \'__main__\': m = EfficientMovingAverage(3) assert m.next(1) == 1.0 assert m.next(10) == 5.5 assert m.next(3) == 4.666666666666667 assert m.next(5) == 6.0 ```","solution":"class EfficientMovingAverage: def __init__(self, size: int): self.size = size self.window = [] self.window_sum = 0 def next(self, val: int) -> float: if len(self.window) == self.size: self.window_sum -= self.window.pop(0) self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"# Dynamic Programming Approach to Set Cover Problem Scenario: You have been given a universe ( U ) of elements and a collection of cost-associated subsets. Your goal is to find the minimum cost subcollection of these subsets that covers all the elements in the universe, using a dynamic programming approach, which balances between optimal and greedy methods in terms of performance. Problem Statement: Given a universe ( U ) of ( n ) elements and a collection of ( m ) subsets ( S_1, S_2, ..., S_m ), each with an associated cost ( text{Cost}(S_i) ). Implement a function `dp_set_cover(universe, subsets, costs)` that returns the optimal subcollection of subsets covering all elements of ( U ) with minimum cost using dynamic programming. Input: - `universe`: A set of elements (e.g., `{1, 2, 3, 4, 5}`). - `subsets`: A dictionary where keys are subset labels and values are sets of elements (e.g., `{\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}}`). - `costs`: A dictionary where keys are subset labels and values are costs associated with each subset (e.g., `{\'S1\': 5, \'S2\': 10, \'S3\': 3}`). Output: - A list of subset labels forming the minimum cost cover. Constraints: - The sum of costs should be minimized. - All elements in the universe must be covered by the subcollection of subsets. Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} result = dp_set_cover(universe, subsets, costs) # Expected output: [\'S2\', \'S3\'] # Explanation: Minimum cost cover is subsets S2 and S3 with total cost 13. ``` Notes: - Develop a dynamic programming solution to reduce redundant calculations and improve efficiency. - Your function should handle edge cases where subsets do not cover the universe by returning an empty list or similar indication. - Ensure the function efficiently handles inputs where ( |U| leq 20 ) and ( |S| leq 50 ). - Include comments and necessary test cases to validate the solution.","solution":"def dp_set_cover(universe, subsets, costs): Finds the minimum cost subcollection of subsets that covers all elements in the universe. Parameters: - universe: a set of elements - subsets: a dictionary where keys are subset labels and values are sets of elements - costs: a dictionary where keys are subset labels and values are costs associated with each subset Returns: A list of subset labels forming the minimum cost cover. from itertools import chain, combinations def all_subsets(ss): Generates all possible subsets of the input list ss. return chain(*map(lambda x: combinations(ss, x), range(0, len(ss)+1))) subset_labels = list(subsets.keys()) n = len(subset_labels) min_cost = float(\'inf\') best_cover = [] # Iterate over all possible subset combinations for subset_combo in all_subsets(subset_labels): covered = set() current_cost = 0 current_cover = [] for subset in subset_combo: covered.update(subsets[subset]) current_cost += costs[subset] current_cover.append(subset) if covered >= universe and current_cost < min_cost: min_cost = current_cost best_cover = current_cover return best_cover"},{"question":"# Simplifying Unix Path Problem Problem Description You are given an absolute path for a file (Unix-style) as a string. Design a function `simplify_path(path)` that simplifies this Unix file path. # Core Requirements: - Eliminate any \\".\\" (current directory) from the path. - Handle \\"..\\" (parent directory) which moves the directory one level up. - Ignore redundant slashes. Write a function to simplify the Unix path as described above. Input - **path** (`str`): A string representing a Unix-style absolute file path. Output - A string representing the simplified path. Constraints - The input string will only contain ASCII characters and will be a valid Unix path. - The length of the input string will not exceed 3000 characters. Performance Requirement - The function should operate within ( O(N) ) time complexity where ( N ) is the length of the input string. - The space complexity should be within ( O(N) ). # Scenarios 1. Example 1: - Input: `\\"/home/\\"` - Output: `\\"/home\\"` 2. Example 2: - Input: `\\"/a/./b/../../c/\\"` - Output: `\\"/c\\"` 3. Example 3: - Input: `\\"/../\\"` - Output: `\\"/\\"` 4. Example 4: - Input: `\\"/home//foo/\\"` - Output: `\\"/home/foo\\"` Write the `simplify_path` function to meet the above requirements and handle typical edge cases.","solution":"def simplify_path(path): Simplifies the given Unix-style absolute file path. :param path: A string representing a Unix-style absolute file path. :return: A string representing the simplified path. # Split the path by \'/\' parts = path.split(\'/\') stack = [] for part in parts: if part == \\"..\\": if stack: stack.pop() # Go back to the parent directory elif part == \\".\\" or part == \\"\\": # Ignore \'.\' and empty parts continue else: stack.append(part) # Valid directory name, add to stack # Join the parts with \'/\' and prepend with a leading \'/\' return \'/\' + \'/\'.join(stack)"},{"question":"**B-Tree Traversal and Update** A functional B-tree is crucial for performance-critical applications like databases and filesystems. We need you to extend our B-tree implementation with the following functionalities: 1. **Range Query**: Implement a method `range_query(low: int, high: int) -> List[int]` that finds and returns all keys within a specified range `[low, high]`. This will help us in scenarios where we need to quickly find a sequence of data points. 2. **Update Key**: Implement a method `update_key(old_key: int, new_key: int) -> bool` that updates a given key (`old_key`) to a new value (`new_key`). Ensure the B-tree properties are maintained after the update. This will help in situations where records need to be updated without reinsertions. # Input/Output Specifications **Input**: - For `range_query(low, high)`: Two integers, `low` and `high`, where `low ≤ high`. - For `update_key(old_key, new_key)`: Two integers, `old_key` to be replaced by `new_key`. **Output**: - For `range_query(low, high)`: A list of integers representing all keys within the range `[low, high]`, in sorted order. - For `update_key(old_key, new_key)`: A boolean value `True` if the key was successfully updated, or `False` if `old_key` does not exist in the tree. **Constraints**: - The B-tree is non-empty and contains unique keys. - You should ensure the B-tree\'s properties are maintained after each operation. # Examples **Example 1**: ```python btree = BTree(t_val=3) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) # Range query from 6 to 17 print(btree.range_query(6, 17)) # Output: [6, 7, 10, 12, 17] # Update key 10 to 15 print(btree.update_key(10, 15)) # Output: True # After update, range query from 6 to 17 print(btree.range_query(6, 17)) # Output: [6, 7, 12, 15, 17] ``` # Notes - Ensure the `range_query` and `update_key` methods are efficient (O(log n) for update and performing the query within the constraints of O(log n) tree traversal). - Handle all edge cases such as non-existing keys in `update_key`, range boundaries in `range_query`, and maintain balanced tree properties. **Tasks**: - Implement the `range_query` method. - Implement the `update_key` method. - Ensure appropriate tests are created for edge cases and standard scenarios.","solution":"class BTreeNode: def __init__(self, t, is_leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.keys = [] # List of keys self.children = [] # List of child BTreeNode instances self.is_leaf = is_leaf # True if leaf node, false otherwise def traverse(self): results = [] for i in range(len(self.keys)): if not self.is_leaf: results.extend(self.children[i].traverse()) results.append(self.keys[i]) if not self.is_leaf: results.extend(self.children[-1].traverse()) return results def range_query(self, low, high): result = [] i = 0 # Find the first key that is greater than or equal to low while i < len(self.keys) and self.keys[i] < low: i += 1 # Traverse the subtree to the left of the ith key (if not leaf) if not self.is_leaf: result.extend(self.children[i].range_query(low, high)) # Add all keys in range [low, high] to result while i < len(self.keys) and low <= self.keys[i] <= high: result.append(self.keys[i]) if not self.is_leaf: result.extend(self.children[i + 1].range_query(low, high)) i += 1 return result def search(self, k): i = 0 while i < len(self.keys) and k > self.keys[i]: i += 1 if i < len(self.keys) and self.keys[i] == k: return self if self.is_leaf: return None return self.children[i].search(k) def update_key(self, old_key, new_key): node = self.search(old_key) if node is None: return False # Find index of old_key in node idx = node.keys.index(old_key) node.keys.pop(idx) node.keys.insert(idx, new_key) node.keys.sort() # Ensure B-tree properties are maintained return True class BTree: def __init__(self, t): self.root = BTreeNode(t, True) self.t = t def insert_key(self, k): root = self.root if len(root.keys) == (2*self.t) - 1: temp = BTreeNode(self.t) self.root = temp temp.is_leaf = False temp.children.insert(0, root) self.split_child(temp, 0) self.insert_non_full(temp, k) else: self.insert_non_full(root, k) def split_child(self, x, i): t = self.t y = x.children[i] z = BTreeNode(t, y.is_leaf) x.children.insert(i + 1, z) x.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t: (2 * t) - 1] y.keys = y.keys[0: t - 1] if not y.is_leaf: z.children = y.children[t: 2 * t] y.children = y.children[0: t] def insert_non_full(self, x, k): i = len(x.keys) - 1 if x.is_leaf: x.keys.append(0) while i >= 0 and k < x.keys[i]: x.keys[i + 1] = x.keys[i] i -= 1 x.keys[i + 1] = k else: while i >= 0 and k < x.keys[i]: i -= 1 i += 1 if len(x.children[i].keys) == (2 * self.t) - 1: self.split_child(x, i) if k > x.keys[i]: i += 1 self.insert_non_full(x.children[i], k) def range_query(self, low, high): return self.root.range_query(low, high) def update_key(self, old_key, new_key): return self.root.update_key(old_key, new_key)"},{"question":"# Question: Message Decoder A message containing strings of digits from \'A\' to \'Z\' can be encoded using the following rules: * \'A\' -> 1 * \'B\' -> 2 * ... * \'Z\' -> 26 Given an encoded message of digits, write a function `num_decoding_ways(s: str) -> int` that determines the total number of ways to decode it. Input * `s` (Length: 1 <= |s| <= 1000): A string containing only digits. Output * An integer representing the total number of ways the encoded message can be decoded. Constraints * The input string will consist of digits only. * The input string will not contain non-digit characters. * The encoded message cannot start with \'0\' as it\'s invalid. Example # Example 1: ``` Input: \\"12\\" Output: 2 Explanation: It could be decoded as \\"AB\\" (1 2) or \\"L\\" (12). ``` # Example 2: ``` Input: \\"226\\" Output: 3 Explanation: It could be decoded as \\"BZ\\" (2 26), \\"VF\\" (22 6), or \\"BBF\\" (2 2 6). ``` # Example 3: ``` Input: \\"06\\" Output: 0 Explanation: Messages starting with \'0\' are not decodable. ``` # Example 4: ``` Input: \\"110\\" Output: 1 Explanation: It could be decoded as \\"AAJ\\" (1 10). ``` # Constraints and Complexity Requirements * Your solution should run in O(n) time, where n is the length of the string. * The space complexity should be optimized as much as possible. Write the function implementation and ensure it handles edge cases efficiently.","solution":"def num_decoding_ways(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i - 1]) two_digits = int(s[i - 2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i - 1] if 10 <= two_digits <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"**Question:** Given a positive integer, implement a function `check_alternating_bits(n: int) -> bool`, to determine if its binary representation has alternating bits. # Input: - A positive integer `n` (1 ≤ n ≤ 2^32 - 1). # Output: - Return `True` if the binary representation of `n` has alternating bits, otherwise return `False`. # Constraints: - You should provide a solution with a time complexity of O(1). # Examples: 1. Input: `n = 5` - Output: `True` - Explanation: The binary representation of 5 is `101`, which has alternating bits. 2. Input: `n = 7` - Output: `False` - Explanation: The binary representation of 7 is `111`, which does not have alternating bits. 3. Input: `n = 11` - Output: `False` - Explanation: The binary representation of 11 is `1011`, which does not have alternating bits. 4. Input: `n = 10` - Output: `True` - Explanation: The binary representation of 10 is `1010`, which has alternating bits. # Note: - You are required to implement a solution that exhibits constant-time complexity.","solution":"def check_alternating_bits(n: int) -> bool: Determine if a given integer has alternating bits in its binary representation. Args: n (int): A positive integer (1 ≤ n ≤ 2^32 - 1). Returns: bool: True if the binary representation has alternating bits, False otherwise. # Shift `n` to right by 1 bit and XOR with the original number `n` xor_result = n ^ (n >> 1) # Check if the XOR result plus 1 is a power of 2 (only has one bit set in binary) return (xor_result & (xor_result + 1)) == 0"},{"question":"# Problem Context Alice is studying number theory and has come across the concept of primitive roots. She needs your help to write a function that finds all primitive roots for a given integer ( n ). A primitive root of ( n ) is a number whose powers generate all integers from 1 to ( n-1 ) when taken modulo ( n ). # Problem Statement Write a function that, given a positive integer ( n ), finds and returns a list of all primitive roots of ( n ). If no primitive roots exist for ( n ), return an empty list. If ( n = 1 ), handle it as a special case. # Input * An integer ( n ) such that ( 1 leq n leq 10^6 ). # Output * A list of integers representing all primitive roots of ( n ), or an empty list if no primitive roots exist. # Constraints * The function should be efficient, keeping the computational time within practical limits for ( n ) up to ( 10^6 ). # Function Signature ```python def find_primitive_root(n: int) -> List[int]: pass ``` # Examples 1. **Input**: `n = 13` **Output**: `[2, 6, 7, 11]` 2. **Input**: `n = 28` **Output**: `[]` 3. **Input**: `n = 1` **Output**: `[0]`","solution":"import math from typing import List def find_primitive_root(n: int) -> List[int]: if n <= 1: return [0] if n == 1 else [] def gcd(a, b): while b: a, b = b, a % b return a def is_primitive_root(candidate, n, required_set): seen = set() power = candidate for _ in range(1, n): if power in seen or power == 0: return False seen.add(power) power = (power * candidate) % n return seen == required_set phi_n = n - 1 required_set = set(range(1, n)) primitive_roots = [] for candidate in range(2, n): if gcd(candidate, n) == 1 and is_primitive_root(candidate, n, required_set): primitive_roots.append(candidate) return primitive_roots"},{"question":"Scenario Imagine you are working on a feature for a text abbreviation application. Your task is to generate all possible abbreviations for a given word. This feature is crucial for optimizing the application\'s search and retrieval mechanisms. Problem Statement Write a function `generate_abbreviations(word)` that takes a single string `word` and returns a list of all possible abbreviations of the word. An abbreviation is defined as replacing each substring of characters with its length, but each character must be substituted at most once. Input - `word`: A string with a length between 1 and 15 characters consisting only of lowercase alphabetical characters. Output - A list of strings, where each string is a possible abbreviation of the input `word`. Constraints - The list should include the word itself as one of the abbreviations. - The abbreviations should cover the cases where any sequence of characters can be replaced by the count of those characters. Example ```python Input: \\"word\\" Output: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] ``` Requirements - Implement the function using a backtracking approach. - Ensure the function is efficient and consider the exponential nature of the problem\'s complexity in your implementation design. ```python def generate_abbreviations(word): def backtrack(result, word, pos, count, cur): if pos == len(word): if count > 0: cur += str(count) result.append(cur) return if count > 0: backtrack(result, word, pos + 1, 0, cur + str(count) + word[pos]) else: backtrack(result, word, pos + 1, 0, cur + word[pos]) backtrack(result, word, pos + 1, count + 1, cur) result = [] backtrack(result, word, 0, 0, \\"\\") return result ``` Provide a test suite that verifies the correctness of the function with different input scenarios.","solution":"def generate_abbreviations(word): def backtrack(result, word, pos, count, cur): if pos == len(word): if count > 0: cur += str(count) result.append(cur) return # Option 1: Include the current character in the abbreviation. backtrack(result, word, pos + 1, 0, cur + (str(count) if count > 0 else \\"\\") + word[pos]) # Option 2: Replace the current character with its count. backtrack(result, word, pos + 1, count + 1, cur) result = [] backtrack(result, word, 0, 0, \\"\\") return result"},{"question":"You are given a list of unique words, each of the same length, and your task is to form all possible word squares where each row and each column of the square reads the same word. A word square is defined as a sequence of words of the same length that forms a valid word square such that the kth row and kth column read the exact same string for any 0 <= k < word length. # Input - A list of words, where each word is a lowercase English alphabet word without duplicates. - All words are of the same length. - There are at least 1 and at most 1000 words. - Word length is at least 1 and at most 5. # Output - A list of all possible word squares. - Each word square should be represented as a list of words. - Order of the word squares does not matter, but within each square, the order of words does matter. # Constraints - The length of each word is `W` where 1 ≤ W ≤ 5. - Number of words is `N` where 1 ≤ N ≤ 1000. # Requirements - The solution should leverage the backtracking technique. - Efficient prefix processing should be implemented to speed up matching of word squares. # Example Input ```python words = [\\"area\\", \\"lead\\", \\"wall\\", \\"lady\\", \\"ball\\"] ``` # Example Output ```python [ [\\"wall\\",\\"area\\",\\"lead\\",\\"lady\\"], [\\"ball\\",\\"area\\",\\"lead\\",\\"lady\\"] ] ``` The above output contains two valid word squares formed from the input list. # Implementation Write a function `findWordSquares(words: List[str]) -> List[List[str]]` to find all word squares from the provided list of words. The function signature is: ```python def findWordSquares(words: List[str]) -> List[List[str]]: ```","solution":"from typing import List, Dict from collections import defaultdict def build_prefix_hash(words: List[str]) -> Dict[str, List[str]]: Builds a prefix hash map for quick prefix-based lookups. prefix_dict = defaultdict(list) for word in words: for i in range(len(word)): prefix_dict[word[:i]].append(word) return prefix_dict def findWordSquares(words: List[str]) -> List[List[str]]: def backtrack(step: int): if step == word_length: result.append(current_square[:]) return prefix = \'\'.join([word[step] for word in current_square]) for next_word in prefix_hash[prefix]: current_square.append(next_word) backtrack(step + 1) current_square.pop() if not words: return [] word_length = len(words[0]) prefix_hash = build_prefix_hash(words) result = [] current_square = [] for word in words: current_square = [word] backtrack(1) return result"},{"question":"# Integer Pair Analysis for GCD and LCM Computation Objective: Implement functions to analyze pairs of integers by computing the greatest common divisor (GCD) and least common multiple (LCM) both conventionally and using bitwise operations. Additionally, include a feature to count trailing zeros in the binary representation of integers. Background: Your functions should be able to handle typical edge cases and exceptions gracefully. You should consider both performance and correctness, adhering to the principles of the Euclidean algorithm and bitwise manipulation. Functions to Implement: - `compute_gcd(a, b)`: Compute the GCD using the Euclidean Algorithm. - `compute_gcd_bitwise(a, b)`: Compute the GCD using bitwise operations. - `compute_lcm(a, b)`: Calculate the LCM based on the computed GCD. - `count_trailing_zeros(x)`: Count the number of trailing zeros in x\'s binary representation. Input and Output: - **Input**: - Integers `a` and `b` for GCD and LCM functions. - Integer `x` for the trailing zero function. - **Output**: - `compute_gcd(a, b)`: Returns an integer representing the GCD. - `compute_gcd_bitwise(a, b)`: Returns an integer representing the GCD. - `compute_lcm(a, b)`: Returns an integer representing the LCM. - `count_trailing_zeros(x)`: Returns an integer representing the number of trailing zeros in the binary representation of `x`. Constraints: - Inputs must be non-zero, positive integers. - Ensure appropriate exception handling for invalid inputs. - Aim for optimized performance. Example Usage: ```python assert compute_gcd(12, 18) == 6 assert compute_gcd_bitwise(12, 18) == 6 assert compute_lcm(12, 18) == 36 assert count_trailing_zeros(40) == 3 ``` Performance Requirements: - Consider minimizing the number of operations to maintain efficiency, especially for large integers and multiple function calls. Implementation: ```python # Function definitions here. def compute_gcd(a, b): # Euclidean Algorithm implementation. def compute_gcd_bitwise(a, b): # GCD using bitwise operations. def compute_lcm(a, b): # LCM computation based on GCD. def count_trailing_zeros(x): # Trailing zero count in binary representation. ```","solution":"def compute_gcd(a, b): Compute the greatest common divisor (GCD) using the Euclidean algorithm. while b: a, b = b, a % b return a def compute_gcd_bitwise(a, b): Compute the GCD using bitwise operations. if a == 0: return b if b == 0: return a # Find common factor of 2 shift = 0 while ((a | b) & 1) == 0: a >>= 1 b >>= 1 shift += 1 while (a & 1) == 0: a >>= 1 while b != 0: while (b & 1) == 0: b >>= 1 if a > b: a, b = b, a b -= a return a << shift def compute_lcm(a, b): Calculate the least common multiple (LCM) using the GCD. return a * b // compute_gcd(a, b) def count_trailing_zeros(x): Count the number of trailing zeros in the binary representation of x. if x == 0: return -1 count = 0 while (x & 1) == 0: x >>= 1 count += 1 return count"},{"question":"Problem Statement You are given two strings `s` and `t`. Your task is to write a function to determine if `t` is an anagram of `s`. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. Function Signature ```python def is_anagram(s: str, t: str) -> bool: Determine if string t is an anagram of string s. :param s: The first string. :param t: The second string. :return: True if t is an anagram of s, False otherwise. pass ``` Input - `s` (a string containing only lowercase alphabets, 1 ≤ len(s) ≤ 10^5) - `t` (a string containing only lowercase alphabets, 1 ≤ len(t) ≤ 10^5) Output - Returns `True` if `t` is an anagram of `s`, `False` otherwise. Constraints - You may assume that both strings contain only lowercase alphabets. Example ```python # Example 1: # Input: s = \\"anagram\\", t = \\"nagaram\\" # Output: true # Example 2: # Input: s = \\"rat\\", t = \\"car\\" # Output: false ``` Performance Requirements - Your solution should handle strings of up to length 100,000 efficiently. Scenario Imagine that you are building a utility that checks whether two given words are anagrams. This functionality is crucial for a game that checks for valid word transformations, so accuracy and performance are essential.","solution":"def is_anagram(s: str, t: str) -> bool: Determine if string t is an anagram of string s. :param s: The first string. :param t: The second string. :return: True if t is an anagram of s, False otherwise. if len(s) != len(t): return False from collections import Counter return Counter(s) == Counter(t)"},{"question":"# Coding Task Implement a function using Cocktail Shaker Sort to sort a list of integers in ascending order. The function should handle various edge cases and include optimization for early termination if the array becomes sorted before completing all passes. Function Signature ```python def cocktail_shaker_sort(arr: list[int]) -> list[int]: ``` Input * A list of integers `arr` (0 ≤ len(arr) ≤ 10^4, -10^5 ≤ arr[i] ≤ 10^5 for each element `arr[i]`). Output * A sorted list of integers in non-decreasing order. Constraints * Aim for an in-place sorting algorithm without using additional space proportional to the input size. * Consider optimizing for early termination to enhance performance. Example ```python assert cocktail_shaker_sort([3, 0, 2, 5, -1, 4, 1]) == [-1, 0, 1, 2, 3, 4, 5] assert cocktail_shaker_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] assert cocktail_shaker_sort([]) == [] assert cocktail_shaker_sort([1]) == [1] ``` Examine the performance of your implementation with both small and large arrays, paying attention to its handling of edge cases.","solution":"def cocktail_shaker_sort(arr: list[int]) -> list[int]: n = len(arr) if n <= 1: return arr start = 0 end = n - 1 swapped = True while swapped: # Initially, no swaps have been made swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If no elements were swapped, then the array is sorted if not swapped: break # Reset the swapped flag for the next stage swapped = False # Decrease the end point, because the last element is in place end -= 1 # Traverse the array from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True # Increase the starting point, because the first element is in place start += 1 return arr"},{"question":"# Scenario You are working for a company that organizes hierarchical data using binary search trees (BST) for efficient search and retrieval. Given a BST, you need to implement a function `num_empty` that calculates the number of empty branches in the tree. Each leaf node is considered to have two empty branches, and an empty tree has exactly one empty branch where the root would be. # Function Signature ```python def num_empty(root: TreeNode) -> int: # Your code here ``` # Expected Input and Output * **Input**: A TreeNode representing the root of the binary search tree. TreeNode is a class that encapsulates the value, left child, and right child nodes. * Example: TreeNode(10) represents a single node with value 10. * **Output**: An integer representing the number of empty branches in the binary search tree. # Constraints * The tree can have up to 10^5 nodes. * The value of each node in the tree will be within the range of [-10^9, 10^9]. # Example For the following tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The function `num_empty` should return `10` (as outlined in the example provided). # Edge Cases 1. **Empty tree**: `num_empty(None)` should return 1. 2. **Single node tree**: `num_empty(TreeNode(5))` should return 2 (one node with two empty branches). # Note * Binary tree traversal techniques such as inorder, preorder, or postorder traversal can be utilized. * Ensure inputs are handled properly without causing runtime exceptions.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def num_empty(root: TreeNode) -> int: Calculates the number of empty branches in the binary search tree. if root is None: return 1 def count_empty(node): if node is None: return 1 left_empty = count_empty(node.left) right_empty = count_empty(node.right) return left_empty + right_empty # We start only if root is not None return count_empty(root.left) + count_empty(root.right)"},{"question":"# Binary Heap Implementation You are tasked with implementing key methods of a Binary Heap data structure (specifically a Min Heap). Your implementation should support dynamic insertions and efficient access to the minimum element. **Function Specifications**: 1. **insert(val)**: Insert a new value into the heap. - **Input**: `val` (int): The value to be inserted into the heap. - **Constraints**: Only integers will be inserted. - **Output**: None. 2. **remove_min()**: Remove and return the smallest element in the heap. - **Input**: None. - **Output**: The smallest element (int) in the heap. 3. **perc_up(i)**: Helper function to maintain heap property after insertion. - **Input**: `i` (int): Index of the newly inserted element. - **Output**: None. 4. **min_child(i)**: Helper function to find the index of the smallest child. - **Input**: `i` (int): Index of the parent element. - **Output**: Index (int) of the smallest child. 5. **perc_down(i)**: Helper function to maintain heap property after removing the minimum. - **Input**: `i` (int): Index of the element being percolated down. - **Output**: None. # Example Scenarios - **Insert Scenario**: 1. Start with an empty heap. 2. Insert `5`, `3`, `7`, `1`. 3. Heap after insertions: `[0, 1, 3, 7, 5]` - **Remove Min Scenario**: 1. Given a heap `[0, 1, 3, 7, 5]`. 2. `remove_min()` returns `1`. 3. Heap after removing min: `[0, 3, 5, 7]` **Note**: The `0` at index 0 is a placeholder to simplify index calculations. Implement your solution in the `BinaryHeap` class provided below. Make sure to maintain the complete tree and heap properties during insertions and deletions. ```python class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [(0)] def perc_up(self, i): # Implement perc_up def insert(self, val): # Implement insert def min_child(self, i): # Implement min_child def perc_down(self, i): # Implement perc_down def remove_min(self): # Implement remove_min ``` **Constraints**: - Ensure that your implementation can handle up to `10^4` elements efficiently. - Elements in the heap will range from `-10^6` to `10^6`. **Performance Requirements**: - Ensure that the `insert` and `remove_min` operations run efficiently with a time complexity of O(log N).","solution":"class BinaryHeap: def __init__(self): self.current_size = 0 self.heap = [0] # placeholder for the 0-th index def perc_up(self, i): while i // 2 > 0: if self.heap[i] < self.heap[i // 2]: # if current node is less than its parent self.heap[i], self.heap[i // 2] = self.heap[i // 2], self.heap[i] i = i // 2 def insert(self, val): self.heap.append(val) self.current_size += 1 self.perc_up(self.current_size) def min_child(self, i): if i * 2 + 1 > self.current_size: return i * 2 # if there is no right child else: if self.heap[i * 2] < self.heap[i * 2 + 1]: return i * 2 else: return i * 2 + 1 def perc_down(self, i): while (i * 2) <= self.current_size: mc = self.min_child(i) if self.heap[i] > self.heap[mc]: self.heap[i], self.heap[mc] = self.heap[mc], self.heap[i] i = mc def remove_min(self): min_val = self.heap[1] self.heap[1] = self.heap[self.current_size] self.current_size -= 1 self.heap.pop() self.perc_down(1) return min_val"},{"question":"# Combination Calculation Challenge Context In combinatorial mathematics, it\'s often required to compute the number of ways to choose `r` items from `n` distinct items, which is denoted as ( C(n, r) ) or nCr. There are multiple ways to approach this calculation, including simple recursion and memoization. Task Your task is to write a function that calculates the number of combinations (nCr) efficiently using the principles of dynamic programming. You need to implement a function that calculates the number of combinations using an iterative approach to minimize the space complexity. Function Signature ```python def combination_iterative(n: int, r: int) -> int: Calculate the number of combinations (nCr) using an iterative approach. :param n: Total number of items :param r: Number of items to choose :return: Number of ways to choose r items from n items ``` Input * Two integers `n` and `r` such that (0 leq r leq n). Output * An integer representing the number of ways to choose `r` items from `n` items. Constraints * ( 0 leq r leq n leq 1000 ) * Aim for a solution with a time complexity of (O(n cdot r)) and space complexity of O(r). Example ```python print(combination_iterative(5, 2)) # Output: 10 print(combination_iterative(6, 3)) # Output: 20 print(combination_iterative(10, 0)) # Output: 1 ``` Notes * Ensure that the function handles edge cases such as r = 0 and r = n correctly. * Avoid using recursion to prevent stack overflow with large input sizes. * Consider optimizing your approach to ensure it runs efficiently even for large values of `n` and `r`.","solution":"def combination_iterative(n: int, r: int) -> int: Calculate the number of combinations (nCr) using an iterative approach. :param n: Total number of items :param r: Number of items to choose :return: Number of ways to choose r items from n items if r > n or r < 0: return 0 if r == 0 or r == n: return 1 # Optimization: C(n, r) == C(n, n-r) r = min(r, n - r) C = [0] * (r + 1) C[0] = 1 # Base case for i in range(1, n + 1): for j in range(min(i, r), 0, -1): C[j] = C[j] + C[j - 1] return C[r]"},{"question":"Context: You are given a grid representing the height of each unit cell in a continent. The Pacific Ocean touches the left and top edges, and the Atlantic Ocean touches the right and bottom edges. Water can flow from a cell to another cell with equal or lower height. You need to identify all cells from where water can reach both the Pacific and Atlantic oceans. Task: Implement a function `pacific_atlantic` that takes an `m x n` grid (matrix) where each cell contains a non-negative integer representing its height, and returns a list of grid coordinates (i.e., tuples) where water can flow to both the Pacific and Atlantic oceans. Input: * `matrix`: A list of lists of integers representing the heights. This matrix is of dimension `m x n` with `1 ≤ m, n ≤ 150`. Output: * A list of pairs `[i, j]` indicating the grid coordinates that can reach both oceans. Constraints: * Water can only flow in four directions: up, down, left, and right. * The order of returned grid coordinates does not matter. Examples: Given the following 5x5 matrix: ```plaintext Pacific ~ ~ ~ ~ ~ ~ 1 2 2 3 (5) ~ 3 2 3 (4) (4) ~ 2 4 (5) 3 1 ~ (6) (7) 1 4 5 ~ (5) 1 1 2 4 * * * * * Atlantic ``` Return: ```plaintext [[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] ``` (Note: positions with parentheses in above matrix). Function Signature: ```python def pacific_atlantic(matrix): :type matrix: List[List[int]] :rtype: List[List[int]] ```","solution":"def pacific_atlantic(matrix): if not matrix: return [] n, m = len(matrix), len(matrix[0]) def dfs(x, y, visit, prevHeight): if (x < 0 or x >= n or y < 0 or y >= m or visit[x][y] or matrix[x][y] < prevHeight): return visit[x][y] = True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy, visit, matrix[x][y]) pacific = [[False] * m for _ in range(n)] atlantic = [[False] * m for _ in range(n)] for i in range(n): dfs(i, 0, pacific, -1) dfs(i, m - 1, atlantic, -1) for j in range(m): dfs(0, j, pacific, -1) dfs(n - 1, j, atlantic, -1) result = [[i, j] for i in range(n) for j in range(m) if pacific[i][j] and atlantic[i][j]] return result"},{"question":"# Problem Description You are given two inputs: 1. A list of integers, `lst`. 2. An integer, `N`. Your task is to write a function `delete_nth(lst, N)` that takes these inputs and returns a list where: - Each element in the original list `lst` appears at most `N` times. - The order of elements in the returned list remains the same as in the input list. # Function Signature ```python def delete_nth(lst: List[int], N: int) -> List[int]: ``` # Input * `lst`: A list of integers, where {|lst| leq 10^5}. * `N`: An integer where {0 leq N leq 10^5}. # Output * A list of integers where each integer from the original list `lst` appears no more than `N` times. # Constraints * The input list can be empty. * If `N` is 0, the result should be an empty list since no element should appear. * The original order of elements must be preserved. # Example ```python assert delete_nth([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert delete_nth([1, 1, 1, 1], 2) == [1, 1] assert delete_nth([], 2) == [] assert delete_nth([20, 37, 20, 21], 1) == [20, 37, 21] ``` # Additional Information * **Edge Cases**: Consider handling cases where `N` is very high, very low (including zero), or the input list is very large. * **Efficiency**: Aim to write an efficient solution with a linear time complexity, O(n), considering the constraints.","solution":"from typing import List def delete_nth(lst: List[int], N: int) -> List[int]: Returns a list where each element of the original list appears at most N times. if N == 0: return [] result = [] counts = {} for number in lst: if number in counts: if counts[number] < N: result.append(number) counts[number] += 1 else: result.append(number) counts[number] = 1 return result"},{"question":"You are working on a color classification application where each item can be represented by one of three colors: red, white, or blue. These colors are represented as integers 0, 1, and 2 respectively. Given an array of n items containing these integers, your task is to sort the colors so that items of the same color are adjacent, sorted in the order of red (0), white (1), and blue (2). Write a function `sort_colors(nums)` that sorts the input list `nums` in-place. Do not use any built-in sorting functions. # Function Signature ```python def sort_colors(nums: List[int]) -> None: Modify the list nums in-place to sort colors. ``` # Input * `nums`: A list of integers where each integer is either 0, 1, or 2. # Output * The function modifies the input list `nums` in-place to sort the colors. # Constraints * The length of `nums` will be in the range [0, 300]. * Each integer in `nums` is 0, 1, or 2. # Performance Requirements * Time Complexity: O(n) * Space Complexity: O(1) # Examples ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` ```python nums = [2, 0, 1] sort_colors(nums) print(nums) # Output: [0, 1, 2] ``` ```python nums = [0] sort_colors(nums) print(nums) # Output: [0] ``` ```python nums = [1] sort_colors(nums) print(nums) # Output: [1] ``` ```python nums = [2, 2, 2, 1, 1, 1, 0, 0, 0] sort_colors(nums) print(nums) # Output: [0, 0, 0, 1, 1, 1, 2, 2, 2] ``` # Hints * Think about using multiple pointers to partition the array.","solution":"def sort_colors(nums): Modify the list nums in-place to sort colors. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Regular Expression Matcher: Implementing with Wildcards Context You are tasked with implementing a function that can determine if a given string matches a given pattern. The pattern can contain two special characters: - \'.\' which matches any single character. - \'*\' which matches zero or more of the preceding element. The matching should cover the entire input string (not partial matches). Function Signature ```python def is_match(str_a: str, str_b: str) -> bool: ``` Input & Output * **Input**: - `str_a`: A string (`0 <= len(str_a) <= 1000`). - `str_b`: A string (`0 <= len(str_b) <= 1000`) containing lowercase letters, \'.\' and \'*\'. * **Output**: - Return `True` if the string matches the pattern even with wildcards, otherwise return `False`. Examples ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` Constraints * Patterns containing \'*\' must be valid (i.e., each \'*\' should follow a valid preceding element). * The solution should handle edge cases gracefully. Task Implement the function `is_match` that adheres to the outlined requirements, ensuring optimal time and space complexity. Thoroughly test your solution with various cases to validate correctness.","solution":"def is_match(str_a: str, str_b: str) -> bool: dp = [[False] * (len(str_b) + 1) for _ in range(len(str_a) + 1)] dp[0][0] = True for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'*\': dp[0][j] = dp[0][j - 2] for i in range(1, len(str_a) + 1): for j in range(1, len(str_b) + 1): if str_b[j - 1] == \'.\' or str_b[j - 1] == str_a[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif str_b[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] or (dp[i - 1][j] and (str_b[j - 2] == \'.\' or str_b[j - 2] == str_a[i - 1])) return dp[len(str_a)][len(str_b)]"},{"question":"Scenario: You are tasked with implementing a real-time data monitoring system for a financial application that tracks stock prices and computes the moving average over a defined window size for the purpose of trend analysis. Problem Statement: Write a class `MovingAverage` that calculates the moving average of the most recent integers in a sliding window of fixed size. Class Definition: ```python class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int pass def next(self, val: int) -> float: Accepts a new integer value and returns the moving average of the last \'size\' values. :type val: int :rtype: float pass ``` Expected Input and Output Formats: * **Initialization**: `m = MovingAverage(size)` * `size` is an integer representing the window size. * **Method Call**: `m.next(val)` * `val` is an integer value that is added to the window. * The method returns a float representing the current moving average. Constraints: * The window size `size` will be in the range `[1, 10000]`. * Each integer value `val` will be in the range `[-10^5, 10^5]`. Performance Requirements: * The `next` method should run in constant time O(1) for adding the value and computing the average. Example: ```python m = MovingAverage(3) assert m.next(1) == 1.0 # [1] => 1 / 1 = 1.0 assert m.next(10) == 5.5 # [1, 10] => (1 + 10) / 2 = 5.5 assert m.next(3) == 4.666... # [1, 10, 3] => (1 + 10 + 3) / 3 = 4.666... assert m.next(5) == 6.0 # [10, 3, 5] => (10 + 3 + 5) / 3 = 6.0 ```","solution":"class MovingAverage: def __init__(self, size: int): Initialize your data structure here. :type size: int self.size = size self.window = [] self.window_sum = 0 def next(self, val: int) -> float: Accepts a new integer value and returns the moving average of the last \'size\' values. :type val: int :rtype: float self.window.append(val) self.window_sum += val if len(self.window) > self.size: removed_val = self.window.pop(0) self.window_sum -= removed_val return self.window_sum / len(self.window)"},{"question":"Context You are working as a software engineer and need to manage a dynamic set of data using an efficient data structure that supports fast search, insertion, and traversal searches. You decide to implement a Binary Search Tree (BST) due to its performance characteristics and ordered property. Task Implement a robust Binary Search Tree (BST) with the following capabilities. You must ensure that the tree maintains its properties through insertions and allows various forms of searches and traversals. Requirements 1. **Insert**: Implement the ability to insert a new value into the BST. 2. **Search**: Provide a method to search for a value within the BST, returning `True` if it exists and `False` otherwise. 3. **Size**: A method to return the number of nodes in the BST. 4. **Traversal**: Functions for preorder, inorder, and postorder traversals which return lists of node values in the respective orders. Function Definitions 1. `insert(data: int) -> bool`: Inserts `data` into the BST. Returns `True` if insertion is successful, `False` if the value already exists. 2. `search(data: int) -> bool`: Searches for `data` in the BST. Returns `True` if found, `False` otherwise. 3. `size() -> int`: Returns the size of the BST. 4. `preorder() -> List[int]`: Returns a list of values resulting from pre-order traversal. 5. `inorder() -> List[int]`: Returns a list of values resulting from in-order traversal. 6. `postorder() -> List[int]`: Returns a list of values resulting from post-order traversal. Input and Output Formats * **Input**: * For insertion, an integer value `data`. * For search, an integer value `data`. * **Output**: * Boolean result for `insert` and `search` methods. * Integer result for `size` method. * List of integers for traversal methods (`preorder`, `inorder`, `postorder`). Constraints * The values inserted into the BST will be unique integers. * Operations will be tested on a variety of cases including edge cases mentioned. Example Usage ```python # Example: Creating and interacting with a BST bst = BST() bst.insert(10) bst.insert(15) bst.insert(6) bst.search(15) # Output: True bst.size() # Output: 3 bst.inorder() # Output: [6, 10, 15] ``` Ensure your implementation is efficient and handles various edge cases such as inserting into an empty BST or searching for non-existent elements.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None self.node_count = 0 def insert(self, data: int) -> bool: if self.root is None: self.root = TreeNode(data) self.node_count += 1 return True current = self.root while current: if data < current.value: if current.left is None: current.left = TreeNode(data) self.node_count += 1 return True current = current.left elif data > current.value: if current.right is None: current.right = TreeNode(data) self.node_count += 1 return True current = current.right else: # data is already present in the BST return False def search(self, data: int) -> bool: current = self.root while current: if data < current.value: current = current.left elif data > current.value: current = current.right else: return True return False def size(self) -> int: return self.node_count def preorder(self) -> list: def _preorder(node): return [node.value] + _preorder(node.left) + _preorder(node.right) if node else [] return _preorder(self.root) def inorder(self) -> list: def _inorder(node): return _inorder(node.left) + [node.value] + _inorder(node.right) if node else [] return _inorder(self.root) def postorder(self) -> list: def _postorder(node): return _postorder(node.left) + _postorder(node.right) + [node.value] if node else [] return _postorder(self.root)"},{"question":"# Question Please complete the function `efficient_cocktail_shaker_sort` that sorts an array of integers using an optimized version of the Cocktail Shaker Sort algorithm. The optimized version should attempt to reduce unnecessary passes once no further swaps are found in a single direction during a pass. Function Signature ```python def efficient_cocktail_shaker_sort(arr: List[int]) -> List[int]: # your code here ``` Input * `arr`: A list of integers, of length `n` (0 <= n <= 10^5). Output * Return the sorted list of integers. Constraints * The algorithm should be optimized to reduce the number of redundant passes. * You cannot use in-built sorting functions. Example ```python # Example 1 arr = [3, 0, 2, 5, -1, 4, 1] print(efficient_cocktail_shaker_sort(arr)) # Output: [-1, 0, 1, 2, 3, 4, 5] # Example 2 arr = [5, 1, 4, 2, 8] print(efficient_cocktail_shaker_sort(arr)) # Output: [1, 2, 4, 5, 8] # Example 3 arr = [] print(efficient_cocktail_shaker_sort(arr)) # Output: [] ``` Performance Requirements * Your solution should aim to handle arrays up to size `10^5` efficiently.","solution":"def efficient_cocktail_shaker_sort(arr): Sorts an array using an optimized Cocktail Shaker Sort algorithm. if not arr: return [] n = len(arr) start = 0 end = n - 1 while start <= end: swapped = False # Forward pass for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break end -= 1 swapped = False # Backward pass for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True if not swapped: break start += 1 return arr"},{"question":"# Context In a binary tree, finding relationships between nodes can be crucial for a variety of applications, such as determining common ancestors in family trees or finding common points in hierarchical data structures. One such relationship is the Lowest Common Ancestor (LCA). # Problem Statement Given a binary tree represented by a root node and two other nodes within the tree, find the lowest common ancestor of the two nodes. The LCA is defined as the lowest node that has both nodes as its descendants (where we allow a node to be a descendant of itself). # Function Signature Write a function `lca(root, p, q)` that takes in the root of a binary tree, and two nodes `p` and `q`, and returns their lowest common ancestor. # Inputs and Outputs * **Input**: * `root`: the root node of the binary tree (TreeNode) * `p`: first target node (TreeNode) * `q`: second target node (TreeNode) * **Output**: * Returns the TreeNode that is the lowest common ancestor of `p` and `q`. # Constraints * All TreeNode values are unique. * Both nodes `p` and `q` are guaranteed to be in the binary tree. * The binary tree has at least two nodes. # Example Consider the following binary tree: ``` _______3______ / ___5__ ___1__ / / 6 _2 0 8 / 7 4 ``` Calling `lca(root, 5, 1)` should return the node `3`. Calling `lca(root, 5, 4)` should return the node `5`. # Implementation Please implement the `lca` function following these constraints and requirements.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def lca(root, p, q): Finds the lowest common ancestor (LCA) of two nodes p and q in a binary tree. # Base case if root is None or root == p or root == q: return root # Recurse on left and right subtrees left = lca(root.left, p, q) right = lca(root.right, p, q) # If both left and right are not None, p and q are found in opposite subtrees if left and right: return root # Otherwise, return the non-null child return left if left else right"},{"question":"# Context: You are developing a scheduling system for a conference where multiple meeting rooms are being booked for various sessions. Each session has a start and end time. To avoid potential conflicts, you need to know if a single person could attend all scheduled sessions in a single room. # Task: Write a function `can_attend_all_sessions` that determines if there exists a room schedule where all sessions can be attended by a single person without any time overlaps. If some sessions overlap in time, the function should return `False`. # Function Signature: ```python def can_attend_all_sessions(sessions: List[List[int]]) -> bool: :param sessions: List of [start, end] time intervals (start < end) :return: boolean value indicating if all sessions can be attended by one person ``` # Input: * `sessions`: A list of intervals representing the start and end times of sessions (each a list of two integers). # Output: * Return `True` if it is possible for an individual to attend all the provided sessions in sequence without any time conflicts; otherwise, return `False`. # Constraints: * Each time interval [start, end] is such that 0 <= start < end <= 10^9. * The length of the sessions list does not exceed 10^4. # Examples: ```python assert can_attend_all_sessions([[0, 30], [5, 10], [15, 20]]) == False assert can_attend_all_sessions([[0, 5], [5, 10], [10, 15]]) == True assert can_attend_all_sessions([[5, 8], [9, 15]]) == True ``` # Notes: * Ensure your solution handles edge cases such as no sessions or single session input. * Consider the performance for large inputs, and aim to maintain an optimal complexity.","solution":"from typing import List def can_attend_all_sessions(sessions: List[List[int]]) -> bool: Determine if a single person can attend all scheduled sessions without any time overlaps. # Sort the sessions by start time (and by end time in case of tie for start time) sessions.sort(key=lambda x: (x[0], x[1])) # Check for any overlapping sessions for i in range(1, len(sessions)): if sessions[i][0] < sessions[i-1][1]: return False return True"},{"question":"**Knapsack Problem Optimization** You are tasked with solving an optimization problem involving a knapsack. Given a knapsack with a fixed carrying capacity and a list of items, each defined by a weight and value, you need to determine the maximum total value that can be accommodated inside the knapsack without exceeding its capacity. Write a function `maximize_knapsack_value(items, capacity)` where `items` is a list of tuples, with each tuple representing an item in the form `(value, weight)`, and `capacity` is an integer representing the maximum weight the knapsack can carry. **Constraints**: - 1 <= len(items) <= 1000 - 1 <= capacity <= 10000 - All item values and weights are positive integers. # Input - items: `List[Tuple[int, int]]` - A list of tuples where each tuple contains two integers representing the value and weight of an item. - capacity: `int` - An integer representing the maximum weight capacity of the knapsack. # Output - A single integer representing the maximum total value obtainable by selecting items without exceeding the knapsack\'s capacity. # Example ```python def maximize_knapsack_value(items, capacity): dp = [0] * (capacity + 1) for value, weight in items: for cur_weight in reversed(range(weight, capacity + 1)): dp[cur_weight] = max(dp[cur_weight], value + dp[cur_weight - weight]) return dp[capacity] # Example use case items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(maximize_knapsack_value(items, capacity)) # Output: 80 ``` # Notes - Consider all scenarios including no items fitting within any capacity, ensuring your function handles such cases gracefully. - Focus on optimizing both time and space complexities within the given constraints.","solution":"def maximize_knapsack_value(items, capacity): Determines the maximum total value that can be accommodated in the knapsack. Args: items (List[Tuple[int, int]]): List of items where each item is represented as (value, weight). capacity (int): The maximum weight the knapsack can carry. Returns: int: The maximum total value obtainable. dp = [0] * (capacity + 1) for value, weight in items: for cur_weight in reversed(range(weight, capacity + 1)): dp[cur_weight] = max(dp[cur_weight], value + dp[cur_weight - weight]) return dp[capacity]"},{"question":"You are tasked with simulating a process using a Markov Chain. The Markov Chain is defined by its transition probabilities from one state to another. Your objective is to write a function that generates a sequence of states starting from a given initial state. # Function Implementation Implement a function `generate_markov_sequence(chain, initial_state, num_steps)` that: - Takes as input: * `chain`: A dictionary representing the Markov Chain, where keys are current states, and values are dictionaries of possible next states with their transition probabilities. * `initial_state`: A string representing the starting state of the Markov Chain. * `num_steps`: An integer representing the number of steps (transitions) to simulate. - Returns: * A list of states representing the sequence of states generated by the Markov Chain starting from the `initial_state` and continuing for `num_steps` transitions. # Constraints * Assume valid input; the sum of transition probabilities for each state\'s possible next states will sum up to 1. * The Markov Chain will contain at least one state with valid transitions. # Performance Requirements The solution should be efficient and handle the generation of sequences up to 10,000 transitions smoothly. # Example ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } initial_state = \'A\' num_steps = 5 print(generate_markov_sequence(chain, initial_state, num_steps)) # Expected output could be: [\'A\', \'A\', \'B\', \'B\', \'B\'] but will vary due to randomness ``` # Additional Notes * Ensure the simulation handles scenarios where the current state has equal probabilities for transitions correctly. * Test the function with various chains and sequences, especially focusing on states with varying probabilities and ensuring the correctness of the transition distribution over multiple runs.","solution":"import random def generate_markov_sequence(chain, initial_state, num_steps): Generates a sequence of states starting from the initial_state for num_steps transitions based on a given Markov Chain. Parameters: - chain (dict): The Markov Chain as a dictionary where keys are the current states and values are dictionaries of possible next states with their transition probabilities. - initial_state (str): The initial state of the Markov Chain. - num_steps (int): The number of steps (transitions) to simulate. Returns: - list: The sequence of states generated by the Markov Chain. current_state = initial_state sequence = [current_state] for _ in range(num_steps): next_states = list(chain[current_state].keys()) probabilities = list(chain[current_state].values()) next_state = random.choices(next_states, probabilities)[0] sequence.append(next_state) current_state = next_state return sequence"},{"question":"**Priority Queue Sorting Challenge** Implement the `merge_priority_queues` function that takes two priority queues implemented using the provided `PriorityQueue` class and merges them into a single priority queue. The resulting priority queue should maintain the same ordering of priorities as the original priority queues. **Function Signature:** ```python def merge_priority_queues(pq1: PriorityQueue, pq2: PriorityQueue) -> PriorityQueue: pass ``` # Input: - `pq1`: An instance of `PriorityQueue`. - `pq2`: An instance of `PriorityQueue`. # Output: - A new `PriorityQueue` instance containing all elements from both `pq1` and `pq2`, maintaining the correct priority order. # Constraints: - Do not use built-in sorting functions or data structures other than the provided `PriorityQueue` class. - Take care of edge cases such as empty priority queues. # Example: ```python pq1 = PriorityQueue(items=[1, 3, 5], priorities=[2, 1, 4]) pq2 = PriorityQueue(items=[2, 4], priorities=[3, 1]) merged_pq = merge_priority_queues(pq1, pq2) print(merged_pq) # PriorityQueue([5: 4, 2: 3, 1: 2, 4: 1, 3: 1]) ``` # Explanation: The merged priority queue contains all the elements from `pq1` and `pq2`, ordered by their priorities: 5 (priority 4), 2 (priority 3), 1 (priority 2), and then the elements 4 and 3 both having priority 1.","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.elements = [] if items and priorities: for item, priority in zip(items, priorities): self.elements.append((priority, item)) self.elements.sort(reverse=True) def is_empty(self): return len(self.elements) == 0 def put(self, item, priority): self.elements.append((priority, item)) self.elements.sort(reverse=True) def get(self): return self.elements.pop()[1] def __repr__(self): return \\"PriorityQueue(\\" + \\", \\".join([f\\"{item}: {priority}\\" for priority, item in self.elements]) + \\")\\" def merge_priority_queues(pq1: PriorityQueue, pq2: PriorityQueue) -> PriorityQueue: merged_pq = PriorityQueue() while not pq1.is_empty(): priority, item = pq1.elements.pop() merged_pq.put(item, priority) while not pq2.is_empty(): priority, item = pq2.elements.pop() merged_pq.put(item, priority) merged_pq.elements.sort(reverse=True) return merged_pq"},{"question":"You are given a non-empty string. Your task is to determine if this string can be constructed by taking a substring of it and appending multiple copies of the substring together. # Function Specification Implement a function `is_repeated_substring_pattern(s: str) -> bool` that returns a boolean value, True if the string can be constructed by repeating some substring of it multiple times, otherwise return False. # Input - A single string `s` (1 <= len(s) <= 10^5). # Output - A boolean value: - `True` if the string can be constructed by repeating some substring multiple times. - `False` otherwise. # Constraints 1. The input string will contain only lowercase English letters. # Performance Requirements - Your solution should have a time complexity of O(n) where n is the length of the input string. - Space complexity should be considered to optimize for linear space usage. # Example Example 1 - **Input**: \\"abab\\" - **Output**: True - **Explanation**: The string can be formed by repeating the substring \\"ab\\". Example 2 - **Input**: \\"aba\\" - **Output**: False - **Explanation**: The string can\'t be constructed by repeating any substring. Example 3 - **Input**: \\"abcabcabcabc\\" - **Output**: True - **Explanation**: The string can be formed by repeating the substring \\"abc\\". # Notes - Consider both naive and optimized approaches, justifying your chosen solution with respect to both time and space complexity.","solution":"def is_repeated_substring_pattern(s: str) -> bool: Determines if the input string can be constructed by repeating a substring. n = len(s) # Naive approach could be looping and checking, but we aim for O(n) time complexity. doubled_s = s + s return s in doubled_s[1:-1]"},{"question":"You are building an application that needs to generate all possible abbreviations of a given word. An abbreviation is created by replacing some of the letters with their count (number of omitted characters). Write a function `generate_abbreviations(word: str) -> List[str]` that generates all possible abbreviations for the given input word. # Input - `word`: A non-empty string comprised of lowercase alphabetical characters (1 <= len(word) <= 5) # Output - Return a list of strings, where each string is a valid abbreviation of the input word. # Examples ```python generate_abbreviations(\\"word\\") # should return: [\'word\', \'wor1\', \'wo1d\', \'wo2\', \'w1rd\', \'w1r1\', \'w2d\', \'w3\', \'1ord\', \'1or1\', \'1o1d\', \'1o2\', \'2rd\', \'2r1\', \'3d\', \'4\'] generate_abbreviations(\\"ab\\") # should return: [\'ab\', \'a1\', \'1b\', \'2\'] ``` # Constraints - The input word will only contain lowercase letters. - The length of the word will be at most 5 characters. # Explanation The algorithm should recursively explore all possible states of characters being abbreviated or kept as is, and collect all possible results.","solution":"from typing import List def generate_abbreviations(word: str) -> List[str]: def backtrack(pos: int, cur: str, count: int): if pos == len(word): result.append(cur + (str(count) if count > 0 else \\"\\")) else: # Abbreviate this character backtrack(pos + 1, cur, count + 1) # Keep this character backtrack(pos + 1, cur + (str(count) if count > 0 else \\"\\") + word[pos], 0) result = [] backtrack(0, \\"\\", 0) return result"},{"question":"Minimum Cost Set Cover Problem You are given a **universe (U)** containing **n elements** and a **collection of subsets** of (U): (S = {S1, S2, ..., Sm}). Each subset (Si) has an associated **cost**. Your task is to find a minimum cost sub-collection of (S) that covers all elements of (U). # Function Specifications: 1. `optimal_set_cover(universe: List[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]` * This function should implement the optimal set-cover algorithm with time complexity (O(2^n cdot n cdot m)). * **Input**: * `universe`: List of elements representing the universe (U). * `subsets`: Dictionary with subset names as keys and sets of elements as values. * `costs`: Dictionary with subset names as keys and integers representing their respective costs. * **Output**: * Returns a list of subset names that form the minimum cost cover of the universe. 2. `greedy_set_cover(universe: Set[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]` * This function should implement the greedy set-cover algorithm with time complexity (O(m cdot n^2)). * **Input**: * `universe`: Set of elements representing the universe (U). * `subsets`: Dictionary with subset names as keys and sets of elements as values. * `costs`: Dictionary with subset names as keys and integers representing their respective costs. * **Output**: * Returns a list of subset names that form an approximate minimum cost cover of the universe. # Constraints: * Elements in `universe` will be unique. * Elements in subsets will be unique and derived from `universe`. * Costs will be positive integers. # Example: ```python universe = {1, 2, 3, 4, 5} subsets = {\'S1\': {4, 1, 3}, \'S2\': {2, 5}, \'S3\': {1, 4, 3, 2}} costs = {\'S1\': 5, \'S2\': 10, \'S3\': 3} optimal_cover = optimal_set_cover(universe, subsets, costs) print(optimal_cover) # Output: [\'S3\', \'S2\'] greedy_cover = greedy_set_cover(universe, subsets, costs) print(greedy_cover) # Output: [\'S3\', \'S2\'] ``` # Additional Scenarios: * Ensure your functions handle the case when the universe is empty. * Test cases where multiple minimal cost solutions exist. * Cases where subsets do not provide full coverage of the universe should return an empty list or `None`.","solution":"from typing import List, Dict, Set def optimal_set_cover(universe: List[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: from itertools import combinations n = len(universe) best_cost = float(\'inf\') best_set_cover = [] # Iterate through all combinations of subsets to find the optimal cover for r in range(1, len(subsets) + 1): for combo in combinations(subsets.keys(), r): covered = set() cost = 0 for subset in combo: covered.update(subsets[subset]) cost += costs[subset] if covered == set(universe) and cost < best_cost: best_cost = cost best_set_cover = list(combo) return best_set_cover def greedy_set_cover(universe: Set[int], subsets: Dict[str, Set[int]], costs: Dict[str, int]) -> List[str]: uncovered = set(universe) selected_subsets = [] while uncovered: best_subset = None best_cost_effectiveness = float(\'inf\') for subset_name, subset in subsets.items(): covered_elements = uncovered & subset if covered_elements: cost_effectiveness = costs[subset_name] / len(covered_elements) if cost_effectiveness < best_cost_effectiveness: best_cost_effectiveness = cost_effectiveness best_subset = subset_name if best_subset is None: return [] # No cover found uncovered -= subsets[best_subset] selected_subsets.append(best_subset) return selected_subsets"},{"question":"# Problem Description Comb Sort is a comparison-based sorting algorithm that improves on Bubble Sort by initially comparing elements that are far apart. The gap between compared elements shrinks gradually to 1, using a shrink factor for efficient performance. Despite its simplicity, Comb Sort is quite effective for small datasets. # Task Given an array of integers, implement the Comb Sort algorithm to sort the array in ascending order. # Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: pass ``` # Input * `arr`: A list of integers, `arr` (0 ≤ len(arr) ≤ 10^5, -10^5 ≤ arr[i] ≤ 10^5). # Output * A list of integers sorted in ascending order. # Constraints * Your solution must implement Comb Sort. * The array may contain duplicate elements. * Your solution should handle the edge cases: empty arrays and arrays with one element. * Performance should be optimized to the best extent possible under the given constraints. # Example ```python assert comb_sort([20, -4, 7, 1, 3, 12, -5]) == [-5, -4, 1, 3, 7, 12, 20] assert comb_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert comb_sort([]) == [] assert comb_sort([100]) == [100] ``` # Explanation 1. The Comb Sort algorithm will sort the example array `[20, -4, 7, 1, 3, 12, -5]` in ascending order resulting in `[-5, -4, 1, 3, 7, 12, 20]`. 2. For an array where all elements are identical, it will return the same array unchanged. 3. An empty array will be returned as is. 4. A single-element array will also be returned as is because it is inherently sorted. Implement `comb_sort` function to perform the sorting as described.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 # Divide by shrink factor of 1.3 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Bitonic Sort Challenge Given an array of integers, implement a sorting function using Bitonic Sort. Your implementation should follow the principles of Bitonic Sort and ensure that the array sizes are a power of two. Function Signature ```python def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: pass ``` # Input - `arr`: A list of integers where the length `n` is a power of two (1 <= n <= 2^10). - `reverse`: A boolean that determines if the array should be sorted in descending order (`True`) or ascending order (`False`). Default is `False`. # Output - Returns a new sorted list based on the `reverse` flag. # Constraints - The length of the array `n` will always be a power of two. # Example ```python # ascending order print(bitonic_sort([3, 7, 2, 8, 6, 4, 5, 1])) # Output: [1, 2, 3, 4, 5, 6, 7, 8] # descending order print(bitonic_sort([3, 7, 2, 8, 6, 4, 5, 1], reverse=True)) # Output: [8, 7, 6, 5, 4, 3, 2, 1] ``` # Notes - You should handle edge cases such as an array having only one or zero elements gracefully, returning the array itself. - Raise a `ValueError` if the input array length is not a power of two.","solution":"from typing import List def bitonic_sort(arr: List[int], reverse: bool = False) -> List[int]: Perform a bitonic sort on the array. Parameters: arr (List[int]): The list of integers to be sorted. reverse (bool): If true, sort in descending order; otherwise, sort in ascending order. Default is False. Returns: List[int]: The sorted list. Raises: ValueError: If the length of the list is not a power of two. def bitonic_compare_and_swap(arr: List[int], i: int, j: int, direction: bool): if (direction == (arr[i] > arr[j])): arr[i], arr[j] = arr[j], arr[i] def bitonic_merge(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 for i in range(low, low + k): bitonic_compare_and_swap(arr, i, i + k, direction) bitonic_merge(arr, low, k, direction) bitonic_merge(arr, low + k, k, direction) def bitonic_sort_recursive(arr: List[int], low: int, cnt: int, direction: bool): if cnt > 1: k = cnt // 2 bitonic_sort_recursive(arr, low, k, True) # sorting in ascending order bitonic_sort_recursive(arr, low + k, k, False) # sorting in descending order bitonic_merge(arr, low, cnt, direction) if (len(arr) & (len(arr) - 1)) != 0: raise ValueError(\\"The length of the array must be a power of two.\\") bitonic_sort_recursive(arr, 0, len(arr), not reverse) return arr"},{"question":"# Pythagorean Theorem Application **Scenario**: You\'re working on an educational software that helps students understand geometry concepts, particularly the Pythagorean theorem. You need to write a function that applies this theorem to determine an unknown side of a right-angled triangle. **Problem Statement**: Implement a function `pythagoras(opposite, adjacent, hypotenuse)` that computes the length of the unknown side of a right-angled triangle given the lengths of the other two sides. The function should determine and return the length of the side that is marked as \\"?\\" (indicating it\'s unknown). If no side is unknown, the function should return a message stating that the answer is already known. **Function Signature**: ```python def pythagoras(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: ``` **Parameters**: * `opposite` (float or str): length of the opposite side or \\"?\\" if unknown. * `adjacent` (float or str): length of the adjacent side or \\"?\\" if unknown. * `hypotenuse` (float or str): length of the hypotenuse or \\"?\\" if unknown. **Returns**: * A string in the format \\"SideName = Value\\" indicating the name and length of the unknown side. * If no side is labelled as \\"?\\", return \\"You already know the answer!\\" * Raise a `ValueError` for invalid inputs. **Constraints**: 1. Only one side can be marked as \\"?\\". 2. All sides should be positive numbers or \\"?\\" (if such a side length is unknown). 3. Ensure the input follows the properties of a right-angled triangle (`hypotenuse**2 = opposite**2 + adjacent**2`). **Example**: ```python >>> pythagoras(3, 4, \\"?\\") \'Hypotenuse = 5.0\' >>> pythagoras(3, \\"?\\", 5) \'Adjacent = 4.0\' >>> pythagoras(\\"?\\", 4, 5) \'Opposite = 3.0\' >>> pythagoras(3, 4, 5) \'You already know the answer!\' ``` **Edge Cases**: - Ensure the function handles invalid inputs gracefully by raising `ValueError`. - Consider scenarios where side lengths provided do not form a right-angled triangle.","solution":"import math from typing import Union def pythagoras(opposite: Union[float, str], adjacent: Union[float, str], hypotenuse: Union[float, str]) -> str: Computes the length of the unknown side of a right-angled triangle using the Pythagorean theorem. Parameters: - opposite: length of the opposite side or \\"?\\" if unknown - adjacent: length of the adjacent side or \\"?\\" if unknown - hypotenuse: length of the hypotenuse or \\"?\\" if unknown Returns: - A string indicating the name and length of the unknown side. - If no side is unknown, returns \\"You already know the answer!\\". - Raises ValueError for invalid inputs. if isinstance(opposite, str) and opposite == \\"?\\": if isinstance(adjacent, (int, float)) and isinstance(hypotenuse, (int, float)): if hypotenuse <= adjacent: raise ValueError(\\"Hypotenuse must be greater than either side in a right-angled triangle.\\") opposite_value = math.sqrt(hypotenuse**2 - adjacent**2) return f\\"Opposite = {opposite_value}\\" elif isinstance(adjacent, str) and adjacent == \\"?\\": if isinstance(opposite, (int, float)) and isinstance(hypotenuse, (int, float)): if hypotenuse <= opposite: raise ValueError(\\"Hypotenuse must be greater than either side in a right-angled triangle.\\") adjacent_value = math.sqrt(hypotenuse**2 - opposite**2) return f\\"Adjacent = {adjacent_value}\\" elif isinstance(hypotenuse, str) and hypotenuse == \\"?\\": if isinstance(opposite, (int, float)) and isinstance(adjacent, (int, float)): hypotenuse_value = math.sqrt(opposite**2 + adjacent**2) return f\\"Hypotenuse = {hypotenuse_value}\\" elif isinstance(opposite, (int, float)) and isinstance(adjacent, (int, float)) and isinstance(hypotenuse, (int, float)): if math.isclose(hypotenuse**2, opposite**2 + adjacent**2): return \\"You already know the answer!\\" else: raise ValueError(\\"The provided sides do not form a right-angled triangle.\\") raise ValueError(\\"Invalid input. Only one side can be unknown, and sides must be positive numbers.\\")"},{"question":"You are working on developing a text similarity system for a company that processes large numbers of textual documents. One of the common tasks is to compute the similarity between pairs of words based on the minimum number of edits (insertions, deletions, substitutions) required to change one word into another. You need to implement an efficient algorithm to determine this edit distance. # Task Write a function `minimum_edit_distance(word_a, word_b)` that calculates the minimum edit distance between two given strings `word_a` and `word_b`. # Function Signature ```python def minimum_edit_distance(word_a: str, word_b: str) -> int: pass ``` # Input * `word_a` (string): The first word. * `word_b` (string): The second word. # Output * (int): The minimum number of edit operations required to transform `word_a` into `word_b`. # Constraints * The lengths of `word_a` and `word_b` will not exceed 1000 characters. * The strings will consist only of lowercase alphabetical characters. # Example ```python assert minimum_edit_distance(\\"kitten\\", \\"sitting\\") == 3 # kitten -> sitten -> sittin -> sitting assert minimum_edit_distance(\\"flaw\\", \\"lawn\\") == 2 # flaw -> law -> lawn ``` # Performance Requirements * The function should be efficient with a time complexity of O(length_a * length_b) and a space complexity of O(length_a * length_b) or better. # Guidelines 1. Initialize a 2D array to store the minimum edit distances. 2. Fill in the base cases where one of the strings is empty. 3. Use dynamic programming to fill in the rest of the array based on the recurrence relation. 4. Return the value in the table that represents the edit distance between the entire `word_a` and `word_b`.","solution":"def minimum_edit_distance(word_a: str, word_b: str) -> int: Calculate the minimum edit distance between two strings word_a and word_b using Dynamic Programming approach. len_a, len_b = len(word_a), len(word_b) # Create a 2D array to store the edit distances dp = [[0] * (len_b + 1) for _ in range(len_a + 1)] # Initialize base cases for i in range(len_a + 1): dp[i][0] = i # Deleting all characters from word_a for j in range(len_b + 1): dp[0][j] = j # Inserting all characters to word_a to make word_b # Fill the dp array using the recurrence relation for i in range(1, len_a + 1): for j in range(1, len_b + 1): if word_a[i - 1] == word_b[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[len_a][len_b]"},{"question":"**Question**: You are given an array that can contain various data types including integers, booleans, strings, etc. Your task is to implement a function `move_zeros` that moves all zero-valued elements to the end of the array while preserving the order of non-zero elements. However, the boolean value `False` should not be considered as zero and should remain in its original position. Non-zero elements should preserve their order. The function should perform the operation in-place. Write the function `move_zeros` with the following signature: ```python def move_zeros(array: List[Any]) -> None: pass ``` # Input 1. An array `array` of length `n` containing elements of various types. # Output 1. The function should modify the input array in-place and return `None`. # Constraints 1. The length of the array `n` will be in the range `[0, 10^5]`. 2. The array can contain integers, booleans, strings, etc. # Example ```python array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] move_zeros(array) print(array) # Output: [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] ``` # Performance Requirements The solution should aim for O(n) time complexity for the best performance given the constraint n can be large. # Hints Consider using two pointers technique for in-place modification to maintain constant space complexity.","solution":"from typing import List, Any def move_zeros(array: List[Any]) -> None: Moves all zero-valued elements to the end of the list while preserving the order of non-zero elements. The boolean value False is not considered as zero and remains in its original position. n = len(array) last_non_zero_found_at = 0 for i in range(n): if array[i] != 0 or isinstance(array[i], bool): array[last_non_zero_found_at] = array[i] last_non_zero_found_at += 1 for i in range(last_non_zero_found_at, n): array[i] = 0"},{"question":"Coding Assessment Question # Problem Description In this task, you are required to implement a more optimized variant of Euler\'s Totient Function. Euler\'s Totient Function, ϕ(n), counts the number of integers between 1 and n inclusive, which are coprime to n. Two numbers are said to be coprime if their greatest common divisor (GCD) is 1. # Function Signature ```python def optimized_euler_totient(n: int) -> int: pass ``` # Input Format - An integer `n` (1 ≤ n ≤ 10^6). # Output Format - An integer representing the value of ϕ(n). # Constraints - Your solution should run efficiently for n up to 10^6. # Example ```python assert optimized_euler_totient(1) == 1 assert optimized_euler_totient(5) == 4 assert optimized_euler_totient(10) == 4 ``` # Notes - You need to ensure efficient handling and factorization while keeping the complexity close to O(√n). - Consider reducing redundant calculations to keep your implementation optimal. - Think through edge cases and validate that your function works correctly for these cases.","solution":"def optimized_euler_totient(n: int) -> int: if n == 1: return 1 result = n p = 2 # Check for each number from 2 to sqrt(n) while p * p <= n: # Check if p is a divisor of n if n % p == 0: # If so, then p is a prime factor, so we calculate while n % p == 0: n //= p result -= result // p p += 1 # This condition is to check if n is a prime number # greater than sqrt(n) if n > 1: result -= result // n return result"},{"question":"# Remove Duplicates from a Linked List **Background**: Imagine you are building a system that stores large datasets, and some of these datasets can have duplicate entries. You are required to clean up these datasets by removing duplicate entries. In this scenario, each dataset is represented as a linked list, where each node contains a string value. **Problem**: Write a Python function to remove duplicate nodes from a linked list. Provide two implementations: 1. Using an additional data structure to track duplicates. 2. Without using any additional storage, only manipulating pointers. # Function Signature ```python class Node: def __init__(self, val: str = None): self.val = val self.next = None def remove_dups(head: Node) -> None: # Your implementation here def remove_dups_without_set(head: Node) -> None: # Your implementation here ``` # Input - `head`: The head node of the linked list. # Output - Modify the linked list in place to remove duplicate values. No return value is needed. # Constraints - The value of each node is assumed to be a string. - The linked list can have up to 10^5 nodes. - Try to handle both small and large lists efficiently. # Example Consider the linked list represented by the nodes in the sequence `A -> A -> B -> C -> D -> C -> F -> G`. After removing duplicates, it should become: `A -> B -> C -> D -> F -> G`. # Testing You can use the following linked list for testing your function: ```python a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g # Apply both functions to the list and verify the results. remove_dups(a1) print_linked_list(a1) # Expected: A -> B -> C -> D -> F -> G # Re-create the linked list or repeat the operations to test the second function. remove_dups_without_set(a1) print_linked_list(a1) # Expected: A -> B -> C -> D -> F -> G ``` # Notes - Ensure your solution handles edge cases like empty and single element linked lists. - Evaluate the performance of your solution with large datasets.","solution":"class Node: def __init__(self, val: str = None): self.val = val self.next = None def remove_dups(head: Node) -> None: if not head: return current = head seen = set([current.val]) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: if not head: return current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next"},{"question":"# Password Strengthening Problem Objective: Determine the minimum number of characters required to make a given password strong based on specified criteria. Problem Statement: You are provided with a password of length `n` and the password itself. A password is considered strong if it satisfies the following conditions: 1. Its length is at least 6 characters. 2. It contains at least one digit. 3. It contains at least one lowercase English character. 4. It contains at least one uppercase English character. 5. It contains at least one special character from the set: `!@#%^&*()-+`. Your task is to determine the minimum number of characters that need to be added to the password to make it strong. Input Format: - An integer `n` representing the length of the password. - A string `password` of length `n` representing the actual password. Output Format: - An integer denoting the minimum number of characters to add to make the password strong. Constraints: - `1 <= n <= 100` - Password consists of lowercase/uppercase English alphabet, digits, or special characters from `!@#%^&*()-+`. Sample Input: ``` 3 Ab1 ``` Sample Output: ``` 3 ``` Explanation: In the sample, the password \'Ab1\' has a length of 3 which is less than 6, and it already contains digits, lower, and upper case. Adding 3 characters, such as \'hk\', will satisfy all criteria, turning the password into \'Ab1hk\'. Sample Input: ``` 11 #Algorithms ``` Sample Output: ``` 1 ``` Explanation: In the sample, the password \'#Algorithms\' has length 11 and includes special, lower, and upper case characters but no digits. Adding a \'0\' makes it strong. Function Signature: ```python def strong_password(n: int, password: str) -> int: ``` Requirements: Implement the function `strong_password` that follows the constraints and determines the minimum number of characters needed to achieve a strong password.","solution":"def strong_password(n: int, password: str) -> int: length_required = max(0, 6 - n) digit_required = 1 lowercase_required = 1 uppercase_required = 1 special_required = 1 special_characters = set(\'!@#%^&*()-+\') for c in password: if c.isdigit(): digit_required = 0 elif c.islower(): lowercase_required = 0 elif c.isupper(): uppercase_required = 0 elif c in special_characters: special_required = 0 types_required = digit_required + lowercase_required + uppercase_required + special_required return max(length_required, types_required)"},{"question":"You are given a string `s` and a dictionary of words `dict`. Your task is to write a function `count_valid_sentences(s, dict)` that returns the number of valid sentences you can form from the string `s` such that all words in each sentence are contained in the dictionary. # Function Signature ```python def count_valid_sentences(s: str, dict: set) -> int: pass ``` # Input * `s`: A string, `1 <= len(s) <= 100`. * `dict`: A set containing up to `100` words, where each word\'s length is between `1` and `20`. # Output * Return an integer representing the number of valid sentences that can be formed. # Constraints * All characters in `s` and `dict` are lowercase English letters. # Example ```python assert count_valid_sentences(\\"appletablet\\", {\\"apple\\", \\"tablet\\"}) == 1 assert count_valid_sentences(\\"applet\\", {\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"}) == 3 assert count_valid_sentences(\\"thing\\", {\\"thing\\"}) == 1 assert count_valid_sentences(\\"word\\", {\\"w\\", \\"o\\", \\"rd\\", \\"word\\", \\"go\\"}) == 2 ``` # Explanation 1. For the string `\\"appletablet\\"` with the dictionary `{\\"apple\\", \\"tablet\\"}`, only one valid sentence `\\"apple tablet\\"` can be formed. 2. For the string `\\"applet\\"` with the dictionary `{\\"app\\", \\"let\\", \\"apple\\", \\"t\\", \\"applet\\"}`, three valid sentences are `\\"apple t\\"`, `\\"app let\\"`, and `\\"applet\\"`. 3. For the string `\\"thing\\"` with the dictionary `{\\"thing\\"}`, only one valid sentence `\\"thing\\"` can be formed. 4. For the string `\\"word\\"` with the dictionary `{\\"w\\", \\"o\\", \\"rd\\", \\"word\\", \\"go\\"}`, two valid sentences can be formed: `\\"w o rd\\"` and `\\"word\\"`. # Notes * Be sure to consider all potential edge cases and optimize the performance with memoization to avoid repeated subproblems.","solution":"def count_valid_sentences(s: str, dict: set) -> int: Returns the number of valid sentences that can be formed from the string `s` using the words in the dictionary `dict`. # Implement a recursive function with memoization to count valid sentences cache = {} def helper(start): if start == len(s): return 1 if start in cache: return cache[start] count = 0 for end in range(start + 1, len(s) + 1): word = s[start:end] if word in dict: count += helper(end) cache[start] = count return count return helper(0)"},{"question":"# RSA Key Generation and Encryption **Objective:** Implement the RSA encryption algorithm by generating the public and private keys, encrypting a given message with the public key, and then decrypting it with the private key. **Task:** 1. **Key Generation:** Implement an efficient prime number generation process for large bit sizes using a probabilistic primality test (like Miller-Rabin or similar). - Function: `generate_key(k: int, seed: int = None) -> Tuple[int, int, int]` - Input: An integer `k` representing the number of bits in `n`, and an optional seed for repeatable random number generation. - Output: A tuple of three integers `(n, e, d)` representing the modulus, the encryption exponent, and the decryption exponent, respectively. 2. **Encryption:** - Function: `encrypt(data: int, e: int, n: int) -> int` - Input: An integer `data` to be encrypted, and integers `e` (encryption exponent) and `n` (modulus) from the public key. - Output: The encrypted data as an integer. 3. **Decryption:** - Function: `decrypt(data: int, d: int, n: int) -> int` - Input: An integer `data` to be decrypted, and integers `d` (decryption exponent) and `n` (modulus) from the private key. - Output: The decrypted original data as an integer. **Constraints:** - Ensure `k` is at least 16 bits for minimal security. - Make sure the chosen primes `p` and `q` are sufficiently large to generate secure keys. - Use modular arithmetic efficiently to avoid performance bottlenecks. **Example:** ```python # Generating keys n, e, d = generate_key(16) data = 12345 # Encrypting data encrypted = encrypt(data, e, n) print(f\\"Encrypted: {encrypted}\\") # Decrypting data decrypted = decrypt(encrypted, d, n) print(f\\"Decrypted: {decrypted}\\") # Verify assert data == decrypted ``` **Performance Requirements:** - Efficient prime generation within reasonable time constraints. - Optimal use of space and time in encryption/decryption to handle large values of `n`. **Notes:** - You may use Python\'s built-in modular exponentiation `pow(a, b, c)` for efficient calculations. - Consider edge cases such as the selection of small primes, invalid `e` and handling non-prime or composite numbers during key generation.","solution":"import random def gcd(a, b): while b: a, b = b, a % b return a def multiplicative_inverse(e, phi): def egcd(a, b): if a == 0: return (b, 0, 1) g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y) g, x, y = egcd(e, phi) if g != 1: raise Exception(\'Multiplicative inverse does not exist\') else: return x % phi def is_prime(n, k=5): # number of tests = k if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_prime_candidate(length): p = random.getrandbits(length) p |= (1 << length - 1) | 1 return p def generate_prime_number(length): p = 4 while not is_prime(p, 128): p = generate_prime_candidate(length) return p def generate_key(k: int, seed: int = None): if seed is not None: random.seed(seed) p = generate_prime_number(k // 2) q = generate_prime_number(k // 2) n = p * q phi = (p - 1) * (q - 1) e = random.randrange(1, phi) g = gcd(e, phi) while g != 1: e = random.randrange(1, phi) g = gcd(e, phi) d = multiplicative_inverse(e, phi) return (n, e, d) def encrypt(data: int, e: int, n: int) -> int: return pow(data, e, n) def decrypt(data: int, d: int, n: int) -> int: return pow(data, d, n)"},{"question":"# Coding Challenge Context You are an intern at a game development company, and you\'ve been assigned a task to implement a new mini-game. This mini-game involves a character climbing a staircase. The character can take either 1 or 2 steps at a time, and you need to determine the number of distinct ways the character can reach the top of the stairs. Problem Statement Write a function `number_of_ways(n)` that computes the number of distinct ways to reach the top of a staircase that has `n` steps. Each time, the character can climb 1 or 2 steps. Input * An integer `n` (1 <= n <= 10^6) representing the number of steps in the staircase. Output * Return an integer, which is the number of distinct ways to reach the top of the staircase. Constraints * The function should run efficiently for large values of `n` up to 10^6. * The the result for n will fit in a typical 64-bit signed integer. Examples Example 1: ``` Input: n = 2 Output: 2 Explanation: There are two ways to climb to the top: 1. 1 step + 1 step 2. 2 steps at once ``` Example 2: ``` Input: n = 3 Output: 3 Explanation: There are three ways to climb to the top: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps at once 3. 2 steps at once + 1 step ``` Additional Notes * Keep in mind the performance requirements, particularly the need for the solution to run efficiently for large inputs.","solution":"def number_of_ways(n): Returns the number of distinct ways to reach the top of a staircase with n steps. A character can take either 1 or 2 steps at a time. Parameters: n (int): The number of steps in the staircase. Returns: int: The number of distinct ways to reach the top. # Base cases if n == 1: return 1 elif n == 2: return 2 # Use dynamic programming to store the number of ways to reach each step ways = [0] * (n + 1) ways[1] = 1 ways[2] = 2 for i in range(3, n + 1): ways[i] = ways[i - 1] + ways[i - 2] return ways[n]"},{"question":"You are given a utilitarian task to implement a Run-Length Encoding (RLE) and Decoding algorithm for compressing and decompressing textual data. Your implementation should handle large data efficiently and preserve data integrity during the process. # Function Definitions 1. **encode_rle** - **Input**: A string `input`. - **Output**: A string representing the run-length encoded data. - **Constraints**: - The input string can have any printable ASCII characters. - The function must be able to handle strings up to a length of 10^6. - Must efficiently handle cases with large numbers of repeated characters. 2. **decode_rle** - **Input**: A string `input`. - **Output**: The original string before encoding. - **Constraints**: - The encoded input string is correctly formatted per RLE specification. - The function must handle strings up to a length of 10^6. # Example ```python assert encode_rle(\\"aaabbcccc\\") == \\"3a2b4c\\" assert decode_rle(\\"3a2b4c\\") == \\"aaabbcccc\\" ``` # Additional Notes - Handle empty strings effectively. - Ensure that the resulting implementation is optimized for both time and space complexities. - Consider edge cases in both encoding and decoding, such as single characters, no repetitions, and very long sequences of the same character.","solution":"def encode_rle(input_string): Encodes a string using Run-Length Encoding (RLE). :param input_string: The input string to encode. :return: A string representing the run-length encoded data. if not input_string: return \\"\\" encoded_str = [] count = 1 previous_char = input_string[0] for char in input_string[1:]: if char == previous_char: count += 1 else: encoded_str.append(f\\"{count}{previous_char}\\") previous_char = char count = 1 encoded_str.append(f\\"{count}{previous_char}\\") return \'\'.join(encoded_str) def decode_rle(encoded_string): Decodes a string using Run-Length Encoding (RLE). :param encoded_string: The encoded string to decode. :return: The original string before encoding. if not encoded_string: return \\"\\" decoded_str = [] count = 0 for char in encoded_string: if char.isdigit(): count = count * 10 + int(char) else: decoded_str.append(char * count) count = 0 return \'\'.join(decoded_str)"},{"question":"Context You are tasked with writing a function that formats a given alphanumeric string into groups separated by hyphens. Each group must contain exactly `k` characters except the first group which can be shorter if necessary. This type of format is often used in displaying license keys, where readability and consistent grouping are important. # Function Signature ```python def format_license_key(key: str, k: int) -> str: ``` # Input * `key`: A string consisting of alphanumeric characters and hyphens. Here are the constraints: * `1 <= len(key) <= 10^4` * `key` contains only \'0\'-\'9\', \'a\'-\'z\', \'A\'-\'Z\' and hyphens (\'-\'). * `k`: An integer where `1 <= k <= 10^4`. # Output * Return a formatted string where the alphanumeric characters are grouped into segments separated by hyphens, each containing exactly `k` characters except the first one which may be shorter to fit in the total length. # Examples Example 1 Input: ```python key = \\"5F3Z-2e-9-w\\" k = 4 ``` Output: ```python \\"5F3Z-2E9W\\" ``` Example 2 Input: ```python key = \\"2-5g-3-J\\" k = 2 ``` Output: ```python \\"2-5G-3J\\" ``` # Constraints * Ignore all hyphens in the input string. * Evenly distribute the remaining alphanumeric characters into groups containing exactly `k` characters. * Convert all lowercase letters to uppercase. Write a function `format_license_key` to solve the problem according to the above requirements.","solution":"def format_license_key(key: str, k: int) -> str: # Remove all hyphens and convert to uppercase clean_key = key.replace(\\"-\\", \\"\\").upper() # Determine the size of the first group first_group_size = len(clean_key) % k # Initialize a list to hold the parts parts = [] # Add the first group if it\'s not empty if first_group_size > 0: parts.append(clean_key[:first_group_size]) # Add subsequent groups of size k for i in range(first_group_size, len(clean_key), k): parts.append(clean_key[i:i+k]) # Join parts with hyphens return \\"-\\".join(parts)"},{"question":"# Unique Character String Filter Your task is to write a function that extracts unique characters from a given string such that each character only appears once in the resulting string, maintaining the order of their first occurrence. Your function should comply with the following requirements: Function Signature ```python def filter_unique_characters(input_string: str) -> str: ``` Input * A single `input_string` which is a non-empty string containing alpha-numeric characters and possibly whitespaces. The string will have at most length of 10^6. Output * A string that contains no repeating characters from the `input_string`, maintaining their first occurrence order. Constraints * Only alpha-numeric characters and whitespaces in the input. * Case-sensitive (treat \'a\' and \'A\' as different characters). * The result will have the characters in the order of their first appearance. Performance Requirements * The solution should have linear time complexity O(n). # Example Input ```python input_string = \\"abracadabra\\" ``` Output ```python \\"abrcd\\" ``` Input ```python input_string = \\"google\\" ``` Output ```python \\"gole\\" ```","solution":"def filter_unique_characters(input_string: str) -> str: seen = set() result = [] for char in input_string: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"**Objective**: Implement a Circular Array Queue with optimized enqueue and dequeue operations. # Problem Description You are required to implement a `CircularArrayQueue` class that extends the provided `AbstractQueue` class. This implementation should use an array internally but manage the elements in a circular manner to avoid the need for element shifting, making both enqueue and dequeue operations O(1). # Requirements 1. **enqueue(value)**: * Insert an element at the rear of the queue. * If the array is full, double its capacity and reorganize elements in a circular manner. 2. **dequeue()**: * Remove and return the front element of the queue. * If the queue is empty, raise an IndexError with the message \\"Queue is empty\\". 3. **peek()**: * Return the front element without removing it. * If the queue is empty, raise an IndexError with the message \\"Queue is empty\\". 4. **is_empty()**: * Return True if the queue is empty, otherwise False. 5. **__len__()**: * Return the number of elements in the queue. # Constraints * **Initial Capacity**: The queue should start with an initial capacity of 10. * **Resizing**: Each time the queue exceeds its capacity, it should double in size. * **Performance**: Operations should be optimized for O(1) time complexity for enqueue and dequeue. # Method Signatures ```python class CircularArrayQueue(AbstractQueue): def __init__(self, capacity=10): pass def __iter__(self): pass def enqueue(self, value): pass def dequeue(self): pass def peek(self): pass ``` # Examples ```python # Example usage: queue = CircularArrayQueue() queue.enqueue(10) queue.enqueue(20) assert queue.dequeue() == 10 assert not queue.is_empty() assert queue.peek() == 20 assert len(queue) == 1 queue.dequeue() assert queue.is_empty() try: queue.dequeue() except IndexError as e: assert str(e) == \\"Queue is empty\\" ```","solution":"class CircularArrayQueue: def __init__(self, capacity=10): self._capacity = capacity self._queue = [None] * capacity self._front = 0 self._rear = 0 self._size = 0 def _resize(self): new_capacity = self._capacity * 2 new_queue = [None] * new_capacity for i in range(self._size): new_queue[i] = self._queue[(self._front + i) % self._capacity] self._queue = new_queue self._front = 0 self._rear = self._size self._capacity = new_capacity def enqueue(self, value): if self._size == self._capacity: self._resize() self._queue[self._rear] = value self._rear = (self._rear + 1) % self._capacity self._size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") value = self._queue[self._front] self._queue[self._front] = None self._front = (self._front + 1) % self._capacity self._size -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self._queue[self._front] def is_empty(self): return self._size == 0 def __len__(self): return self._size def __iter__(self): for i in range(self._size): yield self._queue[(self._front + i) % self._capacity]"},{"question":"# Stooge Sort Implementation Challenge Question You are tasked with implementing a sorting algorithm known as Stooge Sort. The algorithm works as follows: 1. If the first element is larger than the last element, swap them. 2. Recursively sort the initial two-thirds of the array. 3. Recursively sort the final two-thirds of the array. 4. Recursively sort the initial two-thirds again to confirm the array is sorted. Write a function `stooge_sort(arr)` that takes a list `arr` of integers and sorts the list in-place using the Stooge Sort algorithm. Function Signature ```python def stooge_sort(arr: List[int]) -> None: ``` Input * `arr` - A list of integers. Constraint: 1 ≤ len(arr) ≤ 10^3 and -10^9 ≤ arr[i] ≤ 10^9. Output * The function should not return anything. It should sort the list `arr` in-place. Examples ```python arr = [2, 4, 5, 3, 1] stooge_sort(arr) print(arr) # Output: [1, 2, 3, 4, 5] arr = [10, -1, 2, 5, 0] stooge_sort(arr) print(arr) # Output: [-1, 0, 2, 5, 10] arr = [3, 3, 3, 3] stooge_sort(arr) print(arr) # Output: [3, 3, 3, 3] ``` Constraints * Your solution should account for edge cases such as arrays of size 1 or 2. * Ensure that your solution handles arrays with negative integers as well as duplicates. * You do not need to worry about in-place modifications causing differences in the reference to the passed arrays in Python.","solution":"from typing import List def stooge_sort(arr: List[int], l: int = 0, h: int = None) -> None: if h is None: h = len(arr) - 1 if l >= h: return # Step 1: If the first element is larger than the last element, swap them. if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # Step 2: Recursively sort the initial two-thirds of the array. if h - l + 1 > 2: k = (h - l + 1) // 3 stooge_sort(arr, l, h - k) stooge_sort(arr, l + k, h) stooge_sort(arr, l, h - k)"},{"question":"Implement a MinStack *MinStack* is a stack that supports push, pop, top operations, and retrieving the minimum element in constant time. Requirements 1. Implement the `MinStack` class: - `__init__()`: Initializes the object. - `push(val: int)`: Pushes the element `val` onto the stack. - `pop()`: Removes the element on the top of the stack. - `top() -> int`: Gets the top element of the stack. - `get_min() -> int`: Retrieves the minimum element in the stack. 2. All operations (`push`, `pop`, `top`, `get_min`) must be performed in constant time O(1). 3. Performance Requirements: Your solution must handle a sequences of operations efficiently, even for large number of operations. Constraints: - Inputs: integer values only (`-10^5 <= val <= 10^5`) - There will be at least one element in the stack when `top` and `get_min` operations are called. # Example: ```plaintext minStack = MinStack() minStack.push(-2) minStack.push(0) minStack.push(-3) assert minStack.get_min() == -3 # Returns -3 minStack.pop() assert minStack.top() == 0 # Returns 0 assert minStack.get_min() == -2 # Returns -2 ```","solution":"class MinStack: def __init__(self): self.stack = [] self.min_stack = [] def push(self, val: int): self.stack.append(val) if not self.min_stack or val <= self.min_stack[-1]: self.min_stack.append(val) def pop(self): if self.stack: if self.stack[-1] == self.min_stack[-1]: self.min_stack.pop() self.stack.pop() def top(self) -> int: if self.stack: return self.stack[-1] def get_min(self) -> int: if self.min_stack: return self.min_stack[-1]"},{"question":"# Markov Chain Simulation Consider a simple website that recommends articles to users based on the article they are currently reading. The recommendation system uses a Markov Chain to predict and recommend the next article. A Markov Chain is represented as a dictionary where each key represents a current state (current article) and the value is another dictionary representing possible next states (articles) with their transition probabilities. Implement a function `recommend_next_article` that takes two inputs: 1. `chain`: A dictionary representing the Markov chain where each key-value pair is a current state and the possible next states with their probabilities. 2. `current_article`: A string representing the current article being read. The function should return a string representing the next article to recommend. # Input: * `chain`: A dictionary with the structure: ```python { \'Article1\': {\'Article2\': 0.6, \'Article3\': 0.4}, \'Article2\': {\'Article1\': 0.3, \'Article3\': 0.7}, ... } ``` * `current_article`: A string representing the current article. # Output: * A string representing the next article to recommend, based on the given Markov Chain. # Constraints: * All probability values for a state\'s transitions sum to 1. * Each state has at least one possible next state. # Example: ```python chain = { \'A1\': {\'A2\': 0.6, \'A3\': 0.4}, \'A2\': {\'A1\': 0.3, \'A3\': 0.7}, \'A3\': {\'A1\': 0.5, \'A2\': 0.5} } current_article = \'A1\' # Function Call print(recommend_next_article(chain, current_article)) # Possible Output: \'A2\' or \'A3\' based on the probabilities ``` # Task: Implement the `recommend_next_article` function. ```python import random def recommend_next_article(chain, current_article): Given a Markov chain and a current article, randomly choose the next article. :param dict chain: Markov chain dictionary. :param str current_article: Current article. :return: The next article to recommend. :rtype: str def __choose_state(state_map): choice = random.random() probability_reached = 0 for state, probability in state_map.items(): probability_reached += probability if probability_reached > choice: return state return None next_state_map = chain.get(current_article) return __choose_state(next_state_map) ```","solution":"import random def recommend_next_article(chain, current_article): Given a Markov chain and a current article, randomly choose the next article. :param dict chain: Markov chain dictionary. :param str current_article: Current article. :return: The next article to recommend. :rtype: str def __choose_state(state_map): choice = random.random() probability_reached = 0 for state, probability in state_map.items(): probability_reached += probability if probability_reached > choice: return state return None next_state_map = chain.get(current_article) return __choose_state(next_state_map)"},{"question":"# Longest Substring Without Repeating Characters Objective You are required to implement a function to find the length and the content of the longest substring without repeating characters using the sliding window technique, ensuring optimal time and space complexity. Function Signature ```python def longest_unique_substring(input_str: str) -> (int, str): Function to find the length and content of the longest substring without repeating characters. Args: - input_str (str): Input string Returns: - tuple: A tuple containing the length of the longest unique-substring and the substring itself. ``` Constraints * The input string consists of ASCII characters. * Handle edge cases such as: * Empty string input * Single-character input * Input string with all identical characters Example 1. Given `input_str = \\"abcabcbb\\"`, the function should return `(3, \\"abc\\")`. 2. Given `input_str = \\"bbbbb\\"`, the function should return `(1, \\"b\\")`. 3. Given `input_str = \\"pwwkew\\"`, the function should return `(3, \\"wke\\")`. Context You are a part of a software development team responsible for building an editor application. One of the requirements is to include a feature that identifies and marks the longest substring within the text that doesn\'t have any repeating characters. This feature can be particularly useful for identifying unique patterns for further analysis.","solution":"def longest_unique_substring(input_str: str) -> (int, str): Function to find the length and content of the longest substring without repeating characters. Args: - input_str (str): Input string Returns: - tuple: A tuple containing the length of the longest unique-substring and the substring itself. n = len(input_str) if n == 0: return 0, \\"\\" char_index_map = {} max_length = 0 start_index = 0 longest_substring = \\"\\" current_start = 0 for current_end in range(n): char = input_str[current_end] if char in char_index_map and char_index_map[char] >= current_start: current_start = char_index_map[char] + 1 char_index_map[char] = current_end current_length = current_end - current_start + 1 if current_length > max_length: max_length = current_length start_index = current_start longest_substring = input_str[current_start:current_end+1] return max_length, longest_substring"},{"question":"Problem Description Given a pattern and a string, write a function `word_pattern(pattern: str, str: str) -> bool` to determine if the string follows the same pattern. A string follows a pattern if there is a one-to-one correspondence between the characters in the pattern and the words in the string. Each character in the pattern must map to a single word, and each word must map to a single character. Constraints - Both `pattern` and `str` are non-empty. - `pattern` contains only lowercase English letters. - `str` contains lowercase English words separated by a single space. - The number of characters in the pattern should match the number of words in the string. Input Format - `pattern`: A string of lowercase letters, length ( n ). - `str`: A string of lowercase words separated by single spaces, representing a sentence with ( n ) words. Output Format - Return `True` if `str` follows the same pattern as `pattern`. - Otherwise, return `False`. Examples 1. **Input**: `pattern = \\"abba\\"`, `str = \\"dog cat cat dog\\"` **Output**: `True` 2. **Input**: `pattern = \\"abba\\"`, `str = \\"dog cat cat fish\\"` **Output**: `False` 3. **Input**: `pattern = \\"aaaa\\"`, `str = \\"dog dog dog dog\\"` **Output**: `True` 4. **Input**: `pattern = \\"abba\\"`, `str = \\"dog dog dog dog\\"` **Output**: `False` Implementation ```python def word_pattern(pattern, str): dict_chars_to_words = {} set_mapped_words = set() words = str.split() if len(words) != len(pattern): return False for i in range(len(pattern)): char = pattern[i] word = words[i] if char not in dict_chars_to_words: if word in set_mapped_words: return False dict_chars_to_words[char] = word set_mapped_words.add(word) else: if dict_chars_to_words[char] != word: return False return True ```","solution":"def word_pattern(pattern, str): dict_chars_to_words = {} set_mapped_words = set() words = str.split() if len(words) != len(pattern): return False for i in range(len(pattern)): char = pattern[i] word = words[i] if char not in dict_chars_to_words: if word in set_mapped_words: return False dict_chars_to_words[char] = word set_mapped_words.add(word) else: if dict_chars_to_words[char] != word: return False return True"},{"question":"# Polynomial Class: Implement Divison Operation You are given a `Monomial` class that represents single-term algebraic expressions. This class supports operations like addition, subtraction, multiplication, division, and more. Additionally, there is a `Polynomial` class for multi-term algebraic expressions, constructed from multiple instances of `Monomial`. Your task is to complete the division operation (`__truediv__`) for the `Polynomial` class, allowing for the division of one polynomial by another or a monomial. # Requirements 1. **Function Definition**: Implement the `__truediv__` method within the provided `Polynomial` class. 2. **Input Format**: Division could involve: - An integer, float, fraction. - A `Monomial` Object. - A `Polynomial` Object. 3. **Output**: Should be of type `Polynomial`. # Constraints - Division by zero should raise an appropriate error. - Only division by a monomial or polynomial containing a single monomial is allowed. - Precision in floating points might be a constraint in some cases. # Example Given two polynomials: `Polynomial_A` and `Polynomial_B`: ```python Polynomial_A = Polynomial([ Monomial({1: 1}, 4), # 4a_1 Monomial({2: 3}, -3) # -3(a_2)^3 ]) Polynomial_B = Polynomial([ Monomial({1: 1}, 2) # 2a_1 ]) result = Polynomial_A / Polynomial_B ``` Your implementation should return a new `Polynomial` Object that is the quotient of the division. # Assessment Criteria - Correctness: Implementation should correctly handle variable operations, including edge cases. - Efficiency: Optimal performance for polynomials with multiple monomials. - Robustness: Proper handling of exceptions and special cases such as division by zero.","solution":"class Monomial: def __init__(self, variables, coefficient): # Assume variables is a dictionary like {var_index: exponent, ...} self.variables = variables self.coefficient = coefficient def __truediv__(self, other): if isinstance(other, (int, float)): if other == 0: raise ZeroDivisionError(\\"division by zero\\") new_coefficient = self.coefficient / other return Monomial(self.variables, new_coefficient) elif isinstance(other, Monomial): # Divide coefficients if other.coefficient == 0: raise ZeroDivisionError(\\"division by zero\\") new_coefficient = self.coefficient / other.coefficient # Subtract exponents new_variables = self.variables.copy() for var, exponent in other.variables.items(): if var in new_variables: new_variables[var] -= exponent if new_variables[var] == 0: del new_variables[var] else: new_variables[var] = -exponent return Monomial(new_variables, new_coefficient) else: raise ValueError(\\"Unsupported division type\\") class Polynomial: def __init__(self, monomials): self.monomials = monomials def __truediv__(self, other): if isinstance(other, (int, float)): if other == 0: raise ZeroDivisionError(\\"division by zero\\") new_monomials = [monomial / other for monomial in self.monomials] return Polynomial(new_monomials) elif isinstance(other, Monomial): new_monomials = [monomial / other for monomial in self.monomials] return Polynomial(new_monomials) elif isinstance(other, Polynomial): if len(other.monomials) == 1: divisor = other.monomials[0] new_monomials = [monomial / divisor for monomial in self.monomials] return Polynomial(new_monomials) else: raise ValueError(\\"Polynomial division supported only with single-term polynomials\\") else: raise ValueError(\\"Unsupported division type\\")"},{"question":"**Objective**: Given an integer array `arr` of size `n`, you\'ll implement a Fenwick Tree (also known as a Binary Indexed Tree, or BIT) to efficiently handle the following queries: 1. `update(index, value)`: Update the element at index `index` in the array to `value`. 2. `prefix_sum(index)`: Compute the sum of elements from the beginning of the array to the given index. Implement a class `FenwickTree` with the following methods: * **`__init__(self, arr: List[int]) -> None`**: Initialize the Fenwick Tree with the provided array `arr`. * **`update(self, index: int, value: int) -> None`**: Update the element at `index` to `value`. * **`prefix_sum(self, index: int) -> int`**: Return the sum of elements from the beginning of the array to the given `index`. # Input and Output Formats * **Initialization**: * Input: `arr`, a list of integers representing the initial elements of the array. * **update(index, value)**: * Input: * `index`: An integer representing the 0-based index of the array element to update. * `value`: The new value for the element at the specified index. * **prefix_sum(index)**: * Input: `index`, an integer representing the 0-based index up to which the prefix sum should be computed. * Output: An integer representing the sum of elements from the start of the array up to the specified `index`. # Constraints * The length of the array, `n`, will be between `1` and `10^5`. * Each element in the array will be an integer between `-10^4` and `10^4`. * The total number of operations (updates and queries) will not exceed `10^6`. # Example ```python arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(arr) # Initial sum from the beginning to index 5 print(fenwick_tree.prefix_sum(5)) # Output: 19 # Update the element at index 3 to 7 fenwick_tree.update(3, 7) # Sum from the beginning to index 5 after update print(fenwick_tree.prefix_sum(5)) # Output: 20 # Update the element at index 7 to 1 fenwick_tree.update(7, 1) # Sum from the beginning to index 8 after update print(fenwick_tree.prefix_sum(8)) # Output: 22 ``` # Notes * Each method should adhere to the constraints to ensure efficient handling of updates and queries. * Proper error handling should be implemented for indexes beyond the bounds of the array.","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]) -> None: Initialize the Fenwick Tree with the provided array arr. self.n = len(arr) self.tree = [0] * (self.n + 1) self.arr = arr[:] for i, value in enumerate(arr): self._add(i + 1, value) def _add(self, index: int, value: int) -> None: Internal method to update the Fenwick Tree for a specific index with a value. while index <= self.n: self.tree[index] += value index += index & -index def update(self, index: int, value: int) -> None: Update the element at index in the array to value. if index < 0 or index >= self.n: raise IndexError(\\"Index out of bounds\\") current_value = self.arr[index] delta = value - current_value self.arr[index] = value self._add(index + 1, delta) def prefix_sum(self, index: int) -> int: Return the sum of elements from the beginning of the array to the given index. if index < 0 or index >= self.n: raise IndexError(\\"Index out of bounds\\") result = 0 index += 1 # Move to 1-based index for the calculation while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Single-Source Shortest Path Problem Scenario: A delivery service company is planning to optimize its delivery routes. The company’s delivery areas are represented as vertices, and the roads between them with certain travel times are represented as weighted edges. The company needs a solution to calculate the shortest travel time from their main office to all other delivery areas. Task: Implement a function `shortest_delivery_time(vertices: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]` that computes the shortest delivery time from the source vertex to all other vertices using Dijkstra\'s algorithm. Function Signature: ```python def shortest_delivery_time(vertices: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: pass ``` Input: - `vertices`: An integer `V`, the number of vertices in the graph. - `edges`: A list of tuples, where each tuple `(u, v, w)` represents an edge from vertex `u` to vertex `v` with weight `w`. - `src`: An integer representing the source vertex. Output: - A list of integers where the `i-th` element represents the shortest travel time from the source vertex to the `i-th` vertex. Constraints: - `1 <= vertices <= 200` - `1 <= len(edges) <= 10^4` - `0 <= src < vertices` - Edges will have non-negative weights. Example: ```python assert shortest_delivery_time(5, [(0, 1, 10), (1, 2, 20), (2, 3, 30), (3, 4, 40), (0, 4, 100)], 0) == [0, 10, 30, 60, 100] ``` Requirements: - Implement the Dijkstra\'s algorithm considering performance and efficiency. - Handle scenarios where some vertices might not be reachable from the source vertex, and return `float(\'inf\')` or a large value for unreachable vertices.","solution":"import heapq from typing import List, Tuple def shortest_delivery_time(vertices: int, edges: List[Tuple[int, int, int]], src: int) -> List[int]: Computes the shortest travel time from the source vertex to all other vertices using Dijkstra\'s algorithm. :param vertices: Number of vertices in the graph. :param edges: List of tuples where each tuple (u, v, w) represents an edge from vertex u to vertex v with weight w. :param src: Source vertex. :return: A list of integers where the i-th element represents the shortest travel time from the source vertex to the i-th vertex. # Create the adjacency list for the graph graph = {i: [] for i in range(vertices)} for u, v, w in edges: graph[u].append((v, w)) # Initialize the distances to all vertices as infinity distances = [float(\'inf\')] * vertices distances[src] = 0 # Use a priority queue to store (distance, vertex) tuples pq = [(0, src)] while pq: current_distance, current_vertex = heapq.heappop(pq) # If we find a greater distance in the priority queue, we skip processing it if current_distance > distances[current_vertex]: continue # Process all adjacent vertices for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"You are given two matrices represented as 2D lists of integers, and your task is to implement a function `multiply_matrices` to compute their product. Ensure that the matrices are compatible for multiplication before proceeding. If the matrices are not compatible, your function should raise an exception. # Function Signature ```python def multiply_matrices(multiplicand: list, multiplier: list) -> list: pass ``` # Input * **multiplicand** (`list[list[int]]`): The first matrix to be multiplied. * **multiplier** (`list[list[int]]`): The second matrix to be multiplied. # Output * A 2D list (`list[list[int]]`) that represents the product of the input matrices. # Constraints * All `N` and `M` values where number of rows and columns of matrices are between `1` and `100`. * The elements of the matrices are integers that can be both positive and negative and fit within 32-bit signed integer range. # Performance Requirements * Ensure your implementation is efficient within the bounds of the given constraints. # Example ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [2, 0], [1, 2] ] print(multiply_matrices(multiplicand, multiplier)) # Output: [[4, 4], [10, 8]] ``` # Edge Cases * Handle cases where the matrices are empty or incompatible by raising an appropriate exception. * Verify handling of matrices with negative values. # Scenario You are developing a module for a linear algebra system that requires the capability to multiply matrices. Your function will be integrated into a larger system used in various algebraic computations and simulations. It must handle matrices of varied sizes efficiently and be robust against invalid input configurations.","solution":"def multiply_matrices(multiplicand: list, multiplier: list) -> list: Multiplies two matrices if they are compatible. Args: multiplicand (list[list[int]]): The first matrix. multiplier (list[list[int]]): The second matrix. Returns: list[list[int]]: The product of the two matrices. Raises: ValueError: If the matrices are incompatible for multiplication. # Check if the matrices are compatible for multiplication if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Matrices are not compatible for multiplication\\") # Initializing the product matrix with zeros result = [[0 for _ in range(len(multiplier[0]))] for _ in range(len(multiplicand))] # Multiplying the matrices for i in range(len(multiplicand)): for j in range(len(multiplier[0])): for k in range(len(multiplicand[0])): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"**Scenario**: You are working on an e-commerce platform and need to implement a product review sorting feature. The reviews are stored in an array based on their initial input times, but you want to sort them based on their rating in ascending order to enhance user experience. Given the nature of the data (frequent, small batches of reviews), you decide to use insertion sort for its simplicity and suitability for small datasets. Your task is to implement the sorting function and validate that it works correctly. # Requirement: Implement a function to sort an array of integers using insertion sort. Your implementation should simulate the sorting process step-by-step, with an option to print each iteration\'s state for debugging. # Function Signature: ```python def sort_reviews(reviews: List[int], simulation: bool) -> List[int]: Sorts the input list of reviews (integers) using insertion sort. Parameters: reviews (List[int]): The input list of review ratings to be sorted. simulation (bool): If True, print the array\'s state after each iteration of the outer loop. Returns: List[int]: The sorted list of review ratings. pass ``` # Input: - `reviews`: A list of integers representing review ratings, where 1 <= len(reviews) <= 1000. - `simulation`: A boolean flag indicating whether to print the array\'s state at each iteration. # Output: - A list of integers representing the sorted review ratings in ascending order. # Constraints: - Do not use built-in sorting functions. - The array may contain duplicate ratings. - Optimize for readability without compromising performance. # Example: ```python # Example 1: ratings = [4, 2, 5, 3, 1] simulation = True print(sort_reviews(ratings, simulation)) # Output should include printed steps of the array\'s state and the final sorted list: # iteration 0: 4 2 5 3 1 # iteration 1: 2 4 5 3 1 # iteration 2: 2 4 5 3 1 # iteration 3: 2 3 4 5 1 # iteration 4: 1 2 3 4 5 # Example 2: ratings = [10, 8, 10, 7, 8] simulation = False print(sort_reviews(ratings, simulation)) # Output: [7, 8, 8, 10, 10] ``` # Notes: - Ensure your function correctly handles the iteration and the internal state of the list. - Focus on maintaining clarity and correctness in your implementation. - Test your function rigorously against various edge cases and input sizes.","solution":"from typing import List def sort_reviews(reviews: List[int], simulation: bool) -> List[int]: Sorts the input list of reviews (integers) using insertion sort. Parameters: reviews (List[int]): The input list of review ratings to be sorted. simulation (bool): If True, print the array\'s state after each iteration of the outer loop. Returns: List[int]: The sorted list of review ratings. for i in range(1, len(reviews)): key = reviews[i] j = i - 1 while j >= 0 and key < reviews[j]: reviews[j + 1] = reviews[j] j -= 1 reviews[j + 1] = key if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, reviews))}\\") return reviews"},{"question":"# Matrix Chain Multiplication You are given a sequence of matrices, and you need to find the most efficient way to compute the product of these matrices. Compute the minimum number of scalar multiplications needed and the optimal order of multiplications using Dynamic Programming. # Instructions 1. Implement the function `matrix_chain_order(array)` to determine the minimum number of scalar multiplications needed and the optimal order of operations. 2. Implement the function `print_optimal_solution(optimal_solution, i, j)` to print the optimal multiplication order. 3. Provide a main function to test your implementation with a sample array. # Function Definitions 1. **Function**: `matrix_chain_order(array)` * **Input**: A list `array` of length n representing the chain of dimensions of the matrices (if the i-th matrix has dimensions array[i-1] x array[i]). * **Output**: Two 2D arrays representing the costs and splits for optimal matrix chain multiplication. 2. **Function**: `print_optimal_solution(optimal_solution, i, j)` * **Input**: A 2D array `optimal_solution` containing split points, and indices `i` and `j`. * **Output**: Prints the optimal parenthesization of the matrix chain. # Constraints - You may assume all input integers are positive. - The length of the array will be between 2 and 20 inclusive. # Example Suppose you have an input array: `[30, 35, 15, 5, 10, 20, 25]`. Your program should compute: - Minimum number of operations: `15125` - Optimal multiplication order: ((A1 (A2 A3)) ((A4 A5) A6)) ```python def matrix_chain_order(array): # Your implementation goes here def print_optimal_solution(optimal_solution, i, j): # Your implementation goes here def main(): array = [30, 35, 15, 5, 10, 20, 25] matrix, optimal_solution = matrix_chain_order(array) print(\\"Minimum number of operations required: \\" + str(matrix[1][len(array) - 1])) print(\\"Optimal multiplication order: \\", end=\\"\\") print_optimal_solution(optimal_solution, 1, len(array) - 1) print() if __name__ == \'__main__\': main() ```","solution":"def matrix_chain_order(p): n = len(p) - 1 m = [[0 for x in range(n+1)] for y in range(n+1)] s = [[0 for x in range(n+1)] for y in range(n+1)] for l in range(2, n+1): for i in range(1, n-l+2): j = i+l-1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j] if q < m[i][j]: m[i][j] = q s[i][j] = k return m, s def print_optimal_solution(s, i, j): if i == j: print(f\\"A{i}\\", end=\\"\\") else: print(\\"(\\", end=\\"\\") print_optimal_solution(s, i, s[i][j]) print_optimal_solution(s, s[i][j] + 1, j) print(\\")\\", end=\\"\\") def main(): array = [30, 35, 15, 5, 10, 20, 25] m, s = matrix_chain_order(array) print(\\"Minimum number of operations required: \\" + str(m[1][len(array) - 1])) print(\\"Optimal multiplication order: \\", end=\\"\\") print_optimal_solution(s, 1, len(array) - 1) print() if __name__ == \'__main__\': main()"},{"question":"# Question: Implement Enhanced Jump Search with Adjustable Block Size Context: Jump Search is an efficient algorithm for finding a target value in a sorted array by jumping ahead in fixed-size blocks and performing a linear search within the respective block. In this exercise, you will implement an enhanced version of Jump Search that can dynamically adjust the block size based on the input array length. Task: Write a function `enhanced_jump_search(arr: List[int], target: int) -> int` that performs the following: 1. Adjusts the block size based on the array length, approximating the optimal block size for faster searches. 2. Implements Jump Search to find the index of the `target` in the `arr`. 3. Returns `-1` if the `target` is not found in the `arr`. Input: - `arr`: A list of integers (sorted in ascending order). - `target`: An integer representing the value to search for in `arr`. Output: - Returns the index of the `target` in `arr`. If the `target` is not found, return `-1`. Constraints: - The array `arr` is guaranteed to be sorted in ascending order. - The array length `n` is such that 1 <= n <= 10^6. Examples: ```python assert enhanced_jump_search([1, 3, 5, 7, 9, 11], 7) == 3 assert enhanced_jump_search([1, 3, 5, 7, 9, 11], 10) == -1 assert enhanced_jump_search([10, 20, 30, 40, 50, 60, 70], 10) == 0 assert enhanced_jump_search([2, 4, 6, 8, 10], 10) == 4 assert enhanced_jump_search([1, 2, 3], 4) == -1 ``` Additional Requirements: - Ensure the implementation handles edge cases correctly, including arrays with a single element or when the `target` is the minimum or maximum value. - Optimize the algorithm to work efficiently within the given constraints. **Note**: Do not use Python\'s built-in search functions. Implement the algorithm from scratch.","solution":"import math from typing import List def enhanced_jump_search(arr: List[int], target: int) -> int: Perform an enhanced jump search to find the target value in the sorted array. :param arr: List[int] - A list of sorted integers. :param target: int - The target value to search for in the array. :return: int - Index of the target value if found, else -1. n = len(arr) if n == 0: return -1 # Block size to be jumped step = int(math.sqrt(n)) # Find the block where the element is present (if it is present) prev = 0 while arr[min(step, n)-1] < target: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Perform linear search within the block while prev < min(step, n): if arr[prev] == target: return prev prev += 1 return -1"},{"question":"# Coding Challenge Question: Merging Two Sorted Linked Lists You are given two singly linked lists, where each list is sorted in ascending order. Your task is to merge these two lists into one single sorted linked list and return its head. Both iterative and recursive approaches are provided as reference implementations. You are required to implement a function that merges an arbitrary number of (k) sorted linked lists into one sorted linked list. Function Signature: ```python def merge_k_lists(lists: List[Node]) -> Node: pass ``` Input: - `lists` (List[Node]): A list containing the heads of `k` sorted singly linked lists. Each singly linked list is represented by its first `Node`. Output: - Return the head of the merged singly linked list. Constraints: - The number of linked lists `k` will be between 0 and 10^4. - The total number of nodes across all linked lists will be between 0 and 10^4. - Each linked list is individually sorted in ascending order. Example: ```python Input: [1->4->5, 1->3->4, 2->6] Output: 1->1->2->3->4->4->5->6 ``` Notes: - Ensure that your solution is optimized for both time and space complexity. - Consider possible edge cases, such as empty linked lists or lists of varying lengths.","solution":"from typing import List, Optional class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def merge_k_lists(lists: List[Optional[Node]]) -> Optional[Node]: import heapq ListNode = Node dummy = ListNode() curr = dummy # Min heap to keep track of the smallest elements across all lists heap = [] # Initialize the heap with the first node of each list for i, l in enumerate(lists): if l: heapq.heappush(heap, (l.value, i, l)) while heap: val, i, node = heapq.heappop(heap) curr.next = node curr = curr.next if node.next: heapq.heappush(heap, (node.next.value, i, node.next)) return dummy.next"},{"question":"**Coding Assessment Question:** Recently, I encountered an interview question whose description was as below: The number 89 is the first integer with more than one digit whose digits when raised up to consecutive powers give the same number. For example, 89 = 8**1 + 9**2 gives the number 89. The next number after 89 with this property is 135 = 1**1 + 3**2 + 5**3 = 135. # Task Write a function `sum_dig_pow(start, end)` that returns a list of numbers within a specified range `[start, end]` (inclusive) that match the property described above: **Input:** - `start` (integer): The starting point of the range. - `end` (integer): The ending point of the range. Example function signature in Python: ```python def sum_dig_pow(start, end): # Your implementation here ``` **Output:** - A list of integers that match the described property within the range. **Constraints:** * `1 <= start <= end <= 10^6` **Performance Requirements:** * Optimize the function to handle large ranges efficiently. # Example: ```python print(sum_dig_pow(1, 10)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9] print(sum_dig_pow(1, 100)) # Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 89] ``` # Considerations: * Focus on efficiency for large ranges. * Ensure the handling of edge cases such as single-digit numbers. * Document any assumptions and test your function with diverse input cases.","solution":"def sum_dig_pow(start, end): def is_eureka_number(n): digits = [int(d) for d in str(n)] return n == sum(d**(i+1) for i, d in enumerate(digits)) return [num for num in range(start, end + 1) if is_eureka_number(num)]"},{"question":"You are given a base `a`, exponent `n`, and optionally a modulus `mod`. Implement an efficient algorithm to compute `a ^ n`. If `mod` is specified, return the result as `a ^ n % mod`. # Input * `a` (integer): The base number (1 <= a <= 10^6) * `n` (integer): The exponent (0 <= n <= 10^9) * `mod` (integer, optional): The modulus (1 <= mod <= 10^9, if provided) # Output * The result of `a` raised to the power `n`. If a modulus is provided, return the result modulo `mod`. # Constraints * Handle both positive and zero exponents. * Time complexity must be O(log(n)). * Space complexity must be O(1) for iterative solution and can be more for recursive. # Example Example 1: Input: `a = 2`, `n = 10`, `mod = None` Output: `1024` Example 2: Input: `a = 2`, `n = 10`, `mod = 1000` Output: `24` Example 3: Input: `a = 10`, `n = 0`, `mod = None` Output: `1` Example 4: Input: `a = 2`, `n = 1`, `mod = None` Output: `2` # Requirements * Implement at least one of the given functions (`power` or `power_recur`) ensuring it handles all edge cases provided. * Make sure the code is optimized for performance. # Notes: * You may find it useful to test edge cases manually, such as very large `n`, minimal `a`, and presence of `mod`.","solution":"def power(a, n, mod=None): Compute a^n efficiently. If mod is provided, compute (a^n) % mod. :param a: int, base :param n: int, exponent :param mod: int or None, modulus :return: int, result of a^n or (a^n) % mod result = 1 base = a % mod if mod else a while n > 0: if n % 2 == 1: # If n is odd result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base n //= 2 return result"},{"question":"# Programming Challenge: Bit Manipulation Toolkit You are tasked with writing a utility function for manipulating bits within an integer. Implement the provided bit manipulation functions to handle fetching, setting, clearing, and updating specific bits. Implement the following functions: 1. `get_bit(num: int, i: int) -> bool`: - **Description**: Fetch the bit at index `i` in the binary representation of `num`. - **Input**: - `num` is an integer. - `i` is the bit index (0-based). - **Output**: Return `True` if the bit at index `i` is set (1), otherwise `False`. 2. `set_bit(num: int, i: int) -> int`: - **Description**: Set the bit at index `i` in `num` to 1. - **Input**: - `num` is an integer. - `i` is the bit index (0-based). - **Output**: Return the new integer value with the bit at index `i` set to 1. 3. `clear_bit(num: int, i: int) -> int`: - **Description**: Clear the bit at index `i` in `num` (set to 0). - **Input**: - `num` is an integer. - `i` is the bit index (0-based). - **Output**: Return the new integer value with the bit at index `i` cleared. 4. `update_bit(num: int, i: int, bit: bool) -> int`: - **Description**: Update the bit at index `i` to the given value (`bit` - True/False). - **Input**: - `num` is an integer. - `i` is the bit index (0-based). - `bit` is the boolean value to set at bit `i`. - **Output**: Return the new integer value with the bit at index `i` updated to `bit`. # Constraints: - `0 <= i < 32` (You can assume a 32-bit integer) - `num` can be a positive or negative integer. - The function should return consistent results regardless of whether `num` is treated as signed or unsigned. # Example: ```python assert get_bit(5, 0) == True # 5 is 101 in binary, bit at index 0 is 1 assert get_bit(5, 1) == False # bit at index 1 is 0 assert set_bit(5, 1) == 7 # set bit at index 1: 101 becomes 111 which is 7 assert clear_bit(5, 0) == 4 # clear bit at index 0: 101 becomes 100 which is 4 assert update_bit(5, 1, True) == 7 # update bit at index 1 to 1: 101 becomes 111 which is 7 assert update_bit(5, 0, False) == 4 # update bit at index 0 to 0: 101 becomes 100 which is 4 ``` Your task is to complete the implementation of these functions to pass the provided example test cases.","solution":"def get_bit(num: int, i: int) -> bool: Fetch the bit at index i in the binary representation of num. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Set the bit at index i in num to 1. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clear the bit at index i in num (set to 0). return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Update the bit at index i to the given value (bit). # Clear the bit at index i num = num & ~(1 << i) # Set the bit at index i to bit return num | ((1 if bit else 0) << i)"},{"question":"# Simulating a Random Walk Using Markov Chain **Context**: You have been hired to develop a predictive text generator, and you need to simulate random walks through the words using a Markov Chain. **Problem Statement**: Given a dictionary representing a Markov Chain, implement the function `simulate_markov_chain(chain, start_state, steps)` that simulates a random walk through the states for a specified number of steps, starting from a given initial state. # Function Signature ```python def simulate_markov_chain(chain: dict, start_state: str, steps: int) -> list: Simulates a random walk through the states of the Markov Chain Parameters: chain (dict): The Markov chain represented as a dictionary. start_state (str): The initial state for the random walk. steps (int): The number of steps in the random walk. Returns: list: List of states representing the random walk. pass ``` # Input * `chain`: A dictionary where keys represent states and values are dictionaries of state transitions with probabilities. * `start_state`: The initial state from which the random walk begins. * `steps`: An integer representing the number of steps in the random walk. # Output * A list of states representing the path taken during the random walk. # Constraints - Each state\'s transition probabilities sum to 1. - The `start_state` exists in the `chain`. - `steps` is a non-negative integer. # Example ```python chain = { \'A\': {\'A\': 0.6, \'B\': 0.4}, \'B\': {\'A\': 0.3, \'B\': 0.7} } print(simulate_markov_chain(chain, \'A\', 5)) # Possible Output: [\'A\', \'B\', \'B\', \'B\', \'A\'] ``` # Instructions 1. Create a function called `simulate_markov_chain`. 2. Use the helper functions `next_state` and `__choose_state` similar to the provided code snippet for selecting the next state. 3. Return the list of states traversed during the random walk. # Considerations * Address edge cases such as when the chain state map is empty or invalid. * Optimize the state selection process to handle larger state spaces efficiently.","solution":"import random def simulate_markov_chain(chain: dict, start_state: str, steps: int) -> list: def __choose_state(state_probs): states = list(state_probs.keys()) probabilities = list(state_probs.values()) return random.choices(states, probabilities)[0] current_state = start_state walk = [current_state] for _ in range(steps): next_state_probs = chain[current_state] next_state = __choose_state(next_state_probs) walk.append(next_state) current_state = next_state return walk"},{"question":"Context Euler\'s Totient Function (ϕ(n)) is used to determine the number of integers between 1 and `n` that are coprime with `n`. Two numbers are coprime if their Greatest Common Divisor (GCD) is 1. This function has significant applications in number theory and cryptography. Problem Statement Write a function `euler_totient_list` that takes an integer `m` and returns a list of the Euler\'s Totient values for every integer from 1 to `m`. The function should make use of the principles of Euler\'s Totient function that you have learned about. Function Signature ```python def euler_totient_list(m: int) -> List[int]: pass ``` Input - `m` (1 <= m <= 10^5): An integer. Output - A list of integers where the i-th element (0-indexed) represents ϕ(i+1). # Constraints - Assume `m` will be a positive integer. - The function should execute within a reasonable time frame for the upper limit. # Example ```python euler_totient_list(5) # Output: [1, 1, 2, 2, 4] # Explanation: # ϕ(1) = 1 (only 1 itself is coprime) # ϕ(2) = 1 (only 1 is coprime with 2) # ϕ(3) = 2 (1 and 2 are coprime with 3) # ϕ(4) = 2 (1 and 3 are coprime with 4) # ϕ(5) = 4 (1, 2, 3, and 4 are coprime with 5) ``` Notes - Focus on implementing the function efficiently. - Avoid recalculating the Euler\'s Totient values redundantly.","solution":"from typing import List def euler_totient_list(m: int) -> List[int]: phi = list(range(m + 1)) for i in range(2, m + 1): if phi[i] == i: # i is a prime for j in range(i, m + 1, i): phi[j] = phi[j] * (i - 1) // i return phi[1:]"},{"question":"# Scenario: You are developing a system to check and correct data transmission errors. One part of this system is to ensure that two data packets (represented by integers) match, and if they do not, determine the number of bit positions where they differ. This will help in understanding the minimal number of bit flips required to correct the packet. # Task: Write a function `count_flips_to_convert(a: int, b: int) -> int` that calculates the number of bit flips required to convert integer `a` to integer `b`. # Input: - Two integers `a` and `b` (0 <= a, b <= 2^31 - 1). # Output: - An integer representing the number of bits that need to be flipped to convert `a` to `b`. # Constraints: - The input integers are non-negative. - The integers are within the 32-bit signed integer range. # Example: ```python assert count_flips_to_convert(29, 15) == 2 # 11101 to 01111, flips needed: 2 assert count_flips_to_convert(0, 15) == 4 # 00000 to 01111, flips needed: 4 assert count_flips_to_convert(8, 8) == 0 # 01000 to 01000, flips needed: 0 ``` # Function Signature: ```python def count_flips_to_convert(a: int, b: int) -> int: # Your code here pass ```","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bit flips required to convert integer a to integer b. # XOR operation between a and b will give us a number where each bit is 1 if the bits of a and b differ at that position xor = a ^ b # Count the number of 1s in the binary representation of xor, which indicates the number of differing bits count = bin(xor).count(\'1\') return count"},{"question":"# Tree Structure Printer You are provided with a nested dictionary structure representing a tree, where each key has a list of sub-elements. Write a function `tree_print(tree: dict) -> None` that performs a depth-first traversal on this tree and prints out each key followed by its sub-elements. The printing should follow these rules: 1. Each key should be printed on a new line, followed by its sub-elements on the same line, separated by arrows (`->`). 2. If a sub-element is not a string (i.e., it is an integer, indicating a leaf node), the printing should continue on a new line with an extra space indentation. Input format: - A dictionary, where keys are strings and values are lists of mixed types (strings for nested keys, integers for leaf nodes). Output format: - Printing of the tree structure as described above. Example: Given the tree: ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } ``` The output should be: ```plaintext a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Constraints: - Assume keys and sub-elements are meaningful strings and integers only. - The tree is acyclic. **Function Signature**: ```python def tree_print(tree: dict) -> None: # Your code here ```","solution":"def tree_print(tree: dict) -> None: def print_tree(key, elements, indent=\\"\\"): print(indent + key, end=\\"\\") for element in elements: if isinstance(element, (str, int)): print(f\\" -> {element}\\", end=\\"\\") print() # Newline after finishing this key\'s elements for key, elements in tree.items(): print_tree(key, elements, \\"\\") # Example usage: tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } tree_print(tree)"},{"question":"**Problem Statement**: You are given a text and a word (pattern) that you need to locate within the text. Write a function `find_pattern(word: str, text: str) -> int` that implements the Rabin Karp algorithm to find the starting index of the first occurrence of the word in the text. If the word is not found, return -1. The function should handle large input sizes efficiently. **Function Signature**: ```python def find_pattern(word: str, text: str) -> int: ``` # Input: * `word` (str): A string containing the word (pattern) to search for. (1 <= len(word) <= 10^5) * `text` (str): A string containing the text to search within. (1 <= len(text) <= 10^7) # Output: * (int): The starting index of the word in the text. If the word is not found, return -1. # Constraints: * The input strings consist of only lowercase English letters (\'a\' - \'z\'). # Example: ```python find_pattern(\\"test\\", \\"this is a test text\\") -> 10 find_pattern(\\"abc\\", \\"abcdef\\") -> 0 find_pattern(\\"xyz\\", \\"abcdef\\") -> -1 find_pattern(\\"a\\", \\"\\") -> -1 ``` # Requirements: 1. Implement the rolling hash technique for substring comparison. 2. Ensure constant time hash recalculations when the window slides. 3. Perform validation when hash values match to confirm the equality of substrings. 4. The solution should be optimized to handle large texts efficiently without exceeding memory limits.","solution":"def find_pattern(word: str, text: str) -> int: Finds the starting index of the word in the text using the Rabin-Karp algorithm. If the word is not found, returns -1. if not word or not text or len(word) > len(text): return -1 # Define the base and modulus for hashing base = 256 modulus = 101 m = len(word) n = len(text) # Compute the hash value of the word (pattern) and first \'m\' characters of text word_hash = 0 text_hash = 0 h = 1 # The value of h would be \\"pow(base, m-1) % modulus\\" for i in range(m-1): h = (h * base) % modulus # Initial hash values for i in range(m): word_hash = (base * word_hash + ord(word[i])) % modulus text_hash = (base * text_hash + ord(text[i])) % modulus # Slide the pattern over text one by one for i in range(n - m + 1): # Check the hash values of current substring of text and word if word_hash == text_hash: # Check characters one by one if text[i:i+m] == word: return i # Compute the hash value for the next window of text: if i < n - m: text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % modulus # Convert negative value of text_hash to positive if text_hash < 0: text_hash += modulus return -1"},{"question":"You are working for a software company that manages an online compiler, and you need to implement a feature to track the nested structure of code blocks for several programming languages. This requires implementing a checker to validate whether every block of code (e.g., `{}` braces in C-like languages) is properly closed according to the Last-In-First-Out (LIFO) order. # Requirements Your task is to implement a function `is_valid_code_blocks(code: str) -> bool`. This function checks whether a given string representing code has balanced braces `{}` using a stack. The string may contain other characters, but you only need to focus on the `{` and `}` braces. # Input - A string, `code` (1 ≤ len(code) ≤ 10^6), which contains the text of the code. # Output - Return a boolean value `True` if the code blocks are balanced, otherwise `False`. # Constraints - You must use a stack to validate the code blocks. - Handle the edge cases: - The code is completely balanced. - The code has excess `{` or `}`. - The code is empty or has no `{}` braces. - Consider potential performance implications given the input size. # Examples ```python print(is_valid_code_blocks(\\"if (a > b) { return a; } else { return b; }\\")) # Expected: True print(is_valid_code_blocks(\\"function() { if (x) { do_something(); }}\\")) # Expected: True print(is_valid_code_blocks(\\"{ int x; if (y) { perform_action(); \\")) # Expected: False ``` # Tips Use the `ArrayStack` or `LinkedListStack` provided in the earlier code snippets. Select the one you believe fits best and implement the required logic to solve the above problem.","solution":"def is_valid_code_blocks(code: str) -> bool: This function checks whether a given string representing code has balanced braces \'{}\' using a stack. :param code: A string representing the code to be validated. :return: A boolean value indicating whether the code blocks are balanced. stack = [] for char in code: if char == \'{\': stack.append(char) elif char == \'}\': if not stack: return False stack.pop() return not stack"},{"question":"# Scenario You are designing a new social media platform and need to implement a user management system. This system will record user data in a hash table for quick lookups and modifications. However, due to the potential high volume of users, you need to ensure the system efficiently resizes and handles collisions. # Task Implement a `UserManager` class that uses a resizable hash table to store user information. The class should offer functionality to add, retrieve, update, and delete users efficiently. # Requirements 1. **Resizing**: The hash table should automatically resize itself to maintain performance. Specifically, it should double its size once it reaches 2/3 capacity. 2. **Collision Handling**: Use linear probing to handle collisions. 3. **Operations**: - `add_user(user_id, user_data)`: Insert a user_id with associated user_data. If the user_id already exists, update the user_data. - `get_user(user_id)`: Retrieve the user_data associated with the user_id. Return None if the user_id doesn\'t exist. - `delete_user(user_id)`: Delete the user entry associated with the user_id. - Implement magic methods if necessary for ease of use. # Input and Output Format * `add_user` accepts an integer user_id and a string user_data. * `get_user` and `delete_user` accept an integer user_id. * The hash table should have a minimum initial size of 8. # Constraints * Assume user_id is a non-negative integer. * Assume user_data is a string with maximum length 100. # Performance Requirements * Achieve O(1) average-case time complexity for add, get, and delete operations under standard load conditions. # Implementation Skeleton ```python class UserManager: def __init__(self, initial_size=8): # Your initialization code here def add_user(self, user_id, user_data): # Your code here def get_user(self, user_id): # Your code here def delete_user(self, user_id): # Your code here # Add any other methods you need # Example Usage: user_manager = UserManager() user_manager.add_user(123, \\"John Doe\\") print(user_manager.get_user(123)) # Output should be \\"John Doe\\" user_manager.delete_user(123) print(user_manager.get_user(123)) # Output should be None ```","solution":"class UserManager: def __init__(self, initial_size=8): self.size = initial_size self.count = 0 self.table = [None] * self.size def _hash(self, user_id): return user_id % self.size def _resize(self): old_table = self.table self.size *= 2 self.count = 0 self.table = [None] * self.size for item in old_table: if item is not None: user_id, user_data = item self.add_user(user_id, user_data) def add_user(self, user_id, user_data): if self.count >= (2 * self.size) // 3: self._resize() idx = self._hash(user_id) while self.table[idx] is not None and self.table[idx][0] != user_id: idx = (idx + 1) % self.size if self.table[idx] is None: self.count += 1 self.table[idx] = (user_id, user_data) def get_user(self, user_id): idx = self._hash(user_id) start_idx = idx while self.table[idx] is not None: if self.table[idx][0] == user_id: return self.table[idx][1] idx = (idx + 1) % self.size if idx == start_idx: break return None def delete_user(self, user_id): idx = self._hash(user_id) start_idx = idx while self.table[idx] is not None: if self.table[idx][0] == user_id: self.table[idx] = None self.count -= 1 self._rehash(idx) return idx = (idx + 1) % self.size if idx == start_idx: break def _rehash(self, start_idx): idx = (start_idx + 1) % self.size while self.table[idx] is not None: user_id, user_data = self.table[idx] self.table[idx] = None self.count -= 1 self.add_user(user_id, user_data) idx = (idx + 1) % self.size"},{"question":"You are required to sort an array of integers that represents colors in the order of red, white, and blue. Here, the integers 0, 1, and 2 are used to denote the colors red, white, and blue respectively. The function should not use any library sorting functions and must sort the array in place. Function Signature: ```python def sort_colors(nums: List[int]) -> None: pass ``` Input: - `nums`: A list of integers where each integer is either 0, 1, or 2. Output: - The function should modify the list in-place to sort it in the order of red, white, and blue. Constraints: - The length of the array can be at least 1 and at most 10^5. - The elements of the array will consist of only 0, 1, and 2. Performance Requirements: - The algorithm must run in O(n) time complexity. - The algorithm must have O(1) space complexity. Example: ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` Context: This problem simulates classification sorting which is commonly used in various scenarios such as sorting data by categories or labels in linear time. This particular problem captures the efficiency of algorithms when dealing with fixed, known categories.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts an array of integers representing colors in the order of red, white, and blue. The integers 0, 1, and 2 are used to denote the colors red, white, and blue respectively. The function modifies the array in place. # Three pointers low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: # nums[mid] == 2 nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Matrix Multiplication Challenge You are given two 2-dimensional matrices represented as lists of lists. Your task is to implement a function to multiply these matrices if they are compatible. The resulting matrix should be returned as a list of lists. # Function Signature ```python def multiply(multiplicand: list, multiplier: list) -> list: :param multiplicand: List[List[int]]: The first matrix to be multiplied. :param multiplier: List[List[int]]: The second matrix to be multiplied. :return: List[List[int]]: Resulting matrix after multiplication. ``` # Input * `multiplicand`: A list of lists of integers representing the first matrix. * `multiplier`: A list of lists of integers representing the second matrix. # Output * Returns a list of lists of integers representing the product matrix. # Constraints * All rows in each matrix have the same length. * 1 <= len(multiplicand), len(multiplier) <= 100 * -10^9 <= element in any matrix <= 10^9 # Performance Requirement * The solution should handle up to 100x100 matrices efficiently. # Scenario A common task in many scientific calculations and computer graphics involves matrix manipulation. In this scenario, you are creating a basic yet precise implementation to multiply matrices together, ensuring that your function handles edge cases like dimension mismatches gracefully. # Example ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] # The expected output is: # [ # [58, 64], # [139, 154] # ] result = multiply(multiplicand, multiplier) print(result) # Output: [[58, 64], [139, 154]] ``` # Additional Notes * Your function should raise an exception if the matrices are not compatible for multiplication. * Ensure edge cases, such as zero matrices or non-numeric elements, are correctly managed, focusing on valid input constraints.","solution":"def multiply(multiplicand: list, multiplier: list) -> list: Multiplies two matrices if they are compatible and returns the resulting matrix. :param multiplicand: List[List[int]]: The first matrix to be multiplied. :param multiplier: List[List[int]]: The second matrix to be multiplied. :return: List[List[int]]: Resulting matrix after multiplication. # Check matrix dimensions if len(multiplicand[0]) != len(multiplier): raise ValueError(\\"Matrices are not compatible for multiplication\\") num_rows_multiplicand = len(multiplicand) num_cols_multiplier = len(multiplier[0]) num_cols_multiplicand = len(multiplicand[0]) # Initialize the result matrix with zeros result = [[0 for _ in range(num_cols_multiplier)] for _ in range(num_rows_multiplicand)] # Perform matrix multiplication for i in range(num_rows_multiplicand): for j in range(num_cols_multiplier): for k in range(num_cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# RSA Encryption Algorithm: Key Generation, Encryption, and Decryption **Problem Statement** You are to implement the RSA encryption algorithm for secure data transmission. The implementation should cover: 1. **Key Generation**: Generate the public and private keys. 2. **Encryption**: Encrypt the given plaintext using the public key. 3. **Decryption**: Decrypt the given ciphertext using the private key. Your solution should handle key generation for a 16-bit modulus (n) and be able to encrypt and decrypt an integer value correctly. **Function Specifications** 1. `generate_key(k, seed=None)`: Generate the RSA keys. - **Input**: Integer (k) representing the number of bits in (n). An optional `seed` for reproducibility. - **Output**: Tuple ((n, e, d)) where (n) is the modulus, (e) is the encryption exponent, and (d) is the decryption exponent. 2. `encrypt(data, e, n)`: Encrypt the data using the public key. - **Input**: * `data` - Integer to be encrypted. * `e` - Encryption exponent from the public key. * `n` - Modulus from the public key. - **Output**: Encrypted integer. 3. `decrypt(data, d, n)`: Decrypt the data using the private key. - **Input**: * `data` - Encrypted integer to be decrypted. * `d` - Decryption exponent from the private key. * `n` - Modulus from the key. - **Output**: Decrypted integer. **Constraints** * (k geq 16) * The encryption and decryption process should successfully retrieve the original integer value. * The implemented solution must handle large integer values effectively within the limits of Python\'s integer type. **Example** ```python n, e, d = generate_key(16) data = 123 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Write your implementation as specified above, ensuring that the given assertions are met. **Extra Credit** For a deeper challenge, try optimizing the primality test used in key generation to speed up the process for larger values of (k).","solution":"import random from sympy import isprime, mod_inverse def generate_key(k, seed=None): if seed is not None: random.seed(seed) if k < 16: raise ValueError(\\"k must be at least 16 bits\\") # Generate two distinct prime numbers p and q def generate_prime(bits): while True: number = random.getrandbits(bits) if isprime(number): return number p = generate_prime(k//2) q = generate_prime(k//2) while p == q: q = generate_prime(k//2) n = p * q phi = (p - 1) * (q - 1) # Select e such that 1 < e < phi(n) and gcd(e, phi(n)) = 1 def find_e(phi): e = 3 while True: if e < phi and gcd(e, phi) == 1: return e e += 2 def gcd(a, b): while b != 0: a, b = b, a % b return a e = find_e(phi) d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# DFA Validator You have been hired to create a DFA (Deterministic Finite Automaton) validator that processes strings and decides if they are accepted by the DFA or not. **Problem**: Write a function `dfa_validator(transitions, start, final, string)` that determines whether a given string is accepted by the DFA defined by the provided transition table, starting state, and set of final states. Input: * `transitions`: A dictionary where keys are state names and values are dictionaries mapping input characters to the next state. * For example: `{\'q0\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q1\': {\'a\': \'q1\', \'b\': \'q3\'}, \'q2\': {\'a\': \'q2\', \'b\': \'q3\'}, \'q3\': {\'a\': \'q3\', \'b\': \'q3\'}}` * `start`: The starting state of the DFA (string). * For example: `\'q0\'` * `final`: A list of final (accepting) states. * For example: `[\'q3\']` * `string`: A string of characters to be validated by the DFA. * For example: `\'abba\'` Output: * Return `True` if the input string is accepted by the DFA, otherwise `False`. Constraints: * The DFA will have at most 1000 states. * The input string will have a maximum length of 10,000 characters. * The alphabet (set of input characters) consists only of lowercase English letters. Example: ```python transitions = {\'q0\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q1\': {\'a\': \'q1\', \'b\': \'q3\'}, \'q2\': {\'a\': \'q2\', \'b\': \'q3\'}, \'q3\': {\'a\': \'q3\', \'b\': \'q3\'}} start = \'q0\' final = [\'q3\'] string = \'abba\' result = dfa_validator(transitions, start, final, string) print(result) # Expected output: True ``` <sub>Note: The provided example and transition table define a DFA which accepts the string `\'abba\'`, landing in the final state `q3`.</sub>","solution":"def dfa_validator(transitions, start, final, string): Determines whether a given string is accepted by the DFA defined by the transition table. Args: transitions: A dictionary where keys are state names and values are dictionaries mapping input characters to the next state. start: The starting state of the DFA (string). final: A list of final (accepting) states. string: A string of characters to be validated by the DFA. Returns: True if the input string is accepted by the DFA, otherwise False. current_state = start for char in string: if char in transitions.get(current_state, {}): current_state = transitions[current_state][char] else: return False return current_state in final"},{"question":"Priority Queue Interface Students are asked to implement a priority queue using a binary min-heap for efficient performance. # Problem Description Implement a class `MinHeapPriorityQueue` which maintains a priority queue of elements using a binary min-heap. Your implementation should support the following operations: 1. **push(item, priority)**: * Insert `item` into the priority queue with the specified `priority`. * The insertion operation should maintain the properties of a min-heap. * If a priority value is not provided, the item\'s value is used as the priority. 2. **pop()**: * Remove and return the item with the highest priority (smallest priority value). * This operation should maintain the properties of a min-heap. * If the priority queue is empty, return `None`. 3. **size()**: * Return the number of items currently in the priority queue. 4. **peek()**: * Return the item with the highest priority without removing it from the queue. * If the queue is empty, return `None`. # Input and Output Formats ```python class MinHeapPriorityQueue: def __init__(self): # Initialize your data structures here def push(self, item, priority=None): # Implement this method def pop(self): # Implement this method def size(self): # Implement this method def peek(self): # Implement this method ``` # Constraints and Requirements 1. Push and pop operations should be optimized to O(log n) complexity. 2. Use a binary min-heap to store internal elements. 3. Handle edge cases such as: - Pushing elements with duplicate priorities. - Popping or peeking from an empty queue. # Example ```python pq = MinHeapPriorityQueue() pq.push(20, 2) pq.push(15, 1) pq.push(10, 3) print(pq.pop()) # Output: 15 print(pq.peek()) # Output: 20 print(pq.size()) # Output: 2 pq.push(5) print(pq.pop()) # Output: 20 print(pq.size()) # Output: 2 ``` Note - Your solution will be evaluated on correctness, efficiency, and code quality. - Avoid using built-in Python libraries like `heapq`. Implement the heap functionalities manually.","solution":"class MinHeapPriorityQueue: def __init__(self): self.heap = [] # This will contain tuples of (priority, item) def push(self, item, priority=None): if priority is None: priority = item self.heap.append((priority, item)) self._sift_up(len(self.heap) - 1) def pop(self): if not self.heap: return None self._swap(0, len(self.heap) - 1) min_item = self.heap.pop() self._sift_down(0) return min_item[1] def size(self): return len(self.heap) def peek(self): if not self.heap: return None return self.heap[0][1] def _sift_up(self, idx): parent_idx = (idx - 1) // 2 if idx > 0 and self.heap[idx][0] < self.heap[parent_idx][0]: self._swap(idx, parent_idx) self._sift_up(parent_idx) def _sift_down(self, idx): smallest = idx left = 2 * idx + 1 right = 2 * idx + 2 if left < len(self.heap) and self.heap[left][0] < self.heap[smallest][0]: smallest = left if right < len(self.heap) and self.heap[right][0] < self.heap[smallest][0]: smallest = right if smallest != idx: self._swap(idx, smallest) self._sift_down(smallest) def _swap(self, i, j): self.heap[i], self.heap[j] = self.heap[j], self.heap[i]"},{"question":"# Regular Expression Matching Given a string `s` and a pattern `p`, implement a function `bool is_match(const char *s, const char *p)` that checks if the pattern `p` matches the entire string `s`. The pattern string `p` may contain the special characters `.` and `*` which are defined as follows: - `.` Matches any single character. - `*` Matches zero or more of the preceding element. The matching should cover the entire input string (not partial). The implementation should use dynamic programming to ensure efficiency. Function Signature ```python def is_match(s:str, p:str) -> bool: ``` # Input - `s`: A string of length `0 <= len(s) <= 1000`. - `p`: A string of length `0 <= len(p) <= 1000`. The pattern can include lowercase letters, `.` and `*`. # Output - `True` if `p` matches the whole string `s`. - `False` otherwise. # Constraints - Patterns cannot have multiple consecutive `*`. # Example Example 1: Input: `s = \\"aa\\"`, `p = \\"a\\"` Output: `False` Example 2: Input: `s = \\"aa\\"`, `p = \\"aa\\"` Output: `True` Example 3: Input: `s = \\"aaa\\"`, `p = \\"aa\\"` Output: `False` Example 4: Input: `s = \\"aa\\"`, `p = \\"a*\\"` Output: `True` Example 5: Input: `s = \\"aa\\"`, `p = \\".*\\"` Output: `True` Example 6: Input: `s = \\"ab\\"`, `p = \\".*\\"` Output: `True` Example 7: Input: `s = \\"aab\\"`, `p = \\"c*a*b\\"` Output: `True` # Important Edge Cases - Empty strings. - Patterns like `a*b*c*`. - String with multiple characters and patterns with special character combinations.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the pattern p matches the entire string s, otherwise returns False. The pattern p can contain \'.\' which matches any single character and \'*\' which matches zero or more of the preceding element. m, n = len(s), len(p) # dp[i][j] will be True if s[:i] matches p[:j], else False dp = [[False] * (n+1) for _ in range(m+1)] # Empty string and empty pattern match dp[0][0] = True # Handle patterns with \'*\', since \'*\' can match zero preceding elements for j in range(1, n+1): if p[j-1] == \'*\': dp[0][j] = dp[0][j-2] for i in range(1, m+1): for j in range(1, n+1): if p[j-1] == \'.\' or p[j-1] == s[i-1]: dp[i][j] = dp[i-1][j-1] elif p[j-1] == \'*\': dp[i][j] = dp[i][j-2] or (dp[i-1][j] if p[j-2] == s[i-1] or p[j-2] == \'.\' else False) return dp[m][n]"},{"question":"# Scenario: You are working on a package handling software where specific nodes (representing package details) in a shipment tracking linked list often need to be removed due to various reasons (e.g., package cancellations, errors in entries). Given access to a node that needs to be removed, you need to implement an efficient function to execute this operation. # Objective: Write a function `delete_given_node(node: Node)` that deletes a specified node (except the tail node) from a singly linked list. You are only given access to the node to be removed, and it\'s guaranteed that it is not the tail. # Requirements: * **Function Signature**: ```python def delete_given_node(node: Node) -> None: ``` * **Expected Input and Output**: * Input: A single `Node` object that indicates the node in a singly linked list that should be deleted. * Output: The function should modify the list in place and return `None`. * **Constraints**: * The input node will never be the tail of the list. * The list has at least two nodes. * **Error Handling**: * If the node is `None` or its `next` is `None`, raise a `ValueError`. # Performance: The function should perform the deletion operation in O(1) time, ensuring the efficiency needed in real-time system updates. # Example: Given a linked list `1 -> 2 -> 3 -> 4` and the node with value `3`: * After calling `delete_given_node(node)` with node value `3`, the list should become `1 -> 2 -> 4`. # Additional Information: You may use the following `Node` class for your implementation: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` Write and implement code that correctly accomplishes this task, including necessary test cases to validate your solution.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def delete_given_node(node: Node) -> None: Delete the given node (except the tail) from a singly linked list. Parameters: node (Node): The node to be deleted. Returns: None: The function modifies the list in place and returns None. if node is None or node.next is None: raise ValueError(\\"The node provided is either None or the tail node which cannot be deleted.\\") node.val = node.next.val node.next = node.next.next"},{"question":"# Question # Objective Convert a given Binary Search Tree (BST) into a sorted Doubly Linked List (DLL). # Background A Doubly Linked List (DLL) is a data structure consisting of a set of sequentially linked records called nodes. Each node contains two fields, each containing a reference (link) to the next and previous node in the sequence. # Scenario Given a binary search tree, write a function to convert the BST into a sorted doubly linked list. The left and right pointers in the tree nodes should be used as pointers in the doubly linked list. # Function ***Design a function with the following signature:*** ```python def bst_to_dll(root: TreeNode) -> TreeNode: Converts the given BST to a sorted doubly linked list (DLL). :param root: Root node of the BST :return: Head of the resultant doubly linked list ``` # Input and Output - **Input**: A `TreeNode` which is the root of the BST. A `TreeNode` is defined as: ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None ``` - **Output**: A `TreeNode` which is the head of the doubly linked list. Each node\'s left pointer should point to the previous node in the list, and the right pointer should point to the next node. # Constraints * The number of nodes in the tree is in the range [0, 1000]. * -1000 <= Node.val <= 1000. * All the values of the BST are unique. # Example Consider the following example to validate the solution. **Input**: ``` 10 / 6 14 / / 4 8 12 16 ``` **Output**: ``` 4 <-> 6 <-> 8 <-> 10 <-> 12 <-> 14 <-> 16 ``` **Function Execution**: ```python root = TreeNode(10) root.left = TreeNode(6) root.right = TreeNode(14) root.left.left = TreeNode(4) root.left.right = TreeNode(8) root.right.left = TreeNode(12) root.right.right = TreeNode(16) head = bst_to_dll(root) # Test the output list by traversing it while head: print(head.val, end=\\" <-> \\" if head.right else \\"n\\") head = head.right ``` # Note * Your solution should be efficient and handle edge cases like empty trees or skewed trees effectively. # Testing - Test with a null tree. - Test with a BST having only one node. - Test with a skewed tree (all nodes only on one side). - Verify the doubly linked list manually with small BSTs.","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def bst_to_dll(root: TreeNode) -> TreeNode: Converts the given BST to a sorted doubly linked list (DLL). :param root: Root node of the BST :return: Head of the resultant doubly linked list if root is None: return None # Helper function to perform the in-order traversal and connect nodes def convert(node): nonlocal last, first if node: # Traverse the left subtree convert(node.left) # Connect the current node with the last node in the DLL if last: last.right, node.left = node, last else: # This node will be the head (first node) of the DLL first = node # Mark the current node as the last node processed last = node # Traverse the right subtree convert(node.right) # Initialize first and last pointers first, last = None, None convert(root) return first"},{"question":"Create a hash table using separate chaining as the collision resolution technique. Implement the put, get, delete, and resize methods. Additionally, create an iterator to return all key-value pairs in the hash table. # Detailed Requirements 1. **Class Definition**: - Name the class `CustomHashTable`. - Use a linked list for each bucket to handle collisions. 2. **Methods to Implement**: - `__init__(self, size=11)`: Initialize the hash table with an array of given initial size. - `hash(self, key)`: Compute and return the hash index for a given key. - `put(self, key, value)`: Insert or update a key-value pair. - `get(self, key)`: Retrieve the value associated with a key. - `delete(self, key)`: Remove the key-value pair. - `resize(self)`: Resize the hash table to the next prime number greater than twice the current size. - `__iter__(self)`: Iterator method to iterate over all key-value pairs in the hash table. - `__len__(self)`: Return the number of elements in the hash table. 3. **Constraints and Considerations**: - Assume keys and values are always non-None. - Resize the hash table dynamically to maintain an average load factor of 0.75. - Handle edge cases, such as inserting duplicate keys, deleting non-existent keys, and accessing non-existent keys. # Expected Function Signatures: ```python class CustomHashTable: def __init__(self, size=11): pass def hash(self, key): pass def put(self, key, value): pass def get(self, key): pass def delete(self, key): pass def resize(self): pass def __iter__(self): pass def __len__(self): pass ``` # Example ```python # Example Usage: cht = CustomHashTable(size=7) cht.put(\'a\', 1) cht.put(\'b\', 2) cht.put(\'c\', 3) print(cht.get(\'b\')) # 2 print(len(cht)) # 3 cht.delete(\'a\') print(cht.get(\'a\')) # None # Iterate over entries for key, value in cht: print(key, value) # Output: # b 2 # c 3 ```","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class CustomHashTable: def __init__(self, size=11): self.size = size self.buckets = [None] * size self.count = 0 self.load_factor = 0.75 def hash(self, key): return hash(key) % self.size def put(self, key, value): index = self.hash(key) if self.buckets[index] is None: self.buckets[index] = Node(key, value) else: current = self.buckets[index] while current: if current.key == key: current.value = value # Update value if key exists return if current.next is None: break current = current.next current.next = Node(key, value) self.count += 1 if self.count / self.size > self.load_factor: self.resize() def get(self, key): index = self.hash(key) current = self.buckets[index] while current: if current.key == key: return current.value current = current.next return None def delete(self, key): index = self.hash(key) current = self.buckets[index] prev = None while current: if current.key == key: if prev: prev.next = current.next else: self.buckets[index] = current.next self.count -= 1 return prev, current = current, current.next def resize(self): new_size = self.find_next_prime(2 * self.size) new_buckets = [None] * new_size self.size = new_size old_buckets = self.buckets self.buckets = new_buckets self.count = 0 for node in old_buckets: while node: self.put(node.key, node.value) node = node.next def find_next_prime(self, n): def is_prime(num): if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True while not is_prime(n): n += 1 return n def __iter__(self): for bucket in self.buckets: current = bucket while current: yield (current.key, current.value) current = current.next def __len__(self): return self.count"},{"question":"Given the implementation of a Binary Search Tree (BST) with methods to insert, search, calculate size, and traversal (preorder, inorder, postorder), enhance the BST class with the following functionalities: 1. **Delete**: Implement a method `delete(data: int) -> bool` to remove a node from the BST. If the node does not exist, return `False`. Otherwise, remove the node and return `True`. Ensure that the tree properties are maintained after deletion. 2. **Height**: Implement a method `height() -> int` that calculates the height of the BST. The height of a binary tree is the number of edges on the longest path from the root to a leaf. # Function Signature ```python class BST: # Existing methods omitted for brevity def delete(self, data: int) -> bool: pass def height(self) -> int: pass ``` # Input/Output * **Input**: * The methods will be called on an instance of the BST. * For `delete(data: int)`, `data` is the value to be removed. * For `height()`, there are no parameters. * **Output**: * The `delete(data: int)` method returns a `boolean`: `True` if the node is successfully deleted and `False` otherwise. * The `height()` method returns an `integer` representing the height of the tree. # Constraints * Assume that the BST contains unique integer values. * The node values are of type integer and within the range of standard 32-bit signed integer values. # Example ```python # Assume BST implementation is provided with existing methods (insert, search, size, traversal) bst = BST() bst.insert(3) bst.insert(1) bst.insert(4) bst.insert(2) print(bst.height()) # Output: 2 print(bst.delete(4)) # Output: True print(bst.height()) # Output: 2 print(bst.delete(5)) # Output: False ``` # Scenarios to Consider 1. Deleting a leaf node. 2. Deleting a node with one child. 3. Deleting a node with two children. 4. Calculating the height of an empty tree. 5. Calculating the height of a single-node tree.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data: int): if self.root is None: self.root = TreeNode(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.value: if node.left is None: node.left = TreeNode(data) else: self._insert(node.left, data) else: if node.right is None: node.right = TreeNode(data) else: self._insert(node.right, data) def search(self, data: int) -> bool: return self._search(self.root, data) def _search(self, node, data): if node is None: return False if data == node.value: return True elif data < node.value: return self._search(node.left, data) else: return self._search(node.right, data) def delete(self, data: int) -> bool: self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if node is None: return node, False deleted = False if data == node.value: deleted = True if node.left and node.right: parent, child = node, node.right while child.left is not None: parent, child = child, child.left child.left = node.left if parent != node: parent.left = child.right child.right = node.right node = child elif node.left or node.right: node = node.left if node.left else node.right else: node = None elif data < node.value: node.left, deleted = self._delete(node.left, data) else: node.right, deleted = self._delete(node.right, data) return node, deleted def height(self) -> int: return self._height(self.root) def _height(self, node): if node is None: return -1 return 1 + max(self._height(node.left), self._height(node.right))"},{"question":"Histogram Count You are tasked with implementing a histogram counting function, which accurately represents the distribution of numerical data in a given list. A histogram provides a frequency count of each unique value in the list. Function Signature: ```python def get_histogram(input_list: list) -> dict: ``` Input: * `input_list` (list): A list of integers where each integer represents a data point in the distribution. The list can be empty or have multiple occurrences of the same integer. Output: * A dictionary where each key is a unique element from the `input_list` and the corresponding value is the count of occurrences of that element. Constraints: * 0 <= len(input_list) <= 10^7 * Each element in input_list (if it exists) is an integer within the range of standard 32-bit signed integer values. Example: ```python list_1 = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} list_2 = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` Your Task: Implement the function as specified. Ensure your implementation handles edge cases such as an empty list and lists with uniform or highly varied data efficiently. Performance Requirements: * Your implementation should run in O(n) time complexity and use O(k) space complexity, where n is the number of elements in the `input_list` and k is the number of unique elements in the list.","solution":"def get_histogram(input_list: list) -> dict: Creates a histogram from the given list of integers, returning a dictionary with keys as the unique elements and values as their respective counts. histogram = {} for num in input_list: if num in histogram: histogram[num] += 1 else: histogram[num] = 1 return histogram"},{"question":"You are provided with a Binary Search Tree (BST) implementation that includes methods for insertion, searching, size calculation, and traversals (preorder, inorder, postorder). However, the BST lacks a method to delete a node. Your task is to implement the `delete` method in the `BST` class to remove a node with a specified value from the tree while maintaining the BST properties. # Objective Implement the `delete` method in the `BST` class to: 1. Locate the node with the specified value. 2. Remove the node while maintaining the BST properties. 3. Handle three scenarios: - The node to be deleted has no children (it\'s a leaf). - The node to be deleted has one child. - The node to be deleted has two children (replace with in-order successor). # Expected Input and Output - Input: `int` (value of the node to be deleted) - Output: `bool` (return `True` if the node was deleted successfully, `False` if the value was not found) # Constraints - The tree will contain unique values. - Performance requirements: Your implementation should maintain an average case time complexity of O(log N). # Implementation Details - Use the provided BST class structure. - Consider edge cases like deletion from an empty tree or a node with specific structures (leaf, one child, two children). # Scenario Imagine you utilize BST for a database indexing system where you frequently insert and delete records while keeping track of ordering. Prompt and correct deletion is critical to maintain system performance. ```python # Existing BST class for reference class BST(object): # ... (other methods as provided) def delete(self, data): Delete a node with the specified data while maintaining BST properties. # You need to implement this method. pass # Example usage: if __name__ == \'__main__\': bst = BST() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) bst.insert(12) bst.insert(18) print(bst.delete(7)) # Output: True print(bst.delete(20)) # Output: False bst.inorder(bst.get_root()) # Output should reflect the deleted nodes ``` # Additional Notes You may add additional helper functions if necessary, ensure their complexity maintains the overall requirements. Provide unit tests to verify the functionality of your `delete` method.","solution":"class Node: def __init__(self, data): self.left = None self.right = None self.data = data class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(self.root, data) def _insert(self, node, data): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(node.left, data) else: if node.right is None: node.right = Node(data) else: self._insert(node.right, data) def search(self, data): return self._search(self.root, data) def _search(self, node, data): if node is None or node.data == data: return node if data < node.data: return self._search(node.left, data) return self._search(node.right, data) def delete(self, data): self.root, deleted = self._delete(self.root, data) return deleted def _delete(self, node, data): if node is None: return node, False if data < node.data: node.left, deleted = self._delete(node.left, data) elif data > node.data: node.right, deleted = self._delete(node.right, data) else: deleted = True if node.left is None: temp = node.right node = None return temp, deleted elif node.right is None: temp = node.left node = None return temp, deleted temp = self._min_value_node(node.right) node.data = temp.data node.right, _ = self._delete(node.right, temp.data) return node, deleted def _min_value_node(self, node): current = node while current.left: current = current.left return current def inorder(self, node): res = [] if node: res = self.inorder(node.left) res.append(node.data) res = res + self.inorder(node.right) return res def get_root(self): return self.root"},{"question":"# Interpolation Search-Based Range Query In many applications, such as database indexing, quick range queries over sorted data are often needed. Designing a solution to efficiently determine the range of indices where array elements fall within a specified range can significantly enhance performance. Problem Statement: You are provided with a sorted array of integers and two integers representing a search range `[lower, upper]`. Your task is to implement a function `range_query(array: List[int], lower: int, upper: int) -> Tuple[int, int]` that uses the principles of interpolation search to find and return the start and end indices where elements fall within the given range. If no elements fall within the range, return `(-1, -1)`. Input Format: - `array`: A list of integers sorted in non-decreasing order. - `lower`: An integer representing the lower bound of the range. - `upper`: An integer representing the upper bound of the range. Output Format: - A tuple containing two integers representing the start and end indices where elements fall within the range, inclusive. Return `(-1, -1)` if no such range exists. Constraints: - Assume the array has no duplicate elements. - The array will have at least one element and at most `10^6` elements. Example: ```python >>> range_query([1, 3, 5, 7, 9, 11, 13, 15], 5, 13) (2, 6) >>> range_query([1, 3, 5, 7, 9, 11, 13, 15], 6, 12) (3, 5) >>> range_query([1, 3, 5, 7, 9, 11, 13, 15], 20, 25) (-1, -1) ``` Notes: - You may assume the lower bound is less than or equal to the upper bound. - You should handle edge cases like an empty array and non-overlapping ranges efficiently. Hints: 1. Adapt the interpolation search method to identify the starting and ending indices. 2. Pay attention to array boundaries and adjust conditions to avoid out-of-bounds errors. Implement the `range_query` function accordingly.","solution":"from typing import List, Tuple def interpolation_search(array: List[int], target: int) -> int: low = 0 high = len(array) - 1 while low <= high and target >= array[low] and target <= array[high]: if low == high: if array[low] == target: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (target - array[low])) if array[pos] == target: return pos if array[pos] < target: low = pos + 1 else: high = pos - 1 return -1 def find_start_index(array: List[int], lower: int) -> int: index = interpolation_search(array, lower) if index == -1: index = 0 while index < len(array) and array[index] < lower: index += 1 return index if index < len(array) else -1 return index def find_end_index(array: List[int], upper: int) -> int: index = interpolation_search(array, upper) if index == -1: index = len(array) - 1 while index >= 0 and array[index] > upper: index -= 1 return index if index >= 0 else -1 return index def range_query(array: List[int], lower: int, upper: int) -> Tuple[int, int]: if not array or lower > array[-1] or upper < array[0]: return (-1, -1) start_idx = find_start_index(array, lower) end_idx = find_end_index(array, upper) if start_idx == -1 or end_idx == -1 or start_idx > end_idx: return (-1, -1) return (start_idx, end_idx)"},{"question":"# Scenario You are part of a data analytics team that processes temperature data from various sensors. One task involves cleaning the data to remove unreasonable temperature readings before further analysis. To achieve this, you need to filter the temperature readings to a specific range, eliminating values outside this range. # Task Implement a function that filters an array of temperature readings. The function should return a new array containing only the temperature readings between a specified minimum and maximum range, inclusive. If either of the bounds (min_lim or max_lim) is not provided, the function should use the smallest or largest value in the array, respectively, as the bounds. # Function Signature ```python def filter_temperatures(temperatures: List[float], min_lim: Optional[float] = None, max_lim: Optional[float] = None) -> List[float]: ``` # Input - `temperatures`: A list of floating-point numbers representing temperature readings. - `min_lim` (optional): A floating-point number specifying the lower bound. - `max_lim` (optional): A floating-point number specifying the upper bound. # Output - Returns a list of floating-point numbers representing the filtered temperature readings within the specified range [min_lim, max_lim]. # Constraints - If `temperatures` is empty, return an empty list. - If `min_lim` is `None`, treat it as the minimum value in the `temperatures` list. - If `max_lim` is `None`, treat it as the maximum value in the `temperatures` list. # Performance Requirements - The solution should have a time complexity of O(n), where n is the number of temperature readings. # Example ```python # Example 1: # Input: [15.6, 22.1, 5.8, 10.4, 31.2, 18.5], min_lim=10.0, max_lim=20.0 # Output: [15.6, 10.4, 18.5] # Example 2: # Input: [15.6, 22.1, 5.8, 10.4, 31.2, 18.5], min_lim=None, max_lim=30.0 # Output: [15.6, 22.1, 5.8, 10.4, 18.5] # Example 3: # Input: [], min_lim=5.0, max_lim=25.0 # Output: [] # Example 4: # Input: [100.1, 200.2, -50.3, 0.0], min_lim=0, max_lim=None # Output: [100.1, 200.2, 0.0] ```","solution":"from typing import List, Optional def filter_temperatures(temperatures: List[float], min_lim: Optional[float] = None, max_lim: Optional[float] = None) -> List[float]: if not temperatures: return [] if min_lim is None: min_lim = min(temperatures) if max_lim is None: max_lim = max(temperatures) return [temp for temp in temperatures if min_lim <= temp <= max_lim]"},{"question":"**Problem Statement**: You are given a stack represented as a list in Python. Your task is to implement a function `stutter_stack` that duplicates every value in the stack. The function should use only a single auxiliary storage (either a stack or a queue). You are required to demonstrate the understanding and performance of different auxiliary storages and choose the most efficient approach. ```python def stutter_stack(stack): pass # Example: # input_stack = [3, 7, 1, 14, 9] # stutter_stack(input_stack) # Expected output: # [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Input: - A list of integers representing a stack. The top of the stack is the last element of the list. # Output: - The same list, but with the elements duplicated. # Constraints: - The stack will contain between 0 to 1000 elements. - All stack elements will be integers. # Performance Requirements: - The solution should be efficient in terms of both time and space complexity. - Aim to minimize the number of reversals of the stack to make the algorithm more efficient. # Additional Notes: - You may decide which auxiliary storage (stack or queue) to use in your implementation. - Consider edge cases such as empty stacks. **Hints**: 1. Carefully choose your auxiliary storage to manage stack operations efficiently. 2. Avoid unnecessary operations to maintain performance.","solution":"from collections import deque def stutter_stack(stack): Duplicates each element in the stack using an auxiliary queue. Parameters: stack (list): A list of integers representing the stack with the top of the stack being the last element of the list. Returns: None: The function modifies the stack in place. queue = deque() # Transfer all elements to the queue, duplicating each element as we go. while stack: elem = stack.pop() queue.appendleft(elem) queue.appendleft(elem) # Transfer duplicated elements back to the stack while queue: stack.append(queue.popleft())"},{"question":"# Problem Description You\'ve been provided with the classes `Node`, `DirectedEdge`, and `DirectedGraph` representing a directed graph\'s basic structure. We will now extend the functionality of the `DirectedGraph` class. Your task is to implement a function `has_cycle` that determines if the Directed Graph contains any cycles. A cycle in a graph is a path that starts from a given node and ends back at the same node. # Function Signature ```python def has_cycle(self) -> bool: ``` # Input The input will be the `DirectedGraph` instance itself which contains: - A list of nodes and edges. - An adjacency list representing the connections. # Output Return a boolean value: - `True` if the graph contains a cycle. - `False` if otherwise. # Constraints - The graph will have at most `1000` nodes. - The graph will not contain multiple edges between the same pair of nodes but can have self-loops. # Example ```python # Example Graph Creation graph = DirectedGraph({ \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] }) print(graph.has_cycle()) # Output: True (A -> B -> C -> A forms a cycle) graph = DirectedGraph({ \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [] }) print(graph.has_cycle()) # Output: False (No cycles in the graph) ``` # Notes * Be mindful of edge cases such as graphs with no edges, multiple disconnected subgraphs, and graphs with self-loops. * Aim for an efficient solution, preferably with a time complexity better than O(V^2).","solution":"class DirectedGraph: def __init__(self, adjacency_list): self.graph = adjacency_list def has_cycle(self): # Auxiliary function to run DFS and check for cycles def dfs(node, visited, rec_stack): visited[node] = True rec_stack[node] = True for neighbor in self.graph.get(node, []): if not visited.get(neighbor, False) and dfs(neighbor, visited, rec_stack): return True elif rec_stack.get(neighbor, False): return True rec_stack[node] = False return False visited = {} rec_stack = {} for node in self.graph: if not visited.get(node, False): if dfs(node, visited, rec_stack): return True return False"},{"question":"# Problem: Integer-Byte Conversion with Endianness Objective Write functions to convert an integer to its byte representation and vice versa, taking into account both big-endian and little-endian formats. You need to ensure that your functions handle zero values, large integers up to `2^64 - 1`, and all edge cases appropriately. Function Signatures * `int_to_bytes_big_endian(num: int) -> bytes` * `int_to_bytes_little_endian(num: int) -> bytes` * `bytes_big_endian_to_int(bytestr: bytes) -> int` * `bytes_little_endian_to_int(bytestr: bytes) -> int` Input * `num`: An integer (0 <= num < 2^64). * `bytestr`: A bytes object representing an integer. Output * Each function returns the converted representation of the input as specified. Constraints * Do not use any external libraries other than standard Python collections and typing. * Efficient time and space complexity are essential. Examples * Example 1: ```python print(int_to_bytes_big_endian(1024)) # Expected output: b\'x04x00\' print(bytes_big_endian_to_int(b\'x04x00\')) # Expected output: 1024 ``` * Example 2: ```python print(int_to_bytes_little_endian(1024)) # Expected output: b\'x00x04\' print(bytes_little_endian_to_int(b\'x00x04\')) # Expected output: 1024 ``` Notes * Non-positive integers (e.g., negative numbers) or integers >= 2^64 are out of scope for this task. * Consider edge cases such as 0 and maximum possible value (2^64 - 1). * Focus on correctness, efficiency, and readability.","solution":"def int_to_bytes_big_endian(num: int) -> bytes: Converts an integer to its byte representation in big-endian format. return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'big\') or b\'x00\' def int_to_bytes_little_endian(num: int) -> bytes: Converts an integer to its byte representation in little-endian format. return num.to_bytes((num.bit_length() + 7) // 8, byteorder=\'little\') or b\'x00\' def bytes_big_endian_to_int(bytestr: bytes) -> int: Converts a big-endian byte representation to its integer form. return int.from_bytes(bytestr, byteorder=\'big\') def bytes_little_endian_to_int(bytestr: bytes) -> int: Converts a little-endian byte representation to its integer form. return int.from_bytes(bytestr, byteorder=\'little\')"},{"question":"# Word Pattern Matching Given a pattern and a string, determine if the string follows the same pattern. Here follow means a full match such that there is a bijection between a letter in the pattern and a non-empty word in the string. Detailed Requirements: - Assume `pattern` is a non-empty string containing only lowercase letters. - Assume `str` is a non-empty string containing lowercase words separated by a single space. # Input Formats: - A string `pattern` of length m (1 ≤ m ≤ 10^4). - A string `str` containing words separated by spaces with length n (1 ≤ n ≤ 10^4). # Output Format: - Return `True` if the string follows the pattern, and `False` otherwise. # Example: 1. **Input**: - `pattern = \\"abba\\"` - `str = \\"dog cat cat dog\\"` - **Output**: `True` 2. **Input**: - `pattern = \\"abba\\"` - `str = \\"dog cat cat fish\\"` - **Output**: `False` 3. **Input**: - `pattern = \\"aaaa\\"` - `str = \\"dog cat cat dog\\"` - **Output**: `False` 4. **Input**: - `pattern = \\"abba\\"` - `str = \\"dog dog dog dog\\"` - **Output**: `False` # Implementation: Complete the function `word_pattern(pattern, str)` to meet the above requirements. ```python def word_pattern(pattern, str): dict = {} set_value = set() list_str = str.split() if len(list_str) != len(pattern): return False for i in range(len(pattern)): if pattern[i] not in dict: if list_str[i] in set_value: return False dict[pattern[i]] = list_str[i] set_value.add(list_str[i]) else: if dict[pattern[i]] != list_str[i]: return False return True # Test your implementation carefully with various test cases to ensure correctness. ```","solution":"def word_pattern(pattern, str): Determines if the string follows the same pattern. Parameters: pattern (str): The pattern string. str (str): The input string containing words. Returns: bool: True if the string follows the pattern, False otherwise. word_to_pattern = {} pattern_to_word = {} words = str.split() if len(words) != len(pattern): return False for p, w in zip(pattern, words): if p in pattern_to_word and pattern_to_word[p] != w: return False if w in word_to_pattern and word_to_pattern[w] != p: return False pattern_to_word[p] = w word_to_pattern[w] = p return True"},{"question":"# Wiggle Sort Implementation Scenario You\'re tasked with designing a function that reorganizes an input list of integers such that it follows a specific zigzag pattern. Specifically, for any given list `nums`: * If the index is even, the element should be less than the next element. * If the index is odd, the element should be greater than the next element. This rearrangement does not require the entire list to be sorted, only that the specific wiggle arrangement condition is met. Challenge Write a function `wiggle_sort` that takes a list `nums` and modifies it in-place to follow the wiggle sorting rules. Function Signature ```python def wiggle_sort(nums: List[int]) -> None: Modifies nums in-place to alternate between less and greater values. Parameters: - nums: List[int], a list of integers. Returns: None, the list is modified in place to satisfy the wiggle sort property. ``` Input - A list of integers `nums` with `0 <= len(nums) <= 10^4`. Output - The integer list is modified in-place such that it follows the wiggle sorting property (`nums[0] < nums[1] > nums[2] < nums[3]...`). Constraints - You must perform the reordering in-place with ( O(n) ) complexity. - The list can be of any length including empty. Example ```python # Example 1: nums = [3, 5, 2, 1, 6, 4] wiggle_sort(nums) print(nums) # Output could be [3, 5, 1, 6, 2, 4] or any valid wiggle sort variation # Example 2: nums = [1, 2, 3, 4, 5] wiggle_sort(nums) print(nums) # Output could be [1, 3, 2, 5, 4] or any valid wiggle sort variation ``` Notes - Ensure to handle edge cases, such as empty lists or lists with all identical elements. - Validate your implementation against varying list lengths and compositions.","solution":"from typing import List def wiggle_sort(nums: List[int]) -> None: Modifies nums in-place to alternate between less and greater values. Parameters: - nums: List[int], a list of integers. Returns: None, the list is modified in place to satisfy the wiggle sort property. if not nums: return for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 != 0 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"Objective Write a function to determine whether two given strings are exactly one edit distance apart. This requires a single insertion, deletion, or substitution of a character. Input - Two strings `s` and `t`. Output - Return `True` if the strings are one edit distance apart; otherwise, return `False`. Constraints - The strings `s` and `t` can contain any printable ASCII character. - Maximum length of each string is 10,000. Example ``` Input: s = \\"ab\\", t = \\"acb\\" Output: True (Explanation: Insert \'c\' in s to get t) Input: s = \\"abc\\", t = \\"ab\\" Output: True (Explanation: Delete \'c\' from s to get t) Input: s = \\"abc\\", t = \\"adc\\" Output: True (Explanation: Replace \'b\' in s with \'d\' to get t) Input: s = \\"abc\\", t = \\"abc\\" Output: False (Explanation: They are already the same) Input: s = \\"abc\\", t = \\"abcd\\" Output: True (Explanation: Insert \'d\' in s to get t) Input: s = \\"abc\\", t = \\"abcf\\" Output: False (Explanation: Two edits are required, insert \'d\' and \'f\') ``` Implementation Implement the function `is_one_edit_distance(s: str, t: str) -> bool`.","solution":"def is_one_edit_distance(s: str, t: str) -> bool: Determine if s and t are one edit distance apart. m, n = len(s), len(t) # If the length difference is greater than 1, return False if abs(m - n) > 1: return False # Ensure that s is the shorter string if m > n: s, t = t, s m, n = n, m i, j, edit_count = 0, 0, 0 while i < m and j < n: if s[i] != t[j]: if edit_count == 1: return False if m == n: i += 1 # substitution case # increment index j for insertion/deletion case edit_count += 1 else: i += 1 j += 1 # If there is an extra character at the end if i < m or j < n: edit_count += 1 return edit_count == 1"},{"question":"**Scenario**: You are designing an inventory management system for a company that needs to maximize the value of goods they can transport in a single trip. The transport vehicle has limited capacity, and each good has a specific weight and value. Your task is to write a function to find the maximum possible value that can be transported without exceeding the vehicle\'s capacity. **Problem Statement**: Write a function `maximize_knapsack_value` that takes in two arguments, a list of items and an integer representing the knapsack capacity. Each item is represented as a tuple `(value, weight)`. The function should return the maximum summarized value of the items that can be fit in the knapsack. **Function Signature**: ```python def maximize_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: ``` **Input Format**: 1. `items`: A list of tuples where each tuple contains two integers - `(value, weight)`. * `1 <= len(items) <= 1000` * `1 <= value <= 1000` * `1 <= weight <= 1000` 2. `capacity`: An integer representing the knapsack\'s capacity. * `0 <= capacity <= 10000` **Output Format**: - The function should return an integer representing the maximum value that can be carried in the knapsack. **Constraints**: - The items cannot be broken; they must be taken whole or not at all (0/1 Knapsack problem). - Each item can only be included once. **Example**: ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 maximize_knapsack_value(items, capacity) # Output: 80 (items valued 50 and 30) items = [(90, 5), (60, 3), (100, 4), (70, 2)] capacity = 8 maximize_knapsack_value(items, capacity) # Output: 160 (items valued 90 and 70) ``` **Performance Considerations**: - Ensure the implementation runs efficiently within given constraints. - Special attention to edge cases such as empty item list or zero capacity.","solution":"from typing import List, Tuple def maximize_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i - 1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"# Function Implementation You are required to implement a function: `efficient_heap_sort(arr: List[int], reverse: bool = False) -> List[int]` This function performs heap sort on the given list `arr`. If the `reverse` parameter is set to `True`, the sorting should be in descending order, otherwise in ascending. Input and Output Formats: * **Input**: * A list of integers, `arr`, which you need to sort. * A boolean, `reverse`, which determines the order of sorting. Default is `False` (ascending). * **Output**: * A sorted list of integers. # Constraints: * The input list can have up to (10^5) elements. * The integers in the list can range from (-10^6) to (10^6). Example: Input: ```python arr = [3, 2, 1, 5, 6, 4] reverse = False ``` Output: ```python [1, 2, 3, 4, 5, 6] ``` Constraints: * You should aim for a solution with a time complexity of O(n log n). Additionally, provide a short explanation of how your solution handles the following scenarios: * An empty array. * An array with all identical elements. * Using `reverse=True`. Your task: Implement `efficient_heap_sort` function using one of the provided heap sort approaches (either max-heap or min-heap given in the code snippets). Make sure to adjust the heap construction according to the `reverse` flag and ensure your solution is efficient and handles edge cases properly.","solution":"from typing import List import heapq def efficient_heap_sort(arr: List[int], reverse: bool = False) -> List[int]: if not arr: return [] if reverse: heapq._heapify_max(arr) sorted_arr = [heapq._heappop_max(arr) for _ in range(len(arr))] else: heapq.heapify(arr) sorted_arr = [heapq.heappop(arr) for _ in range(len(arr))] return sorted_arr"},{"question":"# Binary Tree Maximum Depth Calculation You are given a binary tree. Your task is to write a function that calculates the maximum depth of this binary tree. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Input: - The input will be the root of the binary tree. Each node contains two children, `left` and `right`. Output: - The output should be an integer representing the maximum depth of the tree. Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - The tree\'s depth will be in the range `[0, 10^4]`. Performance Requirements: - Ensure that your solution can handle trees with up to 10^4 nodes efficiently. Example: ``` # Example Tree: # # 10 # / # 12 15 # / / # 25 30 36 # # 100 Input: [10, 12, 15, 25, 30, 36, null, null, null, null, 100] Output: 4 ``` You may use the iterative BFS approach already provided or come up with your method. **Write your function named `max_depth` below:** ```python class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: # Your code here pass ```","solution":"class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None def max_depth(root: TreeNode) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"# Histogram Representation Challenge You have been tasked with creating a function to generate a histogram representation of a list of elements. The histogram will be in the form of a dictionary where each key is a unique element from the list and the value is the count of that element in the list. # Function Signature ```python def get_histogram(input_list: list) -> dict: Get a histogram representation of the input list. :param input_list: A list with elements of any hashable type. :return: A dictionary where keys are unique elements of the input list and values are their occurrences. ``` # Input - `input_list`: A list (0 <= len(input_list) <= 10^6) of elements. Elements can be any hashable type such as integers, strings, or tuples. # Output - A dictionary where the keys are the unique elements from the input list and values are their corresponding counts. # Constraints - The elements of the list must be hashable. - Ensure the solution works efficiently for large input sizes up to 10^6 elements. # Example Scenario You are given a list of integers representing the number of visitors to a website each day over a week. You need to create a histogram to determine how often each visitor count occurred. Example 1: ```python input_list = [3, 3, 2, 1] Expected output: {1: 1, 2: 1, 3: 2} ``` Example 2: ```python input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] Expected output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} ``` # Instructions - Implement the `get_histogram` function. - Ensure the function handles edge cases such as empty lists and lists with a single element. - Optimize for both time and space complexity. - Write clean and understandable code, including comments for clarity.","solution":"def get_histogram(input_list): Get a histogram representation of the input list. :param input_list: A list with elements of any hashable type. :return: A dictionary where keys are unique elements of the input list and values are their occurrences. histogram = {} for element in input_list: if element in histogram: histogram[element] += 1 else: histogram[element] = 1 return histogram"},{"question":"Generate Reverse Hailstone Sequence Context You are given the task to generate a Hailstone sequence starting from a given number `n`, but as an additional challenge, you must generate and return the sequence in reverse order, starting from 1 and ending at `n`. This requires you to first compute the traditional Hailstone sequence then reverse it. Task Write a function `reverse_hailstone(n)` that computes the Hailstone sequence for a given starting integer `n` and returns the sequence in reverse order, from 1 to `n`. Function Signature ```python def reverse_hailstone(n: int) -> list: ``` Input * An integer `n` (1 <= n <= 10^6). Output * A list representing the reversed Hailstone sequence, starting with 1 and ending with the initial `n`. Constraints and Requirements * The function should correctly handle all integers within the provided range. * The function should be efficient in terms of time and space complexity. * Ensure correctness by handling edge cases such as starting with 1 or very large numbers. Example ```python >>> reverse_hailstone(5) [1, 2, 4, 8, 16, 5] >>> reverse_hailstone(1) [1] ```","solution":"def hailstone(n: int) -> list: sequence = [] while n != 1: sequence.append(n) if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 sequence.append(1) return sequence def reverse_hailstone(n: int) -> list: sequence = hailstone(n) return sequence[::-1]"},{"question":"# AVL Tree Insertion with Rebalancing Problem Statement: An AVL tree is a self-balancing binary search tree where the difference in heights of left and right subtrees cannot be more than one for all nodes. Given the provided AVL tree implementation, your task is to: 1. Complete the `insert` function to insert a new key while maintaining the AVL tree properties. 2. Implement any necessary helper functions to ensure the AVL tree remains balanced after each insertion. Your function should handle the following: * Insert a key into the AVL tree. * Automatically rebalance the tree if it becomes unbalanced. * Ensure that the tree properties (BST and balance conditions) are preserved. Requirements: 1. Function signature: `def insert(self, key: int) -> None`. 2. Your function should not return any value; it should modify the tree in place. 3. You must consider all edge cases including inserting into an empty tree and handling duplicates by ignoring the insertion. 4. Performance is critical; ensure your implementation has an efficient balancing mechanism. Example: Given an empty AVL tree, the following sequence of insertions should lead to a balanced tree: 1. Insert `10`. - Tree: 10 2. Insert `20`. - Tree: ``` 10 20 ``` 3. Insert `30`. - Tree: ``` 20 / 10 30 ``` Constraints: 1. You can assume all keys are unique within a single insert operation. 2. The keys will be integers within the range of `[-10^5, 10^5]`. Good luck, and ensure your implementation is optimized for performance without compromising on correctness!","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def __init__(self): self.root = None def _get_height(self, node): if not node: return 0 return node.height def _right_rotate(self, y): x = y.left T2 = x.right x.right = y y.left = T2 y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) return x def _left_rotate(self, x): y = x.right T2 = y.left y.left = x x.right = T2 x.height = 1 + max(self._get_height(x.left), self._get_height(x.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) elif key > node.key: node.right = self._insert(node.right, key) else: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def insert(self, key): self.root = self._insert(self.root, key) def in_order_traversal(self): def _in_order(node): return _in_order(node.left) + [node.key] + _in_order(node.right) if node else [] return _in_order(self.root)"},{"question":"# Scenario Company X is hosting a coding competition, and as a part of it, they are conducting a fun challenge to implement one of the most inefficient sorting algorithms known: Bogo Sort. Your task is to implement this algorithm just as a demonstration of algorithm inefficiency and randomness. # Problem Statement You are given an array of integers. Write a function `bogo_sort(arr: List[int], simulation: bool = False) -> List[int]` that sorts the array using the Bogo Sort algorithm. If `simulation` is set to True, the function should print the intermediate array state of each shuffle. # Input * A list of integers `arr` with length `n` where (0 leq n leq 50). * A boolean flag `simulation`. # Output * The sorted list. # Performance Requirements * Since Bogo Sort is very inefficient, you need not worry about optimizing the implementation. However, the function should correctly implement the Bogo Sort algorithm. # Constraints * You may assume that all integer elements in the array are in the range (-10^6) to (10^6). # Example ```python import random def bogo_sort(arr, simulation=False): Bogo Sort Best Case Complexity: O(n) Worst Case Complexity: O(∞) Average Case Complexity: O(n(n-1)!) iteration = 0 if simulation: print(\\"iteration\\", iteration, \\":\\", *arr) def is_sorted(arr): # Check if the array is in order for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True while not is_sorted(arr): random.shuffle(arr) if simulation: iteration += 1 print(\\"iteration\\", iteration, \\":\\", *arr) return arr # Example Usage: # arr = [3, 2, 5, 1] # print(bogo_sort(arr, simulation=True)) # Output will be the sorted array and several iterations. ```","solution":"import random from typing import List def bogo_sort(arr: List[int], simulation: bool=False) -> List[int]: Sorts the given array using the Bogo Sort algorithm. If simulation is True, prints the array state after each shuffle. Parameters: arr (List[int]): The list of integers to sort. simulation (bool): Flag indicating whether to print intermediate states. Returns: List[int]: The sorted list. def is_sorted(arr: List[int]) -> bool: Checks if the given array is sorted. Parameters: arr (List[int]): The list of integers to check. Returns: bool: True if the array is sorted, False otherwise. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True iteration = 0 if simulation: print(f\\"iteration {iteration}: {arr}\\") while not is_sorted(arr): random.shuffle(arr) iteration += 1 if simulation: print(f\\"iteration {iteration}: {arr}\\") return arr"},{"question":"# Binary Tree Preorder Traversal You are provided with a class representing a node in a binary tree and two functions performing preorder traversal on the tree, one iteratively and the other recursively. Preorder traversal visits the root node first, followed by the left subtree, then the right subtree. # Objective Implement a function to perform preorder traversal on a binary tree. The function should accept the root of the binary tree and return a list of values representing the tree nodes visited in preorder. # Function Signature ```python def preorder_traversal(root): pass ``` # Input * `root`: The root node of a binary tree (`Node`). # Output * Returns a list of values representing the preorder traversal of the tree. # Constraints * Number of nodes in the tree: (1 leq n leq 10^4) * Node values are unique integers. # Example ```python # Example usage: # Building the following binary tree: # 1 # / # 2 3 # / / # 4 5 6 7 root = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) assert preorder_traversal(root) == [1, 2, 4, 5, 3, 6, 7] ``` # Additional Notes * You may choose to implement the traversal using an iterative or recursive approach. * Ensure your solution handles edge cases such as empty trees correctly.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def preorder_traversal(root): Perform a preorder traversal of a binary tree. :param root: The root of the binary tree. :return: A list of node values in preorder. if root is None: return [] # Initialize the result list and the stack with the root node result = [] stack = [root] # Perform the preorder traversal while stack: node = stack.pop() result.append(node.value) # Push right child first so that left is processed first if node.right: stack.append(node.right) if node.left: stack.append(node.left) return result"},{"question":"# Question You are tasked with implementing a custom stack called `OrderedStack` that will always keep elements in ascending order with the largest value at the top. This involves overriding the default `push` method to ensure that when a new element is added, the stack remains sorted. Requirements: 1. Implement the `OrderedStack` class that supports the following methods: - `push(self, item)`: Add an element to the stack while maintaining order. - `pop(self)`: Remove and return the top element of the stack. - `peek(self)`: Return the top element without removing it. - `is_empty(self)`: Check if the stack is empty. - `size(self)`: Return the number of elements in the stack. Constraints: * You may not use any additional data structures such as lists outside of those implied by the existing stack. * The stack should handle typical edge cases such as pushing into or popping from an empty stack appropriately. Example Usage: ```python stack = OrderedStack() stack.push(4) stack.push(2) stack.push(5) stack.push(1) assert stack.pop() == 5 assert stack.peek() == 4 assert stack.size() == 3 ``` Performance Expectations: * Ensure your implementation runs efficiently for up to 10^3 push and pop operations. Implement the `OrderedStack` class and make sure your implementation passes various test cases.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): # Find the correct position to insert the item to keep the stack ordered position = 0 while position < len(self.stack) and self.stack[position] < item: position += 1 self.stack.insert(position, item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack)"},{"question":"You have been tasked with enhancing the financial data analysis system of a startup by implementing an algorithm that finds the maximum possible profit within a given time period. Given an array representing the profit and loss over time, determine the maximum sum of any contiguous subsequence. # Function Signature: ```python def max_contiguous_subsequence_sum(arr: List[int]) -> int: ``` # Input: - `arr`: A list of integers (`-10^5 <= arr[i] <= 10^5`), where the length of the list (`n`) satisfies `0 <= n <= 10^5`. # Output: - Returns an integer representing the maximum sum of a contiguous subsequence. # Constraints: - The input list can be empty. In such cases, the function should return `0`. - The solution should aim for O(n) time complexity and O(1) space complexity. # Example: ```python # Example 1: arr = [-2, 3, 8, -1, 4] # The maximum contiguous subsequence is [3, 8, -1, 4] print(max_contiguous_subsequence_sum(arr)) # Output: 14 # Example 2: arr = [-1, 1, 0] # The maximum contiguous subsequence is [1] print(max_contiguous_subsequence_sum(arr)) # Output: 1 # Example 3: arr = [-1, -3, -4] # The maximum contiguous subsequence is [-1] print(max_contiguous_subsequence_sum(arr)) # Output: -1 # Example 4: arr = [] # Empty list should return 0 print(max_contiguous_subsequence_sum(arr)) # Output: 0 ``` # Notes: - Consider edge cases such as arrays with all negative numbers or single-element arrays.","solution":"def max_contiguous_subsequence_sum(arr): Returns the maximum sum of a contiguous subsequence in the array. if not arr: return 0 max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"Scenario: You are given a list of stock prices recorded each day over the course of a month. The list was originally sorted in ascending order but has since been rotated at an unknown pivot. Your task is to determine the minimum stock price from this list using an efficient algorithm. Objective: Write a function `find_min_stock_price(prices)` that takes a list of integers, `prices`, representing the stock prices and returns the minimum stock price. The function must operate in O(log N) time complexity. Input: - A list of integers, `prices` (1 <= len(prices) <= 10^6), where each integer represents a positive stock price. Output: - An integer representing the minimum stock price. Constraints: - No two stock prices are the same. - The list is guaranteed to be rotated. Examples: 1. **Input**: `[5, 6, 7, 1, 2, 3, 4]` **Output**: `1` 2. **Input**: `[2, 3, 4, 5, 1]` **Output**: `1` 3. **Input**: `[1, 2, 3, 4]` **Output**: `1` 4. **Input**: `[8, 9, 10, 2, 3, 4, 5]` **Output**: `2` Requirements: - Your solution should handle large lists efficiently. - The function must run in O(log N) time complexity. Implement the function `find_min_stock_price(prices)` based on the above requirements.","solution":"def find_min_stock_price(prices): Finds the minimum stock price from the rotated sorted list of prices. This function uses a binary search approach to achieve the O(log N) time complexity. low, high = 0, len(prices) - 1 while low < high: mid = (low + high) // 2 # if mid element is greater than high element, the minimum is in the right half if prices[mid] > prices[high]: low = mid + 1 else: # otherwise, the minimum is in the left half (including mid) high = mid return prices[low]"},{"question":"# Segment Tree in Frequent Fluctuating Market Context: You are working on a financial application that monitors stock prices. Due to the volatile nature of the market, prices fluctuate frequently, and you need to keep track of the maximum price within a specific range at any given time. You decide to use a Segment Tree to efficiently perform range maximum queries and point updates on the stock prices. Problem Statement: Implement a `SegmentTree` class in Python to manage stock prices where you can support: 1. Initialization with a list of stock prices, 2. Update the stock price at a given index, 3. Retrieve the maximum stock price within a given range of indices. Implement the following methods: 1. `__init__(self, arr: List[int]) -> None:` Initializes the Segment Tree with the given list of stock prices. 2. `update(self, index: int, price: int) -> None:` Update the stock price at the specified index. 3. `max_range(self, left: int, right: int) -> int:` Return the maximum stock price within the range [left, right] inclusive. Input: * A list of integers representing initial stock prices. * Multiple update operations each specified with an index and a new price. * Multiple range maximum queries each specified with two indices defining the range. Output: * Max stock price within the specified range for each range maximum query. Constraints: * Prices and indices are valid integers. * Indices for the range queries are within the bounds of the list length. Example: ```python # Initial stock prices [3, 8, 7, 6, 2, 10] seg_tree = SegmentTree([3, 8, 7, 6, 2, 10]) # Perform update operations seg_tree.update(2, 15) # updates the price at index 2 to 15 seg_tree.update(5, 5) # updates the price at index 5 to 5 # Perform range maximum queries print(seg_tree.max_range(1, 4)) # Output: 15 (from range 8, 15, 6, 2) print(seg_tree.max_range(0, 5)) # Output: 15 (from range 3, 8, 15, 6, 2, 5) ```","solution":"class SegmentTree: def __init__(self, arr): n = len(arr) self.arr = arr self.tree = [0] * (4 * n) self._build(0, 0, n - 1) def _build(self, node, start, end): if start == end: self.tree[node] = self.arr[start] else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 self._build(left_child, start, mid) self._build(right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) def update(self, index, price): def _update(node, start, end): if start == end: self.arr[index] = price self.tree[node] = price else: mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 if start <= index <= mid: _update(left_child, start, mid) else: _update(right_child, mid + 1, end) self.tree[node] = max(self.tree[left_child], self.tree[right_child]) _update(0, 0, len(self.arr) - 1) def max_range(self, left, right): def _query(node, start, end, L, R): if R < start or L > end: return float(\'-inf\') if L <= start and end <= R: return self.tree[node] mid = (start + end) // 2 left_child = 2 * node + 1 right_child = 2 * node + 2 left_query = _query(left_child, start, mid, L, R) right_query = _query(right_child, mid + 1, end, L, R) return max(left_query, right_query) return _query(0, 0, len(self.arr) - 1, left, right)"},{"question":"Advanced Search Algorithms Scenario You are tasked to implement a search algorithm that can efficiently find elements within a sorted array. The target is to use the ternary search algorithm due to its theoretical advantages in specific high-comparison environments. Problem Write a Python function `ternary_search(left, right, key, arr)` that finds the index of a `key` in the sorted array `arr` using the ternary search algorithm. The function should return the index of the key if it\'s found in the array, and `-1` otherwise. Your solution should be optimized for both time and space complexity. Function Signature ```python def ternary_search(left: int, right: int, key: int, arr: list) -> int: ``` Input 1. `left` (int): The starting index of the array segment to be searched (inclusive, initially `0`). 2. `right` (int): The ending index of the array segment to be searched (inclusive, initially `len(arr) - 1`). 3. `key` (int): The value to be searched within the array. 4. `arr` (list): A list of integers that is already sorted in ascending order. Output - Returns an integer representing the index of the `key` in the array `arr`. If `key` is not present, return `-1`. Constraints - The array `arr` must be sorted. - `0 <= left <= right < len(arr)` - `1 <= len(arr) <= 10^4` - `-10^6 <= arr[i], key <= 10^6` Examples ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] print(ternary_search(0, len(arr) - 1, 5, arr)) # Output: 4 # Example 2 arr = [1, 3, 4, 9, 10, 12, 15, 19, 20] print(ternary_search(0, len(arr) - 1, 10, arr)) # Output: 4 # Example 3 arr = [1, 2, 3, 4, 6, 7, 8] print(ternary_search(0, len(arr) - 1, 5, arr)) # Output: -1 ``` Ensure your implementation covers different edge cases, including when the array is empty or the key is not present.","solution":"def ternary_search(left, right, key, arr): Implement the ternary search algorithm. :param left: int - The starting index of the array segment :param right: int - The ending index of the array segment :param key: int - The value to be searched :param arr: list - A sorted list of integers :return: int - The index of the key if found, otherwise -1 while right >= left: third = (right - left) // 3 mid1 = left + third mid2 = right - third if arr[mid1] == key: return mid1 if arr[mid2] == key: return mid2 if key < arr[mid1]: right = mid1 - 1 elif key > arr[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Huffman Coding Implementation Problem You are provided with a partially implemented Huffman Coding algorithm. Your task is to complete the implementation by adding the code for decoding a Huffman encoded file. # Task Implement the `HuffmanReader` class which is used in the Huffman decoding process. Specifically, you need to complete the following methods: 1. `get_number_of_additional_bits_in_the_last_byte`: This method should return the number of additional bits appended to fill the last byte. 2. `load_tree`: This method should reconstruct the Huffman tree from the encoded data. 3. `get_bit`: This method should return the next bit from the input stream. 4. `get_byte`: This method should return the next byte from the input stream. # Input and Output Formats **Input**: The input to your program will be a Huffman encoded file (binary format) including the encoded tree and the encoded data. **Output**: The output should be the decoded file (binary format). # Examples 1. **Input File**: `encoded_file.bin` (contains binary data) 2. **Output File**: `decoded_file.txt` (contains the original text data) # Constraints * The input file will be a valid Huffman encoded file. * Characters in the file will be encoded using their byte values (0-255). * The input file size will be moderately large (up to a few MBs). # Implementation Requirements Here is a partially implemented HuffmanReader class for context: ```python class HuffmanReader: def __init__(self, file): self.file = file self.buffer = [] self.is_last_byte = False def get_number_of_additional_bits_in_the_last_byte(self) -> int: # TODO: Implement this method pass def load_tree(self) -> Node: # TODO: Implement this method pass def get_bit(self, buff_limit=8): # TODO: Implement this method pass def get_byte(self): # TODO: Implement this method pass ``` # Evaluation Criteria Your solution will be evaluated based on: 1. **Correctness**: Correct implementation of the decoding functionality. 2. **Efficiency**: Efficient handling of input and reconstruction of the Huffman tree. 3. **Robustness**: Handling edge cases and ensuring correctness for various input files. Good luck!","solution":"class HuffmanReader: def __init__(self, file): self.file = file self.buffer = [] self.is_last_byte = False self.file.seek(0, 2) self.file_size = self.file.tell() self.file.seek(0) def get_number_of_additional_bits_in_the_last_byte(self) -> int: Gets the number of padding bits added to the last byte. self.file.seek(self.file_size - 1) last_byte = self.file.read(1) number_of_additional_bits = ord(last_byte) return number_of_additional_bits def load_tree(self): Reconstructs the Huffman tree from the input file. Deserialize the Huffman tree using pre-order traversal. # Read character frequencies or use a predefined format # This depends on how the tree was serialized # For simplicity, assume each unique character and its frequency is stored # This should be replaced with the actual logic to rebuild the tree pass def get_bit(self, buff_limit=8): Returns the next bit from the input stream by maintaining a buffer of byte if required. if len(self.buffer) == 0: if self.file.tell() == self.file_size: return None current_byte = self.file.read(1) self.buffer = [int(bit) for bit in bin(ord(current_byte))[2:].zfill(buff_limit)] return self.buffer.pop(0) def get_byte(self): Gets the next byte from the input stream using the buffer for bits. byte = 0 for i in range(8): bit = self.get_bit() if bit is None: return None byte = (byte << 1) | bit return byte"},{"question":"# Question Given a stack, implement a function `remove_min` that removes the smallest value from the stack and returns the modified stack. **Function Signature**: ```python def remove_min(stack: list) -> list: ``` **Input**: - `stack`: A list representing the stack, where the last element in the list corresponds to the top of the stack. The stack can contain integers. **Output**: - Returns the modified stack after removing the smallest value. **Constraints**: 1. The stack may contain duplicate elements. 2. Do not use any built-in functions like `min()` to directly find the minimum value. 3. Do not use additional data structures (like heaps or sets) apart from another stack (in the form of a list). **Example**: ```python stack = [2, 8, 3, -6, 7, 3] print(remove_min(stack)) # Output should be [2, 8, 3, 7, 3] stack = [] print(remove_min(stack)) # Output should be [] stack = [5, 1, 3, 2, 1] print(remove_min(stack)) # Output should be [5, 3, 2, 1] ``` **Scenario**: You are developing a program that tracks recent events in a coroutine-style processing pipeline using a stack. Occasionally, you need to exclude the least significant event and continue processing. Implement this functionality to support removing the least significant event without utilizing external libraries for complex data manipulations. **Performance Requirements**: Handle the stack operations within linear time complexity relative to the number of elements. The space complexity should also remain linear due to the constraints specified.","solution":"def remove_min(stack: list) -> list: Removes the smallest value from the stack and returns the modified stack. if not stack: return stack # Find the minimum value using an extra stack min_val = float(\'inf\') temp_stack = [] while stack: top = stack.pop() if top < min_val: min_val = top temp_stack.append(top) # Push back everything except the minimum value found_min = False while temp_stack: top = temp_stack.pop() if top == min_val and not found_min: found_min = True else: stack.append(top) return stack"},{"question":"**Problem Statement:** You are tasked with writing a function to incrementally build a Roman Numeral Converter. In this task, you must complete a function that converts an integer in the range from 1 to 3999 into its Roman numeral representation. Your function should be efficient and operate within the given constraints. # Function Signature ```python def int_to_roman(num: int) -> str: ``` # Input: * An integer `num` satisfying `1 <= num <= 3999`. # Output: * A string representing the Roman numeral equivalent of the given integer. # Example: ```python assert int_to_roman(3) == \\"III\\" assert int_to_roman(58) == \\"LVIII\\" # Explanation: L = 50, V = 5, III = 3. assert int_to_roman(1994) == \\"MCMXCIV\\" # Explanation: M = 1000, CM = 900, XC = 90, IV = 4. ``` # Constraints: * The input integer will always be in the range from 1 to 3999. * You must complete the function without using any library functions for this specific conversion (e.g., no libraries that convert directly to Roman numerals). # Requirements: * Your solution must run in O(1) time complexity. * Your solution must use O(1) additional space. # Hints: * Break down the number based on its place values (thousands, hundreds, tens, units). * Use predefined lists to map digits to Roman numeral strings effectively.","solution":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. :param num: An integer in the range 1 <= num <= 3999 :return: The Roman numeral representation of the given integer val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syms = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_numeral = \\"\\" for i in range(len(val)): while num >= val[i]: roman_numeral += syms[i] num -= val[i] return roman_numeral"},{"question":"# Question: Implement RSA Encryption and Decryption You are tasked with implementing a simplified version of the RSA encryption algorithm. The goal is to practice the key aspects of RSA, including key generation, encryption, and decryption. You need to create functions for these tasks based on the detailed algorithm analysis provided. # Requirements: 1. Implement key generation with a helper function for generating prime numbers. 2. Implement functions for encrypting and decrypting data. 3. Ensure to handle edge cases such as invalid keys or non-prime numbers correctly. # Function Signatures: - `generate_key(k: int, seed: int = None) -> (int, int, int)` - **Input**: - `k`: The number of bits in modulus `n`. - `seed`: Optional seed for random number generator. - **Output**: - Tuple containing `(n, e, d)` where `n` is modulus, `e` is the public exponent, and `d` is the private exponent. - `encrypt(data: int, e: int, n: int) -> int` - **Input**: - `data`: The integer to be encrypted. - `e`: The public exponent. - `n`: The modulus. - **Output**: - Encrypted integer. - `decrypt(data: int, d: int, n: int) -> int` - **Input**: - `data`: The integer to be decrypted. - `d`: The private exponent. - `n`: The modulus. - **Output**: - Decrypted integer. # Constraints: - Assume `k >= 16` for practical usability. - Manage to handle large integers ensuring no overflow using appropriate Python libraries if needed. # Example Usage: ```python n, e, d = generate_key(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Note: - Use prime libraries and modular arithmetic functions to optimize performance. - Validate the correctness by testing with various key sizes and random seeds.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): Generate an odd integer randomly p = random.getrandbits(length) # Ensure p is odd if p % 2 == 0: p += 1 return p def generate_prime_number(length): Generate a prime number of length `length` p = 4 # Initialize with a number that is not prime while not isprime(p): p = generate_prime_candidate(length) return p def generate_key(bits, seed=None): if seed: random.seed(seed) p = generate_prime_number(bits // 2) q = generate_prime_number(bits // 2) n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # A commonly used value for e d = mod_inverse(e, phi_n) return (n, e, d) def encrypt(data, e, n): return pow(data, e, n) def decrypt(data, d, n): return pow(data, d, n)"},{"question":"# Maximum Sum of Contiguous Subarray You have been hired by a financial analytics company to develop a module that can determine the maximum profit (or minimum loss) over a given period from a sequence of daily financial transactions (profits and losses). Your task is to implement a function that determines the maximum sum of any contiguous subarray within a given array of integers, which represent daily profits and losses. Function Signature ```python def max_subarray(array: List[int]) -> int: ``` Input The function takes a single argument: * `array` (List[int]): A list of integers representing daily profits and losses. Output The function should return an integer: * The maximum sum of any contiguous subarray. Constraints * The array length (n) will be in the range [1, 10^5]. * The array elements will be in the range [-10^4, 10^4]. Example ```python array = [1, 2, -3, 4, 5, -7, 23] print(max_subarray(array)) # Output: 25 (subarray [4, 5, -7, 23]) ``` Notes * You may assume that the array will contain at least one element (no empty arrays). * Consider the possibility of all elements being negative when implementing your solution. * Aim for an optimal solution with a linear time complexity due to the potentially large size of the array.","solution":"def max_subarray(array): Returns the maximum sum of any contiguous subarray. :param array: List[int]: A list of integers representing daily profits and losses. :return: int: The maximum sum of any contiguous subarray. max_current = max_global = array[0] for num in array[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Context: You are a software engineer tasked with optimizing a web application\'s caching mechanism. The current caching system is causing performance degradation due to frequent collisions and inefficient resizing operations. # Task: Implement an EnhancedHashTable with the following functionality: 1. **Quadratic Probing Collision Resolution**: Instead of linear probing, use quadratic probing to resolve hash collisions. 2. **Load Factor-Based Resizing**: Resize the hash table when it’s 50% full instead of 66%. 3. **Separate Hash Function Utilization**: Use a more complex hash function to minimize collision probabilities. # Implementation: Write a class `EnhancedHashTable` extending the given `HashTable` class with the above enhancements. # Specifications: * **Methods to Implement**: 1. `put(key, value)`: Insert a key-value pair using quadratic probing. 2. `get(key)`: Retrieve the value associated with the key using quadratic probing. 3. `del_(key)`: Delete the key-value pair. 4. `__resize()`: Resize the hash table when it is 50% full. * **Custom Hash Function**: Implement a hash function that provides a more even distribution of keys. * **Constraints/Limitations**: * Keys are non-negative integers. * Ensure average-case time complexity remains O(1). # Example: ```python class EnhancedHashTable(HashTable): MIN_SIZE = 8 def __init__(self): super().__init__(self.MIN_SIZE) def put(self, key, value): # Override with quadratic probing and resizing at 50% full pass def get(self, key): # Override with quadratic probing pass def del_(self, key): # Override with quadratic probing pass def hash(self, key): # Override with a more complex hash function pass def _rehash(self, old_hash, i): # Implement quadratic probing rehashing # Formula: new_hash = (old_hash + i^2) % self.size pass def __resize(self): # Override resizing condition to trigger at 50% capacity pass ``` Implement your solution by correctly overriding the specified methods and ensuring efficient quadratic probing alongside a better hash function.","solution":"class EnhancedHashTable: MIN_SIZE = 8 def __init__(self, size=MIN_SIZE): self.size = size self.count = 0 self.table = [None] * self.size def _hash(self, key): return (key * 2654435761 % 2**32) % self.size def _rehash(self, old_hash, i): return (old_hash + i**2) % self.size def put(self, key, value): if self.count >= 0.5 * self.size: self.__resize() index = self._hash(key) i = 1 while self.table[index] is not None and self.table[index][0] != key: index = self._rehash(index, i) i += 1 if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) i = 1 while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = self._rehash(index, i) i += 1 return None def del_(self, key): index = self._hash(key) i = 1 while self.table[index] is not None: if self.table[index][0] == key: self.table[index] = None self.count -= 1 return index = self._rehash(index, i) i += 1 def __resize(self): old_table = self.table self.size = 2 * self.size self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: self.put(item[0], item[1])"},{"question":"# Scenario: You are working on a recommendation system that suggests articles to users based on the similarity of article content vectors. The content of each article is represented by a vector, and you need to compute the cosine similarity between these vectors to find articles that are most similar to each other. # Task: Implement a function `cosine_similarity` that computes the cosine similarity between two given vectors of the same length. # Requirements: 1. Your function should accept two input lists `vec1` and `vec2`. 2. The function should calculate the L2 norm of each vector. 3. Compute the dot product of the two vectors. 4. Calculate the cosine similarity by dividing the dot product by the product of the norms of the two vectors. 5. Handle cases where the input vectors are of different lengths by raising a `ValueError`. # Function Signature: ```python def cosine_similarity(vec1: list, vec2: list) -> float: pass ``` # Input: - Both `vec1` and `vec2` are lists of floats and have the same length, i.e., `1 <= len(vec1) == len(vec2) <= 1000`. # Output: - Return a float that represents the cosine similarity between the two vectors. # Constraints: - Elements of both vectors may include positive, negative, or zero values. # Examples: ```python assert abs(cosine_similarity([1, 1, 1], [1, 2, -1]) - 0.4714) < 0.0001 assert abs(cosine_similarity([0, 1], [1, 0]) - 0.0) < 0.0001 assert abs(cosine_similarity([1, 2, 3], [1, 2, 3]) - 1.0) < 0.0001 assert abs(cosine_similarity([-1, -1], [1, 1]) - (-1.0)) < 0.0001 ``` # Explanation: - In the first example, the cosine similarity between the vectors yields approximately 0.4714. - In the second example, the vectors are orthogonal, resulting in a cosine similarity of 0. - In the third example, the vectors are exactly the same, leading to a cosine similarity of 1. - In the fourth example, the vectors are opposites, resulting in a cosine similarity of -1. # Note: Ensure to provide evidence of your function following the example requirements and handle edge cases robustly.","solution":"from math import sqrt def cosine_similarity(vec1: list, vec2: list) -> float: if len(vec1) != len(vec2): raise ValueError(\\"The vectors are of different lengths.\\") dot_product = sum(v1 * v2 for v1, v2 in zip(vec1, vec2)) norm_vec1 = sqrt(sum(v1 ** 2 for v1 in vec1)) norm_vec2 = sqrt(sum(v2 ** 2 for v2 in vec2)) if norm_vec1 == 0 or norm_vec2 == 0: raise ValueError(\\"One of the vectors is a zero vector, which is not allowed for cosine similarity calculation.\\") return dot_product / (norm_vec1 * norm_vec2)"},{"question":"# Question: Find the Nth Digit in a Sequence You are tasked with implementing a function that returns the nth digit in the infinitely increasing sequence of natural numbers (1, 2, 3, ..., 10, 11, 12, ...). The sequence is constructed by concatenating the numbers continuously. Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Input * `n`: An integer (1 ≤ n ≤ 2^31 - 1) representing the position in the continuous sequence of natural numbers. Output * Return a single integer: the digit at position `n`. Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(15)) # Output: 2 ``` Constraints * Your function should be optimized for both time and space complexity. * Consider edge cases such as very small and very large values of `n`. Performance Requirements * The function should complete execution in logarithmic time relative to `n`.","solution":"def find_nth_digit(n: int) -> int: length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length return int(str(start)[(n - 1) % length])"},{"question":"# Resizable Hash Table Implementation Hash tables are fundamental data structures used to store key-value pairs. A proficient hash table implementation offers efficient average-case time complexity for insertion, retrieval, and deletion operations. In this task, you are to extend the provided `ResizableHashTable` to support a more intricate resizing strategy. # Objective Extend the `ResizableHashTable` to handle the following: 1. Implement a resizing strategy where the size of the table is adjusted both upwards and downwards. Specifically: * When the number of elements exceeds two-thirds of the table size, double the table\'s size. * When the number of elements drops below one-quarter of the table size, halve the table\'s size, but never shrink below the minimum size (8). 2. Ensure that the operations maintain the properties of a hash table—efficiently handling collisions and preserving key-value pairs during resizing. # Constraints * The minimum size of the table should always be 8. * Aim for maintaining average O(1) for insertion, lookup, and deletion operations. # Function to Implement You\'ll need to override the `put` and `del_` methods in `ResizableHashTable` class to incorporate the new resizing logic. ```python class ResizableHashTable(HashTable): MIN_SIZE = 8 def __init__(self): super().__init__(self.MIN_SIZE) def put(self, key, value): return super().put(key, value) # Your save and resize logic here def del_(self, key): return super().del_(key) # Your delete and resize logic here ``` # Detailed Instructions * **put(key, value)**: Insert the key-value pair. After insertion, if the table is two-thirds full, resize it to double its current size. * **del_(key)**: Remove the key-value pair. After deletion, if the table drops below one-quarter full, resize it to half its current size, but not smaller than the minimum size. # Expected Function Signature ```python class ResizableHashTable(HashTable): MIN_SIZE = 8 def __init__(self): super().__init__(self.MIN_SIZE) def put(self, key, value): # Your code here def del_(self, key): # Your code here ``` # Example ```python hash_table = ResizableHashTable() for i in range(10): hash_table.put(i, i*2) assert len(hash_table) == 10 for i in range(5): hash_table.del_(i) assert len(hash_table) == 5 ``` Be sure to handle edge cases and ensure the operations remain efficient even after resizing.","solution":"class HashTable: def __init__(self, size): self.size = size self.table = [None] * size self.count = 0 def put(self, key, value): idx = hash(key) % self.size initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.size if idx == initial_idx: raise Exception(\\"Table is full\\") self.table[idx] = (key, value) self.count += 1 def get(self, key): idx = hash(key) % self.size initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size if idx == initial_idx: break return None def del_(self, key): idx = hash(key) % self.size initial_idx = idx while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.count -= 1 self._rehash_from_index((idx + 1) % self.size) return idx = (idx + 1) % self.size if idx == initial_idx: break def _rehash_from_index(self, start_index): idx = start_index while self.table[idx] is not None: key, value = self.table[idx] self.table[idx] = None self.count -= 1 self.put(key, value) idx = (idx + 1) % self.size def __len__(self): return self.count class ResizableHashTable(HashTable): MIN_SIZE = 8 def __init__(self): super().__init__(self.MIN_SIZE) def put(self, key, value): super().put(key, value) if self.count > 2 * self.size // 3: self._resize(self.size * 2) def del_(self, key): super().del_(key) if self.count < self.size // 4 and self.size // 2 >= self.MIN_SIZE: self._resize(max(self.MIN_SIZE, self.size // 2)) def _resize(self, new_size): old_table = self.table self.table = [None] * new_size old_size = self.size self.size = new_size self.count = 0 for entry in old_table: if entry is not None: self.put(entry[0], entry[1])"},{"question":"You are in charge of a parking lot that currently has only one empty spot. You are given the initial state of the parking lot as well as the desired final state. Each car can only be moved into the empty spot. Your task is to determine the minimum number of moves required to reach the final state, and to print each intermediate state during this process. # Input - `initial`: a list of integers representing the initial state of the parking lot, where `0` represents the empty spot. - `final`: a list of integers representing the desired final state of the parking lot. # Output - Return an integer representing the number of moves required. - Print the sequence of each intermediate state. # Constraints - The length of `initial` will be between 2 and 1000 inclusive. - The lists `initial` and `final` will contain the same elements but in different orders. # Example ```python initial = [1, 2, 3, 0, 4] final = [0, 3, 2, 1, 4] ``` # Output ``` Steps = 4 Sequence: [0, 2, 3, 1, 4] [2, 0, 3, 1, 4] [2, 3, 0, 1, 4] [0, 3, 2, 1, 4] ``` Write a function `garage(initial, final)` to solve the problem. # Function Signature ```python def garage(initial: List[int], final: List[int]) -> int: pass ```","solution":"def garage(initial, final): Determine the minimum number of moves required to reach the final state and print each intermediate state during this process. initial = initial[:] steps = 0 print(\\"Initial:\\", initial) while initial != final: empty_index = initial.index(0) if final[empty_index] != 0: target_index = initial.index(final[empty_index]) initial[empty_index], initial[target_index] = initial[target_index], initial[empty_index] else: # Find first non-correct element to swap with empty spot for i in range(len(initial)): if initial[i] != final[i]: initial[empty_index], initial[i] = initial[i], initial[empty_index] break steps += 1 print(\\"Step {}: {}\\".format(steps, initial)) return steps"},{"question":"**Staircase Problem** You are climbing a staircase. It takes `steps` number of steps to reach the top. Each time you can either climb 1 or 2 steps. Your task is to determine the number of distinct ways you can climb to the top. # Function Signature ```python def count_ways_to_climb(steps: int) -> int: pass ``` # Input - `steps` (1 <= steps <= 10^3): an integer representing the number of steps to reach the top. # Output - Return an integer value representing the number of distinct ways to climb to the top. # Constraints - You can only climb either 1 step or 2 steps at a time. - `steps` is always a positive integer. # Example ```python assert count_ways_to_climb(2) == 2 # (1, 1) and (2) assert count_ways_to_climb(3) == 3 # (1, 1, 1), (1, 2), and (2, 1) assert count_ways_to_climb(4) == 5 # (1, 1, 1, 1), (1, 1, 2), (1, 2, 1), (2, 1, 1), and (2, 2) ``` # Note - Think about the recursive nature similar to the Fibonacci sequence. - Consider optimizing your solution to use O(1) space. # Additional Context Imagine you are a robot tasked with climbing stairs of varying heights. You want to program efficient algorithms into your robot guaranteeing it determines the number of possible distinct ways to climb any staircase size up to 1000 steps.","solution":"def count_ways_to_climb(steps: int) -> int: if steps == 1: return 1 elif steps == 2: return 2 prev2 = 1 # ways to climb 1 step prev1 = 2 # ways to climb 2 steps for _ in range(3, steps + 1): current = prev1 + prev2 prev2 = prev1 prev1 = current return prev1"},{"question":"# Connected Components in an Undirected Graph You have been provided with the adjacency list representation of an undirected graph, and your task is to determine the number of connected components in this graph using Depth-First Search (DFS). Input * The first line contains two integers, (N) and (M) — the number of nodes and the number of edges, respectively. * The next (M) lines contain two integers (u) and (v) each, indicating that there is an edge between node (u) and node (v). Output * Output a single integer, the number of connected components in the graph. Constraints * (1 leq N leq 10^5) * (0 leq M leq 2 times 10^5) * (1 leq u, v leq N) and (u neq v) * It is guaranteed that there are no duplicate edges. Example **Input:** ``` 8 5 1 2 2 3 4 5 6 7 6 8 ``` **Output:** ``` 3 ``` **Explanation:** The graph has three connected components: 1. Component 1: Nodes 1, 2, and 3 2. Component 2: Nodes 4 and 5 3. Component 3: Nodes 6, 7, and 8 Scoring * Full points will be awarded for correct solutions that also handle the edge cases and constraints efficiently. * Partial points may be awarded for solutions that work but are not optimized, or fail on some cases.","solution":"def number_of_connected_components(n, m, edges): from collections import defaultdict # Building the graph as adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Set to keep track of visited nodes visited = [False] * (n + 1) def dfs(node): stack = [node] while stack: current = stack.pop() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True stack.append(neighbor) # Initiating the count of connected components components = 0 for node in range(1, n + 1): if not visited[node]: components += 1 visited[node] = True dfs(node) return components"},{"question":"# Question: Implement a Nested Dictionary Flattener Given a dictionary that may contain nested dictionaries as values, write a function `flatten_dict` that returns a single flat dictionary. The keys in the flattened dictionary should be a concatenation of the keys from each level, separated by underscores. **Function Signature**: ```python def flatten_dict(nested_dict: dict) -> dict: pass ``` **Input**: - `nested_dict` (dict): A dictionary which may contain nested dictionaries. **Output**: - Returns a flattened dictionary. **Constraints**: - The dictionary values can be other dictionaries, lists, integers, strings, or any other types. - The concatenation key separator is an underscore `_`. **Performance Requirements**: - The function should handle deeply nested dictionaries efficiently without hitting the recursion limit in Python. **Examples**: ```python # Example 1 nested_dict_1 = { \'a\': 1, \'b\': { \'c\': 2, \'d\': { \'e\': 3, \'f\': 4 } } } assert flatten_dict(nested_dict_1) == { \'a\': 1, \'b_c\': 2, \'b_d_e\': 3, \'b_d_f\': 4 } # Example 2 nested_dict_2 = { \'x\': { \'y\': { \'z\': 5 } }, \'w\': 6 } assert flatten_dict(nested_dict_2) == { \'x_y_z\': 5, \'w\': 6 } # Example 3 nested_dict_3 = { \'a\': { \'b\': { \'c\': { \'d\': { \'e\': 5, \'f\': 6 } } } } } assert flatten_dict(nested_dict_3) == { \'a_b_c_d_e\': 5, \'a_b_c_d_f\': 6 } ``` **Edge Cases**: - Empty dictionary `{}` - Nested dictionaries with non-dict values like lists, which should be ignored in key concatenation. - Dictionaries containing non-dictionary values like integers, strings at any depth.","solution":"def flatten_dict(nested_dict: dict) -> dict: def flatten(current_dict, parent_key, result_dict): for key in current_dict: new_key = f\\"{parent_key}_{key}\\" if parent_key else key if isinstance(current_dict[key], dict): flatten(current_dict[key], new_key, result_dict) else: result_dict[new_key] = current_dict[key] return result_dict return flatten(nested_dict, \\"\\", {}) nested_dict_1 = { \'a\': 1, \'b\': { \'c\': 2, \'d\': { \'e\': 3, \'f\': 4 } } } nested_dict_2 = { \'x\': { \'y\': { \'z\': 5 } }, \'w\': 6 } nested_dict_3 = { \'a\': { \'b\': { \'c\': { \'d\': { \'e\': 5, \'f\': 6 } } } } } print(flatten_dict(nested_dict_1)) # Expected: {\'a\': 1, \'b_c\': 2, \'b_d_e\': 3, \'b_d_f\': 4} print(flatten_dict(nested_dict_2)) # Expected: {\'x_y_z\': 5, \'w\': 6} print(flatten_dict(nested_dict_3)) # Expected: {\'a_b_c_d_e\': 5, \'a_b_c_d_f\': 6}"},{"question":"# Graph Traversal Analysis and Implementation Objective You are given an unweighted, undirected graph that can be represented as an adjacency list. Your task is to implement both Depth First Search (DFS) and Breadth First Search (BFS) algorithms to traverse the graph. Additionally, you need to extend the provided implementations to return not only the visited nodes but also the order in which the nodes were visited. Problem Statement Implement two functions: `dfs_traverse_with_order(graph, start)` and `bfs_traverse_with_order(graph, start)` which use DFS and BFS respectively, to traverse the graph starting from a given node and return the order of node visits as a list. Input The input to both functions will be: 1. `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. 2. `start`: The starting node for the traversal. Output Both functions should return a list of nodes representing the order in which the nodes are visited. Constraints 1. The graph is undirected, and all edges are bidirectional. 2. The starting node always exists in the graph. 3. The graph may have disconnected components, but traversal should consider only the connected component containing the start node. 4. Nodes are identified by any hashable data type (string, integer, etc.). Example ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'A\', \'D\', \'E\'], \'C\': [\'A\', \'F\'], \'D\': [\'B\'], \'E\': [\'B\', \'F\'], \'F\': [\'C\', \'E\'] } start = \'A\' assert dfs_traverse_with_order(graph, start) == [\'A\', \'C\', \'F\', \'E\', \'B\', \'D\'] # One possible valid DFS order assert bfs_traverse_with_order(graph, start) == [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'] # One possible valid BFS order ``` Task 1. Write the function `dfs_traverse_with_order(graph, start)`. 2. Write the function `bfs_traverse_with_order(graph, start)`. # Requirements - Your solution should have a time complexity of O(V + E). - Use a stack explicitly in DFS if not implementing the recursive version. - Use a queue for BFS traversal. Notes - Consider edge cases such as disconnected nodes not included in the traversal result. - Test your solution for various graph structures to ensure correctness.","solution":"def dfs_traverse_with_order(graph, start): Perform Depth First Search (DFS) traversal on the graph and return nodes in the order visited. visited = set() order = [] def dfs(node): visited.add(node) order.append(node) for neighbor in graph.get(node, []): if neighbor not in visited: dfs(neighbor) dfs(start) return order def bfs_traverse_with_order(graph, start): Perform Breadth First Search (BFS) traversal on the graph and return nodes in the order visited. from collections import deque visited = set() order = [] queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) order.append(node) for neighbor in graph.get(node, []): if neighbor not in visited: queue.append(neighbor) return order"},{"question":"Scenario You are working on a new digital library system. Books are identified uniquely by digit sequences assigned serially from 1 onward. Task Write a Python function `find_nth_digit_in_series(n)` that returns the nth digit in this infinite sequence of concatenated natural numbers (\\"123456789101112...\\") where `n` thrives in the range `1 ≤ n ≤ 10^9`. Function Signature: ```python def find_nth_digit_in_series(n: int) -> int: :param n: an integer, the position in the infinite sequence \'123456789101112...\' :return: the nth digit in the infinite sequence pass ``` # Input - An integer `n` representing the position in the infinite sequence. # Output - An integer representing the nth digit in the infinite sequence. # Constraints - `1 ≤ n ≤ 10^9` # Example 1. find_nth_digit_in_series(3) should return 3: * The sequence is \\"12345678910...\\", and the third digit is 3. 2. find_nth_digit_in_series(11) should return 0: * The sequence is \\"12345678910111213...\\", and the 11th digit which falls in the number 10 is 0. 3. find_nth_digit_in_series(15) should return 2: * The sequence is \\"123456789101112131415...\\", and the 15th digit is 2. Notes: - Your solution should be efficient with a time complexity better than O(n). - Avoid any unnecessary memory usage to comply with the time/memory limits.","solution":"def find_nth_digit_in_series(n: int) -> int: Find the nth digit in an infinite sequence of concatenated natural numbers: \'123456789101112...\' :param n: An integer representing the position in the infinite sequence. :return: The nth digit in the infinite sequence. length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n - 1) // length s = str(start) return int(s[(n - 1) % length])"},{"question":"You are tasked with implementing a word dictionary that supports adding new words and searching for existing words using regular expressions with wildcard characters. Function Implementations to Write: 1. **add_word(self, word: str) -> None**: Adds a word into the data structure. 2. **search(self, word: str) -> bool**: Returns whether the word (including wildcards) exists in the data structure. # Requirements: - Wildcard character \\".\\" can match any letter. - Ensure efficient addition and search operations. # Constraints: - Words consist only of lowercase alphabets. - Words can be up to length 50000. - The number of operations (add/search) can be up to 100000. Example: ```python dictionary = WordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") assert dictionary.search(\\"pad\\") == False assert dictionary.search(\\"bad\\") == True assert dictionary.search(\\".ad\\") == True assert dictionary.search(\\"b..\\") == True ```","solution":"import re class WordDictionary: def __init__(self): Initialize the data structure here. self.words = [] def add_word(self, word: str) -> None: Adds a word into the data structure. self.words.append(word) def search(self, word: str) -> bool: Returns whether the word (including wildcards) exists in the data structure. pattern = re.compile(word) for w in self.words: if pattern.fullmatch(w): return True return False"},{"question":"# Climbing Stairs with Custom Steps You are climbing a staircase that requires `steps` number of steps to reach the top. Each time, you can choose to climb a step according to a custom set of allowed steps given in an array `allowed_steps`. Implement a function that computes the number of distinct ways to reach the top of the staircase. Function Signature ```python def climb_stairs_custom(steps, allowed_steps): :param steps: int - number of steps to reach the top :param allowed_steps: List[int] - list of allowed steps that can be climbed at a time :return: int - number of distinct ways to reach the top ``` Input and Output Formats **Input:** - `steps`: an integer, representing the number of steps to the top of the staircase. (1 ≤ steps ≤ 10^5) - `allowed_steps`: a list of integers, where each integer represents a number of steps you can choose to climb at a time. (1 ≤ len(allowed_steps) ≤ 100, 1 ≤ allowed_steps[i] ≤ 10) **Output:** - An integer representing the number of distinct ways to reach the top of the staircase using only the steps in `allowed_steps`. Example **Example 1:** ```python steps = 5 allowed_steps = [1, 2] result = climb_stairs_custom(steps, allowed_steps) # Expected Output: 8 # Explanation: The number of ways to reach step 5 are: # 1+1+1+1+1, 1+1+1+2, 1+1+2+1, 1+2+1+1, 2+1+1+1, 1+2+2, 2+1+2, 2+2+1 ``` **Example 2:** ```python steps = 3 allowed_steps = [1, 3, 5] result = climb_stairs_custom(steps, allowed_steps) # Expected Output: 2 # Explanation: The number of ways to reach step 3 are: # 1+1+1, 3 ``` Constraints: - Optimize your solution to handle up to the maximum constraints efficiently. - Focus on using dynamic programming to minimize both time and space complexity. Additional Challenge: - Handle edge cases where some values in `allowed_steps` are greater than `steps`.","solution":"def climb_stairs_custom(steps, allowed_steps): Calculate the number of ways to reach the top of a staircase with given steps. :param steps: int - number of steps to reach the top :param allowed_steps: List[int] - list of allowed steps that can be climbed at a time :return: int - number of distinct ways to reach the top # Initialize a list to store the number of ways to reach each step dp = [0] * (steps + 1) dp[0] = 1 # There\'s one way to reach step 0: doing nothing # Compute the number of ways to reach each step from 1 to steps for i in range(1, steps + 1): for step in allowed_steps: if i - step >= 0: dp[i] += dp[i - step] return dp[steps]"},{"question":"# Scenario An online gaming event requires you to build a tool to determine the number of ways players can form teams. The calculation is based on the binomial coefficient, which determines the number of ways to choose `k` items from `n` without regards to the order of selection. Given the potential for large numbers, this calculation needs to be performed efficiently. # Question Implement a function `binomial_coefficient` that calculates the binomial coefficient C(n, k) efficiently using both recursion and memoization to avoid redundant calculations. # Function Signature ```python def binomial_coefficient(n: int, k: int) -> int: pass ``` # Input - `n` (integer): A non-negative integer representing the total number of items. - `k` (integer): A non-negative integer representing the number of items to choose from `n`. # Output - (integer): The binomial coefficient C(n, k). # Constraints - 0 <= k <= n <= 500 - The function should handle large values and be efficient in terms of both time and space complexity. - Use memoization to improve performance. # Example Usage ```python print(binomial_coefficient(5, 0)) # Output: 1 print(binomial_coefficient(8, 2)) # Output: 28 print(binomial_coefficient(500, 300)) # Output: Should calculate efficiently without stack overflow or excessive computation time. ``` # Additional Information - The function should raise a `ValueError` if `k` is greater than `n`. Implementation Notes - Utilize a dictionary or other data structure to store previously calculated values to avoid repeat calculations. - Consider edge cases such as `k` being 0 or equal to `n`, which should immediately return 1. - Test your code with small and large values of `n` and `k` to ensure efficiency.","solution":"def binomial_coefficient(n: int, k: int) -> int: if k > n: raise ValueError(\\"k cannot be greater than n\\") memo = {} def _binomial_coefficient(n, k): if k == 0 or k == n: return 1 if (n, k) in memo: return memo[(n, k)] memo[(n, k)] = _binomial_coefficient(n-1, k-1) + _binomial_coefficient(n-1, k) return memo[(n, k)] return _binomial_coefficient(n, k)"},{"question":"# Question You are required to write a function that implements an optimized version of the given mode calculation algorithm. Your function should be able to handle large datasets with many unique elements efficiently. Furthermore, it should also address edge cases and performance bottlenecks effectively. Function Signature ```python def find_modes(nums: list) -> list: pass ``` Input and Output Formats * **Input**: A list of integers `nums` which could be empty or have any length from 0 to 10^6. * **Output**: A list of integers representing the most frequent elements. If no elements are present, return an empty list. Constraints - You need to ensure that the function performs efficiently even on large datasets. - Ensure that edge cases, such as empty arrays and arrays with all unique elements, are handled gracefully. Example 1. Example 1: * Input: `[]` * Output: `[]` 2. Example 2: * Input: `[3, 3, 2, 2, 1]` * Output: `[3, 2]` 3. Example 3: * Input: `[7]` * Output: `[7]`","solution":"from collections import Counter def find_modes(nums: list) -> list: Returns a list of the most frequent elements (modes). If no elements are present, return an empty list. if not nums: return [] # Count the frequencies of each element counts = Counter(nums) # Find the maximum frequency max_freq = max(counts.values()) # Collect all elements with the maximum frequency modes = [num for num, freq in counts.items() if freq == max_freq] return modes"},{"question":"You are tasked with implementing an enhanced word dictionary that supports adding words and searching them with potential wildcard characters (represented as \\".\\"). Objectives 1. Implement a data structure that efficiently supports adding words and searching for words, where the search can involve wildcard characters. Requirements 1. **Function 1**: `add_word(word: str) -> None` - Adds a word to the data structure. 2. **Function 2**: `search(word: str) -> bool` - Searches for a word in the data structure. The word can include \\".\\" as a wildcard character where \\".\\" can represent any letter. Input and Output Formats - **add_word**: - **Input**: A single string `word` (1 <= |word| <= 50). - **Output**: None. - **search**: - **Input**: A single string `word` (1 <= |word| <= 50) which can include \\".\\". - **Output**: Returns `True` if the word exists in the dictionary, otherwise `False`. Constraints and Notes - The Trie should be optimized to handle large datasets with potentially many common prefixes. - Optimize for memory usage while ensuring fast search operations. - Ensure the search function correctly handles wildcard characters for potential matches. Example ```python # Example usage wd = WordDictionary() wd.add_word(\\"bad\\") wd.add_word(\\"dad\\") wd.add_word(\\"mad\\") print(wd.search(\\"pad\\")) # Output: False print(wd.search(\\"bad\\")) # Output: True print(wd.search(\\".ad\\")) # Output: True print(wd.search(\\"b..\\")) # Output: True ``` Implement the `WordDictionary` class with the specified methods: ```python class WordDictionary: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ```","solution":"class WordDictionary: def __init__(self): self.trie = {} def add_word(self, word: str) -> None: node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True # Mark the end of a word def search(self, word: str) -> bool: return self._search_in_node(word, self.trie) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \'.\': for key in node: if key != \'#\' and self._search_in_node(word[i+1:], node[key]): return True return False else: if char not in node: return False node = node[char] return \'#\' in node"},{"question":"You are asked to extend the functionality of a library that converts Arabic numerals into Roman numerals. The given function handles numbers from 1 to 3999 in constant time. Your task is to implement a function that can handle a similar problem: converting Roman numerals back to integers. The input is guaranteed to be a valid Roman numeral within the range from I (1) to MMMCMXCIX (3999). # Function Signature ```python def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. :param s: A string representing a Roman numeral. :return: An integer corresponding to the Roman numeral. ``` # Input - `s`: A string representing a valid Roman numeral (1 ≤ s ≤ 3999) # Output - An integer corresponding to the provided Roman numeral. # Constraints - The input Roman numeral is valid and within the range [I, MMMCMXCIX]. # Example ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` # Guidelines - Handle all cases of Roman numeral subtraction. - Ensure that your solution runs efficiently within the given constraints. # Tips - Iterating through the string and using a mapping of Roman numerals to their integer values may prove useful. - Carefully handle the logic for subtractive combinations like \'IV\', \'IX\', etc.","solution":"def roman_to_int(s: str) -> int: Convert a Roman numeral to an integer. :param s: A string representing a Roman numeral. :return: An integer corresponding to the Roman numeral. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): value = roman_to_value[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Scenario You have been tasked with improving a communication protocol that ensures transmitted data uses alternating patterns of bits to reduce the likelihood of simple bit errors disrupting the pattern detection. Given this, your job is to implement a function that verifies if a given positive integer\'s binary representation consists of alternating bits. # Task Write two functions to check if an integer `n` has alternating bits in its binary representation. Function 1: `has_alternative_bit(n)` - **Input**: A positive integer `n`. - **Output**: Boolean value `True` if `n` has alternating bits, otherwise `False`. - **Constraints**: - Must iterate over each bit and compare adjacent bits. - **Description**: - Extract each bit of `n` and compare it with its adjacent bit until all bits are checked. Return `False` if two adjacent bits are the same; otherwise, return `True`. Function 2: `has_alternative_bit_fast(n)` - **Input**: A positive integer `n`. - **Output**: Boolean value `True` if `n` has alternating bits, otherwise `False`. - **Constraints**: - Must use bitwise operations for constant time complexity. - **Description**: - Use predefined bitwise masks to compare the bits of `n` to ensure it follows alternating bit patterns. Return `True` if `n` matches any pattern of alternating bits, otherwise `False`. # Example ```python assert has_alternative_bit(5) == True # Binary: 101 assert has_alternative_bit(7) == False # Binary: 111 assert has_alternative_bit(10) == True # Binary: 1010 assert has_alternative_bit_fast(5) == True assert has_alternative_bit_fast(7) == False assert has_alternative_bit_fast(10) == True ``` # Performance Requirements - `has_alternative_bit` should have a time complexity of O(number of bits in `n`). - `has_alternative_bit_fast` should have a time complexity of O(1).","solution":"def has_alternative_bit(n): Check if n has alternating bits by iterating over each bit and comparing adjacent bits. prev_bit = n & 1 n >>= 1 while n > 0: curr_bit = n & 1 if curr_bit == prev_bit: return False prev_bit = curr_bit n >>= 1 return True def has_alternative_bit_fast(n): Check if n has alternating bits using bitwise operations for constant time complexity. x = n ^ (n >> 1) return (x & (x + 1)) == 0"},{"question":"**Missing Number Detection** Given a list of unique integers `nums` in the range `[0..n]` without any gaps larger than one, design a function `find_missing_number(nums)` to find and return the missing number. If the list is complete (all numbers in `[0..n]` are present), return the next integer `n + 1`. # Input - `nums` (List[int]): A list of unique integers in range `[0..n]`. # Output - `int`: The missing number or `n + 1` if the sequence is complete. # Constraints - All integers in `nums` are unique and within the range `[0..n]`. - List length will be `n` where `n` is the maximum number in `nums`. # Performance Requirements - Time Complexity: O(n) - Space Complexity: O(1) # Example ```python # Example 1 nums = [4, 1, 3, 0, 6, 5, 2] # Explanation: 0 to 6 cover 7 numbers, but 4 is missing, so the next expected number is 7. # Output: 7 # Example 2 nums = [0, 1, 2, 3] # Explanation: The sequence contains all numbers 0..3. So the next expected number is 4. # Output: 4 ``` # Function Signature ```python def find_missing_number(nums: List[int]) -> int: # Your code here ``` # Notes - Ensure to properly handle all edge cases like empty list or list containing all the numbers in range.","solution":"def find_missing_number(nums): Given a list of unique integers nums in the range [0..n], return the missing number or n + 1 if the sequence is complete. n = len(nums) expected_sum = n * (n + 1) // 2 actual_sum = sum(nums) if expected_sum == actual_sum: return n + 1 else: return expected_sum - actual_sum"},{"question":"# Objective: Design a coding question where students need to demonstrate their understanding of dynamic programming. The objective is to write a function that determines the number of ways an input integer can be decomposed into sums of smaller integers. # Scenario You are a programmer tasked with solving a combinatorics problem. The problem is about finding the number of ways a given positive integer `N` can be decomposed into sums of other non-negative integers. # Requirements: - Implement a function `int_divide(decompose)` where `decompose` is a single positive integer. - Your function should return the total number of integer partitions of the input integer. # Example Input: ```python int_divide(4) ``` Output: ```python 5 ``` Explanation: 4 can be decomposed into: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Input: ```python int_divide(7) ``` Output: ```python 15 ``` Explanation: 7 can be decomposed into 15 different ways. # Constraints: 1. The input `decompose` will be a positive integer. 2. Ensure your function runs efficiently for values up to 1000. # Coding Task: Implement the following function in Python: ```python def int_divide(decompose): Find number of decompositions from `decompose`. Arguments: decompose : int : positive integer to be decomposed. Returns: int : number of decompositions. ``` Use dynamic programming to compute the result efficiently. Avoid using recursive approaches without memoization to prevent excessive computation time.","solution":"def int_divide(decompose): Find number of decompositions from `decompose`. Arguments: decompose : int : positive integer to be decomposed. Returns: int : number of decompositions. dp = [0] * (decompose + 1) dp[0] = 1 for i in range(1, decompose + 1): for j in range(i, decompose + 1): dp[j] += dp[j - i] return dp[decompose]"},{"question":"# Combinatorial Function Implementation Given that combinations (nCr) are vital in many areas such as statistical calculations, probability, and combinatorics, your task is to implement an efficient function to calculate combinations using dynamic programming. Your function should demonstrate the ability to handle large inputs effectively. **Function Specification:** * Function Name: `calculate_combinations` * Input: Two integers `n` and `r` (0 <= r <= n) * Output: The number of ways to choose `r` items from `n` items. **Performance Requirements:** * Time Complexity: Expected to be O(n * r) * Space Complexity: Can use additional space, but should be within reasonable bounds (O(n * r)) **Constraints:** * 0 <= r <= n <= 1000 * The function should be able to handle large input values efficiently. **Example:** ```python assert calculate_combinations(5, 2) == 10 # There are 10 ways to choose 2 items from 5. assert calculate_combinations(6, 3) == 20 # There are 20 ways to choose 3 items from 6. assert calculate_combinations(10, 0) == 1 # There is exactly 1 way to choose 0 items from any set. assert calculate_combinations(10, 10) == 1 # There is exactly 1 way to choose all items from the set. ``` **Scenario:** You are developing a part of a system that performs statistical analysis over different datasets. One of the tasks requires calculating combinations frequently, for which efficiency is crucial due to the large size of these datasets. Implement the function in an efficient manner using dynamic programming to meet the performance requirements.","solution":"def calculate_combinations(n, r): Returns the number of ways to choose r items from n items. Uses dynamic programming to efficiently compute the combinations. if r > n: return 0 if r == 0 or r == n: return 1 # Initialization of a 2D list for storing results of subproblems dp = [[0] * (r + 1) for _ in range(n + 1)] # Base cases for i in range(n + 1): for j in range(min(i, r) + 1): # Base case: If j is 0 or i is equal to j if j == 0 or j == i: dp[i][j] = 1 else: dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j] return dp[n][r]"},{"question":"You are given an implementation of a Segment Tree, a powerful data structure that supports efficient range queries and updates on an array. We would like you to extend its functionality by implementing additional operations as described below. # Requirements: 1. **Prefix Sum Query**: Implement a function `prefix_sum(u)` that returns the sum of elements from the start of the array up to index `u` (inclusive). 2. **Range Update**: Modify the `update` function to support range updates, where instead of updating a single element, you will update all elements within a specified range `[l, r]` by setting each element to a new value `v`. # Input Format: * The segment tree is constructed with an initial array of integers and uses the addition function for range queries. * You will receive multiple operations to perform, which could be either of the type \\"QUERY\\", \\"UPDATE\\", or \\"PREFIX_SUM\\". * \\"QUERY l r\\" will request the sum of elements in the range `[l, r]`. * \\"UPDATE l r v\\" will set all elements from index `l` to `r` to value `v`. * \\"PREFIX_SUM u\\" will return the sum of elements from the start of the array up to index `u`. # Expected Functions: Implement the methods: * `def prefix_sum(self, u: int) -> int:` * Modify `def update(self, l: int, r: int, v: int) -> None:` # Constraints: * 1 <= N <= 10^5, where N is the length of the array. * 1 <= q <= 10^5, where q is the number of operations. # Example: ```python arr = [1, 2, 3, 4, 5] seg_tree = SegmentTree(arr, lambda a, b: a + b) print(seg_tree.query(0, 4)) # Returns: 15 seg_tree.update(1, 3, 10) # Array becomes: [1, 10, 10, 10, 5] print(seg_tree.query(0, 4)) # Returns: 36 print(seg_tree.prefix_sum(2)) # Returns: 21 ``` # Implementation Note: Ensure that the update and prefix_sum functions work efficiently within the given constraints.","solution":"class SegmentTree: def __init__(self, data, function): self.n = len(data) self.function = function self.tree = [0] * (2 * self.n) self.build(data) def build(self, data): # Initialize leaves for i in range(self.n): self.tree[self.n + i] = data[i] # Initialize internal nodes for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, l, r, v): l += self.n r += self.n + 1 # to make range inclusive for i in range(l, r): self.tree[i] = v # Update internal nodes l //= 2 r = (r - 1) // 2 while l > 0: self.tree[l] = self.function(self.tree[2 * l], self.tree[2 * l + 1]) self.tree[r] = self.function(self.tree[2 * r], self.tree[2 * r + 1]) l //= 2 r //= 2 def query(self, l, r): l += self.n r += self.n + 1 # to make range inclusive res = 0 while l < r: if l % 2: res += self.tree[l] l += 1 if r % 2: r -= 1 res += self.tree[r] l //= 2 r //= 2 return res def prefix_sum(self, u): # Query from start to index u return self.query(0, u)"},{"question":"# Priority Queue Implementation Scenario You are tasked with implementing a priority queue to handle tasks. Each task needs to be processed based on its priority. A linear array is used for the priority queue, where tasks (or items) with numeric priorities are inserted in descending priority order. Problem Statement Implement a `PriorityQueue` class with the following methods: 1. `__init__(items=None, priorities=None)`: Initializes the priority queue with given items and their respective priorities. 2. `size()`: Returns the size of the priority queue. 3. `push(item, priority=None)`: Inserts an item into the priority queue. If the priority is not given, the priority is set to the item value. 4. `pop()`: Removes and returns the item with the highest priority. Input * Method `__init__` takes an optional list of items and an optional list of corresponding priorities. * Method `push` takes an item and an optional priority. * Method `pop` does not take any input. Output * Method `size` returns the current size of the priority queue. * Method `push` does not return any value. * Method `pop` returns the item with the highest priority. Constraints * If an item is pushed without specifying a priority, the item\'s value will be used as its priority. * The priority queue must store elements in descending order based on priority. Example ```python pq = PriorityQueue() pq.push(4) pq.push(2, priority=10) pq.push(7, priority=5) print(pq.size()) # Output: 3 print(pq.pop()) # Output: 2 print(pq.pop()) # Output: 7 print(pq.pop()) # Output: 4 ``` Implementation Notes 1. Make sure to handle edge cases such as popping from an empty queue. 2. Keep in mind that insertion has a time complexity of O(n) while extraction has O(1).","solution":"class PriorityQueue: def __init__(self, items=None, priorities=None): self.queue = [] if items and priorities: for item, priority in zip(items, priorities): self.push(item, priority) def size(self): return len(self.queue) def push(self, item, priority=None): if priority is None: priority = item inserted = False for i in range(len(self.queue)): if priority > self.queue[i][1]: # Higher priority value means higher priority self.queue.insert(i, (item, priority)) inserted = True break if not inserted: self.queue.append((item, priority)) def pop(self): if self.size() > 0: return self.queue.pop(0)[0] # Pop the item with the highest priority else: raise IndexError(\\"pop from an empty priority queue\\")"},{"question":"# Decoding Ways of Encrypted Message Problem Statement: A message containing letters from A-Z is encoded to numbers using the following rule: - \'A\' -> 1, \'B\' -> 2, ..., \'Z\' -> 26. Given an encoded message containing digits, write a function `num_decodings_optimized(s: str) -> int` that determines the total number of ways to decode it. **Function Signature:** ```python def num_decodings_optimized(s: str) -> int: ``` Input: - A string `s` of length 1 ≤ |s| ≤ 100 containing digits from \'0\' to \'9\'. Output: - An integer representing the total number of unique decodings possible. Constraints: - The input string will not start with \'0\'. Examples: - Input: \\"12\\" - Output: 2 - Explanation: \'12\' can be decoded as \\"AB\\" (1, 2) or \\"L\\" (12). - Input: \\"226\\" - Output: 3 - Explanation: \'226\' can be decoded as \\"BZ\\" (2, 26), \\"VF\\" (22, 6), or \\"BBF\\" (2, 2, 6). - Input: \\"06\\" - Output: 0 - Explanation: Leading \'0\' invalidates the decoding. Explanation: - Use a dynamic programming approach to iteratively count valid decodings. - Handle edge cases for sequences starting with \'0\' and invalid sequences like \'30\', \'40\', etc. Performance: - Ensure the code runs in O(n) time complexity and use constant space or O(n) space optimally. Notes: - You may use the existing function headers and build upon them. - Keep in mind performance and edge cases while designing your solution.","solution":"def num_decodings_optimized(s: str) -> int: if not s or s[0] == \'0\': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): one_digit = int(s[i-1:i]) two_digits = int(s[i-2:i]) if 1 <= one_digit <= 9: dp[i] += dp[i-1] if 10 <= two_digits <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"# Coding Task: Optimized Array Rotation Problem Statement: You are given an array of integers, and you need to rotate the array to the right by a given number of steps, k. You need to implement an efficient solution to perform this rotation. Requirements: 1. Implement the function `optimized_rotate(array: List[int], k: int) -> None`. 2. Modify the input array in-place without using extra space for another array. 3. The function should handle various edge cases gracefully, such as when k is zero, negative, or larger than the array\'s length. Input and Output Format: * **Input**: - `array`: A list of integers (possible empty array). - `k`: An integer representing the number of steps to rotate the array. * **Output**: - The function should not return anything; it should modify the input array in place. Constraints: * The array should only be modified in place. * The input list should handle up to 10^5 elements. * k can be larger than the length of the array or negative. Example: ```python # Example 1 arr = [1, 2, 3, 4, 5, 6, 7] optimized_rotate(arr, 3) print(arr) # Output: [5, 6, 7, 1, 2, 3, 4] # Example 2 arr = [-1, -100, 3, 99] optimized_rotate(arr, 2) print(arr) # Output: [3, 99, -1, -100] # Example 3 arr = [1, 2, 3] optimized_rotate(arr, 4) print(arr) # Output: [3, 1, 2] # Example 4 arr = [1, 2, 3] optimized_rotate(arr, -2) print(arr) # Output: [2, 3, 1] # Example 5 arr = [1] optimized_rotate(arr, 10) print(arr) # Output: [1] ``` Be sure your function has clear and efficient handling of the `k` rotations even when `k` is larger than the array\'s length or negative.","solution":"from typing import List def optimized_rotate(array: List[int], k: int) -> None: Rotates the array to the right by k steps in-place. n = len(array) if n == 0: return # Normalize k to be within the range of 0 to n-1 k = k % n # Rotate the array using reverse strategy def reverse(sub_array, start, end): while start < end: sub_array[start], sub_array[end] = sub_array[end], sub_array[start] start += 1 end -= 1 # Step 1: Reverse the whole array reverse(array, 0, n-1) # Step 2: Reverse the first k elements reverse(array, 0, k-1) # Step 3: Reverse the remaining n-k elements reverse(array, k, n-1)"},{"question":"# Question: Finding the Lowest Common Ancestor in a Binary Search Tree You are given a binary search tree (BST) and two nodes within this tree. Your task is to implement a function that finds the lowest common ancestor (LCA) of these two nodes. The definition of LCA on Wikipedia: > “The lowest common ancestor is defined between two nodes **v** and **w** as the lowest node in **T** that has both **v** and **w** as descendants (where we allow a node to be a descendant of itself).” Input: * `root`: A TreeNode representing the root of the BST. * `p` and `q`: Two TreeNode objects whose LCA needs to be found. Output: * Return the TreeNode representing the lowest common ancestor of `p` and `q`. Constraints: 1. All TreeNode values are unique. 2. Both `p` and `q` are different and exist in the BST. Example: Consider the following binary search tree: ``` _______6______ / ___2__ ___8__ / / 0 _4 7 9 / 3 5 ``` * **Example 1**: * Input: `root = 6, p = 2, q = 8` * Output: `6` * Explanation: The LCA of nodes 2 and 8 is 6. * **Example 2**: * Input: `root = 6, p = 2, q = 4` * Output: `2` * Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself. Function Signature: ```python def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: ``` Additional Notes: 1. It\'s guaranteed that both `p` and `q` are different and they exist in the BST. 2. You do not need to handle the case where the tree is empty.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def lowest_common_ancestor(root: TreeNode, p: TreeNode, q: TreeNode) -> TreeNode: Function to find the lowest common ancestor of two nodes in a binary search tree. Args: root (TreeNode): The root of the BST. p (TreeNode): The first node. q (TreeNode): The second node. Returns: TreeNode: The lowest common ancestor of nodes p and q. while root: # If both p and q are greater than root, then LCA lies in the right subtree if p.val > root.val and q.val > root.val: root = root.right # If both p and q are less than root, then LCA lies in the left subtree elif p.val < root.val and q.val < root.val: root = root.left else: # We have found the split point, i.e., the LCA node return root"},{"question":"Longest Common Subsequence Scenario You are working on a file comparison tool that needs to find similarities between two text files. One of the key functionalities is to determine the longest common subsequence (LCS) between two given strings. Your task is to implement this functionality using dynamic programming. Task Implement a function `longest_common_subsequence(s_1, s_2)` that takes in two strings `s_1` and `s_2`, and returns the length of the longest common subsequence. Specifications * Expected input: * `s_1`: a string containing lowercase English alphabets (e.g., \\"abcdgh\\"). * `s_2`: another string containing lowercase English alphabets (e.g., \\"aedfhr\\"). * Expected output: * An integer representing the length of the longest common subsequence (LCS). Constraints * 1 <= len(s_1), len(s_2) <= 1000 Implementation Steps 1. Create a matrix `mat` of size `(len(s_1) + 1) x (len(s_2) + 1)` initialized to 0. 2. Loop through each character of both strings. 3. If characters match, update the matrix value at that position. 4. If characters don\'t match, take the maximum value from the cell above or to the left. 5. The final value at `mat[len(s_1)][len(s_2)]` will be the length of the LCS. Example ```python Input: s_1 = \'abcdgh\' s_2 = \'aedfhr\' Output: 3 Explanation: The longest subsequence common to both strings is \\"adh\\". ``` Function Signature ```python def longest_common_subsequence(s_1, s_2): :param s_1: string :param s_2: string :return: int # your code here ```","solution":"def longest_common_subsequence(s_1, s_2): Returns the length of the longest common subsequence between s_1 and s_2. m, n = len(s_1), len(s_2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s_1[i - 1] == s_2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Quick Sort Implementation with Median-of-Three Pivot Selection **Scenario**: The company you are working for has data analysis software that needs to efficiently sort large datasets. Your manager has noted that the conventional Quick Sort algorithm sometimes performs poorly on nearly sorted data and wants you to implement an optimized version using the \\"median-of-three\\" pivot selection strategy. **Task**: Implement the Quick Sort algorithm that uses the \\"median-of-three\\" method for selecting the pivot to improve efficiency on various datasets. The median-of-three method chooses the pivot as the median of the first, middle, and last elements of the array segment being sorted. **Function Signature**: ```python def optimized_quick_sort(arr): Sorts the array `arr` using an optimized quick sort algorithm with median-of-three pivot selection. Parameters: arr (list): A list of comparable elements. Returns: list: A sorted version of `arr`. ``` **Input**: - A list of comparable elements (e.g., integers, floats, or strings). **Output**: - A sorted list of the same elements. **Constraints**: - Do not use any built-in sorting functions. - Optimize for cases with nearly sorted input. - Handle arrays with few elements efficiently. **Example**: ```python # Example 1 input_arr = [3, 6, 8, 10, 1, 2, 1] sorted_arr = optimized_quick_sort(input_arr) print(sorted_arr) # Output: [1, 1, 2, 3, 6, 8, 10] # Example 2 input_arr = [10, 7, 8, 9, 1, 5] sorted_arr = optimized_quick_sort(input_arr) print(sorted_arr) # Output: [1, 5, 7, 8, 9, 10] ``` **Note**: In your implementation, specifically handle scenarios like already sorted input or arrays with repeated elements to ensure the sorting remains efficient.","solution":"def median_of_three(arr, low, high): mid = (low + high) // 2 if arr[low] > arr[mid]: arr[low], arr[mid] = arr[mid], arr[low] if arr[low] > arr[high]: arr[low], arr[high] = arr[high], arr[low] if arr[mid] > arr[high]: arr[mid], arr[high] = arr[high], arr[mid] return mid def partition(arr, low, high): pivot_index = median_of_three(arr, low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[low] = arr[low], arr[pivot_index] border = low for i in range(low, high + 1): if arr[i] < pivot_value: border += 1 arr[i], arr[border] = arr[border], arr[i] arr[low], arr[border] = arr[border], arr[low] return border def quick_sort_recursive(arr, low, high): if low < high: pivot_index = partition(arr, low, high) quick_sort_recursive(arr, low, pivot_index - 1) quick_sort_recursive(arr, pivot_index + 1, high) def optimized_quick_sort(arr): Sorts the array `arr` using an optimized quick sort algorithm with median-of-three pivot selection. Parameters: arr (list): A list of comparable elements. Returns: list: A sorted version of `arr`. if arr is None or len(arr) <= 1: return arr quick_sort_recursive(arr, 0, len(arr) - 1) return arr"},{"question":"Given two strings `s` and `t` where `t` is generated by randomly shuffling string `s` and then adding one more letter at a random position, write a function `find_difference(s: str, t: str) -> str` to find the letter that was added to `t`. # Input - `s`: A string consisting of only lowercase letters (`1 <= len(s) <= 10^4`). - `t`: A string consisting of only lowercase letters and is one character longer than `s` (`len(t) = len(s) + 1`). # Output - A single character string that represents the letter added. # Example ```plaintext Input: s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' ``` # Explanation The letter \'e\' is the additional character in `t` that wasn\'t originally in `s`. # Constraints & Assumptions - Strings `s` and `t` consist only of lowercase English letters. - `t` is always one character longer than `s`. - The input strings are not empty. # Performance Requirements - The solution should run in O(n) time complexity. - The solution should use O(1) additional space. # Scenario Imagine you have two scenarios of string data. One represents a series of sequences, and another is a corrupt sequence where exactly one character was inserted randomly. Your task is to identify which character was the corrupt addition. Implement the function following the provided signature: ```python def find_difference(s: str, t: str) -> str: # Your code here ```","solution":"def find_difference(s: str, t: str) -> str: Finds the letter that was added to t which is a shuffled version of s with one extra character. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in t: if char not in char_count or char_count[char] == 0: return char char_count[char] -= 1"},{"question":"# Problem: Count Unique Binary Search Trees Scenario: A software company\'s technical interview process includes assessing candidates on their understanding of dynamic programming and algorithms involving trees. One of the challenges posed to the candidates is to calculate the number of structurally unique Binary Search Trees (BSTs) that can be formed using a set of values from 1 to n. Task: Given an integer `n`, write a Python function `num_trees(n)` that computes the number of structurally unique BSTs that can be formed using values `1` to `n`. Function Signature: ```python def num_trees(n: int) -> int: ``` Input: - `n` (1 ≤ n ≤ 19): An integer value representing the range of values 1 to `n`. Output: - Returns an integer representing the number of structurally unique BSTs that can be formed using values from 1 to `n`. Constraints: - Ensure that the solution is efficient and works within the provided constraints. Example: Input: ```python n = 3 ``` Output: ```python 5 ``` Explanation: There are 5 structurally unique BSTs that can be formed using values 1, 2, 3. They are: ``` 1 3 3 2 1 / / / 3 2 1 1 3 2 / / 2 1 2 3 ``` Assumptions: - The function should handle edge cases where `n` is at its minimum or maximum limit (within the given range). Performance Requirements: - The time complexity of the solution should ideally be O(n^2). Testing: - The function will be tested against multiple test cases to ensure its correctness and efficiency.","solution":"def num_trees(n: int) -> int: Returns the number of structurally unique BSTs that can be formed using values from 1 to n. # Array to store the number of unique BSTs for each number of nodes dp = [0] * (n + 1) # There is one unique BST with 0 or 1 nodes dp[0] = 1 dp[1] = 1 # Fill the dp array for nodes from 2 to n using the dynamic programming approach for nodes in range(2, n + 1): for root in range(1, nodes + 1): left_subtree_nodes = root - 1 right_subtree_nodes = nodes - root dp[nodes] += dp[left_subtree_nodes] * dp[right_subtree_nodes] return dp[n]"},{"question":"**Resizing Hash Table Implementation** A local library system wants to manage users with unique identification numbers and their associated data. They want to use a dynamic hash table to store users\' data, which will dynamically resize when a certain load factor is exceeded. Implement a function within the `ResizableHashTable` class to handle resize operations to optimize performance. # Requirements: * Modify the `ResizableHashTable` to include handling for a user-defined maximum load factor. * Implement a method within the class to resize based on this load factor. * Ensure the keys and values are correctly rehashed and placed in the new resized table with the new size. # Functional Requirements: 1. **Class Function Signature**: ```python class ResizableHashTable(HashTable): ... def put(self, key, value): # Implementation with resize handling def __resize(self, new_load_factor): # Implement resizing based on the new load factor ``` 2. **Function Description**: * **`put(key: int, value: Any) -> None`**: Adds a key-value pair to the hash table. If the load factor exceeds the user-defined value, resize the table. * **`__resize(new_load_factor: float) -> None`**: Resizes the hash table to maintain the load factor within the user-defined threshold. 3. **Input/Output**: * **Input**: * Method calls with integer keys and associated values. * User-defined load factor, a float. * **Output**: * None directly, but the hash table must maintain correct key-value mappings. 4. **Constraints**: * Keys are positive integers. * Handle typical edge cases, such as insertion when the table is full or repeated keys. # Scenario: Consider you are adding new user data to the library\'s hash table. You initialize the dynamic hash table with a minimum size and define the load factor at which you want the resizing to occur. # Example: ```python # Example usage: htable = ResizableHashTable() htable.put(1, \\"User1\\") htable.put(2, \\"User2\\") # Assume the user-defined load factor is 0.7, resizing occurs after adding the third element htable.put(11, \\"User11\\") # Trigger resize and relocate to new hash positions. print(htable.get(1)) # Should return \\"User1\\" print(htable.get(11)) # Should return \\"User11\\" ``` # Note: * Focus on ensuring rehashing is done properly during the resizing process * Test your implementation with edge cases like duplicate keys and maximum table capacity.","solution":"class ResizableHashTable: def __init__(self, initial_size = 10, max_load_factor = 0.7): self.table = [None] * initial_size self.size = 0 self.max_load_factor = max_load_factor def _hash(self, key): # Basic hashing function return key % len(self.table) def put(self, key, value): if self.size / len(self.table) >= self.max_load_factor: self.__resize(len(self.table) * 2) index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: break index = (index + 1) % len(self.table) if self.table[index] is None: self.size += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: if self.table[index][0] == key: return self.table[index][1] index = (index + 1) % len(self.table) return None def __resize(self, new_size): old_table = self.table self.table = [None] * new_size self.size = 0 # Reset size as put() increments it for entry in old_table: if entry is not None: self.put(entry[0], entry[1])"},{"question":"Scenario Suppose you are assisting in maintaining a large binary search tree (BST) for an online e-commerce platform to manage product search operations. Efficient data retrieval means it is crucial to quickly find predecessors of certain nodes when required to optimize browsing history and suggestion algorithms. Problem Statement Write a function `find_predecessor` that finds the predecessor of a given node in a binary search tree (BST). The predecessor of a node is the node with the largest key smaller than the given node’s key. If the given node has no predecessor, the function should return `None`. # Function Signature ```python def find_predecessor(root: \'TreeNode\', node: \'TreeNode\') -> \'TreeNode\': pass ``` # Input * `root`: The root node of the BST (TreeNode), which can be `None` if the tree is empty. * `node`: The target node (TreeNode) for which the predecessor is to be found. # Output * Return the predecessor node (TreeNode) if it exists; otherwise, return `None`. # Constraints * The BST may contain up to `10^4` nodes. * Each node\'s value will be unique. * All node values are integer numbers. # Example ```plaintext Input: 20 / 10 30 / 5 15 17 Node = 15 Output: 10 Explanation: The predecessor of node with value 15 is the node with value 10. ``` Notes * Design your solution in a way that it efficiently handles large BSTs. * Consider edge cases such as the node being the smallest or the tree being empty.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None def find_predecessor(root: \'TreeNode\', node: \'TreeNode\') -> \'TreeNode\': # Helper function to find the maximum value node in a subtree def max_value_node(node): current = node while current.right: current = current.right return current # Edge case: if the tree is empty or node is None if root is None or node is None: return None predecessor = None current = root while current: if node.key > current.key: predecessor = current current = current.right elif node.key < current.key: current = current.left else: if current.left: predecessor = max_value_node(current.left) break return predecessor"},{"question":"# Regular Expression Matching with Dynamic Programming Context: You have been given the task to implement a function that can match a string against a given pattern. The pattern may contain two special characters: `.` which matches any single character, and `*` which matches zero or more of the preceding element. Your goal is to determine whether the entire string matches the pattern. Task Description: Write a function `is_match` that checks if a given string `str_a` matches the pattern `str_b`. # Function Signature: ```python def is_match(str_a: str, str_b: str) -> bool: Determine if the input string matches the given pattern. Args: str_a (str): The input string. str_b (str): The pattern string containing \'.\' and \'*\'. Returns: bool: True if the entire string matches the pattern, False otherwise. ``` Input: * `str_a`: A non-empty string containing lowercase alphabetical characters (1 <= len(str_a) <= 1000). * `str_b`: A non-empty string containing lowercase alphabetical characters, dots `.` and asterisks `*` (1 <= len(str_b) <= 1000). Output: * Boolean value `True` if the entire string matches the pattern, `False` otherwise. Constraints: 1. `.` matches any single character. 2. `*` matches zero or more of the preceding character. 3. The entire input string must match the pattern from start to end. Examples: 1. `is_match(\\"aa\\", \\"a\\")` -> `False` 2. `is_match(\\"aa\\", \\"aa\\")` -> `True` 3. `is_match(\\"aa\\", \\"a*\\")` -> `True` 4. `is_match(\\"aa\\", \\".*\\")` -> `True` 5. `is_match(\\"ab\\", \\".*\\")` -> `True` 6. `is_match(\\"aab\\", \\"c*a*b\\")` -> `True` Implementation Notes: - Consider using a 2D DP table `matches` where `matches[i][j]` represents if the first `i` characters of `str_a` match the first `j` characters of `str_b`. - Iterate through the strings and fill this table based on the rules of `.` and `*`. - Handle edge cases where the pattern starts or ends with `*` carefully, and ensure efficient space utilization if possible.","solution":"def is_match(str_a: str, str_b: str) -> bool: len_a, len_b = len(str_a), len(str_b) # Initialize a DP table with False dp = [[False] * (len_b + 1) for _ in range(len_a + 1)] # Empty string matches empty pattern dp[0][0] = True # Handles patterns like a*, a*b*, a*b*c* etc for j in range(1, len_b + 1): if str_b[j-1] == \'*\': dp[0][j] = dp[0][j-2] # Fill the DP table for i in range(1, len_a + 1): for j in range(1, len_b + 1): if str_b[j-1] == str_a[i-1] or str_b[j-1] == \'.\': dp[i][j] = dp[i-1][j-1] elif str_b[j-1] == \'*\': dp[i][j] = dp[i][j-2] or (dp[i-1][j] and (str_b[j-2] == str_a[i-1] or str_b[j-2] == \'.\')) return dp[len_a][len_b]"},{"question":"Objective Write a function `find_nth_digit(n)` that will return the nth digit in the sequence formed by concatenating all natural numbers: 123456789101112131415... Input - `n`: A positive integer (1 <= n <= 2 * 10^9). Output - Return the corresponding nth digit as an integer. Example - Input: `find_nth_digit(3)` - Output: `3` - Explanation: The sequence starts with \'123\', the 3rd digit is \'3\'. - Input: `find_nth_digit(11)` - Output: `0` - Explanation: The sequence starts with \'12345678910\', the 11th digit is \'0\'. Constraints - Your solution should be efficient in both time and space complexity. - Make sure to handle very large values of `n` without running into performance issues. - Consider handling all possible edge cases, specifically transitions between numbers of different lengths. # Notes - You may use integer arithmetic ensuring high precision in calculations. - Avoid floating-point operations to prevent precision errors; use integer division instead. - Think about the scenario described in the prompt and ensure thorough testing of edge cases. ```python def find_nth_digit(n): find the nth digit of given number. 1. find the length of the number where the nth digit is from. 2. find the actual number where the nth digit is from 3. find the nth digit and return length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length]) ``` Your task is to implement the function as described and ensure all edge cases are properly handled.","solution":"def find_nth_digit(n): find the nth digit of given number. 1. find the length of the number where the nth digit is from. 2. find the actual number where the nth digit is from 3. find the nth digit and return length = 1 count = 9 start = 1 while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 start += (n-1) // length s = str(start) return int(s[(n-1) % length])"},{"question":"# Bit Insertion Programming Challenge Objective Write a function to insert one or multiple bits into an integer at a specified position. Function Signatures ```python def insert_one_bit(num: int, bit: int, i: int) -> int: pass def insert_mult_bits(num: int, bits: int, bit_length: int, i: int) -> int: pass ``` Inputs and Outputs 1. **Function `insert_one_bit`**: - **Input**: An integer `num`, a single bit `bit` (either 0 or 1), and a position `i`. - **Output**: A modified integer with `bit` inserted at position `i`. 2. **Function `insert_mult_bits`**: - **Input**: An integer `num`, a series of bits `bits` (represented as an integer), a length `bit_length`, and a position `i`. - **Output**: A modified integer with `bits` inserted at position `i`. Constraints: - Input integer `num` is guaranteed to be non-negative. - Bit insertion position `i` will be a valid position within the bit length of `num`. - For `insert_mult_bits`, the `bit_length` is the length of `bits` in binary representation, and `bits` will be up to the maximum of the bit length that fits within a 32-bit integer range. Example: ```python assert insert_one_bit(21, 1, 2) == 45 # 10101 -> 101101 assert insert_one_bit(21, 0, 2) == 41 # 10101 -> 101001 assert insert_one_bit(21, 1, 5) == 53 # 10101 -> 110101 assert insert_one_bit(21, 1, 0) == 43 # 10101 -> 101011 assert insert_mult_bits(5, 7, 3, 1) == 47 # 101 -> 101111 assert insert_mult_bits(5, 7, 3, 0) == 47 # 101 -> 101111 assert insert_mult_bits(5, 7, 3, 3) == 61 # 101 -> 111101 ``` # Note: Students should ensure that their solution: - Handles edge cases appropriately (like inserting at the start or end). - Efficiently handles large inputs within the constraints.","solution":"def insert_one_bit(num: int, bit: int, i: int) -> int: Inserts a single bit into an integer at the specified position. :param num: Integer in which to insert the bit. :param bit: The bit to insert (0 or 1). :param i: The position to insert the bit at. :return: The modified integer with the bit inserted. # Isolate the part before the insertion point before = num >> i # Retrieve the part that remains unchanged after = num & ((1 << i) - 1) # Combine all parts with the new bit in the middle return (before << 1 | bit) << i | after def insert_mult_bits(num: int, bits: int, bit_length: int, i: int) -> int: Inserts multiple bits into an integer at the specified position. :param num: Integer in which to insert the bits. :param bits: The bits to insert (represented by an integer). :param bit_length: The length of the bits in binary representation. :param i: The position to insert the bits at. :return: The modified integer with the bits inserted. # Isolate the part before the insertion point before = num >> i # Retrieve the part that remains unchanged after = num & ((1 << i) - 1) # Combine all parts with the new bits in the middle return (before << bit_length | bits) << i | after"},{"question":"Problem Description Implement a function that approximates the cube root of a given positive integer (N) within a specified precision factor (P). Detailed Description Given a positive integer (N) and a precision factor (P), your task is to implement the `cube_root` function using Newton\'s Method to calculate an approximation of the cube root of (N) such that the absolute error does not exceed (P). The function signature should be: ```python def cube_root(n: int, epsilon: float = 0.001) -> float: ... ``` Input * `n`: A positive integer (1 leq n leq 10^9). * `epsilon` (default value (0.001)): A positive float representing the precision requirement (0 < epsilon < 1). Output * Return a float (x) such that the absolute error (|x^3 - n| leq epsilon). Constraints * Your solution should aim for an optimal time complexity. * Ensure edge cases are handled, including the smallest and largest possible values of (n) within the given constraints. * No built-in functions for cube root are allowed; you must use Newton\'s Method. Example ```python cube_root(27, 0.001) # Expected output: A float value close to 3, the actual cube root of 27. cube_root(8, 0.0001) # Expected output: A float value close to 2, the actual cube root of 8. ``` Notes - Ensure your implementation is robust and considers precision and performance. - Choose an appropriate initial guess to improve convergence speed. - Include adequate checks and balances to avoid infinite loops and ensure convergence.","solution":"def cube_root(n: int, epsilon: float = 0.001) -> float: if n == 0: return 0 # Using Newton\'s Method guess = n / 2.0 # Initial guess while abs(guess**3 - n) > epsilon: guess = guess - (guess**3 - n) / (3 * guess**2) return guess"},{"question":"Implement Enhanced Stooge Sort Stooge Sort is an inefficient sorting algorithm that serves educational purposes rather than practical ones. Your task is to implement an enhanced version of Stooge Sort, which also tracks the number of comparisons made during the sorting process. Problem Statement: Write a function `enhanced_stoogesort(arr)` that takes a list of integers `arr` and sorts it in ascending order using Stooge Sort. In addition to sorting, it should return the number of element comparisons made during the process. Your function should: 1. Sort the list in-place using Stooge Sort. 2. Return the count of element comparisons. Input: - `arr`: a list of integers (1 <= len(arr) <= 1000, -1000 <= arr[i] <= 1000). Output: - Sorted list `arr` (sorted in-place). - An integer representing the number of comparisons made. Example: ```python arr = [5, 3, 2, 4, 1] count = enhanced_stoogesort(arr) print(arr) # Output: [1, 2, 3, 4, 5] print(count) # Output: [Number of comparisons made] ``` Constraints: - You are forbidden from using Python\'s built-in sort function or any external sorting libraries. - Your implementation must be recursive and follow the principles of Stooge Sort. Performance Requirements: - Your solution should efficiently count and return the number of comparisons. Even with its inherent inefficiency, your sorting should handle up to 1000 elements within reasonable time. # Tips: - Ensure you handle the base cases correctly, especially when the array length is 1 or 2. - Accurately count each comparison made during the sorting process. Good luck, and happy coding!","solution":"def enhanced_stoogesort(arr): def stoogesort(arr, l, h): nonlocal comparisons if l >= h: return # Compare first and last elements comparisons += 1 if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] # If the list has more than 2 elements if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t) stoogesort(arr, l + t, h) stoogesort(arr, l, h - t) comparisons = 0 stoogesort(arr, 0, len(arr) - 1) return comparisons"},{"question":"# Question: Implement a Robust Square Root Function Given a positive integer `N` and a precision factor `P`, write a Python function that computes and returns the square root of `N` to within the specified precision `P`. Your implementation should handle edge cases and be efficient in terms of time and space complexity. Function Signature ```python def square_root(n: int, p: float) -> float: ``` Input 1. `n` (1 <= N <= 10^9): A positive integer representing the number for which the square root is to be calculated. 2. `p` (0 < P <= 0.1): A float representing the acceptable precision in the result. Output - A float representing the approximate square root of `n` to within a maximum absolute error of `p`. Example ```python square_root(5, 0.001) -> Outputs a value such that 2.235 < result < 2.237 square_root(10, 0.0001) -> Outputs a value such that 3.1622 < result < 3.1624 ``` Requirements - Handle edge cases like `n = 0` (should return 0). - Avoid infinite loops or excessive computation time. - Ensure the function works efficiently for large values of `n`.","solution":"def square_root(n: int, p: float) -> float: Returns the square root of n to within the precision p using binary search. if n < 0: raise ValueError(\\"The input number should be a positive integer.\\") if n == 0: return 0.0 low, high = 0, n mid = (low + high) / 2.0 while high - low > p: if mid * mid < n: low = mid else: high = mid mid = (low + high) / 2.0 return mid"},{"question":"You are given a grid representing a map where each cell represents either land (1) or water (0). Initially, the entire map is water, and you will be provided with a sequence of positions to turn water into land. Write a function to count the number of islands after each position is turned into land incrementally. An island is defined as a group of adjacent lands connected horizontally or vertically. Implement the function `num_islands(grid_size, positions)` where: - `grid_size` is a tuple `(n, m)` representing the number of rows and columns respectively. - `positions` is a list of tuples `(x, y)` representing the positions to turn water into land. The function should return a list of integers, where each integer represents the number of islands after each operation. # Input: - A tuple `grid_size` (n, m): (integer, integer) - A list of tuples `positions` [(x1, y1), (x2, y2), ..., (xk, yk)]: list of integer pairs # Output: - A list of integers, representing the count of islands after each position addition. # Constraints: - 1 <= n, m <= 1000 - 1 <= len(positions) <= n * m - 0 <= x < n - 0 <= y < m # Example: ```python # Example grid of size 3x3 grid_size = (3, 3) positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(num_islands(grid_size, positions)) # Output: [1, 1, 2, 3] ``` # Note: - Initially, the 2D grid is filled with water. - As the positions are turned into land sequentially, the number of islands may increase or decrease depending on the connectivity. - Use the Union-Find data structure for implementing this function for efficient union and find operations.","solution":"class UnionFind: def __init__(self, total_elements): self.parent = list(range(total_elements)) self.rank = [0] * total_elements self.count = 0 def find(self, x): if self.parent[x] != x: self.parent[x] = self.find(self.parent[x]) return self.parent[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.parent[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.parent[rootX] = rootY else: self.parent[rootY] = rootX self.rank[rootX] += 1 self.count -= 1 def add_land(self, pos): self.count += 1 self.parent[pos] = pos def num_islands(grid_size, positions): n, m = grid_size uf = UnionFind(n * m) result = [] grid = [[0] * m for _ in range(n)] for x, y in positions: if grid[x][y] == 1: result.append(uf.count) continue grid[x][y] = 1 pos = x * m + y uf.add_land(pos) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: neighbor_pos = nx * m + ny uf.union(pos, neighbor_pos) result.append(uf.count) return result"},{"question":"You are given a binary tree represented by its root node. Implement a function `level_order_sum` that performs a level order traversal of the binary tree and returns a list of sums of node values at each level. # Function Signature: ```python def level_order_sum(root: Optional[TreeNode]) -> List[int]: ``` # Input: - `root`: The root node of the binary tree (type `TreeNode`), where `TreeNode` is a class representing each node in the tree. # Output: - A list of integers, where each integer is the sum of the node values at that level in the tree. # Constraints: - The number of nodes in the tree will be in the range `[0, 10^4]`. - The node values will be integers in the range `[-10^5, 10^5]`. # Example: Example 1: ```text Input: 3 / 9 20 / 15 7 Output: [3, 29, 22] ``` Explanation: - The sums of nodes at each level are: - Level 1: [3] -> 3 - Level 2: [9, 20] -> 29 - Level 3: [15, 7] -> 22 # Additional Notes: Ensure your solution is both time and space efficient to handle large input sizes. Consider edge cases such as trees with only one node or completely balanced/unbalanced trees.","solution":"from typing import Optional, List class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def level_order_sum(root: Optional[TreeNode]) -> List[int]: if not root: return [] queue = [root] level_sums = [] while queue: level_sum = 0 next_queue = [] for node in queue: level_sum += node.val if node.left: next_queue.append(node.left) if node.right: next_queue.append(node.right) level_sums.append(level_sum) queue = next_queue return level_sums"},{"question":"Scenario You are tasked with designing a system that processes a continuous stream of temperature readings. The system must be capable of providing a moving average of the last \'n\' readings to facilitate real-time analysis. Problem Statement Implement a class `TemperatureMonitor` that calculates the moving average of the last \'size\' temperature readings in real-time. Requirements 1. **Initialization**: * The class should be initialized with a parameter \'size\', which denotes the number of readings to consider for the moving average. 2. **Method to add a new reading**: * Implement a method `add_reading(self, temperature: float) -> float` that takes a temperature reading (floating point) and returns the current moving average of the last \'size\' readings. Input and Output Formats 1. **Initialization**: `TemperatureMonitor(int size)` 2. **Method**: `add_reading(float temperature) -> float` Constraints * Size of the moving window, `size`, will always be a positive integer, `1 <= size <= 1000`. * Temperature readings will be floating-point numbers in the range `-100.0 <= temperature <= 100.0`. Example: ```python monitor = TemperatureMonitor(3) assert monitor.add_reading(20.0) == 20.0 # (20)/1 assert monitor.add_reading(22.0) == 21.0 # (20+22)/2 assert monitor.add_reading(24.0) == 22.0 # (20+22+24)/3 assert monitor.add_reading(25.0) == 23.67 # (22+24+25)/3, rounded to 2 decimal places ``` Additional Notes * Ensure the implementation keeps time complexity for adding a new reading constant, O(1). * Handle the computation of moving average efficiently.","solution":"from collections import deque class TemperatureMonitor: def __init__(self, size: int): Initialize the TemperatureMonitor with a specific size for the moving average window. self.size = size self.readings = deque(maxlen=size) self.total = 0.0 def add_reading(self, temperature: float) -> float: Add a new temperature reading and return the current moving average of the last \'size\' readings. if len(self.readings) == self.size: self.total -= self.readings.popleft() # Remove the oldest reading from the total self.readings.append(temperature) self.total += temperature return round(self.total / len(self.readings), 2)"},{"question":"Binary Tree Balance Check You have been provided with the implementation of a function `is_balanced(root)`, which determines if a given binary tree is height-balanced. A binary tree is considered height-balanced if for each node in the tree, the difference in the height of its left and right subtrees is no more than 1. Your task is to implement the helper functions `__get_depth` and `__is_balanced_recursive` that `is_balanced` depends on, ensuring an efficient solution. Implementation Details 1. **Function Signature**: ```python def is_balanced(root): pass def __is_balanced_recursive(root): pass def __get_depth(root): pass ``` 2. **Definitions**: * `is_balanced(root)`: Returns a boolean indicating if the tree rooted at `root` is balanced. * `__is_balanced_recursive(root)`: Recursively checks if the tree is balanced using depth information from `__get_depth`. * `__get_depth(root)`: Returns the depth of the tree if balanced, otherwise returns -1 if the subtree is unbalanced. 3. **Input**: * `root`: A TreeNode object representing the root of the binary tree. TreeNode is defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` 4. **Output**: * Returns `True` if the tree is height-balanced, `False` otherwise. Constraints 1. The number of nodes in the tree is in the range `[0, 10^4]`. 2. Each node\'s value is an integer in the range `[-10^5, 10^5]`. Example *Example 1*: ``` Input: root = [3,9,20,null,null,15,7] Output: True Explanation: The tree is balanced because the height difference of every node\'s subtrees is 1 or less. ``` *Example 2*: ``` Input: root = [1,2,2,3,3,null,null,4,4] Output: False Explanation: The tree is not balanced as the height difference at the root node’s subtrees is 2. ``` Write your solution below:","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_balanced(root): Determine if the binary tree is height-balanced. def __is_balanced_recursive(root): Helper function to recursively check if the tree is balanced. Returns a tuple (is_balanced, depth). if root is None: return True, 0 left_balanced, left_depth = __is_balanced_recursive(root.left) right_balanced, right_depth = __is_balanced_recursive(root.right) current_balanced = (left_balanced and right_balanced and abs(left_depth - right_depth) <= 1) current_depth = 1 + max(left_depth, right_depth) return current_balanced, current_depth balanced, _ = __is_balanced_recursive(root) return balanced"},{"question":"Moving Average with Optimized Performance # Context You are given a stream of integers and you need to efficiently compute the moving average of the last `N` integers in the stream. The existing implementation uses a deque data structure and recalculates the sum for each request, which can be improved. You should enhance the solution to optimize the performance considering larger data streams. # Task Implement a more efficient version of the `MovingAverage` class that computes the moving average without recalculating the sum from scratch each time a new value is added. # Specifications 1. **Class**: `MovingAverageOptimized` 2. **Constructor**: `__init__(self, size: int)` - Initialize the data structure with a window size `size`. 3. **Method**: `next(self, val: int) -> float` - Add a new integer `val` to the window. - Return the moving average of the last `size` integers. 4. **Constraints**: - 1 <= `size` <= 10^5 - -10^4 <= `val` <= 10^4 - At most 10^5 calls will be made to `next`. # Example ```python m = MovingAverageOptimized(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.67 (rounded to 2 decimal places) print(m.next(5)) # Output: 6.0 ``` # Performance Requirements You should ensure that the `next` method runs in O(1) time complexity. # Implementation Notes - Use an optimized approach to maintain the sum efficiently. - Handle edge cases appropriately, especially when the stream has fewer elements than the window size.","solution":"from collections import deque class MovingAverageOptimized: def __init__(self, size: int): Initialize your data structure here. self.size = size self.queue = deque() self.current_sum = 0.0 def next(self, val: int) -> float: Add a new value to the queue and return the current moving average. The average should be rounded to 2 decimal places. self.queue.append(val) self.current_sum += val if len(self.queue) > self.size: self.current_sum -= self.queue.popleft() return round(self.current_sum / len(self.queue), 2)"},{"question":"# Question: Incremental Digit Array You are given a non-negative number represented as an array of digits, where each digit is a single digit from 0 to 9. The most significant digit is at the head of the list. Write a function that adds one to the number and returns the resulting array of digits. Function Signature ```python def increment_digits(digits: List[int]) -> List[int]: pass ``` Input - `digits`: A list of integers representing the number, where each element is a single digit (0-9). Output - A list of integers representing the number after adding one to it. Constraints - 1 <= len(digits) <= 1000 - The input list does not contain any leading zeros except the number zero itself (i.e., digits cannot be [0, 0, 1], but can be [0]). Performance Requirements - The function should run in linear time relative to the size of the input list. - Aim for minimal extra space usage, preferring in-place updates if possible. Example - **Input**: `[1, 2, 3]` - **Output**: `[1, 2, 4]` - **Input**: `[9, 9, 9]` - **Output**: `[1, 0, 0, 0]` Detailed Explanation: 1. Start from the last digit of the list. 2. Add one to this digit. 3. Check if there is a carry (i.e., if the result is 10, set digit to 0 and carry over 1). 4. Propagate the carry forward to the next significant digit. 5. If all digits are 9 and there is still a carry after the most significant digit, insert 1 at the beginning of the list. 6. Return the updated list of digits. Note - You do not need to handle inputs where the list contains characters or non-numeric values. - Your solution should be robust to handle the edge cases mentioned in the guidelines.","solution":"from typing import List def increment_digits(digits: List[int]) -> List[int]: Given a list of digits, increments the represented number by one and returns the resulting list of digits. n = len(digits) # Traverse the list from the end to the beginning for i in range(n - 1, -1, -1): if digits[i] < 9: digits[i] += 1 return digits digits[i] = 0 # If we have reached this point, all digits were 9 return [1] + digits"},{"question":"Given an array of integers, implement the Shell Sort algorithm to sort the array in ascending order. The function should be named `shell_sort` and take a single argument, which is the list of integers. Return the sorted list as the output. Input A single list of integers `arr`: ```python arr = [12, 34, 54, 2, 3] ``` Output A list of integers sorted in ascending order: ```python [2, 3, 12, 34, 54] ``` Constraints 1. The function should sort the array in-place. 2. The function should handle edge cases such as empty arrays and arrays with one element. 3. Do not use built-in sorting functions. 4. Minimize memory usage wherever possible. Additional Performance Requirements 1. The implementation should attempt to minimize the number of shifts/swaps. 2. Use an appropriate gap sequence to ensure good average case performance. # Example Input ```python arr = [64, 34, 25, 12, 22, 11, 90] ``` Output ```python [11, 12, 22, 25, 34, 64, 90] ``` Implement the `shell_sort` function as specified: ```python def shell_sort(arr): # Your Implementation Here ```","solution":"def shell_sort(arr): Function to sort an array using Shell Sort algorithm. n = len(arr) gap = n // 2 while gap > 0: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp gap //= 2 return arr"},{"question":"Implement a BSTIterator for Range Queries Given a binary search tree (BST), create an iterator class `BSTIteratorRange`. This iterator should support the following functionalities: 1. **Initialization**: Create an iterator for the given range [low, high]. 2. **has_next()**: Returns `True` if there are further elements within the range [low, high], otherwise returns `False`. 3. **next_in_range()**: Returns the next element in ascending order within the range [low, high]. Input: - The initialization parameter includes the `root` of the BST and the inclusive range boundaries `[low, high]`. Output: - `has_next()` should return a boolean. - `next_in_range()` should return an integer. Constraints: - Each element in the BST is unique. - The BST contains up to `n` nodes (1 ≤ n ≤ 10⁴). - The values of the nodes, `lo`, and `hi` are integers within the range -10⁴ to 10⁴. Example: ```python # Assuming the BST structure and node definition as follows: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Given BST creation for the example: # 7 # / # 3 15 # / # 9 20 root = TreeNode(7) root.left = TreeNode(3) root.right = TreeNode(15) root.right.left = TreeNode(9) root.right.right = TreeNode(20) # Instantiate iterator for range [4, 17]: iterator = BSTIteratorRange(root, 4, 17) while iterator.has_next(): print(iterator.next_in_range()) # Should output: 7, 9, 15 ``` Implementation: ```python class BSTIteratorRange: def __init__(self, root, low, high): self.stack = [] self.low = low self.high = high self._inorder_traversal_left(root) def _inorder_traversal_left(self, node): while node: if node.val >= self.low: self.stack.append(node) node = node.left def has_next(self): while self.stack and self.stack[-1].val > self.high: self.stack.pop() return bool(self.stack) def next_in_range(self): while self.has_next(): node = self.stack.pop() value = node.val if node.right: self._inorder_traversal_left(node.right) if self.low <= value <= self.high: return value # You would need to test it thoroughly with different edge cases. ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BSTIteratorRange: def __init__(self, root, low, high): self.stack = [] self.low = low self.high = high self._inorder_traversal_left(root) def _inorder_traversal_left(self, node): while node: self.stack.append(node) node = node.left def has_next(self): while self.stack: if self.stack[-1].val > self.high: self.stack.pop() else: return True return False def next_in_range(self): while self.has_next(): node = self.stack.pop() value = node.val if node.right: self._inorder_traversal_left(node.right) if self.low <= value <= self.high: return value return None"},{"question":"# File Path and URL Joiner **Scenario**: You are building a script that needs to handle both file paths and URLs. One necessary functionality is to properly join a base path with a suffix, ensuring that no double slashes are present at the junction. **Task**: Write a Python function `smart_join(base, suffix)` that takes two strings - `base` (the base path/URL) and `suffix` (the part to append) - and returns their proper concatenation using a single slash as separator. The function should meet the following requirements: * Remove any trailing slashes from `base`, and leading slashes from `suffix`. * Ensure there are no redundant slashes when joining the two parts. * Handle cases where either `base` or `suffix` (or both) may be empty strings. Input Format: * `base` - A string representing the base path or URL. * `suffix` - A string representing the subsequent part to append. Output Format: * A string representing the concatenation of `base` and `suffix` with a single slash as separator. Constraints: * The resulting string should not have redundant slashes at the junction. * Both `base` and `suffix` are ASCII strings. Examples: ```python print(smart_join(\\"path/to/dir\\", \\"file\\")) # Output: \\"path/to/dir/file\\" print(smart_join(\\"path/to/dir/\\", \\"file\\")) # Output: \\"path/to/dir/file\\" print(smart_join(\\"http://algorithms.com/\\", \\"part\\")) # Output: \\"http://algorithms.com/part\\" print(smart_join(\\"http://algorithms.com\\", \\"/part\\")) # Output: \\"http://algorithms.com/part\\" print(smart_join(\\"\\", \\"file\\")) # Output: \\"file\\" print(smart_join(\\"path/to/dir\\", \\"\\")) # Output: \\"path/to/dir\\" print(smart_join(\\"\\", \\"\\")) # Output: \\"\\" ``` **Note**: You are not allowed to use any built-in library functions such as `os.path.join` or `urllib.parse`.","solution":"def smart_join(base, suffix): Joins a base path or URL with a suffix ensuring no double slashes. Parameters: base (str): The base path or URL. suffix (str): The part to append. Returns: str: The concatenation of base and suffix with a single slash as separator. # Remove trailing slashes from base base = base.rstrip(\'/\') # Remove leading slashes from suffix suffix = suffix.lstrip(\'/\') # Join with a single slash if base and suffix: return base + \'/\' + suffix return base + suffix"},{"question":"Background Scenario You are given a task to find a specific digit within an infinitely growing sequence of natural numbers concatenated together (e.g., \\"1234567891011121314...\\"). A function has to be written to efficiently find the nth digit in this sequence for a large value of n. Problem Statement Write a function `find_nth_digit(n)` that takes an integer n and returns the nth digit in the sequence of natural numbers concatenated together. # Input: * `n: int` - An integer representing the position in the concatenated sequence. (1 ≤ n ≤ 2 * 10^9) # Output: * Returns the digit at the n-th position as an integer. Example: ```python find_nth_digit(3) -> 3 find_nth_digit(11) -> 0 find_nth_digit(189) -> 9 find_nth_digit(190) -> 1 ``` Constraints and Assumptions: * The sequence of numbers starts from `1` and grows continuously. * Python\'s arbitrary-precision integers can handle very large values for this task. Performance Requirements: * The solution must efficiently handle large values of `n`, leveraging the logarithmic time complexity demonstrated in the core algorithm. ```python def find_nth_digit(n): # Your code here ``` Provide a comprehensive and efficient implementation to ensure correct results for the given constraints.","solution":"def find_nth_digit(n): Find the nth digit in the sequence of natural numbers concatenated together. # Start with the smallest digit length length = 1 count = 9 start = 1 # Determine the length of the number where the nth digit is found while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Determine the actual number that contains the nth digit start += (n - 1) // length s = str(start) # Determine the position of the nth digit in the number return int(s[(n - 1) % length])"},{"question":"# Scenario You are working on optimizing data storage and manipulation within a software system handling large volumes of transactions. Part of the optimization involves setting, clearing, and checking specific flags embedded within individual transaction records, represented as integers. # Problem Statement Implement functions for manipulating specific bits within integer representations of transaction records. Your implementation should correctly handle operations like getting the value of a particular bit, setting a bit to 1, clearing a bit to 0, and updating a bit to a specific value. Function Specifications: 1. Implement `get_bit(num: int, i: int) -> bool` - **Input**: - `num`: the input integer (representing a transaction). - `i`: the bit position to check. - **Output**: - `True` if the bit at position `i` is 1, otherwise `False`. 2. Implement `set_bit(num: int, i: int) -> int` - **Input**: - `num`: the input integer (representing a transaction). - `i`: the bit position to set to 1. - **Output**: - The integer with the bit at position `i` set to 1. 3. Implement `clear_bit(num: int, i: int) -> int` - **Input**: - `num`: the input integer (representing a transaction). - `i`: the bit position to clear (set to 0). - **Output**: - The integer with the bit at position `i` cleared to 0. 4. Implement `update_bit(num: int, i: int, bit: bool) -> int` - **Input**: - `num`: the input integer (representing a transaction). - `i`: the bit position to update. - `bit`: `True` to set to 1, `False` to set to 0. - **Output**: - The integer with the bit at position `i` updated accordingly. Constraints: - The bit position `i` will be provided within the range `[0, 31]` (considering a 32-bit integer). - Assume `num` fits within a 32-bit signed integer. # Examples: ```python assert get_bit(5, 0) == True # 5 (binary: 101) assert get_bit(5, 1) == False # 5 (binary: 101) assert get_bit(5, 2) == True # 5 (binary: 101) assert set_bit(5, 1) == 7 # 5 (binary: 101) => 7 (binary: 111) assert clear_bit(5, 0) == 4 # 5 (binary: 101) => 4 (binary: 100) assert update_bit(5, 1, True) == 7 # 5 (binary: 101) => 7 (binary: 111) assert update_bit(5, 0, False) == 4 # 5 (binary: 101) => 4 (binary: 100) ```","solution":"def get_bit(num: int, i: int) -> bool: Returns True if the bit at position i in num is 1, otherwise False. return (num & (1 << i)) != 0 def set_bit(num: int, i: int) -> int: Sets the bit at position i in num to 1. return num | (1 << i) def clear_bit(num: int, i: int) -> int: Clears the bit at position i in num to 0. return num & ~(1 << i) def update_bit(num: int, i: int, bit: bool) -> int: Updates the bit at position i in num to the specified bit (True for 1, False for 0). mask = ~(1 << i) return (num & mask) | (bit << i)"},{"question":"# Problem Description You are given an api which returns an array of words and an array of symbols. Your task is to write a function that returns the word with their matched symbol surrounded by square brackets. If a word matches more than one symbol, choose the one with the longest length. Input * `words` - a list of strings containing words (1 ≤ len(words) ≤ 1000, 1 ≤ len(words[i]) ≤ 100) * `symbols` - a list of strings containing symbols (1 ≤ len(symbols) ≤ 500, 1 ≤ len(symbols[i]) ≤ 50) Output * Return a list of the transformed words after matching symbols. **Note**: If no symbols match a word, return the word as is. Example ```python Input: words: [\'Amazon\', \'Microsoft\', \'Google\'] symbols: [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Function Signature ```python def match_and_bracket_words(words: List[str], symbols: List[str]) -> List[str]: pass ``` # Constraints * Optimize for both time and space complexity as feasible. * Avoid unnecessary loops and redundant checks. Implement the function `match_and_bracket_words` that performs the task described above.","solution":"from typing import List def match_and_bracket_words(words: List[str], symbols: List[str]) -> List[str]: Surrounds matched symbols in words with square brackets. If a word matches more than one symbol, choose the one with the longest length. result = [] for word in words: match = \\"\\" for symbol in symbols: if symbol in word and len(symbol) > len(match): match = symbol if match: transformed_word = word.replace(match, f\\"[{match}]\\") result.append(transformed_word) else: result.append(word) return result"},{"question":"# Binary Search Implementation and Analysis In this task, you are required to implement both iterative and recursive versions of the binary search algorithm. This will test your understanding of algorithm design and your ability to write efficient code. Function Specifications: 1. **Iterative Version** * **Function Name**: `binary_search` * **Input**: A list of integers `array` (sorted in ascending order) and an integer `query`. * **Output**: The index of `query` if present in `array`; otherwise, `None`. ```python def binary_search(array, query): # Your code goes here pass ``` 2. **Recursive Version** * **Function Name**: `binary_search_recur` * **Input**: A list of integers `array` (sorted in ascending order), two integers `low` and `high` representing the current indices being searched, and an integer `val` representing the target value. * **Output**: The index of `val` if present in `array`; otherwise, `-1`. ```python def binary_search_recur(array, low, high, val): # Your code goes here pass ``` # Constraints: * Your solution should have a time complexity of O(log(n)). * Your solution should handle edge cases such as an empty array and arrays with size one. # Performance Requirement: - The algorithm should run efficiently under time constraints typical in competitive coding environments. Example: ```python # Iterative example_array = [1, 2, 3, 4, 5, 6, 7, 8, 9] query = 5 # Output: 4 (zero-based index) # Recursive example_array = [1, 2, 3, 4, 5, 6, 7, 8, 9] query = 10 # Output: -1 ``` **Note**: Write test cases to validate your solutions against various edge cases and ensure correctness.","solution":"def binary_search(array, query): Perform an iterative binary search. :param array: A list of sorted integers. :param query: The integer to search for. :return: The index of query in array if found, otherwise None. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return None def binary_search_recur(array, low, high, val): Perform a recursive binary search. :param array: A list of sorted integers. :param low: The lower index of the current search range. :param high: The upper index of the current search range. :param val: The integer to search for. :return: The index of val in array if found, otherwise -1. if low > high: return -1 mid = (low + high) // 2 if array[mid] == val: return mid elif array[mid] < val: return binary_search_recur(array, mid + 1, high, val) else: return binary_search_recur(array, low, mid - 1, val)"},{"question":"Scenario You are given the task of validating the path sums in a binary tree. Your goal is to determine if there exists a root-to-leaf path such that the sum of the values along the path equals a given target sum. Task Implement a function called `has_path_sum` to achieve this. Your function should utilize DFS strategy (both recursive and iterative implementations) to check for the existence of such a path. Input - The `root` of a binary tree, where tree nodes contain integer values. - An integer `sum` representing the target path sum. Output - Return `True` if such a path is found, otherwise return `False`. Constraints - The number of nodes in the tree is in the range `[0, 10^4]`. - `-1000 <= Node.val <= 1000` - `-1000 <= sum <= 1000` Example Given the binary tree and sum = 22, ```plaintext 5 / 4 8 / / 11 13 4 / 7 2 1 ``` The function should return `True` since there exist a root-to-leaf path 5->4->11->2 which sum is 22. Additional Requirements Implement the following in your function: 1. A recursive DFS approach. 2. An iterative DFS approach using a stack. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, sum): # Recursive DFS Implementation pass def has_path_sum_iterative(root, sum): # Iterative DFS Implementation using Stack pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, sum): def dfs(node, current_sum): if not node: return False current_sum += node.val # Check if it\'s a leaf node and if the path sum equals the target sum if not node.left and not node.right: return current_sum == sum # Recursively call for left and right subtrees return dfs(node.left, current_sum) or dfs(node.right, current_sum) return dfs(root, 0) def has_path_sum_iterative(root, sum): if not root: return False stack = [(root, root.val)] while stack: node, current_sum = stack.pop() # Check if it\'s a leaf node and if the path sum equals the target sum if not node.left and not node.right: if current_sum == sum: return True # Add left and right children to the stack if node.right: stack.append((node.right, current_sum + node.right.val)) if node.left: stack.append((node.left, current_sum + node.left.val)) return False"},{"question":"# Encode and Decode Strings Scenario: You are developing a messaging application that needs to transmit an array of messages (strings). Your task is to design two functions that can encode a list of messages into a single string and then decode it back to the original list. Function Specifications: 1. `encode(strs: List[str]) -> str`: - **Input**: A list of strings. - **Output**: A single encoded string that represents the list of strings. - **Process**: Each string in the list is prefixed with its length followed by a delimiter, ensuring even empty strings are correctly encoded. 2. `decode(s: str) -> List[str]`: - **Input**: A single encoded string. - **Output**: The original list of strings. - **Process**: Parse the encoded string by reading lengths and reconstruct the original list of strings. Requirements: - The solution should handle edge cases such as empty strings and strings with special characters. - Memory usage should be efficient with respect to the input size. - Ensure proper handling of erroneous or malformed encoded strings. Example: ```python messages = [\\"hello\\", \\"world\\", \\"\\", \\"let\'s\\", \\"code!\\"] encoded = encode(messages) print(encoded) # e.g., \\"5:hello5:world0:5:let\'s5:code!\\" decoded = decode(encoded) print(decoded) # [\\"hello\\", \\"world\\", \\"\\", \\"let\'s\\", \\"code!\\"] ``` Constraints: - String elements in the list `strs` have a maximum length of (10^3). - The list `strs` will have a maximum length of (10^4). Implement the two functions in Python: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str # Your code here. def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] # Your code here. ```","solution":"from typing import List def encode(strs: List[str]) -> str: Encodes a list of strings to a single string by prefixing each with its length and a delimiter. return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s: str) -> List[str]: Decodes a single string to a list of strings by parsing length prefixes and reading substrings. i, n = 0, len(s) result = [] while i < n: j = s.find(\':\', i) length = int(s[i:j]) i = j + 1 + length result.append(s[j + 1:i]) return result"},{"question":"# Question: Implement Tarjan\'s Algorithm for SCC in Different Graph Representations **Objective**: You have learned about Tarjan\'s Algorithm for finding strongly connected components (SCCs) in a directed graph. Now, it\'s your task to apply this understanding to implement Tarjan\'s Algorithm for a graph represented in a different form. # Problem Statement Implement Tarjan\'s Algorithm to find all the strongly connected components (SCCs) in a directed graph, where the graph is provided as an adjacency matrix. # Function Signature ```python def tarjans_scc(matrix: List[List[int]]) -> List[List[int]]: pass ``` # Input * `matrix`: A 2D list of integers representing the adjacency matrix of the graph, where `matrix[i][j] == 1` implies an edge from vertex `i` to vertex `j`, and `matrix[i][j] == 0` implies no edge. # Output * The function should return a list of lists, where each inner list represents a strongly connected component containing vertices. # Example ```python matrix = [ [0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1] ] print(tarjans_scc(matrix)) # Expected Output: [[3], [0, 1, 2]] or [[0, 1, 2], [3]] ``` # Constraints * The number of vertices (V) in the graph will not exceed 1000. * There will be at most (V^2) edges in the graph. * Ensure that your algorithm runs in (O(V + E)) time complexity where (E) is the number of edges. # Additional Notes 1. **Graph Representation**: Ensure to correctly parse the adjacency matrix representation of the graph. 2. **Vertex Identification**: Vertices are indexed starting from 0. 3. **Stack Management**: Ensure that vertices are properly pushed/popped to/from the stack as per Tarjan\'s algorithm. 4. **Result Formatting**: Sort each SCC before adding it to the result list for consistency and to facilitate testing. Good luck and ensure each part of the algorithm is meticulously implemented!","solution":"from typing import List def tarjans_scc(matrix: List[List[int]]) -> List[List[int]]: index = 0 stack = [] indexes = [-1] * len(matrix) lowlinks = [-1] * len(matrix) on_stack = [False] * len(matrix) result = [] def strong_connect(node): nonlocal index indexes[node] = index lowlinks[node] = index index += 1 stack.append(node) on_stack[node] = True for neighbor in range(len(matrix)): if matrix[node][neighbor]: if indexes[neighbor] == -1: strong_connect(neighbor) lowlinks[node] = min(lowlinks[node], lowlinks[neighbor]) elif on_stack[neighbor]: lowlinks[node] = min(lowlinks[node], indexes[neighbor]) if lowlinks[node] == indexes[node]: scc = [] while True: neighbor = stack.pop() on_stack[neighbor] = False scc.append(neighbor) if neighbor == node: break scc.sort() result.append(scc) for i in range(len(matrix)): if indexes[i] == -1: strong_connect(i) result.sort() return result"},{"question":"# Permutations of a String Given a string `s` containing distinct characters, write a function `generate_permutations` that returns all possible permutations of the characters in the string. Additionally, write an `iterative_permutations` function that returns an iterator yielding permutations one by one. # Function Signature: ```python def generate_permutations(s: str) -> List[str]: pass def iterative_permutations(s: str) -> Iterator[str]: pass ``` # Input: * `s`: a string containing distinct characters (1 ≤ |s| ≤ 8) # Output: * `generate_permutations(s)` should return a list of strings, where each string is a permutation of the input string. * `iterative_permutations(s)` should return an iterator yielding permutations of the input string one by one. # Constraints: * The input string contains only distinct characters. * The length of the input string is at most 8. * The solutions should handle edge cases and ensure efficient memory management and performance. # Examples: ```python assert sorted(generate_permutations(\\"abc\\")) == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert sorted(generate_permutations(\\"a\\")) == [\\"a\\"] assert sorted(list(iterative_permutations(\\"abc\\"))) == [\\"abc\\", \\"acb\\", \\"bac\\", \\"bca\\", \\"cab\\", \\"cba\\"] assert sorted(list(iterative_permutations(\\"a\\"))) == [\\"a\\"] ``` # Note: * Ensure your solution caters to the performance constraints. * The recursive approach should use a helper function as needed to organize the code. * The function should handle any potential edge cases according to the constraints provided.","solution":"from typing import List, Iterator from itertools import permutations def generate_permutations(s: str) -> List[str]: Generates all possible permutations of the characters in the input string and returns them as a list of strings. :param s: A string containing distinct characters :return: A list of permutations of the input string return [\'\'.join(p) for p in permutations(s)] def iterative_permutations(s: str) -> Iterator[str]: Returns an iterator that yields all possible permutations of the characters in the input string one by one. :param s: A string containing distinct characters :return: An iterator yielding permutations of the input string for p in permutations(s): yield \'\'.join(p)"},{"question":"# Objective: Implement an optimized version of Dijkstra\'s algorithm using a priority queue to efficiently calculate the shortest paths from a single source vertex to all other vertices in a graph. # Problem Statement: Given a directed, weighted graph with V vertices and E edges, and a source vertex S, write a function `dijkstra_algorithm` that calculates the shortest paths from S to all other vertices using the Dijkstra\'s algorithm with a priority queue. # Input: - An integer V (1 ≤ V ≤ 1000), the number of vertices. - An integer E (0 ≤ E ≤ 10,000), the number of edges. - A list of tuples `edges`, where each tuple (u, v, w) represents an edge from vertex u to vertex v with weight w (0 ≤ u, v < V and 1 ≤ w ≤ 1000). - An integer S (0 ≤ S < V), the source vertex. # Output: - A list of integers of length V, where the ith element represents the shortest distance from the source vertex S to vertex i. If a vertex is not reachable from S, its distance should be represented as \\"inf\\". # Example: ```python def dijkstra_algorithm(V, E, edges, S): # Your code here # Example Input: V = 5 E = 6 edges = [ (0, 1, 10), (0, 4, 5), (1, 2, 1), (4, 1, 3), (4, 2, 9), (4, 3, 2) ] S = 0 # Example Output: print(dijkstra_algorithm(V, E, edges, S)) # Output should be: [0, 8, 9, 7, 5] ``` # Constraints: - Ensure that the graph edges are stored in an efficient data structure for quick lookup. - Implement the priority queue using a heap data structure to achieve optimal time complexity. - Handle edge cases such as: - Disconnected vertices. - Vertices with no outgoing/incoming edges. # Note: - Do not assume that all vertices are reachable from the source. - Consider using a dictionary for the adjacency list representation of the graph to handle varying graph densities efficiently.","solution":"import heapq def dijkstra_algorithm(V, E, edges, S): # Create an adjacency list from edges graph = {i: [] for i in range(V)} for u, v, w in edges: graph[u].append((v, w)) # Initialize distances with infinity and source distance with zero distances = [float(\'inf\')] * V distances[S] = 0 # Use a priority queue to store (distance, vertex) priority_queue = [(0, S)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the distance in the priority queue is greater, skip processing if current_distance > distances[current_vertex]: continue # Explore neighbors for neighbor, weight in graph[current_vertex]: distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"Context You have been hired as a software engineer at a company that designs software for managing databases stored in flash memory devices. Due to wear limitations of flash memory, one of the primary concerns is minimizing the number of write operations. Task Implement the cycle sort algorithm that minimizes the number of write operations while sorting an array. Function Specification * **Function Name**: `cycle_sort` * **Input Format**: One single parameter `arr`, a list of integers. * **Output Format**: Return the sorted list of integers. Constraints * The length of the array will be between 1 and 10^3. * Elements in the array will be between -10^4 and 10^4. Performance Requirement Your solution should optimize the number of write operations while performing the sort. Example ```python def cycle_sort(arr): # Your implementation here pass # Example Usage: arr = [4, 3, 2, 1] sorted_arr = cycle_sort(arr) print(sorted_arr) # Output should be [1, 2, 3, 4] ``` **Note**: Focus on implementing the cycle sort algorithm correctly with minimal writes, and consider the edge cases such as empty arrays or arrays with duplicate elements.","solution":"def cycle_sort(arr): Perform cycle sort on the list `arr` and return the sorted list. writes = 0 # Number of write operations # Cycle through each element and perform the sorting for start in range(len(arr) - 1): item = arr[start] # Find the position where we put the element pos = start for i in range(start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == start: continue # Otherwise, put the item to its correct position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != start: pos = start for i in range(start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Roman Numeral Conversion Scenario Imagine you\'re developing an ancient calculator emulator which converts given numerical years into Roman numerals. The system you\'re developing will be used by historians to ensure that dates on documents are preserved and displayed correctly in Roman numeral format. Task Write a Python function `convert_to_roman` that takes an integer `num` as input and returns its Roman numeral representation. The input integer is guaranteed to be within the range from 1 to 3999. Implementation Implement the `convert_to_roman` function with the following signature: ```python def convert_to_roman(num): :type num: int :rtype: str ``` Expected Input and Output Formats * **Input**: A single integer `num` (1 <= num <= 3999). * **Output**: A string representing the Roman numeral of the given integer. Constraints and Limitations * The function should be efficient, with an expected time complexity of O(1). * Ensure the function handles edge cases like the smallest (1) and largest (3999) possible inputs. * Perform input validation and raise a `ValueError` if the input is out of the specified bounds. Example ```python assert convert_to_roman(29) == \\"XXIX\\" assert convert_to_roman(44) == \\"XLIV\\" assert convert_to_roman(1994) == \\"MCMXCIV\\" assert convert_to_roman(3999) == \\"MMMCMXCIX\\" assert convert_to_roman(1) == \\"I\\" ```","solution":"def convert_to_roman(num): Converts an integer to its Roman numeral representation. :type num: int :rtype: str if not (1 <= num <= 3999): raise ValueError(\\"Input number must be in the range 1 to 3999\\") values = [ (1000, \\"M\\"), (900, \\"CM\\"), (500, \\"D\\"), (400, \\"CD\\"), (100, \\"C\\"), (90, \\"XC\\"), (50, \\"L\\"), (40, \\"XL\\"), (10, \\"X\\"), (9, \\"IX\\"), (5, \\"V\\"), (4, \\"IV\\"), (1, \\"I\\") ] roman_numeral = \\"\\" for value, symbol in values: while num >= value: roman_numeral += symbol num -= value return roman_numeral"},{"question":"Scenario Imagine you are programming a drone navigation system. The drone can receive a series of commands and each command will move the drone one step in one of four directions: up (U), down (D), left (L), and right (R). You need to write a function to check if the sequence of moves will return the drone to its original starting point at coordinates (0, 0). Task Implement the function `returns_to_origin(moves)` that checks whether a given sequence of moves will bring the drone back to its starting point. Function Signature ```python def returns_to_origin(moves: str) -> bool: ``` Inputs and Outputs * **Input**: A string `moves` consisting of characters \'U\', \'D\', \'L\', \'R\'. * **Output**: A boolean value `True` if the drone returns to the origin, `False` otherwise. Constraints * All characters in the input will be one of \'U\', \'D\', \'L\', \'R\'. * The length of `moves` will not exceed 10,000. Examples ```python # Example 1 input: \\"UD\\" output: True # Example 2 input: \\"LL\\" output: False # Example 3 input: \\"UDLR\\" output: True # Example 4 input: \\"UUDDLLRR\\" output: True # Example 5 input: \\"UDLD\\" output: False ```","solution":"def returns_to_origin(moves: str) -> bool: Determines if a series of drone movements return to the starting point (0, 0). :param moves: A string containing characters \'U\', \'D\', \'L\', \'R\' :return: True if the drone returns to the origin, False otherwise x, y = 0, 0 for move in moves: if move == \'U\': y += 1 elif move == \'D\': y -= 1 elif move == \'L\': x -= 1 elif move == \'R\': x += 1 return x == 0 and y == 0"},{"question":"# Scenario You have recently joined a team working on a project to optimize sorting algorithms for a real-time data processing system. One of the core tasks is to efficiently sort incoming data which may vary significantly in size and content. # Task Implement an optimized version of the Shell Sort algorithm. Your task is to write a function `optimized_shell_sort` that sorts an array of integers using the Shell Sort algorithm. However, instead of the straightforward gap sequence `n//2`, you are to use the **Hibbard Gap Sequence** which is defined as `1, 3, 7, 15, 31, ... (2^k - 1)`. # Function Signature ```python def optimized_shell_sort(arr: List[int]) -> List[int]: pass ``` # Input * A list of integers `arr` with `1 <= len(arr) <= 10^6` and `-10^9 <= arr[i] <= 10^9` for all `i`. # Output * A sorted list of integers. # Constraints: * The solution should be efficient in terms of both time and space. * The algorithm must be implemented using the Hibbard gap sequence. # Examples ```python assert optimized_shell_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert optimized_shell_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([10]) == [10] ```","solution":"from typing import List def optimized_shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm with Hibbard Gap Sequence. n = len(arr) # Generate Hibbard gap sequence gaps = [] k = 1 while (2**k - 1) < n: gaps.append(2**k - 1) k += 1 # Start with the highest gap and work down to 1 for gap in reversed(gaps): for i in range(gap, n): temp = arr[i] j = i # Shift earlier gap-sorted elements up until the correct location for arr[i] is found while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap # Put temp (the original arr[i]) in its correct location arr[j] = temp return arr"},{"question":"# Question: Two Sum in Sorted Array You are given an array of integers sorted in ascending order. Write a function `two_sum_optimal(numbers, target)` that finds the indices of the two numbers that add up to a specific target value. Your returned indices (both index1 and index2) should be based on a 1-based indexing system, and index1 must be less than index2. # Function Signature: ```python def two_sum_optimal(numbers: List[int], target: int) -> List[int]: ``` # Input Parameters: - `numbers` (List[int]): an array of integers sorted in ascending order of length n, where 2 <= n <= 10^4. - `target` (int): the target sum # Output: - Returns a list of two integers [index1, index2] where: - `1 <= index1 < index2 <= len(numbers)` - `numbers[index1-1] + numbers[index2-1] == target` # Constraints: - You may assume that each input would have exactly one solution. - You may not use the same element twice. # Performance Requirement: - The solution should be optimal with a time complexity of O(n) and a space complexity of O(1). # Example: ```python numbers = [2, 7, 11, 15] target = 9 Output: [1, 2] ``` Explanation: The sum of numbers[0] and numbers[1] is equal to the target (2 + 7 = 9). The returned indices are 1-based. # Instructions: 1. Implement the function `two_sum_optimal` using an optimal approach. 2. Ensure your solution adheres to the outlined constraints and performance requirements. 3. Handle edge cases such as smallest and largest possible arrays correctly.","solution":"from typing import List def two_sum_optimal(numbers: List[int], target: int) -> List[int]: Given a sorted array `numbers`, find two indices such that the numbers at these indices add up to `target`. Indices are returned in 1-based indexing and index1 must be less than index2. Parameters: numbers (List[int]): Sorted list of integers. target (int): The target sum we are looking for. Returns: List[int]: A list of two integers representing the indices (1-based). left, right = 0, len(numbers) - 1 while left < right: current_sum = numbers[left] + numbers[right] if current_sum == target: return [left + 1, right + 1] # Return 1-based indices elif current_sum < target: left += 1 else: right -= 1 # Given problem constraints state that exactly one solution exists, so no need for further handling. return []"},{"question":"# Question: Implement Efficient Moving Average with Sliding Window You are given a sequence of integer values arriving one by one and a fixed-size window. Your task is to implement a class `EfficientMovingAverage` that calculates the moving average of all integers within the sliding window. **Requirements**: - Implement the class `EfficientMovingAverage` with the following methods: - `__init__(self, size: int)`: Initializes the object with the size of the window. - `next(self, val: int) -> float`: Accepts a new integer value and returns the current moving average of the sliding window. **Constraints**: - 1 <= size <= 1000 - -10^5 <= val <= 10^5 - At most 10^4 calls will be made to `next`. **Performance**: - Aim for O(1) time complexity for each call to the `next` method. **Example**: ```plaintext obj = EfficientMovingAverage(3) print(obj.next(1)) # Output: 1.0 print(obj.next(10)) # Output: 5.5 print(obj.next(3)) # Output: 4.666666666666667 print(obj.next(5)) # Output: 6.0 ``` **Explanation**: - After first call, the window will have `[1]`, so the average is `1`. - After the second call, the window will have `[1, 10]`, so the average is `(1+10)/2 = 5.5`. - After the third call, the window will have `[1, 10, 3]`, so the average is `(1+10+3)/3 ≈ 4.67`. - After the fourth call, the window will have `[10, 3, 5]`, as the oldest element `1` is removed, so the average is `(10+3+5)/3 = 6`. Solve this problem with optimal time complexity in mind.","solution":"from collections import deque class EfficientMovingAverage: def __init__(self, size: int): Initializes the EfficientMovingAverage with a given window size. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Adds a new value to the window and returns the current moving average. if len(self.window) == self.size: self.window_sum -= self.window.popleft() self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"# Context You are given an array of words and an array of symbols. Your goal is to replace the first occurrence of each symbol within a word with the symbol surrounded by square brackets. If a word matches more than one symbol, choose the longest symbol. # Function Description Implement the function `find_and_bracket(words, symbols)`. # Input * `words` (list of str): An array of words, where each word is a non-empty string. * `symbols` (list of str): An array of non-empty strings representing symbols. # Output * `result` (list of str): An array of words where matched symbols are replaced with the symbol surrounded by square brackets. # Requirements * If a word has multiple matching symbols, replace the match with the longest symbol. * Ensure efficient search operations to maximize performance. # Example ```python words = [\'Amazon\', \'Microsoft\', \'Google\'] symbols = [\'i\', \'Am\', \'cro\', \'Na\', \'le\', \'abc\'] Output: [\'[Am]azon\', \'Mi[cro]soft\', \'Goog[le]\'] ``` # Constraints * 1 ≤ `len(words)` ≤ 1000 * 1 ≤ `len(symbols)` ≤ 1000 * Each word and symbol has a length between 1 and 20 characters. Implement your function to solve this problem. Please ensure your code is efficient and can handle the upper boundary constraints effectively.","solution":"def find_and_bracket(words, symbols): Replaces the first occurrence of each symbol within a word with the symbol surrounded by square brackets. If a word matches more than one symbol, chooses the longest symbol. Parameters: words (list of str): An array of non-empty strings representing words. symbols (list of str): An array of non-empty strings representing symbols. Returns: list of str: An array of words with the matched symbols replaced by the symbol surrounded by square brackets. # Sort symbols by length in descending order to prioritize longer matches symbols = sorted(symbols, key=len, reverse=True) # Function to replace the first match in a word def replace_match(word): for symbol in symbols: if symbol in word: return word.replace(symbol, f\'[{symbol}]\', 1) return word return [replace_match(word) for word in words]"},{"question":"# Shortest Path in a Weighted Graph Given a directed, weighted graph represented by an adjacency matrix, implement the Dijkstra\'s algorithm to find the shortest paths from a single vertex to all other vertices in the graph. # Input - An integer `n` representing the number of vertices in the graph. - A 2D list `graph` of size `n x n`, where `graph[i][j]` represents the weight of the edge from vertex `i` to vertex `j`. If there is no edge, the weight will be `0`. All edge weights are non-negative. - An integer `src` representing the source vertex from which to calculate the shortest paths. # Output - A list of integers, where the `i-th` element represents the shortest distance from `src` to vertex `i`. # Example ```python # Example Input: n = 5 graph = [ [0, 10, 0, 0, 5], [0, 0, 1, 0, 2], [0, 0, 0, 4, 0], [7, 0, 6, 0, 0], [0, 3, 9, 2, 0] ] src = 0 # Expected Output: # [0, 8, 9, 7, 5] ``` # Constraints - There are no negative weight edges. - The graph is fully connected and directed. - The number of vertices `n` is between 2 and 1000. Implement the function `dijkstra(n, graph, src)` to compute the shortest distances: ```python def dijkstra(n, graph, src): # Your code here pass ```","solution":"import heapq def dijkstra(n, graph, src): Implements Dijkstra\'s algorithm to find the shortest paths from src to all other vertices. :param n: int - Number of vertices in the graph :param graph: 2D list - Adjacency matrix representing the graph :param src: int - Source vertex :return: List[int] - Shortest distances from src to all other vertices # Initialize distances array with infinity distances = [float(\'inf\')] * n distances[src] = 0 # Priority queue to store the vertices to be processed priority_queue = [(0, src)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) # If the distance is greater than the recorded distance, ignore if current_distance > distances[current_vertex]: continue # Examine adjacent nodes for neighbor in range(n): if graph[current_vertex][neighbor] > 0: distance = current_distance + graph[current_vertex][neighbor] # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Scenario You are a resource manager at a disaster relief organization. You need to maximize the total value of relief goods that can be packed into a transportation container which has a limited weight capacity. Each relief item has a specific weight and value. # Task Write a function `max_knapsack_value` to determine the maximum value of items that can be packed without exceeding the container\'s weight capacity. # Function Signature ```python def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: pass ``` # Input - `items`: A list of tuples where each tuple contains two integers, the first integer is the value of the item, and the second integer is the weight of the item. For example, `[(60, 5), (50, 3)]`. - `capacity`: An integer representing the weight capacity of the container. # Output - Returns an integer which is the maximum value obtainable without exceeding the capacity. # Constraints - The number of items (n) and capacity (m) are such that 1 ≤ n ≤ 1000 and 0 ≤ m ≤ 1000. - Each item\'s weight and value are positive integers. # Example ```python items = [(60, 5), (50, 3), (70, 4), (30, 2)] capacity = 5 print(max_knapsack_value(items, capacity)) # Output should be 80 ``` # Requirements Ensure your solution meets the following criteria: - **Efficiency**: The solution should run within the given constraints efficiently. - **Correctness**: Handle all edge cases correctly, including capacities of zero and items with zero or minimum weight.","solution":"from typing import List, Tuple def max_knapsack_value(items: List[Tuple[int, int]], capacity: int) -> int: Determines the maximum value of items that can be packed into a container with a limited weight capacity using the 0/1 Knapsack dynamic programming approach. Args: items (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers - the value and the weight of the item. capacity (int): The weight capacity of the container. Returns: int: The maximum value obtainable without exceeding the capacity. n = len(items) dp = [[0] * (capacity + 1) for _ in range(n + 1)] for i in range(1, n + 1): value, weight = items[i - 1] for w in range(capacity + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[n][capacity]"},{"question":"Implement a Custom Sorting Function You are required to implement a custom sorting function that sorts an array of integers using the Exchange Sort algorithm. Your function should handle various edge cases and ensure it operates within the constraints provided. Function Signature ```python def custom_exchange_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): A list of integers that needs to be sorted. The list length can range from 0 to 10,000. Output - Returns the sorted list in ascending order. Constraints - All elements in `arr` must be integers. - The function should handle sorting an empty list and a list with a single element correctly. Examples 1. Input: `[4, 2, 7, 1, 3]` Output: `[1, 2, 3, 4, 7]` 2. Input: `[10, 3, -2, 5, 7, -1]` Output: `[-2, -1, 3, 5, 7, 10]` 3. Input: `[]` Output: `[]` 4. Input: `[5]` Output: `[5]` Performance Requirements - Given the constraints, ensure that the implementation can handle inputs up to the maximum length efficiently, even though Exchange Sort is an O(n^2) algorithm. Notes - Pay attention to edge cases such as an empty list and a list with duplicated elements. - Document your code and explain any decisions or optimizations made.","solution":"from typing import List def custom_exchange_sort(arr: List[int]) -> List[int]: Sort an array of integers using the Exchange Sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: List[int]: A new list of integers sorted in ascending order. n = len(arr) # Make a copy of the array to avoid mutating the original list. sorted_arr = arr[:] for i in range(n): for j in range(i + 1, n): if sorted_arr[i] > sorted_arr[j]: # Swap elements if they are in the wrong order. sorted_arr[i], sorted_arr[j] = sorted_arr[j], sorted_arr[i] return sorted_arr"},{"question":"# Shell Sort Implementation with Problem Constraints You are tasked with improving a given sorting algorithm called Shell Sort. This does not simply require understanding and applying Shell Sort, but also ensuring that your implementation can handle large datasets efficiently by modifying the gap sequence used in the algorithm. Problem Statement Write a function `improved_shell_sort` that sorts a given list of integers using the Shell Sort algorithm with an optimized gap sequence to improve performance. Function Signature ```python def improved_shell_sort(arr: List[int]) -> List[int]: pass ``` Input - A single parameter, `arr`: a list of integers of size `n` (0 <= n <= 10^6). Output - A single sorted list of integers. Example ```python assert improved_shell_sort([8, 5, 3, 6, 9]) == [3, 5, 6, 8, 9] assert improved_shell_sort([2, 3, 2, 2, 3]) == [2, 2, 2, 3, 3] ``` Constraints - Your implementation should sort the list efficiently within a reasonable time frame for large inputs. - Use an optimized gap sequence to enhance performance. Performance Requirements - Your solution should have a lower time complexity than the average case O(n^2) for naïve Shell Sort. Notes - Consider the optimal gap sequences used in practice like Sedgewick\'s or Hibbard\'s to improve the performance of your implementation.","solution":"from typing import List def improved_shell_sort(arr: List[int]) -> List[int]: Sorts the given list of integers using the Shell Sort algorithm with an optimized gap sequence (Sedgewick\'s increments). n = len(arr) # Using Sedgewick\'s gap sequence: 1, 5, 19, 41, 109, ... # gaps = 1, 4*3^k - 2^k + 1, 2^(k+2)(2^(k+2) - 3)+1 gaps = [] k = 0 while True: gap1 = 4**k + 3*2**(k-1) + 1 if k > 0 else 1 if gap1 > n: break gaps.append(gap1) k += 1 gaps.reverse() for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Binary Exponentiation Challenge Context: In many computational problems, particularly those involving large numbers, efficient computation of powers is crucial. Binary exponentiation is one such method that speeds up the process significantly compared to the naive approach. Task: Your task is to implement a function that computes the power of a given base and exponent using binary exponentiation. You must also provide a variant of your function that supports modular arithmetic to prevent overflow issues. Function Signature: ```python def binary_exponentiation(base: int, exp: int, mod: int = None) -> int: Calculate base ^ exp using binary exponentiation. If mod is provided, return the result modulo mod. :param base: The base number (an integer) :param exp: The exponent (a non-negative integer) :param mod: An optional modulo value (a positive integer) :return: The result of base^exp (mod given value, if provided) pass ``` Constraints: 1. The `base` is an integer such that -10^9 ≤ base ≤ 10^9. 2. The `exp` is a non-negative integer such that 0 ≤ exp ≤ 10^9. 3. The `mod` is an optional parameter; if provided, it is a positive integer. Input: * An integer `base` * A non-negative integer `exp` * An optional positive integer `mod` Output: * An integer result of base^exp, optionally modulo `mod`. Examples: ```python assert binary_exponentiation(2, 10) == 1024 assert binary_exponentiation(2, 10, 1000) == 24 assert binary_exponentiation(3, 7, 100) == 87 assert binary_exponentiation(5, 0) == 1 assert binary_exponentiation(10, 7, 1) == 0 assert binary_exponentiation(-2, 3) == -8 assert binary_exponentiation(2, 3) == 8 ``` Considerations: Think through the edge cases, such as when the exponent is zero, when the modulo is provided versus when it is not, and when operating with large numbers. Ensure that your function performs efficiently and handles all possible inputs appropriately.","solution":"def binary_exponentiation(base: int, exp: int, mod: int = None) -> int: Calculate base ^ exp using binary exponentiation. If mod is provided, return the result modulo mod. :param base: The base number (an integer) :param exp: The exponent (a non-negative integer) :param mod: An optional modulo value (a positive integer) :return: The result of base^exp (mod given value, if provided) if exp < 0: raise ValueError(\\"Exponent should be a non-negative integer.\\") if mod is not None and mod <= 0: raise ValueError(\\"Modulo should be a positive integer.\\") result = 1 base = base % mod if mod else base while exp > 0: if exp % 2 == 1: # If exp is odd, multiply base with the result result = (result * base) % mod if mod else result * base base = (base * base) % mod if mod else base * base exp //= 2 return result % mod if mod else result"},{"question":"# Question: Optimized Sieve of Eratosthenes Prime Generator Suppose you are working on a cryptographic application where you need to frequently generate a list of prime numbers less than a given integer `n`. Implement the `get_primes(n)` function using the optimized Sieve of Eratosthenes algorithm discussed. # Function Signature ```python def get_primes(n: int) -> List[int]: pass ``` # Input - A single integer `n` (1 <= n <= 10^6): The upper limit (exclusive) for generating prime numbers. # Output - A list of all prime numbers less than `n` in ascending order. # Requirements - Your function should handle the given constraints within a reasonable time frame. - If `n` <= 1, return an empty list. - The function should throw a `ValueError` if `n` is not a positive integer. # Constraints - Time complexity must be O(n log log n). - Space complexity must be O(n). # Example ```python assert get_primes(10) == [2, 3, 5, 7] assert get_primes(20) == [2, 3, 5, 7, 11, 13, 17, 19] assert get_primes(2) == [2] try: get_primes(-5) except ValueError: print(\\"ValueError\\") # This should be printed ``` Write the implementation for `get_primes(n)` function.","solution":"from typing import List def get_primes(n: int) -> List[int]: Returns a list of prime numbers less than `n` using the Sieve of Eratosthenes algorithm. if n < 1: raise ValueError(\\"Input must be a positive integer.\\") if n <= 2: return [] sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(n**0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False return [num for num in range(2, n) if sieve[num]]"},{"question":"# Stack-backed Browser History Tracker Introduction You are required to develop a simple browser history tracker using a stack data structure. The browser history will allow you to perform actions such as visiting new URLs and going back to previously visited URLs. Problem Statement Implement the following class: ```python class BrowserHistory: # Initializes the object with the homepage of the browser. def __init__(self, homepage: str): pass # Visits a new URL from the current page. It clears up the forward history. def visit(self, url: str) -> None: pass # Moves back \'steps\' pages. If you can only go back less steps than required, go as far back as possible. def back(self, steps: int) -> str: pass # Moves forward \'steps\' pages. If you can only go forward less steps than required, go as far forward as possible. def forward(self, steps: int) -> str: pass ``` Requirements 1. Implement a constructor `__init__(self, homepage: str)` that initializes the object with the homepage. 2. Implement `visit(self, url: str) -> None` to visit a new URL. This should push the URL to the stack and clear the forward history. 3. Implement `back(self, steps: int) -> str` to move back a certain number of pages. 4. Implement `forward(self, steps: int) -> str` to move forward a certain number of pages. Constraints - The `homepage`, `url` strings will have at most length 100, and contain only printable ASCII characters. - `steps` will be between 1 and 500 inclusive. - You should maintain `O(1)` time complexity for `back` and `forward` operations. Example ```python history = BrowserHistory(\\"homepage.com\\") history.visit(\\"page1.com\\") history.visit(\\"page2.com\\") print(history.back(1)) # Output: \'page1.com\' print(history.back(1)) # Output: \'homepage.com\' print(history.forward(1)) # Output: \'page1.com\' history.visit(\\"page3.com\\") print(history.back(2)) # Output: \'homepage.com\' print(history.forward(2)) # Output: \'page3.com\' ``` Notes - Utilize two stacks, one for the back history and one for the forward history. - When a new URL is visited, clear the forward history. - Handle edge cases like back or forward more steps than history length gracefully.","solution":"class BrowserHistory: def __init__(self, homepage: str): self.back_stack = [homepage] self.forward_stack = [] def visit(self, url: str) -> None: self.back_stack.append(url) self.forward_stack.clear() def back(self, steps: int) -> str: while steps > 0 and len(self.back_stack) > 1: self.forward_stack.append(self.back_stack.pop()) steps -= 1 return self.back_stack[-1] def forward(self, steps: int) -> str: while steps > 0 and self.forward_stack: self.back_stack.append(self.forward_stack.pop()) steps -= 1 return self.back_stack[-1]"},{"question":"Context: You are tasked with implementing an enhanced Insertion Sort algorithm that uses binary search to locate the insertion point efficiently. This should help in reducing the number of comparisons required to find the correct position for each element in the partially sorted array. Problem: Write a function `binary_insertion_sort(array)` that sorts the given list in ascending order using Insertion Sort enhanced with binary search to locate the correct insertion position. You should only modify the `binary_insertion_sort` function, as the `search_insert` function is already provided. Provided Function: ```python def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low ``` Expected Input and Output * **Input:** A list of integers `array` (can be an empty list). * **Output:** The same list sorted in ascending order. Constraints: * The function should work for lists of varying lengths, from 0 to 10^4 elements. * The function should strive to have O(n^2) complexity in the worst case, but should often be faster due to insertion point optimization. Function Signature: ```python def binary_insertion_sort(array): pass ``` Example: ```python array = [20, 5, 18, 14, 3, 9] binary_insertion_sort(array) print(array) # Output should be [3, 5, 9, 14, 18, 20] ```","solution":"def search_insert(array, val): low = 0 high = len(array) - 1 while low <= high: mid = low + (high - low) // 2 if val > array[mid]: low = mid + 1 else: high = mid - 1 return low def binary_insertion_sort(array): for i in range(1, len(array)): key = array[i] # Find the insertion point using binary search j = search_insert(array[:i], key) # Move elements from j to i-1 up by one position for k in range(i, j, -1): array[k] = array[k-1] array[j] = key"},{"question":"# Matrix Inversion Challenge You are required to implement a function to invert a given square matrix. The function should handle matrices of size n x n and account for various edge cases such as non-invertible matrices. Function Signature ```python def invert_matrix(m: List[List[float]]) -> List[List[float]]: ``` Input * A 2D list `m` representing an n x n matrix where `1 <= n <= 10`. Each element of the matrix is a float representing numbers in the matrix. Output * A 2D list representing the inverted matrix if it exists. * Return a list with a single element `[-1]` if the input list is not a proper square matrix. * Return a list with a single element `[-2]` if the input matrix is square but has a zero determinant (i.e., it is singular). * The input matrices will not be empty. Constraints * The input matrix will have valid dimensions (i.e., not jagged and each row will have the same number of elements). Example ```python assert invert_matrix([[1, 2], [3, 4]]) == [[-2.0, 1.0], [1.5, -0.5]] assert invert_matrix([[0, 0], [0, 0]]) == [[-2]] assert invert_matrix([[1, 2, 3], [0, 1, 4], [5, 6, 0]]) == [[-24.0, 18.0, 5.0], [20.0, -15.0, -4.0], [-5.0, 4.0, 1.0]] ``` Requirements 1. **Error Handling**: Validate that the matrix is square and handle relevant edge cases by returning an appropriate error code. 2. **Matrix Determination**: Implement the recursive determinant calculation. 3. **Inversion Logic**: Follow the prescribed steps—matrix of minors, matrix of cofactors, adjugate, and inversion. 4. **Efficiency**: Maintain comprehensibility and readability while addressing performance wherever possible without changing the fundamental approach. Good luck coding!","solution":"from typing import List def determinant(matrix: List[List[float]]) -> float: Calculate the determinant of a square matrix. if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1) ** c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det def minor(matrix: List[List[float]], i: int, j: int) -> List[List[float]]: Return the Minor of the matrix excluding the i-th row and j-th column. return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def transpose(matrix: List[List[float]]) -> List[List[float]]: Return the transpose of the matrix. return list(map(list, zip(*matrix))) def cofactor(matrix: List[List[float]]) -> List[List[float]]: Return the matrix of cofactors of the matrix. cofactors = [] for r in range(len(matrix)): cofactor_row = [] for c in range(len(matrix)): minor_det = determinant(minor(matrix, r, c)) cofactor_row.append(((-1) ** (r + c)) * minor_det) cofactors.append(cofactor_row) return cofactors def invert_matrix(m: List[List[float]]) -> List[List[float]]: Returns the inverted matrix if it exists, otherwise error codes: [-1] for non-square matrix [-2] for non-invertible matrix n = len(m) # Check if the matrix is square if not all(len(row) == n for row in m): return [-1] # Calculate the determinant of the matrix det = determinant(m) if det == 0: return [-2] # Matrix is non-invertible # Calculate the matrix of cofactors cofactors = cofactor(m) # Transpose the matrix of cofactors to get the adjugate adjugate = transpose(cofactors) # Divide each element of the adjugate by the determinant to get the inverse inverse = [] for r in adjugate: row = [x / det for x in r] inverse.append(row) return inverse"},{"question":"# Ternary Search for Product IDs You are given a sorted list of product IDs in ascending order. You need to implement a function using the ternary search algorithm to determine the index of a specific product ID in this list. If the product ID is not found, the function should return `-1`. Function Signature ```python def find_product_id(product_ids: List[int], key: int) -> int: pass ``` Input * `product_ids` (List[int]): A sorted list of product IDs in ascending order. * `key` (int): The product ID to search for. Output * An integer representing the index of the product ID if found, otherwise `-1`. Constraints * The length of `product_ids` will be between `1` and `10^6`. * Each element in `product_ids` is unique and within the range `1` to `10^6`. * The product ID to be searched (`key`) is within the range of `1` to `10^6`. Example ```python product_ids = [101, 203, 302, 450, 502, 600, 750, 800, 900, 1001] key = 750 find_product_id(product_ids, key) # returns 6 product_ids = [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000] key = 1500 find_product_id(product_ids, key) # returns -1 ``` Performance Requirements * The solution should be efficient with respect to both time and space complexity. * The solution should execute in O(log3(N)) time complexity and use O(1) additional space. Scenario You are a database administrator and you need to quickly locate product IDs in a sorted list without having to scan through each element. Implementing this using ternary search will allow you to efficiently handle queries, especially as the size of the database grows.","solution":"from typing import List def find_product_id(product_ids: List[int], key: int) -> int: Determines the index of a specific product ID using ternary search algorithm. Returns -1 if the product ID is not found. left, right = 0, len(product_ids) - 1 while left <= right: # Divide the range into three parts third = (right - left) // 3 mid1 = left + third mid2 = right - third if product_ids[mid1] == key: return mid1 if product_ids[mid2] == key: return mid2 if key < product_ids[mid1]: right = mid1 - 1 elif key > product_ids[mid2]: left = mid2 + 1 else: left = mid1 + 1 right = mid2 - 1 return -1"},{"question":"# Coding Challenge: Verify Sorted Stack Scenario You are working on a project that requires validating the order of elements in various data structures. One of the key data structures used extensively in this project is a stack. The order of elements in the stack represents the priority with which tasks should be executed. It is critical that these elements are in ascending order from the bottom of the stack to the top. To ensure the integrity of task execution, you need to verify that the elements in a given stack are sorted correctly. Task Write a Python function `is_sorted(stack: List[int]) -> bool` that takes a stack as input and returns `True` if the elements are sorted in ascending order from the bottom to the top of the stack, and `False` otherwise. Input and Output Formats * **Input**: A list of integers representing the stack. The end of the list corresponds to the top of the stack. * **Output**: A boolean value - `True` if the stack is sorted in ascending order from the bottom, `False` otherwise. Constraints * The stack should not be altered after the function call. * The function should handle edge cases gracefully, such as an empty stack or a stack with a single element. * The solution should strive for O(n) time complexity and O(1) or minimal space complexity beyond the input stack. Example ```python # Example 1 stack = [1, 2, 3, 4, 5, 6] print(is_sorted(stack)) # Output: True # Example 2 stack = [6, 5, 4, 3, 2, 1] print(is_sorted(stack)) # Output: False # Example 3 stack = [1] print(is_sorted(stack)) # Output: True ``` Write the function `is_sorted(stack)` to solve this problem. Ensure that the original stack remains unchanged after the function call.","solution":"def is_sorted(stack): Checks if the elements in the stack are sorted in ascending order from bottom to top. Parameters: stack (list[int]): The stack represented as a list of integers. Returns: bool: True if the stack is sorted in ascending order, False otherwise. for i in range(len(stack) - 1): if stack[i] > stack[i + 1]: return False return True"},{"question":"# RSA Key Generation, Encryption, and Decryption As part of your assessments, you need to implement components of the RSA encryption algorithm to measure the understanding of your students. Your task is to complete the implementation of the RSA cryptographic algorithm for secure data transmission. **Functions to Implement**: 1. **find_mod_inverse(a, m)**: - Find the modular inverse `b` such that `(a * b) % m == 1`. - Inputs: non-negative integers `a`, `m` where `a < m`. - Output: integer `b`. 2. **is_prime(num)**: - Check if the given number `num` is prime. - Inputs: a positive integer `num`. - Output: Boolean value, `True` if `num` is prime, otherwise `False`. 3. **generate_prime(bits, seed=None)**: - Generate a random prime number with the specified number of bits. - Inputs: integer `bits`, optional seed for random number generation. - Output: integer prime number with the specified bit-length. # Function Specifications **find_mod_inverse(a, m)** ```python def find_mod_inverse(a, m) -> int: \'\'\' Find and return the modular inverse of a modulo m. \'\'\' # your code here ``` **is_prime(num)** ```python def is_prime(num) -> bool: \'\'\' Determine if the number num is prime. \'\'\' # your code here ``` **generate_prime(bits, seed=None)** ```python def generate_prime(bits: int, seed=None) -> int: \'\'\' Generate and return a prime number with the specified number of bits. \'\'\' # your code here ``` # Constraints - `bits`: Positive integer in the range [8, 1024] for generating prime numbers. - Your solution should handle edge cases such as small bit sizes or scenarios where suitable primes are hard to find. # Example Usage ```python # Use case example n, e, d = generate_key(16) data = 42 encrypted_data = encrypt(data, e, n) decrypted_data = decrypt(encrypted_data, d, n) assert decrypted_data == data ``` # Evaluation Criteria - Correctness: Your implemented functions should be correct and pass test cases. - Efficiency: The performance of your algorithm should be reasonable for the problem constraints. - Code Quality: Code should be clean, modular, and well-documented.","solution":"import random def find_mod_inverse(a, m): Find and return the modular inverse of a modulo m. def egcd(a, b): if a == 0: return b, 0, 1 else: g, x, y = egcd(b % a, a) return g, y - (b // a) * x, x g, x, y = egcd(a, m) if g != 1: raise ValueError(f\\"No modular inverse found for a = {a} and m = {m}\\") return x % m def is_prime(num): Determine if the number num is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def generate_prime(bits, seed=None): Generate and return a prime number with the specified number of bits. if seed is not None: random.seed(seed) lower_bound = 1 << (bits - 1) upper_bound = (1 << bits) - 1 while True: num = random.randint(lower_bound, upper_bound) if is_prime(num): return num"},{"question":"# Question You have been given a simple cipher algorithm called the Atbash Cipher. The Atbash cipher substitutes each letter of the alphabet with its opposite letter in the alphabet (i.e., \'a\' is substituted with \'z\', \'b\' with \'y\', etc.). Non-alphabetic characters remain unchanged. You are tasked with implementing a function that performs the Atbash cipher encryption on a given input string. Function Signature: ```python def atbash_cipher(input_string: str) -> str: ``` Input: - `input_string`: A string `s` containing a mix of alphabetic and non-alphabetic characters. Output: - Returns a string that is the result of applying the Atbash cipher to `input_string`. Example: ```python assert atbash_cipher(\\"Attack at dawn\\") == \\"Zggzxp zg wzdm\\" assert atbash_cipher(\\"Hello, World!\\") == \\"Svool, Dliow!\\" assert atbash_cipher(\\"python-123\\") == \\"kbgslm-123\\" assert atbash_cipher(\\"\\") == \\"\\" ``` Constraints: - The input string can be of length `0 <= len(s) <= 10^6`. - The function should handle both upper and lower case letters appropriately. Performance Requirements: - Time complexity should be O(n) where n is the length of the input string. - Space complexity should also be O(n) as it stores the resulting translated string. Ensure that the function handles edge cases correctly, such as empty strings or strings with only non-alphabetic characters.","solution":"def atbash_cipher(input_string: str) -> str: result = [] for char in input_string: if \'a\' <= char <= \'z\': result.append(chr(ord(\'z\') - (ord(char) - ord(\'a\')))) elif \'A\' <= char <= \'Z\': result.append(chr(ord(\'Z\') - (ord(char) - ord(\'A\')))) else: result.append(char) return \'\'.join(result)"},{"question":"# The Unique Pair Finder (Advanced XOR Application) You are given an array of integers, `nums`, where exactly two elements appear only once and all the other elements appear exactly twice. Your task is to identify those two unique elements. Using an efficient algorithm with both **O(N) time complexity** and **O(1) space complexity**, find and return these two unique elements. Example: ```python Given nums = [1, 2, 1, 3, 2, 5], return [3, 5]. ``` *Note: The order of the result does not matter; hence, `[5, 3]` is also an acceptable output in this case.* Function Signature: ```python def find_unique_pair(nums: List[int]) -> List[int]: :param nums: List[int] - a list of integers where exactly two elements appear only once and the rest appear exactly twice :return: List[int] - a list containing the two unique elements ``` Constraints: 1. The length of the array will always be at least 2. 2. It is guaranteed that exactly two elements will appear only once. Performance Requirements: 1. **Time Complexity**: O(N) 2. **Space Complexity**: O(1) Guidance: 1. Use XOR to isolate the combination of the two unique numbers. 2. Exploit the properties of XOR to single out the two unique elements.","solution":"from typing import List def find_unique_pair(nums: List[int]) -> List[int]: xor_all = 0 for num in nums: xor_all ^= num # Get the rightmost set bit in xor_all rightmost_set_bit = xor_all & -xor_all unique1 = 0 unique2 = 0 # Divide array elements into two groups and XOR separately for num in nums: if num & rightmost_set_bit: unique1 ^= num else: unique2 ^= num return [unique1, unique2]"},{"question":"Efficient Sparse Vector Operations Scenario: Your company is dealing with a large amount of high-dimensional data where most of the elements are zero (sparse vectors). To optimize storage and computational efficiency, you have been tasked with implementing a system to store these vectors and quickly compute their dot products. Task: Write a Python program that includes the following components: 1. **Sparse Vector Storage**: Implement a function `vector_to_index_value_list` that converts a given list (vector) into a list of (index, value) pairs, omitting all entries where the value is zero. 2. **Dot Product Computation**: Implement a function `dot_product` that takes two lists of (index, value) pairs and computes their dot product. Function Signatures: ```python def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: pass def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: pass ``` Input and Output: 1. **vector_to_index_value_list** * **Input**: A list of floats representing the vector. * **Output**: A list of tuples, where each tuple contains an index and a non-zero value from the original list. 2. **dot_product** * **Input**: Two lists of tuples. Each tuple contains an index and a value, representing non-zero entries of two sparse vectors. * **Output**: A single float value representing the dot product of the two vectors. Constraints: * The input vectors can be very large, but most elements will be zero. * The non-zero elements will not be too frequent, ensuring sparsity. * The vectors can have different lengths. * You are not allowed to use external libraries for sparse vector computations. Example: ```python vector = [1.0, 0.0, 2.0, 0.0, 0.0, 3.0] iv_list = vector_to_index_value_list(vector) # iv_list should be [(0, 1.0), (2, 2.0), (5, 3.0)] iv_list1 = [(0, 1.0), (2, 2.0), (5, 3.0)] iv_list2 = [(0, 4.0), (2, 0.5), (4, 1.0), (5, 2.0)] result = dot_product(iv_list1, iv_list2) # result should be 1.0*4.0 + 2.0*0.5 + 3.0*2.0 = 11.0 ``` Performance Requirements: * Your solution should efficiently handle vectors with up to millions of elements, though only thousands of these may be non-zero.","solution":"from typing import List, Tuple def vector_to_index_value_list(vector: List[float]) -> List[Tuple[int, float]]: Converts a vector into a list of (index, value) pairs, omitting zero entries. Parameters: - vector: List[float] : A list of floats representing the vector. Returns: - List[Tuple[int, float]] : A list of tuples containing index and non-zero value. return [(i, v) for i, v in enumerate(vector) if v != 0] def dot_product(iv_list1: List[Tuple[int, float]], iv_list2: List[Tuple[int, float]]) -> float: Computes the dot product of two sparse vectors represented as lists of (index, value) pairs. Parameters: - iv_list1: List[Tuple[int, float]] : First sparse vector as a list of (index, value) pairs. - iv_list2: List[Tuple[int, float]] : Second sparse vector as a list of (index, value) pairs. Returns: - float : The dot product of the two vectors. index_dict1 = dict(iv_list1) index_dict2 = dict(iv_list2) dot_product_result = sum(index_dict1[i] * index_dict2[i] for i in index_dict1 if i in index_dict2) return dot_product_result"},{"question":"# Matrix Inversion Challenge Given an n x n matrix, invert the matrix if it is invertible (i.e., non-singular). If the matrix is not invertible or does not meet the specified conditions, return appropriate error messages. Function Signature ```python def invert_matrix(m: List[List[float]]) -> List[List[float]]: ``` # Input * A matrix `m` represented by a 2D list of numbers (floats). * The matrix is guaranteed to have the same number of rows and columns. # Output * If the matrix is invertible, return the inverted matrix as a 2D list of floats. * If the matrix is not invertible, return one of the following error matrices: - `[[ -1 ]]` if the input is not a matrix. - `[[ -2 ]]` if the matrix is not square. - `[[ -3 ]]` if the matrix is too small (below 2x2). - `[[ -4 ]]` if the matrix is singular (determinant is zero). # Constraints * Matrix sizes will range from 2x2 to 10x10. * Elements of the matrix will be real numbers (positive or negative). # Performance Requirements * Given the complexity of matrix inversion, aim to handle matrices up to size 10x10 efficiently. # Example Scenarios 1. **Scenario 1**: - **Input**: `[[4, 7], [2, 6]]` - **Output**: `[[0.6, -0.7], [-0.2, 0.4]]` 2. **Scenario 2**: - **Input**: `[[1, 2], [2, 4]]` (singular matrix) - **Output**: `[[-4]]` 3. **Scenario 3**: - **Input**: `[[5]]` (non-invertible small matrix) - **Output**: `[[-3]]` Write a function implementing the above requirements and test with various edge cases as mentioned in the example scenarios.","solution":"from typing import List import numpy as np def invert_matrix(m: List[List[float]]) -> List[List[float]]: Returns the inverse of a square matrix if it is invertible. Otherwise, return an appropriate error code. # Check if the input is a list of lists if not isinstance(m, list) or not all(isinstance(row, list) for row in m): return [[-1]] # Check if the matrix is square n = len(m) for row in m: if len(row) != n: return [[-2]] # Check if the matrix is at least 2x2 if n < 2: return [[-3]] # Convert to numpy array for inversion matrix = np.array(m) # Check if the matrix is singular if np.linalg.det(matrix) == 0: return [[-4]] # Calculate the inverse of the matrix matrix_inv = np.linalg.inv(matrix) return matrix_inv.tolist()"},{"question":"# Coding Challenge: Find the nth Digit in a Sequence Background Imagine we have an infinite sequence of all positive integers written consecutively in a string: \\"123456789101112...\\". This string starts with \\"123456789101112...\\" and continues infinitely. Task You are required to implement a function `find_nth_digit(n)` that returns the nth digit (1-based index) in this infinite sequence. Expected Inputs and Outputs * **Input**: A single integer n, where 1 <= n <= 2*10^9. * **Output**: A single integer that represents the nth digit in the sequence. Constraints * You must handle very large values of n, ensuring efficiency and correct results. Example 1. `find_nth_digit(3)` should return `3`. 2. `find_nth_digit(11)` should return `0`. 3. `find_nth_digit(15)` should return `2` (sequence: \\"123456789101112...\\"). Function Signature ```python def find_nth_digit(n: int) -> int: pass ``` Notes 1. Ensure that your function has a time complexity better than O(n), preferably O(log n). 2. Pay special attention to integer division and indexing to avoid common pitfalls. 3. Write clear and concise code, and add comments to explain your logic where necessary.","solution":"def find_nth_digit(n: int) -> int: Finds the nth digit in an infinite sequence of integers. length = 1 count = 9 start = 1 # Determine the range in which the nth digit falls while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the exact number where the nth digit is located start += (n - 1) // length s = str(start) # Find the exact digit within that number return int(s[(n - 1) % length])"},{"question":"# Sudoku Solver: Complete the Board You are tasked with implementing a Sudoku solver. You need to fill an incomplete 9x9 Sudoku board using a backtracking algorithm. A Sudoku board (partially filled) is given with digits `1-9` and empty cells represented by the character `\'.\'`. You need to complete the board such that each row, each column, and each of the nine 3x3 sub-grids that make up the grid (also called \\"boxes\\") contains all of the digits from 1 to 9 exactly once. # Function Signature ```python def solveSudoku(board: List[List[str]]) -> None: # Implement the function here ``` # Input Format - A 9x9 board where each cell contains a digit `1-9` or `\'.\'`. # Output Format - In-place modification of the original board, filling in all `\'.\'` with digits `1-9` to complete the Sudoku as per the rules. # Constraints - The given board will only contain digits `1-9` and `\'.\'`. - The solution must use backtracking and must result in a completed Sudoku board. # Example Input ```python board = [ [\\"5\\",\\"3\\",\\".\\",\\".\\",\\"7\\",\\".\\",\\".\\",\\".\\",\\".\\"], [\\"6\\",\\".\\",\\".\\",\\"1\\",\\"9\\",\\"5\\",\\".\\",\\".\\",\\".\\"], [\\".\\",\\"9\\",\\"8\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\"], [\\"8\\",\\".\\",\\".\\",\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\"3\\"], [\\"4\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\"3\\",\\".\\",\\".\\",\\"1\\"], [\\"7\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\".\\",\\".\\",\\".\\",\\"6\\"], [\\".\\",\\"6\\",\\".\\",\\".\\",\\".\\",\\".\\",\\"2\\",\\"8\\",\\".\\"], [\\".\\",\\".\\",\\".\\",\\"4\\",\\"1\\",\\"9\\",\\".\\",\\".\\",\\"5\\"], [\\".\\",\\".\\",\\".\\",\\".\\",\\"8\\",\\".\\",\\".\\",\\"7\\",\\"9\\"] ] solveSudoku(board) print(board) ``` Output ```python [ [\\"5\\",\\"3\\",\\"4\\",\\"6\\",\\"7\\",\\"8\\",\\"9\\",\\"1\\",\\"2\\"], [\\"6\\",\\"7\\",\\"2\\",\\"1\\",\\"9\\",\\"5\\",\\"3\\",\\"4\\",\\"8\\"], [\\"1\\",\\"9\\",\\"8\\",\\"3\\",\\"4\\",\\"2\\",\\"5\\",\\"6\\",\\"7\\"], [\\"8\\",\\"5\\",\\"9\\",\\"7\\",\\"6\\",\\"1\\",\\"4\\",\\"2\\",\\"3\\"], [\\"4\\",\\"2\\",\\"6\\",\\"8\\",\\"5\\",\\"3\\",\\"7\\",\\"9\\",\\"1\\"], [\\"7\\",\\"1\\",\\"3\\",\\"9\\",\\"2\\",\\"4\\",\\"8\\",\\"5\\",\\"6\\"], [\\"9\\",\\"6\\",\\"1\\",\\"5\\",\\"3\\",\\"7\\",\\"2\\",\\"8\\",\\"4\\"], [\\"2\\",\\"8\\",\\"7\\",\\"4\\",\\"1\\",\\"9\\",\\"6\\",\\"3\\",\\"5\\"], [\\"3\\",\\"4\\",\\"5\\",\\"2\\",\\"8\\",\\"6\\",\\"1\\",\\"7\\",\\"9\\"] ] ``` # Note - You do not need to check if the initial board is valid. - You may assume that there will be only one unique solution to the Sudoku puzzle.","solution":"from typing import List def solveSudoku(board: List[List[str]]) -> None: Modifies the board in-place to complete the Sudoku puzzle. def is_valid(board: List[List[str]], row: int, col: int, num: str) -> bool: for i in range(9): if board[row][i] == num or board[i][col] == num: return False box_row_start = (row // 3) * 3 box_col_start = (col // 3) * 3 for i in range(3): for j in range(3): if board[box_row_start + i][box_col_start + j] == num: return False return True def solve(board: List[List[str]]) -> bool: for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in \'123456789\': if is_valid(board, row, col, num): board[row][col] = num if solve(board): return True board[row][col] = \'.\' return False return True solve(board)"},{"question":"Design and implement a data structure named `RandomizedMultiSet` that supports the following operations in average O(1) time complexity: 1. **insert(val)**: Inserts an item val into the multiset. 2. **remove(val)**: Removes an item val from the multiset if present. 3. **get_random()**: Returns a random element from the current multiset. Each element, including duplicates, must have the same probability of being returned. # Constraints - The value of the element to be inserted or removed is an integer. - Multiple instances of the same element are allowed. - If there are no elements in the multiset and `get_random()` is called, the implementation should handle it appropriately (e.g., raise an exception or return a specific indicator value). # Input and Output Formats - **insert(val)**: - Input: `integer` - Output: `boolean` indicating if the insertion was successful. - **remove(val)**: - Input: `integer` - Output: `boolean` indicating if the removal was successful. - **get_random()**: - Input: None - Output: Random integer from the multiset. # Performance Requirements - Aim for O(1) average time complexity for insert, remove, and get_random operations. - Properly handle edge cases like accessing an empty set. # Example ```python ms = RandomizedMultiSet() print(ms.insert(1)) # True, since 1 is successfully inserted print(ms.insert(2)) # True, since 2 is successfully inserted print(ms.insert(1)) # True, since 1 is again successfully inserted (multiset) print(ms.remove(1)) # True, one instance of 1 is removed print(ms.remove(3)) # False, since 3 is not in the multiset print(ms.get_random()) # Randomly returns 1 or 2 print(ms.get_random()) # Randomly returns 1 or 2 ```","solution":"import random from collections import defaultdict class RandomizedMultiSet: def __init__(self): self.list = [] self.dict = defaultdict(set) def insert(self, val): self.dict[val].add(len(self.list)) self.list.append(val) return True def remove(self, val): if not self.dict[val]: return False remove_idx = self.dict[val].pop() last_element = self.list[-1] self.list[remove_idx] = last_element self.dict[last_element].add(remove_idx) self.dict[last_element].discard(len(self.list) - 1) self.list.pop() if not self.dict[val]: # Clean up the dictionary entry if it\'s empty del self.dict[val] return True def get_random(self): if not self.list: raise IndexError(\\"The multiset is empty\\") return random.choice(self.list)"},{"question":"Context You are developing a file management application where consistent and accurate file path handling is critical. To ensure the application handles file paths correctly, you need to create a function that converts any given file path into an absolute path with expanded user directories. Task Write a function `normalize_file_path(file_path: str) -> str` that takes a single string input `file_path`. The function should return the absolute path with any user directories expanded. Input * `file_path` (str): A string representing the relative or absolute file path which may contain user directory shortcuts (`~`). Output * (str): The absolute file path with expanded user directories. Constraints * The input path will only be a valid string that represents a file path in the operating system. Examples 1. `normalize_file_path(\\"~/Documents/project.txt\\")` should return `/home/username/Documents/project.txt` assuming the user\'s home directory is `/home/username`. 2. `normalize_file_path(\\"project.txt\\")` should return the absolute path based on the current working directory. 3. `normalize_file_path(\\"/usr/local/bin/script.sh\\")` should return `/usr/local/bin/script.sh`. Requirements * Ensure the solution handles both relative paths and those using the `~` shortcut. * The function should work if the path is already an absolute path. * Performance should be efficient, but given typical path lengths, standard library capabilities are sufficient.","solution":"import os def normalize_file_path(file_path: str) -> str: Converts the given file path into an absolute path with expanded user directories. Parameters: file_path (str): A string representing the relative or absolute file path. Returns: str: The absolute path with expanded user directories. return os.path.abspath(os.path.expanduser(file_path))"},{"question":"You are required to implement a `CountableHashTable`, a variant of the `HashTable` class provided. This hash table should support the standard operations (insert, retrieve, delete) and also provide a method to count the number of entries currently stored in the hash table without having to iterate over the internal storage. Requirements Implement the class `CountableHashTable` with the following methods: 1. `put(key, value)`: Insert a key-value pair into the hash table. 2. `get(key)`: Retrieve the value associated with the given key. 3. `del_(key)`: Remove the key-value pair associated with the given key. 4. `count()`: Return the number of entries currently stored in the hash table. 5. Ensure collision resolution using linear probing. 6. Implement resizing to maintain efficient storage and retrieval. 7. The hash table should have an initial size of 8, and resize when 2/3 full. Constraints - The keys are non-negative integers. - Handle collisions with linear probing. - Resize dynamically when more than two-thirds full. - Use a doubling strategy for resizing. Example ```python # Example code usage hash_table = CountableHashTable() hash_table.put(1, \\"one\\") hash_table.put(2, \\"two\\") print(hash_table.get(1)) # Output: \\"one\\" print(hash_table.count()) # Output: 2 hash_table.del_(1) print(hash_table.count()) # Output: 1 print(hash_table.get(1)) # Output: None ```","solution":"class CountableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.table = [None] * self.size self.num_entries = 0 def _hash(self, key): return key % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.num_entries = 0 for item in old_table: if item is not None: key, value = item self.put(key, value) def put(self, key, value): if self.num_entries + 1 > 2 * self.size // 3: self._resize() idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = (key, value) return idx = (idx + 1) % self.size self.table[idx] = (key, value) self.num_entries += 1 def get(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: return self.table[idx][1] idx = (idx + 1) % self.size return None def del_(self, key): idx = self._hash(key) while self.table[idx] is not None: if self.table[idx][0] == key: self.table[idx] = None self.num_entries -= 1 break idx = (idx + 1) % self.size # Rehash elements in the same cluster. idx = (idx + 1) % self.size while self.table[idx] is not None: key_to_rehash, value_to_rehash = self.table[idx] self.table[idx] = None self.num_entries -= 1 self.put(key_to_rehash, value_to_rehash) idx = (idx + 1) % self.size def count(self): return self.num_entries"},{"question":"Context In text processing and bioinformatics, efficiently finding patterns within long strings of text is crucial. The Knuth-Morris-Pratt (KMP) algorithm is a powerful tool for this purpose because of its linear time complexity. Problem Statement Given a long piece of text and a pattern you wish to locate within it, write a function that uses the Knuth-Morris-Pratt (KMP) algorithm to find all the starting indices where the pattern occurs in the text. Function Signature ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds all the starting indices of the pattern in the text using the KMP algorithm. Args: text: The input text in which to search for the pattern. pattern: The pattern to search within the text. Returns: A list of starting indices where the pattern is found in the text. Example: >>> find_pattern_occurrences(\\"ABC ABCDAB ABCDABCDABDE\\", \\"ABCDABD\\") [15] Constraints: - The text and pattern inputs will only contain uppercase and lowercase English letters. - The length of the text and pattern will be in the range [0, 10000]. Requirements 1. Implement the Knuth-Morris-Pratt (KMP) algorithm to ensure an efficient search. 2. Handle edge cases, such as empty text or pattern. 3. Ensure the function works within a time complexity of O(N + M) and space complexity of O(M).","solution":"from typing import List def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Finds all the starting indices of the pattern in the text using the KMP algorithm. Args: text: The input text in which to search for the pattern. pattern: The pattern to search within the text. Returns: A list of starting indices where the pattern is found in the text. def compute_lps(pattern: str) -> List[int]: Computes the longest prefix suffix (LPS) array for the pattern. Args: pattern: The pattern for which to compute the LPS array. Returns: A list representing the LPS array. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps n = len(text) m = len(pattern) if m == 0: return [] lps = compute_lps(pattern) indices = [] i = 0 # index for text j = 0 # index for pattern while i < n: if pattern[j] == text[i]: i += 1 j += 1 if j == m: indices.append(i - j) j = lps[j - 1] elif i < n and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Matrix Chain Multiplication Problem Context Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices together. The problem does not lie in actually performing the multiplications, but in determining the optimal parenthesization of the matrices - that is, finding a way to fully parenthesize a matrix product such that the total number of scalar multiplications is minimized. Task Write a function `matrix_chain_order` that takes a list `p` of dimensions of matrices such that the dimensions of the `i`th matrix are `p[i-1] x p[i]` for `i=1` to `n` and returns the minimum number of multiplications needed to multiply the chain. ```python def matrix_chain_order(p: List[int]) -> int: # Your code here ``` Example ```python p = [1, 2, 3, 4] print(matrix_chain_order(p)) # Output: 18 ``` Input Format: - `p`: A list of integers where the (i)th matrix has dimensions (p[i-1] times p[i]). Output Format: - Return an integer representing the minimum number of multiplications needed to multiply the chain. Constraints: - (2 leq len(p) leq 100) - (1 leq p[i] leq 500) Notes: - The solution should optimize the scalar multiplications using dynamic programming. - Consider the edge cases like the minimum number of matrices, very large matrices, and cases where matrices are already optimally ordered.","solution":"def matrix_chain_order(p): Given a list `p` where the i-th matrix has dimensions p[i-1] x p[i], return the minimum number of scalar multiplications needed to multiply the chain. n = len(p) # Create a 2D list to store minimum multiplication costs m = [[0 for x in range(n)] for y in range(n)] # l is the chain length. for l in range(2, n): for i in range(1, n - l + 1): j = i + l - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j] if q < m[i][j]: m[i][j] = q return m[1][n - 1]"},{"question":"# Question: Graph Cloning with Different Traversal Techniques Suppose you are given an undirected graph represented using nodes and edges. Each `UndirectedGraphNode` has a label and a list of its neighboring nodes. Your task is to write a function that clones this graph using the provided graph traversal strategy. Write three different functions to clone the graph: 1. `clone_graph_bfs(node)` - Using a Breadth-First Search (BFS) technique. 2. `clone_graph_dfs_iterative(node)` - Using an iterative Depth-First Search (DFS) technique. 3. `clone_graph_dfs_recursive(node)` - Using a recursive Depth-First Search (DFS) technique. To implement the functions, use the `UndirectedGraphNode` class provided below: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) ``` **Input**: * A reference node (`node`), which points to a node in the graph. **Output**: * A cloned graph reference to the corresponding node, using the defined traversal strategy. **Function Signature**: ```python def clone_graph_bfs(node: UndirectedGraphNode) -> UndirectedGraphNode: pass def clone_graph_dfs_iterative(node: UndirectedGraphNode) -> UndirectedGraphNode: pass def clone_graph_dfs_recursive(node: UndirectedGraphNode) -> UndirectedGraphNode: pass ``` # Constraints: 1. The graph may contain cycles. 2. The graph may be disconnected, but you will only need to clone the connected component that the input node belongs to. 3. The labels of the nodes are unique and non-negative integers. 4. Up to 1000 nodes and 5000 edges. # Examples: **Example 1**: ```python # Assume the graph is given as follows: # 0 # / # 1 2 # Cloning this using any of the traversal strategies should effectively replicate this structure without modifying the original. node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.add_neighbor(node1) node0.add_neighbor(node2) node1.add_neighbor(node0) node2.add_neighbor(node0) clone = clone_graph_bfs(node0) # clone is a deep copy of the above structure. ``` **Example 2**: ```python # Graph with a self-loop: # 2 # / # 0---1 # | . (self loop on 2) # _ / # 2 node0 = UndirectedGraphNode(0) node1 = UndirectedGraphNode(1) node2 = UndirectedGraphNode(2) node0.add_neighbor(node1) node0.add_neighbor(node2) node1.add_neighbor(node0) node2.add_neighbor(node0) node2.add_neighbor(node2) # self-loop clone = clone_graph_dfs_recursive(node0) # clone is a deep copy of the above structure. ``` # Notes: 1. Ensure that the cloned graph is a deep copy and no shallow references exist between the original and cloned graph. 2. Avoid stack overflow in recursive DFS by testing with large cyclic graphs.","solution":"class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def shallow_copy(self): return UndirectedGraphNode(self.label) def add_neighbor(self, node): self.neighbors.append(node) from collections import deque def clone_graph_bfs(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None # Dictionary to save the mapping of original node to cloned node node_map = {} # Initialize the queue for BFS queue = deque([node]) # Clone the root node node_map[node] = node.shallow_copy() while queue: current = queue.popleft() for neighbor in current.neighbors: if neighbor not in node_map: # Clone the neighbor node node_map[neighbor] = neighbor.shallow_copy() # Add it to the queue for further traversal queue.append(neighbor) # Add the cloned neighbor to the neighbors of the cloned current node node_map[current].neighbors.append(node_map[neighbor]) return node_map[node] def clone_graph_dfs_iterative(node: UndirectedGraphNode) -> UndirectedGraphNode: if not node: return None # Dictionary to save the mapping of original node to cloned node node_map = {} # Initialize the stack for DFS stack = [node] # Clone the root node node_map[node] = node.shallow_copy() while stack: current = stack.pop() for neighbor in current.neighbors: if neighbor not in node_map: # Clone the neighbor node node_map[neighbor] = neighbor.shallow_copy() # Add it to the stack for further traversal stack.append(neighbor) # Add the cloned neighbor to the neighbors of the cloned current node node_map[current].neighbors.append(node_map[neighbor]) return node_map[node] def clone_graph_dfs_recursive(node: UndirectedGraphNode) -> UndirectedGraphNode: def dfs(node, node_map): if node in node_map: return node_map[node] # Clone the current node clone = node.shallow_copy() node_map[node] = clone for neighbor in node.neighbors: # Recursively clone neighbors clone.neighbors.append(dfs(neighbor, node_map)) return clone if not node: return None node_map = {} return dfs(node, node_map)"},{"question":"You are tasked with writing an efficient algorithm to find the index of the last occurrence of a given number in a sorted array. The array is sorted in increasing order, and your solution should be optimized to operate in O(log n) time complexity. # Function Signature ```python def last_occurrence(array, query): Returns the index of the last occurrence of the given element in a sorted array. Parameters: array (list of int): A list of integers sorted in increasing order. query (int): An integer whose last occurrence index needs to be found. Returns: int: The index of the last occurrence of the query element in array, or -1 if the query is not found. ``` # Input Format 1. `array`: A list of integers sorted in increasing order where `0 <= len(array) <= 10^5`. 2. `query`: An integer value within the range `-10^9 <= query <= 10^9`. # Output Format - You should return an integer representing the index of the last occurrence of the queried element within the array. If the element is not found, return -1. # Constraints - The array may contain duplicate elements. - The solution must run in O(log n) time complexity. # Example ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 # Result: 3 # Example 2 array = [1, 3, 3, 5, 5, 5, 5, 9, 10] query = 5 # Result: 6 # Example 3 array = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1] query = 1 # Result: 9 # Example 4 array = [1, 2, 3, 4, 5] query = 6 # Result: -1 ``` # Constraints * Your solution should handle arrays of up to 100,000 elements efficiently within the specified time complexity.","solution":"def last_occurrence(array, query): Returns the index of the last occurrence of the given element in a sorted array. Parameters: array (list of int): A list of integers sorted in increasing order. query (int): An integer whose last occurrence index needs to be found. Returns: int: The index of the last occurrence of the query element in array, or -1 if the query is not found. low, high = 0, len(array) - 1 result = -1 while low <= high: mid = (low + high) // 2 if array[mid] > query: high = mid - 1 elif array[mid] < query: low = mid + 1 else: result = mid low = mid + 1 return result"},{"question":"Scenario You are building a software to verify if certain terain formations in a larger map match predefined formations. These formations are represented as binary trees, where the main map and the formation to be checked are both provided in tree data structures. Task Write a Python function `is_subtree(s: TreeNode, t: TreeNode) -> bool` that determines if the tree `t` is a subtree of the tree `s`. Function Signature ```python def is_subtree(s: TreeNode, t: TreeNode) -> bool: pass ``` Input: - `s`: the root node of a binary tree representing the main map. - `t`: the root node of a binary tree representing the formation to check. Output: - Returns `True` if tree `t` is a subtree of tree `s`, otherwise returns `False`. Constraints: - The number of nodes in either tree is in the range [0, 10000]. - Node values in the binary trees are within the integer range [-10^4, 10^4]. Example: **Example 1:** ```python Given: s = [3, 4, 5, 1, 2] t = [4, 1, 2] Output: True ``` (Explanation: t is a subtree of s) **Example 2:** ```python Given: s = [3, 4, 5, 1, 2, None, None, 0] t = [4, 1, 2] Output: False ``` (Explanation: t is not a subtree of s, as there is an extra node `0` in `s` that is not in `t`.) Hints: 1. Implement a helper function that compares two trees. 2. Use a queue to traverse the main tree `s` in BFS manner. 3. Recursively check for subtree matches from potential root nodes.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_subtree(s: TreeNode, t: TreeNode) -> bool: if not t: return True if not s: return False def are_identical(s, t): if not s and not t: return True if not s or not t: return False return s.val == t.val and are_identical(s.left, t.left) and are_identical(s.right, t.right) if are_identical(s, t): return True return is_subtree(s.left, t) or is_subtree(s.right, t)"},{"question":"Design a function `secure_key_exchange` that employs Diffie-Hellman key exchange protocol to generate a shared secret key between two parties, Alice and Bob. Your implementation should include all necessary steps from prime validation to the final key exchange. # Input - A large prime number `p` (1 < `p` < 10^9) - A primitive root `a` of `p` # Output - Return the shared secret key if successful, otherwise return an error message indicating the reason for the failure. # Constraints 1. `p` must be a prime number. 2. `a` must be a primitive root modulo `p`. # Additional requirements - Use provided helper functions (`prime_check`, `find_primitive_root`) to validate inputs. - The function should handle possible edge cases and error scenarios gracefully. - Print intermediate steps (keys, validation steps) for debug purposes, if an optional `debug` parameter is set to `True`. # Function Signature ```python def secure_key_exchange(p: int, a: int, debug: bool = False) -> int: ``` # Example ```python p = 23 a = 5 result = secure_key_exchange(p, a) print(result) # Output: Shared Key # Invalid Parameters p = 22 a = 5 result = secure_key_exchange(p, a) print(result) # Output: Error: 22 is not a prime number ```","solution":"def prime_check(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def find_primitive_root(p): if not prime_check(p): return -1 phi = p - 1 factors = [] n = phi i = 2 while i * i <= n: if n % i == 0: factors.append(i) while n % i == 0: n //= i i += 1 if n > 1: factors.append(n) def power(x, y, p): res = 1 x = x % p while y > 0: if (y & 1) == 1: res = (res * x) % p y = y >> 1 x = (x * x) % p return res for g in range(2, p): flag = False for factor in factors: if power(g, phi // factor, p) == 1: flag = True break if not flag: return g return -1 def secure_key_exchange(p: int, a: int, debug: bool = False) -> int: if not prime_check(p): return \\"Error: {} is not a prime number\\".format(p) if find_primitive_root(p) != a: return \\"Error: {} is not a primitive root of {}\\".format(a, p) # Private keys alice_private = 6 bob_private = 15 # Public keys A = pow(a, alice_private, p) B = pow(a, bob_private, p) if debug: print(f\\"Alice\'s Public Key: {A}\\") print(f\\"Bob\'s Public Key: {B}\\") # Shared secrets alice_shared_secret = pow(B, alice_private, p) bob_shared_secret = pow(A, bob_private, p) if debug: print(f\\"Alice\'s Shared Secret: {alice_shared_secret}\\") print(f\\"Bob\'s Shared Secret: {bob_shared_secret}\\") if alice_shared_secret == bob_shared_secret: return alice_shared_secret return \\"Error: Shared secret key mismatch\\""},{"question":"# Binary Search Implementation and Extension You are tasked with implementing and extending the Binary Search algorithm to suit a slightly more advanced need. Binary Search is an efficient algorithm for finding an item from a sorted array of items. The basic idea is to divide the search interval in half repeatedly until the target value is found or the interval is empty. Core Functionality 1. Implement both an iterative and a recursive version of binary search that will return the index of a target value in a sorted array. 2. Extend the binary search function to handle two additional requests: - **Find First Occurrence**: Return the index of the first occurrence of the target value. - **Find Last Occurrence**: Return the index of the last occurrence of the target value. Requirements 1. **Iteration** - Implement an iterative binary search function `binary_search_iter(array, query)` that returns the index of the target value, or `None` if the value is not present. 2. **Recursion** - Implement a recursive binary search function `binary_search_recur(array, low, high, query)` that returns the index of the target value, or `-1` if the value is not present. 3. **First Occurrence** - Implement a function `find_first_occurrence(array, query)` that leverages binary search to return the index of the first occurrence of the target value. 4. **Last Occurrence** - Implement a function `find_last_occurrence(array, query)` that leverages binary search to return the index of the last occurrence of the target value. Input * `array` (list of integers): A sorted list of integers (ascending order). * `query` (integer): The value to search for within the array. Output * For basic binary search, return the index of the found element, or `None` if not found. * For first and last occurrence functions, return the respective indices, or `None` if not found. Constraints * The function must handle sorted arrays of varying lengths, including edge cases like empty arrays or arrays with a single element. * Aim for an efficient solution with a time complexity of O(log(n)). Example ```python array = [1, 2, 2, 2, 3, 4, 5, 6] query = 2 binary_search_iter(array, query) # returns 2 binary_search_recur(array, 0, len(array)-1, query) # returns 2 find_first_occurrence(array, query) # returns 1 find_last_occurrence(array, query) # returns 3 ``` Use the following template to create your solution: ```python def binary_search_iter(array, query): # Implement the iterative binary search pass def binary_search_recur(array, low, high, query): # Implement the recursive binary search pass def find_first_occurrence(array, query): # Implement finding the first occurrence pass def find_last_occurrence(array, query): # Implement finding the last occurrence pass ```","solution":"def binary_search_iter(array, query): Perform binary search iteratively to find the index of query in array. Return the index if found, None otherwise. low, high = 0, len(array) - 1 while low <= high: mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: low = mid + 1 else: high = mid - 1 return None def binary_search_recur(array, low, high, query): Perform binary search recursively to find the index of query in array. Return the index if found, -1 otherwise. if low > high: return -1 mid = (low + high) // 2 if array[mid] == query: return mid elif array[mid] < query: return binary_search_recur(array, mid + 1, high, query) else: return binary_search_recur(array, low, mid - 1, query) def find_first_occurrence(array, query): Find the index of the first occurrence of query in array using binary search. Return the index if found, None otherwise. low, high = 0, len(array) - 1 result = None while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid high = mid - 1 # continue search on the left side elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result def find_last_occurrence(array, query): Find the index of the last occurrence of query in array using binary search. Return the index if found, None otherwise. low, high = 0, len(array) - 1 result = None while low <= high: mid = (low + high) // 2 if array[mid] == query: result = mid low = mid + 1 # continue search on the right side elif array[mid] < query: low = mid + 1 else: high = mid - 1 return result"},{"question":"# Question: Plagiarism Detection using Rolling Hash As part of a plagiarism detection system, you have been tasked to detect whether a specific paragraph (pattern) exists within a given document (text). The system should use a robust and efficient algorithm to quickly find the position of the paragraph if it exists. Function Description Implement the function `find_paragraph(text: str, pattern: str) -> int`. Input Format * **text**: A string representing the document to be searched within (1 <= len(text) <= 10^6). * **pattern**: A string representing the paragraph to search for (1 <= len(pattern) <= min(len(text), 10^5)). Output Format * Return the starting index (0-based) of the first occurrence of the pattern in the text. * If the pattern does not exist, return `None`. Constraints * The function should efficiently handle large text strings and patterns up to the specified lengths. * Assume the text and pattern contain only lowercase alphabetic characters (\'a\' to \'z\'). Edge Cases * The pattern length might be longer than the text, which should return `None`. * The text and pattern might be empty strings. Example ```python def find_paragraph(text: str, pattern: str) -> int: # your implementation here # Example Usage print(find_paragraph(\\"abcdefghijk\\", \\"def\\")) # Output: 3 print(find_paragraph(\\"abcdefghijk\\", \\"xyz\\")) # Output: None print(find_paragraph(\\"\\", \\"\\")) # Output: None ``` The task is to complete the implementation of the function using the Rabin-Karp algorithm with a rolling hash to check for the presence of the pattern within the text. Hints: * Calculate hash values using rolling hash computation. * Ensure any edge case handling around the comparison of the hash values and the substrings to avoid false positives due to hash collisions.","solution":"def find_paragraph(text: str, pattern: str) -> int: if not text or not pattern or len(pattern) > len(text): return None # Base and Modulus for the rolling hash base = 256 mod = 101 pattern_length = len(pattern) text_length = len(text) # Calculate the hash value of pattern and first window of text def calculate_hash(s): h = 0 for char in s: h = (h * base + ord(char)) % mod return h pattern_hash = calculate_hash(pattern) window_hash = calculate_hash(text[:pattern_length]) for i in range(text_length - pattern_length + 1): # Check the hash values of the current window of text and pattern if window_hash == pattern_hash: # Since hash matches, check the actual substring for validation if text[i:i + pattern_length] == pattern: return i # Calculate hash value for the next window of text: if i < text_length - pattern_length: window_hash = (window_hash * base + ord(text[i + pattern_length]) - ord(text[i]) * (base ** pattern_length)) % mod return None"},{"question":"**Question**: Implement a function that finds the k-th smallest element in an AVL tree. Given an AVL Tree, you must write a function `find_kth_smallest` that takes the tree root and an integer k as input, and returns the k-th smallest element in the tree. # Function Signature ```python def find_kth_smallest(root: TreeNode, k: int) -> int: ``` # Input * **root**: `TreeNode` - the root node of the AVL tree. * **k**: `int` - the \\"k-th\\" position where 1 ≤ k ≤ number of nodes in the tree. # Output * Return the k-th smallest element in the AVL tree. # Constraints * The tree is an AVL tree. * The tree contains at least one node. * 1 ≤ k ≤ number of nodes in the tree. # Performance Requirements * The function must run in O(log n + k) time complexity. # Example Given an AVL tree with nodes [10, 20, 5, 6, 8], calling `find_kth_smallest(root, 3)` should return 8. # Scenario Consider an AVL Tree implemented for maintaining records in a database. Suppose you want to find the k-th smallest record based on a certain attribute. Implement a function that finds this efficiently leveraging the properties of AVL Trees. ```python # Example class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None # Helper class for AVL Tree not necessarily included in the question. # The focus is on the function ‘find_kth_smallest’. def find_kth_smallest(root, k): # Implement this function based on the requirements. pass # Example usage: # root = TreeNode(10) # ... # k = 3 # print(find_kth_smallest(root, k)) # Expected Output: 8 ``` # Notes * Consider in-order traversal for the implementation since it inherently visits elements in a sorted order. * Make sure to handle tree balance and traversals efficiently.","solution":"class TreeNode: def __init__(self, key): self.val = key self.left = None self.right = None def find_kth_smallest(root: TreeNode, k: int) -> int: def in_order_traversal(node): if node is None: return [] return in_order_traversal(node.left) + [node.val] + in_order_traversal(node.right) sorted_elements = in_order_traversal(root) return sorted_elements[k - 1]"},{"question":"# FizzBuzz Variants Context: FizzBuzz is a popular problem used to teach and assess understanding of basic programming principles. You are asked to extend this basic problem in a manner that requires more advanced handling. Problem: Write a function `fizzbuzz_variant(n, rules)` that returns a list of numbers from 1 to `n`, but replaces certain values based on a given set of rules. Each rule is a tuple containing a divisor and a string. For example, given the rules `[(3, \\"Fizz\\"), (5, \\"Buzz\\")]`, the function will replace numbers divisible by 3 with \\"Fizz\\", those divisible by 5 with \\"Buzz\\", and those divisible by 3 and 5 with \\"FizzBuzz\\". The rules can expand or change dynamically. Parameters: - `n`: an integer (1 ≤ n ≤ 10^6) representing the range of numbers to process. - `rules`: a list of tuples where each tuple contains an integer divisor and a string. `(divisor, string)`. Output: - A list of strings or integers based on the rules applied. Constraints: - Each divisor in the rules is unique. - At least one rule will be present. - Assume that `n` and the rules are always valid inputs within the constraints mentioned. # Example: ```python def fizzbuzz_variant(n, rules): # Your implementation here # Example usage: print(fizzbuzz_variant(15, [(3, \\"Fizz\\"), (5, \\"Buzz\\")])) # Output: [1, 2, \\"Fizz\\", 4, \\"Buzz\\", \\"Fizz\\", 7, 8, \\"Fizz\\", \\"Buzz\\", 11, \\"Fizz\\", 13, 14, \\"FizzBuzz\\"] print(fizzbuzz_variant(10, [(2, \\"Even\\"), (3, \\"Odd\\")])) # Output: [1, \\"Even\\", \\"Odd\\", \\"Even\\", 5, \\"EvenOdd\\", 7, \\"Even\\", \\"Odd\\", \\"Even\\"] ``` Additional Notes: - If a number is divisible by multiple divisors, concatenate the corresponding strings in the order of the rules provided. - Ensure the solution processes each number in O(1) time to achieve overall O(n) time complexity.","solution":"def fizzbuzz_variant(n, rules): Returns a list of numbers from 1 to n with replacements according to the rules. Parameters: n (int): The range of numbers to process. rules (list of tuple): A list of tuples where each tuple contains a divisor and a replacement string. Returns: list: A list of numbers or strings based on the replacement rules. result = [] for i in range(1, n + 1): value = \\"\\" for divisor, word in rules: if i % divisor == 0: value += word if value == \\"\\": value = i result.append(value) return result"},{"question":"# Palindrome Verification Using Various Techniques Context You\'ve been hired to develop a reliable system to validate whether given strings are palindromes. Considering potential variations in the input data, such as the presence of non-alphanumeric characters and different cases, the verification should be both robust and efficient. Task Write a function called `advanced_is_palindrome` implementing the palindrome check using three different techniques mentioned below. Your function should first clean the input string by removing any non-alphanumeric characters and converting it to lowercase. Functions to Implement: 1. **Using String Reversal**: Compare the string to its reverse. 2. **Using Two-Pointer Technique**: One pointer starts at the beginning and another at the end, moving inward. 3. **Using Deque**: Utilize a deque to check if the string reads the same forwards and backwards. Expected Function Signature ```python def advanced_is_palindrome(s: str, method: str) -> bool: :param s: The input string to check. :param method: The method to use (\'reverse\', \'two_pointer\', \'deque\'). :return: True if the string is a palindrome, otherwise False. ``` Input - `s`: A string that may contain alphanumeric characters, whitespace, punctuation, etc. - `method`: A string specifying which method to use. It can be \'reverse\', \'two_pointer\', or \'deque\'. Output - Returns `True` if the given string `s` is a palindrome using the specified method; otherwise, `False`. Constraints - The input string may be empty or contain special characters. - The method parameter will be valid strings (\'reverse\', \'two_pointer\', \'deque\'). Performance Expectations - The implementation should effectively handle strings of up to length 10^6. Example ```python print(advanced_is_palindrome(\\"A man, a plan, a canal: Panama\\", \\"reverse\\")) # Output: True print(advanced_is_palindrome(\\"race a car\\", \\"two_pointer\\")) # Output: False print(advanced_is_palindrome(\\" \\", \\"deque\\")) # Output: True ```","solution":"import re from collections import deque def clean_string(s): Remove non-alphanumeric characters and convert to lowercase. return re.sub(r\'[^A-Za-z0-9]\', \'\', s).lower() def advanced_is_palindrome(s: str, method: str) -> bool: Check if the given string is a palindrome using the specified method. cleaned_s = clean_string(s) if method == \'reverse\': # Using String Reversal return cleaned_s == cleaned_s[::-1] elif method == \'two_pointer\': # Using Two-Pointer Technique left, right = 0, len(cleaned_s) - 1 while left < right: if cleaned_s[left] != cleaned_s[right]: return False left += 1 right -= 1 return True elif method == \'deque\': # Using Deque deq = deque(cleaned_s) while len(deq) > 1: if deq.popleft() != deq.pop(): return False return True else: raise ValueError(\\"Invalid method provided. Choose from \'reverse\', \'two_pointer\', or \'deque\'.\\")"},{"question":"# Nearest Neighbor Classification In this assessment, you will implement and extend the Nearest Neighbor algorithm based on the provided code snippets. The goal is to classify a given test point by finding its nearest neighbor in a training set of labeled vectors. # Problem Statement You are given a training set `tSet` where each key is a vector (tuple of integers) and its corresponding value is a class label (string). Given a query vector `x`, your task is to find the vector in `tSet` that has the smallest Euclidean distance to `x`, and return the class label of that nearest vector. # Function Signature ```python def nearest_neighbor(x, tSet): pass ``` # Input 1. A tuple `x` of integers, representing the query vector. 2. A dictionary `tSet` with keys as tuples of integers (training vectors) and values as strings (class labels). # Output - A string representing the class label of the nearest vector in `tSet`. # Constraints - Each vector in `tSet` and the query vector `x` will have the same length. - The training set `tSet` will contain at least one vector. - All vector elements will be non-negative integers. - Length of vectors will not exceed 100. - Size of the training set will not exceed 1000. # Example ```python x = (1, 2) tSet = { (2, 3): \\"A\\", (4, 5): \\"B\\", (1, 2): \\"C\\" } print(nearest_neighbor(x, tSet)) # Output: \\"C\\" ``` # Requirements 1. Ensure your implementation handles edge cases where distances between multiple points are the same by returning the first encountered. 2. Optimize for efficiency in both time and space complexities where possible considering the given constraints. 3. Add general validation checks for input types and constraints. **Note**: Avoid using advanced data structures or external libraries outside of standard Python libraries in your solution.","solution":"import math def euclidean_distance(v1, v2): Computes the Euclidean distance between two vectors return math.sqrt(sum((a - b) ** 2 for a, b in zip(v1, v2))) def nearest_neighbor(x, tSet): Finds and returns the class label of the nearest neighbor of vector x in the training set tSet. :param x: Tuple of integers, the query vector. :param tSet: Dictionary where keys are tuples of integers (training vectors) and values are strings (class labels). :return: The class label of the nearest neighbor. nearest_label = None min_distance = float(\'inf\') for vector, label in tSet.items(): distance = euclidean_distance(x, vector) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"You are given a function that implements Pancake Sort, an inefficient but interesting sorting algorithm. Pancake Sort works by flipping subarrays (like flipping segments of a stack of pancakes) to move the maximum unsorted element to its correct position iteratively. Task Write a function `pancake_sort(arr)` that takes a single parameter: - `arr` (list of integers), where 1 <= len(arr) <= 1000, and -10^5 <= arr[i] <= 10^5 The function should return the sorted list of integers using the Pancake Sort algorithm. Constraints - You must use the Pancake Sort algorithm. - The function should handle all edge cases, such as empty lists or lists with repeated elements. - Aim to write the method with clear logic and efficient operations considering the constraints. Example ```python # Example Input arr = [3, 6, 2, 7, 4] # Example Output [2, 3, 4, 6, 7] ``` Note In your implementation, focus on correctness and ensure the function works efficiently even for the upper limits of the constraints.","solution":"def flip(arr, end): Helper function to flip the subarray from start to end (inclusive). start = 0 while start < end: arr[start], arr[end] = arr[end], arr[start] start += 1 end -= 1 def pancake_sort(arr): Perform Pancake Sort on the input list `arr`. n = len(arr) for size in range(n, 1, -1): # Find the maximum element\'s index in arr[0:size] max_index = 0 for i in range(1, size): if arr[i] > arr[max_index]: max_index = i # Move the maximum element to the end of the current subarray # If max_index is already at the position, it skips both flips if max_index != size - 1: # Flip to move the maximum element to the beginning flip(arr, max_index) # Flip to move the maximum element to its correct position flip(arr, size - 1) return arr"},{"question":"# Repeated String Match - Coding Challenge Objective You are given two strings `A` and `B`. Your task is to determine the minimum number of repetitions of `A` such that `B` becomes a substring of the repeated string. If no such solution exists, return `-1`. Function Signature ```python def repeated_string_match(A: str, B: str) -> int: pass ``` Input Format - `A` (1 ≤ len(A) ≤ 10000): A non-empty string containing the characters of the alphabet. - `B` (1 ≤ len(B) ≤ 10000): A non-empty string containing the characters of the alphabet. Output Format - Return an integer representing the minimum number of repetitions of `A` such that `B` is a substring of the repeated string. If `B` cannot be a substring, return `-1`. Constraints - The strings will only contain lowercase English letters. - You can assume that the minimum lengths of both strings are `1` and the maximum lengths are `10,000`. Example - Input: ```python A = \\"abcd\\" B = \\"cdabcdab\\" ``` - Output: ```python 3 ``` Explanation In this case, repeating `A` three times (`\\"abcdabcdabcd\\"`) will result in `B` being a substring of the repeated string.","solution":"def repeated_string_match(A: str, B: str) -> int: repeated_A = A count = 1 while len(repeated_A) < len(B): repeated_A += A count += 1 if B in repeated_A: return count repeated_A += A count += 1 if B in repeated_A: return count return -1"},{"question":"# Question You are tasked with completing a function within an AVL Tree class. Your function will find the height of the tree from the root node to the deepest leaf node. Recall that an AVL tree maintains balance and the height difference between left and right subtrees of any node is at most 1. # Function Signature ```python class AvlTree: def find_height(self): Find the height of the AVL Tree. Returns: int: The height of the tree. pass ``` # Input - No input parameters # Output - An integer representing the height of the tree. # Constraints - This function must be implemented within the AvlTree class provided. # Sample Scenario Given the following AVL Tree where numbers represent keys: ``` 20 / 10 30 / 25 40 ``` Calling the `find_height` function on this AVL Tree should return `2`. # Considerations - Handle an empty tree (should return height as -1) - Your method should accurately reflect the height even after a sequence of insertions, updates, and rotations. - Implement this function within the context of the AVL Tree class provided in the code snippet.","solution":"class AvlTreeNode: def __init__(self, key, height=1, left=None, right=None): self.key = key self.height = height self.left = left self.right = right class AvlTree: def __init__(self): self.root = None def find_height(self): def height(node): if not node: return -1 return max(height(node.left), height(node.right)) + 1 return height(self.root)"},{"question":"You are given an encoded string using the encoding rule: `k[encoded_string]`, where the `encoded_string` inside the square brackets is repeated exactly k times. The encoded string can contain nested patterns. Write a function `decode_string` which decodes the input string according to the provided rules. # Constraints 1. The input string `s` will always be valid; no extra whitespaces, and square brackets are well-formed. 2. The input string will not contain any digits besides those used for repeat counts. # Input - A string `s` which is an encoded string using the format `k[encoded_string]`. # Output - A string that is decoded from the input string. # Examples Example 1 ```python s = \\"3[a]2[bc]\\" decode_string(s) => \\"aaabcbc\\" ``` Example 2 ```python s = \\"3[a2[c]]\\" decode_string(s) => \\"accaccacc\\" ``` Example 3 ```python s = \\"2[abc]3[cd]ef\\" decode_string(s) => \\"abcabccdcdcdef\\" ``` # Function Signature ```python def decode_string(s: str) -> str: pass ``` # Notes - You should consider edge cases like empty input, deeply nested patterns, and long encoded strings. - Optimize for both time and space complexity where possible.","solution":"def decode_string(s: str) -> str: Decodes a given encoded string according to the encoding rule k[encoded_string]. stack = [] current_string = \\"\\" current_number = 0 for c in s: if c.isdigit(): current_number = current_number * 10 + int(c) elif c == \'[\': stack.append((current_string, current_number)) current_string = \\"\\" current_number = 0 elif c == \']\': last_string, number = stack.pop() current_string = last_string + number * current_string else: current_string += c return current_string"},{"question":"Context You are hired as a junior developer in a tech company where data compression is crucial for data storage and transmission efficiency. The company primarily uses Run-Length Encoding (RLE) for compressing text files. Your task is to implement two functions: one for encoding a given string using RLE and another for decoding an encoded string back to its original form. Problem Statement Implement the following two functions: 1. `encode_rle(input: str) -> str`: This function takes a string `input` and returns its run-length encoded string. 2. `decode_rle(input: str) -> str`: This function takes a run-length encoded string `input` and returns the original string. Function Specifications # encode_rle - **Input**: A string `input` of length `n` (0 ≤ n ≤ 10^6). - **Output**: Run-length encoded string of the input data. # decode_rle - **Input**: A run-length encoded string `input` of length `m` (0 ≤ m ≤ 10^6), where the encoded format is always correctly structured. - **Output**: Original uncompressed string. Constraints - The characters in `input` for both functions are limited to lowercase English letters (`a-z`). - There will be no leading zeros in the run-length used in encoded strings. Examples # Example 1: ```python assert encode_rle(\\"aaabccddddd\\") == \\"3a1b2c5d\\" assert decode_rle(\\"3a1b2c5d\\") == \\"aaabccddddd\\" ``` # Example 2: ```python assert encode_rle(\\"abcd\\") == \\"1a1b1c1d\\" assert decode_rle(\\"1a1b1c1d\\") == \\"abcd\\" ``` # Example 3: ```python assert encode_rle(\\"\\") == \\"\\" assert decode_rle(\\"\\") == \\"\\" ``` Notes - Make sure to account for edge cases such as empty input strings and strings with no repeating characters. - Ensure your implementation handles large inputs within acceptable performance limits.","solution":"def encode_rle(input: str) -> str: if not input: return \\"\\" encoded = [] count = 1 current_char = input[0] for char in input[1:]: if char == current_char: count += 1 else: encoded.append(f\\"{count}{current_char}\\") current_char = char count = 1 encoded.append(f\\"{count}{current_char}\\") return \\"\\".join(encoded) def decode_rle(input: str) -> str: if not input: return \\"\\" decoded = [] count = 0 for char in input: if char.isdigit(): count = count * 10 + int(char) else: decoded.append(char * count) count = 0 return \\"\\".join(decoded)"},{"question":"# Question: Implementing an Optimized Sorting Algorithm You are provided with an integer array where the elements lie within a known range. Your task is to implement an efficient sorting algorithm suitable for this specific scenario. Given an array of N integers and an integer K representing the range of the values (values range from 0 to K-1), write a function `optimized_sort(arr, K)` that returns the sorted array. Ensure your implementation has a time complexity of O(N + K) and utilizes as little extra space as possible. Function Signature ```python def optimized_sort(arr: List[int], K: int) -> List[int]: ``` # Input * `arr`: A list of integers containing N elements. * `K`: An integer representing the range of possible values (0 to K-1). # Output * A list of integers sorted in non-decreasing order. # Constraints * 1 ≤ N ≤ 10^5 * 1 ≤ K ≤ 10^5 * 0 ≤ arr[i] < K # Examples ```python # Example 1 arr = [4, 2, 2, 8, 3, 3, 1] K = 9 print(optimized_sort(arr, K)) # Output: [1, 2, 2, 3, 3, 4, 8] # Example 2 arr = [5, 4, 3, 2, 1] K = 6 print(optimized_sort(arr, K)) # Output: [1, 2, 3, 4, 5] ``` # Notes * The array contains integers in the range [0, K-1]. * A direct adaptation of pigeonhole sort will be efficient for this task. * The implementation should be optimized for both time and space complexity.","solution":"from typing import List def optimized_sort(arr: List[int], K: int) -> List[int]: Sort an array of integers where elements are within the range [0, K-1]. # Create a count array to store the count of each distinct integer count = [0] * K # Fill the count array with the frequency of each element in arr for num in arr: count[num] += 1 # Construct the sorted array from the count array sorted_arr = [] for num in range(K): sorted_arr.extend([num] * count[num]) return sorted_arr"},{"question":"**Key concepts**: String Manipulation, Algorithm Efficiency # Problem: You are tasked with writing a function that determines whether one string is a rotation of another string. A rotation of a string `s` is any string that can be obtained by shifting the characters of `s` any number of positions. # Function Signature: ```python def is_rotated(s1: str, s2: str) -> bool: ``` # Parameters: - `s1`: A string consisting of alphanumerical characters. - `s2`: Another string consisting of alphanumerical characters. # Constraints: - Both strings should be compared case-sensitively. - The function should handle up to 100,000 characters efficiently. # Returns: - A boolean value indicating whether `s2` is a rotated version of `s1`. # Performance Requirement: - Your solution should have a time complexity of O(N), where N is the length of the string. # Example: - `is_rotated(\\"hello\\", \\"llohe\\")` should return `True`, as `llohe` is a rotation of `hello`. - `is_rotated(\\"hello\\", \\"helol\\")` should return `False`, as `helol` is not a rotation of `hello`. # Additional Considerations: 1. Handle cases where both strings are of different lengths by returning `False`. 2. Ensure efficient handling and avoid excess memory use if possible. **Note**: Do not use the built-in substring search or concatenation directly. Implement the rotation check manually.","solution":"def is_rotated(s1: str, s2: str) -> bool: Determines if s2 is a rotation of s1. Parameters: s1 (str): The original string. s2 (str): The string to check if it is a rotation of s1. Returns: bool: True if s2 is a rotation of s1, False otherwise. # If lengths are not the same, s2 cannot be a rotation of s1 if len(s1) != len(s2): return False # Concatenate s1 with itself and then check if s2 is a substring of the result concatenated = s1 + s1 # Check if s2 is a substring of concatenated s1 return s2 in concatenated"},{"question":"Maximum Sum Subarray Objective: You are given an integer array `nums`. Your task is to write a function `max_subarray_with_indices` to find the contiguous subarray (containing at least one number) which has the largest sum and return both the sum and the starting and ending indices of that subarray. Function Signature: ```python def max_subarray_with_indices(nums: List[int]) -> Tuple[int, int, int]: pass ``` Input: - A list `nums` of integers where (1 leq text{len}(nums) leq 10^5) and (-10^4 leq text{nums[i]} leq 10^4). Output: - A tuple (max_sum, start_index, end_index) where: - `max_sum` is the sum of the contiguous subarray with the largest sum. - `start_index` and `end_index` are the starting and ending indices (0-based) of that subarray. Constraints: - The `nums` array will contain at least one element. Example: ```python assert max_subarray_with_indices([-2,1,-3,4,-1,2,1,-5,4]) == (6, 3, 6) # The contiguous subarray [4, -1, 2, 1] has the largest sum = 6. assert max_subarray_with_indices([1]) == (1, 0, 0) # The single element array has the largest sum itself. assert max_subarray_with_indices([-2, -3, -1, -5]) == (-1, 2, 2) # The subarray [-1] has the largest sum = -1. ```","solution":"from typing import List, Tuple def max_subarray_with_indices(nums: List[int]) -> Tuple[int, int, int]: # Initialize variables max_sum = current_sum = nums[0] start_index = end_index = 0 temp_start = 0 for i in range(1, len(nums)): if nums[i] > current_sum + nums[i]: current_sum = nums[i] temp_start = i else: current_sum += nums[i] if current_sum > max_sum: max_sum = current_sum start_index = temp_start end_index = i return (max_sum, start_index, end_index)"},{"question":"You are given a starred (asterisk-separated) string of words, which represents a sequence of words in a sentence. Your task is to reverse the order of the words in the sentence efficiently and return the new starred string. # Function Signature ```python def reverse_starred_string(starred_string: str) -> str: # Your code here pass ``` # Input and Output Formats * **Input**: A string `starred_string` (1 <= len(starred_string) <= 10^6) containing words separated by exactly one \'*\'. * **Output**: A single string with the words reversed, maintaining the single \'*\' separator between words. # Constraints * Words within the string consist only of lowercase English letters. * There is exactly one \'*\' character between any two consecutive words. # Example 1. **Input**: ```python \\"apple*banana*cherry*date\\" ``` **Output**: ```python \\"date*cherry*banana*apple\\" ``` 2. **Input**: ```python \\"hello*world\\" ``` **Output**: ```python \\"world*hello\\" ``` # Notes - Ensure your solution runs efficiently for very large inputs. - You can assume there are no leading, trailing, or more than one consecutive \'*\' in the input string. - Returning the words in precisely the reverse order is essential for passing the test cases.","solution":"def reverse_starred_string(starred_string: str) -> str: Reverses the order of words in a starred (*) string. Args: starred_string (str): A string where words are separated by \'*\'. Returns: str: A new starred string with words in reverse order. words = starred_string.split(\'*\') return \'*\'.join(reversed(words))"},{"question":"**Problem Statement**: You are provided with a singly linked list. Your task is to write a function that removes duplicate entries from the linked list. Implement both an efficient method using a set, and a more space-efficient method without using an additional data structure. **Function Signature**: ```python def remove_dups(head: Node) -> None: pass def remove_dups_without_set(head: Node) -> None: pass class Node: def __init__(self, val=None): self.val = val self.next = None ``` **Instructions**: 1. Implement `remove_dups(head)` using a hash set to ensure the removal operation runs in linear time. 2. Implement `remove_dups_without_set(head)` which doesn\'t use any auxiliary storage; thus, it should run in quadratic time complexity. 3. Assume the linked list is implemented using the provided `Node` class. 4. Both functions should modify the linked list in-place and should not return any value. 5. You can use the following helper function to assist with visualization/testing: ```python def print_linked_list(head: Node) -> None: result = [] while head: result.append(head.val) head = head.next print(\\" -> \\".join(result)) ``` **Expected Input and Output**: * Input: Head of the linked list. * Output: None. The linked list should be modified in place. **Example**: ```python # Example for remove_dups a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups(a1) print_linked_list(a1) # Expected output: \\"A -> B -> C -> D -> F -> G\\" # Example for remove_dups_without_set a1 = Node(\\"A\\") a2 = Node(\\"A\\") b = Node(\\"B\\") c1 = Node(\\"C\\") d = Node(\\"D\\") c2 = Node(\\"C\\") f = Node(\\"F\\") g = Node(\\"G\\") a1.next = a2 a2.next = b b.next = c1 c1.next = d d.next = c2 c2.next = f f.next = g remove_dups_without_set(a1) print_linked_list(a1) # Expected output: \\"A -> B -> C -> D -> F -> G\\" ``` **Constraints**: * Ensure your methods handle linked lists with varying lengths effectively. * Consider edge cases such as an empty list, a list with single element, and lists with all elements being identical.","solution":"class Node: def __init__(self, val=None): self.val = val self.next = None def remove_dups(head: Node) -> None: if not head: return current = head seen = set() seen.add(current.val) while current.next: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head: Node) -> None: current = head while current: runner = current while runner.next: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def print_linked_list(head: Node) -> None: result = [] while head: result.append(head.val) head = head.next print(\\" -> \\".join(result))"},{"question":"Implement Cycle Sort You are tasked with implementing a custom sorting algorithm called Cycle Sort. Cycle Sort is designed to sort an array in place by minimizing the number of memory writes. This is particularly useful in scenarios where the writing operation is costly. Problem Statement Write a function `cycle_sort` that takes a list of integers and sorts it in ascending order using the Cycle Sort algorithm. Ensure that your implementation writes each element to its correct position with the minimal number of writes possible. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers, where `1 <= len(arr) <= 10^4` and `-10^9 <= arr[i] <= 10^9`. Output - Returns a sorted list of integers in ascending order. Constraints - The algorithm should run in O(N^2) time complexity in the worst case. - Optimize to ensure minimal memory writes. - No additional space other than minimal local variables, effectively an in-place sort. Example ```python assert cycle_sort([3, 2, 1]) == [1, 2, 3] assert cycle_sort([1, 2, 3]) == [1, 2, 3] assert cycle_sort([4, 3, 1, 2]) == [1, 2, 3, 4] assert cycle_sort([7, 9, 1, 4, 2, 6]) == [1, 2, 4, 6, 7, 9] ``` Edge Cases to Consider - Arrays with duplicate elements. - Arrays already sorted in ascending order. - Arrays with all identical elements. **Notes**: - Carefully handle the duplicate elements to avoid infinite loops. - Pay attention to the correct placement of elements without using extra space.","solution":"def cycle_sort(arr): writes = 0 # Traverse the entire array for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position, continue if pos == cycle_start: continue # Skip duplicates while item == arr[pos]: pos += 1 # Put the item to the right position arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"# Segment Tree Implementation Assessment You have come across a data structure known as a Segment Tree which allows efficient range queries and point updates on an array. The Segment Tree is capable of handling different types of associative functions (like sum, maximum, minimum, etc.) that are commutative. Task Implement the `SegmentTree` class that supports the following operations: 1. **Initialize**: Given an array and a commutative function, construct the segment tree. 2. **Query**: Given a range [l, r], return the result of applying the commutative function to this range. 3. **Update**: Given an index `p` and value `v`, update the array at index `p` to `v` and update the tree accordingly. Specifications * **Function Signature**: - `def __init__(self, arr: List[int], function: Callable[[int, int], int]) -> None:` - `def query(self, l: int, r: int) -> int:` - `def update(self, p: int, v: int) -> None:` * **Input and Output**: - `__init__`: Takes a list of integers `arr` and a function `function` that takes two integers and returns an integer. - `query`: Takes two integers `l` and `r`, and returns an integer result of applying the function to the range `[l, r]`. - `update`: Takes an integer index `p` and value `v`, updates the element at index `p` to `v` and updates the segment tree. Example ```python # Example 1: mytree = SegmentTree([2, 4, 5, 3, 4], max) print(mytree.query(2, 4)) # Expected Output: 5 mytree.update(3, 6) print(mytree.query(0, 3)) # Expected Output: 6 # Example 2: mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) print(mytree.query(0, 6)) # Expected Output: 64 mytree.update(2, -10) print(mytree.query(0, 6)) # Expected Output: 52 ``` Constraints and Limitations 1. The input array size will be at most (10^5). 2. The values in the array and results will fit in a 32-bit signed integer. 3. The function provided will always be commutative. Write a robust implementation that handles edge cases, minimizes performance bottlenecks, and ensures the correctness of results for any valid input according to the specified operations. Provide unit tests to confirm the correctness of your segment tree implementation.","solution":"from typing import List, Callable class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]) -> None: self.n = len(arr) self.function = function self.tree = [0] * (2 * self.n) # Build the tree for i in range(self.n): self.tree[self.n + i] = arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def query(self, l: int, r: int) -> int: l += self.n r += self.n res = None while l <= r: if l % 2 == 1: if res is None: res = self.tree[l] else: res = self.function(res, self.tree[l]) l += 1 if r % 2 == 0: if res is None: res = self.tree[r] else: res = self.function(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res def update(self, p: int, v: int) -> None: pos = p + self.n self.tree[pos] = v while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1])"},{"question":"# Prime Number Validation Function Context: Prime numbers play an essential role in various fields, particularly in cryptography and network security. Efficiently determining if a number is prime helps in cryptographic key generation, data encryption, and other mathematical applications. Problem Statement: Implement a function `is_prime(n: int) -> bool` that takes an integer `n` and returns `True` if `n` is a prime number and `False` otherwise. Ensure that the algorithm is efficient and handles numbers up to 1,000,000,000 accurately. Input Format: - An integer `n` where `-1,000,000,000 <= n <= 1,000,000,000`. Output Format: - A boolean value, `True` if `n` is prime, `False` otherwise. Constraints: - Prioritize time efficiency with a complexity goal of O(√n). - Optimize space usage to O(1). - Handle both positive and negative integers accordingly. Implementation Details: - Numbers less than or equal to 1 are not prime. - The number 2 and 3 are prime numbers. - Numbers divisible by 2 or 3 are not prime. - For numbers greater than 3, use the 6k ± 1 optimization to reduce the number of divisors checked. Example Cases: ```python # Example 1: n = 29 Output: True # Example 2: n = 15 Output: False # Example 3: n = 1 Output: False # Example 4: n = -17 Output: False # Example 5: n = 1000000007 Output: True ``` Performance Requirements: - The function should execute within a reasonable timeframe for any number within the provided range, ideally under 1 second for the upper limits. ```python def is_prime(n): Return True if n is a prime number, else return False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False j = 5 while j * j <= n: if n % j == 0 or n % (j + 2) == 0: return False j += 6 return True ```","solution":"def is_prime(n): Return True if n is a prime number, else return False. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are provided with two sorting functions `max_heap_sort` and `min_heap_sort` that utilize max heap and min heap data structures respectively. Your task is to implement a **median heap sort** function which combines both max heap and min heap approaches to sort the list and compute the median in an efficient manner. # Input and Output * **Input**: A list of integers `arr`, and an optional boolean flag `simulation` (default set to `False`) for debugging purposes. * **Output**: A tuple consisting of: - A list of integers sorted in ascending order. - The median value of the input list. # Constraints 1. The input list `arr` will have `1 ≤ len(arr) ≤ 10^5`. 2. The integers in the list will be in the range `-10^6` to `10^6`. 3. The median for an even-length array should be calculated as the average of the two middle elements. # Performance Requirements - The implementation should aim for a time complexity of O(n log(n)) and a space complexity of O(1) (in-place sorting is preferred). # Examples **Example 1:** ```python arr = [3, 1, 4, 1, 5, 9] result = median_heap_sort(arr) print(result) # Output: ([1, 1, 3, 4, 5, 9], 3.5) ``` **Example 2:** ```python arr = [2, 4, 6, 8, 10] result = median_heap_sort(arr) print(result) # Output: ([2, 4, 6, 8, 10], 6) ``` # Instructions 1. Implement a function named `median_heap_sort()` with the provided specifications. 2. Your function should return a tuple containing the sorted list and the calculated median. 3. Ensure efficient time and space utilization and consider edge cases (like empty or single-element arrays).","solution":"def median_heap_sort(arr, simulation=False): Function that sorts the array and calculates the median using a combination of max heap and min heap approaches. Parameters: - arr: list of integers - simulation: boolean flag for debugging purposes Returns: - A tuple containing: * The sorted list of integers * The median value of the input list if len(arr) == 0: return ([], None) # Sorting the list in ascending order arr.sort() # Calculating the median n = len(arr) if n % 2 == 1: median = arr[n // 2] else: median = (arr[n // 2 - 1] + arr[n // 2]) / 2 return (arr, median)"},{"question":"Context: In various applications, managing and working with file paths efficiently can prevent issues related to locating and accessing files. Functions that can automatically resolve and normalize paths help streamline file operations and avoid errors due to incorrect paths. In this exercise, you will improve upon a basic path resolution function by ensuring it also handles file existence and manages specific edge cases to provide robust and reliable path resolution. Task: Implement a function `enhanced_full_path(file: str) -> str` that not only resolves the absolute path of a given file through expansion and normalization but also checks if the file exists. If the file does not exist, your function should raise an appropriate error. Specifications: * Your function will take a single argument, `file`: - `file` (str): A file path that might include relative components or user directories (e.g., `~`). * The function should return the absolute path of the file if it exists. * If the file does not exist, raise a `FileNotFoundError` with a descriptive error message. * Consider and handle edge cases like empty strings or non-string inputs appropriately. Input: - A string representing the file path. Output: - A string representing the absolute path to the file, if it exists. Example: ```python print(enhanced_full_path(\'~/test.txt\')) # Might return \'/home/user/test.txt\' if the file exists. print(enhanced_full_path(\'../a_file.json\')) # Returns valid absolute path if it exists, else raises error. ``` Constraints: - Ensure robust error handling we discussed. - The solution should handle cross-platform differences in file path structures. Performance: - Efficient string handling is expected, though the primary focus is on correct and reliable path resolution.","solution":"import os def enhanced_full_path(file: str) -> str: Resolves the absolute path of a given file through expansion and normalization. If the file does not exist, raises a FileNotFoundError. if not isinstance(file, str) or not file: raise ValueError(\\"Input must be a non-empty string representing a file path.\\") # Expand user directory and get absolute normalized path expanded_path = os.path.expanduser(file) absolute_path = os.path.abspath(expanded_path) # Check if the file exists if not os.path.exists(absolute_path): raise FileNotFoundError(f\\"The file \'{absolute_path}\' does not exist.\\") return absolute_path"},{"question":"# Scenario: You are given a series of daily temperature changes recorded over a certain period. You need to find the most significant warm spell (i.e., the period with the highest cumulative temperature rise). Develop an algorithm that identifies this period efficiently. # Task: Implement a function `max_temperature_rise(temperature_changes)` that takes a list of integers as input, each representing daily temperature changes. The function should return the maximum cumulative temperature rise for any contiguous subarray of days. # Function Signature: ```python def max_temperature_rise(temperature_changes: List[int]) -> int: pass ``` # Input: - `temperature_changes` (List[int]): A list of integers where each integer represents the discrete change in temperature for each day. # Output: - Return an integer: the maximum temperature rise for any contiguous subarray of days. # Constraints: - The list can contain both positive and negative values. - The length of the list will be between 1 and 10^5. - Each element in the list will be between -100 and 100. # Example: ```python # Example 1 temperature_changes = [1, -2, 3, 4, -1, 2, 1, -5, 4] print(max_temperature_rise(temperature_changes)) # Output: 9 # Example 2 temperature_changes = [-2, 1] print(max_temperature_rise(temperature_changes)) # Output: 1 # Example 3 temperature_changes = [-1, -2, -3, -4] print(max_temperature_rise(temperature_changes)) # Output: -1 ``` # Explanation: - **Example 1**: The subarray with the maximum sum is `[3, 4, -1, 2, 1]` with a sum of 9. - **Example 2**: The maximum sum of contiguous subarray is 1. - **Example 3**: The maximum sum of contiguous subarray is -1, which is the maximum single value in a fully negative array. Implement your solution using Kadane\'s Algorithm.","solution":"def max_temperature_rise(temperature_changes): Finds the maximum cumulative temperature rise for any contiguous subarray of days. Params: - temperature_changes (List[int]): List of daily temperature changes Returns: - int: Maximum cumulative temperature rise max_current = max_global = temperature_changes[0] for temp_change in temperature_changes[1:]: max_current = max(temp_change, max_current + temp_change) if max_current > max_global: max_global = max_current return max_global"},{"question":"Cycle Detection in a Directed Graph Background You have been provided with an incomplete implementation of a directed graph. Your task is to enhance this implementation by writing a function to detect cycles in the graph. Cycles in a directed graph can be problematic, especially when the graph is used to represent dependencies or tasks in a sequence where cyclic dependencies can cause tasks to become non-completable. Task Implement a function `detect_cycle` within the `DirectedGraph` class that detects if the graph contains any cycles. If a cycle is detected, the function should return `True`. Otherwise, it should return `False`. Function Signature ```python class DirectedGraph: # ... existing methods def detect_cycle(self) -> bool: # Implement cycle detection logic here pass ``` Input - The graph structure is already stored within the `DirectedGraph` instance. Output - Return `True` if there is at least one cycle in the graph, `False` otherwise. Constraints - Graph can contain between 1 and 1000 nodes. - Each node can have between 0 and 100 directed edges. - Node names are strings and are unique. Example Consider the following adjacency list: ```python { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'A\'] } ``` In this graph, a cycle `A -> B -> C -> A` exists. The `detect_cycle` function should return `True`. For a non-cyclic graph: ```python { \'A\': [\'B\'], \'B\': [\'C\'] } ``` The function should return `False`. Implementation Notes Consider using Depth First Search (DFS) technique starting from each node to detect back edges, which indicate cycles. Hints 1. Use a white-gray-black (unvisited, visited, finished) coloring mechanism to manage the traversal state of nodes. 2. Utilize recursion or a stack to perform DFS.","solution":"class DirectedGraph: def __init__(self): self.adjacency_list = {} def add_edge(self, start, end): if start not in self.adjacency_list: self.adjacency_list[start] = [] self.adjacency_list[start].append(end) def detect_cycle(self) -> bool: def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in self.adjacency_list.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visited = set() visiting = set() for node in self.adjacency_list: if dfs(node): return True return False"},{"question":"# Selection Sort with Detailed Analysis You are given an implementation of the **Selection Sort** algorithm. Your task is to enhance this implementation to handle detailed analysis and validation of the sorting process. # Requirements 1. **Function Signature:** ```python def enhanced_selection_sort(arr): # your code goes here ``` 2. **Input:** - A list of integers `arr`. 3. **Output:** - A tuple containing: 1. The sorted list. 2. The number of comparisons made during the sorting process. 3. A list of tuples representing each step of the sorting process: (iteration_number, list_state). # Constraints - The list can have a maximum length of 10^4 elements. # Performance Requirements: - Your algorithm\'s time complexity should remain O(n^2), as it is a characteristic of selection sort. # Example ```python input: [64, 25, 12, 22, 11] output: ([11, 12, 22, 25, 64], 10, [ (0, [11, 25, 12, 22, 64]), (1, [11, 12, 25, 22, 64]), (2, [11, 12, 22, 25, 64]), (3, [11, 12, 22, 25, 64]) ]) ``` # Explanation - The first element moves to its correct place in the first iteration. - The second smallest element moves to its place in the second iteration, and so on. - Return the sorted list, the total count of comparisons made, and the state of the array after each swap for all iterations. # Notes Consider edge cases and potential pitfalls like: - Empty arrays. - Arrays with a single element. - Arrays where all elements are identical. Implement the `enhanced_selection_sort` function to provide a deeper understanding of the selection sort mechanism.","solution":"def enhanced_selection_sort(arr): Perform selection sort on the input array while recording detailed analysis. Args: - arr: list of integers to sort. Returns: - tuple: (sorted list, number of comparisons, list of tuples representing each step of the sorting process) n = len(arr) comparisons = 0 steps = [] for i in range(n - 1): min_idx = i for j in range(i + 1, n): comparisons += 1 if arr[j] < arr[min_idx]: min_idx = j # Swap if the minimum is not the element at the current position if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] # Record the state after each iteration where a new element is placed in the correct position steps.append((i, arr[:])) return arr, comparisons, steps"},{"question":"# Binary Tree Traversal You are provided with a binary tree where each node contains an integer value. Implement a function that returns the in-order traversal of the binary tree. You will need to provide both iterative and recursive versions of the solution. Function Signature ```python def inorder_iterative(root: Node) -> List[int]: # Write your iterative solution here def inorder_recursive(root: Node) -> List[int]: # Write your recursive solution here ``` Input * `root`: The root node of a binary tree. Output * A list of integers representing the in-order traversal of the binary tree. Constraints * The number of nodes in the tree will be in the range [0, 10^4]. * The values of the nodes will be in the range [-10^4, 10^4]. Performance Requirements The solution should have a time complexity of O(n), where n is the number of nodes in the tree. Example Consider the following binary tree: ``` 100 / 50 150 / / 25 75 125 175 ``` For this tree, the in-order traversal is `25, 50, 75, 100, 125, 150, 175`. Example Usage The provided Python snippet constructs the above tree and tests the function: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right if __name__ == \\"__main__\\": n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Node\' = None, right: \'Node\' = None): self.val = val self.left = left self.right = right def inorder_iterative(root: Optional[Node]) -> List[int]: result = [] stack = [] current = root while current is not None or stack: while current is not None: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Optional[Node]) -> List[int]: def inorder(node: Optional[Node], res: List[int]): if node: inorder(node.left, res) res.append(node.val) inorder(node.right, res) result = [] inorder(root, result) return result"},{"question":"**Objective**: Implement and utilize a non-comparison-based sorting algorithm. **Context**: Stooge Sort is an inefficient sorting algorithm with a time complexity of (O(n^{2.709})), chiefly used for educational purposes. In contrast, non-comparison sorts like Counting Sort, Radix Sort, or Bucket Sort offer efficient alternatives with linear or linearithmic time complexity for specific data types or ranges. **Task**: 1. Write a Python function called `counting_sort(arr, max_val)` to sort an array of non-negative integers. 2. Outline your implementation approach. **Function Signature**: ```python def counting_sort(arr: List[int], max_val: int) -> List[int]: pass ``` **Input**: - `arr`: a list of non-negative integers - `max_val`: an integer representing the maximum value in the list `arr` **Output**: - Returns a sorted list of integers. **Constraints**: - The length of `arr` will not exceed `10^5`. - The elements in `arr` will be in the range `[0, max_val]`. - For simplicity, assume `max_val` will not exceed `10^6`. **Performance**: - Expected time complexity is (O(n + k)), where (n) is the number of elements in `arr` and (k) is `max_val`. - Expected space complexity is (O(k)). **Example**: ```python >>> counting_sort([4, 2, 2, 8, 3, 3, 1], 8) [1, 2, 2, 3, 3, 4, 8] >>> counting_sort([0, 0, 0, 0, 0], 0) [0, 0, 0, 0, 0] ``` **Notes**: - Briefly document your approach. - Ensure your solution can handle edge cases effectively. - Avoid using built-in sorting methods.","solution":"def counting_sort(arr, max_val): Performs a counting sort on a list of non-negative integers. Parameters: - arr: List[int], a list of non-negative integers to be sorted. - max_val: int, the maximum value in the array. Returns: - List[int], the sorted list. # Create a count array to store the count of each unique object count = [0] * (max_val + 1) # Populate the count array for num in arr: count[num] += 1 # Build the sorted array sorted_arr = [] for num, cnt in enumerate(count): sorted_arr.extend([num] * cnt) return sorted_arr"},{"question":"**Problem Description:** Write a function `find_nth_digit(n)` that finds the nth digit of an infinite sequence formed by concatenating all positive integers sequentially: 1234567891011121314... # Input: * An integer `n` (1 ≤ n ≤ 10^9), representing the position in the infinite sequence. # Output: * An integer, the nth digit in the sequence. # Function Signature: ```python def find_nth_digit(n: int) -> int: ``` # Constraints: * Ensure that the solution runs efficiently for very large values of `n`. * Use meaningful variable names and appropriate algorithms to achieve the result. # Example Test Cases: 1. `find_nth_digit(1)` should return `1` 2. `find_nth_digit(11)` should return `0` (since the sequence is 12345678910...) 3. `find_nth_digit(15)` should return `2` (since the sequence is 123456789101112...) # Scenario/Context: **Contextual Scenario for Enhanced Clarity:** Imagine you are observing a digital display that continuously shows digits of positive integers in sequence. You want to know which digit appears at a specific position. For example, at position 15, the display shows the digit 2 from the number 12. # Additional Notes: * Do not generate the entire sequence due to performance constraints. * Consider all possible edge cases and constraints to ensure robust code. # Performance Requirements: * The function should have an optimal time complexity, i.e., O(log n), and minimal space complexity.","solution":"def find_nth_digit(n: int) -> int: if n <= 0: raise ValueError(\'n must be a positive integer.\') length = 1 # Initial length of numbers count = 9 # Initial count of numbers having the same number of digits (1 through 9) start = 1 # The initial number with the given number of digits # Determine the length of the number where the nth digit is located while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Find the actual number that contains the nth digit start += (n - 1) // length # Find the exact digit in the number s = str(start) return int(s[(n - 1) % length])"},{"question":"# Question: Enhanced Linear Search with Constraints You are tasked with writing an enhanced version of the linear search algorithm. The enhancement involves searching within a specified subarray range and handling a special condition for early termination based on a given maximum number of allowed comparisons. The function should be called `enhanced_linear_search` and must meet the following specifications: Function Signature ```python def enhanced_linear_search(array: list, query: int, left: int, right: int, max_comparisons: int) -> int: ``` Input: - `array`: A list of integers where the search will be performed. - `query`: The integer value to be searched for. - `left`: The starting index (inclusive) of the subarray where the search is to be confined. - `right`: The ending index (inclusive) of the subarray where the search is to be confined. - `max_comparisons`: The maximum number of comparisons allowed before terminating the search. Output: - The index (i) of the `query` within the specified subarray range (`left` to `right`), or -1 if the `query` is not found within the subarray or if the number of comparisons exceeds `max_comparisons`. Example ```python array = [5, 2, 8, 4, 1, 3, 7, 6] query = 4 left = 1 right = 5 max_comparisons = 3 assert enhanced_linear_search(array, query, left, right, max_comparisons) == 3 assert enhanced_linear_search(array, query, left, right, 2) == -1 # Stops early due to max_comparisons assert enhanced_linear_search(array, 10, left, right, max_comparisons) == -1 # Query not found ``` Constraints - `0 <= left <= right < len(array)` - The number of elements in the array is less than or equal to 10^4. - The number of comparisons should not exceed `max_comparisons`. Write a function `enhanced_linear_search` to solve the problem.","solution":"def enhanced_linear_search(array, query, left, right, max_comparisons): Performs an enhanced linear search within a specified subarray range. Parameters: array (list): List of integers. query (int): The integer value to search for. left (int): Starting index of the subarray (inclusive). right (int): Ending index of the subarray (inclusive). max_comparisons (int): The maximum number of comparisons allowed. Returns: int: The index of the query if found within the range and comparison limit, otherwise -1. if left < 0 or right >= len(array) or left > right: return -1 comparisons = 0 for i in range(left, right + 1): if comparisons >= max_comparisons: break if array[i] == query: return i comparisons += 1 return -1"},{"question":"**Context**: You are given a simulation problem where you need to manage a dynamic grid of land and water. Initially, all cells in a 2D grid are water. You will receive a list of positions where land should be added. Each addition may form new islands by connecting adjacent land cells horizontally or vertically. An island is defined as a group of connected land cells. **Task**: Write a function `count_islands` that takes in the grid dimensions (rows and columns) and a list of positions where land will be added. The function should return a list indicating the number of islands present in the grid after each land addition. **Function Signature**: ```python def count_islands(rows: int, cols: int, positions: List[Tuple[int, int]]) -> List[int]: pass ``` **Input**: * `rows`: an integer representing the number of rows in the grid (1 <= rows <= 1000). * `cols`: an integer representing the number of columns in the grid (1 <= cols <= 1000). * `positions`: a list of tuples, where each tuple `(i, j)` represents the position to turn from water to land (0 <= i < rows, 0 <= j < cols). **Output**: * A list of integers where the `i-th` integer is the number of islands after the `i-th` addLand operation. **Constraints**: * The position coordinates are valid and will not repeat. * The initial grid is considered to have infinite water around it. **Example**: ```python rows = 3 cols = 3 positions = [(0, 0), (0, 1), (1, 2), (2, 1)] print(count_islands(rows, cols, positions)) # Output: [1, 1, 2, 3] ``` **Requirements**: * Implement the function `count_islands` using the Union-Find data structure. * Ensure that the solution is efficient and can handle large grids and numerous position additions.","solution":"from typing import List, Tuple def count_islands(rows: int, cols: int, positions: List[Tuple[int, int]]) -> List[int]: parent = {} rank = {} count = [] num_islands = 0 def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for position in positions: r, c = position if (r, c) in parent: count.append(num_islands) continue parent[(r, c)] = (r, c) rank[(r, c)] = 0 num_islands += 1 for dr, dc in directions: nr, nc = r + dr, c + dc if (nr, nc) in parent: if find((r, c)) != find((nr, nc)): union((r, c), (nr, nc)) num_islands -= 1 count.append(num_islands) return count"},{"question":"Scenario You have been tasked to implement a priority queue for a simulation system where events need to be processed in order of their importance (priority). The current implementation uses a linear array, which can become inefficient with frequent insertions. Your goal is to enhance the performance of the priority queue by using a more efficient underlying data structure. Task Implement a `HeapPriorityQueue` using binary min-heap (for min-priority queue) data structure. Ensure that the insertion and extraction operations are optimized. Requirements 1. Implement the `HeapPriorityQueue` class with the following methods: * `__init__(self, items=None, priorities=None)`: Initialize the priority queue. If `items` and `priorities` are provided, populate the queue initially. * `size(self)`: Return the size of the priority queue. * `push(self, item, priority)`: Insert an item with the given priority. If no priority is provided, set the item\'s value as its priority. * `pop(self)`: Remove and return the item with the lowest priority. 2. Ensure that the priority queue operations have the following complexities: * **Insertion (`push`)**: O(log n) * **Extraction (`pop`)**: O(log n) 3. Handle edge cases, such as attempting to pop from an empty queue gracefully. Constraints * The number of items, `n`, to be managed by the priority queue can go up to 10^5. Input and Output Formats * **Initialization**: Can be with or without initial items and priorities. * **push**: Add an item with a given priority. * **pop**: Remove and return the item with the lowest priority. * **size**: Return the current size of the queue. Example ```python pq = HeapPriorityQueue([\\"task1\\", \\"task2\\"], [2, 1]) print(pq.pop()) # Output: task2 pq.push(\\"task3\\", 1) print(pq.pop()) # Output: task3 print(pq.size()) # Output: 1 ``` Notes - Avoid using any built-in priority queue libraries; implement the heap structure yourself. - Prioritize efficient implementation and code readability.","solution":"import heapq class HeapPriorityQueue: def __init__(self, items=None, priorities=None): self._heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self._heap, (priority, item)) def size(self): return len(self._heap) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self._heap, (priority, item)) def pop(self): if self.size() > 0: return heapq.heappop(self._heap)[1] else: raise IndexError(\\"pop from an empty priority queue\\")"},{"question":"**Scenario**: Your company is aggregating historical log entries from various distributed systems. Each log is sorted by timestamp. You need to write a function to merge these k sorted log files into one continuous sorted log file. **Task**: Implement the function `merge_k_logs(log_lists)` which merges k sorted linked lists into a single sorted linked list. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_logs(log_lists: List[ListNode]) -> ListNode: Merge k sorted linked lists and return it as one sorted list. Parameters: log_lists (List[ListNode]): List of k singly-linked lists each sorted in ascending order. Returns: ListNode: The head of the merged singly-linked list sorted in ascending order. ``` # Constraints * The number of linked lists, k, will be between 1 and 10^4. * The number of total nodes will be between 0 and 10^6. * The value of each node will be between -10^4 and 10^4. * The linked lists are not necessarily of the same length. # Input * `log_lists`: A list of head nodes for k sorted singly-linked lists. # Output * The head node of a single merged sorted linked list. # Example ```python list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) log_lists = [list1, list2, list3] result = merge_k_logs(log_lists) # The returned list should be: 1->1->2->3->4->4->5->6 ``` # Performance Requirements * Your solution must run in O(N log k) time complexity. # Implementation Requirements * Use a min-heap (priority queue) for efficiently finding and merging the smallest current node.","solution":"import heapq from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __repr__(self): # This repr is used for testing purposes to easily compare lists nodes = [] current = self while current: nodes.append(current.val) current = current.next return \\"->\\".join(map(str, nodes)) def merge_k_logs(log_lists: List[Optional[ListNode]]) -> Optional[ListNode]: Merge k sorted linked lists and return it as one sorted list. Parameters: log_lists (List[ListNode]): List of k singly-linked lists each sorted in ascending order. Returns: ListNode: The head of the merged singly-linked list sorted in ascending order. min_heap = [] for i, node in enumerate(log_lists): if node: heapq.heappush(min_heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while min_heap: val, i, node = heapq.heappop(min_heap) current.next = ListNode(val) current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, i, node.next)) return dummy.next"},{"question":"Scenario You are given a binary search tree (BST) that represents a hierarchy of employees in a company. Each node contains the employee ID and other relevant details. The company wants to implement a feature to find the next higher-level employee based on the employee ID. Task Write a function `find_successor` that takes the root of the BST and a node representing an employee and returns the in-order successor of that employee node in the BST. Function Signature ```python def find_successor(root, node): # Your code here ``` Input - `root`: The root node of the BST. - `node`: The node for which the in-order successor needs to be found. Output - Returns the in-order successor node. If there is no successor, return `None`. Constraints - The BST will not contain duplicate values. - Assume that the `node` belongs to the BST. Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Construct the BST # 5 # / # 3 7 # / # 2 4 8 root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.right = TreeNode(8) node = root.left # node with value 3 assert find_successor(root, node).val == 4 ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_successor(root, node): def minValue(node): current = node while current.left is not None: current = current.left return current if node.right: return minValue(node.right) successor = None while root: if node.val < root.val: successor = root root = root.left elif node.val > root.val: root = root.right else: break return successor"},{"question":"# Coding Task: Flatten Nested Arrays You are given an array that may contain nested arrays of varying depths. Your task is to write a function to flatten this array into a single resultant array. # Function Signature ```python def flatten_array(input_arr: list) -> list: Flattens a nested array into a single-level array. Parameters: input_arr (list): A potentially nested array of elements. Returns: list: A flattened version of the input array. ``` # Input - `input_arr`: A list which may contain nested lists or other iterables. # Output - Return a single list that contains all elements from the nested input list in a flattened structure. # Constraints - The function should handle arbitrary levels of nesting. - Elements in the array can be any type (integers, strings, lists, tuples, etc.). - You should not use any built-in or library functions specifically designed to flatten arrays. # Example Inputs and Outputs ```python # Example 1 input_arr = [1, [2, [3, 4], 5], 6] output = flatten_array(input_arr) print(output) # Output: [1, 2, 3, 4, 5, 6] # Example 2 input_arr = [[[\'a\']], \'b\', [[[\'c\']]]] output = flatten_array(input_arr) print(output) # Output: [\'a\', \'b\', \'c\'] # Example 3 input_arr = [1, [], [2, [[], 3], []], []] output = flatten_array(input_arr) print(output) # Output: [1, 2, 3] # Example 4 input_arr = [] output = flatten_array(input_arr) print(output) # Output: [] ``` # Notes - You should consider edge cases where the array might be already flat, empty, or contain mixed data types. - Aim to write clean and readable code, keeping performance in mind. - Do not modify the input array directly; create a new one to hold the results.","solution":"def flatten_array(input_arr: list) -> list: Flattens a nested array into a single-level array. Parameters: input_arr (list): A potentially nested array of elements. Returns: list: A flattened version of the input array. flattened_list = [] def flatten(element): if isinstance(element, list): for item in element: flatten(item) else: flattened_list.append(element) flatten(input_arr) return flattened_list"},{"question":"# Question: Implementing Enhanced Sparse Vector Operations You are provided with sparse vectors that contain a lot of zero values. Your task is to implement a class `SparseVector` to efficiently store these vectors and facilitate operations on them, including the dot product, addition, and retrieval of values. Requirements: 1. **SparseVector Class**: * Constructor: `__init__(self, vector: List[float])` * Initializes the sparse vector efficiently by storing only non-zero values. * Method: `dot_product(self, other: \'SparseVector\') -> float` * Returns the dot product of this sparse vector with another sparse vector. * Method: `add(self, other: \'SparseVector\') -> \'SparseVector\'` * Returns a new SparseVector that is the result of adding this vector with another sparse vector. * Method: `get_value(self, index: int) -> float` * Returns the value at the given index of the sparse vector. If the index is out of bounds or does not exist, it should return 0.0. Input and Output Formats: * The `SparseVector` constructor will accept a list of floating-point numbers. * The `dot_product` method will return a floating-point number. * The `add` method will return a new `SparseVector`. * The `get_value` method will return a floating-point number. Constraints: * Sparse vectors can have a length up to 10^6. * The sum of non-zero values will not exceed 10^5. * Indices will always be within [0, length of vector - 1]. Example: ```python # Example usage: vec1 = SparseVector([0.0, 2.0, 0.0, 3.0]) vec2 = SparseVector([1.0, 0.0, 2.0, 0.0]) print(vec1.dot_product(vec2)) # Should print 0.0 sum_vector = vec1.add(vec2) print(sum_vector.get_value(1)) # Should print 2.0 print(sum_vector.get_value(2)) # Should print 2.0 print(sum_vector.get_value(3)) # Should print 3.0 ``` Implement the `SparseVector` class according to the specifications provided.","solution":"class SparseVector: def __init__(self, vector): # Store only non-zero values with their respective indices self.values = {i: val for i, val in enumerate(vector) if val != 0.0} def dot_product(self, other): # Calculate and return the dot product of two sparse vectors return sum(self.values[i] * other.values.get(i, 0.0) for i in self.values) def add(self, other): # Create a new dictionary for storing the result of the addition result = {} # Add all elements from self for i in self.values: result[i] = self.values[i] # Add all elements from other (and handle the sum) for i in other.values: if i in result: result[i] += other.values[i] else: result[i] = other.values[i] # Create a list for the new vector max_index = max(max(self.values.keys(), default=0), max(other.values.keys(), default=0)) vector = [0.0] * (max_index + 1) # Populate the list with non-zero values for i in result: vector[i] = result[i] return SparseVector(vector) def get_value(self, index): # Return value at the given index or 0.0 if index does not exist return self.values.get(index, 0.0)"},{"question":"You are given an array representing a stack of pancakes of varying sizes. You are to sort this array using only a series of \\"flips.\\" A flip consists of reversing the order of the first `k` elements of the array. You need to implement the `pancake_sort()` function which will sort the array in ascending order using the minimum number of flips possible. Function signature: ```python def pancake_sort(arr: List[int]) -> List[int]: ``` # Input: * A list `arr` of integers where `1 <= len(arr) <= 1000`. * Each integer in `arr` may range from `-10^3` to `10^3`. # Output: * A list of integers which is the sorted version of the input list `arr`. # Constraints: * Your solution should sort the array using only the described flip operation. * Must handle edge cases such as empty arrays and arrays of length 1. # Example: ```python assert pancake_sort([3, 2, 4, 1]) == [1, 2, 3, 4] assert pancake_sort([1]) == [1] assert pancake_sort([]) == [] assert pancake_sort([9, 7, 5, 3]) == [3, 5, 7, 9] assert pancake_sort([-2, -5, -1, 0]) == [-5, -2, -1, 0] ```","solution":"def pancake_sort(arr): def flip(sub_arr, k): return sub_arr[:k][::-1] + sub_arr[k:] n = len(arr) for cur_size in range(n, 1, -1): # Find the index of the maximum element in the current subarray max_index = arr.index(max(arr[:cur_size])) if max_index != cur_size - 1: # Flip the maximum element to the start arr = flip(arr, max_index + 1) # Flip it to its final position arr = flip(arr, cur_size) return arr"},{"question":"# Scenario: You are working on a real-time analytics dashboard for processing live data streams. One of the requirements is to track the moving average of the last `N` data points. Given the necessity to handle high-frequency incoming data efficiently, you need to create a data structure that supports this operation. Implement a class `MovingAverage` that calculates the moving average of the last `N` integers in a sliding window fashion. # Requirements: * Initialize the class with a window size `size`. * Implement the method `next(val)` that should: * Add the integer `val` to the data structure. * Return the moving average of the last `N` values. # Input & Output: * The `__init__` method takes an integer `size` representing the window size. * The method `next(val)` takes an integer `val` and returns a float representing the moving average. # Constraints: * The maximum window size (`size`) can be up to 10^5. * Values added will range between `-10^4` and `10^4`. # Example: ```python # Example usage: m = MovingAverage(3) print(m.next(1)) # Output: 1.0 print(m.next(10)) # Output: 5.5 print(m.next(3)) # Output: 4.66667 (approx.) print(m.next(5)) # Output: 6.0 ``` # Notes: * Be mindful of performance, ensure your approach works within the given constraints.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the moving average with a specific window size. self.size = size self.window = deque() self.total = 0 def next(self, val: int) -> float: Add the integer val to the moving average data structure and return the current moving average. if len(self.window) == self.size: self.total -= self.window.popleft() self.window.append(val) self.total += val return self.total / len(self.window)"},{"question":"# Strongly Connected Components Using Kosaraju’s Algorithm Implement a function using Kosaraju\'s algorithm to find the number of strongly connected components in a directed graph. Function Signature ```python def kosaraju_scc(V: int, edges: List[Tuple[int, int]]) -> int: ``` Input - `V` (int): The number of vertices in the graph (0-indexed). - `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges between vertices u -> v. Output - Returns an integer representing the number of strongly connected components in the graph. Constraints - (1 leq V leq 10^5) - (0 leq E leq 10^5) - The graph does not contain self-loops or multiple edges between the same pair of vertices. Example ```python from typing import List, Tuple def kosaraju_scc(V: int, edges: List[Tuple[int, int]]) -> int: # Your implementation here pass # Example Usage: V = 6 edges = [(0, 2), (1, 0), (2, 3), (3, 1), (3, 4), (4, 5), (5, 4)] print(kosaraju_scc(V, edges)) # Output: 2 ``` Scenario You are working for a social networking site and tasked with identifying closely-knit communities within user interactions. Users are represented as vertices in a directed graph where a direct interaction is represented by a directed edge. Implement Kosaraju\'s algorithm to find and count the strongly connected components of user interactions to help identify these communities for further analysis. Considerations: - Handle edge cases such as isolated nodes and multiple small SCCs effectively. - Ensure that your algorithm can handle large input sizes within a reasonable runtime.","solution":"from typing import List, Tuple def kosaraju_scc(V: int, edges: List[Tuple[int, int]]) -> int: from collections import defaultdict, deque # Step 1: Create adjacency list for the graph and its transpose graph = defaultdict(list) transpose_graph = defaultdict(list) for u, v in edges: graph[u].append(v) transpose_graph[v].append(u) # Step 2: Order vertices by finish time in decreasing order (DFS finishing order) def dfs(v, visited, stack): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor, visited, stack) stack.append(v) visited = [False] * V stack = [] for i in range(V): if not visited[i]: dfs(i, visited, stack) # Step 3: Reverse the order and do a DFS on the transposed graph def reverse_dfs(v, visited): visited[v] = True for neighbor in transpose_graph[v]: if not visited[neighbor]: reverse_dfs(neighbor, visited) visited = [False] * V scc_count = 0 while stack: v = stack.pop() if not visited[v]: reverse_dfs(v, visited) scc_count += 1 return scc_count"},{"question":"# Problem Description Counting sort is often used to sort integers efficiently when the range of the values is known and manageable. In this problem, we aim to sort an array of potentially negative integers. Your task is to implement an enhanced version of the counting sort that can handle both positive and negative integers. # Requirements * Implement a function `counting_sort(arr: List[int]) -> List[int]` that sorts the input array `arr` of integers. * Ensure that negative integers are handled correctly. * The algorithm should maintain the O(n + k) complexity, where n is the number of elements and k is the range of the numbers. # Input * A list of integers, `arr`, where -1000000 <= arr[i] <= 1000000. # Output * A sorted list of integers. # Constraints * The length of the input list will not exceed 10^5 elements. * All integers in the input list are within the range [-1000000, 1000000]. # Examples Example 1: ```python input: arr = [5, -3, 0, 2, -1, -4] output: [-4, -3, -1, 0, 2, 5] ``` Example 2: ```python input: arr = [10, 7, 5, 3, 1, 2, -2, -5] output: [-5, -2, 1, 2, 3, 5, 7, 10] ``` # Note Your implementation should be efficient and optimized for performance to handle large input sizes within reasonable time limits.","solution":"def counting_sort(arr): Sorts the input array \'arr\' using an enhanced version of counting sort that can handle both positive and negative integers. if not arr: return [] # Find the range of the input min_val = min(arr) max_val = max(arr) # Create count array with range from min_val to max_val range_val = max_val - min_val + 1 count = [0] * range_val # Populate the count array for num in arr: count[num - min_val] += 1 # Build the sorted array sorted_arr = [] for i, c in enumerate(count): sorted_arr.extend([i + min_val] * c) return sorted_arr"},{"question":"# RSA Encryption/Decryption Implementations Background RSA is one of the first public-key cryptosystems and is widely used for secure data transmission. Unlike symmetric key cryptosystems, RSA relies on a pair of keys: - A public key (n, e) for encryption. - A private key (n, d) for decryption. Task Your task is to implement RSA encryption and decryption based on the key generation algorithm provided. Requirements 1. **Key Generation Function**: Implement a function `generate_key_pair(k)` that generates a pair of RSA keys (public and private) with: - `k` being the bit length of the modulus `n`. - The function returns a tuple (n, e, d). 2. **Encryption Function**: Implement a function `encrypt(data, e, n)` that takes: - `data`: The plaintext data (an integer) to be encrypted. - `e`: The public exponent. - `n`: The modulus. - The function returns the encrypted data. 3. **Decryption Function**: Implement a function `decrypt(data, d, n)` that takes: - `data`: The encrypted data (an integer) to be decrypted. - `d`: The private exponent. - `n`: The modulus. - The function returns the decrypted data. Constraints - You may assume that the inputs `e`, `d`, and `n` are all positive integers. - Ensure that `d` correctly computes as the modular inverse of `e` modulo (p-1)*(q-1). - The bit length `k` will be at least 16 bits. Example ```python # Example usage: n, e, d = generate_key_pair(16) data = 42 encrypted = encrypt(data, e, n) decrypted = decrypt(encrypted, d, n) assert decrypted == data ``` Notes - You can use Python\'s built-in `pow()` function to perform modular exponentiation efficiently. - The generated primes should be of appropriate size to ensure the bit length of `n` adds up to `k`.","solution":"import random from sympy import isprime, mod_inverse def generate_prime_candidate(length): Generate an odd integer randomly p = random.getrandbits(length) # apply a mask to set MSB and LSB to 1 p |= (1 << length - 1) | 1 return p def generate_prime_number(length): Generate a prime p = 4 # keep trying until you find a prime while not isprime(p): p = generate_prime_candidate(length) return p def generate_key_pair(bit_length): Generate RSA public and private keys. p = generate_prime_number(bit_length // 2) q = generate_prime_number(bit_length // 2) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = mod_inverse(e, phi) return (n, e, d) def encrypt(data, e, n): Encrypt data using RSA public key. return pow(data, e, n) def decrypt(data, d, n): Decrypt data using RSA private key. return pow(data, d, n)"},{"question":"# Question: Implement an enhanced Merge Sort Objective You are given an array of integers and need to sort it in ascending order using the merge sort algorithm. The implementation should consider typical edge cases and aim for minimal auxiliary space usage. Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: pass ``` Input - A list of integers i.e., `arr` (0 ≤ len(arr) ≤ 10^5) Output - The function should return a new list of sorted integers. Constraints - Your implementation must have a time complexity of O(n log n) and a space complexity close to O(n). Requirements 1. Properly handle edge cases such as empty arrays and arrays with a single element. 2. Ensure the algorithm is robust and efficient for large datasets. 3. Enhance the merge function to reduce auxiliary space usage while still maintaining clarity and correctness. 4. The solution should be efficient and not cause stack overflow for large input sizes. Example ```python # Example 1 input_arr = [38, 27, 43, 3, 9, 82, 10] print(merge_sort(input_arr)) # Output: [3, 9, 10, 27, 38, 43, 82] # Example 2 input_arr = [] print(merge_sort(input_arr)) # Output: [] # Example 3 input_arr = [1] print(merge_sort(input_arr)) # Output: [1] ``` Enhance the provided merge sort algorithm with the above considerations.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Sorts the input list `arr` in ascending order using merge sort algorithm. if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: Merges two sorted sublists (`left` and `right`) into one sorted list. sorted_list = [] left_index, right_index = 0, 0 # Merge the two sorted sublists into a single sorted list while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 # Collect the remaining elements, if any sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list"},{"question":"Implement a function `improved_sort(arr)` that sorts an array of integers in ascending order. Your task is to enhance the given exchange sort algorithm based on its limitations and performance bottlenecks. You may consider some form of optimization or choose an entirely different sorting algorithm, provided it improves the performance. Expected Function Signature ```python def improved_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers, `arr` (0 <= len(arr) <= 10^4). Output * A new list of integers sorted in ascending order. Constraints - You may not use Python\'s built-in sorting functions. - Ensure that your algorithm performs better than O(n^2) for large arrays if possible. Performance Requirements - Aim for an average time complexity of O(n log n). Examples 1. Given `arr = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]`, your function should return `[1, 1, 2, 3, 3, 4, 5, 5, 5, 6, 9]`. 2. Given `arr = [10, -1, 3, 7, 8]`, your function should return `[-1, 3, 7, 8, 10]`. 3. Given `arr = []`, your function should return `[]`. Provide an explanation of why your sorting approach improves upon the provided `exchange_sort` algorithm.","solution":"from typing import List def improved_sort(arr: List[int]) -> List[int]: Sorts an array of integers in ascending order using the Merge Sort algorithm. Merge Sort is a divide-and-conquer algorithm that provides an average and worst-case time complexity of O(n log n). if len(arr) <= 1: return arr # Split the array into two halves mid = len(arr) // 2 left_half = improved_sort(arr[:mid]) right_half = improved_sort(arr[mid:]) # Merge the sorted halves return merge(left_half, right_half) def merge(left: List[int], right: List[int]) -> List[int]: sorted_array = [] i = j = 0 # Merge the two halves while maintaining order while i < len(left) and j < len(right): if left[i] < right[j]: sorted_array.append(left[i]) i += 1 else: sorted_array.append(right[j]) j += 1 # If there are remaining elements in left or right, append them sorted_array.extend(left[i:]) sorted_array.extend(right[j:]) return sorted_array"},{"question":"Pancake Sort Optimization and Enhancement You are given an array of integers that you need to sort using the Pancake Sort algorithm. Write a function `enhanced_pancake_sort` that sorts the array in ascending order. Your task is to first improve the basic pancake sort by minimizing the number of flips and ensuring the function handles all edge cases effectively. Function Signature ```python def enhanced_pancake_sort(arr: List[int]) -> List[int]: ``` Input * `arr` (List[int]): A list of integers that needs to be sorted. The array may have duplicate elements. Output * Returns the list sorted in ascending order. Constraints * 1 <= len(arr) <= 1000 * -10^6 <= arr[i] <= 10^6 Requirements * Ensure that the solution works efficiently within the given constraints. * Handle edge cases like arrays with one element, already sorted arrays, and arrays with all duplicates. * Reduce the number of flips compared to the standard pancake sort algorithm where possible. * Maintain an in-place sort to use O(1) additional space. Additional Context Pancake sorting is an analogue to flipping pancakes in a pan. Given an unsorted stack of pancakes, your goal is to sort the entire stack with a spatula which can flip any number of pancakes from the top of the stack. Demonstrate your understanding of this sorting technique, ensure minimal flips in your implementation and handle any edge cases effectively.","solution":"from typing import List def flip(arr: List[int], k: int): Helper function to reverse the array from start up to index k. arr[:k+1] = arr[:k+1][::-1] def enhanced_pancake_sort(arr: List[int]) -> List[int]: Sorts an array using the enhanced Pancake Sort algorithm. n = len(arr) for size in range(n, 1, -1): # Find the index of the maximum element in arr[0:size] max_idx = max(range(size), key=lambda i: arr[i]) if max_idx != size - 1: # Flip max element to the front if it\'s not already at the front if max_idx != 0: flip(arr, max_idx) # Flip max element to its final position flip(arr, size - 1) return arr"},{"question":"Longest Prefix-Suffix Matching with KMP Algorithm **Context**: You\'ve recently learned about the Knuth-Morris-Pratt (KMP) algorithm for string matching, a foundational algorithm in computer science known for its efficient handling of pattern searches within texts. As part of your coursework, you need to apply this knowledge to a related problem. **Objective**: Write a function `longest_prefix_suffix` that takes in a single string `s` and returns the length of the longest proper prefix which is also a suffix. A proper prefix is a prefix that is not equal to the string itself. **Function Signature**: ```python def longest_prefix_suffix(s: str) -> int: ``` **Input**: - `s` (1 <= len(s) <= 10^6): a string containing lowercase alphabets. **Output**: - An integer representing the length of the longest proper prefix which is also a suffix. # Examples: 1. `longest_prefix_suffix(\\"abab\\")` should return `2` 2. `longest_prefix_suffix(\\"aaaa\\")` should return `3` 3. `longest_prefix_suffix(\\"abcdef\\")` should return `0` 4. `longest_prefix_suffix(\\"abcabc\\")` should return `3` # Constraints: - Efficiency is crucial; the solution should run in linear time relative to the length of the string. - The function should correctly handle edge cases such as very short strings or strings with repeating patterns. **Hints**: - Consider the concept of the pi table (prefix function) used in the KMP algorithm. - Think about how building the pi table can help determine the longest prefix which is also a suffix. # Grading Criteria: - Correctness: Does your function return the right output for all test cases? - Efficiency: Does your implementation perform within acceptable time limits? - Edge Cases: Does your function handle edge cases properly?","solution":"def longest_prefix_suffix(s: str) -> int: n = len(s) lps = [0] * n length = 0 i = 1 while i < n: if s[i] == s[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps[n - 1]"},{"question":"You are given two strings, `haystack` and `needle`. Implement a function `find_needle` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. Your function should strictly follow the following guidelines: * Performance: Optimize the solution to handle large strings efficiently where possible. * Edge Cases: Consider common edge cases such as when `needle` is an empty string or longer than the `haystack`. Function Signature: ```python def find_needle(haystack: str, needle: str) -> int: ``` Input: * `haystack` : str : The main string to be searched. * `needle` : str : The substring to search for in `haystack`. Output: * int : The index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not found. Example: ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" output = find_needle(haystack, needle) print(output) # Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" output = find_needle(haystack, needle) print(output) # Output: -1 # Example 3 haystack = \\"haystack\\" needle = \\"\\" output = find_needle(haystack, needle) print(output) # Output: 0 ``` Constraints: * The function should handle cases where `haystack` and `needle` can be very large efficiently. * Avoid unnecessary string slicing and comparisons for better performance. Provide a thoughtful algorithm with detailed comments explaining each step and performance considerations integrated into your solution.","solution":"def find_needle(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack. # Edge case where needle is an empty string if not needle: return 0 # Edge case where needle is longer than haystack if len(needle) > len(haystack): return -1 # Iterate through the haystack only up to the point where the remaining # substring is at least as long as needle for i in range(len(haystack) - len(needle) + 1): # Check if the substring from i to i+len(needle) matches needle if haystack[i:i+len(needle)] == needle: return i # If needle is not found in haystack return -1"},{"question":"# Matrix Search Problem Scenario: You are given a matrix where each row and each column is sorted in non-decreasing order. Your task is to write an efficient function to find a given key in this matrix. If the key exists, your function should print the row and column indices (1-based) of the key. If the key does not exist, print a message indicating the key was not found. Function Signature: ```python def search_in_a_sorted_matrix(mat: List[List[int]], key: int) -> Tuple[int, int]: ``` Input: * `mat`: A list of lists of integers representing the matrix. * `key`: An integer representing the element to search for. Output: * A tuple of integers representing the 1-based row and column indices where the key is found, or (-1, -1) if the key is not found. Constraints: * The matrix will have at least 1 row and 1 column. * Each row and column in the matrix is sorted in non-decreasing order. Example: Given the matrix: ``` [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] ``` If the key is `13`, your function should return `(2, 3)` since `13` is located at row 2, column 3 (1-based index). If the key is `10`, your function should return `(-1, -1)` indicating the key is not found. Performance Requirements: * Your implementation should run in O(m + n) time, where m is the number of rows and n is the number of columns.","solution":"from typing import List, Tuple def search_in_a_sorted_matrix(mat: List[List[int]], key: int) -> Tuple[int, int]: Search for a key in a sorted matrix and return its position as (row, col) in 1-based index. If the key is not found, return (-1, -1). :param mat: List of lists, where each row and column is sorted in non-decreasing order. :param key: An integer to be searched. :return: A tuple representing the 1-based index of the key\'s position, or (-1, -1) if not found. if not mat or not mat[0]: return (-1, -1) rows, cols = len(mat), len(mat[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if mat[row][col] == key: return (row + 1, col + 1) elif mat[row][col] < key: row += 1 else: col -= 1 return (-1, -1)"},{"question":"Kruskal\'s Minimum Spanning Tree You are given an undirected, weighted, connected graph with `n` vertices and `m` edges. Implement Kruskal\'s algorithm to find the minimum spanning tree (MST) of this graph and return the sum of the weights of the edges in the MST. Input Format: - The first line contains two integers `n` and `m` representing the number of vertices and edges respectively. - The next `m` lines each contain three integers `u`, `v`, and `w` denoting an edge between vertices `u` and `v` with weight `w`. Output Format: - Return the sum of the weights of the edges in the minimum spanning tree. Constraints: - 1 ≤ n, m ≤ 1000 - 1 ≤ u, v ≤ n - 1 ≤ w ≤ 1000 Example: # Input: ``` 5 6 1 2 3 1 3 8 2 4 5 3 4 2 3 5 4 4 5 6 ``` # Output: ``` 14 ``` Explanation: The MST for this graph includes the edges with weights 3, 2, 4, and 5. Hence, the sum is (3 + 2 + 4 + 5 = 14). Function Signature: Write a function called `kruskal_mst` that takes the following parameters: - `int n`: number of vertices. - `List[Tuple[int, int, int]] edges`: list of edges, where each edge is a tuple `(u, v, w)`. The function should return an integer representing the sum of the weights of the edges in the minimum spanning tree. ```python def kruskal_mst(n, edges): # Your code here ```","solution":"def kruskal_mst(n, edges): # Helper function to find the root of a set with path compression def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] # Helper function to perform the union of two sets def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 # Step 1: Sort all the edges in non-decreasing order by weight edges.sort(key=lambda item: item[2]) parent = [] rank = [] # Create a parent array and a rank array for node in range(n+1): parent.append(node) rank.append(0) mst_weight_sum = 0 num_edges_in_mst = 0 # Step 2: Pick the smallest edge and check if it forms a cycle with the spanning tree formed so far for edge in edges: if num_edges_in_mst == n - 1: break u, v, w = edge root_u = find(parent, u) root_v = find(parent, v) # If including this edge does not cause a cycle, include it in the result if root_u != root_v: mst_weight_sum += w union(parent, rank, root_u, root_v) num_edges_in_mst += 1 return mst_weight_sum"},{"question":"<|Analysis Begin|> # Core Identification * **Algorithm/Data Structure**: The provided code snippet implements the algorithm for rotating an image (represented as an n x n 2D matrix) by 90 degrees clockwise. * **Complexity**: - Time Complexity: O(n^2), where n is the dimension of the matrix. - Space Complexity: O(1), as the rotation is performed in-place without any additional memory allocation. * **Principles**: - The matrix is first reversed upside down (row-wise reversal). - Symmetry is swapped by transposing the matrix elements along the main diagonal. # Characteristics & Applications * **Properties**: - An in-place algorithm, meaning no extra space beyond the input matrix size is used. - The operation involves both a row reversal and a transposition of the matrix. * **Common Use Cases**: - Rotating digital images in image processing. - Manipulating grid-based puzzles or games. * **Strengths/Limitations**: - **Strengths**: Space efficient, single matrix used. - **Limitations**: Not straightforward, involves two different transformations (reverse and transpose). Can be complex to comprehend initially. # Implementation Challenges * **Edge Cases**: - Empty matrix or single-element matrix. * **Performance Bottlenecks**: - None significant for in-place rotation. * **Error Scenarios**: - Improper handling of reversal or transposition can lead to incorrect rotation. * **Optimization Points**: - The given approach is quite efficient with respect to space complexity but verifying corner cases (such as sparse matrices) ensures robustness. <|Analysis End|> <|Question Begin|> # Rotate Matrix by 90 Degrees Clockwise Problem Statement You are given an n x n 2D matrix representing an image. You need to rotate the image by 90 degrees clockwise in-place. **Constraints:** - The transformation must be done in-place, which means you cannot use any additional 2D array. - The input matrix size `n x n` (i.e., number of rows and columns) is between 1 and 1000, inclusive. **Input:** - An `n x n` 2D matrix `mat` containing integers where `1 <= mat[i][j] <= 10^4`. **Output:** - The function should not return anything; it should modify the input matrix in-place to reflect the rotation. **Example:** ```python Input: mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] Output: [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` **Function Signature:** ```python def rotate(mat): # implement the function here ``` Detailed Requirements 1. **Initial Check**: - If the given matrix is empty or a single element, simply return as is. 2. **Steps to Rotate**: - Reverse the rows of the matrix: Reverse the matrix row by row from top to bottom. - Swap symmetry: For every element in the upper triangle (excluding the diagonal), swap it with the corresponding symmetric element. 3. **Edge Cases to Consider**: - Matrix with only one element, no rotation needed. - Large matrices (to ensure your algorithm handles the upper input constraint efficiently). Implement the `rotate` function that modifies the given matrix in-place to produce the required output.","solution":"def rotate(mat): Rotates a given n x n 2D matrix by 90 degrees clockwise in-place. Args: mat (List[List[int]]): The n x n 2D matrix to be rotated. n = len(mat) if n <= 1: return # Step 1: Reverse the rows of the matrix mat.reverse() # Step 2: Swap the symmetry (transpose the matrix) for i in range(n): for j in range(i + 1, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j]"},{"question":"Last Occurrence in a Sorted Array Given a sorted array of integers in increasing order and a target integer value, write a function `last_occurrence(array, query)` that returns the index of the last occurrence of the target value in the array. If the target value is not found in the array, the function should return -1. Function Signature ```python def last_occurrence(array: List[int], query: int) -> int: ``` Input * `array`: A list of integers sorted in increasing order. The length of the array is at most 10^6. * `query`: An integer representing the target value. Output * An integer representing the index of the last occurrence of the target value in the array. Constraints * The array must be sorted in increasing order. * The function should run in O(log n) time complexity to handle large datasets efficiently. * The function must return -1 if the target value does not exist in the array. Example ```python # Example 1 array = [1, 2, 2, 2, 3, 4, 5] query = 2 # The function should return 3 because the last occurrence of `2` is at index 3. # Example 2 array = [1, 2, 3, 4, 5, 6, 7] query = 5 # The function should return 4 because the last occurrence of `5` is at index 4. # Example 3 array = [1, 2, 2, 2, 3, 4, 5] query = 6 # The function should return -1 because `6` is not present in the array. ``` Notes * Consider handling edge cases such as an empty array or an array where all elements are the same. * Ensure proper management of array indices to avoid out-of-bound errors.","solution":"def last_occurrence(array, query): Returns the index of the last occurrence of the target value in the sorted array. If the target value is not found, returns -1. :param array: List[int] - A list of integers sorted in increasing order :param query: int - The target value to find :return: int - The index of the last occurrence of the target value left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == query: result = mid left = mid + 1 # Continue searching in the right half elif array[mid] < query: left = mid + 1 else: right = mid - 1 return result"},{"question":"Given the implementation of an AVL Tree outlined in the code snippet, your task is to extend its functionality to include deletion of nodes while maintaining the self-balancing property of the tree. Implement a function `delete` that removes a node with a specified key from the AVL Tree and rebalances the tree if necessary. Write a function `delete` with the following specifications: # Function Signature ```python def delete(self, key: int): ``` # Input - `key` (int): The value of the node to be deleted. # Output - None (the AVL tree should be updated in-place). # Constraints - You can assume that the key to be deleted always exists in the AVL tree. # Example ```python avl_tree = AvlTree() keys_to_insert = [20, 4, 26, 3, 9, 15] for key in keys_to_insert: avl_tree.insert(key) # Delete a node with key 4 avl_tree.delete(4) print(avl_tree.in_order_traverse()) # Output should be [3, 9, 15, 20, 26] ``` # Notes - Ensure that after deletion, the AVL tree remains balanced. - Performing the in-order traversal after deletion should yield a sorted list of the remaining keys in the tree.","solution":"class Node: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class AvlTree: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if node is None: return Node(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and key < node.left.key: return self._right_rotate(node) if balance < -1 and key > node.right.key: return self._left_rotate(node) if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) if not node: return node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) balance = self._get_balance(node) if balance > 1 and self._get_balance(node.left) >= 0: return self._right_rotate(node) if balance > 1 and self._get_balance(node.left) < 0: node.left = self._left_rotate(node.left) return self._right_rotate(node) if balance < -1 and self._get_balance(node.right) <= 0: return self._left_rotate(node) if balance < -1 and self._get_balance(node.right) > 0: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def _min_value_node(self, node): current = node while current.left: current = current.left return current def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def in_order_traverse(self): res = [] self._in_order_traverse(self.root, res) return res def _in_order_traverse(self, node, res): if node: self._in_order_traverse(node.left, res) res.append(node.key) self._in_order_traverse(node.right, res)"},{"question":"# Problem Description You are tasked with writing a function to decode a string encoded with a specific set of rules. The encoded string follows the pattern `k[encoded_string]`, where `encoded_string` is repeated exactly `k` times. Your function should correctly decode the string applying the rules when the input is always valid (no extra spaces, properly formed brackets, and digits only for representing repeat counts). # Function Signature ```python def decode_string(s: str) -> str: :param s: str - The encoded string. :return: str - The decoded string. ``` # Input - `s` (1 <= len(s) <= 30): a string encoded with the pattern `k[encoded_string]`. # Output - A string that is the decoded version of `s`. # Constraints - The input string `s` is guaranteed to be valid and properly formatted. - There are no embedded digits in the input except as repeat counts. - Possible nested encodings up to a reasonable level. # Examples 1. Input: `s = \\"3[a]2[bc]\\"` Output: `\\"aaabcbc\\"` 2. Input: `s = \\"3[a2[c]]\\"` Output: `\\"accaccacc\\"` 3. Input: `s = \\"2[abc]3[cd]ef\\"` Output: `\\"abcabccdcdcdef\\"` # Requirements - Ensure your algorithm has a linear time complexity O(n) given the constraints. - Optimize space usage where possible, given the expected depth of nested encodings. # Solution Approach Implement the function following these steps: 1. Initialize an empty stack, a current number (`cur_num`), and a current string (`cur_string`). 2. Traverse each character of the input string: - Push context to the stack when encountering `[`. - Pop and resolve pattern when encountering `]`. - Accumulate numbers if encountering digits. - Build the current string otherwise. 3. After traversing the input, the final `cur_string` will be the decoded string.","solution":"def decode_string(s: str) -> str: Decodes the given encoded string. stack = [] cur_string = \'\' cur_num = 0 for char in s: if char.isdigit(): cur_num = cur_num * 10 + int(char) elif char == \'[\': stack.append((cur_string, cur_num)) cur_string = \'\' cur_num = 0 elif char == \']\': last_string, num = stack.pop() cur_string = last_string + num * cur_string else: cur_string += char return cur_string"},{"question":"# Task You are required to implement the Cycle Sort algorithm. Your implementation should be based on understanding cycle decomposition and minimizing the number of writes. # Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: # your code here ``` # Inputs and Outputs * **Input**: A list of integers, `arr`, where (0 leq len(arr) leq 10^6) and all elements are within the bounds of typical integer values. * **Output**: The sorted list of integers in non-decreasing order. # Constraints 1. The algorithm must use the Cycle Sort technique. 2. The implementation must perform the sort in place with (O(1)) auxiliary space. 3. Aim to handle large inputs efficiently, but understand that Cycle Sort inherently has (O(N^2)) time complexity. # Example ```python assert cycle_sort([3, 6, 1, 8, 4, 5]) == [1, 3, 4, 5, 6, 8] assert cycle_sort([20, 40, 50, 10, 30]) == [10, 20, 30, 40, 50] assert cycle_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert cycle_sort([]) == [] ``` **Scenario**: You are a programmer working on an embedded system where memory write operations are costly. You need an efficient way to sort data with minimal write operations. Implement cycle sort to solve this problem.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: Sorts a list of integers in non-decreasing order using Cycle Sort algorithm. This algorithm is known for its minimal number of writes. n = len(arr) # Traverse the array one by one for start in range(n): # Store the item to be placed in its sorted position item = arr[start] # Find the position where we put the element pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 # If the element is already in the correct position, continue if pos == start: continue # Ignore all duplicate elements while item == arr[pos]: pos += 1 # Put the element to its correct position if pos != start: arr[pos], item = item, arr[pos] # Rotate rest of the cycle while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 # Put the element to its correct position if item != arr[pos]: arr[pos], item = item, arr[pos] return arr"},{"question":"As a software developer intern, you have been assigned the task of analyzing a function call history in a software system. The function call history is maintained using a stack data structure. Due to heavy usage, the current Array-based stack is running into performance issues with frequent resizing of the array. Your task is to implement a LinkedList-based stack for better performance during heavy operations. # Task: Problem Description: You need to implement a stack using a linked list with the following functionalities: 1. **push(item)**: Adds a new item to the top of the stack. 2. **pop()**: Removes and returns the top item from the stack. 3. **peek()**: Returns the top item from the stack without removing it. 4. **is_empty()**: Returns `True` if the stack is empty, else returns `False`. Given: You are provided with the \'StackNode\' class. Implement the \'LinkedListStack\' class. # Requirements: * Your implementation should handle edge cases such as popping from an empty stack and peeking at an empty stack. * Ensure that your stack operations (`push`, `pop`, `peek`, `is_empty`) are efficient. * Implement these operations in the ‘LinkedListStack’ class as described below. ```python class StackNode: Represents a single stack node. def __init__(self, value): self.value = value self.next = None class LinkedListStack: def __init__(self): self.head = None def push(self, value): Adds a new item to the top of the stack. :param value: item to be added. pass # To be implemented def pop(self): Removes and returns the top item from the stack. :return: top item from the stack. pass # To be implemented def peek(self): Returns the top item from the stack without removing it. :return: top item from the stack without removing it. pass # To be implemented def is_empty(self): Returns True if the stack is empty, else returns False. :return: boolean indicating if the stack is empty. pass # To be implemented # Example usage s = LinkedListStack() s.push(1) s.push(2) # Returns 2 print(s.peek()) # Returns 2 print(s.pop()) # Returns 1 print(s.peek()) # Returns False print(s.is_empty()) ``` # Input Constraints: * You do not need to handle input errors such as pushing invalid data types. * Operations will only be performed on integers as given in the example usage. # Output: * Your implemented functions should match the expected behavior as shown in the example usage. Good luck, and happy coding!","solution":"class StackNode: Represents a single stack node. def __init__(self, value): self.value = value self.next = None class LinkedListStack: def __init__(self): self.head = None def push(self, value): Adds a new item to the top of the stack. :param value: item to be added. new_node = StackNode(value) new_node.next = self.head self.head = new_node def pop(self): Removes and returns the top item from the stack. :return: top item from the stack. if self.is_empty(): raise IndexError(\\"Pop from empty stack\\") top_value = self.head.value self.head = self.head.next return top_value def peek(self): Returns the top item from the stack without removing it. :return: top item from the stack without removing it. if self.is_empty(): raise IndexError(\\"Peek from empty stack\\") return self.head.value def is_empty(self): Returns True if the stack is empty, else returns False. :return: boolean indicating if the stack is empty. return self.head is None"},{"question":"**Problem Statement: Implement a Doubly Linked List** You are required to implement a doubly linked list with the operations described below. Your implementation should support: 1. Inserting a node at the head. 2. Inserting a node at the tail. 3. Deleting a node by value. 4. Searching for a node by value (should return the first node with given value). 5. Displaying the list from head to tail. # Constraints * Values are integer numbers. * The list should handle both positive and negative integer values. * You should ensure that the list does not contain duplicate values. * Operations will be tested for efficiency; aim to achieve the stated complexities. # Function Signatures Implement the following functions: ```python class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value: int) -> None: pass # Your implementation here def insert_at_tail(self, value: int) -> None: pass # Your implementation here def delete_node(self, value: int) -> bool: pass # Your implementation here def search(self, value: int) -> DoublyLinkedListNode: pass # Your implementation here def display(self) -> list: pass # Your implementation here ``` # Expected Output For the function: * `insert_at_head(value)`: Inserts a node with the specified value at the head of the list. * `insert_at_tail(value)`: Inserts a node with the specified value at the tail of the list. * `delete_node(value)`: Attempts to delete the node with the specified value from the list. Returns `True` if deletion was successful; `False` otherwise. * `search(value)`: Searches for the first node containing the specified value and returns it. If no such node exists, return `None`. * `display()`: Returns a list of values representing the current state of the list from head to tail. # Example ``` dll = DoublyLinkedList() dll.insert_at_head(3) dll.insert_at_tail(5) dll.insert_at_head(2) dll.display() # Output: [2, 3, 5] dll.delete_node(3) # Output: True dll.display() # Output: [2, 5] dll.search(5) # Output: DoublyLinkedListNode object with value 5 dll.search(10) # Output: None ```","solution":"class DoublyLinkedListNode: def __init__(self, value): self.value = value self.next = None self.prev = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def insert_at_head(self, value: int) -> None: if self.search(value): return new_node = DoublyLinkedListNode(value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def insert_at_tail(self, value: int) -> None: if self.search(value): return new_node = DoublyLinkedListNode(value) if not self.tail: self.head = self.tail = new_node else: new_node.prev = self.tail self.tail.next = new_node self.tail = new_node def delete_node(self, value: int) -> bool: node = self.search(value) if not node: return False if node.prev: node.prev.next = node.next if node.next: node.next.prev = node.prev if node == self.head: self.head = node.next if node == self.tail: self.tail = node.prev return True def search(self, value: int) -> \'DoublyLinkedListNode\': current = self.head while current: if current.value == value: return current current = current.next return None def display(self) -> list: values = [] current = self.head while current: values.append(current.value) current = current.next return values"},{"question":"# Floyd-Warshall Algorithm Implementation **Context**: You are designing a routing algorithm for an urban traffic control system. The goal is to determine the shortest paths between all pairs of intersections in the city to optimize traffic light timing and route suggestions. **Task**: Implement the Floyd-Warshall algorithm to compute shortest paths between all pairs of intersections represented as a graph with positive and negative edge weights. Write a function that takes an adjacency matrix of edge weights and returns a matrix of the shortest path distances. # Function Signature ```python def floyd_warshall(adjacency_matrix: List[List[float]]) -> List[List[float]]: Args: adjacency_matrix (List[List[float]]): A 2D matrix where the element at [i][j] represents the weight of the edge from vertex i to vertex j. A value of float(\'inf\') indicates the absence of an edge. Returns: List[List[float]]: A 2D matrix where the element at [i][j] represents the shortest distance from vertex i to vertex j. ``` # Input * `adjacency_matrix`: A 2D list of floats of size n x n (1 ≤ n ≤ 500), where `adjacency_matrix[i][j]` is the weight of the edge from vertex `i` to vertex `j`. * `adjacency_matrix[i][i]` will always be 0. * `adjacency_matrix[i][j]` is `float(\'inf\')` if there is no direct edge from `i` to `j`. # Output * A 2D list of floats of size n x n, where the element at `[i][j]` is the shortest distance from vertex `i` to vertex `j`. # Constraints * The graph can contain positive and negative edge weights but will not contain negative weight cycles. * Floating-point precision errors must be handled appropriately. # Example ```python from typing import List import math def floyd_warshall(adjacency_matrix: List[List[float]]) -> List[List[float]]: n = len(adjacency_matrix) # Create a deep copy of the adjacency matrix to maintain the original data distance = [row[:] for row in adjacency_matrix] for k in range(n): for i in range(n): for j in range(n): if distance[i][j] > distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] return distance # Example usage: adjacency_matrix = [ [0, 3, float(\'inf\'), 5], [2, 0, float(\'inf\'), 4], [float(\'inf\'), 1, 0, float(\'inf\')], [float(\'inf\'), float(\'inf\'), 2, 0] ] expected_output = [ [0, 3, 7, 5], [2, 0, 6, 4], [3, 1, 0, 5], [5, 3, 2, 0] ] assert floyd_warshall(adjacency_matrix) == expected_output ``` # Notes * Ensure to test the function with various cases, including graphs with disconnected nodes and negative weights. * Consider edge cases, such as a graph where all nodes are isolated (no edges).","solution":"from typing import List def floyd_warshall(adjacency_matrix: List[List[float]]) -> List[List[float]]: Implements the Floyd-Warshall algorithm that computes shortest paths between all pairs of vertices in a given weighted graph. Args: adjacency_matrix (List[List[float]]): A 2D matrix where the element at [i][j] represents the weight of the edge from vertex i to vertex j. A value of float(\'inf\') indicates the absence of an edge. Returns: List[List[float]]: A 2D matrix where the element at [i][j] represents the shortest distance from vertex i to vertex j. n = len(adjacency_matrix) # Create a deep copy of the adjacency matrix to maintain the original data distance = [row[:] for row in adjacency_matrix] for k in range(n): for i in range(n): for j in range(n): if distance[i][j] > distance[i][k] + distance[k][j]: distance[i][j] = distance[i][k] + distance[k][j] return distance"},{"question":"# Question: **Prefix Sum with Fenwick Tree** You have been given an array of integers representing the frequency of occurrences. Implement a `Fenwick_Tree` class that supports the following operations efficiently: 1. **Construct**: Constructs the Binary Indexed Tree from the input array. 2. **Get Sum**: Returns the cumulative frequency up to a given index. 3. **Update**: Updates an element in the array and the Binary Indexed Tree. # Input: 1. An integer `n`, representing the number of elements in the array. 2. An array `arr` of size `n`, where `arr[i]` denotes the frequency at index `i`. 3. Several operations: * **get_sum(i)**: Takes an index `i` and returns the sum of the first `i` elements in the array. * **update(i, value)**: Updates the element at index `i` to `value`. # Output: For each `get_sum` operation, output the cumulative sum up to the given index. # Constraints: 1. `1 <= n <= 10^5` 2. `0 <= arr[i] <= 10^9` 3. Operations will be in the form specified and within reasonable constraints to ensure efficient computation. # Example: Input: ```plaintext 5 [3, 2, -1, 6, 5] get_sum(3) update(3, 2) get_sum(3) ``` Output: ```plaintext 10 6 ``` *Note*: The output corresponds to the results of the `get_sum` operations. # Notes: - Initialize a Fenwick Tree and use it to perform the necessary operations as described. - Ensure that your implementation efficiently handles both queries and updates.","solution":"class Fenwick_Tree: def __init__(self, arr): Initializes a Fenwick Tree (Binary Indexed Tree) from the given array. self.n = len(arr) self.BITree = [0] * (self.n + 1) self.arr = [0] * self.n # To store the original array for i in range(self.n): self.update(i, arr[i]) def get_sum(self, i): Returns the sum of the elements from arr[0] to arr[i] (inclusive). i += 1 # To match 1-based indexing of BIT s = 0 while i > 0: s += self.BITree[i] i -= i & (-i) return s def update(self, i, value): Updates the element at index i to value. diff = value - self.arr[i] self.arr[i] = value i += 1 # To match 1-based indexing of BIT while i <= self.n: self.BITree[i] += diff i += i & (-i)"},{"question":"Objective Design a function to find all start positions of a pattern string within a larger text string using the Rabin-Karp algorithm. The aim is to assess your understanding of rolling hashes and efficient string searching. # Function Signature ```python def find_pattern_positions(pattern: str, text: str) -> List[int]: pass ``` # Input and Output * **Input**: * `pattern`: A string to search for within the `text`. Non-empty string. * `text`: A string where the pattern search occurs. Non-empty string. * **Output**: * A list of integers representing all start positions where the pattern begins within the text. # Constraints * Only lowercase English letters in both `pattern` and `text`. * Length of `pattern` (m): 1 <= m <= 10^3 * Length of `text` (n): 1 <= n <= 10^5 # Notes * Consider edge cases such as overlapping occurrences and no matches. * Ensure your solution handles large input sizes efficiently. # Example ```python # Example 1 pattern = \\"aba\\" text = \\"abacaba\\" output = find_pattern_positions(pattern, text) # Output: [0, 4] # Example 2 pattern = \\"abc\\" text = \\"abcdef\\" output = find_pattern_positions(pattern, text) # Output: [0] # Example 3 pattern = \\"xyz\\" text = \\"abcdef\\" output = find_pattern_positions(pattern, text) # Output: [] ``` # Performance Requirement Your solution should run in O(n + m) time on average, providing efficiency for large inputs.","solution":"from typing import List def find_pattern_positions(pattern: str, text: str) -> List[int]: Finds all start positions of the pattern string within the text string using the Rabin-Karp algorithm. if not pattern or not text or len(pattern) > len(text): return [] result = [] base = 256 prime = 101 m, n = len(pattern), len(text) pat_hash = 0 text_hash = 0 h = 1 # Precompute h = base^(m-1) % prime for i in range(m - 1): h = (h * base) % prime # Compute initial hash values for pattern and first window of text for i in range(m): pat_hash = (base * pat_hash + ord(pattern[i])) % prime text_hash = (base * text_hash + ord(text[i])) % prime # Slide the pattern over text one character at a time for i in range(n - m + 1): if pat_hash == text_hash: # Check if current window\'s hash matches the pattern\'s hash if text[i:i + m] == pattern: # Final check for characters match result.append(i) if i < n - m: # Compute hash for next window (remove leading character, add trailing character) text_hash = (base * (text_hash - ord(text[i]) * h) + ord(text[i + m])) % prime # Ensure positive hash value if text_hash < 0: text_hash += prime return result"},{"question":"Find Primitive Roots Given a positive integer n, your task is to write a function that finds all primitive roots of n. If no primitive roots exist, return an empty list. # Function Signature ```python def find_primitive_root(n: int) -> List[int]: Returns a list of all primitive roots of n. ``` # Input - Single positive integer `n` (1 ≤ n ≤ 10^6). # Output - A list of integers which are the primitive roots of the given integer `n` sorted in ascending order. # Constraints 1. If ( text{gcd}(a, n) neq 1 ), ( a ) cannot have an order modulo ( n ). 2. Ensure the function handles edge constraints efficiently. # Example ```python # Example 1: n = 10 # 2 and 4 are the primitive roots of 10. print(find_primitive_root(n)) # Output: [] # Example 2: n = 13 # 2 and 6 are the primitive roots of 13. print(find_primitive_root(n)) # Output: [2, 6, 7, 11] # Example 3: n = 1 # The only primitive root of 1 is 0. print(find_primitive_root(n)) # Output: [0] ``` # Note Be cautious of the time complexity, and ensure that your implementation handles large inputs within a reasonable time frame. Use efficient methods to compute the necessary aspects like the totients and orders.","solution":"from typing import List import math def gcd(a: int, b: int) -> int: while b: a, b = b, a % b return a def find_primitive_root(n: int) -> List[int]: def is_primitive_root(root: int, n: int, totient: int) -> bool: required = set(range(1, n)) seen = set() current = root for _ in range(totient): if current in seen or gcd(current, n) != 1: return False seen.add(current) current = current * root % n return seen == required if n <= 1: return [] if n == 0 else [0] phi = n - 1 # assuming n is prime; this might need modification for non-prime n primitive_roots = [] for candidate in range(1, n): if is_primitive_root(candidate, n, phi): primitive_roots.append(candidate) return primitive_roots"},{"question":"# Prompt: Given a specific pattern characterized by lowercase letters and a string `str` composed of lowercase words separated by a single space, your task is to write a function `is_bijective_pattern(pattern: str, string: str) -> bool` that returns `True` if the string follows the pattern, and `False` otherwise. The follow pattern means that there is a bijection, i.e., a one-to-one correspondence between characters in the pattern and words in the string. # Input: * A string `pattern` consisting of lowercase letters. * A string `str` consisting of lowercase words separated by a single space. # Output: * Return `True` if the string follows the given pattern, otherwise return `False`. # Constraints: * Pattern consists only of lowercase letters (a-z). * String consists only of lowercase words separated by a single space. * The length of pattern and string will be at most 1000 characters each. # Scenarios: 1. Pattern: \\"abba\\", String: \\"dog cat cat dog\\" => Output: True 2. Pattern: \\"abba\\", String: \\"dog cat cat fish\\" => Output: False 3. Pattern: \\"aaaa\\", String: \\"dog cat cat dog\\" => Output: False 4. Pattern: \\"abba\\", String: \\"dog dog dog dog\\" => Output: False # Requirements: * Ensure your solution runs efficiently within the given constraints. * Handle cases where the length of pattern does not match the number of words in the string. * Ensure a bijective (one-to-one) correspondence between characters and words. # Example: ```python def is_bijective_pattern(pattern: str, string: str) -> bool: # Your implementation here pass # Test Cases print(is_bijective_pattern(\\"abba\\", \\"dog cat cat dog\\")) # Should return True print(is_bijective_pattern(\\"abba\\", \\"dog cat cat fish\\")) # Should return False print(is_bijective_pattern(\\"aaaa\\", \\"dog cat cat dog\\")) # Should return False print(is_bijective_pattern(\\"abba\\", \\"dog dog dog dog\\")) # Should return False ``` # Explanation: In Example 1, characters \'a\' and \'b\' map to \\"dog\\" and \\"cat\\" respectively. Thus \\"abba\\" and \\"dog cat cat dog\\" are bijective, returning true. In Example 2, character \'a\' maps to \\"dog\\" but \'b\' maps to both \\"cat\\" and \\"fish\\", so it returns false.","solution":"def is_bijective_pattern(pattern: str, string: str) -> bool: # Split the words in the string words = string.split() # If lengths of pattern and words do not match, return False if len(pattern) != len(words): return False # Dictionaries to store the mapping of pattern to word and word to pattern pattern_to_word = {} word_to_pattern = {} # Iterate through each character in pattern and corresponding word for char, word in zip(pattern, words): # Check if we have a mapping from pattern to word if char in pattern_to_word: # If there is a mismatch, return False if pattern_to_word[char] != word: return False else: # If there is no mapping, create one pattern_to_word[char] = word # Check if we have a mapping from word to pattern if word in word_to_pattern: # If there is a mismatch, return False if word_to_pattern[word] != char: return False else: # If there is no mapping, create one word_to_pattern[word] = char return True"},{"question":"# Context You\'re working on a system that synchronizes data between two servers. Each data packet is represented as an integer, and the system uses bit-level operations to detect changes between packets efficiently. To ensure the synchronization process is minimal in data exchange, you need to determine the minimal number of bits that need to be changed to convert one packet representation (integer A) to another (integer B). # Problem Statement Write a function `count_flips_to_convert(a: int, b: int) -> int` to determine the minimal number of bits that need to be flipped to convert integer A to integer B. Input: * Two integers, `a` and `b` (0 ≤ a, b ≤ 2^31 - 1). Output: * Return an integer representing the number of bit flips required. Constraints: * Consider edge cases like: * When `a` and `b` are equal. * When `a` or `b` is zero. * When `a` or `b` is the maximum value (2^31 - 1). Performance Requirements: * The solution should be efficient, with a constant time complexity O(1) and space complexity O(1). ```python def count_flips_to_convert(a: int, b: int) -> int: # Write your implementation here pass # Example Usage # Input: 29 (11101), 15 (01111) # Output: 2 assert count_flips_to_convert(29, 15) == 2 # Input: 1 (0001), 4 (0100) # Output: 2 assert count_flips_to_convert(1, 4) == 2 # Input: 0, 0 # Output: 0 assert count_flips_to_convert(0, 0) == 0 ```","solution":"def count_flips_to_convert(a: int, b: int) -> int: Returns the number of bit flips required to convert integer a to integer b. # XOR a and b; the result will have bits set where a and b differ. xor_result = a ^ b # Count and return the number of set bits in xor_result. return bin(xor_result).count(\'1\')"},{"question":"You are required to expand the given implementation of a **Binary Search Tree (BST)** by adding methods to address additional scenarios and operations. # Objective Implement the following new operations: 1. **Delete**: A method to delete a node with a given value from the BST. 2. **Find Minimum**: A method to find the minimum value in the BST. 3. **Find Maximum**: A method to find the maximum value in the BST. 4. **Height**: A method to calculate the height of the BST. # Function Signatures: * `def delete(self, data):` * `def find_min(self):` * `def find_max(self):` * `def height(self):` # Input and Output Formats * **Deletion**: * Input: `delete(data)` where `data` is the value to be deleted. * Output: The tree should no longer contain the node with `data`, if it existed. * **Find Minimum**: * Input: `find_min()` * Output: The minimum value present in the BST. * **Find Maximum**: * Input: `find_max()` * Output: The maximum value present in the BST. * **Height**: * Input: `height()` * Output: The height of the BST, defined as the number of edges on the longest path from the root to a leaf. # Constraints 1. No constraints on the values to be inserted (handling of duplicate values can be omitted). 2. Assume the tree does not contain any non-integer elements. 3. All new methods should preserve the properties of the BST. # Guidelines * Implement the methods directly within the provided BST class. * Ensure the methods work with the existing tree structure and integrate seamlessly. * Write related unit tests to validate the correctness of each method. # Example: ```python tree = BST() tree.insert(10) tree.insert(15) tree.insert(6) tree.insert(4) tree.insert(9) tree.insert(12) tree.insert(24) tree.insert(7) tree.insert(20) tree.insert(30) tree.insert(18) print(tree.find_min()) # Output: 4 print(tree.find_max()) # Output: 30 print(tree.height()) # Output: 4 tree.delete(24) print(tree.search(24)) # Output: False ```","solution":"class Node: def __init__(self, data): self.data = data self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, data): if self.root is None: self.root = Node(data) else: self._insert(data, self.root) def _insert(self, data, node): if data < node.data: if node.left is None: node.left = Node(data) else: self._insert(data, node.left) else: if node.right is None: node.right = Node(data) else: self._insert(data, node.right) def search(self, data): return self._search(data, self.root) def _search(self, data, node): if node is None: return False elif node.data == data: return True elif data < node.data: return self._search(data, node.left) else: return self._search(data, node.right) def delete(self, data): self.root = self._delete(self.root, data) def _delete(self, node, data): if node is None: return node if data < node.data: node.left = self._delete(node.left, data) elif data > node.data: node.right = self._delete(node.right, data) else: # Node with only one child or no child if node.left is None: return node.right elif node.right is None: return node.left # Node with two children: Get the inorder successor temp = self._min_value_node(node.right) node.data = temp.data node.right = self._delete(node.right, temp.data) return node def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current def find_min(self): return self._find_min(self.root) def _find_min(self, node): current = node while current.left is not None: current = current.left return current.data def find_max(self): return self._find_max(self.root) def _find_max(self, node): current = node while current.right is not None: current = current.right return current.data def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return max(left_height, right_height) + 1"},{"question":"You are tasked with implementing an improved version of the Quick Sort algorithm to handle some of its common drawbacks. In particular, you need to implement the following enhancements: 1. Implement the Quick Sort algorithm using a randomized pivot to minimize the risk of hitting the worst-case time complexity. 2. Switch to Insertion Sort for small partitions (e.g., 10 elements or less) to improve performance on small subsets. Write a function `quick_sort_optimized(arr)` that sorts an array using the optimized Quick Sort algorithm. The function should return the sorted array. Function Signature ```python def quick_sort_optimized(arr): pass ``` Input - `arr`: A list of integers, length can be between 0 and 10^4. Output - A sorted list of integers. Constraints - Use Quick Sort with randomized pivots. - Switch to Insertion Sort for partitions of size 10 or smaller. Performance Requirements - Aim for an average-case time complexity of O(n log(n)). # Implementation Tips 1. **Randomized Pivot:** Randomly select a pivot to help reduce the chance of the worst-case scenario. 2. **Insertion Sort for Small Partitions:** For subarrays with less than or equal to 10 elements, use a simpler and more efficient sorting algorithm such as Insertion Sort to avoid the overhead of recursive calls. Edge Cases - Empty array. - Array with duplicate values. - Already sorted array.","solution":"import random def insertion_sort(arr, low, high): for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def partition(arr, low, high): pivot_index = random.randint(low, high) arr[pivot_index], arr[high] = arr[high], arr[pivot_index] pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort(arr, low, high): if low < high: if high - low <= 10: insertion_sort(arr, low, high) else: pivot_index = partition(arr, low, high) quick_sort(arr, low, pivot_index - 1) quick_sort(arr, pivot_index + 1, high) def quick_sort_optimized(arr): if not arr: return arr quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"# Question You are given two integers ( n ) and ( m ). Implement a function `count_strobogrammatic_in_range(n, m)` which counts how many strobogrammatic numbers exist within the range ( n ) to ( m ) inclusive. Constraints: - The range [n, m] will be given in string format. - The length of the string representing the numbers can vary between 1 and 14. - The numbers ( n ) and ( m ) will be valid positive integers with ( 1 leq int(n) leq int(m) ). Function Signature: ```python def count_strobogrammatic_in_range(n: str, m: str) -> int: pass ``` Input: - `n`: A string representation of the lower bound. - `m`: A string representation of the upper bound. Output: - An integer representing the count of all strobogrammatic numbers within the range [n, m]. Example: ```python print(count_strobogrammatic_in_range(\\"50\\", \\"100\\")) # Output: 3 ``` (The strobogrammatic numbers within the range are \\"69\\", \\"88\\", and \\"96\\") Performance Requirements: - The solution should be optimized to handle the upper constraint efficiently. - Memory usage should be considered to avoid excessive consumption.","solution":"def count_strobogrammatic_in_range(n: str, m: str) -> int: Count the strobogrammatic numbers in the range [n, m]. def is_strobogrammatic(num: str) -> bool: Check if a number is strobogrammatic. strobogrammatic_pairs = {\'0\': \'0\', \'1\': \'1\', \'6\': \'9\', \'8\': \'8\', \'9\': \'6\'} l, r = 0, len(num) - 1 while l <= r: if num[l] not in strobogrammatic_pairs or strobogrammatic_pairs[num[l]] != num[r]: return False l += 1 r -= 1 return True def generate_strobogrammatic(n: int, m: int) -> list: Generate all strobogrammatic numbers of length between n and m. def helper(m, n): if m == 0: return [\\"\\"] if m == 1: return [\\"0\\", \\"1\\", \\"8\\"] prev = helper(m - 2, n) curr = [] for num in prev: if m != n: curr.append(\\"0\\" + num + \\"0\\") curr.append(\\"1\\" + num + \\"1\\") curr.append(\\"6\\" + num + \\"9\\") curr.append(\\"8\\" + num + \\"8\\") curr.append(\\"9\\" + num + \\"6\\") return curr result = [] for length in range(n, m + 1): result.extend(helper(length, length)) return result count = 0 strobogrammatic_numbers = generate_strobogrammatic(len(n), len(m)) for num in strobogrammatic_numbers: if len(num) == len(n) and num < n: continue if len(num) == len(m) and num > m: continue count += 1 return count"},{"question":"# Objective You are given a binary tree and need to implement a function to perform postorder traversal iteratively. While postorder traversal is often done recursively, this exercise will focus on implementing the iterative approach, which can be better for performance with large trees. # Problem Statement Write a function that performs an iterative postorder traversal of a binary tree. The function should return a list of values representing the traversal. # Input The function will receive the root node of a binary tree. ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output A list of integers where each integer is a node value visited in postorder. # Constraints * The number of nodes in the tree can be up to (10^4). * Each node\'s value will be a unique integer. * The tree may be balanced, unbalanced, or degenerate (linked list form). # Example ```python def postorder_iterative(root): # Your implementation # Example usage: root = Node(1, Node(2), Node(3)) print(postorder_iterative(root)) # Output: [2, 3, 1] root2 = Node(1, Node(2, Node(4), Node(5)), Node(3, Node(6), Node(7))) print(postorder_iterative(root2)) # Output: [4, 5, 2, 6, 7, 3, 1] ``` # Additional Notes - Make sure to handle edge cases such as an empty tree. - Focus on the iterative approach for this implementation to understand the stack management. - Aim for an efficient solution with respect to both time and space complexity. Avoid unnecessary recursion or excessive memory usage.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def postorder_iterative(root): if not root: return [] result = [] stack = [] last_visited = None while stack or root: if root: stack.append(root) root = root.left else: peek_node = stack[-1] if peek_node.right and last_visited != peek_node.right: root = peek_node.right else: stack.pop() result.append(peek_node.val) last_visited = peek_node return result"},{"question":"# Digit Counting Algorithm Implementation **Problem Statement**: Write a function `count_digits` that takes an integer as input and returns the number of digits in that integer. Ensure your solution works efficiently for both positive and negative inputs as well as edge cases such as zero. **Function Signature**: `def count_digits(n: int) -> int:` **Input**: - `n` (int): An integer whose number of digits is to be counted. It can be a positive integer, a negative integer, or zero. **Output**: - An integer representing the number of digits in `n`. **Constraints**: - The function should handle integers in a typical 32-bit signed integer range (-2^31 to 2^31 - 1). **Examples**: 1. `count_digits(12345)` should return `5`. 2. `count_digits(-6789)` should return `4`. 3. `count_digits(0)` should return `1`. **Performance Requirements**: - The function should run in constant time O(1). **Scenario**: Imagine you are developing a digital number pad interface where you need to quickly provide feedback on the number of digits entered. You must ensure that the system can handle a range of integer inputs effectively and efficiently, providing accurate digit counts without delay.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the integer n. Works for positive, negative integers including zero. # Convert the integer to a string and strip the negative sign if present return len(str(abs(n)))"},{"question":"# Question: You are given two strings `word1` and `word2`. Your task is to write a function that determines the minimum number of steps required to make the two strings the same. In each step, you can delete one character in either string. **Function Signature:** ```python def min_distance(word1: str, word2: str) -> int: ``` Input: - word1: A string with length `n` (1 <= n <= 1000) - word2: A string with length `m` (1 <= m <= 1000) Output: - An integer representing the minimum number of steps. Example: ``` Input: word1 = \\"sea\\", word2 = \\"eat\\" Output: 2 Explanation: You need one step to make \\"sea\\" to \\"ea\\" and another step to make \\"eat\\" to \\"ea\\". ``` Constraints: - The strings consist of lowercase English letters. - Solve the problem using a dynamic programming approach to ensure optimal performance. - Consider both time and space efficiency while implementing. Hints: - Think about how you can leverage the LCS (Longest Common Subsequence) approach to reduce the problem. - Use a 2D DP table where each cell `res[i][j]` represents the minimum steps to make the substrings `word1[:i]` and `word2[:j]` the same.","solution":"def min_distance(word1: str, word2: str) -> int: # Compute the length of the words n = len(word1) m = len(word2) # Create a DP table where dp[i][j] represents the length of LCS of word1[:i] and word2[:j] dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the DP table for i in range(1, n + 1): for j in range(1, m + 1): # If current characters match, add 1 to the LCS for the previous characters if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 # Otherwise take the maximum from the left or top cell else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # The length of LCS lcs = dp[n][m] # The minimum number of steps to make the two strings the same return (n - lcs) + (m - lcs)"},{"question":"# Problem Description # Matrix Zigzag Traversal Given a matrix of ( m times n ) elements (m rows and n columns), return all elements of the matrix in a zigzag order. Zigzag Order Starting from the top-left element, proceed right across the top row, then diagonally down to the left, then back diagonally up to the next element on the right column, and so on, until all elements are traversed. Example Given the following matrix: [ begin{array}{ccc} 1 & 2 & 3 4 & 5 & 6 7 & 8 & 9 end{array} ] The expected zigzag traversal is: [1, 2, 4, 7, 5, 3, 6, 8, 9] # Constraints - The matrix can have up to ( 10^6 ) elements. - Elements of the matrix are integers. - The matrix is not necessarily square (i.e., m and n can be different). # Function Signature ```python def zigzag_traversal(matrix: List[List[int]]) -> List[int]: pass ``` # Input - **matrix**: A list of lists of integers representing the ( m times n ) matrix. # Output - **List[int]**: A list of integers representing the zigzag traversal of the matrix. # Example ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(zigzag_traversal(mat)) # Expected output: [1, 2, 4, 7, 5, 3, 6, 8, 9] ``` # Hints - Consider the direction changes: right, down-left, up-right. - Ensure edge cases such as single row/column matrices are handled correctly.","solution":"from typing import List def zigzag_traversal(matrix: List[List[int]]) -> List[int]: if not matrix or not matrix[0]: return [] m, n = len(matrix), len(matrix[0]) result = [] row, col, direction = 0, 0, 1 # direction 1 means moving up-right, -1 means down-left while row < m and col < n: result.append(matrix[row][col]) new_row = row + (-1 if direction == 1 else 1) new_col = col + (1 if direction == 1 else -1) if new_row < 0 or new_row == m or new_col < 0 or new_col == n: if direction == 1: if new_col == n: row += 1 else: col += 1 else: if new_row == m: col += 1 else: row += 1 direction *= -1 else: row = new_row col = new_col return result"},{"question":"**Objective**: Demonstrate your understanding of backtracking by implementing a function to generate all possible subsets of a set of distinct integers using both a recursive and iterative approach. **Problem Statement**: You are given a set of distinct integers, `nums`. Your task is to implement a function `subsets(nums)` that returns all possible subsets (the power set). **Requirements**: 1. Implement the function with a recursive approach using backtracking. 2. Implement the function with an iterative approach. **Function Signature**: ```python def subsets(nums: List[int]) -> List[List[int]]: pass def subsets_v2(nums: List[int]) -> List[List[int]]: pass ``` **Input Format**: - `nums`: List of distinct integers. **Output Format**: - A list of lists, where each list represents a subset of the input list. **Constraints**: - The length of `nums` will be in the range [0, 20]. **Examples**: 1. Input: `nums = [1, 2, 3]` Output: `[[], [1], [2], [3], [1,2], [1,3], [2,3], [1,2,3]]` 2. Input: `nums = []` Output: `[[]]` 3. Input: `nums = [5]` Output: `[[], [5]]` # Detailed Requirements: 1. **Recursive Approach**: - Use a helper function `backtrack` that takes current subset and position as parameters. - Make decisions to include or exclude the current element for each function call. - Append the resulting subset when all decisions are made (i.e., at the end of the recursion). 2. **Iterative Approach**: - Start with the initial subset `res = [[]]`. - For each element in the input list, create new subsets by adding the current element to all existing subsets. - Append these new subsets to the result and continue until all elements are processed. **Performance Requirements**: - Ensure that your algorithm runs efficiently for the input size constraint where `nums` can have up to 20 elements.","solution":"from typing import List def subsets(nums: List[int]) -> List[List[int]]: def backtrack(start, path): res.append(path[:]) for i in range(start, len(nums)): path.append(nums[i]) backtrack(i + 1, path) path.pop() res = [] backtrack(0, []) return res def subsets_v2(nums: List[int]) -> List[List[int]]: res = [[]] for num in nums: new_subsets = [curr + [num] for curr in res] res.extend(new_subsets) return res"},{"question":"You are given an array `colors` where each element can be `0`, `1`, or `2`, representing the colors red, white, and blue respectively. Your task is to sort the array in place such that the colors are arranged in the order red, white, and blue. Implement a function `sort_colors(colors)` which modifies the input list in-place to achieve the required order. Do not use any built-in sorting functions for this task. # Input * An array `colors` of integers where `0 <= colors[i] <= 2` and `1 <= len(colors) <= 10^5`. # Output * The function should modify the input list so that it is sorted in the order of `0`s first, followed by `1`s, and then `2`s. # Constraints * The function must operate in O(n) time complexity. * The function must use O(1) additional space, i.e., it should sort the array in place. # Example ```python def sort_colors(colors): i = j = 0 for k in range(len(colors)): v = colors[k] colors[k] = 2 if v < 2: colors[j] = 1 j += 1 if v == 0: colors[i] = 0 i += 1 # Example colors = [2, 0, 2, 1, 1, 0] sort_colors(colors) print(colors) # Output: [0, 0, 1, 1, 2, 2] ``` # Edge Cases 1. Input array contains only one type of color. 2. Input array is already sorted. 3. Input array is in completely reverse order. 4. Input array has only one element. # Additional Considerations 1. Ensure proper handling of edge cases in the implementation. 2. Verify correctness through a mix of random and boundary test cases to confirm algorithm robustness.","solution":"def sort_colors(colors): Sort the colors array in-place such that 0\'s (red color) come first, followed by 1\'s (white color), and then 2\'s (blue color). low, mid, high = 0, 0, len(colors) - 1 while mid <= high: if colors[mid] == 0: # red colors[low], colors[mid] = colors[mid], colors[low] low += 1 mid += 1 elif colors[mid] == 1: # white mid += 1 else: # blue colors[mid], colors[high] = colors[high], colors[mid] high -= 1"},{"question":"# Nearest Neighbor Extended You have been given a training set of labeled n-dimensional vectors and a query vector. Using the Nearest Neighbor approach, determine the label of the query vector based on the shortest Euclidean distance to the vectors in the training set. Task Implement the following function: ```python def classify(query_vector, training_set): Classify the input query_vector based on the nearest neighbor among the training_set. Arguments: query_vector : tuple The vector to be classified. training_set : dict A dictionary where keys are vectors (tuples) and values are the corresponding labels. Returns: label : any The label of the nearest training set vector to the query vector. ``` Input * `query_vector`: A tuple of integers/floats representing coordinates in an n-dimensional space. * `training_set`: A dictionary where the keys are tuples of integers/floats (vectors) and the values are the labels (can be any hashable type) related to those vectors. Output * Return the label corresponding to the nearest neighbor of the query vector from the training set. # Example ```python query_vector = (1, 2) training_set = { (1, 2): \'A\', (3, 4): \'B\', (5, 6): \'C\' } assert classify(query_vector, training_set) == \'A\' ``` Constraints * Assume that the vectors are always numerical. * You can assume the following for all inputs: * `1 <= len(query_vector) <= 100` * `1 <= len(training_set) <= 10^4` * Each vector in the training set has the same dimension as the query_vector. Performance Requirements * The solution must efficiently handle the given constraints, particularly the size of `training_set`.","solution":"import math def classify(query_vector, training_set): Classify the input query_vector based on the nearest neighbor among the training_set. Arguments: query_vector : tuple The vector to be classified. training_set : dict A dictionary where keys are vectors (tuples) and values are the corresponding labels. Returns: label : any The label of the nearest training set vector to the query vector. min_distance = float(\'inf\') nearest_label = None for vector, label in training_set.items(): distance = math.sqrt(sum((q - v) ** 2 for q, v in zip(query_vector, vector))) if distance < min_distance: min_distance = distance nearest_label = label return nearest_label"},{"question":"# Problem: Minimum Edit Distance Calculation Given two words word1 and word2, you need to write a function `min_edit_distance(word1, word2)` that computes the minimum number of operations (insertions, deletions, and substitutions) required to transform word1 into word2. Function Signature ```python def min_edit_distance(word1: str, word2: str) -> int: ``` Input * `word1` (string): The first word. * `word2` (string): The second word. # Constraints: * `0 <= len(word1), len(word2) <= 500` * word1 and word2 consist of lowercase English letters. Output * Returns an integer corresponding to the minimum edit distance between `word1` and `word2`. Example ```python assert min_edit_distance(\\"food\\", \\"money\\") == 4 assert min_edit_distance(\\"intention\\", \\"execution\\") == 5 assert min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert min_edit_distance(\\"\\", \\"abc\\") == 3 assert min_edit_distance(\\"abc\\", \\"\\") == 3 assert min_edit_distance(\\"\\", \\"\\") == 0 assert min_edit_distance(\\"same\\", \\"same\\") == 0 ``` Explanation Given the two words `food` and `money`, the minimum edit distance is 4. One optimal way to transform `food` to `money` is: 1. Change \'f\' to \'m\'. 2. Insert \'n\' after \'m\'. 3. Change \'o\' to \'e\'. 4. Insert \'y\' after \'e\'. This question tests your understanding of dynamic programming and your ability to implement and optimize 2D array manipulation in Python.","solution":"def min_edit_distance(word1: str, word2: str) -> int: Computes the minimum number of operations (insertions, deletions, and substitutions) required to transform word1 into word2. len1 = len(word1) len2 = len(word2) # dp table with (len1+1) x (len2+1) dimensions dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] # Initialize the dp array for i in range(len1 + 1): dp[i][0] = i for j in range(len2 + 1): dp[0][j] = j # Fill the dp table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if word1[i - 1] == word2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min( dp[i - 1][j] + 1, # Deletion dp[i][j - 1] + 1, # Insertion dp[i - 1][j - 1] + 1 # Substitution ) return dp[len1][len2]"},{"question":"# Coding Challenge: Array Filtering Algorithm Context: You are processing data from various sensors, and you need to filter out readings that do not fall within a specific range. This preprocessing step is crucial for ensuring that subsequent analysis algorithms only work with relevant data. Task: Write a function `filter_array` that limits an array to values between a given minimum and maximum limit, inclusive. The function should handle cases where the limits might be unspecified (i.e., None). Requirements: * **Input**: - `arr` (List[int]): The list of integers to filter. - `min_lim` (int, optional): The minimum allowed value. If None, there is no lower limit. - `max_lim` (int, optional): The maximum allowed value. If None, there is no upper limit. * **Output**: - List[int]: A list containing the elements from `arr` that lie within the specified range [min_lim, max_lim]. Constraints: * The input list `arr` can be empty. * The result must respect the order of elements as they appear in the input list. Function Signature: ```python def filter_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: ``` Examples: ```python assert filter_array([1,2,3,4,5], None, 3) == [1, 2, 3] assert filter_array([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert filter_array([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] assert filter_array([1, 2, 3, 4, 5], None, None) == [1, 2, 3, 4, 5] assert filter_array([], 1, 5) == [] assert filter_array([1, 2, 3, 4, 5], 5, 1) == [] ``` Notes: * You should ensure that None values for `min_lim` or `max_lim` are interpreted as having no lower or upper bound, respectively. * Focus on code efficiency—ensure your solution runs in O(n) time complexity.","solution":"from typing import List, Optional def filter_array(arr: List[int], min_lim: Optional[int] = None, max_lim: Optional[int] = None) -> List[int]: Filters the given array to include only values between min_lim and max_lim, inclusive. If min_lim is None, there is no lower bound. If max_lim is None, there is no upper bound. if min_lim is None and max_lim is None: return arr filtered_arr = [] for num in arr: if (min_lim is None or num >= min_lim) and (max_lim is None or num <= max_lim): filtered_arr.append(num) return filtered_arr"},{"question":"# Comb Sort Implementation and Analysis **Problem Statement**: You are tasked with implementing the Comb Sort algorithm from scratch. Comb Sort is an enhancement over Bubble Sort that attempts to eliminate small values near the end of the list faster. Alongside the implementation, you should also handle various edge cases and optimize your solution to ensure efficiency. **Function Signature**: ```python def comb_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers that needs to be sorted. **Output**: - Returns a sorted list of integers. **Constraints**: 1. The input list will have a length `n` such that `1 <= n <= 10^5`. 2. The elements of the list are integers where `-10^6 <= arr[i] <= 10^6`. **Performance Requirements**: - Your solution should aim for the average-case time complexity better than O(N^2). **Scenario and Context**: Imagine you are part of a software development team tasked with optimizing a system with mediocre sorting performance. Your team has identified that Bubble Sort is causing delays. You propose using Comb Sort as an improvement. Your implementation will replace the previous algorithm, solving the inefficiency problem. **Requirements and Points to Consider**: - Handle edge cases such as empty arrays, arrays with one element or already sorted arrays. - Ensure that your algorithm handles large arrays efficiently without causing performance bottlenecks. - Return the result in a new list to avoid in-place sorting affecting the original input. **Example**: ```python assert comb_sort([64, 34, 25, 12, 22, 11, 90]) == [11, 12, 22, 25, 34, 64, 90] assert comb_sort([]) == [] assert comb_sort([1]) == [1] assert comb_sort([7, 3, 9, 2, 5]) == [2, 3, 5, 7, 9] ``` **Note**: Based on the Comb Sort implementation you\'ve studied, write a detailed approach and implement the function accordingly. Justify your choices made during implementation.","solution":"def comb_sort(arr): Implements the Comb Sort algorithm which is an improvement over Bubble Sort. def get_next_gap(gap): # Shrink gap by shrink factor of 1.3 gap = (gap * 10) // 13 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Sorting Algorithm Analysis and Enhancement Bogo Sort, also whimsically known as \\"stupid sort,\\" is a notoriously inefficient algorithm due to its reliance on random shuffling. Despite being impractical for real-world applications, it serves as an engaging example of algorithm complexity and inefficiency. For this task, you must implement and analyze a more efficient sorting algorithm called **Insertion Sort**, then compare it to Bogo Sort. Here’s what you need to do: 1. **Implement Insertion Sort** 2. **Compare Performance**: Write a program to empirically compare the performance of Insertion Sort and Bogo Sort on various input sizes. Part 1: Insertion Sort Implementation Implement the Insertion Sort algorithm as a function: ```python def insertion_sort(arr): Sorts an array in ascending order using the insertion sort algorithm. Parameters: arr (list): The list of elements to be sorted. Returns: list: The sorted list. # Your code here ``` Part 2: Performance Comparison Write a function to compare the performance between Insertion Sort and Bogo Sort. It should record the time taken to sort arrays of different sizes using both algorithms. ```python import time def compare_performance(): Compares the performance of Insertion Sort and Bogo Sort on arrays of varying sizes. Prints the time taken for both sorting algorithms for each array size. # array sizes to test array_sizes = [5, 10, 15] for size in array_sizes: test_array = [random.randint(1, 100) for _ in range(size)] # Timing insertion sort start_time = time.time() insertion_sort(test_array.copy()) insertion_sort_time = time.time() - start_time # Timing bogo sort start_time = time.time() bogo_sort(test_array.copy()) bogo_sort_time = time.time() - start_time print(f\\"Array size: {size}\\") print(f\\"Insertion Sort Time: {insertion_sort_time:.6f}s\\") print(f\\"Bogo Sort Time: {bogo_sort_time:.6f}s\\") print(\\"-\\" * 30) ``` # Input and Output Formats - Input for `insertion_sort(arr)` function: A list of integers. - Output for `insertion_sort(arr)` function: A sorted list in ascending order. **Constraints**: - The input for performance comparison should contain randomly generated integers within a reasonable range to simulate real input scenarios. - Compare the two algorithms only on relatively small arrays (up to size 15) for practicality. # Performance Requirements - Ensure that the `insertion_sort` function has a time complexity of O(n^2), which is more realistic and manageable than the O(n(n-1)!) of Bogo Sort. Example Scenario A scenario could include testing various small arrays, such as: - `[3, 1, 4, 1, 5]` - `[10, 9, 8, 7, 6]` - `[2, 3, 1, 5, 4]` And observing the significantly faster performance of Insertion Sort compared to Bogo Sort.","solution":"import random def insertion_sort(arr): Sorts an array in ascending order using the insertion sort algorithm. Parameters: arr (list): The list of elements to be sorted. Returns: list: The sorted list. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr def is_sorted(arr): Helper function to check if the array is sorted in ascending order. return all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) def bogo_sort(arr): Sorts an array in ascending order using the bogo sort algorithm. Will only work for small arrays due to its inefficiency. Parameters: arr (list): The list of elements to be sorted. Returns: list: The sorted list. while not is_sorted(arr): random.shuffle(arr) return arr import time def compare_performance(): Compares the performance of Insertion Sort and Bogo Sort on arrays of varying sizes. Prints the time taken for both sorting algorithms for each array size. array_sizes = [5, 10, 15] for size in array_sizes: test_array = [random.randint(1, 100) for _ in range(size)] # Timing insertion sort start_time = time.time() insertion_sort(test_array.copy()) insertion_sort_time = time.time() - start_time # Timing bogo sort start_time = time.time() bogo_sort(test_array.copy()) bogo_sort_time = time.time() - start_time print(f\\"Array size: {size}\\") print(f\\"Insertion Sort Time: {insertion_sort_time:.6f}s\\") print(f\\"Bogo Sort Time: {bogo_sort_time:.6f}s\\") print(\\"-\\" * 30)"},{"question":"# Scenario You\'re working for a fintech startup, and one of your tasks involves ensuring that their transactional system can efficiently identify fraudulent transactions. One simple heuristic is to identify when a transaction indirectly \\"balances out\\" another recent transaction, indicating potential fraud. # Task Implement a function `find_two_sum(array, target)` that finds two distinct elements in the array which sum up to the given target and returns their indices. Assume that the input will always have exactly one such pair. # Requirements 1. **Function Signature**: `def find_two_sum(array: List[int], target: int) -> Tuple[int, int]:` 2. **Input**: - `array`: A list of integers. - `target`: An integer representing the sum we need to find. 3. **Output**: A tuple of two integers representing the indices of the two elements that sum to the target. 4. **Constraints**: - Each input will have exactly one solution. - You may not use the same element twice. - The array will have at least two elements. # Example ```python assert find_two_sum([2, 7, 11, 15], 9) == (0, 1) ``` # Note Make sure your solution runs efficiently with a time complexity of O(n).","solution":"from typing import List, Tuple def find_two_sum(array: List[int], target: int) -> Tuple[int, int]: Finds two distinct elements in the \'array\' which sum up to \'target\' and returns their indices. lookup = {} for index, value in enumerate(array): complement = target - value if complement in lookup: return (lookup[complement], index) lookup[value] = index # Example usage result = find_two_sum([2, 7, 11, 15], 9) print(result) # Output should be (0, 1)"},{"question":"Hierarchical Tree Data Display You are given a nested dictionary representing hierarchical data similar to a directory structure or an organizational chart. Each key in the dictionary is a node, and its value is a list containing strings and/or other nested lists representing the structure. Your task is to implement a function `tree_print(tree: dict) -> None` that outputs the tree structure in a specified format: - Each top-level node (key) starts on a new line. - Each child node is indented by two spaces. - Non-string node values trigger a newline and indentation. The function should handle: - Empty input (print nothing). - Mixed types in values. - Necessary indentation for clarity. Input Format - `tree` (dict): A dictionary where keys are strings and values are lists containing strings and/or nested structures. Output Format - The function prints the hierarchy as described. Constraints - The tree structure won\'t be deeper than 4 levels. - Nodes within the tree structures are only string or integer types. Example ```python tree = { \\"a\\": [\\"Adam\\", \\"Book\\", 4], \\"b\\": [\\"Bill\\", \\"Computer\\", 5, \\"TV\\", 6, \\"Jill\\", \\"Sports\\", 1], \\"c\\": [\\"Bill\\", \\"Sports\\", 3], \\"d\\": [\\"Adam\\", \\"Computer\\", 3, \\"Quin\\", \\"Computer\\", 3], \\"e\\": [\\"Quin\\", \\"Book\\", 5, \\"TV\\", 2], \\"f\\": [\\"Adam\\", \\"Computer\\", 7] } Expected Output: a -> Adam -> Book -> 4 b -> Bill -> Computer -> 5 -> TV -> 6 -> Jill -> Sports -> 1 c -> Bill -> Sports -> 3 d -> Adam -> Computer -> 3 -> Quin -> Computer -> 3 e -> Quin -> Book -> 5 -> TV -> 2 f -> Adam -> Computer -> 7 ``` Implement the `tree_print` function conforming to the signature provided. ```python def tree_print(tree): for key in tree: print(key, end=\' \') tree_element = tree[key] for subElem in tree_element: print(\\" -> \\", subElem, end=\' \') if type(subElem) != str: print(\\"n \\") print() ```","solution":"def tree_print(tree: dict) -> None: Prints the hierarchical tree structure in a specified format. for key, values in tree.items(): print(key, end=\' -> \') print(\\" -> \\".join(map(str, values)))"},{"question":"# Scenario: You are working as a software engineer at a tech company where you are required to optimize search features in various applications. You have a sorted list of users\' last login timestamps (represented as integers), and you need to search for specific timestamps efficiently. Given this context, implement a binary search function to perform this task. # Task: Write a function `find_timestamp(timestamps, target)` that searches for a given `target` timestamp in a sorted list `timestamps`. If the `target` timestamp is found, return its index. If not found, return `-1`. Ensure your solution handles edge cases such as empty arrays and boundary conditions efficiently. # Input: - `timestamps` (List of integers) : A list of sorted integers representing timestamps. - `target` (Integer) : The timestamp you are searching for. # Output: - Integer : The index of the `target` timestamp if found; otherwise, `-1`. # Constraints: - The function must complete in O(log n) time complexity. - The input list can be empty. # Examples: ```python # Example 1: timestamps = [1001, 1025, 1030, 1047, 1055, 1066] target = 1047 # Output: 3 # Example 2: timestamps = [1001, 1025, 1030, 1047, 1055, 1066] target = 1080 # Output: -1 # Example 3: timestamps = [] target = 1001 # Output: -1 ``` # Requirements: - Function signature: `def find_timestamp(timestamps: [int], target: int) -> int` - Make sure to cover all edge cases including empty lists and target elements not in the list.","solution":"def find_timestamp(timestamps, target): Searches for the target timestamp in the sorted list of timestamps using binary search. Parameters: timestamps (list of int): A sorted list of integer timestamps. target (int): The target timestamp to search for. Returns: int: The index of the target timestamp if found, otherwise -1. left, right = 0, len(timestamps) - 1 while left <= right: mid = left + (right - left) // 2 if timestamps[mid] == target: return mid elif timestamps[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"Context You are responsible for managing a system where a sequence of operations is stored in a stack. A critical requirement is to verify whether the sequence of operations (represented as integers) is consecutive from bottom to top. Task Write a function `is_consecutive_with_queue(stack: List[int]) -> bool` that determines if a given stack contains a sequence of consecutive integers starting from the bottom of the stack. Your implementation should use a single queue as auxiliary storage. Input - A list of integers `stack` representing the stack, where the first element in the list corresponds to the bottom of the stack. Output - Return `True` if the stack contains consecutive integers from bottom to top. - Return `False` otherwise. Constraints - The numbers in the stack will be non-negative integers. - You are required to use a single queue as auxiliary storage and restore the stack to its original state after the function completes. Performance Requirements - Ensure that your solution has a time complexity of (O(n)) and a space complexity of (O(n)). Example ```python assert is_consecutive_with_queue([3, 4, 5, 6, 7]) == True assert is_consecutive_with_queue([3, 4, 6, 7]) == False assert is_consecutive_with_queue([3, 2, 1]) == False assert is_consecutive_with_queue([]) == True # an empty stack is considered to have no consecutive constraints assert is_consecutive_with_queue([1]) == True # single element is trivially consecutive ``` Function Signature ```python def is_consecutive_with_queue(stack: List[int]) -> bool: # Your code here ```","solution":"from typing import List from collections import deque def is_consecutive_with_queue(stack: List[int]) -> bool: if len(stack) <= 1: return True queue = deque() prev = stack[0] for elem in stack[1:]: if elem != prev + 1: return False queue.append(elem) prev = elem # Restore the stack to its original state while queue: stack.insert(0, queue.pop()) return True"},{"question":"You are tasked with implementing a matrix decomposition function based on the Crout matrix decomposition algorithm. This function should decompose a given square matrix (A) into two matrices (L) and (U) such that (L * U = A). # Function Signature ```python def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: ``` # Input * A: A 2D list of floats (square matrix) representing the matrix to be decomposed. - Matrix (A) will be of size (n times n), where (n geq 1). - The elements in (A) will be real numbers. # Output * Returns a tuple where the first element is the lower triangular matrix (L) and the second element is the upper triangular matrix (U). - (L) is an (n times n) lower triangular matrix with non-zero elements on the diagonal and below. - (U) is an (n times n) upper triangular matrix with ones on the diagonal and non-zero elements above. # Constraints * You may assume that the input matrix (A) is invertible. * Handle potential precision issues when performing division operations. * Implementations should aim for a balance between clarity and performance. # Example ```python A = [ [1.0, 2.0, 3.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0] ] L, U = crout_matrix_decomposition(A) # Expected Output: # L = [ # [1.0, 0.0, 0.0], # [3.0, -2.0, 0.0], # [6.0, -5.0, 0.0] # ] # U = [ # [1.0, 2.0, 3.0], # [0.0, 1.0, 2.0], # [0.0, 0.0, 1.0] # ] ``` # Notes * You may use the pseudo-code and details provided in the initial analysis to guide your implementation.","solution":"from typing import List, Tuple def crout_matrix_decomposition(A: List[List[float]]) -> Tuple[List[List[float]], List[List[float]]]: n = len(A) # Initialize L and U with zeroes L = [[0.0] * n for _ in range(n)] U = [[0.0] * n for _ in range(n)] for i in range(n): U[i][i] = 1.0 # Set the diagonal of U to 1 # Compute the L matrix for j in range(i, n): L[j][i] = A[j][i] - sum(L[j][k] * U[k][i] for k in range(i)) # Compute the U matrix for j in range(i + 1, n): U[i][j] = (A[i][j] - sum(L[i][k] * U[k][j] for k in range(i))) / L[i][i] return L, U"},{"question":"Context A highly esteemed company employs a unique method in their data processing center to reduce computing overhead — they use stack-based algorithms to successfully manage tasks such as function call management and backtracking. Understanding and implementing optimized stack mechanisms can significantly enhance the system\'s efficiency. Problem Statement You are assigned the task of developing two different types of stack data structures: one using a static array and the other using a linked list. Your implementation should comply with the given Stack Abstract Data Type (ADT) and handle edge cases including but not limited to stack overflow, underflow, and memory management efficiently. 1. **ArrayStack**: Implement a stack using a static array where you should handle stack overflow by dynamically resizing the array. 2. **LinkedListStack**: Implement a stack using a singly linked list where each stack node points to the next node. Each implementation must provide methods: `push(item)`, `pop()`, `peek()`, and `is_empty()`. Specifications - **ArrayStack**: - `__init__(self, size=10)`: Initializes the stack with an initial size of 10 or the given size. - `push(self, value)`: Adds a value on top of the stack, expanding the array if needed. - `pop(self)`: Removes and returns the top value from the stack or raises an IndexError if empty. - `peek(self)`: Returns the top value from the stack without removing it or raises an IndexError if empty. - `is_empty(self)`: Returns whether the stack is empty. - **LinkedListStack**: - `__init__(self)`: Initializes an empty stack. - `push(self, value)`: Adds a value on top of the stack. - `pop(self)`: Removes and returns the top value from the stack or raises an IndexError if empty. - `peek(self)`: Returns the top value from the stack without removing it or raises an IndexError if empty. - `is_empty(self)`: Returns whether the stack is empty. Write the implementations for both `ArrayStack` and `LinkedListStack` according to the above ADT descriptions. Constraints - The input operations for the stack will be in the form of method calls. - Ensure methods are efficient and handle errors appropriately. - You are not permitted to use Python\'s built-in list methods for stack operations directly (e.g., using `list.append()` for `push`). Example Usage ```python # Example usage for ArrayStack array_stack = ArrayStack() array_stack.push(10) array_stack.push(20) print(array_stack.peek()) # Outputs: 20 print(array_stack.pop()) # Outputs: 20 print(array_stack.is_empty()) # Outputs: False # Example usage for LinkedListStack linked_list_stack = LinkedListStack() linked_list_stack.push(\'a\') linked_list_stack.push(\'b\') print(linked_list_stack.peek()) # Outputs: \'b\' print(linked_list_stack.pop()) # Outputs: \'b\' print(linked_list_stack.is_empty()) # Outputs: False ```","solution":"class ArrayStack: def __init__(self, size=10): self.stack = [None] * size self.capacity = size self.top = -1 def push(self, value): if self.top >= self.capacity - 1: self._resize() self.top += 1 self.stack[self.top] = value def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.stack[self.top] self.stack[self.top] = None self.top -= 1 return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[self.top] def is_empty(self): return self.top == -1 def _resize(self): self.capacity *= 2 new_stack = [None] * self.capacity for i in range(self.top + 1): new_stack[i] = self.stack[i] self.stack = new_stack class LinkedListStack: class Node: def __init__(self, value, next=None): self.value = value self.next = next def __init__(self): self.head = None def push(self, value): new_node = self.Node(value) new_node.next = self.head self.head = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.head.value self.head = self.head.next return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.head.value def is_empty(self): return self.head is None"},{"question":"**Scenario:** You are tasked to build a scheduler that can verify whether a person can attend all the provided meetings without any overlap. You need to implement a function to determine if a list of meeting time intervals is conflict-free. **Function Signature:** ```python def can_attend_meetings(intervals: List[List[int]]) -> bool: ``` # Input: * `intervals`: A list of `n` meeting time intervals consisting of start and end times. Each interval `[start, end]` is given as a list of two integers such that `start < end`. # Output: * Return `True` if a person can attend all meetings without overlap, and `False` otherwise. # Constraints: * The list of intervals may have up to 10^4 intervals. * Each pair `[start, end]` will respect the constraint that `0 <= start < end <= 10^6`. # Example: ```python assert can_attend_meetings([[0, 30], [5, 10], [15, 20]]) == False assert can_attend_meetings([[7, 10], [2, 4]]) == True ``` # Explanation: 1. In the first example, the intervals [0, 30] and [5, 10] overlap. 2. In the second example, there are no overlapping intervals, so the person can attend all meetings. # Completion: You need to ensure your function is both efficient and correct, considering the constraints and edge cases provided.","solution":"from typing import List def can_attend_meetings(intervals: List[List[int]]) -> bool: Determines if a person can attend all meeting intervals without any overlap. Args: intervals (List[List[int]]): List of meeting intervals represented as [start, end]. Returns: bool: True if a person can attend all meetings without overlap, False otherwise. # First, sort the intervals by their start times intervals.sort(key=lambda x: x[0]) for i in range(1, len(intervals)): # Compare the end time of the previous interval with the start time of the current interval if intervals[i-1][1] > intervals[i][0]: return False return True"},{"question":"**Problem Statement**: You are given a graph represented as an adjacency list (a dictionary where each key represents a node and its value is a list of adjacent nodes). Implement a function `detect_cycle(graph: Dict[int, List[int]]) -> bool` that determines if there is a cycle in the graph. # Input - `graph`: A dictionary representing an undirected graph. The keys are node identifiers (integers), and the values are lists of adjacent nodes. # Output - Return `True` if the graph contains a cycle, otherwise return `False`. # Constraints 1. The graph is undirected. 2. The node identifiers are non-negative integers. 3. There are no parallel edges or self-loops. 4. The graph may be disconnected. # Example ```python graph1 = { 0: [1, 2], 1: [0, 2], 2: [0, 1, 3], 3: [2] } # This graph has a cycle: 0 -> 1 -> 2 -> 0 graph2 = { 0: [1], 1: [0, 2], 2: [1] } # This graph does not have any cycle print(detect_cycle(graph1)) # Output: True print(detect_cycle(graph2)) # Output: False ``` # Performance Requirements Your solution should have a time complexity of O(V + E) and a space complexity of O(V), where V is the number of vertices and E is the number of edges in the graph. # Note You may use either Depth-First Search (DFS) or Breadth-First Search (BFS) to solve this problem. Ensure that your implementation handles disconnected graphs and does not modify the input graph.","solution":"from typing import List, Dict, Set def detect_cycle(graph: Dict[int, List[int]]) -> bool: Detects if there is a cycle in the given undirected graph. :param graph: A dictionary representing an undirected graph. :return: True if there is a cycle, False otherwise. def dfs(node: int, parent: int, visited: Set[int]) -> bool: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node, visited): return True elif parent != neighbor: return True return False visited = set() for node in graph: if node not in visited: if dfs(node, -1, visited): return True return False"},{"question":"Objective Design a function to compute the LCM of an array of positive integers based on the provided GCD and LCM functions. Your function should efficiently handle large arrays with elements up to (10^9). Problem Statement Given an array of positive integers, write a function `array_lcm(arr)` that computes the Least Common Multiple (LCM) of all elements in the array. You may assume the array length is at least 2 and all integers are positive. Input and Output Format * **Input**: A list of positive integers `arr` with length ( n ) ( ( 2 leq n leq 10^5 ) ). * **Output**: An integer representing the LCM of the elements in the array. Constraints * ( 1 leq arr[i] leq 10^9 ) * Function performance should be efficient to handle the upper limit of input sizes. Example ``` python >>> array_lcm([2, 7, 3]) 42 >>> array_lcm([1, 2, 3, 4, 5]) 60 ``` Hints * Leverage the relationship between GCD and LCM: ( text{LCM}(a, b) = frac{|a cdot b|}{text{GCD}(a, b)} ). * Consider using the `reduce` function from the `functools` module to iteratively apply the LCM function across the array elements. Implementation Notes 1. You can utilize the provided `gcd` and `lcm` functions to simplify your solution. 2. Avoid overflow issues by ensuring intermediate results for LCM computations do not exceed the maximum integer limits. Consider the following code template to get started: ```python from functools import reduce def array_lcm(arr): def gcd(a, b): while b != 0: a, b = b, a % b return a def lcm(a, b): return abs(a * b) // gcd(a, b) return reduce(lcm, arr) # Example usage: print(array_lcm([2, 7, 3])) # Output: 42 print(array_lcm([1, 2, 3, 4, 5])) # Output: 60 ```","solution":"from functools import reduce def array_lcm(arr): def gcd(a, b): while b != 0: a, b = b, a % b return a def lcm(a, b): return abs(a * b) // gcd(a, b) return reduce(lcm, arr)"},{"question":"# Question Objective Write a function to encode a list of integers using a modified Run-Length Encoding (RLE) and another function to decode the encoded string back to the original list. The modification: 1. Instead of a single character, we deal with sequences of integers. 2. Each integer and its count are separated by a comma, and each pair count-integer separated by a semicolon. # Input and Output Formats * **Encoding Function** (`encode_rle`): * **Input**: A list of non-negative integers. * **Output**: A string where each integer and its count form a pair separated by a comma, and each pair is separated by a semicolon, representing the RLE encoded data. * **Decoding Function** (`decode_rle`): * **Input**: A string representing the RLE encoded data. * **Output**: The original list of integers. # Examples Example 1: * **Input**: `[3, 3, 3, 6, 6, 9, 9, 9, 9]` * **Output**: `\'3,3;2,6;4,9\'` * **Explanation**: The list `[3, 3, 3, 6, 6, 9, 9, 9, 9]` is encoded as `3` occurs `3` times, `6` occurs `2` times, `9` occurs `4` times. Example 2: * **Input**: `\'3,3;2,6;4,9\'` * **Output**: `[3, 3, 3, 6, 6, 9, 9, 9, 9]` * **Explanation**: The encoded string `3,3;2,6;4,9` decodes back to `[3, 3, 3, 6, 6, 9, 9, 9, 9]`. # Constraints * The input list will only contain non-negative integers. * You may assume the counts will not be zero. * You may assume the input string for decoding is always valid. **Function Signatures**: ```python def encode_rle(input): pass def decode_rle(input): pass ```","solution":"def encode_rle(input_list): if not input_list: return \\"\\" encoded_result = [] current_number = input_list[0] count = 1 for num in input_list[1:]: if num == current_number: count += 1 else: encoded_result.append(f\\"{count},{current_number}\\") current_number = num count = 1 # Append the last run-length pair encoded_result.append(f\\"{count},{current_number}\\") return \\";\\".join(encoded_result) def decode_rle(encoded_string): if not encoded_string: return [] decoded_list = [] pairs = encoded_string.split(\\";\\") for pair in pairs: count, number = pair.split(\\",\\") decoded_list.extend([int(number)] * int(count)) return decoded_list"},{"question":"You are given a robot initially positioned at (0, 0) on a 2D coordinate plane. The robot can make moves in four possible directions, denoted by the characters \'R\' (Right), \'L\' (Left), \'U\' (Up), and \'D\' (Down). Write a function `judge_circle(moves)` that determines if the robot returns to the origin (0, 0) after a sequence of moves. - The input to the function is a string `moves`, where each character represents the robot\'s move. - The output should be a boolean `True` if the robot returns to the initial position, or `False` otherwise. # Function Signature ```python def judge_circle(moves: str) -> bool: ``` # Input - A string `moves` (0 <= len(moves) <= 10^4): The sequence of moves made by the robot. # Output - A boolean: `True` if the robot returns to the origin, otherwise `False`. # Examples ```python print(judge_circle(\\"UD\\")) # True print(judge_circle(\\"LL\\")) # False print(judge_circle(\\"\\")) # True print(judge_circle(\\"UDLR\\")) # True ``` # Constraints - Moves can only be \'U\', \'D\', \'L\', \'R\'. - Handle empty move sequences gracefully. # Hints - Use a dictionary to count the occurrences of each move. - Compare counts for opposing directions to determine if they cancel out. Clean and precise implementation will demonstrate understanding of counting algorithms and string processing.","solution":"def judge_circle(moves: str) -> bool: Determines if the robot returns to the original position (0, 0) after a sequence of moves. Parameters: moves (str): The sequence of moves made by the robot. Returns: bool: True if the robot returns to the origin, otherwise False. vertical = 0 horizontal = 0 for move in moves: if move == \'U\': vertical += 1 elif move == \'D\': vertical -= 1 elif move == \'L\': horizontal -= 1 elif move == \'R\': horizontal += 1 return vertical == 0 and horizontal == 0"},{"question":"**Problem Statement:** You are given an array of integers `nums` where exactly two elements appear only once and all other elements appear exactly twice. Your task is to identify and return the two elements that appear only once. # Input - An array of integers `nums`, where the length `n` (where `n` >= 2) is such that exactly two elements appear only once and the rest appear exactly twice. # Output - A list of two integers containing the two elements that appear only once. The order of the integers does not matter. # Constraints - The algorithm must run in O(N) time complexity. - The algorithm must use O(1) extra space. # Example ```python Input: nums = [1, 2, 1, 3, 2, 5] Output: [3, 5] # [5, 3] is also an acceptable answer. ``` # Requirements 1. Implement the function `single_number3(nums)` that takes a list of integers `nums` and returns a list of two integers. 2. Ensure efficient use of bitwise operations to meet the performance constraints. 3. Handle edge cases where possible. # Function Signature ```python def single_number3(nums): :type nums: List[int] :rtype: List[int] # Implement your solution here. ``` # Additional Notes - Use XOR operation to find the crucial differences between the numbers. - Isolate significant bits to separate the unique numbers from pairs. - Keep code clean and avoid unnecessary computations or space usage.","solution":"def single_number3(nums): Given a list of integers where exactly two elements appear only once and all others appear exactly twice, this function finds and returns the two elements that appear just once. # First pass: Get XOR of the two unique numbers xor_result = 0 for num in nums: xor_result ^= num # Get the rightmost set bit (a bit that is different between the two unique numbers) rightmost_set_bit = xor_result & -xor_result # Second pass: divide the numbers into two groups based on the rightmost set bit and XOR them individually num1 = num2 = 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"# Priority Queue with Advanced Features Scenario A web server processes multiple types of requests, each with a different priority. The server uses a priority queue to manage these requests such that high-priority requests are processed before low-priority ones. Implement a priority queue in Python with the following requirements: # Requirements: 1. **Supporting Update Operation**: Update the priority of an existing item in the queue. 2. **Checking if an Item Exists**: Check if a specific item currently exists in the queue. # Function Descriptions: - **`update_priority(item, new_priority)`**: - **Input**: An item (the data) whose priority needs to be updated and the new priority value. - **Output**: Nothing; the function should update the priority of the specified item. - **Behavior**: If the item is not found, it does nothing. - **`contains(item)`**: - **Input**: An item (the data) to check for its existence in the queue. - **Output**: Return `True` if the item exists, else `False`. # Input and Output Formats: - **update_priority(item, new_priority)** - **Input**: `item`: any data type, `new_priority`: an integer. - **Output**: None. - **contains(item)** - **Input**: `item`: any data type. - **Output**: Boolean (`True` or `False`). # Constraints: - All operations should ensure that the priority queue maintains the proper order. - Assume the priority values are integers. # Example: ```python pq = PriorityQueue() pq.push(\'Task1\', 3) pq.push(\'Task2\', 5) assert pq.contains(\'Task1\') == True assert pq.contains(\'Task3\') == False pq.update_priority(\'Task1\', 6) assert pq.pop() == \'Task2\' assert pq.pop() == \'Task1\' ``` # Notes: - Assume that the initial priority queue implementation provided in the code snippets should be extended. - Make sure the `update_priority` operation maintains the time complexity of re-sorting the list efficiently.","solution":"import heapq class PriorityQueue: def __init__(self): self._queue = [] self._entry_finder = {} self._REMOVED = \'<removed-task>\' self._counter = 0 def push(self, item, priority): if item in self._entry_finder: self.update_priority(item, priority) else: count = self._counter entry = [priority, count, item] self._counter += 1 self._entry_finder[item] = entry heapq.heappush(self._queue, entry) def pop(self): while self._queue: priority, count, item = heapq.heappop(self._queue) if item is not self._REMOVED: del self._entry_finder[item] return item raise KeyError(\'pop from an empty priority queue\') def update_priority(self, item, new_priority): if item in self._entry_finder: entry = self._entry_finder.pop(item) entry[-1] = self._REMOVED self.push(item, new_priority) def contains(self, item): return item in self._entry_finder and self._entry_finder[item][-1] != self._REMOVED"},{"question":"**String Rotation** You are given a string `s` and an integer `k`. Write a function that returns the string after rotating `s` to the left by `k` positions. The rotation should work in a cyclic manner such that characters from the start of the string appear at the end after rotating. Your task is to implement this function in the most time and space-efficient way possible. # Function Signature ```python def rotate_string(s: str, k: int) -> str: ``` # Input * `s` (1 <= len(s) <= 10^5): A non-empty string consisting of any printable characters. * `k` (0 <= k <= 10^9): A non-negative integer representing the number of positions to rotate the string. # Output * Returns the rotated string. # Constraints 1. The rotation value `k` can be significantly larger than the length of the string `s`. 2. The solution should be efficient in both time and space. # Examples ```python rotate_string(\\"abcdef\\", 2) # Output: \\"cdefab\\" rotate_string(\\"abcdef\\", 6) # Output: \\"abcdef\\" rotate_string(\\"abcdef\\", 7) # Output: \\"bcdefa\\" rotate_string(\\"abcdef\\", 1000000000) # Output: \\"efabcd\\" ``` # Notes * If `k` is a multiple of the length of the string, the string should appear unchanged. * Use efficient string slicing techniques to achieve the desired result without unnecessary computations.","solution":"def rotate_string(s: str, k: int) -> str: Rotates the string s to the left by k positions. n = len(s) k = k % n # Effective rotations needed as rotations equivalent to the length are redundant return s[k:] + s[:k]"},{"question":"Develop an optimized substring search function inspired by the KMP (Knuth-Morris-Pratt) algorithm. Your implementation should improve upon the naive approach by reducing the time complexity to O(n + m). # Problem Statement You are given two strings `haystack` and `needle`. Implement a function `find_first_occurrence_kmp(haystack, needle)` that returns the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Input * `haystack`: A string of length `n` (1 <= n <= 10^5). * `needle`: A string of length `m` (1 <= m <= 10^4). # Output * An integer representing the index of the first occurrence of `needle` in `haystack`, or -1 if `needle` is not part of `haystack`. # Constraints * Both `haystack` and `needle` contain only lowercase English characters. # Example ```python # Example 1 haystack = \\"hello\\" needle = \\"ll\\" print(find_first_occurrence_kmp(haystack, needle)) # Output: 2 # Example 2 haystack = \\"aaaaa\\" needle = \\"bba\\" print(find_first_occurrence_kmp(haystack, needle)) # Output: -1 # Example 3 haystack = \\"aabaaabaaac\\" needle = \\"aabaaac\\" print(find_first_occurrence_kmp(haystack, needle)) # Output: 4 ``` # Requirements - Implement the KMP algorithm for substring search. - Ensure the function runs in O(n + m) time. - Your function should handle edge cases gracefully and efficiently.","solution":"def find_first_occurrence_kmp(haystack, needle): Returns the index of the first occurrence of needle in haystack using KMP algorithm. If needle is not part of haystack, returns -1. def compute_lps(needle): Compute the Longest Prefix Suffix (LPS) array for the needle. m = len(needle) lps = [0] * m length = 0 i = 1 while i < m: if needle[i] == needle[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps n = len(haystack) m = len(needle) if m == 0: return 0 lps = compute_lps(needle) i = j = 0 while i < n: if needle[j] == haystack[i]: i += 1 j += 1 if j == m: return i - j elif i < n and needle[j] != haystack[i]: if j != 0: j = lps[j - 1] else: i += 1 return -1"},{"question":"You are tasked with implementing a system that finds the transitive closure of a directed graph using Depth-First Search (DFS). Transitive closure of a graph determines the reachability of vertices by illustrating if a path exists from vertex `i` to vertex `j` for all pairs of vertices in the graph. # Function Implementation Implement the following functions in Python: 1. `Graph.__init__(self, vertices)`: * Initializes an empty graph with `vertices` number of vertices. * Sets up an adjacency list `graph` and a `closure` matrix initialized to zero. 2. `Graph.add_edge(self, source, target)`: * Adds a directed edge from `source` to `target`. 3. `Graph.dfs_util(self, source, target)`: * A utility function that performs a Depth-First Search from `source` trying to mark reachable targets as per the transitive closure. 4. `Graph.transitive_closure(self)`: * Computes the transitive closure matrix of the graph using the DFS utility function and returns it. # Input/Output Format * **Input**: You will only call `transitive_closure()` method on Graph objects after setting up the graphs. * **Output**: A 2D list where closure[i][j] is 1 if there is a path from vertex i to vertex j, otherwise 0. # Example ```python # Sample input: g = Graph(4) g.add_edge(0, 1) g.add_edge(1, 2) g.add_edge(2, 3) closure = g.transitive_closure() # Expected output: # [ # [1, 1, 1, 1], # [0, 1, 1, 1], # [0, 0, 1, 1], # [0, 0, 0, 1] # ] print(closure) ``` # Constraints * The value of vertices (V) will be between 1 and 100. * Input graph is directed and may contain cycles.","solution":"class Graph: def __init__(self, vertices): self.V = vertices self.graph = [[] for _ in range(vertices)] self.closure = [[0] * vertices for _ in range(vertices)] def add_edge(self, source, target): self.graph[source].append(target) def dfs_util(self, source, target): self.closure[source][target] = 1 for neighbor in self.graph[target]: if not self.closure[source][neighbor]: self.dfs_util(source, neighbor) def transitive_closure(self): for i in range(self.V): self.dfs_util(i, i) return self.closure"},{"question":"You are tasked with implementing a function to calculate the binomial coefficient, C(n, k), which gives the number of ways to choose k items from n items without regard to order. The binomial coefficient can be calculated using the following recursive relationship: [ C(n, k) = begin{cases} 1 & text{if } k=0 text{ or } k=n C(n, n-k) & text{if } k > n/2 frac{n}{k} cdot C(n-1, k-1) & text{otherwise} end{cases} ] **Input**: - An integer `n` where ( n geq 0 ). - An integer `k` where ( 0 leq k leq n ). **Output**: - An integer representing the calculated binomial coefficient. **Constraints**: - The function should handle large values of `n` and `k`. - The function should be optimized for performance and avoid stack overflow for large inputs. **Function Signature**: ```python def binomial_coefficient(n: int, k: int) -> int: ``` # Examples ```python binomial_coefficient(5, 0) # Output: 1 binomial_coefficient(8, 2) # Output: 28 binomial_coefficient(500, 300) # Output: 5054949849935535817667719165973249533761635252733275327088189563256013971725761702359997954491403585396607971745777019273390505201262259748208640 ``` # Requirements 1. If `k > n`, the function should raise a ValueError. 2. Optimize your function for handling large inputs and consider using techniques such as memoization to enhance performance. 3. Ensure your implementation is iterative to avoid potential issues with deep recursion. # Hints 1. Utilize the properties of binomial coefficients to reduce unnecessary calculations. 2. Test your function with both small and large values of `n` and `k` to confirm correctness and performance.","solution":"def binomial_coefficient(n: int, k: int) -> int: Calculate the binomial coefficient C(n, k). :param n: an integer where n >= 0 :param k: an integer where 0 <= k <= n :return: Binomial coefficient C(n, k) if k < 0 or k > n: raise ValueError(\\"k must be between 0 and n inclusive\\") # Utility to calculate n! / (k! * (n - k)!) if k > n - k: # Take advantage of symmetry properties k = n - k result = 1 for i in range(k): result = result * (n - i) // (i + 1) return result"},{"question":"# Problem Context You have been hired to improve the performance of a content delivery system using advanced data structures. The system receives numerous requests to insert, search, and delete delivery records quickly and efficiently. You decide to use a B-tree to manage these records. # Task Implement a BTree class that handles the insertion, search, and deletion of records efficiently. Your BTree should be capable of dynamically adjusting to maintain balance after records are inserted or deleted, ensuring optimal performance. # Requirements 1. **Insert Function**: Insert a new record key into the B-tree. 2. **Search Function**: Check if a record key exists within the B-tree. 3. **Delete Function**: Remove a record key from the B-tree if it exists. 4. **Traverse Function**: Print all keys in ascending order. # Specifications 1. **Node** Class: - Represents individual nodes holding keys and child pointers. - The `__init__` method initializes an empty node. 2. **BTree** Class: - `__init__(self, t_val=2)`: Initialize a B-tree with a specified minimum degree `t`. - `insert_key(self, key)`: Insert a key into the B-tree. - `find(self, key)`: Return `True` if the key exists, `False` otherwise. - `remove_key(self, key)`: Remove the key from the B-tree. - `traverse_tree(self)`: Print all keys in the B-tree in ascending order. # Constraints - Assume all keys are unique integers. - The minimum degree `t` is greater than or equal to 2. - Operations should maintain the balance of the B-tree. - Your solution must handle edge cases such as underflow and overflow of nodes during insertions and deletions. # Example ```python btree = BTree(t_val=2) btree.insert_key(10) btree.insert_key(20) btree.insert_key(5) btree.insert_key(6) btree.insert_key(12) btree.insert_key(30) btree.insert_key(7) btree.insert_key(17) print(btree.find(6)) # Output: True print(btree.find(15)) # Output: False btree.remove_key(6) print(btree.find(6)) # Output: False btree.traverse_tree() # Output: 5 7 10 12 17 20 30 ``` Your task is to complete the `BTree` class implementation to match the specifications provided.","solution":"class BTreeNode: def __init__(self, t, leaf=False): self.t = t # Minimum degree (defines the range for number of keys) self.leaf = leaf # True if leaf node, False otherwise self.keys = [] # List of keys in this node self.children = [] # List of child pointers class BTree: def __init__(self, t_val=2): self.t = t_val # Minimum degree self.root = BTreeNode(t_val, True) def traverse_tree(self): def _traverse(node): # Print all keys in this node for i in range(len(node.keys)): # If this is not leaf, traverse the child before printing the key if not node.leaf: _traverse(node.children[i]) print(node.keys[i], end=\' \') # Print the subtree rooted with the last child if not node.leaf: _traverse(node.children[-1]) _traverse(self.root) print() def find(self, key): def _find(node, key): # Find the first key greater than or equal to key i = 0 while i < len(node.keys) and key > node.keys[i]: i += 1 # If the found key is equal to key, return this node if i < len(node.keys) and node.keys[i] == key: return node # If the key is not found here and this is a leaf node if node.leaf: return None # Go to the appropriate child return _find(node.children[i], key) return _find(self.root, key) is not None def insert_key(self, key): root = self.root # When root is full, the tree grows in height if len(root.keys) == 2 * self.t - 1: s = BTreeNode(self.t, False) s.children.append(self.root) self._split_child(s, 0) self.root = s self._insert_non_full(self.root, key) def _split_child(self, parent, i): t = self.t y = parent.children[i] z = BTreeNode(t, y.leaf) parent.children.insert(i + 1, z) parent.keys.insert(i, y.keys[t - 1]) z.keys = y.keys[t:t*2 - 1] y.keys = y.keys[0:t - 1] if not y.leaf: z.children = y.children[t:t*2] y.children = y.children[0:t] def _insert_non_full(self, node, key): i = len(node.keys) - 1 if node.leaf: node.keys.append(None) while i >= 0 and node.keys[i] > key: node.keys[i + 1] = node.keys[i] i -= 1 node.keys[i + 1] = key else: while i >= 0 and node.keys[i] > key: i -= 1 i += 1 if len(node.children[i].keys) == 2 * self.t - 1: self._split_child(node, i) if key > node.keys[i]: i += 1 self._insert_non_full(node.children[i], key) def remove_key(self, key): def _remove(node, key): t = self.t idx = 0 while idx < len(node.keys) and node.keys[idx] < key: idx += 1 if len(node.keys) != 0 and idx < len(node.keys) and node.keys[idx] == key: if node.leaf: node.keys.pop(idx) else: def get_pred(node, idx): curr = node.children[idx] while not curr.leaf: curr = curr.children[len(curr.keys)] return curr.keys[-1] def get_succ(node, idx): curr = node.children[idx + 1] while not curr.leaf: curr = curr.children[0] return curr.keys[0] def fill(node, idx): if idx != 0 and len(node.children[idx - 1].keys) >= t: borrow_from_prev(node, idx) elif idx != len(node.children) - 1 and len(node.children[idx + 1].keys) >= t: borrow_from_next(node, idx) else: if idx != len(node.children) - 1: merge(node, idx) else: merge(node, idx - 1) def borrow_from_prev(node, idx): child=node.children[idx] sibling=node.children[idx-1] # Move all key in child right by 1 child.keys = [node.keys[idx-1]] + child.keys # Move last child of sibling to front child position of child if not child.leaf: child.children = [sibling.children[-1]] + child.children # Move sibling key up to parent node.keys[idx-1] = sibling.keys[-1] # Reduce sibling key list by 1 sibling.keys = sibling.keys[:-1] if not sibling.leaf: sibling.children.pop() def borrow_from_next(node, idx): child=node.children[idx] sibling=node.children[idx+1] # Move all key in sibling left by 1 child.keys.append(node.keys[idx]) if not child.leaf: child.children.append(sibling.children[0]) # Move sibling key up to parent node.keys[idx]=sibling.keys[0] # Reduce sibling key list by 1 sibling.keys=sibling.keys[1:] if not sibling.leaf: sibling.children=sibling.children[1:] def merge(node, idx): child = node.children[idx] sibling = node.children[idx+1] child.keys = child.keys + [node.keys[idx]] + sibling.keys if not child.leaf: child.children+=sibling.children # Reduce the parent node key list node.keys = node.keys[:idx] + node.keys[idx + 1:] node.children = node.children[:idx+1] + node.children[idx+2:] if len(node.keys)==0: if self.root==node: self.root=node.children[0] del node if len(node.children[idx].keys) >= t: pred=get_pred(node, idx) node.keys[idx]=pred _remove(node.children[idx], pred) elif len(node.children[idx+1].keys) >= t: succ=get_succ(node, idx) node.keys[idx]=succ _remove(node.children[idx+1], succ) else: merge(node, idx) _remove(node.children[idx], key) else: if node.leaf: return flag = idx==len(node.keys) if len(node.children[idx].keys)<t: fill(node, idx) if flag and idx>len(node.keys): _remove(node.children[idx-1], key) else: _remove(node.children[idx], key) _remove(self.root, key) if len(self.root.keys) == 0: self.root = self.root.children[0] if len(self.root.children)>0 else None"},{"question":"You are given a class `BinaryHeap` which implements a min heap. Your task is to complete the implementation for the following operation: **`HeapSort`**: Write a function `heap_sort(self)` that sorts a given list of numbers using the properties of the binary heap. # Function Signature ```python def heap_sort(self, nums: List[int]) -> List[int]: ``` # Input - The function `heap_sort` takes a list of integers `nums` as input which is unsorted. # Output - The function should return a sorted list containing the same integers in ascending order. # Constraints - You must use the `BinaryHeap` class and its methods to implement the sorting algorithm. - You must ensure the complexity remains within O(n log n). # Example ```python # Example of initializing and using the BinaryHeap to sort a list. heap = BinaryHeap() sorted_list = heap.heap_sort([3, 1, 6, 5, 2, 4]) print(sorted_list) # Output: [1, 2, 3, 4, 5, 6] ``` # Hints - Utilize the `insert` and `remove_min` methods to sort the list. - First, insert all elements into the heap, then repeatedly remove the minimum element to get the sorted order. # Additional Notes - Ensure to handle edge cases such as an empty list or list with one element. # Test Cases 1. `heap.heap_sort([])` should return `[]`. 2. `heap.heap_sort([10])` should return `[10]`. 3. `heap.heap_sort([5, 3, 8, 4, 2])` should return `[2, 3, 4, 5, 8]`. 4. `heap.heap_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0])` should return `[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`.","solution":"from typing import List class BinaryHeap: def __init__(self): self.heap = [] def insert(self, value: int): self.heap.append(value) self._bubble_up(len(self.heap) - 1) def remove_min(self) -> int: if len(self.heap) == 1: return self.heap.pop() min_value = self.heap[0] self.heap[0] = self.heap.pop() self._bubble_down(0) return min_value def _bubble_up(self, index: int): parent_index = (index - 1) // 2 if index > 0 and self.heap[index] < self.heap[parent_index]: self.heap[index], self.heap[parent_index] = self.heap[parent_index], self.heap[index] self._bubble_up(parent_index) def _bubble_down(self, index: int): smallest = index left_child_index = 2 * index + 1 right_child_index = 2 * index + 2 if left_child_index < len(self.heap) and self.heap[left_child_index] < self.heap[smallest]: smallest = left_child_index if right_child_index < len(self.heap) and self.heap[right_child_index] < self.heap[smallest]: smallest = right_child_index if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self._bubble_down(smallest) def heap_sort(self, nums: List[int]) -> List[int]: sorted_nums = [] self.heap = [] # Insert all elements into the heap for num in nums: self.insert(num) # Extract the smallest element from the heap until it is empty while self.heap: sorted_nums.append(self.remove_min()) return sorted_nums"},{"question":"# Problem Description **Nth Digit Finder** You are tasked with finding the nth digit of an infinite sequence of all natural numbers concatenated together: \\"123456789101112...\\". The sequence begins with the digit \'1\' and continues indefinitely. # Function Signature ```python def find_nth_digit(n: int) -> int: Returns the nth digit in the infinite concatenated sequence of natural numbers. Parameters: n - the position of the digit to find (1-indexed). Returns: int: The nth digit in the sequence. ``` # Input * `n` (1 ≤ n ≤ 10^9): The 1-indexed position of the digit you need to find. # Output * Returns a single integer representing the nth digit in the sequence. # Constraints * Ensure your function is efficient and can handle very large values of n (up to 10^9). # Example ```python print(find_nth_digit(11)) # Output: 0 (The 11th digit in the sequence \\"12345678910\\" is \'0\') print(find_nth_digit(15)) # Output: 2 (The 15th digit is in the \'12\' of the 2-digit numbers) ``` # Explanation To solve the problem: 1. Determine the length category of the nth digit (single, double, triple digit, etc.). 2. Calculate the actual number that contains the nth digit. 3. Extract and return the digit. Make sure to handle various edge cases like transitions between digit lengths and large indices.","solution":"def find_nth_digit(n: int) -> int: # Length of the numbers within the sequence length = 1 count = 9 # There are 9 single-digit numbers, 90 double-digit numbers, etc. start = 1 # The first number with the current length while n > length * count: n -= length * count length += 1 count *= 10 start *= 10 # Finding the actual number that contains the nth digit start += (n - 1) // length # Extracting the specific digit from that number digit = str(start)[(n - 1) % length] return int(digit)"},{"question":"# Scenario You are developing a basic file compression utility to be used for compressing repetitive data files. You need to allow users to compress and decompress data using the Run-Length Encoding (RLE) algorithm. Your task is to implement the `encode_rle` and `decode_rle` functions based on this algorithm. # Task Write two functions, `encode_rle` for encoding data and `decode_rle` for decoding data. Function 1: `encode_rle(input)` * **Input Format**: A string `input` containing the data to be encoded. * **Output Format**: A string representing the encoded data. * **Constraints**: * The input string will only contain printable ASCII characters. * The input string length will be between 0 and 1000. Function 2: `decode_rle(input)` * **Input Format**: A string `input` containing the RLE encoded data. * **Output Format**: A string representing the decoded data. * **Constraints**: * The encoded input string will always be valid and well-formed according to the RLE rules. * The input string length will be between 0 and 1000. # Examples **Example 1:** ```python # Encoding input_str = \\"aaabbcccc\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"3a2b4c\\" # Decoding encoded_str = \\"3a2b4c\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"aaabbcccc\\" ``` **Example 2:** ```python # Encoding input_str = \\"abcd\\" encoded_str = encode_rle(input_str) print(encoded_str) # Output: \\"1a1b1c1d\\" # Decoding encoded_str = \\"1a1b1c1d\\" decoded_str = decode_rle(encoded_str) print(decoded_str) # Output: \\"abcd\\" ``` # Notes * Ensure that your implementation handles edge cases, such as empty strings. * Pay attention to the efficiency of your code to handle the upper constraint limits smoothly.","solution":"def encode_rle(input): Encodes the given input string using Run-Length Encoding (RLE) algorithm. Parameters: input (str): The data to be encoded. Returns: str: The RLE encoded data. if not input: return \\"\\" encoded_str = \\"\\" current_char = input[0] count = 1 for char in input[1:]: if char == current_char: count += 1 else: encoded_str += f\\"{count}{current_char}\\" current_char = char count = 1 # Add the last group encoded_str += f\\"{count}{current_char}\\" return encoded_str def decode_rle(input): Decodes the given RLE encoded string. Parameters: input (str): The RLE encoded data. Returns: str: The decoded data. decoded_str = \\"\\" count = \\"\\" for char in input: if char.isdigit(): count += char else: decoded_str += char * int(count) count = \\"\\" return decoded_str"},{"question":"# Binary Search Enhancement Problem Statement You are given an array of integers sorted in ascending order and a target integer. Your task is to write a function that returns the index of the first occurrence of the target in the array using binary search. If the target is not found, return `-1`. You must implement both iterative and recursive versions of the binary search algorithm. Function Signatures ```python def binary_search_iterative(array: List[int], target: int) -> int: def binary_search_recursive(array: List[int], target: int) -> int: ``` Input * `array`: A list of `n` integers (1 <= n <= 10^5) sorted in ascending order. * `target`: An integer to search for in the array. Output * Return the index of the first occurrence of `target` in the array. If not found, return `-1`. Constraints * The array will be sorted in non-decreasing order. * Perform binary search. Linear search will not be accepted. Sample Input/Output **Example 1:** ```python array = [1, 2, 4, 4, 5, 6, 8] target = 4 output: 2 ``` **Example 2:** ```python array = [1, 3, 5, 7, 9] target = 2 output: -1 ``` **Example 3:** ```python array = [2, 2, 2, 2, 2] target = 2 output: 0 ``` Hints - Make sure your recursive approach does not run into maximum recursion depth exceeded errors. - Think about how you can modify the binary search to find the first occurrence, even if duplicates are present.","solution":"from typing import List def binary_search_iterative(array: List[int], target: int) -> int: Perform binary search to find the first occurrence of the target using iterative approach. left, right = 0, len(array) - 1 result = -1 while left <= right: mid = (left + right) // 2 if array[mid] == target: result = mid right = mid - 1 elif array[mid] < target: left = mid + 1 else: right = mid - 1 return result def binary_search_recursive_helper(array: List[int], target: int, left: int, right: int) -> int: Helper function for the recursive binary search to reduce function parameters. if left > right: return -1 mid = (left + right) // 2 if array[mid] == target: first_occurrence_left = binary_search_recursive_helper(array, target, left, mid - 1) return mid if first_occurrence_left == -1 else first_occurrence_left elif array[mid] < target: return binary_search_recursive_helper(array, target, mid + 1, right) else: return binary_search_recursive_helper(array, target, left, mid - 1) def binary_search_recursive(array: List[int], target: int) -> int: Perform binary search to find the first occurrence of the target using recursive approach. return binary_search_recursive_helper(array, target, 0, len(array) - 1)"},{"question":"Context You are given a sorted array of integers in increasing order. Your task is to find the index of the first occurrence of a given target value in this array using an efficient search method. This is a common problem in settings where large amounts of sorted data need to be searched quickly, such as in databases or search engines. Task Implement a function `find_first_occurrence(nums: List[int], target: int) -> int` that takes a list of integers `nums` and an integer `target`, and returns the index of the first occurrence of `target` in `nums`. If `target` is not present in the array, return -1. Input Format * `nums`: A list of integers sorted in non-decreasing order. * `target`: An integer value you need to find the first occurrence of in `nums`. Output Format * An integer representing the index of the first occurrence of `target` in `nums`, or -1 if `target` is not present. Constraints * The length of `nums` will be between 0 and 100,000. * The integer values in `nums` and `target` will be in the range `-10^9` to `10^9`. Example ```python >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) 1 >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 3) 4 >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 6) -1 ``` Requirements Ensure your solution runs in O(log n) time complexity. Notes 1. Handle edge cases such as an empty array or the target value not being present in the array. 2. Consider optimizing for both time and space and provide a clear and efficient implementation of the algorithm. 3. Explain the logic and steps of your algorithm.","solution":"from typing import List def find_first_occurrence(nums: List[int], target: int) -> int: Returns the index of the first occurrence of target in a sorted list nums. If target is not found, returns -1. left, right = 0, len(nums) - 1 result = -1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: result = mid right = mid - 1 # Look on the left side for the first occurrence elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"**Scenario**: You have been hired by a network security company to create a component of their new firewall system. One of the requirements is to identify and permit or deny requests based on a specific set of patterns. A deterministic finite automaton (DFA) is a suitable choice for this task due to its efficiency in matching patterns. **Task**: Write a function `is_accepted_string(transitions, start, final, string)` in Python that will determine if the given `string` is accepted (matches specific patterns) by the DFA defined by the transition table `transitions`. **Function Signature**: ```python def is_accepted_string(transitions: dict, start: str, final: list, string: str) -> bool: # function implementation ``` **Input**: - `transitions`: A dictionary where keys are state names, and values are dictionaries that map input symbols to subsequent states. E.g., `{\'q0\': {\'a\': \'q1\', \'b\': \'q2\'}, \'q1\': {\'a\': \'q0\'}}` - `start`: A string representing the initial state. - `final`: A list of strings representing the final (accepting) states. - `string`: The input string which you need to validate through the DFA. **Output**: - Return `True` if the string is accepted by the DFA (i.e., it ends in one of the final states after processing all input symbols). Otherwise, return `False`. **Constraints**: - The input string will only contain characters defined in the transition dictionary. - The transition dictionary will include all necessary state transitions. - The input string can be empty. **Example**: ```python transitions = { \'q0\': {\'a\': \'q1\', \'b\': \'q0\'}, \'q1\': {\'a\': \'q0\', \'b\': \'q2\'}, \'q2\': {\'a\': \'q2\', \'b\': \'q2\'} } start = \'q0\' final = [\'q2\'] print(is_accepted_string(transitions, start, final, \\"ab\\")) # Output: True print(is_accepted_string(transitions, start, final, \\"aa\\")) # Output: False ``` In this example, the DFA will transition as follows: 1. Start at state `q0`, read \'a\' -> move to `q1` 2. Read \'b\' -> move to `q2` The final state is `q2`, which is an accepting state, so the output should be `True`.","solution":"def is_accepted_string(transitions, start, final, string): current_state = start for char in string: if char in transitions[current_state]: current_state = transitions[current_state][char] else: return False # If there\'s no transition defined for this character, reject the string return current_state in final"},{"question":"# Scenario You are tasked with organizing a set of books on a library shelf by their catalog numbers represented in a list. You decide to use a simple, straightforward Gnome sort to reorder them. To achieve this, you need to implement a function that sorts the list of catalog numbers. # Task Implement the function `gnome_sort_books(catalog_numbers: List[int]) -> List[int]` which sorts a list of catalog numbers using the Gnome sort algorithm. # Specifications - **Input**: A list of integers `catalog_numbers` where each integer represents a catalog number. - **Output**: A list of integers representing the sorted catalog numbers. - **Constraints**: - The list can be empty or have up to 10,000 catalog numbers. - Each catalog number is a unique integer within the range `1` to `100,000`. # Function Signature ```python from typing import List def gnome_sort_books(catalog_numbers: List[int]) -> List[int]: pass ```","solution":"from typing import List def gnome_sort_books(catalog_numbers: List[int]) -> List[int]: Sorts the list of catalog numbers using the Gnome sort algorithm. Parameters: catalog_numbers (List[int]): List of integers representing catalog numbers. Returns: List[int]: Sorted list of catalog numbers. index = 0 while index < len(catalog_numbers): if index == 0 or catalog_numbers[index] >= catalog_numbers[index - 1]: index += 1 else: catalog_numbers[index], catalog_numbers[index - 1] = catalog_numbers[index - 1], catalog_numbers[index] index -= 1 return catalog_numbers"},{"question":"Validate Nested Structures Objective: Write a function to determine if a given string of various types of brackets is valid. The brackets include \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. The string is said to be valid if all the brackets are correctly closed and nested. Input: * A single string `s` containing just the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\'. * Constraints: * The length of the string, `n`, will be such that 0 <= n <= 10^4. Output: * Return `True` if the string is valid, otherwise `Return False`. Function Signature: ```python def validate_nested_structures(s: str) -> bool: pass ``` Performance Requirements: * The solution should have a time complexity of O(n). * Space complexity should be O(n) in the worst case scenario. Example: ```python assert validate_nested_structures(\\"()\\") == True assert validate_nested_structures(\\"()[]{}\\") == True assert validate_nested_structures(\\"(]\\") == False assert validate_nested_structures(\\"([])\\") == True assert validate_nested_structures(\\"([)]\\") == False assert validate_nested_structures(\\"{[()]}\\") == True assert validate_nested_structures(\\"\\") == True ``` Explanation: * For the string `\\"()\\"`, the function returns `True` because each opening bracket is closed properly. * The string `\\"()[]{}\\"` is also valid with correctly nested and matched brackets. * The string `\\"(]\\"` is invalid because there\'s a mismatch between brackets. * The string `\\"(())\\"` and `\\"[()]\\"` are valid as they are properly nested.","solution":"def validate_nested_structures(s: str) -> bool: Determines if a given string of brackets is valid. stack = [] bracket_map = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in s: if char in bracket_map: top_element = stack.pop() if stack else \'#\' if bracket_map[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"Given a positive integer `decompose`, write a function `int_divide(decompose: int) -> int` to find the number of ways to partition this number into sums of non-negative integers (including the number itself). The function should utilize dynamic programming to ensure efficient computation. # Function Signature ```python def int_divide(decompose: int) -> int: pass ``` # Input * `decompose` - A single integer (1 <= decompose <= 100). # Output Return an integer representing the number of ways to partition the input integer into sums of non-negative integers. # Example ```python assert int_divide(4) == 5 # Partitions: {4}, {3+1}, {2+2}, {2+1+1}, {1+1+1+1} assert int_divide(7) == 15 # Partitions: {7}, {6+1}, {5+2}, {5+1+1}, etc. ``` # Constraints * The function should run efficiently for all inputs within the given range. * You must ensure the function handles edge cases such as `decompose` being a very small or very large number within the allowed range. * Optimize for both time and space complexity, staying within O(n^2) complexity.","solution":"def int_divide(decompose: int) -> int: Returns the number of ways to partition a number into sums of non-negative integers. Uses dynamic programming for efficient computation. if decompose < 1: return 0 # Create a list to store the number of ways to partition each number from 0 to decompose dp = [0] * (decompose + 1) dp[0] = 1 # There\'s one way to partition 0 - using the empty sum for num in range(1, decompose + 1): for sums in range(num, decompose + 1): dp[sums] += dp[sums - num] return dp[decompose]"},{"question":"**Context**: You are given the task of consolidating multiple busy schedules into free time intervals. This involves finding the free slots between the busy periods of multiple employees. **Task**: Write a function `find_free_time(intervals)` that takes a list of busy intervals and returns the free intervals. **Function Signature**: ```python def find_free_time(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pass ``` **Input**: - `intervals`: A list of tuples, where each tuple `(start, end)` represents a busy period, `start` and `end` are integers with `start < end`. **Output**: - A list of tuples representing the free intervals between the busy periods. # Examples ```python assert find_free_time([(1, 3), (5, 6), (4, 5)]) == [(0, 1), (3, 4), (6, float(\'inf\'))] assert find_free_time([(1, 2), (3, 4), (5, 6)]) == [(0, 1), (2, 3), (4, 5), (6, float(\'inf\'))] ``` # Constraints: 1. Intervals within the input list are non-overlapping after pre-processing. 2. The solution should be optimal with respect to both time and space complexity. # Notes: * Assume the day starts from time 0 and extends to infinity for the purposes of this problem. * Handle edge cases like overlapping intervals, single intervals, and empty input list. * Strive for a solution with O(N log N) time complexity due to the sorting operation.","solution":"from typing import List, Tuple def find_free_time(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]: if not intervals: return [(0, float(\'inf\'))] # Sort intervals by start time intervals.sort() free_times = [] # The end of the last interval we have considered end_time = intervals[0][1] # Handle the start of the day if intervals[0][0] > 0: free_times.append((0, intervals[0][0])) for start, end in intervals[1:]: if start > end_time: free_times.append((end_time, start)) end_time = max(end_time, end) # Handle the end of the day free_times.append((end_time, float(\'inf\'))) return free_times"},{"question":"# ZigZag Iterator Challenge You are given an iterator class `ZigZagIterator` which interleaves elements from multiple input lists. The goal of this challenge is to extend its functionality to support any number of lists, not just two. # Function Implementation Define a class `ZigZagIterator` with the following specifications: Methods 1. **`__init__(self, *args: List[int])`** * Initializes the iterator with multiple lists. * **Input**: Variable number of lists (each is a list of integers). 2. **`next(self) -> int`** * Returns the next element from the interleaved sequence. * **Output**: The next integer in the zigzag sequence. 3. **`has_next(self) -> bool`** * Returns whether there are more elements to iterate over. * **Output**: Boolean indicating if there are more elements. Constraints 1. All input lists contain non-negative integers. 2. The method `next()` should not be called when `has_next()` returns `False`. Example ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigZagIterator(l1, l2, l3) while it.has_next(): print(it.next()) ``` **Expected Output**: ``` 1 3 7 2 4 8 5 9 6 ``` # Additional Notes * Ensure proper handling of edge cases, such as empty lists. * Your solution should be efficient in terms of both time and space complexity. **Implement `ZigZagIterator` class below:** ```python class ZigZagIterator: def __init__(self, *args): self.queue = [lst for lst in args if lst] def next(self): v = self.queue.pop(0) ret = v.pop(0) if v: self.queue.append(v) return ret def has_next(self): return bool(self.queue) ```","solution":"class ZigZagIterator: def __init__(self, *args): self.queue = [lst for lst in args if lst] def next(self): v = self.queue.pop(0) ret = v.pop(0) if v: self.queue.append(v) return ret def has_next(self): return bool(self.queue)"},{"question":"Jump Search Implementation You are given a sorted array of integers `arr` and a target integer value `target`. Your task is to implement the Jump Search algorithm to find the index of the target value in the array. If the target value is not found, return -1. # Function Signature ```python def jump_search(arr: List[int], target: int) -> int: ``` # Input - `arr`: A sorted list of integers (1 <= len(arr) <= 10^5, -10^6 <= arr[i] <= 10^6) - `target`: An integer value to search for in the array (-10^6 <= target <= 10^6) # Output - Return the index of the target value if found, otherwise, return -1. # Constraints - The array is sorted in non-decreasing order. - The search must be performed using the Jump Search algorithm. # Example ```python assert jump_search([1, 3, 5, 7, 9], 3) == 1 assert jump_search([1, 3, 5, 7, 9], 8) == -1 assert jump_search([2, 3, 4, 10, 40], 10) == 3 assert jump_search([2, 3, 4, 10, 40], 41) == -1 ``` # Scenario Consider the following scenario to understand the practical utility of the question: \\"Sophie is developing a specialized search feature for a library database where the books are stored based on their unique IDs, all sorted in ascending order. She needs an efficient method to locate books quickly given their unique ID. She decides to use Jump Search for its optimization over linear searches, especially for bigger datasets.\\" # Performance Ensure the implementation handles up to the maximum constraint efficiently.","solution":"from typing import List import math def jump_search(arr: List[int], target: int) -> int: length = len(arr) if length == 0: return -1 # Finding block size to be jumped step = int(math.sqrt(length)) # Finding the block where element is present prev = 0 while arr[min(step, length) - 1] < target: prev = step step += int(math.sqrt(length)) if prev >= length: return -1 # Linear search for target in block beginning with prev while arr[prev] < target: prev += 1 if prev == min(step, length): return -1 # If element is found if arr[prev] == target: return prev return -1"},{"question":"You are working on a problem where you need to find all unique combinations of numbers from a given set that sum up to a target value. The same number can be chosen from the set multiple times, but the combinations must be unique and sorted in non-decreasing order. # Function Signature ```python def combination_sum(candidates: List[int], target: int) -> List[List[int]]: ``` # Input - `candidates`: A list of positive integers representing the set of candidate numbers (e.g., [2, 3, 6, 7]). - `target`: A positive integer representing the target sum (e.g., 7). # Output - A list of lists, where each list is a unique combination of numbers that sum up to the target (e.g., [[7], [2, 2, 3]]). # Constraints - All numbers in both the candidate list and the target will be positive integers. - The candidate list will not contain duplicate numbers. - The solution set must not contain duplicate combinations (i.e., no permutation of the same combination). # Performance Requirements - The solution must efficiently handle inputs where the size of the candidate list is up to 30 and the target value is up to 500. # Example ```python candidates = [2, 3, 6, 7] target = 7 combination_sum(candidates, target) # Expected output: # [ # [7], # [2, 2, 3] # ] ``` # Additional Notes - Think about handling edge cases such as when the candidate list has only one number or when the target is very small or very large relative to the candidate numbers. - optimize to avoid redundant calculations and ensure the uniqueness of the combinations in the result.","solution":"from typing import List def combination_sum(candidates: List[int], target: int) -> List[List[int]]: def backtrack(start, target, path, res): if target == 0: res.append(path) return for i in range(start, len(candidates)): if candidates[i] > target: break # Early termination since candidates is sorted backtrack(i, target - candidates[i], path + [candidates[i]], res) candidates.sort() result = [] backtrack(0, target, [], result) return result"},{"question":"Objective Implement the Pigeonhole Sort algorithm as described, ensuring proper handling of various edge cases and efficient performance within given constraints. Task You are required to write a function `pigeonhole_sort(arr)` to sort the input list `arr` using the Pigeonhole Sort algorithm. Function Signature ```python def pigeonhole_sort(arr: List[int]) -> List[int]: pass ``` Input - `arr`: A list of integers with length `n` (0 ≤ n ≤ 1000). Output - Return a new list with the elements of `arr` sorted in non-decreasing order. Constraints - Each element of `arr` is an integer between -1000 and 1000, inclusive. Example ```python # Example 1: input = [8, 3, 2, 7, 4] output = [2, 3, 4, 7, 8] # Example 2: input = [1000, -1000, 0, 1000, -1000] output = [-1000, -1000, 0, 1000, 1000] # Example 3: input = [] output = [] ``` Performance Requirements - The time complexity of your solution should be O(n + Range), where `Range` is the difference between the maximum and minimum values in the array. Notes - Ensure that your function handles edge cases like an empty list and lists with all identical elements.","solution":"def pigeonhole_sort(arr): Sorts an array using the Pigeonhole Sort algorithm. if len(arr) == 0: return [] min_value = min(arr) max_value = max(arr) range_size = max_value - min_value + 1 holes = [0] * range_size for num in arr: holes[num - min_value] += 1 sorted_arr = [] for index, count in enumerate(holes): while count > 0: sorted_arr.append(index + min_value) count -= 1 return sorted_arr"},{"question":"You are tasked with improving the efficiency of the provided cosine similarity function. While the current implementation is sufficient for average-sized vectors, it can be optimized further for very large vectors by leveraging NumPy\'s efficient array operations. # Task Rewrite the `cosine_similarity` function using the NumPy library to handle vector operations. Ensure your implementation maintains the functionality and correctness of the original function. # Input Format - Two 1D lists, `vec1` and `vec2`, where both lists contain numerical values and are of the same length. # Output Format - A single float value representing the cosine similarity between the two input vectors. # Constraints 1. The length of `vec1` and `vec2` will always be greater than 0. 2. The vectors will be numeric lists containing integers or floats. # Performance Requirements - Your solution should handle vectors with up to 1 million elements efficiently. # Example ```python # Input vec1 = [1, 1, 1] vec2 = [1, 2, -1] # Output 0.47140452079103173 # Expected Implementation def cosine_similarity(vec1, vec2): # Your optimized implementation using NumPy pass ```","solution":"import numpy as np def cosine_similarity(vec1, vec2): Returns the cosine similarity between two vectors. vec1 = np.array(vec1) vec2 = np.array(vec2) dot_product = np.dot(vec1, vec2) magnitude_vec1 = np.linalg.norm(vec1) magnitude_vec2 = np.linalg.norm(vec2) if magnitude_vec1 == 0 or magnitude_vec2 == 0: return 0.0 return dot_product / (magnitude_vec1 * magnitude_vec2)"},{"question":"Find the Added Character Problem Statement Given two strings `s` and `t` which consist of only lowercase letters, string `t` is generated by random shuffling string `s` and then adding one more letter at a random position. Your task is to find the letter that was added to `t`. Write a function `find_added_character(s: str, t: str) -> str` that takes two strings `s` and `t` as input and returns the character that was added to `t`. Input: * A string `s` of lowercase letters (1 ≤ len(s) ≤ 1000). * A string `t` of lowercase letters (len(t) = len(s) + 1). Output: * A single character which is the letter added to `t`. Constraints: * `s` and `t` consist only of lowercase letters. * `t` is generated by shuffling `s` and then adding one additional letter. Example: ``` Input: s = \\"abcd\\" t = \\"abecd\\" Output: \'e\' Explanation: \'e\' is the letter that was added. ``` Notes: * Avoid using extra space for storage, except variables required for processing. * Aim to achieve a time complexity of O(n).","solution":"def find_added_character(s: str, t: str) -> str: Find the additional character added to string t. char_count = [0] * 26 for char in s: char_count[ord(char) - ord(\'a\')] -= 1 for char in t: char_count[ord(char) - ord(\'a\')] += 1 for idx, count in enumerate(char_count): if count == 1: return chr(ord(\'a\') + idx)"},{"question":"# Secure Communication Simulation with RSA You are tasked to implement a secure communication channel simulation using the RSA encryption algorithm. Task 1. **Key Generation**: Write a function to generate RSA public and private keys. 2. **Encryption/Decryption**: Write functions to encrypt and decrypt messages using the RSA keys. 3. **Verification**: Write a test suite to verify that encryption and subsequent decryption retrieves the original message. Function Signature ```python def generate_rsa_keypair(k: int, seed: int = None) -> Tuple[int, int, int]: Generates and returns RSA keypair: :param k: Bit length of the RSA key. :param seed: Optional seed for reproducibility. :return: Tuple containing (n, e, d) - modulus, public exponent and private exponent. # Implement the key generation by modifying the provided snippets pass def rsa_encrypt(message: int, e: int, n: int) -> int: Encrypts a message using RSA encryption. :param message: The numerical representation of the message to encrypt. :param e: Public exponent. :param n: Modulus. :return: Encrypted message as an integer. # Implement the encryption pass def rsa_decrypt(enc_message: int, d: int, n: int) -> int: Decrypts a message using RSA. :param enc_message: The encrypted message to decrypt. :param d: Private exponent. :param n: Modulus. :return: Decrypted message as an integer. # Implement the decryption pass ``` Input: - `k`: An integer for the bit length of the RSA key. - `seed` (optional): An integer seed for the random number generator (useful for testing). - `message`: An integer representing the message to be encrypted (should be less than n). - `e`, `n`, `d`: Integers representing the components of RSA keys. Output: - For `generate_rsa_keypair`: A tuple (n, e, d) representing the RSA key pair. - For `rsa_encrypt`: An integer representing the encrypted message. - For `rsa_decrypt`: An integer representing the decrypted message. Constraints: - Ensure that the message is an integer and smaller than `n`. - Ensure efficient prime number checks and modular arithmetic. - Optimize the prime generators and inverse modulo calculations for performance. Example: ```python k = 16 seed = 42 message = 42 n, e, d = generate_rsa_keypair(k, seed) encrypted_msg = rsa_encrypt(message, e, n) decrypted_msg = rsa_decrypt(encrypted_msg, d, n) assert decrypted_msg == message print(\\"RSA encryption and decryption successful.\\") ``` Requirements: Ensure the provided key generation, encryption, and decryption methods are tested to validate RSA algorithm correctness. Remember to handle any potential edge cases and optimize where necessary.","solution":"import random from sympy import isprime, mod_inverse def generate_rsa_keypair(k: int, seed: int = None): if seed is not None: random.seed(seed) def generate_large_prime(bits): while True: p = random.getrandbits(bits) if isprime(p): return p half_k = k // 2 p = generate_large_prime(half_k) q = generate_large_prime(half_k) n = p * q phi = (p - 1) * (q - 1) e = 65537 # Commonly used prime exponent d = mod_inverse(e, phi) return (n, e, d) def rsa_encrypt(message: int, e: int, n: int) -> int: return pow(message, e, n) def rsa_decrypt(enc_message: int, d: int, n: int) -> int: return pow(enc_message, d, n)"},{"question":"# File Path Normalization and Validation You are implementing a file management tool that requires all user-provided file paths to be converted to absolute paths before performing operations on them. This is important to ensure consistency and avoid errors related to relative paths or user shortcuts. **Task**: Write a function named `get_normalized_path` that takes a single string argument representing a file path. The function should return the absolute version of this path, appropriately handling user directory shortcuts (e.g., `~` for the home directory). Additionally, implement validation to ensure the provided path is not empty and lies within the user\'s home directory. If the path fails these validations, the function should raise an appropriate exception. **Function Signature**: ```python def get_normalized_path(file_path: str) -> str: ``` **Input**: * `file_path` (str): A file path which may be relative, absolute, or include user directory shortcuts. **Output**: * A string representing the absolute file path after normalization. **Constraints**: * Your implementation should handle paths valid on a typical Unix-based or Windows-based system. * Return absolute paths only if they lie within the user\'s home directory. **Exception Handling**: * Raise a `ValueError` exception if the provided path is an empty string. * Raise an `OSError` exception if the normalized path lies outside the user\'s home directory. **Example**: ```python import os def get_normalized_path(file_path): if not file_path: raise ValueError(\\"File path cannot be empty\\") home_dir = os.path.expanduser(\\"~\\") abs_path = os.path.abspath(os.path.expanduser(file_path)) if not abs_path.startswith(home_dir): raise OSError(\\"File path lies outside the user\'s home directory\\") return abs_path # Usage examples: try: print(get_normalized_path(\\"~/documents/file.txt\\")) # e.g., \\"/home/user/documents/file.txt\\" print(get_normalized_path(\\"file.txt\\")) # e.g., \\"/current/working/directory/file.txt\\" print(get_normalized_path(\\"\\")) # Expect ValueError print(get_normalized_path(\\"/etc/hosts\\")) # Raise OSError if outside user\'s home directory except (ValueError, OSError) as e: print(e) ``` **Explanation**: * The function first expands the user directory shortcut using `os.path.expanduser()`. * It then converts the provided or expanded path to an absolute path using `os.path.abspath()`. * The function checks if the absolute path is within the user\'s home directory. * Appropriate exceptions are raised for invalid paths to guide the user or prevent potential issues.","solution":"import os def get_normalized_path(file_path: str) -> str: Converts a given file path to an absolute path and ensures it lies within the user\'s home directory. Args: file_path (str): A file path which may be relative, absolute, or include user directory shortcuts. Returns: str: The absolute version of the file path. Raises: ValueError: If the provided path is an empty string. OSError: If the normalized path lies outside the user\'s home directory. if not file_path: raise ValueError(\\"File path cannot be empty\\") home_dir = os.path.expanduser(\\"~\\") abs_path = os.path.abspath(os.path.expanduser(file_path)) if not abs_path.startswith(home_dir): raise OSError(\\"File path lies outside the user\'s home directory\\") return abs_path"},{"question":"# Topological Sorting of a Directed Acyclic Graph Problem Statement You are given a directed graph represented as an adjacency list with nodes labeled from `0` to `N-1`. This graph represents dependencies between tasks where each edge `(u, v)` indicates that task `u` must be completed before task `v`. Your objective is to implement a function that returns a topological sort of the graph if it is acyclic. If the graph contains a cycle, your function should raise an error to indicate that topological sort is not possible. Function Signature ```python def topological_sort(n: int, edges: List[Tuple[int, int]]) -> List[int]: pass ``` Input * `n` (int): The number of nodes in the graph, where `0 <= n <= 1000`. * `edges` (List[Tuple[int, int]]): A list of directed edges where each edge is represented as a tuple `(u, v)` indicating a directed edge from node `u` to node `v`. Output * `List[int]`: A list of nodes representing the topological ordering. * Raise a `ValueError` if the graph contains a cycle. Constraints * Time Complexity: Your solution should have a time complexity of O(V + E). * Space Complexity: Your solution should have a space complexity of O(V). Example ```python n = 6 edges = [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)] print(topological_sort(n, edges)) # Output: [5, 4, 2, 3, 1, 0] ``` Explanation In the example, the topological sort provides an ordering of tasks based on their dependencies. Task `5` and task `4` can be processed first as there are no tasks they depend on. Note Make sure to handle the case where the given graph has cycles appropriately by raising a `ValueError`.","solution":"from typing import List, Tuple from collections import deque, defaultdict def topological_sort(n: int, edges: List[Tuple[int, int]]) -> List[int]: Returns a list of nodes in topological order or raises ValueError if a cycle exists. # Create an adjacency list adj = defaultdict(list) in_degree = {i: 0 for i in range(n)} for u, v in edges: adj[u].append(v) in_degree[v] += 1 # Queue for vertices with no incoming edges queue = deque([node for node in in_degree if in_degree[node] == 0]) result = [] while queue: current = queue.popleft() result.append(current) # Decrease the in-degree of each neighbor for neighbor in adj[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If topological sorting is not possible due to a cycle if len(result) != n: raise ValueError(\\"Graph contains a cycle, topological sorting not possible\\") return result"},{"question":"# Assessment Question Given a list of integers `lst` and an integer `N`, write a function `limit_occurrences(lst, N)` that returns a new list containing each integer of `lst` at most `N` times without changing the order of elements. Input - `lst` (List[int]): A list of integers. - `N` (int): The maximum number of times an integer can appear in the output list. Output - (List[int]): A new list with elements from `lst` with each element appearing no more than `N` times. Constraints - The list can be any length from 0 to 10^6. - Elements of the list are integers and can range from -10^9 to 10^9. - N is a non-negative integer and can range from 0 to 10^6. Example ```python assert limit_occurrences([1, 2, 3, 1, 2, 1, 2, 3], 2) == [1, 2, 3, 1, 2, 3] assert limit_occurrences([1, 1, 1, 1], 2) == [1, 1] assert limit_occurrences([], 2) == [] assert limit_occurrences([1, 2, 3], 0) == [] ``` # Explanation - In the first example, the number `1` appears 3 times in the original list but is restricted to 2 appearances in the output list. - In the second example, the repeated `1` values are limited to 2 occurrences. - The third example handles an empty input list which naturally results in an empty output list. - The fourth example shows that with `N` being 0, no elements are included in the output list. Implement the function considering time and space efficiency. # Implementation Write your solution by implementing the function `limit_occurrences(lst, N)` below: ```python def limit_occurrences(lst, N): import collections result = [] counts = collections.defaultdict(int) # keep track of occurrences for i in lst: if counts[i] < N: result.append(i) counts[i] += 1 return result ```","solution":"def limit_occurrences(lst, N): import collections result = [] counts = collections.defaultdict(int) # Dictionary to keep track of occurrences for i in lst: if counts[i] < N: result.append(i) counts[i] += 1 return result"},{"question":"# Context You have been provided with code snippets demonstrating the inorder traversal of a binary tree both iteratively and recursively. Your task is to implement a function that generates the same inorder traversal sequence but for a specific subclass of binary trees, the Binary Search Tree (BST). # Problem You need to write a function `bst_inorder_values` that takes the root of a BST and returns a list of values in ascending order using inorder traversal. Additionally, you must handle edge cases efficiently and ensure your solution is robust. # Function Signature ```python def bst_inorder_values(root: Node) -> list: Function to perform inorder traversal on a BST and return list of values in ascending order. Parameters: - root (Node): The root node of the BST. Returns: - list: A list containing the inorder traversal of the BST. pass ``` # Constraints * The input variable, `root`, will be an instance of the `Node` class or `None`. * Each node\'s value in the BST will be an integer. * The BST does not contain duplicate values. # Example ```python # Example Binary Search Tree # 5 # / # 3 7 # / # 2 4 8 root = Node(5) root.left = Node(3, Node(2), Node(4)) root.right = Node(7, None, Node(8)) assert bst_inorder_values(root) == [2, 3, 4, 5, 7, 8] ``` # Additional Notes - Ensure your implementation can handle an empty tree (root is `None`) by returning an empty list. - Consider both the iterative and recursive approach and mention in comments which approach you have used.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def bst_inorder_values(root): Function to perform inorder traversal on a BST and return list of values in ascending order. Parameters: - root (Node): The root node of the BST. Returns: - list: A list containing the inorder traversal of the BST. if not root: return [] stack, inorder = [], [] # Start from the root node (current node) current = root while current or stack: # Reach the left most Node of the current Node while current: stack.append(current) current = current.left # Current must be None at this point current = stack.pop() inorder.append(current.value) # We have visited the node and its left subtree. Now, it\'s right subtree\'s turn current = current.right return inorder"},{"question":"# Question: Move Zeros to the End You are given an array which contains various types of elements including integers, strings, booleans, etc. You need to write a function that moves all of the zeros to the end of the array while preserving the order of the non-zero elements. **Function Signature**: ```python def move_zeros(array: list) -> list: pass ``` **Input**: - `array`: A list which can contain elements of any data type, including integers, strings, booleans, etc. **Output**: - A list with all zero values moved to the end of the array while preserving the order of non-zero elements. **Constraints**: - The array can be of any length from 0 to 10^5. - Elements in the array can be of any type. - Do not consider `False`, empty lists, or any falsey values as zero. **Example**: ```python # Example 1: assert move_zeros([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"]) == [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] # Example 2: assert move_zeros([0, \\"0\\", 0.0, 0, 42]) == [\\"0\\", 0.0, 42, 0, 0] ``` **Scenario**: Imagine you are working with a 2D graphics application that maintains a list of graphic objects in rendering order. The rendering engine uses \'0\' to mark blank spaces that need to be moved to the end of the list for efficient rendering. Unfortunately, it still needs to keep track of elements like False or empty strings which have special meanings and should not be moved. Your task is to implement a function that handles this requirement efficiently. **Performance Requirements**: Your solution should run in O(n) time complexity and should ideally be optimized for minimum additional space usage.","solution":"def move_zeros(array: list) -> list: Moves all zeros in the list to the end while preserving the order of non-zero elements. result = [] zeros_count = 0 for element in array: if element == 0 and type(element) is int: zeros_count += 1 else: result.append(element) result.extend([0] * zeros_count) return result"},{"question":"# Context You are working with a grid-based map where land and water are represented by 0s and 1s respectively. You need to implement an algorithm that dynamically tracks and counts the number of isolated islands as land is added incrementally. # Task Implement a function called `count_islands` which takes a list of positions where land is added one by one. The function should return the number of islands after each land addition. ```python def count_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: Given a grid of size n x m initially filled with water (0s), this function should count the number of islands after each position in the positions list is turned into land (1). Args: n (int): The number of rows in the grid. m (int): The number of columns in the grid. positions (List[Tuple[int, int]]): A list of positions (tuples) where each position is turned into land. Returns: List[int]: A list containing the number of islands after each addLand operation. # Example Given a 3x3 grid, positions = [(0,0), (0,1), (1,2), (2,1)]: - Initially, 0 0 0, 0 0 0, 0 0 0 (all water). - After (0,0), the grid becomes: 1 0 0, 0 0 0, 0 0 0 (1 island). - After (0,1), the grid becomes: 1 1 0, 0 0 0, 0 0 0 (1 island). - After (1,2), the grid becomes: 1 1 0, 0 0 1, 0 0 0 (2 islands). - After (2,1), the grid becomes: 1 1 0, 0 0 1, 0 1 0 (3 islands). Expected Output: [1, 1, 2, 3] ``` # Constraints - 1 ≤ n, m ≤ 1000 - Positions list will not exceed n * m elements. - Positions will be valid and within the grid boundaries. # Performance Requirements - Ensure the solution handles up to the maximum input size efficiently. - Optimize union-find operations using path compression and union by rank. Implement the `count_islands` function considering the aforementioned constraints and performance requirements.","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size: int): self.parent = list(range(size)) self.rank = [0] * size self.count = 0 def find(self, p: int) -> int: if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p: int, q: int): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 self.count -= 1 def add(self): self.count += 1 def count_islands(n: int, m: int, positions: List[Tuple[int, int]]) -> List[int]: directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] uf = UnionFind(n * m) grid = [[0] * m for _ in range(n)] result = [] for (x, y) in positions: if grid[x][y] == 1: result.append(uf.count) continue grid[x][y] = 1 index = x * m + y uf.add() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 1: neighbor_index = nx * m + ny if uf.find(index) != uf.find(neighbor_index): uf.union(index, neighbor_index) result.append(uf.count) return result"},{"question":"You are given a binary tree represented by its root node, and your task is to implement an optimized solution to find the minimum depth of the binary tree using an iterative approach. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. Many applications require understanding the tree\'s structure and its depth to optimize operations and manage resources. For instance, databases and file systems use tree structures extensively, making it essential to quickly determine their depth efficiently. Requirements: - Implement a function `minDepthIterative(root: TreeNode) -> int` that returns the minimum depth of the binary tree. - You are provided with the TreeNode class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Constraints: - The provided tree may be empty (i.e., root can be None). - The tree nodes have non-negative values. - Your solution must have a time complexity of (O(n)) and a space complexity of (O(n)) where (n) is the number of nodes in the tree. Function Signature: ```python def minDepthIterative(root: TreeNode) -> int: pass ``` Example: ```python # Example tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) print(minDepthIterative(root)) # Output: 2 ``` Note: Ensure to test your solution with various edge cases such as an empty tree, a skewed tree, and trees with different structures.","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def minDepthIterative(root: TreeNode) -> int: Returns the minimum depth of the binary tree using an iterative approach. if not root: return 0 queue = deque([(root, 1)]) # Queue holds pairs of (node, current_depth) while queue: node, depth = queue.popleft() # Check if we\'ve reached a leaf node if not node.left and not node.right: return depth # Add children to queue with updated depth if node.left: queue.append((node.left, depth + 1)) if node.right: queue.append((node.right, depth + 1))"},{"question":"# Problem: Compute Euler\'s Totient Function for an Array of Integers Your task is to write a function that computes the totient function (ϕ(n)) for each integer in a list. You will be given an array of integers and must return an array of totient function results corresponding to each integer. # Function Signature: ```python def compute_totients(arr: List[int]) -> List[int]: ``` # Input: - `arr`: A list of integers `arr` where (1 leq |arr| leq 1000) and (1 leq arr[i] leq 10^6). # Output: - A list of integers with the totient results for each integer in `arr`. # Constraints: - Each element in the input list `arr` will be a positive integer. # Example: ```python compute_totients([1, 2, 3, 4, 5]) # Returns: [1, 1, 2, 2, 4] compute_totients([6, 25, 100]) # Returns: [2, 20, 40] ``` # Performance Requirements: - Your function should be efficient and run in an overall complexity not exceeding (O(n sqrt{max(arr)})). # Description: Use Euler\'s Totient Function to compute the number of integers from 1 to `n` that are coprime with `n` for each number in the input array. Implement and optimize the code to handle the given constraints and performance requirements efficiently. Test your function for edge cases and large inputs to ensure its correctness and performance.","solution":"from typing import List def compute_totient(n: int) -> int: result = n p = 2 while p * p <= n: if n % p == 0: while n % p == 0: n //= p result -= result // p p += 1 if n > 1: result -= result // n return result def compute_totients(arr: List[int]) -> List[int]: return [compute_totient(n) for n in arr]"},{"question":"Decode Ways **Objective**: Write a function to determine the total number of ways to decode a given encoded message. **Function Signature**: ```python def decode_ways(encoded_message: str) -> int: pass ``` # Input * A single string `encoded_message` containing only digits (0-9). # Output * An integer representing the total number of ways to decode the string. # Constraints * The input string length will be between 1 and 100. * The input string will not be empty but can include the digit \'0\' which must be considered for decoding. # Requirements * Handle invalid messages starting with \'0\'. * Consider valid characters ranges from \'1\' to \'26\' for multi-character decoding. * Ensure your solution is optimized for both time and space complexity. # Example ```python assert decode_ways(\\"12\\") == 2 # \\"AB\\" (1 2) and \\"L\\" (12) assert decode_ways(\\"226\\") == 3 # \\"BZ\\" (2 26), \\"VF\\" (22 6), \\"BBF\\" (2 2 6) assert decode_ways(\\"06\\") == 0 # No valid decoding ``` # Scenarios 1. **Basic Case:** Small strings without \'0\' providing multiple ways to decode. 2. **Edge Case:** Strings starting with \'0\'. 3. **Large Input:** Ensure the program handles inputs up to 100 characters efficiently. Implementation Notes - Use dynamic programming to store intermediate results. - Optimize for O(n) time complexity. - Aim to keep space complexity to O(1) or the minimum necessary to handle dynamic programming constraints. Provide the function implementation below.","solution":"def decode_ways(encoded_message: str) -> int: # Edge case: If the message is empty or starts with \'0\', it cannot be decoded if not encoded_message or encoded_message[0] == \'0\': return 0 # Length of the encoded message n = len(encoded_message) # dp[i] represents the number of ways to decode the message up to the i-th character dp = [0] * (n + 1) # There\'s one way to decode an empty message dp[0] = 1 # There\'s one way to decode a non-\'0\' starting character dp[1] = 1 if encoded_message[0] != \'0\' else 0 for i in range(2, n + 1): # Check if the current character can be interpreted on its own if encoded_message[i - 1] != \'0\': dp[i] += dp[i - 1] # Check if the last two characters can be interpreted as a valid character two_digit = int(encoded_message[i - 2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n]"},{"question":"# Cycle Sort Implementation and Enhancement Context You are working on a memory-constrained embedded system, and you need to implement an efficient sorting algorithm that minimizes write operations. Cycle Sort is ideal for this scenario due to its in-place sorting and minimized writes. However, the system\'s performance cannot afford an O(N^2) time complexity for sorting large datasets. Your task is to implement the Cycle Sort algorithm and enhance it, if possible, to reduce its time complexity for specific types of input arrays. Task 1. Implement the Cycle Sort algorithm as described. 2. Analyze the performance of your implementation. 3. Propose and implement any enhancements to improve the algorithm\'s efficiency, especially for nearly sorted arrays. Function Signature ```python def cycle_sort(arr: List[int]) -> None: Sort the input list arr using Cycle Sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: None: The function should sort the list in place. ``` Input * List of integers, example: `[4, 2, 3, 1]` Output * The function sorts the list in place. The input list will be modified. # Requirements * The sorting should be in ascending order. * Aim to implement enhancements that reduce average time complexity for nearly sorted input arrays. * Document any specific optimizations and edge cases handled. Constraints * Size of the array (N) can be up to 10^4. * Array elements (arr[i]) can be negative, zero, or positive integers. Example ```python arr = [4, 3, 2, 1] cycle_sort(arr) print(arr) # Output: [1, 2, 3, 4] ``` Performance * Ensure that your implementation is efficient enough to handle the constraints. * Discuss the worst-case scenarios and how your implementation handles them. * If possible, demonstrate with a variety of test cases, including edge cases like empty arrays, single-element arrays, and arrays with duplicate values.","solution":"from typing import List def cycle_sort(arr: List[int]) -> None: Sort the input list arr using Cycle Sort algorithm. Args: arr (List[int]): The list of integers to be sorted. Returns: None: The function should sort the list in place. n = len(arr) for start in range(0, n-1): item = arr[start] pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 if pos == start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != start: pos = start for i in range(start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos]"},{"question":"# Binary Tree Paths Extraction **Objective**: Write a function that extracts all root-to-leaf paths in a given binary tree and returns them as a list of strings. Each path should be formatted as node values connected by \'->\'. Function Signature ```python def binary_tree_paths(root: TreeNode) -> List[str]: pass ``` # Input and Output Input * `root: TreeNode` - The root of the binary tree. A node is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * `List[str]` - A list of strings, with each string representing a root-to-leaf path, formatted as described. # Constraints * The number of nodes in the tree will be in the range `[0, 1000]`. * The values of the nodes will be in the range `[-1000, 1000]`. # Example ```python # Example 1 # Input: # 1 # / # 2 3 # # 5 # Output: [\\"1->2->5\\", \\"1->3\\"] # Example 2 # Input: # 4 # Output: [\\"4\\"] ``` # Instructions 1. Implement the provided function signature to traverse the binary tree using DFS. 2. Ensure correct concatenation of node values to form paths. 3. Handle edge cases such as empty trees or trees with only left or only right sub-trees. 4. Aim for a time complexity of O(N) and space complexity of O(H). *Hint*: Consider creating a helper function within your solution to manage the DFS traversal and string concatenation logic.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def binary_tree_paths(root: TreeNode) -> List[str]: if not root: return [] def dfs(node, path, paths): if not node.left and not node.right: paths.append(path) return if node.left: dfs(node.left, path + \'->\' + str(node.left.val), paths) if node.right: dfs(node.right, path + \'->\' + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Repeat Substring Pattern Detection Scenario: The marketing department of a company has an automated text analysis tool that recognizes repeated patterns in strings for generating concise summaries. To improve the tool, the company needs to verify if a certain string can be entirely constructed by repeated substrings. They need an efficient function to confirm this theory. Problem: You have been provided with a string, `s`, and you need to determine whether this string can be represented as multiple copies of a substring. Write a function that accomplishes this. Function Signature: ```python def is_repeated_substring(s: str) -> bool: :param s: Input string. :return: True if it can be constructed by repeated substrings, False otherwise. ``` Input: * A non-empty string `s` consisting of lowercase English letters. Output: * Return `True` if the string can be constructed by repeating a substring; otherwise, return `False`. Examples: ```python assert is_repeated_substring(\\"abab\\") == True assert is_repeated_substring(\\"aba\\") == False assert is_repeated_substring(\\"abcabcabcabc\\") == True ``` Constraints: * The length of the input string will not exceed 10^5. Performance Requirements: * The implementation should be expected to run in O(n) time, where n is the length of the string.","solution":"def is_repeated_substring(s: str) -> bool: Determines if the input string can be constructed by repeating a substring. # The idea is to use the properties of string concatenation and slicing. # If we concatenate the string with itself and remove the first and last character, # the original string should be a substring of this new string if it can be # represented as multiple repeats of a substring. doubled_s = s + s modified_doubled_s = doubled_s[1:-1] return s in modified_doubled_s"},{"question":"# Simplify File Path Context You are developing a file system navigation feature for a Unix-based operating system shell. One of the functionalities you need to implement is simplifying file paths. Unix-style file paths may contain redundant components such as the current directory (.) or parent directory (..), and multiple slashes (\'///\') can occur. Your task is to write a function to simplify these paths. Task Implement a function `simplify_path` that takes as input a string representing an absolute path for a file and returns the simplified canonical path. Input Format - A single string `path` which is an absolute path starting with a slash \'/\'. Output Format - Return a single string representing the simplified canonical path. Constraints - The input string consists of ASCII characters and is guaranteed to be a valid Unix file path. Examples 1. Input: `\\"/home/\\"` Output: `\\"/home\\"` 2. Input: `\\"/a/./b/../../c/\\"` Output: `\\"/c\\"` 3. Input: `\\"/../\\"` Output: `\\"/\\"` 4. Input: `\\"/home//foo/\\"` Output: `\\"/home/foo\\"` Performance Requirements - Your solution should have a time complexity of O(n) and a space complexity of O(n), where n is the length of the input string. # Note Pay special attention to edge cases such as: - Paths containing multiple consecutive slashes. - Paths involving parent directory movements. Write a well-thought-out solution function named `simplify_path` and ensure it passes all the provided examples and constraints. ```python def simplify_path(path): :type path: str :rtype: str # Your code goes here ```","solution":"def simplify_path(path): Simplifies the given Unix-style file path. :type path: str :rtype: str stack = [] components = path.split(\'/\') for component in components: if component == \'..\': if stack: stack.pop() # Go back to the parent directory elif component == \'.\' or component == \'\': continue # Stay in the current directory or skip redundant slashes else: stack.append(component) return \'/\' + \'/\'.join(stack)"},{"question":"# Rabin-Karp Algorithm Implementation Scenario You are a software developer tasked with implementing the Rabin-Karp algorithm for efficient string matching. This algorithm allows you to quickly identify the starting index of a given pattern (substring) within a larger text. Your implementation should be capable of handling diverse inputs while maintaining optimal performance. Task Implement the Rabin-Karp string matching algorithm. Given two strings, `text` and `pattern`, return the starting index of the first occurrence of `pattern` in `text`. If the pattern is not found, return `-1`. Function Signature ```python def rabin_karp_search(pattern: str, text: str) -> int: # Your implementation here ``` Example ```python # Example 1 text = \\"abracadabra\\" pattern = \\"cad\\" output = rabin_karp_search(pattern, text) # Output: 4 # Example 2 text = \\"abcdefgh\\" pattern = \\"ghi\\" output = rabin_karp_search(pattern, text) # Output: -1 ``` Input * `pattern`: The substring to search for (1 <= len(pattern) <= 10^4) * `text`: The string to search within (1 <= len(text) <= 10^4) Output * Returns the starting index of the first occurrence of `pattern` in `text`, or `-1` if not found. Constraints * Assure pattern and text contain only lowercase English letters. * Reduce hash collisions to improve avergae performance. * Ensure that your function handles edge cases effectively, such as empty strings and pattern longer than text.","solution":"def rabin_karp_search(pattern: str, text: str) -> int: Rabin-Karp algorithm for searching a pattern in a text. Returns the starting index of the first occurrence of pattern in text. Returns -1 if the pattern is not found. if not pattern or not text or len(pattern) > len(text): return -1 base = 256 prime = 101 pattern_len = len(pattern) text_len = len(text) def hash_func(s: str, end: int) -> int: h = 0 for i in range(end): h = (h * base + ord(s[i])) % prime return h pattern_hash = hash_func(pattern, pattern_len) text_hash = hash_func(text, pattern_len) for i in range(text_len - pattern_len + 1): if pattern_hash == text_hash: if text[i:i+pattern_len] == pattern: return i if i < text_len - pattern_len: text_hash = (text_hash - ord(text[i]) * (base ** (pattern_len - 1))) % prime text_hash = (text_hash * base + ord(text[i + pattern_len])) % prime text_hash = (text_hash + prime) % prime # Make sure the hash is not negative return -1"},{"question":"You are tasked with implementing a doubly linked list with additional functionalities. The list should support adding elements at any position, deleting elements from any position, and reversing the list. Requirements: 1. Implement the `DoublyLinkedList` class with the following methods: - `add_at_position(position, value)`: Adds a node with the given value at the specified position. - `delete_at_position(position)`: Deletes the node at the specified position. - `reverse_list()`: Reverses the order of the list. Constraints: - The position is a 0-indexed integer. - If the position is invalid (e.g., negative or exceeding the list size), raise an `IndexError`. - Assume the functions will be called multiple times and should be efficient. Input and Output: - The add and delete methods will not return any value. - The reverse method will not return any value. - For ease of testing, implement an additional method `to_list()` which converts the linked list into a Python list of values for verification. Performance Requirements: - The operations should aim for the best possible efficiency given the constraints. Example Usage: ```python dll = DoublyLinkedList() dll.add_at_position(0, 10) dll.add_at_position(1, 20) dll.add_at_position(1, 15) print(dll.to_list()) # Output: [10, 15, 20] dll.delete_at_position(1) print(dll.to_list()) # Output: [10, 20] dll.reverse_list() print(dll.to_list()) # Output: [20, 10] ``` Implement your solution with the class definition and methods as specified above.","solution":"class Node: def __init__(self, value): self.value = value self.prev = None self.next = None class DoublyLinkedList: def __init__(self): self.head = None self.tail = None def add_at_position(self, position, value): new_node = Node(value) if position < 0: raise IndexError(\\"Position is out of bounds.\\") if position == 0: if not self.head: self.head = new_node self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node else: current = self.head count = 0 while current and count < position - 1: count += 1 current = current.next if current is None: raise IndexError(\\"Position is out of bounds.\\") new_node.next = current.next new_node.prev = current if current.next: current.next.prev = new_node current.next = new_node if new_node.next is None: self.tail = new_node def delete_at_position(self, position): if position < 0 or not self.head: raise IndexError(\\"Position is out of bounds.\\") if position == 0: if self.head == self.tail: self.head = None self.tail = None else: self.head = self.head.next self.head.prev = None else: current = self.head count = 0 while current and count < position: count += 1 current = current.next if current is None: raise IndexError(\\"Position is out of bounds.\\") if current == self.tail: self.tail = current.prev self.tail.next = None else: current.prev.next = current.next if current.next: current.next.prev = current.prev def reverse_list(self): current = self.head prev = None self.tail = current while current is not None: next_node = current.next current.next = prev current.prev = next_node prev = current current = next_node self.head = prev def to_list(self): values = [] current = self.head while current is not None: values.append(current.value) current = current.next return values"},{"question":"# Topological Sorting Challenge Given a directed, acyclic graph represented as an adjacency list, implement a function `topological_sort(graph)` to return a list of vertices in topological order. If the graph contains a cycle, the function should raise a `ValueError`. Function Signature ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: pass ``` Input - `graph`: A dictionary where the keys are vertices and the values are lists of adjacent vertices (e.g., `{0: [1, 2], 1: [2], 2: []}`). Output - A list of vertices ordered such that for every directed edge u -> v, vertex u appears before v in the list. Constraints - The graph is guaranteed to be acyclic. - The graph may have unconnected vertices. - Vertex indices are unique and non-negative. Example ```python graph = { 0: [1, 2], 1: [2], 2: [3], 3: [] } assert topological_sort(graph) == [0, 1, 2, 3] or [0, 2, 1, 3] or [1, 0, 2, 3] ``` Notes - Ensure your implementation handles cases where the graph has vertices that are not connected. - Consider the use of stack or queue to manage the vertices during the depth-first traversal for efficiency.","solution":"def topological_sort(graph): from collections import deque def dfs(v): if visited[v] == -1: raise ValueError(\\"Graph is not acyclic; cycle detected\\") if visited[v] == 1: return visited[v] = -1 for neighbor in graph.get(v, []): dfs(neighbor) visited[v] = 1 stack.appendleft(v) visited = {key: 0 for key in graph} stack = deque() for vertex in graph: if visited[vertex] == 0: dfs(vertex) return list(stack)"},{"question":"# Context: You have been given the task to design a data structure that manages a collection of words. This structure should allow you to add new words and search for existing ones using patterns that may include the dot (\'.\') character as a wildcard, representing any letter. # Task: Implement a class `OptimizedWordDictionary` that effectively combines the strengths of both trie-based and dictionary-based implementations to handle a large number of words and ensure efficient search performance. # Requirements: 1. The class should support adding words with the method `add_word(word: str) -> None`. 2. The class should support searching for words with the method `search(word: str) -> bool`. 3. Your implementation must optimize for both time and space complexity. # Constraints: * The words to be added consist only of lowercase English letters. * The length of any given word will not exceed 50. * The number of words to be added will not exceed 10000. # Example: ```python dictionary = OptimizedWordDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") assert dictionary.search(\\"pad\\") == False assert dictionary.search(\\"bad\\") == True assert dictionary.search(\\".ad\\") == True assert dictionary.search(\\"b..\\") == True ``` # Performance Considerations: The solution must efficiently handle: * The space complexity due to potentially large numbers of words with common prefixes. * The time complexity for wildcard searches, ensuring it remains manageable even with the maximum number of words. # Implementation: Implement your `OptimizedWordDictionary` class below.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class OptimizedWordDictionary: def __init__(self): self.root = TrieNode() def add_word(self, word: str) -> None: current_node = self.root for char in word: if char not in current_node.children: current_node.children[char] = TrieNode() current_node = current_node.children[char] current_node.is_end_of_word = True def search(self, word: str) -> bool: return self._search_in_node(word, 0, self.root) def _search_in_node(self, word: str, index: int, node: TrieNode) -> bool: if index == len(word): return node.is_end_of_word char = word[index] if char == \'.\': for child in node.children.values(): if self._search_in_node(word, index + 1, child): return True elif char in node.children: return self._search_in_node(word, index + 1, node.children[char]) return False"},{"question":"Implement a Hash Table with Improved Collision Handling and Adaptive Resizing Context You have been provided with a basic implementation of a resizable hash table using linear probing for collision handling and doubling the size of the table when it is two-thirds full. To assess your understanding of hash table concepts and advanced collision resolution techniques, your task is to enhance this hash table by implementing: 1. Double hashing for collision resolution. 2. Adaptive resizing mechanism based on load factor thresholds. Objective Modify the provided hash table class to use double hashing for collision resolution. Additionally, implement the logic to dynamically resize the hash table based on the following conditions: - Shrink the table to half its size if the load factor drops below 1/3. - Double the table size if the load factor exceeds 2/3. Function Requirements 1. `hash2(self, key)`: Compute the secondary hash value for a given key. This function will be applied in the second probe formula. 2. `_rehash(self, old_hash, key, iteration)`: Modify this method to implement double hashing. 3. `put(self, key, value)`: Adjust to call the new rehash function for collision handling. 4. `__resize(self, shrink=False)`: Implement the logic to shrink or expand the table based on the load factor. Input and Output Formats - `put(key: int, value: int)`: Inserting or updating a key-value pair. No direct output, but internal resizing can occur. - `get(key: int) -> int`: Returns the value associated with the key or `None` if the key does not exist. - `del_(key: int)`: Delete the key-value pair if it exists. The table size may shrink if load factor criteria are met. Constraints - Key and value are non-negative integers. - The initial table size is a prime number to mitigate clustering during hashing. Performance Requirements - Hashing and rehashing processes should be efficient to ensure average-case time complexity remains constant. - Resizing should ensure minimal disruption to ongoing operations. Sample Usage ```python hash_table = ResizableHashTable() hash_table.put(10, \'value1\') hash_table.put(20, \'value2\') print(hash_table.get(10)) # Outputs \'value1\' hash_table.del_(20) print(hash_table.get(20)) # Outputs None ```","solution":"class ResizableHashTable: def __init__(self, initial_capacity=11): self.capacity = initial_capacity self.size = 0 self.keys = [None] * self.capacity self.values = [None] * self.capacity def hash1(self, key): return key % self.capacity def hash2(self, key): return 1 + (key % (self.capacity - 1)) def _rehash(self, old_hash, key, iteration): return (old_hash + iteration * self.hash2(key)) % self.capacity def _resize(self, shrink=False): old_keys = self.keys old_values = self.values old_capacity = self.capacity if shrink: self.capacity = max(11, self.capacity // 2) else: self.capacity *= 2 self.keys = [None] * self.capacity self.values = [None] * self.capacity self.size = 0 for i in range(old_capacity): if old_keys[i] is not None: self.put(old_keys[i], old_values[i]) def put(self, key, value): if self.size / self.capacity >= 2 / 3: self._resize() idx = self.hash1(key) iteration = 0 while self.keys[idx] is not None and self.keys[idx] != key: iteration += 1 idx = self._rehash(idx, key, iteration) if self.keys[idx] != key: self.size += 1 self.keys[idx] = key self.values[idx] = value def get(self, key): idx = self.hash1(key) iteration = 0 while self.keys[idx] is not None: if self.keys[idx] == key: return self.values[idx] iteration += 1 idx = self._rehash(idx, key, iteration) return None def del_(self, key): idx = self.hash1(key) iteration = 0 while self.keys[idx] is not None: if self.keys[idx] == key: self.keys[idx] = None self.values[idx] = None self.size -= 1 if self.size / self.capacity < 1 / 3: self._resize(shrink=True) return iteration += 1 idx = self._rehash(idx, key, iteration)"},{"question":"# Question: Implement Two Product Algorithm You are required to implement a function, `two_product(array, target)`, that is quite similar to the \\"Two Sum\\" problem, but instead, it involves finding two distinct indices in an array such that their corresponding numbers\' product equals a given target. Input - `array`: A list of integers. - `target`: An integer representing the product to be found. Output - A tuple containing two integer indices `(i, j)` such that `array[i] * array[j] = target` and `i != j`. - If no such pair exists, return `None`. Constraints - Each input will have at most one solution. - The indices returned should be in ascending order (i.e., `(i, j)` should satisfy `i < j`). - Negative numbers and zero can be part of the array. Example Given the array `[2, 4, 1, 6]` and target `8`, - Because `array[0] * array[1] = 2 * 4 = 8`, - The function should return `(0, 1)`. Given the array `[2, 4, 0, 6, 0]` and target `0`, - Because `array[2] * array[4] = 0 * 0 = 0`, - The function should return `(2, 4)`. Additional Requirements - Your solution should have a linear time complexity. Write the function `two_product(array, target)` to solve the problem. ```python def two_product(array, target): # Your code here ```","solution":"def two_product(array, target): seen = {} for i, num in enumerate(array): if num == 0 and target == 0: for j in range(i + 1, len(array)): if array[j] == 0: return (i, j) elif num != 0 and target % num == 0: complement = target // num if complement in seen: return (seen[complement], i) seen[num] = i return None"},{"question":"# Longest Increasing Subsequence Optimization Challenge Given an unsorted array of integers, your task is to implement an optimized solution to find the length of the longest increasing subsequence (LIS). The provided algorithms utilize dynamic programming and segment trees to improve efficiency. **Input** - A list of non-negative integers, `sequence`, with length `n` (1 ≤ n ≤ 10^5). **Output** - An integer representing the length of the longest increasing subsequence. **Expectations** - Your implementation should efficiently handle input sizes up to 100,000 with values up to 10^18. **Constraints** - Avoid brute force O(n^2) solutions due to performance considerations. **Performance Requirements** - Aim for a solution with time complexity around O(n log n) or O(n log x) where x is the maximum element in the sequence. **Examples** 1. **Input**: `[10, 9, 2, 5, 3, 7, 101, 18]` **Output**: `4` 2. **Input**: `[0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]` **Output**: `6` 3. **Input**: `[3, 10, 2, 1, 20]` **Output**: `3` **Scenario** Imagine analyzing a series of stock prices to identify the longest period where the prices consistently increased. You are tasked with designing a function to efficiently compute this period for given price sequences. **Function Signature** ```python def longest_increasing_subsequence_optimized(sequence: List[int]) -> int: # Your implementation here ``` Your function should take a list of integers `sequence` and return an integer representing the length of the longest increasing subsequence.","solution":"def longest_increasing_subsequence_optimized(sequence): from bisect import bisect_left if not sequence: return 0 lis = [] for num in sequence: pos = bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"Scenario You are working as a data analyst and need to determine patterns in a given set of marathons. Each marathon record is an integer representing a participant’s finish time. A Longest Increasing Subsequence (LIS) would represent a sequence of improving performance times. # Task Write a function `longest_increasing_subsequence` that takes a list of integers (representing marathon finish times) and returns the length of the longest increasing subsequence in these times. # Function Signature ```python def longest_increasing_subsequence(times: List[int]) -> int: ``` # Inputs - `times` (List[int]): A list of integers representing marathon finish times. # Outputs - `int`: The length of the longest increasing subsequence. # Constraints 1. ( 1 leq text{len(times)} leq 10^5 ) 2. ( 1 leq text{times[i]} leq 10^9 ) # Requirements 1. Optimize for time complexity within the given input size constraints. 2. Consider large ranges and large inputs. # Example ```python # Example times = [10, 9, 2, 5, 3, 7, 101, 18] print(longest_increasing_subsequence(times)) # Output: 4 # Explanation: The longest increasing subsequence is [2, 3, 7, 101]. ``` # Notes - Consider possible edge cases (e.g., an empty list). - Provide comments in your code for clarity.","solution":"from typing import List import bisect def longest_increasing_subsequence(times: List[int]) -> int: Returns the length of the longest increasing subsequence in the list of marathon finish times. if not times: return 0 # \'lis\' will store the smallest ending element of all increasing subsequences with different lengths. lis = [] for time in times: # Find the insertion point for current time in the lis list. pos = bisect.bisect_left(lis, time) # If time is larger than any element in lis, append it. if pos == len(lis): lis.append(time) else: # Otherwise replace the element at index \'pos\' lis[pos] = time return len(lis)"},{"question":"# Task You are required to implement a function that uses the Atbash cipher to encrypt a given string. Your function should work for both uppercase and lowercase letters, preserving the case. Non-alphabetical characters in the input string should remain unchanged. # Function Signature ```python def atbash_cipher(text: str) -> str: ``` # Input - `text` (str): A string containing the text to be encrypted, where `1 ≤ len(text) ≤ 10^6`. It can contain uppercase, lowercase, spaces, and special characters. # Output - Returns a `str`: The encrypted string using the Atbash cipher. # Example ```python print(atbash_cipher(\\"Attack at dawn\\")) # Expected output: \\"Zggzxp zg wzdm\\" print(atbash_cipher(\\"Hello, World!\\")) # Expected output: \\"Svool, Dliow!\\" ``` # Constraints - The function should have a time complexity of O(n). - The function should handle all edge cases such as: - Handling empty strings. - Properly mapping both uppercase and lowercase letters. - Leaving non-alphabetical characters unchanged. # Notes - Pay attention to character cases and make sure the encryption respects the case of each letter. - Focus on performance, ensuring that the function can handle up to the maximum input size efficiently.","solution":"def atbash_cipher(text: str) -> str: def atbash_char(c): if \'A\' <= c <= \'Z\': return chr(ord(\'Z\') - (ord(c) - ord(\'A\'))) elif \'a\' <= c <= \'z\': return chr(ord(\'z\') - (ord(c) - ord(\'a\'))) else: return c return \'\'.join(atbash_char(c) for c in text)"},{"question":"# Wiggle Sort (Advanced Scenario) Given an unsorted integer array `nums`, reorder it in such a way that `nums[0] < nums[1] > nums[2] < nums[3]...`. This pattern should hold for all adjacent elements in the array. If the given array has duplicate elements, they must fit into the wiggle pattern as defined. Write a function `advanced_wiggle_sort(nums)` that accepts a list of integers and modifies it according to the defined wiggle sort rules. Your implementation should be efficient, running in O(n) time complexity and O(1) space complexity. Input * A list `nums` of length `n` where `0 <= n <= 100,000`. Output * The function modifies the list `nums` in place to satisfy the wiggle condition. Constraints * The input array may contain negative numbers, duplicates, and will fit into memory. Example 1. `advanced_wiggle_sort([3, 5, 2, 1, 6, 4])` * Before: [3, 5, 2, 1, 6, 4] * After: [3, 5, 1, 6, 2, 4] (or any valid wiggle sort pattern) 2. `advanced_wiggle_sort([1, 3, 2, 2, 3, 1])` * Before: [1, 3, 2, 2, 3, 1] * After: [1, 3, 1, 3, 2, 2] (or any valid wiggle sort pattern) Remember, your function should aim to: * Handle edge cases such as empty arrays or arrays with a single element. * Ensure the function runs in linear time and uses constant extra space. ```python def advanced_wiggle_sort(nums): for i in range(len(nums)): if (i % 2 == 1) == (nums[i-1] > nums[i]): nums[i-1], nums[i] = nums[i], nums[i] # Example usage: if __name__ == \\"__main__\\": array = [3, 5, 2, 1, 6, 4] advanced_wiggle_sort(array) print(array) # Expected output: [3, 5, 1, 6, 2, 4] or any valid wiggle sorted sequence ```","solution":"def advanced_wiggle_sort(nums): for i in range(1, len(nums)): if (i % 2 == 1) == (nums[i - 1] > nums[i]): nums[i - 1], nums[i] = nums[i], nums[i - 1] # Example usage: if __name__ == \\"__main__\\": array = [3, 5, 2, 1, 6, 4] advanced_wiggle_sort(array) print(array) # Expected output: [3, 5, 1, 6, 2, 4] or any valid wiggle sorted sequence"},{"question":"You are given `k` sequences, each sequence containing `n_i` integers. Implement a generalized `ZigZagIterator` class that can traverse elements from these `k` sequences in a zigzag manner. The iterator should produce elements by switching sequences after every element, attempting to pull from each sequence in a cyclic order until all sequences are exhausted. # Implement the following methods: 1. **`__init__(self, lists: List[List[int]])`**: Initialize the zigzag iterator with a list of integer sequences. 2. **`next(self) -> int`**: Return the next integer in the zigzag order. 3. **`has_next(self) -> bool`**: Return `True` if there are more integers to return; otherwise, `False`. # Example: ```python k = 3 lists = [ [1, 2, 3], [4, 5, 6, 7], [8, 9] ] it = ZigZagIterator(lists) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 4, 8, 2, 5, 9, 3, 6, 7] ``` # Constraints: * All integers in the sequences are non-negative. * At least one sequence is non-empty. * Performance should be optimized for large input sizes. # Notes: * Carefully manage the internal state to ensure minimal latency between calls to `next()` and `has_next()`. * You may use standard libraries like `collections.deque` for managing sequences internally. # Your Implementation: ```python from collections import deque class ZigZagIterator: def __init__(self, lists): :type lists: List[List[int]] self.queue = deque([deque(lst) for lst in lists if lst]) def next(self): :rtype: int if not self.has_next(): return None current_list = self.queue.popleft() next_value = current_list.popleft() if current_list: self.queue.append(current_list) return next_value def has_next(self): :rtype: bool return bool(self.queue) ```","solution":"from collections import deque class ZigZagIterator: def __init__(self, lists): :type lists: List[List[int]] self.queue = deque([deque(lst) for lst in lists if lst]) def next(self): :rtype: int if not self.has_next(): return None current_list = self.queue.popleft() next_value = current_list.popleft() if current_list: self.queue.append(current_list) return next_value def has_next(self): :rtype: bool return bool(self.queue)"},{"question":"# Scenario You are tasked with developing an algorithm to sort an array of integers efficiently. The array may contain negative integers, and you need to implement a version of the Counting Sort algorithm that gracefully handles negative numbers. # Task Write a function called `counting_sort_with_negatives(arr)` that sorts an input array of integers using the Counting Sort algorithm. Your function should correctly handle arrays containing negative numbers and return the sorted array. # Input * `arr` (list of integers): The list of integers to sort. The array can include negative numbers, and its length `n` can range from 0 to 10^6. # Output * Returns a sorted list of integers. # Constraints * The elements of `arr` are integers and can range between -10^6 and 10^6. * The length of `arr` (n) ranges from 0 to 10^6. # Example ```python assert counting_sort_with_negatives([4, -2, -1, 0, 3]) == [-2, -1, 0, 3, 4] assert counting_sort_with_negatives([-5, 3, -2, 1, -1]) == [-5, -2, -1, 1, 3] assert counting_sort_with_negatives([0, 0, 0, 0]) == [0, 0, 0, 0] assert counting_sort_with_negatives([]) == [] ``` # Requirements * Your function should be efficient and complete within reasonable time limits for large input sizes. * Handle edge cases, like the presence of negative numbers, duplicate values, and empty arrays.","solution":"def counting_sort_with_negatives(arr): Sorts an array of integers using the Counting Sort algorithm, handling negative numbers. Args: - arr (list of int): The array of integers to sort. Returns: - list of int: The sorted array. if not arr: return arr # Find the minimum and maximum values in the array min_val = min(arr) max_val = max(arr) # Create the count array to store the count of each unique number count_range = max_val - min_val + 1 count_arr = [0] * count_range # Fill the count array with the frequencies of each number for num in arr: count_arr[num - min_val] += 1 # Construct the sorted array sorted_arr = [] for i, count in enumerate(count_arr): sorted_arr.extend([i + min_val] * count) return sorted_arr"},{"question":"# Coding Challenge: Enhanced Comb Sort Implementation **Objective:** Write an enhanced version of the Comb Sort algorithm that optimizes the gap sequence and handles common edge cases. **Function Signature:** ```python def enhanced_comb_sort(arr: List[int]) -> List[int]: pass ``` # Instructions: 1. **Input:** - A list of integers, e.g., `arr = [5, 3, 8, 4, 2]`. - It may contain duplicate values and includes zero or negative numbers. 2. **Output:** - Return a new list with the integers sorted in ascending order. # Constraints: - The length of the list will be at most (10^6). - Each integer will fit within the range of a 32-bit signed integer [-2147483648, 2147483647]. # Requirements: 1. **Use a better gap sequence:** Utilize the Hibbard gap sequence (1, 3, 7, ...) instead of the traditional gap sequence (n/shrink factor). 2. **Handle edge cases:** Ensure your function correctly processes empty lists and lists with a single element. 3. **Performance:** Aim for an average case time complexity improvement over the traditional comb sort\'s O(N^2). # Examples: ```python assert enhanced_comb_sort([]) == [] assert enhanced_comb_sort([1]) == [1] assert enhanced_comb_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert enhanced_comb_sort([5, 5, 5, 5, 5]) == [5, 5, 5, 5, 5] assert enhanced_comb_sort([-1, -3, 0, 2]) == [-3, -1, 0, 2] ``` Use this extra challenge to demonstrate your deep understanding of sorting algorithms, particularly the nuanced improvements over the basic comb sort approach.","solution":"def enhanced_comb_sort(arr): An enhanced version of the Comb Sort algorithm using the Hibbard gap sequence. def hibbard_gap_sequence(length): # Generate Hibbard gap sequence: 1, 3, 7, 15, ... gaps = [] k = 1 while (2 ** k) - 1 < length: gaps.append((2 ** k) - 1) k += 1 return gaps[::-1] # reverse for descending order n = len(arr) if n < 2: return arr gaps = hibbard_gap_sequence(n) for gap in gaps: for i in range(gap, n): temp = arr[i] j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap arr[j] = temp return arr"},{"question":"# Scenario Sorting algorithms are fundamental in computer science, used in various applications like organizing records, searching algorithms, and more. As an aspiring developer, it\'s critical to understand different sorting strategies and where they shine or fall short. # Task You are given an array of integers that needs to be sorted. Your job is to implement the `cocktail_shaker_sort` function to sort the array in ascending order. # Requirements * Implement the function `cocktail_shaker_sort(arr)`: * **Input**: An unsorted list of integers `arr`. * **Output**: A list of integers sorted in ascending order. # Constraints * The input list will contain at most `10^4` elements. * Each element in the array will be between `-10^6` and `10^6`. # Example ```python # Exmaple 1 arr = [5, 1, 4, 2, 8] print(cocktail_shaker_sort(arr)) # Output should be [1, 2, 4, 5, 8] # Example 2 arr = [3, -1, 0, -1, 2, 1] print(cocktail_shaker_sort(arr)) # Output should be [-1, -1, 0, 1, 2, 3] # Example 3 arr = [] print(cocktail_shaker_sort(arr)) # Output should be [] # Example 4 arr = [1] print(cocktail_shaker_sort(arr)) # Output should be [1] ```","solution":"def cocktail_shaker_sort(arr): Sorts a list of integers in ascending order using the cocktail shaker sort algorithm. Parameters: arr (list): Unsorted list of integers Returns: list: Sorted list of integers in ascending order n = len(arr) if n == 0: return arr swapped = True start = 0 end = n - 1 while swapped: swapped = False # Traverse the list from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True if not swapped: break swapped = False end -= 1 # Traverse the list from right to left for i in range(end, start, -1): if arr[i] < arr[i - 1]: arr[i], arr[i - 1] = arr[i - 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Segment Tree Coding Assessment **Scenario**: You have been hired to build an efficient system that can quickly perform range sum queries and updates on a large dataset. Your task is to implement a `SegmentTree` class that supports these operations. Instructions: Implement a `SegmentTree` class with the following methods: 1. **Constructor**: Initialize the segment tree with a given array and commutative function. 2. **build_tree**: Construct the tree based on the given array. 3. **update**: Update an element in the array and reflect this change in the segment tree. 4. **query**: Perform a range query on the array using the tree. ```python class SegmentTree: def __init__(self, arr, function): # Implement this method def build_tree(self): # Implement this method def update(self, p, v): # Implement this method def query(self, l, r): # Implement this method ``` **Method Descriptions**: - **`__init__(self, arr, function)`**: - **Input**: `arr` (a list of elements), `function` (a commutative function). - Initialize the segment tree using the given array and function. - Call the `build_tree` method to construct the tree. - **`build_tree`**: - Construct the segment tree in a bottom-up manner. - **`update(self, p, v)`**: - **Input**: `p` (index to be updated), `v` (new value). - Update the value at index `p` to `v` and adjust the segment tree accordingly. - **`query(self, l, r)`**: - **Input**: `l` (left boundary, inclusive), `r` (right boundary, inclusive). - **Output**: Result of applying the commutative function to the elements within range `[l, r]`. **Constraints**: - `1 <= len(arr) <= 10^5` - `0 <= p < len(arr)` - `0 <= l, r < len(arr)` **Performance Requirements**: - Ensure that all operations (`build_tree`, `update`, and `query`) meet their expected time complexities for large inputs. **Example**: ```python # Example 1 mytree = SegmentTree([2, 4, 5, 3, 4], max) assert mytree.query(2, 4) == 5 mytree.update(3, 6) assert mytree.query(0, 3) == 6 # Example 2 mytree = SegmentTree([4, 5, 2, 3, 4, 43, 3], lambda a, b: a + b) assert mytree.query(0, 6) == 64 mytree.update(2, -10) assert mytree.query(0, 6) == 52 # Example 3 mytree = SegmentTree([(1, 2), (4, 6), (4, 5)], lambda a, b: (a[0] + b[0], a[1] + b[1])) assert mytree.query(0, 2) == (9, 13) mytree.update(2, (-1, 2)) assert mytree.query(0, 2) == (4, 10) ``` Consider these examples and ensure your implementation passes these and other edge cases.","solution":"class SegmentTree: def __init__(self, arr, function): self.n = len(arr) self.arr = arr self.function = function self.tree = [0] * (2 * self.n) self.build_tree() def build_tree(self): for i in range(self.n): self.tree[self.n + i] = self.arr[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, p, v): p += self.n self.tree[p] = v while p > 1: p //= 2 self.tree[p] = self.function(self.tree[2 * p], self.tree[2 * p + 1]) def query(self, l, r): l += self.n r += self.n res = None while l <= r: if l % 2 == 1: if res is None: res = self.tree[l] else: res = self.function(res, self.tree[l]) l += 1 if r % 2 == 0: if res is None: res = self.tree[r] else: res = self.function(res, self.tree[r]) r -= 1 l //= 2 r //= 2 return res"},{"question":"# Context Heap Sort is a well-known comparison-based sorting algorithm that uses a binary heap data structure. There are two versions of Heap Sort: one that uses a Max Heap to sort an array in ascending order and another that uses a Min Heap for the same purpose. Both approaches perform in O(n log n) time complexity and sort the array in-place. # Problem Statement Given an array of integers, implement the Heap Sort algorithm using a Min Heap to sort the array in ascending order. However, this time you need to implement the min_heap_sort function without writing your own min_heapify function. Instead, you should use Python\'s heapq library to simplify the construction of the Min Heap. # Function Signature ```python import heapq def min_heap_sort_with_heapq(arr: List[int]) -> List[int]: ``` # Input * An array `arr` of integers, with length `n` where `1 <= n <= 10^5`. # Output * Return the array sorted in ascending order. # Constraints * You must not use any sorting library functions (like sorted in Python), except for the heapq functions. * Your implementation must maintain a time complexity of O(n log n). # Example Input ```python arr = [12, 11, 13, 5, 6, 7] ``` Output ```python [5, 6, 7, 11, 12, 13] ``` # Requirements * The function should properly handle arrays of different sizes and values, including edge cases. * You should ensure your implementation is efficient and meets the O(n log n) constraint. # Hints * Think about how you can leverage the heapq.heappush() and heapq.heappop() functions to construct the Min Heap and extract elements in sorted order. * Avoid writing the min_heapify function manually, instead focus on using heapq to streamline the heap operations.","solution":"import heapq from typing import List def min_heap_sort_with_heapq(arr: List[int]) -> List[int]: Sorts the given array using Heap Sort algorithm with Min Heap. It uses the heapq library for heap operations. Parameters: arr (List[int]): List of integers to be sorted Returns: List[int]: Sorted list of integers in ascending order heapq.heapify(arr) # Convert the list into a heap in-place sorted_arr = [heapq.heappop(arr) for _ in range(len(arr))] # Extract elements in sorted order return sorted_arr"},{"question":"# Graph Bipartite Check # Context Alice is working on a graph-theory-based game. She needs to ensure that the game model can represent the interactions between entities without forming harmful loops. She decided to use bipartite graphs for their properties but isn\'t sure how to determine if a given graph is bipartite. Write a function `is_graph_bipartite(adj_list)` that tests whether a given graph is bipartite. # Function Signature ```python def is_graph_bipartite(adj_list: List[List[int]]) -> bool: Determine if the given graph is bipartite. Parameters: adj_list (List[List[int]]): It is an adjacency matrix representation of an undirected graph. adj_list[i][j] is 1 if there\'s an edge between vertex i and j, 0 otherwise Returns: bool: True if the graph is bipartite, False otherwise. ``` # Input - `adj_list` is a square matrix (nxn) where n is the number of vertices in the graph. It represents the adjacency matrix of an undirected graph. # Output - Return `True` if the graph can be colored with two colors such that no two adjacent vertices share the same color (i.e., the graph is bipartite). - Return `False` otherwise. # Constraints - The adjacency list contains only integers 0 or 1. - The graph does not contain self-loops or duplicate edges. # Examples 1. **Example 1:** ```python adj_list = [ [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0] ] assert is_graph_bipartite(adj_list) == True ``` 2. **Example 2:** ```python adj_list = [ [0, 1, 1, 0], [1, 0, 1, 1], [1, 1, 0, 0], [0, 1, 0, 0] ] assert is_graph_bipartite(adj_list) == False ``` # Notes - Consider the graph might be disconnected; the function should correctly handle such cases. - Aim for an efficient solution as much as possible in terms of both time and space complexity.","solution":"from typing import List def is_graph_bipartite(adj_list: List[List[int]]) -> bool: n = len(adj_list) colors = [-1] * n for start in range(n): if colors[start] == -1: stack = [start] colors[start] = 0 while stack: node = stack.pop() for neighbor in range(n): if adj_list[node][neighbor] == 1: if colors[neighbor] == -1: colors[neighbor] = 1 - colors[node] stack.append(neighbor) elif colors[neighbor] == colors[node]: return False return True"},{"question":"# Combination Sum Problem with Dynamic Programming Context: You are working as a developer for a software that helps in various combinatorial optimizations. One of your tasks is to develop a functionality to compute the number of ways to achieve a target sum given an array of integers. You need to ensure the solution is efficient enough to handle large inputs. Problem Statement: Write a function `combination_sum` that takes in an integer array `nums` with all positive numbers and no duplicates, and an integer `target`. The function should return the number of possible combinations that add up to the target. Implement the function using both top-down and bottom-up dynamic programming approaches. Function Signature: ```python def combination_sum(nums: List[int], target: int) -> Tuple[int, int]: # Top-down implementation def combination_sum_topdown(nums: List[int], target: int) -> int: # Implement top-down DP solution here pass # Bottom-up implementation def combination_sum_bottom_up(nums: List[int], target: int) -> int: # Implement bottom-up DP solution here pass topdown_result = combination_sum_topdown(nums, target) bottomup_result = combination_sum_bottom_up(nums, target) return (topdown_result, bottomup_result) ``` Input: * `nums` - A list of positive integers without duplicates. * `target` - A positive integer representing the target sum. Output: * A tuple (int, int) where the first integer is the result from the top-down approach and the second integer is the result from the bottom-up approach. Constraints: * The elements in `nums` are all unique positive integers. * `target` is a positive integer. * Performance should be optimized for large target values and arrays. Example: ```python nums = [1, 2, 3] target = 4 # When passed to combination_sum(nums, target): # Expected output (7, 7) ``` **Follow-Up (Optional):** Consider extending the problem to handle negative integers in `nums`. Outline the changes required in your algorithm and discuss any constraints and limitations introduced as a result.","solution":"from typing import List, Tuple def combination_sum(nums: List[int], target: int) -> Tuple[int, int]: # Top-down implementation def combination_sum_topdown(nums: List[int], target: int) -> int: memo = {} def helper(target): if target in memo: return memo[target] if target == 0: return 1 if target < 0: return 0 total = 0 for num in nums: total += helper(target - num) memo[target] = total return total return helper(target) # Bottom-up implementation def combination_sum_bottom_up(nums: List[int], target: int) -> int: dp = [0] * (target + 1) dp[0] = 1 for t in range(1, target + 1): for num in nums: if t >= num: dp[t] += dp[t - num] return dp[target] topdown_result = combination_sum_topdown(nums, target) bottomup_result = combination_sum_bottom_up(nums, target) return (topdown_result, bottomup_result)"},{"question":"# Polynomial Simplification Given the `Monomial` and `Polynomial` classes explained above, your task is to implement a method to simplify a polynomial by combining like terms. # Requirements 1. Implement the `simplify` method in the `Polynomial` class which combines all like terms in the polynomial. 2. Ensure that the resulting polynomial has no two monomials with the same variables. # Input Format ```python # A Polynomial object. polynomial = Polynomial([ Monomial({1:1, 2:2}, 3), Monomial({2:2, 1:1}, 5), Monomial({1:3}, 7), Monomial({1:1}, -3), ]) ``` # Output Format The `simplify` method should return a new `Polynomial` object with combined like terms: ```python polynomial.simplify() # Expected output: Polynomial([ Monomial({1:1, 2:2}, 8), Monomial({1:3}, 7), Monomial({}, -3), ]) ``` # Constraints * Assume there will be at most (10^3) monomials in the polynomial. * All coefficients will be integers. * Variable exponents are also guaranteed to be integer values. # Example ```python polynomial = Polynomial([ Monomial({1:1, 2:2}, 3), Monomial({2:2, 1:1}, 5), Monomial({1:3}, 7), Monomial({1:1}, -3), ]) simplified_polynomial = polynomial.simplify() # Output: # Polynomial([ # Monomial({1:1, 2:2}, 8), # Monomial({1:3}, 7), # Monomial({}, -3), # ]) ``` # Guidelines * Focus on combining like terms efficiently. * Ensure the `simplify` method is correctly implemented and tested. * Be mindful of edge cases such as polynomials with zero coefficients.","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = variables # Dictionary where keys are variable IDs and values are exponents self.coefficient = coefficient def __eq__(self, other): return self.variables == other.variables and self.coefficient == other.coefficient def __repr__(self): return f\\"Monomial({self.variables}, {self.coefficient})\\" class Polynomial: def __init__(self, monomials): self.monomials = monomials # List of Monomial objects def simplify(self): from collections import defaultdict # Dictionary to store combined coefficients of like terms combined_monomials = defaultdict(int) for monomial in self.monomials: # Convert variable dictionary to an immutable tuple key variables_key = frozenset(monomial.variables.items()) combined_monomials[variables_key] += monomial.coefficient # Now construct the simplified list of monomials simplified_monomials = [ Monomial(dict(key), coefficient) for key, coefficient in combined_monomials.items() if coefficient != 0 ] return Polynomial(simplified_monomials) def __eq__(self, other): return self.monomials == other.monomials def __repr__(self): return f\\"Polynomial({self.monomials})\\""},{"question":"# Context You have been hired by a software company to develop an improved version of their existing scheduling system. The heart of this system revolves around efficiently managing a queue of tasks that need to be processed on a first-come, first-served basis. The current implementation uses a simple list, which has performance bottlenecks, especially when tasks are frequently added and removed. # Task Your task is to implement a new version of the task queue using a dynamically expanding array approach (ArrayQueue) and a linked list approach (LinkedListQueue). You need to provide complete implementations while considering the performance implications and ensure no data is lost during typical queue operations. The queue must support the following operations: * **enqueue(item)**: Adds a new item to the rear of the queue. * **dequeue()**: Removes and returns the front item from the queue. * **peek()**: Returns the front item without removing it. * **isEmpty()**: Checks if the queue is empty. * **size()**: Returns the number of items in the queue. # Requirements 1. Implement the `ArrayQueue` class. 2. Implement the `LinkedListQueue` class. 3. Ensure both classes are thoroughly tested with edge cases (e.g., operations on an empty queue). # Constraints * You may assume that the `ArrayQueue` will not be initialized with a capacity larger than 1,000,000. # Input/Output 1. `enqueue(item)` - Input: item (the value to be added to the queue) - Output: None 2. `dequeue()` - Input: None - Output: item (the value removed from the front of the queue) 3. `peek()` - Input: None - Output: item (the value at the front of the queue) 4. `isEmpty()` - Input: None - Output: Boolean (True if the queue is empty, False otherwise) 5. `size()` - Input: None - Output: Integer (the number of items in the queue) # Example ```python # ArrayQueue Example aq = ArrayQueue(capacity=5) aq.enqueue(1) aq.enqueue(2) print(aq.dequeue()) # Output: 1 print(aq.peek()) # Output: 2 print(aq.isEmpty()) # Output: False print(aq.size()) # Output: 1 # LinkedListQueue Example llq = LinkedListQueue() llq.enqueue(1) llq.enqueue(2) print(llq.dequeue()) # Output: 1 print(llq.peek()) # Output: 2 print(llq.isEmpty()) # Output: False print(llq.size()) # Output: 1 ```","solution":"class ArrayQueue: def __init__(self, capacity=1000000): self.queue = [] self.capacity = capacity def enqueue(self, item): if len(self.queue) >= self.capacity: raise Exception(\\"Queue is full\\") self.queue.append(item) def dequeue(self): if self.isEmpty(): raise Exception(\\"Queue is empty\\") return self.queue.pop(0) def peek(self): if self.isEmpty(): raise Exception(\\"Queue is empty\\") return self.queue[0] def isEmpty(self): return len(self.queue) == 0 def size(self): return len(self.queue) class LinkedListQueue: class Node: def __init__(self, value): self.value = value self.next = None def __init__(self): self.front = None self.rear = None self._size = 0 def enqueue(self, item): new_node = self.Node(item) if self.rear: self.rear.next = new_node self.rear = new_node if not self.front: self.front = self.rear self._size += 1 def dequeue(self): if self.isEmpty(): raise Exception(\\"Queue is empty\\") value = self.front.value self.front = self.front.next if not self.front: self.rear = None self._size -= 1 return value def peek(self): if self.isEmpty(): raise Exception(\\"Queue is empty\\") return self.front.value def isEmpty(self): return self.front is None def size(self): return self._size"},{"question":"**Problem Statement**: You are given a large document (text) and a specific word (pattern) that you need to search within the text. Use the Knuth-Morris-Pratt (KMP) algorithm to efficiently find all the starting indices where the word appears as a substring in the document. **Function Signature**: ```python def find_pattern_occurrences(text: str, pattern: str) -> List[int]: Args: - text (str): The document in which to search the word. It can be empty. - pattern (str): The word to search for in the document. It can be empty. Returns: - List[int]: A list of starting indices where the word is found in the document. If no matches are found, return an empty list. Example: find_pattern_occurrences(\'hello there hero!\', \'he\') [0, 7, 12] Constraints: - The length of the text is up to 10^6 characters. - The length of the pattern is up to 10^5 characters. - The function should execute efficiently within these input size constraints. pass ``` **Notes**: 1. If the pattern is empty, return an empty list. 2. If the text is empty, return an empty list. 3. Ensure your implementation handles edge cases like: - Pattern longer than text. - Repeated characters in pattern and text. **Example Usage**: ```python assert find_pattern_occurrences(\'abcabcabc\', \'abc\') == [0, 3, 6] assert find_pattern_occurrences(\'\', \'pattern\') == [] assert find_pattern_occurrences(\'text\', \'\') == [] assert find_pattern_occurrences(\'abracadabra\', \'abra\') == [0, 7] assert find_pattern_occurrences(\'mississippi\', \'issi\') == [1, 4] ``` **Constraints**: - Optimal usage of time and memory should be considered given the large potential size of text and pattern. - Avoid brute-force solutions which might not run efficiently for large inputs.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Helper function to compute the Longest Prefix Suffix (LPS) array used in KMP algorithm. lps = [0] * len(pattern) length = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_pattern_occurrences(text: str, pattern: str) -> List[int]: if not text or not pattern: return [] lps = compute_lps(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return result"},{"question":"Coding Question: In-Place Merge Sort **Objective:** Implement an in-place merge sort algorithm to sort an array of integers now without utilizing additional space for the merged subarrays. **Function Signature:** ```python def in_place_merge_sort(arr: List[int]) -> List[int]: ``` **Input:** - An array of integers `arr` (0 <= len(arr) <= 10^5) **Output:** - Return the sorted array, which should be sorted in non-decreasing order. **Constraints:** - You should not use extra space for merging subarrays, instead work in-place. **Performance Requirement:** - Time Complexity: O(n log n) - Space Complexity: O(1) additional space **Notes:** - This problem examines your ability to optimize the merge process to work without additional memory. - Consider edge cases such as arrays with a single element or empty arrays. - You are restricted from using auxiliary arrays during the merge process. **Example:** ```python assert in_place_merge_sort([4, 2, 5, 1, 6, 3]) == [1, 2, 3, 4, 5, 6] assert in_place_merge_sort([1, 1, 1, 0, 0, 0]) == [0, 0, 0, 1, 1, 1] assert in_place_merge_sort([]) == [] assert in_place_merge_sort([3]) == [3] assert in_place_merge_sort([1, 2, 3, 4, 5, 6]) == [1, 2, 3, 4, 5, 6] ``` **Hint:** Try implementing two-pointer technique and adjust the elements within the original array during the merging phase.","solution":"def in_place_merge_sort(arr): Sorts an array in-place using the merge sort algorithm. def merge(arr, start, mid, end): start2 = mid + 1 if arr[mid] <= arr[start2]: return while start <= mid and start2 <= end: if arr[start] <= arr[start2]: start += 1 else: value = arr[start2] index = start2 while index != start: arr[index] = arr[index - 1] index -= 1 arr[start] = value start += 1 mid += 1 start2 += 1 def merge_sort(arr, left, right): if left < right: mid = (left + right) // 2 merge_sort(arr, left, mid) merge_sort(arr, mid + 1, right) merge(arr, left, mid, right) merge_sort(arr, 0, len(arr) - 1) return arr"},{"question":"**Question**: In many applications, it is important to efficiently sort arrays when the values fall into a limited range of categories. One such problem is to sort an array of integers representing colors in a specific order without using built-in sort functions. Given an array `nums` with `n` objects colored red, white, or blue, where: - Red is represented by `0` - White is represented by `1` - Blue is represented by `2` Sort the array so that objects of the same color are adjacent, with the colors in the order red, white, and blue. Write a function `sort_colors(nums)` that modifies the array in-place to achieve the desired sorting. You are not allowed to use the library\'s sort function. **Function Signature**: `def sort_colors(nums: List[int]) -> None:` **Input**: - `nums` (List[int]): An array of integers, each element can be 0, 1, or 2. **Output**: - The function should not return anything. It should modify the array `nums` in-place such that all 0s come first, followed by all 1s, and all 2s come at the end. **Constraints**: - The length of the array `nums` will be in the range `[1, 300]`. - The values in the array `nums` will be 0, 1, or 2. **Example**: ```python nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output: [0, 0, 1, 1, 2, 2] ``` **Notes**: - Your solution should have O(n) time complexity and O(1) space complexity. - The array should be sorted in-place without copying the array or using extra data structures for sorting.","solution":"from typing import List def sort_colors(nums: List[int]) -> None: Sorts the array so that all 0s come first, followed by all 1s, then all 2s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Stooge Sort Analysis and Enhancement You are given a recursive sorting algorithm known as Stooge Sort. It is known for its inefficiency due to its high time complexity but serves as a good educational example for understanding recursive sorting mechanisms. **Task**: Augment the Stooge Sort implementation to include performance enhancements and optimizations. Specifically, you are required to implement the following enhancements: 1. **Early Termination Check**: Identify if the array or sub-array is already sorted before proceeding with further recursive calls. 2. **Array Size Threshold Optimization**: Implement a threshold `k` below which a more efficient sorting algorithm (e.g., Insertion Sort) is used instead of Stooge Sort. Experiment with different values of `k`. Input * An unsorted list of integers `arr`. Output * A sorted list of integers in non-decreasing order. Constraints * You must retain the core operation of the Stooge Sort algorithm. * You are free to implement additional functions as needed for improving efficiency. # Example ```python def stoogesort(arr, l, h): # Your enhanced implementation here # Example usage: array = [5, 3, 2, 8, 6, 2] print(stoogesort(array, 0, len(array) - 1)) # Output should be [2, 2, 3, 5, 6, 8] ``` Notes: * In the above example, the input list `[5, 3, 2, 8, 6, 2]` is transformed into `[2, 2, 3, 5, 6, 8]`. * Ensure your enhanced Stooge Sort implementation is tested against various edge cases and large datasets to verify efficiency gains.","solution":"def insertion_sort(arr, l, h): for i in range(l + 1, h + 1): key = arr[i] j = i - 1 while j >= l and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def stoogesort(arr, l, h, k=10): # Early termination check already_sorted = True for i in range(l + 1, h + 1): if arr[i-1] > arr[i]: already_sorted = False break if already_sorted: return # If size of the subarray is below or equal to threshold k, use insertion sort if h - l + 1 <= k: insertion_sort(arr, l, h) return # Main Stooge Sort logic if arr[l] > arr[h]: arr[l], arr[h] = arr[h], arr[l] if h - l + 1 > 2: t = (h - l + 1) // 3 stoogesort(arr, l, h - t, k) stoogesort(arr, l + t, h, k) stoogesort(arr, l, h - t, k) # Example usage: array = [5, 3, 2, 8, 6, 2] stoogesort(array, 0, len(array) - 1) print(array) # Output should be [2, 2, 3, 5, 6, 8]"},{"question":"# Question: Implement an Optimized Counting Sort Algorithm You are given an array containing a mix of negative and positive integers. Your task is to implement an optimized version of the counting sort algorithm that can handle these types of arrays efficiently. # Function Signature ```python def optimized_counting_sort(arr: List[int]) -> List[int]: ``` # Input * `arr` (List[int]): A list of integers which can be negative, zero, or positive. # Output * `List[int]`: A sorted list of integers. # Constraints 1. `-10^6 <= arr[i] <= 10^6` 2. The length of `arr` will not exceed `10^6`. # Example ```python assert optimized_counting_sort([4, -1, -3, 2, 1, -4, 0]) == [-4, -3, -1, 0, 1, 2, 4] assert optimized_counting_sort([55, 23, 1, 0, -4, -20, 23]) == [-20, -4, 0, 1, 23, 23, 55] ``` # Requirements - You are expected to handle the integer range efficiently to keep the space complexity within acceptable limits. - Consider edge cases such as empty arrays and arrays with identical elements.","solution":"from typing import List def optimized_counting_sort(arr: List[int]) -> List[int]: if not arr: return [] # Find the maximum and minimum value in the array min_val = min(arr) max_val = max(arr) # Create the counting array range_of_elements = max_val - min_val + 1 count = [0] * range_of_elements # Store the count of each number in the count array for number in arr: count[number - min_val] += 1 # Build the output array using the count array sorted_arr = [] for i in range(range_of_elements): sorted_arr.extend([i + min_val] * count[i]) return sorted_arr"},{"question":"**Context**: In computer science, understanding how to navigate and manipulate data structures like binary trees is fundamental. One such manipulation is finding the maximum depth of the binary tree, which is critical for problems like balancing trees, analyzing tree structures, and optimizing traversal processes. **Problem Statement**: Write an efficient function to find the maximum depth of a binary tree. The function should accept the root of the binary tree and return the maximum depth. # Function Signature: ```python def max_depth(root: Optional[TreeNode]) -> int: pass ``` # Constraints: * The number of nodes in the tree is in the range [0, 10^4]. * -100 <= Node.val <= 100 # Input: * `root` - the root node of the binary tree. # Output: * An integer representing the maximum depth of the binary tree. # Examples: 1. Given the binary tree: ``` 3 / 9 20 / 15 7 ``` The function should return `3`. 2. Given the binary tree: ``` 1 2 3 4 5 ``` The function should return `5`. # Explanation: 1. The first example contains three levels with the longest depth being up to the leaf nodes (15 and 7) from the root. 2. The second example is a skewed tree, with the maximum depth being the number of nodes. # Note: 1. Consider crafting both recursive (DFS) and iterative (BFS) approaches to demonstrate a thorough understanding of the principles and their implementations. # Performance Requirements: * Your solution should run in O(n) time complexity. * The space complexity should be O(h) where h is the height of the tree for the DFS approach and O(n) for BFS due to the queue.","solution":"from typing import Optional class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def max_depth(root: Optional[TreeNode]) -> int: if not root: return 0 left_depth = max_depth(root.left) right_depth = max_depth(root.right) return max(left_depth, right_depth) + 1"},{"question":"Context: A bank\'s database needs to quickly identify the length of account numbers to ensure data consistency and adherence to formatting standards. Given that the account numbers can be extremely large, an efficient mechanism to determine the number of digits is required. Task: Implement a function `num_digits()` that accurately computes the number of digits in a given integer. The function should handle both positive and negative numbers, and should also consider edge cases effectively. Function Signature: ```python def num_digits(n: int) -> int: pass ``` Input: * `n` (int): An integer for which the number of digits needs to be calculated. - Constraints: -10^18 ≤ n ≤ 10^18 Output: * Return the number of digits in the given integer. Example: ```python assert num_digits(0) == 1 assert num_digits(12345) == 5 assert num_digits(-12345) == 5 assert num_digits(1000000000) == 10 assert num_digits(-1000000000) == 10 ``` Requirements: * The function should have a time complexity of O(1). * The function should correctly handle edge cases such as zero and negative integers. Note: * You should not use any string conversion methods to determine the number of digits. * Use `math.log10` function to achieve constant time complexity. Good luck!","solution":"import math def num_digits(n: int) -> int: Returns the number of digits in the given integer n. if n == 0: return 1 else: # We take the absolute value to count digits correctly for negative numbers n = abs(n) return math.floor(math.log10(n) + 1)"},{"question":"You are given two strings and need to determine whether they are anagrams of each other. An anagram of a string is another string that contains the same characters, only the order of characters can be different. However, unlike the provided example, your implementation should handle the full ASCII character set and be case insensitive. # Input and Output * **Input**: - A string `s1` (1 ≤ |s1| ≤ 10^5) - A string `s2` (1 ≤ |s2| ≤ 10^5) * **Output**: - Return `True` if `s1` and `s2` are anagrams of each other, otherwise return `False`. # Constraints 1. The strings will only consist of ASCII characters. 2. The comparison should be case insensitive. # Example Example 1 *Input*: \\"Listen\\", \\"Silent\\" *Output*: `True` Example 2 *Input*: \\"Hello\\", \\"Olelh\\" *Output*: `True` Example 3 *Input*: \\"Test\\", \\"Taste\\" *Output*: `False` # Note Ensure that your solution is efficient, with a focus on minimizing the time complexity to O(n). Consider edge cases such as strings of different lengths or same characters in different cases. # Template ```python def is_anagram(s1: str, s2: str) -> bool: # Your code here # Examples print(is_anagram(\\"Listen\\", \\"Silent\\")) # True print(is_anagram(\\"Hello\\", \\"Olelh\\")) # True print(is_anagram(\\"Test\\", \\"Taste\\")) # False ```","solution":"def is_anagram(s1: str, s2: str) -> bool: Determine whether two strings are anagrams of each other, case insensitive and considering full ASCII set. :param s1: First string :param s2: Second string :return: True if s1 and s2 are anagrams, False otherwise # Convert both strings to lower case for case insensitive comparison s1 = s1.lower() s2 = s2.lower() # If lengths differ, they cannot be anagrams if len(s1) != len(s2): return False # Use dictionaries to count occurrences of each character count1 = {} count2 = {} for char in s1: if char in count1: count1[char] += 1 else: count1[char] = 1 for char in s2: if char in count2: count2[char] += 1 else: count2[char] = 1 # Compare the frequency dictionaries return count1 == count2"},{"question":"# In-Order Traversal of a Binary Tree Objective Implement both iterative and recursive in-order traversal methods for a binary tree and ensure correct handling of edge cases, performance concerns, and accurate results. Description You need to write two functions: 1. `inorder_iterative(root: Node) -> List[int]`: An iterative approach to perform in-order traversal of a binary tree. 2. `inorder_recursive(root: Node) -> List[int]`: A recursive approach to perform in-order traversal of a binary tree. The in-order traversal visits nodes in the \\"left node, current node, right node\\" order. If given a Binary Search Tree (BST), this traversal will return nodes in ascending order. Input - `root`: The root node of the binary tree, which can be `None` (an empty tree). Output - A list of integers representing the in-order traversal of the binary tree nodes. Constraints 1. The number of nodes in the binary tree can be up to `10^4`. 2. Node values are unique and range from `-10^4` to `10^4`. Example ```python # Binary Tree Structure: # 100 # / # 50 150 # / / # 25 75 125 175 n1 = Node(100) n2 = Node(50) n3 = Node(150) n4 = Node(25) n5 = Node(75) n6 = Node(125) n7 = Node(175) n1.left, n1.right = n2, n3 n2.left, n2.right = n4, n5 n3.left, n3.right = n6, n7 assert inorder_iterative(n1) == [25, 50, 75, 100, 125, 150, 175] assert inorder_recursive(n1) == [25, 50, 75, 100, 125, 150, 175] ``` Please ensure your solutions handle edge cases like empty trees correctly. **Function Signatures:** ```python from typing import List, Optional class Node: def __init__(self, val: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.val = val self.left = left self.right = right def inorder_iterative(root: Optional[Node]) -> List[int]: pass def inorder_recursive(root: Optional[Node]) -> List[int]: pass ```","solution":"from typing import List, Optional class Node: def __init__(self, val: int, left: \'Optional[Node]\' = None, right: \'Optional[Node]\' = None): self.val = val self.left = left self.right = right def inorder_iterative(root: Optional[Node]) -> List[int]: Perform in-order traversal of the binary tree iteratively. stack, result = [], [] current = root while stack or current: while current: stack.append(current) current = current.left current = stack.pop() result.append(current.val) current = current.right return result def inorder_recursive(root: Optional[Node]) -> List[int]: Perform in-order traversal of the binary tree recursively. result = [] def helper(node: Optional[Node]): if node: helper(node.left) result.append(node.val) helper(node.right) helper(root) return result"},{"question":"# Question: Implement a Balanced Parentheses Checker using Stack Objective Write a function to check if a given string of parentheses (of different types) is balanced. Parentheses are considered balanced if every opening bracket has a corresponding closing bracket and the pairs of brackets are properly nested. Function Signature ```python def is_balanced(expression: str) -> bool: ``` Input * `expression` (string): A string containing parentheses - `()`, `{}`, `[]`. Output * Returns `True` if the expression is balanced, otherwise `False`. Constraints * The length of the `expression` will not exceed 10^4. * The `expression` will only contain the characters - `(){}[]`. Example ```python print(is_balanced(\\"([{}])\\")) # Output: True print(is_balanced(\\"((({}]]\\")) # Output: False print(is_balanced(\\"{[()]}\\")) # Output: True print(is_balanced(\\"{{[[(())]]}}\\")) # Output: True print(is_balanced(\\")(\\")) # Output: False ``` Use Case Scenario Consider a situation where you need to parse and evaluate mathematical expressions or commands in a code editor. It is crucial to ensure that all parentheses are balanced for the expressions to be valid. An unbalanced expression might lead to syntax errors or runtime exceptions. Performance Requirements - The function should operate within O(n) time complexity, where n is the length of the expression. - Utilization of either `ArrayStack` or `LinkedListStack` to implement the stack operations is necessary to hold the parentheses temporarily. Notes 1. You can choose to implement the `ArrayStack` or `LinkedListStack` from the provided structure or use Python\'s list (which behaves like a stack). 2. Keep an eye on edge cases, like an empty string (which is balanced).","solution":"def is_balanced(expression: str) -> bool: opening_brackets = set(\'([{\') closing_brackets = set(\')]}\') matches = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} stack = [] for char in expression: if char in opening_brackets: stack.append(char) elif char in closing_brackets: if stack and stack[-1] == matches[char]: stack.pop() else: return False return len(stack) == 0"},{"question":"**Scenario**: You are developing a library for an educational application focused on teaching ancient number systems. One of the features needed is the ability to convert Roman numerals to integers as part of the user\'s learning and testing processes. Users can input any Roman numeral, and they should receive the equivalent integer displayed in the application. **Task**: Implement the function `roman_to_int(s: str) -> int` that converts a Roman numeral, provided as a string `s`, into its integer equivalent. The function should handle Roman numerals up to 3999 correctly. **Function Signature**: `def roman_to_int(s: str) -> int` **Input**: * `s` (str): A string representing a valid Roman numeral. Constraints: 1 <= len(s) <= 15 **Output**: * (int): An integer corresponding to the Roman numeral. **Constraints**: * The input is guaranteed to be a valid Roman numeral from 1 to 3999. * The string will be non-empty and contain only the characters \'I\', \'V\', \'X\', \'L\', \'C\', \'D\', \'M\'. Implement your solution considering: * Time efficiency (O(n) time complexity). * Robustness in handling all valid Roman numeral cases. # Example ```python assert roman_to_int(\\"III\\") == 3 assert roman_to_int(\\"IV\\") == 4 assert roman_to_int(\\"IX\\") == 9 assert roman_to_int(\\"LVIII\\") == 58 assert roman_to_int(\\"MCMXCIV\\") == 1994 ``` **Example Explanation**: - `\\"III\\"` is 3 as III represents 1+1+1. - `\\"IV\\"` is 4 as IV represents 5-1. - `\\"IX\\"` is 9 as IX represents 10-1. - `\\"LVIII\\"` is 58 as L is 50, V is 5, and III is 3, totaling 50+5+3. - `\\"MCMXCIV\\"` is 1994 as M is 1000, CM is 900, XC is 90, and IV is 4, totaling 1000+900+90+4. Implement the function `roman_to_int` using the provided guidelines to ensure correctness and efficiency.","solution":"def roman_to_int(s: str) -> int: Converts a Roman numeral to an integer. roman_to_value = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in reversed(s): curr_value = roman_to_value[char] if curr_value < prev_value: total -= curr_value else: total += curr_value prev_value = curr_value return total"},{"question":"# Question Context You are tasked with enhancing a system for detecting cycles in linked lists. This task is crucial for preventing potential infinite loops and ensuring safe operations on data structures that may have cyclic references. Problem Statement Implement a function `detect_cycle_head` that not only detects the presence of a cycle in a linked list but also identifies the node where the cycle begins. If there is no cycle, the function should return `None`. # Function Signature ```python def detect_cycle_head(head: Node) -> Node: :param head: Node - The head node of the linked list. :return: Node - The node where the cycle begins, or None if there is no cycle. ``` # Input * `head`: The head node of a linked list. A node is defined by the `Node` class: ```python class Node: def __init__(self, x): self.val = x self.next = None ``` # Output * The node where the cycle begins if the linked list has a cycle, or `None` if there is no cycle. # Constraints * The linked list may contain between 0 and (10^5) nodes. * You may not modify the list. # Example Example 1 **Input**: The linked list: 3 -> 2 -> 0 -> -4 -> 2 (cycle starts at the second node) **Output**: ```python Node with value 2 (memory address of the node where the cycle starts) ``` Example 2 **Input**: The linked list: 1 -> None **Output**: ```python None ``` Example 3 **Input**: The linked list: 1 -> 2 -> 3 -> 4 -> 2 (cycle starts at the second node) **Output**: ```python Node with value 2 (memory address of the node where the cycle starts) ``` # Notes 1. Ensure your implementation runs with (O(n)) time complexity. 2. Ensure your implementation uses (O(1)) space complexity. 3. Consider cycle detection edge cases thoroughly.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def detect_cycle_head(head: Node) -> Node: Detects the cycle in the linked list and returns the node where the cycle begins. :param head: Node - The head node of the linked list. :return: Node - The node where the cycle begins, or None if there is no cycle. if not head or not head.next: return None slow = head fast = head # Phase 1: Determine if there\'s a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: # Cycle detected break else: # No cycle return None # Phase 2: Find the entry to the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Context: A company is developing a software that processes transactions in real-time. They receive a sorted list of daily transactions, but occasionally, due to network latency, a few transactions might be out of order. To efficiently correct the order with minimal disruptions, the company wants a quick sorting solution. Instead of implementing a full-scale sorting algorithm, they have decided to use Cocktail Shaker Sort to handle these minor disruptions. # Question: Implement the `cocktail_shaker_sort` function in Python. The function should take a list of integers (representing transaction timestamps) and return a list sorted in ascending order. # Inputs & Outputs: * **Input**: * An unsorted list of integers `arr` with length `N` * `1 <= N <= 10^6` * Each integer in the list `0 <= arr[i] <= 10^9` * **Output**: * A new list of integers sorted in ascending order. # Example: ```python # Example 1 input: [3, 2, 1, 4, 5] output: [1, 2, 3, 4, 5] # Example 2 input: [10, 1, 9, 2] output: [1, 2, 9, 10] ``` # Constraints: * You may assume the list contains no duplicates. **Performance Requirement**: Optimize the number of comparisons and swaps for nearly sorted lists.","solution":"def cocktail_shaker_sort(arr): Sort the list using the Cocktail Shaker Sort algorithm. if not arr: return arr n = len(arr) start = 0 end = n - 1 swapped = True while swapped: swapped = False # Traverse the array from left to right for i in range(start, end): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True # If nothing moved, then array is sorted if not swapped: break swapped = False end -= 1 # Traverse the array from right to left for i in range(end - 1, start - 1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] swapped = True start += 1 return arr"},{"question":"# Cycle Detection in a Directed Graph Objective: Write Python functions to determine if a directed graph has a cycle. This is crucial in applications like detecting deadlocks in operating systems, where processes and resources can be modeled as a directed graph. Details: - You are provided with a function template. Implement the function to detect cycles. Function Signatures: ```python from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): Determines if the given vertex is in a cycle. :param graph: Dictionary representation of the graph. :param traversal_states: Dictionary representing the state of each vertex. :param vertex: The vertex to check for cycles. :return: True if the vertex is part of a cycle, False otherwise. pass # Implement this function def contains_cycle(graph): Determines if there is a cycle in the directed graph. :param graph: Dictionary where keys are vertices and values are lists of adjacent vertices. :return: True if the graph contains a cycle, False otherwise. pass # Implement this function ``` Input: * The graph is provided as a dictionary where each key is a vertex and its value is a list of vertices to which it has directed edges. Output: * Return `True` if the graph has a cycle, otherwise `False`. Example: ```python graph = { \'A\': [\'B\', \'C\'], \'B\': [\'D\'], \'C\': [\'F\'], \'D\': [\'E\', \'F\'], \'E\': [\'B\'], \'F\': [] } print(contains_cycle(graph)) # Output: True graph_2 = { \'A\': [\'B\'], \'B\': [\'C\'], \'C\': [\'D\'], \'D\': [\'E\'], \'E\': [] } print(contains_cycle(graph_2)) # Output: False ``` Constraints: * The graph will have at most `10^3` vertices. * Each vertex identifier is a string consisting of uppercase and lowercase letters. Edge Cases: * Empty graph. * Graph with a single vertex and no edges. * Graph with multiple isolated components. Ensure your implementation adheres to the described functionality and efficiently checks for cycles.","solution":"from enum import Enum class TraversalState(Enum): WHITE = 0 GRAY = 1 BLACK = 2 def is_in_cycle(graph, traversal_states, vertex): Determines if the given vertex is in a cycle. :param graph: Dictionary representation of the graph. :param traversal_states: Dictionary representing the state of each vertex. :param vertex: The vertex to check for cycles. :return: True if the vertex is part of a cycle, False otherwise. if traversal_states[vertex] == TraversalState.GRAY: return True if traversal_states[vertex] == TraversalState.BLACK: return False traversal_states[vertex] = TraversalState.GRAY for neighbor in graph.get(vertex, []): if is_in_cycle(graph, traversal_states, neighbor): return True traversal_states[vertex] = TraversalState.BLACK return False def contains_cycle(graph): Determines if there is a cycle in the directed graph. :param graph: Dictionary where keys are vertices and values are lists of adjacent vertices. :return: True if the graph contains a cycle, False otherwise. traversal_states = {vertex: TraversalState.WHITE for vertex in graph} for vertex in graph: if traversal_states[vertex] == TraversalState.WHITE: if is_in_cycle(graph, traversal_states, vertex): return True return False"},{"question":"# Problem Description In the infinite sequence of decimal digits formed by concatenating positive integers (123456789101112...), write a function that efficiently finds and returns the nth digit. Function Signature ```python def find_nth_digit(n: int) -> int: ``` # Input * **n** (1 <= n <= 2 * 10^9): An integer representing the position in the sequence. # Output * An integer representing the nth digit in the sequence. # Example ```python print(find_nth_digit(3)) # Output: 3 print(find_nth_digit(11)) # Output: 0 print(find_nth_digit(12)) # Output: 1 ``` # Constraints - You cannot generate the sequence to find the nth digit. - The function must handle very large values of n efficiently. # Explanation The sequence begins as follows: `123456789101112...` The 3rd digit is 3 because the sequence is `123...`. The 11th digit is 0 as the sequence goes `12345678910...`. The 12th digit is 1 as the sequence goes `123456789101...`. # Objective Implement the function `find_nth_digit` that follows the aforementioned constraints and returns the correct digit efficiently, ensuring all edge cases and large input values are handled appropriately.","solution":"def find_nth_digit(n: int) -> int: # Initialize the length of the digits, start number and count of numbers with current digit length digit_length = 1 start = 1 count = 9 # Find the length of the number that contains the nth digit while n > digit_length * count: n -= digit_length * count digit_length += 1 start *= 10 count *= 10 # Find the exact number where the nth digit is located number = start + (n - 1) // digit_length # Find the exact digit in the number digit_index = (n - 1) % digit_length return int(str(number)[digit_index])"},{"question":"# Ordered Stack Implementation and Application Scenario You are tasked with implementing and testing an Ordered Stack where each new element is pushed such that the stack remains ordered with the highest element on top. This stack will be used in an application that requires frequent updates and quick access to the largest element at any given time. Requirements Implement the `OrderedStack` class using Python with the following methods: 1. **is_empty()**: Returns `True` if the stack is empty, `False` otherwise. 2. **push(item)**: Inserts `item` into the stack while maintaining order. 3. **push_t(item)**: (Provided) Pushes the item without maintaining order. 4. **pop()**: Removes and returns the top item of the stack. Raises an `IndexError` if the stack is empty. 5. **peek()**: Returns the top item of the stack without removing it. Raises an `IndexError` if the stack is empty. 6. **size()**: Returns the number of elements in the stack. # Constraints - The stack operations should be as efficient as possible given the need for maintaining order. - The stack should handle integer inputs, and integers can be negative or positive. - Optimize for correct handling of edge cases such as stack empty scenarios, and repeated values. Input and Output Formats - **Input**: The inputs will consist of method calls to the stack. - **Output**: All operations should return appropriate results or errors as specified above. Example Usage ```python stk = OrderedStack() stk.push(5) stk.push(1) stk.push(8) stk.push(3) print(stk.pop()) # Should return 8 print(stk.peek()) # Should return 5 print(stk.size()) # Should return 3 ``` Implement the `OrderedStack` class and test it with the provided example usage. Ensure to handle all the edge cases discussed.","solution":"class OrderedStack: def __init__(self): self.stack = [] def is_empty(self): return len(self.stack) == 0 def push(self, item): if self.is_empty(): self.stack.append(item) else: temp_stack = [] while not self.is_empty() and self.stack[-1] > item: temp_stack.append(self.pop()) self.stack.append(item) while temp_stack: self.stack.append(temp_stack.pop()) def push_t(self, item): self.stack.append(item) def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") return self.stack.pop() def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def size(self): return len(self.stack)"},{"question":"# Maximum Depth of a Binary Tree Given a binary tree, write a function to find its maximum depth. The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. Function Signature ```python def max_depth(root: TreeNode) -> int: ``` Input * `root` (TreeNode): The root of the binary tree. Output * `int`: An integer representing the maximum depth of the binary tree. Constraints * The number of nodes in the tree is in the range [0, 10000]. * The value of each node is an integer within the value range of 32-bit signed integers. # Example ```python # Given the following binary tree: # 3 # / # 9 20 # / # 15 7 # The maximum depth is 3. # Sample Input root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) # Sample Output print(max_depth(root)) # Output: 3 ``` # Additional Requirements 1. Implement both recursive and iterative approaches to solve this problem. 2. Ensure your iterative implementation uses a queue to manage the nodes at each level. 3. Write additional test cases to validate the following: * An empty tree should return depth 0. * A tree with a single node should return depth 1. * A tree with only left or right subtrees deeper than one level. # Constraints * Aim for a solution with O(n) time complexity and O(w) space complexity where n is the number of nodes and w is the maximum width of the tree.","solution":"from typing import Optional class TreeNode: def __init__(self, val:int=0, left:Optional[\'TreeNode\']=None, right:Optional[\'TreeNode\']=None): self.val = val self.left = left self.right = right def max_depth_recursive(root: Optional[TreeNode]) -> int: if not root: return 0 left_depth = max_depth_recursive(root.left) right_depth = max_depth_recursive(root.right) return max(left_depth, right_depth) + 1 from collections import deque def max_depth_iterative(root: Optional[TreeNode]) -> int: if not root: return 0 queue = deque([(root, 1)]) max_depth = 0 while queue: current_node, depth = queue.popleft() if current_node: max_depth = max(max_depth, depth) if current_node.left: queue.append((current_node.left, depth + 1)) if current_node.right: queue.append((current_node.right, depth + 1)) return max_depth"},{"question":"# Question: Improved Selection Sort with Simulation and Diagnostic Output You have been given the task to implement an improved version of the selection sort algorithm. This version should include diagnostic output to help understand the workings step-by-step. Objectives - **Implement** the selection sort algorithm. - **Add a detailed simulation** output that prints each iteration of the array after any swap. - **Extend the function** to return a tuple containing the sorted array and the total number of swaps made during the sort. Input - A list of integers `arr` that needs to be sorted. - A boolean flag `simulation` which, when set to `True`, will print the state of the array during each iteration. Output - A tuple containing: 1. The sorted list. 2. An integer representing the total number of swaps made. Function Signature ```python def improved_selection_sort(arr: list, simulation: bool = False) -> tuple: # Implementation here pass ``` Constraints - The length of the array will not exceed 1000 elements. - Elements of the array are integers and can be positive, negative, or zero. Example ```python # Example 1 arr = [64, 25, 12, 22, 11] simulation = True print(improved_selection_sort(arr, simulation)) # Expected output steps: # iteration 0: 11 25 12 22 64 # iteration 1: 11 12 25 22 64 # iteration 2: 11 12 22 25 64 # iteration 3: 11 12 22 25 64 # iteration 4: 11 12 22 25 64 # Expected output tuple: ([11, 12, 22, 25, 64], 3) # Example 2 arr = [5] simulation = False print(improved_selection_sort(arr, simulation)) # Expected output tuple: ([5], 0) ``` Your implementation should be efficient and correctly handle all edge cases.","solution":"def improved_selection_sort(arr: list, simulation: bool = False) -> tuple: Sorts the input list using selection sort algorithm. If simulation is True, prints the array after each swap. Parameters: arr (list): The list of integers to sort. simulation (bool): Flag to print the array state after each swap. Returns: tuple: A tuple containing the sorted list and the total number of swaps made. n = len(arr) swap_count = 0 for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j if min_idx != i: arr[i], arr[min_idx] = arr[min_idx], arr[i] swap_count += 1 if simulation: print(f\\"iteration {i}: {\' \'.join(map(str, arr))}\\") return arr, swap_count"},{"question":"Scenario You are tasked with monitoring the performance of a system by calculating the moving average of response times. The system should be efficient enough to handle a continuous stream of data points. Problem Statement Write a class `MovingAverage` that calculates the moving average of a sequence of numbers within a fixed-size window. You should include the following methods: - `__init__(self, size: int)`: Constructor that initializes the moving average with a window size. - `next(self, val: int) -> float`: Method that adds a new number `val` into the data stream and returns the updated moving average of the last `size` numbers. Input and Output Format - The constructor `__init__` receives an integer `size` (1 ≤ size ≤ 10^5). - The method `next` receives an integer `val` (-10^4 ≤ val ≤ 10^4) and returns a float representing the moving average. Constraints - The class should handle up to 10^5 calls to the `next` method efficiently. Requirements - Optimize your solution to handle large input sizes and high frequency of calls. - Assume the initial stream of numbers can be any integer. Example ```python # Example usage: m = MovingAverage(3) print(m.next(1)) # Returns 1.0 print(m.next(10)) # Returns 5.5 print(m.next(3)) # Returns 4.66667 (approximately 4.67) print(m.next(5)) # Returns 6.0 ``` # Evaluation Criteria - Correctness: The solution should return accurate moving averages. - Efficiency: It should handle the upper constraint on calls with optimal performance. - Edge Cases: Properly handle edge cases including initial input smaller than window size. - Code Quality: Clear, understandable, and properly commented code.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the moving average with a specified window size. self.size = size self.window = deque() self.window_sum = 0 def next(self, val: int) -> float: Add a new value to the stream and return the moving average of the last \'size\' values. if len(self.window) == self.size: removed_value = self.window.popleft() self.window_sum -= removed_value self.window.append(val) self.window_sum += val return self.window_sum / len(self.window)"},{"question":"# Scenario: You are working as a developer for a company that deals with large datasets that need efficient searching and insertion operations. One of the frequent operations you need to handle is processing a stream of incoming numbers and inserting each number into a sorted list while maintaining the list\'s order. Efficiently determining the insertion position for each number is crucial to optimize the overall performance. # Question: Write a Python function `find_insert_position(lst, value)` that utilizes the binary search algorithm to find the index at which a given `value` should be inserted into the sorted list `lst` to maintain the list\'s sorted order. **Function Signature**: ```python def find_insert_position(lst: List[int], value: int) -> int: pass ``` **Input**: - `lst`: A list of integers sorted in ascending order. - `value`: An integer value to be inserted into `lst`. **Output**: - Return an integer representing the index at which `value` should be inserted. **Constraints**: - The length of `lst` will not exceed 10^6. - All elements in `lst` are distinct. - `lst` contains integers within the range of -10^9 to 10^9. - `value` is an integer within the range of -10^9 to 10^9. **Examples**: ```python assert find_insert_position([1, 3, 5, 6], 5) == 2 assert find_insert_position([1, 3, 5, 6], 2) == 1 assert find_insert_position([1, 3, 5, 6], 7) == 4 assert find_insert_position([1, 3, 5, 6], 0) == 0 ``` **Performance Requirements**: - The implemented function should have a time complexity of O(log n) and a space complexity of O(1).","solution":"from typing import List def find_insert_position(lst: List[int], value: int) -> int: Uses binary search to find the index at which the value should be inserted in the list to maintain sorted order. left, right = 0, len(lst) while left < right: mid = (left + right) // 2 if lst[mid] < value: left = mid + 1 else: right = mid return left"},{"question":"**Question**: You are given an array of integers. Your task is to implement the Merge Sort algorithm to sort the given array in ascending order. # Function Signature ```python def merge_sort(arr: List[int]) -> List[int]: ``` # Input - `arr`: A list of integers that needs to be sorted. # Output - Returns a new list of integers sorted in ascending order. # Constraints - The length of the array, `n`, can be in the range of 0 ≤ `n` ≤ 10^5. - Each element of the array `arr[i]` is within the range of -10^9 ≤ `arr[i]` ≤ 10^9. # Performance Requirements - Your implementation should have a time complexity of O(n log n). - Space complexity should be O(n). # Example ```python test_case_1 = [38, 27, 43, 3, 9, 82, 10] assert merge_sort(test_case_1) == [3, 9, 10, 27, 38, 43, 82] test_case_2 = [1, 2, 3, 4, 5] assert merge_sort(test_case_2) == [1, 2, 3, 4, 5] test_case_3 = [] assert merge_sort(test_case_3) == [] test_case_4 = [5, 1, 1, 2, 0, 0] assert merge_sort(test_case_4) == [0, 0, 1, 1, 2, 5] ``` # Scenario Imagine you are working on a project that requires you to handle and manipulate large datasets efficiently. Sorting is a common step in the data processing pipeline, and using an efficient and stable sorting algorithm can make a significant difference. In this case, you choose to implement Merge Sort because of its reliable performance and stability, ensuring that no matter what the dataset characteristics are, it will always provide a predictable and efficient sorting operation. # Implementation Task Implement the `merge_sort` function to sort the array adhering to the requirements and performance criteria specified.","solution":"from typing import List def merge_sort(arr: List[int]) -> List[int]: Performs merge sort on the given list of integers and returns a new sorted list. :param arr: A list of integers :return: A new list of integers sorted in ascending order if len(arr) <= 1: return arr def merge(left: List[int], right: List[int]) -> List[int]: sorted_arr = [] i = j = 0 # Merge the two halves while both have elements while i < len(left) and j < len(right): if left[i] < right[j]: sorted_arr.append(left[i]) i += 1 else: sorted_arr.append(right[j]) j += 1 # Append the remaining elements from left while i < len(left): sorted_arr.append(left[i]) i += 1 # Append the remaining elements from right while j < len(right): sorted_arr.append(right[j]) j += 1 return sorted_arr mid = len(arr) // 2 left_half = merge_sort(arr[:mid]) right_half = merge_sort(arr[mid:]) return merge(left_half, right_half)"},{"question":"Scenario In a recent discussion about right-angled triangles in your geometry class, you learned the Pythagorean theorem, which is foundational in calculating the sides of a triangle. You are given a function intended to compute the unknown side of a right-angled triangle when provided with the lengths of two sides. Your task is to implement this functionality while considering various edge cases and ensuring robust error handling. Requirements Implement a function called `calculate_third_side(opposite, adjacent, hypotenuse)` that will determine the length of the missing side in a right-angled triangle. One of the input parameters will always be the string \\"?\\" to indicate the unknown side. The function should: 1. Return the length of the missing side as a float. 2. If all three sides are provided, return the string \\"You already know the answer!\\". 3. Handle invalid input by raising a `ValueError` with the message \\"Invalid inputs\\". Input Format * The function will take three parameters: * `opposite` (float or \\"?\\"): length of the side opposite the right angle. * `adjacent` (float or \\"?\\"): length of the side adjacent to the right angle. * `hypotenuse` (float or \\"?\\"): length of the hypotenuse. * The parameter which is \\"?\\" indicates the missing side. Output Format * Return the length of the missing side as a float. * If all sides are provided, return \\"You already know the answer!\\". * Raise a `ValueError` with the message \\"Invalid inputs\\" for invalid cases. Example ```python # Example 1 calculate_third_side(3, 4, \\"?\\") # Returns: 5.0 # Example 2 calculate_third_side(3, \\"?\\", 5) # Returns: 4.0 # Example 3 calculate_third_side(\\"?\\", 4, 5) # Returns: 3.0 # Example 4 calculate_third_side(3, 4, 5) # Returns: \\"You already know the answer!\\" # Example 5 calculate_third_side(3, 4, 2) # Raises ValueError: \\"Invalid inputs\\" ``` Constraints * The inputs should always form a valid right-angled triangle. * The length of each side must be a non-negative number if provided.","solution":"def calculate_third_side(opposite, adjacent, hypotenuse): Given two sides and identifying one side as unknown (\\"?\\"), compute the length of the unknown side. If all three sides are provided, return \\"You already know the answer!\\". Raise ValueError for invalid inputs. if opposite != \\"?\\" and isinstance(opposite, (int, float)) and opposite < 0: raise ValueError(\\"Invalid inputs\\") if adjacent != \\"?\\" and isinstance(adjacent, (int, float)) and adjacent < 0: raise ValueError(\\"Invalid inputs\\") if hypotenuse != \\"?\\" and isinstance(hypotenuse, (int, float)) and hypotenuse < 0: raise ValueError(\\"Invalid inputs\\") if opposite != \\"?\\" and adjacent != \\"?\\" and hypotenuse != \\"?\\": return \\"You already know the answer!\\" try: if hypotenuse == \\"?\\": return (opposite**2 + adjacent**2) ** 0.5 elif adjacent == \\"?\\": if hypotenuse <= opposite: raise ValueError(\\"Invalid inputs\\") return (hypotenuse**2 - opposite**2) ** 0.5 elif opposite == \\"?\\": if hypotenuse <= adjacent: raise ValueError(\\"Invalid inputs\\") return (hypotenuse**2 - adjacent**2) ** 0.5 except: raise ValueError(\\"Invalid inputs\\") raise ValueError(\\"Invalid inputs\\")"},{"question":"# Scenario Context You are tasked with validating the integrity of data transfer between two servers. The data is represented as binary trees in both servers. You need to verify that the binary trees are identical to ensure successful data replication. # Task Write a Python function `is_same_tree(tree_p, tree_q)` to determine if two binary trees are identical. The function should compare the structure and node values of both trees. # Function Signature ```python def is_same_tree(tree_p, tree_q): pass ``` # Input - `tree_p` and `tree_q`: The roots of the two binary trees to be compared. Each tree node has the following attributes: - `val`: An integer value of the node. - `left`: A pointer to the left child of the node. - `right`: A pointer to the right child of the node. # Output - Return `True` if both binary trees are identical, otherwise return `False`. # Constraints - The number of nodes in each tree will be at most `1000`. - The values of the nodes will be integers within the range `-1000` to `1000`. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example trees: # Tree 1: # 1 # / # 2 3 # # Tree 2: # 1 # / # 2 3 tree_p = TreeNode(1, TreeNode(2), TreeNode(3)) tree_q = TreeNode(1, TreeNode(2), TreeNode(3)) print(is_same_tree(tree_p, tree_q)) # Expected output: True ``` # Performance Requirements - The solution should handle trees with up to `1000` nodes efficiently without exceeding the memory limits. - Avoid deep recursion to mitigate the risk of stack overflow.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_same_tree(tree_p, tree_q): if not tree_p and not tree_q: return True if not tree_p or not tree_q: return False if tree_p.val != tree_q.val: return False return is_same_tree(tree_p.left, tree_q.left) and is_same_tree(tree_p.right, tree_q.right)"},{"question":"Context: Tree traversal is a fundamental concept in computer science, especially for algorithms related to hierarchical structures. Preorder traversal is one such traversal method where you visit the root node first, followed by the left subtree, and finally the right subtree. Problem Statement: You are given the definition of a binary tree and tasked with implementing the preorder traversal of the tree. You need to write two functions: one that performs the traversal iteratively using a stack and one that performs the traversal recursively. Function Signature: ```python class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_iter(root: Node) -> list: pass def preorder_rec(root: Node) -> list: pass ``` Constraints: 1. The number of nodes in the tree will be in the range [0, 10^4]. 2. -10^5 <= Node.val <= 10^5 Input and Output: * Input: A binary tree represented by its root node. * Output: A list of integers representing the preorder traversal of the binary tree. Examples: 1. **Input**: ```python root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) ``` **Output**: ```python [1, 2, 4, 5, 3] ``` 2. **Input**: ```python root = Node(1) root.right = Node(2) root.right.left = Node(3) ``` **Output**: ```python [1, 2, 3] ``` Requirements: 1. Implement the `preorder_iter` function to perform an iterative preorder traversal using a stack. 2. Implement the `preorder_rec` function to perform a recursive preorder traversal. Performance: Your solution should be performant and able to handle the given constraints efficiently. Submission: Include the implementation of both the iterative and recursive approaches in a single submission.","solution":"class Node: def __init__(self, val, left=None, right=None): self.val = val self.left = left self.right = right def preorder_iter(root: Node) -> list: if not root: return [] stack, output = [root], [] while stack: node = stack.pop() if node: output.append(node.val) if node.right: stack.append(node.right) if node.left: stack.append(node.left) return output def preorder_rec(root: Node) -> list: def helper(node): if not node: return [] return [node.val] + helper(node.left) + helper(node.right) return helper(root)"},{"question":"--- # Problem: Sorting Checker You have been provided with a highly inefficient sorting algorithm called Bogo Sort. Your task is to develop a more efficient checker function to verify if the list is sorted in ascending order. Alongside, implement a new function that uses this sorting checker to stop the Bogo Sort earlier if the list becomes sorted. Specifications 1. **Function 1**: Implement a helper function `is_sorted(arr: List[int]) -> bool` to verify if the given list is sorted in ascending order. 2. **Function 2**: Implement an improved `bogo_sort_with_check(arr: List[int]) -> List[int]` that utilizes `is_sorted` and shuffles the array until it\'s sorted. Function Definitions 1. `is_sorted(arr: List[int]) -> bool`: - **Input**: a list of integers. - **Output**: a boolean indicating whether the array is sorted (True) or not (False). 2. `bogo_sort_with_check(arr: List[int]) -> List[int]`: - **Input**: a list of integers. - **Output**: a sorted list of integers using a version of Bogo Sort that stops early if the list is already sorted. Constraints - The array can have between 1 and 1000 elements. - Elements in the array will be integers in the range [-10^6, 10^6]. - You may use Python\'s built-in `random.shuffle`. Performance - Your `is_sorted` function must have a time complexity of O(n). # Example ```python # Example 1 arr = [3, 2, 1] print(is_sorted(arr)) # Output: False # Example 2 arr = [1, 2, 3] print(is_sorted(arr)) # Output: True # Example 3 arr = [3, 2, 1] print(bogo_sort_with_check(arr)) # Output: [1, 2, 3] ``` # Notes - Pay special attention to edge cases (e.g., empty list, list with one element, etc.). - Even though Bogo Sort is very inefficient, your is_sorted helper should ensure no unnecessary shuffling when the list is already sorted. ---","solution":"import random from typing import List def is_sorted(arr: List[int]) -> bool: Checks if the given list is sorted in ascending order. for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return False return True def bogo_sort_with_check(arr: List[int]) -> List[int]: Sorts the list using an improved Bogo Sort algorithm that stops early if the list becomes sorted. while not is_sorted(arr): random.shuffle(arr) return arr"},{"question":"Greatest Common Divisors and Bézout Coefficients Objective Write a function `find_bezout_coefficients` that takes two integers num1 and num2, and returns three integers: the Bézout coefficients s and t, and the GCD of num1 and num2. Input - Two integers, `num1` and `num2` (-10^6 <= num1, num2 <= 10^6). Output - Three integers: `s`, `t`, and `gcd` such that `num1 * s + num2 * t = gcd`. Constraints - Ensure your solution handles negative numbers properly. - Aim for an efficient algorithm with a time complexity of O(log(min(num1, num2))). Example ```python # Example 1 input: num1 = 30, num2 = 20 output: s = 1, t = -1, gcd = 10 # Example 2 input: num1 = -30, num2 = 50 output: s = 1, t = 1, gcd = 10 ``` Scenario & Context In number theory, Bézout\'s identity provides a way to express the greatest common divisor as a linear combination of the original numbers, which has practical applications in several domains such as cryptography and algorithm design. Implement the function to find such coefficients effectively. ```python def find_bezout_coefficients(num1, num2): Extended GCD algorithm to find Bézout coefficients. Parameters: num1 (int): First integer num2 (int): Second integer Returns: Tuple[int, int, int]: Returns coefficients (s, t) and the GCD such that num1 * s + num2 * t = gcd # Initialize variables old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = abs(num1), abs(num2) while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t # Adjust coefficients for original sign of num1 and num2 gcd = old_r s = old_s if num1 >= 0 else -old_s t = old_t if num2 >= 0 else -old_t return s, t, gcd # Test cases assert find_bezout_coefficients(30, 20) == (1, -1, 10) assert find_bezout_coefficients(-30, 50) == (1, 1, 10) ```","solution":"def find_bezout_coefficients(num1, num2): Extended GCD algorithm to find Bézout coefficients. Parameters: num1 (int): First integer num2 (int): Second integer Returns: Tuple[int, int, int]: Returns coefficients (s, t) and the GCD such that num1 * s + num2 * t = gcd # Initialize variables old_s, s = 1, 0 old_t, t = 0, 1 old_r, r = abs(num1), abs(num2) while r != 0: quotient = old_r // r old_r, r = r, old_r - quotient * r old_s, s = s, old_s - quotient * s old_t, t = t, old_t - quotient * t # Adjust coefficients for original sign of num1 and num2 gcd = old_r s = old_s if num1 >= 0 else -old_s t = old_t if num2 >= 0 else -old_t return s, t, gcd"},{"question":"# Question: Implement an Enhanced Insertion Sort Given the basic insertion sort implementation, enhance the sorting function to handle large datasets more efficiently. Instead of always performing the default insertion sort, apply a condition that switches to a more efficient sorting method when the array size exceeds a certain threshold. Specifications: 1. Create a function `enhanced_insertion_sort(arr, threshold)` where: - `arr` is a list of integers. - `threshold` is an integer denoting the maximum size for which to use insertion sort. For arrays larger than this size, implement Merge Sort instead. 2. Implement the Merge Sort algorithm within the same function or as a helper function. 3. Ensure the function maintains the properties of stability and in-place sorting (where applicable). 4. Maintain the option of printing iterations for insertion sort with a parameter (`simulation`) set to `False` by default. It should indicate the array\'s state at each iteration. Input: - An array `arr` of integers. - An integer `threshold`. Output: - The sorted array. Example: ```python # Example usage: arr = [5, 2, 4, 6, 1, 3] threshold = 5 print(enhanced_insertion_sort(arr, threshold)) # Output: [1, 2, 3, 4, 5, 6] ``` Constraints: - 1 <= len(arr) <= 10^6 - -10^6 <= arr[i] <= 10^6 Additional Notes: - Ensure the function handles all typical edge cases gracefully. - Consider performance implications for the hybrid approach to sorting.","solution":"def enhanced_insertion_sort(arr, threshold, simulation=False): def insertion_sort(arr): for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(arr) def merge_sort(arr): if len(arr) > 1: mid = len(arr) // 2 left_half = arr[:mid] right_half = arr[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i] < right_half[j]: arr[k] = left_half[i] i += 1 else: arr[k] = right_half[j] j += 1 k += 1 while i < len(left_half): arr[k] = left_half[i] i += 1 k += 1 while j < len(right_half): arr[k] = right_half[j] j += 1 k += 1 if len(arr) <= threshold: insertion_sort(arr) else: merge_sort(arr) return arr"},{"question":"# Coding Challenge: Prime Number Finder A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. The goal of this task is to enhance your understanding of basic number theory concepts and implement an efficient algorithm for checking prime numbers. # Objective: Write a function `is_prime(n)` that checks if a given number `n` is a prime number. Function Signature: ```python def is_prime(n: int) -> bool: pass ``` Parameters: - `n (int)`: An integer to be tested for primality (1 ≤ n ≤ 10^12). Returns: - `bool`: `True` if `n` is a prime number, `False` otherwise. Constraints: - Optimize for efficiency in terms of both time and space. - The function should handle very large numbers efficiently up to 10^12. - You may not use built-in library functions for primality testing. - Consider edge cases such as very small values (e.g., 1, 2, 3) and even numbers. Performance Requirements: - Aim for a function with time complexity O(√n) and space complexity O(1). Example: ```python print(is_prime(29)) # Output: True print(is_prime(35)) # Output: False print(is_prime(1)) # Output: False print(is_prime(2)) # Output: True ``` # Context: This function is a crucial component for larger number-theoretic operations, particularly within cryptographic computations requiring prime number checks. Understanding and implementing this function will ensure foundational knowledge of prime checking algorithms.","solution":"def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are given an array consisting of elements \'0\', \'1\', and \'2\'. Your task is to write a function to sort this array so that all \'0\'s come first, followed by \'1\'s, and then all \'2\'s in the end. **Function Specification**: - **Function Name**: `sort_colors` - **Input**: A list of integers, `nums`, where each integer is either 0, 1, or 2. - **Output**: The function should modify the input list in-place to reflect the sorted order. **Constraints**: 1. Do not use any built-in sorting function. 2. Try to solve the problem in O(n) time. **Example**: ```python def sort_colors(nums): # implementation goes here nums = [2, 0, 2, 1, 1, 0] sort_colors(nums) print(nums) # Output should be: [0, 0, 1, 1, 2, 2] ``` **Explanation**: - The input array `[2, 0, 2, 1, 1, 0]` should be sorted such that all distinct groups are adjacent and maintain the order `0`, `1`, and `2`. **Additional Test Cases**: 1. Input: `[0]` -> Output: `[0]` 2. Input: `[1, 0]` -> Output: `[0, 1]` 3. Input: `[2, 1, 0, 2, 1, 0]` -> Output: `[0, 0, 1, 1, 2, 2]` 4. Input: `[0, 0, 0, 0, 0, 0, 0]` -> Output: `[0, 0, 0, 0, 0, 0, 0]` 5. Input: `[1, 1, 1, 1, 1, 1, 1]` -> Output: `[1, 1, 1, 1, 1, 1, 1]` 6. Input: `[2, 2, 2, 2, 2, 2, 2]` -> Output: `[2, 2, 2, 2, 2, 2, 2]` **Scenarios to Consider**: 1. Arrays with different sizes including very small (e.g., single element) to very large (e.g., thousand elements). 2. Ensuring that the algorithm correctly handles boundary conditions without errors or additional space requirements.","solution":"def sort_colors(nums): Given a list of integers \'nums\' consisting of \'0\'s, \'1\'s, and \'2\'s, this function sorts the list in-place such that all \'0\'s come first, followed by \'1\'s, and then \'2\'s. low, mid, high = 0, 0, len(nums) - 1 while mid <= high: if nums[mid] == 0: nums[low], nums[mid] = nums[mid], nums[low] low += 1 mid += 1 elif nums[mid] == 1: mid += 1 else: nums[high], nums[mid] = nums[mid], nums[high] high -= 1"},{"question":"# Scenario You are involved in a project involving cryptographic algorithms where you frequently need to compute modular inverses and solve linear congruences. One common requirement is to find integers `s` and `t` for given integers `a` and `b`, such that: [ a cdot s + b cdot t = text{gcd}(a, b) ] This is essentially finding the Bézout coefficients for the given integers. # Task Implement the function `extended_gcd(a, b)` which returns a tuple `(s, t, gcd)`: - `s` and `t`: Bézout coefficients - `gcd`: the greatest common divisor of `a` and `b` # Input - Two integers `a` and `b` where `0 <= a, b <= 10^9`. # Output - A tuple containing three integers `(s, t, gcd)`. # Constraints & Requirements - The function should handle edge cases efficiently (e.g., `a` or `b` being zero). - The solution should use integer arithmetic avoiding any floating-point calculations. - Maintain an efficient runtime complexity of O(log(min(a, b))). # Example ```python assert extended_gcd(240, 46) == (2, -9, 2) assert extended_gcd(99, 78) == (-11, 14, 3) ``` # Notes - In the example `extended_gcd(240, 46)`, the output `(2, -9, 2)` means that `2 * 240 + (-9) * 46 = 2`, where `2` is the gcd of `240` and `46`. - Similarly, `extended_gcd(99, 78)` should output `(-11, 14, 3)`, because `(-11) * 99 + 14 * 78 = 3`, where `3` is the gcd of `99` and `78`. Your task is to implement the `extended_gcd` function correctly.","solution":"def extended_gcd(a, b): Returns the Bézout coefficients (s, t) and gcd of a and b such that a * s + b * t = gcd(a, b). if a == 0: return (0, 1, b) else: s1, t1, gcd = extended_gcd(b % a, a) s = t1 - (b // a) * s1 t = s1 return (s, t, gcd)"},{"question":"# Question: Matrix Multiplication Implementation You are tasked with implementing the matrix multiplication algorithm. Given two compatible two-dimensional matrices, your function will return their product. Function Signature ```python def multiply_matrix(multiplicand: list, multiplier: list) -> list: ``` Input: - **multiplicand**: A list of lists, where each sublist represents a row of the matrix. Each value in the sublist is an integer. - **multiplier**: A list of lists, where each sublist represents a row of the matrix. Each value in the sublist is an integer. Output: - A list of lists representing the result of multiplying `multiplicand` by `multiplier`. Constraints: - Assume the matrices are compatible for multiplication (you will not be given input that will result in a mismatched dimension error). - Both matrices will have at least one element and no more than 100x100 elements. - Integer values in matrices are between -10^3 to 10^3. Instructions: 1. Implement the `multiply_matrix` function as described. 2. Ensure your implementation is optimal within the provided constraints. 3. Handle edge cases such as single-element matrices. Example: ```python multiplicand = [ [1, 2], [3, 4] ] multiplier = [ [5, 6], [7, 8] ] result = multiply_matrix(multiplicand, multiplier) # Expected Output: # [ # [19, 22], # [43, 50] # ] ```","solution":"def multiply_matrix(multiplicand: list, multiplier: list) -> list: Multiplies two 2D matrices and returns the resulting matrix. Parameters: - multiplicand: list of lists, representing the first matrix - multiplier: list of lists, representing the second matrix Returns: - list of lists, representing the result of matrix multiplication rows_a = len(multiplicand) cols_a = len(multiplicand[0]) cols_b = len(multiplier[0]) result = [[0 for _ in range(cols_b)] for _ in range(rows_a)] for i in range(rows_a): for j in range(cols_b): for k in range(cols_a): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"# Segment Tree Implementation and Usage **Context**: You are given a Segment Tree class used to handle range queries and updates on an array with a commutative function. The Segment Tree can support operations like finding the maximum, minimum, sum etc., within a subrange of the array in logarithmic time. **Task**: You need to extend the functionality of the Segment Tree by implementing a method called `range_update` which performs updates on a range of elements in the array and propagates the changes throughout the tree. We\'ll assume that the function used is the summation function for simplicity in this task. # Function Signature: ```python def range_update(self, l: int, r: int, delta: int): Update the elements in the range [l, r] by adding `delta`. Propagate the changes throughout the segment tree. :param l: Left index of the range to update (inclusive). :param r: Right index of the range to update (inclusive). :param delta: The value to be added to each element in the range [l, r]. ``` **Expected Input/Output**: - `range_update(l, r, delta)` should update each element in the range `[l, r]` by adding `delta`. # Example: ```python mytree = SegmentTree([1, 2, 3, 4, 5], lambda a, b: a + b) mytree.range_update(1, 3, 2) print(mytree.query(0, 4)) # Should reflect the update, e.g., [1, 4, 5, 6, 5] mytree.range_update(0, 2, 1) print(mytree.query(0, 4)) # Further reflect the update, e.g., [2, 5, 6, 6, 5] ``` Constraints: * Do not use any global variables. * Ensure efficient updates and lookups with time complexity O(log N) for range operations. **Note**: Ensure that your function works efficiently with large arrays and handles edge cases, especially when the array length is not a power of two. Also, validate that the range parameters are within the array bounds.","solution":"class SegmentTree: def __init__(self, data, func, default=0): Initializes the Segment Tree. :param data: List of initial elements. :param func: A commutative function (like min, max, sum). :param default: The default value that represents an non-overlapping element. self.n = len(data) self.func = func self.default = default self.data = [default] * (2 * self.n) # Initialize the leaves of the segment tree for i in range(self.n): self.data[self.n + i] = data[i] # Compute the values for the internal nodes for i in range(self.n - 1, 0, -1): self.data[i] = self.func(self.data[2 * i], self.data[2 * i + 1]) def update(self, index, value): Update the value at index `index` to `value` and propagate the change up the tree. :param index: Index to update. :param value: New value to set. # Update the leaf node index += self.n self.data[index] = value # Propagate the changes up i = index while i > 1: i //= 2 self.data[i] = self.func(self.data[2 * i], self.data[2 * i + 1]) def query(self, l, r): Query the range [l, r]. :param l: Left index of the range (inclusive). :param r: Right index of the range (inclusive). :return: The result of applying `func` over the range [l, r]. l += self.n r += self.n + 1 res = self.default while l < r: if l % 2 == 1: res = self.func(res, self.data[l]) l += 1 if r % 2 == 1: r -= 1 res = self.func(res, self.data[r]) l //= 2 r //= 2 return res def range_update(self, l, r, delta): Update the elements in the range [l, r] by adding `delta`. Propagate the changes throughout the segment tree. :param l: Left index of the range to update (inclusive). :param r: Right index of the range to update (inclusive). :param delta: The value to be added to each element in the range [l, r]. for i in range(l, r + 1): self.update(i, self.query(i, i) + delta)"},{"question":"# Question You are tasked with developing a variant of the Bron-Kerbosch algorithm that considers additional constraints to find all maximal cliques in an undirected graph. Specifically, you need to ensure that the cliques found contain at least a certain minimum number of vertices. Problem Statement: Implement a function `find_all_cliques_with_min_size(edges, min_size)` that finds all maximal cliques in an undirected graph where each clique contains at least `min_size` vertices. Function Signature: ```python def find_all_cliques_with_min_size(edges: dict, min_size: int) -> list: pass ``` Parameters: - `edges`: A dictionary representing the graph, where the keys are vertex identifiers (strings) and the values are sets of vertex identifiers representing the neighbors of the key vertex. - `min_size`: An integer representing the minimum number of vertices that each found clique must contain. Returns: - A list of lists, where each sublist is a maximal clique containing at least `min_size` vertices. Example: ```python edges = { \\"1\\": {\\"2\\", \\"3\\"}, \\"2\\": {\\"1\\", \\"3\\"}, \\"3\\": {\\"1\\", \\"2\\", \\"4\\"}, \\"4\\": {\\"3\\", \\"5\\"}, \\"5\\": {\\"4\\"} } min_size = 3 print(find_all_cliques_with_min_size(edges, min_size)) ``` Output: ``` [[\'1\', \'2\', \'3\'], [\'1\', \'3\', \'4\']] ``` Constraints: - The minimum size of the cliques (`min_size`) is guaranteed to be a positive integer and not larger than the number of vertices in the graph. - The function should be optimized to handle reasonably sized graphs. Implementation Details: - Modify the Bron-Kerbosch algorithm to include an additional check to filter out cliques that do not meet the minimum size requirement. - Ensure that the algorithm retains its ability to find all maximal cliques without missing any due to the size constraint. - Handle common edge cases and make sure the solution is efficient and correct.","solution":"def find_all_cliques_with_min_size(edges, min_size): def bron_kerbosch(R, P, X): if not P and not X: if len(R) >= min_size: cliques.append(R) return for v in list(P): bron_kerbosch(R.union([v]), P.intersection(edges[v]), X.intersection(edges[v])) P.remove(v) X.add(v) cliques = [] bron_kerbosch(set(), set(edges.keys()), set()) return [list(clique) for clique in cliques]"},{"question":"# Knuth-Morris-Pratt String Matching Enhancement Given the implementation of the Knuth-Morris-Pratt (KMP) algorithm for string matching, enhance it to handle multiple patterns simultaneously. Specifically, you will implement a function `multi_pattern_kmp` which searches for multiple patterns in a given text and returns a dictionary where each key is a pattern and the corresponding value is a list of start indexes where the pattern is found in the text. Function Signature ```python def multi_pattern_kmp(text: str, patterns: List[str]) -> Dict[str, List[int]]: pass ``` Input - `text` (str): The main text string in which to search for patterns. - `patterns` (List[str]): A list of pattern strings to search in the text. Output - Return a dictionary where each key is a pattern and its value is a list of integers representing starting indexes in `text` where the pattern is found. Constraints - Patterns and text are non-empty strings. - Patterns are guaranteed to have unique values. - The overall length of text and all patterns combined will not exceed 100,000 characters. Example ```python patterns = [\'he\', \'hero\', \'there\'] text = \'hello there hero\' output = multi_pattern_kmp(text, patterns) # Expected output: # {\'he\': [0, 7, 12], \'hero\': [12], \'there\': [6]} ``` Performance Requirements The solution should efficiently handle the combined text and patterns lengths within the provided constraints, leveraging the efficiency of KMP for each pattern. Notes - Use the provided `knuth_morris_pratt` function as a base for implementing the multi-pattern matching. - Focus on code modularity by breaking down the problem into manageable parts.","solution":"from typing import List, Dict def compute_kmp_table(pattern: str) -> List[int]: Compute the KMP table (also known as the \\"partial match\\" table or \\"failure function\\") for a given pattern. table = [0] * len(pattern) j = 0 # length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[j]: j += 1 table[i] = j i += 1 else: if j != 0: j = table[j - 1] else: table[i] = 0 i += 1 return table def knuth_morris_pratt(text: str, pattern: str) -> List[int]: KMP algorithm for finding all occurrences of a pattern in a text. Returns a list of start indices. table = compute_kmp_table(pattern) result = [] i = 0 # index for text j = 0 # index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): result.append(i - j) j = table[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = table[j - 1] else: i += 1 return result def multi_pattern_kmp(text: str, patterns: List[str]) -> Dict[str, List[int]]: Search for multiple patterns in a given text using KMP algorithm. Returns a dictionary with pattern as the key and list of start indexes as the value. result = {} for pattern in patterns: result[pattern] = knuth_morris_pratt(text, pattern) return result"},{"question":"# Description: You are provided with an array of integers that needs to be sorted in non-decreasing order. Your task is to write a function `optimized_shell_sort` that sorts this array utilizing the Shell Sort algorithm. However, to assess deeper understanding, you must incorporate Sedgewick\'s gap sequence for the gap reduction process to enhance performance. # Function Signature: ```python def optimized_shell_sort(arr: List[int]) -> List[int]: ``` # Input: * A list of integers, `arr` (0 <= len(arr) <= 1000). # Output: * A list of integers sorted in non-decreasing order. # Constraints: * You must implement Shell Sort using Sedgewick\'s gap sequence. * The implementation should handle edge cases (e.g., empty array, one element array). * Aim to keep the time complexity as efficient as possible with the optimal gap sequence. # Example: ```python assert optimized_shell_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] assert optimized_shell_sort([1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1] assert optimized_shell_sort([]) == [] assert optimized_shell_sort([0]) == [0] ``` # Explanation: In the above examples: 1. The array `[5, 3, 8, 4, 2]` is sorted into `[2, 3, 4, 5, 8]`. 2. The array with identical elements `[1, 1, 1, 1, 1]` remains unchanged. 3. An empty array results in an empty array. 4. A single element array `[0]` remains as is. Ensure that the solution is clear, handles the edge cases properly, and implements the use of Sedgewick’s gaps to optimize the Shell Sort performance.","solution":"def optimized_shell_sort(arr): Sorts an array in non-decreasing order using the Shell Sort algorithm with Sedgewick\'s gap sequence. # Sedgewick\'s gap sequence for more optimized sorting gaps = [701, 301, 132, 57, 23, 10, 4, 1] n = len(arr) for gap in gaps: # Perform a gapped insertion sort for this gap size. # The first gap elements arr[0..gap-1] are already in gapped order. for i in range(gap, n): # Add arr[i] to the elements that have been gap sorted. # Save arr[i] in temp and make a hole at position i. temp = arr[i] # Shift earlier gap-sorted elements up until the correct location # for arr[i] is found. j = i while j >= gap and arr[j - gap] > temp: arr[j] = arr[j - gap] j -= gap # Put temp (the original arr[i]) in its correct location. arr[j] = temp return arr"},{"question":"You are given two lists of integers, `list1` and `list2`. Write a class `ZigZagIterator` that alternates between elements from `list1` and `list2` during iteration. If one list is exhausted before the other, subsequent elements should come from the remaining list. Implement the following functionalities: 1. **Constructor (`__init__`)**: Initializes the iterator with `list1` and `list2`. 2. **`next()` method**: Returns the next integer in the alternating sequence. 3. **`has_next()` method**: Returns a boolean indicating whether there are any more integers to return. # Input and Output - `__init__(list1, list2)` takes two lists of integers. - `next()` returns the next element in the zigzag iteration. - `has_next()` returns `True` if there are more elements to return, `False` otherwise. # Example ```python list1 = [1, 2] list2 = [3, 4, 5 ,6] iterator = ZigZagIterator(list1, list2) output = [] while iterator.has_next(): output.append(iterator.next()) print(output) ``` This should output: ``` [1, 3, 2, 4, 5, 6] ``` # Constraints - Elements will only be integers. - Lists can be of different lengths or even empty. - Ensure space complexity does not unnecessarily increase. Implement your solution in Python.","solution":"class ZigZagIterator: def __init__(self, list1, list2): self.list1 = list1 self.list2 = list2 self.index1 = 0 self.index2 = 0 self.turn = 0 # 0 for list1\'s turn, 1 for list2\'s turn def next(self): if not self.has_next(): raise Exception(\\"No more elements\\") if (self.turn == 0 and self.index1 < len(self.list1)) or self.index2 >= len(self.list2): result = self.list1[self.index1] self.index1 += 1 else: result = self.list2[self.index2] self.index2 += 1 self.turn = 1 - self.turn return result def has_next(self): return self.index1 < len(self.list1) or self.index2 < len(self.list2)"},{"question":"Given a root node of a binary tree, write a function to invert the binary tree. The function should modify the tree in place and should not return anything. Function Signature ```python def reverse(root): # Your implementation here ``` Input * `root`: A `TreeNode` object representing the root of the binary tree. It can be `None` if the tree is empty. Output * The function does not return anything. Instead, it modifies the tree in place. # Constraints 1. The number of nodes in the binary tree is in the range `[0, 1000]`. 2. The values of the nodes are arbitrary integers. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example Usage root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) reverse(root) # After calling reverse function, the tree should be inverted to: # 4 # / # 7 2 # / / # 9 6 3 1 ``` Handle edge cases such as: * An empty tree (`root` is `None`). * A tree with a single node. * A tree with only one sub-tree (either left or right).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root): Given a binary tree root, this function inverts the binary tree in place. if root is None: return # Swap the left and right child root.left, root.right = root.right, root.left # Recursively invert the left subtree if root.left: invert_tree(root.left) # Recursively invert the right subtree if root.right: invert_tree(root.right)"},{"question":"# Problem: Constructing an Optimal Road Network You are tasked with designing a road network for a new city. The city has `n` locations, and possible roads between these locations with given costs. Using Kruskal\'s Algorithm, write a function `construct_optimal_network(vertex_count, edges)` that computes the minimum total cost to connect all locations. If it is impossible to connect all locations, return `-1`. **Function Signature**: ```python def construct_optimal_network(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: ``` # Input: - `vertex_count (int)`: The number of locations in the city (vertices in the graph). - `edges (List[Tuple[int, int, int]])`: A list of tuples where each tuple contains three integers `u`, `v`, and `weight` representing a bidirectional road between locations `u` and `v` with the given cost `weight`. # Output: - `int`: The minimum total cost to connect all locations. Return `-1` if it is impossible to connect all locations. # Constraints: - `1 <= vertex_count <= 10^4` - `0 <= len(edges) <= 2 * 10^4` - `1 <= weight <= 10^6` # Example: ```python vertex_count = 5 edges = [ (1, 2, 3), (1, 3, 8), (2, 4, 5), (3, 4, 2), (3, 5, 4), (4, 5, 6) ] print(construct_optimal_network(vertex_count, edges)) # Output: 14 vertex_count = 3 edges = [ (2, 1, 20), (3, 1, 20), (2, 3, 100) ] print(construct_optimal_network(vertex_count, edges)) # Output: 40 ``` **Notes**: 1. You must handle the input to ensure that the vertices are zero-indexed when processing them internally, even if given as one-indexed. 2. You need to return the sum of the minimum spanning tree weights, or -1 if the MST cannot be formed due to disconnected components. **Hint**: Use Disjoint Set (Union-Find) with path compression and union by rank to optimize your algorithm.","solution":"from typing import List, Tuple def construct_optimal_network(vertex_count: int, edges: List[Tuple[int, int, int]]) -> int: # Union-Find class with path compression and union by rank class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 return True return False # Kruskal\'s Algorithm to find the MST cost edges.sort(key=lambda edge: edge[2]) uf = UnionFind(vertex_count) mst_cost = 0 edges_used = 0 for u, v, weight in edges: if uf.union(u - 1, v - 1): mst_cost += weight edges_used += 1 if edges_used == vertex_count - 1: return mst_cost return -1 if edges_used != vertex_count - 1 else mst_cost"},{"question":"You are a software developer working on geographic data processing for an environmental monitoring application. One of your tasks is to analyze the terrain map to identify distinct islands. An island is defined as a group of \'1\'s (land) connected 4-directionally (horizontal/vertical). The map is represented as a 2D grid of \'1\'s (land) and \'0\'s (water). **Objective**: Write a function `count_islands(grid: List[List[int]]) -> int` that returns the number of distinct islands on the given map. **Function Signature**: ```python def count_islands(grid: List[List[int]]) -> int: pass ``` **Input**: - `grid`: A 2D list of integers representing the map, where 1 represents land and 0 represents water. **Output**: - An integer representing the number of distinct islands. **Constraints**: - The grid dimensions are 1 <= m, n <= 10^3. - Elements of `grid` are `0` or `1` only. - The edges of the grid are surrounded by water. **Performance Requirements**: - Your solution should efficiently handle grids of sizes up to 1000x1000. - Aim to use O(m * n) time and space complexity. **Example**: ```python # Example 1 grid1 = [ [1, 1, 1, 1, 0], [1, 1, 0, 1, 0], [1, 1, 0, 0, 0], [0, 0, 0, 0, 0] ] assert count_islands(grid1) == 1 # Example 2 grid2 = [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 0, 1, 1] ] assert count_islands(grid2) == 3 ```","solution":"from typing import List def count_islands(grid: List[List[int]]) -> int: if not grid: return 0 rows, cols = len(grid), len(grid[0]) def dfs(row, col): if row < 0 or row >= rows or col < 0 or col >= cols or grid[row][col] == 0: return # Mark the cell as visited grid[row][col] = 0 # Recursively explore the neighbors dfs(row - 1, col) dfs(row + 1, col) dfs(row, col - 1) dfs(row, col + 1) island_count = 0 for r in range(rows): for c in range(cols): if grid[r][c] == 1: island_count += 1 dfs(r, c) return island_count"},{"question":"# Filtering Array by Limits # Problem Implement a function `limit(arr: List[int], min_lim: Union[int, None] = None, max_lim: Union[int, None] = None) -> List[int]` which filters the input list `arr` to include only the elements that are greater than or equal to `min_lim` and less than or equal to `max_lim`. Your solution should perform efficiently on large lists. # Input - `arr`: A list of integers. - `min_lim`: An integer or `None`, specifies the minimum limit. If `None`, no lower bound is enforced. - `max_lim`: An integer or `None`, specifies the maximum limit. If `None`, no upper bound is enforced. # Output - A list of integers containing only the elements from `arr` that are within the given limits. # Constraints - All elements in `arr` are integers. - The length of `arr` is between 0 and (10^6). # Edge Cases 1. `arr` is empty. 2. Both `min_lim` and `max_lim` are `None`. 3. All elements are less than `min_lim` or greater than `max_lim`. # Examples 1. Input: `arr = [1, 2, 3, 4, 5]`, `min_lim = None`, `max_lim = 3` - Output: `[1, 2, 3]` 2. Input: `arr = [1, 2, 3, 4, 5]`, `min_lim = 2`, `max_lim = None` - Output: `[2, 3, 4, 5]` 3. Input: `arr = [1, 2, 3, 4, 5]`, `min_lim = 2`, `max_lim = 4` - Output: `[2, 3, 4]` 4. Input: `arr = []`, `min_lim = 1`, `max_lim = 5` - Output: `[]` # Implementation Requirements - Your function should handle large inputs within a reasonable time, adhering to the O(n) time complexity. - If both `min_lim` and `max_lim` are `None`, return the original array. ```python from typing import List, Union def limit(arr: List[int], min_lim: Union[int, None] = None, max_lim: Union[int, None] = None) -> List[int]: # Your code here pass ```","solution":"from typing import List, Union def limit(arr: List[int], min_lim: Union[int, None] = None, max_lim: Union[int, None] = None) -> List[int]: Filters the input list to include only the elements that are within the given minimum and maximum limits. Parameters: arr (List[int]): The list of integers to be filtered. min_lim (Union[int, None]): The minimum limit. If None, no lower bound is enforced. max_lim (Union[int, None]): The maximum limit. If None, no upper bound is enforced. Returns: List[int]: A new list containing elements that fall within the specified limits. if min_lim is None and max_lim is None: return arr result = [] for num in arr: if (min_lim is not None and num < min_lim) or (max_lim is not None and num > max_lim): continue result.append(num) return result"},{"question":"Repeated Substring Pattern Context In many text processing tasks, it is crucial to identify repeated patterns within strings. One common problem is to determine if a string can be formed by repeating a smaller substring. Challenge Write a function, `check_repeated_substring`, that determines if a given non-empty string can be constructed by taking a substring of it and appending multiple copies of the substring together. Implementation Requirements - **Function Name**: `check_repeated_substring` - **Input**: A single `str` parameter, which is a non-empty string `s`. - **Output**: A single `boolean` indicating if the string can be constructed by repeating a substring (`True` or `False`). Examples - Example 1: - **Input**: `\\"abab\\"` - **Output**: `True` - **Explanation**: The string can be constructed by repeating the substring `\\"ab\\"` twice. - Example 2: - **Input**: `\\"aba\\"` - **Output**: `False` - Example 3: - **Input**: `\\"abcabcabcabc\\"` - **Output**: `True` - **Explanation**: The string can be constructed by repeating the substring `\\"abc\\"` four times. Constraints - The input string `s` should have a length in the range of [1, 10^4]. - The function should aim to provide an efficient solution in terms of both time and space complexity. Note Avoid using any built-in functions that directly solve the problem; instead, focus on string manipulation and pattern-matching techniques. Function Signature ```python def check_repeated_substring(s: str) -> bool: pass ```","solution":"def check_repeated_substring(s: str) -> bool: Determines if the given string can be constructed by repeating a substring. Parameters: s (str): The input string. Returns: bool: True if the string can be constructed by repeating a substring, otherwise False. n = len(s) for i in range(1, n // 2 + 1): if n % i == 0: # Check if i is a divisor of n substring = s[:i] if substring * (n // i) == s: return True return False"},{"question":"# Problem Description You are asked to implement an optimized version of the Merge Sort algorithm for sorting a list of integers. Your implementation should focus on efficiency and correctness while demonstrating a sound understanding of the merge sort process. Instead of using subarrays, you should use indices to minimize additional space usage. Additionally, you should implement a hybrid approach where the algorithm uses Insertion Sort for very small subarrays to potentially improve performance. # Function Signature ```python def hybrid_merge_sort(arr: List[int], threshold: int = 10) -> List[int]: pass ``` # Input - `arr`: A list of integers to be sorted. (0 <= len(arr) <= 10^5) - `threshold`: (optional) An integer value that determines the maximum size of subarrays for using Insertion Sort. Default value is 10. # Output - A list of integers sorted in non-decreasing order. # Constraints and Requirements 1. **Efficiency**: * The algorithm should have a time complexity of O(n log(n)) in general. * It should have a space complexity of O(n). 2. **Correctness**: * The implementation should handle all edge cases correctly. * Ensure that the algorithm is stable, preserving the order of equal elements. # Guidelines 1. **Hybrid Approach**: * Use Merge Sort for large subarrays. * Use Insertion Sort for subarrays of size <= `threshold` to optimize performance for smaller segments. 2. **Avoid excessive copying**: * Utilize indices to refer to subarrays instead of creating new arrays. 3. **Error Handling**: * Consider common edge cases such as empty arrays or arrays with a single element. # Example ```python print(hybrid_merge_sort([38, 27, 43, 3, 9, 82, 10])) # Output: [3, 9, 10, 27, 38, 43, 82] print(hybrid_merge_sort([1, 2, 2, 1, 0, 0])) # Output: [0, 0, 1, 1, 2, 2] print(hybrid_merge_sort([])) # Output: [] ``` # Additional Notes - Ensure your solution passes for larger input sizes up to 100,000 elements within a reasonable time frame. - You are encouraged to write unit tests to validate the correctness of your implementation.","solution":"from typing import List def insertion_sort(arr: List[int], left: int, right: int): for i in range(left + 1, right + 1): key = arr[i] j = i - 1 while j >= left and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def merge(arr: List[int], left: int, mid: int, right: int): n1 = mid - left + 1 n2 = right - mid L = arr[left:mid + 1] R = arr[mid + 1:right + 1] i = 0 j = 0 k = left while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 while i < n1: arr[k] = L[i] i += 1 k += 1 while j < n2: arr[k] = R[j] j += 1 k += 1 def hybrid_merge_sort(arr: List[int], threshold: int = 10): def sort(arr: List[int], left: int, right: int): if left < right: if right - left <= threshold: insertion_sort(arr, left, right) else: mid = (left + right) // 2 sort(arr, left, mid) sort(arr, mid + 1, right) merge(arr, left, mid, right) sort(arr, 0, len(arr) - 1) return arr"},{"question":"Given two singly linked lists, write a function that returns the node at which the two lists intersect. If the two linked lists have no intersection, return `None`. Implement the function `find_intersection(headA: Node, headB: Node) -> Node`. # Input * `headA` and `headB`: The heads of two singly linked lists. # Output * The node at which the two lists intersect, or `None` if no intersection exists. # Constraints * The number of nodes in both lists is (O(N + M)). * The values of the nodes do not uniquely identify the nodes; the nodes themselves are the identifiers. # Example Consider the following linked lists: ``` 1 -> 3 -> 5 7 -> 9 -> 11 / 2 -> 4 -> 6 ``` The function should return the node with the value `7`. # Notes * Ensure to handle edge cases like empty lists or when lists do not intersect. * Considering the linked list might terminate in a null node, the comparison should ensure node references, not values. # Functional Implementation ```python class Node: def __init__(self, x): self.val = x self.next = None def find_intersection(headA: Node, headB: Node) -> Node: # Edge case: if either head is None if not headA or not headB: return None # Get the lengths of both lists def get_length(head): length = 0 while head: length += 1 head = head.next return length lenA, lenB = get_length(headA), get_length(headB) long_head, short_head = (headA, headB) if lenA > lenB else (headB, headA) # Advance the longer head so both have equal remaining length for _ in range(abs(lenA - lenB)): long_head = long_head.next # Move both heads until they collide while long_head and short_head: if long_head == short_head: return long_head long_head = long_head.next short_head = short_head.next return None ``` Use the above structure to implement and test your solution.","solution":"class Node: def __init__(self, x): self.val = x self.next = None def find_intersection(headA: Node, headB: Node) -> Node: # Edge case: if either head is None if not headA or not headB: return None # Get the lengths of both lists def get_length(head): length = 0 while head: length += 1 head = head.next return length lenA, lenB = get_length(headA), get_length(headB) long_head, short_head = (headA, headB) if lenA > lenB else (headB, headA) # Advance the longer head so both have equal remaining length for _ in range(abs(lenA - lenB)): long_head = long_head.next # Move both heads until they collide while long_head and short_head: if long_head == short_head: return long_head long_head = long_head.next short_head = short_head.next return None"},{"question":"You are required to write a function `can_form_repeated_pattern` that takes a single non-empty string `s` as input. The function should determine if the string `s` can be constructed by taking a substring of it and appending multiple copies of the substring together. # Function Signature ```python def can_form_repeated_pattern(s: str) -> bool: ``` # Input - A single string `s` with length between 1 and 10^5, consisting of lowercase English letters. # Output - Return `True` if the given string can be constructed by repeating a substring of it. - Return `False` otherwise. # Examples ```python assert can_form_repeated_pattern(\\"abab\\") == True assert can_form_repeated_pattern(\\"aba\\") == False assert can_form_repeated_pattern(\\"abcabcabcabc\\") == True assert can_form_repeated_pattern(\\"a\\") == False assert can_form_repeated_pattern(\\"zzzz\\") == True ``` # Constraints - The input string length is between 1 and 100,000. - Can assume the input string consists only of lowercase English alphabets. # Hints - Consider creating a string by concatenating the input string to itself and removing the first and last characters. - Check if the original string appears as a substring within this modified string. - If yes, the original string can be constructed by repeating a substring, otherwise it cannot.","solution":"def can_form_repeated_pattern(s: str) -> bool: Determines if the given string can be constructed by taking a substring of it and appending multiple copies of the substring together. Args: s (str): The input string consisting of lowercase English letters. Returns: bool: True if the string can be constructed by repeating a substring, False otherwise. # Concatenate the string with itself and remove the first and last character s_double = (s + s)[1:-1] # Check if the original string is a substring of the new string return s in s_double"},{"question":"# Queue Implementation Challenge You are tasked with implementing a queue-based data structure capable of handling basic operations such as enqueue, dequeue, peek, and checking whether the queue is empty. Implement the queue using both an array-based approach (ArrayQueue) and a linked-list-based approach (LinkedListQueue). # Function Descriptions: Implement the following methods for both ArrayQueue and LinkedListQueue classes: 1. **enqueue(item)**: Adds an item to the rear of the queue. - **Input**: Integer or string `item`. - **Output**: None. 2. **dequeue()**: Removes and returns the front item from queue. If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". - **Input**: None. - **Output**: The item that was removed from the front of the queue. 3. **peek()**: Returns (but does not remove) the front item from the queue. If the queue is empty, raise an `IndexError` with the message \\"Queue is empty\\". - **Input**: None. - **Output**: The item at the front of the queue. 4. **is_empty()**: Returns `True` if the queue is empty, otherwise returns `False`. - **Input**: None. - **Output**: Boolean `True` or `False`. 5. **__len__()**: Returns the number of items in the queue. - **Input**: None. - **Output**: Integer representing the number of items in the queue. # Constraints: - For ArrayQueue, assume the initial capacity is 10. You must implement dynamic expansion of the array if it gets full. - The operations should maintain the expected constant time complexities where applicable. - The `dequeue` and `peek` methods should handle the case where the queue is empty by raising an `IndexError`. # Example Usage: ```python # ArrayQueue Example aQueue = ArrayQueue() aQueue.enqueue(10) aQueue.enqueue(20) print(aQueue.dequeue()) # Output: 10 print(aQueue.peek()) # Output: 20 print(aQueue.is_empty()) # Output: False print(len(aQueue)) # Output: 1 # LinkedListQueue Example lQueue = LinkedListQueue() lQueue.enqueue(30) lQueue.enqueue(40) print(lQueue.dequeue()) # Output: 30 print(lQueue.peek()) # Output: 40 print(lQueue.is_empty()) # Output: False print(len(lQueue)) # Output: 1 ```","solution":"# Array-based Queue Implementation class ArrayQueue: def __init__(self): self.queue = [] self.capacity = 10 self.size = 0 def enqueue(self, item): if self.size >= self.capacity: self.capacity *= 2 self.queue.append(item) self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.queue.pop(0) self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.queue[0] def is_empty(self): return self.size == 0 def __len__(self): return self.size # Linked list node for the LinkedListQueue class Node: def __init__(self, data): self.data = data self.next = None # Linked-list-based Queue Implementation class LinkedListQueue: def __init__(self): self.front = None self.rear = None self.size = 0 def enqueue(self, item): new_node = Node(item) if self.rear: self.rear.next = new_node self.rear = new_node if self.front is None: self.front = new_node self.size += 1 def dequeue(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") item = self.front.data self.front = self.front.next if self.front is None: self.rear = None self.size -= 1 return item def peek(self): if self.is_empty(): raise IndexError(\\"Queue is empty\\") return self.front.data def is_empty(self): return self.size == 0 def __len__(self): return self.size"},{"question":"# Question **String Reversal Algorithm Implementation** You are tasked with implementing a function to reverse a given string using a specified method. The method should be chosen based on the application needs and constraints provided. **Function Signature**: ```python def reverse_string(s: str, method: str) -> str: ``` **Input**: * `s` : A string to be reversed (1 ≤ |s| ≤ 1000). * `method`: A string specifying the method to use. It can be: * \'recursive\' * \'iterative\' * \'pythonic\' * \'ultra_pythonic\' **Output**: * Returns the reversed string based on the specified method. **Constraints**: * Ensure the provided method is one of the four specified. If an invalid method is provided, raise a `ValueError` with the message \\"Invalid method.\\" **Performance Requirements**: * The implementation must be efficient enough to handle the input size constraints within a reasonable time limit, given the maximum string length is 1000. **Scenario**: Imagine you are developing a text editor that needs to support different kinds of string manipulations, including reversing. The users can choose their preferred reversal method for better performance tuning and educational purposes. Implement the function to correctly reverse the string as specified. **Example**: ```python # Example usage: reverse_string(\\"hello\\", \\"iterative\\") # returns \\"olleh\\" reverse_string(\\"world\\", \\"ultra_pythonic\\") # returns \\"dlrow\\" reverse_string(\\"python\\", \\"pythonic\\") # returns \\"nohtyp\\" reverse_string(\\"example\\", \\"recursive\\") # returns \\"elpmaxe\\" ``` Implement the `reverse_string` function considering the given guidelines.","solution":"def reverse_string(s: str, method: str) -> str: Reverses a string based on the specified method. Parameters: s (str): The string to be reversed. method (str): The method to use for reversal. One of \'recursive\', \'iterative\', \'pythonic\', \'ultra_pythonic\'. Returns: str: The reversed string. if method == \'recursive\': return _reverse_recursive(s) elif method == \'iterative\': return _reverse_iterative(s) elif method == \'pythonic\': return _reverse_pythonic(s) elif method == \'ultra_pythonic\': return _reverse_ultra_pythonic(s) else: raise ValueError(\\"Invalid method.\\") def _reverse_recursive(s: str) -> str: if len(s) == 0: return s else: return s[-1] + _reverse_recursive(s[:-1]) def _reverse_iterative(s: str) -> str: result = \\"\\" for char in s: result = char + result return result def _reverse_pythonic(s: str) -> str: return \'\'.join(reversed(s)) def _reverse_ultra_pythonic(s: str) -> str: return s[::-1]"},{"question":"# Fibonacci Focus You are tasked with writing an optimized function to compute the nth Fibonacci number using matrix exponentiation. This method should maintain a polynomial time complexity. The Fibonacci numbers are defined as: - F0 = 0, F1 = 1 - Fn = Fn-1 + Fn-2 for n > 1 Matrix exponentiation allows us to compute large Fibonacci numbers efficiently using the properties of matrix multiplication and exponentiation by squaring. Write a function `fib_matrix(n)` which will compute the nth Fibonacci number using the matrix exponentiation technique. You should consider edge cases and performance requirements for very large values of n. **Function Signature** ```python def fib_matrix(n: int) -> int: pass ``` **Input** - An integer `n`, where `0 <= n <= 10^18`. **Output** - The nth Fibonacci number. **Example** ```python assert fib_matrix(0) == 0 assert fib_matrix(1) == 1 assert fib_matrix(10) == 55 assert fib_matrix(100) == 354224848179261915075 ``` **Constraints** - Your solution should run efficiently for very large values of n (up to 10^18). **Hints** - Use matrix exponentiation to solve the problem. - The characteristic matrix for Fibonacci numbers is `[[1, 1], [1, 0]]`.","solution":"def matrix_mult(A, B): Multiplies two 2x2 matrices. return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(M, power): Exponentiates matrix M to the given power using exponentiation by squaring. result = [[1, 0], [0, 1]] # Identity matrix base = M while power: if power % 2: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result def fib_matrix(n): Computes the nth Fibonacci number using matrix exponentiation. if n == 0: return 0 elif n == 1: return 1 F = [[1, 1], [1, 0]] F_n_minus_1 = matrix_pow(F, n - 1) # The nth Fibonacci number is in F_n_minus_1[0][0] return F_n_minus_1[0][0]"},{"question":"**Problem Statement:** You are given an array of integers where every element appears exactly three times except for one element which appears exactly once. Write a function `findUnique(nums)` to identify the element that appears only once. # Input: * `nums`: List[int] - An array of integers. # Output: * int - The integer that appears exactly once. # Constraints: * The size of the array is at least 4 and at most (10^5). * Every element in the array is a 32-bit integer. * One element appears exactly once, and all other elements appear exactly three times. # Performance Requirement: * Your solution must run in linear time, O(n). * Your solution must use constant space, O(1). # Example: ```python assert findUnique([2, 2, 3, 2]) == 3 assert findUnique([0, 1, 0, 1, 0, 1, 99]) == 99 ``` # Guidance: * Avoid using extra memory beyond the input array and a few integer variables. * Think about how bit manipulation might help you in maintaining a tally of the set bits.","solution":"def findUnique(nums): Finds the unique element that appears only once in the array where every other element appears exactly three times. ones, twos = 0, 0 for num in nums: # Update `ones` ones = (ones ^ num) & ~twos # Update `twos` twos = (twos ^ num) & ~ones return ones"},{"question":"# Gnome Sort in Practice Background Gnome Sort is a simple, intuitive sorting algorithm that is not efficient for large datasets but can be useful for educational purposes or when sorting trivially small datasets. The algorithm employs a series of comparisons and swaps to ensure the array is ordered. Task Implement the `gnome_sort` function that sorts a list of integers using the Gnome Sort algorithm. After implementing the sort function, write a secondary function `sorted_index_positions` that takes a list of integers and returns a list of indices showing the new positions of the elements in the sorted list. Function Signature ```python def gnome_sort(arr: List[int]) -> List[int]: pass def sorted_index_positions(arr: List[int]) -> List[int]: pass ``` Input - `arr` (List[int]): A list of integers (the length of `arr` will not exceed 10^3). Output - `gnome_sort`: Returns a sorted list of integers. - `sorted_index_positions`: Returns a list of integers indicating the new positions of the elements from the original list in the sorted list. Example ```python print(gnome_sort([34, 2, 78, 1, 58])) # Output: [1, 2, 34, 58, 78] print(sorted_index_positions([34, 2, 78, 1, 58])) # Output: [3, 1, 0, 4, 2] ``` Constraints - Implement the gnome sort algorithm from scratch. - Do not use built-in sorting functions. - Focus on clarity and efficiency appropriate for small lists.","solution":"def gnome_sort(arr): Sorts a list of integers using the Gnome Sort algorithm. index = 0 while index < len(arr): if index == 0 or arr[index] >= arr[index - 1]: index += 1 else: arr[index], arr[index - 1] = arr[index - 1], arr[index] index -= 1 return arr def sorted_index_positions(arr): Returns a list of indices showing the new positions of the elements in the sorted list. original_indices = list(range(len(arr))) combined = list(zip(arr, original_indices)) # Sort combined list based on the values sorted_combined = gnome_sort(combined) # Extract new indices new_positions = [index for value, index in sorted_combined] return new_positions"},{"question":"# Matrix Transformation Challenge Problem Statement Consider a 2D matrix of integers. Implement the following transformation functions: 1. `rotate_clockwise(matrix)`: Rotates the given matrix 90 degrees clockwise. 2. `rotate_counterclockwise(matrix)`: Rotates the given matrix 90 degrees counterclockwise. 3. `top_left_invert(matrix)`: Inverts the matrix from the top-left to the bottom-right. 4. `bottom_left_invert(matrix)`: Inverts the matrix from the bottom-left to the top-right. Input * A 2D list representing the matrix, where each sublist is a row. The matrix can have any size, including empty matrices. Output * A new 2D list representing the transformed matrix. Constraints * The matrix dimensions will be between 0 and 1000 inclusive. * The matrix elements will be integers between -10^6 and 10^6 inclusive. Examples ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] # Rotate clockwise rotate_clockwise(matrix) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Rotate counterclockwise rotate_counterclockwise(matrix) # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] # Top left invert top_left_invert(matrix) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] # Bottom left invert bottom_left_invert(matrix) # Output: # [ # [9, 6, 3], # [8, 5, 2], # [7, 4, 1] # ] ``` Requirements * Your solution should handle edge cases effectively, such as empty matrices or single row/column matrices. * Focus on minimizing time and space complexity where possible.","solution":"def rotate_clockwise(matrix): Rotates the given matrix 90 degrees clockwise. return [list(row) for row in zip(*matrix[::-1])] def rotate_counterclockwise(matrix): Rotates the given matrix 90 degrees counterclockwise. return [list(row) for row in zip(*matrix)][::-1] def top_left_invert(matrix): Inverts the matrix from the top-left to the bottom-right. return [list(row) for row in zip(*matrix)] def bottom_left_invert(matrix): Inverts the matrix from the bottom-left to the top-right. return [list(row) for row in zip(*matrix[::-1])][::-1]"},{"question":"# Problem: Implement the Cycle Sort algorithm to sort an array of distinct integers. # Function Signature: ```python def cycle_sort(arr: List[int]) -> List[int]: ``` # Input: - `arr` : List[int] - A list of distinct integers. # Output: - Returns the sorted list of integers. # Constraints: - The list `arr` will have a length in the range [1, 1000]. - All integers in the list will be distinct and within the range [-10^6, 10^6]. # Performance Requirements: - The algorithm should sort the list in-place. - Minimize the number of write operations to the minimum necessary to achieve the sort. # Scenario: You are a database engineer working on optimizing the performance of data write operations on a NAND flash memory chip. Each write operation reduces the life of a memory cell. Therefore, minimizing write operations is crucial. Implement Cycle Sort to ensure this optimization. # Example: Input: ```python cycle_sort([3, 5, 2, 1, 4]) ``` Output: ```python [1, 2, 3, 4, 5] ``` Explanation: The function should sort the input list `[3, 5, 2, 1, 4]` in ascending order using the Cycle Sort algorithm. # Notes: 1. Handle the core Cycle Sort logic as outlined in the provided analysis. 2. The function should not use any built-in sorting functions. 3. Focus on minimizing the number of write operations to the array.","solution":"def cycle_sort(arr): A function to sort a list using Cycle Sort. writes = 0 # Loop through the array to find cycles to rotate for cycle_start in range(0, len(arr) - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item there or right after any duplicates while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: # Find where to put the element pos = cycle_start for i in range(cycle_start + 1, len(arr)): if arr[i] < item: pos += 1 # Put the item there or right after any duplicates while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Context Given a range of numbers, we are looking for special numbers. A number is considered \\"special\\" if it can be written as the sum of its digits each raised to the power of their positions. Task Write a function `find_special_numbers(start, end)` that finds all special numbers within the inclusive range `[start, end]` where the sum of its digits each raised to the power of their respective positions results in the number itself. Input - `start`: an integer representing the starting range (1 ≤ start ≤ end ≤ 10^6). - `end`: an integer representing the ending range. Output - Return a list of integers which are the special numbers within the given range `[start, end]`. Example ```python def find_special_numbers(start, end): # Your code goes here # Example Usage: assert find_special_numbers(1, 10) == [1, 2, 3, 4, 5, 6, 7, 8, 9] assert find_special_numbers(10, 150) == [89, 135] ``` Constraints - Your implementation should aim for an optimized solution given the potential size of the range. - Handle edge cases such as the single-digit numbers correctly. - Ensure code readability and proper commenting for understanding your logic.","solution":"def find_special_numbers(start, end): Finds all special numbers within the inclusive range [start, end]. A number is considered \\"special\\" if it can be written as the sum of its digits each raised to the power of their positions. :param start: int: starting range (inclusive) :param end: int: ending range (inclusive) :return: list of special numbers within the range def is_special(num): Determines if a number is special. digits = list(map(int, str(num))) return num == sum(digit ** (i + 1) for i, digit in enumerate(digits)) return [num for num in range(start, end + 1) if is_special(num)]"},{"question":"Problem Statement You are provided with an ordered (sorted) list of integers and a target integer to be searched within that list. Implement the function `efficient_jump_search`, which improves upon Jump Search by optimizing block sizes dynamically to reduce comparison overhead. Your function should locate the position of the target integer efficiently. # Function Signature ```python def efficient_jump_search(arr: List[int], target: int) -> int: ``` # Input * `arr` (List[int]): A sorted list of integers with values in non-decreasing order. The length of the list will be between 1 and 10^6 (inclusive). * `target` (int): An integer that you need to find in the list. # Output * Return an integer representing the index of the first occurrence of the `target` in the list. If the `target` is not found, return -1. # Constraints * All integers in the list fit within the range of [-10^9, 10^9]. * The list is guaranteed to be sorted in non-decreasing order. * Optimize the algorithm to handle large arrays efficiently. # Example ```python assert efficient_jump_search([1, 2, 4, 5, 7, 8, 10], 5) == 3 assert efficient_jump_search([1, 2, 4, 5, 7, 8, 10], 6) == -1 assert efficient_jump_search([10, 20, 30, 40, 50, 60, 70, 80, 90, 100], 70) == 6 ``` # Notes * Consider edge cases such as the `target` being the smallest or largest integer in the list. * Achieve efficient performance, potentially exploring using dynamically optimized block sizes or hybrid approaches.","solution":"from typing import List import math def efficient_jump_search(arr: List[int], target: int) -> int: Perform an efficient jump search with dynamic block sizes to locate the target integer. n = len(arr) if n == 0: return -1 # Finding the optimal block size to step block_size = int(math.sqrt(n)) prev = 0 # Finding the block where the target could be while prev < n and arr[min(block_size, n) - 1] < target: prev = block_size block_size += int(math.sqrt(n)) if prev >= n: return -1 # Performing a linear search within the block for i in range(prev, min(block_size, n)): if arr[i] == target: return i return -1"},{"question":"# Hamming Weight Calculation Challenge Scenario You are developing a bitwise operation tool for a network security application that needs to frequently compute the Hamming weight (number of \'1\' bits) in binary representations of various unsigned integers. To ensure the efficiency and reliability of your tool, you need to implement a function that performs this calculation optimally. Task Write a function `hamming_weight(n: int) -> int` that takes an unsigned integer `n` and returns the number of \'1\' bits in its binary representation. Requirements: 1. Implement both an **iterative** and a **recursive** approach. 2. Use Brian Kernighan\'s algorithm, given its efficiency. 3. The function should handle large inputs within reasonable time and memory limits. **Function Signature**: ```python def hamming_weight(n: int) -> int: ``` Input * An unsigned integer `n` (0 ≤ n ≤ 2^31 - 1). Output * An integer representing the number of \'1\' bits in the binary representation of `n`. Constraints * You must use the specific algorithm provided (Brian Kernighan\'s algorithm). * Avoid the use of any built-in functions for directly counting bits (e.g., `bin()`, `count()`). Example ```python assert hamming_weight(11) == 3 # Binary: 00000000000000000000000000001011 assert hamming_weight(128) == 1 # Binary: 00000000000000000000000010000000 assert hamming_weight(255) == 8 # Binary: 00000000000000000000000011111111 assert hamming_weight(1023) == 10 # Binary: 00000000000000000000001111111111 assert hamming_weight(0) == 0 # Binary: 00000000000000000000000000000000 ```","solution":"def hamming_weight(n: int) -> int: Returns the number of \'1\' bits in the binary representation of n using Brian Kernighan\'s algorithm. count = 0 while n: n &= (n - 1) count += 1 return count"},{"question":"# Quick Sort Implementation Task You are tasked with implementing the Quick Sort algorithm. This algorithm should sort an array of integers in ascending order. Function Signature: ```python def quick_sort(arr: List[int]) -> List[int]: ``` Input: - `arr` (List[int]): A list of integers to be sorted. Output: - Returns a list of integers sorted in ascending order. Constraints: - The length of the list `n` is (1 leq n leq 10^4). - All elements in the list are integers within the range ([-10^9, 10^9]). Requirements: 1. Your implementation should use the in-place Quick Sort algorithm. 2. Write a helper function `partition(arr, low, high)` that partitions the array and returns the pivot index. 3. You may implement any strategy for pivot selection, but a good choice can help optimize the performance. 4. Your solution should avoid excessive memory usage and handle large lists efficiently. Example: ```python Input: [3, 6, 8, 10, 1, 2, 1] Output: [1, 1, 2, 3, 6, 8, 10] Input: [1] Output: [1] Input: [9, -3, 5, 2, 6, 8, -6, 1, 3] Output: [-6, -3, 1, 2, 3, 5, 6, 8, 9] ``` Note: For this task: - Focus on the correctness and efficiency of your implementation. - Consider edge cases such as empty array or array with a single element. Good luck!","solution":"from typing import List def quick_sort(arr: List[int]) -> List[int]: Sorts the given array using the Quick Sort algorithm and returns the sorted array. def partition(arr, low, high): pivot = arr[high] # Choosing the last element as the pivot i = low - 1 # Index of the smaller element for j in range(low, high): if arr[j] <= pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 def quick_sort_helper(arr, low, high): if low < high: pi = partition(arr, low, high) quick_sort_helper(arr, low, pi - 1) quick_sort_helper(arr, pi + 1, high) quick_sort_helper(arr, 0, len(arr)-1) return arr"},{"question":"You are given a singly linked list where each node contains a character. Your task is to implement a function to remove duplicates from the list while preserving the original order of unique elements. You need to implement two variants of this function: 1. `remove_dups(head)` - This version should remove duplicates using additional memory (like a hash set), achieving linear time complexity. 2. `remove_dups_without_set(head)` - This variant should not use any extra memory, achieving constant space complexity but may have higher time complexity. # Input * A singly linked list where each node contains a `val` (string of length 1) and a `next` pointer. * `head`: The head node of the linked list. # Output * The function should modify the linked list in place. * There is no return value; the modified list should reflect changes directly. * You may provide a helper function to print the list to verify results. # Constraints * The list nodes will only contain lowercase alphabets \'a\' to \'z\'. * The maximum number of nodes in the linked list is 1000. # Example Given the linked list: ``` a -> a -> b -> c -> d -> c -> f -> g ``` After calling `remove_dups(head)`, the linked list should become: ``` a -> b -> c -> d -> f -> g ``` And after calling `remove_dups_without_set(head)` on the original list, the result should be the same: ``` a -> b -> c -> d -> f -> g ``` # Instructions 1. Implement both functions below. 2. Provide helper functions as necessary to aid in testing/debugging.","solution":"class ListNode: def __init__(self, val=\'\'): self.val = val self.next = None def remove_dups(head): Removes duplicates from the linked list using extra space. if head is None: return seen = set() current = head seen.add(current.val) while current.next is not None: if current.next.val in seen: current.next = current.next.next else: seen.add(current.next.val) current = current.next def remove_dups_without_set(head): Removes duplicates from the linked list without using extra space. if head is None: return current = head while current is not None: runner = current while runner.next is not None: if runner.next.val == current.val: runner.next = runner.next.next else: runner = runner.next current = current.next def create_linked_list(values): Helper function to create a linked list from a list of values. if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def to_list(head): Helper function to convert a linked list back into a list of values. result = [] current = head while current is not None: result.append(current.val) current = current.next return result # Example usage: # head = create_linked_list([\\"a\\", \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"c\\", \\"f\\", \\"g\\"]) # remove_dups(head) # print(to_list(head)) # Output should be [\'a\', \'b\', \'c\', \'d\', \'f\', \'g\'] # head = create_linked_list([\\"a\\", \\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"c\\", \\"f\\", \\"g\\"]) # remove_dups_without_set(head) # print(to_list(head)) # Output should be [\'a\', \'b\', \'c\', \'d\', \'f\', \'g\']"},{"question":"You are tasked with implementing an efficient algorithm to compute the n-th Fibonacci number. Given a positive integer ( n ), your objective is to determine ( F_n ). Use dynamic programming to ensure your solution is optimized for performance. Input * An integer ( n ) (0 ≤ ( n ) ≤ 10^7). Output * The integer corresponding to the n-th Fibonacci number. # Constraints * Your solution should be optimized for both time and space. * Handle large values of ( n ) up to 10^7 efficiently. * Consider edge cases such as ( n = 0 ) and ( n = 1 ). # Example ```python assert fibonacci(0) == 0 assert fibonacci(1) == 1 assert fibonacci(10) == 55 assert fibonacci(50) == 12586269025 ``` Function Signature ```python def fibonacci(n: int) -> int: # Your code goes here ``` # Explanation: Your task is to implement the `fibonacci` function such that it computes the Fibonacci sequence efficiently up to very large values. Ensure optimal time and space complexities while maintaining accuracy. Avoid naive recursive approaches which are inefficient for large ( n ).","solution":"def fibonacci(n: int) -> int: Returns the n-th Fibonacci number using an iterative approach to ensure efficiency. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"You have been hired to develop a feature for a grant allocation module in a financial application. The module needs to find all possible ways to allocate funds (=target) from a set of grant amounts (=candidates). Each candidate can be used multiple times. # Problem Description You are given an array of positive integers `candidates` with no duplicates and a target integer `target`. Your task is to implement a function `find_grant_combinations()` that finds all unique combinations in `candidates` where the numbers sum up to the `target`. Each number in `candidates` may be used unlimited times in the combination. # Function Signature ```python def find_grant_combinations(candidates: List[int], target: int) -> List[List[int]]: # your code here ``` # Input - `candidates`: List of integers > 0, with length n (1 ≤ n ≤ 30). - `target`: A positive integer ≤ 500. # Output - Returns a list of lists, where each inner list represents a unique combination summing up to the target. - The order of combinations in the output does not matter. # Constraints - The solution should not have duplicate combinations. - The combination elements must be in non-descending order. # Example Example 1: ```python candidates = [2, 3, 6, 7] target = 7 find_grant_combinations(candidates, target) # Expected Output: [[7], [2, 2, 3]] ``` Example 2: ```python candidates = [5, 10, 12] target = 15 find_grant_combinations(candidates, target) # Expected Output: [[5, 5, 5], [5, 10]] ``` # Note 1. All numbers, including the target, are positive integers. 2. The solution set must not contain duplicate combinations.","solution":"from typing import List def find_grant_combinations(candidates: List[int], target: int) -> List[List[int]]: def backtrack(rem_target, start, path): if rem_target == 0: result.append(list(path)) return for i in range(start, len(candidates)): if candidates[i] > rem_target: break path.append(candidates[i]) backtrack(rem_target - candidates[i], i, path) path.pop() candidates.sort() result = [] backtrack(target, 0, []) return result"},{"question":"RSA Public Key Cryptosystem Context The RSA public key cryptosystem heavily relies on number theory and concepts such as the Extended Euclidean Algorithm and Modular Inverse. Given two large prime numbers p and q, the RSA algorithm involves calculating the public and private keys for secure communication. Problem Statement Implement a function to generate RSA public and private keys based on two given prime numbers. Use the Extended Euclidean Algorithm to calculate the modular inverse required for generating the private key. Function Signature ```python def generate_rsa_keys(p: int, q: int) -> (int, int, int): Generate RSA keys given two prime numbers p and q. Args: p (int): A prime number. q (int): A prime number. Returns: (public_key, private_key, n): A tuple containing the public key, private key, and n. ``` Input - `p`: A prime number. - `q`: A prime number. Output - A tuple `(public_key, private_key, n)` which includes: - `public_key`: The RSA public key (e). - `private_key`: The RSA private key (d). - `n`: The modulus (n = p * q). Constraints - 1 < p, q < 10^9 - p and q are prime. Example ```python p = 17 q = 23 print(generate_rsa_keys(p, q)) # Example output: (65537, 2753, 391) ``` Requirements 1. Calculate n = p * q. 2. Calculate Euler\'s totient φ(n) = (p-1)*(q-1). 3. Choose an integer `e` such that 1 < e < φ(n) and gcd(e, φ(n)) = 1. A common choice for `e` is 65537. 4. Calculate the modular inverse `d` of `e` with respect to φ(n), such that e*d ≡ 1 (mod φ(n)). 5. Return the tuple (public_key, private_key, n). Notes - You may assume that the provided prime numbers `p` and `q` are valid and distinct.","solution":"def gcd(a, b): while b != 0: a, b = b, a % b return a def extended_gcd(a, b): if a == 0: return b, 0, 1 gcd, x1, y1 = extended_gcd(b % a, a) x = y1 - (b // a) * x1 y = x1 return gcd, x, y def modular_inverse(a, m): gcd, x, _ = extended_gcd(a, m) if gcd != 1: raise ValueError(\'Modular inverse does not exist\') return x % m def generate_rsa_keys(p, q): n = p * q phi_n = (p - 1) * (q - 1) e = 65537 # Common choice for e if gcd(e, phi_n) != 1: raise ValueError(\'e and φ(n) are not coprime\') d = modular_inverse(e, phi_n) return e, d, n"},{"question":"Context: You’ve been tasked with developing an efficient function to organize data in a list by moving all occurrences of zero to the end. The function should leave the order of other elements unaffected. This task is common in data cleaning stages before analysis or machine learning model application. Problem: Write a function called `move_zeros_to_end` that takes an input list and reorders it such that all zero elements are moved to the end of the list, while the order of all other elements is maintained. Requirements: - Non-zero elements in the list should retain their original order. - The function needs to handle various data types within the list. - Boolean `False` and numeric `0` should be treated differently; only numeric zeros should be moved. - The solution should be efficient in terms of time complexity (O(n) is expected). Function Signature: ```python def move_zeros_to_end(arr: list) -> list: pass ``` Input: - A list `arr` containing various data types and possibly zero integers. Output: - A list where all zero integers are moved to the end, with the order of non-zero elements preserved. Examples: ```python print(move_zeros_to_end([False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"])) # Output: [False, 1, 1, 2, 1, 3, \'a\', 0, 0] print(move_zeros_to_end([0, 0, 0, \'b\', \'c\'])) # Output: [\'b\', \'c\', 0, 0, 0] print(move_zeros_to_end([4, 5, 6])) # Output: [4, 5, 6] print(move_zeros_to_end([])) # Output: [] ``` Constraints: - The input list `arr` can contain up to 10^6 elements. - Elements in `arr` can be of any data type. Notes: - Make sure the function works in linear time. - Minimize additional space usage if possible, but correctness is the first priority.","solution":"def move_zeros_to_end(arr: list) -> list: This function moves all zero elements in a list to the end, while preserving the order of non-zero elements. Args: arr (list): The input list which may contain zeros. Returns: list: A list where all zero elements are moved to the end. # Initialize two lists to separate non-zeros and zeros non_zeros = [] zeros = [] # Iterate through the list and categorize elements into non-zeros and zeros for element in arr: if element == 0 and type(element) in (int, float): # Check for numeric zeros only zeros.append(element) else: non_zeros.append(element) # Concatenate non-zeros with zeros return non_zeros + zeros"},{"question":"You are an experienced security consultant tasked with improving the performance of a robbery simulation system. Your goal is to enhance the \\"house robber\\" algorithm to determine the maximum amount of money that can be robbed from a series of houses arranged sequentially. Each house has a certain amount of money stashed. The key constraint is that two adjacent houses cannot be robbed on the same night because they have an interconnected security system. # Specification Write a function `house_robber(houses)` that takes as input a list of non-negative integers, where each integer represents the amount of money in a house. Your function should return the maximum amount of money you can rob without triggering alarms by robbing two consecutive houses. # Input Format - A list of non-negative integers `houses` (0 <= len(houses) <= 10^4, 0 <= houses[i] <= 10^4). # Output Format - Return a single integer, representing the maximum amount of money that can be robbed without tripping the alarms. # Constraints - You are guaranteed that all the inputs will meet the problem constraints. - Try to achieve the solution with time complexity of O(n) and space complexity of O(1). # Example ```python assert house_robber([2, 3, 2]) == 4 assert house_robber([1, 2, 3, 1]) == 4 assert house_robber([0]) == 0 assert house_robber([]) == 0 assert house_robber([2, 7, 9, 3, 1]) == 12 ``` # Explanation 1. **Example 1**: Rob houses with value [2] and [2], total amount = 4. 2. **Example 2**: Rob houses with value [1] and [3], total amount = 4. 3. **Example 3**: Only one house with 0 stashed, return 0. 4. **Example 4**: No house to rob, return 0. 5. **Example 5**: Rob houses with value [2], [9], [1], total amount = 12. Your task is to implement the function `house_robber(houses)`.","solution":"def house_robber(houses): Determine the maximum amount of money that can be robbed without triggering alarms by robbing two consecutive houses. :param houses: List[int] - a list of non-negative integers representing the amount of money in each house :return: int - the maximum amount that can be robbed n = len(houses) if n == 0: return 0 elif n == 1: return houses[0] prev2 = 0 # Money robbed from house before the previous one prev1 = 0 # Money robbed from the previous house for money in houses: current = max(prev1, prev2 + money) prev2 = prev1 prev1 = current return prev1"},{"question":"# Question: Implementing an Optimized Topological Sort # Context You are tasked with writing code that can determine a topologically sorted order of tasks based on their dependencies. # Problem Statement Given a Directed Acyclic Graph (DAG) representing tasks and their dependency relationships, implement a function `topological_sort(graph)` that returns a list of tasks in a valid topological order. If the given graph contains cycles, the function should raise a `ValueError`. # Function Signature ```python def topological_sort(graph: Dict[int, List[int]]) -> List[int]: pass ``` # Input * `graph`: A dictionary where keys are task IDs (integers) and values are lists of task IDs that depend on the key task. # Output * Returns a list of integers representing the topologically sorted order of task IDs. # Constraints * The input graph is guaranteed to be a DAG. * Nodes (task IDs) are non-negative integers. # Example ```python # Example 1 graph1 = { 5: [2, 0], 4: [0, 1], 3: [1], 2: [3], 1: [], 0: [] } print(topological_sort(graph1)) # Possible output: [5, 4, 2, 3, 1, 0] # Example 2 graph2 = { 1: [2], 2: [3], 3: [] } print(topological_sort(graph2)) # Possible output: [1, 2, 3] # Example 3 graph3 = { 1: [2], 2: [1] } try: topological_sort(graph3) except ValueError as e: print(str(e)) # Output: \\"cycle\\" ``` # Notes - Raise a `ValueError` with the message \\"cycle\\" if a cycle is detected in the graph. - Your implementation should handle large graphs efficiently. # Requirements - Implement your solution using both recursive and iterative approaches. - Provide sufficient comments and documentation to explain your code.","solution":"from typing import List, Dict from collections import deque, defaultdict def topological_sort(graph: Dict[int, List[int]]) -> List[int]: Perform topological sort on a directed acyclic graph (DAG). :param graph: Dictionary representing the graph where keys are task IDs and values are lists of dependent task IDs. :return: List of integers representing the topologically sorted order of task IDs. :raises ValueError: If a cycle is detected in the graph. in_degree = {u: 0 for u in graph} # Initialize in-degree of all vertices to 0 for u in graph: for v in graph[u]: in_degree[v] += 1 # Calculate in-degree queue = deque([u for u in graph if in_degree[u] == 0]) # Collect all nodes with in-degree 0 topological_order = [] while queue: u = queue.popleft() # Remove a node with in-degree 0 topological_order.append(u) for v in graph[u]: in_degree[v] -= 1 # Decrease in-degree for all adjacent nodes if in_degree[v] == 0: queue.append(v) # If in-degree becomes 0, add to queue if len(topological_order) == len(graph): return topological_order else: raise ValueError(\\"cycle\\") # If topological order doesn\'t include all nodes, a cycle must exist"},{"question":"# Merge Sort Implementation and Custom Application Scenario You are tasked to implement custom sorting for a library. The library management system maintains records of books, where each book has attributes like title, author, and year of publication. For specific use cases, you need to sort the list of books based on the author\'s name and, in case of ties, by the year of publication in descending order. Implement a modified merge sort algorithm that sorts the books accordingly. Here’s a function signature you need to follow: ```python def merge_sort_books(books): Sorts a list of books based on the author\'s name and then by year of publication. Parameters: books (list): A list of dictionaries, each dictionary contains \'title\', \'author\', and \'year\'. Returns: list: The sorted list of books. # Your code here ``` Input and Output Format * **Input**: A list of dictionaries, where each dictionary contains: - \'title\': a string representing the book\'s title. - \'author\': a string representing the book\'s author. - \'year\': an integer representing the year of publication. * **Output**: A list of dictionaries sorted by the following criteria: - First by \'author\' in lexicographic order. - In case of ties, by \'year\' in descending order. Constraints - The length of the input list, `n`, will be between 0 and 10^5. - The length of the title and author strings will not exceed 100 characters. - The year of publication will be a positive integer. Example ```python books = [ {\'title\': \'Book A\', \'author\': \'Author X\', \'year\': 2005}, {\'title\': \'Book B\', \'author\': \'Author A\', \'year\': 2010}, {\'title\': \'Book C\', \'author\': \'Author X\', \'year\': 2001} ] sorted_books = merge_sort_books(books) # Expected Output: # [ # {\'title\': \'Book B\', \'author\': \'Author A\', \'year\': 2010}, # {\'title\': \'Book A\', \'author\': \'Author X\', \'year\': 2005}, # {\'title\': \'Book C\', \'author\': \'Author X\', \'year\': 2001} # ] ``` Notes - Ensure that your implementation minimizes the additional memory usage. - Handle edge cases like empty input list or list with a single book. - The solution should leverage the merge sort algorithm correctly to handle large input efficiently.","solution":"def merge_sort_books(books): Sorts a list of books based on the author\'s name and then by year of publication. Parameters: books (list): A list of dictionaries, each dictionary contains \'title\', \'author\', and \'year\'. Returns: list: The sorted list of books. def merge(left, right): sorted_books = [] while left and right: if left[0][\'author\'] < right[0][\'author\']: sorted_books.append(left.pop(0)) elif left[0][\'author\'] > right[0][\'author\']: sorted_books.append(right.pop(0)) else: if left[0][\'year\'] > right[0][\'year\']: sorted_books.append(left.pop(0)) else: sorted_books.append(right.pop(0)) sorted_books.extend(left if left else right) return sorted_books def merge_sort(books_list): if len(books_list) <= 1: return books_list mid = len(books_list) // 2 left_half = merge_sort(books_list[:mid]) right_half = merge_sort(books_list[mid:]) return merge(left_half, right_half) return merge_sort(books)"},{"question":"Generate All Possible Subsets Given a set of distinct integers `nums`, write a function `generate_subsets(nums)` that returns all possible subsets (the power set). Input * A list of distinct integers `nums`. * `1 <= len(nums) <= 10` * `-10 <= nums[i] <= 10` Output * A list of lists, where each list is a subset of `nums`. Constraints * Elements in a subset must be in non-descending order (sorted). * The output list should not contain duplicate subsets. * The subsets can be returned in any order. # Example **Example 1:** ```python generate_subsets([1, 2, 3]) ``` **Output:** ``` [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]] ``` **Example 2:** ```python generate_subsets([]) ``` **Output:** ``` [[]] ``` **Example 3:** ```python generate_subsets([4]) ``` **Output:** ``` [[], [4]] ``` # Note * Focus on implementing the function `generate_subsets` with both an iterative approach and a recursive backtracking approach to understand the differences in implementations. * Ensure your implementation adheres to the constraints and handles edge cases appropriately.","solution":"def generate_subsets(nums): Returns all possible subsets of the list of distinct integers nums. subsets = [] nums.sort() def backtrack(start, path): subsets.append(path) for i in range(start, len(nums)): backtrack(i + 1, path + [nums[i]]) # Start backtracking with an empty path backtrack(0, []) return subsets"},{"question":"Scenario You are working on a low-level programming task in an embedded system where memory efficiency is paramount. You need to manipulate integers by removing specific bits at given positions. This helps optimize the storage and data processing pipeline in your system. Task Implement a function `remove_bit(num: int, i: int) -> int` to remove the bit at the i-th position from the binary representation of the given integer `num`. Requirements * **Input Format**: - An integer `num` (0 <= num <= 10^9). - An integer `i` (0 <= i < number of bits in the binary representation of `num`). * **Output Format**: - Return the resulting integer after removing the i-th bit from `num`. * **Constraints**: - Do not convert `num` to a string. Use bitwise operations only. - Ensure handling for edge cases where `i` is out of range properly before performing operations. * **Performance Requirements**: - Aim for O(1) time complexity. - Use O(1) space complexity. Example ```python remove_bit(21, 2) -> 9 remove_bit(21, 4) -> 5 remove_bit(21, 0) -> 10 ``` Implementation Skeleton Provide a brief skeleton for the implementation. ```python def remove_bit(num, i): # Ensure `i` is within the correct range if i < 0 or i >= num.bit_length(): raise ValueError(\\"i is out of range\\") # Perform bit removal mask = num >> (i + 1) mask = mask << i right = ((1 << i) - 1) & num return mask | right # Test the function print(remove_bit(21, 2)) # 9 print(remove_bit(21, 4)) # 5 print(remove_bit(21, 0)) # 10 ```","solution":"def remove_bit(num, i): Removes the bit at the i-th position from num. Parameters: num (int): The integer from which a bit needs to be removed. i (int): The 0-based position of the bit. Returns: int: The resulting integer after the bit has been removed. # Ensure `i` is within the correct range if i < 0 or i >= num.bit_length(): raise ValueError(\\"i is out of range\\") # Separate the parts of the number before and after the i-th bit. left = num >> (i + 1) right = num & ((1 << i) - 1) # Combine these parts. The left part is shifted back to its original position. result = (left << i) | right return result"},{"question":"# Problem Description In mathematics, the Fibonacci numbers commonly denoted as Fn, form a sequence, called the Fibonacci sequence, such that each number is the sum of the two preceding ones, starting from 0 and 1. The sequence follows: F0=0, F1=1, Fn= F(n-1) + F(n-2) for n > 1. Given a positive integer n, you are required to return the n-th Fibonacci number efficiently using any of the three techniques (recursive, dynamic programming, or iterative). Additionally, your implementation must handle very large values of n (up to 10^5). # Input Format - A single integer n (0 <= n <= 10^5). # Output Format - A single integer representing the n-th Fibonacci number. # Constraints - n is a non-negative integer up to 10^5. # Performance Requirements Your solution should run efficiently even for the maximum value of n. Prefer implementing a method that adheres to O(n) time complexity and O(1) space complexity for the iterative approach. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Example Input ```python 10 ``` # Example Output ```python 55 ``` # Additional Test Cases Test Case 1 **Input**: ```python 0 ``` **Output**: ```python 0 ``` Test Case 2 **Input**: ```python 1 ``` **Output**: ```python 1 ``` Test Case 3 **Input**: ```python 100 ``` **Output**: ```python 354224848179261915075 ``` # Instructions 1. Implement the `fibonacci` function. 2. Ensure your implementation is efficient and handles large input sizes without performance issues. 3. Handle edge cases appropriately.","solution":"def fibonacci(n: int) -> int: This function returns the n-th Fibonacci number efficiently using an iterative approach. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"Your task is to implement a dictionary data structure that can store a list of words and allow searches, including searches with wildcard characters. The wildcard character \'.\' can represent any letter. Implement the class `WordDictionary` with the following methods: 1. **`add_word(word: str) -> None`**: Adds a word to the data structure. 2. **`search(word: str) -> bool`**: Returns `True` if the word or pattern exists in the structure, `False` otherwise. # Requirements: * The data structure must support efficient searches. * The search pattern may include the wildcard character \'.\' which can match any letter. # Constraints: * Input word lengths will be between 1 and 500 characters. * Total number of words added to the dictionary will be at most 10^4. # Examples: ```python wordDict = WordDictionary() wordDict.add_word(\\"bad\\") wordDict.add_word(\\"dad\\") wordDict.add_word(\\"mad\\") print(wordDict.search(\\"pad\\")) # Output: False print(wordDict.search(\\"bad\\")) # Output: True print(wordDict.search(\\".ad\\")) # Output: True print(wordDict.search(\\"b..\\")) # Output: True ``` # Note: * You should handle edge cases such as searching an empty dictionary or searching with wildcards at the start or end of words.","solution":"class WordDictionary: def __init__(self): Initialize the data structure. self.trie = {} def add_word(self, word: str) -> None: Adds a word to the data structure. node = self.trie for char in word: if char not in node: node[char] = {} node = node[char] node[\'#\'] = True def search(self, word: str) -> bool: Returns True if the word or pattern exists in the structure, False otherwise. return self._search_in_node(word, self.trie) def _search_in_node(self, word, node): for i, char in enumerate(word): if char == \'.\': for key in node: if key != \'#\' and self._search_in_node(word[i + 1:], node[key]): return True return False else: if char not in node: return False node = node[char] return \'#\' in node"},{"question":"# Scenario: You are tasked with developing an auto-complete feature for a text editor. The text editor suggests words based on the prefix typed by the user. The backend system responsible for this feature uses a Trie data structure to store and retrieve the prefixes efficiently. # Task: Implement the functionality to insert, search, and check prefixes in the Trie. You need to implement an additional function to return all words in the Trie with a given prefix. # Function Signature: ```python class Trie: def __init__(self): # Initializes the Trie object pass def insert(self, word: str) -> None: # Inserts a word into the trie pass def search(self, word: str) -> bool: # Returns if the word is in the trie pass def starts_with(self, prefix: str) -> bool: # Returns if there is any word in the trie that starts with the given prefix pass def get_words_with_prefix(self, prefix: str) -> List[str]: # Returns a list of all the words in the trie with the given prefix pass ``` # Expected Input: 1. `insert(word: str)`: The `word` to be inserted into the Trie (`word` consists of lowercase English letters only). 2. `search(word: str)`: The `word` to search in the Trie (`word` consists of lowercase English letters only). 3. `starts_with(prefix: str)`: The `prefix` to check in the Trie (`prefix` consists of lowercase English letters only). 4. `get_words_with_prefix(prefix: str)`: The `prefix` to retrieve all words from the Trie (`prefix` consists of lowercase English letters only). # Expected Output: 1. `insert(word: str)`: No return value. 2. `search(word: str)`: Returns `True` if the `word` is in the Trie, otherwise `False`. 3. `starts_with(prefix: str)`: Returns `True` if there is any word in the Trie that starts with the given `prefix`, otherwise `False`. 4. `get_words_with_prefix(prefix: str)`: Returns a list of all the words in the Trie that start with the given `prefix`. # Constraints: * All words and prefixes consist of lowercase English letters. * Input words and prefixes have length in the range [1, 100]. * The total number of words inserted will not exceed (10^4). # Example Usage: ```python trie = Trie() trie.insert(\\"apple\\") print(trie.search(\\"apple\\")) # Output: True print(trie.search(\\"app\\")) # Output: False print(trie.starts_with(\\"app\\")) # Output: True trie.get_words_with_prefix(\\"app\\") # Output: [\\"apple\\"] trie.insert(\\"app\\") print(trie.search(\\"app\\")) # Output: True trie.get_words_with_prefix(\\"app\\") # Output: [\\"apple\\", \\"app\\"] ``` # Additional Notes: * Ensure you handle edge cases such as empty strings and strings that do not exist in the trie. * Consider performance and efficiency for large datasets. * Thoroughly test your functions to cover various scenarios.","solution":"from typing import List class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def _find_node(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return None node = node.children[char] return node def _collect_words(self, node: TrieNode, prefix: str, result: List[str]) -> None: if node.is_end_of_word: result.append(prefix) for char, next_node in node.children.items(): self._collect_words(next_node, prefix + char, result) def get_words_with_prefix(self, prefix: str) -> List[str]: result = [] node = self._find_node(prefix) if node is not None: self._collect_words(node, prefix, result) return result"},{"question":"# Hash Table with Linear Probing and Dynamic Resizing **Context**: Suppose you are building a caching system. You need to design an efficient Hash Table that can dynamically resize itself when it becomes full. Your task is to implement a resizable hash table using linear probing for collision resolution and resizing the hash table to double its size when the load factor exceeds 2/3. **Function Implementations**: 1. `put(key, value)`: Insert or update a key-value pair into the hash table. 2. `get(key)`: Retrieve the value associated with a given key, or return `None` if the key is not found. 3. `del_(key)`: Delete the key-value pair from the hash table. 4. Implement dynamic resizing such that the size of the hash table doubles when the load factor (ratio of the number of elements to the size of the table) exceeds 2/3. **Input and Output Formats**: * The `put` method takes two arguments: an integer `key` and any `value`. * The `get` method takes one argument: an integer `key` and returns the associated value or `None`. * The `del_` method takes one argument: an integer `key` and deletes the key-value pair. * Resizing should be handled internally and transparently to the user. **Constraints**: * Implement the `hash` method as modulo operation. * Implement linear probing for collision resolution. **Requirements**: * Ensure that your implementation maintains O(1) average time complexity for insertion, deletion, and search operations. * Ensure that the resizing mechanism is correctly implemented, and ensure no data is lost during resizing. * Handle edge cases, such as attempting to delete non-existing keys or inserting duplicate keys, gracefully. **Example**: ```python hash_table = ResizableHashTable() hash_table.put(1, \'A\') hash_table.put(2, \'B\') hash_table.put(3, \'C\') assert hash_table.get(1) == \'A\' assert hash_table.get(4) == None hash_table.put(2, \'Z\') assert hash_table.get(2) == \'Z\' hash_table.del_(3) assert hash_table.get(3) == None ``` Implement the `ResizableHashTable` class based on the above requirements.","solution":"class ResizableHashTable: def __init__(self, initial_size=8): self.size = initial_size self.count = 0 self.table = [None] * self.size def _hash(self, key): return key % self.size def _resize(self): old_table = self.table self.size *= 2 self.table = [None] * self.size self.count = 0 for item in old_table: if item is not None: key, value = item self.put(key, value) def put(self, key, value): if self.count + 1 > 2 / 3 * self.size: self._resize() index = self._hash(key) while self.table[index] is not None: current_key, _ = self.table[index] if current_key == key: break index = (index + 1) % self.size if self.table[index] is None: self.count += 1 self.table[index] = (key, value) def get(self, key): index = self._hash(key) while self.table[index] is not None: current_key, value = self.table[index] if current_key == key: return value index = (index + 1) % self.size return None def del_(self, key): index = self._hash(key) while self.table[index] is not None: current_key, _ = self.table[index] if current_key == key: self.table[index] = None self.count -= 1 next_index = (index + 1) % self.size while self.table[next_index] is not None: moved_key, moved_value = self.table[next_index] self.table[next_index] = None self.count -= 1 self.put(moved_key, moved_value) next_index = (next_index + 1) % self.size return index = (index + 1) % self.size"},{"question":"Scenario: You are building an auto-suggestion system for a search feature that assists users in finding products faster. The system suggests the next available product name that comes alphabetically after the user’s typed query. The product names are case-insensitive and only contain lowercase letters. The suggestions need to be wrap-around compatible, meaning if the query is greater than any product name, it should cycle back to the smallest product name. Task: Write a function `next_product_name` that determines the next product name in alphabetical order from a list of sorted product names. Requirements: 1. Implement binary search to achieve O(log N) time complexity. 2. Handle wrap-around scenarios correctly. 3. Do not use built-in library functions such as `bisect`. Function Signature: ```python def next_product_name(product_names: List[str], query: str) -> str: pass ``` Input: * `product_names`: A list of strings, sorted in alphabetical order and containing only lowercase characters. (e.g., `[\\"apple\\", \\"banana\\", \\"cherry\\"]`) * `query`: A string consisting of lowercase characters that is the search query (e.g., `\\"apple\\"`). Output: * A string representing the next available product name in alphabetical order. Constraints: * The length of `product_names` is between 2 and 10^4. * All character strings in `product_names` are lowercase. Example: ```python product_names = [\\"apple\\", \\"banana\\", \\"cherry\\"] query = \\"banana\\" output = \\"cherry\\" product_names = [\\"apple\\", \\"banana\\", \\"cherry\\"] query = \\"zebra\\" output = \\"apple\\" product_names = [\\"apple\\", \\"banana\\", \\"cherry\\"] query = \\"apple\\" output = \\"banana\\" ``` Note: - If the `query` is the largest string or beyond the last element, it should wrap around to the first element in `product_names`.","solution":"from typing import List def next_product_name(product_names: List[str], query: str) -> str: left, right = 0, len(product_names) - 1 # Wrap-around: if the query is greater than the last product name, # it should wrap around to the first product name if query >= product_names[-1]: return product_names[0] while left < right: mid = (left + right) // 2 if product_names[mid] > query: right = mid else: left = mid + 1 return product_names[left]"},{"question":"You are provided with a stack of integers. Your task is to write a function `is_consecutive` which determines whether the stack contains a sequence of consecutive integers from the bottom to the top (from the first element pushed to the last element). Specifications - Implement the function `is_consecutive(stack: List[int]) -> bool` which: * Takes a single argument `stack`, which is a list representing a stack of integers. * Returns `True` if the stack contains a sequence of consecutive integers from bottom to top, otherwise `False`. Constraints - The function must use either an auxiliary stack or an auxiliary queue to achieve its goal. - The stack must be restored to its original state post-verification. Examples Example 1: ``` Input: stack = [3, 4, 5, 6, 7] Output: True Explanation: The stack contains numbers 3 to 7 in consecutive order. ``` Example 2: ``` Input: stack = [3, 4, 6, 7] Output: False Explanation: The stack does not contain consecutive numbers (5 is missing). ``` Example 3: ``` Input: stack = [1] Output: True Explanation: A single element is trivially consecutive. ``` Example 4: ``` Input: stack = [] Output: True Explanation: An empty stack is considered to be consecutively ordered. ``` Notes - Your implementation should ensure the original stack remains unchanged after the function completes.","solution":"def is_consecutive(stack): Checks if the stack contains a sequence of consecutive integers from bottom to top. if not stack: return True sorted_stack = sorted(stack) is_consecutive = all(sorted_stack[i] + 1 == sorted_stack[i + 1] for i in range(len(sorted_stack) - 1)) return is_consecutive"},{"question":"You are given an undirected graph in which each node contains a unique label and a list of its neighbors. A node in this graph is represented by the following class: ```python class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] ``` You need to implement a function that performs a deep copy (clone) of the given undirected graph using an iterative BFS approach. The function signature is: ```python def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': ``` # Input * `node`: The starting node of the undirected graph to be cloned. This node is an instance of `UndirectedGraphNode`. # Output * Returns the `UndirectedGraphNode` which is the root node of the cloned graph. # Constraints * The graph may be empty, i.e., `node` may be `None`. * The graph may have self-loops or be cyclic. # Example Given the serialized graph `{0,1,2#1,2#2,2}`, the visual representation is: ``` 1 / / 0 --- 2 / _/ ``` One possible way to visualize the cloned graph is by ensuring that the node labels and their connections are replicated exactly. # Requirements - Ensure no references to the original nodes are retained in the new graph. - Handle edge cases such as empty graphs and self-loops. - Avoid excessive space use and potential recursion depth issues. # Note You may use the following helper function provided in the code snippet for creating a shallow copy of a node: ```python def shallow_copy(node): Return a shallow copy of the node (ignoring any neighbors). return UndirectedGraphNode(node.label) ``` # Task Implement the `clone_graph_bfs` function that meets the above requirements.","solution":"from collections import deque class UndirectedGraphNode: def __init__(self, label): self.label = label self.neighbors = [] def clone_graph_bfs(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None # A dictionary to keep track of all the created nodes and avoid duplicate copies. node_map = {node: UndirectedGraphNode(node.label)} # Use a deque for BFS queue = deque([node]) # BFS traversal while queue: current_node = queue.popleft() # Iterate through each neighbor of the current node for neighbor in current_node.neighbors: if neighbor not in node_map: # Clone the neighbor and put it into the map node_map[neighbor] = UndirectedGraphNode(neighbor.label) # Add it to the queue for future BFS queue.append(neighbor) # Add neighbors to the current cloned node node_map[current_node].neighbors.append(node_map[neighbor]) return node_map[node]"},{"question":"# Palindrome Linked List Checker Given a singly linked list, your task is to write a function that checks whether the linked list is a palindrome. **Function Signature**: ```python def is_linked_list_palindrome(head: Optional[ListNode]) -> bool: ``` **Input**: - `head`: A singly linked list node representing the head of the list. - Linked list node is described by the following class definition: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` **Output**: - Return `True` if the linked list is a palindrome, otherwise return `False`. **Constraints**: - The number of nodes in the list is in the range `[0, 10^5]`. - `-10^6 <= Node.val <= 10^6`. **Scenario**: You are developing a medical record system, where patient details are stored in a linked list format. You need to ensure that the data is symmetric, i.e., it reads the same forward and backward, to make records easier to verify and ensure consistency across patient data. **Example**: ```python # Example 1: # Input: 1 -> 2 -> 2 -> 1 # Output: True # Example 2: # Input: 1 -> 2 # Output: False ``` Implement the optimized solution that considers space and time efficiency while checking if the linked list is a palindrome.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_linked_list_palindrome(head: ListNode) -> bool: # Step 1: Find the middle of the linked list using the slow and fast pointers approach slow, fast = head, head while fast and fast.next: slow = slow.next fast = fast.next.next # Step 2: Reverse the second half of the linked list prev = None while slow: temp = slow.next slow.next = prev prev = slow slow = temp # Step 3: Compare the first and second half nodes left, right = head, prev while right: # Only need to compare till the end of the reversed half if left.val != right.val: return False left = left.next right = right.next return True"},{"question":"# Question: Constructing Normalized Paths Scenario You are working on a file management application that requires correctly formatted file paths. Additionally, your application needs to fetch resources over the internet by composing valid URLs. For both tasks, it\'s essential to ensure that the constructed paths are normalized, without redundant slashes. Task Write a function `construct_path(base: str, suffix: str) -> str` that takes two strings `base` and `suffix`, and returns a single joined string. The joining process should ensure: 1. The `base` string should not end with a slash. 2. The `suffix` string should not start or end with a slash. 3. The concatenated result should use a single slash to join the two parts. Input - `base` (string): A base path or URL. - `suffix` (string): A path or URL segment to be appended to the base. Output - A single string representing the correctly concatenated path or URL. Constraints 1. Both `base` and `suffix` consist of printable ASCII characters. 2. `base` and/or `suffix` can be an empty string. Performance Requirements - Ensure efficient handling of strings, with an emphasis on both time and space complexity. - No auxiliary data structures are required. Example ```python assert construct_path(\\"path/to/dir\\", \\"file\\") == \\"path/to/dir/file\\" assert construct_path(\\"path/to/dir/\\", \\"file\\") == \\"path/to/dir/file\\" assert construct_path(\\"http://algorithms.com/\\", \\"part\\") == \\"http://algorithms.com/part\\" assert construct_path(\\"http://algorithms.com\\", \\"/part\\") == \\"http://algorithms.com/part\\" assert construct_path(\\"\\", \\"file\\") == \\"file\\" assert construct_path(\\"path\\", \\"\\") == \\"path\\" ``` Implement the function based on the outlined requirements: ```python def construct_path(base: str, suffix: str) -> str: # Implement the function here ```","solution":"def construct_path(base: str, suffix: str) -> str: This function takes a base path and a suffix path and returns a single normalized path. The base should not end with a slash, and the suffix should not start or end with a slash. base = base.rstrip(\'/\') suffix = suffix.strip(\'/\') if not base: return suffix if not suffix: return base return f\\"{base}/{suffix}\\""},{"question":"# Array Manipulation: Move Zeros to End Objective Write a function to move all zero elements in an array to the end while preserving the order of the other elements. Function Signature ```python def move_zeros(array): # Your implementation here ``` Input * A list of various data types, containing integers, strings, booleans, etc. Output * A list with all zeros moved to the end, and the relative order of non-zero elements preserved. Constraints * The function should handle booleans correctly (e.g., `False` should not be moved as it is different from `0`). * Implementations must not alter the input list. * Performance expectation: O(n) time complexity. * Space expectation: Try to achieve constant space complexity if possible, or provide an alternative solution using O(n) additional space. Scenario Imagine you are working with data from multiple sources. Some sources use placeholders represented by zeros. Your task is to move these placeholders to the end of the dataset array while retaining the order of the remaining data items. Examples ```python # Example 1 input_array = [False, 1, 0, 1, 2, 0, 1, 3, \\"a\\"] # False is not considered as 0 output_array = [False, 1, 1, 2, 1, 3, \\"a\\", 0, 0] # Example 2 input_array = [0, 1, 0, 3, 12] output_array = [1, 3, 12, 0, 0] # Example 3 input_array = [1, 2, 3, 4, 5] output_array = [1, 2, 3, 4, 5] # Example 4 input_array = [] output_array = [] ``` Notes * Consider using in-place techniques or provide a space-optimized solution. * Assume that the input will always be a list.","solution":"def move_zeros(array): Move all zeros to the end of the array while preserving the order of the other elements. if not array: return [] non_zero_elements = [elem for elem in array if elem != 0 or type(elem) == bool] zero_count = len(array) - len(non_zero_elements) return non_zero_elements + [0] * zero_count"},{"question":"# Question: Enhanced Insertion Sort with Range Limitation **Objective**: Implement an enhanced version of Insertion Sort that only sorts within a specified subrange of the array. The rest of the array should remain unchanged. **Task**: Write a function `subrange_insertion_sort(arr, start, end, simulation=False)` that: * Sorts the elements of `arr` between indices `start` and `end` (inclusive) using the insertion sort algorithm. * If `simulation` is `True`, prints the list after each pass of the outer loop with the simulated sorting process. * Returns the sorted array. **Input**: * `arr`: List of integers. * `start`: Integer specifying the starting index of the subrange to sort. * `end`: Integer specifying the ending index of the subrange to sort. * `simulation` (optional): Boolean; if `True`, prints the internal state after each iteration. Default is `False`. **Output**: * The function returns the array with the specified subrange sorted. **Constraints**: * `0 <= start <= end < len(arr)` * The array `arr` contains at least one element. **Example**: ```python # Example 1 arr = [5, 2, 4, 6, 1, 3] start = 1 end = 4 print(subrange_insertion_sort(arr, start, end)) # Output: [5, 1, 2, 4, 6, 3] # Example 2 arr = [10, -1, 0, 5, 8] start = 0 end = 2 print(subrange_insertion_sort(arr, start, end)) # Output: [-1, 0, 10, 5, 8] ``` **Note**: * Invalid subrange indices (e.g., `start` > `end`) can be checked, but the guarded constraints ensure the valid input range.","solution":"def subrange_insertion_sort(arr, start, end, simulation=False): Sort the elements of arr between indices start and end using insertion sort. :param arr: List[int] - list of integers to be sorted within a subrange :param start: int - starting index of the subrange to sort (inclusive) :param end: int - ending index of the subrange to sort (inclusive) :param simulation: bool - if True, prints the internal state after each iteration of the outer loop :return: List[int] - the array with the specified subrange sorted if not (0 <= start <= end < len(arr)): raise ValueError(f\\"Invalid range: start={start}, end={end}, len(arr)={len(arr)}\\") for i in range(start + 1, end + 1): key = arr[i] j = i - 1 while j >= start and arr[j] > key: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key if simulation: print(f\\"Pass {i-start}: {arr}\\") return arr"},{"question":"**Extended Euclidean Algorithm & Modular Inverse Implementation** You have been given the task of implementing two functions that utilize the Extended Euclidean Algorithm to compute: 1. The GCD of two integers, and their corresponding coefficients. 2. The modular inverse of an integer modulo (m). # Full Description: 1. **Extended Euclidean Algorithm** Implement a function `extended_gcd(a: int, b: int) -> (int, int, int)`: This function computes the greatest common divisor (GCD) of (a) and (b), and also finds integers (x) and (y) such that (ax + by = text{GCD}(a, b)). **Input**: - Two integers (a) and (b), where (a, b geq 0). **Output**: - A tuple ((x, y, text{GCD}(a, b))) such that (a cdot x + b cdot y = text{GCD}(a, b)). 2. **Modular Inverse** Implement a function `modular_inverse(a: int, m: int) -> int`: This function calculates the modular inverse of (a) under modulo (m), which is an integer (x) such that (a cdot x equiv 1 pmod{m}). **Input**: - Two integers (a) and (m), where (a, m geq 1) and ( text{GCD}(a, m)=1 ). **Output**: - Return the modular inverse of (a) under modulo (m). **Constraints**: - If (a) and (m) are not coprime, raise a `ValueError` indicating that a modular inverse does not exist. # Example Test Cases: 1. **Test Case 1**: `extended_gcd(30, 12)` - **Input**: (a=30), (b=12) - **Output**: ((1, -2, 6)) since (30 cdot 1 + 12 cdot (-2) = 6) 2. **Test Case 2**: `modular_inverse(3, 11)` - **Input**: (a=3), (m=11) - **Output**: (4), since (3 cdot 4 equiv 1 pmod{11}) 3. **Test Case 3**: `modular_inverse(10, 17)` - **Input**: (a=10), (m=17) - **Output**: (12), since (10 cdot 12 equiv 1 pmod{17}) 4. **Test Case 4**: `modular_inverse(3, 6)` - **Input**: (a=3), (m=6) - **Output**: Raises `ValueError` (3 and 6 are not coprime) # Notes: * The functions should handle large inputs gracefully, considering the mathematical properties of Euclidean algorithm. * Focus on the edge cases where (a) or (b) could be zero for the `extended_gcd` function. * Ensure clear and concise error handling in the event of non-coprime inputs for the `modular_inverse` function.","solution":"def extended_gcd(a, b): Implements the Extended Euclidean Algorithm. Calculates integers x and y such that ax + by = gcd(a, b). Args: a (int): First number. b (int): Second number. Returns: tuple: (x, y, gcd(a, b)) if b == 0: return (1, 0, a) else: x1, y1, gcd = extended_gcd(b, a % b) x = y1 y = x1 - (a // b) * y1 return (x, y, gcd) def modular_inverse(a, m): Finds the modular inverse of a under modulo m. Args: a (int): Number to find the inverse of. m (int): Modulus. Returns: int: Modular inverse of a under m. Raises: ValueError: If gcd(a, m) != 1, meaning there\'s no modular inverse. x, y, gcd = extended_gcd(a, m) if gcd != 1: raise ValueError(f\\"No modular inverse for {a} under modulo {m}\\") else: return x % m"},{"question":"**Problem Statement: Interpolation Search Implementation** You are required to implement the Interpolation Search algorithm in Python as described below. This problem will assess your understanding of the Interpolation Search algorithm, edge cases, and its application in searching sorted arrays efficiently. # Function Specification **Input:** * `array` (List[int]): A list of sorted integers in increasing order. * `search_key` (int): The integer value to search for in the array. **Output:** * Return the index of `search_key` if found in the array. Otherwise, return -1. # Constraints: - The length of the array, (n), will be in the range (0 leq n leq 10^6). - Array elements can be negative or positive integers. - Elements in the array are distinct. # Examples: ```python # Example 1: assert interpolation_search([10, 20, 30, 40, 50], 30) == 2 # Example 2: assert interpolation_search([1, 2, 3, 4, 5, 6], 7) == -1 # Example 3: assert interpolation_search([], 10) == -1 # Example 4: assert interpolation_search([100, 200, 300, 400, 500], 300) == 2 # Example 5: assert interpolation_search([10, 20, 30, 40, 50], 10) == 0 ``` # Notes: 1. Pay careful attention to handle possible edge cases such as empty arrays or values not found within the array. 2. Use of external libraries is not permitted. 3. Ensure the solution adheres to the constraints mentioned and performs efficiently. **Function to Implement:** ```python def interpolation_search(array: List[int], search_key: int) -> int: # Implement the Interpolation Search algorithm here. pass ``` # Additional Examples for More Robust Testing: ```python assert interpolation_search([-10, -5, 0, 5, 10], 0) == 2 assert interpolation_search([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], -1) == -1 assert interpolation_search([2, 2, 2, 2, 2], 2) == 0 # Handle uniform array ``` # Hints: - Think about how you will handle the edge cases, such as arrays with all same values. - Be mindful of potential performance pitfalls with irregularly distributed data.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: low, high = 0, len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"Write a function called `next_prime` that takes an integer `n` and returns the smallest prime number larger than `n`. The function should efficiently utilize the given `prime_check` function as part of its solution. # Input * An integer `n` (−10^6 ≤ n ≤ 10^6) # Output * Returns an integer that is the smallest prime number greater than `n`. # Constraints * Handle negative `n` gracefully by understanding that the smallest prime number is 2. * Your solution should be efficient, aiming for a time complexity close to O(sqrt(n) * log(n)) for the sequence of checks. # Examples 1. `next_prime(10)` should return `11`. 2. `next_prime(17)` should return `19`. 3. `next_prime(-5)` should return `2`. # Notes * Consider edge cases where `n` is non-positive and scenarios where `n` might be very large.","solution":"import math def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def next_prime(n): Returns the smallest prime number greater than n. if n < 2: return 2 prime_candidate = n + 1 while not is_prime(prime_candidate): prime_candidate += 1 return prime_candidate"},{"question":"# Question A popular task in data preprocessing is filtering a dataset to include only the records that fall within a specified numeric range. Your task is to implement a function that performs such filtering on an array of numerical values. Function Signature ```python def limited_range_filter(arr: list, min_lim: float=None, max_lim: float=None) -> list: ``` Input - `arr`: A list of numerical values. (1 ≤ len(arr) ≤ 10^5) - `min_lim`: An optional float value representing the lower bound of the range. Default is `None`, which means there\'s no lower bound. - `max_lim`: An optional float value representing the upper bound of the range. Default is `None`, which means there\'s no upper bound. Output - A list of numerical values from the input array that fall within the specified range [min_lim, max_lim] (inclusive). Constraints - If `min_lim` is `None`, ignore the lower bound condition. - If `max_lim` is `None`, ignore the upper bound condition. - Ensure that the output list maintains the order of elements as they appeared in the input array. Performance Requirements - The solution should have a time complexity of O(n). - The solution should handle up to 10^5 elements efficiently. Examples: ```python assert limited_range_filter([1, 2, 3, 4, 5], None, 3) == [1, 2, 3] assert limited_range_filter([1, 2, 3, 4, 5], 2, None) == [2, 3, 4, 5] assert limited_range_filter([12, 34, 3, 7, 17], 5, 20) == [12, 7, 17] assert limited_range_filter([12, 34, 3, 7, 17], None, None) == [12, 34, 3, 7, 17] ``` Instructions 1. Implement the `limited_range_filter` function. 2. Consider all edge cases and ensure the function handles them correctly. 3. Optimize for performance and make sure the function works within the provided constraints.","solution":"def limited_range_filter(arr: list, min_lim: float = None, max_lim: float = None) -> list: Filters the elements in the array that fall within the [min_lim, max_lim] range inclusively. :param arr: A list of numerical values. :param min_lim: An optional float value representing the lower bound of the range. :param max_lim: An optional float value representing the upper bound of the range. :return: A list of numerical values from the input array that fall within the specified range. filtered_arr = [] for value in arr: if ((min_lim is None or value >= min_lim) and (max_lim is None or value <= max_lim)): filtered_arr.append(value) return filtered_arr"},{"question":"# Question: Binary Tree Path Finder You are given the root of a binary tree. Each node in the tree contains an integer value. Your task is to implement a function to find all root-to-leaf paths in the tree. Represent each path as a string of node values separated by the \\"->\\" symbol. Function Signature ```python def find_all_paths(root): # your code here ``` Input * A binary tree node `root` which is the root of the tree. * Each `TreeNode` has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * A list of strings, where each string represents a path from the root to a leaf. Constraints * The number of nodes in the tree is in the range `[0, 1000]`. * `-100 <= Node.val <= 100` Example # Input ```python # Example Tree: # 1 # / # 2 3 # # 5 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.right = TreeNode(5) ``` # Output ```python [\\"1->2->5\\", \\"1->3\\"] ``` Note - If the tree is empty, return an empty list. - Aim for a solution with a time complexity of O(N), where N is the number of nodes in the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def find_all_paths(root): if not root: return [] def dfs(node, path, paths): if not node.left and not node.right: # It\'s a leaf paths.append(path) if node.left: dfs(node.left, path + \\"->\\" + str(node.left.val), paths) if node.right: dfs(node.right, path + \\"->\\" + str(node.right.val), paths) paths = [] dfs(root, str(root.val), paths) return paths"},{"question":"# Advanced Stutter Problem You are given a stack presented as a list in Python, where stack[0] represents the bottom of the stack and stack[-1] represents the top. You need to write two functions that each duplicate every element in the stack. The first function must use an additional stack for its operations, and the second function must use a queue. # Function Signatures ```python def first_stutter(stack: List[int]) -> List[int]: Duplicates each element in the given stack using an additional stack. :param stack: A list representing the stack. :return: A list representing the stack after stuttering. pass def second_stutter(stack: List[int]) -> List[int]: Duplicates each element in the given stack using a queue. :param stack: A list representing the stack. :return: A list representing the stack after stuttering. pass ``` # Input/Output Format **Input**: - `stack` (List[int]): A list of integers representing the stack elements. **Output**: - A list of integers representing the stack after every element has been stuttered (duplicated). # Constraints - The stack will contain at most 10^4 elements. - The stack will only contain integers. - You may assume that the input stack always fits in memory. # Example ```python stack = [3, 7, 1, 14, 9] assert first_stutter(stack[:]) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] assert second_stutter(stack[:]) == [3, 3, 7, 7, 1, 1, 14, 14, 9, 9] ``` # Notes - Your implementation should modify the stack in place and return the modified stack. - Edge cases such as an empty stack should return an empty stack. - Avoid using libraries for additional stack or queue functionalities beyond what is provided in the standard Python collections module.","solution":"from typing import List from collections import deque def first_stutter(stack: List[int]) -> List[int]: Duplicates each element in the given stack using an additional stack. :param stack: A list representing the stack. :return: A list representing the stack after stuttering. temp_stack = [] while stack: element = stack.pop() temp_stack.append(element) temp_stack.append(element) while temp_stack: stack.append(temp_stack.pop()) return stack def second_stutter(stack: List[int]) -> List[int]: Duplicates each element in the given stack using a queue. :param stack: A list representing the stack. :return: A list representing the stack after stuttering. queue = deque() while stack: element = stack.pop() queue.appendleft(element) queue.appendleft(element) while queue: stack.append(queue.popleft()) return stack"},{"question":"**Context**: You are developing a feature in a graphics program that requires rotating and inverting image matrices in specific ways. You need to implement these transformations efficiently as they will be used frequently with potentially large matrices. **Task**: Implement a function that takes a square matrix and a transformation operation identifier and returns the transformed matrix. The operations include: * Rotate 90 degrees clockwise (`\\"rotate_clockwise\\"`) * Rotate 90 degrees counterclockwise (`\\"rotate_counterclockwise\\"`) * Invert from top-left (`\\"top_left_invert\\"`) * Invert from bottom-left (`\\"bottom_left_invert\\"`) # Requirements * Function Signature: ```python def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: ``` * **Input**: * `matrix` (List[List[int]]): A 2D list representing a square matrix. * `operation` (str): One of `\\"rotate_clockwise\\"`, `\\"rotate_counterclockwise\\"`, `\\"top_left_invert\\"`, or `\\"bottom_left_invert\\"`. * **Output**: * A new transformed matrix according to the specified operation. * **Constraints**: * Matrix dimensions: ( n times n ) where ( 1 leq n leq 10^3 ). * Elements of the matrix: integer values. # Performance * Your solution should handle the maximum input size efficiently within the constraints. # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9], ] operation = \\"rotate_clockwise\\" transform_matrix(matrix, operation) ``` Expected Output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3], ] ``` **Notes**: Ensure to handle edge cases such as a single-element or empty matrix input correctly.","solution":"from typing import List def transform_matrix(matrix: List[List[int]], operation: str) -> List[List[int]]: Transforms the input matrix based on the provided operation. Args: - matrix (List[List[int]]): A 2D list representing a square matrix. - operation (str): One of \\"rotate_clockwise\\", \\"rotate_counterclockwise\\", \\"top_left_invert\\", or \\"bottom_left_invert\\". Returns: - List[List[int]]: The transformed matrix. n = len(matrix) if operation == \\"rotate_clockwise\\": return [[matrix[n - 1 - j][i] for j in range(n)] for i in range(n)] elif operation == \\"rotate_counterclockwise\\": return [[matrix[j][n - 1 - i] for j in range(n)] for i in range(n)] elif operation == \\"top_left_invert\\": return [[matrix[i][j] for j in range(n-1, -1, -1)] for i in range(n)] elif operation == \\"bottom_left_invert\\": return [[matrix[n - 1 - i][j] for j in range(n)] for i in range(n)] else: raise ValueError(\\"Invalid operation\\")"},{"question":"# Coding Challenge: Matrix Inversion Objective: Implement a function in Python to invert a given n x n matrix. The matrix will be a square, non-singular matrix with dimensions n ≥ 2. Specifications: 1. **Input**: A list of lists `matrix` representing an n x n matrix of integers. 2. **Output**: A list of lists representing the inverted matrix, or specific error codes: - `[[ -1 ]]` if the input is not a matrix. - `[[ -2 ]]` if the matrix is not square. - `[[ -3 ]]` if the matrix size is less than 2. - `[[ -4 ]]` if the matrix is singular. Function Signature: ```python def invert_matrix(matrix: List[List[int]]) -> List[List[float]]: ``` Constraints: - The matrix will contain integer values. - The determinant of the input matrix will not be zero. Example: ```python matrix = [ [4, 7], [2, 6] ] print(invert_matrix(matrix)) # Output should be close to [[ 0.6, -0.7], [-0.2, 0.4]] ``` Notes: 1. You may use library functions for fractions to maintain precision. 2. Consider using helper functions to improve code readability. 3. Ensure to handle errors gracefully and return the appropriate error codes. **Good luck and happy coding!**","solution":"from typing import List def invert_matrix(matrix: List[List[int]]) -> List[List[float]]: def is_square(matrix): return all(len(row) == len(matrix) for row in matrix) def determinant(matrix): if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1)**c) * matrix[0][c] * determinant(minor(matrix, 0, c)) return det def minor(matrix, i, j): return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def matrix_inverse(matrix): det = determinant(matrix) if len(matrix) == 2: return [[matrix[1][1] / det, -1 * matrix[0][1] / det], [-1 * matrix[1][0] / det, matrix[0][0] / det]] cofactors = [] for r in range(len(matrix)): cofactorRow = [] for c in range(len(matrix)): minor_matrix = minor(matrix, r, c) cofactorRow.append(((-1)**(r+c)) * determinant(minor_matrix)) cofactors.append(cofactorRow) cofactors = list(map(list, zip(*cofactors))) # Transposing for r in range(len(cofactors)): for c in range(len(cofactors)): cofactors[r][c] = cofactors[r][c] / det return cofactors if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return [[-1]] if not is_square(matrix): return [[-2]] if len(matrix) < 2: return [[-3]] if determinant(matrix) == 0: return [[-4]] return matrix_inverse(matrix)"},{"question":"**Context**: An e-commerce platform needs to verify that product codes in their database do not contain any anagrams of each other to avoid duplicate listings under different names. **Problem**: Write a Python function `check_anagram(s, t)` that determines whether two provided string inputs `s` and `t` are anagrams of each other. An anagram of a string is another string that contains the same characters in the same frequency but arranged differently. # Input: - `s` (string) - a non-empty string consisting only of lowercase alphabets. - `t` (string) - another non-empty string consisting only of lowercase alphabets. # Output: - Return `True` if `t` is an anagram of `s`, otherwise return `False`. # Constraints: 1. Strings will only contain lowercase alphabets. 2. Perform the check in O(n) time complexity where n is the length of the strings. # Requirements: 1. Consider edge cases such as strings of different lengths. 2. Optimize for space and performance where possible. # Example: ```python def check_anagram(s, t): # Your implementation here # Example 1 assert check_anagram(\\"anagram\\", \\"nagaram\\") == True # Example 2 assert check_anagram(\\"rat\\", \\"car\\") == False # Example 3 assert check_anagram(\\"\\", \\"\\") == True ```","solution":"def check_anagram(s, t): Determines whether two strings s and t are anagrams of each other. :param s: First string :param t: Second string :return: True if t is an anagram of s, otherwise False if len(s) != len(t): return False # Use a dictionary to count the frequency of characters in both strings char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in t: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"Background You are tasked with implementing a filtering utility for a data analysis tool. Users often need to limit arrays of data points to a specific range. You need to ensure that the final array contains only the values within the desired range, inclusive of boundary values. Task Description Write a function `limit_values_within_range(data, min_val=None, max_val=None)` that filters the input array `data` and returns a new array containing values between `min_val` and `max_val` (inclusive). If `min_val` or `max_val` are not provided, the function should not restrict on that end. Input * `data` (list of int/float): The array of numbers to be filtered. * `min_val` (int/float, optional): The minimum value (inclusive) for the range. Defaults to `None`, indicating no lower limit. * `max_val` (int/float, optional): The maximum value (inclusive) for the range. Defaults to `None`, indicating no upper limit. Output * A new list containing only the values within the specified range. Constraints * The elements in `data` are all of the same type (either all integers or all floats). * `data` can be an empty list. * `min_val` and `max_val`, if provided, will be of the same type as the elements in `data`. Performance Requirements * The function should run in O(n) time complexity, where n is the length of the input array. Example ```python assert limit_values_within_range([1,2,3,4,5], None, 3) == [1,2,3] assert limit_values_within_range([10, 20, 30, 40, 50], 15, 35) == [20, 30] assert limit_values_within_range([100, 200, 300], 150, None) == [200, 300] assert limit_values_within_range([], 1, 10) == [] assert limit_values_within_range([1, 5, 3, 2, 8], 0, 10) == [1, 5, 3, 2, 8] ``` Implementation ```python def limit_values_within_range(data, min_val=None, max_val=None): # Handle edge case of empty data if not data: return [] # Determine actual min and max values if not provided if min_val is None: min_val = float(\'-inf\') if max_val is None: max_val = float(\'inf\') # Filter and return values within the range return [x for x in data if min_val <= x <= max_val] ```","solution":"def limit_values_within_range(data, min_val=None, max_val=None): Filters the input array \'data\' and returns a new array containing values between \'min_val\' and \'max_val\' (inclusive). If \'min_val\' or \'max_val\' are not provided, those limits are disregarded. Args: data (list of int/float): The list of numbers to be filtered. min_val (int/float, optional): The minimum value (inclusive) for the range. Defaults to None. max_val (int/float, optional): The maximum value (inclusive) for the range. Defaults to None. Returns: list of int/float: A new list containing only the values within the specified range. # Handle edge case of empty data if not data: return [] # Determine actual min and max values if not provided if min_val is None: min_val = float(\'-inf\') if max_val is None: max_val = float(\'inf\') # Filter and return values within the range return [x for x in data if min_val <= x <= max_val]"},{"question":"Radix Sort Implementation & Extension Scenario You are working on upgrading a company\'s internal sorting library to handle more diverse types of input arrays efficiently. They specifically require the sorting algorithm to handle not only positive integers but also negative integers while maintaining a stable sort property. Task Implement an extended version of the `radix_sort` function which can sort an array containing both positive and negative integers. Additionally, ensure that when negative integers are present, the function first sorts by the absolute value keeping the negative sign intact. Function Signature ```python def extended_radix_sort(arr: List[int]) -> List[int]: pass ``` Input * A list of integers where the integers can be both positive and negative. Output * A list of integers sorted in non-decreasing order. Negative numbers should come before positive numbers if they have the same absolute value. Constraints * The list can contain up to 10^6 elements. * Individual numbers range from -10^9 to 10^9. Performance Requirements * The function should operate efficiently with a time complexity of O(nk) and a manageable space complexity. Example ```python print(extended_radix_sort([-1, -3, 2, 1, -2])) # Output: [-3, -2, -1, 1, 2] ``` Considerations * Handle zero appropriately (0 is neither positive nor negative and should stay in place). * Ensure stable sorting for numbers with the same absolute value. Notes * Do not use Python\'s built-in sort function. * Consider edge cases such as: - Empty list - List with one element - List with all elements being the same - Large range of values in the list","solution":"from typing import List def extended_radix_sort(arr: List[int]) -> List[int]: def counting_sort(nums, exp): n = len(nums) output = [0] * n count = [0] * 10 for i in range(n): index = abs(nums[i]) // exp count[index % 10] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = abs(nums[i]) // exp output[count[index % 10] - 1] = nums[i] count[index % 10] -= 1 i -= 1 for i in range(n): nums[i] = output[i] if not arr: return [] max_num = max(abs(num) for num in arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp) exp *= 10 negatives = [num for num in arr if num < 0] positives = [num for num in arr if num >= 0] sorted_arr = negatives[::-1] + positives return sorted_arr"},{"question":"# Scenario You are tasked with developing a feature for a social media platform where posts can have upvotes. However, to maintain fairness, no single user should upvote a post more than a specified number of times. To achieve this, you need to write a function that processes a list of upvotes while ensuring no user has more than a specified number of upvotes on any post. # Problem Write a function `filter_upvotes(upvotes: List[Tuple[str, str]], N: int) -> List[Tuple[str, str]]`. The function takes in a list of tuples `upvotes`, where each tuple contains the user ID and the post ID they upvoted, and an integer `N` representing the maximum number of upvotes allowed per user per post. The function should return a new list of tuples with each user appearing at most `N` times per post, maintaining the original order of upvotes. Input * `upvotes` (List[Tuple[str, str]]): A list of tuples where each tuple consists of a user ID and a post ID. * `N` (int): The maximum number of times a user can upvote a particular post. Output * List of tuples with each user appearing at most `N` times per post. Example ```python input_upvotes = [(\'user1\', \'post1\'), (\'user2\', \'post1\'), (\'user1\', \'post1\'), (\'user1\', \'post2\'), (\'user2\', \'post1\'), (\'user1\', \'post1\'), (\'user2\', \'post2\'), (\'user3\', \'post1\')] N = 2 expected_output = [(\'user1\', \'post1\'), (\'user2\', \'post1\'), (\'user1\', \'post1\'), (\'user1\', \'post2\'), (\'user2\', \'post1\'), (\'user2\', \'post2\'), (\'user3\', \'post1\')] ``` # Constraints 1. `1 <= len(upvotes) <= 10^5` 2. `1 <= len(user_id), len(post_id) <= 20` 3. `1 <= N <= 100` # Requirements * The solution should maintain the original order of the upvotes. * The solution should be optimized to handle up to 10^5 upvotes efficiently. # Additional Information Ensure that your solution uses efficient data structures to handle counting and lookups.","solution":"from collections import defaultdict def filter_upvotes(upvotes, N): Filters upvotes so that no user appears more than N times per post. Parameters: upvotes (List[Tuple[str, str]]): A list of tuples where each tuple contains a user ID and a post ID. N (int): The maximum number of times a user can upvote a particular post. Returns: List[Tuple[str, str]]: A new list of tuples with each user appearing at most N times per post. user_post_count = defaultdict(lambda: defaultdict(int)) filtered_upvotes = [] for user_id, post_id in upvotes: if user_post_count[user_id][post_id] < N: filtered_upvotes.append((user_id, post_id)) user_post_count[user_id][post_id] += 1 return filtered_upvotes"},{"question":"You are tasked with implementing a `MultiStack` class that manages multiple stacks within a single data structure. The `MultiStack` needs to support the following operations for each individual stack: 1. `push(stack_id, value)`: Adds a new item to the designated stack. 2. `pop(stack_id)`: Removes the top item from the designated stack and returns it. 3. `peek(stack_id)`: Returns the top item from the designated stack without removing it. 4. `is_empty(stack_id)`: Checks if the designated stack is empty and returns a boolean value. Each stack should be identified by a `stack_id`, which is an integer value. There are no predefined limits for the number of individual stacks or the elements within each stack. # Input/Output format: * **`push(stack_id, value)`** - Input: `int stack_id, Any value` - Output: None * **`pop(stack_id)`** - Input: `int stack_id` - Output: `Any value` (raises `IndexError` if the stack is empty) * **`peek(stack_id)`** - Input: `int stack_id` - Output: `Any value` (raises `IndexError` if the stack is empty) * **`is_empty(stack_id)`** - Input: `int stack_id` - Output: `bool` # Constraints: - You cannot assume that the `stack_id` will be given in increasing order or will always be incremental. - Handle cases where operations are performed on a non-existent stack (you may need to initialize a stack dynamically upon first request). Your implementation should be efficient in terms of both time and space, and maintain proper abstraction and encapsulation principles. # Example: ```python multi_stack = MultiStack() multi_stack.push(0, \\"apple\\") multi_stack.push(0, \\"banana\\") print(multi_stack.pop(0)) # Output: \\"banana\\" print(multi_stack.peek(0)) # Output: \\"apple\\" print(multi_stack.is_empty(0)) # Output: False multi_stack.push(1, \\"carrot\\") print(multi_stack.peek(1)) # Output: \\"carrot\\" print(multi_stack.is_empty(1)) # Output: False multi_stack.pop(1) print(multi_stack.is_empty(1)) # Output: True ``` # Note: - Consider both ArrayStack and LinkedListStack implementations for handling individual stacks. - Ensure your code handles edge cases and errors gracefully.","solution":"class MultiStack: def __init__(self): self.stacks = {} def push(self, stack_id, value): if stack_id not in self.stacks: self.stacks[stack_id] = [] self.stacks[stack_id].append(value) def pop(self, stack_id): if stack_id not in self.stacks or self.is_empty(stack_id): raise IndexError(\\"pop from empty stack\\") return self.stacks[stack_id].pop() def peek(self, stack_id): if stack_id not in self.stacks or self.is_empty(stack_id): raise IndexError(\\"peek from empty stack\\") return self.stacks[stack_id][-1] def is_empty(self, stack_id): return stack_id not in self.stacks or len(self.stacks[stack_id]) == 0"},{"question":"**Context**: Palindromes are strings that read the same forwards and backwards once all non-alphanumeric characters are removed and case differences are ignored. This property makes them interesting subjects for computational text analysis. Ensuring correct palindrome checking is essential in various applications, including text validation and data normalization. **Problem Statement**: Implement a function `is_sentence_palindrome(s: str) -> bool` that determines if a given string is a palindrome, considering only alphanumeric characters and ignoring cases. The function should handle strings efficiently in terms of both time and space complexity. **Input**: - `s`: A string containing alphanumeric characters, spaces, and punctuation (0 ≤ len(s) ≤ 10^5). **Output**: - A boolean value: `True` if the string is a palindrome, `False` otherwise. **Constraints**: - The function must only use O(1) additional space. - The function must run in O(n) time. **Example**: ```python assert is_sentence_palindrome(\\"A man, a plan, a canal: Panama\\") == True assert is_sentence_palindrome(\\"race a car\\") == False assert is_sentence_palindrome(\\"\\") == True assert is_sentence_palindrome(\\" \\") == True assert is_sentence_palindrome(\\".,\\") == True ``` **Additional Requirements**: - You must handle all edge cases efficiently. - Avoid using additional data structures like stacks, lists, or deques for storing intermediate results. **Function Signature**: ```python def is_sentence_palindrome(s: str) -> bool: pass ``` **Hints**: - Use the two-pointer approach to reduce space complexity. - Normalize the string by checking and converting characters in place. **Explanation**: The provided function should ideally scan the string from both ends towards the center, comparing alphanumeric characters and ignoring others, while maintaining case insensitivity for comparison. This process guarantees minimal additional space usage while preserving linear time complexity. **Your task**: Complete the function `is_sentence_palindrome` to satisfy the above requirements.","solution":"def is_sentence_palindrome(s: str) -> bool: Determines if the given string is a palindrome, considering only alphanumeric characters and ignoring case differences. left, right = 0, len(s) - 1 while left < right: # Move left pointer to the next alphanumeric character while left < right and not s[left].isalnum(): left += 1 # Move right pointer to the previous alphanumeric character while left < right and not s[right].isalnum(): right -= 1 if s[left].lower() != s[right].lower(): return False left += 1 right -= 1 return True"},{"question":"# AVL Tree Implementation & Operations You are required to implement an AVL Tree that supports insertion of nodes and maintains its balance properties. You will also implement a method to determine whether the AVL tree is balanced correctly after several insertions. Your Task: 1. Implement the AVL tree insertion and balancing operations. 2. Implement a method to check if the tree is balanced. Function Signature: ```python class AvlTree: def __init__(self): pass def insert(self, key: int): pass def is_balanced(self) -> bool: pass ``` Method Description: * `insert(self, key: int) -> None`: Insert a key into the AVL tree. * `is_balanced(self) -> bool`: Returns `True` if the tree is balanced according to AVL tree properties, `False` otherwise. Example: ```python # Initialize the AVL tree avl = AvlTree() # Insert elements avl.insert(10) avl.insert(20) avl.insert(5) avl.insert(4) avl.insert(30) # Check if the tree is balanced print(avl.is_balanced()) # Expected output: True ``` Constraints and Considerations: * The key values are unique integers. * Tree operations should maintain the AVL properties: the height of the left and right subtrees of any node differs by at most one. * Your implementations should handle edge cases like inserting into an empty tree and ensuring the tree remains balanced after several insertions. Performance: * Your solution should efficiently handle insertions and balance checks for a large number of nodes (e.g., up to 10^5) while maintaining the AVL tree properties.","solution":"class Node: def __init__(self, key): self.key = key self.height = 1 self.left = None self.right = None class AvlTree: def __init__(self): self.root = None def _insert(self, node, key): if not node: return Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) # Update the height of this ancestor node node.height = 1 + max(self._get_height(node.left), self._get_height(node.right)) # Get the balance factor balance = self._get_balance(node) # If the node is unbalanced, then try out the 4 cases # Left Left Case if balance > 1 and key < node.left.key: return self._right_rotate(node) # Right Right Case if balance < -1 and key > node.right.key: return self._left_rotate(node) # Left Right Case if balance > 1 and key > node.left.key: node.left = self._left_rotate(node.left) return self._right_rotate(node) # Right Left Case if balance < -1 and key < node.right.key: node.right = self._right_rotate(node.right) return self._left_rotate(node) return node def insert(self, key): self.root = self._insert(self.root, key) def _get_height(self, node): if not node: return 0 return node.height def _get_balance(self, node): if not node: return 0 return self._get_height(node.left) - self._get_height(node.right) def _left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def _right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self._get_height(z.left), self._get_height(z.right)) y.height = 1 + max(self._get_height(y.left), self._get_height(y.right)) return y def is_balanced(self): def check_balanced(node): if not node: return True, 0 left_balanced, left_height = check_balanced(node.left) right_balanced, right_height = check_balanced(node.right) current_height = 1 + max(left_height, right_height) balance = left_height - right_height if abs(balance) > 1: return False, current_height return left_balanced and right_balanced, current_height balanced, _ = check_balanced(self.root) return balanced"},{"question":"**Context**: You are working as a software engineer in a streaming data processing company. Your team is tasked with implementing an algorithm to check if a given stream is 1-sparse. A stream is considered 1-sparse if there has been a unique number in the stream after all the addition and subtraction operations are performed. **Task**: Write a function `is_one_sparse` that determines if a stream of tuples representing numbers and their corresponding signs is 1-sparse. If the stream is 1-sparse, the function should return the unique number. If not, return `None`. **Function Signature**: ```python def is_one_sparse(stream: List[Tuple[int, str]]) -> int: ``` **Input**: * `stream`: A list of tuples, where each tuple contains an integer and a sign (\'+\' or \'-\'). **Output**: * An integer representing the unique number in the 1-sparse stream or `None` if the stream is not 1-sparse. **Constraints**: * All numbers in the input stream are non-negative integers. * The input stream contains at least 1 and at most 10^5 tuples. * Each tuple contains an integer between 0 and 10^9 and a sign (\'+\' or \'-\'). **Examples**: 1. **Input**: `[(4,\'+\'), (2,\'+\'),(2,\'-\'),(4,\'+\'),(3,\'+\'),(3,\'-\')]` **Output**: `4` 2. **Input**: `[(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\')]` **Output**: `2` 3. **Input**: `[(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(2,\'+\'),(1,\'+\')]` **Output**: `None` **Explanation**: 1. All numbers except `4` and `4` cancel out, leaving `4` as the unique number. 2. Only `2` is present in the stream with the same sign. 3. The stream contains more than one number after cancellations, hence it is not 1-sparse. **Note**: Handle edge cases such as: - Streams with many cancellations. - Streams with non-unique final results. - Properly manage bitwise operations to maintain efficient time complexity. **Performance Requirements**: Ensure that the implementation maintains an overall time complexity of O(n) and space complexity of O(1). Your solution should be efficient even for large inputs sizes.","solution":"def is_one_sparse(stream): Determine if a stream of tuples (number, sign) is 1-sparse. Args: stream (List[Tuple[int, str]]): A list of tuples where each tuple contains an integer and a sign (\'+\' or \'-\'). Returns: int or None: The unique number if the stream is 1-sparse, otherwise None. total_sum = 0 unique_number_candidate = None count_of_non_zero_entries = 0 number_count = {} for number, sign in stream: if sign == \'+\': number_count[number] = number_count.get(number, 0) + 1 elif sign == \'-\': number_count[number] = number_count.get(number, 0) - 1 if number_count[number] == 0: del number_count[number] if len(number_count) == 1: return list(number_count.keys())[0] else: return None"},{"question":"# Encoding and Decoding Strings Context You are working on a communication protocol that requires sending lists of strings over a network. To ensure the integrity and correct parsing of these strings, you need to encode a list of strings into a single string and decode it back again on receipt. Task Implement two functions, `encode` and `decode`, which will perform the encoding and decoding of a list of strings, respectively. * **Encode** method: * **Input**: A list of strings `strs` (List[str]) * **Output**: A single encoded string (str) * **Decode** method: * **Input**: A single encoded string `s` (str) * **Output**: The original list of strings (List[str]) Constraints: * Each string in the input list may contain any character, including colons. * The total length of the input list will not exceed 10^5 characters. Example ```python # Example input: strs = [\\"apple\\", \\"banana\\", \\"cherry\\"] encoded_string = encode(strs) # encoded_string should be: \\"5:apple6:banana6:cherry\\" decoded_list = decode(encoded_string) # decoded_list should be: [\\"apple\\", \\"banana\\", \\"cherry\\"] ``` Requirements: 1. Your implementation should handle edge cases. 2. You must use efficient methods to avoid unnecessary overhead.","solution":"def encode(strs): Encodes a list of strings to a single string. Args: strs (List[str]): A list of strings to encode. Returns: str: The encoded single string. encoded_str = \'\' for s in strs: encoded_str += f\\"{len(s)}:{s}\\" return encoded_str def decode(s): Decodes a single string to a list of strings. Args: s (str): The encoded string. Returns: List[str]: The decoded list of strings. decoded_list = [] i = 0 while i < len(s): # Find the length indicator j = i while s[j] != \':\': j += 1 length = int(s[i:j]) # Extract the string of the given length decoded_string = s[j+1:j+1+length] decoded_list.append(decoded_string) # Move to the next encoded segment i = j + 1 + length return decoded_list"},{"question":"**Factorial Calculation with Modulo** You are required to implement a function that computes the factorial of a non-negative integer `n`. Additionally, you must support an optional modulo operation. Function Signature ```python def factorial_mod(n: int, mod: int = None) -> int: pass ``` Input * `n` (int): A non-negative integer representing the number for which the factorial is being computed. (0 ≤ n ≤ 10^5) * `mod` (int, optional): A positive integer representing the modulo value. If `None`, the function should return the factorial without taking mod. (1 ≤ mod ≤ 10^9) Output * Returns an integer which is the factorial of `n` modulo `mod` if provided, otherwise the factorial of `n`. Constraints * `n` and `mod` (if provided) will be valid according to the input specifications. Examples * Input: `factorial_mod(5)` Output: `120` * Input: `factorial_mod(5, 7)` Output: `1` * Input: `factorial_mod(0)` Output: `1` * Input: `factorial_mod(100, 1000000007)` Output: `437918130` Additional Requirements * Consider edge cases such as input `0` and large values of `n`. * Your implementation should handle invalid inputs by raising appropriate exceptions. * Ensure your solution is efficient in both time and space complexity.","solution":"def factorial_mod(n: int, mod: int = None) -> int: Computes the factorial of n, optionally taking the result modulo mod. :param n: Non-negative integer for which the factorial is computed. :param mod: Optional positive integer for modulo operation. :return: Factorial of n, optionally modulo mod. if n < 0: raise ValueError(\\"n must be a non-negative integer.\\") if mod is not None: if mod <= 0: raise ValueError(\\"mod must be a positive integer.\\") result = 1 for i in range(2, n + 1): result *= i if mod is not None: result %= mod return result"},{"question":"**Context**: Consider an e-commerce platform where products are sold in many different categories. The platform wants to maintain a data structure that allows them to efficiently: 1. Retrieve the total number of items sold up to a given product category. 2. Update the number of items sold in a particular product category. Having an efficient means of performing these operations will enhance the platform\'s performance in real-time analytics and decision-making. **Task**: You are tasked with implementing a class `FenwickTree` that supports the following operations: - **`__init__(self, arr: List[int])`**: Constructor that initializes the Fenwick Tree using the given list of integers where each integer represents the initial number of items sold in a product category. - **`update(self, index: int, value: int) -> None`**: Method to update the number of items sold in the given index (`index` is 0-based). - **`sum(self, index: int) -> int`**: Method to return the total number of items sold up to the given index (inclusive, `index` is 0-based). **Input Format**: - The initialization list `arr` is a list of non-negative integers where `0 <= len(arr) <= 10^5`. - For `update(index, value)`, `0 <= index < len(arr)` and `value` is the new number of items sold at that product category. - For `sum(index)`, `0 <= index < len(arr)`. **Constraints**: - It is guaranteed there will be at least one call to the `sum` method. - The method `update` will only be called for valid indices within the array length. **Example**: ```python # Initialize the FenwickTree with the number of items sold across 5 product categories ft = FenwickTree([4, 2, 5, 7, 3]) # Query the total items sold up to the 3rd category (inclusive) print(ft.sum(3)) # Output: 18 (4+2+5+7) # Update the number of items sold in the 2nd category to 6 ft.update(2, 6) # Query again the total items sold up to the 3rd category (inclusive) print(ft.sum(3)) # Output: 19 (4+2+6+7) ``` Implement the `FenwickTree` class below.","solution":"from typing import List class FenwickTree: def __init__(self, arr: List[int]): self.n = len(arr) self.tree = [0] * (self.n + 1) for i, val in enumerate(arr): self.update(i, val) def update(self, index: int, value: int) -> None: diff = value - (self.sum(index) - self.sum(index - 1)) index += 1 while index <= self.n: self.tree[index] += diff index += index & -index def sum(self, index: int) -> int: index += 1 res = 0 while index > 0: res += self.tree[index] index -= index & -index return res"},{"question":"# Comb Sort Implementation Challenge **Objective**: Write a function that sorts a given array of integers in ascending order using the Comb Sort algorithm. Function Signature ```python def comb_sort(arr: List[int]) -> List[int]: ``` Parameters - `arr` (List[int]): A list of integers that needs to be sorted. Output - Returns a new list that consists of the integers sorted in ascending order. Constraints - The length of the list (N) will be between 1 and 10^4. - The integers in the list will be in the range of -10^9 to 10^9. Performance Requirements - The solution should aim to provide a performance close to O(N log N) in average-case scenarios. # Example: ```python print(comb_sort([34, -5, 42, 0, 8, 19, 83])) # Output: [-5, 0, 8, 19, 34, 42, 83] ``` **Note**: You are required to adhere to the comb sort principles mentioned above and ensure your implementation is efficient.","solution":"from typing import List def comb_sort(arr: List[int]) -> List[int]: def get_next_gap(gap): gap = (gap * 10) // 13 # Shrink factor of 1.3 if gap < 1: return 1 return gap n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = get_next_gap(gap) swapped = False for i in range(n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"**Question:** You are given a stack, and you are required to write a function (`third_is_consecutive`) to determine if the stack contains a sequence of consecutive integers from the bottom to the top. Your function should not use any auxiliary storage like additional stacks or queues. Implement the following function: ```python def third_is_consecutive(stack): Given a stack containing integers, return whether or not the stack\'s elements form a sequence of consecutive integers from the bottom of the stack to the top. Args: stack: List[int] - A list of integers representing the stack where index 0 is the bottom and the last index is the top. Returns: bool - True if the stack forms a sequence of consecutive integers from bottom to top, False otherwise. pass ``` # Constraints: 1. Do not use auxiliary storage such as additional stacks or queues. 2. Optimize for both time and space. # Examples: - Example 1: ``` python stack = [3, 4, 5, 6, 7] print(third_is_consecutive(stack)) # True ``` - Example 2: ``` python stack = [3, 4, 6, 7] print(third_is_consecutive(stack)) # False ``` - Example 3: ``` python stack = [3, 2, 1] print(third_is_consecutive(stack)) # False ``` # Edge cases: - Stack with a single element: `[1]` - Empty stack: `[]` Your implementation should handle these edge cases efficiently without the use of additional memory structures.","solution":"def third_is_consecutive(stack): Given a stack containing integers, return whether or not the stack\'s elements form a sequence of consecutive integers from the bottom of the stack to the top. Args: stack: List[int] - A list of integers representing the stack where index 0 is the bottom and the last index is the top. Returns: bool - True if the stack forms a sequence of consecutive integers from bottom to top, False otherwise. if len(stack) < 2: return True # Empty or single-element stack is trivially consecutive for i in range(1, len(stack)): if stack[i] != stack[i-1] + 1: return False return True"},{"question":"You are given an array of integers where every element appears exactly twice, except for one element which appears once. Your task is to find this unique element. **Function Signature**: `def find_unique_element(arr: List[int]) -> int:` # Input: * `arr` - A list of integers (1 ≤ len(arr) ≤ 10^5). Each integer in the list can be positive, negative, or zero. # Output: * Returns the single integer that appears only once in the array. # Constraints: * The array will contain integers. * Each integer will appear exactly twice, except for one that appears once. * The algorithm should have a linear runtime complexity. * You must implement this without using extra memory. # Example: ```python find_unique_element([2, 2, 3, 4, 4, 5, 5]) # Output: 3 find_unique_element([0, 1, 2, 1, 0]) # Output: 2 find_unique_element([14, 14, 15]) # Output: 15 ``` # Explanation: In the example `[2, 2, 3, 4, 4, 5, 5]`: - All numbers except 3 appear twice. - The function returns 3 as it is the unique element. # Notes: - The provided function should handle the edge cases such as: - An empty array (should return 0 as there is no single number). - Arrays with large sizes efficiently within the given constraints.","solution":"from typing import List def find_unique_element(arr: List[int]) -> int: Finds the unique element in an array where every element appears exactly twice, except for one element which appears once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"# Problem: Polynomial and Monomial Algebra Scenario: You are given a class structure to handle polynomials and monomials in symbolic algebra. Your task is to extend the functionality by implementing an additional feature: **polynomial differentiation**. This feature will automate the process of deriving polynomials with respect to a given variable. Task: 1. Implement a method `differentiate(variable: int) -> Polynomial` in the `Polynomial` class. 2. Implement a method `differentiate(variable: int) -> Monomial` in the `Monomial` class. Function Specifications: 1. **Monomial Class**: - **Method**: `differentiate(variable: int) -> Monomial` - **Input**: Integer `variable` representing the variable with respect to which the differentiation is performed. - **Output**: A new `Monomial` representing the derivative of the current monomial. 2. **Polynomial Class**: - **Method**: `differentiate(variable: int) -> Polynomial` - **Input**: Integer `variable` representing the variable with respect to which the differentiation is performed. - **Output**: A new `Polynomial` representing the derivative of the current polynomial. Constraints: - The variables within polynomials and monomials are represented by integers (e.g., ( a_1, a_2, dots )). - The differentiation rules follow standard polynomial differentiation, where ( frac{d}{dx}(a cdot x^n) = a cdot n cdot x^{n-1} ). - If a variable that does not exist in the monomial or polynomial is differentiated, the result should be zero. Example: ```python # Differentiation of Monomial monomial = Monomial({1: 3}, 4) # Represents 4(a_1)^3 derivative_monomial = monomial.differentiate(1) print(derivative_monomial) # Output should be 12(a_1)^2 # Differentiation of Polynomial polynomial = Polynomial([ Monomial({1:2}, 3), # Represents 3(a_1)^2 Monomial({1:1, 2:1}, -4), # Represents -4(a_1)(a_2) Monomial({2:3}, 5) # Represents 5(a_2)^3 ]) derivative_polynomial = polynomial.differentiate(1) print(derivative_polynomial) # Output should be Polynomial with Monomials: 6(a_1), -4(a_2) ``` Notes: 1. Carefully manage coefficients when applying differentiation rules. 2. Ensure that the output polynomial and monomial structures are correctly simplified and cleaned up (e.g., removing zero coefficients).","solution":"class Monomial: def __init__(self, exponents, coefficient): Initializes a monomial. :param exponents: Dictionary where keys are variable indices and values are their exponents. :param coefficient: The coefficient of the monomial. self.exponents = exponents self.coefficient = coefficient def differentiate(self, variable): Differentiates the monomial with respect to the given variable. :param variable: The variable index with respect to which differentiation is performed. :return: A new Monomial representing the derivative. if variable in self.exponents: new_exponents = self.exponents.copy() new_exponent = new_exponents[variable] new_coefficient = self.coefficient * new_exponent if new_exponent == 1: del new_exponents[variable] else: new_exponents[variable] -= 1 return Monomial(new_exponents, new_coefficient) else: return Monomial({}, 0) def __repr__(self): return f\\"Monomial({self.exponents}, {self.coefficient})\\" class Polynomial: def __init__(self, monomials): Initializes a polynomial. :param monomials: List of Monomial objects. self.monomials = monomials def differentiate(self, variable): Differentiates the polynomial with respect to the given variable. :param variable: The variable index with respect to which differentiation is performed. :return: A new Polynomial representing the derivative. new_monomials = [monomial.differentiate(variable) for monomial in self.monomials] new_monomials = [monomial for monomial in new_monomials if monomial.coefficient != 0] return Polynomial(new_monomials) def __repr__(self): return f\\"Polynomial({self.monomials})\\""},{"question":"# Question Given two sparse matrices A and B, both represented as lists of lists, implement a function `sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]` that returns the product of A and B. You can assume that the number of columns in A is equal to the number of rows in B. Example ``` A = [ [ 1, 0, 0], [-1, 0, 3] ] B = [ [ 7, 0, 0 ], [ 0, 0, 0 ], [ 0, 0, 1 ] ] sparse_matrix_multiply(A, B) Output: [ [7, 0, 0], [-7, 0, 3] ] ``` # Function Signature ```python from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: pass ``` # Constraints * (1 leq text{number of rows in } A, text{ number of columns in } B leq 100) * Matrices A and B will only contain integer values. # Notes * Focus on minimizing the computational steps involving zero elements to enhance performance. * Handle edge cases such as when the matrices are empty or contain all zero elements. * Ensure your solution can handle the constraints efficiently within a reasonable time frame.","solution":"from typing import List def sparse_matrix_multiply(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: if not A or not B: # Edge case, if either A or B is empty return [] m, n = len(A), len(A[0]) nB, p = len(B), len(B[0]) # Initialize result matrix with zeros result = [[0] * p for _ in range(m)] # Create lists of non-zero values for B non_zero_B = {} for i in range(nB): for j in range(p): if B[i][j] != 0: if i not in non_zero_B: non_zero_B[i] = [] non_zero_B[i].append((j, B[i][j])) # Multiply A and B for i in range(m): for k in range(n): if A[i][k] != 0: if k in non_zero_B: for j, val in non_zero_B[k]: result[i][j] += A[i][k] * val return result"},{"question":"# Wiggle Sort Algorithm Implementation Scenario: You are given an unsorted array of integers. Your task is to reorder the array in such a way that it satisfies the wiggle sort condition: nums[0] < nums[1] > nums[2] < nums[3]... This makes consecutive elements follow a high-low pattern. # Function Specification: Write a function `wiggle_sort(nums)` that takes in a list of integers and rearranges the array in-place to satisfy the wiggle sort requirement. Input: * `nums`: A list of unsorted integers (1 ≤ len(nums) ≤ 10^4, -10^4 ≤ nums[i] ≤ 10^4) Output: * Reorders the input list in-place to meet the wiggle sort condition. # Example: ```python def wiggle_sort(nums): for i in range(len(nums)): if (i % 2 == 1) == (nums[i-1] > nums[i]): nums[i-1], nums[i] = nums[i], nums[i] if __name__ == \\"__main__\\": array = [3, 5, 2, 1, 6, 4] print(array) wiggle_sort(array) print(array) ``` # Explanation: For an example input `[3, 5, 2, 1, 6, 4]`, a valid wiggle sorted output could be `[3, 5, 1, 6, 2, 4]` or `[1, 6, 2, 5, 3, 4]`. The exact wiggle order might vary but must always satisfy the condition: * `array[0] < array[1]` * `array[1] > array[2]` * `array[2] < array[3]` * and so forth... Additional Notes: * It is guaranteed that the provided array will have at least one element. * The provided algorithm should operate in O(n) time complexity. * Ensure that the list is modified in place with no extra space usage.","solution":"def wiggle_sort(nums): for i in range(len(nums) - 1): if (i % 2 == 0 and nums[i] > nums[i + 1]) or (i % 2 == 1 and nums[i] < nums[i + 1]): nums[i], nums[i + 1] = nums[i + 1], nums[i]"},{"question":"# Word Search Dictionary Implementation **Context**: You are tasked with developing an efficient dictionary data structure that allows for the addition and search of words. The search should support both literal words and patterns containing wildcards, where the wildcard character `.` can represent any letter. **Objective**: Implement a class, `WordSearchDictionary`, that supports adding words and searching for them using both exact and wildcard matches. # Implementation Requirements: 1. **add_word(word)**: Adds the given word to the dictionary. 2. **search(word)**: Searches for the word in the dictionary, where `word` can contain the wildcard character `.` which matches any single letter. # Input and Output Formats: * **Input**: - `word` for `add_word` is a string. - `word` for `search` is a string that may contain the character `.`. * **Output**: - `search` returns `True` if the word is found, otherwise `False`. # Performance Constraints: * The solution should efficiently handle up to 10^5 `add_word` and `search` operations combined. * Words are limited to lowercase alphabets and wildcards. # Function Signature: ```python class WordSearchDictionary: def __init__(self): pass def add_word(self, word: str) -> None: pass def search(self, word: str) -> bool: pass ``` # Examples: ```python dictionary = WordSearchDictionary() dictionary.add_word(\\"bad\\") dictionary.add_word(\\"dad\\") dictionary.add_word(\\"mad\\") print(dictionary.search(\\"pad\\")) # False print(dictionary.search(\\"bad\\")) # True print(dictionary.search(\\".ad\\")) # True print(dictionary.search(\\"b..\\")) # True print(dictionary.search(\\"b.d\\")) # True ``` # Constraints: 1. Words consist only of lowercase alphabets and the wildcard character `.`. 2. Maximum combined length of all words is 10^6. Note: Optimize for both time and space complexity while considering the edge cases like words composed of only wildcards or an empty dictionary. Good luck, and may your implementation be both correct and efficient!","solution":"class WordSearchDictionary: def __init__(self): self.words = {} def add_word(self, word: str) -> None: length = len(word) if length not in self.words: self.words[length] = [] self.words[length].append(word) def search(self, word: str) -> bool: length = len(word) if length not in self.words: return False for w in self.words[length]: if self._match(w, word): return True return False def _match(self, word: str, pattern: str) -> bool: for wc, pc in zip(word, pattern): if pc != \'.\' and wc != pc: return False return True"},{"question":"Context & Objective Suppose you are tasked with analyzing text data where you need to determine structural similarities between various pairs of strings. Your goal is to write a function that checks whether two input strings are isomorphic. By definition, two strings are isomorphic if the characters in each string can be replaced to get the other string, ensuring no two characters map to the same character, although a character may map to itself. Task Description Write a function `check_isomorphism` that takes in two strings `str1` and `str2` as input parameters and returns a boolean value indicating if they are isomorphic. Input and Output Formats * **Input**: ```python def check_isomorphism(str1, str2): # Your implementation here ``` - `str1`: a string containing lowercase alphabets. - `str2`: a string containing lowercase alphabets. * **Output**: A boolean value (`True` or `False`). - `True` if `str1` and `str2` are isomorphic. - `False` otherwise. Constraints * `1 <= len(str1), len(str2) <= 1000` * Both strings consist only of printable ASCII characters. Example Example 1: * **Input**: `str1 = \\"egg\\"`, `str2 = \\"add\\"` * **Output**: `True` Example 2: * **Input**: `str1 = \\"foo\\"`, `str2 = \\"bar\\"` * **Output**: `False` Example 3: * **Input**: `str1 = \\"paper\\"`, `str2 = \\"title\\"` * **Output**: `True` Performance Requirements Your solution should maintain a linear time complexity relative to the input size, i.e., (O(n)). Additional Notes Consider various edge cases such as whether the lengths of the strings are equal and whether mapping consistency is maintained throughout the strings.","solution":"def check_isomorphism(str1, str2): Checks if two strings are isomorphic. Parameters: - str1: first input string - str2: second input string Returns: - True if both strings are isomorphic, False otherwise if len(str1) != len(str2): return False mapping_str1_to_str2 = {} mapping_str2_to_str1 = {} for char1, char2 in zip(str1, str2): if char1 in mapping_str1_to_str2: if mapping_str1_to_str2[char1] != char2: return False else: if char2 in mapping_str2_to_str1 and mapping_str2_to_str1[char2] != char1: return False mapping_str1_to_str2[char1] = char2 mapping_str2_to_str1[char2] = char1 return True"},{"question":"Question # Problem Statement You are required to implement an optimized version of the Quick Sort algorithm. Your function should sort an array of integers efficiently, optimizing for both average and worst-case scenarios. Specifically, you should: 1. Use a randomized pivot to avoid the worst-case performance on nearly sorted or identical elements. 2. Implement tail recursion optimization where applicable. 3. For small sub-arrays (size ≤ 10), switch to Insertion Sort for better performance. # Function Signature ```python def optimized_quick_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the optimized Quick Sort algorithm. Parameters: - arr: List[int] : List of integers to be sorted Returns: - List[int] : Sorted list of integers ``` # Input - `arr`: A list of integers of length between 0 and (10^5). # Output - A list of integers sorted in non-decreasing order. # Constraints - Handle the input within linearithmic time complexity in most cases. - Optimize for space and performance based on the given guidelines. - Avoid recursion depth exceeding Python\'s limit to prevent stack overflow. # Example ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] assert optimized_quick_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert optimized_quick_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] ``` # Notes - You should ensure proper handling of edge cases, such as empty arrays, arrays with all identical elements, and already sorted arrays. - Only the function implementation is required; no need for additional script or main guard.","solution":"import random from typing import List def insertion_sort(arr: List[int], low: int, high: int) -> None: for i in range(low + 1, high + 1): key = arr[i] j = i - 1 while j >= low and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key def _quick_sort(arr: List[int], low: int, high: int) -> None: while low < high: if high - low <= 10: insertion_sort(arr, low, high) break else: pivot_index = random.randint(low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] i = low - 1 for j in range(low, high): if arr[j] < pivot_value: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] pivot_index = i + 1 if pivot_index - low < high - pivot_index: _quick_sort(arr, low, pivot_index - 1) low = pivot_index + 1 else: _quick_sort(arr, pivot_index + 1, high) high = pivot_index - 1 def optimized_quick_sort(arr: List[int]) -> List[int]: if len(arr) <= 1: return arr _quick_sort(arr, 0, len(arr) - 1) return arr"},{"question":"Context: You are implementing a specialized iterator for iterating over multiple lists (or sequences) in a zigzag fashion. The iterator should take any number of input lists and allow iteration such that it alternates between elements of each list in the order they are given until all lists are exhausted. Task: Write a class `ZigzagIterator` that provides `next` and `has_next` methods. The class should be initialized with any number of lists as input and must iterate over them in the alternating order. Requirements: 1. **Initialization**: The iterator should be initialized with any number of lists. 2. **Methods**: - `next`: Returns the next element in the zigzag order. - `has_next`: Returns `True` if there are more elements to iterate over, `False` otherwise. Input and Output Formats: ```python class ZigzagIterator: def __init__(self, *args): Initialize your data structure here. :param args: List of lists to be iterated in zigzag order. def next(self): :return: The next element in the zigzag order. :rtype: int def has_next(self): :return: True if there is a next element, False otherwise. :rtype: bool ``` Constraints: 1. The input lists may have different lengths. 2. Ensure that the operations `next` and `has_next` run in constant time. Example: ```python l1 = [1, 2] l2 = [3, 4, 5, 6] l3 = [7, 8, 9] it = ZigzagIterator(l1, l2, l3) result = [] while it.has_next(): result.append(it.next()) print(result) # Output: [1, 3, 7, 2, 4, 8, 5, 9, 6] ``` Edge Cases to Consider: 1. Empty lists. 2. Lists with unequal lengths. 3. All lists being exhausted at different times. Hints (Optional): - Maintain a queue of non-empty lists and cycle through them to fetch the next element. - Keep track of the current state to handle the alternating sequence effectively.","solution":"from collections import deque class ZigzagIterator: def __init__(self, *args): Initialize your data structure here. :param args: List of lists to be iterated in zigzag order. self.queue = deque([iter(lst) for lst in args if lst]) self.next_elem = None self._advance() def _advance(self): Advances the iterator to the next available element if not self.queue: self.next_elem = None return for _ in range(len(self.queue)): iterator = self.queue.popleft() self.queue.append(iterator) try: self.next_elem = next(iterator) return except StopIteration: self.queue.pop() self.next_elem = None def next(self): :return: The next element in the zigzag order. :rtype: int if not self.has_next(): raise StopIteration(\\"No more elements\\") result = self.next_elem self._advance() return result def has_next(self): :return: True if there is a next element, False otherwise. :rtype: bool return self.next_elem is not None"},{"question":"# Graph Traversal Assessment You are tasked with implementing both Depth First Search (DFS) and Breadth First Search (BFS) graph traversal algorithms. Given an undirected graph represented as an adjacency list and a starting node, write two functions that perform the traversals. Implement the following functions: 1. `depth_first_search(graph, start)`: Performs DFS traversal iteratively and returns a list of nodes in the order they are visited. 2. `breadth_first_search(graph, start)`: Performs BFS traversal and returns a list of nodes in the order they are visited. Input Format - `graph`: A dictionary where keys are node identifiers and values are lists of adjacent nodes. Example: `{0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}` - `start`: The starting node for traversal. Output Format - A list of nodes visited in the order of traversal. Constraints - The graph is connected and can have up to 1000 nodes. - Node identifiers are integers. - The graph may have cycles. Example ```python graph = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1] } start_node = 0 # Expected DFS traversal order starting from node 0: [0, 2, 1, 3] # Expected BFS traversal order starting from node 0: [0, 1, 2, 3] assert depth_first_search(graph, start_node) == [0, 2, 1, 3] assert breadth_first_search(graph, start_node) == [0, 1, 2, 3] ``` Performance Requirements - Ensure the function performs efficiently with a time complexity of O(V + E) and a space complexity of O(V).","solution":"def depth_first_search(graph, start): visited = [] stack = [start] while stack: node = stack.pop() if node not in visited: visited.append(node) stack.extend(reversed(graph[node])) return visited def breadth_first_search(graph, start): visited = [] queue = [start] while queue: node = queue.pop(0) if node not in visited: visited.append(node) queue.extend(graph[node]) return visited"},{"question":"# Question: Implement an Optimized Hash Table with Specific Operations You are required to implement an optimized resizable hash table class that includes additional operations: 1. Retrieve all active keys (excluding deleted ones). 2. Resize only when specific conditions are met to avoid frequent resizing overhead. **Class Definition**: ```python class OptimizedResizableHashTable(HashTable): An optimized resizable hash table. def __init__(self, initial_size=8): Initialize the hash table with a given initial size. pass def put(self, key, value): Insert or update the given key-value pair into the hash table. pass def get(self, key): Return the value associated with the given key or None if not found. pass def delete(self, key): Remove the given key from the hash table. pass def __resize(self): Resize the hash table based on specific criteria. pass def get_active_keys(self): Return a list of all active keys in the hash table. pass ``` **Expected Functionality**: 1. **insert(key, value)**: Inserts the given key-value pair. Resizes the table if it is 2/3 full. If the key already exists, update its value. 2. **get(key)**: Returns the value for the given key, or `None` if the key is not present. 3. **delete(key)**: Deletes the key-value pair from the table if found. 4. **get_active_keys()**: Returns a list of all active keys excluding any deleted ones. 5. **__resize()**: Resizes the hash table when it is 2/3 full. This function should ensure keys and values are rehashed correctly. 6. **Properly handle edge cases**: Including but not limited to, when the table is initially empty, deleting non-existent keys, and inserting duplicate keys. # Constraints: 1. The keys will be non-negative integers. 2. The values can be any data type. 3. The initial size parameter should be greater than or equal to 8. 4. The hash table should dynamically resize when it gets 2/3 full to avoid excessive probing times. **Performance Requirements**: - Ensure the average-case time complexity for insert, search, and delete operations remains O(1).","solution":"class OptimizedResizableHashTable: An optimized resizable hash table. def __init__(self, initial_size=8): Initialize the hash table with a given initial size. self.size = initial_size self.count = 0 self.table = [None] * initial_size self.deleted = [False] * initial_size def put(self, key, value): Insert or update the given key-value pair into the hash table. if self.count >= self.size * 2 // 3: self.__resize() index = self.__hash(key) while self.table[index] is not None and self.table[index][0] != key: index = (index + 1) % self.size if self.table[index] is None: self.count += 1 self.table[index] = (key, value) self.deleted[index] = False def get(self, key): Return the value associated with the given key or None if not found. index = self.__hash(key) for _ in range(self.size): if self.table[index] is None: return None if self.table[index][0] == key and not self.deleted[index]: return self.table[index][1] index = (index + 1) % self.size return None def delete(self, key): Remove the given key from the hash table. index = self.__hash(key) for _ in range(self.size): if self.table[index] is None: return if self.table[index][0] == key and not self.deleted[index]: self.deleted[index] = True self.count -= 1 return index = (index + 1) % self.size def __resize(self): new_size = self.size * 2 new_table = OptimizedResizableHashTable(new_size) for i in range(self.size): if self.table[i] is not None and not self.deleted[i]: new_table.put(self.table[i][0], self.table[i][1]) self.size = new_size self.table = new_table.table self.deleted = [False] * new_size def get_active_keys(self): Return a list of all active keys in the hash table. active_keys = [] for i in range(self.size): if self.table[i] is not None and not self.deleted[i]: active_keys.append(self.table[i][0]) return active_keys def __hash(self, key): return key % self.size"},{"question":"# Question You are given an array of integers and a target integer. Write a function `two_sum(array, target)` that finds two distinct indices `i` and `j` in the array such that the numbers at these indices sum to the target integer. The function should return a tuple `(i, j)` if such indices exist, otherwise return `None`. Each input has exactly one solution, and you may not use the same element twice. # Input * `array`: A list of integers `[-10^9, 10^9]` (length `n`, `2 <= n <= 10^6`) * `target`: An integer within the same range as the array elements # Output * A tuple of two integers `(i, j)` representing the indices of the elements that sum to the target * Return `None` if no valid indices are found # Example ```python # Example 1 array = [2, 7, 11, 15] target = 9 # 2 + 7 = 9, therefore the function should return (0, 1) print(two_sum(array, target)) # Output: (0, 1) # Example 2 array = [1, 5, 9] target = 10 # 1 + 9 = 10, therefore the function should return (0, 2) print(two_sum(array, target)) # Output: (0, 2) # Example 3 array = [-3, 4, 3, 90] target = 0 # -3 + 3 = 0, therefore the function should return (0, 2) print(two_sum(array, target)) # Output: (0, 2) # Edge case: No valid indices array = [1, 2, 3] target = 7 print(two_sum(array, target)) # Output: None ``` # Constraints - Assume each input has exactly one solution. - You may not use the same element twice. # Notes - Ensure your implementation is efficient, ideally with a time complexity of O(n). - Clearly handle edge cases such as very large or very small arrays, negative numbers, and zeros.","solution":"def two_sum(array, target): Finds two distinct indices i and j in the array such that the numbers at these indices sum to the target integer. Returns a tuple (i, j) if such indices exist, otherwise returns None. num_to_index = {} for i, num in enumerate(array): complement = target - num if complement in num_to_index: return (num_to_index[complement], i) num_to_index[num] = i return None"},{"question":"# Task Implement a function `kth_largest_element` that finds the kth largest element in an unsorted array using the max heap. Your implementation should use the Max Heap Sort algorithm described above but optimize it specifically for finding the kth largest element without sorting the entire array. # Requirements - **Function Name**: kth_largest_element - **Input**: - `arr` - A list of integers. - `k` - An integer indicating the kth largest element to find (1-based index). - **Output**: - An integer representing the kth largest element in the array. - **Constraints**: - 1 ≤ k ≤ len(arr) - The array can contain negative numbers and duplicate values. # Performance Requirements - Your solution should aim for an average case time complexity of O(n log(k)). # Example Scenario Given the array `[3, 2, 1, 5, 6, 4]` and `k = 2`, the function should return `5` as the 2nd largest element. # Function Signature ```python def kth_largest_element(arr, k: int) -> int: # Your implementation here ``` # Notes - Consider optimizing heap operations to find the kth largest element without sorting the entire array. - Implement error handling for edge cases such as empty arrays and invalid `k` values (though such cases are out of constraint).","solution":"import heapq def kth_largest_element(arr, k): Finds the kth largest element in an unsorted array using a max heap. Parameters: arr (list of int): A list of integers k (int): The kth largest element to find (1-based index) Returns: int: The kth largest element in the array if not arr or k < 1 or k > len(arr): raise ValueError(\\"Invalid input: check the array and k.\\") # Use a min heap to always maintain the k largest elements in the heap min_heap = [] for num in arr: heapq.heappush(min_heap, num) if len(min_heap) > k: # Keep the size of the heap to k heapq.heappop(min_heap) # The root of the min-heap (the first element) is the kth largest element return min_heap[0]"},{"question":"# Scenario You are tasked with designing a task scheduler using a queue system. You need to implement and test different queue functionalities using both array-based and linked list-based queue implementations. # Task Implement an efficient task scheduler using both ArrayQueue and LinkedListQueue implementation that supports the following functionalities: 1. **enqueue_task(task_id: int)**: Adds a task to the queue. 2. **dequeue_task() -> int**: Removes and returns the front task from the queue. 3. **view_next_task() -> int**: Returns the front task without removing it. 4. **current_task_count() -> int**: Returns the number of tasks in the queue. 5. **is_task_queue_empty() -> bool**: Returns whether the queue is empty. # Requirements - Implement the `TaskScheduler` class with: 1. `__init__(self, use_linkedlist: bool = False)`: Initializes the scheduler. Use LinkedListQueue if `use_linkedlist=True`, otherwise use ArrayQueue. 2. The required methods listed above using the chosen queue implementation. # Constraints - You should handle edge cases such as performing `dequeue_task` or `view_next_task` on an empty queue. - You need to ensure the operations adhere to the performance requirements: * enqueue_task and dequeue_task should run in O(1) time. # Example ```python scheduler = TaskScheduler() scheduler.enqueue_task(1) scheduler.enqueue_task(2) print(scheduler.view_next_task()) # Output: 1 print(scheduler.dequeue_task()) # Output: 1 print(scheduler.current_task_count()) # Output: 1 print(scheduler.is_task_queue_empty()) # Output: False scheduler.dequeue_task() print(scheduler.is_task_queue_empty()) # Output: True ``` # Performance Note - Assume the number of tasks will not exceed 10,000. - Ensure your implementation can handle a high-frequency task addition and removal efficiently.","solution":"# Array-based Queue Implementation class ArrayQueue: def __init__(self): self.queue = [] def enqueue(self, task_id: int): self.queue.append(task_id) def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") return self.queue.pop(0) def front(self) -> int: if self.is_empty(): raise IndexError(\\"front from empty queue\\") return self.queue[0] def size(self) -> int: return len(self.queue) def is_empty(self) -> bool: return len(self.queue) == 0 # Node class for Linked List based Queue class Node: def __init__(self, task_id=None): self.task_id = task_id self.next = None # Linked List-based Queue Implementation class LinkedListQueue: def __init__(self): self.front_node = None self.rear_node = None self.count = 0 def enqueue(self, task_id: int): new_node = Node(task_id) if self.is_empty(): self.front_node = self.rear_node = new_node else: self.rear_node.next = new_node self.rear_node = new_node self.count += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"dequeue from empty queue\\") task_id = self.front_node.task_id self.front_node = self.front_node.next if self.front_node is None: # If the queue is now empty self.rear_node = None self.count -= 1 return task_id def front(self) -> int: if self.is_empty(): raise IndexError(\\"front from empty queue\\") return self.front_node.task_id def size(self) -> int: return self.count def is_empty(self) -> bool: return self.count == 0 class TaskScheduler: def __init__(self, use_linkedlist: bool = False): if use_linkedlist: self.queue = LinkedListQueue() else: self.queue = ArrayQueue() def enqueue_task(self, task_id: int): self.queue.enqueue(task_id) def dequeue_task(self) -> int: return self.queue.dequeue() def view_next_task(self) -> int: return self.queue.front() def current_task_count(self) -> int: return self.queue.size() def is_task_queue_empty(self) -> bool: return self.queue.is_empty()"},{"question":"# Question: Implement Cycle Sort As an exercise in understanding sorting algorithms and in-place sorting, implement the Cycle Sort algorithm. This algorithm is known for its minimal write operations despite its quadratic time complexity. Function Signature ```python def cycle_sort(arr: List[int]) -> List[int]: ``` Input - `arr`: A list of integers to be sorted. - Constraints: - The length of the array `n` is such that 1 <= n <= 10^5. - Each element `arr[i]` is an integer such that -10^9 <= arr[i] <= 10^9. Output - Returns the sorted list of integers in ascending order. Example ```python assert cycle_sort([4, 2, 3, 1]) == [1, 2, 3, 4] assert cycle_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert cycle_sort([6, 2, 5, 3, 1, 4]) == [1, 2, 3, 4, 5, 6] assert cycle_sort([]) == [] assert cycle_sort([3]) == [3] ``` Constraints to Consider - Take special care of edge cases, such as duplicates and already sorted arrays. - Ensure that the solution does not use extra space beyond the input array. Performance - Aim to keep your implementation in line with the documented O(N^2) time complexity and O(1) additional space complexity. Context You work as a software engineer at a company that designs firmware for flash-based storage devices. Your team is tasked with optimizing the number of writes in the sorting processes due to the finite endurance of flash memory cells. Implementing Cycle Sort will provide a good balance between write minimization and the acceptable computation time for the size of your datasets.","solution":"from typing import List def cycle_sort(arr: List[int]) -> List[int]: n = len(arr) for cycle_start in range(0, n - 1): item = arr[cycle_start] pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 if pos == cycle_start: continue while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] return arr"},{"question":"You are given a stack of integers. Your goal is to determine if the stack contains a sequence of consecutive integers from the bottom to the top. Using the insights provided in the two approaches above, your task is to implement a third version that handles larger stacks more efficiently. Function Signature Implement a function named `third_is_consecutive` with the following signature: ```python def third_is_consecutive(stack: list[int]) -> bool: ``` Input * `stack`: List of integers representing the stack where the first element denotes the bottom and the last denotes the top. Output * Return `True` if the stack contains consecutive integers from bottom to top, otherwise return `False`. Constraints * You must not use any other data structures for auxiliary storage other than an integer counter or a single additional variable. * The solution must handle stacks with up to (10^5) integers efficiently. Example ```python stack = [3, 4, 5, 6, 7] print(third_is_consecutive(stack)) # Output: True stack = [3, 4, 6, 7] print(third_is_consecutive(stack)) # Output: False stack = [7, 6, 5, 4, 3] print(third_is_consecutive(stack)) # Output: False stack = [] print(third_is_consecutive(stack)) # Output: True stack = [3] print(third_is_consecutive(stack)) # Output: True ``` This question tests your understanding of stacks and algorithms to determine consecutive sequences. It assesses your ability to optimize space usage while maintaining functionality and correctness.","solution":"def third_is_consecutive(stack): Determines if the stack contains consecutive integers from bottom to top. Args: stack (list[int]): List of integers representing the stack where the first element is the bottom and the last element is the top. Returns: bool: True if the stack contains consecutive integers from bottom to top, otherwise False. if not stack: # An empty stack is considered to be consecutive return True for i in range(1, len(stack)): if stack[i] != stack[i - 1] + 1: return False return True"},{"question":"You are provided with an array of integers `nums` where exactly two elements appear only once and all other elements appear exactly twice. Implement the function `single_number3(nums)` to find and return the two elements that appear only once. You should optimize your solution to have a time complexity of O(N) and a space complexity of O(1). # Example Given the array `nums = [1, 2, 1, 3, 2, 5]`, the function should return `[3, 5]` or `[5, 3]`. # Constraints - The length of the array will be an even number. - The array will have exactly two elements that appear only once. - All other elements will appear exactly twice. - Time Complexity should be O(N). - Space Complexity should be O(1). # Function Signature ```python def single_number3(nums: List[int]) -> List[int]: pass ``` # Explanation 1. Use XOR to find the XOR of the two unique numbers which we denote as A and B. 2. Find the rightmost set bit in the result from step 1. 3. Partition the numbers into two groups using the set bit identified in step 2. 4. XOR the numbers in each group to find the two unique numbers. Your implementation will receive a list of integers, and it should return a list containing the two unique integers.","solution":"from typing import List def single_number3(nums: List[int]) -> List[int]: # Step 1: XOR all the numbers to get the XOR of the two unique numbers xor_all = 0 for num in nums: xor_all ^= num # Step 2: Get the rightmost set bit (a bit that is 1) in the xor_all # We use the property of two\'s complement to isolate the rightmost set bit rightmost_set_bit = xor_all & -xor_all # Step 3: Use the rightmost set bit to partition the numbers into two groups and XOR each group num1, num2 = 0, 0 for num in nums: if num & rightmost_set_bit: num1 ^= num else: num2 ^= num return [num1, num2]"},{"question":"You are provided with a `SegmentTree` class that supports range queries over an array with a given associative function like sum, min, or max. An incomplete implementation is provided to illustrate the structure. Your task is to extend this class by implementing the `update` method to allow updating an array element and adjusting the segment tree accordingly. Additionally, ensure that the segment tree appropriately handles edge cases and maintains efficiency. # Function Signature ```python class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]) -> None: # constructor implementation def make_tree(self, i: int, l: int, r: int) -> None: # implementation for constructing tree def __query(self, i: int, L: int, R: int, l: int, r: int) -> Optional[int]: # implementation for querying tree def query(self, L: int, R: int) -> Optional[int]: # implementation to return the result of the range query def update(self, index: int, value: int) -> None: # implementation to update an element in the array and the segment tree ``` # Input - **arr**: List of integers. - **function**: A functional argument that defines the operation to be performed on range queries (e.g., sum, min, max). # Output - **query(L, R)**: Returns the result of the given function operated over the range [L, R] of the array. - **update(index, value)**: Updates an element at position `index` with `value` and updates the segment tree accordingly. # Constraints - 1 <= len(arr) <= 10^5 - 0 <= L <= R < len(arr) - 0 <= index < len(arr) # Example ```python # Example usage of the SegmentTree class after extending it: # Testing the sum function with update arr = [1, 3, 5] segment_tree = SegmentTree(arr, sum) print(segment_tree.query(0, 2)) # Output: 9 segment_tree.update(1, 2) # arr becomes [1, 2, 5] print(segment_tree.query(0, 2)) # Output: 8 # Testing the max function with update arr = [1, 3, 5] segment_tree = SegmentTree(arr, max) print(segment_tree.query(0, 2)) # Output: 5 segment_tree.update(2, 7) # arr becomes [1, 3, 7] print(segment_tree.query(0, 2)) # Output: 7 ``` # Notes - Focus on maintaining the efficiency of the segment tree during execution. - Consider handling edge cases for both segment construction and query processes. - Ensure your solution is robust and can handle the upper limits of the constraints efficiently.","solution":"from typing import List, Callable, Optional class SegmentTree: def __init__(self, arr: List[int], function: Callable[[int, int], int]) -> None: self.function = function self.n = len(arr) self.tree = [0] * (2 * self.n) # Building the segment tree self.build(arr) def build(self, arr: List[int]) -> None: # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.function(self.tree[2 * i], self.tree[2 * i + 1]) def update(self, index: int, value: int) -> None: # Update the value at the original array index and propagate the change upwards pos = self.n + index self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.function(self.tree[2 * pos], self.tree[2 * pos + 1]) def query(self, L: int, R: int) -> Optional[int]: # Range is inclusive L += self.n R += self.n result = None while L <= R: if L % 2 == 1: result = self.tree[L] if result is None else self.function(result, self.tree[L]) L += 1 if R % 2 == 0: result = self.tree[R] if result is None else self.function(result, self.tree[R]) R -= 1 L //= 2 R //= 2 return result"},{"question":"**Problem Statement:** You are tasked with implementing a function to convert an integer from its decimal representation to an arbitrary base and vice versa. This is useful in contexts where numbers need to be displayed or transmitted in various base encodings such as hexadecimal (base 16) or binary (base 2). # Function 1: `int_to_base(num: int, base: int) -> str` **Input:** - `num`: An integer (both positive and negative are possible). - `base`: An integer between 2 and 36 inclusive, representing the target base. **Output:** - Returns the string representation of `num` in the specified base. # Function 2: `base_to_int(str_to_convert: str, base: int) -> int` **Input:** - `str_to_convert`: A string representing the number in the specified base. - `base`: An integer between 2 and 36 inclusive. **Output:** - Returns the integer converted from `str_to_convert` in the specified base. # Requirements: 1. Implement the functions without using Python\'s built-in `int()` or any direct conversion utilities. 2. Consider handling negative integers for `int_to_base`. 3. Ensure that `base_to_int` correctly identifies invalid characters based on the base provided. # Constraints: - `num` can range from (-2^{31}) to (2^{31}-1). - The `str_to_convert` has valid characters according to the provided base. - Performance expectations: Your solution should efficiently handle inputs up to the given constraint limits. # Example: ```python assert int_to_base(5, 2) == \'101\' assert int_to_base(-255, 16) == \'-FF\' assert base_to_int(\'101\', 2) == 5 assert base_to_int(\'FF\', 16) == 255 ``` Using these functions, you can convert numbers between bases and validate your understanding of number systems and conversions.","solution":"def int_to_base(num: int, base: int) -> str: Converts an integer to a string representation in a specified base from 2 to 36. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") if num == 0: return \\"0\\" digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" negative = num < 0 num = abs(num) result = [] while num: result.append(digits[num % base]) num //= base if negative: result.append(\'-\') return \'\'.join(result[::-1]) def base_to_int(str_to_convert: str, base: int) -> int: Converts a string representation of a number in the specified base to a decimal integer. if base < 2 or base > 36: raise ValueError(\\"Base must be between 2 and 36 inclusive.\\") digits = \\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" str_to_convert = str_to_convert.upper() result = 0 negative = str_to_convert[0] == \'-\' if negative: str_to_convert = str_to_convert[1:] for char in str_to_convert: if char not in digits[:base]: raise ValueError(f\\"Character {char} is not valid for base {base}\\") result = result * base + digits.index(char) return -result if negative else result"},{"question":"# Context You are asked to improve the primary ordered stack provided by creating a function that allows batch insertion of elements while maintaining the order. # Problem Statement Implement a function `batch_push` for the `OrderedStack` class that allows pushing an array of elements into the stack in one go while maintaining the order. # Function Specification ```python class OrderedStack: # Other methods as provided... def batch_push(self, items): Push a list of items into the stack maintaining the ordered property. :param items: A list of elements to be pushed. # Your code here ``` # Input * `items`: A list of integers, which may contain duplicates or already ordered elements (1 <= len(items) <= 10^5). # Output The function should modify the stack in-place, so no return value is needed. # Constraints * The elements in `items` should be inserted into the stack such that the largest value is at the top. * The stack and the array length combined guarantee at most 10^5 operations in a reasonable time. # Example ```python # Initialize the stack ordered_stack = OrderedStack() # batch push elements into the stack ordered_stack.batch_push([3, 5, 1, 4]) print([ordered_stack.pop() for _ in range(ordered_stack.size())]) # Output: [5, 4, 3, 1] ``` # Notes - Ensure that the function `batch_push` leverages the current structure to maintain performance efficiency. - Handle edge cases efficiently, like pushing into an empty stack or multiple repeated values.","solution":"class OrderedStack: def __init__(self): self.stack = [] def push(self, item): self.stack.append(item) self.stack.sort(reverse=True) def pop(self): if not self.is_empty(): return self.stack.pop(0) # returns the top element as stack is highest element first def is_empty(self): return len(self.stack) == 0 def size(self): return len(self.stack) def batch_push(self, items): self.stack.extend(items) self.stack.sort(reverse=True)"},{"question":"# Factorial Problem with Modulo You are tasked with writing a function that calculates the factorial of a non-negative integer ( n ) with an optional modulo operation. The factorial of ( n ) is defined as ( n! = n times (n-1) times (n-2) times ldots times 1 ) with ( 0! = 1 ). For very large ( n ), you are allowed to return the result modulo some positive integer `mod` if specified. Implement a function `compute_factorial(n, mod=None)` that uses an iterative approach to compute the factorial. You need to handle errors gracefully and ensure the function is efficient for larger values of ( n ). **Function Signature**: ```python def compute_factorial(n: int, mod: int = None) -> int: pass ``` **Input**: - `n`: A non-negative integer representing the number to compute the factorial for. - `mod`: An optional positive integer used to take the modulo of the result. **Output**: - Return an integer representing ( n! ) if `mod` is not provided. - Return an integer representing ( n! ) modulo `mod` if `mod` is provided. **Constraints**: - ( 0 leq n leq 10^5 ) - ( 1 leq mod leq 10^9 ) (if provided) **Examples**: ```python compute_factorial(5) # Returns: 120 compute_factorial(5, 3) # Returns: 0 compute_factorial(0) # Returns: 1 compute_factorial(10, 11) # Returns: 10 ``` **Additional Requirements**: - Ensure your function handles invalid input cases gracefully by raising appropriate error messages. - Your implementation should be efficient to handle the upper limits of the constraints.","solution":"def compute_factorial(n: int, mod: int = None) -> int: if not isinstance(n, int) or n < 0: raise ValueError(\\"n must be a non-negative integer\\") if mod is not None and (not isinstance(mod, int) or mod <= 0): raise ValueError(\\"mod must be a positive integer if provided\\") result = 1 for i in range(1, n + 1): result *= i if mod: result %= mod return result"},{"question":"You are given a sorted list of integers without duplicates. You need to implement a function that summarizes its ranges. A range is a sequence of two or more consecutive integers. **Function Signature**: ```python def summarize_ranges(array: List[int]) -> List[str]: ``` **Input**: - `array` (List[int]): A sorted list of unique integers. **Output**: - List[str]: A list of strings representing the summary of ranges. Each string should follow the format: - \\"a-b\\" if the range contains multiple elements from `a` to `b`. - \\"a\\" if the range contains only a single element `a`. **Constraints**: - The input list will have at least one and at most 10^4 elements. - The integer values in the list will be within the range of all possible 32-bit signed integers. **Examples**: 1. Input: `[0, 1, 2, 4, 5, 7]` Output: `[\\"0-2\\", \\"4-5\\", \\"7\\"]` 2. Input: `[1, 3, 4, 5, 7, 9, 10, 11]` Output: `[\\"1\\", \\"3-5\\", \\"7\\", \\"9-11\\"]` 3. Input: `[0, 2, 4, 6, 8]` Output: `[\\"0\\", \\"2\\", \\"4\\", \\"6\\", \\"8\\"]` **Edge Cases to Consider**: - The input list is empty. - The input list contains only one element. - All elements in the input list are non-consecutive. Implement the `summarize_ranges` function to meet the above specifications.","solution":"from typing import List def summarize_ranges(array: List[int]) -> List[str]: if not array: return [] ranges = [] start = array[0] end = array[0] for i in range(1, len(array)): if array[i] == end + 1: end = array[i] else: if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") start = array[i] end = array[i] if start == end: ranges.append(f\\"{start}\\") else: ranges.append(f\\"{start}-{end}\\") return ranges"},{"question":"**Question: Stack Pair-Switching Algorithm Implementation** # Problem Description You are tasked with implementing a function to switch successive pairs of numbers in a stack starting from the bottom. Specifically, given a stack, you should write a function that switches the bottom-most pair, the next pair, and so forth. If there is an odd number of elements, the top-most element remains unmoved. # Function Signature ```python def switch_pairs(stack: List[int]) -> List[int]: # Your code here ``` # Input: - A list of integers representing the stack arranged from bottom to top `[bottom, ..., top]`. # Output: - A modified list of integers representing the stack after pairs have been switched `[bottom, ..., top]`. # Constraints: 1. The stack can have any number of integer elements, including zero or one. 2. Your solution should handle both even and odd counts of elements. # Examples: Example 1: Input: ```python [3, 8, 17, 9, 1, 10] ``` Output: ```python [8, 3, 9, 17, 10, 1] ``` Example 2: Input: ```python [3, 8, 17, 9, 1] ``` Output: ```python [8, 3, 9, 17, 1] ``` # Instructions: 1. Create an empty auxiliary data structure. 2. Implement the necessary logic to reverse the input in auxiliary storage and switch the pairs. 3. Return the modified stack. # Optional Challenges: 1. Implement the solution without using any additional data structures, if possible, considering the constraints and expected complexities. 2. Evaluate space efficiency and suggest improvements for minimizing auxiliary space further.","solution":"def switch_pairs(stack): Switch successive pairs of numbers in a stack starting from the bottom. :param stack: List[int] - List representing the stack from bottom to top. :return: List[int] - Modified stack with pairs switched. n = len(stack) result = stack[:] # Process elements in pairs, swapping adjacent elements for i in range(0, n - 1, 2): result[i], result[i + 1] = result[i + 1], result[i] return result"},{"question":"# Question Given a 2D matrix where each row and column is sorted in non-decreasing order, write a function `find_key_in_matrix(matrix, key)` that returns the position (row, column) of the given key if it is present in the matrix. If the key is not present, the function should return `None`. Input: - `matrix`: List of lists, where each inner list represents a row of the matrix, sorted in non-decreasing order. - `key`: An integer to be searched within the matrix. Output: - A tuple (row, column) representing the position of the key if found (1-indexed). - `None` if the key is not present in the matrix. Constraints: - The number of rows and columns in the matrix will be at most 10^3. - The elements in the matrix are integers in the range [-10^6, 10^6]. # Example: ```python def find_key_in_matrix(matrix, key): # Your code here # Example usage: matrix = [ [2, 5, 7], [4, 8, 13], [9, 11, 15], [12, 17, 20] ] key = 13 assert find_key_in_matrix(matrix, key) == (2, 3) # (1-indexed) assert find_key_in_matrix(matrix, 1) == None ``` Explanation: For the matrix given and the key 13, the function should return (2, 3) because the key 13 is present in the second row and the third column of the matrix.","solution":"def find_key_in_matrix(matrix, key): rows = len(matrix) cols = len(matrix[0]) if rows > 0 else 0 # Start from the top-right corner row, col = 0, cols - 1 while row < rows and col >= 0: if matrix[row][col] == key: return (row + 1, col + 1) # 1-indexed elif matrix[row][col] > key: col -= 1 else: row += 1 return None"},{"question":"# Question: Implement Red-Black Tree Deletion with Reinsertion Fix Problem Statement You are given a partially implemented Red-Black Tree (RBT) which supports insertion and basic deletion. Your task is to complete the `reinsert` function that rebalances the tree when: 1. A node is temporarily removed. 2. A new node is inserted in a consistent manner that adheres to RBT properties. Requirements: 1. **Function Signature:** `def reinsert(self, node):` 2. **Input:** - `node`: An instance of `RBNode` to be reintegrated into the tree. 3. **Output:** - The tree must be balanced and satisfy all RBT properties post re-insertion. Constraints: 1. Ensure node colors are correctly updated during re-insertion. 2. Handle cases where re-insertion results in violations of RBT properties. 3. The tree should remain valid, consistent, and balanced after the operation. ```python class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None # Assume other methods like insert, left_rotate, right_rotate, etc., are already implemented. def reinsert(self, node): # TODO: Complete the reinsertion logic, ensuring tree is balanced as a valid RBT pass # Example Usage: rb = RBTree() # Insert a series of values nodes = [RBNode(val, 1) for val in [10, 20, 5, 6, 15]] for node in nodes: rb.insert(node) print(rb.inorder()) # Reinsert a node to see if tree maintains Red-Black properties node_to_reinsert = RBNode(25, 1) rb.reinsert(node_to_reinsert) print(rb.inorder()) ``` # Evaluation Criteria: - Correctness: Adhere to all Red-Black Tree properties. - Edge cases: Handle edge cases effectively. - Complexity: Maintain (O(log n)) operations for re-insertion. - Code clarity and comments.","solution":"class RBNode: def __init__(self, val, is_red, parent=None, left=None, right=None): self.val = val self.parent = parent self.left = left self.right = right self.color = is_red class RBTree: def __init__(self): self.root = None def left_rotate(self, x): y = x.right x.right = y.left if y.left is not None: y.left.parent = x y.parent = x.parent if x.parent is None: # x is root self.root = y elif x == x.parent.left: x.parent.left = y else: x.parent.right = y y.left = x x.parent = y def right_rotate(self, y): x = y.left y.left = x.right if x.right is not None: x.right.parent = y x.parent = y.parent if y.parent is None: # y is root self.root = x elif y == y.parent.left: y.parent.left = x else: y.parent.right = x x.right = y y.parent = x def insert_fixup(self, z): while z.parent is not None and z.parent.color == 1: if z.parent == z.parent.parent.left: y = z.parent.parent.right if y and y.color == 1: z.parent.color = 0 y.color = 0 z.parent.parent.color = 1 z = z.parent.parent else: if z == z.parent.right: z = z.parent self.left_rotate(z) z.parent.color = 0 z.parent.parent.color = 1 self.right_rotate(z.parent.parent) else: y = z.parent.parent.left if y and y.color == 1: z.parent.color = 0 y.color = 0 z.parent.parent.color = 1 z = z.parent.parent else: if z == z.parent.left: z = z.parent self.right_rotate(z) z.parent.color = 0 z.parent.parent.color = 1 self.left_rotate(z.parent.parent) self.root.color = 0 def insert(self, z): y = None x = self.root while x is not None: y = x if z.val < x.val: x = x.left else: x = x.right z.parent = y if y is None: self.root = z elif z.val < y.val: y.left = z else: y.right = z z.left = None z.right = None z.color = 1 self.insert_fixup(z) def reinsert(self, node): self.insert(node) def inorder(self): def inorder_helper(node): return inorder_helper(node.left) + [node.val] + inorder_helper(node.right) if node else [] return inorder_helper(self.root) # Example Usage: rb = RBTree() # Insert a series of values nodes = [RBNode(val, 1) for val in [10, 20, 5, 6, 15]] for node in nodes: rb.insert(node) print(rb.inorder()) # Reinsert a node to see if tree maintains Red-Black properties node_to_reinsert = RBNode(25, 1) rb.reinsert(node_to_reinsert) print(rb.inorder())"},{"question":"# Radix Sort Application to Transaction IDs Consider a scenario where you are working with a large dataset of transaction IDs represented as integers. These transaction IDs need to be sorted in ascending order for efficient lookup and subsequent processing. Implement the `radix_sort` function to sort these transaction IDs efficiently. Function Specification **Function Name** ```python def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: ``` **Input** * `arr`: List of transaction IDs (integers) to be sorted. * `simulation` (default is False): A boolean flag for printing intermediate steps (iterations of the algorithm). **Output** * Returns a list of sorted transaction IDs. **Constraints** 1. 0 <= len(arr) <= 10^6 2. Each transaction ID is an integer within the range [0, 10^9]. **Performance Requirements** * The algorithm should have an average time complexity of O(nk), where `n` is the size of the input list and `k` is the number of digits in the largest number. Example ```python >>> radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) [2, 24, 45, 66, 75, 90, 170, 802] ``` Additional Information 1. Handle edge cases like an empty list or a list with one element. 2. Consider how the function will behave with \\"simulation=True\\" for educational purposes, ensuring it prints clearly the state of the list after each significant iteration.","solution":"from typing import List def counting_sort(arr: List[int], exp: int, simulation: bool=False) -> None: n = len(arr) output = [0] * n count = [0] * 10 for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 for i in range(1, 10): count[i] += count[i - 1] i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 for i in range(n): arr[i] = output[i] if simulation: print(f\\"Intermediate result with exp={exp}: {arr}\\") def radix_sort(arr: List[int], simulation: bool=False) -> List[int]: if not arr: return [] max_num = max(arr) exp = 1 while max_num // exp > 0: counting_sort(arr, exp, simulation) exp *= 10 return arr"},{"question":"Scenario A prominent data analysis company requires you to write an efficient function for analyzing datasets to determine the frequency distribution of elements. This functionality is vital for generating statistical insights into their data. Task Implement a function `get_histogram_values(input_list: list) -> dict` that computes the histogram of values in the provided list. The function should return a dictionary where each key is an element from the list and the corresponding value is the frequency of that element. Function Signature ```python def get_histogram_values(input_list: list) -> dict: pass ``` Input * `input_list`: A list of integers `input_list` (0 ≤ len(input_list) ≤ 10^6). The list can contain negative numbers and large positive numbers but will exclusively consist of integers. Output * A dictionary where the keys are the unique elements from the input list and the values are their frequencies. Constraints * The function should handle large lists efficiently. * The output dictionary does not need to be ordered. * The function should gracefully handle an empty list by returning an empty dictionary. Example ```python # Example 1 input_list = [3, 3, 2, 1] # Expected Output: {1: 1, 2: 1, 3: 2} # Example 2 input_list = [2, 3, 5, 5, 5, 6, 4, 3, 7] # Expected Output: {2: 1, 3: 2, 4: 1, 5: 3, 6: 1, 7: 1} # Example 3 input_list = [] # Expected Output: {} ``` Notes * Consider edge cases such as empty lists and lists with repeated or negative elements. * Ensure your solution is optimized for both time and space complexity.","solution":"def get_histogram_values(input_list: list) -> dict: Returns the histogram of values in the input list. histogram = {} for item in input_list: if item in histogram: histogram[item] += 1 else: histogram[item] = 1 return histogram"},{"question":"# Priority Queue Implementation and Operations You are given a task to enhance and extend the functionality of the existing Priority Queue implemented using a linear array. The current implementation supports basic operations such as insert (`push`) and extract minimum/maximum (`pop`). Your goal is to add new capabilities while ensuring efficiency. Provided Code You are given the following base code to work with: ```python import itertools class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = PriorityQueueNode(item, priority) for index, current in enumerate(self.priority_queue_list): if current.priority < node.priority: self.priority_queue_list.insert(index, node) return self.priority_queue_list.append(node) def pop(self): return self.priority_queue_list.pop().data ``` Task Requirements 1. **Enhance the Priority Queue Class**: - Implement a method `peek` that returns the item with the lowest priority without removing it from the queue. - Implement a method `contains` that checks if a specific item exists in the queue. - Optimize the `push` method to achieve a better average time complexity, ideally better than O(n). Input and Output Formats - **Input**: You will implement the methods that will not take any specific input through main function. Your methods will be directly tested. - **Output**: Outputs will be the result of operations like `peek`, `contains`, etc. Constraints - Assume all items and priorities are integers. - Priorities are not necessarily unique. If priorities are not specified, they should take the value of the item. Example ```python # Example Usage pq = PriorityQueue(items=[5, 4, 3], priorities=[5, 1, 9]) print(pq.size()) # Output: 3 pq.push(2, priority=7) print(pq.peek()) # Output: 4 print(pq.contains(3)) # Output: True print(pq.pop()) # Output: 4 ``` Notes - Ensure your code handles empty scenarios appropriately. - Provide adequate comments and documentation.","solution":"import itertools import bisect class PriorityQueueNode: def __init__(self, data, priority): self.data = data self.priority = priority def __repr__(self): return \\"{}: {}\\".format(self.data, self.priority) def __lt__(self, other): return self.priority < other.priority class PriorityQueue: def __init__(self, items=None, priorities=None): self.priority_queue_list = [] if items is None: return if priorities is None: priorities = itertools.repeat(None) for item, priority in zip(items, priorities): self.push(item, priority=priority) def __repr__(self): return \\"PriorityQueue({!r})\\".format(self.priority_queue_list) def size(self): return len(self.priority_queue_list) def push(self, item, priority=None): priority = item if priority is None else priority node = PriorityQueueNode(item, priority) bisect.insort_left(self.priority_queue_list, node) # Use bisect to maintain the sorted order def pop(self): if not self.priority_queue_list: raise IndexError(\\"pop from empty priority queue\\") return self.priority_queue_list.pop(0).data # pop the item with the highest priority def peek(self): if not self.priority_queue_list: raise IndexError(\\"peek from empty priority queue\\") return self.priority_queue_list[0].data # peek at the item with the highest priority def contains(self, item): return any(node.data == item for node in self.priority_queue_list)"},{"question":"# Binary Tree Diameter Background In addition to height, another important measure in binary trees is the diameter. The diameter of a binary tree is the length of the longest path between any two nodes in the tree. This path may or may not pass through the root. Given a binary tree, write a function called `diameter` that determines the diameter of the tree. Input Format * The input will be the root of the binary tree. Output Format * The output should be a single integer which is the diameter of the tree. Constraints * The number of nodes in the tree will be in the range [0, 1000]. * The value of each node will be a unique integer within the range [-1000, 1000]. Performance Requirements * Your solution should run in linear time, O(n), where n is the number of nodes in the tree. Example 1. Given the binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` The diameter of the tree is 6 (path: 3-6-9-12-15-18). 2. Given an empty tree: * Output should be 0. Function Signature ```python class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter(root): # Implement the function here pass ``` Provide a comprehensive solution to the problem, ensuring to handle edge cases such as empty tree and skewed trees properly.","solution":"class Node: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def diameter(root): Determines the diameter of the binary tree. def height_and_diameter(node): if not node: return 0, 0 # height, diameter left_height, left_diameter = height_and_diameter(node.left) right_height, right_diameter = height_and_diameter(node.right) current_height = 1 + max(left_height, right_height) current_diameter = max(left_height + right_height, left_diameter, right_diameter) return current_height, current_diameter _, tree_diameter = height_and_diameter(root) return tree_diameter"},{"question":"You are given a binary tree, and your task is to implement a function that determines the height of this tree. The height of the tree is defined as the number of levels in the tree: - An empty tree has a height of 0. - A tree with only one node, the root, has a height of 1. - The height increases by one for every additional level of nodes. # Input ``` A binary tree node class and the root node of a binary tree. ``` # Output ``` An integer representing the height of the binary tree. ``` # Expected Function Signature ```python def height(root: \'Node\') -> int: ``` # Example Consider the following binary tree: ``` 9 / 6 12 / / 3 8 10 15 / 7 18 ``` In this example, the height of the tree is `4`. # Constraints - The number of nodes in the tree will be between 0 and 10^5. - The value of each node is an integer. # Performance Requirements - **Time Complexity**: O(n), where n is the number of nodes in the tree. - **Space Complexity**: O(h), where h is the height of the tree. # Implementation Implement the function by following these steps: 1. If the root is `None`, return 0. 2. Compute the height of the left subtree. 3. Compute the height of the right subtree. 4. Return the maximum of the heights of the left and right subtrees, plus 1 (for the root). Note: Do not import or define any other data structures. Use only the provided `Node` class and its attributes. Test your implementation using a provided tree class `bst` and ensure it passes the provided unit tests.","solution":"class Node: def __init__(self, data=None): self.data = data self.left = None self.right = None def height(root: \'Node\') -> int: Returns the height of the binary tree. An empty tree has a height of 0. if root is None: return 0 left_height = height(root.left) right_height = height(root.right) return max(left_height, right_height) + 1"},{"question":"# Priority Queue Implementation using a Different Data Structure You are given the task to refactor the given priority queue implementation to improve the efficiency of the insertion operation. Specifically, you need to re-implement the priority queue using a heap data structure (e.g., a binary heap) to ensure that both the `push` and `pop` operations are optimized. Requirements 1. Implement the `PriorityQueue` class using a heap. 2. Ensure that the `push` operation has a time complexity of O(log n). 3. Ensure that the `pop` operation has a time complexity of O(log n). 4. Maintain the same interface and methods: * `__init__(self, items=None, priorities=None)` * `size(self)` * `push(self, item, priority=None)` * `pop(self)` 5. Handle all potential edge cases, including popping from an empty queue and managing items with duplicate priorities. Input The `PriorityQueue` class will be instantiated and used as follows: ```python pq = PriorityQueue(items=[1, 2, 3, 4], priorities=[4, 3, 2, 1]) pq.push(5, priority=2) print(pq.size()) # Output: 5 print(pq.pop()) # Output: 1 print(pq.pop()) # Output: 2 ``` Output Your `pop` method should return the element with the highest priority (lowest numerical value) each time it\'s called. Constraints 1. The input `items` and `priorities` lists will have the same length. 2. If `priorities` are not provided, assume the priority of each item is the item itself. You are expected to implement the `PriorityQueue` class in Python, using a heap-based approach to improve the efficiency of the `push` and `pop` operations.","solution":"import heapq class PriorityQueue: def __init__(self, items=None, priorities=None): self.heap = [] if items and priorities: for item, priority in zip(items, priorities): heapq.heappush(self.heap, (priority, item)) elif items: for item in items: heapq.heappush(self.heap, (item, item)) def size(self): return len(self.heap) def push(self, item, priority=None): if priority is None: priority = item heapq.heappush(self.heap, (priority, item)) def pop(self): if self.heap: return heapq.heappop(self.heap)[1] raise IndexError(\\"pop from an empty priority queue\\")"},{"question":"Truncated Mean Calculator Scenario In a data analysis pipeline, it\'s often essential to mitigate the effect of outliers when computing the mean of a dataset. One effective method to achieve this is through a truncated mean, which ignores a specified percentage of the highest and lowest values. You are tasked with implementing a function that computes the truncated mean of a list of numerical values. Task Write a Python function `calculate_truncated_mean(arr: List[float], percentage: float) -> float` that calculates the truncated mean of a given list of numerical values. The function will exclude the highest and lowest `percentage` percent of values before calculating the mean. Function Signature ```python def calculate_truncated_mean(arr: List[float], percentage: float) -> float: ``` Input - `arr`: A list of floating-point numbers of length `n` (1 ≤ n ≤ 10^5). - `percentage`: A floating-point number representing the percentage of values to trim from both ends (0 ≤ percentage < 100). Output - Returns the truncated mean of the remaining values after trimming. Constraints - You must handle edge cases where trimming the specified percentage results in no remaining values to average. - The time complexity of your solution should not exceed O(n log n). Example ```python # Example 1 print(calculate_truncated_mean([10.0, 20.0, 30.0, 40.0, 50.0], 20)) # Output: 30.0 # Example 2 print(calculate_truncated_mean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10)) # Output: 5.5 # Example 3 print(calculate_truncated_mean([5, 5, 5, 5, 5, 5], 80)) # Raise an appropriate error or handle edge case ``` Explanation - In the first example, trimming 20% means removing the highest 10% and lowest 10% values: [20.0, 30.0, 40.0], mean = 30.0. - In the second example, trimming 10% means removing the values [1, 10]; list becomes [2, 3, 4, 5, 6, 7, 8, 9], mean = 5.5. - In the third example, if 80% trimming removes too many values, handle the case appropriately.","solution":"from typing import List def calculate_truncated_mean(arr: List[float], percentage: float) -> float: Calculates the truncated mean of the given list of numerical values. :param arr: List of floating point numbers. :param percentage: Percentage of values to trim from both ends (0 ≤ percentage < 100). :return: Truncated mean of the remaining values. n = len(arr) if n == 0: raise ValueError(\\"The array is empty.\\") if not (0 <= percentage < 100): raise ValueError(\\"Percentage must be between 0 and less than 100.\\") # Number of elements to trim from each end k = int(n * (percentage / 100)) if k * 2 >= n: raise ValueError(\\"The percentage is too high, leading to zero or negative remaining values.\\") # Sort the array arr_sorted = sorted(arr) # Trim the array trimmed_arr = arr_sorted[k:n - k] # Calculate mean of trimmed array if not trimmed_arr: raise ValueError(\\"No elements remaining after trimming.\\") truncated_mean = sum(trimmed_arr) / len(trimmed_arr) return truncated_mean"},{"question":"**Context**: Bogo Sort is an intentionally inefficient algorithm used for academic purposes to demonstrate the pitfalls of relying on randomness for sorting. Despite its impracticality, understanding Bogo Sort provides a clear understanding of why efficient algorithms are necessary. Write a function to sort an array using a variation of Bogo Sort. In this variation, instead of randomly shuffling the array, generate all possible permutations of the array and check if they are sorted. This will still be inefficient but will terminate after finding the sorted permutation. **Task**: Implement the function in Python: ```python def permutation_bogo_sort(arr): Sort the given list of elements using a variation of Bogo Sort. Input: - arr: A list of integers. Output: - Returns the sorted list. Constraints: - Do not use built-in sorting functions. - The implementation should inherently be inefficient. Example: >>> permutation_bogo_sort([3, 2, 1]) [1, 2, 3] >>> permutation_bogo_sort([5, 3, 4]) [3, 4, 5] # Your implementation here ``` **Input/Output Formats**: * The input is a list of integers. * The output is the sorted list of integers in ascending order. **Constraints**: * The input list may contain duplicate elements. * List length can be 0 to 5 (for practical runtime management).","solution":"from itertools import permutations def is_sorted(arr): Check if the given list is sorted in ascending order. return all(arr[i] <= arr[i+1] for i in range(len(arr)-1)) def permutation_bogo_sort(arr): Sort the given list of elements using a variation of Bogo Sort by generating all possible permutations and checking if they are sorted. for perm in permutations(arr): if is_sorted(perm): return list(perm) return arr # Example usages: # print(permutation_bogo_sort([3, 2, 1])) # [1, 2, 3] # print(permutation_bogo_sort([5, 3, 4])) # [3, 4, 5]"},{"question":"Segment Tree Range Minimum Query You are given an array of integers. Implement a segment tree data structure that supports efficient range minimum queries (i.e., finding the minimum value in a given subrange of the array). Function Signatures * `__init__(self, arr: List[int])`: * Initializes the segment tree with the provided array. * `query(self, left: int, right: int) -> int`: * Returns the minimum value in the subarray range specified by the indices `left` and `right` (inclusive). # Input/Output Formats * **Input**: * The input will be provided as an array of integers. * The query function will receive two integer arguments, corresponding to the range of the subarray. * **Output**: * The output for the query function should be a single integer representing the minimum value in the specified subarray. Constraints * 0 <= left <= right < len(arr) * 1 <= len(arr) <= 10^5 * -10^9 <= arr[i] <= 10^9 Performance Requirements Your implementation should have a time complexity of O(N) for building the segment tree and O(log N) for each query. Example ```python # Example array arr = [1, 3, 2, 7, 9, 11] # Initialize segment tree st = SegmentTree(arr) # The minimum value in the subarray range [1, 4] is 2 print(st.query(1, 4)) # Output: 2 # The minimum value in the subarray range [0, 3] is 1 print(st.query(0, 3)) # Output: 1 ``` Implementation Guidelines * Design the Segment Tree class with necessary attributes. * Focus on correctly constructing the tree to support range minimum queries. * Ensure efficient handling of edge cases such as empty subarray or out-of-bounds indices.","solution":"class SegmentTree: def __init__(self, arr): Initializes the segment tree with the provided array. self.n = len(arr) self.tree = [0] * (2 * self.n) # Build the segment tree self.build(arr) def build(self, arr): # Insert leaf nodes in tree for i in range(self.n): self.tree[self.n + i] = arr[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = min(self.tree[i << 1], self.tree[i << 1 | 1]) def query(self, left, right): Returns the minimum value in the subarray range specified by the indices left and right (inclusive). left += self.n right += self.n minimum = float(\'inf\') while left <= right: if left & 1: minimum = min(minimum, self.tree[left]) left += 1 if not right & 1: minimum = min(minimum, self.tree[right]) right -= 1 left >>= 1 right >>= 1 return minimum"},{"question":"You are tasked to implement the search query functionality for a giant database server. The main requirement is to efficiently find a specific entry in a sorted list of integers that represent user IDs. The database is read-only, well-sorted, and extremely large, making linear search infeasible for most queries. Therefore, we are to use Jump Search to optimize the search operation. # Function Signature ```python def database_search(user_ids: List[int], target_id: int) -> int: pass ``` # Input - `user_ids` (List[int]): A list of n sorted integers representing user IDs (1 ≤ n ≤ 10^6). - `target_id` (int): An integer representing the ID to be searched. # Output - Returns the index of `target_id` if found in `user_ids`. - Returns -1 if `target_id` is not found in `user_ids`. # Constraints - The input list is non-empty and sorted in ascending order. - The list can contain up to 1,000,000 (10^6) IDs. # Example ```python user_ids = [5, 12, 23, 36, 48, 56, 72, 89, 95, 100] target_id = 36 assert(database_search(user_ids, target_id) == 3) user_ids = [5, 12, 23, 36, 48, 56, 72, 89, 95, 100] target_id = 70 assert(database_search(user_ids, target_id) == -1) ``` # Explanation The function `database_search` should implement the Jump Search algorithm to efficiently locate the target ID. # Notes - Ensure to handle edge cases such as: - An array where the target ID is smaller than the first element or larger than the last element. - Scenarios where the list contains very few elements. - Prioritize minimizing time complexity to handle large inputs efficiently.","solution":"from typing import List import math def database_search(user_ids: List[int], target_id: int) -> int: Uses Jump Search to efficiently find target_id in a sorted list of user_ids. Returns the index of target_id if found, otherwise returns -1. n = len(user_ids) step = int(math.sqrt(n)) # Finding the block where the element is present (if it is present) prev = 0 while user_ids[min(step, n)-1] < target_id: prev = step step += int(math.sqrt(n)) if prev >= n: return -1 # Doing a linear search for target_id in the block beginning with prev. for idx in range(prev, min(step, n)): if user_ids[idx] == target_id: return idx return -1"},{"question":"# Binary Tree Construction from Traversal Data You are given the pre-order and post-order traversal sequences of a full binary tree. A full binary tree is a binary tree in which every node has either 0 or 2 children. Your task is to reconstruct this full binary tree and return its in-order traversal sequence. # Input * `pre`: A list of integers representing the pre-order traversal of the binary tree. * `post`: A list of integers representing the post-order traversal of the binary tree. # Output Return a list of integers representing the in-order traversal of the constructed binary tree. # Constraints * Both lists are guaranteed to represent the traversal of a full binary tree. * Each element in the pre and post lists is unique. * 1 ≤ len(pre) = len(post) ≤ 1000 # Example Input ```python pre = [1, 2, 4, 5, 3, 6, 7] post = [4, 5, 2, 6, 7, 3, 1] ``` Output ```python [4, 2, 5, 1, 6, 3, 7] ``` # Instructions Implement the function `build_tree_inorder(pre, post)` that takes in the pre and post lists and returns the in-order traversal of the reconstructed binary tree. # Function Signature ```python def build_tree_inorder(pre: list, post: list) -> list: pass ```","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def construct_tree(pre, pre_start, pre_end, post, post_start, post_end): if pre_start > pre_end or post_start > post_end: return None root = TreeNode(pre[pre_start]) if pre_start == pre_end: return root left_root_val = pre[pre_start + 1] left_root_idx_in_post = post.index(left_root_val) left_size = left_root_idx_in_post - post_start + 1 root.left = construct_tree(pre, pre_start + 1, pre_start + left_size, post, post_start, left_root_idx_in_post) root.right = construct_tree(pre, pre_start + left_size + 1, pre_end, post, left_root_idx_in_post + 1, post_end - 1) return root def inorder_traversal(root): return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) if root else [] def build_tree_inorder(pre: list, post: list) -> list: root = construct_tree(pre, 0, len(pre) - 1, post, 0, len(post) - 1) return inorder_traversal(root)"},{"question":"Run-Length Encoding (RLE) is a fundamental technique in data compression. Your task is to implement both Run-Length Encoding and Decoding functions. You are provided with a skeleton of the RLE encoding/decoding in Python. You\'ll need to write robust implementations that handle various edge cases effectively. # Function Signature ```python def encode_rle(input: str) -> str: # Your code here pass def decode_rle(input: str) -> str: # Your code here pass ``` # Input and Output 1. **encode_rle(input: str) -> str**: - **Input**: A string containing any characters. - **Output**: A compressed string using RLE. 2. **decode_rle(input: str) -> str**: - **Input**: An RLE compressed string. - **Output**: The original uncompressed string. # Constraints - The input strings can be empty. - The input for the decoder is always valid; i.e. it will only contain valid RLE-encoded strings. - You must handle strings with unique characters properly. - Ensure the functions are optimized to handle long strings efficiently. # Example 1. **Encoding** - Input: `\\"aaabbc\\"` - Output: `\\"3a2b1c\\"` 2. **Decoding** - Input: `\\"3a2b1c\\"` - Output: `\\"aaabbc\\"` # Hints - Think about how you can manage and count consecutive characters effectively for encoding. - For decoding, remember that the counts will be digits followed by a character. - Pay attention to how you handle the end of the strings in both cases.","solution":"def encode_rle(input: str) -> str: if not input: return \'\' encoded_string = \'\' current_char = input[0] count = 1 for char in input[1:]: if char == current_char: count += 1 else: encoded_string += f\'{count}{current_char}\' current_char = char count = 1 encoded_string += f\'{count}{current_char}\' return encoded_string def decode_rle(input: str) -> str: if not input: return \'\' decoded_string = \'\' count_str = \'\' for char in input: if char.isdigit(): count_str += char else: decoded_string += char * int(count_str) count_str = \'\' return decoded_string"},{"question":"Maximum Flow Network Analysis Task You are given a directed graph representing a flow network with `n` vertices and `m` edges. Each edge has a specific capacity representing the maximum possible flow that can pass through that edge. Your task is to implement the Ford-Fulkerson, Edmonds-Karp, and Dinic algorithms to compute the maximum flow from a given source to a given sink. Inputs - An integer `n` representing the number of vertices (2 ≤ n ≤ 100). - An integer `m` representing the number of edges (1 ≤ m ≤ 10000). - A list of tuples `edges`, with each tuple containing three integers `(u, v, c)`, where `u` and `v` are vertices (0 ≤ u, v < n), and `c` is the capacity of the edge from `u` to `v`. - An integer `source` representing the source vertex (0 ≤ source < n). - An integer `sink` representing the sink vertex (0 ≤ sink < n). Output A dictionary with the keys \\"Ford-Fulkerson\\", \\"Edmonds-Karp\\", and \\"Dinic\\", and their corresponding maximum flow values from the source to the sink. Function Signature ```python def maximum_flow(n: int, m: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> Dict[str, int]: pass ``` Constraints and Notes - You must use the provided function signature. - The vertices and edges list follow a 0-indexing system. - Implement each algorithm as described in the analysis above. You can define helper functions if necessary. - Aim to handle up to the maximum constraints efficiently. Example ```python n = 4 m = 5 edges = [(0, 1, 1000), (0, 2, 1000), (1, 2, 1), (1, 3, 1000), (2, 3, 1000)] source = 0 sink = 3 output = maximum_flow(n, m, edges, source, sink) print(output) # Expected output might be: # { # \\"Ford-Fulkerson\\": 2000, # \\"Edmonds-Karp\\": 2000, # \\"Dinic\\": 2000 # } ``` Implementation Tips * Preprocess the edges to create the capacity matrix. * Properly update the flow network after each iteration. * Ensure residual capacities are correctly maintained and used. * Use appropriate data structures like queues for BFS and stack/recursive functions for DFS.","solution":"from typing import List, Tuple, Dict from collections import deque, defaultdict def bfs_level_graph(C, source, sink, levels, n): queue = deque([source]) levels[source] = 0 while queue: u = queue.popleft() for v in range(n): if levels[v] < 0 and C[u][v] > 0: # unused capacity levels[v] = levels[u] + 1 queue.append(v) if v == sink: return True return False def dfs_flow(C, levels, u, sink, flow): if u == sink: return flow total_flow = 0 for v in range(len(C)): if C[u][v] > 0 and levels[v] == levels[u] + 1: curr_flow = min(flow, C[u][v]) temp_flow = dfs_flow(C, levels, v, sink, curr_flow) if temp_flow > 0: C[u][v] -= temp_flow C[v][u] += temp_flow total_flow += temp_flow flow -= temp_flow if flow == 0: break if total_flow == 0: levels[u] = -1 return total_flow def dinic_algorithm(n, source, sink, capacity): max_flow = 0 while True: levels = [-1] * n if not bfs_level_graph(capacity, source, sink, levels, n): # no more augmenting path break max_flow += dfs_flow(capacity, levels, source, sink, float(\'Inf\')) return max_flow def bfs(C, source, sink, parent): visited = set() queue = deque([source]) visited.add(source) while queue: u = queue.popleft() for v in range(len(C)): if v not in visited and C[u][v] > 0: # positive residual capacity queue.append(v) visited.add(v) parent[v] = u if v == sink: return True return False def ford_fulkerson(n, source, sink, capacity): parent = [-1] * n max_flow = 0 while bfs(capacity, source, sink, parent): path_flow = float(\'Inf\') v = sink while v != source: u = parent[v] path_flow = min(path_flow, capacity[u][v]) v = u v = sink while v != source: u = parent[v] capacity[u][v] -= path_flow capacity[v][u] += path_flow v = u max_flow += path_flow return max_flow def edmonds_karp(n, source, sink, capacity): return ford_fulkerson(n, source, sink, capacity) def maximum_flow(n: int, m: int, edges: List[Tuple[int, int, int]], source: int, sink: int) -> Dict[str, int]: # Create capacity matrix capacity = [[0] * n for _ in range(n)] for u, v, c in edges: capacity[u][v] += c # Copy of original capacity for each algorithm as they modify the graph capacity_for_ff = [row[:] for row in capacity] capacity_for_ek = [row[:] for row in capacity] capacity_for_dinic = [row[:] for row in capacity] return { \\"Ford-Fulkerson\\": ford_fulkerson(n, source, sink, capacity_for_ff), \\"Edmonds-Karp\\": edmonds_karp(n, source, sink, capacity_for_ek), \\"Dinic\\": dinic_algorithm(n, source, sink, capacity_for_dinic) }"},{"question":"You are given two strings, `s` and `p`, where `s` is the input string and `p` is the pattern. Implement a function: ```python def is_match(s: str, p: str) -> bool: pass ``` * The pattern `p` might contain two special characters: * `.` which matches any single character. * `*` which matches zero or more of the preceding element. The function should return `True` if the input string `s` matches the pattern `p`, otherwise return `False`. The matching should cover the entire input string (not partial matches). # Example ```python assert is_match(\\"aa\\", \\"a\\") == False assert is_match(\\"aa\\", \\"aa\\") == True assert is_match(\\"aaa\\", \\"aa\\") == False assert is_match(\\"aa\\", \\"a*\\") == True assert is_match(\\"aa\\", \\".*\\") == True assert is_match(\\"ab\\", \\".*\\") == True assert is_match(\\"aab\\", \\"c*a*b\\") == True ``` # Constraints 1. 0 <= len(s) <= 1000 2. 0 <= len(p) <= 1000 3. `s` and `p` consist of only lowercase English letters and the special characters `.` and `*`. # Hints - Use dynamic programming to store intermediate results. - Consider edge cases such as empty strings and patterns with multiple `*` characters in a row. # Notes - Ensure your solution handles all edge cases and is efficient in terms of both time and space.","solution":"def is_match(s: str, p: str) -> bool: Returns True if the string s matches the pattern p, otherwise False. # dp[i][j] will be True if the first i characters in s (s[0:i]) match # the first j characters in p (p[0:j]) dp = [[False] * (len(p) + 1) for _ in range(len(s) + 1)] dp[0][0] = True # empty string matches empty pattern # Populate the dp array for patterns with \'*\' for j in range(2, len(p) + 1): dp[0][j] = dp[0][j - 2] if p[j - 1] == \'*\' else False for i in range(1, len(s) + 1): for j in range(1, len(p) + 1): if p[j - 1] == \'.\' or p[j - 1] == s[i - 1]: dp[i][j] = dp[i - 1][j - 1] elif p[j - 1] == \'*\': dp[i][j] = dp[i][j - 2] # Zero occurrence of the element before \'*\' if p[j - 2] == \'.\' or p[j - 2] == s[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] # Consider one more occurrence of the element before \'*\' return dp[len(s)][len(p)]"},{"question":"# Scenario You are developing a module for a statistics software that frequently needs to determine the number of digits in input integer values for proper formatting and display purposes. To ensure the software is highly performant, especially when dealing with large datasets, an efficient approach is paramount. # Task Implement a function that efficiently counts the number of digits in a given integer, including handling edge cases. # Function Signature ```python def count_digits(n: int) -> int: Returns the number of digits in the given integer n. ``` # Input * An integer `n` where `-10^18 <= n <= 10^18`. # Output * An integer representing the number of digits in `n`. # Constraints * Your solution should run in O(1) time complexity. * Handle the case where `n` is zero correctly. # Examples * `count_digits(123)` should return `3`. * `count_digits(-4567)` should return `4`. * `count_digits(0)` should return `1`. # Notes * Do not use string conversion methods to determine digit count. * Ensure that the function handles both positive and negative integers uniformly.","solution":"def count_digits(n: int) -> int: Returns the number of digits in the given integer n. if n == 0: return 1 count = 0 if n < 0: n = -n while n > 0: count += 1 n //= 10 return count"},{"question":"Detect the First Node of a Cycle in a Linked List **Scenario**: Suppose you are given a directed linked list where some nodes form a cycle. Your goal is to implement a function that detects the first node of the cycle (if any) using Floyd\'s Cycle-Finding Algorithm (Tortoise and Hare algorithm). **Objective**: Write a function that detects the first node in the cycle of a linked list. **Function Signature**: ```python def detect_cycle_start(head: Node) -> Node: # your code here ``` **Input**: * `head`: The head node of the singly linked list. **Output**: * Returns the node where the cycle begins. If there is no cycle, return `None`. **Constraints**: * If the linked list has no nodes or only one node without a cycle, your function must handle these cases and return `None`. * The linked list can contain any number of nodes up to the system\'s memory limits. **Example**: 1. Given a linked list: 1 -> 2 -> 3 -> 4 -> 5 -> 3 (cycle back to node with value 3), * Your function should return the node with value 3. 2. Given a linked list: A -> B -> C -> D -> E -> C (cycle back to node with value C), * Your function should return the node with value C. 3. Given a linked list with no cycle: * Your function should return `None`. **Edge Cases to Consider**: * Empty linked list. * Linked list with one node (with and without a cycle). Here is a class definition for the Node that you can use: ```python class Node: def __init__(self, val): self.val = val self.next = None ``` **Additional Notes**: * Write your function to ensure it\'s efficient and handles all edge cases. * Use the provided class definition and ensure the linked list structure remains unchanged post-execution. * Avoid unnecessary loops and checks to maintain O(n) time complexity. **Sample Test Case**: ```python import unittest class TestDetectCycleStart(unittest.TestCase): def test_cycle_detected(self): head = Node(1) node2 = Node(2) node3 = Node(3) head.next = node2 node2.next = node3 node3.next = head # Cycle here self.assertEqual(detect_cycle_start(head).val, 1) def test_no_cycle(self): head = Node(1) node2 = Node(2) head.next = node2 self.assertIsNone(detect_cycle_start(head)) if __name__ == \'__main__\': unittest.main() ``` Your task is to implement the `detect_cycle_start` function.","solution":"class Node: def __init__(self, val): self.val = val self.next = None def detect_cycle_start(head: Node) -> Node: if not head or not head.next: return None slow = head fast = head # Phase 1: Detect if there is a cycle while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: break else: return None # Phase 2: Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Question Context You are working for a network security company that uses graphs to model computer networks. Each computer is a node, and the connections between them are edges. Your task is to determine if these networks are bipartite, meaning they can be divided into two sets where no two nodes within the same set are connected directly. Function Implementation Write a function `is_bipartite_graph(adj_matrix: List[List[int]]) -> bool` that takes an adjacency matrix representing an unweighted and undirected graph and returns `True` if the graph is bipartite, otherwise returns `False`. Input * `adj_matrix`: A list of lists of integers where `adj_matrix[i][j]` is `1` if there is an edge between node `i` and node `j`, otherwise `0`. Output * `Boolean`: `True` if the graph is bipartite, otherwise `False`. Constraints * The adjacency matrix will be of dimensions `n x n` where `1 <= n <= 1000`. * The graph may not have self-loops and parallel edges. Performance Requirements * The solution should efficiently handle graphs with up to 1000 nodes and their respective edges. * The solution must work within O(V + E) time complexity and O(V) space complexity. Example ```python adj_matrix = [ [0, 1, 0, 1], [1, 0, 1, 0], [0, 1, 0, 1], [1, 0, 1, 0] ] print(is_bipartite_graph(adj_matrix)) # Output: True ```","solution":"from collections import deque from typing import List def is_bipartite_graph(adj_matrix: List[List[int]]) -> bool: n = len(adj_matrix) color = [-1] * n # -1 means uncolored, 0 and 1 are the two colors def bfs(start: int) -> bool: queue = deque([start]) color[start] = 0 # Start coloring the starting node with color 0 while queue: node = queue.popleft() for neighbor in range(n): if adj_matrix[node][neighbor]: if color[neighbor] == -1: # If the neighbor is not colored color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: # If the neighbor has the same color return False return True for i in range(n): if color[i] == -1: # If the node is not colored, start a BFS from it if not bfs(i): return False return True"},{"question":"You are tasked with writing a function that calculates the power of a number using binary exponentiation, incorporating modular arithmetic if specified. Function Signature ```python def optimized_power(base: int, exponent: int, modulus: int = None) -> int: pass ``` Input - `base` (int): The base of the exponentiation (1 ≤ base ≤ 10^9). - `exponent` (int): The exponent (0 ≤ exponent ≤ 10^9). - `modulus` (int, optional): If provided, the result should be modulo `modulus` (1 ≤ modulus ≤ 10^9). Output - An integer representing ( base^{exponent} modulus modulus ) if modulus is provided. - Otherwise, an integer representing ( base^{exponent} ). # Constraints - Both iterative and recursive approaches have been provided above. Implement the approach you find most suitable. - The function should handle very large numbers within the provided constraints efficiently. # Examples 1. **Example 1:** ```python assert optimized_power(2, 10) == 1024 ``` Since (2^{10} = 1024). 2. **Example 2:** ```python assert optimized_power(3, 7) == 2187 ``` Since (3^{7} = 2187). 3. **Example 3:** ```python assert optimized_power(2, 10, 1000) == 24 ``` Since (2^{10} mod 1000 = 24). 4. **Example 4:** ```python assert optimized_power(5, 0) == 1 ``` Since (5^{0} = 1). Be sure to take into consideration edge cases such as an exponent of zero and ensure your algorithm is optimized for performance.","solution":"def optimized_power(base: int, exponent: int, modulus: int = None) -> int: Calculate the power of a number using binary exponentiation. :param base: The base of the exponentiation. :param exponent: The exponent. :param modulus: If provided, the result will be modulo the modulus. :return: The result of base^exponent % modulus if modulus is provided, otherwise base^exponent. result = 1 base = base % modulus if modulus else base while exponent > 0: if exponent % 2 == 1: result = (result * base) % modulus if modulus else result * base base = (base * base) % modulus if modulus else base * base exponent //= 2 return result % modulus if modulus else result"},{"question":"You need to design a data structure that supports the addition of words and the ability to search for words using regular expressions (containing “.” where “.” can be any letter). Implement the two methods for the data structure: 1. `add_word(word: str)` - Adds a word into the data structure. 2. `search(word: str) -> bool` - Searches for a word in the data structure, where the word can contain “.” as a wildcard character. # Requirements: - Implement the solution efficiently, considering both time and space complexity. - Provide a thorough solution that handles various edge cases. - Ensure the function works within acceptable performance constraints for large inputs. # Input and Output Format: - `add_word(word: str)`: This method takes a string `word` as input and adds it to the data structure. - `search(word: str) -> bool`: This method takes a string `word` with possible wildcard characters and returns a boolean indicating whether the word exists in the data structure. # Constraints: - All input strings are lowercase \'a\'-\'z\'. - The maximum length of the word is 50. - The total number of words added will not exceed 10^4. # Example ```python # Example Usage: wordDict = WordDictionary() wordDict.add_word(\\"bad\\") wordDict.add_word(\\"dad\\") wordDict.add_word(\\"mad\\") print(wordDict.search(\\"pad\\")) # Output: False print(wordDict.search(\\"bad\\")) # Output: True print(wordDict.search(\\".ad\\")) # Output: True print(wordDict.search(\\"b..\\")) # Output: True ``` # Explanation - `search(\\"pad\\")` returns False because \\"pad\\" was not added. - `search(\\"bad\\")` returns True because \\"bad\\" was added. - `search(\\".ad\\")` returns True because the wildcard can match \\"b\\", \\"d\\", and \\"m\\" to form \\"bad\\", \\"dad\\", and \\"mad\\". - `search(\\"b..\\")` returns True because \\"b..\\" can form \\"bad\\" with wildcards.","solution":"class WordDictionary: def __init__(self): self.words = [] def add_word(self, word: str): self.words.append(word) def search(self, word: str) -> bool: from re import compile pattern = compile(\'^\' + word + \'\') for w in self.words: if pattern.match(w): return True return False"},{"question":"# Zigzag Order Traversal of a Binary Tree Scenario You have been hired by a software company to develop a feature for a visual tree diagram tool. One of the functionalities is to provide a zigzag level order traversal of nodes\' values of a given binary tree. Your task is to implement this feature by writing a function. Problem Statement Write a function `zigzag_level(root)` which takes as input the root node of a binary tree and returns a list of node values in a zigzag level order traversal. # Function Signature ```python def zigzag_level(root: Optional[TreeNode]) -> List[List[int]]: ``` # Input * `root` (TreeNode): The root node of a binary tree. # Output * A list of lists of integers, representing the nodes\' values in zigzag level order traversal. # Constraints * Tree nodes will have the following properties: * `val` (int): The value of the node, which can be any integer. * `left` (TreeNode): A reference to the left child node (if there is one). * `right` (TreeNode): A reference to the right child node (if there is one). * The tree could be empty (i.e., root is `None`). Performance Requirements * Your solution should run in O(N) time complexity, where N is the number of nodes in the binary tree. * The space complexity should be optimal for processing large trees. Example Consider the binary tree: ``` 3 / 9 20 / 15 7 ``` Calling `zigzag_level(root)` on this tree should return: ``` [ [3], [20, 9], [15, 7] ] ``` Notes 1. Make sure you correctly handle cases where the tree has only one node or is empty. 2. Alternate the traversal direction at each level: left-to-right, then right-to-left for the next level, and so on.","solution":"from typing import Optional, List from collections import deque class TreeNode: def __init__(self, val: int = 0, left: Optional[\'TreeNode\'] = None, right: Optional[\'TreeNode\'] = None): self.val = val self.left = left self.right = right def zigzag_level(root: Optional[TreeNode]) -> List[List[int]]: Returns the zigzag level order traversal of a binary tree. if not root: return [] result, level, left_to_right = [], deque([root]), True while level: current_level_nodes = [] for _ in range(len(level)): node = level.popleft() current_level_nodes.append(node.val) if node.left: level.append(node.left) if node.right: level.append(node.right) if not left_to_right: current_level_nodes.reverse() result.append(current_level_nodes) left_to_right = not left_to_right return result"},{"question":"Problem Statement: Nearest Neighbor Search Optimization # Context You\'re working on a recommendation system that suggests similar products to users based on their preferences. Each product and user preference is represented as a high-dimensional vector. Due to the large number of products in the database, the current system using a basic nearest neighbor algorithm is slow and inefficient. Your task is to optimize this system. # Task Write a Python function `optimized_nearest_neighbor` that improves upon the provided nearest neighbor algorithm. Use advanced data structures to reduce the time complexity of finding the nearest neighbor for a given test vector. Your function should handle large datasets efficiently. # Input - `x`: A tuple representing the test vector of length (m). - `tSet`: A dictionary where keys are tuples representing the vectors of products in the training set, and values are the product classifications (strings). # Output - A string representing the classification of the closest vector in the training set to the given test vector. # Constraints - All vectors are of the same dimensionality (m), (1 leq m leq 100). - The training set `tSet` can contain between (1) and (10^6) vectors. # Requirements - Your implementation should significantly reduce the time required to find the nearest neighbor compared to the brute-force approach. - Implement appropriate error handling for edge cases. # Example ```python x = (2.5, 3.7, 1.9) tSet = { (1.0, 1.0, 1.0): \\"Product A\\", (4.0, 4.0, 4.0): \\"Product B\\", (5.0, 5.0, 5.0): \\"Product C\\" } print(optimized_nearest_neighbor(x, tSet)) # Output: \\"Product B\\" ``` # Note You are free to use existing libraries to build data structures like KD-Trees or perform dimensionality reduction. Ensure your code is well-documented and efficient.","solution":"from scipy.spatial import KDTree def optimized_nearest_neighbor(x, tSet): Given a test vector x and a training set tSet, find the nearest neighbor of x in tSet and return its classification. :param x: A tuple representing the test vector. :param tSet: A dictionary where keys are tuples representing the vectors of products and values are the product classifications. :return: The classification of the nearest neighbor in the training set. # Create a list of vectors (keys) and build the KD-Tree vectors = list(tSet.keys()) tree = KDTree(vectors) # Find the nearest neighbor of the test vector x using KDTree. distance, index = tree.query(x) # Retrieve the nearest neighbor vector and its classification nearest_vector = vectors[index] classification = tSet[nearest_vector] return classification"},{"question":"# Dijkstra\'s Navigation Route You are given the task of developing a navigation system for a city represented by a weighted graph. Each edge in the graph represents a road between two intersections (vertices), with the edge weight corresponding to the time taken to travel that road. Your goal is to implement a function that calculates the shortest travel times from a given starting intersection to all other intersections in the city. # Input * A 2D list (matrix) `graph` of size `n x n` representing the adjacency matrix of the graph. - `graph[i][j] = w` indicates there is a road from intersection `i` to intersection `j` with travel time `w`. - If there is no road from intersection `i` to intersection `j`, `graph[i][j]` will be 0 or a negative number. * An integer `src` representing the starting intersection. # Output * A list of integers where the `i-th` value denotes the shortest time from the source intersection to the `i-th` intersection. If the destination is not reachable, the value should remain `float(\'inf\')`. # Function Signature ```python def dijkstra_shortest_paths(graph: List[List[int]], src: int) -> List[int]: pass ``` # Example ```python graph = [ [0, 10, 20, 0, 0], [10, 0, 5, 10, 0], [20, 5, 0, 15, 30], [0, 10, 15, 0, 10], [0, 0, 30, 10, 0] ] src = 0 print(dijkstra_shortest_paths(graph, src)) # Output: [0, 10, 15, 20, 30] ``` # Constraints * The number of intersections `n` will be in the range [1, 1000]. * The travel times will be non-negative integers less than 1000. * It is guaranteed that the graph is a fully connected graph with at least one route between any two intersections. # Notes * Utilize the provided Dijkstra\'s algorithm structure as a reference to develop the required function. * Ensure your implementation handles edge cases like disconnected components, zero-weight edges, and larger graphs efficiently.","solution":"import heapq from typing import List def dijkstra_shortest_paths(graph: List[List[int]], src: int) -> List[int]: Calculates the shortest travel times from a given starting intersection to all other intersections in the city. n = len(graph) dist = [float(\'inf\')] * n dist[src] = 0 pq = [(0, src)] # Priority queue of (distance, vertex) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v in range(n): if graph[u][v] > 0: # There is a road between u and v. new_dist = current_dist + graph[u][v] if new_dist < dist[v]: dist[v] = new_dist heapq.heappush(pq, (new_dist, v)) return dist"},{"question":"Reverse String in Different Approaches Given the four different functions to reverse a string, your task is to implement a new function that integrates all these methods under specific conditions. Write a function `smart_reverse(s: str, method: str) -> str` that reverses the input string using the specified method: - **method** can be one of the following values: `recursive`, `iterative`, `pythonic`, `ultra_pythonic`. The function should select the corresponding reversal technique based on the `method` parameter. Implement the `smart_reverse` function with the following specifications: # Input: - `s`: A string (0 ≤ length of s ≤ 10^5) - `method`: A string indicating the reversal method (`recursive`, `iterative`, `pythonic`, `ultra_pythonic`) # Output: - A reversed string based on the selected method. # Example: ```python print(smart_reverse(\\"hello\\", \\"recursive\\")) # Expected: \\"olleh\\" print(smart_reverse(\\"world\\", \\"iterative\\")) # Expected: \\"dlrow\\" print(smart_reverse(\\"python\\", \\"pythonic\\")) # Expected: \\"nohtyp\\" print(smart_reverse(\\"code\\", \\"ultra_pythonic\\")) # Expected: \\"edoc\\" ``` # Constraints: 1. Ensure that the function handles the upper limit of `s` efficiently. 2. Choose the most appropriate method based on the provided `method` argument. 3. Consider all edge cases and optimize the recursive call stack to avoid maximum recursion depth error. **Required Implementation:** ```python def smart_reverse(s: str, method: str) -> str: if method == \\"recursive\\": # Implement the recursive reversal from the provided snippet pass elif method == \\"iterative\\": # Implement the iterative reversal from the provided snippet pass elif method == \\"pythonic\\": # Implement the pythonic reversal from the provided snippet pass elif method == \\"ultra_pythonic\\": # Implement the ultra-pythonic reversal from the provided snippet pass else: raise ValueError(\\"Unknown method specified\\") return reversed_string ```","solution":"def smart_reverse(s: str, method: str) -> str: def reverse_recursive(s): if len(s) == 0: return s return s[-1] + reverse_recursive(s[:-1]) def reverse_iterative(s): reversed_str = [] for char in s: reversed_str.insert(0, char) return \'\'.join(reversed_str) def reverse_pythonic(s): return s[::-1] def reverse_ultra_pythonic(s): return \'\'.join(reversed(s)) if method == \\"recursive\\": return reverse_recursive(s) elif method == \\"iterative\\": return reverse_iterative(s) elif method == \\"pythonic\\": return reverse_pythonic(s) elif method == \\"ultra_pythonic\\": return reverse_ultra_pythonic(s) else: raise ValueError(\\"Unknown method specified\\")"},{"question":"# Question: Implement a Priority Queue A **Priority Queue** is an abstract data structure similar to a regular queue but with an added property - each element is associated with a priority, and elements with higher priority get dequeued before elements with lower priority. If two elements have the same priority, they are dequeued in the order they were enqueued (FIFO). Your Task You are required to implement a priority queue using a min-heap. Heaps are binary trees that satisfy the heap property, which is that every parent node has a value less than or equal to the values of its children (min-heap). Methods to Implement 1. **`enqueue(item, priority)`**: * Adds `item` to the priority queue with a given `priority`. * If there is a tie in priority, the earlier enqueued item is processed first. 2. **`dequeue()`**: * Removes and returns the item with the highest priority. * If the queue is empty, raises an `IndexError`. 3. **`peek()`**: * Returns the item with the highest priority without removing it. * If the queue is empty, raises an `IndexError`. 4. **`is_empty()`**: * Returns `True` if the queue is empty, `False` otherwise. 5. **`size()`**: * Returns the number of items in the queue. Constraints 1. Implement the underlying structure using a min-heap. 2. You may use a list to store the heap. Example ```python pq = PriorityQueue() pq.enqueue(\\"apple\\", 5) pq.enqueue(\\"banana\\", 3) pq.enqueue(\\"mango\\", 4) print(pq.dequeue()) # Output: \\"banana\\" print(pq.peek()) # Output: \\"mango\\" print(pq.size()) # Output: 2 print(pq.is_empty()) # Output: False ``` Notes * The time complexity for `enqueue` and `dequeue` operations should be O(log n). * Handle edge cases appropriately, such as ensuring methods behave correctly on an empty priority queue.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] self.index = 0 def enqueue(self, item, priority): Adds `item` with `priority` to the priority queue. heapq.heappush(self.heap, (priority, self.index, item)) self.index += 1 def dequeue(self): Removes and returns the item with the highest priority. If the queue is empty, raises an IndexError. if self.is_empty(): raise IndexError(\\"PriorityQueue is empty\\") return heapq.heappop(self.heap)[2] def peek(self): Returns the item with the highest priority without removing it. If the queue is empty, raises an IndexError. if self.is_empty(): raise IndexError(\\"PriorityQueue is empty\\") return self.heap[0][2] def is_empty(self): Returns True if the queue is empty, otherwise False. return len(self.heap) == 0 def size(self): Returns the number of items in the queue. return len(self.heap)"},{"question":"# Substring Search Optimization Suppose you are given two strings, `haystack` and `needle`. You are tasked with finding the index of the first occurrence of `needle` in `haystack`, or returning -1 if `needle` is not part of `haystack`. The straightforward approach utilizes a brute-force method, which can be inefficient for large inputs. To improve performance, implement an optimized version of this search using the Knuth-Morris-Pratt (KMP) algorithm. Input: * `haystack`: A string in which to search, with length `N` (1 <= N <= 10^5) * `needle`: A string to find, with length `M` (1 <= M <= 10^5) Output: * An integer representing the index of the first occurrence of `needle` in `haystack` or -1 if `needle` is not part of `haystack`. Constraints: * `haystack` and `needle` consist of only lower-case English characters. Example: 1. Input: `haystack` = \\"hello\\", `needle` = \\"ll\\" Output: 2 2. Input: `haystack` = \\"aaaaa\\", `needle` = \\"bba\\" Output: -1 Performance Requirements: * The overall time complexity should ideally be better than O(N*M). # Instructions: 1. Implement the function `find_needle(haystack, needle)` that uses the KMP algorithm. 2. Construct the partial match table (prefix table) necessary for the KMP algorithm. 3. Ensure your implementation handles the edge cases appropriately.","solution":"def find_needle(haystack, needle): Finds the index of the first occurrence of needle in haystack using the KMP algorithm. Returns -1 if needle is not part of haystack. # Edge case where needle is an empty string if not needle: return 0 # Step 1: Construct the prefix table (also known as the partial match table) def build_prefix_table(pattern): prefix_table = [0] * len(pattern) j = 0 for i in range(1, len(pattern)): while j > 0 and pattern[i] != pattern[j]: j = prefix_table[j - 1] if pattern[i] == pattern[j]: j += 1 prefix_table[i] = j return prefix_table # Step 2: Search for the pattern in the text using the prefix table prefix_table = build_prefix_table(needle) j = 0 for i in range(len(haystack)): while j > 0 and haystack[i] != needle[j]: j = prefix_table[j - 1] if haystack[i] == needle[j]: if j == len(needle) - 1: return i - j j += 1 return -1"},{"question":"# Substring Search Algorithm Implementation Problem Statement You are tasked with implementing a function **`strStr(haystack, needle)`** that returns the index of the first occurrence of the substring `needle` in the string `haystack`. If `needle` is not part of `haystack`, return `-1`. The function should handle cases efficiently and adhere to the following specifications: * If `needle` is an empty string, return 0. * If `needle` is longer than `haystack`, return -1. Your implementation should aim to be as efficient as possible, given the constraints. Example 1 **Input**: ```python haystack = \\"hello\\" needle = \\"ll\\" ``` **Output**: ```python 2 ``` Example 2 **Input**: ```python haystack = \\"aaaaa\\" needle = \\"bba\\" ``` **Output**: ```python -1 ``` Constraints * `0 <= haystack.length, needle.length <= 10^4` * `haystack` and `needle` consist of only lowercase English characters. Function Signature ```python def strStr(haystack: str, needle: str) -> int: ``` Performance Requirements * Target time complexity: O(n * m), where n is the length of `haystack` and m is the length of `needle`. * Target space complexity: O(1). Edge Cases * Return `0` when `needle` is an empty string. * Return `-1` when `needle` is longer than `haystack`. Task Implement the function `strStr(haystack, needle)` so that it adheres to the specifications and constraints.","solution":"def strStr(haystack: str, needle: str) -> int: Returns the index of the first occurrence of needle in haystack. If needle is not part of haystack, returns -1. # Edge case: if needle is an empty string, return 0 if not needle: return 0 # Get the lengths of haystack and needle len_haystack = len(haystack) len_needle = len(needle) # Edge case: if needle is longer than haystack, return -1 if len_needle > len_haystack: return -1 # Use sliding window to check each substring of haystack with the length of needle for i in range(len_haystack - len_needle + 1): if haystack[i:i + len_needle] == needle: return i return -1"},{"question":"# Radix Sort Implementation with Enhanced Requirements **Problem Statement**: You are required to implement the radix sort algorithm. In addition to sorting the input list of non-negative integers, the function should also handle a simulation mode that prints intermediate sorting states after each digit place sorting. Furthermore, incorporate checks and optimizations to address typical implementation challenges. **Function Signature**: ```python def enhanced_radix_sort(arr: list, simulation: bool = False) -> list: pass ``` **Input**: - `arr`: A list of non-negative integers (0 <= `arr[i]` <= 10^9). - `simulation`: A boolean flag indicating whether to print the state of the array after every digit-wise sorting (default is False). **Output**: - A sorted list of integers. **Constraints**: - The function must handle edge cases such as empty input lists and lists with identical elements. - Ensure that the function efficiently handles large datasets within reasonable time and space limits. **Performance Requirements**: - The solution should work efficiently for common inputs, with an acceptable trade-off between time and space complexity. **Examples**: 1. Example 1: ```python enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66]) # Expected Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` 2. Example 2: ```python enhanced_radix_sort([170, 45, 75, 90, 802, 24, 2, 66], simulation=True) # Expected Output: # iteration 0 : 170 45 75 90 802 24 2 66 # iteration 1 : 170 90 802 2 24 45 75 66 # iteration 2 : 802 2 24 45 66 75 90 170 # iteration 3 : 2 24 45 66 75 90 170 802 # Final Output: [2, 24, 45, 66, 75, 90, 170, 802] ``` **Notes**: - Debugging output is only required when `simulation` is true. - Implement the function with careful attention to handling large numbers and typical edge cases.","solution":"def enhanced_radix_sort(arr: list, simulation: bool = False) -> list: Sorts an array of non-negative integers using radix sort. Optionally prints the state of the array after each digit-wise sorting. Args: arr (list): List of non-negative integers. simulation (bool): If True, prints the intermediate states of the array after each digit place sorting. Returns: list: Sorted list of integers. if len(arr) == 0: return arr # Function to do counting sort based on a specific digit represented by exp def counting_sort(arr, exp): n = len(arr) output = [0] * n # output array to store sorted numbers count = [0] * 10 # count array to store occurrences of digits (0 to 9) # Count occurrences of each digit for i in range(n): index = (arr[i] // exp) % 10 count[index] += 1 # Change count[i] so that count[i] contains actual position of this digit in output[] for i in range(1, 10): count[i] += count[i - 1] # Build the output array by placing numbers in the sorted order i = n - 1 while i >= 0: index = (arr[i] // exp) % 10 output[count[index] - 1] = arr[i] count[index] -= 1 i -= 1 # Copy the output array to arr[], so that arr[] contains sorted numbers according to current digit for i in range(n): arr[i] = output[i] # Find the maximum number to know the number of digits max_num = max(arr) # Do counting sort for every digit. The exponent starts from 1 (10^0) and increases by a factor of 10. exp = 1 iteration = 0 while max_num // exp > 0: counting_sort(arr, exp) if simulation: print(f\\"iteration {iteration} : {\' \'.join(map(str, arr))}\\") exp *= 10 iteration += 1 return arr"},{"question":"Validate Binary Search Tree Context In biotechnology, researchers often use tree structures to organize and manipulate hierarchical data from genetic studies. One critical task in such operations is ensuring data integrity by checking that certain properties are maintained. Given a binary tree, write a function `is_bst` to determine if it is a valid binary search tree (BST). A BST has the following properties: * The left subtree of a node contains only nodes with keys less than the node\'s key. * The right subtree of a node contains only nodes with keys greater than the node\'s key. * Both the left and right subtrees must also be binary search trees. Function Signature ```python def is_bst(root): :type root: TreeNode :rtype: bool ``` Input - `root`: The root node of the binary tree. Output - Return `True` if the binary tree is a valid BST, otherwise return `False`. Constraints - Nodes are represented by `TreeNode` class instances. - Values of the nodes are integers within the range from `-2^31` to `2^31 - 1`. Example *Example 1:* ```plaintext 2 / 1 3 Binary tree [2,1,3], return True. ``` *Example 2:* ```plaintext 1 / 2 3 Binary tree [1,2,3], return False. ``` Implementation Notes - You are required to implement an in-order traversal to ensure that the nodes are checked in sorted order. - Use an iterative approach with a stack to simulate recursion. ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Performance - Aim for a time complexity of O(n), where n is the number of nodes. - Aim for a space complexity of O(h), where h is the height of the tree.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_bst(root): :type root: TreeNode :rtype: bool def validate(node, low=float(\'-inf\'), high=float(\'inf\')): # An empty tree is a valid BST if not node: return True # The current node\'s value must be within the range if node.val <= low or node.val >= high: return False # The left subtree must be valid with updated high constraint # The right subtree must be valid with updated low constraint return (validate(node.left, low, node.val) and validate(node.right, node.val, high)) return validate(root)"},{"question":"Scenario: You are tasked with implementing a specialized search function tailored for datasets stored in an advanced, geo-spatial database system. The data stored in this system is predominantly uniformly distributed due to its geographical nature. You have to implement a search mechanism to optimize the performance of locating specific records efficiently. Task: Implement the provided Interpolation Search algorithm in Python, ensuring it works efficiently for the described use case. Additionally, handle edge cases and optimize error-checking mechanisms. Function Signature: ```python def interpolation_search(array: List[int], search_key: int) -> int: # your implementation here ``` Input: - `array` (List[int]): A sorted array of integers representing the dataset (size n where 1 ≤ n ≤ 10^5). - `search_key` (int): The key to be searched within the array (-10^5 ≤ search_key ≤ 10^5). Output: - Return the index of `search_key` if found within the array. - If `search_key` is not found, return -1. Constraints: - The array will be uniformly distributed. - Ensure the function is optimized to handle edge cases and avoids any performance bottlenecks. - The function should run efficiently even for the upper limits of input size. Example/Test Cases: ```python # Example 1 array = [-25, -12, -1, 10, 12, 15, 20, 41, 55] search_key = -1 # Returns: 2 print(interpolation_search(array, search_key)) # Example 2 array = [5, 10, 12, 14, 17, 20, 21] search_key = 55 # Returns: -1 print(interpolation_search(array, search_key)) # Example 3 array = [5, 10, 12, 14, 17, 20, 21] search_key = -5 # Returns: -1 print(interpolation_search(array, search_key)) ``` Additional Validation: - Ensure to handle edge cases such as the presence of duplicate elements in the array. - Ensure the search key outside the range of array values should immediately return -1. - Avoid scenarios leading to division by zero errors.","solution":"from typing import List def interpolation_search(array: List[int], search_key: int) -> int: Perform interpolation search on a uniformly distributed sorted array. Parameters: array (List[int]): A sorted array of integers. search_key (int): The key to be searched. Returns: int: The index of search_key in array if found, else -1. low = 0 high = len(array) - 1 while low <= high and search_key >= array[low] and search_key <= array[high]: if low == high: if array[low] == search_key: return low return -1 pos = low + ((high - low) // (array[high] - array[low]) * (search_key - array[low])) if array[pos] == search_key: return pos if array[pos] < search_key: low = pos + 1 else: high = pos - 1 return -1"},{"question":"# Background Your company is developing an educational platform that visually demonstrates sorting algorithms. As part of this project, we need a function to sort an array using Selection Sort. Additionally, the platform should be able to simulate the sorting process by displaying the array after every swap operation. # Task Write a Python function `selection_sort(arr, simulation=False)` that sorts a list of integers using the Selection Sort algorithm. The function should optionally simulate and print the array at the end of each iteration when the `simulation` parameter is set to `True`. # Implementation Requirements 1. **Function Signature**: ```python def selection_sort(arr, simulation=False) ``` 2. **Input**: - `arr` : List of integers that need to be sorted. - `simulation` : Boolean parameter (default `False`), when `True`, it prints the array after each iteration. 3. **Output**: - A sorted list of integers in ascending order. - When `simulation=True`, print the array at the end of each iteration. # Constraints 1. Do not use any built-in sorting functions or libraries. 2. Ensure the function handles edge cases such as an empty array, an array with one element, and an array with identical elements. # Example ```python arr = [64, 25, 12, 22, 11] print(selection_sort(arr, simulation=True)) ``` Output: ``` iteration 0 : 64 25 12 22 11 iteration 1 : 11 25 12 22 64 iteration 2 : 11 12 25 22 64 iteration 3 : 11 12 22 25 64 ``` And the final returned sorted array: ``` [11, 12, 22, 25, 64] ``` # Notes * Remember to \\"select\\" and swap the smallest value in the unsorted portion and print the array after each iteration when `simulation=True`. * Focus on correctness and clarity of your code.","solution":"def selection_sort(arr, simulation=False): Sorts the input list using the Selection Sort algorithm. Parameters: arr (list): a list of integers to be sorted simulation (bool): if True, prints the array at the end of each iteration Returns: list: the sorted list n = len(arr) for i in range(n): min_idx = i for j in range(i+1, n): if arr[j] < arr[min_idx]: min_idx = j # Swap the found minimum element with the first element arr[i], arr[min_idx] = arr[min_idx], arr[i] if simulation: print(f\'iteration {i} : {\\" \\".join(map(str, arr))}\') return arr"},{"question":"# Question: Efficient Quick Sort Implementation **Scenario**: You are tasked with sorting a large dataset of numbers using a highly efficient sorting algorithm due to memory constraints and the data\'s unsorted nature. **Task**: Implement an optimized version of Quick Sort, considering the partitioning and pivot selection process. Your implementation should include the following: 1. **Efficient Pivot Selection Strategy**: Use the median-of-three method to select the pivot to minimize the chance of hitting the worst-case performance. 2. **In-Place Sorting**: Ensure that memory consumption is kept to a minimum. 3. **Handling Edge Cases**: Appropriately manage arrays that are empty or contain duplicate values. **Function Signature**: ```python def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: ``` # Input: * `arr`: List of integers to be sorted. * `simulation`: Optional boolean flag indicating whether to print iterations. # Output: * Returns the sorted list of integers. # Constraints: * You may assume all elements of `arr` are integers. * Aim to implement an in-place solution to limit additional memory usage. * Manage arrays of arbitrary size, including large datasets efficiently. OPTIONAL: # Performance Requirements: Your solution should aim for: * An efficient average-case run-time of O(n log n). * Reduced worst-case performance with a good pivot strategy. * Minimal additional space complexity beyond the input array. # Example: ```python assert optimized_quick_sort([3, 6, 8, 10, 1, 2, 1]) == [1, 1, 2, 3, 6, 8, 10] ``` # Note: Performance analysis and edge case handling will be a part of your code review. Consider elaborating on optimizations and choices made during implementation.","solution":"from typing import List import random def median_of_three(arr, low, high): mid = (low + high) // 2 a, b, c = arr[low], arr[mid], arr[high] if a > b: if a < c: return low elif b > c: return mid else: return high if b < c: return mid elif a > c: return low else: return high def partition(arr, low, high): pivot_index = median_of_three(arr, low, high) pivot_value = arr[pivot_index] arr[pivot_index], arr[high] = arr[high], arr[pivot_index] store_index = low for i in range(low, high): if arr[i] < pivot_value: arr[i], arr[store_index] = arr[store_index], arr[i] store_index += 1 arr[store_index], arr[high] = arr[high], arr[store_index] return store_index def quick_sort(arr, low, high, simulation): if low < high: pivot_index = partition(arr, low, high) if simulation: print(f\\"arr: {arr}, low: {low}, high: {high}, pivot_index: {pivot_index}\\") quick_sort(arr, low, pivot_index - 1, simulation) quick_sort(arr, pivot_index + 1, high, simulation) def optimized_quick_sort(arr: List[int], simulation: bool = False) -> List[int]: if not arr or len(arr) <= 1: return arr quick_sort(arr, 0, len(arr) - 1, simulation) return arr"},{"question":"# Longest Common Subsequence - Coding Assessment Question Context: Imagine you\'re a software engineer working with a large dataset comprised of different texts and biological sequences. For a specific task, you need an efficient algorithm to determine the longest contiguous common substring between two given strings (s1) and (s2). However, (s2) is guaranteed to consist only of unique characters. Objective: Write a Python function `max_common_sub_string(s1: str, s2: str) -> str` that takes two strings (s1) and (s2) and returns the longest contiguous substring present in both strings. If there are multiple such substrings with the same length, return the one which appears first in (s1). Ensure the function operates within (O(n log n)) complexity. Input: - `s1` (string): The first string where we will search for the common substring. - `s2` (string): The second string containing unique characters, aiding for comparisons. Output: - The function should return the longest common contiguous substring present in both `s1` and `s2`. Constraints: 1. Both strings are non-empty. 2. `s2` contains all distinct characters. 3. The length of each string will be between 1 and 10^5 (inclusive). Example: ```python print(max_common_sub_string(\\"abcde\\", \\"bce\\")) # Output: \\"bc\\" print(max_common_sub_string(\\"xyzabcd\\", \\"bzcd\\")) # Output: \\"cd\\" ``` Performance Requirements: The solution should aim to process inputs within the specified complexity constraints. Consider both time and space efficiency in your design.","solution":"def max_common_sub_string(s1, s2): Finds the longest contiguous common substring between two strings s1 and s2. len1, len2 = len(s1), len(s2) # Initialize the DP table dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] max_len = 0 end_index_s1 = 0 # Populate the DP table for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 if dp[i][j] > max_len: max_len = dp[i][j] end_index_s1 = i # Extract the maximum length substring if max_len == 0: return \\"\\" else: start_index_s1 = end_index_s1 - max_len return s1[start_index_s1:end_index_s1]"},{"question":"# Scenario Your task is to implement a function that sorts an array of integers using the Shell Sort algorithm. Shell Sort improves upon simple insertion sort by breaking the original list into smaller sub-lists, which are then sorted using insertion sort. The array is divided based on a gap sequence, and the gaps are progressively reduced until the whole array is sorted. # Function Details Implement the function named `shell_sort` to sort an array of integers: **Function Signature:** ```python def shell_sort(arr: List[int]) -> List[int]: ``` **Input:** - `arr`: A list of integers. (0 <= len(arr) <= 10^5, -10^9 <= arr[i] <= 10^9) **Output:** - The function should return a new list containing the sorted integers in ascending order. # Constraints - The function should not mutate the input list. It should return a new sorted list. - The function must implement the Shell Sort algorithm. - The implementation should strive for optimal performance. # Example ```python assert shell_sort([12, 34, 54, 2, 3]) == [2, 3, 12, 34, 54] assert shell_sort([5, 1, 1, 2, 0, 0]) == [0, 0, 1, 1, 2, 5] assert shell_sort([]) == [] assert shell_sort([42]) == [42] assert shell_sort([9,8,6,1,3,7,5,0,2,4]) == [0,1,2,3,4,5,6,7,8,9] ``` # Challenge To further enhance your function, experiment with different gap sequences other than the traditional `n/2` and see if you can improve the performance for larger datasets. You can report back on the results and insights gained from trying different sequences or optimizations.","solution":"from typing import List def shell_sort(arr: List[int]) -> List[int]: Sorts an array of integers using the Shell Sort algorithm and returns a new sorted list. # Create a copy of the input list to avoid mutating it sorted_arr = arr[:] n = len(sorted_arr) gap = n // 2 # Start with a big gap and reduce the gap until we can do a regular insertion sort while gap > 0: # Perform a gapped insertion sort for this gap size for i in range(gap, n): temp = sorted_arr[i] j = i # Shift earlier gap-sorted elements up until the correct location for sorted_arr[i] is found while j >= gap and sorted_arr[j - gap] > temp: sorted_arr[j] = sorted_arr[j - gap] j -= gap # Put temp (the original sorted_arr[i]) in its correct location sorted_arr[j] = temp gap //= 2 return sorted_arr"},{"question":"# Coding Task: Optimized Cycle Sort You are tasked with optimizing an existing **Cycle Sort** algorithm by implementing a version that reduces the number of comparisons made during the sorting process. Objective: - Write a function `optimized_cycle_sort(arr)` that sorts an array utilizing the principles of Cycle Sort but minimizes redundant comparisons. Specifications: - **Input**: An array `arr` of `N` integers where `1 <= N <= 10^4` and each element `0 <= arr[i] < 10^6`. - **Output**: A sorted array in ascending order. - **Constraints**: - Do not use any additional library functions for sorting. - Implement sort in-place with O(1) extra space. - Aim to reduce the average number of comparisons compared to the basic Cycle Sort. Example: ```python # Example 1 arr = [4, 5, 3, 2, 7, 1] print(optimized_cycle_sort(arr)) # Output: [1, 2, 3, 4, 5, 7] # Example 2 arr = [1, 2, 3, 4, 5, 6] print(optimized_cycle_sort(arr)) # Output: [1, 2, 3, 4, 5, 6] ``` Guidelines: 1. Identify cycles in the permutation of the array. 2. For each cycle, minimize redundant comparisons to improve efficiency. 3. Ensure that the algorithm remains in O(N^2) time complexity but demonstrates a clear reduction in the number of comparisons performed. Notes: - Provide detailed comments explaining each step of your algorithm and the improvements made over the basic Cycle Sort. - Edge cases to consider include arrays of various sizes, arrays with repeated elements, and sorted/partially sorted arrays.","solution":"def optimized_cycle_sort(arr): Function to sort an array using the optimized cycle sort algorithm. n = len(arr) writes = 0 for cycle_start in range(0, n - 1): item = arr[cycle_start] # Find the position where we put the element pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 # If the item is already in the correct position if pos == cycle_start: continue # Otherwise, put the item to the right position while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 # Rotate the rest of the cycle while pos != cycle_start: pos = cycle_start for i in range(cycle_start + 1, n): if arr[i] < item: pos += 1 while item == arr[pos]: pos += 1 arr[pos], item = item, arr[pos] writes += 1 return arr"},{"question":"Context You are working on a data preprocessing task where you need to handle nested arrays. Typically, arrays might contain lists within lists at multiple levels of depth. For further analysis and operations, you need a utility function that can flatten these nested arrays into a single-dimensional array. Task Write a function `flatten_array(input_arr: List[Any]) -> List[Any]` that flattens a multi-dimensional array (list) into a single-dimensional list. # Input and Output Formats * **Input**: A list `input_arr` which may contain nested lists and any other types of elements. * **Output**: A single-dimensional list with all elements from the nested array in the same order. Constraints * The input list and its nested lists may contain integers, strings, nested lists, and other objects. * Strings should not be broken down into individual characters. * You should handle the recursion to avoid exceeding the system call stack limit. Requirements * The function should handle varying depths of nesting effectively. * Optimize for performance where possible and avoid excessive memory usage. Example ```python # Example 1 input_arr = [1, [2, 3], [[4, 5], 6], 7] # Output: [1, 2, 3, 4, 5, 6, 7] # Example 2 input_arr = [\'a\', [\'b\', [\'c\', \'d\'], \'e\'], \'f\'] # Output: [\'a\', \'b\', \'c\', \'d\', \'e\', \'f\'] ``` # Function Signature ```python def flatten_array(input_arr: List[Any]) -> List[Any]: Flattens a nested list into a single-dimensional list. pass ``` # Performance Consideration Ensure your implementation avoids deep recursion leading to call stack overflow for highly nested arrays. Consider alternative approaches if necessary to handle large input sizes efficiently.","solution":"from typing import List, Any def flatten_array(input_arr: List[Any]) -> List[Any]: Flattens a nested list into a single-dimensional list. Args: input_arr (List[Any]): A nested list which may contain nested lists and any other types of elements. Returns: List[Any]: A single-dimensional list with all elements from the nested array in the same order. flat_list = [] def flatten(sub_arr): for item in sub_arr: if isinstance(item, list): flatten(item) else: flat_list.append(item) flatten(input_arr) return flat_list"},{"question":"You are employed as a backend engineer at a fintech company working on encryption protocols. A core part of the encryption requires generating and verifying large prime numbers efficiently. Your task is to implement a prime-checking function, optimized for handling multiple large inputs. # Function Signature ```python def is_prime(n: int) -> bool: Determine if n is a prime number. :param n: An integer to be checked for primality. :return: True if n is a prime number, False otherwise. pass ``` # Input - A single integer `n` where `0 <= n <= 10^12`. # Output - Return `True` if `n` is a prime number, `False` otherwise. # Constraints - Your solution should be efficient enough to handle the upper limit within a reasonable time (e.g., a few seconds per number). # Examples - `is_prime(2)` should return `True`. - `is_prime(4)` should return `False`. - `is_prime(17)` should return `True`. - `is_prime(100000000003)` should return `True`. # Notes - Consider edge cases such as small numbers (including negatives and zero), even numbers, and large primes near the upper constraint. - Optimize your solution for performance to ensure it can handle factors of very large numbers up to 10^12.","solution":"def is_prime(n: int) -> bool: Determine if n is a prime number. :param n: An integer to be checked for prime. :return: True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"You are given a matrix of `m x n` elements (m rows and n columns). Your task is to return all elements of the matrix in spiral order. **Function Signature**: ```python def spiral_order(matrix: List[List[int]]) -> List[int]: pass ``` # Input: * `matrix`: A list of lists where each sublist represents a row in an `m x n` matrix. # Output: * A list of integers representing the elements of the matrix in spiral order. # Constraints: * `0 <= m, n <= 10^3` * `-10^4 <= matrix[i][j] <= 10^4` # Examples: Example 1: ```python matrix = [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] Output: [1, 2, 3, 6, 9, 8, 7, 4, 5] ``` Example 2: ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12] ] Output: [1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7] ``` # Scenario In a warehouse, products are shelved in rows and columns. To efficiently pick products, a robot moves in a spiral path starting from the top-left corner of the shelving system and proceeds in a clockwise manner until all products are picked. Implement a function to simulate this behavior.","solution":"def spiral_order(matrix): Returns all elements of the matrix in spiral order. if not matrix or not matrix[0]: return [] result = [] top, bottom = 0, len(matrix) - 1 left, right = 0, len(matrix[0]) - 1 while top <= bottom and left <= right: # Traverse from left to right along the top row for i in range(left, right + 1): result.append(matrix[top][i]) top += 1 # Move the top boundary down # Traverse from top to bottom along the right column for i in range(top, bottom + 1): result.append(matrix[i][right]) right -= 1 # Move the right boundary left if top <= bottom: # Traverse from right to left along the bottom row for i in range(right, left - 1, -1): result.append(matrix[bottom][i]) bottom -= 1 # Move the bottom boundary up if left <= right: # Traverse from bottom to top along the left column for i in range(bottom, top - 1, -1): result.append(matrix[i][left]) left += 1 # Move the left boundary right return result"},{"question":"You are given a directed graph class with a method to determine if the graph is strongly connected. A strongly connected graph is one where there is a path between any pair of vertices. Given the `Graph` class, implement an additional method to determine if the graph is weakly connected. A graph is weakly connected if replacing all its directed edges with undirected edges produces a connected (undirected) graph. # Function Signature ```python def is_weakly_connected(graph: Graph) -> bool: pass ``` # Input - An instance of `Graph` with the given vertices and directed edges. # Output - A boolean value: `True` if the graph is weakly connected, `False` otherwise. # Constraints - 1 <= number of vertices <= 1000 - 0 <= number of edges <= 10000 # Performance Requirements - The algorithm should run in O(V + E) time complexity where V is the number of vertices and E is the number of edges. # Implementation Guidance - Utilize Breadth-First Search (BFS) or an alternative approach to check connectivity in the undirected version of the graph. - Ensure that all vertices in the graph are reachable from any starting vertex after replacing directed edges with undirected edges. # Example ```python # Example graph setup graph = Graph(5) graph.add_edge(0, 1) graph.add_edge(1, 2) graph.add_edge(2, 3) graph.add_edge(3, 4) graph.add_edge(4, 0) print(is_weakly_connected(graph)) # Output: True graph.add_edge(3, 5) # Adding a vertex not connected to others print(is_weakly_connected(graph)) # Output: False ``` Good luck with your implementation!","solution":"from collections import deque class Graph: def __init__(self, num_vertices): self.num_vertices = num_vertices self.adj_list = {i: [] for i in range(num_vertices)} def add_edge(self, u, v): self.adj_list[u].append(v) def is_weakly_connected(graph: Graph) -> bool: def bfs(start): visited = [False] * graph.num_vertices queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph.adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Check the reversed edges. for i in range(graph.num_vertices): if node in graph.adj_list[i] and not visited[i]: visited[i] = True queue.append(i) return visited # Perform BFS starting from the first vertex if graph.num_vertices == 0: return True visited = bfs(0) # If there\'s any vertex not visited, the graph is not weakly connected return all(visited)"},{"question":"**Problem Statement**: You are given an array of strings where each string is comprised of lowercase letters. Your task is to write a function `group_anagrams` that groups the strings into sets of anagrams. Anagrams are strings that can be formed by rearranging the characters of another string. **Function Signature**: ```python def group_anagrams(strs: List[str]) -> List[List[str]]: ``` **Input**: - strs: List[str] — A list of strings, 0 <= len(strs) <= 10^4 and len(str) <= 100. **Output**: - Returns: List[List[str]] — A list of lists, where each sublist contains strings that are anagrams of each other. **Constraints**: - Each string will consist only of lowercase English letters. - The order of the groups and the order within each group does not matter. **Performance Requirements**: - Ensure the solution runs efficiently within the given constraints. **Example**: ```python # Example 1 input = [\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] output = [ [\\"ate\\", \\"eat\\", \\"tea\\"], [\\"nat\\", \\"tan\\"], [\\"bat\\"] ] # Example 2 input = [] output = [] # Example 3 input = [\\"a\\"] output = [[\\"a\\"]] ``` **Scenario**: Imagine you are building a spell checker that clusters together all permutations of words for optimization purposes. By grouping anagrams into sets, the spell checker will effectively reduce the number of lookups and comparisons needed during text processing. **Description**: Write the `group_anagrams` function that processes the list of strings and groups them according to the anagram rules. To ensure optimal performance, consider ways to reduce complexity, such as avoiding unnecessary repeated sort operations. Be mindful of edge cases to avoid errors.","solution":"from typing import List from collections import defaultdict def group_anagrams(strs: List[str]) -> List[List[str]]: Groups an array of strings into sets of anagrams. :param strs: List of strings :return: List of lists, where each sublist contains strings that are anagrams of each other anagram_dict = defaultdict(list) for s in strs: # Sort the string to generate a key for anagrams sorted_s = \'\'.join(sorted(s)) anagram_dict[sorted_s].append(s) # Convert the dictionary values to a list of lists return list(anagram_dict.values())"},{"question":"# Question: Join Paths Using Customized Rules You are tasked with implementing a function that joins two strings, `base` and `suffix`, to form a path using a slash (`/`). The function must ensure there are no redundant slashes between the two parts. Requirements: * If `base` ends with a slash, it should be removed. * If `suffix` starts with a slash, it should be removed. * Ensure there is exactly one slash between the two parts after joining them. # Function Signature: ```python def join_with_slash(base: str, suffix: str) -> str: ``` # Input: * `base` (str): The base part of the path. * `suffix` (str): The suffix part of the path. # Output: * (str): The concatenated result of `base` and `suffix` joined by a slash. # Constraints: * The length of `base` and `suffix` will be between 0 and 1000. * `base` and `suffix` will only contain printable ASCII characters. # Example: 1. `join_with_slash(\'path/to/dir\', \'file\')` -> `\'path/to/dir/file\'` 2. `join_with_slash(\'path/to/dir/\', \'file\')` -> `\'path/to/dir/file\'` 3. `join_with_slash(\'http://algorithms.com\', \'part\')` -> `\'http://algorithms.com/part\'` 4. `join_with_slash(\'http://algorithms.com/\', \'/part\')` -> `\'http://algorithms.com/part\'` 5. `join_with_slash(\'\', \'part\')` -> `\'part\'` 6. `join_with_slash(\'path/to/base\', \'\')` -> `\'path/to/base\'` # Edge Cases: * Consider cases where either `base` or `suffix` is empty. * Ensure correctness when both `base` and `suffix` contain slashes at their junction. Implement the function `join_with_slash` to fulfill these requirements. Test your function to ensure it handles all the specified scenarios and edge cases.","solution":"def join_with_slash(base: str, suffix: str) -> str: Joins two strings, `base` and `suffix`, ensuring there is exactly one slash between them. # Remove trailing slash from base if it exists if base.endswith(\'/\'): base = base.rstrip(\'/\') # Remove leading slash from suffix if it exists if suffix.startswith(\'/\'): suffix = suffix.lstrip(\'/\') # Join with a single slash if base and suffix: return f\\"{base}/{suffix}\\" elif base: return base elif suffix: return suffix else: return \'\'"},{"question":"# Question: Implement Nested Data Flattening Function You are tasked with implementing a function that takes a nested iterable structure and returns a flat list of all elements in the structure. This problem assesses your understanding of recursion, handling nested structures, and efficiently managing memory. # Function Signature ```python def flatten_data_structure(data): pass ``` # Input - `data`: A potentially nested iterable containing various elements (can be nested lists, tuples, sets, etc.). Note that strings, although iterable, should be treated as single elements and not split into individual characters. # Output - Returns a flat list containing all elements from the input nested structure, preserving their order. # Constraints - The depth of nesting can be up to 1000. - Elements in the structure can include integers, floats, strings, lists, tuples, sets, and other iterable collections. - You must not use any built-in function such as `chain` from `itertools` to flatten the structure directly. # Example ```python assert flatten_data_structure([1, [2, 3, [4], {\'a\', \'b\'}, (5, 6)], 7]) == [1, 2, 3, 4, \'a\', \'b\', 5, 6, 7] assert flatten_data_structure([\'hello\', [\'world\', [\'!\']]]) == [\'hello\', \'world\', \'!\'] assert flatten_data_structure([]) == [] assert flatten_data_structure([[], [[]]]) == [] ``` # Notes - Pay attention to edge cases such as empty nested arrays and strings within the nested structure. - Aim for an efficient solution that carefully manages memory and recursion depth.","solution":"def flatten_data_structure(data): Flattens a nested iterable structure into a flat list of elements. flattened_list = [] def _flatten(element): if isinstance(element, (list, tuple, set)): for item in element: _flatten(item) else: flattened_list.append(element) _flatten(data) return flattened_list"},{"question":"# Scenario: You are given the task of calculating an average score for a series of student test results. Some scores are extremely low or high due to occasional errors and should not significantly influence the average score. To ensure a fair mean calculation, you are required to trim a certain percentage of the highest and lowest scores before calculating the mean. # Objective: Implement a function `trimmean` in Python that calculates the trimmed mean of a list of numbers after removing a specified percentage of the highest and lowest values. # Function Signature: ```python def trimmean(arr: List[float], per: float) -> float: ``` # Input: * `arr`: List of float/int values representing scores. The list will have at least one element, but could be large. * `per`: A float value representing the percentage of the highest and lowest values to trim. It will be in the range from 0 to 100. # Output: * Returns the trimmed mean as a float. # Constraints: * The percentage provided must be valid; ensure it does not result in removing all elements from `arr`. * Optimize your solution to handle large lists efficiently. # Example: ```python # Example 1: print(trimmean([50.0, 60.0, 70.0, 80.0, 90.0], 20.0)) # Output: 70.0 # Example 2: print(trimmean([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 40.0)) # Output: 5.5 ``` # Notes: * For the purpose of this problem, round the mean to two decimal places. * Consider edge cases where the percentage given might remove too many elements or leave too few to calculate a reliable mean.","solution":"def trimmean(arr, per): Returns the trimmed mean of a list of numbers after removing a specified percentage of the highest and lowest values. :param arr: List of float/int values representing scores. :param per: A float value representing the percentage of the highest and lowest values to trim. It will be in the range from 0 to 100. :return: The trimmed mean as a float. # Ensure the percentage is not invalid if not 0 <= per < 100: raise ValueError(\'Percentage must be between 0 and 100 (exclusive).\') # Calculate the number of elements to trim total_len = len(arr) trim_count = int(total_len * per / 100) # Sort the array sorted_arr = sorted(arr) # Trim the values trimmed_arr = sorted_arr[trim_count:(total_len - trim_count)] # Calculate the mean of the trimmed list if not trimmed_arr: raise ValueError(\'Trimmed array is empty. Adjust the percentage to leave elements.\') trimmed_mean = sum(trimmed_arr) / len(trimmed_arr) return round(trimmed_mean, 2)"},{"question":"# String Encoding and Decoding **Objective**: Write two functions `encode` and `decode` to encode a list of strings into a single string and decode the single string back into the original list. Part 1: Encoding Implement the `encode` function: ```python def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str pass ``` * **Input**: A list of strings `strs` where each string can be of any valid character. * **Output**: A single encoded string. Part 2: Decoding Implement the `decode` function: ```python def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] pass ``` * **Input**: A single encoded string `s`. * **Output**: A list of original strings. Constraints: 1. The list of strings may contain empty strings. 2. Each encoded string will form a valid encoding as described above. 3. You should handle special characters and edge cases properly. **Example:** ```python encoded_string = encode([\\"hello\\", \\"world\\"]) print(encoded_string) # Example output: \'5:hello5:world\' decoded_list = decode(encoded_string) print(decoded_list) # Example output: [\\"hello\\", \\"world\\"] ``` **Notes**: * Ensure that your encoding and decoding functions are efficient. * Handle all edge cases, such as the presence of special characters.","solution":"def encode(strs): Encodes a list of strings to a single string. :type strs: List[str] :rtype: str return \'\'.join(f\'{len(s)}:{s}\' for s in strs) def decode(s): Decodes a single string to a list of strings. :type s: str :rtype: List[str] i, n = 0, len(s) result = [] while i < n: j = i while s[j] != \':\': j += 1 length = int(s[i:j]) result.append(s[j+1:j+1+length]) i = j + 1 + length return result"},{"question":"# Question: Implement Prim’s Minimum Spanning Tree Algorithm with Enhanced Functionality You are required to implement an enhanced version of Prim\'s algorithm that not only finds the weight of the minimum spanning tree (MST) but also returns the edges that form the MST in a given connected, undirected graph. The function should handle string-named nodes and numerical indices interchangeably. Function Signature ```python def enhanced_prims_minimum_spanning_tree(graph_used: Dict[Union[str, int], List[Tuple[int, Union[str, int]]]]) -> Tuple[int, List[Tuple[Union[str, int], Union[str, int]]]]: Returns the weight of the MST and the edges forming the MST ``` # Input: * `graph_used`: A dictionary where: - Keys are the node names (can be strings or integers). - Values are lists of tuples, where each tuple has two elements: (weight, adjacent_node). # Output: * A tuple `(min_cost, mst_edges)` where: - `min_cost`: Integer representing the total weight of the minimum spanning tree. - `mst_edges`: List of tuples representing the edges in the MST, each tuple in the form (node1, node2). # Constraints: * The graph is connected, undirected, and contains at least two nodes. * There are no self-loops or multiple edges between the same pair of nodes. # Performance Requirements: * The implementation should have a time complexity of O(E log V) and space complexity of O(V). # Example: ```python graph = { \'a\': [ (3, \'b\'), (8, \'c\') ], \'b\': [ (3, \'a\'), (5, \'d\') ], \'c\': [ (8, \'a\'), (2, \'d\'), (4, \'e\') ], \'d\': [ (5, \'b\'), (2, \'c\'), (6, \'e\') ], \'e\': [ (4, \'c\'), (6, \'d\') ] } min_cost, mst_edges = enhanced_prims_minimum_spanning_tree(graph) print(min_cost) # Output: 14 print(mst_edges) # Output: [(\'a\', \'b\'), (\'b\', \'d\'), (\'d\', \'c\'), (\'c\', \'e\')] ```","solution":"import heapq from typing import Dict, List, Tuple, Union def enhanced_prims_minimum_spanning_tree(graph_used: Dict[Union[str, int], List[Tuple[int, Union[str, int]]]]) -> Tuple[int, List[Tuple[Union[str, int], Union[str, int]]]]: # Prim\'s algorithm to find MST start_node = next(iter(graph_used)) # Arbitrarily start with the first node in the graph visited = set() min_heap = [(0, start_node, start_node)] min_cost = 0 mst_edges = [] while min_heap: weight, frm, to = heapq.heappop(min_heap) if to in visited: continue visited.add(to) if frm != to: mst_edges.append((frm, to)) min_cost += weight for edge_weight, neighbor in graph_used[to]: if neighbor not in visited: heapq.heappush(min_heap, (edge_weight, to, neighbor)) return min_cost, mst_edges"},{"question":"# Scenario: You are working as a software engineer at a company that heavily relies on graph-based data structures for storing business logic. Recently, your team experienced a significant issue due to unintended modifications in the graph, causing data inconsistencies. To prevent this in the future, you have been tasked with creating an implementation to clone any given undirected graph, allowing the team to safely experiment on the copied graph without affecting the original. # Task: Implement a function that performs a deep copy of an undirected graph. Given a reference to a node from a connected undirected graph, return a new graph that is a deep copy of the old graph. # Input Format: - A reference to a node `node` which is an instance of the `UndirectedGraphNode`. # Output Format: - Return a reference to the copied graph node. # Constraints: - The graph can have self-loops and multiple connected components. # Performance Requirements: - Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges. - Space Complexity: O(V). # Note: - Each node contains a unique label. - You may assume all input graphs are connected. # Function Signature: ```python def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': # implementation here ``` # Example: Consider the following graph represented by the serialized input `{0,1,2#1,2#2,2}` This graph visually represents: 1 / / 0 --- 2 / _/ ```python # Example Usage: # Let\'s represent the above graph in terms of `UndirectedGraphNode` node_0 = UndirectedGraphNode(0) node_1 = UndirectedGraphNode(1) node_2 = UndirectedGraphNode(2) node_0.neighbors = [node_1, node_2] node_1.neighbors = [node_2] node_2.neighbors = [node_2] cloned_node = clone_graph(node_0) # Verify if the cloned_node correctly deep-copies the structure of the original graph. ```","solution":"class UndirectedGraphNode: def __init__(self, label: int): self.label = label self.neighbors = [] def clone_graph(node: \'UndirectedGraphNode\') -> \'UndirectedGraphNode\': if not node: return None node_map = {} def clone(node): if node in node_map: return node_map[node] copy = UndirectedGraphNode(node.label) node_map[node] = copy for neighbor in node.neighbors: copy.neighbors.append(clone(neighbor)) return copy return clone(node)"},{"question":"# Question: Implementing Secure Key Exchange Computations You are tasked with implementing a function that computes the modular exponentiation, critical for cryptographic key exchanges like Diffie-Hellman. This function will take three integers `base`, `exponent`, and `mod` and return the result of ((text{base}^text{exponent}) % text{mod}). Function Signature ```python def secure_key_exchange(base: int, exponent: int, mod: int) -> int: ``` Input - An integer `base` (1 ≤ base ≤ 10^9) - An integer `exponent` (0 ≤ exponent ≤ 10^9) - An integer `mod` (1 ≤ mod ≤ 10^9) Output - Returns an integer which is the computed ((text{base}^text{exponent}) % text{mod}). Constraints - The exponent must be non-negative. - The modulus should be a positive non-zero integer. Example ```python assert secure_key_exchange(2, 10, 1000) == 24 assert secure_key_exchange(3, 0, 29) == 1 assert secure_key_exchange(10, 10, 100) == 0 assert secure_key_exchange(7, 256, 13) == 9 ``` Special Conditions - The function should handle large numbers efficiently using logarithmic time complexity O(log n). - If the modulus is 1, the function should return 0 (as any number modulo 1 is 0). - Ensure correct handling of edge cases like zero exponent. Note The provided function should help in key cryptographic operations where large number exponentiation under a modulus is required.","solution":"def secure_key_exchange(base: int, exponent: int, mod: int) -> int: Computes the result of (base^exponent) % mod efficiently using the method of modular exponentiation. if mod == 1: return 0 result = 1 base = base % mod while exponent > 0: if (exponent % 2) == 1: result = (result * base) % mod exponent = exponent >> 1 base = (base * base) % mod return result"},{"question":"# Level Order Traversal of a Binary Tree Suppose you are given the root of a binary tree. Your task is to implement a function `level_order` that returns the level order traversal of its nodes\' values (i.e., from left to right, level by level). Function Signature ```python def level_order(root: TreeNode) -> List[List[int]]: ``` Input * `root`: The root node of a binary tree. The TreeNode is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Output * Return a list of lists, where each list represents the values of the nodes at each level of the binary tree. Constraints * The number of nodes in the tree is in the range [0, 10^4]. * -1000 <= Node value <= 1000. Performance Requirements * The implementation should handle large trees efficiently within the given constraints. * Must ensure O(n) time complexity and O(n) space complexity for processing n nodes. Example ```python # Example 1: root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert level_order(root) == [ [3], [9,20], [15,7] ] # Example 2: root = None assert level_order(root) == [] ``` Detailed Explanation Using a breadth-first approach, traverse each level of the tree. 1. Initialize a queue with the root node and a variable to store the results. 2. Process nodes level by level, adding children nodes to the queue. 3. After processing each level, store the values in the result list. 4. Continue until all levels are traversed. Edge Cases to Consider * Tree with no nodes (empty tree). * Tree with a single node. * Tree with nodes only on one side (left or right). Implement the function to handle the mentioned edge cases correctly.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def level_order(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = [root] while queue: level_length = len(queue) level_nodes = [] for _ in range(level_length): node = queue.pop(0) # dequeue level_nodes.append(node.val) if node.left: queue.append(node.left) # enqueue left child if node.right: queue.append(node.right) # enqueue right child result.append(level_nodes) return result"},{"question":"You are working at a network design company. Your task is to select routers to cover a set of offices with minimum cost. Each router has a specific cost and a certain range of office coverage. Given the total offices that need coverage and the available routers with their associated costs and coverage, write a function to determine the minimum cost set of routers that can cover all offices. **Function Requirements**: Implement a function `find_min_cost_routers` that takes three arguments: - `universe`: a set of integers representing the IDs of the offices that need coverage. - `subsets`: a dictionary where keys are router IDs and values are sets of integers representing the IDs of the offices that each router can cover. - `costs`: a dictionary where keys are router IDs and values are integers representing the cost of each router. The function should return a tuple containing two elements: 1. A set of integers representing the router IDs that form the minimum cost cover. 2. An integer representing the total cost of this set of routers. If it is impossible to cover all offices, the function should return (`None`, []). **Constraints**: - The universe set size will not exceed 20. - The number of routers will not exceed 100. - The cost of each router is a positive integer. - Each subset in `subsets` will have unique office IDs, and no coverage sets will be empty. **Performance Requirements**: - Your solution should be efficient to handle up to the given constraints promptly. **Example**: ```python universe = {1, 2, 3, 4, 5} subsets = {\'R1\': {4, 1, 3}, \'R2\': {2, 5}, \'R3\': {1, 4, 3, 2}} costs = {\'R1\': 5, \'R2\': 10, \'R3\': 3} output = find_min_cost_routers(universe, subsets, costs) print(output) # Expected Output: ({\'R2\', \'R3\'}, 13) ``` You are required to design and implement this function using an appropriate algorithm based on the given constraints.","solution":"def find_min_cost_routers(universe, subsets, costs): from itertools import combinations best_cost = float(\'inf\') best_routers = None all_routers = list(subsets.keys()) for i in range(1, len(all_routers) + 1): for combo in combinations(all_routers, i): combined_coverage = set() total_cost = 0 for router in combo: combined_coverage |= subsets[router] total_cost += costs[router] if combined_coverage >= universe and total_cost < best_cost: best_cost = total_cost best_routers = set(combo) if best_routers is not None: return best_routers, best_cost else: return None, 0"},{"question":"# String Merge Validation Question **Background/Scenario**: You\'ve recently joined a software firm that heavily focuses on manipulating strings for various applications. One of the basic utilities in one of the modules is checking if a given string can be formed from two other strings without altering the order of characters. Specifically, the characters from the two strings must appear in the given string in their respective order but can be interleaved. **Problem Statement**: Write a function `is_merge(s: str, part1: str, part2: str) -> bool` that takes in three string arguments, `s`, `part1`, and `part2`, and returns `True` if `s` can be formed by interleaving the characters from `part1` and `part2`, maintaining their respective order. Return `False` otherwise. # Input and Output Formats - **Input**: - `s` (1 ≤ |s| ≤ 100): the target string to be formed. - `part1` and `part2` (0 ≤ |part1|, |part2| ≤ 100): two strings to be interleaved. - **Output**: - A boolean value `True` if `s` can be formed by interleaving `part1` and `part2`, otherwise `False`. # Constraints: - The length of `s` is equal to the total length of `part1` and `part2`, i.e., |s| = |part1| + |part2|. - All characters are alphanumeric and case-sensitive. - Order of characters must be maintained. # Example: 1. ``` s = \\"codewars\\" part1 = \\"cdw\\" part2 = \\"oears\\" ``` Expected Output: `True` (since \\"cdw\\" and \\"oears\\" can be interleaved to form \\"codewars\\"). 2. ``` s = \\"abc\\" part1 = \\"ab\\" part2 = \\"bc\\" ``` Expected Output: `False` (since the characters must maintain their order from part1 and part2). # Edge Cases: - Consider scenarios where: - Any of the input strings is empty. - Characters do not match correctly. - The lengths are inconsistent. # Instructions: Your task is to implement the `is_merge(s: str, part1: str, part2: str) -> bool` function. Make sure your solution efficiently handles the constraints.","solution":"def is_merge(s: str, part1: str, part2: str) -> bool: Returns True if string s can be formed by interleaving part1 and part2 preserving their order, else returns False. n = len(part1) m = len(part2) if len(s) != n + m: return False # Create a DP table to store results of subproblems dp = [[False] * (m + 1) for _ in range(n + 1)] # Initialize the starting point dp[0][0] = True # Fill the table in a bottom-up manner for i in range(n + 1): for j in range(m + 1): if i > 0 and s[i + j - 1] == part1[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j] if j > 0 and s[i + j - 1] == part2[j - 1]: dp[i][j] = dp[i][j] or dp[i][j - 1] return dp[n][m]"},{"question":"# Question: Verifying Descending Stack Order Given a stack, write a function `is_sorted_descending(stack)` that checks if the elements in the stack are arranged in descending order from bottom to top. That is, the largest element should be at the bottom, and the smallest at the top. # Function Signature ```python def is_sorted_descending(stack: List[int]) -> bool: pass ``` # Expected Input and Output Formats - **Input**: A list `stack` that represents a stack (`list[int]`). For example: `[6, 5, 4, 3, 2, 1]`. - **Output**: A boolean value: `True` if the stack is sorted in descending order, `False` otherwise. # Constraints - The stack should not be modified permanently post-execution. - Solution should handle edge cases: empty stack, stack with single element. - Aim for linear time complexity with respect to the stack size. # Example ```python >>> is_sorted_descending([6, 5, 4, 3, 2, 1]) True >>> is_sorted_descending([1, 3, 2, 4, 5]) False >>> is_sorted_descending([10, 9, 8, 7, 7]) True >>> is_sorted_descending([1]) True >>> is_sorted_descending([]) True ``` # Scenario/Context Imagine you are working on a sorting and organization system that relies on stacks to manage inventories. One requirement is to ensure the items in a given stack are arranged in a strictly descending order, where the most significant item (largest value) is placed at the bottom for quick access. Your job is to create an efficient checking mechanism to verify this descending order without permanently altering the stack\'s contents.","solution":"def is_sorted_descending(stack): Check if the stack is sorted in descending order from bottom to top. n = len(stack) if n < 2: return True for i in range(n - 1): if stack[i] < stack[i + 1]: return False return True"},{"question":"Develop a function `generalized_gcd(arr)` which computes the greatest common divisor (GCD) of a list of integers. Then, use this function to develop another function `generalized_lcm(arr)` to compute the least common multiple (LCM) for the same list of integers. # Requirements 1. Implement the `generalized_gcd(arr)` function using the provided `gcd(a, b)` function as a building block. 2. Implement the `generalized_lcm(arr)` function using the `generalized_gcd(arr)` function and the provided `lcm(a, b)` function. 3. Your functions should handle edge cases including empty lists and lists with non-integer elements gracefully by raising appropriate exceptions. 4. Ensure optimal performance for large lists by avoiding redundant computations. # Function Signatures ```python def generalized_gcd(arr): Computes the GCD of a list of integers. Args: arr: List[int] - A list of integers. Returns: int: GCD of the list. Raises: ValueError: If arr is empty or contains non-integer elements. pass def generalized_lcm(arr): Computes the LCM of a list of integers. Args: arr: List[int] - A list of integers. Returns: int: LCM of the list. Raises: ValueError: If arr is empty or contains non-integer elements. pass ``` # Constraints * 1 <= len(arr) <= 100 * -10^6 <= arr[i] <= 10^6 # Example ```python # Example 1 arr = [2, 4, 6, 8] print(generalized_gcd(arr)) # Output: 2 print(generalized_lcm(arr)) # Output: 24 # Example 2 arr = [10, 20, 40] print(generalized_gcd(arr)) # Output: 10 print(generalized_lcm(arr)) # Output: 40 # Example 3 arr = [5, 7, 11] print(generalized_gcd(arr)) # Output: 1 print(generalized_lcm(arr)) # Output: 385 ``` # Notes 1. Your implementation should leverage the provided `gcd(a, b)` and `lcm(a, b)` functions. 2. Consider edge cases such as: * The list is empty. * The list contains one element. * The list contains negative numbers. 3. Ensure minimal computational overhead by avoiding unnecessary loops and recursive calls.","solution":"import math from functools import reduce def gcd(a, b): Computes the greatest common divisor of a and b. while b: a, b = b, a % b return a def lcm(a, b): Computes the least common multiple of a and b. return abs(a*b) // gcd(a, b) def generalized_gcd(arr): Computes the GCD of a list of integers. Args: arr: List[int] - A list of integers. Returns: int: GCD of the list. Raises: ValueError: If arr is empty or contains non-integer elements. if not arr: raise ValueError(\\"The list cannot be empty.\\") if not all(isinstance(x, int) for x in arr): raise ValueError(\\"All elements in the list must be integers.\\") return reduce(gcd, arr) def generalized_lcm(arr): Computes the LCM of a list of integers. Args: arr: List[int] - A list of integers. Returns: int: LCM of the list. Raises: ValueError: If arr is empty or contains non-integer elements. if not arr: raise ValueError(\\"The list cannot be empty.\\") if not all(isinstance(x, int) for x in arr): raise ValueError(\\"All elements in the list must be integers.\\") return reduce(lcm, arr)"},{"question":"# Convert File Paths to Absolute Paths The `full_path` function performs two key operations on a given file path: 1. It expands the user\'s home directory symbol (`~`) to the full home directory path. 2. It converts the resulting path to an absolute path, ensuring it is fully qualified. Your task is to extend the functionality of this function to handle several additional scenarios. # Requirements 1. Ensure that any path provided is first expanded if it contains the `~` character. 2. Convert the path to its absolute path form. 3. Check if the absolute path exists on the filesystem. If it does not, raise a `FileNotFoundError` with the message `\\"The path does not exist.\\"` 4. If the path is empty or contains only whitespace, raise a `ValueError` with the message `\\"Invalid path provided.\\"` # Function Signature ```python def full_path(file: str) -> str: pass ``` # Input - `file`: A string representing the relative or absolute file path. # Output - Returns the absolute path of the file as a string. # Constraints - The path should be checked for validity before converting to an absolute path. - The function should handle edge cases like empty paths or invalid formats. # Examples ```python # Example 1: Expand user directory and convert to absolute path print(full_path(\'~/Documents/test.txt\')) # Output: \'/home/username/Documents/test.txt\' (path may vary) # Example 2: Already absolute path print(full_path(\'/usr/local/bin\')) # Output: \'/usr/local/bin\' # Example 3: Non-existing path should raise FileNotFoundError print(full_path(\'/path/that/does/not/exist\')) # Output: FileNotFoundError: The path does not exist. # Example 4: Empty path should raise ValueError print(full_path(\'\')) # Output: ValueError: Invalid path provided. ```","solution":"import os def full_path(file: str) -> str: Expands the given file path by handling the user\'s home directory symbol (~), converting the path to an absolute path, and checking if the path exists. :param file: A string representing the relative or absolute file path. :return: The absolute path as a string. :raises FileNotFoundError: If the path does not exist. :raises ValueError: If an empty or invalid path is provided. if not file or file.strip() == \\"\\": raise ValueError(\\"Invalid path provided.\\") # Expand the user home directory symbol (~) expanded_path = os.path.expanduser(file) # Convert to an absolute path absolute_path = os.path.abspath(expanded_path) # Check if the absolute path exists if not os.path.exists(absolute_path): raise FileNotFoundError(\\"The path does not exist.\\") return absolute_path"},{"question":"Matrix Transformations You have been provided several functions that transform a given 2D matrix. For this exercise, you are required to implement two specific transformations: `rotate_clockwise` and `rotate_counterclockwise`. # Objectives: 1. **Rotate Clockwise**: Implement the function to rotate a given `n x m` matrix by 90 degrees clockwise. 2. **Rotate Counterclockwise**: Similarly, rotate the matrix by 90 degrees counterclockwise. # Input: * A 2D list `matrix` with `n` rows and `m` columns, where each element of the list is an integer. # Output: * A 2D list that represents the rotated matrix based on the specified transformation. # Function Signatures: ```python def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: # Implement this function pass def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: # Implement this function pass ``` # Constraints: - Matrix can be empty, in which case the function should return an empty matrix. - The rows in the matrix might not be of uniform length. # Example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Rotate Clockwise # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] print(rotate_clockwise(matrix)) # Rotate Counterclockwise # Output: # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] print(rotate_counterclockwise(matrix)) ``` **Note**: While implementing, ensure you handle edge cases and optimize where possible. Avoid deeply nested loops and redundant computations for better performance.","solution":"from typing import List def rotate_clockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] n = len(matrix) m = len(matrix[0]) rotated = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated[j][n - 1 - i] = matrix[i][j] return rotated def rotate_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix or not matrix[0]: return [] n = len(matrix) m = len(matrix[0]) rotated = [[0] * n for _ in range(m)] for i in range(n): for j in range(m): rotated[m - 1 - j][i] = matrix[i][j] return rotated"},{"question":"You are given a positive integer `n`. Your task is to write a function that determines whether the integer has alternating bits, i.e., no two adjacent bits in its binary representation are the same. Write two functions: 1. `has_alternating_bits(n: int) -> bool`: which implements the naive bit by bit checking approach. 2. `has_alternating_bits_fast(n: int) -> bool`: which uses bitwise operations and arithmetic with predefined masks for a fast constant-time solution. # Input - `n`: A positive integer (1 <= n <= 10^9) # Output - Return `True` if the integer `n` has alternating bits, otherwise return `False`. # Constraints - Your solution should handle the maximum constraints efficiently. - Pay attention to edge cases like the smallest integers and binary representations that have patterns close but not exactly matching alternating bits. # Examples ```python assert has_alternating_bits(5) == True # Binary Representation: 101 assert has_alternating_bits(7) == False # Binary Representation: 111 assert has_alternating_bits(11) == False # Binary Representation: 1011 assert has_alternating_bits(10) == True # Binary Representation: 1010 assert has_alternating_bits_fast(5) == True # Binary Representation: 101 assert has_alternating_bits_fast(7) == False # Binary Representation: 111 assert has_alternating_bits_fast(11) == False # Binary Representation: 1011 assert has_alternating_bits_fast(10) == True # Binary Representation: 1010 ``` Make sure your implementation handles the input constraints and edge cases efficiently.","solution":"def has_alternating_bits(n: int) -> bool: Checks if the binary representation of the integer n has alternating bits. previous_bit = n & 1 n >>= 1 while n > 0: current_bit = n & 1 if current_bit == previous_bit: return False previous_bit = current_bit n >>= 1 return True def has_alternating_bits_fast(n: int) -> bool: Checks if the binary representation of the integer n has alternating bits using a fast approach. x = n ^ (n >> 1) return (x & (x + 1)) == 0"},{"question":"# Polynomial and Monomial Manipulation You are given the implementation of classes `Monomial` and `Polynomial` which allow representation and manipulation of mathematical monomials and polynomials. **Objective**: Implement a function to compute the derivative of a polynomial with respect to a specified variable. # Function Specification ```python def derivative(poly: Polynomial, var_index: int) -> Polynomial: Computes the derivative of the given polynomial with respect to the given variable. Parameters: - poly (Polynomial): The polynomial to differentiate. - var_index (int): The index of the variable to differentiate with respect to. Returns: - Polynomial: The derivative of the given polynomial. pass ``` # Input - `poly`: An instance of the `Polynomial` class representing a polynomial. - `var_index`: An integer representing the variable index with respect to which the derivative is to be computed. # Output - A new `Polynomial` representing the derivative of the input polynomial with respect to the specified variable. # Example ```python # Example Polynomial: 2(a_1)^3(a_2) - 4(a_2)^2(a_3) + 5 p = Polynomial([ Monomial({1:3, 2:1}, 2), # 2(a_1)^3(a_2) Monomial({2:2, 3:1}, -4), # -4(a_2)^2(a_3) Monomial({}, 5) # +5 ]) # Derivative with respect to a_1 should be: # 6(a_1)^2(a_2) dp_da1 = derivative(p, 1) print(dp_da1) # Expected output: 6(a_1)^2(a_2) ``` # Constraints - The polynomial can contain up to 1000 monomials. - Each monomial can have variables with powers in the range [-10, 10]. - The coefficients of monomials will be real numbers (floats, integers, or fractions). # Notes - The coefficient of the derivative for a term with respect to a variable with zero power should result in zero and need not be included in the resultant polynomial. - Carefully handle monomials with the variable having negative powers.","solution":"class Monomial: def __init__(self, variables, coefficient): self.variables = variables # dictionary of var_index: exponent self.coefficient = coefficient def __repr__(self): # This is a simple string representation for debugging return f\\"({self.coefficient})\\" + \'\'.join([f\'a_{k}^{v}\' for k, v in sorted(self.variables.items())]) class Polynomial: def __init__(self, monomials): self.monomials = monomials def __repr__(self): # This is a simple string representation for debugging return \' + \'.join([str(m) for m in self.monomials]) def derivative(poly, var_index): Computes the derivative of the given polynomial with respect to the given variable. Parameters: - poly (Polynomial): The polynomial to differentiate. - var_index (int): The index of the variable to differentiate with respect to. Returns: - Polynomial: The derivative of the given polynomial. derivative_monomials = [] for monomial in poly.monomials: if var_index in monomial.variables: exponent = monomial.variables[var_index] if exponent != 0: new_coefficient = monomial.coefficient * exponent new_variables = monomial.variables.copy() if new_variables[var_index] == 1: del new_variables[var_index] else: new_variables[var_index] -= 1 derivative_monomials.append(Monomial(new_variables, new_coefficient)) return Polynomial(derivative_monomials)"},{"question":"# Matrix Multiplication Implementation **Context**: You are building a small component for a scientific computation library. One functionality that you need to support is matrix multiplication. Given two matrices, your task is to implement a function that correctly multiplies them and handles all edge cases gracefully. **Function Signature**: ```python def matrix_multiply(multiplicand: list, multiplier: list) -> list: ``` **Input**: * `multiplicand`: A list of lists where each sub-list represents a row of the matrix (e.g., [[1, 2], [3, 4]]). * `multiplier`: A list of lists with each sub-list representing a row of the matrix. **Output**: * Return the resulting matrix as a list of lists after multiplying `multiplicand` with `multiplier`. **Constraints**: 1. Assume each matrix is a valid 2D matrix with integer elements. 2. If the number of columns of the multiplicand does not equal the number of rows of the multiplier, raise an `Exception` with the message \\"Multiplicand matrix not compatible with Multiplier matrix.\\" 3. The resulting matrix should preserve the order of multiplication (i.e., the result of `A` x `B` is different from `B` x `A`). **Performance Requirements**: * The function should be designed to handle edge cases where matrix dimensions are incompatible. **Example**: ```python multiplicand = [ [1, 2, 3], [4, 5, 6] ] multiplier = [ [7, 8], [9, 10], [11, 12] ] result = matrix_multiply(multiplicand, multiplier) # Expected result: # [ # [58, 64], # [139, 154] # ] ``` Ensure your code is efficient and well-documented. Test your function with various matrices to validate its correctness and performance.","solution":"def matrix_multiply(multiplicand: list, multiplier: list) -> list: # Get dimensions of the matrices rows_multiplicand = len(multiplicand) cols_multiplicand = len(multiplicand[0]) rows_multiplier = len(multiplier) cols_multiplier = len(multiplier[0]) # Ensure that multiplicand columns match multiplier rows if cols_multiplicand != rows_multiplier: raise Exception(\\"Multiplicand matrix not compatible with Multiplier matrix.\\") # Initialize the result matrix with zeros result = [[0 for _ in range(cols_multiplier)] for _ in range(rows_multiplicand)] # Perform matrix multiplication for i in range(rows_multiplicand): for j in range(cols_multiplier): for k in range(cols_multiplicand): result[i][j] += multiplicand[i][k] * multiplier[k][j] return result"},{"question":"Problem Statement - Fenwick Tree Range Update and Point Query # Context: You are provided with an array of integers. You need to implement functions utilizing a Fenwick Tree (Binary Indexed Tree) to: 1. Update the elements within a given range by adding a specified value. 2. Query the exact value of any given element after some range updates. # Requirements: - Design and implement a Fenwick Tree with methods to handle: 1. **Range Updates:** Efficiently update all elements in a specified range `[l, r]` by adding a value `v` to each element within this range. 2. **Point Queries:** Return the value of an element at a specific index post any range updates. # Input and Output Formats: 1. **Initialization:** - An integer array `arr` of size `n`. 2. **Operations:** - `update_range(l, r, v)`: Add value `v` to all elements in the range `[l, r]` (inclusive). - `query_point(i)`: Return the value of element `arr[i]` after all updates. # Constraints: - `1 <= n <= 10^5` - `0 <= l, r < n` - `-10^9 <= v <= 10^9` - `0 <= i < n` **Example:** ```python # Initial array arr = [1, 2, 3, 4, 5] # Operations to perform ops = [ (\\"update_range\\", 1, 3, 10), (\\"query_point\\", 2), (\\"query_point\\", 4), (\\"update_range\\", 0, 4, 5), (\\"query_point\\", 0), (\\"query_point\\", 3) ] # Expected Output: # Initial: [1, 2, 3, 4, 5] # After update_range(1, 3, 10): [1, 12, 13, 14, 5] # query_point(2): 13 # query_point(4): 5 # After update_range(0, 4, 5): [6, 17, 18, 19, 10] # query_point(0): 6 # query_point(3): 19 ``` # Implementation: Implement the following class with given operations. ```python class FenwickTree: def __init__(self, arr): # Initialize the Fenwick Tree from given array def update_range(self, l, r, v): # Update range [l, r] by value v def query_point(self, i): # Return the value at index i ```","solution":"class FenwickTree: def __init__(self, arr): self.n = len(arr) self.tree = [0] * (self.n + 1) self.lazy = [0] * (self.n + 1) self.original = arr.copy() # Initially updating the Fenwick tree with array values for i in range(self.n): self.update_point(i, arr[i]) def update_point(self, i, val): idx = i + 1 while idx <= self.n: self.tree[idx] += val idx += idx & -idx def update_range(self, l, r, v): self._update_range(l, r, v) def _update_range(self, l, r, v): self._update(l + 1, v) self._update(r + 2, -v) def _update(self, idx, val): while idx <= self.n: self.lazy[idx] += val idx += idx & -idx def query_point(self, i): return self.original[i] + self._query(i + 1) def _query(self, idx): sum = 0 while idx > 0: sum += self.lazy[idx] idx -= idx & -idx return sum"},{"question":"# Question **Longest Common Prefix Problem** You are given an array of strings. Write a function to find the longest common prefix string amongst the array of strings. If there is no common prefix, return an empty string. Function Signature ```python def find_longest_common_prefix(strs: List[str]) -> str: ``` # Input * `strs`: A list of `n` strings (`1 <= n <= 10^4`) where each string\'s length is `1 <= len(string) <= 200`. # Output * Return a single string representing the longest common prefix. # Constraints * The array of strings contains only lowercase alphabetical characters. # Examples Example 1 ```python find_longest_common_prefix([\\"flower\\",\\"flow\\",\\"flight\\"]) ``` * Expected Output: `\\"fl\\"` Example 2 ```python find_longest_common_prefix([\\"dog\\",\\"racecar\\",\\"car\\"]) ``` * Expected Output: `\\"\\"` # Scenario Consider a situation where we need to define a namespace. Multiple modules in a large codebase might have common prefixes in their paths. Understanding shared prefixes can significantly simplify namespace management. # Performance Requirement * Your function should have a time complexity of O(S) where S is the sum of the length of all input strings. # Implementation Requirement Implement the function using: 1. Horizontal scanning. 2. Vertical scanning. 3. Divide and Conquer approach. Note: Ensure your function handles edge cases like an empty input list or a list containing empty strings appropriately.","solution":"from typing import List def find_longest_common_prefix(strs: List[str]) -> str: Function to find the longest common prefix string amongst a list of strings. If there is no common prefix, return an empty string. if not strs: return \\"\\" # Find the minimum length string min_len = min(len(s) for s in strs) if min_len == 0: return \\"\\" # Initialize prefix with the first string prefix = strs[0][:min_len] for s in strs: while s[:len(prefix)] != prefix and prefix: # Shorten the prefix by one character from the end until it matches prefix = prefix[:-1] if not prefix: break return prefix"},{"question":"# Scenario You are building a cryptographic system that relies heavily on modular arithmetic and primitive roots. One of the critical operations is identifying these roots for given integers, which is necessary for secure key generation. # Task Implement a function `is_primitive_root(a, n)` that checks if a given integer `a` is a primitive root of `n`. # Function Signature ```python def is_primitive_root(a: int, n: int) -> bool: Parameters: a (int): The integer to check. n (int): The modulo integer. Returns: bool: True if \'a\' is a primitive root of \'n\', else False. ``` # Input - `a` and `n` (1 <= a, n <= 10^6) - `a` and `n` are integers. # Constraints - `a` and `n` should be coprime (gcd(a, n) = 1). # Output - Return `True` if `a` is a primitive root of `n`, else return `False`. # Examples 1. `is_primitive_root(2, 5)` should return `True` because 2 is a primitive root of 5. 2. `is_primitive_root(4, 6)` should return `False` because 4 is not a primitive root of 6. # Explanation To solve this problem: 1. Calculate the Euler\'s totient function ϕ(n) for the given `n`. 2. Find the modular order of a using the `find_order` function. 3. Verify if the order equals ϕ(n), if so, `a` is a primitive root of `n`. # Note - Use the provided `euler_totient` function to calculate ϕ(n). - Use the provided `find_order` function to determine the order of `a` modulo `n`.","solution":"from math import gcd def euler_totient(n): Calculate Euler\'s Totient function ϕ(n) result = n p = 2 while (p * p <= n): if (n % p == 0): while (n % p == 0): n //= p result -= result // p p += 1 if (n > 1): result -= result // n return result def find_order(a, n): Find the order of a modulo n if gcd(a, n) != 1: return -1 # Invalid as \'a\' and \'n\' are not coprime order = 1 k = a % n while k != 1: k = (k * a) % n order += 1 if order > n: return -1 # order is too large return order def is_primitive_root(a, n): Check if \'a\' is a primitive root of \'n\' if gcd(a, n) != 1: return False phi_n = euler_totient(n) order_of_a = find_order(a, n) return order_of_a == phi_n"},{"question":"# Question Implement a function `optimized_comb_sort` in Python that sorts an array of integers using the comb sort algorithm. The optimized function should also handle a list of strings. The function should adhere to the following requirements: - **Input**: A list of integers or strings. - **Output**: A list sorted in ascending order. - **Constraints**: - The input list could contain anywhere from 0 to 10,000 elements. - Elements in the list will be integers or strings (not both in the same list). The function should be able to handle: * An empty list. * A list with only one element. * A list with all elements being the same. * A list that is already sorted in ascending order. Function Signature: ```python def optimized_comb_sort(arr: List[Union[int, str]]) -> List[Union[int, str]]: pass ``` Example: ```python assert optimized_comb_sort([34, -50, 3, 99, 88, -100, 42]) == [-100, -50, 3, 34, 42, 88, 99] assert optimized_comb_sort([\\"apple\\", \\"orange\\", \\"banana\\", \\"mango\\", \\"grape\\"]) == [\'apple\', \'banana\', \'grape\', \'mango\', \'orange\'] ``` **Note**: Ensure that your implementation can handle large inputs efficiently and include a brief explanation of any tweaks or optimizations you made to the standard comb sort algorithm.","solution":"from typing import List, Union def optimized_comb_sort(arr: List[Union[int, str]]) -> List[Union[int, str]]: def next_gap(gap): gap = int(gap / 1.3) return max(1, gap) n = len(arr) gap = n swapped = True while gap != 1 or swapped: gap = next_gap(gap) swapped = False for i in range(0, n - gap): if arr[i] > arr[i + gap]: arr[i], arr[i + gap] = arr[i + gap], arr[i] swapped = True return arr"},{"question":"# Question Given the TreeNode class provided below, implement a Binary Search Tree (BST) with functions for insertion, searching, and in-order traversal. Ensure your solution handles edge cases and is efficient. Class Definition: ```python class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None ``` # Task 1. **Insertion Function**: Implement a method `insert` that inserts a value into the BST. 2. **Search Function**: Implement a method `search` that searches for a value in the BST and returns True if found, else False. 3. **In-Order Traversal Function**: Implement a method `in_order_traversal` that returns a list of values representing the in-order traversal of the BST. # Input and Output Format - **Insertion**: - **Input**: Integer value to be inserted into the BST. - **Output**: Void. - **Searching**: - **Input**: Integer value to be searched in the BST. - **Output**: Boolean indicating if the value is present in the BST. - **In-Order Traversal**: - **Input**: None. - **Output**: List of integers representing the in-order traversal of the BST. # Constraints - The tree can contain negative, positive, and zero values. - Duplicate values should be ignored (no action should be taken if the value already exists). # Example ```python # Example Usage # Creating an empty BST bst = BST() # Inserting values bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(2) bst.insert(7) # Searching values print(bst.search(7)) # Output: True print(bst.search(3)) # Output: False # In-Order Traversal print(bst.in_order_traversal()) # Output: [2, 5, 7, 10, 15] ``` # Implementation Details 1. **Insert**: Function should traverse the BST and insert the value at the appropriate position. 2. **Search**: Function should traverse the BST to locate the value. 3. **In-Order Traversal**: Function should return values in ascending order as a list. **Note**: Pay attention to edge cases such as inserting and searching in an initially empty BST or handling duplicate values.","solution":"class TreeNode: def __init__(self, val=0): self.val = val self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, val): if self.root is None: self.root = TreeNode(val) else: self._insert(self.root, val) def _insert(self, node, val): if val < node.val: if node.left is None: node.left = TreeNode(val) else: self._insert(node.left, val) elif val > node.val: if node.right is None: node.right = TreeNode(val) else: self._insert(node.right, val) # if val == node.val, do nothing (no duplicates) def search(self, val): return self._search(self.root, val) def _search(self, node, val): if node is None: return False if val == node.val: return True elif val < node.val: return self._search(node.left, val) else: return self._search(node.right, val) def in_order_traversal(self): result = [] self._in_order_traversal(self.root, result) return result def _in_order_traversal(self, node, result): if node: self._in_order_traversal(node.left, result) result.append(node.val) self._in_order_traversal(node.right, result)"}]'),S={name:"App",components:{PoemCard:O},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},z={class:"search-container"},C={class:"card-container"},F={key:0,class:"empty-state"},L=["disabled"],R={key:0},Y={key:1};function j(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",z,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),y(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[_,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",C,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",F,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",Y,"Loading...")):(n(),i("span",R,"See more"))],8,L)):u("",!0)])}const P=c(S,[["render",j],["__scopeId","data-v-be677907"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"drive/45.md","filePath":"drive/45.md"}'),D={name:"drive/45.md"},U=Object.assign(D,{setup(r){return(e,l)=>(n(),i("div",null,[x(P)]))}});export{M as __pageData,U as default};
