import{_ as d,o as s,c as i,a as t,m,t as _,C as h,M as g,U as b,f as l,F as x,p as y,e as w,q as v}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function R(n,e,u,c,r,a){return s(),i("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(_(u.poem.solution),1)])])])}const j=d(q,[["render",R],["__scopeId","data-v-47ee83e0"]]),S=JSON.parse(`[{"question":"def count_students_receiving_prize(n: int, k: int) -> int: Returns the number of students who will receive the prize. :param n: Total number of students :param k: Divisor to determine prize eligibility :return: Number of students receiving the prize >>> count_students_receiving_prize(10, 3) 3 >>> count_students_receiving_prize(1, 1) 1","solution":"def count_students_receiving_prize(n, k): Returns the number of students who will receive the prize. :param n: Total number of students :param k: Divisor to determine prize eligibility :return: Number of students receiving the prize return n // k"},{"question":"def max_profit(f, m, prices): Calculate the maximum profit that can be achieved by selling each fruit in the market that offers the highest price. Parameters: f (int): Number of fruits m (int): Number of markets prices (list of list of int): Price list with f lists of m integers Returns: int: Maximum profit Example: >>> max_profit(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 18 pass from solution import max_profit def test_example(): prices = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_profit(3, 3, prices) == 18 def test_single_fruit_single_market(): prices = [ [5] ] assert max_profit(1, 1, prices) == 5 def test_multiple_fruits_single_market(): prices = [ [15], [10], [20] ] assert max_profit(3, 1, prices) == 45 def test_single_fruit_multiple_markets(): prices = [ [1, 2, 3, 4, 5] ] assert max_profit(1, 5, prices) == 5 def test_random_prices(): prices = [ [10, 20, 30], [5, 15, 25], [1, 11, 21] ] assert max_profit(3, 3, prices) == 76 def test_equal_prices(): prices = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert max_profit(3, 3, prices) == 6 def test_large_input(): prices = [[i + j for j in range(1000)] for i in range(1000)] assert max_profit(1000, 1000, prices) == sum(999 + i for i in range(1000))","solution":"def max_profit(f, m, prices): Calculate the maximum profit that can be achieved by selling each fruit in the market that offers the highest price. Parameters: f (int): Number of fruits m (int): Number of markets prices (list of list of int): Price list with f lists of m integers Returns: int: Maximum profit max_profit = 0 for fruit_prices in prices: max_profit += max(fruit_prices) return max_profit"},{"question":"from typing import List, Tuple def count_main_routes(N: int, M: int, T: int, portals: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Given the list of one-way portals connecting pairs of planets, determine the number of different main routes from planet S to planet D. If there is no route from S to D, the number of different main routes should be zero. Args: N (int): Number of planets. M (int): Number of one-way portals. T (int): Number of test cases. portals (List[Tuple[int, int]]): List of one-way portals where each portal connects a pair of planets (u, v). queries (List[Tuple[int, int]]): List of queries where each query consists of two integers S and D. Returns: List[int]: List of integers representing the number of different main routes for each query. >>> count_main_routes(6, 7, 2, [(1, 2), (2, 3), (1, 3), (3, 4), (4, 5), (5, 6), (3, 6)], [(1, 5), (1, 6)]) [1, 1] >>> count_main_routes(5, 4, 3, [(1, 2), (1, 3), (3, 4), (4, 5)], [(1, 4), (1, 5), (2, 5)]) [1, 1, 0]","solution":"from collections import defaultdict, deque def count_main_routes(N, M, T, portals, queries): def bfs_distance_and_count(S): # BFS to find shortest paths and path count distances = [-1] * (N + 1) path_counts = [0] * (N + 1) queue = deque([S]) distances[S] = 0 path_counts[S] = 1 while queue: planet = queue.popleft() for neighbor in graph[planet]: if distances[neighbor] == -1: # unvisited planet distances[neighbor] = distances[planet] + 1 path_counts[neighbor] = path_counts[planet] queue.append(neighbor) elif distances[neighbor] == distances[planet] + 1: # another shortest path found path_counts[neighbor] += path_counts[planet] return distances, path_counts # Create the graph graph = defaultdict(list) for u, v in portals: graph[u].append(v) results = [] for S, D in queries: distances, path_counts = bfs_distance_and_count(S) # If D is unreachable, path_counts[D] will be 0 results.append(path_counts[D] if distances[D] != -1 else 0) return results # Main logic to read input and produce output (For interactive use, commented out for unit tests) # if __name__ == \\"__main__\\": # N, M, T = map(int, input().split()) # portals = [tuple(map(int, input().split())) for _ in range(M)] # queries = [tuple(map(int, input().split())) for _ in range(T)] # results = count_main_routes(N, M, T, portals, queries) # for result in results: # print(result)"},{"question":"def can_complete_mission(P: int, n: int, terrains: List[int]) -> str: Determines if the robot can complete its mission without running out of power at any point. Parameters: P (int): Initial power level of the robot. n (int): Number of terrains to traverse. terrains (list of int): List indicating the effect of each terrain on the robot's power level. Returns: str: \\"Yes\\" if the robot can complete its mission without the power level dropping to zero or below at any point, otherwise \\"No\\". >>> can_complete_mission(10, 5, [-2, 3, -5, 1, -3]) 'Yes' >>> can_complete_mission(10, 5, [-2, 3, -10, 1, -3]) 'No'","solution":"def can_complete_mission(P, n, terrains): Determines if the robot can complete its mission without running out of power at any point. Parameters: P (int): Initial power level of the robot. n (int): Number of terrains to traverse. terrains (list of int): List indicating the effect of each terrain on the robot's power level. Returns: str: \\"Yes\\" if the robot can complete its mission without the power level dropping to zero or below at any point, otherwise \\"No\\". current_power = P for effect in terrains: current_power += effect if current_power <= 0: return \\"No\\" return \\"Yes\\""},{"question":"def count_ways(N: int, K: int) -> int: Return the number of ways Alice can buy consecutive books such that the length of the consecutive sequence is less than or equal to K. Examples: >>> count_ways(5, 3) 12 >>> count_ways(4, 2) 7 >>> count_ways(1, 1) 1 >>> count_ways(10, 10) 55 >>> count_ways(6, 2) 11 >>> count_ways(8, 4) 26","solution":"def count_ways(N, K): Return the number of ways Alice can buy consecutive books such that the length of the consecutive sequence is less than or equal to K. total_ways = 0 for x in range(1, K + 1): total_ways += N - x + 1 return total_ways"},{"question":"def min_edges_to_eulerian(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Determine the minimum number of edges that need to be added to make the graph Eulerian. Each test case contains N (number of nodes), M (number of edges), and a list of M edges. The function returns a list of integers, where each integer represents the minimum number of edges to be added for each test case. >>> min_edges_to_eulerian(2, [((3, 2), [(1, 2), (2, 3)]), ((4, 3), [(1, 2), (2, 3), (3, 4)])]) [1, 1] >>> min_edges_to_eulerian(1, [((4, 4), [(1, 2), (2, 3), (3, 4), (4, 1)])]) [0] >>> min_edges_to_eulerian(1, [((3, 3), [(1, 2), (2, 3), (3, 1)])]) [0] >>> min_edges_to_eulerian(1, [((4, 2), [(1, 2), (3, 4)])]) [2] >>> min_edges_to_eulerian(1, [((1, 0), [])]) [0]","solution":"def min_edges_to_eulerian(T, test_cases): def eulerian_edges_needed(N, edges): # Degree of each node degree = [0] * (N + 1) for u, v in edges: degree[u] += 1 degree[v] += 1 # Count nodes with odd degree odd_degree_count = sum(1 for d in degree if d % 2 == 1) # The number of edges added should make all degrees even # If odd_degree_count is even, we need to add odd_degree_count/2 edges if odd_degree_count % 2 == 0: return odd_degree_count // 2 else: # This is never executed with problem constraints (even number of odd vertices needed) return -1 results = [] for i in range(T): N, M = test_cases[i][0] edges = test_cases[i][1] results.append(eulerian_edges_needed(N, edges)) return results"},{"question":"from typing import List, Tuple def shortest_path(n: int, m: int, grid: List[str], queries: List[Tuple[Tuple[int, int], Tuple[int, int]]]) -> List[int]: Computes the shortest path between pairs of coordinates in a grid. >>> shortest_path( ... 6, 7, ... [ ... \\".#.\\", ... \\".#....#\\", ... \\".#.#..#\\", ... \\".#...\\", ... \\".\\", ... \\".m..t..\\" ... ], ... [ ... ((1, 1), (1, 4)), ... ((4, 1), (4, 4)) ... ]) == [3, -1] pass def test_shortest_path(): n = 6 m = 7 grid = [ \\".#.\\", \\".#....#\\", \\".#.#..#\\", \\".#...\\", \\".\\", \\".m..t..\\" ] queries = [ ((1, 1), (1, 4)), ((4, 1), (4, 4)) ] expected_results = [3, -1] # hypothetic expected results based on example results = shortest_path(n, m, grid, queries) assert results == expected_results, f\\"Expected {expected_results}, got {results}\\" # Further tests def test_no_path(): n = 5 m = 5 grid = [ \\"#\\", \\"#\\", \\"#\\", \\"#\\", \\"#\\" ] queries = [((2, 2), (3, 3))] results = shortest_path(n, m, grid, queries) assert results == [-1], f\\"Expected [-1], got {results}\\" def test_single_cell_paths(): n = 3 m = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] queries = [((0, 0), (0, 0)), ((1, 1), (1, 1)), ((2, 2), (2, 2))] results = shortest_path(n, m, grid, queries) assert results == [0, 0, 0], f\\"Expected [0, 0, 0], got {results}\\" def test_direct_paths(): n = 3 m = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] queries = [((0, 0), (0, 1)), ((1, 1), (1, 2)), ((2, 0), (2, 1))] results = shortest_path(n, m, grid, queries) assert results == [1, 1, 1], f\\"Expected [1, 1, 1], got {results}\\"","solution":"from collections import deque def shortest_path(n, m, grid, queries): Computes the shortest path between pairs of coordinates in a grid. def bfs(start, end): # BFS initialization queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == end: return dist for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 results = [] for start, end in queries: result = bfs(start, end) results.append(result) return results"},{"question":"def unique_permutations(S: str) -> int: Returns the number of unique permutations of the characters in the string S. >>> unique_permutations(\\"abc\\") 6 >>> unique_permutations(\\"aabb\\") 6 >>> unique_permutations(\\"a\\") 1 >>> unique_permutations(\\"aa\\") 1 >>> unique_permutations(\\"aaa\\") 1 >>> unique_permutations(\\"abcde\\") 120 >>> unique_permutations(\\"abbccc\\") 60","solution":"from itertools import permutations def unique_permutations(S): Returns the number of unique permutations of the characters in the string S. # Generate all unique permutations using a set to avoid duplicates unique_perms = set(permutations(S)) # Return the number of unique permutations return len(unique_perms)"},{"question":"def minimum_groups(S: str) -> int: Determine the minimum number of groups with even members and all members have unique names. Parameters: S (str): A string containing names separated by commas. Returns: int: Minimum number of groups, or \\"Impossible\\" if not possible. >>> minimum_groups(\\"Alice,Bob,Charlie,David,Eve,Frank,Grace,Hank\\") 4 >>> minimum_groups(\\"John,Paul,George,Ringo,Jim,Mick,Keith\\") \\"Impossible\\" >>> minimum_groups(\\"Charlotte,Anne,Emily,Jane,Alice,Beatrice,Clara,Diana,Eve,Flora\\") 5 >>> minimum_groups(\\"Alice,Bob,Alice\\") \\"Impossible\\" >>> minimum_groups(\\"Tom,Tim,Tom\\") \\"Impossible\\" >>> minimum_groups(\\"Alice,Bob,Charlie\\") \\"Impossible\\" >>> minimum_groups(\\"David,Eve,Frank,Grace,Hank\\") \\"Impossible\\" >>> minimum_groups(\\"Anna,Anna\\") \\"Impossible\\" >>> minimum_groups(\\"Janet,John\\") 1 >>> minimum_groups(\\"Mary,Bob\\") 1","solution":"def minimum_groups(S): Determine the minimum number of groups with even members and all members have unique names. Parameters: S (str): A string containing names separated by commas. Returns: int: Minimum number of groups, or \\"Impossible\\" if not possible. names = S.split(\\",\\") unique_names = set(names) # If there are duplicates in names, it's impossible to form the groups if len(names) != len(unique_names): return \\"Impossible\\" # Number of unique names n = len(unique_names) # If the count of unique names is odd, it's impossible to form groups with even members. if n % 2 != 0: return \\"Impossible\\" # The minimum number of groups with even members return n // 2"},{"question":"def number_of_paths(n: int, m: int, barriers: List[Tuple[int, int]]) -> int: Computes the number of distinct paths from the top-left to the bottom-right corner of a grid, without crossing any barriers, modulo 1,000,000,007 >>> number_of_paths(3, 3, [(2, 2), (3, 2)]) == 1 >>> number_of_paths(3, 3, []) == 6 >>> number_of_paths(2, 2, []) == 2 >>> number_of_paths(3, 3, [(1, 2), (2, 1)]) == 0 >>> number_of_paths(1, 5, [(1, 3)]) == 0 >>> number_of_paths(1, 5, []) == 1 >>> number_of_paths(5, 1, [(3, 1)]) == 0 >>> number_of_paths(5, 1, []) == 1","solution":"def number_of_paths(n, m, barriers): MOD = 1_000_000_007 # create a grid to mark barriers grid = [[0] * m for _ in range(n)] for barrier in barriers: x, y = barrier[0] - 1, barrier[1] - 1 grid[x][y] = 1 # create dp table dp = [[0] * m for _ in range(n)] # Initialize dp table dp[0][0] = 1 if grid[0][0] == 0 else 0 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] dp[i][j] %= MOD return dp[n-1][m-1] # Example usage: n, m, b = 3, 3, 2 barriers = [(2, 2), (3, 2)] print(number_of_paths(n, m, barriers)) # Output: 1"},{"question":"def minimum_cost(prices: List[int], k: int) -> int: Returns the minimum amount of money required to buy exactly \`k\` items considering the bulk discount. >>> minimum_cost([4, 3, 2, 7, 8], 3) == 9 >>> minimum_cost([5, 1, 2, 6, 4], 2) == 3 >>> minimum_cost([7, 7, 7, 7], 2) == 14 >>> minimum_cost([10, 20, 30, 40, 50, 60, 70, 80, 90], 5) == 150 >>> minimum_cost([8, 6, 4, 2], 1) == 2 >>> minimum_cost([5, 3, 4, 10, 8, 6, 2], 3) == 9 >>> minimum_cost([9, 7, 5, 3, 1], 4) == 16 >>> minimum_cost([1], 1) == 1 >>> minimum_cost([1000000], 1) == 1000000 # [Your code here]","solution":"def minimum_cost(prices, k): Returns the minimum amount of money required to buy exactly \`k\` items considering the bulk discount. # Sort prices in ascending order prices.sort() # We need to pay for the first \`k\` items in the sorted list all of which have the lowest prices total_cost = sum(prices[:k]) return total_cost"},{"question":"def min_subarray_length(n, s, arr): Returns the length of the smallest subarray with sum greater than or equal to s. If no such subarray exists, returns 0. >>> min_subarray_length(5, 12, [1, 2, 3, 4, 5]) == 3 >>> min_subarray_length(6, 9, [2, 1, 5, 2, 8, 1]) == 2 >>> min_subarray_length(4, 15, [1, 2, 3, 4]) == 0 def main(input_data): Returns the results for each test case based on the provided input data. >>> input_data = \\"3n5 12n1 2 3 4 5n6 9n2 1 5 2 8 1n4 15n1 2 3 4\\" >>> main(input_data) == [3, 2, 0]","solution":"def min_subarray_length(n, s, arr): Returns the length of the smallest subarray with sum greater than or equal to s. If no such subarray exists, returns 0. min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else 0 def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [] idx = 1 for _ in range(T): n, s = map(int, lines[idx].split()) arr = list(map(int, lines[idx + 1].split())) result = min_subarray_length(n, s, arr) results.append(result) idx += 2 return results"},{"question":"import math from typing import List def calculate_gcd_for_subarray(arr: List[int]) -> List[int]: Calculate the GCD for each subarray ending at each index. >>> calculate_gcd_for_subarray([10, 5, 7, 12, 10]) [10, 5, 1, 1, 1] >>> calculate_gcd_for_subarray([4, 8, 16, 32]) [4, 4, 4, 4] >>> calculate_gcd_for_subarray([2, 3, 4, 5, 6]) [2, 1, 1, 1, 1] >>> calculate_gcd_for_subarray([10]) [10] >>> calculate_gcd_for_subarray([15, 25, 35, 45]) [15, 5, 5, 5] >>> calculate_gcd_for_subarray([14, 28, 56, 112]) [14, 14, 14, 14]","solution":"import math from typing import List def calculate_gcd_for_subarray(arr: List[int]) -> List[int]: n = len(arr) result = [0] * n result[0] = arr[0] for i in range(1, n): result[i] = math.gcd(result[i-1], arr[i]) return result"},{"question":"def max_rotation_number(T: int, mechanisms: List[int]) -> List[int]: Given the number of treasure chests T and a list indicating the number of rotation mechanisms for each chest, return a list of maximum rotation numbers for each chest. >>> max_rotation_number(3, [2, 3, 4]) [99, 999, 9999] >>> max_rotation_number(2, [6, 7]) [999999, 9999999]","solution":"def max_rotation_number(T, mechanisms): Given the number of treasure chests T and a list indicating the number of rotation mechanisms for each chest, return a list of maximum rotation numbers for each chest. max_numbers = [] for N in mechanisms: max_numbers.append(int('9' * N)) # Create a string with N '9's and convert to integer return max_numbers"},{"question":"def condense_spaces(s: str) -> str: Removes leading, trailing, and multiple consecutive spaces from the input string. >>> condense_spaces(\\"Hello world!\\") \\"Hello world!\\" >>> condense_spaces(\\" This is a test. \\") \\"This is a test.\\" >>> condense_spaces(\\"No extra spaces here.\\") \\"No extra spaces here.\\" >>> condense_spaces(\\" \\") \\"\\" >>> condense_spaces(\\" x \\") \\"x\\" >>> condense_spaces(\\"\\") \\"\\" >>> condense_spaces(\\"Already perfect\\") \\"Already perfect\\"","solution":"def condense_spaces(s): Removes leading, trailing and multiple consecutive spaces from the input string. result = [] in_space = False for char in s: if char == ' ': if not in_space: in_space = True result.append(char) else: in_space = False result.append(char) return ''.join(result).strip()"},{"question":"def shortest_subarray_length(n: int, x: int, arr: List[int]) -> int: Finds the length of the shortest subarray with a sum greater than or equal to the target sum x. If no such subarray exists, returns -1. Parameters: n (int): The length of the array x (int): The target sum arr (list of int): The array of integers Returns: int: The length of the shortest subarray or -1 if no such subarray exists Examples: >>> shortest_subarray_length(5, 11, [1, 2, 3, 4, 5]) 3 >>> shortest_subarray_length(4, 15, [1, 2, 3, 4]) -1","solution":"def shortest_subarray_length(n, x, arr): Finds the length of the shortest subarray with a sum greater than or equal to the target sum x. If no such subarray exists, returns -1. Parameters: n (int): The length of the array x (int): The target sum arr (list of int): The array of integers Returns: int: The length of the shortest subarray or -1 if no such subarray exists # Initialize variables left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += arr[right] while current_sum >= x: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def register_user(usernames: List[str], new_user: str) -> str: Returns a unique username by appending the smallest integer that makes the username unique if needed. >>> register_user([\\"user1\\", \\"user2\\", \\"user3\\"], \\"user1\\") 'user11' >>> register_user([\\"user\\"], \\"user\\") 'user1'","solution":"def register_user(usernames, new_user): Returns a unique username by appending the smallest integer that makes the username unique if needed. if new_user not in usernames: return new_user i = 1 while f\\"{new_user}{i}\\" in usernames: i += 1 return f\\"{new_user}{i}\\""},{"question":"def max_score(arr, k): Calculate the maximum possible score that can be achieved after exactly k moves by adding the smallest integers from k contiguous sub-arrays. >>> max_score([1, -2, 3, -4, 5], 2) 8 >>> max_score([-1, 3, -2, 5, -4, 6], 3) 14 >>> max_score([10], 1) 10 >>> max_score([-10, -20, -30], 2) -30 >>> max_score([-5, 0, 5, 10], 2) 15 >>> max_score([-5, 0, 5, 10], 1) 10 >>> max_score([1, 2, 3], 3) 6 >>> max_score([1, 2, 3], 2) 5 pass","solution":"def max_score(arr, k): Calculate the maximum possible score that can be achieved after exactly k moves by adding the smallest integers from k contiguous sub-arrays. arr.sort(reverse=True) return sum(arr[:k])"},{"question":"def perform_queries(S: str, queries: List[str]) -> List[str]: Processes the queries on the string S and returns the results of palindrome checks. >>> perform_queries(\\"abacaba\\", [\\"2 1 7\\", \\"2 2 6\\", \\"1 3 d\\", \\"2 1 7\\", \\"2 2 6\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> perform_queries(\\"\\", []) [] >>> perform_queries(\\"a\\", [\\"2 1 1\\", \\"1 1 b\\", \\"2 1 1\\"]) [\\"YES\\", \\"YES\\"] >>> perform_queries(\\"abcde\\", [\\"2 1 5\\", \\"2 2 4\\"]) [\\"NO\\", \\"NO\\"] >>> perform_queries(\\"aabaa\\", [\\"2 1 5\\", \\"2 2 4\\", \\"2 3 3\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def perform_queries(S, queries): Processes the queries on the string S and returns the results of palindrome checks. results = [] S = list(S) # Convert string to list for mutability for query in queries: parts = query.split() if parts[0] == \\"1\\": # Replace character at 1-based index x with c x = int(parts[1]) c = parts[2] S[x - 1] = c elif parts[0] == \\"2\\": # Check if substring from l to r is palindrome l = int(parts[1]) r = int(parts[2]) substring = S[l - 1:r] if substring == substring[::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def minCoins(n, amount, coins): Determine the minimum number of coins required to make up a given amount. If it is not possible to make up that amount, return -1. Parameters: n (int): Number of different coin denominations amount (int): The total amount of money coins (List[int]): The value of the coin denominations Returns: int: Minimum number of coins needed to make up the given amount or -1 if not possible Examples: >>> minCoins(3, 11, [1, 2, 5]) 3 >>> minCoins(2, 3, [2, 6]) -1","solution":"def minCoins(n, amount, coins): # Initialize the dp array with amount+1, which represents infinite in this case dp = [amount + 1] * (amount + 1) dp[0] = 0 # Process each amount from 1 to 'amount' for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) # If dp[amount] is still the initialized value, it means it's not possible to form the amount return dp[amount] if dp[amount] != amount + 1 else -1"},{"question":"def max_zones(n: int, z: int, edges: List[Tuple[int, int]]) -> int: Determine the maximum number of zones that can be formed in a tree with n vertices, such that each zone contains exactly z vertices. If exact partition is not possible, the zones should have nearly equal sizes with a difference of no more than one vertex. >>> max_zones(10, 3, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (5, 9), (6, 10)]) 3 >>> max_zones(7, 2, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 3","solution":"def max_zones(n, z, edges): def dfs(node, parent): subtree_size = 1 for neighbor in adj[node]: if neighbor != parent: subtree_size += dfs(neighbor, node) zone_count[0] += subtree_size // z return subtree_size % z if z > n: return 0 adj = [[] for _ in range(n + 1)] for u, v in edges: adj[u].append(v) adj[v].append(u) zone_count = [0] dfs(1, -1) return zone_count[0]"},{"question":"def house_side_and_position(n: int) -> str: Given a house number n, return the side of the street and the position of the house on that side. >>> house_side_and_position(1) == \\"left 1\\" >>> house_side_and_position(5) == \\"left 3\\" >>> house_side_and_position(11) == \\"left 6\\" >>> house_side_and_position(2) == \\"right 1\\" >>> house_side_and_position(8) == \\"right 4\\" >>> house_side_and_position(20) == \\"right 10\\" >>> house_side_and_position(1000000001) == \\"left 500000001\\" >>> house_side_and_position(1000000000) == \\"right 500000000\\"","solution":"def house_side_and_position(n): Given a house number n, return the side of the street and the position of the house on that side. if n % 2 == 0: side = \\"right\\" position = n // 2 else: side = \\"left\\" position = (n // 2) + 1 return f\\"{side} {position}\\""},{"question":"def is_island_word(R: int, C: int, grid: List[str], word: str) -> str: Determine if a given word can be formed as an island word in the grid. >>> is_island_word(3, 4, [\\"abcd\\", \\"efgh\\", \\"ijkl\\"], \\"test\\") NO >>> is_island_word(2, 2, [\\"aa\\", \\"bb\\"], \\"abb\\") YES def test_is_island_word_with_no(): R, C = 3, 4 grid = [ \\"abcd\\", \\"efgh\\", \\"ijkl\\" ] word = \\"test\\" assert is_island_word(R, C, grid, word) == \\"NO\\" def test_is_island_word_with_yes(): R, C = 2, 2 grid = [ \\"aa\\", \\"bb\\" ] word = \\"abb\\" assert is_island_word(R, C, grid, word) == \\"YES\\" def test_is_island_word_edge_case(): R, C = 1, 1 grid = [ \\"a\\" ] word = \\"a\\" assert is_island_word(R, C, grid, word) == \\"YES\\" def test_is_island_word_single_row(): R, C = 1, 5 grid = [ \\"apple\\" ] word = \\"ple\\" assert is_island_word(R, C, grid, word) == \\"YES\\" def test_is_island_word_single_column(): R, C = 5, 1 grid = [ \\"a\\", \\"p\\", \\"p\\", \\"l\\", \\"e\\" ] word = \\"ple\\" assert is_island_word(R, C, grid, word) == \\"YES\\"","solution":"def is_island_word(R, C, grid, word): def dfs(x, y, idx): if idx == len(word): return True if x < 0 or x >= R or y < 0 or y >= C or grid[x][y] != word[idx] or (x, y, idx) in visited: return False visited.add((x, y, idx)) found = (dfs(x+1, y, idx+1) or dfs(x-1, y, idx+1) or dfs(x, y+1, idx+1) or dfs(x, y-1, idx+1)) visited.remove((x, y, idx)) return found visited = set() for i in range(R): for j in range(C): if grid[i][j] == word[0] and dfs(i, j, 0): return \\"YES\\" return \\"NO\\" def solve_island_words(T, test_cases): results = [] for case in test_cases: R, C, grid, word = case results.append(is_island_word(R, C, grid, word)) return results if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split(\\"n\\") T = int(data[0]) index = 1 test_cases = [] for _ in range(T): R, C = map(int, data[index].split()) grid = data[index+1:index+1+R] word = data[index+1+R] test_cases.append((R, C, grid, word)) index += 2+R results = solve_island_words(T, test_cases) for result in results: print(result)"},{"question":"def can_form_sequence(a: int, b: int, c: int) -> str: Returns \\"YES\\" if the three trees can be part of the same sequence with a single integer step, otherwise \\"NO\\". >>> can_form_sequence(2, 4, 6) 'YES' >>> can_form_sequence(1, 5, 3) 'YES' >>> can_form_sequence(1, 5, 4) 'NO'","solution":"def can_form_sequence(a, b, c): Returns \\"YES\\" if the three trees can be part of the same sequence with a single integer step, otherwise \\"NO\\". positions = [a, b, c] positions.sort() if positions[1] - positions[0] == positions[2] - positions[1]: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List, Tuple def longest_subarray_with_two_distinct_integers(arr: List[int]) -> int: Returns the length of the longest subarray with at most two distinct integers. >>> longest_subarray_with_two_distinct_integers([1, 2, 1, 2, 3, 3]) == 4 >>> longest_subarray_with_two_distinct_integers([1, 2, 3, 4]) == 2 def solve(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the results for all test cases. >>> solve(2, [(6, [1, 2, 1, 2, 3, 3]), (4, [1, 2, 3, 4])]) == [4, 2]","solution":"def longest_subarray_with_two_distinct_integers(arr): Returns the length of the longest subarray with at most two distinct integers. n = len(arr) if n == 0: return 0 left = 0 right = 0 max_len = 0 freq = {} while right < n: if arr[right] in freq: freq[arr[right]] += 1 else: freq[arr[right]] = 1 while len(freq) > 2: freq[arr[left]] -= 1 if freq[arr[left]] == 0: del freq[arr[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len def solve(T, cases): results = [] for i in range(T): N, arr = cases[i] results.append(longest_subarray_with_two_distinct_integers(arr)) return results"},{"question":"def find_pairs_with_sum(n: int, integers: List[int], target: int) -> Union[List[Tuple[int, int]], str]: Finds and prints pairs of integers from the list that sum up to the target value. Each pair should be in the format (a, b) where a < b. :param n: Number of integers in the list :param integers: List of integers :param target: Target sum value :return: List of tuples representing pairs that sum up to the target value or \\"No pairs found\\". Examples: >>> find_pairs_with_sum(5, [1, 2, 3, 4, 5], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum(4, [1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs_with_sum(3, [1, 2, 4], 8) \\"No pairs found\\" def format_pairs(pairs: Union[List[Tuple[int, int]], str]) -> str: Formats the output pairs or \\"No pairs found\\" for printing. Each pair is on a new line. :param pairs: Either a list of tuples or the string \\"No pairs found\\" :return: Formatted string Examples: >>> format_pairs([(1, 4), (2, 3)]) \\"(1, 4)n(2, 3)\\" >>> format_pairs([(1, 1)]) \\"(1, 1)\\" >>> format_pairs(\\"No pairs found\\") \\"No pairs found\\"","solution":"def find_pairs_with_sum(n, integers, target): Finds and returns pairs of integers from the list that sum up to the target value. Each pair should be in the format (a, b) where a < b. :param n: Number of integers in the list :param integers: List of integers :param target: Target sum value :return: List of tuples representing pairs that sum up to the target value. if n < 1 or n > 100: raise ValueError(\\"n should be between 1 and 100\\") integers.sort() pairs = [] seen = set() for num in integers: complement = target - num if complement in seen: if complement != num: pairs.append((min(num, complement), max(num, complement))) elif integers.count(num) > 1: # This handles the case where we need pairs like (1, 1) pairs.append((num, complement)) seen.add(num) pairs = list(set(pairs)) pairs.sort() if not pairs: return \\"No pairs found\\" return pairs def format_pairs(pairs): Formats the output pairs or \\"No pairs found\\" for printing. Each pair is on a new line. :param pairs: Either a list of tuples or the string \\"No pairs found\\" :return: Formatted string if pairs == \\"No pairs found\\": return pairs return \\"n\\".join(f\\"({a}, {b})\\" for a, b in pairs)"},{"question":"def min_radius_of_influence(n: int, k: int, stations: List[int]) -> float: Calculate the minimum radius of influence required so that every segment of the track has access to at least one water station. Parameters: n (int): Number of segments on the track. k (int): Number of water stations. stations (List[int]): The segment indices where the water stations are placed. Returns: float: The minimum radius of influence required. Examples: >>> min_radius_of_influence(8, 3, [1, 4, 7]) 1.5000000000 >>> min_radius_of_influence(12, 3, [0, 4, 8]) 2.0000000000 Unit Tests from solution import min_radius_of_influence def test_example_1(): n = 8 k = 3 stations = [1, 4, 7] assert abs(min_radius_of_influence(n, k, stations) - 1.5000000000) < 1e-9 def test_example_2(): n = 12 k = 3 stations = [0, 4, 8] assert abs(min_radius_of_influence(n, k, stations) - 2.0000000000) < 1e-9 def test_single_station(): n = 5 k = 1 stations = [2] assert abs(min_radius_of_influence(n, k, stations) - 2.5000000000) < 1e-9 def test_all_stations(): n = 4 k = 4 stations = [0, 1, 2, 3] assert abs(min_radius_of_influence(n, k, stations) - 0.5000000000) < 1e-9 def test_large_circle(): n = 1000 k = 2 stations = [0, 500] assert abs(min_radius_of_influence(n, k, stations) - 250.0000000000) < 1e-9","solution":"def min_radius_of_influence(n, k, stations): stations.sort() max_gap = 0 for i in range(k-1): max_gap = max(max_gap, stations[i+1] - stations[i]) max_gap = max(max_gap, n - stations[-1] + stations[0]) return max_gap / 2.0 # Example usage n = 8 k = 3 stations = [1, 4, 7] print(f\\"{min_radius_of_influence(n, k, stations):.9f}\\") # Output: 1.5000000000 n = 12 k = 3 stations = [0, 4, 8] print(f\\"{min_radius_of_influence(n, k, stations):.9f}\\") # Output: 2.0000000000"},{"question":"def find_smallest_missing_sum(n: int, sums: List[int]) -> int: Given the number of rows and their respective sums, returns the smallest positive integer that is not already the sum of any existing row. >>> find_smallest_missing_sum(5, [1, 2, 3, 4, 5]) 6 >>> find_smallest_missing_sum(3, [7, 11, 14]) 1 >>> find_smallest_missing_sum(0, []) 1 >>> find_smallest_missing_sum(6, [10, 20, 30, 40, 50, 60]) 1 >>> find_smallest_missing_sum(3, [10000, 9999, 9998]) 1 >>> find_smallest_missing_sum(1, [1]) 2 >>> find_smallest_missing_sum(5, [2, 3, 4, 5, 6]) 1 >>> find_smallest_missing_sum(4, [1, 10, 20, 30]) 2 >>> find_smallest_missing_sum(5, [1, 2, 3, 4, 6]) 5","solution":"def find_smallest_missing_sum(n, sums): Given the number of rows and their respective sums, returns the smallest positive integer that is not already the sum of any existing row. sums_set = set(sums) smallest_missing_sum = 1 while smallest_missing_sum in sums_set: smallest_missing_sum += 1 return smallest_missing_sum"},{"question":"from typing import List def can_transform_to_palindrome(s: str) -> str: Determines if the string \`s\` can be transformed into a palindrome by either: 1. Deleting a single character. 2. Appending exactly one character ('a', 'b', or 'c') to the end. def process_cases(T: int, cases: List[str]) -> List[str]: Processes multiple test cases. def main(input_data: str) -> str: Main entry point for processing input data. # Test Cases def test_palindrome_no_change_required(): assert can_transform_to_palindrome(\\"abcba\\") == \\"YES\\" def test_single_deletion_palindrome(): assert can_transform_to_palindrome(\\"abdcba\\") == \\"YES\\" assert can_transform_to_palindrome(\\"racecarx\\") == \\"YES\\" def test_single_append_palindrome(): assert can_transform_to_palindrome(\\"abcdc\\") == \\"NO\\" assert can_transform_to_palindrome(\\"abccba\\") == \\"YES\\" def test_no_possible_palindrome(): assert can_transform_to_palindrome(\\"abcdef\\") == \\"NO\\" def test_edge_cases(): assert can_transform_to_palindrome(\\"a\\") == \\"YES\\" # Single character is always a palindrome assert can_transform_to_palindrome(\\"ab\\") == \\"YES\\" # Can append one character to make it a palindrome def test_long_string(): s = \\"a\\" * 100000 assert can_transform_to_palindrome(s) == \\"YES\\"","solution":"def can_transform_to_palindrome(s): Determines if the string \`s\` can be transformed into a palindrome by either: 1. Deleting a single character. 2. Appending exactly one character ('a', 'b', or 'c') to the end. def is_palindrome(s): return s == s[::-1] if is_palindrome(s): return \\"YES\\" # Check by deleting one character for i in range(len(s)): if is_palindrome(s[:i] + s[i+1:]): return \\"YES\\" # Check by appending one character for c in 'abc': if is_palindrome(s + c): return \\"YES\\" return \\"NO\\" def process_cases(T, cases): results = [] for case in cases: results.append(can_transform_to_palindrome(case)) return results def main(input_data): lines = input_data.split('n') T = int(lines[0]) cases = lines[1:T+1] return \\"n\\".join(process_cases(T, cases))"},{"question":"def find_most_influential_user(n, m, connections): Finds the user with the highest influence (number of direct connections). If multiple users have the same number of connections, returns the smallest user ID. Parameters: n (int): Number of users m (int): Number of connections connections (list of tuples): Each tuple contains two integers representing a connection between users. Returns: int: The user ID of the most influential user. from solution import find_most_influential_user def test_no_connections(): assert find_most_influential_user(4, 0, []) == 1 def test_single_most_influential_user(): assert find_most_influential_user(5, 4, [(1, 2), (1, 3), (2, 3), (4, 5)]) == 1 def test_multiple_influential_users(): assert find_most_influential_user(3, 2, [(1, 2), (2, 3)]) == 2 def test_all_users_same_influence(): # All users have 2 connections: (1-2, 1-3, 2-3) assert find_most_influential_user(3, 3, [(1, 2), (1, 3), (2, 3)]) == 1 def test_larger_network(): # Expected user with highest number of connections is user 3 assert find_most_influential_user(6, 6, [(1, 3), (2, 3), (3, 4), (3, 5), (3, 6), (4, 5)]) == 3 def test_single_user(): assert find_most_influential_user(1, 0, []) == 1","solution":"def find_most_influential_user(n, m, connections): Finds the user with the highest influence (number of direct connections). If multiple users have the same number of connections, returns the smallest user ID. Parameters: n (int): Number of users m (int): Number of connections connections (list of tuples): Each tuple contains two integers representing a connection between users. Returns: int: The user ID of the most influential user. if m == 0: # No connections, return the smallest user ID, which is 1 return 1 # Create a list to store the count of connections for each user connection_count = [0] * (n + 1) for u, v in connections: connection_count[u] += 1 connection_count[v] += 1 # Find the user with the highest number of connections max_connections = max(connection_count) for user_id in range(1, n + 1): if connection_count[user_id] == max_connections: return user_id"},{"question":"def longest_balanced_substring(s: str) -> int: Given a string \`s\` consisting of only the characters 'A' and 'B', determine the length of the longest substring that contains an equal number of 'A's and 'B's. Args: s (str): the input string consisting only of 'A' and 'B' Returns: int: the length of the longest balanced substring Examples: >>> longest_balanced_substring('AABBAB') 6 >>> longest_balanced_substring('AAABB') 4 >>> longest_balanced_substring('AAAA') 0","solution":"def longest_balanced_substring(s): Returns the length of the longest balanced substring containing an equal number of 'A's and 'B's. count_map = {0: -1} max_length = 0 count = 0 for i, char in enumerate(s): if char == 'A': count += 1 else: count -= 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def most_frequent_item(n: int, sequences: List[str]) -> Tuple[str, int]: Find the item with the highest frequency across N sequences. If multiple items have the same highest frequency, return the lexicographically smallest item. Parameters: n (int): The number of sequences sequences (List[str]): Each element is a string representing a sequence of items sold on a particular day Returns: Tuple[str, int]: The item with the highest frequency and the number of times it was sold. Examples: >>> most_frequent_item(3, [\\"3 apple banana apple\\", \\"2 banana apple\\", \\"4 orange banana apple orange\\"]) (\\"apple\\", 4) >>> most_frequent_item(2, [\\"3 milk milk milk\\", \\"3 bread bread bread\\"]) (\\"bread\\", 3)","solution":"def most_frequent_item(n, sequences): from collections import defaultdict item_freq = defaultdict(int) for sequence in sequences: items = sequence.split()[1:] for item in items: item_freq[item] += 1 max_freq = -1 result_item = \\"\\" for item, freq in item_freq.items(): if freq > max_freq or (freq == max_freq and item < result_item): max_freq = freq result_item = item return result_item, max_freq"},{"question":"from datetime import datetime from typing import List def find_patients_with_gaps(visits: List[str]) -> List[str]: Identify patients with gaps longer than 30 days between visits. Args: visits (List[str]): A list of visit records where each record contains patient_id, date (YYYY-MM-DD), and doctor_id. Returns: List[str]: A sorted list of patient IDs with gaps longer than 30 days between visits. >>> find_patients_with_gaps([ ... \\"abc123 2023-01-01 doc789\\", ... \\"abc123 2023-01-15 doc456\\", ... \\"xyz987 2023-01-05 doc123\\", ... \\"xyz987 2023-02-10 doc123\\", ... \\"xyz987 2023-03-11 doc456\\", ... \\"abc123 2023-02-20 doc789\\", ... \\"abc123 2023-04-01 doc123\\" ... ]) [\\"abc123\\", \\"xyz987\\"] >>> find_patients_with_gaps([ ... \\"abc123 2023-01-01 doc789\\", ... \\"abc123 2023-01-15 doc456\\", ... \\"xyz987 2023-01-05 doc123\\", ... \\"xyz987 2023-01-10 doc123\\" ... ]) [] >>> find_patients_with_gaps([ ... \\"abc123 2023-01-01 doc789\\", ... \\"abc123 2023-01-15 doc456\\", ... \\"abc123 2023-03-20 doc123\\" ... ]) [\\"abc123\\"] >>> find_patients_with_gaps([ ... \\"abc123 2020-01-01 doc789\\", ... \\"abc123 2021-01-15 doc456\\", ... \\"abc123 2022-03-20 doc123\\" ... ]) [\\"abc123\\"]","solution":"from datetime import datetime, timedelta def find_patients_with_gaps(visits): patients = {} for visit in visits: patient_id, date_str, doctor_id = visit date = datetime.strptime(date_str, '%Y-%m-%d') if patient_id not in patients: patients[patient_id] = [] patients[patient_id].append(date) result = [] for patient_id, dates in patients.items(): dates.sort() for i in range(1, len(dates)): if (dates[i] - dates[i-1]).days > 30: result.append(patient_id) break result.sort() return result def process_input(n, visit_records): visits = [tuple(line.split()) for line in visit_records] return find_patients_with_gaps(visits)"},{"question":"def min_subarray_length(n: int, S: int, nums: List[int]) -> int: Determines the minimum length of a contiguous subarray that has a sum greater than or equal to S. >>> min_subarray_length(8, 15, [5, 1, 3, 5, 10, 7, 4, 9]) 2 >>> min_subarray_length(5, 11, [1, 2, 3, 4, 5]) 3","solution":"def min_subarray_length(n, S, nums): Determines the minimum length of a contiguous subarray that has a sum greater than or equal to S. left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += nums[right] while current_sum >= S: min_length = min(min_length, right - left + 1) current_sum -= nums[left] left += 1 return min_length if min_length != float('inf') else 0"},{"question":"def cuboid_properties(l: int, w: int, h: int) -> (int, int): Calculate the volume and surface area of a cuboid given its dimensions. Parameters: l (int): The length of the cuboid (1 ≤ l ≤ 1000). w (int): The width of the cuboid (1 ≤ w ≤ 1000). h (int): The height of the cuboid (1 ≤ h ≤ 1000). Returns: (int, int): The volume and surface area of the cuboid. >>> cuboid_properties(3, 4, 5) (60, 94) >>> cuboid_properties(2, 2, 2) (8, 24) >>> cuboid_properties(1, 2, 3) (6, 22) >>> cuboid_properties(1, 1, 1) (1, 6) >>> cuboid_properties(1000, 1000, 1000) (1000000000, 6000000)","solution":"def cuboid_properties(l, w, h): Calculate the volume and surface area of a cuboid given its dimensions. Parameters: l (int): The length of the cuboid (1 ≤ l ≤ 1000). w (int): The width of the cuboid (1 ≤ w ≤ 1000). h (int): The height of the cuboid (1 ≤ h ≤ 1000). Returns: (int, int): The volume and surface area of the cuboid. volume = l * w * h surface_area = 2 * (l * w + w * h + h * l) return volume, surface_area"},{"question":"def min_max_height_difference(n: int, heights: List[int]) -> int: Returns the minimum possible maximum height difference within each group after dividing the students into two non-empty groups. Parameters: n (int): Number of students heights (list of int): List of heights of the students Returns: int: Minimum possible maximum height difference Examples: >>> min_max_height_difference(5, [10, 20, 30, 40, 50]) 10 >>> min_max_height_difference(4, [15, 30, 25, 10]) 5","solution":"def min_max_height_difference(n, heights): Returns the minimum possible maximum height difference within each group after dividing the students into two non-empty groups. Parameters: n (int): Number of students heights (list of int): List of heights of the students Returns: int: Minimum possible maximum height difference # Sort the list of heights heights.sort() # Initialize min_diff with a large value min_diff = float('inf') # Iterate through possible splitting points for i in range(1, n): min_diff = min(min_diff, heights[i] - heights[i - 1]) return min_diff"},{"question":"from typing import List def validParentheses(s: str) -> bool: Determines if the input string of parentheses is valid. :param s: string consisting of the characters '(', ')', '{', '}', '[' and ']' :return: True if the string is valid, otherwise False >>> validParentheses(\\"()\\") == True >>> validParentheses(\\"()[]{}\\") == True >>> validParentheses(\\"(]\\") == False >>> validParentheses(\\"({[]})\\") == True >>> validParentheses(\\"([)]\\") == False >>> validParentheses(\\"\\") == True >>> validParentheses(\\"(((((((())))))))\\") == True >>> validParentheses(\\"(((((((()))))))\\") == False >>> validParentheses(\\"{[()]}(){}\\") == True >>> validParentheses(\\"{[(])}\\") == False >>> validParentheses(\\"([])\\" * 250) == True >>> validParentheses(\\"([])\\" * 250 + \\"(\\") == False","solution":"def validParentheses(s): Determines if the input string of parentheses is valid. :param s: string consisting of the characters '(', ')', '{', '}', '[' and ']' :return: True if the string is valid, otherwise False stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return False else: stack.append(char) return not stack"},{"question":"from typing import List def maximum_product(nums: List[int]) -> int: Find three numbers in the array such that the product is maximum and return the maximum product. >>> maximum_product([1, 2, 3, 4]) 24 >>> maximum_product([-1, -2, -3, -4]) -6 >>> maximum_product([1, -4, 3, -6, 7, 0]) 168","solution":"from typing import List def maximum_product(nums: List[int]) -> int: nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"from typing import List def generate_pattern(n: int) -> List[str]: Generates an NxN grid pattern with given rules: - '*' on the main diagonal - '.' everywhere else >>> generate_pattern(3) ['*..', '.*.', '..*'] >>> generate_pattern(5) ['*....', '.*...', '..*..', '...*.', '....*'] def iris_patterns(test_cases: List[int]) -> List[List[str]]: Generates the patterns for each test case and returns them. >>> iris_patterns([3, 5]) [['*..', '.*.', '..*'], ['*....', '.*...', '..*..', '...*.', '....*']] def format_patterns(results: List[List[str]]) -> List[str]: Formats the list of patterns into the specified output format. >>> format_patterns([['*..', '.*.', '..*'], ['*....', '.*...', '..*..', '...*.', '....*']]) ['*..', '.*.', '..*', '', '*....', '.*...', '..*..', '...*.', '....*', '']","solution":"def generate_pattern(n): Generates an NxN grid pattern with given rules: - '*' on the main diagonal - '.' everywhere else pattern = [] for i in range(n): row = ['.'] * n row[i] = '*' pattern.append(''.join(row)) return pattern def iris_patterns(test_cases): Generates the patterns for each test case and returns them. results = [] for n in test_cases: pattern = generate_pattern(n) results.append(pattern) return results def format_patterns(results): Formats the list of patterns into the specified output format. formatted_result = [] for result in results: formatted_result.extend(result) formatted_result.append(\\"\\") # Add a blank line after each pattern return formatted_result"},{"question":"def distinct_ways_to_reach_top(n: int, steps: List[int]) -> int: Determines the number of distinct ways to reach the top of a sequence of steps. Example: >>> distinct_ways_to_reach_top(3, [1, 2, 1]) 3 >>> distinct_ways_to_reach_top(2, [1, 2]) 2","solution":"def num_ways(n, steps): Returns the number of distinct ways to reach the top of n steps given the sequence of steps that can be climbed in one move (either 1 step or 2 steps). # Handling edge cases where n is 0 if n == 0: return 1 # Initialize dp array where dp[i] means the number of ways to reach step i dp = [0] * (n + 1) # Ways to reach the first step dp[0] = 1 dp[1] = 1 # Fill dp array using the relation: dp[i] = dp[i-1] + dp[i-2] for i in range(2, n + 1): dp[i] = dp[i - 1] + dp[i - 2] return dp[n] def distinct_ways_to_reach_top(n, steps): Determines the number of distinct ways to reach the top of the sequence. return num_ways(n, steps) # Example Usage if __name__ == \\"__main__\\": n = int(input()) steps = list(map(int, input().split())) result = distinct_ways_to_reach_top(n, steps) print(result)"},{"question":"def is_perfect_number(N: int) -> bool: Determines if N is a perfect number. >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(12) False >>> is_perfect_number(2) False","solution":"def is_perfect_number(N): Determines if N is a perfect number. proper_divisors_sum = 0 for i in range(1, N): if N % i == 0: proper_divisors_sum += i return proper_divisors_sum == N"},{"question":"def find_cycles(grid, N, M): Determine the number of valid cycles present in the given matrix. >>> find_cycles([['R', 'R', 'D'], ['L', 'U', 'L'], ['L', 'D', 'L']], 3, 3) 1 >>> find_cycles([['R', 'R'], ['L', 'L']], 2, 2) 0 def count_cycles(test_cases): Count cycles for given test cases. >>> count_cycles([(3, 3, [['R', 'R', 'D'], ['L', 'U', 'L'], ['L', 'D', 'L']]), (2, 2, [['R', 'R'], ['L', 'L']])]) [1, 0] def process_input(input_string): Process and parse input string to extract test cases. >>> process_input(\\"2n3 3nR R DnL U LnL D Ln2 2nR RnL Ln\\") [(3, 3, [['R', 'R', 'D'], ['L', 'U', 'L'], ['L', 'D', 'L']]), (2, 2, [['R', 'R'], ['L', 'L']])] def solution(input_string): Main function to execute the solution. >>> solution(\\"2n3 3nR R DnL U LnL D Ln2 2nR RnL Ln\\") \\"1n0\\"","solution":"def find_cycles(grid, N, M): def move(i, j): if grid[i][j] == 'L': return i, j - 1 if grid[i][j] == 'R': return i, j + 1 if grid[i][j] == 'U': return i - 1, j if grid[i][j] == 'D': return i + 1, j visited = [[False] * M for _ in range(N)] cycle_count = 0 for i in range(N): for j in range(M): if not visited[i][j]: path = set() ci, cj = i, j while 0 <= ci < N and 0 <= cj < M: if (ci, cj) in path: cycle_count += 1 break if visited[ci][cj]: break path.add((ci, cj)) visited[ci][cj] = True ci, cj = move(ci, cj) return cycle_count def count_cycles(test_cases): results = [] for N, M, grid in test_cases: results.append(find_cycles(grid, N, M)) return results def process_input(input_string): lines = input_string.strip().split('n') index = 0 T = int(lines[index]) index += 1 test_cases = [] for _ in range(T): N, M = map(int, lines[index].split()) index += 1 grid = [] for _ in range(N): row = lines[index].split() index += 1 grid.append(row) test_cases.append((N, M, grid)) return test_cases def solution(input_string): test_cases = process_input(input_string) results = count_cycles(test_cases) return 'n'.join(map(str, results))"},{"question":"def calculate_total_and_max_distance(distances): This function takes a list of daily running distances and returns: - the total distance run in the month - the longest distance run in the month Parameters: distances (list of int): list of distances run each day in the month Returns: tuple: (total distance, longest distance) pass # Unit Tests def test_calculate_total_and_max_distance_example1(): assert calculate_total_and_max_distance([5, 10, 7, 3, 12, 5]) == (42, 12) def test_calculate_total_and_max_distance_example2(): assert calculate_total_and_max_distance([2, 3, 5, 1, 4, 9]) == (24, 9) def test_calculate_total_and_max_distance_single_day(): assert calculate_total_and_max_distance([7]) == (7, 7) def test_calculate_total_and_max_distance_same_distances(): assert calculate_total_and_max_distance([4, 4, 4, 4, 4]) == (20, 4) def test_calculate_total_and_max_distance_all_zeroes(): assert calculate_total_and_max_distance([0, 0, 0, 0, 0]) == (0, 0) def test_calculate_total_and_max_distance_mixed_distances(): assert calculate_total_and_max_distance([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == (55, 10)","solution":"def calculate_total_and_max_distance(distances): This function takes a list of daily running distances and returns: - the total distance run in the month - the longest distance run in the month Parameters: distances (list of int): list of distances run each day in the month Returns: tuple: (total distance, longest distance) total_distance = sum(distances) max_distance = max(distances) return total_distance, max_distance"},{"question":"def is_prime(n: int) -> bool: Determines if a number is prime. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Parameters: n (int): The integer to check for primality (2 ≤ n ≤ 10^6). Returns: bool: True if the number is prime, False otherwise. Examples: >>> is_prime(5) True >>> is_prime(4) False","solution":"def is_prime(n): Determines if a number is prime. Parameters: n (int): The integer to check for primality. Returns: bool: True if the number is prime, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True"},{"question":"def longest_increasing_subsequence_with_one_removal(n: int, arr: List[int]) -> int: Compute the length of the longest strictly increasing subsequence that can be obtained after removing at most one element from the given array. >>> longest_increasing_subsequence_with_one_removal(5, [10, 20, 30, 10, 40]) 4 >>> longest_increasing_subsequence_with_one_removal(6, [10, 20, 30, 20, 10, 40]) 4 >>> longest_increasing_subsequence_with_one_removal(3, [1, 2, 1]) 2","solution":"def longest_increasing_subsequence_with_one_removal(n, arr): if n == 1: return 1 # Function to calculate LIS ending at each position def calculate_lis_ending_at(arr): lis_ending = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: lis_ending[i] = max(lis_ending[i], lis_ending[j] + 1) return lis_ending # Function to calculate LIS starting at each position def calculate_lis_starting_from(arr): lis_starting = [1] * len(arr) for i in range(len(arr) - 2, -1, -1): for j in range(i + 1, len(arr)): if arr[i] < arr[j]: lis_starting[i] = max(lis_starting[i], lis_starting[j] + 1) return lis_starting lis_ending = calculate_lis_ending_at(arr) lis_starting = calculate_lis_starting_from(arr) max_len = 0 for i in range(n): max_len = max(max_len, lis_ending[i]) for i in range(1, n - 1): if arr[i - 1] < arr[i + 1]: max_len = max(max_len, lis_ending[i - 1] + lis_starting[i + 1]) return max_len"},{"question":"def count_unique_items(transactions: List[List[int]]) -> int: Returns the total count of unique item IDs across all transactions. Args: transactions (List[List[int]]): List of transactions, where each transaction is a list of item IDs. Returns: int: Total number of unique item IDs. >>> count_unique_items([[1, 2, 3], [2, 3, 4], [5, 2, 1]]) == 5 >>> count_unique_items([]) == 0 >>> count_unique_items([[1, 1, 1, 1]]) == 1 >>> count_unique_items([[1, 2], [2, 3], [3, 4], [4, 5]]) == 5 >>> count_unique_items([[100000, 99999, 99998], [99998, 99997, 100000], [99997, 99996]]) == 5 >>> count_unique_items([[1, 2], [3, 4], [5, 6]]) == 6","solution":"def count_unique_items(transactions): Returns the total count of unique item IDs across all transactions. Args: transactions (List[List[int]]): List of transactions, where each transaction is a list of item IDs. Returns: int: Total number of unique item IDs. unique_items = set() for transaction in transactions: unique_items.update(transaction) return len(unique_items)"},{"question":"def calculate_scores(N: int, M: int, K: int, challenges: List[str]) -> List[int]: Calculate the total score for each participant. Args: N (int): Number of participants. M (int): Number of challenges. K (int): Maximum number of participants in a team challenge. challenges (List[str]): List of challenge descriptions. Returns: List[int]: Total scores for each participant. Example: >>> calculate_scores(4, 5, 2, [\\"1 100 1\\", \\"2 200 1 2\\", \\"1 50 2\\", \\"2 150 3 4\\", \\"2 100 1 3\\"]) [400, 250, 250, 150] >>> calculate_scores(3, 3, 2, [\\"2 100 1 2\\", \\"1 50 2\\", \\"2 200 1 3\\"]) [300, 150, 200]","solution":"def calculate_scores(N, M, K, challenges): scores = [0] * N for challenge in challenges: parts = challenge.split() if parts[0] == '1': # solo challenge score = int(parts[1]) participant = int(parts[2]) - 1 scores[participant] += score elif parts[0] == '2': # team challenge score = int(parts[1]) participants = list(map(int, parts[2:])) for participant in participants: scores[participant - 1] += score return scores"},{"question":"def zog_sequence(a: int, b: int, k: int) -> int: Calculate the k-th term of the Zog Sequence starting with a and b. Parameters: a (int): The first term of the sequence. b (int): The second term of the sequence. k (int): The position of the term to be found. Returns: int: The k-th term of the Zog Sequence. >>> zog_sequence(1, 2, 3) 5 >>> zog_sequence(3, 4, 4) 641","solution":"def zog_sequence(a, b, k): Calculate the k-th term of the Zog Sequence starting with a and b. Parameters: a (int): The first term of the sequence. b (int): The second term of the sequence. k (int): The position of the term to be found. Returns: int: The k-th term of the Zog Sequence. if k == 1: return a elif k == 2: return b else: seq = [a, b] for i in range(2, k): next_term = seq[-1]**2 + seq[-2]**2 seq.append(next_term) return seq[k-1]"},{"question":"def max_distance_travel(N, K, connections): Calculate the maximum distance Rama can travel to visit exactly K unique shops starting from shop 1 in a marketplace represented as a tree. >>> max_distance_travel(5, 3, [(1, 2), (1, 3), (2, 4), (2, 5)]) 2 >>> max_distance_travel(3, 2, [(1, 2), (1, 3)]) 1","solution":"from collections import deque def bfs_to_find_furthest(node, edges): queue = deque([node]) visited = {node} furthest_node = node while queue: current_node = queue.popleft() furthest_node = current_node for neighbor in edges[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) return furthest_node def bfs_to_find_distance(node, target, edges, K): queue = deque([(node, 0)]) visited = {node} while queue: current_node, distance = queue.popleft() if distance == K - 1: return distance for neighbor in edges[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, distance + 1)) return -1 # This should not happen as K <= N def max_distance_travel(N, K, connections): if K == 1: return 0 edges = [[] for _ in range(N + 1)] for u, v in connections: edges[u].append(v) edges[v].append(u) # Step 1: Find furthest from node 1 to any node furthest_from_start = bfs_to_find_furthest(1, edges) # Step 2: Find longest distance K - 1 from furthest_from_start max_distance = bfs_to_find_distance(furthest_from_start, 1, edges, K) return max_distance # Example usage # Note: The connections input format should be a list of tuples[(u1, v1), (u2, v2), ...] print(max_distance_travel(5, 3, [(1, 2), (1, 3), (2, 4), (2, 5)])) # Output should be 2"},{"question":"def prize_categories(n: int) -> Tuple[int, List[int]]: Distributes n prizes into unique, positive integer categories. Returns the number of categories and the list of integers. Parameters: n (int): The total number of prizes to be distributed. Returns: Tuple[int, List[int]]: The number of unique categories and the list of prizes in each category. Examples: >>> prize_categories(8) (3, [1, 2, 5]) >>> prize_categories(15) (5, [1, 2, 3, 4, 5]) >>> prize_categories(2) (1, [2]) from typing import List, Tuple def test_prize_categories_example1(): n = 8 k, categories = prize_categories(n) assert k == 3 assert categories == [1, 2, 5] def test_prize_categories_example2(): n = 15 k, categories = prize_categories(n) assert k == 5 assert categories == [1, 2, 3, 4, 5] def test_prize_categories_example3(): n = 2 k, categories = prize_categories(n) assert k == 1 assert categories == [2] def test_prize_categories_small_number(): n = 3 k, categories = prize_categories(n) assert k == 2 assert categories == [1, 2] def test_prize_categories_medium_number(): n = 10 k, categories = prize_categories(n) assert k == 4 assert categories == [1, 2, 3, 4] def test_prize_categories_large_number(): n = 1000 k, categories = prize_categories(n) assert k == 44 assert sum(categories) == 1000","solution":"def prize_categories(n): Distributes n prizes into unique, positive integer categories. Returns the number of categories and the list of integers. categories = [] total = 0 i = 1 while total + i <= n: categories.append(i) total += i i += 1 if total < n: categories[-1] += n - total return len(categories), categories"},{"question":"def is_subsequence(s: str, t: str) -> str: Returns \\"YES\\" if t is a subsequence of s, otherwise returns \\"NO\\". >>> is_subsequence('abpcplea', 'apple') 'YES' >>> is_subsequence('abc', 'abcd') 'NO'","solution":"def is_subsequence(s, t): Returns \\"YES\\" if t is a subsequence of s, otherwise returns \\"NO\\". it = iter(s) return \\"YES\\" if all(char in it for char in t) else \\"NO\\""},{"question":"def count_unique_ways(m: int, b: int, k: int) -> int: Determine the number of possible unique ways to place the k continuous beats in an m measure and b beats per measure grid. >>> count_unique_ways(3, 4, 5) 4 >>> count_unique_ways(2, 6, 8) 6 >>> count_unique_ways(1, 1, 1) 1 def process_test_cases(test_cases: List[Tuple[int, int, int]]) -> List[int]: Process multiple test cases to determine the number of unique ways to place the k continuous beats in each scenario. >>> process_test_cases([(3, 4, 5), (2, 6, 8), (1, 1, 1)]) [4, 6, 1] >>> process_test_cases([(5, 10, 15), (4, 5, 3)]) [10, 3] from typing import List, Tuple def test_count_unique_ways(): assert count_unique_ways(3, 4, 5) == 4 assert count_unique_ways(2, 6, 8) == 6 assert count_unique_ways(1, 1, 1) == 1 assert count_unique_ways(5, 10, 15) == 10 assert count_unique_ways(4, 5, 3) == 3 assert count_unique_ways(2, 2, 5) == 2 def test_process_test_cases(): test_cases = [(3, 4, 5), (2, 6, 8), (1, 1, 1)] expected = [4, 6, 1] assert process_test_cases(test_cases) == expected test_cases = [(5, 10, 15), (4, 5, 3)] expected = [10, 3] assert process_test_cases(test_cases) == expected","solution":"def count_unique_ways(m, b, k): Function to compute the number of unique ways to place k continuous beats in an m measure and b beats per measure grid. if k <= b: return k return b def process_test_cases(test_cases): results = [] for m, b, k in test_cases: results.append(count_unique_ways(m, b, k)) return results"},{"question":"def find_overlapping_routes(N: int, K: int, routes: List[List[int]]) -> List[Tuple[int, int]]: Identify pairs of bus routes that overlap for at least K consecutive stops. Args: N : int : Number of bus routes. K : int : Minimum number of consecutive stops for overlap. routes : List[List[int]] : List of bus routes, where each route is represented by a list of stops. Returns: List[Tuple[int, int]] : List of pairs (i, j) indicating that route i and route j overlap. >>> find_overlapping_routes(4, 3, [[1, 2, 3, 4, 5], [3, 4, 5, 6, 7, 8], [10, 11, 12, 3, 4, 5, 6], [1, 2, 3, 5]]) [(1, 2), (1, 3), (1, 4), (2, 3)] >>> find_overlapping_routes(3, 2, [[1, 2], [3, 4], [5, 6]]) []","solution":"def find_overlapping_routes(N, K, routes): def has_k_consecutive_stops(route1, route2, K): len1, len2 = len(route1), len(route2) for i in range(len1 - K + 1): for j in range(len2 - K + 1): if route1[i:i+K] == route2[j:j+K]: return True return False overlaps = [] for i in range(N): for j in range(i + 1, N): if has_k_consecutive_stops(routes[i], routes[j], K): overlaps.append((i + 1, j + 1)) return overlaps # Example usage: if __name__ == \\"__main__\\": N, K = 4, 3 routes = [ [1, 2, 3, 4, 5], [3, 4, 5, 6, 7, 8], [10, 11, 12, 3, 4, 5, 6], [1, 2, 3, 5] ] result = find_overlapping_routes(N, K, routes) for res in result: print(res[0], res[1])"},{"question":"import heapq def manage_emergency_room(n, m, severities): Manages the list of patients in an emergency room based on their severity levels. Parameters: n (int): The number of patients arriving. m (int): The maximum capacity of the emergency room. severities (list of int): The severities of the patients arriving in order. Returns: list of int: The severities of the patients currently in the emergency room, sorted in non-decreasing order. Examples: >>> manage_emergency_room(6, 3, [50, 30, 20, 40, 60, 70]) [50, 60, 70] >>> manage_emergency_room(5, 2, [100, 50, 30, 60, 80]) [80, 100]","solution":"import heapq def manage_emergency_room(n, m, severities): Manages the list of patients in an emergency room based on their severity levels. Parameters: n (int): The number of patients arriving. m (int): The maximum capacity of the emergency room. severities (list of int): The severities of the patients arriving in order. Returns: list of int: The severities of the patients currently in the emergency room, sorted in non-decreasing order. # Use a min-heap to keep track of the least severe patients in the emergency room emergency_room = [] for severity in severities: if len(emergency_room) < m: heapq.heappush(emergency_room, severity) else: # If new patient has higher severity than the least severe patient in the room if severity > emergency_room[0]: heapq.heappushpop(emergency_room, severity) # Convert min-heap to a sorted list sorted_room = sorted(emergency_room) return sorted_room"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Returns the length of longest substring without repeating characters in string s. >>> length_of_longest_substring(\\"abcabcbb\\") == 3 >>> length_of_longest_substring(\\"bbbbb\\") == 1 >>> length_of_longest_substring(\\"pwwkew\\") == 3 >>> length_of_longest_substring(\\"abcddefg\\") == 4 def find_longest_substrings(test_cases: List[str]) -> List[int]: For each string in test_cases, return the length of longest substring without repeating characters. >>> find_longest_substrings([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\", \\"abcddefg\\"]) == [3, 1, 3, 4] >>> find_longest_substrings([\\"\\", \\"a\\", \\"au\\", \\"dvdf\\"]) == [0, 1, 2, 3]","solution":"def length_of_longest_substring(s): Returns the length of longest substring without repeating characters in string s. char_map = {} max_length = 0 start = 0 for idx, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = idx max_length = max(max_length, idx - start + 1) return max_length def find_longest_substrings(test_cases): For each string in test_cases, return the length of longest substring without repeating characters. return [length_of_longest_substring(s) for s in test_cases]"},{"question":"from typing import List def count_distinct_greater_or_equal(nums: List[int], queries: List[int]) -> List[int]: You are given a list of n integers and q queries. Each query consists of a single integer k. For each query, determine the number of distinct integers in the list that are greater than or equal to k. >>> count_distinct_greater_or_equal([1, 3, 3, 5, 7, 9], [4, 3, 10]) [3, 4, 0] >>> count_distinct_greater_or_equal([5], [5, 4, 6]) [1, 1, 0] >>> count_distinct_greater_or_equal([2, 2, 2, 2], [1, 2, 3]) [1, 1, 0] >>> count_distinct_greater_or_equal([], [1, 2, 3]) [0, 0, 0] >>> count_distinct_greater_or_equal(list(range(1, 100001)), [1, 50000, 99999, 100000, 100001]) [100000, 50001, 2, 1, 0]","solution":"def count_distinct_greater_or_equal(nums, queries): # Convert nums list to a set to get distinct elements distinct_nums = sorted(set(nums)) result = [] for k in queries: # Find the number of elements greater than or equal to k using binary search low, high = 0, len(distinct_nums) while low < high: mid = (low + high) // 2 if distinct_nums[mid] >= k: high = mid else: low = mid + 1 result.append(len(distinct_nums) - low) return result"},{"question":"def min_cost_to_make_distinct(arr): Returns the minimum cost to transform the array into a sequence of distinct integers. >>> min_cost_to_make_distinct([4, 4, 4, 4, 4]) 4 >>> min_cost_to_make_distinct([1, 2, 2]) 1 >>> min_cost_to_make_distinct([5, 3, 8, 8, 1, 1]) 2 >>> min_cost_to_make_distinct([1, 2, 3, 4, 5]) 0 >>> min_cost_to_make_distinct([7, 7, 7, 7]) 3 >>> min_cost_to_make_distinct([10, 20, 10, 20, 30, 30, 40]) 3","solution":"def min_cost_to_make_distinct(arr): Returns the minimum cost to transform the array into a sequence of distinct integers. from collections import Counter counter = Counter(arr) duplicates = sum(count - 1 for count in counter.values() if count > 1) return duplicates"},{"question":"def fill_crossword(grid): Fill the empty cells in the 26x26 grid so that each row contains all the characters from 'a' to 'z' exactly once. Args: grid (List[str]): A list of 26 strings each containing 26 characters. Returns: List[str]: A list of 26 strings each containing 26 characters with all rows filled such that each row contains all letters 'a' to 'z'. >>> test_single_case() >>> test_full_filled_case() >>> test_all_empty_case() pass def test_single_case(): input_grid = [ \\"a.........................\\", \\".b........................\\", \\"..c.......................\\", \\"...d......................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", \\"..........................\\", ] result = fill_crossword(input_grid) for row in result: assert sorted(row) == list('abcdefghijklmnopqrstuvwxyz') def test_full_filled_case(): input_grid = [ \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", \\"abcdefghijklmnopqrstuvwxyz\\", ] result = fill_crossword(input_grid) assert result == input_grid def test_all_empty_case(): input_grid = [\\"..........................\\" for _ in range(26)] result = fill_crossword(input_grid) for row in result: assert sorted(row) == list('abcdefghijklmnopqrstuvwxyz') assert len(row) == 26 assert len(set(row)) == 26","solution":"def fill_crossword(grid): import string def complete_row(row): alphabet = set(string.ascii_lowercase) existing_chars = set(row) - {'.'} missing_chars = list(alphabet - existing_chars) row = list(row) for i, char in enumerate(row): if char == '.': row[i] = missing_chars.pop() return ''.join(row) return [complete_row(row) for row in grid]"},{"question":"def can_form_word(n: int, cubes: List[List[str]], word: str) -> str: Determine if a word can be constructed using characters from a given set of cubes. Each cube has exactly six faces with one letter on each face. Args: n (int): Number of cubes. cubes (List[List[str]]): A list containing n sublists, each with 6 different lowercase letters. word (str): The word to be formed. Returns: str: \\"Yes\\" if the word can be formed using the cubes, otherwise \\"No\\". Example: >>> can_form_word(3, [['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p', 'q', 'r']], \\"dog\\") \\"Yes\\" >>> can_form_word(3, [['a', 'b', 'c', 'd', 'e', 'f'], ['g', 'h', 'i', 'j', 'k', 'l'], ['m', 'n', 'o', 'p', 'q', 'r']], \\"cat\\") \\"No\\"","solution":"def can_form_word(n, cubes, word): from collections import defaultdict # Create a list to keep track of available cubes for each character char_to_cubes = defaultdict(list) for i, cube in enumerate(cubes): for char in cube: char_to_cubes[char].append(i) # Keep track of which cubes are used used_cubes = [False] * n # Function to check if we can form the word starting from a specific position def backtrack(position): if position == len(word): return True char = word[position] for cube_index in char_to_cubes.get(char, []): if not used_cubes[cube_index]: used_cubes[cube_index] = True if backtrack(position + 1): return True used_cubes[cube_index] = False return False return \\"Yes\\" if backtrack(0) else \\"No\\""},{"question":"from typing import List def find_minimized_maximum_pages(pages: List[int], students: int) -> int: Divide books into the given number of students such that the maximum number of pages assigned to a student is minimized. >>> find_minimized_maximum_pages([12, 34, 67, 90], 2) 113 >>> find_minimized_maximum_pages([10, 20, 30, 40], 2) 60 pass def is_possible(pages: List[int], students: int, max_pages: int) -> bool: Helper function to decide if it is possible to allocate books to students such that no student reads more than max_pages. >>> is_possible([12, 34, 67, 90], 2, 113) True >>> is_possible([12, 34, 67, 90], 2, 112) False pass","solution":"def is_possible(pages, students, max_pages): required_students = 1 current_pages = 0 for page in pages: if current_pages + page > max_pages: required_students += 1 current_pages = page if required_students > students: return False else: current_pages += page return True def find_minimized_maximum_pages(pages, students): if students > len(pages): return -1 # Not enough books for every student to have at least one book low, high = max(pages), sum(pages) result = high while low <= high: mid = (low + high) // 2 if is_possible(pages, students, mid): result = mid high = mid - 1 else: low = mid + 1 return result"},{"question":"def max_widgets(max_capacity: int, weights: List[int]) -> int: Returns the maximum number of widgets that can be processed without exceeding the weight capacity. >>> max_widgets(15, [3, 1, 4, 3, 2]) 5 >>> max_widgets(10, [6, 4, 4, 3, 2]) 3 >>> max_widgets(6, [5, 1, 2, 3, 1, 1]) 4 >>> max_widgets(20, [5, 5, 5, 5]) 4 >>> max_widgets(1, [2, 2, 2]) 0 >>> max_widgets(10000, [1000] * 10) 10 # Your code here","solution":"def max_widgets(max_capacity, weights): Returns the maximum number of widgets that can be processed without exceeding the weight capacity. Parameters: max_capacity (int): The maximum weight capacity the factory can handle. weights (list): List of weights of the widget types. Returns: int: The maximum number of widgets that can be processed. # Sort weights in ascending order weights.sort() total_weight = 0 count = 0 for weight in weights: if total_weight + weight <= max_capacity: total_weight += weight count += 1 else: break return count"},{"question":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. :param arr1: List of integers, sorted in non-decreasing order :param arr2: List of integers, sorted in non-decreasing order :return: A new list containing all integers from arr1 and arr2 in sorted order >>> merge_sorted_arrays([1, 3, 5, 7], [2, 4, 6]) [1, 2, 3, 4, 5, 6, 7] >>> merge_sorted_arrays([1, 2, 3, 4, 5], [6, 7, 8]) [1, 2, 3, 4, 5, 6, 7, 8]","solution":"def merge_sorted_arrays(arr1, arr2): Merges two sorted arrays into one sorted array. :param arr1: List of integers, sorted in non-decreasing order :param arr2: List of integers, sorted in non-decreasing order :return: A new list containing all integers from arr1 and arr2 in sorted order n = len(arr1) m = len(arr2) merged_array = [] i = j = 0 while i < n and j < m: if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 while i < n: merged_array.append(arr1[i]) i += 1 while j < m: merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"def can_make_equal(s1: str, s2: str) -> str: Determine if s1 can be rearranged to match s2 by swapping characters any number of times. Args: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s1 can be made equal to s2, otherwise \\"NO\\". Examples: >>> can_make_equal(\\"abc\\", \\"bca\\") \\"YES\\" >>> can_make_equal(\\"aabbcc\\", \\"ccbbaa\\") \\"YES\\" >>> can_make_equal(\\"abcdef\\", \\"ghijkl\\") \\"NO\\"","solution":"def can_make_equal(s1, s2): Determine if s1 can be rearranged to match s2 by swapping characters any number of times. Args: s1 (str): The first string. s2 (str): The second string. Returns: str: \\"YES\\" if s1 can be made equal to s2, otherwise \\"NO\\". if sorted(s1) == sorted(s2): return \\"YES\\" else: return \\"NO\\""},{"question":"def largest_prime_divisor(n: int) -> int: Returns the largest prime divisor of n. >>> largest_prime_divisor(100) 5 >>> largest_prime_divisor(97) 97","solution":"def largest_prime_divisor(n): Returns the largest prime divisor of n. def is_prime(x): if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True if n <= 1: return None largest_prime = None # Check for smallest factor (2) while n % 2 == 0: largest_prime = 2 n //= 2 # Check for odd factors for i in range(3, int(n ** 0.5) + 1, 2): while n % i == 0: largest_prime = i n //= i # If n becomes a prime number greater than 2 if n > 2: largest_prime = n return largest_prime"},{"question":"def merge_images(n: int, m: int, image1: List[List[int]], image2: List[List[int]]) -> List[List[int]]: Merges two grayscale images by averaging their pixel values. :param n: Number of rows in the image :param m: Number of columns in the image :param image1: First grayscale image represented as a 2D list of integers :param image2: Second grayscale image represented as a 2D list of integers :return: Merged grayscale image represented as a 2D list of integers >>> merge_images(2, 3, [[100, 150, 200], [50, 100, 150]], [[200, 250, 100], [150, 200, 50]]) [[150, 200, 150], [100, 150, 100]] >>> merge_images(3, 3, [[0, 0, 0], [255, 255, 255], [128, 128, 128]], [[64, 64, 64], [192, 192, 192], [0, 128, 255]]) [[32, 32, 32], [223, 223, 223], [64, 128, 191]]","solution":"def merge_images(n, m, image1, image2): Merges two grayscale images by averaging their pixel values. :param n: Number of rows in the image :param m: Number of columns in the image :param image1: First grayscale image represented as a 2D list of integers :param image2: Second grayscale image represented as a 2D list of integers :return: Merged grayscale image represented as a 2D list of integers merged_image = [] for i in range(n): merged_row = [] for j in range(m): average_pixel = (image1[i][j] + image2[i][j]) // 2 merged_row.append(average_pixel) merged_image.append(merged_row) return merged_image"},{"question":"def can_accommodate_meeting(n: int, meetings: List[Tuple[int, int]], new_meeting: Tuple[int, int]) -> str: Determine if a new meeting can be accommodated without conflicts. Args: n: Number of existing meetings scheduled in the room. meetings: A list of tuples representing the start and end times of existing meetings. new_meeting: A tuple representing the start and end times of the new meeting request. Returns: 'YES' if the new meeting can be accommodated without conflicts, otherwise 'NO'. Examples: >>> can_accommodate_meeting(3, [(1, 3), (4, 6), (7, 10)], (5, 8)) 'NO' >>> can_accommodate_meeting(2, [(2, 4), (6, 8)], (4, 6)) 'YES' >>> can_accommodate_meeting(4, [(1, 2), (3, 5), (5, 6), (8, 10)], (6, 8)) 'YES'","solution":"def can_accommodate_meeting(n, meetings, new_meeting): new_start, new_end = new_meeting for start_i, end_i in meetings: # Check if there is any overlap if not (new_end <= start_i or new_start >= end_i): return \\"NO\\" return \\"YES\\""},{"question":"def is_prime(n: int) -> bool: Helper function to determine if a number n is prime. >>> is_prime(2) True >>> is_prime(9) False def largest_prime_leq(n: int) -> int: Find the largest prime number less than or equal to n. Returns -1 if no such prime exists. >>> largest_prime_leq(10) 7 >>> largest_prime_leq(20) 19 >>> largest_prime_leq(1) -1","solution":"def is_prime(n): Helper function to determine if a number n is prime. if n <= 1: return False if n == 2 or n == 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def largest_prime_leq(n): Find the largest prime number less than or equal to n. Returns -1 if no such prime exists. for num in range(n, 1, -1): if is_prime(num): return num return -1"},{"question":"def min_operations_to_sort(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations needed to sort each array in non-decreasing order. >>> min_operations_to_sort(1, [(5, [1, 2, 3, 4, 5])]) [0] >>> min_operations_to_sort(1, [(5, [5, 4, 3, 2, 1])]) [1] >>> min_operations_to_sort(1, [(5, [3, 1, 2, 4, 5])]) [1] >>> min_operations_to_sort(1, [(4, [4, 3, 1, 2])]) [2] >>> min_operations_to_sort(3, [(5, [5, 4, 3, 2, 1]), (5, [3, 1, 2, 4, 5]), (4, [4, 3, 1, 2])]) [1, 1, 2]","solution":"def min_operations_to_sort(t, test_cases): results = [] for case in test_cases: n, arr = case if arr == sorted(arr): results.append(0) elif arr == sorted(arr, reverse=True): results.append(1) elif arr[0] > arr[-1]: results.append(2) else: results.append(1) return results"},{"question":"def is_possible_to_enclose(n: int, m: int, grid: List[str]) -> str: Determine if it's possible to completely enclose a rectangular area of forest using mountains along its perimeter. >>> is_possible_to_enclose(4, 5, [\\".....\\", \\"..^..\\", \\".^^..\\", \\".....\\"]) == \\"NO\\" >>> is_possible_to_enclose(4, 4, [\\"^^^^\\", \\"^^^^\\", \\"^^^^\\", \\"^^^^\\"]) == \\"YES\\" >>> is_possible_to_enclose(5, 5, [\\".^^^^\\", \\"^^^^^\\", \\"^^^.^\\", \\"^^^^^\\", \\"^^^^^\\"]) == \\"NO\\"","solution":"def is_possible_to_enclose(n, m, grid): # Check if there is any shore cell '~' for row in grid: if '~' in row: return \\"NO\\" found_forest = False for i in range(n): for j in range(m): if grid[i][j] == '.': found_forest = True # Check the entire border cells around this forest cell if i > 0 and grid[i-1][j] != '^': return \\"NO\\" if i < n-1 and grid[i+1][j] != '^': return \\"NO\\" if j > 0 and grid[i][j-1] != '^': return \\"NO\\" if j < m-1 and grid[i][j+1] != '^': return \\"NO\\" if ( (i == 0 or i == n-1) or (j == 0 or j == m-1) ): return \\"NO\\" if not found_forest: return \\"YES\\" return \\"YES\\""},{"question":"def distribute_books(n: int, m: int) -> List[int]: Distributes n books into m sections such that the difference between the number of books in the largest and smallest section is minimized. >>> distribute_books(7, 3) [3, 2, 2] >>> distribute_books(9, 4) [3, 2, 2, 2] >>> distribute_books(2, 5) [1, 1]","solution":"def distribute_books(n, m): Distributes n books into m sections such that the difference between the number of books in the largest and smallest section is minimized. Parameters: n (int): Total number of books. m (int): Number of sections. Returns: List[int]: A list of integers where each value represents the number of books in each section. # If there are more sections than books, each section can only have at most one book if m >= n: return [1] * n # Number of books per section books_per_section = n // m # Number of sections that will have an extra book num_extra_book_sections = n % m # Construct the result with extra books in the first num_extra_book_sections sections distribution = [books_per_section + 1] * num_extra_book_sections + [books_per_section] * (m - num_extra_book_sections) return distribution"},{"question":"from typing import List, Tuple def isolated_servers(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the number of servers that would be isolated if server 1 fails. Args: n (int): The number of servers. m (int): The number of direct connections. connections (List[Tuple[int, int]]): The list of direct connections. Returns: int: The number of servers that would be isolated. >>> isolated_servers(4, 3, [(1, 2), (2, 3), (3, 4)]) 3 >>> isolated_servers(5, 4, [(1, 2), (2, 3), (3, 4), (1, 5)]) 4 pass","solution":"def isolated_servers(n, m, connections): from collections import defaultdict, deque # Build the graph graph = defaultdict(list) for x, y in connections: graph[x].append(y) graph[y].append(x) # BFS to find all nodes connected to node 1 queue = deque([1]) visited = set([1]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Subtract one for the removed server 1 return len(visited) - 1"},{"question":"def are_anagrams(str1: str, str2: str) -> bool: Check if two given strings are anagrams or not. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False","solution":"def are_anagrams(str1, str2): Check if two strings are anagrams of each other. if len(str1) != len(str2): return False # Create frequency dictionaries for both strings freq1 = {} freq2 = {} for char in str1: if char in freq1: freq1[char] += 1 else: freq1[char] = 1 for char in str2: if char in freq2: freq2[char] += 1 else: freq2[char] = 1 # Compare the frequency dictionaries return freq1 == freq2"},{"question":"def largest_palindromic_substring(s: str) -> str: Returns the largest palindromic substring of s. If multiple such substrings exist, returns the one which appears first in the string. >>> largest_palindromic_substring(\\"babad\\") \\"bab\\" or \\"aba\\" >>> largest_palindromic_substring(\\"cbbd\\") \\"bb\\"","solution":"def largest_palindromic_substring(s): Returns the largest palindromic substring of s. If multiple such substrings exist, returns the one which appears first in the string. n = len(s) if n == 0: return \\"\\" # Initialize a table to store solutions of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic start = 0 max_len = 1 for i in range(n): dp[i][i] = True # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_len = 2 # Check for length greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_len: start = i max_len = length return s[start:start + max_len]"},{"question":"def find_single_element(nums: List[int]) -> int: Finds the single element in a list where every other element appears twice. Args: nums (list): List of integers where every element appears twice except for one. Returns: int: The single element that does not repeat. result = 0 for num in nums: result ^= num return result def test_find_single_element_basic(): assert find_single_element([1, 2, 3, 4, 2, 3, 1]) == 4 def test_find_single_element_single_element(): assert find_single_element([5]) == 5 def test_find_single_element_negative_numbers(): assert find_single_element([1, -1, 2, 2, 1, 3, 3]) == -1 def test_find_single_element_large_case(): nums = [i for i in range(1, 10**6, 2)] * 2 + [10**6] assert find_single_element(nums) == 10**6 def test_find_single_element_mixed_order(): assert find_single_element([4, 3, 3, 5, 4, 6, 5]) == 6","solution":"def find_single_element(nums): Finds the single element in a list where every other element appears twice. Args: nums (list): List of integers where every element appears twice except for one. Returns: int: The single element that does not repeat. result = 0 for num in nums: result ^= num return result"},{"question":"from typing import List, Tuple def rearrange_list(no_of_cases: int, case_list: List[Tuple[int, List[int]]]) -> List[str]: Given a list of integers, determine if it is possible to rearrange them so that no two adjacent integers are the same. If it is possible, return the rearranged list as a string. If it is not possible, return \\"Not possible\\". >>> rearrange_list(1, [(5, [1, 1, 1, 1, 1])]) [\\"Not possible\\"] >>> rearrange_list(1, [(6, [1, 2, 1, 2, 1, 2])]) [\\"1 2 1 2 1 2\\"] >>> rearrange_list(1, [(4, [1, 2, 3, 4])]) [\\"1 2 3 4\\"] >>> rearrange_list(3, [(5, [1, 1, 1, 1, 1]), (6, [1, 2, 1, 2, 1, 2]), (4, [1, 2, 3, 4])]) [\\"Not possible\\", \\"1 2 1 2 1 2\\", \\"1 2 3 4\\"] >>> rearrange_list(1, [(0, [])]) [\\"\\"] >>> rearrange_list(1, [(1, [1])]) [\\"1\\"]","solution":"from collections import Counter import heapq def rearrange_list(no_of_cases, case_list): results = [] for i in range(no_of_cases): n = case_list[i][0] lst = case_list[i][1] count = Counter(lst) max_heap = [] for num, freq in count.items(): heapq.heappush(max_heap, (-freq, num)) result = [] prev_freq, prev_num = 0, None while max_heap: freq, num = heapq.heappop(max_heap) result.append(num) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_num)) prev_freq, prev_num = freq + 1, num if len(result) != n: results.append(\\"Not possible\\") else: results.append(\\" \\".join(map(str, result))) return results"},{"question":"def is_balanced(tree: List[Optional[int]]) -> bool: Check whether the given binary tree is balanced. >>> is_balanced([3, 9, 20, None, None, 15, 7]) # True >>> is_balanced([1, 2, 2, 3, 3, None, None, 4, 4]) # False","solution":"def is_balanced(tree): from collections import deque # Edge case: When the tree contains only one node if len(tree) == 1: return True index_tree = 0 n = len(tree) # Helper function to build the binary tree from level order list def build_binary_tree(): root = TreeNode(tree[0]) queue = deque([root]) index = 1 while queue and index < n: node = queue.popleft() if node: if index < n and tree[index] is not None: node.left = TreeNode(tree[index]) queue.append(node.left) index += 1 if index < n and tree[index] is not None: node.right = TreeNode(tree[index]) queue.append(node.right) index += 1 return root root = build_binary_tree() # Helper function to calculate height and check balance def check_balance(node): if not node: return 0 left_height = check_balance(node.left) if left_height == -1: return -1 right_height = check_balance(node.right) if right_height == -1: return -1 if abs(left_height - right_height) > 1: return -1 return max(left_height, right_height) + 1 return check_balance(root) != -1 class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right"},{"question":"def min_moves(x1: int, y1: int, x2: int, y2: int) -> int: Given the starting and target coordinates (x1, y1) and (x2, y2), calculate the minimum number of moves required for the spaceship to reach the target point from the starting point. Each move horizontally or vertically takes 1 unit of time. >>> min_moves(0, 0, 3, 4) 7 >>> min_moves(-1, 2, -4, 6) 7 >>> min_moves(5, 5, 5, 5) 0","solution":"def min_moves(x1, y1, x2, y2): Given the starting and target coordinates (x1, y1) and (x2, y2), calculate the minimum number of moves required for the spaceship to reach the target point from the starting point. Each move horizontally or vertically takes 1 unit of time. return abs(x2 - x1) + abs(y2 - y1)"},{"question":"def can_return_to_origin(s: str) -> str: Determines if the robot can return to the origin after k full repetitions of the instruction sequence. >>> can_return_to_origin('UDLR') == \\"YES\\" >>> can_return_to_origin('UURDL') == \\"NO\\"","solution":"def can_return_to_origin(s): Determines if the robot can return to the origin after k full repetitions of the instruction sequence. x, y = 0, 0 for char in s: if char == 'L': x -= 1 elif char == 'R': x += 1 elif char == 'U': y += 1 elif char == 'D': y -= 1 if x == 0 and y == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def count_B_W_pairs(strings): Given a list of strings, this function counts the number of times 'B' is followed by 'W'. pass def input_handler(n, strings): Handles the input and calls the appropriate function to get the result. pass # Unit Tests def test_count_B_W_pairs(): assert count_B_W_pairs([\\"B\\"]) == 0 assert count_B_W_pairs([\\"WB\\"]) == 0 assert count_B_W_pairs([\\"BWB\\"]) == 1 assert count_B_W_pairs([\\"WWB\\"]) == 0 assert count_B_W_pairs([\\"BWWB\\"]) == 1 assert count_B_W_pairs([\\"WBWB\\"]) == 1 def test_input_handler(): assert input_handler(1, [\\"B\\"]) == 0 assert input_handler(1, [\\"WB\\"]) == 0 assert input_handler(1, [\\"BWB\\"]) == 1 assert input_handler(1, [\\"WWB\\"]) == 0 assert input_handler(1, [\\"BWWB\\"]) == 1 assert input_handler(1, [\\"WBWB\\"]) == 1 assert input_handler(6, [\\"B\\", \\"WB\\", \\"BWB\\", \\"WWB\\", \\"BWWB\\", \\"WBWB\\"]) == 3","solution":"def count_B_W_pairs(strings): Given a list of strings, this function counts the number of times 'B' is followed by 'W'. total_count = 0 for s in strings: total_count += s.count('BW') return total_count def input_handler(n, strings): Handles the input and calls the appropriate function to get the result. return count_B_W_pairs(strings)"},{"question":"def max_magical_power(n: int, powers: List[int]) -> int: Returns the maximum sum of values of selected trees such that no two selected trees are adjacent :param n: integer, number of trees :param powers: list of integers, magical power values of the trees :return: integer, maximum sum of selected values >>> max_magical_power(5, [3, 2, 5, 10, 7]) 15 >>> max_magical_power(6, [3, 2, 7, 10, 12, 5]) 22 >>> max_magical_power(1, [3]) 3 >>> max_magical_power(2, [2, 3]) 3 >>> max_magical_power(4, [-1, -2, -3, -4]) 0 from typing import List","solution":"def max_magical_power(n, powers): Returns the maximum sum of values of selected trees such that no two selected trees are adjacent :param n: integer, number of trees :param powers: list of integers, magical power values of the trees :return: integer, maximum sum of selected values if n == 0: return 0 if n == 1: return max(0, powers[0]) if n == 2: return max(0, powers[0], powers[1]) dp = [0] * n dp[0] = max(0, powers[0]) dp[1] = max(dp[0], powers[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + powers[i]) return dp[-1]"},{"question":"def process_alarms(n: int, thresholds: List[int], m: int, readings: List[Tuple[int, int, int]]) -> List[str]: Process a series of temperature readings and determine if and when each room's alarm is triggered. Args: n (int): The number of rooms. thresholds (List[int]): The list of threshold temperatures for the rooms. m (int): The number of temperature readings. readings (List[Tuple[int, int, int]]): A list of tuples where each tuple contains a timestamp, a room number, and a temperature reading. Returns: List[str]: A list of strings where each string contains two pieces of information: the number of alarms triggered in that room and the timestamp of the last alarm triggered in that room. If no alarm was triggered in that room, print -1 for the timestamp. Example: >>> process_alarms(3, [60, 50, 70], 5, [(1, 1, 55), (2, 2, 45), (3, 1, 65), (4, 3, 75), (5, 2, 55)]) [\\"1 3\\", \\"1 5\\", \\"1 4\\"] >>> process_alarms(2, [100, 200], 4, [(1, 1, 90), (2, 1, 105), (3, 2, 190), (4, 2, 210)]) [\\"1 2\\", \\"1 4\\"] from typing import List, Tuple def test_process_alarms_example1(): n = 3 thresholds = [60, 50, 70] m = 5 readings = [ (1, 1, 55), (2, 2, 45), (3, 1, 65), (4, 3, 75), (5, 2, 55) ] expected_output = [\\"1 3\\", \\"1 5\\", \\"1 4\\"] assert process_alarms(n, thresholds, m, readings) == expected_output def test_process_alarms_example2(): n = 2 thresholds = [100, 200] m = 4 readings = [ (1, 1, 90), (2, 1, 105), (3, 2, 190), (4, 2, 210) ] expected_output = [\\"1 2\\", \\"1 4\\"] assert process_alarms(n, thresholds, m, readings) == expected_output def test_process_alarms_no_alarm(): n = 3 thresholds = [100, 200, 300] m = 3 readings = [ (1, 1, 90), (2, 2, 190), (3, 3, 290) ] expected_output = [\\"0 -1\\", \\"0 -1\\", \\"0 -1\\"] assert process_alarms(n, thresholds, m, readings) == expected_output def test_process_alarms_all_alarms(): n = 2 thresholds = [30, 40] m = 5 readings = [ (1, 1, 35), (2, 1, 45), (3, 2, 50), (4, 2, 60), (5, 2, 70) ] expected_output = [\\"2 2\\", \\"3 5\\"] assert process_alarms(n, thresholds, m, readings) == expected_output","solution":"def process_alarms(n, thresholds, m, readings): alarm_counts = [0] * n last_alarm_time = [-1] * n for timestamp, room, temp in readings: room_index = room - 1 if temp > thresholds[room_index]: alarm_counts[room_index] += 1 last_alarm_time[room_index] = timestamp result = [] for i in range(n): result.append(f\\"{alarm_counts[i]} {last_alarm_time[i]}\\") return result"},{"question":"def minimize_absolute_difference(arr: List[int]) -> List[int]: Returns a permutation of the array such that the absolute difference between any two consecutive elements is minimized. >>> minimize_absolute_difference([3, 1, 2, 4]) [1, 2, 3, 4] >>> minimize_absolute_difference([20, 10, 30, 40, 50]) [10, 20, 30, 40, 50]","solution":"def minimize_absolute_difference(arr): Returns a permutation of the array such that the absolute difference between any two consecutive elements is minimized. return sorted(arr) # Example usage: # if __name__ == \\"__main__\\": # n = int(input()) # arr = list(map(int, input().split())) # result = minimize_absolute_difference(arr) # print(\\" \\".join(map(str, result)))"},{"question":"def encrypt_string(s: str, k: int) -> str: Encrypts the given string \`s\` by shifting each character \`k\` positions forward. The shift is circular, wrapping around to 'a' if it exceeds 'z'. pass def process_encryption_cases(T: int, cases: List[Tuple[str, int]]) -> List[str]: Processes T encryption cases and returns the results. Each case is a tuple (S, K), where S is the string and K is the shift value. pass def test_encrypt_string(): assert encrypt_string(\\"hello\\", 1) == \\"ifmmp\\" assert encrypt_string(\\"abc\\", 3) == \\"def\\" assert encrypt_string(\\"xyz\\", 2) == \\"zab\\" assert encrypt_string(\\"abc\\", 25) == \\"zab\\" assert encrypt_string(\\"abcdefghij\\", 5) == \\"fghijklmno\\" def test_process_encryption_cases(): cases = [(\\"hello\\", 1), (\\"abc\\", 3), (\\"xyz\\", 2)] expected = [\\"ifmmp\\", \\"def\\", \\"zab\\"] assert process_encryption_cases(3, cases) == expected cases = [(\\"a\\", 1), (\\"z\\", 1), (\\"a\\", 25)] expected = [\\"b\\", \\"a\\", \\"z\\"] assert process_encryption_cases(3, cases) == expected","solution":"def encrypt_string(s, k): Encrypts the given string \`s\` by shifting each character \`k\` positions forward. The shift is circular, wrapping around to 'a' if it exceeds 'z'. encrypted = [] for char in s: if 'a' <= char <= 'z': # Calculate the new character with wrapping around shifted_char = chr((ord(char) - ord('a') + k) % 26 + ord('a')) encrypted.append(shifted_char) else: encrypted.append(char) return ''.join(encrypted) def process_encryption_cases(T, cases): Processes T encryption cases and returns the results. Each case is a tuple (S, K), where S is the string and K is the shift value. results = [] for s, k in cases: encrypted_string = encrypt_string(s, k) results.append(encrypted_string) return results"},{"question":"def replace_placeholders(article: str, replacements: dict) -> str: Replaces placeholders in the article with corresponding values from replacements dictionary. Args: article (str): The article containing placeholders. replacements (dict): The dictionary with placeholder replacements. Returns: str: The article with placeholders replaced by their respective values. Examples: >>> article = \\"The event will take place on [[date]]. This is an important event for [[organization]]. Attendees should arrive by [[time]].\\" >>> replacements = { \\"date\\": \\"12th October 2021\\", \\"organization\\": \\"The Coding Institute\\", \\"time\\": \\"9:00 AM\\" } >>> replace_placeholders(article, replacements) \\"The event will take place on 12th October 2021. This is an important event for The Coding Institute. Attendees should arrive by 9:00 AM.\\" >>> article = \\"Our next meeting is scheduled for [[day]] at [[location]].\\" >>> replacements = { \\"day\\": \\"Friday\\", \\"location\\": \\"Conference Room B\\" } >>> replace_placeholders(article, replacements) \\"Our next meeting is scheduled for Friday at Conference Room B.\\" pass","solution":"def replace_placeholders(article: str, replacements: dict) -> str: Replaces placeholders in the article with corresponding values from replacements dictionary. Args: article (str): The article containing placeholders. replacements (dict): The dictionary with placeholder replacements. Returns: str: The article with placeholders replaced by their respective values. import re def replace_match(match): placeholder = match.group(1) return replacements.get(placeholder, match.group(0)) # Regex to find [[placeholder]] pattern = re.compile(r'[[(.*?)]]') return pattern.sub(replace_match, article)"},{"question":"from typing import List, Tuple def find_project_order(p: int, q: int, prerequisites: List[Tuple[int, int]]) -> List[int]: You are given a list of projects and a list of prerequisites. Each project is represented by a unique integer. Each prerequisite is a pair of projects [a, b], which means that project a must be completed before project b. Write a function to find the order in which projects should be completed to finish all projects. If there are multiple valid orders, return any of them. If it is impossible to complete all projects due to a cycle in the prerequisites, return an empty list. >>> find_project_order(4, 3, [(1, 2), (2, 3), (3, 4)]) == [1, 2, 3, 4] >>> find_project_order(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) == [] >>> find_project_order(3, 0, []) == [1, 2, 3] >>> find_project_order(2, 1, [(1, 2)]) == [1, 2] >>> find_project_order(3, 3, [(1, 2), (2, 3), (3, 1)]) == [] >>> find_project_order(6, 6, [(1, 3), (2, 3), (3, 4), (4, 5), (4, 6), (5, 6)]) in ([1, 2, 3, 4, 5, 6], [2, 1, 3, 4, 5, 6])","solution":"from collections import defaultdict, deque def find_project_order(p, q, prerequisites): graph = defaultdict(list) indegree = {i: 0 for i in range(1, p + 1)} for a, b in prerequisites: graph[a].append(b) indegree[b] += 1 queue = deque([node for node in indegree if indegree[node] == 0]) order = [] while queue: node = queue.popleft() order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) if len(order) == p: return order else: return [] # Example usage: # p = 4 # q = 4 # prerequisites = [(1, 2), (2, 3), (3, 4), (4, 2)] # print(find_project_order(p, q, prerequisites)) # Output: [] # p = 4 # q = 3 # prerequisites = [(1, 2), (2, 3), (3, 4)] # print(find_project_order(p, q, prerequisites)) # Output: [1, 2, 3, 4]"},{"question":"from typing import List def k_largest_unique_desc(n: int, numbers: List[int], k: int) -> List[int]: Return a list of the k largest unique numbers from the input list in descending order. >>> k_largest_unique_desc(10, [3, 1, 4, 1, 5, 9, 2, 6, 5, 3], 3) [9, 6, 5] >>> k_largest_unique_desc(5, [1, 2, 3, 4, 5], 10) [5, 4, 3, 2, 1]","solution":"def k_largest_unique_desc(n, numbers, k): unique_numbers = list(set(numbers)) unique_numbers.sort(reverse=True) if len(unique_numbers) <= k: return unique_numbers else: return unique_numbers[:k]"},{"question":"def find_min_in_subarray(n: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, determine the minimum value in the subarray from the x-th to the y-th index. >>> find_min_in_subarray(5, [1, 2, 3, 4, 5], [(1, 3)]) [1] >>> find_min_in_subarray(7, [4, 2, 6, 1, 7, 5, 3], [(1, 4), (3, 6), (2, 3), (5, 7)]) [1, 1, 2, 3]","solution":"def find_min_in_subarray(n, arr, queries): results = [] for x, y in queries: min_val = min(arr[x-1:y]) # Adjusting for 1-based index results.append(min_val) return results"},{"question":"import re from typing import List def is_valid_passcode(passcode: str) -> bool: Check if the passcode is valid. A passcode is valid if it contains at least one uppercase letter, one lowercase letter, one digit, and one special character from the set \`!@#%^&*()\`. pass def validate_passcodes(test_cases: List[str]) -> List[str]: Validate a list of passcodes. Args: test_cases (List[str]): A list of passcodes to be validated. Returns: List[str]: A list containing \\"YES\\" for valid passcodes and \\"NO\\" for invalid passcodes. >>> validate_passcodes([\\"Password123!\\", \\"helloWorld1!\\", \\"weakpass\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> validate_passcodes([\\"12345\\", \\"Strong1#\\"]) [\\"NO\\", \\"YES\\"] pass","solution":"def is_valid_passcode(passcode): Check if the passcode is valid. A passcode is valid if it contains at least one uppercase letter, one lowercase letter, one digit, and one special character from the set \`!@#%^&*()\`. has_upper = any(c.isupper() for c in passcode) has_lower = any(c.islower() for c in passcode) has_digit = any(c.isdigit() for c in passcode) has_special = any(c in '!@#%^&*()' for c in passcode) return has_upper and has_lower and has_digit and has_special def validate_passcodes(test_cases): Validate a list of passcodes. results = [] for passcode in test_cases: if is_valid_passcode(passcode): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def largest_square_subgrid(n: int, m: int, grid: List[str]) -> int: Find the largest square sub-grid where all characters are the same. >>> largest_square_subgrid(3, 4, ['abab', 'baba', 'abab']) 1 >>> largest_square_subgrid(4, 4, ['aaaa', 'aaaa', 'aabb', 'aabb']) 2 >>> largest_square_subgrid(5, 5, ['abcde', 'fghij', 'klmno', 'pqrst', 'uvwxy']) 1 pass","solution":"def largest_square_subgrid(n, m, grid): if n == 0 or m == 0: return 0 # Create a 2D list to hold the size of the largest square sub-grid ending at each cell dp = [[0] * m for _ in range(n)] max_side = 0 for i in range(n): for j in range(m): if i == 0 or j == 0: # The first row and the first column can only form a 1x1 square if the character is there dp[i][j] = 1 elif grid[i][j] == grid[i-1][j] == grid[i][j-1] == grid[i-1][j-1]: # Check if current cell and its top, left and top-left neighbors are the same dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 else: dp[i][j] = 1 max_side = max(max_side, dp[i][j]) return max_side"},{"question":"def min_edit_distance(source: str, target: str) -> int: Returns the minimum number of operations required to transform \`source\` string into \`target\` string using insert, delete, or replace. >>> min_edit_distance(\\"kitten\\", \\"sitting\\") == 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") == 2 >>> min_edit_distance(\\"\\", \\"\\") == 0 >>> min_edit_distance(\\"abc\\", \\"\\") == 3 >>> min_edit_distance(\\"\\", \\"abc\\") == 3 >>> min_edit_distance(\\"intention\\", \\"execution\\") == 5 >>> min_edit_distance(\\"a\\", \\"a\\") == 0 >>> min_edit_distance(\\"a\\", \\"b\\") == 1 >>> min_edit_distance(\\"abcdef\\", \\"azced\\") == 3 >>> min_edit_distance(\\"algorithm\\", \\"altruistic\\") == 6 >>> min_edit_distance(\\"sunday\\", \\"saturday\\") == 3","solution":"def min_edit_distance(source, target): Returns the minimum number of operations required to transform \`source\` string into \`target\` string using insert, delete, or replace. m, n = len(source), len(target) # Create a (m+1) x (n+1) matrix to store distances dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize dp matrix for i in range(m + 1): dp[i][0] = i for j in range(n + 1): dp[0][j] = j # Fill in the dp matrix for i in range(1, m + 1): for j in range(1, n + 1): if source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete dp[i][j - 1], # Insert dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def max_subarray_sum(n: int, flower_values: List[int]) -> int: Returns the maximum possible sum of a contiguous subarray. Args: n (int): The number of flowers. flower_values (list of int): The magical values of the flowers. Returns: int: The maximum sum of a contiguous subarray. >>> max_subarray_sum(6, [2, -1, 2, 3, 4, -5]) 10 >>> max_subarray_sum(5, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(3, [-1, -2, -5]) -1","solution":"def max_subarray_sum(n, flower_values): Returns the maximum possible sum of a contiguous subarray. Args: n (int): The number of flowers. flower_values (list of int): The magical values of the flowers. Returns: int: The maximum sum of a contiguous subarray. current_sum = max_sum = flower_values[0] for value in flower_values[1:]: current_sum = max(value, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def min_swaps_to_match(a: str, b: str) -> int: Determine the minimum number of swaps to make string \`a\` equal to string \`b\`. If it is not possible, return -1. pass def process_test_cases(t: int, test_cases: List[Tuple[str, str]]) -> List[int]: Process multiple test cases and return the results for each test case. pass # Unit tests def test_min_swaps_to_match(): assert min_swaps_to_match(\\"abcd\\", \\"dcba\\") == 2 assert min_swaps_to_match(\\"aabb\\", \\"bbaa\\") == 2 assert min_swaps_to_match(\\"abcd\\", \\"abcf\\") == -1 assert min_swaps_to_match(\\"abc\\", \\"abc\\") == 0 assert min_swaps_to_match(\\"abc\\", \\"bac\\") == 1 def test_process_test_cases(): t = 3 test_cases = [(\\"abcd\\", \\"dcba\\"), (\\"aabb\\", \\"bbaa\\"), (\\"abcd\\", \\"abcf\\")] expected_results = [2, 2, -1] assert process_test_cases(t, test_cases) == expected_results t = 2 test_cases = [(\\"abc\\", \\"abc\\"), (\\"abc\\", \\"bac\\")] expected_results = [0, 1] assert process_test_cases(t, test_cases) == expected_results","solution":"def min_swaps_to_match(a, b): if sorted(a) != sorted(b): return -1 swaps = 0 a = list(a) b = list(b) for i in range(len(a)): if a[i] != b[i]: swap_index = a.index(b[i], i) a[i], a[swap_index] = a[swap_index], a[i] swaps += 1 return swaps def process_test_cases(t, test_cases): results = [] for i in range(t): a, b = test_cases[i] result = min_swaps_to_match(a, b) results.append(result) return results"},{"question":"def find_pair_with_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between the values at these indices is equal to the target value. :param arr: List of integers :param target: Target value for the absolute difference :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" >>> find_pair_with_difference([1, 5, 3, 4, 2, 7], 2) \\"YES\\" >>> find_pair_with_difference([1, 3, 5, 8, 6], 3) \\"YES\\" >>> find_pair_with_difference([1, 2, 3, 4, 5], 10) \\"NO\\" >>> find_pair_with_difference([10, 20, 30, 40, 50], 25) \\"NO\\" >>> find_pair_with_difference([1], 1) \\"NO\\" >>> find_pair_with_difference([-1, -2, -3, -4, -5], 1) \\"YES\\" >>> find_pair_with_difference([1000000000, -1000000000, 0], 2000000000) \\"YES\\"","solution":"def find_pair_with_difference(arr, target): Determines if there are two distinct indices i and j in the array such that the absolute difference between the values at these indices is equal to the target value. :param arr: List of integers :param target: Target value for the absolute difference :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" value_indices = {} for idx, value in enumerate(arr): if (value + target) in value_indices or (value - target) in value_indices: return \\"YES\\" value_indices[value] = idx return \\"NO\\""},{"question":"from typing import List, Dict def shortest_path_to_park(t: int, test_cases: List[Dict]) -> List[int]: Calculates the shortest possible time Sam needs to reach his destination park starting from the given position or returns -1 if it is not possible. Args: t (int): Number of test cases. test_cases (List[Dict]): List of test cases where each test case contains: n (int): Size of the grid. grid (List[str]): The grid representation as a list of strings where 'B' represents a building and 'P' represents a park. start (Tuple[int, int, int, int]): The starting and ending positions (sx, sy, ex, ey) in 1-indexed format. Returns: List[int]: List of shortest times required for each test case to reach the destination park or -1 if it is not possible. Examples: >>> t = 2 >>> test_cases = [ >>> { >>> 'n': 4, >>> 'grid': [ >>> 'PPPP', >>> 'PBBP', >>> 'PBBP', >>> 'PPPP' >>> ], >>> 'start': (1, 1, 4, 4) >>> }, >>> { >>> 'n': 3, >>> 'grid': [ >>> 'BBP', >>> 'BPB', >>> 'PBB' >>> ], >>> 'start': (1, 1, 3, 3) >>> } >>> ] >>> shortest_path_to_park(t, test_cases) [6, -1]","solution":"from collections import deque def shortest_path_to_park(t, test_cases): results = [] for case in test_cases: n = case['n'] grid = case['grid'] sx, sy, ex, ey = case['start'] if grid[sx-1][sy-1] == 'B' or grid[ex-1][ey-1] == 'B': results.append(-1) continue directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] visited = [[False for _ in range(n)] for _ in range(n)] queue = deque([(sx-1, sy-1, 0)]) visited[sx-1][sy-1] = True found = False while queue and not found: x, y, dist = queue.popleft() if (x, y) == (ex-1, ey-1): results.append(dist) found = True break for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == 'P': visited[nx][ny] = True queue.append((nx, ny, dist + 1)) if not found: results.append(-1) return results # Usage example (use the input provided in the task) t = 2 test_cases = [ { 'n': 4, 'grid': [ 'PPPP', 'PBBP', 'PBBP', 'PPPP' ], 'start': (1, 1, 4, 4) }, { 'n': 3, 'grid': [ 'BBP', 'BPB', 'PBB' ], 'start': (1, 1, 3, 3) } ] shortest_path_to_park(t, test_cases) # Expected output: [6, -1]"},{"question":"def sum_of_maximums(l: int, k: int, c: List[int]) -> int: Returns the sum of maximum elements from each subarray of length k. >>> sum_of_maximums(6, 3, [1, 3, 2, 5, 4, 2]) 8 >>> sum_of_maximums(5, 2, [4, 1, 3, 5, 2]) 9 >>> sum_of_maximums(6, 3, [1, 1, 1, 1, 1, 1]) 2 >>> sum_of_maximums(1, 1, [5]) 5 >>> sum_of_maximums(4, 4, [2, 8, 6, 4]) 8","solution":"def sum_of_maximums(l, k, c): Returns the sum of maximum elements from each subarray of length k. sum_max = 0 for i in range(0, l, k): subarray = c[i:i+k] if len(subarray) == k: sum_max += max(subarray) return sum_max"},{"question":"def remove_vowels(S: str) -> str: Removes all vowels from the input string S and returns the resulting string. Vowels considered: a, e, i, o, u (both lowercase and uppercase) >>> remove_vowels(\\"Hello, World!\\") \\"Hll, Wrld!\\" >>> remove_vowels(\\"Python Programming\\") \\"Pythn Prgrmmng\\"","solution":"def remove_vowels(S): Removes all vowels from the input string S and returns the resulting string. Vowels considered: a, e, i, o, u (both lowercase and uppercase) vowels = \\"aeiouAEIOU\\" result = ''.join([c for c in S if c not in vowels]) return result"},{"question":"from typing import List def is_valid_sequence(sequence: str) -> str: Determines if the sequence is valid based on the requirement that no character appears consecutively more than once. Returns \\"VALID\\" if the sequence is valid, and \\"INVALID\\" otherwise. # Insert implementation here def check_sequences(t: int, sequences: List[str]) -> List[str]: Check multiple sequences and return their validity. t: number of sequences sequences: list of sequences >>> check_sequences(3, [\\"abac\\", \\"aabb\\", \\"abcabc\\"]) ['VALID', 'INVALID', 'VALID'] >>> check_sequences(2, [\\"abba\\", \\"abcdefg\\"]) ['INVALID', 'VALID'] >>> check_sequences(1, [\\"a\\"]) ['VALID'] >>> check_sequences(1, [\\"aa\\"]) ['INVALID'] # Insert implementation here","solution":"def is_valid_sequence(sequence): Determines if the sequence is valid based on the requirement that no character appears consecutively more than once. Returns \\"VALID\\" if the sequence is valid, and \\"INVALID\\" otherwise. for i in range(1, len(sequence)): if sequence[i] == sequence[i - 1]: return \\"INVALID\\" return \\"VALID\\" def check_sequences(t, sequences): Check multiple sequences and return their validity. t: number of sequences sequences: list of sequences results = [] for sequence in sequences: results.append(is_valid_sequence(sequence)) return results"},{"question":"import math def is_perfect_square(n: int) -> bool: Check if a number is a perfect square. >>> is_perfect_square(1) True >>> is_perfect_square(4) True >>> is_perfect_square(9) True >>> is_perfect_square(10) False >>> is_perfect_square(15) False pass def sequence_product_or_not_all_perfect_squares(sequences: List[List[int]]) -> List[Union[int, str]]: Given a list of sequences, return the product of all elements in the sequence if all elements are perfect squares, otherwise return \\"Not All Perfect Squares\\". >>> sequence_product_or_not_all_perfect_squares([[1, 4, 9], [16, 49]]) [36, 784] >>> sequence_product_or_not_all_perfect_squares([[2, 3, 5], [16, 50], [1, 2, 4]]) [\\"Not All Perfect Squares\\", \\"Not All Perfect Squares\\", \\"Not All Perfect Squares\\"] >>> sequence_product_or_not_all_perfect_squares([ ... [1, 4, 9], [2, 3, 5], [16, 49], [4, 16, 29] ... ]) [36, \\"Not All Perfect Squares\\", 784, \\"Not All Perfect Squares\\"] pass","solution":"import math def is_perfect_square(n): Check if a number is a perfect square. return math.isqrt(n) ** 2 == n def sequence_product_or_not_all_perfect_squares(sequences): Given a list of sequences, return the product of all elements in the sequence if all elements are perfect squares, otherwise return \\"Not All Perfect Squares\\". results = [] for sequence in sequences: product = 1 all_perfect_squares = True for num in sequence: if is_perfect_square(num): product *= num else: all_perfect_squares = False break if all_perfect_squares: results.append(product) else: results.append(\\"Not All Perfect Squares\\") return results # Example usage: sequences = [ [1, 4, 9], [2, 3, 5], [16, 49] ] print(sequence_product_or_not_all_perfect_squares(sequences))"},{"question":"def count_sunset_views(buildings: List[int]) -> int: Returns the number of buildings with a clear view of the sunset. >>> count_sunset_views([4, 2, 3, 1]) 3 >>> count_sunset_views([3, 3, 3, 3]) 1 >>> count_sunset_views([5, 4, 3, 2, 1]) 5 >>> count_sunset_views([1, 2, 3, 4, 5]) 1 >>> count_sunset_views([3, 7, 8, 3, 6, 1]) 3 >>> count_sunset_views([5]) 1 >>> count_sunset_views([2, 1]) 2 >>> count_sunset_views([1, 2]) 1 >>> count_sunset_views(list(range(1, 100001))) 1","solution":"def count_sunset_views(buildings): Returns the number of buildings with a clear view of the sunset. # Initialize the count of buildings with sunset view count = 0 # Initialize the maximum height seen so far to zero max_height_so_far = 0 # Iterate through the buildings from right to left for height in reversed(buildings): # If the current building is taller than all buildings to its right if height > max_height_so_far: count += 1 max_height_so_far = height return count"},{"question":"def max_samples_collected(m: int, n: int, grid: List[List[int]]) -> int: Determine the maximum amount of samples the robot can collect from a grid. The robot starts from the top-left corner and can move either to the right or downwards to collect samples until it reaches the bottom-right corner. Example usage: >>> m, n = 3, 3 >>> grid = [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ] >>> print(max_samples_collected(m, n, grid)) 12","solution":"def max_samples_collected(m, n, grid): # Create a dp table to store the maximum samples collected up to each cell dp = [[0] * n for _ in range(m)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, m): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, m): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer is the value in the bottom-right cell return dp[m-1][n-1] # Example usage: # m, n = 3, 3 # grid = [ # [1, 3, 1], # [1, 5, 1], # [4, 2, 1] # ] # print(max_samples_collected(m, n, grid)) # Output: 12"},{"question":"from typing import List def max_subarray_sum(arr: List[int]) -> int: Find the maximum sum of any subarray of the given list. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 pass def process_test_cases(test_cases: List[List[int]]) -> List[int]: Process multiple test cases for the maximum subarray sum problem. >>> process_test_cases([[-2, 1, -3, 4, -1, 2, 1, -5, 4], [1, 2, 3, 4, 5]]) [6, 15] pass","solution":"def max_subarray_sum(arr): Find the maximum sum of any subarray of the given list. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(test_cases): Process multiple test cases for the maximum subarray sum problem. results = [] for arr in test_cases: results.append(max_subarray_sum(arr)) return results"},{"question":"import sys def find_hidden_number(): Determine the hidden number within the interval [1, 500] by asking up to 30 queries. Once found, print \\"even\\" if the number is even, or \\"odd\\" if the number is odd. Testing: >>> find_hidden_number() 1 2 ... 299 300 even pass def test_find_hidden_number(monkeypatch): from io import StringIO import sys # Simulate input for hidden number 300 test_input = \\"n\\".join([\\"no\\"] * 299 + [\\"yes\\"]) sys.stdin = StringIO(test_input) def mock_flush(): pass # Replace the stdout.flush function with a mock sys.stdout.flush = mock_flush output = StringIO() sys.stdout = output find_hidden_number() # Capture output output_lines = output.getvalue().strip().split(\\"n\\") queries = [int(line) for line in output_lines[:-1]] result = output_lines[-1] assert queries == list(range(1, 301)) assert result == \\"even\\" def test_find_hidden_number_odd(monkeypatch): from io import StringIO import sys # Simulate input for hidden number 299 test_input = \\"n\\".join([\\"no\\"] * 298 + [\\"yes\\"]) sys.stdin = StringIO(test_input) def mock_flush(): pass # Replace the stdout.flush function with a mock sys.stdout.flush = mock_flush output = StringIO() sys.stdout = output find_hidden_number() # Capture output output_lines = output.getvalue().strip().split(\\"n\\") queries = [int(line) for line in output_lines[:-1]] result = output_lines[-1] assert queries == list(range(1, 300)) assert result == \\"odd\\"","solution":"def find_hidden_number(): import sys input = sys.stdin.read data = input().split() for query_number in range(1, 501): print(query_number) sys.stdout.flush() response = data.pop(0) if response == \\"yes\\": if query_number % 2 == 0: print(\\"even\\") else: print(\\"odd\\") sys.stdout.flush() return # Note: The primary solution is designed to interact with an environment where it # communicates with another service to determine the hidden number. The function below # is not meant to be tested effectively with standard unit test frameworks as it requires # input/output interaction."},{"question":"def min_operations_to_equalize(arr: List[int]) -> int: Determine the minimum number of operations required to make all elements in the array equal. In each operation, you can select any three elements and increase exactly two of them by 1. If it is not possible to make all elements equal, return -1. >>> min_operations_to_equalize([3, 5, 7, 9]) 6 >>> min_operations_to_equalize([1, 2, 2]) -1","solution":"def min_operations_to_equalize(arr): n = len(arr) min_value = min(arr) # Calculate the number of operations required to reduce all elements to the minimum element def count_operations(x): ops = 0 for i in range(n): diff = arr[i] - x if diff % 2 != 0: return -1 ops += diff // 2 return ops result = count_operations(min_value) for i in range(1, 3): if min_value - i >= 0: temp_result = count_operations(min_value - i) if temp_result != -1: result = min(result, temp_result) return result"},{"question":"def next_permutation(nums): Rearranges the given list of numbers to the lexicographically next greater permutation. If such an arrangement is not possible, rearrange it as the lowest possible order. >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] pass # Implement the function here","solution":"def next_permutation(nums): Rearranges the given list of numbers to the lexicographically next greater permutation. If such an arrangement is not possible, rearrange it as the lowest possible order. n = len(nums) # Find the largest index k such that nums[k] < nums[k + 1] k = n - 2 while k >= 0 and nums[k] >= nums[k + 1]: k -= 1 if k == -1: # If no such k exists, the list is in descending order, so reverse it to get the smallest permutation nums.reverse() return nums # Find the largest index l greater than k such that nums[k] < nums[l] l = n - 1 while nums[k] >= nums[l]: l -= 1 # Swap nums[k] and nums[l] nums[k], nums[l] = nums[l], nums[k] # Reverse the sequence from nums[k + 1] nums[k + 1:] = reversed(nums[k + 1:]) return nums"},{"question":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_leaf_to_leaf_path(root): Returns the length of the longest path from one leaf to another leaf in the binary tree. if not root: return 0 def dfs(node): nonlocal diameter if not node: return 0 left_depth = dfs(node.left) right_depth = dfs(node.right) if node.left and node.right: diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 dfs(root) return diameter def test_empty_tree(): assert longest_leaf_to_leaf_path(None) == 0 def test_single_node_tree(): root = TreeNode(1) assert longest_leaf_to_leaf_path(root) == 0 def test_small_tree(): root = TreeNode(1, TreeNode(2), TreeNode(3)) assert longest_leaf_to_leaf_path(root) == 2 def test_small_unbalanced_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3)) assert longest_leaf_to_leaf_path(root) == 3 def test_larger_tree(): root = TreeNode(1, TreeNode(2, TreeNode(4, TreeNode(6)), TreeNode(5)), TreeNode(3)) assert longest_leaf_to_leaf_path(root) == 4","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def longest_leaf_to_leaf_path(root): Returns the length of the longest path from one leaf to another leaf in the binary tree. if not root: return 0 def dfs(node): nonlocal diameter if not node: return 0 left_depth = dfs(node.left) right_depth = dfs(node.right) if node.left and node.right: diameter = max(diameter, left_depth + right_depth) return max(left_depth, right_depth) + 1 diameter = 0 dfs(root) return diameter"},{"question":"def game_winner(s: str) -> str: Determines who will win the game given the initial string \`s\`. Returns 'Alice' if Alice wins the game, or 'Bob' if Bob wins the game. >>> game_winner(\\"ababa\\") 'Alice' >>> game_winner(\\"aabbcc\\") 'Bob' >>> game_winner(\\"abcabc\\") 'Bob' >>> game_winner(\\"aaabbb\\") 'Alice' >>> game_winner(\\"a\\") 'Alice' >>> game_winner(\\"aaaa\\") 'Bob' >>> game_winner(\\"abcde\\") 'Alice' >>> game_winner(\\"abacabadacaba\\") 'Alice'","solution":"def game_winner(s): Determines who will win the game given the initial string \`s\`. Returns 'Alice' if Alice wins the game, or 'Bob' if Bob wins the game. from collections import Counter # Count frequencies of each character freq = Counter(s) # If all characters appear an even number of times, Bob wins if all(v % 2 == 0 for v in freq.values()): return \\"Bob\\" # If there's any character that appears an odd number of times, Alice wins return \\"Alice\\""},{"question":"from typing import List def detect_brute_force_attempts(k: int, w: int, login_attempts: List[str]) -> List[int]: Detects potential brute force login attempts based on consecutive failures within a given time window. Args: - k: An integer representing the number of consecutive failures to consider. - w: An integer representing the time window in seconds. - login_attempts: A list of strings representing login attempts in the format 'timestamp user_id outcome'. Returns: - A list of user IDs that are flagged for suspected brute force attacks, sorted in ascending order. >>> detect_brute_force_attempts(3, 60, [\\"1 123 failure\\", \\"2 123 failure\\", \\"63 123 failure\\", \\"64 123 failure\\", \\"100 456 success\\"]) [123] >>> detect_brute_force_attempts(3, 60, [\\"1 123 failure\\", \\"2 123 success\\", \\"3 123 failure\\", \\"4 123 success\\"]) []","solution":"def detect_brute_force_attempts(k, w, login_attempts): from collections import defaultdict flagged_users = set() attempts_by_user = defaultdict(list) for attempt in login_attempts: timestamp, user_id, outcome = attempt.split() timestamp = int(timestamp) user_id = int(user_id) attempts_by_user[user_id].append((timestamp, outcome)) for user_id, attempts in attempts_by_user.items(): num_failures = 0 start_index = 0 for index, (timestamp, outcome) in enumerate(attempts): if outcome == 'failure': if index == 0 or attempts[index - 1][1] == 'success': start_index = index num_failures += 1 if num_failures >= k: if timestamp - attempts[start_index][0] <= w: flagged_users.add(user_id) break else: num_failures = 0 return sorted(flagged_users)"},{"question":"def max_coins(grid: List[List[int]]) -> int: Find the maximum number of coins Alex can collect moving from the top-left to the bottom-right corner of the grid. >>> max_coins([[0, 1, 4], [2, 8, 0], [1, 5, 3]]) 18 >>> max_coins([[5]]) 5 >>> max_coins([[0, 0], [0, 0]]) 0 >>> max_coins([[1, 2, 3]]) 6 >>> max_coins([[1], [2], [3]]) 6 >>> max_coins([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12","solution":"def max_coins(grid): N = len(grid) M = len(grid[0]) # Create a dp array with the same dimensions as grid dp = [[0] * M for _ in range(N)] # Initialize the dp array with the values from the grid dp[0][0] = grid[0][0] # Fill the first row of the dp array for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column of the dp array for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum number of coins Alex can collect return dp[N-1][M-1]"},{"question":"def find_final_coordinates(directions: str) -> (int, int): Given a string of directions, returns the final coordinates on a 2D plane starting from (0, 0). >>> find_final_coordinates(\\"LURD\\") (0, 0) >>> find_final_coordinates(\\"LLLL\\") (-4, 0) >>> find_final_coordinates(\\"RRRR\\") (4, 0) >>> find_final_coordinates(\\"UUUU\\") (0, 4) >>> find_final_coordinates(\\"DDDD\\") (0, -4) >>> find_final_coordinates(\\"LRUD\\") (0, 0) >>> find_final_coordinates(\\"LRRUDD\\") (1, -1) >>> find_final_coordinates(\\"ULDR\\") (0, 0) >>> find_final_coordinates(\\"UDDLRR\\") (1, -1) >>> find_final_coordinates(\\"\\") (0, 0)","solution":"def find_final_coordinates(directions): Given a string of directions, returns the final coordinates on a 2D plane starting from (0, 0). x, y = 0, 0 for direction in directions: if direction == 'L': x -= 1 elif direction == 'R': x += 1 elif direction == 'U': y += 1 elif direction == 'D': y -= 1 return (x, y)"},{"question":"from typing import List def min_time_to_complete_tasks(n: int, k: int, tasks: List[int]) -> int: Returns the minimum time required to complete all the tasks when distributed optimally among k workers. >>> min_time_to_complete_tasks(5, 2, [3, 1, 3, 2, 4]) 7 >>> min_time_to_complete_tasks(4, 3, [4, 2, 3, 1]) 4 >>> min_time_to_complete_tasks(7, 3, [10, 10, 10, 10, 10, 10, 10]) 30","solution":"def min_time_to_complete_tasks(n, k, tasks): Returns the minimum time required to complete all the tasks when distributed optimally among k workers. if k == 1: return sum(tasks) lo, hi = max(tasks), sum(tasks) while lo < hi: mid = (lo + hi) // 2 current_sum = 0 required_workers = 1 for task in tasks: if current_sum + task > mid: required_workers += 1 current_sum = 0 current_sum += task if required_workers > k: lo = mid + 1 else: hi = mid return lo"},{"question":"def reverse_words_and_sentence(sentence: str) -> str: This function takes a sentence, reverses the order of words, and then reverses each word individually. :param sentence: str: The input sentence where words are separated by a single space. :return: str: The modified sentence def process_sentences(t: int, sentences: list) -> list: Processes multiple sentences and applies the reverse_words_and_sentence function to each sentence. :param t: int: Number of test cases (sentences) :param sentences: list: List of sentences to process :return: list: List of processed sentences from solution import reverse_words_and_sentence, process_sentences def test_reverse_words_and_sentence(): assert reverse_words_and_sentence(\\"hello world\\") == \\"dlrow olleh\\" assert reverse_words_and_sentence(\\"programming is fun\\") == \\"nuf si gnimmargorp\\" assert reverse_words_and_sentence(\\"data structures and algorithms\\") == \\"smhtirogla dna serutcurts atad\\" assert reverse_words_and_sentence(\\"a b c\\") == \\"c b a\\" assert reverse_words_and_sentence(\\"single\\") == \\"elgnis\\" def test_process_sentences(): input_sentences = [ \\"hello world\\", \\"programming is fun\\", \\"data structures and algorithms\\" ] expected_output = [ \\"dlrow olleh\\", \\"nuf si gnimmargorp\\", \\"smhtirogla dna serutcurts atad\\" ] assert process_sentences(3, input_sentences) == expected_output input_sentences = [ \\"a b c\\", \\"single\\" ] expected_output = [ \\"c b a\\", \\"elgnis\\" ] assert process_sentences(2, input_sentences) == expected_output","solution":"def reverse_words_and_sentence(sentence: str) -> str: This function takes a sentence, reverses the order of words, and then reverses each word individually. :param sentence: str: The input sentence where words are separated by a single space. :return: str: The modified sentence words = sentence.split() reversed_word_order = words[::-1] reversed_words = [word[::-1] for word in reversed_word_order] return ' '.join(reversed_words) def process_sentences(t: int, sentences: list) -> list: Processes multiple sentences and applies the reverse_words_and_sentence function to each sentence. :param t: int: Number of test cases (sentences) :param sentences: list: List of sentences to process :return: list: List of processed sentences return [reverse_words_and_sentence(sentence) for sentence in sentences]"},{"question":"def min_difficulty_path(grid: List[List[int]]) -> int: Determine the minimum difficulty path in a 2D grid from top-left to bottom-right. >>> min_difficulty_path([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) 7 >>> min_difficulty_path([ ... [0] ... ]) 0 >>> min_difficulty_path([ ... [1, 2], ... [1, 1] ... ]) 3","solution":"def min_difficulty_path(grid): n = len(grid) m = len(grid[0]) # Initialize a dp array to store the minimum difficulty of reaching each cell dp = [[0] * m for _ in range(n)] # Set the difficulty of the starting point dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The answer is in the bottom-right corner of the dp array return dp[n - 1][m - 1]"},{"question":"def max_steal(house_values: List[int]) -> int: Determine the maximum amount of money a burglar can steal in one operation without stealing from two directly adjacent houses. Args: house_values (List[int]): List of integers representing the amount of money in each house. Returns: int: Maximum amount of money that can be stolen. >>> max_steal([2, 7, 9, 3, 1]) 12 >>> max_steal([3, 2, 5, 10]) 13 >>> max_steal([5]) 5 >>> max_steal([3, 10]) 10 >>> max_steal([50, 10]) 50 >>> max_steal([0, 0, 0, 0]) 0 >>> max_steal([1, 2, 3, 4, 5, 6]) 12 >>> max_steal([100, 1, 100, 1, 100, 1]) 300","solution":"def max_steal(house_values): Returns the maximum amount of money that can be stolen without stealing from two adjacent houses. n = len(house_values) if n == 0: return 0 if n == 1: return house_values[0] dp = [0] * n dp[0] = house_values[0] if n > 1: dp[1] = max(house_values[0], house_values[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + house_values[i]) return dp[-1]"},{"question":"from typing import List def num_paths(city: List[List[int]]) -> int: Determine the number of distinct paths for a robot to reach the bottom-right corner of a grid city without passing through buildings. Args: city (List[List[int]]): A 2D list of integers representing the city grid. Returns: int: The number of distinct paths from the top-left corner to the bottom-right corner of the grid. Examples: >>> num_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) 2 >>> num_paths([[0, 1], [1, 0]]) 0 >>> num_paths([[1, 0], [0, 0]]) 0 >>> num_paths([[0, 0], [0, 1]]) 0","solution":"def num_paths(city): rows = len(city) cols = len(city[0]) if city[0][0] == 1 or city[rows-1][cols-1] == 1: return 0 dp = [[0] * cols for _ in range(rows)] dp[0][0] = 1 for i in range(rows): for j in range(cols): if city[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[rows-1][cols-1]"},{"question":"def robot_return_to_origin(movements: str) -> str: Determines if the robot returns to the origin after executing the movements. Parameters: - movements (str): A string of characters 'L', 'R', 'U', 'D'. Returns: - str: \\"YES\\" if the robot returns to the origin, otherwise \\"NO\\". Examples: >>> robot_return_to_origin(\\"LRUD\\") == \\"YES\\" >>> robot_return_to_origin(\\"LL\\") == \\"NO\\" >>> robot_return_to_origin(\\"UUDDRRLL\\") == \\"YES\\"","solution":"def robot_return_to_origin(movements): Determines if the robot returns to the origin after executing the movements. Parameters: - movements (str): A string of characters 'L', 'R', 'U', 'D'. Returns: - str: \\"YES\\" if the robot returns to the origin, otherwise \\"NO\\". x, y = 0, 0 for move in movements: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def count_substrings_with_vowel(s: str) -> int: Returns the count of all contiguous substrings that contain at least one vowel. >>> count_substrings_with_vowel(\\"aba\\") 5 >>> count_substrings_with_vowel(\\"xyz\\") 0","solution":"def count_substrings_with_vowel(s): Returns the count of all contiguous substrings that contain at least one vowel. vowels = set('aeiou') count = 0 n = len(s) for i in range(n): for j in range(i + 1, n + 1): if any(char in vowels for char in s[i:j]): count += 1 return count"},{"question":"def rearrange_list(n, arr, x): Rearranges the list such that all numbers <= x come before numbers > x, maintaining the relative order of the numbers within each partition. Parameters: n (int): Number of elements in the list. arr (list of int): The list of integers. x (int): The pivot integer. Returns: list of int: The rearranged list. >>> rearrange_list(6, [3, 5, 2, 8, 1, 4], 4) [3, 2, 1, 4, 5, 8] >>> rearrange_list(7, [1, 7, 3, 6, 2, 5, 4], 3) [1, 3, 2, 7, 6, 5, 4]","solution":"def rearrange_list(n, arr, x): Rearranges the list such that all numbers <= x come before numbers > x, maintaining the relative order of the numbers within each partition. Parameters: n (int): Number of elements in the list. arr (list of int): The list of integers. x (int): The pivot integer. Returns: list of int: The rearranged list. less_than_or_equal = [num for num in arr if num <= x] greater_than = [num for num in arr if num > x] return less_than_or_equal + greater_than"},{"question":"def main(strings): Determine if it is possible to reorder and potentially reverse some of the strings to form a sequence where the last character of each string matches the first character of the next string in the sequence. Args: strings (List[str]): A list of strings consisting of lowercase English letters only (1 ≤ length of each string ≤ 1000). Returns: List[str]: \\"IMPOSSIBLE\\" if it is not possible to form the sequence; otherwise, \\"POSSIBLE\\" followed by the ordered list of strings. Example: >>> main([\\"abc\\", \\"cba\\", \\"bac\\", \\"abb\\"]) [\\"POSSIBLE\\", \\"abc\\", \\"cba\\", \\"abb\\", \\"bac\\"] >>> main([\\"a\\", \\"b\\", \\"c\\"]) \\"IMPOSSIBLE\\" # Your code here from solution import main def test_possible_case(): strings = [\\"abc\\", \\"cba\\", \\"bac\\", \\"abb\\"] result = main(strings) assert result[0] == \\"POSSIBLE\\" def test_impossible_case(): strings = [\\"a\\", \\"b\\", \\"c\\"] result = main(strings) assert result == \\"IMPOSSIBLE\\" def test_single_string(): strings = [\\"a\\"] result = main(strings) assert result == [\\"POSSIBLE\\", \\"a\\"] def test_reversible_case(): strings = [\\"abc\\", \\"cba\\", \\"baa\\"] result = main(strings) assert result[0] == \\"POSSIBLE\\" def test_possible_with_reversing(): strings = [\\"abc\\", \\"cbb\\", \\"bba\\"] result = main(strings) assert result[0] == \\"POSSIBLE\\"","solution":"def is_sequence_possible(strings): from collections import defaultdict, deque def can_form_sequence(start, strings): used = set() result = [] q = deque([(start, strings.index(start), False)]) q.extend([(s[::-1], i, True) for i, s in enumerate(strings) if s[::-1][0] == start[-1]]) while q: current, idx, reversed_flag = q.popleft() if idx in used: continue used.add(idx) result.append((current, reversed_flag)) for i, s in enumerate(strings): if i in used: continue if s[0] == current[-1]: q.append((s, i, False)) elif s[::-1][0] == current[-1]: q.append((s[::-1], i, True)) if len(result) == len(strings): return result return None for s in strings: res = can_form_sequence(s, strings) if res: returned_strings = [s if not rev else s[::-1] for s, rev in res] return \\"POSSIBLE\\", returned_strings return \\"IMPOSSIBLE\\", [] # Ensuring the helper function to use for testing def main(strings): status, result = is_sequence_possible(strings) if status == \\"IMPOSSIBLE\\": return \\"IMPOSSIBLE\\" else: return [\\"POSSIBLE\\"] + result"},{"question":"def can_insert_one_char(s1: str, s2: str) -> str: Returns \\"YES\\" if s1 can be made equal to s2 by inserting exactly one character at any position in s1. Otherwise returns \\"NO\\". # Your code here def process_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Processes multiple test cases. # Your code here # Sample unit tests def test_insert_one_right_position(): assert can_insert_one_char(\\"abc\\", \\"abac\\") == \\"YES\\" def test_insert_one_duplicate_char(): assert can_insert_one_char(\\"hello\\", \\"heello\\") == \\"YES\\" def test_cannot_insert_one(): assert can_insert_one_char(\\"code\\", \\"coed\\") == \\"NO\\" def test_result_for_multiple_cases(): test_cases = [ (\\"abc\\", \\"abac\\"), (\\"hello\\", \\"heello\\"), (\\"code\\", \\"coed\\") ] assert process_cases(test_cases) == [\\"YES\\", \\"YES\\", \\"NO\\"] def test_diff_length_greater_than_one(): assert can_insert_one_char(\\"abc\\", \\"abcde\\") == \\"NO\\" def test_equal_length(): assert can_insert_one_char(\\"abc\\", \\"abc\\") == \\"NO\\"","solution":"def can_insert_one_char(s1, s2): Returns \\"YES\\" if s1 can be made equal to s2 by inserting exactly one character at any position in s1. Otherwise returns \\"NO\\". if len(s2) - len(s1) != 1: return \\"NO\\" i, j = 0, 0 while i < len(s1) and j < len(s2): if s1[i] != s2[j]: if i != j: return \\"NO\\" j += 1 else: i += 1 j += 1 return \\"YES\\" def process_cases(test_cases): results = [] for s1, s2 in test_cases: results.append(can_insert_one_char(s1, s2)) return results"},{"question":"def staircase_climb_ways(n): Calculate the number of ways to climb a staircase with n steps, where you can take 1, 2, or 3 steps at a time. Also returns the time complexity of the solution in big-O notation. >>> staircase_climb_ways(4) (7, 'O(n)') >>> staircase_climb_ways(5) (13, 'O(n)') >>> staircase_climb_ways(1) (1, 'O(1)') >>> staircase_climb_ways(0) (0, 'O(1)') pass # Implement the function logic here def process_input_output(datasets): Process multiple datasets and output the number of ways to climb the staircase along with the time complexity. >>> process_input_output([4, 5, 0]) ['7 O(n)', '13 O(n)'] >>> process_input_output([1, 2, 3, 0]) ['1 O(1)', '2 O(1)', '4 O(1)'] pass # Implement the function logic here","solution":"def staircase_climb_ways(n): Calculates the number of ways to climb a staircase with n steps, where you can take 1, 2, or 3 steps at a time. Also returns the time complexity of the solution in big-O notation. if n == 0: return 0, 'O(1)' # If n is less than 3, we can use direct logic if n == 1: return 1, 'O(1)' elif n == 2: return 2, 'O(1)' elif n == 3: return 4, 'O(1)' # Initialize base cases dp = [0] * (n + 1) dp[1], dp[2], dp[3] = 1, 2, 4 # Fill dp array with number of ways to climb for i in range(4, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n], 'O(n)' def process_input_output(datasets): Process multiple datasets and output the number of ways to climb the staircase along with the time complexity. results = [] for n in datasets: if n == 0: break result = staircase_climb_ways(n) results.append(f\\"{result[0]} {result[1]}\\") return results"},{"question":"import math from typing import List, Tuple def gcd_lcm_pairs(input_pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Reads a list of integer pairs and computes their GCD and LCM. The input ends when a pair with a single zero is encountered. Args: input_pairs (list of tuples): List of integer pairs (a, b). Returns: list of tuples: Each tuple contains the GCD and LCM of the two integers. >>> gcd_lcm_pairs([(12, 18), (100, 25), (7, 13), (0, 0)]) [(6, 36), (25, 100), (1, 91)] >>> gcd_lcm_pairs([(0, 18), (25, 0), (0, 0)]) [(18, 0), (25, 0)] pass","solution":"import math def gcd_lcm_pairs(input_pairs): Reads a list of integer pairs and computes their GCD and LCM. The input ends when a pair with a single zero is encountered. Args: input_pairs (list of tuples): List of integer pairs (a, b). Returns: list of tuples: Each tuple contains the GCD and LCM of the two integers. results = [] for a, b in input_pairs: if a == 0 and b == 0: break gcd_val = math.gcd(a, b) lcm_val = abs(a * b) // gcd_val if a and b else 0 results.append((gcd_val, lcm_val)) return results"},{"question":"from typing import List def can_partition(nums: List[int]) -> List[List[int]]: Given a list of integers, determine if it can be divided into two non-empty subsets such that the sum of the elements in the two subsets is the same. If it's possible to divide the list into two subsets with equal sums, output the two subsets in separate lists. If there are multiple ways to divide the list, you may output any one of them. If such a division is not possible, return an empty list. >>> can_partition([1, 5, 11, 5, 7, 3]) [[1, 5, 5, 3], [11, 7]] >>> can_partition([1, 2, 3, 5]) [] # Your implementation here # Unit tests def test_can_partition_multiple_solutions(): nums = [1, 5, 11, 5, 7, 3] result = can_partition(nums) # Verifying not empty, correct partition assert len(result) == 2 assert sum(result[0]) == sum(result[1]) def test_can_partition_impossible(): nums = [1, 2, 3, 5] result = can_partition(nums) assert result == [] def test_can_partition_single_pair(): nums = [1, 1] result = can_partition(nums) assert len(result) == 2 assert sum(result[0]) == sum(result[1]) def test_can_partition_large_input(): nums = [1] * 1000 # Should be partitionable result = can_partition(nums) assert len(result) == 2 assert sum(result[0]) == sum(result[1]) def test_can_partition_no_solution(): nums = [2, 2, 2, 2, 6] result = can_partition(nums) assert result == []","solution":"def can_partition(nums): total_sum = sum(nums) # If the sum is odd, it cannot be partitioned into two equal sum subsets if total_sum % 2 != 0: return [] subset_sum = total_sum // 2 n = len(nums) # dp[i] will be True if a subset with sum i can be achieved dp = [False] * (subset_sum + 1) dp[0] = True for num in nums: for i in range(subset_sum, num - 1, -1): dp[i] = dp[i] | dp[i - num] # If subset_sum cannot be achieved, return empty list if not dp[subset_sum]: return [] # Trace back to find the elements which sum up to subset_sum subset1 = [] subset2 = nums.copy() current_sum = subset_sum for num in nums[::-1]: if current_sum >= num and dp[current_sum - num]: subset1.append(num) subset2.remove(num) current_sum -= num return [subset1, subset2] # Example usage: n = 6 nums = [1, 5, 11, 5, 7, 3] print(can_partition(nums)) # Output example: [[1, 5, 5, 3], [11, 7]]"},{"question":"def reorganize_warehouse(n, m, matrix): Determine whether the reorganization of the warehouse matrix is possible so that no two \\"good neighbors\\" are adjacent. If possible, print \\"YES\\" followed by the reorganized matrix. Otherwise, print \\"NO\\". Args: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. matrix (List[List[int]]): The warehouse matrix. Returns: None: Prints the result directly. Example: >>> reorganize_warehouse(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) YES 1 2 1 2 1 2 1 2 1 >>> reorganize_warehouse(1, 4, [[1, 2, 3, 4]]) NO from io import StringIO import sys def test_reorganize_warehouse(): # Test case 1 input_data = \\"3 3n1 2 3n4 5 6n7 8 9n\\" expected_output = \\"YESn1 2 1n2 1 2n1 2 1n\\" assert run_function_with_input(input_data) == expected_output # Test case 2 input_data = \\"2 2n1 2n3 4n\\" expected_output = \\"YESn1 2n2 1n\\" assert run_function_with_input(input_data) == expected_output # Test case 3 input_data = \\"1 4n1 2 3 4n\\" expected_output = \\"NOn\\" assert run_function_with_input(input_data) == expected_output def run_function_with_input(input_data): old_input = sys.stdin sys.stdin = StringIO(input_data) old_output = sys.stdout sys.stdout = StringIO() reorganize_warehouse(*map(int, input_data.split(\\"n\\")[0].split()), [list(map(int, row.split())) for row in input_data.strip().split(\\"n\\")[1:]]) output = sys.stdout.getvalue() sys.stdout = old_output sys.stdin = old_input return output","solution":"def reorganize_warehouse(n, m, matrix): def is_good_neighbor(a, b): return (a % 2 == b % 2) if n == 1 or m == 1: print(\\"NO\\") return new_matrix = [[0 for _ in range(m)] for _ in range(n)] for i in range(n): for j in range(m): if (i + j) % 2 == 0: new_matrix[i][j] = 1 else: new_matrix[i][j] = 2 print(\\"YES\\") for row in new_matrix: print(\\" \\".join(map(str, row)))"},{"question":"def shortest_substring_length(s: str, c: str, k: int) -> int: Returns the length of the shortest contiguous substring of s that contains at least k occurrences of the character c, or -1 if no such substring exists. >>> shortest_substring_length(\\"abcabcabca\\", \\"a\\", 3) 7 >>> shortest_substring_length(\\"hhehellohe\\", \\"h\\", 2) 2 >>> shortest_substring_length(\\"xxyzxzzyyy\\", \\"x\\", 4) -1 >>> shortest_substring_length(\\"aaaaaaa\\", \\"a\\", 4) 4 >>> shortest_substring_length(\\"abacabadabacaba\\", \\"b\\", 2) 5 pass def process_queries(queries: List[str]) -> List[int]: Processes a list of queries to find the length of the shortest contiguous substring of a given string that contains at least k occurrences of a specific character. >>> process_queries([\\"abcabcabca a 3\\", \\"hhehellohe h 2\\", \\"xxyzxzzyyy x 4\\", \\"aaaaaaa a 4\\", \\"abacabadabacaba b 2\\"]) [7, 2, -1, 4, 5] pass","solution":"def shortest_substring_length(s, c, k): Returns the length of the shortest contiguous substring of s that contains at least k occurrences of the character c, or -1 if no such substring exists. n = len(s) positions = [i for i, char in enumerate(s) if char == c] if len(positions) < k: return -1 min_length = float('inf') for i in range(len(positions) - k + 1): length = positions[i + k - 1] - positions[i] + 1 min_length = min(min_length, length) return min_length def process_queries(queries): results = [] for query in queries: s, c, k = query.split() k = int(k) result = shortest_substring_length(s, c, k) results.append(result) return results"},{"question":"from typing import List, Tuple def calculate_total_items(datasets: List[Tuple[int, int, int]]) -> List[int]: Calculate the total number of items a customer gets based on their purchases and the store's discount policy. Arguments: datasets -- a list of tuples containing the quantity of items bought, the minimum quantity required for the discount, and the percentage bonus. Returns: A list of integers representing the total number of items for each dataset. >>> calculate_total_items([(10, 5, 20), (18, 10, 50), (3, 5, 40), (0, 0, 0)]) [12, 27, 3] >>> calculate_total_items([(2, 5, 10), (3, 6, 20), (4, 7, 30), (0, 0, 0)]) [2, 3, 4] >>> calculate_total_items([(100, 50, 10), (200, 150, 25), (500, 499, 50), (0, 0, 0)]) [110, 250, 750] >>> calculate_total_items([(1, 1, 100), (1000, 1000, 100), (999, 1000, 0), (0, 0, 0)]) [2, 2000, 999] pass # TODO: Implement this function","solution":"def calculate_total_items(datasets): results = [] for Q, M, P in datasets: if Q == 0 and M == 0 and P == 0: break if Q >= M: bonus = (Q * P) // 100 else: bonus = 0 total_items = Q + bonus results.append(total_items) return results"},{"question":"from typing import List def find_shortest_path(n: int, m: int, grid: List[str]) -> int: Finds the shortest path from 'S' to 'X' in the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): The dungeon grid containing paths '.', walls '#', traps 'T', starting point 'S', and treasure 'X'. Returns: int: The length of the shortest path from 'S' to 'X', or -1 if no such path exists. >>> find_shortest_path(5, 5, [\\"S....\\", \\".#.#.\\", \\".#T#.\\", \\"...#X\\", \\".\\"]) 7 >>> find_shortest_path(3, 3, [\\"S#.\\", \\"X\\", \\"T..\\"]) -1 >>> find_shortest_path(3, 4, [\\"S..X\\", \\"....\\", \\"....\\"]) 3 >>> find_shortest_path(4, 4, [\\"S.#.\\", \\"...#\\", \\"#.#.\\", \\"..X.\\"]) 5 >>> find_shortest_path(2, 2, [\\"S#\\", \\"#X\\"]) -1","solution":"from collections import deque def find_shortest_path(n, m, grid): Finds the shortest path from 'S' to 'X' in the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[str]]): The dungeon grid containing paths '.', walls '#', traps 'T', starting point 'S', and treasure 'X'. Returns: int: The length of the shortest path from 'S' to 'X', or -1 if no such path exists. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Find the starting point 'S' start = None for r in range(n): for c in range(m): if grid[r][c] == 'S': start = (r, c) break if start: break if not start: return -1 # Initialize the queue for BFS queue = deque([(start, 0)]) # (cell, distance) visited = set() visited.add(start) while queue: (r, c), dist = queue.popleft() # Check if we have reached the treasure if grid[r][c] == 'X': return dist # Explore neighbors for dr, dc in directions: nr, nc = r + dr, c + dc # Check if the new position is valid and not visited if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited: if grid[nr][nc] == '.' or grid[nr][nc] == 'X': queue.append(((nr, nc), dist + 1)) visited.add((nr, nc)) return -1"},{"question":"def expected_layers(n: int, m: int, k: int, marked_cells: list) -> list: Computes the expected number of geological strata layers for marked cells. Args: n : int : size of the grid (n x n) m : int : maximum number of layers in any cell k : int : number of marked cells marked_cells : list of tuples : contains the (row, column) indices of the marked cells Returns: list of float : expected number of layers for each marked cell pass import pytest def test_example_1(): n = 3 m = 4 k = 2 marked_cells = [(1, 1), (2, 3)] expected_output = [2.5, 2.5] assert expected_layers(n, m, k, marked_cells) == expected_output def test_example_2(): n = 5 m = 10 k = 3 marked_cells = [(3, 3), (4, 4), (5, 2)] expected_output = [5.5, 5.5, 5.5] assert expected_layers(n, m, k, marked_cells) == expected_output def test_single_marked_cell(): n = 5 m = 20 k = 1 marked_cells = [(3, 3)] expected_output = [10.5] assert expected_layers(n, m, k, marked_cells) == expected_output def test_multiple_marked_cells(): n = 5 m = 50 k = 4 marked_cells = [(1, 1), (2, 2), (3, 3), (4, 4)] expected_output = [25.5, 25.5, 25.5, 25.5] assert expected_layers(n, m, k, marked_cells) == expected_output def test_minimum_values(): n = 1 m = 1 k = 1 marked_cells = [(1, 1)] expected_output = [1.0] assert expected_layers(n, m, k, marked_cells) == expected_output def test_large_values(): n = 300 m = 100000 k = 10 marked_cells = [(i, i) for i in range(1, 11)] # First 10 diagonal cells expected_output = [50000.5] * 10 assert expected_layers(n, m, k, marked_cells) == expected_output","solution":"def expected_layers(n, m, k, marked_cells): Computes the expected number of geological strata layers for marked cells. Args: n : int : size of the grid (n x n) m : int : maximum number of layers in any cell k : int : number of marked cells marked_cells : list of tuples : contains the (row, column) indices of the marked cells Returns: list of float : expected number of layers for each marked cell # The expected number of layers in any cell is the average of the uniform distribution expected_value = (1 + m) / 2 # The expected number of layers is the same for each marked cell return [expected_value] * k"},{"question":"import itertools import math from typing import List def max_triangle_area(points: List[tuple]) -> float: Find the maximum possible area of a non-degenerate triangle formed by any three points. >>> max_triangle_area([(0, 0), (0, 1), (1, 0), (1, 1)]) 0.5 >>> max_triangle_area([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]) \\"No triangle\\" def process_input(N: int, coordinates: List[int]) -> float: Process input data to calculate the maximum possible area of a non-degenerate triangle. >>> process_input(4, [0, 0, 0, 1, 1, 0, 1, 1]) 0.5 >>> process_input(5, [0, 0, 1, 0, 2, 0, 3, 0, 4, 0]) \\"No triangle\\" >>> process_input(3, [0, 0, 0, 1, 1, 0]) 0.5 >>> process_input(3, [0, 0, 1, 2, 2, 1]) 1.5 >>> process_input(3, [0, 0, 0, 2, 0, 5]) \\"No triangle\\" if __name__ == \\"__main__\\": import pytest pytest.main()","solution":"import itertools import math def max_triangle_area(points): def area(p1, p2, p3): return 0.5 * abs(p1[0] * (p2[1] - p3[1]) + p2[0] * (p3[1] - p1[1]) + p3[0] * (p1[1] - p2[1])) max_area = 0 for p1, p2, p3 in itertools.combinations(points, 3): max_area = max(max_area, area(p1, p2, p3)) return max_area def process_input(N, coordinates): points = [tuple(map(int, coordinates[i:i+2])) for i in range(0, 2*N, 2)] max_area = max_triangle_area(points) if max_area > 0: return round(max_area, 2) else: return \\"No triangle\\""},{"question":"def sieve_of_eratosthenes(n): Returns a list of primes <= n using the Sieve of Eratosthenes algorithm. def sum_of_primes_up_to_n(n): Returns the sum of all prime numbers less than or equal to n. def solve_primes_sums(test_cases): Given a list of test cases with values of N, returns a list of sums of all prime numbers less than or equal to each N. >>> solve_primes_sums([10]) == [17] >>> solve_primes_sums([10, 100]) == [17, 1060] >>> solve_primes_sums([1]) == [0] >>> solve_primes_sums([2]) == [2] >>> solve_primes_sums([1000000]) == [37550402023]","solution":"def sieve_of_eratosthenes(n): Returns a list of primes <= n using the Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, n + 1) if is_prime[p]] return prime_numbers def sum_of_primes_up_to_n(n): Returns the sum of all prime numbers less than or equal to n. primes = sieve_of_eratosthenes(n) return sum(primes) def solve_primes_sums(test_cases): Given a list of test cases with values of N, returns a list of sums of all prime numbers less than or equal to each N. result = [] for n in test_cases: result.append(sum_of_primes_up_to_n(n)) return result"},{"question":"def min_units_to_add(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Mira the magician has N distinct magical stones, each with a particular power level. She wants to increase the power levels of the stones such that their sum becomes exactly divisible by an integer K. To achieve this, she can increase the power level of any stone by X units of power, where X is a non-negative integer. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, where each tuple contains a tuple \`(N, K)\` and a list of integers representing the power levels of the stones. Returns: A list of integers, where each integer is the minimum number of units of power that need to be added to make the sum of all power levels exactly divisible by K. >>> min_units_to_add(2, [((3, 5), [10, 12, 15]), ((4, 7), [1, 2, 3, 4])]) [3, 4] >>> min_units_to_add(1, [((5, 10), [1, 2, 3, 4, 5])]) [5] >>> min_units_to_add(1, [((3, 1), [5, 5, 5])]) [0] >>> min_units_to_add(1, [((6, 10), [7, 7, 7, 7, 7, 7])]) [8] >>> min_units_to_add(1, [((10, 3), [1, 1, 1, 1, 1, 1, 1, 1, 1, 1])]) [2]","solution":"def min_units_to_add(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] power_levels = test_cases[i][1] total_power = sum(power_levels) remainder = total_power % K if remainder == 0: results.append(0) else: results.append(K - remainder) return results"},{"question":"def max_non_overlapping_subarrays(arr: List[int], k: int) -> int: Return the maximum number of non-overlapping subarrays with sum equal to k. >>> max_non_overlapping_subarrays([1, 2, 3, 2, 1, 2, 3], 5) 2 >>> max_non_overlapping_subarrays([1, 2, 3, 4, 5], 6) 1 >>> max_non_overlapping_subarrays([1, 2, 3, 4, 5], 50) 0 >>> max_non_overlapping_subarrays([10**9, -(10**9), 10**9], 10**9) 2 >>> max_non_overlapping_subarrays([-1, -2, -3, -4, -5], -6) 1 >>> max_non_overlapping_subarrays([], 0) 0 >>> max_non_overlapping_subarrays([3, 3, 3, 3, 3], 3) 5","solution":"def max_non_overlapping_subarrays(arr, k): Return the maximum number of non-overlapping subarrays with sum equal to k. count = 0 current_sum = 0 seen_sums = {0} for num in arr: current_sum += num if (current_sum - k) in seen_sums: count += 1 current_sum = 0 seen_sums = {0} else: seen_sums.add(current_sum) return count def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) arr = list(map(int, data[2:n+2])) print(max_non_overlapping_subarrays(arr, k)) if __name__ == \\"__main__\\": main()"},{"question":"def decode_message(codes: dict, encoded_string: str) -> str: Decodes the encoded_string using the provided dictionary of codes. Parameters: codes (dict): A dictionary where keys are numeric codes as strings and values are corresponding phrases. encoded_string (str): A string of concatenated numeric codes to decode. Returns: str: The decoded message. >>> decode_message({'1': 'hello', '2': 'world'}, '12') == 'hello world' >>> decode_message({'101': 'cat', '11': 'dog', '100': 'bird'}, '10111100') == 'cat dog bird' # Your code here def process_test_cases(test_cases: list) -> list: Processes multiple test cases for decoding messages. Parameters: test_cases (list): A list of test cases, where each test case is a tuple (codes, encoded_string). Returns: list: A list of decoded messages for each test case. >>> process_test_cases([({'1': 'hello', '2': 'world'}, '12'), ({'101': 'cat', '11': 'dog', '100': 'bird'}, '10111100')]) == ['hello world', 'cat dog bird'] # Your code here","solution":"def decode_message(codes, encoded_string): Decodes the encoded_string using the provided dictionary of codes. Parameters: codes (dict): A dictionary where keys are numeric codes as strings and values are corresponding phrases. encoded_string (str): A string of concatenated numeric codes to decode. Returns: str: The decoded message. decoded_words = [] i = 0 while i < len(encoded_string): for code in codes: if encoded_string.startswith(code, i): decoded_words.append(codes[code]) i += len(code) break return ' '.join(decoded_words) def process_test_cases(test_cases): Processes multiple test cases for decoding messages. Parameters: test_cases (list): A list of test cases, where each test case is a tuple (codes, encoded_string). Returns: list: A list of decoded messages for each test case. results = [] for codes, encoded_string in test_cases: results.append(decode_message(codes, encoded_string)) return results"},{"question":"from typing import List, Tuple def is_prime(num: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False # (Implementation needed) def count_beautiful_subarrays(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Function to count the number of beautiful subarrays for each test case. >>> count_beautiful_subarrays(1, [(4, [1, 2, 3, 4])]) [5] >>> count_beautiful_subarrays(2, [(4, [1, 2, 3, 4]), (5, [2, 3, 5, 7, 11])]) [5, 8] # (Implementation needed) def main(input_text: str) -> List[int]: Main function to handle input and output format. >>> main(\\"2n4n1 2 3 4n5n2 3 5 7 11\\") [5, 8] # (Implementation needed)","solution":"def is_prime(num): Helper function to check if a number is prime. if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def count_beautiful_subarrays(t, test_cases): Function to count the number of beautiful subarrays for each test case. results = [] for case in test_cases: n, arr = case beautiful_count = 0 # Iterate over all subarrays for i in range(n): subarray_sum = 0 for j in range(i, n): subarray_sum += arr[j] if is_prime(subarray_sum): beautiful_count += 1 results.append(beautiful_count) return results def main(input_text): lines = input_text.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((n, arr)) index += 2 return count_beautiful_subarrays(t, test_cases)"},{"question":"def can_sort_crystals(n: int, k: int, crystals: List[int]) -> str: Determines if the crystals can be sorted in non-decreasing order using at most k swaps. Parameters: n (int): The number of crystals. k (int): The maximum number of swaps allowed. crystals (list of int): The power values of the crystals. Returns: str: \\"YES\\" if it's possible to sort within k swaps, otherwise \\"NO\\". Examples: >>> can_sort_crystals(5, 2, [5, 3, 1, 4, 2]) 'NO' >>> can_sort_crystals(4, 3, [4, 3, 2, 1]) 'YES' >>> can_sort_crystals(3, 1, [3, 1, 2]) 'NO'","solution":"def can_sort_crystals(n, k, crystals): Determines if the crystals can be sorted in non-decreasing order using at most k swaps. Parameters: n (int): The number of crystals. k (int): The maximum number of swaps allowed. crystals (list of int): The power values of the crystals. Returns: str: \\"YES\\" if it's possible to sort within k swaps, otherwise \\"NO\\". # Create a list of tuples where each tuple is (crystal_power, original_index) indexed_crystals = list(enumerate(crystals)) # Sort the indexed crystals by the power value sorted_crystals = sorted(indexed_crystals, key=lambda x: x[1]) # Dictionary to map the original position to final sorted position position_map = {original_index: i for i, (original_index, _) in enumerate(sorted_crystals)} # Initialize variables for visited nodes and cycle count visited = [False] * n cycle_count = 0 # Count cycles in the permutation represented by position_map for i in range(n): if not visited[i]: # Found the start of a cycle cycle_length = 0 current = i while not visited[current]: visited[current] = True current = position_map[current] cycle_length += 1 # If cycle length is more than 1, we need (cycle_length - 1) swaps to sort it if cycle_length > 1: cycle_count += (cycle_length - 1) # Check if the total required swaps is within the allowed number of swaps if cycle_count <= k: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_treasures_collected(M: int, N: int, grid: List[List[int]]) -> int: Calculate the maximum number of treasures the two hunters can collect in a rectangular grid. >>> max_treasures_collected(3, 3, [ ... [1, 1, 1], ... [0, 1, 0], ... [1, 0, 1]]) 5 >>> max_treasures_collected(4, 4, [ ... [1, 0, 0, 1], ... [0, 0, 1, 0], ... [1, 0, 1, 1], ... [0, 1, 1, 0]]) 7","solution":"def max_treasures_collected(M, N, grid): dp = [[[0 for _ in range(N)] for _ in range(N)] for _ in range(2)] for i in range(M): current = i % 2 prev = 1 - current for j1 in range(N): for j2 in range(N): if grid[i][j1] == 0 and grid[i][j2] == 0: dp[current][j1][j2] = dp[prev][j1][j2] elif j1 == j2: dp[current][j1][j2] = max(dp[prev][x][y] for x in range(max(0, j1 - 1), min(N, j1 + 2)) for y in range(max(0, j2 - 1), min(N, j2 + 2))) if i > 0: dp[current][j1][j2] += grid[i][j1] elif grid[i][j1] == 1 and grid[i][j2] == 1: dp[current][j1][j2] = max(dp[prev][x][y] for x in range(max(0, j1 - 1), min(N, j1 + 2)) for y in range(max(0, j2 - 1), min(N, j2 + 2))) if i > 0: dp[current][j1][j2] += 2 else: dp[current][j1][j2] = 2 elif grid[i][j1] == 1 or grid[i][j2] == 1: dp[current][j1][j2] = max(dp[prev][x][y] for x in range(max(0, j1 - 1), min(N, j1 + 2)) for y in range(max(0, j2 - 1), min(N, j2 + 2))) if i > 0: dp[current][j1][j2] += 1 result = 0 for j1 in range(N): for j2 in range(N): result = max(result, dp[(M - 1) % 2][j1][j2]) return result M = 4 N = 4 grid = [ [1, 0, 0, 1], [0, 0, 1, 0], [1, 0, 1, 1], [0, 1, 1, 0] ] print(max_treasures_collected(M, N, grid)) # Output: 7"},{"question":"def classify_books(n, titles): Classifies a list of book titles into subject sets based on training data of book title frequencies. Args: n (int): Number of book titles to classify. titles (List[str]): List of book titles to classify. Returns: List[int]: List of integers representing the predicted subject of each book title. >>> result = classify_books(3, [\\"data mining techniques\\", \\"ancient history of rome\\", \\"modern physics for engineers\\"]) >>> result [1, 3, 2] # Load training data and build word to subject map (mock example) def load_training_data(): pass def build_word_subject_map(training_data): pass def predict_subject(title, word_subject_map): pass training_data = load_training_data() word_subject_map = build_word_subject_map(training_data) results = [] for title in titles: subject = predict_subject(title, word_subject_map) results.append(subject) return results","solution":"from collections import defaultdict, Counter import os def load_training_data(): training_data = defaultdict(list) for i in range(1, 6): directory = str(i) for filename in os.listdir(directory): filepath = os.path.join(directory, filename) with open(filepath, 'r') as file: titles = file.readlines() training_data[i].extend([title.strip() for title in titles]) return training_data def build_word_subject_map(training_data): word_subject_map = defaultdict(Counter) for subject, titles in training_data.items(): for title in titles: words = title.split() for word in words: word_subject_map[word][subject] += 1 return word_subject_map def predict_subject(title, word_subject_map): words = title.split() subject_score = Counter() for word in words: if word in word_subject_map: subject_score.update(word_subject_map[word]) if subject_score: return subject_score.most_common(1)[0][0] else: return 1 # Default to subject 1 if no words match def classify_books(n, titles): training_data = load_training_data() word_subject_map = build_word_subject_map(training_data) results = [] for title in titles: subject = predict_subject(title, word_subject_map) results.append(subject) return results"},{"question":"def calculate_total_cost(items: str) -> int: Calculates the total cost of all items described in the input string. Parameters: items (str): The compact descriptions of items (e.g., \\"appleQ2P30\\") Returns: int: Total cost of all items >>> calculate_total_cost(\\"appleQ2P30\\") 60 >>> calculate_total_cost(\\"appleQ2P30bananaQ5P100grapeQ1P50\\") 610 >>> calculate_total_cost(\\"appleQ2P30appleQ3P20\\") 120 >>> calculate_total_cost(\\"appleQ1000P10000\\") 10000000 >>> calculate_total_cost(\\"appleQ2P30bananaQ5P100orangeQ10P15grapeQ1P50\\") 760 >>> calculate_total_cost(\\"\\") 0 >>> calculate_total_cost(\\"fruitQ123P456\\") 56088","solution":"def calculate_total_cost(items): Calculates the total cost of all items described in the input string. Parameters: items (str): The compact descriptions of items (e.g., \\"appleQ2P30\\") Returns: int: Total cost of all items import re pattern = r\\"([a-z]+)Q(d+)P(d+)\\" matches = re.findall(pattern, items) total_cost = 0 for match in matches: name, quantity, price = match quantity = int(quantity) price = int(price) total_cost += quantity * price return total_cost"},{"question":"def distribute_dishes(n: int, m: int) -> List[int]: Distribute n dishes to m guests such that each guest gets at least one dish and the difference between any two guests' number of dishes is not more than 1. Inputs: n (int): Number of dishes m (int): Number of guests Outputs: List[int]: A list of integers representing the number of dishes each guest will receive, in non-decreasing order. >>> distribute_dishes(7, 3) [2, 2, 3] >>> distribute_dishes(5, 5) [1, 1, 1, 1, 1] >>> distribute_dishes(9, 2) [4, 5]","solution":"def distribute_dishes(n, m): Distribute n dishes to m guests such that each guest gets at least one dish and the difference between any two guests' number of dishes is not more than 1. base_count = n // m extra_count = n % m distribution = [base_count] * m for i in range(extra_count): distribution[i] += 1 return sorted(distribution)"},{"question":"def find_top_participant(n: int, scores: List[List[int]]) -> int: Returns the ID of the participant with the highest single-category score. In case of a tie, returns the smallest ID among those tied. :param n: Integer, number of participants :param scores: List of lists of integers, each containing scores in categories for each participant :return: Integer, ID of the top participant Examples: >>> find_top_participant(3, [[3, 5, 2], [4, 7], [5, 5, 5]]) 2 >>> find_top_participant(4, [[1, 6, 3], [10], [5, 8], [8]]) 2","solution":"def find_top_participant(n, scores): Returns the ID of the participant with the highest single-category score. In case of a tie, returns the smallest ID among those tied. :param n: Integer, number of participants :param scores: List of lists of integers, each containing scores in categories for each participant :return: Integer, ID of the top participant max_score = -1 winner_id = -1 for i in range(n): participant_best_score = max(scores[i]) if participant_best_score > max_score or (participant_best_score == max_score and (winner_id == -1 or i + 1 < winner_id)): max_score = participant_best_score winner_id = i + 1 return winner_id"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def find_minimum_roads(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the minimum number of roads required to make the communication system complete. >>> find_minimum_roads(4, 2, [(1, 2), (3, 4)]) 1 >>> find_minimum_roads(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> find_minimum_roads(1, 0, []) 0 >>> find_minimum_roads(2, 0, []) 1 >>> find_minimum_roads(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 0 >>> find_minimum_roads(7, 4, [(1, 2), (2, 3), (4, 5), (6, 7)]) 2","solution":"from collections import defaultdict, deque def find_minimum_roads(n, m, roads): graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) components = 0 for city in range(1, n + 1): if not visited[city]: bfs(city) components += 1 return components - 1"},{"question":"import math from typing import List def can_be_expressed_as_sum_of_two_squares(n: int) -> str: Checks if a given integer n can be expressed as the sum of two squares. >>> can_be_expressed_as_sum_of_two_squares(5) 'YES' >>> can_be_expressed_as_sum_of_two_squares(8) 'YES' >>> can_be_expressed_as_sum_of_two_squares(13) 'YES' >>> can_be_expressed_as_sum_of_two_squares(7) 'NO' def process_test_cases(T: int, cases: List[int]) -> List[str]: Processes multiple test cases. >>> process_test_cases(3, [5, 8, 13]) ['YES', 'YES', 'YES'] >>> process_test_cases(4, [4, 7, 10, 18]) ['YES', 'NO', 'YES', 'YES'] >>> process_test_cases(1, [0]) ['YES']","solution":"import math def can_be_expressed_as_sum_of_two_squares(n): Checks if a given integer n can be expressed as the sum of two squares. for i in range(int(math.isqrt(n)) + 1): remaining = n - i * i if remaining >= 0 and int(math.isqrt(remaining))**2 == remaining: return \\"YES\\" return \\"NO\\" def process_test_cases(T, cases): Processes multiple test cases. results = [] for n in cases: results.append(can_be_expressed_as_sum_of_two_squares(n)) return results"},{"question":"def process_transactions(T: int, clients_data: List[str]) -> str: Process a series of transactions for multiple clients and return the final balance and transaction summary for each client. Args: T (int): The number of clients. clients_data (List[str]): The transaction data for each client in the format of \\"[client_id, num_transactions, transaction1, transaction2, ...\\", ...] Returns: str: The final balance and transaction summary for each client. Examples: >>> process_transactions(3, [\\"clientA\\", \\"5\\", \\"deposit 1000\\", \\"withdrawal 300\\", \\"deposit 500\\", \\"withdrawal 200\\", \\"deposit 300\\", \\"clientB\\", \\"3\\", \\"deposit 200\\", \\"withdrawal 100\\", \\"withdrawal 100\\", \\"clientC\\", \\"4\\", \\"deposit 4000\\", \\"withdrawal 1000\\", \\"deposit 5000\\", \\"withdrawal 2000\\"]) 'clientAnBalance: 1300nTransactions:ndeposit 1000nwithdrawal 300ndeposit 500nwithdrawal 200ndeposit 300nnclientBnBalance: 0nTransactions:ndeposit 200nwithdrawal 100nwithdrawal 100nnclientCnBalance: 6000nTransactions:ndeposit 4000nwithdrawal 1000ndeposit 5000nwithdrawal 2000' >>> process_transactions(1, [\\"clientD\\", \\"2\\", \\"deposit 500\\", \\"withdrawal 200\\"]) 'clientDnBalance: 300nTransactions:ndeposit 500nwithdrawal 200' import re assert process_transactions(3, [\\"clientA\\", \\"5\\", \\"deposit 1000\\", \\"withdrawal 300\\", \\"deposit 500\\", \\"withdrawal 200\\", \\"deposit 300\\", \\"clientB\\", \\"3\\", \\"deposit 200\\", \\"withdrawal 100\\", \\"withdrawal 100\\", \\"clientC\\", \\"4\\", \\"deposit 4000\\", \\"withdrawal 1000\\", \\"deposit 5000\\", \\"withdrawal 2000\\"]) == 'clientAnBalance: 1300nTransactions:ndeposit 1000nwithdrawal 300ndeposit 500nwithdrawal 200ndeposit 300nnclientBnBalance: 0nTransactions:ndeposit 200nwithdrawal 100nwithdrawal 100nnclientCnBalance: 6000nTransactions:ndeposit 4000nwithdrawal 1000ndeposit 5000nwithdrawal 2000' assert process_transactions(1, [\\"clientD\\", \\"2\\", \\"deposit 500\\", \\"withdrawal 200\\"]) == 'clientDnBalance: 300nTransactions:ndeposit 500nwithdrawal 200'","solution":"def process_transactions(T, clients_data): clients_summary = [] index = 0 for i in range(T): client_id = clients_data[index] index += 1 N = int(clients_data[index]) index += 1 balance = 0 transactions = [] for _ in range(N): transaction = clients_data[index] index += 1 t_type, amount = transaction.split() amount = int(amount) if t_type == 'deposit': balance += amount elif t_type == 'withdrawal': balance -= amount transactions.append(transaction) summary = f\\"{client_id}n\\" summary += f\\"Balance: {balance}n\\" summary += \\"Transactions:n\\" summary += \\"n\\".join(transactions) clients_summary.append(summary) return \\"nn\\".join(clients_summary)"},{"question":"def min_swaps_to_group_ones(n: int, k: int, arr: List[int]) -> int: Returns the minimum number of swaps required to group all 1's in the array together. >>> min_swaps_to_group_ones(7, 3, [1, 0, 1, 0, 1, 0, 0]) 1 >>> min_swaps_to_group_ones(7, 2, [1, 0, 1, 0, 1, 1, 0]) 0 >>> min_swaps_to_group_ones(7, 3, [1, 1, 1, 1, 1, 0, 0]) 0 >>> min_swaps_to_group_ones(7, 3, [1, 0, 0, 0, 0, 0, 1]) -1 >>> min_swaps_to_group_ones(5, 1, [1, 0, 0, 0, 1]) 0 >>> min_swaps_to_group_ones(6, 2, [0, 0, 0, 1, 1, 0]) 0 >>> min_swaps_to_group_ones(4, 2, [1, 0, 0, 1]) 1","solution":"def min_swaps_to_group_ones(n, k, arr): Returns the minimum number of swaps required to group all 1's in the array together. # Calculate the number of 1's in the given array count_ones = sum(arr) # If there are less 1's in array than k, it's impossible to group k 1's together if count_ones < k: return -1 # Use a sliding window to determine the maximum number of 1's in any window/subarray of size k max_ones_in_window = 0 current_ones_in_window = 0 # Initialize the first window for i in range(k): if i < n: current_ones_in_window += arr[i] max_ones_in_window = current_ones_in_window # Slide the window from left to right for i in range(k, n): current_ones_in_window += arr[i] current_ones_in_window -= arr[i - k] if current_ones_in_window > max_ones_in_window: max_ones_in_window = current_ones_in_window # The number of swaps needed is the difference between k and the maximum number of 1's in such a window return k - max_ones_in_window"},{"question":"from typing import List def is_path_possible(n: int, m: int, grid: List[str]) -> str: Determines if there's a clear path from the starting position (0, 0) to the target position (n-1, m-1). >>> is_path_possible(4, 4, ['....', '...#', '..#.', '....']) \\"YES\\" >>> is_path_possible(4, 4, ['#.', '.#..', '#...', '..']) \\"NO\\" >>> is_path_possible(6, 5, ['.....', '.', '.#...', '.#.', '....#', '.....']) \\"YES\\" >>> is_path_possible(4, 4, ['#...', '....', '....', '....']) \\"NO\\" >>> is_path_possible(4, 4, ['....', '....', '....', '...#']) \\"NO\\" >>> is_path_possible(3, 3, ['...', '#..', '...']) \\"YES\\"","solution":"def is_path_possible(n, m, grid): from collections import deque if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"def three_sum_exists(nums: List[int], target: int) -> bool: Determine if there exists any three distinct elements in the list that add up to a target sum. >>> three_sum_exists([1, 2, 3, 4, 5, 6], 10) True >>> three_sum_exists([1, 2, 3, 4, 5, 6], 20) False >>> three_sum_exists([1, 1, 1, 1, 1], 10) False >>> three_sum_exists([1, 2, 2, 3, 4], 9) True >>> three_sum_exists([100000, 99999, 99998, 1, 2, 3], 200002) True >>> three_sum_exists([1, 2, 4, 5, 6], 15) True >>> three_sum_exists([1, 3, 5, 7], 25) False >>> three_sum_exists([0, 1, 2, 3, 4, 5], 6) True","solution":"from typing import List def three_sum_exists(nums: List[int], target: int) -> bool: nums.sort() n = len(nums) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def largest_rectangle_area(heights: List[int]) -> int: Calculate the largest rectangle area in a histogram, where heights represent the histogram's bar heights. Args: heights (List[int]): List of heights of the buildings. Returns: int: The maximum area of a rectangle that can be formed. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3, 4]) 10 >>> largest_rectangle_area([1, 2, 3, 4, 5]) 9 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12 >>> largest_rectangle_area([1]) 1 >>> largest_rectangle_area([4, 2]) 4 pass def process_test_cases(t: int, test_cases: List[List[int]]) -> List[int]: Process multiple test cases, each with a corresponding list of building heights. Args: t (int): Number of test cases test_cases (List[List[int]]): List of test case lists, each containing the heights of the buildings Returns: List[int]: List of the maximum rectangle areas for each test case. >>> process_test_cases(3, [[2, 1, 5, 6, 2, 3, 4], [1, 2, 3, 4, 5], [6, 2, 5, 4, 5, 1, 6]]) [10, 9, 12] >>> process_test_cases(2, [[1, 1, 1, 1], [2, 1, 2]]) [4, 3] >>> process_test_cases(1, [[7, 6, 5]]) [15] pass","solution":"def largest_rectangle_area(heights): This function calculates the largest rectangle area in a histogram, where heights represent the histogram's bar heights. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def process_test_cases(t, test_cases): Process multiple test cases. results = [] for heights in test_cases: results.append(largest_rectangle_area(heights)) return results"},{"question":"from typing import List def wordSearch(matrix: List[List[str]], words: List[str]) -> List[bool]: Determines if each word in the list of words exists in the given matrix of characters. A word is said to exist in the matrix if it can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are those horizontally, vertically, or diagonally neighboring. The same letter in the matrix cell may not be used more than once within a single word. >>> matrix = [ ... ['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e'] ... ] >>> words = [\\"abcced\\", \\"see\\", \\"abcb\\", \\"abfde\\"] >>> wordSearch(matrix, words) [True, True, False, True] >>> matrix = [ ... ['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e'] ... ] >>> words = [\\"xyz\\"] >>> wordSearch(matrix, words) [False] >>> matrix = [ ... ['a', 'b', 'c', 'e'], ... ['s', 'f', 'c', 's'], ... ['a', 'd', 'e', 'e'] ... ] >>> words = [] >>> wordSearch(matrix, words) [] >>> matrix = [] >>> words = [\\"abc\\"] >>> wordSearch(matrix, words) [False] >>> matrix = [ ... ['a'] ... ] >>> words = [\\"a\\", \\"b\\"] >>> wordSearch(matrix, words) [True, False] >>> matrix = [['a' for _ in range(100)] for _ in range(100)] >>> words = [\\"a\\" * 10, \\"b\\" * 10] >>> wordSearch(matrix, words) [True, False]","solution":"def wordSearch(matrix, words): def dfs(matrix, word, index, x, y, visited): if index == len(word): return True if x < 0 or x >= len(matrix) or y < 0 or y >= len(matrix[0]): return False if (x, y) in visited or matrix[x][y] != word[index]: return False visited.add((x, y)) for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]: if dfs(matrix, word, index + 1, x + dx, y + dy, visited): return True visited.remove((x, y)) return False def exist(matrix, word): for i in range(len(matrix)): for j in range(len(matrix[0])): if dfs(matrix, word, 0, i, j, set()): return True return False return [exist(matrix, word) for word in words]"},{"question":"def min_absolute_difference(n: int, t: int, sweetness_levels: List[int]) -> int: Find the minimum absolute difference between the sum of selected candies' sweetness levels and the given target t. >>> min_absolute_difference(5, 10, [1, 2, 3, 4, 5]) 0 >>> min_absolute_difference(3, 7, [8, 5, 3]) 1","solution":"def min_absolute_difference(n, t, sweetness_levels): dp = {0} for candy in sweetness_levels: new_dp = dp.copy() for total in dp: new_dp.add(total + candy) dp = new_dp min_diff = abs(t) for total in dp: min_diff = min(min_diff, abs(t - total)) return min_diff"},{"question":"def minimal_travel_cost(n: int, costs: List[int]) -> int: Given the number of islands n and the costs for each bridge, this function returns the minimal travel cost between any two islands in the archipelago. n: int, number of islands costs: List[int], cost of each bridge Returns: int, the minimal travel cost between any two islands >>> minimal_travel_cost(5, [4, 3, 10, 5, 2]) 2 >>> minimal_travel_cost(4, [1, 2, 3, 1]) 1","solution":"def minimal_travel_cost(n, costs): Given the number of islands n and the costs for each bridge, this function returns the minimal travel cost between any two islands in the archipelago. n: int, number of islands costs: List[int], cost of each bridge Returns: int, the minimal travel cost between any two islands return min(costs)"},{"question":"def remaining_animals(G: int, S: int, D: int) -> (int, int): Function to compute the number of goats and sheep remaining after D days. Parameters: G (int): initial number of goats S (int): initial number of sheep D (int): number of days actions are performed Returns: tuple: remaining number of goats and sheep Examples: >>> remaining_animals(4, 5, 3) (1, 5) >>> remaining_animals(200000000000, 100000000000, 250000000000) (0, 50000000000)","solution":"def remaining_animals(G, S, D): Function to compute the number of goats and sheep remaining after D days. Parameters: G (int): initial number of goats S (int): initial number of sheep D (int): number of days actions are performed Returns: tuple: remaining number of goats and sheep # Reduce the goats count first goats_left = max(G - D, 0) # Calculate remaining actions after all goats (if any) are sold remaining_days = max(D - G, 0) # Reduce the sheep count by remaining actions sheep_left = max(S - remaining_days, 0) return goats_left, sheep_left"},{"question":"def find_pair_with_sum(array, target): Returns a pair of integers from the array that sum to the target value. If no such pair exists, returns an empty list. >>> find_pair_with_sum([1, 2, 3, 4, 5], 9) [4, 5] >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) [] >>> find_pair_with_sum([5, 8, -3, 11, 6], 3) [-3, 6] >>> find_pair_with_sum([10, 15, 3, 7], 17) [10, 7] >>> find_pair_with_sum([1, 2], 3) [1, 2] >>> find_pair_with_sum([1, 2], 5) [] >>> find_pair_with_sum([], 5) [] >>> find_pair_with_sum([1], 1) []","solution":"def find_pair_with_sum(array, target): Returns a pair of integers from the array that sum to the target value. If no such pair exists, returns an empty list. seen = set() for num in array: complement = target - num if complement in seen: return [complement, num] seen.add(num) return []"},{"question":"def minimum_water_stations(N, M, stations, Q, participants): Determine the minimum number of water stations each participant can drink from. Args: N: int : the finishing position of the marathon track M: int : the number of water stations stations: List[Tuple[int, int]] : each tuple contains the position and hydration level of a water station Q: int : the number of participants participants: List[int] : the starting hydration level of each participant Returns: List[int] : the minimum number of water stations each participant can drink from Examples: >>> minimum_water_stations(100, 5, [(20, 3), (50, 2), (70, 3), (80, 2), (90, 3)], 3, [1, 2, 3]) [0, 2, 3] >>> minimum_water_stations(150, 6, [(10, 4), (30, 2), (50, 4), (70, 4), (90, 2), (110, 3)], 2, [2, 4]) [2, 3] # Function implementation here","solution":"def minimum_water_stations(N, M, stations, Q, participants): from collections import defaultdict import heapq # Dictionary to store the water stations by hydration level hydration_map = defaultdict(list) for position, hydration in stations: hydration_map[hydration].append(position) # For each participant query, determine the minimum number of stations results = [] for starting_hydration in participants: if starting_hydration not in hydration_map: results.append(0) continue usable_stations = sorted(hydration_map[starting_hydration]) results.append(len(usable_stations)) return results"},{"question":"def possible_d_values(m, p, q, t): This function computes the possible values for d given the market specification and stall distribution details. m: int - number of sectors p: int - starting sector number q: int - starting stall number within the sector t: int - number of stalls visited before returning to the starting stall. Returns: (int, int) - the minimum and maximum values of d pass # Example test cases def test_example1(): assert possible_d_values(3, 2, 1, 6) == (6, 6) def test_example2(): assert possible_d_values(4, 3, 3, 8) == (8, 8) def test_example3(): assert possible_d_values(5, 1, 1, 10) == (10, 10) def test_minimum_input_values(): assert possible_d_values(1, 1, 1, 1) == (1, 1) def test_large_m_value(): assert possible_d_values(100000, 50000, 25000, 100000) == (100000, 100000)","solution":"def possible_d_values(m, p, q, t): This function computes the possible values for d given the market specification and stall distribution details. m: int - number of sectors p: int - starting sector number q: int - starting stall number within the sector t: int - number of stalls visited before returning to the starting stall. Returns: (int, int) - the minimum and maximum values of d # The minimum d fits exactly into t (t // 1 = t) min_d = t # The maximum d is such that only one step is needed (t // t = 1) max_d = t return min_d, max_d"},{"question":"from typing import List def filter_suggestions(watched: List[int], suggestions: List[int]) -> List[int]: Filters the suggestions list to remove videos that have been watched. Parameters: watched (list of int): The list of watched video IDs. suggestions (list of int): The list of suggested video IDs. Returns: list of int: A list of suggested video IDs that have not been watched. pass # Unit Tests def test_no_watched_videos(): watched = [] suggestions = [1, 2, 3, 4] assert filter_suggestions(watched, suggestions) == [1, 2, 3, 4] def test_no_suggestions(): watched = [1, 2, 3, 4] suggestions = [] assert filter_suggestions(watched, suggestions) == [] def test_watched_some_suggestions(): watched = [1, 2, 3] suggestions = [3, 4, 5, 6, 7] assert filter_suggestions(watched, suggestions) == [4, 5, 6, 7] def test_all_suggestions_watched(): watched = [2, 3, 4, 5] suggestions = [2, 3, 4] assert filter_suggestions(watched, suggestions) == [] def test_some_watched_some_suggestions(): watched = [4, 6] suggestions = [2, 4, 6, 8] assert filter_suggestions(watched, suggestions) == [2, 8] def test_no_overlap(): watched = [1, 2, 3] suggestions = [4, 5, 6] assert filter_suggestions(watched, suggestions) == [4, 5, 6]","solution":"def filter_suggestions(watched, suggestions): Filters the suggestions list to remove videos that have been watched. Parameters: watched (list of int): The list of watched video IDs. suggestions (list of int): The list of suggested video IDs. Returns: list of int: A list of suggested video IDs that have not been watched. watched_set = set(watched) return [video for video in suggestions if video not in watched_set]"},{"question":"def isHarmonious(n, k, sequence): Determines if the given sequence is Harmonious. Parameters: n (int): Length of the sequence. k (int): The divisor. sequence (list of int): The sequence of integers. Returns: bool: True if the sequence is Harmonious, False otherwise. Examples: >>> isHarmonious(5, 5, [10, 15, 20, 25, 30]) True >>> isHarmonious(6, 3, [1, 4, 7, 10, 13, 16]) False","solution":"def isHarmonious(n, k, sequence): Determines if the given sequence is Harmonious. Parameters: n (int): Length of the sequence. k (int): The divisor. sequence (list of int): The sequence of integers. Returns: bool: True if the sequence is Harmonious, False otherwise. for i in range(n - 1): if (sequence[i] + sequence[i + 1]) % k != 0: return False return True"},{"question":"def min_operations(source: str, target: str) -> int: Returns the minimum number of operations required to convert source to target. Parameters: source (str): The original string. target (str): The target string to convert to. Returns: int: The minimum number of operations required. Examples: >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"abc\\", \\"yabd\\") 2 >>> min_operations(\\"a\\", \\"b\\") 1","solution":"def min_operations(source, target): Returns the minimum number of operations required to convert source to target. Parameters: source (str): The original string. target (str): The target string to convert to. Returns: int: The minimum number of operations required. m, n = len(source), len(target) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif source[i - 1] == target[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Delete dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def encrypt_message(message: str) -> str: Encrypts the message using a substitution cipher strategy where each letter in the alphabet is mapped to its reverse counterpart. >>> encrypt_message(\\"Hello World\\") 'Svool Dliow' >>> encrypt_message(\\"Hello, World!\\") 'Svool, Dliow!' >>> encrypt_message(\\"abcdefghijklmnopqrstuvwxyz\\") 'zyxwvutsrqponmlkjihgfedcba' >>> encrypt_message(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'ZYXWVUTSRQPONMLKJIHGFEDCBA' >>> encrypt_message(\\"AbCdEfGhIjKlMnOpQrStUvWxYz\\") 'ZyXwVuTsRqPoNmLkJiHgFeDcBa' >>> encrypt_message(\\"The quick brown fox jumps over the lazy dog\\") 'Gsv jfrxp yildm ulc qfnkh levi gsv ozab wlt'","solution":"def create_cipher_map(): Creates a dictionary to map each letter to its reverse counterpart. from string import ascii_lowercase, ascii_uppercase cipher_map = {} for a, z in zip(ascii_lowercase, reversed(ascii_lowercase)): cipher_map[a] = z cipher_map[a.upper()] = z.upper() return cipher_map def encrypt_message(message): Encrypts the message using the substitution cipher strategy. Parameters: message (str): The message to be encrypted. Returns: str: The encrypted message. cipher_map = create_cipher_map() encrypted_message = ''.join(cipher_map.get(char, char) for char in message) return encrypted_message"},{"question":"def is_symmetric(matrix): Determines if the given matrix is symmetric. :param matrix: List of lists, representing an n x n matrix :return: String \\"YES\\" if the matrix is symmetric, otherwise \\"NO\\". def process_input(input_string): Processes the multiline input string into a matrix. :param input_string: The input string containing the matrix size and elements :return: A list of lists representing the matrix def main(input_string): Main function to determine if a given matrix is symmetric from the input string. :param input_string: The input string containing the matrix size and elements :return: String \\"YES\\" if the matrix is symmetric, otherwise \\"NO\\". # Test cases if __name__ == \\"__main__\\": def test_symmetric_matrix(): matrix = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] assert is_symmetric(matrix) == \\"YES\\" def test_non_symmetric_matrix(): matrix = [ [1, 2], [3, 4] ] assert is_symmetric(matrix) == \\"NO\\" def test_process_input(): input_string = \\"3n1 2 3n2 3 4n3 4 5\\" expected_output = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] assert process_input(input_string) == expected_output def test_main_symmetric(): input_string = \\"3n1 2 3n2 3 4n3 4 5\\" assert main(input_string) == \\"YES\\" def test_main_non_symmetric(): input_string = \\"2n1 2n3 4\\" assert main(input_string) == \\"NO\\" test_symmetric_matrix() test_non_symmetric_matrix() test_process_input() test_main_symmetric() test_main_non_symmetric()","solution":"def is_symmetric(matrix): Determines if the given matrix is symmetric. :param matrix: List of lists, representing an n x n matrix :return: String \\"YES\\" if the matrix is symmetric, otherwise \\"NO\\". n = len(matrix) for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return \\"NO\\" return \\"YES\\" def process_input(input_string): Processes the multiline input string into a matrix. :param input_string: The input string containing the matrix size and elements :return: A list of lists representing the matrix lines = input_string.strip().split('n') n = int(lines[0]) matrix = [list(map(int, line.split())) for line in lines[1:]] return matrix def main(input_string): matrix = process_input(input_string) return is_symmetric(matrix)"},{"question":"def can_form_palindrome(S: str) -> str: Returns 'Yes' if the string S can be rearranged to form a palindrome, otherwise returns 'No'. >>> can_form_palindrome(\\"carrace\\") \\"Yes\\" >>> can_form_palindrome(\\"daily\\") \\"No\\"","solution":"def can_form_palindrome(S): Returns 'Yes' if the string S can be rearranged to form a palindrome, otherwise returns 'No'. from collections import Counter freq = Counter(S) odd_count = sum(1 for count in freq.values() if count % 2 != 0) if odd_count > 1: return \\"No\\" else: return \\"Yes\\""},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[List[int]]) -> int: Finds the shortest path from the top-left corner to the bottom-right corner in a given grid. The grid is represented by a 2D array where 0 represents an empty cell and 1 represents an obstacle. The robot moves one cell at a time in either up, down, left, or right directions and cannot move diagonally. Args: n (int): The number of rows in the grid (1 ≤ n ≤ 1000). m (int): The number of columns in the grid (1 ≤ m ≤ 1000). grid (List[List[int]]): A 2D array of integers where each element is either 0 (empty cell) or 1 (obstacle). Returns: int: The length of the shortest path from (0, 0) to (n-1, m-1). If no path exists, return -1. Examples: >>> shortest_path(3, 3, [ [0, 0, 0], [1, 1, 0], [0, 0, 0] ]) 4 >>> shortest_path(3, 3, [ [0, 1, 0], [1, 1, 0], [0, 0, 0] ]) -1 >>> shortest_path(1, 1, [[0]]) 0 >>> shortest_path(2, 2, [ [0, 0], [0, 0] ]) 2","solution":"from collections import deque def shortest_path(n, m, grid): if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if x == n-1 and y == m-1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny)) visited.add((nx, ny)) steps += 1 return -1"},{"question":"import numpy as np from typing import List def categorize_projects(N: int, projects: List[List[int]]) -> List[str]: Categorize projects based on the standard deviation of hours worked. Parameters: N (int): Number of projects projects (list of list of int): List of project hours worked over several days Returns: list of str: Category of each project, either \\"consistent\\" or \\"variable\\" pass # Unit test for the function def test_categorize_projects(): N = 3 projects = [ [8, 8, 8, 8, 8], [6, 7, 5, 6, 7, 8, 5], [10, 15, 20, 25, 10, 15, 20, 25, 10, 15] ] expected = [\\"consistent\\", \\"consistent\\", \\"variable\\"] assert categorize_projects(N, projects) == expected N = 1 projects = [[8, 8, 8, 8, 8]] expected = [\\"consistent\\"] assert categorize_projects(N, projects) == expected N = 1 projects = [[5, 10, 15, 20, 25]] expected = [\\"variable\\"] assert categorize_projects(N, projects) == expected N = 2 projects = [ [8, 8, 8, 8], [1, 5, 10, 15] ] expected = [\\"consistent\\", \\"variable\\"] assert categorize_projects(N, projects) == expected","solution":"import numpy as np def categorize_projects(N, projects): Categorize projects based on the standard deviation of hours worked. Parameters: N (int): Number of projects projects (list of list of int): List of project hours worked over several days Returns: list of str: Category of each project, either \\"consistent\\" or \\"variable\\" categories = [] for project in projects: std_dev = np.std(project) if std_dev <= 2.0: categories.append(\\"consistent\\") else: categories.append(\\"variable\\") return categories"},{"question":"def max_points(n: int) -> int: Calculate the maximum possible points that can be scored by any participant in a tournament with n participants. >>> max_points(2) 1 >>> max_points(3) 3 >>> max_points(4) 6 >>> max_points(10) 45 >>> max_points(100) 4950 >>> max_points(1000) 499500","solution":"def max_points(n): Calculate the maximum possible points that can be scored by any participant in a tournament with n participants. max_points = 0 for k in range(n - 1): max_points += (k + 1) return max_points"},{"question":"def is_prime(num: int) -> bool: Checks if a number is a prime number. pass def max_prime_difference(array: List[int]) -> int: Finds the maximum difference between any two prime numbers in the array. pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases to find the maximum difference between any two prime numbers in each array. pass # Unit Tests def test_case_1(): T = 3 test_cases = [ (6, [8, 3, 15, 5, 14, 9]), (4, [4, 10, 6, 15]), (7, [2, 5, 11, 3, 17, 18, 19]) ] assert process_test_cases(T, test_cases) == [2, -1, 17] def test_case_no_primes(): T = 1 test_cases = [ (5, [4, 6, 8, 10, 12]) ] assert process_test_cases(T, test_cases) == [-1] def test_case_single_prime(): T = 1 test_cases = [ (5, [2, 4, 6, 8, 10]) ] assert process_test_cases(T, test_cases) == [-1] def test_case_multiple_primes(): T = 1 test_cases = [ (6, [5, 11, 3, 17, 2, 19]) ] assert process_test_cases(T, test_cases) == [17] def test_case_large_numbers(): T = 1 test_cases = [ (4, [991, 997, 1000, 992]) ] assert process_test_cases(T, test_cases) == [6] def test_case_all_primes(): T = 1 test_cases = [ (6, [2, 3, 5, 7, 11, 13]) ] assert process_test_cases(T, test_cases) == [11]","solution":"def is_prime(num): Checks if a number is a prime number. if num <= 1: return False for i in range(2, int(num ** 0.5) + 1): if num % i == 0: return False return True def max_prime_difference(array): Finds the maximum difference between any two prime numbers in the array. primes = [num for num in array if is_prime(num)] if len(primes) < 2: return -1 return max(primes) - min(primes) def process_test_cases(T, test_cases): results = [] for i in range(T): N, array = test_cases[i] results.append(max_prime_difference(array)) return results"},{"question":"def max_treasures(N, T, treasures, start_x, start_y): Determine the maximum number of treasures that the kid can collect. Parameters: N (int): The size of the grid. T (int): The total number of treasures. treasures (List[Tuple[int, int]]): A list of tuples where each tuple contains the coordinates (i, j) of a treasure. start_x (int): The starting x-coordinate of the kid. start_y (int): The starting y-coordinate of the kid. Returns: int: The maximum number of treasures that the kid can collect. Examples: >>> max_treasures(5, 0, [], 0, 0) 0 >>> max_treasures(5, 1, [(0, 0)], 0, 0) 1 >>> max_treasures(5, 5, [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4)], 1, 2) 5 pass def test_no_treasures(): assert max_treasures(5, 0, [], 0, 0) == 0 def test_one_treasure_at_start(): assert max_treasures(5, 1, [(0, 0)], 0, 0) == 1 def test_treasures_in_a_line(): N = 5 T = 5 treasures = [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4)] start_x, start_y = 1, 2 assert max_treasures(N, T, treasures, start_x, start_y) == 5 def test_example1(): N = 5 T = 3 treasures = [(1, 1), (2, 2), (3, 3)] start_x, start_y = 0, 0 assert max_treasures(N, T, treasures, start_x, start_y) == 3 def test_example2(): N = 5 T = 5 treasures = [(1, 0), (1, 1), (1, 2), (1, 3), (1, 4)] start_x, start_y = 2, 2 assert max_treasures(N, T, treasures, start_x, start_y) == 5","solution":"def max_treasures(N, T, treasures, start_x, start_y): from collections import deque # Create the grid and mark the treasures grid = [[0] * N for _ in range(N)] for (i, j) in treasures: grid[i][j] = 1 # Initialize variables for BFS visited = [[False] * N for _ in range(N)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # up, down, left, right max_treasures_collected = 0 queue = deque([(start_x, start_y)]) visited[start_x][start_y] = True while queue: x, y = queue.popleft() if grid[x][y] == 1: max_treasures_collected += 1 grid[x][y] = 0 # Collect the treasure for dx, dy in directions: new_x, new_y = x + dx, y + dy if 0 <= new_x < N and 0 <= new_y < N and not visited[new_x][new_y]: visited[new_x][new_y] = True queue.append((new_x, new_y)) return max_treasures_collected"},{"question":"def max_land_area(n: int, listings: List[Tuple[int, int]]) -> int: Returns the maximum possible area of a rectangular land from the given listings. Parameters: n (int): Number of land listings. listings (list of tuples): Each tuple contains two integers (length, width) of a land plot. Returns: int: Maximum area of a rectangular plot of land. >>> max_land_area(4, [(4, 5), (7, 3), (6, 6), (8, 2)]) 36 >>> max_land_area(3, [(1, 1), (2, 2), (3, 5)]) 15","solution":"def max_land_area(n, listings): Returns the maximum possible area of a rectangular land from the given listings. Parameters: n (int): Number of land listings. listings (list of tuples): Each tuple contains two integers (length, width) of a land plot. Returns: int: Maximum area of a rectangular plot of land. max_area = 0 for l, w in listings: area = l * w if area > max_area: max_area = area return max_area # Example usage: # land_listings = [(4, 5), (7, 3), (6, 6), (8, 2)] # print(max_land_area(4, land_listings)) # Output: 36"},{"question":"def can_distribute(t: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[str]: Determine whether it is possible to distribute all the crates into the containers while ensuring that the total capacity of crates in each container does not exceed the container's capacity. Args: t (int): Number of test cases test_cases (List[Tuple[Tuple[int, int], List[int], List[int]]]): List of test cases, each test case is a tuple where: - first element is a tuple (m, k) representing number of containers and crates - second element is the list of container capacities - third element is the list of crate capacities Returns: List[str]: List of results for each test case (\\"YES\\" or \\"NO\\") Example: >>> can_distribute(3, [ [(3, 3), [5, 10, 8], [5, 4, 5]], [(2, 3), [7, 5], [5, 5, 6]], [(4, 2), [4, 8, 2, 2], [3, 1]], ]) ['YES', 'NO', 'YES']","solution":"def can_distribute(t, test_cases): results = [] for i in range(t): m, k = test_cases[i][0] container_capacities = sorted(test_cases[i][1], reverse=True) crate_capacities = sorted(test_cases[i][2], reverse=True) j = 0 possible = True for crate in crate_capacities: while j < len(container_capacities) and container_capacities[j] < crate: j += 1 if j == len(container_capacities): possible = False break container_capacities[j] -= crate if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def longest_non_overlapping_repeating_substring(s: str) -> int: Given a string s, find the length of the longest substring that appears at least twice without overlapping in s. Overlapping is not allowed, meaning if a substring starts at position i, another instance of this substring should not start before position i + length of substring. Examples: >>> longest_non_overlapping_repeating_substring(\\"banana\\") 3 >>> longest_non_overlapping_repeating_substring(\\"abcd\\") 0","solution":"def longest_non_overlapping_repeating_substring(s): n = len(s) def is_valid_length(length): seen = set() for i in range(0, n - length + 1): substring = s[i:i + length] if substring in seen: return True seen.add(substring) return False left, right = 1, n // 2 + 1 result = 0 while left < right: mid = (left + right) // 2 if is_valid_length(mid): result = mid left = mid + 1 else: right = mid return result"},{"question":"import bisect class IntegerListManager: Manage a list of integers by adding, removing, finding the maximum, and finding the median. Methods: add(x: int): Add the integer x to the list. remove(x: int): Remove one occurrence of the integer x from the list. max() -> int: Find and return the maximum integer from the list. median() -> float: Find and return the median of the integers in the list. Example: >>> manager = IntegerListManager() >>> manager.add(7) >>> manager.add(3) >>> manager.add(5) >>> manager.add(9) >>> manager.max() 9 >>> manager.median() 5 >>> manager.remove(5) >>> manager.max() 9 >>> manager.median() 6 >>> manager.remove(10) # does nothing since 10 is not in the list def __init__(self): self.integers = [] def add(self, x): bisect.insort(self.integers, x) def remove(self, x): if x in self.integers: self.integers.remove(x) def max(self): if self.integers: return self.integers[-1] return None def median(self): if not self.integers: return None n = len(self.integers) if n % 2 == 1: return self.integers[n // 2] else: return (self.integers[(n // 2) - 1] + self.integers[n // 2]) / 2","solution":"import bisect class IntegerListManager: def __init__(self): self.integers = [] def add(self, x): bisect.insort(self.integers, x) def remove(self, x): if x in self.integers: self.integers.remove(x) def max(self): if self.integers: return self.integers[-1] return None def median(self): if not self.integers: return None n = len(self.integers) if n % 2 == 1: return self.integers[n // 2] else: return (self.integers[(n // 2) - 1] + self.integers[n // 2]) / 2"},{"question":"def smallest_missing_positive_integer(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Write a program to determine the smallest positive integer that is missing from an unsorted array of integers. The array can contain duplicates and both positive and negative numbers. Input: The first line contains an integer t (1 ≤ t ≤ 100) — the number of test cases. The description of t test cases follows. Each test case consists of two lines. The first line contains an integer n (1 ≤ n ≤ 1000) — the length of the array. The second line consists of n space-separated integers a_i (−10^6 ≤ a_i ≤ 10^6) — the elements of the array. Output: For each test case, return the smallest positive integer that is missing from the array. >>> smallest_missing_positive_integer(3, [(7, [1, 2, 0, -1, 3, 5, 4]), (5, [4, -1, 2, 1, 10]), (6, [-1, -3, -4, -2, -5, 0])]) [6, 3, 1] >>> smallest_missing_positive_integer(1, [(1, [-1])]) [1] >>> smallest_missing_positive_integer(1, [(10, [-1000000, 1, 2, 3, 4, 5, 6, 7, 8, 9])]) [10]","solution":"def smallest_missing_positive_integer(t, test_cases): results = [] for case in test_cases: n, arr = case # Filter the array to only include positives positives = [num for num in arr if num > 0] positives = set(positives) # Remove duplicates and convert to a set for O(1) lookups missing = 1 while missing in positives: missing += 1 results.append(missing) return results"},{"question":"def can_be_sorted_by_reversing_one_subarray(n: int, arr: List[int]) -> str: Determines whether the list can be sorted into a non-decreasing order by performing at most one operation of reversing a contiguous subarray. Parameters: n (int): The length of the list. arr (list of int): The list of integers. Returns: str: \\"Yes\\" if the list can be sorted by reversing at most one subarray. Otherwise, \\"No\\". Examples: >>> can_be_sorted_by_reversing_one_subarray(4, [1, 3, 2, 4]) 'Yes' >>> can_be_sorted_by_reversing_one_subarray(6, [3, 1, 2, 4, 5, 6]) 'No'","solution":"def can_be_sorted_by_reversing_one_subarray(n, arr): Determines whether the list can be sorted into a non-decreasing order by performing at most one operation of reversing a contiguous subarray. Parameters: n (int): The length of the list. arr (list of int): The list of integers. Returns: str: \\"Yes\\" if the list can be sorted by reversing at most one subarray. Otherwise, \\"No\\". # Step 1: Find the first segment of the array that is out of order start = None for i in range(n - 1): if arr[i] > arr[i + 1]: start = i break # Step 2: If no such segment is found, the array is already sorted if start is None: return \\"Yes\\" # Step 3: Find the end of the out-of-order segment end = None for i in range(start, n - 1): if arr[i] < arr[i + 1]: end = i break if end is None: end = n - 1 # Step 4: Reverse the identified segment reversed_segment = arr[start:end + 1][::-1] # Step 5: Check whether reversing the segment makes the entire array sorted new_arr = arr[:start] + reversed_segment + arr[end + 1:] for i in range(n - 1): if new_arr[i] > new_arr[i + 1]: return \\"No\\" return \\"Yes\\""},{"question":"def num_distinct_subsequences(s: str, dictionary: List[str]) -> int: Determine how many distinct words from the dictionary can be formed as subsequences of s. >>> num_distinct_subsequences(\\"abcde\\", [\\"a\\", \\"bb\\", \\"ace\\"]) 2 >>> num_distinct_subsequences(\\"abcdef\\", [\\"ab\\", \\"cf\\", \\"ef\\", \\"gh\\"]) 3 pass def test_example_1(): s = \\"abcde\\" dictionary = [\\"a\\", \\"bb\\", \\"ace\\"] assert num_distinct_subsequences(s, dictionary) == 2 def test_example_2(): s = \\"abcdef\\" dictionary = [\\"ab\\", \\"cf\\", \\"ef\\", \\"gh\\"] assert num_distinct_subsequences(s, dictionary) == 3 def test_no_subsequences(): s = \\"abcdef\\" dictionary = [\\"gh\\", \\"ij\\", \\"kl\\"] assert num_distinct_subsequences(s, dictionary) == 0 def test_subsequence_is_the_same_word(): s = \\"abcdef\\" dictionary = [\\"abcdef\\"] assert num_distinct_subsequences(s, dictionary) == 1 def test_empty_dictionary(): s = \\"abcdef\\" dictionary = [] assert num_distinct_subsequences(s, dictionary) == 0 def test_empty_string(): s = \\"\\" dictionary = [\\"a\\", \\"bb\\", \\"ace\\"] assert num_distinct_subsequences(s, dictionary) == 0","solution":"def num_distinct_subsequences(s, dictionary): def is_subsequence(s, word): it = iter(s) return all(char in it for char in word) count = 0 for word in dictionary: if is_subsequence(s, word): count += 1 return count # Function to process the input def process_input_and_compute(s, n, word_list): return num_distinct_subsequences(s, word_list)"},{"question":"def max_length_contiguous_subarray(flowers_by_row: list) -> list: Determines the maximum length of contiguous flowers of the same color for each row. Parameters: flowers_by_row (list of str): A list where each element is a string representing the colors in a row. Returns: list of int: A list where each element is the maximum length of contiguous flowers of the same color for that row. >>> max_length_contiguous_subarray([\\"ABBAC\\", \\"CCCCB\\", \\"ABAAB\\"]) [2, 4, 2] >>> max_length_contiguous_subarray([\\"AAA\\"]) [3] >>> max_length_contiguous_subarray([\\"ABC\\", \\"DEF\\"]) [1, 1] >>> max_length_contiguous_subarray([\\"AABB\\", \\"BBAA\\", \\"ABAB\\"]) [2, 2, 1] >>> max_length_contiguous_subarray([\\"AABBAABB\\", \\"CCCAABBBCCC\\", \\"DDDDDDDD\\"]) [2, 3, 8]","solution":"def max_length_contiguous_subarray(flowers_by_row): Determines the maximum length of contiguous flowers of the same color for each row. Parameters: flowers_by_row (list of str): A list where each element is a string representing the colors in a row. Returns: list of int: A list where each element is the maximum length of contiguous flowers of the same color for that row. max_lengths = [] for row in flowers_by_row: max_length = 1 current_length = 1 for i in range(1, len(row)): if row[i] == row[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) max_lengths.append(max_length) return max_lengths"},{"question":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def build_tree(nodes): Build a binary tree from a list of node tuples. pass def longest_increasing_path(root): Find the longest path in the tree where the values along the path form a strictly increasing sequence. pass def longest_path_in_binary_tree(n, nodes): Given a binary tree, return the length of the longest path with strictly increasing values. pass def test_example_1(): n = 5 nodes = [ (4, 2, 5), (2, -1, -1), (5, 3, -1), (3, -1, -1), (1, -1, -1) ] assert longest_path_in_binary_tree(n, nodes) == 2 def test_example_2(): n = 7 nodes = [ (8, 3, 10), (3, 1, 6), (10, -1, 14), (1, -1, -1), (6, 4, 7), (14, 13, -1), (4, -1, -1) ] assert longest_path_in_binary_tree(n, nodes) == 3 def test_single_node(): n = 1 nodes = [ (1, -1, -1), ] assert longest_path_in_binary_tree(n, nodes) == 1 def test_no_increasing_path(): n = 3 nodes = [ (3, 2, 1), (2, -1, -1), (1, -1, -1) ] assert longest_path_in_binary_tree(n, nodes) == 1 def test_multiple_equal_lengths(): n = 7 nodes = [ (5, 3, 6), (3, 2, 4), (6, -1, 7), (2, -1, -1), (4, -1, -1), (7, -1, 8), (8, -1, -1) ] assert longest_path_in_binary_tree(n, nodes) == 4","solution":"class TreeNode: def __init__(self, value=0): self.value = value self.left = None self.right = None def build_tree(nodes): if not nodes: return None tree_nodes = {} for value, left, right in nodes: if value not in tree_nodes: tree_nodes[value] = TreeNode(value) node = tree_nodes[value] if left != -1: if left not in tree_nodes: tree_nodes[left] = TreeNode(left) node.left = tree_nodes[left] if right != -1: if right not in tree_nodes: tree_nodes[right] = TreeNode(right) node.right = tree_nodes[right] return tree_nodes[nodes[0][0]] if nodes else None def longest_increasing_path(root): def dfs(node, parent_value): if not node: return 0 left_length = dfs(node.left, node.value) right_length = dfs(node.right, node.value) if node.value <= parent_value: return 0 else: return max(left_length, right_length) + 1 return dfs(root, float('-inf')) def longest_path_in_binary_tree(n, nodes): root = build_tree(nodes) return longest_increasing_path(root)"},{"question":"from typing import List class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root: TreeNode, value: int) -> TreeNode: Insert a value into the BST. if root is None: return TreeNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root def bst_in_order_traversal(numbers: List[int]) -> List[int]: Create a BST from the given list and return its in-order traversal. >>> bst_in_order_traversal([5, 3, 7, 2, 4, 6, 8]) [2, 3, 4, 5, 6, 7, 8] >>> bst_in_order_traversal([]) [] >>> bst_in_order_traversal([1]) [1] >>> bst_in_order_traversal([5, 4, 6, 3, 7, 2, 8]) [2, 3, 4, 5, 6, 7, 8] >>> bst_in_order_traversal([10, 5, 1, 7, 40, 50]) [1, 5, 7, 10, 40, 50] >>> bst_in_order_traversal([10, -10, -20, 0, 20, 15, 30]) [-20, -10, 0, 10, 15, 20, 30]","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert(root.left, value) else: root.right = insert(root.right, value) return root def bst_in_order_traversal(numbers): if not numbers: return [] root = None for number in numbers: root = insert(root, number) result = [] def in_order(node): if node: in_order(node.left) result.append(node.value) in_order(node.right) in_order(root) return result"},{"question":"def next_alphabet_string(s: str) -> str: Transforms the input string such that each character is replaced by the next character in the English alphabet, with 'z' wrapping around to 'a'. >>> next_alphabet_string(\\"abc\\") == \\"bcd\\" >>> next_alphabet_string(\\"xyz\\") == \\"yza\\" >>> next_alphabet_string(\\"hello\\") == \\"ifmmp\\"","solution":"def next_alphabet_string(s: str) -> str: Transforms the input string such that each character is replaced by the next character in the English alphabet, with 'z' wrapping around to 'a'. result = [] for char in s: if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def min_cost_path(grid): Find the minimum cost path in the given M x N grid from the top-left corner to the bottom-right corner. pass def process_cases(test_cases): results = [] for case in test_cases: M, N, grid = case results.append(min_cost_path(grid)) return results def test_min_cost_path(): T = 2 test_cases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (2, 2, [ [1, 2], [3, 4] ]) ] expected_results = [7, 7] results = process_cases(test_cases) assert results == expected_results def test_min_cost_path_single_row(): test_cases = [ (1, 3, [ [1, 2, 5] ]) ] expected_results = [8] results = process_cases(test_cases) assert results == expected_results def test_min_cost_path_single_column(): test_cases = [ (3, 1, [ [1], [2], [5] ]) ] expected_results = [8] results = process_cases(test_cases) assert results == expected_results def test_min_cost_path_large_grid(): test_cases = [ (3, 3, [ [1, 2, 3], [4, 8, 2], [1, 5, 3] ]) ] expected_results = [11] results = process_cases(test_cases) assert results == expected_results","solution":"def min_cost_path(grid): Find the minimum cost path in the given M x N grid from the top-left corner to the bottom-right corner. M = len(grid) N = len(grid[0]) # Create a 2D dp array with the same dimensions as grid dp = [[0 for _ in range(N)] for _ in range(M)] # Initialize the first cell with the value in grid dp[0][0] = grid[0][0] # Initialize the first row of dp array for j in range(1, N): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column of dp array for i in range(1, M): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, M): for j in range(1, N): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The answer will be in the bottom-right corner of dp array return dp[M-1][N-1] def process_cases(test_cases): results = [] for case in test_cases: M, N, grid = case results.append(min_cost_path(grid)) return results"},{"question":"class BankSystem: def __init__(self, n): Initialize the banking system with n accounts. pass def deposit(self, a, amount): Deposit a given amount into account a. pass def withdraw(self, a, amount): Withdraw a given amount from account a if sufficient funds are available. pass def balance(self, a): Return the current balance of account a. pass def process_commands(n, q, commands): Process a series of banking commands. Args: n (int): The number of accounts. q (int): The number of commands. commands (List[Tuple[str, str, str]]): A list of commands to be processed. Returns: List[int]: Results of balance operations. Example: >>> n = 5 >>> q = 8 >>> commands = [ >>> (\\"deposit\\", \\"1\\", \\"100\\"), >>> (\\"deposit\\", \\"2\\", \\"150\\"), >>> (\\"balance\\", \\"1\\", \\"\\"), >>> (\\"balance\\", \\"2\\", \\"\\"), >>> (\\"withdraw\\", \\"1\\", \\"50\\"), >>> (\\"balance\\", \\"1\\", \\"\\"), >>> (\\"withdraw\\", \\"2\\", \\"200\\"), >>> (\\"balance\\", \\"2\\", \\"\\") >>> ] >>> process_commands(n, q, commands) [100, 150, 50, 150] pass # Unit tests def test_deposit(): bank = BankSystem(2) bank.deposit(1, 100) assert bank.balance(1) == 100 def test_withdraw(): bank = BankSystem(2) bank.deposit(1, 100) bank.withdraw(1, 50) assert bank.balance(1) == 50 def test_withdraw_insufficient_funds(): bank = BankSystem(2) bank.deposit(1, 100) bank.withdraw(1, 150) assert bank.balance(1) == 100 def test_balance(): bank = BankSystem(2) bank.deposit(1, 100) bank.deposit(2, 50) assert bank.balance(1) == 100 assert bank.balance(2) == 50 def test_process_commands(): n = 5 q = 8 commands = [ (\\"deposit\\", \\"1\\", \\"100\\"), (\\"deposit\\", \\"2\\", \\"150\\"), (\\"balance\\", \\"1\\", \\"\\"), (\\"balance\\", \\"2\\", \\"\\"), (\\"withdraw\\", \\"1\\", \\"50\\"), (\\"balance\\", \\"1\\", \\"\\"), (\\"withdraw\\", \\"2\\", \\"200\\"), (\\"balance\\", \\"2\\", \\"\\") ] expected = [100, 150, 50, 150] assert process_commands(n, q, commands) == expected def test_process_commands_with_zero_deposit(): n = 3 q = 4 commands = [ (\\"deposit\\", \\"1\\", \\"0\\"), (\\"balance\\", \\"1\\", \\"\\"), (\\"withdraw\\", \\"1\\", \\"0\\"), (\\"balance\\", \\"1\\", \\"\\") ] expected = [0, 0] assert process_commands(n, q, commands) == expected def test_large_deposit_and_withdrawal(): n = 3 q = 3 commands = [ (\\"deposit\\", \\"1\\", \\"1000000000\\"), (\\"withdraw\\", \\"1\\", \\"999999999\\"), (\\"balance\\", \\"1\\", \\"\\") ] expected = [1] assert process_commands(n, q, commands) == expected","solution":"class BankSystem: def __init__(self, n): self.accounts = [0] * n def deposit(self, a, amount): self.accounts[a - 1] += amount def withdraw(self, a, amount): if self.accounts[a - 1] >= amount: self.accounts[a - 1] -= amount def balance(self, a): return self.accounts[a - 1] def process_commands(n, q, commands): bank = BankSystem(n) results = [] for command in commands: op, a, amount = command a = int(a) if op == 'deposit': bank.deposit(a, int(amount)) elif op == 'withdraw': bank.withdraw(a, int(amount)) elif op == 'balance': results.append(bank.balance(a)) return results"},{"question":"def find_integer_with_exactly_two_occurrences(n: int, arr: List[int]) -> int: Determine if any integer appears exactly twice in the list. :param n: Number of integers in the list. :param arr: List of integers. :return: An integer that appears exactly twice or -1. >>> find_integer_with_exactly_two_occurrences(5, [1, 2, 3, 2, 4]) 2 >>> find_integer_with_exactly_two_occurrences(4, [1, 1, 1, 2]) -1 >>> find_integer_with_exactly_two_occurrences(6, [4, 5, 6, 7, 7, 8]) 7 >>> find_integer_with_exactly_two_occurrences(5, [1, 2, 3, 4, 5]) -1 >>> find_integer_with_exactly_two_occurrences(8, [1, 2, 3, 2, 4, 4, 5, 6]) in [2, 4] True >>> find_integer_with_exactly_two_occurrences(5, [3, 3, 3, 3, 3]) -1 >>> find_integer_with_exactly_two_occurrences(1, [3]) -1 >>> find_integer_with_exactly_two_occurrences(5, [1, 2, 1, 3, 4]) 1 >>> find_integer_with_exactly_two_occurrences(5, [100, 2, 100, 3, 4]) 100","solution":"def find_integer_with_exactly_two_occurrences(n, arr): Returns an integer that appears exactly twice in the list if such an integer exists. Otherwise returns -1. :param n: Number of integers in the list. :param arr: List of integers. :return: An integer that appears exactly twice or -1. from collections import Counter # Count the occurrences of each integer in the list count = Counter(arr) # Iterate through the count dictionary to find an integer with exactly two occurrences for key, value in count.items(): if value == 2: return key # If no integer appears exactly twice, return -1 return -1"},{"question":"def plant_trees(n: int, trees: List[int]) -> Tuple[int, List[int]]: Return the minimum number of trees to be planted and the resulting number of trees in each park. :param n: number of parks :param trees: list of initial number of trees in each park :return: tuple containing the minimum number of trees to be planted and the resulting list of trees >>> plant_trees(4, [1, 2, 2, 3]) (2, [1, 2, 3, 4]) >>> plant_trees(3, [0, 0, 0]) (3, [0, 1, 2]) pass","solution":"def plant_trees(n, trees): Return the minimum number of trees to be planted and the resulting number of trees in each park. :param n: number of parks :param trees: list of initial number of trees in each park :return: tuple containing the minimum number of trees to be planted and the resulting list of trees trees = sorted(trees) min_trees_needed = 0 for i in range(1, n): if trees[i] <= trees[i - 1]: needed = trees[i - 1] - trees[i] + 1 trees[i] += needed min_trees_needed += needed return min_trees_needed, trees"},{"question":"def max_non_consecutive_subsequence_sum(n: int, sequence: List[int]) -> int: Determine the maximum possible sum of any contiguous subsequence with the condition that no two consecutive subsequences chosen can share any elements. >>> max_non_consecutive_subsequence_sum(8, [3, 2, -6, 4, 0, -2, 8, -1]) 15 >>> max_non_consecutive_subsequence_sum(5, [1, 2, 3, 4, 5]) 9 >>> max_non_consecutive_subsequence_sum(5, [-1, -2, -3, -4, -5]) 0 >>> max_non_consecutive_subsequence_sum(6, [-2, 1, 3, -4, 2, 1]) 5 >>> max_non_consecutive_subsequence_sum(1, [10]) 10 >>> max_non_consecutive_subsequence_sum(1, [-10]) 0 >>> max_non_consecutive_subsequence_sum(2, [1, 2]) 2 >>> max_non_consecutive_subsequence_sum(2, [-1, 2]) 2 >>> max_non_consecutive_subsequence_sum(2, [-1, -2]) 0","solution":"def max_non_consecutive_subsequence_sum(n, sequence): if n == 0: return 0 if n == 1: return max(0, sequence[0]) # Dynamic programming approach dp = [0] * n dp[0] = max(0, sequence[0]) # the best sum for sequence[:1] dp[1] = max(dp[0], sequence[1]) # the best sum for sequence[:2] for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + sequence[i]) return dp[-1]"},{"question":"from typing import List def min_sweet_difference(n: int, s: List[int]) -> int: Determine the minimum possible absolute difference in the total sweetness of candies distributed to two friends. Parameters: n (int): The number of candies. s (List[int]): The sweetness levels of the candies. Returns: int: The minimum possible absolute difference in the total sweetness. >>> min_sweet_difference(6, [1, 2, 3, 4, 5, 6]) 1 >>> min_sweet_difference(4, [8, 6, 5, 7]) 0 >>> min_sweet_difference(1, [5]) 5 >>> min_sweet_difference(4, [1, 1, 1, 1]) 0 >>> min_sweet_difference(5, [1, 6, 11, 5, 9]) 0 >>> min_sweet_difference(3, [1, 2, 1000]) 997","solution":"def min_sweet_difference(n, s): total_sum = sum(s) half_sum = total_sum // 2 # Create a DP array to store the possible subset sums dp = [False] * (half_sum + 1) dp[0] = True for sweetness in s: for j in range(half_sum, sweetness - 1, -1): if dp[j - sweetness]: dp[j] = True # Find the largest value which can be reached # that is <= half_sum for i in range(half_sum, -1, -1): if dp[i]: subset_sum1 = i break subset_sum2 = total_sum - subset_sum1 return abs(subset_sum2 - subset_sum1)"},{"question":"def maximum_participants(n: int) -> int: Returns the maximum number of participants that can each receive unique number of prizes given the total number of unique prizes n. >>> maximum_participants(10) 4 >>> maximum_participants(15) 5 >>> maximum_participants(1) 1 >>> maximum_participants(2) 1 >>> maximum_participants(3) 2 >>> maximum_participants(6) 3 >>> maximum_participants(0) 0 >>> maximum_participants(1000000000) > 1000 True >>> maximum_participants(11) 4 >>> maximum_participants(100) 13 >>> maximum_participants(56) 10","solution":"def maximum_participants(n): Returns the maximum number of participants that can each receive unique number of prizes given the total number of unique prizes n. k = 1 total_prizes = 0 while total_prizes + k <= n: total_prizes += k k += 1 return k - 1"},{"question":"def max_energy_collected(N, M, grid): Calculate the maximum energy that can be collected by the time astronauts reach the bottom-right cell of the grid. The function receives the dimensions of the grid, N (rows) and M (columns), and a 2D list \`grid\` representing the energy levels. >>> max_energy_collected(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) 12 >>> max_energy_collected(1, 4, [ [1, 2, 3, 4] ]) 10 >>> max_energy_collected(4, 1, [ [1], [2], [3], [4] ]) 10 >>> max_energy_collected(2, 2, [ [-1, -2], [-3, -4] ]) -7 >>> max_energy_collected(3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]) 0 >>> max_energy_collected(1000, 1000, [[1] * 1000 for _ in range(1000)]) 1999 >>> max_energy_collected(3, 3, [ [1, -1, 2], [2, -2, 3], [3, 0, 4] ]) 10","solution":"def max_energy_collected(N, M, grid): if N == 0 or M == 0: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = grid[0][0] # Initialize the first row of the dp table for j in range(1, M): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column of the dp table for i in range(1, N): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the dp table for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[N-1][M-1]"},{"question":"def min_tasks_to_collect_stars(m, k, t, stars): Determine the minimum number of tasks needed to collect at least k stars. Args: m (int): number of levels k (int): required number of stars t (int): number of tasks per level stars (List[List[int]]): stars given by tasks in each level Returns: int: minimum number of tasks needed or -1 if not possible. >>> min_tasks_to_collect_stars(3, 10, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 2 >>> min_tasks_to_collect_stars(2, 15, 2, [[1, 1], [2, 2]]) == -1","solution":"def min_tasks_to_collect_stars(m, k, t, stars): all_stars = [] for level in stars: all_stars.extend(level) all_stars.sort(reverse=True) collected_stars = 0 tasks_count = 0 for star in all_stars: if collected_stars >= k: break collected_stars += star tasks_count += 1 if collected_stars >= k: return tasks_count else: return -1"},{"question":"import re def is_palindrome(s: str) -> str: Verifies if a given string is a valid palindrome after removing all non-alphanumeric characters and ignoring cases. >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") == \\"YES\\" >>> is_palindrome(\\"Hello, World!\\") == \\"NO\\" def test_simple_palindrome(): assert is_palindrome(\\"A man, a plan, a canal, Panama!\\") == \\"YES\\" def test_not_a_palindrome(): assert is_palindrome(\\"Hello, World!\\") == \\"NO\\" def test_empty_string(): assert is_palindrome(\\"\\") == \\"YES\\" def test_single_character(): assert is_palindrome(\\"a\\") == \\"YES\\" assert is_palindrome(\\"Z\\") == \\"YES\\" def test_numeric_palindrome(): assert is_palindrome(\\"12321\\") == \\"YES\\" assert is_palindrome(\\"12345\\") == \\"NO\\" def test_mixed_case_palindrome(): assert is_palindrome(\\"RaceCar\\") == \\"YES\\" def test_with_special_characters(): assert is_palindrome(\\"!@# %^ &*()\\") == \\"YES\\" assert is_palindrome(\\"abc@# %^!cba\\") == \\"YES\\" assert is_palindrome(\\"abc@# %^!abc\\") == \\"NO\\"","solution":"import re def is_palindrome(s): Checks if the given string is a palindrome after removing all non-alphanumeric characters and ignoring cases. # Remove non-alphanumeric characters and convert to lowercase cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the cleaned string is a palindrome return \\"YES\\" if cleaned_string == cleaned_string[::-1] else \\"NO\\""},{"question":"class ArrayProcessor: def __init__(self, arr): self.arr = arr def update_value(self, i, v): Update the value at index i in the array to v. # Implement the logic to update the value at the specific index def sum_subarray(self, l, r): Find the sum of the subarray from index l to r (inclusive). # Implement the logic to find the sum of elements in the subarray def max_subarray(self, l, r): Find the maximum element in the subarray from index l to r (inclusive). # Implement the logic to find the maximum element in the subarray def process_queries(n, m, arr, queries): Process the given queries on the array. Args: n (int): Number of elements in the initial array m (int): Number of queries arr (List[int]): The initial array of integers queries (List[List[int]]): Queries to process on the array Returns: List[int]: The results of the subarray sum and maximum queries Example: >>> n = 7 >>> m = 5 >>> arr = [1, 3, -2, 8, 5, 7, 6] >>> queries = [ ... [2, 2, 4], ... [3, 1, 7], ... [1, 3, 4], ... [2, 3, 5], ... [3, 2, 6] ... ] >>> process_queries(n, m, arr, queries) [9, 8, 17, 8]","solution":"class ArrayProcessor: def __init__(self, arr): self.arr = arr def update_value(self, i, v): self.arr[i - 1] = v def sum_subarray(self, l, r): return sum(self.arr[l - 1:r]) def max_subarray(self, l, r): return max(self.arr[l - 1:r]) def process_queries(n, m, arr, queries): processor = ArrayProcessor(arr) results = [] for q in queries: if q[0] == 1: processor.update_value(q[1], q[2]) elif q[0] == 2: results.append(processor.sum_subarray(q[1], q[2])) elif q[0] == 3: results.append(processor.max_subarray(q[1], q[2])) return results"},{"question":"def update_grid(n: int, m: int, grid: List[List[int]], operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Updates the grid based on given operations. n: number of rows m: number of columns grid: initial state of the grid operations: list of operations >>> update_grid(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1, 2, 2)]) [[2, 3, 3], [5, 6, 6], [7, 8, 9]] >>> update_grid(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1, 2, 2), (2, 2, 3, 3)]) [[2, 3, 3], [5, 7, 7], [7, 9, 10]] >>> update_grid(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]], [(1, 1, 3, 3)]) [[1, 1, 1], [1, 1, 1], [1, 1, 1]] >>> update_grid(3, 3, [[5, 5, 5], [5, 5, 5], [5, 5, 5]], []) [[5, 5, 5], [5, 5, 5], [5, 5, 5]] >>> update_grid(3, 3, [[10, 20, 30], [40, 50, 60], [70, 80, 90]], [(1, 1, 1, 1), (3, 3, 3, 3)]) [[11, 20, 30], [40, 50, 60], [70, 80, 91]]","solution":"def update_grid(n, m, grid, operations): Updates the grid based on given operations. n: number of rows m: number of columns grid: initial state of the grid operations: list of operations # Initialize the difference array diff = [[0] * (m + 1) for _ in range(n + 1)] # Apply the operations using the difference array for x1, y1, x2, y2 in operations: diff[x1-1][y1-1] += 1 if y2 < m: diff[x1-1][y2] -= 1 if x2 < n: diff[x2][y1-1] -= 1 if x2 < n and y2 < m: diff[x2][y2] += 1 # Apply the 2D prefix sum algorithm to get the final grid values for i in range(n): for j in range(m): if i > 0: diff[i][j] += diff[i-1][j] if j > 0: diff[i][j] += diff[i][j-1] if i > 0 and j > 0: diff[i][j] -= diff[i-1][j-1] grid[i][j] += diff[i][j] return grid"},{"question":"def calculate_successful_shots(datasets): Calculate the number of successful shots that hit a target. For each dataset, output the number of shots that hit a target on one line. Example: >>> datasets = [ ... [ ... (3, 2), ... (2, 3), ... (5, 5), ... (8, 8), ... (0, 0, 1, 1), ... (1, 1, 2, 2) ... ], ... [ ... (5, 5), ... (10, 10), ... (1, 2, 3, 4), ... (-5, -5, 2, 2) ... ], ... [(0, 0)] ...] >>> calculate_successful_shots(datasets) [1, 0]","solution":"def calculate_successful_shots(datasets): results = [] for dataset in datasets: T, S = dataset[0] if T == 0 and S == 0: break targets = set(tuple(target) for target in dataset[1:T+1]) shots = dataset[T+1:] successful_shots = 0 for shot in shots: XS, YS, VXS, VYS = shot x, y = XS, YS while (-1000 <= x <= 1000) and (-1000 <= y <= 1000): if (x, y) in targets: targets.remove((x, y)) successful_shots += 1 break x += VXS y += VYS results.append(successful_shots) return results"},{"question":"def find_longest_active_sequence(T, test_cases): T: The number of test cases. test_cases: A list of tuples, each tuple contains an integer N, followed by a list of N integers (either 0 or 1) Find the longest sequence of consecutive active employees for each test case. If no active employees are found, return \\"No active sequence found\\". If there are multiple sequences of the same longest length, return the first one found. Example: >>> find_longest_active_sequence(3, [(6, [1, 1, 0, 1, 1, 1]), (5, [1, 0, 0, 0, 1]), (3, [0, 0, 0])]) [\\"0 1\\", \\"0 0\\", \\"No active sequence found\\"]","solution":"def find_longest_active_sequence(T, test_cases): T: The number of test cases. test_cases: A list of tuples, each tuple contains an integer N, followed by list of N integers (either 0 or 1) results = [] for case in test_cases: N, statuses = case max_length = 0 max_start_idx = -1 curr_length = 0 curr_start_idx = -1 for i in range(N): if statuses[i] == 1: if curr_length == 0: curr_start_idx = i curr_length += 1 else: if curr_length > max_length: max_length = curr_length max_start_idx = curr_start_idx curr_length = 0 # Final check in case the longest sequence ends at the last element if curr_length > max_length: max_length = curr_length max_start_idx = curr_start_idx if max_length == 0: results.append(\\"No active sequence found\\") else: results.append(f\\"{max_start_idx} {max_start_idx + max_length - 1}\\") return results"},{"question":"def min_additional_roads(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determines the minimum number of new zero-length roads required to ensure full connectivity between all intersections in Vertexville. :param n: Integer, number of intersections :param m: Integer, number of roads :param roads: List of tuples, each tuple has three integers (u_i, v_i, l_i) representing a road from u_i to v_i with a length of l_i :return: Integer, minimum number of new zero-length roads required >>> min_additional_roads(5, 3, [(1, 2, 3), (2, 3, 4), (5, 4, 2)]) == 1 >>> min_additional_roads(6, 6, [(1, 2, 1), (1, 3, 2), (2, 3, 1), (4, 5, 2), (4, 6, 3), (5, 6, 1)]) == 1 >>> min_additional_roads(1, 0, []) == 0 >>> min_additional_roads(3, 0, []) == 2 >>> min_additional_roads(4, 2, [(1, 2, 1), (3, 4, 1)]) == 1 >>> min_additional_roads(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) == 0","solution":"def min_additional_roads(n, m, roads): Determines the minimum number of new zero-length roads required to ensure full connectivity between all intersections in Vertexville. :param n: Integer, number of intersections :param m: Integer, number of roads :param roads: List of tuples, each tuple has three integers (u_i, v_i, l_i) representing a road from u_i to v_i with a length of l_i :return: Integer, minimum number of new zero-length roads required from collections import defaultdict import sys sys.setrecursionlimit(200000) # Helper function to perform DFS and find connected components def dfs(v): visited[v] = True for neighbor in graph[v]: if not visited[neighbor]: dfs(neighbor) # Build the adjacency list graph = defaultdict(list) for u, v, l in roads: graph[u].append(v) graph[v].append(u) # To keep track of visited nodes visited = [False] * (n + 1) # Count connected components num_components = 0 for i in range(1, n + 1): if not visited[i]: dfs(i) num_components += 1 # The minimum number of new zero-length roads required to ensure full connectivity return max(0, num_components - 1)"},{"question":"def deepest_leaf_depth(n, edges): Determine the depth of the deepest leaf node in a binary tree. The function should take two inputs: - n: an integer representing the number of nodes in the tree. - edges: a list of tuples where each tuple (u, v) represents an edge between nodes u and v in the binary tree. The function should return an integer representing the depth of the deepest leaf node. Example: >>> deepest_leaf_depth(5, [(1, 2), (1, 3), (2, 4), (2, 5)]) 2 >>> deepest_leaf_depth(3, [(1, 2), (1, 3)]) 1 Test cases: def test_deepest_leaf_depth(): # Example case n = 5 edges = [(1, 2), (1, 3), (2, 4), (2, 5)] assert deepest_leaf_depth(n, edges) == 2 # Additional test cases n = 3 edges = [(1, 2), (1, 3)] assert deepest_leaf_depth(n, edges) == 1 n = 7 edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (6, 7)] assert deepest_leaf_depth(n, edges) == 3 n = 4 edges = [(1, 2), (2, 3), (3, 4)] assert deepest_leaf_depth(n, edges) == 3 n = 6 edges = [(1, 2), (1, 3), (2, 4), (4, 5), (5, 6)] assert deepest_leaf_depth(n, edges) == 4 if __name__ == '__main__': test_deepest_leaf_depth() print(\\"All test cases passed\\")","solution":"def deepest_leaf_depth(n, edges): from collections import defaultdict, deque # Create the adjacency list for the tree tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) # Function to perform BFS and find the depth of the deepest leaf def bfs_depth(root): visited = set() queue = deque([(root, 0)]) # (node, depth) max_depth = 0 while queue: node, depth = queue.popleft() visited.add(node) # Check for children is_leaf = True for child in tree[node]: if child not in visited: is_leaf = False queue.append((child, depth + 1)) if is_leaf: max_depth = max(max_depth, depth) return max_depth # Start BFS from the root node 1 return bfs_depth(1)"},{"question":"def find_unique_element(arr: List[int]) -> int: Given an array where every element appears twice except for one element which appears only once, this function finds and returns the element that appears only once. >>> find_unique_element([4, 3, 2, 4, 1, 3, 2]) 1 >>> find_unique_element([5, 1, 1, 2, 2]) 5 >>> find_unique_element([7]) 7 >>> find_unique_element([1000000, 999999, 999999, 1000000, 123456]) 123456 >>> find_unique_element([10, 20, 30, 20, 30, 40, 10]) 40 >>> find_unique_element([10, -10, -10, 10, -5]) -5","solution":"def find_unique_element(arr): Given an array where every element appears twice except for one element which appears only once, this function finds and returns the element that appears only once. Args: arr : List[int] : list of integers where every element except one appears twice. Returns: int : element that appears only once. unique_element = 0 for num in arr: unique_element ^= num return unique_element"},{"question":"def count_binary_ones(n: int) -> List[int]: Output the counts of binary numbers of length n with exactly 0 to n '1's. Arguments: n -- an integer representing the number of bits in the binary number Returns: A list where the i-th element in the list represents the count of binary numbers with exactly i '1's. >>> count_binary_ones(3) [1, 3, 3, 1] >>> count_binary_ones(0) [1]","solution":"def count_binary_ones(n): Output the counts of binary numbers of length n with exactly 0 to n '1's. Arguments: n -- an integer representing the number of bits in the binary number Returns: A list where the i-th element in the list represents the count of binary numbers with exactly i '1's. from itertools import combinations result = [0] * (n + 1) for ones_count in range(n + 1): result[ones_count] = len(list(combinations(range(n), ones_count))) return result"},{"question":"def is_balanced(S: str) -> str: Determine if the given string S is balanced. A string is balanced if every letter in it appears the same number of times. Args: S (str): The input string consisting of lowercase English letters. Returns: str: 'Yes' if S is balanced, otherwise 'No'. Examples: >>> is_balanced(\\"aabbcc\\") 'Yes' >>> is_balanced(\\"aabbccc\\") 'No' >>> is_balanced(\\"abcabcabc\\") 'Yes' >>> is_balanced(\\"a\\") 'Yes' >>> is_balanced(\\"aaabbb\\") 'Yes' >>> is_balanced(\\"aabb aa bb cc\\") 'No' >>> is_balanced(\\"ab\\" * 50000) 'Yes' >>> is_balanced(\\"a\\" * 50001 + \\"b\\" * 49999) 'No'","solution":"def is_balanced(S: str) -> str: Determine if the given string S is balanced. A string is balanced if every letter in it appears the same number of times. Args: S (str): The input string consisting of lowercase English letters. Returns: str: 'Yes' if S is balanced, otherwise 'No'. from collections import Counter # Count the frequency of each character in the string frequency = Counter(S) # Get set of unique frequencies unique_frequencies = set(frequency.values()) # Check if there is only one unique frequency if len(unique_frequencies) == 1: return \\"Yes\\" else: return \\"No\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): Merge two sorted linked lists and return it as a new list. >>> l1 = list_to_linked_list([1, 2, 4]) >>> l2 = list_to_linked_list([1, 3]) >>> merged = mergeTwoLists(l1, l2) >>> linked_list_to_list(merged) [1, 1, 2, 3, 4] pass def list_to_linked_list(lst): Convert a list to a linked list. >>> list_to_linked_list([1, 2, 3]).val 1 pass def linked_list_to_list(head): Convert a linked list to a list. >>> node = ListNode(1, ListNode(2, ListNode(3))) >>> linked_list_to_list(node) [1, 2, 3] pass def test_merge_empty_lists(): l1 = list_to_linked_list([]) l2 = list_to_linked_list([]) merged = mergeTwoLists(l1, l2) assert linked_list_to_list(merged) == [] def test_merge_one_empty_list(): l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([]) merged = mergeTwoLists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 4] l1 = list_to_linked_list([]) l2 = list_to_linked_list([1, 3]) merged = mergeTwoLists(l1, l2) assert linked_list_to_list(merged) == [1, 3] def test_merge_non_empty_lists(): l1 = list_to_linked_list([1, 2, 4]) l2 = list_to_linked_list([1, 3]) merged = mergeTwoLists(l1, l2) assert linked_list_to_list(merged) == [1, 1, 2, 3, 4] def test_merge_mixed_values(): l1 = list_to_linked_list([2, 5, 7]) l2 = list_to_linked_list([1, 3, 4, 6]) merged = mergeTwoLists(l1, l2) assert linked_list_to_list(merged) == [1, 2, 3, 4, 5, 6, 7]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def mergeTwoLists(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next def list_to_linked_list(lst): dummy = ListNode() current = dummy for val in lst: current.next = ListNode(val) current = current.next return dummy.next def linked_list_to_list(head): result = [] while head: result.append(head.val) head = head.next return result"},{"question":"def reward_top_users(n: int, t: int, users_purchases: List[Tuple[str, int]]) -> List[str]: Determines the top t users with the highest purchase amounts. Parameters: - n (int): Total number of users - t (int): Number of top users to reward - users_purchases (list of tuples): List containing tuples with username and purchase amount Returns: - list: List of usernames in descending order of their total purchase amounts pass from solution import reward_top_users def test_reward_top_users_example_1(): n, t = 5, 3 users_purchases = [(\\"alice\\", 1500), (\\"bob\\", 1900), (\\"charlie\\", 1800), (\\"david\\", 1900), (\\"eve\\", 1300)] assert reward_top_users(n, t, users_purchases) == [\\"bob\\", \\"david\\", \\"charlie\\"] def test_reward_top_users_example_2(): n, t = 4, 2 users_purchases = [(\\"xander\\", 5000), (\\"yvonne\\", 3200), (\\"zeph\\", 3200), (\\"wendy\\", 2800)] assert reward_top_users(n, t, users_purchases) == [\\"xander\\", \\"yvonne\\"] def test_reward_top_users_all_same_amount(): n, t = 3, 2 users_purchases = [(\\"alice\\", 1000), (\\"bob\\", 1000), (\\"charlie\\", 1000)] assert reward_top_users(n, t, users_purchases) == [\\"alice\\", \\"bob\\"] def test_reward_top_users_t_equals_n(): n, t = 3, 3 users_purchases = [(\\"alice\\", 1500), (\\"bob\\", 1900), (\\"charlie\\", 1800)] assert reward_top_users(n, t, users_purchases) == [\\"bob\\", \\"charlie\\", \\"alice\\"] def test_reward_top_users_t_is_one(): n, t = 4, 1 users_purchases = [(\\"alice\\", 2000), (\\"bob\\", 1800), (\\"charlie\\", 1700), (\\"diana\\", 1600)] assert reward_top_users(n, t, users_purchases) == [\\"alice\\"]","solution":"def reward_top_users(n, t, users_purchases): Determines the top t users with the highest purchase amounts. Parameters: - n (int): Total number of users - t (int): Number of top users to reward - users_purchases (list of tuples): List containing tuples with username and purchase amount Returns: - list: List of usernames in descending order of their total purchase amounts # Sort users by (-amount_spent, username) sorted_users = sorted(users_purchases, key=lambda user: (-user[1], user[0])) # Extract the top t usernames result = [username for username, amount in sorted_users[:t]] return result # Example usage: # n, t = 5, 3 # users_purchases = [(\\"alice\\", 1500), (\\"bob\\", 1900), (\\"charlie\\", 1800), (\\"david\\", 1900), (\\"eve\\", 1300)] # print(reward_top_users(n, t, users_purchases)) # Output: ['bob', 'david', 'charlie']"},{"question":"from typing import List def canPartition(nums: List[int]) -> bool: Determines if the given set of integers can be partitioned into two subsets such that the sum of elements in both subsets is equal. >>> canPartition([1, 5, 11, 5]) True >>> canPartition([1, 2, 3, 5]) False def test_example_1(): nums = [1, 5, 11, 5] assert canPartition(nums) == True def test_example_2(): nums = [1, 2, 3, 5] assert canPartition(nums) == False def test_single_element(): nums = [1] assert canPartition(nums) == False def test_two_elements_equal(): nums = [1, 1] assert canPartition(nums) == True def test_two_elements_not_equal(): nums = [1, 2] assert canPartition(nums) == False def test_large_sum(): nums = [100, 100, 100, 100, 100, 100, 100, 100, 100, 100] assert canPartition(nums) == True def test_odd_total_sum(): nums = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1] assert canPartition(nums) == False def test_multiple_zero_elements(): nums = [0, 0, 0, 0, 0, 0] assert canPartition(nums) == True def test_partitionable_with_zeros(): nums = [0, 0, 1, 1] assert canPartition(nums) == True def test_non_partitionable_large_elements(): nums = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10] assert canPartition(nums) == False","solution":"from typing import List def canPartition(nums: List[int]) -> bool: Determines if the given set of integers can be partitioned into two subsets such that the sum of elements in both subsets is equal. total_sum = sum(nums) # If total sum is odd, it's not possible to partition into equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Using dynamic programming to find if there's a subset with sum equal to target dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def top_k_students(N: int, K: int, students_data: List[Tuple[int, ...]]) -> List[int]: This function returns the top K students based on their average grades. If two students have the same average grade, the one with the higher ID is ranked higher. :param N: The number of students :param K: The top number of students to retrieve :param students_data: List of tuples, each containing a student ID and their list of grades :return: List of student IDs of the top K students pass def parse_input(input_lines: List[str]) -> Tuple[int, int, List[Tuple[int, ...]]]: This function parses the input from the list of strings into appropriate variables. :param input_lines: List of input strings :return: Tuple containing (N, K, students_data) pass from solution import top_k_students, parse_input def test_top_k_students_basic(): input_lines = [ \\"5 3\\", \\"123 95 85 76 88 70 -1\\", \\"456 100 92 78 -1\\", \\"789 85 90 93 78 -1\\", \\"654 70 80 65 85 90 -1\\", \\"321 88 74 91 -1\\" ] N, K, students_data = parse_input(input_lines) assert top_k_students(N, K, students_data) == [456, 789, 321] def test_with_equal_averages_higher_ID(): input_lines = [ \\"4 2\\", \\"123 80 80 80 -1\\", \\"456 80 80 80 -1\\", \\"789 90 90 90 -1\\", \\"321 60 60 60 -1\\" ] N, K, students_data = parse_input(input_lines) assert top_k_students(N, K, students_data) == [789, 456] def test_min_values(): input_lines = [ \\"1 1\\", \\"1 0 0 0 0 0 -1\\" ] N, K, students_data = parse_input(input_lines) assert top_k_students(N, K, students_data) == [1] def test_max_values(): input_lines = [ \\"3 3\\", \\"100000 100 100 100 100 100 -1\\", \\"99999 95 95 95 95 95 -1\\", \\"99998 90 90 90 90 90 -1\\" ] N, K, students_data = parse_input(input_lines) assert top_k_students(N, K, students_data) == [100000, 99999, 99998] def test_parse_input(): input_lines = [ \\"5 3\\", \\"123 95 85 76 88 70 -1\\", \\"456 100 92 78 -1\\", \\"789 85 90 93 78 -1\\", \\"654 70 80 65 85 90 -1\\", \\"321 88 74 91 -1\\" ] expected_students_data = [ (123, 95, 85, 76, 88, 70), (456, 100, 92, 78), (789, 85, 90, 93, 78), (654, 70, 80, 65, 85, 90), (321, 88, 74, 91) ] N, K, students_data = parse_input(input_lines) assert (N, K) == (5, 3) assert students_data == expected_students_data","solution":"def top_k_students(N, K, students_data): This function returns the top K students based on their average grades. If two students have the same average grade, the one with the higher ID is ranked higher. :param N: The number of students :param K: The top number of students to retrieve :param students_data: List of tuples, each containing a student ID and their list of grades :return: List of student IDs of the top K students students_avg_grades = [] for student in students_data: student_id = student[0] grades = student[1:] average_grade = sum(grades) / len(grades) students_avg_grades.append((average_grade, student_id)) # Sort by average grade first (descending), then by student ID (descending) students_avg_grades.sort(key=lambda x: (x[0], x[1]), reverse=True) # Retrieve top K student IDs top_k_ids = [student_id for _, student_id in students_avg_grades[:K]] return top_k_ids def parse_input(input_lines): This function parses the input from the list of strings into appropriate variables. :param input_lines: List of input strings :return: Tuple containing (N, K, students_data) header = input_lines[0].split() N = int(header[0]) K = int(header[1]) students_data = [] for line in input_lines[1:]: parts = list(map(int, line.split())) student_id = parts[0] grades = parts[1:-1] # Ignore the terminating '-1' students_data.append((student_id, *grades)) return N, K, students_data"},{"question":"def get_week_label(week_number: int) -> str: Given the week number (1 to 15), returns the corresponding weekly label. Parameters: week_number (int): An integer between 1 and 15 (inclusive) representing the week number. Returns: str: The label of the week in the format 'Week{week_number}'. >>> get_week_label(1) 'Week1' >>> get_week_label(8) 'Week8' >>> get_week_label(15) 'Week15'","solution":"def get_week_label(week_number): Given the week number (1 to 15), returns the corresponding weekly label. Parameters: week_number (int): An integer between 1 and 15 (inclusive) representing the week number. Returns: str: The label of the week in the format 'Week{week_number}'. if 1 <= week_number <= 15: return f\\"Week{week_number}\\" else: raise ValueError(\\"week_number must be between 1 and 15\\")"},{"question":"def max_nutritional_value(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determines the maximum nutritional value Alice can get in one day for each test case. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, List[int]]]): List of tuples where each tuple contains: - n (int): The total number of fruits. - k (int): The maximum number of fruits Alice can eat in a day. - values (List[int]): The nutritional values of the fruits. Returns: List[int]: A list of integers representing the maximum nutritional value for each test case. >>> max_nutritional_value(3, [(6, 3, [1, 2, 3, 4, 5, 6]), (5, 2, [5, 3, 8, 6, 2]), (4, 1, [10, 20, 30, 40])]) [15, 14, 40]","solution":"def max_nutritional_value(t, test_cases): For each test case, determine the maximum nutritional value Alice can get in one day. t: int - the number of test cases test_cases: list of tuples - each tuple contains (n, k, values) Returns a list of integers representing the maximum nutritional value for each test case. results = [] for n, k, values in test_cases: # Sort the nutritional values in descending order values.sort(reverse=True) # Take the top 'k' values to maximize the nutritional intake max_value = sum(values[:k]) results.append(max_value) return results"},{"question":"def longest_common_subsequence(a: str, b: str) -> int: Determines the length of the longest string that is a subsequence of both a and b. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0","solution":"def longest_common_subsequence(a, b): Determines the length of the longest string that is a subsequence of both a and b. m, n = len(a), len(b) # Table to store lengths of longest common subsequences dp = [[0] * (n + 1) for _ in range(m + 1)] # Building the dp table for i in range(1, m + 1): for j in range(1, n + 1): if a[i - 1] == b[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def fetch_data(max_calls_per_minute: int) -> list: Fetches data from the API while adhering to the rate limit. Parameters: max_calls_per_minute (int): The maximum number of API calls allowed per minute. Returns: list: A list of all successfully fetched data. from solution import fetch_data, mock_api_call def test_fetch_data_rate_limit(): data = fetch_data(10) assert len(data) <= 10 assert all(d == \\"Some data\\" for d in data) def test_fetch_data_handles_errors(): data = fetch_data(100) assert len(data) <= 100 def test_fetch_data_rate_limit_exceeded(): # Mock the function to always simulate rate limit exceeded original_mock_api_call = mock_api_call def mock_rate_limited_api_call(): return { \\"status\\": \\"error\\", \\"data\\": None, \\"error_message\\": \\"Rate limit exceeded\\" } import solution solution.mock_api_call = mock_rate_limited_api_call data = fetch_data(10) assert len(data) == 0 # Reset mock solution.mock_api_call = original_mock_api_call def test_fetch_data_all_success(): # Mock the function to always succeed original_mock_api_call = mock_api_call def mock_success_api_call(): return { \\"status\\": \\"ok\\", \\"data\\": \\"Some data\\", \\"error_message\\": None } import solution solution.mock_api_call = mock_success_api_call data = fetch_data(10) assert len(data) == 10 # Reset mock solution.mock_api_call = original_mock_api_call","solution":"import time def fetch_data(max_calls_per_minute: int) -> list: Fetches data from the API while adhering to the rate limit. Parameters: max_calls_per_minute (int): The maximum number of API calls allowed per minute. Returns: list: A list of all successfully fetched data. start_time = time.time() data_list = [] call_count = 0 while len(data_list) < max_calls_per_minute: if call_count >= max_calls_per_minute: # If call count reaches the rate limit, wait until the next minute while time.time() - start_time < 60: time.sleep(1) start_time = time.time() call_count = 0 # Reset the call count result = mock_api_call() call_count += 1 if result['status'] == 'ok': data_list.append(result['data']) elif result['error_message'] == 'Rate limit exceeded': break return data_list def mock_api_call(): import random if random.randint(1, 10) <= 2: return { \\"status\\": \\"error\\", \\"data\\": None, \\"error_message\\": \\"Rate limit exceeded\\" } elif random.randint(1, 10) <= 3: return { \\"status\\": \\"error\\", \\"data\\": None, \\"error_message\\": \\"Some other error\\" } else: return { \\"status\\": \\"ok\\", \\"data\\": \\"Some data\\", \\"error_message\\": None }"},{"question":"from typing import List, Tuple def open_vault(N: int, S: int, buttons: List[int]) -> Tuple[str, List[int]]: Determine if it's possible to press a unique combination of enabled buttons to achieve the target sum Example: >>> open_vault(5,15,[1,2,3,4,5]) (\\"YES\\", [1, 2, 3, 4, 5]) >>> open_vault(5,10,[1,2,3,4,0]) (\\"YES\\", [1, 2, 3, 4]) >>> open_vault(5,9,[1,2,3,0,5]) (\\"YES\\", [1, 3, 5]) >>> open_vault(5,25,[1,2,3,4,5]) (\\"NO\\", []) >>> open_vault(5,10,[0,0,0,0,0]) (\\"NO\\", [])","solution":"def open_vault(N, S, buttons): from itertools import combinations # Filter out disabled buttons valid_buttons = [b for b in buttons if b != 0] # Try all combinations of buttons for r in range(1, len(valid_buttons) + 1): for combo in combinations(valid_buttons, r): if sum(combo) == S: return (\\"YES\\", list(combo)) return (\\"NO\\",) # Example Usage result = open_vault(5, 15, [1, 2, 3, 4, 5]) print(result)"},{"question":"def max_non_overlapping_jobs(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of non-overlapping jobs the machine can process for each test case. >>> max_non_overlapping_jobs(2, [(3, [(1, 4), (2, 6), (5, 8)]), (4, [(1, 5), (3, 7), (2, 4), (6, 8)])]) == [2, 2] >>> max_non_overlapping_jobs(1, [(5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)])]) == [5]","solution":"def max_non_overlapping_jobs(T, test_cases): results = [] for case in test_cases: N, jobs = case jobs.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for job in jobs: start, end = job if start >= last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"from typing import List def shortest_path(n: int, m: int, grid: List[List[int]]) -> int: Returns the length of the shortest path from (0, 0) to (n-1, m-1) avoiding hurdles. If there is no path, returns -1. >>> grid = [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ] >>> shortest_path(3, 3, grid) 4 >>> grid = [ ... [0, 0, 1], ... [0, 1, 0], ... [1, 0, 0] ... ] >>> shortest_path(3, 3, grid) -1 # Your code here","solution":"from collections import deque def shortest_path(n, m, grid): Returns the length of the shortest path from (0, 0) to (n-1, m-1) avoiding hurdles. If there is no path, returns -1. if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 # Directions for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # BFS queue queue = deque([(0, 0, 0)]) # (row, col, distance) visited = set() visited.add((0, 0)) while queue: row, col, dist = queue.popleft() # If we reached the bottom-right corner, return the distance if row == n-1 and col == m-1: return dist # Explore neighbors for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and (new_row, new_col) not in visited and grid[new_row][new_col] == 0: visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) # If we exhaust the queue without finding the bottom-right corner, there's no path return -1"},{"question":"def find_majority_element(nums: List[int]) -> int: Write a function \`find_majority_element(nums)\` that takes a list of integers \`nums\` and returns the element that appears more than ⌊n / 2⌋ times, where n is the length of the list. If no such element exists, return \`None\`. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None","solution":"from typing import List def find_majority_element(nums: List[int]) -> int: Returns the element that appears more than ⌊n / 2⌋ times, where n is the length of the list, or None if no such element exists. candidate = None count = 0 # Boyer-Moore Voting Algorithm for num in nums: if count == 0: candidate = num count = 1 elif candidate == num: count += 1 else: count -= 1 # Verify if the candidate is actually the majority element if nums.count(candidate) > len(nums) // 2: return candidate return None"},{"question":"def is_palindrome(strings: List[str]) -> List[str]: Given a list of strings, returns a list of \\"Yes\\" or \\"No\\" depending on whether each string is a palindrome. >>> is_palindrome([\\"madam\\", \\"hello\\", \\"RaceCar\\"]) ['Yes', 'No', 'Yes'] >>> is_palindrome([\\"level\\", \\"Algorithm\\"]) ['Yes', 'No']","solution":"def is_palindrome(strings): Given a list of strings, returns a list of \\"Yes\\" or \\"No\\" depending on whether each string is a palindrome. results = [] for s in strings: if s.lower() == s.lower()[::-1]: # Convert to lowercase for case-insensitivity and check palindrome results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def max_hourglass_sum(arr: List[List[int]]) -> int: Find the maximum sum of an hourglass in a given 6x6 2D array. >>> max_hourglass_sum([ ... [1, 1, 1, 0, 0, 0], ... [0, 1, 0, 0, 0, 0], ... [1, 1, 1, 0, 0, 0], ... [0, 0, 2, 4, 4, 0], ... [0, 0, 0, 2, 0, 0], ... [0, 0, 1, 2, 4, 0] ... ]) 19 >>> max_hourglass_sum([ ... [-1, -1, 0, -9, -2, -2], ... [-2, -1, -6, -8, -2, -5], ... [-1, -1, -1, -2, -3, -4], ... [-1, -9, -2, -4, -4, -5], ... [-7, -3, -3, -2, -9, -9], ... [-1, -3, -1, -2, -4, -5] ... ]) -6","solution":"def max_hourglass_sum(arr): max_sum = -63 # Since the minimum hourglass sum is -63 (7 * -9) for i in range(4): for j in range(4): top = arr[i][j] + arr[i][j+1] + arr[i][j+2] middle = arr[i+1][j+1] bottom = arr[i+2][j] + arr[i+2][j+1] + arr[i+2][j+2] hourglass_sum = top + middle + bottom if hourglass_sum > max_sum: max_sum = hourglass_sum return max_sum"},{"question":"def minimum_swaps_to_sort_books(n: int, widths: List[int]) -> int: Returns the minimum number of adjacent swaps required to sort book widths in non-decreasing order. Parameters: n (int): The number of books. widths (List[int]): The widths of the books. Returns: int: The minimum number of swaps required to sort the books. Examples: >>> minimum_swaps_to_sort_books(4, [4, 3, 2, 1]) 6 >>> minimum_swaps_to_sort_books(3, [3, 1, 2]) 2 >>> minimum_swaps_to_sort_books(5, [1, 2, 3, 4, 5]) 0","solution":"def minimum_swaps_to_sort_books(n, widths): Returns the minimum number of adjacent swaps required to sort book widths in non-decreasing order. swaps = 0 # Bubble sort to count swaps for i in range(n): for j in range(0, n-i-1): if widths[j] > widths[j+1]: # Swap and count widths[j], widths[j+1] = widths[j+1], widths[j] swaps += 1 return swaps"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given list. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60]) 5 >>> longest_increasing_subsequence([5, 3, 4, 8, 6]) 3 >>> longest_increasing_subsequence([10]) 1 >>> longest_increasing_subsequence([7, 7, 7, 7, 7]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6, 7, 8]) 8 >>> longest_increasing_subsequence([8, 7, 6, 5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 >>> longest_increasing_subsequence(list(range(1, 2501))) 2500","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list. n = len(arr) if n == 0: return 0 # Initialize the lis array to store the length of the longest increasing subsequence ending at each index lis = [1] * n # Compute the length of the longest increasing subsequence for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis)"},{"question":"def max_height_difference(N: int, K: int, heights: List[int]) -> int: Find the maximum possible height difference between the tallest and shortest building after performing exactly K operations. >>> max_height_difference(5, 3, [1, 2, 3, 4, 5]) 7 >>> max_height_difference(4, 10, [1, 1, 1, 1]) 10 >>> max_height_difference(5, 0, [1, 2, 3, 4, 5]) 4 >>> max_height_difference(1, 5, [10]) 5 >>> max_height_difference(4, 6, [2, 2, 2, 2]) 6 >>> max_height_difference(3, 1000000, [1, 2, 3]) 1000002","solution":"def max_height_difference(N, K, heights): Find the maximum possible height difference between the tallest and shortest building after performing exactly K operations. min_height = min(heights) max_height = max(heights) # The minimal building height would be maximized incrementally new_min_height = min_height + K # Compute the difference between the tallest building and the new minimal height max_difference = max_height - min_height + K return max_difference"},{"question":"import heapq from typing import List def min_time_to_attend_patients(N: int, M: int, patient_times: List[int]) -> int: Determines the minimum time required for all doctors to attend to all patients at least once. :param N: Number of doctors. :param M: Number of patients. :param patient_times: List of patient times each patient requires. :return: Minimum time required for all doctors to attend to all patients. >>> min_time_to_attend_patients(3, 6, [7, 10, 4, 8, 9, 6]) 15 >>> min_time_to_attend_patients(10, 5, [4, 6, 7, 9, 5]) 9 >>> min_time_to_attend_patients(1, 4, [2, 8, 3, 5]) 18 >>> min_time_to_attend_patients(4, 4, [3, 9, 1, 7]) 9 >>> min_time_to_attend_patients(2, 5, [10**6, 10**6, 10**6, 10**6, 10**6]) 3000000 >>> min_time_to_attend_patients(3, 5, [5, 5, 5, 5, 5]) 10","solution":"import heapq def min_time_to_attend_patients(N, M, patient_times): Determines the minimum time required for all doctors to attend to all patients at least once. if N >= M: return max(patient_times) patient_times.sort(reverse=True) doctors = [0] * N heapq.heapify(doctors) for time in patient_times: earliest_available = heapq.heappop(doctors) heapq.heappush(doctors, earliest_available + time) return max(doctors)"},{"question":"def find_pair_with_target_sum(arr, target): Determine if there are two distinct integers in the array that add up to the target sum. If such a pair exists, print \\"YES\\" followed by the pair of integers. If no such pair exists, print \\"NO\\". >>> find_pair_with_target_sum([1, 2, 3, 4, 5], 7) YES 3 4 >>> find_pair_with_target_sum([-1, 0, 1, 2], 5) NO","solution":"def find_pair_with_target_sum(arr, target): Determine if there are two distinct integers in the array that add up to the target sum. If such a pair exists, print \\"YES\\" followed by the pair of integers. If no such pair exists, print \\"NO\\". seen = set() for number in arr: complement = target - number if complement in seen: print(\\"YES\\", complement, number) return seen.add(number) print(\\"NO\\")"},{"question":"from typing import List def min_operations_to_equalize_array(N: int, A: List[int]) -> int: Determine the minimum number of operations required to make all elements of the array A equal. >>> min_operations_to_equalize_array(3, [1, 2, 3]) 2 >>> min_operations_to_equalize_array(4, [4, 4, 4, 4]) 0 >>> min_operations_to_equalize_array(5, [1, 5, 1, 1, 1]) 3 # Test Cases def test_min_operations_to_equalize_array(): assert min_operations_to_equalize_array(3, [1, 2, 3]) == 2 assert min_operations_to_equalize_array(4, [4, 4, 4, 4]) == 0 assert min_operations_to_equalize_array(5, [1, 5, 1, 1, 1]) == 1 assert min_operations_to_equalize_array(1, [100]) == 0 assert min_operations_to_equalize_array(3, [100, 100, 200]) == 1 assert min_operations_to_equalize_array(6, [1, 1, 1, 2, 2, 2]) == 3 assert min_operations_to_equalize_array(5, [1, 2, 3, 4, 5]) == 4 def test_large_input(): assert min_operations_to_equalize_array(100, [1]*50 + [2]*50) == 50 def test_already_equal(): assert min_operations_to_equalize_array(10, [1]*10) == 0","solution":"def min_operations_to_equalize_array(N, A): from collections import Counter counter = Counter(A) most_common = counter.most_common(1)[0][1] return N - most_common # Reading input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:])) print(min_operations_to_equalize_array(N, A))"},{"question":"def find_pairs(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: For each test case, determine if there exists a pair of distinct indices \`(i, j)\` such that \`arr[j] - arr[i] = d\` and \`i < j\`. Args: test_cases: List of tuples, where each tuple contains an integer \`n\`, an integer \`d\`, and a list of integers \`arr\`. Returns: List of strings, where each string is either \\"Yes\\" or \\"No\\". >>> find_pairs([(5, 3, [1, 4, 5, 8, 10]), (4, 7, [2, 9, 3, 1]), (3, 2, [3, 3, 3])]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> find_pairs([(4, 10, [1, 2, 3, 4]), (5, 5, [5, 5, 5, 5, 5])]) [\\"No\\", \\"No\\"] def parse_input(input_string: str) -> List[Tuple[int, int, List[int]]]: Parse the input string to extract the number of test cases and each test case as a tuple. Args: input_string: Input string containing multiple test cases. Returns: List of tuples, where each tuple contains an integer \`n\`, an integer \`d\`, and a list of integers \`arr\`. >>> parse_input(\\"3n5 3n1 4 5 8 10nn4 7n2 9 3 1nn3 2n3 3 3\\") [(5, 3, [1, 4, 5, 8, 10]), (4, 7, [2, 9, 3, 1]), (3, 2, [3, 3, 3])]","solution":"def find_pairs(test_cases): results = [] for case in test_cases: n, d, arr = case found = False for i in range(n): for j in range(i + 1, n): if arr[j] - arr[i] == d: found = True break if found: break if found: results.append(\\"Yes\\") else: results.append(\\"No\\") return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) cases = [] i = 1 while i < len(lines): if lines[i].strip() == \\"\\": i += 1 continue n, d = map(int, lines[i].strip().split()) arr = list(map(int, lines[i + 1].strip().split())) cases.append((n, d, arr)) i += 2 return cases # Example usage: input_string = 3 5 3 1 4 5 8 10 4 7 2 9 3 1 3 2 3 3 3 test_cases = parse_input(input_string) results = find_pairs(test_cases) for result in results: print(result)"},{"question":"def longest_palindrome_subsequence_length(s: str) -> int: Returns the length of the longest palindromic subsequence that can be rearranged from the given string. >>> longest_palindrome_subsequence_length(\\"abccba\\") == 6 >>> longest_palindrome_subsequence_length(\\"abcdefg\\") == 1","solution":"from collections import Counter def longest_palindrome_subsequence_length(s): Returns the length of the longest palindromic subsequence that can be rearranged from the given string. freq = Counter(s) length = 0 odd_count = 0 for count in freq.values(): # Add the largest even number that is less than or equal to \`count\`. length += count // 2 * 2 # Check if there is an odd count character. if count % 2 == 1: odd_count = 1 # If there is any character with an odd count, we can add one to the length. return length + odd_count"},{"question":"def count_distinct_vowels(s: str) -> int: Returns the count of distinct vowels in the input string. :param s: Input string consisting of lowercase and uppercase English letters. :return: Count of distinct vowels in the input string. >>> count_distinct_vowels(\\"hello\\") == 2 >>> count_distinct_vowels(\\"AEIOU\\") == 5 >>> count_distinct_vowels(\\"HELlo\\") == 2","solution":"def count_distinct_vowels(s): Returns the count of distinct vowels in the input string. :param s: Input string consisting of lowercase and uppercase English letters. :return: Count of distinct vowels in the input string. vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'} distinct_vowels = set() for char in s: if char in vowels: distinct_vowels.add(char.lower()) return len(distinct_vowels)"},{"question":"def determine_winner(S: str) -> str: Determines if Alice can force a win in the game by playing optimally. :param S: A binary string :return: \\"Alice\\" if Alice can force a win, otherwise \\"Bob\\" >>> determine_winner(\\"1101\\") \\"Alice\\" >>> determine_winner(\\"000\\") \\"Bob\\"","solution":"def determine_winner(S): Determines if Alice can force a win. Alice wins if there is at least one '1' in the string. :param S: A binary string :return: \\"Alice\\" if Alice can force a win, otherwise \\"Bob\\" if '1' in S: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def max_orders(t: int, test_cases: List[Dict[str, Tuple]]) -> List[int]: Determines the maximum number of orders that can be fulfilled. Args: t (int): The number of test cases. test_cases (List[Dict[str, Tuple]]): A list of dictionaries, where each dictionary contains: - 'info': A tuple containing three integers: - w (int): The number of warehouses. - d (int): The number of delivery trucks available in total. - k (int): The delivery capacity of each truck. - 'inventories': A list of integers representing the number of units of products available in each warehouse. Returns: List[int]: A list of integers representing the maximum number of orders fulfilled for each test case. Example: >>> max_orders(2, [{'info': (3, 10, 5), 'inventories': [10, 20, 15]}, {'info': (4, 7, 4), 'inventories': [5, 6, 8, 12]}]) [45, 28] pass","solution":"def max_orders(t, test_cases): results = [] for case in test_cases: w, d, k = case['info'] inventories = case['inventories'] orders_fulfilled = 0 truck_counts = [inv // k for inv in inventories] while d > 0 and any(truck_counts): max_trucks = max(truck_counts) idx = truck_counts.index(max_trucks) used_trucks = min(max_trucks, d) orders_fulfilled += used_trucks * k d -= used_trucks truck_counts[idx] = 0 # Mark this warehouse as used up results.append(orders_fulfilled) return results # Example usage: # Test cases t = 2 test_cases = [ {'info': (3, 10, 5), 'inventories': [10, 20, 15]}, {'info': (4, 7, 4), 'inventories': [5, 6, 8, 12]}, ] # Compute results results = max_orders(t, test_cases) print(results) # Output should be [45, 28]"},{"question":"def is_prime(num): Check if a number is prime. >>> is_prime(2) True >>> is_prime(4) False >>> is_prime(11) True >>> is_prime(-1) False ... def can_be_partitioned(arr): Check if the array can be partitioned such that each subarray's sum is a prime number. >>> can_be_partitioned([2, 3, 5, 7]) True >>> can_be_partitioned([1, -1, 3]) False >>> can_be_partitioned([11, 13, 17, 19]) True >>> can_be_partitioned([6, 7, 8]) False ... def susans_game(T, test_cases): Determine if the array can be partitioned such that each contiguous subarray's sum is a prime number. >>> test_cases = [{'N': 4, 'array': [2, 3, 5, 7]}, {'N': 3, 'array': [1, -1, 3]}] >>> susans_game(2, test_cases) [\\"Possible\\", \\"Impossible\\"] >>> test_cases = [{'N': 5, 'array': [11, 13, 17, 19, 23]}, {'N': 4, 'array': [4, 6, 8, 9]}] >>> susans_game(2, test_cases) [\\"Possible\\", \\"Impossible\\"] ...","solution":"def is_prime(num): if num <= 1: return False elif num <= 3: return True elif num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def can_be_partitioned(arr): for num in arr: if not is_prime(num): return False return True def susans_game(T, test_cases): results = [] for i in range(T): N = test_cases[i]['N'] arr = test_cases[i]['array'] if can_be_partitioned(arr): results.append(\\"Possible\\") else: results.append(\\"Impossible\\") return results"},{"question":"def num_paths(R: int, C: int, grid: List[str]) -> int: Determine the number of distinct paths from the top-left cell at (1, 1) to the bottom-right cell at (R, C) that do not revisit any cell. You can move only right or down from any cell. >>> num_paths(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths(4, 4, [\\"...#\\", \\".#..\\", \\"#...\\", \\"...#\\"]) 0","solution":"def num_paths(R, C, grid): # If the start or end is blocked, no paths are possible if grid[0][0] == '#' or grid[R-1][C-1] == '#': return 0 # DP table to store the number of paths to each cell dp = [[0] * C for _ in range(R)] dp[0][0] = 1 # Start position has one way to reach for r in range(R): for c in range(C): if grid[r][c] == '#': dp[r][c] = 0 # No paths through a blocked cell else: if r > 0: dp[r][c] += dp[r-1][c] # From top cell if c > 0: dp[r][c] += dp[r][c-1] # From left cell return dp[R-1][C-1]"},{"question":"from typing import List, Tuple from collections import deque, defaultdict def friendship_levels(n: int, m: int, friendships: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determine the level of friendship between pairs of individuals in a social network. Level 1 friendship means direct friends, level 2 friendship means friends of friends, and so on. If two individuals are not connected by any level of friendship, their level is considered infinite. Args: n (int): the number of people. m (int): the number of friendships. friendships (List[Tuple[int, int]]): each tuple u, v indicating that person u and person v are friends. queries (List[Tuple[int, int]]): each tuple a, b representing the pair of individuals to determine the level of friendship. Returns: List[int]: the level of friendship for each query or \\"Infinity\\" if not connected. Example: >>> friendship_levels(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)], [(1, 4), (1, 5), (2, 6)]) [3, 4, 4] >>> friendship_levels(5, 0, [], [(1, 2), (3, 4), (4, 5)]) [\\"Infinity\\", \\"Infinity\\", \\"Infinity\\"]","solution":"from collections import deque, defaultdict def friendship_levels(n, m, friendships, queries): adjacency_list = defaultdict(list) # Build the graph for u, v in friendships: adjacency_list[u].append(v) adjacency_list[v].append(u) def bfs(start, end): if start == end: return 0 queue = deque([(start, 0)]) visited = set() visited.add(start) while queue: current_node, level = queue.popleft() for neighbor in adjacency_list[current_node]: if neighbor not in visited: if neighbor == end: return level + 1 visited.add(neighbor) queue.append((neighbor, level + 1)) return float('inf') results = [] for a, b in queries: level = bfs(a, b) if level == float('inf'): results.append(\\"Infinity\\") else: results.append(level) return results"},{"question":"class SegmentTree: def __init__(self, data): # Initialize the segment tree with a data array pass def build(self, data): # Build the segment tree pass def update(self, pos, value): # Update a specific element in the segment tree pass def range_query(self, left, right): # Query the sum of a specified subsequence pass def process_queries(n, q, array, queries): Process the given queries on the sequence of integers. Args: n : int : Number of integers in the sequence q : int : Number of queries array : List[int] : Sequence of integers queries : List[List[int]] : Queries to be processed Returns: List[int] : Results of the sum queries Example: >>> process_queries(5, 5, [1, 2, 3, 4, 5], [[2, 1, 3], [1, 2, 4], [2, 1, 3], [1, 5, 1], [2, 1, 5]]) [6, 8, 13] >>> process_queries(3, 3, [10, 20, 30], [[2, 1, 3], [1, 2, 50], [2, 1, 3]]) [60, 90] # Inner class SegmentTree defined above pass","solution":"class SegmentTree: def __init__(self, data): n = len(data) self.n = n self.tree = [0] * (2 * n) self.build(data) def build(self, data): # Build the tree for i in range(self.n): self.tree[self.n + i] = data[i] for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[i * 2] + self.tree[i * 2 + 1] def update(self, pos, value): # Update a single element pos += self.n self.tree[pos] = value while pos > 1: pos //= 2 self.tree[pos] = self.tree[2 * pos] + self.tree[2 * pos + 1] def range_query(self, left, right): # Sum on interval [left, right) result = 0 left += self.n right += self.n while left < right: if left % 2 == 1: result += self.tree[left] left += 1 if right % 2 == 1: right -= 1 result += self.tree[right] left //= 2 right //= 2 return result def process_queries(n, q, array, queries): seg_tree = SegmentTree(array) results = [] for query in queries: if query[0] == 1: _, index, newValue = query seg_tree.update(index - 1, newValue) elif query[0] == 2: _, left, right = query results.append(seg_tree.range_query(left - 1, right)) return results"},{"question":"def maximum_magic_power(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the maximum magic power that can be obtained for a given segment of trees. Parameters: n (int): The number of enchanted trees. q (int): The number of queries. a (List[int]): The list of magic power values of each tree. queries (List[Tuple[int, int]]): The list of queries, each containing two integers l and r. Returns: List[int]: A list containing the maximum magic power for each query. >>> maximum_magic_power(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> maximum_magic_power(5, 1, [1, 2, 3, 4, 5], [(3, 3)]) [3]","solution":"def maximum_magic_power(n, q, a, queries): prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + a[i - 1] results = [] for l, r in queries: max_power = prefix_sums[r] - prefix_sums[l - 1] results.append(max_power) return results"},{"question":"def can_be_consecutive(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if the given arrays can be arranged into a permutation of consecutive integers. >>> can_be_consecutive(3, [(4, [1, 4, 3, 2]), (5, [7, 5, 9, 6, 8]), (3, [1, 2, 4])]) ['YES', 'YES', 'NO'] >>> can_be_consecutive(1, [(4, [1000000000, 999999999, 999999998, 999999996])]) ['NO'] >>> can_be_consecutive(1, [(3, [999999998, 999999999, 1000000000])]) ['YES'] >>> can_be_consecutive(1, [(1, [5])]) ['YES'] >>> can_be_consecutive(1, [(2, [2, 2])]) ['NO']","solution":"def can_be_consecutive(t, test_cases): results = [] for i in range(t): n, arr = test_cases[i] arr.sort() is_consecutive = True for j in range(1, n): if arr[j] - arr[j-1] != 1: is_consecutive = False break if is_consecutive: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_min_difference(N: int, A: [int]) -> int: This function returns the difference between the maximum and minimum values in the array A. :param N: int - Size of the array :param A: list of int - The array of integers :return: int - Difference between maximum and minimum value >>> max_min_difference(5, [1, 3, 5, 7, 9]) 8 >>> max_min_difference(1, [100]) 0 >>> max_min_difference(4, [5, 5, 5, 5]) 0 >>> max_min_difference(6, [-10, 0, 10, 20, -20, 5]) 40 >>> max_min_difference(5, [-9, -7, -5, -3, -1]) 8","solution":"def max_min_difference(N, A): This function returns the difference between the maximum and minimum values in the array A. :param N: int - Size of the array :param A: list of int - The array of integers :return: int - Difference between maximum and minimum value max_value = max(A) min_value = min(A) return max_value - min_value"},{"question":"from typing import List, Tuple def merge_intervals(intervals: List[Tuple[str, str]]) -> List[Tuple[str, str]]: Takes a list of intervals and merges overlapping intervals. >>> merge_intervals([(\\"09:00\\", \\"11:00\\"), (\\"10:00\\", \\"12:00\\"), (\\"13:00\\", \\"15:00\\")]) [(\\"09:00\\", \\"12:00\\"), (\\"13:00\\", \\"15:00\\")] >>> merge_intervals([(\\"16:00\\", \\"18:00\\"), (\\"17:00\\", \\"19:00\\")]) [(\\"16:00\\", \\"19:00\\")] def process_input(data: str) -> List[List[Tuple[str, str]]]: Processes the raw input data and returns merged intervals for each dataset. >>> process_input(\\"3n09:00-11:00n10:00-12:00n13:00-15:00n2n16:00-18:00n17:00-19:00n-1n\\") [[(\\"09:00\\", \\"12:00\\"), (\\"13:00\\", \\"15:00\\")], [(\\"16:00\\", \\"19:00\\")]] >>> process_input(\\"1n09:00-10:00n-1n\\") [[(\\"09:00\\", \\"10:00\\")]]","solution":"def merge_intervals(intervals): Takes a list of intervals and merges overlapping intervals. Arguments: intervals -- list of tuples with intervals (start, end) in \\"HH:MM\\" format Returns: A list of merged intervals as tuples (start, end) # Convert \\"HH:MM\\" to minute representation def to_minutes(time): h, m = map(int, time.split(\\":\\")) return h * 60 + m # Convert minute representation back to \\"HH:MM\\" def to_hhmm(minutes): h = minutes // 60 m = minutes % 60 return f\\"{h:02d}:{m:02d}\\" # Convert interval times to minutes for easy sorting and comparison intervals = [(to_minutes(start), to_minutes(end)) for start, end in intervals] intervals.sort() merged = [] for start, end in intervals: if not merged or merged[-1][1] < start: merged.append((start, end)) else: merged[-1] = (merged[-1][0], max(merged[-1][1], end)) return [(to_hhmm(start), to_hhmm(end)) for start, end in merged] def process_input(data): Processes the raw input data and returns merged intervals for each dataset. Arguments: data -- a string containing multiple datasets as described Returns: A list of lists containing merged intervals for each dataset datasets = [] lines = data.strip().split(\\"n\\") i = 0 while i < len(lines): n = int(lines[i]) if n == -1: break intervals = [] for _ in range(n): i += 1 start, end = lines[i].split(\\"-\\") intervals.append((start, end)) merged_intervals = merge_intervals(intervals) datasets.append(merged_intervals) i += 1 return datasets"},{"question":"from typing import List class Tournament: def __init__(self): self.scores = {} def add_result(self, player1: str, player2: str, winner: str) -> None: The result of a match between \`player1\` and \`player2\` is given. \`winner\` is the name of the player who won the match. Args: player1 (str): The first player. player2 (str): The second player. winner (str): The player who won the match. def get_ranking(self) -> List[str]: Returns a list of player names sorted by their ranking. Players with a higher score come first. If scores are the same, players are ranked alphabetically by their names. Returns: List[str]: The ranked players.","solution":"from typing import List class Tournament: def __init__(self): self.scores = {} def add_result(self, player1: str, player2: str, winner: str) -> None: if player1 not in self.scores: self.scores[player1] = 0 if player2 not in self.scores: self.scores[player2] = 0 self.scores[winner] += 1 def get_ranking(self) -> List[str]: return sorted(self.scores.keys(), key=lambda player: (-self.scores[player], player)) # Create an instance of the Tournament class to use for method calls tournament = Tournament()"},{"question":"def find_minimum_platforms(n: int, schedule: List[Tuple[int, int]]) -> int: Determine the minimum number of railway platforms required at the station so that no train has to wait for a platform to become free. Parameters: n (int): Number of trains. schedule (list of tuples): Each tuple contains two integers, the arrival and departure times of a train in a 24-hour format (HHMM). Returns: int: The minimum number of platforms needed. >>> find_minimum_platforms(6, [(900, 910), (940, 1200), (950, 1120), (1100, 1130), (1500, 1900), (1800, 2000)]) 3 >>> find_minimum_platforms(4, [(900, 930), (940, 1000), (1010, 1040), (1050, 1100)]) 1 >>> find_minimum_platforms(4, [(900, 1000), (910, 1010), (920, 1020), (930, 1030)]) 4 >>> find_minimum_platforms(5, [(900, 1200), (910, 1000), (1100, 1130), (1115, 1145), (2000, 2030)]) 3 >>> find_minimum_platforms(4, [(1000, 1100), (1000, 1100), (1000, 1100), (1000, 1100)]) 4 >>> find_minimum_platforms(1, [(1100, 1130)]) 1 >>> find_minimum_platforms(4, [(100, 200), (300, 400), (500, 600), (700, 800)]) 1","solution":"def find_minimum_platforms(n, schedule): Returns the minimum number of platforms required so that no train has to wait for a platform. Parameters: - n: int, number of trains. - schedule: list of tuples, each containing arrival and departure times of trains. arrivals = sorted([train[0] for train in schedule]) departures = sorted([train[1] for train in schedule]) platform_needed = 0 max_platforms = 0 i = 0 j = 0 while (i < n and j < n): if arrivals[i] <= departures[j]: platform_needed += 1 i += 1 if platform_needed > max_platforms: max_platforms = platform_needed else: platform_needed -= 1 j += 1 return max_platforms"},{"question":"def min_operations_to_turn_off_all_bulbs(n: int, s: str) -> int: Returns the minimum number of operations required to turn off all the bulbs only by flipping the state of any single bulb at a time. Parameters: n (int): length of the binary string s (str): binary string representing the state of the bulbs Returns: int: minimum number of operations required to turn off all the bulbs >>> min_operations_to_turn_off_all_bulbs(4, '1100') 2 >>> min_operations_to_turn_off_all_bulbs(5, '10101') 3 # Sample Unit Test def test_min_operations_to_turn_off_all_bulbs(): assert min_operations_to_turn_off_all_bulbs(4, '1111') == 4 assert min_operations_to_turn_off_all_bulbs(5, '00000') == 0 assert min_operations_to_turn_off_all_bulbs(4, '1100') == 2 assert min_operations_to_turn_off_all_bulbs(5, '10101') == 3 assert min_operations_to_turn_off_all_bulbs(6, '100101') == 3 assert min_operations_to_turn_off_all_bulbs(1, '1') == 1 assert min_operations_to_turn_off_all_bulbs(1, '0') == 0","solution":"def min_operations_to_turn_off_all_bulbs(n, s): Returns the minimum number of operations required to turn off all the bulbs only by flipping the state of any single bulb at a time. Parameters: n (int): length of the binary string s (str): binary string representing the state of the bulbs Returns: int: minimum number of operations required to turn off all the bulbs return s.count('1')"},{"question":"def rank_archers(test_cases): Determine the overall ranking of the archers based on their total scores. >>> input_str = '''2 ...3 5 ...8 7 10 10 9 ...9 8 8 7 10 ...6 5 6 7 5 ...2 3 ...5 6 7 ...8 8 8''' >>> expected_output_str = '''1 ...2 ...3 ...2 ...1''' >>> test_cases = parse_input(input_str) >>> results = rank_archers(test_cases) >>> format_output(results) == expected_output_str True >>> input_str = '''1 ...4 4 ...7 7 7 7 ...8 8 8 8 ...7 7 7 7 ...8 8 8 8''' >>> expected_output_str = '''3 ...1 ...3 ...1''' >>> test_cases = parse_input(input_str) >>> results = rank_archers(test_cases) >>> format_output(results) == expected_output_str True >>> input_str = '''1 ...1 1 ...10''' >>> expected_output_str = '''1''' >>> test_cases = parse_input(input_str) >>> results = rank_archers(test_cases) >>> format_output(results) == expected_output_str True >>> input_str = '''1 ...3 1 ...8 ...7 ...8''' >>> expected_output_str = '''1 ...3 ...1''' >>> test_cases = parse_input(input_str) >>> results = rank_archers(test_cases) >>> format_output(results) == expected_output_str True","solution":"def rank_archers(test_cases): results = [] for n, m, scores in test_cases: total_scores = [(sum(arrows), i) for i, arrows in enumerate(scores)] total_scores.sort(reverse=True, key=lambda x: x[0]) ranks = [0] * n rank = 1 same_score_tally = 0 last_score = total_scores[0][0] for i, (score, idx) in enumerate(total_scores): if score != last_score: rank += same_score_tally same_score_tally = 1 last_score = score else: same_score_tally += 1 ranks[idx] = rank results.append(ranks) return results # Utility function to parse the input similar to example given def parse_input(input_str): lines = input_str.strip().split('n') index = 0 t = int(lines[index]) index += 1 test_cases = [] for _ in range(t): n, m = map(int, lines[index].split()) index += 1 scores = [] for _ in range(n): scores.append(list(map(int, lines[index].split()))) index += 1 test_cases.append((n, m, scores)) return test_cases # Utility function to format the output similar to example given def format_output(results): output = [] for result in results: for rank in result: output.append(str(rank)) return \\"n\\".join(output)"},{"question":"def shortest_subarray_with_sum_k(arr, k): Determines the length of the shortest subarray whose sum equals k. If such a subarray does not exist, returns -1. Args: arr (List[int]): List of integers. k (int): The target sum. Returns: int: Length of the shortest subarray with sum equals to k, or -1 if no such subarray exists. Examples: >>> shortest_subarray_with_sum_k([1, 2, 3, 4, 5], 9) 2 >>> shortest_subarray_with_sum_k([1, -1, 1], 3) -1 pass from solution import shortest_subarray_with_sum_k def test_shortest_subarray_with_sum_k(): assert shortest_subarray_with_sum_k([1, 2, 3, 4, 5], 9) == 2 assert shortest_subarray_with_sum_k([1, -1, 1], 3) == -1 assert shortest_subarray_with_sum_k([3, 1, 4, 1, 5], 6) == 2 assert shortest_subarray_with_sum_k([1, 2, 3, 4, 5], 15) == 5 assert shortest_subarray_with_sum_k([5, -2, 3, -1, 2], 3) == 1 assert shortest_subarray_with_sum_k([5, 10, -3, 7, 2], 14) == 3 assert shortest_subarray_with_sum_k([1, 2, 3], 7) == -1 assert shortest_subarray_with_sum_k([-1, -1, 1, 1], -2) == 2 def test_edge_cases(): assert shortest_subarray_with_sum_k([1], 1) == 1 assert shortest_subarray_with_sum_k([0], 0) == 1 assert shortest_subarray_with_sum_k([5], 5) == 1 assert shortest_subarray_with_sum_k([10**4], 10**4) == 1 assert shortest_subarray_with_sum_k([-10**4], -10**4) == 1 assert shortest_subarray_with_sum_k([5, -5, 5], 5) == 1","solution":"def shortest_subarray_with_sum_k(arr, k): Determines the length of the shortest subarray whose sum equals k. If such a subarray does not exist, returns -1. n = len(arr) prefix_sum = 0 min_length = float('inf') prefix_sum_indices = {0: -1} for i in range(n): prefix_sum += arr[i] if (prefix_sum - k) in prefix_sum_indices: min_length = min(min_length, i - prefix_sum_indices[prefix_sum - k]) if prefix_sum not in prefix_sum_indices: prefix_sum_indices[prefix_sum] = i return min_length if min_length != float('inf') else -1"},{"question":"def sand_clock(n: int) -> str: Generates a sand clock pattern with n layers. Parameters: n (int): number of layers in the sand clock. Returns: str: sand clock pattern. >>> sand_clock(3) ''' 1 121 12321 121 1''' >>> sand_clock(4) ''' 1 121 12321 1234321 12321 121 1'''","solution":"def sand_clock(n): Generates a sand clock pattern with n layers. Parameters: n (int): number of layers in the sand clock. Returns: str: sand clock pattern. layers = [] for i in range(1, n + 1): layer = ' ' * (n - i) # Adding leading spaces for j in range(1, i + 1): layer += str(j) for j in range(i - 1, 0, -1): layer += str(j) layers.append(layer) for i in range(n - 1, 0, -1): # Reverse the upper part to form the lower part layers.append(layers[i-1]) return 'n'.join(layers)"},{"question":"def count_buildings_with_sunset_view(buildings): Returns the number of buildings with a direct view of the sunset. Parameters: buildings (list): A list of integers where each integer represents the height of a building. Returns: int: Number of buildings with a direct view of the sunset. Example Usage: >>> count_buildings_with_sunset_view([4, 2, 3, 1]) 3 >>> count_buildings_with_sunset_view([1, 2, 3, 4]) 1 >>> count_buildings_with_sunset_view([4, 4, 4, 4]) 1 >>> count_buildings_with_sunset_view([2, 3, 4, 1, 2, 1]) 3","solution":"def count_buildings_with_sunset_view(buildings): Returns the number of buildings with a direct view of the sunset. Parameters: buildings (list): A list of integers where each integer represents the height of a building. Returns: int: Number of buildings with a direct view of the sunset. if not buildings: return 0 count = 0 max_height_from_right = 0 for height in reversed(buildings): if height > max_height_from_right: count += 1 max_height_from_right = height return count"},{"question":"def sort_advertisements(advertisements: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Sort the advertisements by their priority level and within the same priority by their duration. If both priority and duration are the same, maintain their original order. Parameters: advertisements (list of tuples): Each tuple contains (duration, priority) of an advertisement. Returns: list of tuples: Sorted list of advertisements. >>> sort_advertisements([(10, 3), (15, 2), (10, 3), (20, 1), (10, 2)]) [(20, 1), (10, 2), (15, 2), (10, 3), (10, 3)] >>> sort_advertisements([(10, 1), (20, 1), (5, 1)]) [(5, 1), (10, 1), (20, 1)] >>> sort_advertisements([(10, 3), (10, 3), (10, 3)]) [(10, 3), (10, 3), (10, 3)] >>> sort_advertisements([(30, 5), (20, 3), (10, 4), (5, 2), (25, 5), (15, 2)]) [(5, 2), (15, 2), (20, 3), (10, 4), (25, 5), (30, 5)] >>> sort_advertisements([(10, 1)]) [(10, 1)] >>> sort_advertisements([]) [] # Your implementation here","solution":"def sort_advertisements(advertisements): Sort the advertisements by their priority level and within the same priority by their duration. If both priority and duration are the same, maintain their original order. Parameters: advertisements (list of tuples): Each tuple contains (duration, priority) of an advertisement. Returns: list of tuples: Sorted list of advertisements. return sorted(advertisements, key=lambda x: (x[1], x[0]))"},{"question":"def min_abs_difference_in_ratings(n: int, ratings: List[int]) -> int: Returns the minimum possible absolute difference in ratings between any two participants. >>> min_abs_difference_in_ratings(5, [1, 5, 3, 19, 18]) 1 >>> min_abs_difference_in_ratings(6, [10, 20, 30, 40, 50, 60]) 10 >>> min_abs_difference_in_ratings(3, [5, 1, 9]) 4","solution":"def min_abs_difference_in_ratings(n, ratings): Returns the minimum possible absolute difference in ratings between any two participants. ratings.sort() min_diff = float('inf') for i in range(1, n): min_diff = min(min_diff, ratings[i] - ratings[i - 1]) return min_diff"},{"question":"def longest_beautiful_view(n: int, heights: List[int]) -> int: Determine the length of the longest beautiful view among skyscrapers. Given an array of integers representing the heights of consecutive skyscrapers, a beautiful view is defined as a sequence of consecutive observations where each observation is from a higher viewpoint than the previous one. Find the length of the longest beautiful view. >>> longest_beautiful_view(5, [2, 2, 2, 2, 2]) == 0 >>> longest_beautiful_view(6, [3, 1, 2, 3, 1, 5]) == 3 >>> longest_beautiful_view(4, [1, 2, 3, 4]) == 4 >>> longest_beautiful_view(1, [5]) == 0 >>> longest_beautiful_view(7, [1, 2, 3, 2, 3, 4, 2]) == 3 >>> longest_beautiful_view(7, [5, 6, 7, 8, 7, 6, 5]) == 4 >>> longest_beautiful_view(2, [2, 1]) == 0 >>> longest_beautiful_view(2, [1, 2]) == 2 >>> longest_beautiful_view(3, [3, 3, 3]) == 0 >>> longest_beautiful_view(3, [5, 4, 3]) == 0 pass","solution":"def longest_beautiful_view(n, heights): if n <= 0: return 0 max_view = 0 current_view = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_view += 1 if current_view > max_view: max_view = current_view else: current_view = 1 return max_view if max_view > 1 else 0"},{"question":"from typing import List def longest_even_sum_subarray_length(n: int, arr: List[int]) -> int: Given an array of n integers, find the length of the longest subarray where the sum of elements is even. >>> longest_even_sum_subarray_length(5, [1, 2, 3, 4, 5]) 4 >>> longest_even_sum_subarray_length(4, [1, 1, 1, 1]) 4 >>> longest_even_sum_subarray_length(1, [2]) 1 >>> longest_even_sum_subarray_length(1, [1]) 0 >>> longest_even_sum_subarray_length(6, [2, 2, 2, 2, 2, 2]) 6 >>> longest_even_sum_subarray_length(6, [1, 2, 3, 4, 5, 6]) 5 >>> longest_even_sum_subarray_length(100000, [1] * 100000) 100000","solution":"def longest_even_sum_subarray_length(n, arr): Returns the length of the longest subarray with an even sum. # We keep track of prefix sums and their positions. prefix_sum = 0 first_odd = -1 last_odd = -1 max_length = 0 for i in range(n): prefix_sum += arr[i] if prefix_sum % 2 == 0: max_length = i + 1 else: if first_odd == -1: first_odd = i else: max_length = max(max_length, i - first_odd) return max_length"},{"question":"def is_prime(num: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False pass def longest_prime_subarray_length(n: int, array: List[int]) -> int: Find the length of the longest contiguous subarray consisting of only prime numbers. >>> longest_prime_subarray_length(9, [3, 5, 8, 7, 9, 10, 11, 13, 15]) 2 >>> longest_prime_subarray_length(6, [4, 6, 8, 10, 12, 14]) 0 pass","solution":"def is_prime(num): if num <= 1: return False if num == 2: return True if num % 2 == 0: return False for i in range(3, int(num**0.5) + 1, 2): if num % i == 0: return False return True def longest_prime_subarray_length(n, array): longest_length = 0 current_length = 0 for num in array: if is_prime(num): current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 0 return longest_length"},{"question":"def is_conflict_free(N: int, K: int, identifiers: List[int]) -> str: Determines if the given list of identifiers is conflict-free. Args: N (int): Number of identifiers. K (int): Length of the sequence to check. identifiers (list): List of numeric identifiers. Returns: str: \\"Yes\\" if the list is conflict-free, \\"No\\" otherwise. Examples: >>> is_conflict_free(6, 3, [1, 2, 2, 3, 4, 5]) 'Yes' >>> is_conflict_free(6, 4, [1, 1, 1, 1, 2, 2]) 'No'","solution":"def is_conflict_free(N, K, identifiers): Determines if the given list of identifiers is conflict-free. Args: N (int): Number of identifiers. K (int): Length of the sequence to check. identifiers (list): List of numeric identifiers. Returns: str: \\"Yes\\" if the list is conflict-free, \\"No\\" otherwise. for i in range(N - K + 1): if len(set(identifiers[i:i + K])) == K: return \\"Yes\\" return \\"No\\""},{"question":"def unique_paths_with_obstacles(n: int, m: int, obstacles: List[Tuple[int, int]]) -> int: Returns the number of unique paths from (1, 1) to (n, m) avoiding obstacles. >>> unique_paths_with_obstacles(3, 3, [(2, 2)]) == 2 >>> unique_paths_with_obstacles(4, 4, [(2, 2), (3, 3)]) == 4 >>> unique_paths_with_obstacles(3, 3, [(1, 2)]) == 3 >>> unique_paths_with_obstacles(3, 3, [(1, 2), (2, 1), (2, 3), (3, 2)]) == 0 >>> unique_paths_with_obstacles(2, 2, [(1, 2), (2, 1)]) == 0 >>> unique_paths_with_obstacles(1, 1, []) == 1 >>> unique_paths_with_obstacles(1, 1, [(1, 1)]) == 0","solution":"def unique_paths_with_obstacles(n, m, obstacles): Returns the number of unique paths from (1, 1) to (n, m) avoiding obstacles. if n == 0 or m == 0: return 0 grid = [[0] * m for _ in range(n)] # Marking the obstacles in the grid for x, y in obstacles: grid[x-1][y-1] = -1 # Starting point if grid[0][0] == -1: return 0 grid[0][0] = 1 # Fill the grid with paths count for i in range(n): for j in range(m): if grid[i][j] == -1: continue if i > 0 and grid[i-1][j] != -1: grid[i][j] += grid[i-1][j] if j > 0 and grid[i][j-1] != -1: grid[i][j] += grid[i][j-1] if grid[n-1][m-1] == -1: return 0 return grid[n-1][m-1]"},{"question":"def flip_subgrid(grid, x1, y1): for i in range(2): for j in range(2): grid[x1 + i][y1 + j] = 1 - grid[x1 + i][y1 + j] def transform_grid(n, m, initial, final): Transform the initial grid to the final grid state using the minimum number of 2x2 sub-grid flips. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. initial (List[str]): Initial state of the grid. final (List[str]): Final desired state of the grid. Returns: List[Tuple[int, int, int, int]]: A list of operations to convert the initial grid to the final grid. # Implement your solution here from solution import transform_grid def test_transform_grid_example_1(): n, m = 3, 3 initial = [\\"011\\", \\"101\\", \\"110\\"] final = [\\"000\\", \\"111\\", \\"000\\"] ops = transform_grid(n, m, initial, final) assert len(ops) <= n * m # Ensure the number of operations is within bounds for x1, y1, x2, y2 in ops: assert 1 <= x1 <= x2 <= n assert 1 <= y1 <= y2 <= m def test_transform_grid_example_2(): n, m = 2, 2 initial = [\\"01\\", \\"10\\"] final = [\\"11\\", \\"00\\"] ops = transform_grid(n, m, initial, final) assert len(ops) <= n * m # Ensure the number of operations is within bounds for x1, y1, x2, y2 in ops: assert 1 <= x1 <= x2 <= n assert 1 <= y1 <= y2 <= m","solution":"def flip_subgrid(grid, x1, y1): for i in range(2): for j in range(2): grid[x1 + i][y1 + j] = 1 - grid[x1 + i][y1 + j] def transform_grid(n, m, initial, final): ops = [] initial = [list(map(int, row)) for row in initial] final = [list(map(int, row)) for row in final] for i in range(n - 1): for j in range(m - 1): if initial[i][j] != final[i][j]: flip_subgrid(initial, i, j) ops.append((i + 1, j + 1, i + 2, j + 2)) return ops # Example: n, m = 3, 3 initial = [\\"011\\", \\"101\\", \\"110\\"] final = [\\"000\\", \\"111\\", \\"000\\"] ops = transform_grid(n, m, initial, final) print(len(ops)) for op in ops: print(*op)"},{"question":"def generate_art_piece_ids(names: List[str]) -> List[str]: Generates a unique ID for each art piece name in the given list. IDs are formatted as 'name#number' where 'name' is the name of the art piece, and 'number' is an integer starting from 1 and incremented for each additional piece of the same name. Parameters: names (list of str): A list of art piece names. Returns: list of str: A list of generated IDs. Examples: >>> generate_art_piece_ids([\\"MonaLisa\\", \\"StarryNight\\", \\"MonaLisa\\", \\"ThePersistenceOfMemory\\", \\"MonaLisa\\", \\"StarryNight\\", \\"END\\"]) [\\"MonaLisa#1\\", \\"StarryNight#1\\", \\"MonaLisa#2\\", \\"ThePersistenceOfMemory#1\\", \\"MonaLisa#3\\", \\"StarryNight#2\\"] >>> generate_art_piece_ids([\\"Sunflowers\\", \\"END\\"]) [\\"Sunflowers#1\\"] >>> generate_art_piece_ids([\\"Scream\\", \\"Scream\\", \\"Scream\\", \\"END\\"]) [\\"Scream#1\\", \\"Scream#2\\", \\"Scream#3\\"] >>> generate_art_piece_ids([\\"Guernica\\", \\"WaterLilies\\", \\"Guernica\\", \\"Sunflowers\\", \\"WaterLilies\\", \\"WaterLilies\\", \\"END\\"]) [\\"Guernica#1\\", \\"WaterLilies#1\\", \\"Guernica#2\\", \\"Sunflowers#1\\", \\"WaterLilies#2\\", \\"WaterLilies#3\\"] >>> generate_art_piece_ids([\\"END\\"]) []","solution":"def generate_art_piece_ids(names): Generates a unique ID for each art piece name in the given list. IDs are formatted as 'name#number' where 'name' is the name of the art piece, and 'number' is an integer starting from 1 and incremented for each additional piece of the same name. Parameters: names (list of str): A list of art piece names. Returns: list of str: A list of generated IDs. ids = [] name_count = {} for name in names: if name == \\"END\\": break if name in name_count: name_count[name] += 1 else: name_count[name] = 1 ids.append(f\\"{name}#{name_count[name]}\\") return ids"},{"question":"def find_longest_word(n: int, dictionary: List[str], s: str) -> str: Find the longest word in the dictionary that can be formed by deleting some characters from S without reordering the remaining characters. >>> find_longest_word(5, [\\"able\\", \\"ale\\", \\"apple\\", \\"bale\\", \\"kangaroo\\"], \\"abpcplea\\") \\"apple\\" >>> find_longest_word(4, [\\"a\\", \\"b\\", \\"c\\", \\"d\\"], \\"abcd\\") \\"a\\" >>> find_longest_word(3, [\\"xyz\\", \\"xy\\", \\"yz\\"], \\"pqrs\\") \\"\\"","solution":"def is_subsequence(word, s): it = iter(s) return all(char in it for char in word) def find_longest_word(n, dictionary, s): longest_word = \\"\\" for word in dictionary: if is_subsequence(word, s): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"class GridOperations: def __init__(self, n: int): Initialize a grid of size n x n filled with zeros. def set_value(self, r: int, c: int, xi: int): Set the value of the cell (r, c) to xi. Args: r (int): The row index (1-indexed). c (int): The column index (1-indexed). xi (int): The value to set. def get_sum(self) -> int: Get the sum of all the values in the grid. Returns: int: The sum of the grid values. def get_min(self) -> int: Get the minimum value in the grid. Returns: int: The minimum value in the grid. def process_operations(n: int, m: int, operations: List[List[int]]) -> List[int]: Perform a list of operations on the grid and return the results for type 2 and 3 operations. Args: n (int): The size of the grid (n x n). m (int): The number of operations. operations (List[List[int]]): A list of operations. Returns: List[int]: List of results for operations of type 2 and 3. >>> process_operations(4, 5, [[1, 2, 3, 5], [2], [1, 1, 1, -2], [3], [2]]) [5, -2, 3] >>> process_operations(3, 4, [[1, 1, 1, -7], [3], [1, 3, 3, 6], [2]]) [-7, -1] from typing import List def test_grid_operations(): n = 4 m = 5 operations = [ [1, 2, 3, 5], [2], [1, 1, 1, -2], [3], [2] ] expected_output = [5, -2, 3] assert process_operations(n, m, operations) == expected_output n = 3 m = 4 operations = [ [1, 1, 1, -7], [3], [1, 3, 3, 6], [2] ] expected_output = [-7, -1] assert process_operations(n, m, operations) == expected_output def test_empty_grid(): n = 1 m = 1 operations = [ [2] ] expected_output = [0] assert process_operations(n, m, operations) == expected_output def test_single_set_and_sum(): n = 2 m = 2 operations = [ [1, 1, 1, 10], [2] ] expected_output = [10] assert process_operations(n, m, operations) == expected_output def test_single_set_and_min(): n = 2 m = 2 operations = [ [1, 1, 1, -10], [3] ] expected_output = [-10] assert process_operations(n, m, operations) == expected_output def test_multiple_sets_and_sum(): n = 3 m = 6 operations = [ [1, 1, 1, 1], [1, 2, 2, 2], [1, 3, 3, 3], [2], [1, 1, 2, -1], [2] ] expected_output = [6, 5] assert process_operations(n, m, operations) == expected_output def test_multiple_operations(): n = 3 m = 5 operations = [ [1, 1, 1, -5], [1, 2, 2, 3], [2], [3], [2] ] expected_output = [-2, -5, -2] assert process_operations(n, m, operations) == expected_output","solution":"class GridOperations: def __init__(self, n): self.n = n self.grid = [[0] * n for _ in range(n)] self.total_sum = 0 def set_value(self, r, c, xi): # Convert 1-indexed to 0-indexed r -= 1 c -= 1 self.total_sum -= self.grid[r][c] # Remove old value from sum self.grid[r][c] = xi self.total_sum += xi # Add new value to sum def get_sum(self): return self.total_sum def get_min(self): return min(min(row) for row in self.grid) def process_operations(n, m, operations): grid_ops = GridOperations(n) results = [] for op in operations: if op[0] == 1: _, r, c, xi = op grid_ops.set_value(r, c, xi) elif op[0] == 2: results.append(grid_ops.get_sum()) elif op[0] == 3: results.append(grid_ops.get_min()) return results"},{"question":"import heapq from typing import List def merge_sorted_lists(sorted_lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list using a min-heap (priority queue). Args: sorted_lists (list of list of int): The input list of sorted lists. Returns: list of int: The merged sorted list. >>> merge_sorted_lists([[1, 4, 7, 8, 10], [2, 6, 12, 14], [3, 9, 11]]) [1, 2, 3, 4, 6, 7, 8, 9, 10, 11, 12, 14] >>> merge_sorted_lists([[1, 2, 3, 4, 5]]) [1, 2, 3, 4, 5] >>> merge_sorted_lists([[1, 3, 5, 7], [], [2, 4, 6, 8, 10]]) [1, 2, 3, 4, 5, 6, 7, 8, 10] >>> merge_sorted_lists([[], [], []]) [] >>> merge_sorted_lists([[1, 4, 5], [1, 3, 4], [2, 6]]) [1, 1, 2, 3, 4, 4, 5, 6] >>> merge_sorted_lists([[1, 3, 5], [1, 3, 5, 7], [2, 4, 6, 8]]) [1, 1, 2, 3, 3, 4, 5, 5, 6, 7, 8]","solution":"import heapq def merge_sorted_lists(sorted_lists): Merges multiple sorted lists into a single sorted list using a min-heap (priority queue). Args: sorted_lists (list of list of int): The input list of sorted lists. Returns: list of int: The merged sorted list. min_heap = [] result = [] # Initialize the min-heap with the first element of each list alongside the list index and element index for i, lst in enumerate(sorted_lists): if lst: # Check if the list is not empty heapq.heappush(min_heap, (lst[0], i, 0)) while min_heap: val, list_idx, element_idx = heapq.heappop(min_heap) result.append(val) # If there's a next element in the same list, push it into the heap if element_idx + 1 < len(sorted_lists[list_idx]): next_val = sorted_lists[list_idx][element_idx + 1] heapq.heappush(min_heap, (next_val, list_idx, element_idx + 1)) return result"},{"question":"def max_sum_abs_diff(N: int) -> int: Determine the maximum possible sum of absolute differences in beauty values of adjacent flowers in a circular arrangement. >>> max_sum_abs_diff(3) 4 >>> max_sum_abs_diff(4) 6 >>> max_sum_abs_diff(5) 8 def solve(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases to determine the maximum possible sum for each case. >>> solve(2, [3, 4]) [4, 6] >>> solve(3, [3, 4, 5]) [4, 6, 8] >>> solve(1, [1000000]) [1999998] >>> solve(5, [2, 3, 4, 5, 6]) [2, 4, 6, 8, 10]","solution":"def max_sum_abs_diff(N): return 2 * (N - 1) def solve(T, test_cases): results = [] for N in test_cases: results.append(max_sum_abs_diff(N)) return results"},{"question":"from typing import List def find_hamiltonian_path(n: int, graph: List[List[int]]) -> str: Determine if there is a Hamiltonian path in the graph. >>> find_hamiltonian_path(4, [ [0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0] ]) \\"Yes\\" >>> find_hamiltonian_path(4, [ [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0] ]) \\"No\\" pass","solution":"from itertools import permutations def query_edge(graph, u, v): return \\"Yes\\" if graph[u-1][v-1] == 1 else \\"No\\" def find_hamiltonian_path(n, graph): nodes = range(1, n + 1) for perm in permutations(nodes): is_path = True for i in range(n - 1): u, v = perm[i], perm[i+1] if query_edge(graph, u, v) == \\"No\\": is_path = False break if is_path: return \\"Yes\\" return \\"No\\""},{"question":"def calculate_matches(n: int) -> int: Given the number of participants in a tournament, returns the total number of matches played. Example: >>> calculate_matches(3) == 3 >>> calculate_matches(4) == 6 pass def process_input(inputs: List[int]) -> List[int]: Processes a list of number of participants and returns a list of total number of matches played for each tournament until a 0 is encountered. Example: >>> process_input([3, 4, 5, 0]) == [3, 6, 10] >>> process_input([2, 0]) == [1] pass # Unit Tests from solution import calculate_matches, process_input def test_calculate_matches(): assert calculate_matches(3) == 3 assert calculate_matches(4) == 6 assert calculate_matches(5) == 10 assert calculate_matches(2) == 1 assert calculate_matches(10) == 45 def test_process_input(): assert process_input([3, 4, 5, 0]) == [3, 6, 10] assert process_input([2, 0]) == [1] assert process_input([7, 8, 0]) == [21, 28] assert process_input([1000, 0]) == [499500]","solution":"def calculate_matches(n): Given the number of participants in a tournament, returns the total number of matches played. if n <= 1: return 0 return (n * (n - 1)) // 2 def process_input(inputs): results = [] for n in inputs: if n == 0: break results.append(calculate_matches(n)) return results"},{"question":"def can_form_palindrome(s: str) -> str: Determine if the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"racecar\\") == \\"YES\\" >>> can_form_palindrome(\\"racerac\\") == \\"YES\\" >>> can_form_palindrome(\\"hello\\") == \\"NO\\" >>> can_form_palindrome(\\"aabbcc\\") == \\"YES\\" def solve_palindrome_puzzle(test_cases: list[str]) -> list[str]: Solve the puzzle for the given test cases. >>> solve_palindrome_puzzle([\\"racecar\\", \\"racerac\\", \\"hello\\", \\"aabbcc\\"]) == [\\"YES\\", \\"YES\\", \\"NO\\", \\"YES\\"] >>> solve_palindrome_puzzle([\\"aabbccdd\\", \\"abcdefg\\"]) == [\\"YES\\", \\"NO\\"] >>> solve_palindrome_puzzle([\\"abcdedcba\\", \\"xyzzyx\\"]) == [\\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determine if the string can be rearranged to form a palindrome. Parameters: s (str): The input string containing only lower-case letters. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, else \\"NO\\". from collections import Counter # Count the frequency of each character char_count = Counter(s) # Count the number of characters with odd frequencies odd_counts = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if at most one character has an odd frequency if odd_counts > 1: return \\"NO\\" return \\"YES\\" def solve_palindrome_puzzle(test_cases): Solve the puzzle for the given test cases. Parameters: test_cases (list of str): List of strings to be checked. Returns: list of str: List of results \\"YES\\" or \\"NO\\" for each test case. results = [] for s in test_cases: results.append(can_form_palindrome(s)) return results"},{"question":"from typing import List, Tuple def minimum_total_length(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Help the Mayor to find the minimum total length of the roads required to make the intersections fully connected in GreenVille. :param n: Number of intersections :param m: Number of roads :param roads: Descriptions of the roads (start intersection, end intersection, and road length) :return: The minimum total length of the roads required to make the intersections connected, or -1 if it is impossible >>> minimum_total_length(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> minimum_total_length(3, 1, [(1, 2, 10)]) -1 >>> minimum_total_length(5, 7, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 7), (3, 4, 1), (3, 5, 5), (4, 5, 6)]) 11 pass def test_example_1(): n, m = 4, 5 roads = [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)] assert minimum_total_length(n, m, roads) == 6 def test_example_2(): n, m = 3, 1 roads = [(1, 2, 10)] assert minimum_total_length(n, m, roads) == -1 def test_example_3(): n, m = 5, 7 roads = [ (1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 7), (3, 4, 1), (3, 5, 5), (4, 5, 6) ] assert minimum_total_length(n, m, roads) == 11 def test_single_intersection(): n, m = 1, 0 roads = [] assert minimum_total_length(n, m, roads) == 0 def test_no_possible_connection(): n, m = 4, 2 roads = [ (1, 2, 1), (3, 4, 2) ] assert minimum_total_length(n, m, roads) == -1","solution":"def minimum_total_length(n, m, roads): from heapq import heappop, heappush if n == 1: return 0 # Create adjacency list graph = [[] for _ in range(n + 1)] for u, v, l in roads: graph[u].append((l, v)) graph[v].append((l, u)) # since we can travel in both directions in MST # Prim's algorithm to find Minimum Spanning Tree (MST) min_heap = [(0, 1)] # (cost, start node) total_cost = 0 visited = [False] * (n + 1) edges_used = 0 while min_heap: cost, u = heappop(min_heap) if visited[u]: continue visited[u] = True total_cost += cost edges_used += 1 for edge_cost, neighbor in graph[u]: if not visited[neighbor]: heappush(min_heap, (edge_cost, neighbor)) # If we were able to visit all nodes, return total_cost; otherwise, return -1 if edges_used == n: return total_cost else: return -1"},{"question":"def max_items_collected(n: int, grid: List[List[int]]) -> int: A robot is placed on an n x n grid and needs to collect the maximum number of items scattered across the grid. The robot starts at the top-left corner of the grid (position (0, 0)) and can only move either right or down to reach the bottom-right corner (position (n-1, n-1)). Each cell in the grid may contain some items, represented by a non-negative integer. The robot's task is to find a path that will maximize the total number of items collected. :param n: int, size of the grid :param grid: List[List[int]], n x n grid representing items in each cell :return: int, maximum number of items collected pass from typing import List def test_example1(): n = 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_items_collected(n, grid) == 29 def test_example2(): n = 2 grid = [ [0, 2], [3, 4] ] assert max_items_collected(n, grid) == 7 def test_single_cell(): n = 1 grid = [ [10] ] assert max_items_collected(n, grid) == 10 def test_all_zeros(): n = 4 grid = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert max_items_collected(n, grid) == 0 def test_increasing_values(): n = 3 grid = [ [1, 2, 3], [2, 3, 4], [3, 4, 5] ] assert max_items_collected(n, grid) == 15 def test_decreasing_values(): n = 3 grid = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] assert max_items_collected(n, grid) == 29","solution":"def max_items_collected(n, grid): Returns the maximum number of items collected by the robot while moving from top-left to bottom-right of the grid. :param n: int, size of the grid :param grid: List[List[int]], n x n grid representing items in each cell # Initialize a 2D dp array with the same dimensions as the grid dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp array for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def minimum_cost_to_connect_islands(n: int, m: int, bridges: List[Tuple[int, int, int]]) -> int: Determine the minimum total cost required to build the network of bridges that connects all islands. Args: n (int): The number of islands. m (int): The number of potential bridges. bridges (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers u, v, and c - denoting a bridge between islands u and v with a construction cost c. Returns: int: The minimum total construction cost required to connect all islands. If it is not possible to connect all islands, return -1. >>> n = 4 >>> m = 5 >>> bridges = [(1, 2, 10), (2, 3, 15), (3, 4, 20), (4, 1, 25), (2, 4, 30)] >>> minimum_cost_to_connect_islands(n, m, bridges) 45 >>> n = 4 >>> m = 2 >>> bridges = [(1, 2, 10), (3, 4, 20)] >>> minimum_cost_to_connect_islands(n, m, bridges) -1 >>> n = 1 >>> m = 0 >>> bridges = [] >>> minimum_cost_to_connect_islands(n, m, bridges) 0 >>> n = 2 >>> m = 1 >>> bridges = [(1, 2, 5)] >>> minimum_cost_to_connect_islands(n, m, bridges) 5 >>> n = 3 >>> m = 3 >>> bridges = [(1, 2, 3), (2, 3, 4), (1, 3, 5)] >>> minimum_cost_to_connect_islands(n, m, bridges) 7 >>> n = 4 >>> m = 6 >>> bridges = [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10), (1, 3, 10), (2, 4, 10)] >>> minimum_cost_to_connect_islands(n, m, bridges) 30","solution":"def find(parent, x): if parent[x] != x: parent[x] = find(parent, parent[x]) return parent[x] def union(parent, rank, x, y): rootX = find(parent, x) rootY = find(parent, y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = list(range(n)) rank = [0] * n minCost = 0 edgesUsed = 0 for u, v, cost in edges: if find(parent, u) != find(parent, v): union(parent, rank, u, v) minCost += cost edgesUsed += 1 if edgesUsed == n - 1: break return minCost if edgesUsed == n - 1 else -1 def minimum_cost_to_connect_islands(n, m, bridges): edges = [(u - 1, v - 1, c) for u, v, c in bridges] # Convert to 0-based index return kruskal(n, edges)"},{"question":"def min_colors_required(T: int, test_cases: List[int]) -> List[int]: Calculate the minimum number of colors needed to paint a strip with N sections where no two adjacent sections have the same color. Args: T (int): The number of test cases. test_cases (List[int]): A list containing the number of sections in each test case. Returns: List[int]: A list containing the minimum number of colors required for each test case. Example: >>> min_colors_required(3, [1, 2, 5]) [1, 2, 2]","solution":"def min_colors_required(T, test_cases): results = [] for N in test_cases: if N == 1: results.append(1) else: results.append(2) return results # Example usage: # T = 3 # test_cases = [1, 2, 5] # print(min_colors_required(T, test_cases)) would output [1, 2, 2]"},{"question":"def find_two_sum_indices(arr: List[int], target: int) -> Union[Tuple[int, int], int]: Finds two distinct integers in the array that add up to the target sum and returns their indices. If no such pair exists, returns -1. >>> find_two_sum_indices([2, 7, 11, 15, 1], 9) (0, 1) >>> find_two_sum_indices([3, 3, 3, 3], 10) -1 >>> find_two_sum_indices([3, 3, 3, 3], 6) (0, 1) >>> find_two_sum_indices([1, 2, 3, 4, 5], 10) -1 >>> find_two_sum_indices([5, 75, 25, 50], 100) (1, 2) >>> find_two_sum_indices([1, 1], 2) (0, 1) >>> find_two_sum_indices([-3, 4, 3, 90], 0) (0, 2)","solution":"def find_two_sum_indices(arr, target): Finds two distinct integers in the array that add up to the target sum and returns their indices. If no such pair exists, returns -1. seen_numbers = {} for index, number in enumerate(arr): complement = target - number if complement in seen_numbers: return seen_numbers[complement], index seen_numbers[number] = index return -1"},{"question":"def min_enclosing_rectangle_area(m: int, n: int, grid: List[List[int]]) -> int: Returns the area of the smallest rectangle that can enclose the island. >>> min_enclosing_rectangle_area(4, 5, [ ... [0, 0, 0, 0, 0], ... [0, 1, 1, 0, 0], ... [0, 1, 1, 0, 0], ... [0, 0, 0, 0, 0] ... ]) 4 >>> min_enclosing_rectangle_area(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 1 >>> min_enclosing_rectangle_area(1, 5, [ ... [0, 1, 1, 0, 0] ... ]) 2","solution":"def min_enclosing_rectangle_area(m, n, grid): Returns the area of the smallest rectangle that can enclose the island. left, right = n, -1 top, bottom = m, -1 for i in range(m): for j in range(n): if grid[i][j] == 1: if j < left: left = j if j > right: right = j if i < top: top = i if i > bottom: bottom = i if left == n or right == -1 or top == m or bottom == -1: return 0 return (right - left + 1) * (bottom - top + 1)"},{"question":"def is_palindrome(s: str) -> str: Returns 'YES' if the given string s is a palindrome, otherwise 'NO'. >>> is_palindrome(\\"12321\\") 'YES' >>> is_palindrome(\\"123456\\") 'NO' # Write your code here def process_test_cases(t: int, cases: List[str]) -> List[str]: Processes multiple test cases and returns a list of results for each case. Parameters: t (int): Number of test cases cases (list of str): List of string representations of large numbers. Returns: list of str: List containing 'YES' or 'NO' for each test case. >>> process_test_cases(2, [\\"12321\\", \\"123456\\"]) ['YES', 'NO'] >>> process_test_cases(3, [\\"22\\", \\"123321\\", \\"123421\\"]) ['YES', 'YES', 'NO'] # Write your code here","solution":"def is_palindrome(s): Returns 'YES' if the given string s is a palindrome, otherwise 'NO'. return 'YES' if s == s[::-1] else 'NO' def process_test_cases(t, cases): Processes multiple test cases and returns a list of results for each case. Parameters: t (int): Number of test cases cases (list of str): List of string representations of large numbers. Returns: list of str: List containing 'YES' or 'NO' for each test case. results = [] for case in cases: results.append(is_palindrome(case)) return results"},{"question":"def get_new_array(arr): Returns a new array where each element at index i is the sum of all elements in the original array except the one at index i. Args: arr (List[int]): List of integers. Returns: List[int]: New array with summed values as per the rule. Example: >>> get_new_array([1, 2, 3, 4]) [9, 8, 7, 6] >>> get_new_array([5]) [0]","solution":"def get_new_array(arr): Returns a new array where each element at index i is the sum of all elements in the original array except the one at index i. total_sum = sum(arr) new_array = [total_sum - arr[i] for i in range(len(arr))] return new_array"},{"question":"def find_unique_runners(T, data): Alice is organizing a marathon event in her city. She wants to track the positions of all participants over time to determine their current rankings during the race. The marathon route consists of N checkpoints, each with a unique number from 1 to N. Input: - The first line of input is the number of test cases T (1 <= T <= 10). - For each test case, the first line contains two integers N (1 <= N <= 100) and M (1 <= M <= 100), where N is the number of checkpoints and M is the number of participants. - The next M lines each contain a sequence of N integers. Each sequence represents the order in which a participant visits the checkpoints. - The next line contains an integer Q (1 <= Q <= 50), the number of queries. - The next Q lines each contain two integers si and ei (1 <= si <= ei <= N), representing the start and end checkpoint numbers for that query. Output: For each test case, output Q lines, each containing the number of unique participants who have been at any checkpoint within the span [si, ei] for that query. Example: Input: 1 5 3 1 2 3 4 5 5 4 3 2 1 3 1 4 2 5 2 1 3 2 5 Output: 3 3 >>> T = 1 >>> data = [ ... (5, 3), ... [1, 2, 3, 4, 5], ... [5, 4, 3, 2, 1], ... [3, 1, 4, 2, 5], ... (2,), ... (1, 3), ... (2, 5), ... ] >>> find_unique_runners(T, data) [3, 3]","solution":"def find_unique_runners(T, data): results = [] index = 0 for _ in range(T): N, M = data[index] index += 1 participants = [] for _ in range(M): participants.append(data[index]) index += 1 Q = data[index][0] index += 1 queries = data[index:index + Q] index += Q checkpoint_participants = [[] for _ in range(N)] for i, checkpoints in enumerate(participants): for j, checkpoint in enumerate(checkpoints): checkpoint_participants[j].append(i) for si, ei in queries: si -= 1 ei -= 1 unique_runners = set() for k in range(si, ei + 1): unique_runners.update(checkpoint_participants[k]) results.append(len(unique_runners)) return results"},{"question":"def min_abs_diff(n: int, arr: List[int]) -> int: Returns the minimum possible absolute difference of the sums of two sublists. :param n: int - number of integers in the list. :param arr: List[int] - list of integers. :return: int - minimum possible absolute difference of the sums of two sublists. Examples: >>> min_abs_diff(4, [3, 1, 4, 2]) 0 >>> min_abs_diff(6, [10, 12, 15, 5, 14, 7]) 1 >>> min_abs_diff(8, [8, 10, 4, 5, 9, 6, 11, 7]) 0 # Your implementation here from itertools import combinations def test_example_case_1(): assert min_abs_diff(4, [3, 1, 4, 2]) == 0 def test_example_case_2(): assert min_abs_diff(6, [10, 12, 15, 5, 14, 7]) == 1 def test_example_case_3(): assert min_abs_diff(8, [8, 10, 4, 5, 9, 6, 11, 7]) == 0 def test_small_case(): assert min_abs_diff(2, [1, 2]) == 1 def test_equal_elements(): assert min_abs_diff(4, [2, 2, 2, 2]) == 0 def test_large_values(): assert min_abs_diff(4, [1000000, 1000000, 1000000, 1000000]) == 0 def test_alternating_values(): assert min_abs_diff(4, [1, 1000000, 1, 1000000]) == 0","solution":"from itertools import combinations def min_abs_diff(n, arr): Returns the minimum possible absolute difference of the sums of two sublists. total_sum = sum(arr) min_diff = float('inf') # Generate all possible combinations of len(arr) // 2 elements for comb in combinations(arr, n // 2): sum_comb = sum(comb) curr_diff = abs(2 * sum_comb - total_sum) if curr_diff < min_diff: min_diff = curr_diff return min_diff"},{"question":"class FlightReservationSystem: def __init__(self, num_seats): Initialize the flight reservation system with a number of seats. pass def book_seat(self, seat_no): Try to book a seat. Return a message indicating the result. pass def cancel_seat(self, seat_no): Try to cancel a seat booking. Return a message indicating the result. pass def status(self): Return a list showing the current status of all seats. pass def process_command(self, command): Process a given command and return the appropriate result. pass from solution import FlightReservationSystem def test_flight_reservation_system(): system = FlightReservationSystem(5) # Test bookings assert system.process_command('BOOK 1') == \\"Seat 1 booked successfully.\\" assert system.process_command('BOOK 2') == \\"Seat 2 booked successfully.\\" assert system.process_command('BOOK 1') == \\"Seat 1 is already booked.\\" # Test cancellations assert system.process_command('CANCEL 2') == \\"Seat 2 canceled successfully.\\" assert system.process_command('CANCEL 3') == \\"Seat 3 is not booked.\\" assert system.process_command('BOOK 3') == \\"Seat 3 booked successfully.\\" # Test status assert system.process_command('STATUS') == [ \\"1: booked\\", \\"2: free\\", \\"3: booked\\", \\"4: free\\", \\"5: free\\" ] assert system.process_command('BOOK 4') == \\"Seat 4 booked successfully.\\" assert system.process_command('CANCEL 1') == \\"Seat 1 canceled successfully.\\" assert system.process_command('STATUS') == [ \\"1: free\\", \\"2: free\\", \\"3: booked\\", \\"4: booked\\", \\"5: free\\" ] # Test end command assert system.process_command('END') == \\"END\\"","solution":"class FlightReservationSystem: def __init__(self, num_seats): self.num_seats = num_seats self.seats = ['free'] * num_seats def book_seat(self, seat_no): if self.seats[seat_no - 1] == 'free': self.seats[seat_no - 1] = 'booked' return f\\"Seat {seat_no} booked successfully.\\" else: return f\\"Seat {seat_no} is already booked.\\" def cancel_seat(self, seat_no): if self.seats[seat_no - 1] == 'booked': self.seats[seat_no - 1] = 'free' return f\\"Seat {seat_no} canceled successfully.\\" else: return f\\"Seat {seat_no} is not booked.\\" def status(self): return [f\\"{i+1}: {seat}\\" for i, seat in enumerate(self.seats)] def process_command(self, command): parts = command.strip().split() action = parts[0] if action == 'BOOK': seat_no = int(parts[1]) return self.book_seat(seat_no) elif action == 'CANCEL': seat_no = int(parts[1]) return self.cancel_seat(seat_no) elif action == 'STATUS': return self.status() elif action == 'END': return \\"END\\""},{"question":"from typing import List, Tuple def rearrange_array(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it is possible to rearrange the array such that adjacent elements have different values. Args: t (int): the number of test cases test_cases (List[Tuple[int, List[int]]]): list of test cases where each test case is a tuple containing an integer n and a list of n integers Returns: List[str]: For each test case, if it's possible to rearrange the array, returns \\"YES\\" followed by the rearranged array, else returns \\"NO\\". Example: >>> rearrange_array(3, [(5, [1, 1, 1, 2, 2]), (3, [1, 1, 1]), (4, [1, 2, 3, 4])]) ['YES', '1 2 1 2 1', 'NO', 'YES', '1 3 2 4'] >>> rearrange_array(1, [(1, [1])]) ['YES', '1'] >>> rearrange_array(1, [(2, [1, 1])]) ['NO']","solution":"from collections import Counter import heapq def rearrange_array(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] a = test_cases[i][1] counter = Counter(a) max_frequency = max(counter.values()) if max_frequency > (n + 1) // 2: results.append(\\"NO\\") else: results.append(\\"YES\\") sorted_items = sorted(counter.items(), key=lambda x: -x[1]) rearranged = [0] * n index = 0 for item, count in sorted_items: for _ in range(count): if index >= n: index = 1 rearranged[index] = item index += 2 results.append(\\" \\".join(map(str, rearranged))) return results"},{"question":"def increasing_subarrays(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: You are given an array of integers. Your task is to manipulate this array to form a series of increasing subarrays, with each number in each subarray being unique. Each number must be used exactly once. If it is not possible to form such a series, output \\"NO\\". Otherwise, output \\"YES\\" followed by the smallest number of subarrays you can form. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): The list of test cases, each containing the number of elements and the elements. Returns: List[str]: The results for each test case, either \\"NO\\" or \\"YES\\" followed by the number of subarrays. Example: >>> increasing_subarrays(1, [(5, [4, 3, 2, 1, 5])]) [\\"YES 3\\"] >>> increasing_subarrays(1, [(6, [1, 2, 3, 2, 1, 4])]) [\\"NO\\"] pass def test_increasing_subarrays_case1(): assert increasing_subarrays(1, [(5, [4, 3, 2, 1, 5])]) == [\\"YES 5\\"] def test_increasing_subarrays_case2(): assert increasing_subarrays(1, [(6, [1, 2, 3, 2, 1, 4])]) == [\\"NO\\"] def test_increasing_subarrays_case3(): assert increasing_subarrays(1, [(4, [2, 1, 4, 3])]) == [\\"YES 4\\"] def test_increasing_subarrays_multiple_cases(): assert increasing_subarrays(3, [ (5, [4, 3, 2, 1, 5]), (6, [1, 2, 3, 2, 1, 4]), (4, [2, 1, 4, 3]) ]) == [\\"YES 5\\", \\"NO\\", \\"YES 4\\"] def test_increasing_subarrays_all_unique(): assert increasing_subarrays(1, [(5, [1, 2, 3, 4, 5])]) == [\\"YES 5\\"] def test_increasing_subarrays_all_duplicates(): assert increasing_subarrays(1, [(4, [2, 2, 2, 2])]) == [\\"NO\\"] def test_increasing_subarrays_mixed(): assert increasing_subarrays(1, [(7, [1, 3, 3, 3, 2, 4, 1])]) == [\\"NO\\"]","solution":"def increasing_subarrays(t, test_cases): results = [] for test_case in test_cases: n, array = test_case unique_elems = set(array) if len(unique_elems) < n: results.append(\\"NO\\") else: results.append(f\\"YES {len(unique_elems)}\\") return results # Example usage: # print(increasing_subarrays(3, [(5, [4, 3, 2, 1, 5]), (6, [1, 2, 3, 2, 1, 4]), (4, [2, 1, 4, 3])]))"},{"question":"from bisect import bisect_left, bisect_right from typing import List, Tuple def recent_events(logs: List[Tuple[int, str]], queries: List[Tuple[int, int]]) -> List[List[str]]: Returns the event messages within the specified time windows. :param logs: List of tuples (timestamp, message) :param queries: List of tuples (start_timestamp, end_timestamp) :return: List of lists containing event messages within each time window Example: >>> logs = [(1, \\"System start\\"), (2, \\"User login\\"), (5, \\"Error: Disk full\\"), (10, \\"User logout\\")] >>> queries = [(1, 5), (2, 10), (3, 7)] >>> recent_events(logs, queries) [[\\"System start\\", \\"User login\\", \\"Error: Disk full\\"], [\\"User login\\", \\"Error: Disk full\\", \\"User logout\\"], [\\"User login\\", \\"Error: Disk full\\"]]","solution":"from bisect import bisect_left, bisect_right def recent_events(logs, queries): Returns the event messages within the specified time windows. :param logs: List of tuples (timestamp, message) :param queries: List of tuples (start_timestamp, end_timestamp) :return: List of lists containing event messages within each time window result = [] # Create a list of timestamps for efficient lookup timestamps = [log[0] for log in logs] for start, end in queries: # Find the start index start_idx = bisect_left(timestamps, start) # Find the end index end_idx = bisect_right(timestamps, end) # Collect the logs within the range messages_within_range = [logs[i][1] for i in range(start_idx, end_idx)] # Append to the result list result.append(messages_within_range) return result"},{"question":"def min_byes_required(n: int) -> int: Returns the minimum number of byes required to proceed in a single-elimination tournament with n participants. >>> min_byes_required(5) 3 >>> min_byes_required(8) 0 >>> min_byes_required(13) 3 def process_tournaments(m: int, participants: List[int]) -> List[int]: Returns a list of the minimum number of byes required for each tournament based on the number of participants. >>> process_tournaments(3, [5, 8, 13]) [3, 0, 3] >>> process_tournaments(2, [1, 32]) [0, 0] # Unit Test import unittest class TestTournaments(unittest.TestCase): def test_min_byes_required(self): self.assertEqual(min_byes_required(5), 3) self.assertEqual(min_byes_required(8), 0) self.assertEqual(min_byes_required(13), 3) self.assertEqual(min_byes_required(1), 0) self.assertEqual(min_byes_required(31), 1) self.assertEqual(min_byes_required(32), 0) self.assertEqual(min_byes_required(33), 31) def test_process_tournaments(self): self.assertEqual(process_tournaments(3, [5, 8, 13]), [3, 0, 3]) self.assertEqual(process_tournaments(2, [1, 32]), [0, 0]) self.assertEqual(process_tournaments(3, [31, 16, 24]), [1, 0, 8]) def test_edge_cases(self): self.assertEqual(process_tournaments(4, [1, 2, 4, 7]), [0, 0, 0, 1])","solution":"import math def min_byes_required(n): Returns the minimum number of byes required to proceed in a single-elimination tournament with n participants. # Calculate the next power of 2 greater than or equal to n if n & (n - 1) == 0: # n is already a power of 2 return 0 next_power_of_2 = 1 << (n.bit_length()) return next_power_of_2 - n def process_tournaments(m, participants): results = [] for n in participants: results.append(min_byes_required(n)) return results"},{"question":"from typing import List def length_of_lds(nums: List[int]) -> int: Given an array of integers nums, return the length of the longest strictly decreasing subsequence (LDS) in nums. A strictly decreasing subsequence is defined as a subsequence where for all i < j, nums[i] > nums[j]. Constraints: * 1 ≤ nums.length ≤ 100000 * -10^9 ≤ nums[i] ≤ 10^9 Examples: >>> length_of_lds([9, 4, 3, 8, 6, 7]) 3 >>> length_of_lds([10, 20, 30, 0]) 2 def test_length_of_lds(): assert length_of_lds([9, 4, 3, 8, 6, 7]) == 3 assert length_of_lds([10, 20, 30, 0]) == 2 assert length_of_lds([5, 3, 4, 8, 6, 7]) == 2 assert length_of_lds([1, 2, 3, 4, 5]) == 1 assert length_of_lds([5, 4, 3, 2, 1]) == 5 assert length_of_lds([]) == 0 assert length_of_lds([3, 10, 2, 1, 20]) == 3 assert length_of_lds([-1, -2, -3, -4]) == 4 assert length_of_lds([7, 7, 7, 7, 7]) == 1 assert length_of_lds([3, 2, 6, 4, 5]) == 2","solution":"def length_of_lds(nums): Returns the length of the longest strictly decreasing subsequence (LDS) in nums. if not nums: return 0 n = len(nums) dp = [1] * n # Initialize dp array where dp[i] is the length of LDS ending at index i for i in range(1, n): for j in range(i): if nums[j] > nums[i]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Function to process input and call the length_of_lds function def process_input_and_find_lds(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) nums = [int(data[i + 1]) for i in range(n)] return length_of_lds(nums)"},{"question":"def min_operations(str1: str, str2: str) -> int: Given two strings, str1 and str2, determine the minimum number of operations required to convert str1 into str2. The operations allowed are: 1. Insert a character 2. Delete a character 3. Replace a character >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"flaw\\", \\"lawn\\") 2 >>> min_operations(\\"abc\\", \\"abc\\") 0 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"horse\\", \\"ros\\") 3","solution":"def min_operations(str1: str, str2: str) -> int: Returns the minimum number of operations required to convert str1 into str2. The operations allowed are insert a character, delete a character, and replace a character. m = len(str1) n = len(str2) # Create a 2D array to store the minimum number of operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # str1 to empty str2 requires i deletions for j in range(n + 1): dp[0][j] = j # empty str1 to str2 requires j insertions # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = min(dp[i - 1][j] + 1, # Delete dp[i][j - 1] + 1, # Insert dp[i - 1][j - 1] + 1) # Replace return dp[m][n]"},{"question":"def caesar_cipher(t, cases): Applies Caesar Cipher encryption technique to a list of cases. Each case consists of a tuple where the first element is a string S of lowercase English characters, and the second element is an integer K, the number of positions each character in S should be shifted down the alphabet. Args: t (int): The number of cases. cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string S and an integer K. Returns: List[str]: A list of encrypted strings after applying Caesar Cipher. def parse_input(input_str): Parses the input string and returns the number of test cases and a list of cases. Args: input_str (str): Input string containing multiple lines with the first line indicating the number of test cases T, followed by T lines each containing a string S and an integer K. Returns: Tuple[int, List[Tuple[str, int]]]: A tuple where the first element is the number of test cases, and the second element is a list of tuples containing string S and integer K. def run_caesar_cipher(input_str): Runs the Caesar Cipher on the provided input string. Args: input_str (str): A multiline input string where the first line indicates the number of test cases T, followed by T lines, each containing a string S and an integer K separated by a space. Returns: str: Encrypted strings for each test case joined by a newline character. import pytest from solution import caesar_cipher, run_caesar_cipher def test_single_case(): input_str = \\"1nhello 3\\" expected_output = \\"khoor\\" assert run_caesar_cipher(input_str) == expected_output def test_multiple_cases(): input_str = \\"2nhello 3nxyz 2\\" expected_output = \\"khoornzab\\" assert run_caesar_cipher(input_str) == expected_output def test_lower_boundary(): input_str = \\"1na 1\\" expected_output = \\"b\\" assert run_caesar_cipher(input_str) == expected_output def test_upper_boundary(): input_str = \\"1nabcdefghijklmnopqrstuvwxyz 25\\" expected_output = \\"zabcdefghijklmnopqrstuvwxy\\" assert run_caesar_cipher(input_str) == expected_output def test_wrap_around(): input_str = \\"1nxyz 2\\" expected_output = \\"zab\\" assert run_caesar_cipher(input_str) == expected_output def test_large_k(): # Since K ≤ 25, just a check for largest K value within constraint input_str = \\"1nabc 25\\" expected_output = \\"zab\\" assert run_caesar_cipher(input_str) == expected_output def test_empty_string(): input_str = \\"1n 1\\" expected_output = \\"\\" assert run_caesar_cipher(input_str) == expected_output def test_all_same_letters(): input_str = \\"1naaaa 1\\" expected_output = \\"bbbb\\" assert run_caesar_cipher(input_str) == expected_output def test_mix_letters(): input_str = \\"1nabz 2\\" expected_output = \\"cdb\\" assert run_caesar_cipher(input_str) == expected_output","solution":"def caesar_cipher(t, cases): results = [] for case in cases: s, k = case encrypted = [] for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) encrypted.append(new_char) results.append(''.join(encrypted)) return results def parse_input(input_str): lines = input_str.strip().split('n') t = int(lines[0]) cases = [] for line in lines[1:]: parts = line.rsplit(' ', 1) s, k = parts[0], int(parts[1]) cases.append((s, k)) return t, cases def run_caesar_cipher(input_str): t, cases = parse_input(input_str) results = caesar_cipher(t, cases) return 'n'.join(results)"},{"question":"def highestFrequency(s: str) -> str: Write a function to find the character with the highest frequency in the input string. Ignore the case during comparison but return the original case of the first occurrence. In case of a tie, return the character that appears first in the string. >>> highestFrequency(\\"abacabadabacaba\\") 'a' >>> highestFrequency(\\"abcdeABCDEabcde\\") 'a' pass # Unit Tests def test_highest_frequency_basic(): assert highestFrequency(\\"abacabadabacaba\\") == 'a' def test_highest_frequency_tie(): assert highestFrequency(\\"abcdeABCDEabcde\\") == 'a' def test_highest_frequency_mixed_case(): assert highestFrequency(\\"AaBbCcAa\\") == 'A' def test_highest_frequency_all_unique(): assert highestFrequency(\\"abcdefGHIJK\\") == 'a' def test_highest_frequency_large_input(): s = \\"a\\" * 50000 + \\"b\\" * 49999 + \\"c\\" * 1 assert highestFrequency(s) == 'a' def test_highest_frequency_start_tie(): assert highestFrequency(\\"bcdefghijkAaCCcc\\") == 'c'","solution":"def highestFrequency(s: str) -> str: from collections import defaultdict freq_dict = defaultdict(int) first_occurrence = {} # Convert string to lowercase for counting purposes lower_s = s.lower() for i, char in enumerate(lower_s): freq_dict[char] += 1 if char not in first_occurrence: first_occurrence[char] = s[i] # Find the character with the highest frequency max_freq = max(freq_dict.values()) max_char = None for char in lower_s: if freq_dict[char] == max_freq: max_char = char break return first_occurrence[max_char]"},{"question":"def three_sum(nums: List[int], target: int) -> bool: Determines if there are three distinct integers in the list nums that add up to the target sum. >>> three_sum([1, 2, 3, 4, 5, 6], 9) == True >>> three_sum([1, 2, 3, 4, 5, 6], 20) == False >>> three_sum([-1, 0, 1, 2, -2, 3], 0) == True >>> three_sum([0, 0, 0], 0) == True >>> three_sum([1, 2, 4, 8, 16], -8) == False >>> three_sum([1000000, 2000000, 3000000, -1000000, -2000000, -3000000], 0) == True >>> three_sum([i for i in range(-5000, 5001)], 3) == True","solution":"def three_sum(nums, target): Determines if there are three distinct integers in the list nums that add up to the target sum. Parameters: nums (list of int): The list of integers. target (int): The target sum. Returns: bool: True if there are three distinct integers that add up to the target sum, False otherwise. # Sort the list to use two-pointer technique nums.sort() # Iterate through each number as a potential first element for i in range(len(nums) - 2): # Use two-pointer technique for the remaining part of the list left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == target: return True elif current_sum < target: left += 1 else: right -= 1 return False"},{"question":"def update_stock(stock: dict, transactions: list) -> dict: Update the stock dictionary based on the list of transactions. Args: stock (dict): a dictionary representing the initial stock level. transactions (list): a list of dictionaries representing the transactions. Returns: dict: the updated stock dictionary. Example: >>> stock = { ... \\"apple\\": 10, ... \\"banana\\": 5, ... \\"orange\\": 8 ... } >>> transactions = [ ... {\\"product\\": \\"apple\\", \\"type\\": \\"purchase\\", \\"quantity\\": 5}, ... {\\"product\\": \\"banana\\", \\"type\\": \\"sale\\", \\"quantity\\": 2}, ... {\\"product\\": \\"orange\\", \\"type\\": \\"sale\\", \\"quantity\\": 10}, ... {\\"product\\": \\"pear\\", \\"type\\": \\"purchase\\", \\"quantity\\": 3} ... ] >>> update_stock(stock, transactions) {'apple': 15, 'banana': 3, 'orange': 0, 'pear': 3} pass import pytest def test_purchase_and_sale(): stock = { \\"apple\\": 10, \\"banana\\": 5, \\"orange\\": 8 } transactions = [ {\\"product\\": \\"apple\\", \\"type\\": \\"purchase\\", \\"quantity\\": 5}, {\\"product\\": \\"banana\\", \\"type\\": \\"sale\\", \\"quantity\\": 2}, {\\"product\\": \\"orange\\", \\"type\\": \\"sale\\", \\"quantity\\": 10}, {\\"product\\": \\"pear\\", \\"type\\": \\"purchase\\", \\"quantity\\": 3} ] updated_stock = update_stock(stock, transactions) expected_stock = {\\"apple\\": 15, \\"banana\\": 3, \\"orange\\": 0, \\"pear\\": 3} assert updated_stock == expected_stock def test_all_sales_resulting_in_zero(): stock = { \\"laptop\\": 20, \\"mouse\\": 50 } transactions = [ {\\"product\\": \\"laptop\\", \\"type\\": \\"sale\\", \\"quantity\\": 20}, {\\"product\\": \\"mouse\\", \\"type\\": \\"sale\\", \\"quantity\\": 50} ] updated_stock = update_stock(stock, transactions) expected_stock = {\\"laptop\\": 0, \\"mouse\\": 0} assert updated_stock == expected_stock def test_purchase_of_new_products(): stock = {} transactions = [ {\\"product\\": \\"charger\\", \\"type\\": \\"purchase\\", \\"quantity\\": 25}, {\\"product\\": \\"keyboard\\", \\"type\\": \\"purchase\\", \\"quantity\\": 10} ] updated_stock = update_stock(stock, transactions) expected_stock = {\\"charger\\": 25, \\"keyboard\\": 10} assert updated_stock == expected_stock def test_sale_of_nonexistent_product(): stock = { \\"phone\\": 15 } transactions = [ {\\"product\\": \\"headphone\\", \\"type\\": \\"sale\\", \\"quantity\\": 5} ] updated_stock = update_stock(stock, transactions) expected_stock = {\\"phone\\": 15, \\"headphone\\": 0} assert updated_stock == expected_stock def test_purchase_and_sale_to_zero(): stock = { \\"tablet\\": 10 } transactions = [ {\\"product\\": \\"tablet\\", \\"type\\": \\"sale\\", \\"quantity\\": 5}, {\\"product\\": \\"tablet\\", \\"type\\": \\"sale\\", \\"quantity\\": 5}, {\\"product\\": \\"tablet\\", \\"type\\": \\"purchase\\", \\"quantity\\": 8}, {\\"product\\": \\"tablet\\", \\"type\\": \\"sale\\", \\"quantity\\": 8} ] updated_stock = update_stock(stock, transactions) expected_stock = {\\"tablet\\": 0} assert updated_stock == expected_stock","solution":"def update_stock(stock: dict, transactions: list) -> dict: for transaction in transactions: product = transaction['product'] transaction_type = transaction['type'] quantity = transaction['quantity'] if transaction_type == 'purchase': if product in stock: stock[product] += quantity else: stock[product] = quantity elif transaction_type == 'sale': if product in stock: stock[product] -= quantity if stock[product] < 0: stock[product] = 0 else: stock[product] = 0 return stock"},{"question":"def shortest_path(n: int, m: int, grid: List[str], start: Tuple[int, int], target: Tuple[int, int]) -> int: Find the shortest path from the starting cell to the target cell in a 2D grid. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[str]): The 2D grid represented as a list of strings. start (Tuple[int, int]): The coordinates of the starting cell (1-based indexing). target (Tuple[int, int]): The coordinates of the target cell (1-based indexing). Returns: int: The length of the shortest path from the starting cell to the target cell. If no such path exists, returns -1. >>> shortest_path(5, 5, [ ... \\".....\\", ... \\"..#..\\", ... \\".\\", ... \\"..#..\\", ... \\".....\\" ... ], (1, 1), (5, 5)) 8 >>> shortest_path(3, 3, [ ... \\"#\\", ... \\"#.#\\", ... \\"#\\" ... ], (1, 1), (3, 3)) -1","solution":"from collections import deque def shortest_path(n, m, grid, start, target): def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' moves = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = [[False] * m for _ in range(n)] queue = deque([(start[0] - 1, start[1] - 1, 0)]) # Convert to 0-based index and add distance visited[start[0] - 1][start[1] - 1] = True while queue: x, y, dist = queue.popleft() if (x, y) == (target[0] - 1, target[1] - 1): return dist for move in moves: nx, ny = x + move[0], y + move[1] if is_valid(nx, ny) and not visited[nx][ny]: visited[nx][ny] = True queue.append((nx, ny, dist + 1)) return -1"},{"question":"def max_difference(input_list: List[int]) -> int: Given a list of integers, find the maximum difference between any two elements in the list. For an empty list or a list with only one element, return 0. >>> max_difference([1, 2, 3, 4, 5]) 4 >>> max_difference([-10, 0, 10]) 20 >>> max_difference([5]) 0","solution":"def max_difference(input_list): Returns the maximum difference between any two integers in the list. For an empty list or a list with only one element, returns 0. if len(input_list) < 2: return 0 return max(input_list) - min(input_list)"},{"question":"def can_sort_words(words: List[str]) -> str: Determine if the list of words can be sorted such that each word is followed by a word whose first letter matches the last letter of the previous word. >>> can_sort_words([\\"abc\\", \\"cde\\", \\"efg\\"]) \\"Yes\\" >>> can_sort_words([\\"hello\\", \\"world\\", \\"test\\", \\"this\\"]) \\"No\\" >>> can_sort_words([\\"a\\"]) \\"Yes\\" >>> can_sort_words([\\"ab\\", \\"bc\\"]) \\"Yes\\" >>> can_sort_words([\\"ab\\", \\"cd\\"]) \\"No\\" def process_test_cases(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Process multiple test cases for the can_sort_words function. >>> test_cases = [(3, [\\"abc\\", \\"cde\\", \\"efg\\"]), (4, [\\"hello\\", \\"world\\", \\"test\\", \\"this\\"]), (1, [\\"abc\\"]), (2, [\\"ab\\", \\"bc\\"]), (2, [\\"ab\\", \\"cd\\"])] >>> T = len(test_cases) >>> process_test_cases(T, test_cases) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\", \\"No\\"]","solution":"def can_sort_words(words): def dfs(start, current_word, visited): if len(visited) == len(words): return True for i in range(len(words)): if i not in visited and current_word[-1] == words[i][0]: visited.add(i) if dfs(i, words[i], visited): return True visited.remove(i) return False for i in range(len(words)): if dfs(i, words[i], set([i])): return \\"Yes\\" return \\"No\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N, words = test_cases[i] results.append(can_sort_words(words)) return results # Example usage: # test_cases = [(3, [\\"abc\\", \\"cde\\", \\"efg\\"]), (4, [\\"hello\\", \\"world\\", \\"test\\", \\"this\\"])] # T = len(test_cases) # print(process_test_cases(T, test_cases)) # This should output ['Yes', 'No']"},{"question":"def process_operations(operations: List[List[str]]) -> List[Union[int, float, str]]: Process a series of operations on a multiset and return the median after each relevant operation. Each operation is represented as a list where the first element is the action 'a', 'r', or 'm': 'a x' - add integer x to the multiset. 'r x' - remove one occurrence of integer x from the multiset if it exists. 'm' - return the median of the current elements in the multiset. Return a list of results for each 'm' operation. If the multiset is empty, return \\"Empty\\". Args: operations: A list of operations represented as lists of strings. Returns: A list of medians after 'm' operations or \\"Empty\\" if the multiset is empty. Examples: >>> process_operations([[\\"a\\", \\"1\\"], [\\"a\\", \\"2\\"], [\\"a\\", \\"3\\"], [\\"m\\"], [\\"r\\", \\"2\\"], [\\"m\\"], [\\"r\\", \\"1\\"], [\\"m\\"]]) [2, 2.0, 3] >>> process_operations([[\\"m\\"], [\\"a\\", \\"5\\"], [\\"m\\"], [\\"r\\", \\"5\\"], [\\"m\\"]]) [\\"Empty\\", 5, \\"Empty\\"] >>> process_operations([[\\"a\\", \\"1\\"], [\\"m\\"]]) [1] >>> process_operations([[\\"a\\", \\"1\\"], [\\"a\\", \\"2\\"], [\\"m\\"]]) [1.5] >>> process_operations([[\\"a\\", \\"1\\"], [\\"a\\", \\"1\\"], [\\"a\\", \\"2\\"], [\\"m\\"], [\\"r\\", \\"1\\"], [\\"m\\"]]) [1, 1.5] >>> process_operations([[\\"a\\", \\"1\\"], [\\"r\\", \\"2\\"], [\\"m\\"]]) [1] pass","solution":"import bisect class Multiset: def __init__(self): self.elements = [] def add(self, x): bisect.insort(self.elements, x) def remove(self, x): index = bisect.bisect_left(self.elements, x) if index < len(self.elements) and self.elements[index] == x: self.elements.pop(index) def median(self): if not self.elements: return \\"Empty\\" n = len(self.elements) if n % 2 == 1: return self.elements[n//2] else: return (self.elements[n//2 - 1] + self.elements[n//2]) / 2 def process_operations(operations): multiset = Multiset() results = [] for op in operations: if op[0] == 'a': multiset.add(int(op[1])) elif op[0] == 'r': multiset.remove(int(op[1])) elif op[0] == 'm': results.append(multiset.median()) return results"},{"question":"def max_unique_junctions(n: int, m: int, edges: List[Tuple[int, int]], s: int) -> int: Determine the maximum number of unique junctions Milo can visit starting from junction s. >>> max_unique_junctions(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)], 1) 5 >>> max_unique_junctions(4, 3, [(1, 2), (2, 3), (3, 4)], 2) 4 Use the following unit tests to verify the solution: from solution import max_unique_junctions def test_example_1(): n = 5 m = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)] s = 1 assert max_unique_junctions(n, m, edges, s) == 5 def test_example_2(): n = 4 m = 3 edges = [(1, 2), (2, 3), (3, 4)] s = 2 assert max_unique_junctions(n, m, edges, s) == 4 def test_minimal_case(): n = 1 m = 0 edges = [] s = 1 assert max_unique_junctions(n, m, edges, s) == 1 def test_disconnected_graph(): n = 5 m = 3 edges = [(1, 2), (2, 3), (4, 5)] s = 1 assert max_unique_junctions(n, m, edges, s) == 3 def test_two_components(): n = 6 m = 5 edges = [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)] s = 4 assert max_unique_junctions(n, m, edges, s) == 3","solution":"def max_unique_junctions(n, m, edges, s): from collections import deque, defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) queue = deque([(s, 0)]) # (current_junction, step_count) visited = set([s]) while queue: current, steps = queue.popleft() if steps % 2 == 0: # Even steps: Move to junction w if there is a v adjacent to current and w adjacent to v for v in graph[current]: for w in graph[v]: if w not in visited: visited.add(w) queue.append((w, steps + 1)) else: # Odd steps: Move to any adjacent junction for neighbor in graph[current]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, steps + 1)) return len(visited) # Example usage n = 5 m = 5 edges = [(1, 2), (2, 3), (3, 4), (4, 5), (2, 4)] s = 1 print(max_unique_junctions(n, m, edges, s)) # Output: 5"},{"question":"def minimize_maximum_sum_partition(n: int, arr: List[int]) -> int: This function takes an array and returns the minimized maximum sum of the two subarrays when split into exactly two non-empty subarrays. >>> minimize_maximum_sum_partition(5, [1, 2, 3, 4, 5]) 9 >>> minimize_maximum_sum_partition(4, [10, 10, 10, 10]) 20","solution":"def minimize_maximum_sum_partition(n, arr): This function takes an array and returns the minimized maximum sum of the two subarrays when split into exactly two non-empty subarrays. total_sum = sum(arr) left_sum = 0 min_max_sum = float('inf') for i in range(n - 1): left_sum += arr[i] right_sum = total_sum - left_sum max_sum = max(left_sum, right_sum) min_max_sum = min(min_max_sum, max_sum) return min_max_sum"},{"question":"def number_reduction(arr: List[int]) -> int: Write a function to simulate a game called \\"Number Reduction.\\" In this game, you are given an array of positive integers. You can perform a specific operation any number of times: choose any two elements in the array, add them together, and replace one of them with the sum, while the other element is set to zero. The goal is to reduce the array to a single non-zero value. Args: arr: A list of positive integers. Returns: The minimum number of operations required to reduce the array to a single non-zero value. Example: >>> number_reduction([1, 2, 3]) 2 >>> number_reduction([5, 3, 9, 4]) 3 # Function implementation goes here","solution":"def number_reduction(arr): Returns the minimum number of operations required to reduce the array to a single non-zero value. # The minimum number of operations is equal to the length of array minus one, # because each operation reduces the number of non-zero elements by one. return len(arr) - 1"},{"question":"def first_repeated_integer(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Identifies the first element that appears more than once in each list of integers provided in test cases. If no such element exists, returns -1. Args: test_cases (list of tuple): A list of tuples where each tuple represents (m, list of integers) Returns: list: A list of the first repeated integer for each test case, or -1 if no repetition occurs. Examples: >>> first_repeated_integer([(5, [1, 2, 3, 4, 5])]) [-1] >>> first_repeated_integer([(6, [1, 2, 3, 1, 2, 3])]) [1]","solution":"def first_repeated_integer(test_cases): Identifies the first element that appears more than once in each list of integers provided in test cases. If no such element exists, returns -1. Args: test_cases (list of tuple): A list of tuples where each tuple represents (m, list of integers) Returns: list: A list of the first repeated integer for each test case, or -1 if no repetition occurs. results = [] for m, integers in test_cases: seen = set() first_repeated = -1 for num in integers: if num in seen: first_repeated = num break seen.add(num) results.append(first_repeated) return results"},{"question":"def max_value_collect(n: int, m: int, grid: List[List[int]]) -> int: Compute the maximum value you can collect while moving from the top-left to the bottom-right corner of the grid. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (List[List[int]]): The grid itself, represented as a list of lists of non-negative integers. Returns: int: The maximum value that can be collected. Example: >>> max_value_collect(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 29","solution":"def max_value_collect(n, m, grid): Returns the maximum value that can be collected while moving from the top-left to the bottom-right corner of the grid. dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1]"},{"question":"class VersionControlSystem: def __init__(self): self.groups = {} self.version_tags = {} def add_version(self, group_name, file_version): Adds a new version of a file to a specified group. pass def remove_version(self, group_name, file_version): Removes a version of a file from a specified group. pass def tag_version(self, file_version, tag_name): Associates a tag with a particular version of a file. pass def query_group(self, group_name): Retrieves all versions of files in a specified group and all associated tags. Returns a list of strings with each file version followed by its tags. pass def process_commands(commands): Simulates a basic version control system for managing file versions and their functionalities. Executes a list of commands and returns results for QUERY commands. Args: commands (List[str]): List of commands to process. Returns: List[str]: Results of QUERY commands. >>> commands = [ ... \\"ADD group1 v1\\", ... \\"ADD group1 v2\\", ... \\"TAG v1 stable\\", ... \\"TAG v2 beta\\", ... \\"QUERY group1\\", ... \\"REMOVE group1 v1\\", ... \\"QUERY group1\\", ... \\"QUERY group2\\" ... ] >>> process_commands(commands) ['v1: [stable]', 'v2: [beta]', 'v2: [beta]'] vcs = VersionControlSystem() results = [] for command in commands: parts = command.split() if parts[0] == \\"ADD\\": vcs.add_version(parts[1], parts[2]) elif parts[0] == \\"REMOVE\\": vcs.remove_version(parts[1], parts[2]) elif parts[0] == \\"TAG\\": vcs.tag_version(parts[1], parts[2]) elif parts[0] == \\"QUERY\\": result = vcs.query_group(parts[1]) results.extend(result) return results","solution":"class VersionControlSystem: def __init__(self): self.groups = {} self.version_tags = {} def add_version(self, group_name, file_version): if group_name not in self.groups: self.groups[group_name] = set() self.groups[group_name].add(file_version) def remove_version(self, group_name, file_version): if group_name in self.groups and file_version in self.groups[group_name]: self.groups[group_name].remove(file_version) def tag_version(self, file_version, tag_name): if file_version not in self.version_tags: self.version_tags[file_version] = set() self.version_tags[file_version].add(tag_name) def query_group(self, group_name): if group_name not in self.groups: return [] result = [] for version in sorted(self.groups[group_name]): tags = sorted(self.version_tags.get(version, [])) result.append(f\\"{version}: {tags}\\") return result def process_commands(commands): vcs = VersionControlSystem() results = [] for command in commands: parts = command.split() if parts[0] == \\"ADD\\": vcs.add_version(parts[1], parts[2]) elif parts[0] == \\"REMOVE\\": vcs.remove_version(parts[1], parts[2]) elif parts[0] == \\"TAG\\": vcs.tag_version(parts[1], parts[2]) elif parts[0] == \\"QUERY\\": result = vcs.query_group(parts[1]) results.extend(result) return results"},{"question":"def min_replacements_to_make_beautiful(s: str) -> int: Determine the minimum number of characters you need to replace to make the string beautiful. A string is said to be beautiful if no two adjacent characters are the same. Given a string s, this function returns the minimum number of characters you need to replace to make the string beautiful. If the string is already beautiful, the output should be 0. Examples: >>> min_replacements_to_make_beautiful(\\"ab\\") 0 >>> min_replacements_to_make_beautiful(\\"aa\\") 1 >>> min_replacements_to_make_beautiful(\\"aab\\") 1 >>> min_replacements_to_make_beautiful(\\"ababa\\") 0","solution":"def min_replacements_to_make_beautiful(s): replacements = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: replacements += 1 return replacements"},{"question":"def count_book_organizations(N: int) -> int: Returns the number of ways to organize N books such that each book can switch places with exactly one other book. >>> count_book_organizations(2) == 1 >>> count_book_organizations(4) == 2 >>> count_book_organizations(6) == 5 >>> count_book_organizations(8) == 14 >>> count_book_organizations(0) == 1 >>> count_book_organizations(3) == 0 >>> count_book_organizations(5) == 0 >>> count_book_organizations(7) == 0","solution":"def count_book_organizations(N): Returns the number of ways to organize N books such that each book can switch places with exactly one other book. # For N books, the valid pairs are: # For N = 2, there is only 1 way: (1, 2) # For N = 4, there are 3 ways: (1, 2), (3, 4); (1, 3), (2, 4); (1, 4), (2, 3) # For N = 6, there are 15 ways: (1, 2), (3, 4), (5, 6); (1, 3), (2, 4), (5, 6) # Essentially it is the (N/2)-th Catalan number if N % 2 != 0: return 0 # It's impossible to pair all books if N is odd pairs_count = N // 2 catalan = [0] * (pairs_count + 1) catalan[0] = 1 for i in range(1, pairs_count + 1): catalan[i] = 0 for j in range(i): catalan[i] += catalan[j] * catalan[i - 1 - j] return catalan[pairs_count]"},{"question":"def determine_capital(N: int, M: int, A: int, B: int, residents: List[int], roads: List[Tuple[int, int]]) -> int: Determine whether assigning city A or city B as the capital results in minimizing the maximum travel distance for any individual resident. If both assignments result in the same maximum travel distance, assign the smaller city (based on the city number). Parameters: N (int): Number of cities. M (int): Number of bidirectional roads. A (int): City A. B (int): City B. residents (List[int]): List of residents in each city. roads (List[Tuple[int, int]]): List of bidirectional roads connecting the cities. Returns: int: The city that should be the capital >>> determine_capital(5, 4, 1, 2, [10, 20, 15, 5, 0], [(1, 3), (3, 4), (4, 5), (2, 4)]) 2 >>> determine_capital(4, 3, 3, 4, [5, 5, 5, 5], [(1, 2), (2, 3), (3, 4)]) 3","solution":"from collections import deque, defaultdict def determine_capital(N, M, A, B, residents, roads): def bfs(start): distances = [-1] * (N + 1) queue = deque([start]) distances[start] = 0 while queue: city = queue.popleft() for neighbor in graph[city]: if distances[neighbor] == -1: queue.append(neighbor) distances[neighbor] = distances[city] + 1 return distances # Build graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Get distances from city A and B distance_from_A = bfs(A) distance_from_B = bfs(B) # Calculate the maximum travel distance for each city being the capital max_distance_A = max(distance_from_A[i] * residents[i-1] for i in range(1, N + 1)) max_distance_B = max(distance_from_B[i] * residents[i-1] for i in range(1, N + 1)) # Determine the capital city if max_distance_A < max_distance_B: return A elif max_distance_A > max_distance_B: return B else: return min(A, B)"},{"question":"def max_success_probability(n: int, m: int, operations: List[Tuple[int, int]]) -> int: Returns the maximum total success probability given n resource points and a list of operations. :param n: Maximum resource points available :param m: Number of operations available :param operations: List of tuples representing each operation's (resource points required, success probability) :return: Maximum total success probability # Initialize dp array where dp[i] is the max probability achievable with i resource points pass # Example test cases if __name__ == \\"__main__\\": print(max_success_probability(10, 3, [(5, 20), (3, 15), (7, 10)])) # Output: 35 print(max_success_probability(8, 4, [(6, 10), (4, 5), (3, 12), (2, 8)])) # Output: 20","solution":"def max_success_probability(n, m, operations): Returns the maximum total success probability given n resource points and a list of operations. :param n: Maximum resource points available :param m: Number of operations available :param operations: List of tuples representing each operation's (resource points required, success probability) :return: Maximum total success probability # Initialize dp array where dp[i] is the max probability achievable with i resource points dp = [0] * (n + 1) for ri, pi in operations: # Update dp array from the end to the start to avoid reusing operations for j in range(n, ri - 1, -1): dp[j] = max(dp[j], dp[j - ri] + pi) return max(dp)"},{"question":"def max_coins(n: int, coins: List[Tuple[int, int, int]]) -> int: Calculate the maximum number of coins Sarah can collect given the coins and their times. Parameters: n (int): Number of coins. coins (list): List of tuples representing the coins. Each tuple contains (x, y, t). Returns: int: Maximum number of coins Sarah can collect. from typing import List, Tuple def test_example_1(): coins = [(1, 1, 2), (2, 2, 4), (3, 3, 6)] assert max_coins(3, coins) == 3 def test_example_2(): coins = [(1, 2, 3), (2, 1, 2)] assert max_coins(2, coins) == 1 def test_single_coin(): coins = [(0, 0, 1)] assert max_coins(1, coins) == 1 def test_distant_coins(): coins = [(1, 1, 1), (1000, 1000, 2)] assert max_coins(2, coins) == 1 def test_two_close_coins(): coins = [(1, 1, 1), (2, 2, 3)] assert max_coins(2, coins) == 2 def test_multiple_colinear(): coins = [(1, 1, 1), (2, 2, 3), (3, 3, 5), (4, 4, 7)] assert max_coins(4, coins) == 4 def test_multiple_non_colinear(): coins = [(1, 1, 2), (3, 1, 5), (2, 2, 4)] assert max_coins(3, coins) == 2","solution":"def max_coins(n, coins): Calculate the maximum number of coins Sarah can collect given the coins and their times. Parameters: n (int): Number of coins. coins (list): List of tuples representing the coins. Each tuple contains (x, y, t). Returns: int: Maximum number of coins Sarah can collect. coins.sort(key=lambda x: x[2]) # Sort coins by the time they fall dp = [0] * n # dp array to keep track of max coins collected up to ith coin for i in range(n): x1, y1, t1 = coins[i] dp[i] = 1 # Sarah can at least collect the coin that falls at (x1, y1, t1) for j in range(i): x2, y2, t2 = coins[j] if t1 - t2 >= abs(x1 - x2) + abs(y1 - y2): # Check if Sarah can move from coin[j] to coin[i] dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def number_of_paths(N: int, M: int, K: int, blocked_cells: List[Tuple[int, int]]) -> int: Calculate the number of distinct paths in a grid from (1, 1) to (N, M) avoiding blocked cells. >>> number_of_paths(3, 3, 2, [(2, 2), (2, 3)]) 1 >>> number_of_paths(3, 3, 3, [(1, 2), (2, 1), (2, 2)]) 0","solution":"def number_of_paths(N, M, K, blocked_cells): MOD = 10**9 + 7 # Initialize the grid with 0 paths. dp = [[0] * M for _ in range(N)] # Block the cells in the grid. for i, j in blocked_cells: dp[i-1][j-1] = -1 # Initialize the starting position if it's not blocked. if dp[0][0] == 0: dp[0][0] = 1 else: return 0 for i in range(N): for j in range(M): if dp[i][j] == -1: continue # Move down if i > 0 and dp[i-1][j] != -1: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD # Move right if j > 0 and dp[i][j-1] != -1: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return max(dp[N-1][M-1], 0)"},{"question":"from collections import defaultdict, deque import sys from typing import List, Tuple def bfs_min_time(N: int, adjacency_list: defaultdict) -> List[int]: Calculate minimum time required for every house to be reached from house 1. Args: N: int: Number of houses. adjacency_list: defaultdict: Adjacency list representing the roads. Returns: List[int]: A list of N-1 integers indicating the minimum time required to reach each house from house 1. If a house is not reachable, return -1 for that house. Examples: >>> bfs_min_time(4, defaultdict(list, {1: [(2, 5), (3, 10)], 2: [(1, 5), (4, 3)], 3: [(1, 10), (4, 1)], 4: [(2, 3), (3, 1)]})) [5, 10, 8] >>> bfs_min_time(3, defaultdict(list, {1: [(2, 1), (3, 4)], 2: [(1, 1)], 3: [(1, 4)]})) [1, 4] pass def solve(test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[List[int]]: Solve the problem for given test cases. Args: test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]: List of test cases. Returns: List[List[int]]: A list of results for each test case. pass def process_input(input_data: str) -> List[Tuple[int, int, List[Tuple[int, int, int]]]]: Process the input data and extract test cases. Args: input_data: str: Raw input data as a string. Returns: List[Tuple[int, int, List[Tuple[int, int, int]]]]: List of test cases. pass # Example usage if __name__ == \\"__main__\\": input_data = 2 4 4 1 2 5 1 3 10 2 4 3 3 4 1 3 2 1 2 1 1 3 4 test_cases = process_input(input_data) results = solve(test_cases) for result in results: print(\\" \\".join(map(str, result)))","solution":"from collections import defaultdict, deque import sys def bfs_min_time(N, adjacency_list): dist = [-1] * (N + 1) dist[1] = 0 queue = deque([1]) while queue: current = queue.popleft() for neighbor, time in adjacency_list[current]: if dist[neighbor] == -1: dist[neighbor] = dist[current] + time queue.append(neighbor) return dist[2:] # excluding house 1 def solve(test_cases): results = [] for N, M, roads in test_cases: adjacency_list = defaultdict(list) for u, v, w in roads: adjacency_list[u].append((v, w)) adjacency_list[v].append((u, w)) result = bfs_min_time(N, adjacency_list) results.append(result) return results # Helper function to process input def process_input(input_data): input_lines = input_data.strip().split('n') T = int(input_lines[0]) index = 1 test_cases = [] for _ in range(T): N, M = map(int, input_lines[index].split()) index += 1 roads = [] for _ in range(M): u, v, w = map(int, input_lines[index].split()) index += 1 roads.append((u, v, w)) test_cases.append((N, M, roads)) return test_cases # Example usage if __name__ == \\"__main__\\": input_data = 2 4 4 1 2 5 1 3 10 2 4 3 3 4 1 3 2 1 2 1 1 3 4 test_cases = process_input(input_data) results = solve(test_cases) for result in results: print(\\" \\".join(map(str, result)))"},{"question":"def arrange_books(n: int, heights: List[int], L: int, R: int) -> List[Union[int, str]]: Arrange books in increasing order of their height within the range [L, R]. Parameters: n (int): Number of books heights (list of int): Heights of the books L (int): Lower bound of the height range R (int): Upper bound of the height range Returns: list of int: Sorted list of heights within the range [L, R] If no books found within range, returns ['No books found'] >>> arrange_books(5, [15, 20, 10, 30, 25], 15, 25) [15, 20, 25] >>> arrange_books(5, [5, 10, 30, 35, 40], 15, 25) ['No books found'] >>> arrange_books(5, [15, 16, 18, 19, 20], 15, 20) [15, 16, 18, 19, 20] >>> arrange_books(5, [5, 10, 15, 20, 25], 20, 20) [20] >>> arrange_books(6, [10, 12, 15, 17, 21, 30], 15, 21) [15, 17, 21] >>> arrange_books(4, [10, 15, 20, 25], 15, 25) [15, 20, 25] >>> arrange_books(6, [15, 15, 15, 15, 25, 25], 15, 25) [15, 15, 15, 15, 25, 25] >>> arrange_books(3, [99999, 100000, 100001], 99999, 100000) [99999, 100000]","solution":"def arrange_books(n, heights, L, R): Arrange books in increasing order of their height within the range [L, R]. Parameters: n (int): Number of books heights (list of int): Heights of the books L (int): Lower bound of the height range R (int): Upper bound of the height range Returns: list of int: Sorted list of heights within the range [L, R] If no books found within range, returns ['No books found'] books_in_range = [height for height in heights if L <= height <= R] if not books_in_range: return [\\"No books found\\"] books_in_range.sort() return books_in_range"},{"question":"def garden_watering(N: int, M: int, garden: List[List[int]], requests: List[Tuple[int, int, int, int]]) -> List[int]: Calculate the amount of water needed to water sub-rectangles in a garden. Args: N (int): Number of rows in the garden. M (int): Number of columns in the garden. garden (List[List[int]]): 2D list representing the garden grid with number of plants in each cell. requests (List[Tuple[int, int, int, int]]): List of tuples representing the sub-rectangle requests. Returns: List[int]: List with the amount of water required for each request. Example: >>> garden_watering(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], [(1, 1, 2, 2), (2, 2, 3, 3), (1, 1, 4, 4)]) [14, 34, 136]","solution":"def preprocess_garden(garden): N = len(garden) M = len(garden[0]) prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, M + 1): prefix_sum[i][j] = (garden[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1]) return prefix_sum def water_amount(prefix_sum, r1, c1, r2, c2): return (prefix_sum[r2][c2] - prefix_sum[r1-1][c2] - prefix_sum[r2][c1-1] + prefix_sum[r1-1][c1-1]) def garden_watering(N, M, garden, requests): prefix_sum = preprocess_garden(garden) results = [] for r1, c1, r2, c2 in requests: results.append(water_amount(prefix_sum, r1, c1, r2, c2)) return results"},{"question":"def count_elements_lesser_left(arr): For each element in the array, count how many elements to the left of the current element are lesser than the current element. Parameters: arr (list): List of non-negative integers Returns: list: Resultant list where each element is a count of elements to the left that are lesser than the current element. Example: >>> count_elements_lesser_left([2, 1, 5, 3, 4]) [0, 0, 2, 2, 3] >>> count_elements_lesser_left([3, 3, 3, 3, 3]) [0, 0, 0, 0, 0] >>> count_elements_lesser_left([1, 2, 3, 4, 5]) [0, 1, 2, 3, 4] >>> count_elements_lesser_left([5, 4, 3, 2, 1]) [0, 0, 0, 0, 0] >>> count_elements_lesser_left([7]) [0] >>> count_elements_lesser_left([3, 6, 1, 8, 2, 5]) [0, 1, 0, 3, 1, 3]","solution":"def count_elements_lesser_left(arr): For each element in the array, count how many elements to the left of the current element are lesser than the current element. Parameters: arr (list): List of non-negative integers Returns: list: Resultant list where each element is a count of elements to the left that are lesser than the current element. n = len(arr) result = [0] * n for i in range(1, n): count = 0 for j in range(i): if arr[j] < arr[i]: count += 1 result[i] = count return result"},{"question":"from typing import List def min_steps_to_reach_bottom_right(n: int, m: int, grid: List[str]) -> int: Calculate the minimum number of steps required to reach the bottom-right cell (n, m) from the top-left cell (1, 1) in a grid. If it's impossible, return -1. >>> min_steps_to_reach_bottom_right(5, 5, [ \\".....\\", \\".#..#\\", \\"..T..\\", \\".#..#\\", \\".....\\" ]) 8 >>> min_steps_to_reach_bottom_right(5, 5, [ \\".....\\", \\".....\\", \\"#\\", \\".....\\", \\".....\\", ]) -1 >>> min_steps_to_reach_bottom_right(2, 2, [ \\"..\\", \\"T.\\", ]) 2","solution":"from collections import deque def min_steps_to_reach_bottom_right(n, m, grid): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] != '#' queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (n - 1, m - 1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) if grid[nx][ny] == 'T': for ddx, ddy in directions: nnx, nny = nx + ddx, ny + ddy if is_valid(nnx, nny) and (nnx, nny) not in visited: visited.add((nnx, nny)) queue.append((nnx, nny, steps + 2)) # 'T' forces an additional move else: queue.append((nx, ny, steps + 1)) return -1"},{"question":"import calendar def generate_calendar(month: int) -> str: Generates the calendar for the given month assuming the first day is Sunday. Parameters: month (int): Month number (1-12 representing January to December) Returns: str: Calendar of the given month Examples: >>> print(generate_calendar(2)) February 2023 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 >>> print(generate_calendar(7)) July 2023 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31","solution":"import calendar def generate_calendar(month): Generates the calendar for the given month assuming the first day is Sunday. Parameters: month (int): Month number (1-12 representing January to December) Returns: str: Calendar of the given month year = 2023 # We can assume any non-leap year for demonstration # Will handle Feb separately # Configure calendar to start on Sunday cal = calendar.TextCalendar(firstweekday=6) # Generate calendar for the given month month_cal = cal.formatmonth(year, month) return month_cal # Example usage: # print(generate_calendar(2)) # print(generate_calendar(7))"},{"question":"def is_even_path_exists(grid): Determine if a path exists from the top-left to the bottom-right corner in a grid, where the path only consists of even numbers. Args: grid (List[List[int]]): A 2D grid of integers. Returns: bool: True if such a path exists, otherwise False. Examples: >>> is_even_path_exists([ ... [2, 4, 6], ... [8, 3, 4], ... [6, 8, 2] ... ]) True >>> is_even_path_exists([ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) False pass def process_input(input_data): Process multiple datasets to determine if the even path exists in each grid. Args: input_data (str): Multi-line string representing multiple datasets. Returns: str: A multi-line string with \\"YES\\" or \\"NO\\" for each dataset. Examples: >>> process_input(\\"3n2 4 6n8 3 4n6 8 2n4n1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16n0\\") 'YESnNO' >>> process_input(\\"2n4 6n8 2n2n1 3n5 7n0\\") 'YESnNO' pass # Unit Test def test_is_even_path_exists(): grid1 = [ [2, 4, 6], [8, 3, 4], [6, 8, 2] ] assert is_even_path_exists(grid1) == True grid2 = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert is_even_path_exists(grid2) == False def test_process_input(): input_data = \\"3n2 4 6n8 3 4n6 8 2n4n1 2 3 4n5 6 7 8n9 10 11 12n13 14 15 16n0\\" expected_output = \\"YESnNO\\" assert process_input(input_data) == expected_output input_data2 = \\"2n4 6n8 2n2n1 3n5 7n0\\" expected_output2 = \\"YESnNO\\" assert process_input(input_data2) == expected_output2","solution":"def is_even_path_exists(grid): N = len(grid) if grid[0][0] % 2 != 0 or grid[N-1][N-1] % 2 != 0: return False from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, N-1): return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] % 2 == 0: visited.add((nx, ny)) queue.append((nx, ny)) return False def process_input(input_data): datasets = input_data.strip().split('n') results = [] i = 0 while i < len(datasets): N = int(datasets[i]) if N == 0: break grid = [] for j in range(1, N+1): grid.append(list(map(int, datasets[i + j].split()))) i += N + 1 if is_even_path_exists(grid): results.append(\\"YES\\") else: results.append(\\"NO\\") return \\"n\\".join(results)"},{"question":"def reorder_string(s: str) -> str: Reorders a string so that alphabetic characters come first, then numbers, then special characters, then spaces, all maintaining their original order. >>> reorder_string(\\"a1b2+_ c3d!\\") == \\"abcd123+_! \\" >>> reorder_string(\\"abcdef\\") == \\"abcdef\\" >>> reorder_string(\\"123456\\") == \\"123456\\" >>> reorder_string(\\"!@#%\\") == \\"!@#%\\" >>> reorder_string(\\" \\") == \\" \\" >>> reorder_string(\\"a1b2c3\\") == \\"abc123\\" >>> reorder_string(\\"a1!b2@\\") == \\"ab12!@\\" >>> reorder_string(\\"a 1!b 2@\\") == \\"ab12!@ \\"","solution":"def reorder_string(s): Reorders a string so that alphabetic characters come first, then numbers, then special characters, then spaces, all maintaining their original order. alphabets = [] numbers = [] specials = [] spaces = [] for char in s: if char.isalpha(): alphabets.append(char) elif char.isdigit(): numbers.append(char) elif char.isspace(): spaces.append(char) else: specials.append(char) return ''.join(alphabets + numbers + specials + spaces)"},{"question":"from typing import List, Tuple def can_assign_difficulties(n: int, m: int, constraints: List[Tuple[int, int]]) -> str: Determine if it is possible to assign difficulties to all problems such that they can be arranged in increasing order. Args: n: The number of problems. m: The number of constraints on the relative difficulties. constraints: A list of tuples where each tuple (u, v) indicates problem u is harder than problem v. Returns: \\"YES\\" or \\"NO\\" depending on whether it is possible to meet the constraints or not. >>> can_assign_difficulties(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)]) 'YES' >>> can_assign_difficulties(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 'NO' >>> can_assign_difficulties(5, 0, []) 'YES' >>> can_assign_difficulties(3, 3, [(1, 2), (2, 3), (3, 1)]) 'NO' >>> can_assign_difficulties(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> can_assign_difficulties(4, 2, [(1, 2), (3, 4)]) 'YES' pass","solution":"def can_assign_difficulties(n, m, constraints): from collections import defaultdict, deque graph = defaultdict(list) in_degree = {i: 0 for i in range(1, n+1)} for u, v in constraints: graph[u].append(v) in_degree[v] += 1 queue = deque([node for node in range(1, n+1) if in_degree[node] == 0]) sorted_nodes = [] while queue: node = queue.popleft() sorted_nodes.append(node) for neigh in graph[node]: in_degree[neigh] -= 1 if in_degree[neigh] == 0: queue.append(neigh) return \\"YES\\" if len(sorted_nodes) == n else \\"NO\\""},{"question":"def are_anagrams(s1: str, s2: str) -> bool: Determines if two strings s1 and s2 are anagrams of each other. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"Anagram\\", \\"nag a ram\\") True pass def process_anagram_tests(T: int, test_cases: list[tuple[str, str]]) -> list[str]: Processes the list of test cases and returns a list of results for each test case. >>> process_anagram_tests(3, [(\\"listen\\", \\"silent\\"), (\\"hello\\", \\"world\\"), (\\"Anagram\\", \\"nag a ram\\")]) [\\"Yes\\", \\"No\\", \\"Yes\\"] >>> process_anagram_tests(2, [(\\"The Eyes\\", \\"They See\\"), (\\"Not\\", \\"Anagram\\")]) [\\"Yes\\", \\"No\\"] pass","solution":"def are_anagrams(s1, s2): Determines if two strings s1 and s2 are anagrams of each other. # Normalize the strings by converting to lowercase and removing spaces normalized_s1 = ''.join(s1.lower().split()) normalized_s2 = ''.join(s2.lower().split()) # Count the frequency of each character return sorted(normalized_s1) == sorted(normalized_s2) def process_anagram_tests(T, test_cases): Processes the list of test cases and returns a list of results for each test case. results = [] for s1, s2 in test_cases: if are_anagrams(s1, s2): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def is_possible_to_redistribute(N: int, flowers: List[int]) -> str: Determines if it's possible to redistribute flowers so that each plant has a unique number of flowers. >>> is_possible_to_redistribute(3, [1, 5, 3]) 'POSSIBLE' >>> is_possible_to_redistribute(4, [1, 2, 2, 3]) 'IMPOSSIBLE'","solution":"def is_possible_to_redistribute(N, flowers): Determines if it's possible to redistribute flowers so that each plant has a unique number of flowers. Parameters: N (int): Number of plants flowers (list): List containing numbers of flowers on each plant Returns: str: \\"POSSIBLE\\" if unique distribution is feasible, \\"IMPOSSIBLE\\" otherwise flower_counts = {} # Count occurrences of each flower count for f in flowers: if f in flower_counts: flower_counts[f] += 1 else: flower_counts[f] = 1 # If any flower count appears more than once, impossible to have unique counts if any(count > 1 for count in flower_counts.values()): return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"import heapq from typing import List def min_cost_to_merge_segments(difficulties: List[int]) -> int: Returns the minimum total cost to merge all segments into one. >>> min_cost_to_merge_segments([4, 3, 2, 6]) 29 >>> min_cost_to_merge_segments([1, 1, 1, 1]) 8 >>> min_cost_to_merge_segments([1, 2, 3, 4]) 19 >>> min_cost_to_merge_segments([4, 3, 2, 1]) 19 >>> min_cost_to_merge_segments([5, 7]) 12","solution":"import heapq def min_cost_to_merge_segments(difficulties): Returns the minimum total cost to merge all segments into one. heapq.heapify(difficulties) total_cost = 0 while len(difficulties) > 1: first = heapq.heappop(difficulties) second = heapq.heappop(difficulties) cost = first + second total_cost += cost heapq.heappush(difficulties, cost) return total_cost"},{"question":"def max_items_in_first_box(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Compute the maximum number of items that can be in the first box after a series of operations. Args: t : int : number of test cases test_cases : List[Tuple[int, List[int]]] : a list of tuples, each containing the number of boxes and the list of items in the boxes Returns: List[int] : a list containing the results for each test case Examples: >>> max_items_in_first_box(2, [(5, [1, 2, 3, 4, 5]), (4, [10, 10, 10, 10])]) [15, 40] >>> max_items_in_first_box(1, [(1, [100])]) [100]","solution":"def max_items_in_first_box(t, test_cases): results = [] for i in range(t): n, items = test_cases[i] total_items = sum(items) results.append(total_items) return results"},{"question":"def rotate_list(nums, k): Rotates the list nums by k positions to the right. Parameters: nums (List[int]): The list of integers to rotate. k (int): The number of positions to rotate the list. Returns: List[int]: The list rotated by k positions. Examples: >>> rotate_list([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_list([10, 20, 30, 40], 1) [40, 10, 20, 30] >>> rotate_list([7, 8, 9], 3) [7, 8, 9]","solution":"def rotate_list(nums, k): Rotates the list nums by k positions to the right. n = len(nums) k = k % n # In case k is larger than n return nums[-k:] + nums[:-k]"},{"question":"import math from typing import List, Tuple def can_reach_food(R: int, Fx: int, Fy: int, D: int, N: int, foxes: List[Tuple[int, int]]) -> List[str]: Determines if each fox can reach the food source within the specified distance. Parameters: - R (int): Radius of the circular forest. - Fx, Fy (int): Coordinates of the food source. - D (int): Distance within which the foxes can reach the food. - N (int): Number of foxes. - foxes (list of tuples): List of tuples representing the coordinates of fox homes. Returns: - list of str: List with \\"Yes\\" or \\"No\\" for each fox. >>> R = 500 >>> Fx, Fy = 0, 0 >>> D = 50 >>> N = 1 >>> foxes = [(30, 40)] >>> can_reach_food(R, Fx, Fy, D, N, foxes) ['Yes'] >>> R = 500 >>> Fx, Fy = 0, 0 >>> D = 30 >>> N = 1 >>> foxes = [(30, 40)] >>> can_reach_food(R, Fx, Fy, D, N, foxes) ['No']","solution":"import math def can_reach_food(R, Fx, Fy, D, N, foxes): Determines if each fox can reach the food source within the specified distance. Parameters: - R (int): Radius of the circular forest. - Fx, Fy (int): Coordinates of the food source. - D (int): Distance within which the foxes can reach the food. - N (int): Number of foxes. - foxes (list of tuples): List of tuples representing the coordinates of fox homes. Returns: - list of str: List with \\"Yes\\" or \\"No\\" for each fox. results = [] for x, y in foxes: distance = math.sqrt((Fx - x) ** 2 + (Fy - y) ** 2) if distance <= D: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"class ArrayProcessor: def __init__(self, n, arr): self.n = n self.arr = arr def update_value(self, pos, x): Replace the value in the array at position pos with x. pass # Replace the value in the array at position pos with x def find_max_in_subarray(self, l, r): Find the maximum value in the subarray arr[l ... r]. pass # Find the maximum value in the subarray arr[l ... r] def process_queries(n, q, array, queries): You are given an array of n integers and q queries to be performed on this array. There are two types of queries: * 1 pos x (1 ≤ pos ≤ n, x is an integer): replace the value in the array at position pos with x (set array[pos] := x); * 2 l r (1 ≤ l ≤ r ≤ n): find the maximum value in the subarray array[l ... r]. Example usage: >>> process_queries(6, 5, [1, 7, 3, 6, 5, 4], [(2, 1, 3), (2, 2, 5), (1, 4, 10), (2, 3, 6), (2, 1, 6)]) [7, 7, 10, 10] pass # Process an array of integers with given queries import pytest def test_example1(): n = 6 q = 5 array = [1, 7, 3, 6, 5, 4] queries = [ (2, 1, 3), (2, 2, 5), (1, 4, 10), (2, 3, 6), (2, 1, 6), ] expected_output = [7, 7, 10, 10] assert process_queries(n, q, array, queries) == expected_output def test_example2(): n = 10 q = 7 array = [5, 2, 9, 7, 5, 1, 3, 4, 8, 6] queries = [ (2, 1, 5), (1, 6, 10), (2, 4, 7), (2, 1, 10), (1, 10, 9), (2, 7, 10), (2, 3, 9), ] expected_output = [9, 10, 10, 9, 10] assert process_queries(n, q, array, queries) == expected_output def test_update_and_max_query(): n = 5 q = 4 array = [1, 2, 3, 4, 5] queries = [ (2, 1, 3), (1, 3, 10), (2, 1, 5), (2, 3, 3), ] expected_output = [3, 10, 10] assert process_queries(n, q, array, queries) == expected_output def test_single_element(): n = 1 q = 3 array = [100] queries = [ (2, 1, 1), (1, 1, 200), (2, 1, 1) ] expected_output = [100, 200] assert process_queries(n, q, array, queries) == expected_output def test_all_elements_same(): n = 4 q = 4 array = [7, 7, 7, 7] queries = [ (2, 1, 4), (1, 2, 5), (2, 1, 3), (2, 2, 4), ] expected_output = [7, 7, 7] assert process_queries(n, q, array, queries) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"class ArrayProcessor: def __init__(self, n, arr): self.n = n self.arr = arr def update_value(self, pos, x): Replace the value in the array at position pos with x. self.arr[pos - 1] = x def find_max_in_subarray(self, l, r): Find the maximum value in the subarray arr[l ... r]. return max(self.arr[l - 1:r]) def process_queries(n, q, array, queries): array_processor = ArrayProcessor(n, array) results = [] for query in queries: if query[0] == 1: _, pos, x = query array_processor.update_value(pos, x) elif query[0] == 2: _, l, r = query result = array_processor.find_max_in_subarray(l, r) results.append(result) return results"},{"question":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If no common prefix exists, returns an empty string. Parameters: strs (List[str]): List of strings to find the common prefix from. Returns: str: The longest common prefix. Examples: >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"flame\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"\\"]) '' >>> longest_common_prefix([\\"a\\"]) 'a' >>> longest_common_prefix([\\"a\\", \\"b\\"]) '' >>> longest_common_prefix([\\"abcdefgh\\", \\"abcde\\", \\"abcd\\", \\"abc\\"]) 'abc' >>> longest_common_prefix([\\"abab\\", \\"aba\\", \\"abc\\"]) 'ab' >>> longest_common_prefix([\\"reflower\\", \\"flow\\", \\"flight\\"]) ''","solution":"def longest_common_prefix(strs): Finds the longest common prefix string amongst an array of strings. If no common prefix exists, returns an empty string. if not strs: return \\"\\" min_length = min(len(s) for s in strs) if min_length == 0: return \\"\\" low, high = 0, min_length while low < high: mid = (low + high) // 2 if all(s.startswith(strs[0][:mid+1]) for s in strs): low = mid + 1 else: high = mid return strs[0][:low] # Example Usage: # strs = [\\"flower\\", \\"flow\\", \\"flight\\", \\"flame\\"] # print(longest_common_prefix(strs)) # Output: \\"fl\\""},{"question":"def range_sum_even_or_odd(n: int, sequence: List[int], q: int, queries: List[Tuple[int, int]]) -> List[str]: Given a sequence of positive integers and a series of range queries, calculate the sum of the integers within each specified range and determine if the sum is an even or odd number. >>> range_sum_even_or_odd(5, [1, 2, 3, 4, 5], 3, [(1, 3), (2, 4), (1, 5)]) [\\"Even\\", \\"Odd\\", \\"Odd\\"] results = [] prefix_sum = [0] * (n + 1) for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + sequence[i - 1] for (l, r) in queries: sum_range = prefix_sum[r] - prefix_sum[l - 1] if sum_range % 2 == 0: results.append(\\"Even\\") else: results.append(\\"Odd\\") return results","solution":"def range_sum_even_or_odd(n, sequence, q, queries): results = [] prefix_sum = [0] * (n + 1) # Compute prefix sums for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + sequence[i - 1] # Process each query for (l, r) in queries: sum_range = prefix_sum[r] - prefix_sum[l - 1] if sum_range % 2 == 0: results.append(\\"Even\\") else: results.append(\\"Odd\\") return results"},{"question":"def longest_zero_sum_subarray(arr): Returns the length of the longest contiguous subarray with a sum of zero. >>> longest_zero_sum_subarray([1, 2, -3, 3, 4]) == 3 >>> longest_zero_sum_subarray([1, 2, 3, -6, 1, 2]) == 4 >>> longest_zero_sum_subarray([1, 2, 3]) == 0 >>> longest_zero_sum_subarray([1, -1, 1, -1]) == 4 >>> longest_zero_sum_subarray([4, 2, -3, 1, 6]) == 3 >>> longest_zero_sum_subarray([1, 2, -2, 4, -4]) == 4 >>> longest_zero_sum_subarray([-1, -1, -1, 2, 2, -1]) == 6 >>> longest_zero_sum_subarray([1]) == 0 >>> longest_zero_sum_subarray([0, 0, 0, 0]) == 4 >>> longest_zero_sum_subarray([-1, 1, -1, 1]) == 4 >>> longest_zero_sum_subarray([100000, -100000]) == 2 >>> longest_zero_sum_subarray([-100000, 100000]) == 2 def process_test_cases(test_cases): Processes multiple test cases and returns the result for each in a list. Each test case consists of an array for which the length of the longest zero sum subarray is to be found. >>> process_test_cases([[1, 2, -3, 3, 4], [1, 2, 3, -6, 1, 2], [1, -1, 1, -1], [1, 2, 3]]) == [3, 4, 4, 0] >>> process_test_cases([[1, -1, 1], [-1, -1, -1, 2, 2, -1], [4, 2, -3, 1, 6]]) == [2, 6, 3] >>> process_test_cases([[], [0], [-1, 1], [1, -1, 1, -1]]) == [0, 1, 2, 4]","solution":"def longest_zero_sum_subarray(arr): Returns the length of the longest contiguous subarray with a sum of zero. max_len = 0 sum_index_map = {} curr_sum = 0 for i in range(len(arr)): curr_sum += arr[i] if curr_sum == 0: max_len = i + 1 if curr_sum in sum_index_map: max_len = max(max_len, i - sum_index_map[curr_sum]) else: sum_index_map[curr_sum] = i return max_len def process_test_cases(test_cases): Processes multiple test cases and returns the result for each in a list. Each test case consists of an array for which the length of the longest zero sum subarray is to be found. results = [] for arr in test_cases: results.append(longest_zero_sum_subarray(arr)) return results"},{"question":"from typing import List def find_exactly_half_prime(t: int, primes: List[int]) -> List[str]: Alice defines an exactly half prime as a number that is prime and exactly half of another prime number. Given a list of prime numbers, find if there is an exactly half prime such that when doubled is also a prime. >>> find_exactly_half_prime(3, [7, 11, 13]) ['NO', 'NO', 'NO'] >>> find_exactly_half_prime(2, [3, 5]) ['NO', 'NO'] # Implementation is required here def prime_as_half_of_another_prime(test_cases: List[str]) -> List[str]: Parses the input test cases and returns the results for each case. >>> prime_as_half_of_another_prime([\\"3\\", \\"7\\", \\"11\\", \\"13\\"]) ['NO', 'NO', 'NO'] # Parse the input and call find_exactly_half_prime","solution":"from sympy import isprime def find_exactly_half_prime(t, primes): results = [] for p in primes: q = p // 2 if p % 2 == 0 and isprime(q): results.append(f\\"YES {q}\\") else: results.append(\\"NO\\") return results def prime_as_half_of_another_prime(test_cases): t = int(test_cases[0]) primes = [int(x) for x in test_cases[1:]] return find_exactly_half_prime(t, primes)"},{"question":"def count_peaks(elevations: list) -> int: Returns the number of peaks in the list 'elevations'. A peak is an element which is strictly greater than its immediate neighbors. >>> count_peaks([5, 10, 5, 6, 15, 4, 2, 20, 10]) 3 >>> count_peaks([1, 3, 1, 3, 1]) 2 >>> count_peaks([]) 0","solution":"def count_peaks(elevations): Returns the number of peaks in the list 'elevations'. A peak is an element which is strictly greater than its immediate neighbors. if len(elevations) < 3: return 0 peaks = 0 for i in range(1, len(elevations) - 1): if elevations[i] > elevations[i - 1] and elevations[i] > elevations[i + 1]: peaks += 1 return peaks"},{"question":"def sort_string(s: str) -> str: Sorts the string such that all alphabets come before all the numbers, maintaining their original order of appearance. >>> sort_string(\\"a1b2c3\\") == \\"abc123\\" >>> sort_string(\\"123abc\\") == \\"abc123\\" >>> sort_string(\\"abc123\\") == \\"abc123\\" def process_test_cases(T: int, strings: List[str]) -> List[str]: Processes multiple test cases. >>> process_test_cases(3, [\\"a1b2c3\\", \\"123abc\\", \\"abc123\\"]) == [\\"abc123\\", \\"abc123\\", \\"abc123\\"] >>> process_test_cases(2, [\\"a1b1c2\\", \\"ab3cd2ef1gh\\"]) == [\\"abc112\\", \\"abcdefgh321\\"] >>> process_test_cases(1, [\\"1a2b3c\\"]) == [\\"abc123\\"] >>> process_test_cases(1, [\\"\\"]) == [\\"\\"]","solution":"def sort_string(s): Sorts the string such that all alphabets come before all the numbers, maintaining their original order of appearance. alphabets = ''.join([c for c in s if c.isalpha()]) numbers = ''.join([c for c in s if c.isdigit()]) return alphabets + numbers def process_test_cases(T, strings): Processes multiple test cases. results = [sort_string(s) for s in strings] return results"},{"question":"def final_positions(n: int, w: int, h: int, boxes: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int, int]]: Determine the final position of each box after all movements have been processed. Arguments: n -- the number of boxes w -- the width of the storage area h -- the height of the storage area boxes -- a list of tuples, each containing box id, initial x-coordinate, initial y-coordinate, and speed Returns: A list of tuples, each containing the id, final x-coordinate, and final y-coordinate of each box. Example: >>> final_positions(5, 10, 8, [(1, 5, 3, 1), (2, 4, 1, 2), (3, 6, 6, 3), (4, 3, 4, 4), (5, 2, 2, 1)]) [(1, 5, 8), (2, 4, 4), (3, 10, 6), (4, 1, 4), (5, 2, 8)]","solution":"def final_positions(n, w, h, boxes): positions = [] for box in boxes: box_id, x, y, speed = box if speed == 1: # north y = min(h, y + 4) elif speed == 2: # south y = max(0, y - 4) elif speed == 3: # east x = min(w, x + 4) elif speed == 4: # west x = max(0, x - 4) positions.append((box_id, x, y)) return positions"},{"question":"def is_marathon_route_possible(n: int, m: int, k: int, roads: List[Tuple[int, int, int]]) -> str: Determine whether it's possible to design the marathon route starting and ending at the same landmark and ensuring the total distance is exactly k kilometers without traversing the same road more than once. >>> is_marathon_route_possible(4, 4, 6, [(1, 2, 3), (2, 3, 2), (3, 4, 1), (4, 1, 3)]) 'YES' >>> is_marathon_route_possible(3, 2, 5, [(1, 2, 3), (2, 3, 4)]) 'NO'","solution":"def is_marathon_route_possible(n, m, k, roads): from collections import defaultdict import sys graph = defaultdict(list) total_road_length = 0 for u, v, d in roads: graph[u].append((v, d)) graph[v].append((u, d)) total_road_length += d if k % 2 != 0 or total_road_length < k: # Simple checks return \\"NO\\" visited = set() def dfs(node, current_length): if current_length == k: return True if current_length > k: return False visited.add(node) for neighbor, distance in graph[node]: if neighbor not in visited or (neighbor in visited and current_length + distance == k): if dfs(neighbor, current_length + distance): return True visited.remove(node) return False for start_node in range(1, n + 1): if dfs(start_node, 0): return \\"YES\\" return \\"NO\\""},{"question":"def min_trucks_required(n: int, w: int, weights: List[int]) -> int: Determines the minimum number of trucks required to deliver all parcels. Args: n (int): Number of parcels. w (int): Weight capacity of each truck. weights (list of int): List of parcel weights. Returns: int: Minimum number of trucks required. >>> min_trucks_required(5, 10, [7, 2, 3, 9, 4]) 3 >>> min_trucks_required(8, 15, [10, 8, 5, 7, 6, 12, 4, 3]) 4","solution":"def min_trucks_required(n, w, weights): Determines the minimum number of trucks required to deliver all parcels. Args: n (int): Number of parcels. w (int): Weight capacity of each truck. weights (list): List of parcel weights. Returns: int: Minimum number of trucks required. weights.sort(reverse=True) # sort weights in descending order trucks = 0 while weights: current_weight = 0 i = 0 while i < len(weights): if current_weight + weights[i] <= w: current_weight += weights.pop(i) else: i += 1 trucks += 1 return trucks"},{"question":"def shortest_travel_times(n: int, m: int, subway_lines: List[Tuple[int, int, int]], q: int, queries: List[Tuple[int, int]]) -> List[int]: Given the subway network details and a number of commuter inquiries, provides the shortest travel time for each query. If it is not possible to travel between two stations, return -1 for that query. >>> n = 4 >>> m = 4 >>> subway_lines = [ >>> (1, 2, 5), >>> (2, 3, 10), >>> (3, 4, 3), >>> (1, 4, 20) >>> ] >>> q = 3 >>> queries = [ >>> (1, 3), >>> (1, 4), >>> (2, 4) >>> ] >>> shortest_travel_times(n, m, subway_lines, q, queries) [15, 18, 13]","solution":"def floyd_warshall(n, edges): # Initialize the distance matrix inf = float('inf') dist = [[inf] * n for _ in range(n)] # Distance to itself is 0 for i in range(n): dist[i][i] = 0 # Initialize distances based on direct edges for u, v, t in edges: dist[u-1][v-1] = t dist[v-1][u-1] = t # Compute shortest paths between all pairs for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def shortest_travel_times(n, m, subway_lines, q, queries): dist = floyd_warshall(n, subway_lines) result = [] for a, b in queries: shortest_distance = dist[a-1][b-1] result.append(shortest_distance if shortest_distance != float('inf') else -1) return result"},{"question":"def longestToysSequence(toys: List[int]) -> int: Returns the length of the longest strictly increasing sub-sequence. >>> longestToysSequence([10, 9, 2, 5, 3, 7, 101, 18]) == 4 >>> longestToysSequence([0, 1, 0, 3, 2, 3]) == 4","solution":"def longestToysSequence(toys): Returns the length of the longest strictly increasing sub-sequence. if not toys: return 0 # DP array to store the length of the longest increasing subsequence ending at each index dp = [1] * len(toys) for i in range(1, len(toys)): for j in range(i): if toys[i] > toys[j]: dp[i] = max(dp[i], dp[j] + 1) # The length of the longest increasing subsequence is the max value in dp array return max(dp)"},{"question":"def longest_palindrome_substring(s: str) -> str: Returns the longest palindromic substring in the given string s. def process_input(input_lines: List[str]) -> List[str]: Process the input lines and returns a list with the longest palindromic substring for each input string except 'END'. >>> process_input([\\"babad\\", \\"cbbd\\", \\"a\\", \\"ac\\", \\"abccba\\", \\"END\\"]) [\\"bab\\", \\"bb\\", \\"a\\", \\"a\\", \\"abccba\\"]","solution":"def longest_palindrome_substring(s): Returns the longest palindromic substring in the given string s. def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes substring1 = expand_around_center(i, i) # Even length palindromes substring2 = expand_around_center(i, i + 1) # Update the longest palindrome found if len(substring1) > len(longest): longest = substring1 if len(substring2) > len(longest): longest = substring2 return longest def process_input(input_lines): results = [] for line in input_lines: if line == \\"END\\": break results.append(longest_palindrome_substring(line)) return results"},{"question":"def forest_operations(n: int, q: int, heights: List[int], operations: List[List[int]]) -> List[int]: Perform operations on a set of trees in a magical forest, including increasing the height of a specific tree and finding the tallest tree in a given range. Args: n (int): Number of trees. q (int): Number of operations. heights (List[int]): Initial heights of the trees. operations (List[List[int]]): List of operations to be performed on the trees. Returns: List[int]: Results of the queries for the maximum height in specified segments. >>> forest_operations(6, 5, [3, 2, 5, 1, 4, 6], [[2, 2, 5], [1, 3, 2], [2, 1, 6], [1, 5, 4], [2, 2, 4]]) [5, 7, 7] >>> forest_operations(1, 3, [10], [[2, 1, 1], [1, 1, 5], [2, 1, 1]]) [10, 15]","solution":"class SegmentTree: def __init__(self, data, default=0, func=max): initialize the segment tree with data from math import ceil, log2 self._default = default self._func = func self._len = len(data) self._size = 2 ** ceil(log2(self._len)) self._tree = [default] * (2 * self._size) # fill the leaves of the tree self._tree[self._size:self._size + self._len] = data[:] # fill the internal nodes of the tree for i in reversed(range(1, self._size)): self._tree[i] = self._func(self._tree[2 * i], self._tree[2 * i + 1]) def update(self, idx, value): update a leaf node and its predecessors idx += self._size self._tree[idx] += value # assuming the update increases the value while idx > 1: idx //= 2 self._tree[idx] = self._func(self._tree[2 * idx], self._tree[2 * idx + 1]) def query(self, left, right): query the range from left to right (inclusive) result = self._default left += self._size right += self._size + 1 while left < right: if left % 2: result = self._func(result, self._tree[left]) left += 1 if right % 2: right -= 1 result = self._func(result, self._tree[right]) left //= 2 right //= 2 return result def forest_operations(n, q, heights, operations): seg_tree = SegmentTree(heights) results = [] for op in operations: if op[0] == 1: seg_tree.update(op[1] - 1, op[2]) elif op[0] == 2: result = seg_tree.query(op[1] - 1, op[2] - 1) results.append(result) return results"},{"question":"def min_messages_to_inform_all(n: int, k: int, connections: List[Tuple[int, int]]) -> int: Given the number of employees (n) and the list of direct project connections, determine the minimum number of messages needed to inform every employee about the new policy. >>> min_messages_to_inform_all(5, 4, [(1, 2), (2, 3), (4, 5), (2, 4)]) 1 >>> min_messages_to_inform_all(6, 4, [(1, 2), (2, 3), (3, 4), (5, 6)]) 2 from typing import List, Tuple def test_min_messages_single_connected_group(): n = 5 k = 4 connections = [(1, 2), (2, 3), (4, 5), (2, 4)] assert min_messages_to_inform_all(n, k, connections) == 1 def test_min_messages_two_separate_groups(): n = 6 k = 4 connections = [(1, 2), (2, 3), (3, 4), (5, 6)] assert min_messages_to_inform_all(n, k, connections) == 2 def test_min_messages_all_individuals(): n = 4 k = 0 connections = [] assert min_messages_to_inform_all(n, k, connections) == 4 def test_min_messages_complete_graph(): n = 4 k = 6 connections = [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)] assert min_messages_to_inform_all(n, k, connections) == 1 def test_min_messages_small_disconnected_graph(): n = 3 k = 1 connections = [(1, 2)] assert min_messages_to_inform_all(n, k, connections) == 2 def test_min_messages_single_employee(): n = 1 k = 0 connections = [] assert min_messages_to_inform_all(n, k, connections) == 1","solution":"def min_messages_to_inform_all(n, k, connections): from collections import defaultdict, deque # Build the adjacency list for the graph adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) visited = [False] * (n + 1) def bfs(start): queue = deque([start]) visited[start] = True while queue: node = queue.popleft() for neighbor in adj_list[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) # Count the number of connected components components = 0 for i in range(1, n + 1): if not visited[i]: bfs(i) components += 1 return components"},{"question":"def max_total_beauty(T, test_cases): Calculate the maximum total beauty of ornaments to be hanged on the tree, obeying the constraint regarding the absolute difference between ornaments' beauty value. >>> max_total_beauty(2, [((3, 2), [1, 3, 5]), ((4, 1), [4, 1, 7, 3])]) == [9, 7] >>> max_total_beauty(1, [((4, 3), [1, 3, 5, 7])]) == [16] >>> max_total_beauty(1, [((5, 0), [1, 1, 1, 1, 1])]) == [5] >>> max_total_beauty(1, [((0, 1), [])]) == [0] >>> max_total_beauty(1, [((5, 10), [9, 9, 8, 8, 7])]) == [41] >>> max_total_beauty(1, [((3, 100), [1000000000, 999999999, 1000000000])]) == [2999999999]","solution":"def max_total_beauty(T, test_cases): results = [] for i in range(T): N, K = test_cases[i][0] beauties = test_cases[i][1] if N == 0: results.append(0) continue dp = [0] * N dp[0] = beauties[0] for j in range(1, N): dp[j] = beauties[j] for l in range(j): if abs(beauties[j] - beauties[l]) <= K: dp[j] = max(dp[j], dp[l] + beauties[j]) results.append(max(dp)) return results"},{"question":"def min_merge_cost(t: int, test_cases: List[Tuple[int, int]]) -> List[int]: Calculate the minimum total cost to merge all stacks into one. Each test case is a tuple (N, K) where N is the number of stacks and K is the number of coins in each stack. Returns a list of integers representing the minimum cost for each test case. >>> min_merge_cost(3, [(3, 1), (4, 2), (5, 3)]) [3, 12, 30] >>> min_merge_cost(1, [(1, 1)]) [0] pass","solution":"def min_merge_cost(t, test_cases): results = [] for case in test_cases: n, k = case result = k * (n - 1) * ((n - 1) + 1) // 2 results.append(result) return results"},{"question":"def max_sum_of_k_consecutive_elements(n: int, k: int, arr: List[int]) -> int: Given an array of n integers, find the maximum sum of k consecutive elements in the array. >>> max_sum_of_k_consecutive_elements(8, 3, [1, 2, 3, -2, 5, -1, 2, 1]) 6 >>> max_sum_of_k_consecutive_elements(5, 2, [1, -2, 3, 4, -5]) 7 pass def test_max_sum_of_k_consecutive_elements(): assert max_sum_of_k_consecutive_elements(8, 3, [1, 2, 3, -2, 5, -1, 2, 1]) == 6 assert max_sum_of_k_consecutive_elements(5, 2, [1, -2, 3, 4, -5]) == 7 assert max_sum_of_k_consecutive_elements(5, 1, [3, 2, 1, -1, -2]) == 3 assert max_sum_of_k_consecutive_elements(5, 5, [1, 2, 3, 4, 5]) == 15 assert max_sum_of_k_consecutive_elements(7, 3, [5, 4, -1, -2, -3, 2, 1]) == 8 def test_with_negative_elements(): assert max_sum_of_k_consecutive_elements(6, 2, [-1, -2, -3, -4, -5, -6]) == -3 assert max_sum_of_k_consecutive_elements(4, 4, [-3, -2, -1, -2]) == -8 def test_single_element_subarray(): assert max_sum_of_k_consecutive_elements(5, 1, [1, 2, 3, 4, 5]) == 5 def test_large_input(): n = 100000 k = 1 arr = [1] * n assert max_sum_of_k_consecutive_elements(n, k, arr) == 1","solution":"def max_sum_of_k_consecutive_elements(n, k, arr): Returns the maximum sum of k consecutive elements in the given array. # Create the sum of the first window window_sum = sum(arr[:k]) max_sum = window_sum # Slide over the array and update the sums for i in range(n - k): window_sum = window_sum - arr[i] + arr[i + k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def max_sum_of_most_valuable_stamps(n: int, k: int, values: List[int]) -> int: Calculate the maximum possible sum of the values of the most valuable stamps in each of the k groups. :param n: An integer representing the number of stamps. :param k: An integer representing the number of groups. :param values: A list of integers representing the values of the stamps. :return: The maximum possible sum of the values of the most valuable stamps in each group. If it is impossible to form k groups such that each group has at least 2 stamps, return -1. Example: >>> max_sum_of_most_valuable_stamps(7, 3, [4, 1, 7, 3, 2, 6, 5]) 18 >>> max_sum_of_most_valuable_stamps(4, 2, [1, 2, 3, 4]) 7 >>> max_sum_of_most_valuable_stamps(5, 3, [1, 3, 5, 7, 9]) -1 pass","solution":"def max_sum_of_most_valuable_stamps(n, k, values): This function calculates the maximum possible sum of the values of the most valuable stamps in each of the k groups. if n < 2 * k: return -1 values.sort(reverse=True) most_valuable = sum(values[:k]) return most_valuable"},{"question":"from typing import List def min_operations_to_equalize(arr: List[int]) -> int: Returns the minimum number of operations needed to make all elements in the array the same. >>> min_operations_to_equalize([1, 2, 2, 1]) 3 >>> min_operations_to_equalize([3, 3, 3]) 0 >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 4 pass def test_min_operations_to_equalize_case1(): assert min_operations_to_equalize([1, 2, 2, 1]) == 3 def test_min_operations_to_equalize_case2(): assert min_operations_to_equalize([3, 3, 3]) == 0 def test_min_operations_to_equalize_case3(): assert min_operations_to_equalize([1, 2, 3, 4, 5]) == 4 def test_min_operations_to_equalize_single_element(): assert min_operations_to_equalize([1]) == 0 def test_min_operations_to_equalize_two_elements(): assert min_operations_to_equalize([7, 8]) == 1","solution":"def min_operations_to_equalize(arr): Returns the minimum number of operations needed to make all elements in the array the same. # Check for special case where all elements are already the same if all(x == arr[0] for x in arr): return 0 # We're aiming to reduce the array to a single element through n-1 sum operations return len(arr) - 1"},{"question":"from typing import List def count_inversions(scores: List[int]) -> int: Returns the number of inversions in the scores array. >>> count_inversions([2, 4, 1, 3, 5]) 3 >>> count_inversions([6, 5, 4, 3, 2, 1]) 15 >>> count_inversions([1, 2, 3, 4, 5]) 0 >>> count_inversions([1, 3, 2, 4, 5]) 1 pass def test_count_inversions(): assert count_inversions([2, 4, 1, 3, 5]) == 3 assert count_inversions([6, 5, 4, 3, 2, 1]) == 15 assert count_inversions([1, 2, 3, 4, 5]) == 0 assert count_inversions([1, 3, 2, 4, 5]) == 1 assert count_inversions([5, 3, 2, 4, 1]) == 8 assert count_inversions([1]) == 0 assert count_inversions([]) == 0 assert count_inversions([3, 1, 2, 3, 1]) == 5 assert count_inversions([9, 6, 7, 3, 2, 1]) == 14 assert count_inversions([10, 20, 30, 20, 10]) == 4","solution":"def count_inversions(scores): Returns the number of inversions in the scores array. if len(scores) == 0: return 0 def merge_count_split_inv(arr, temp_arr, left, right): mid = (left + right)//2 inv_count = 0 if left < right: inv_count += merge_count_split_inv(arr, temp_arr, left, mid) inv_count += merge_count_split_inv(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index for to be sorted subarray inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count temp_arr = [0]*len(scores) return merge_count_split_inv(scores, temp_arr, 0, len(scores) - 1)"},{"question":"def get_unique_times(finishing_times): Returns the list of unique finishing times in ascending order and the count of those times. Args: finishing_times (list of float): List of finishing times. Returns: int: The count of unique finishing times. List of float: The sorted list of unique finishing times. Example: >>> get_unique_times([10.52, 12.43, 11.11, 12.43, 9.99, 10.52, 9.58, 11.11, 8.75, 12.50]) (7, [8.75, 9.58, 9.99, 10.52, 11.11, 12.43, 12.50]) >>> get_unique_times([5.55, 5.55, 5.55, 5.55]) (1, [5.55]) from solution import get_unique_times def test_get_unique_times_case_1(): times = [10.52, 12.43, 11.11, 12.43, 9.99, 10.52, 9.58, 11.11, 8.75, 12.50] distinct_count, unique_times = get_unique_times(times) assert distinct_count == 7 assert unique_times == [8.75, 9.58, 9.99, 10.52, 11.11, 12.43, 12.50] def test_get_unique_times_all_distinct(): times = [1.0, 2.0, 3.0, 4.0, 5.0] distinct_count, unique_times = get_unique_times(times) assert distinct_count == 5 assert unique_times == [1.0, 2.0, 3.0, 4.0, 5.0] def test_get_unique_times_all_same(): times = [5.55, 5.55, 5.55, 5.55] distinct_count, unique_times = get_unique_times(times) assert distinct_count == 1 assert unique_times == [5.55] def test_get_unique_times_mixed(): times = [3.33, 2.22, 1.11, 3.33, 2.22, 1.11] distinct_count, unique_times = get_unique_times(times) assert distinct_count == 3 assert unique_times == [1.11, 2.22, 3.33] def test_get_unique_times_empty(): times = [] distinct_count, unique_times = get_unique_times(times) assert distinct_count == 0 assert unique_times == []","solution":"def get_unique_times(finishing_times): Returns the list of unique finishing times in ascending order and the count of those times. Args: finishing_times (list of float): List of finishing times. Returns: int: The count of unique finishing times. List of float: The sorted list of unique finishing times. unique_times = sorted(set(finishing_times)) return len(unique_times), unique_times"},{"question":"from collections import defaultdict from typing import List, Tuple class InventorySystem: def __init__(self): self.total_inventory = defaultdict(int) self.warehouse_inventory = defaultdict(lambda: defaultdict(int)) def add_inventory(self, product_id: int, warehouse_id: int, quantity: int) -> None: Add a certain quantity of a product to a specific warehouse. pass def query_inventory(self, product_id: int) -> int: Return the total quantity of a product across all warehouses. pass def process_inventory(n: int, initial_data: List[Tuple[int, int, int]], q: int, queries: List[str]) -> List[int]: Process the initial inventory data and handle queries for inventory system. Args: n (int): Number of initial inventory inputs. initial_data (List[Tuple[int, int, int]]): List of tuples containing initial inventory data. q (int): Number of queries. queries (List[str]): List of query strings. Returns: List[int]: List of results for 'QUERY' operations. Example: >>> n = 5 >>> q = 3 >>> initial_data = [(1, 1, 10), (2, 1, 15), (1, 2, 5), (1, 3, 8), (3, 1, 7)] >>> queries = [\\"QUERY 1\\", \\"ADD 1 1 5\\", \\"QUERY 1\\"] >>> process_inventory(n, initial_data, q, queries) [23, 28] pass def test_inventory_system(): n = 5 q = 3 initial_data = [ (1, 1, 10), (2, 1, 15), (1, 2, 5), (1, 3, 8), (3, 1, 7) ] queries = [ \\"QUERY 1\\", \\"ADD 1 1 5\\", \\"QUERY 1\\" ] expected_output = [23, 28] assert process_inventory(n, initial_data, q, queries) == expected_output def test_empty_initial_data(): n = 0 q = 2 initial_data = [] queries = [ \\"QUERY 1\\", \\"ADD 1 1 5\\", \\"QUERY 1\\" ] expected_output = [0, 5] assert process_inventory(n, initial_data, q, queries) == expected_output def test_add_inventory_mixed_queries(): n = 3 q = 4 initial_data = [ (1, 1, 10), (2, 1, 20), (1, 2, 5) ] queries = [ \\"QUERY 1\\", \\"ADD 1 3 10\\", \\"QUERY 1\\", \\"QUERY 2\\" ] expected_output = [15, 25, 20] assert process_inventory(n, initial_data, q, queries) == expected_output","solution":"from collections import defaultdict class InventorySystem: def __init__(self): self.total_inventory = defaultdict(int) self.warehouse_inventory = defaultdict(lambda: defaultdict(int)) def add_inventory(self, product_id, warehouse_id, quantity): self.warehouse_inventory[warehouse_id][product_id] += quantity self.total_inventory[product_id] += quantity def query_inventory(self, product_id): return self.total_inventory[product_id] def process_inventory(n, initial_data, q, queries): system = InventorySystem() # Process initial inventory data for product_id, warehouse_id, quantity in initial_data: system.add_inventory(product_id, warehouse_id, quantity) results = [] # Process queries for query in queries: parts = query.split() if parts[0] == \\"ADD\\": product_id, warehouse_id, quantity = map(int, parts[1:]) system.add_inventory(product_id, warehouse_id, quantity) elif parts[0] == \\"QUERY\\": product_id = int(parts[1]) results.append(system.query_inventory(product_id)) return results"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], k: int) -> int: Determines if there are two distinct integers in the array that sum up to k. >>> has_pair_with_sum([10, 15, 3, 7], 17) 1 >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) 0 >>> has_pair_with_sum([-1, 2, -3, 4, 5], 1) 1 >>> has_pair_with_sum([], 10) 0 >>> has_pair_with_sum([3], 6) 0 >>> has_pair_with_sum([1000000000, -1000000000], 0) 1 >>> has_pair_with_sum([3], 3) 0 >>> has_pair_with_sum([1, 1, 2, 3, 4, 2], 5) 1 >>> has_pair_with_sum([1, 2, 2, 2, 2], 10) 0 >>> has_pair_with_sum(list(range(1, 100001)), 199999) 1 >>> has_pair_with_sum(list(range(1, 100001)), 200001) 0","solution":"def has_pair_with_sum(arr, k): Determines if there are two distinct integers in the array that sum up to k. Args: arr (List[int]): An array of integers. k (int): The target sum. Returns: int: 1 if there exists a pair that sums up to k, otherwise 0. seen = set() for num in arr: if k - num in seen: return 1 seen.add(num) return 0"},{"question":"def max_production_capacities(n, m, capacities, queries): Function to return the maximum production capacities within each specified range for the given queries. Parameters: n (int): Number of production slots. m (int): Number of queries. capacities (list of int): Production capacities for each slot. queries (list of tuple): Each tuple contains (li, ri) range for the queries. Returns: list of int: Maximum production capacity within each specified range for the given queries. pass # Unit Tests def test_max_production_case_1(): n = 5 m = 3 capacities = [8, 7, 3, 9, 5] queries = [(1, 3), (2, 4), (1, 5)] expected = [8, 9, 9] assert max_production_capacities(n, m, capacities, queries) == expected def test_max_production_case_2(): n = 6 m = 2 capacities = [10, 15, 20, 25, 30, 35] queries = [(1, 6), (3, 5)] expected = [35, 30] assert max_production_capacities(n, m, capacities, queries) == expected def test_max_production_case_3(): n = 7 m = 4 capacities = [5, 4, 6, 3, 7, 8, 2] queries = [(2, 4), (1, 7), (5, 7), (3, 6)] expected = [6, 8, 8, 8] assert max_production_capacities(n, m, capacities, queries) == expected def test_max_production_case_min_values(): n = 1 m = 1 capacities = [1] queries = [(1, 1)] expected = [1] assert max_production_capacities(n, m, capacities, queries) == expected def test_max_production_case_single_range(): n = 4 m = 1 capacities = [1, 2, 3, 4] queries = [(1, 4)] expected = [4] assert max_production_capacities(n, m, capacities, queries) == expected","solution":"def max_production_capacities(n, m, capacities, queries): Function to return the maximum production capacities within each specified range for the given queries. Parameters: n (int): Number of production slots. m (int): Number of queries. capacities (list of int): Production capacities for each slot. queries (list of tuple): Each tuple contains (li, ri) range for the queries. Returns: list of int: Maximum production capacity within each specified range for the given queries. results = [] for query in queries: l, r = query # adjust indices to be zero-based for Python lists max_capacity = max(capacities[l-1:r]) results.append(max_capacity) return results"},{"question":"def max_sum_subgrid(N: int, grid: List[List[int]]) -> int: Returns the maximum sum of values within any subgrid of the grid. >>> max_sum_subgrid(3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) == 45 >>> max_sum_subgrid(4, [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ]) == 136 from typing import List # Test cases def test_case_1(): assert max_sum_subgrid(3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]) == 45 def test_case_2(): assert max_sum_subgrid(4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) == 136 def test_case_3(): assert max_sum_subgrid(2, [ [1, 2], [3, 4] ]) == 10 def test_case_4(): assert max_sum_subgrid(1, [ [10000] ]) == 10000 def test_case_5(): N = 3 grid = [ [1, -1, 1], [-1, 3, -1], [1, -1, 1] ] assert max_sum_subgrid(N, grid) == 3 def test_case_6(): N = 5 grid = [ [1, 2, 3, 4, 5], [6, 7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20], [21, 22, 23, 24, 25] ] assert max_sum_subgrid(N, grid) == 325","solution":"def max_sum_subgrid(N, grid): Returns the maximum sum of values within any subgrid of the grid. # Precompute sums for all subgrids sums = [[0] * (N + 1) for _ in range(N + 1)] for i in range(1, N + 1): for j in range(1, N + 1): sums[i][j] = grid[i-1][j-1] + sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] max_sum = float(\\"-inf\\") # Consider all possible subgrids for i1 in range(1, N + 1): for j1 in range(1, N + 1): for i2 in range(i1, N + 1): for j2 in range(j1, N + 1): current_sum = sums[i2][j2] - sums[i1-1][j2] - sums[i2][j1-1] + sums[i1-1][j1-1] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def search_insert_position(nums: List[int], target: int) -> int: Searches for the target in nums. If found, returns the index. Otherwise, returns the index where the target would be if inserted in order. >>> search_insert_position([1, 3, 5, 6], 5) == 2 >>> search_insert_position([1, 3, 5, 6], 2) == 1 >>> search_insert_position([1, 3, 5, 6], 7) == 4 >>> search_insert_position([1, 3, 5, 6], 0) == 0 def test_target_found(): assert search_insert_position([1, 3, 5, 6], 5) == 2 def test_target_insert_mid(): assert search_insert_position([1, 3, 5, 6], 2) == 1 def test_target_insert_end(): assert search_insert_position([1, 3, 5, 6], 7) == 4 def test_target_insert_start(): assert search_insert_position([1, 3, 5, 6], 0) == 0 def test_target_insert_between_elements(): assert search_insert_position([1, 2, 4, 5, 6], 3) == 2 def test_empty_array(): assert search_insert_position([], 3) == 0 def test_single_element_found(): assert search_insert_position([3], 3) == 0 def test_single_element_not_found(): assert search_insert_position([3], 2) == 0 assert search_insert_position([3], 4) == 1 def test_target_larger_than_all_elements(): assert search_insert_position([1, 2, 3], 4) == 3 def test_target_smaller_than_all_elements(): assert search_insert_position([2, 3, 4], 1) == 0","solution":"def search_insert_position(nums, target): Searches for the target in nums. If found, returns the index. Otherwise, returns the index where the target would be if inserted in order. Args: nums (List[int]): The sorted list of integers. target (int): The target value to search for. Returns: int: The index of the target if found, otherwise the index where it would be inserted. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return mid elif nums[mid] < target: left = mid + 1 else: right = mid - 1 return left"},{"question":"def number_of_illuminated_buildings(building_heights: List[int]) -> int: Returns the number of buildings that will be illuminated by the beam of light. Args: building_heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The number of buildings that will be illuminated. Examples: >>> number_of_illuminated_buildings([1, 2, 3, 4, 5]) 5 >>> number_of_illuminated_buildings([10, 20, 30]) 3 >>> number_of_illuminated_buildings([1, 5, 6, 7]) 4 >>> number_of_illuminated_buildings([2, 3, 4, 8, 9, 10]) 6 >>> number_of_illuminated_buildings([1000000000]) 1","solution":"def number_of_illuminated_buildings(building_heights): Returns the number of buildings that will be illuminated by the beam of light. Args: building_heights (list of int): A list of integers representing the heights of the buildings. Returns: int: The number of buildings that will be illuminated. return len(building_heights)"},{"question":"def has_zero_sum_subarray(arr: List[int]) -> str: Determine whether there exists a non-empty subarray whose sum is zero. :param arr: List of integers :return: \\"YES\\" if there exists a subarray with zero sum, otherwise \\"NO\\" >>> has_zero_sum_subarray([4, -1, 2, -2, 1]) \\"YES\\" >>> has_zero_sum_subarray([1, 2, 3]) \\"NO\\"","solution":"def has_zero_sum_subarray(arr): Determines whether there exists a non-empty subarray whose sum is zero. :param arr: List of integers :return: \\"YES\\" if there exists a subarray with zero sum, otherwise \\"NO\\" # Set to store the prefix sums prefix_sums = set() # Initialize current sum to 0 current_sum = 0 for num in arr: # Add the current element to the current_sum current_sum += num # Check if current_sum is zero or already exists in the prefix_sums if current_sum == 0 or current_sum in prefix_sums: return \\"YES\\" # Add the current_sum to the set prefix_sums.add(current_sum) return \\"NO\\""},{"question":"def has_pair_with_difference(arr, k): Given an array of unique integers sorted in ascending order and a value k, returns \\"Yes\\" if there exists a pair of elements in the array whose difference is k, otherwise returns \\"No\\". >>> has_pair_with_difference([1, 5, 7, 9, 12], 2) == \\"Yes\\" >>> has_pair_with_difference([1, 4, 6, 9], 3) == \\"Yes\\" >>> has_pair_with_difference([1, 3, 6], 10) == \\"No\\" >>> has_pair_with_difference([1, 2, 3, 4, 5], 0) == \\"No\\" >>> has_pair_with_difference([3, 6, 9, 12], 0) == \\"No\\" >>> has_pair_with_difference([10, 20, 30, 40, 50], 100) == \\"No\\" >>> has_pair_with_difference([1, 10], 9) == \\"Yes\\" >>> has_pair_with_difference(list(range(1001)), 999) == \\"Yes\\"","solution":"def has_pair_with_difference(arr, k): Given an array of unique integers sorted in ascending order and a value k, returns \\"Yes\\" if there exists a pair of elements in the array whose difference is k, otherwise returns \\"No\\". n = len(arr) for i in range(n): for j in range(i + 1, n): if arr[j] - arr[i] == k: return \\"Yes\\" return \\"No\\""},{"question":"def does_robot_return(moves: str) -> str: Determines if the robot returns to the starting point after executing the given sequence of moves. Parameters: moves (str): A string representing the sequence of moves. Returns: str: \\"YES\\" if the robot returns to the starting point, otherwise \\"NO\\". >>> does_robot_return(\\"UDLR\\") \\"YES\\" >>> does_robot_return(\\"UULDD\\") \\"NO\\"","solution":"def does_robot_return(moves): Determines if the robot returns to the starting point after executing the given sequence of moves. Parameters: moves (str): A string representing the sequence of moves. Returns: str: \\"YES\\" if the robot returns to the starting point, otherwise \\"NO\\". x, y = 0, 0 for move in moves: if move == 'L': x -= 1 elif move == 'R': x += 1 elif move == 'U': y += 1 elif move == 'D': y -= 1 return \\"YES\\" if x == 0 and y == 0 else \\"NO\\""},{"question":"def latest_cargo_dates(T, test_cases): Determine the latest arrival date for each unique cargo type. Args: T: int : Number of test cases test_cases: List[Tuple[int, List[Tuple[str, int]]]] : List of test cases Returns: List[List[Tuple[str, int]]] : Latest arrival dates for each cargo type in lexicographical order pass from latest_cargo_dates import latest_cargo_dates def test_latest_cargo_dates_single(): T = 1 test_cases = [(7, [ (\\"electronics\\", 20220110), (\\"furniture\\", 20220112), (\\"electronics\\", 20220215), (\\"clothing\\", 20220120), (\\"clothing\\", 20220125), (\\"furniture\\", 20220120), (\\"clothing\\", 20220115)])] result = latest_cargo_dates(T, test_cases) expected = [[('clothing', 20220125), ('electronics', 20220215), ('furniture', 20220120)]] assert result == expected def test_latest_cargo_dates_multiple(): T = 2 test_cases = [ (7, [ (\\"electronics\\", 20220110), (\\"furniture\\", 20220112), (\\"electronics\\", 20220215), (\\"clothing\\", 20220120), (\\"clothing\\", 20220125), (\\"furniture\\", 20220120), (\\"clothing\\", 20220115) ]), (3, [ (\\"toys\\", 20220101), (\\"toys\\", 20220228), (\\"appliances\\", 20211231) ])] result = latest_cargo_dates(T, test_cases) expected = [ [('clothing', 20220125), ('electronics', 20220215), ('furniture', 20220120)], [('appliances', 20211231), ('toys', 20220228)] ] assert result == expected def test_latest_cargo_dates_edge_cases(): T = 1 test_cases = [(4, [ (\\"furniture\\", 20210001), (\\"furniture\\", 20211231), (\\"furniture\\", 20230000), (\\"furniture\\", 20220101)])] result = latest_cargo_dates(T, test_cases) expected = [[('furniture', 20230000)]] assert result == expected def test_latest_cargo_dates_empty(): T = 1 test_cases = [(0, [])] result = latest_cargo_dates(T, test_cases) expected = [[]] assert result == expected","solution":"def latest_cargo_dates(T, test_cases): Given the number of test cases and a list of test cases where each test case is a list of tuples (cargo type, arrival date), determines the latest arrival date for each unique cargo type. results = [] for i in range(T): N = test_cases[i][0] containers = test_cases[i][1] cargo_dict = {} for cargo, date in containers: if cargo in cargo_dict: if cargo_dict[cargo] < date: cargo_dict[cargo] = date else: cargo_dict[cargo] = date sorted_cargo = sorted(cargo_dict.items()) results.append(sorted_cargo) return results"},{"question":"def shortest_distance_to_char(S: str, C: str) -> List[int]: Returns a list of integers representing the shortest distance from each character in the string to the character C. Parameters: S (str): A string consisting of lowercase alphabets. C (str): A character in the string S. Returns: List[int]: A list of shortest distances from each character to the character C. Example: >>> shortest_distance_to_char(\\"loveleetcode\\", \\"e\\") [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> shortest_distance_to_char(\\"abcdefg\\", \\"e\\") [4, 3, 2, 1, 0, 1, 2] >>> shortest_distance_to_char(\\"aaaaa\\", \\"a\\") [0, 0, 0, 0, 0] >>> shortest_distance_to_char(\\"helloh\\", \\"h\\") [0, 1, 2, 2, 1, 0] >>> shortest_distance_to_char(\\"a\\" * 100000, \\"a\\") [0] * 100000","solution":"def shortest_distance_to_char(S, C): Returns a list of integers representing the shortest distance from each character in the string to the character C. n = len(S) result = [float('inf')] * n # First pass: left to right prev = float('-inf') for i in range(n): if S[i] == C: prev = i result[i] = i - prev # Second pass: right to left prev = float('inf') for i in range(n-1, -1, -1): if S[i] == C: prev = i result[i] = min(result[i], prev - i) return result"},{"question":"def find_missing_positive(nums: List[int]) -> int: Determine the smallest positive integer that is missing from the list. The function has to work in linear time O(n) and constant space O(1). >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([1, 2, 0, 4]) 3 >>> find_missing_positive([7, 8, 9]) 1","solution":"def find_missing_positive(nums): n = len(nums) # Step 1: Move all non-positive (<= 0) numbers to the left side j = 0 for i in range(n): if nums[i] <= 0: nums[i], nums[j] = nums[j], nums[i] j += 1 # Step 2: Work only with the positive part nums = nums[j:] n = len(nums) # Step 3: Mark numbers as visited by making the value at the corresponding index negative for i in range(n): val = abs(nums[i]) if 1 <= val <= n and nums[val - 1] > 0: nums[val - 1] = -nums[val - 1] # Step 4: Find the first positive index, which is the missing number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"def find_highest_numeric_code(T: int, test_cases: List[Tuple[int, List[str]]]) -> List[Tuple[int, int]]: Determine the highest numeric code among decoded strings and its frequency. >>> find_highest_numeric_code(1, [(3, [\\"hello\\", \\"world\\", \\"salary\\"])]) [(652, 1)] >>> find_highest_numeric_code(2, [(3, [\\"hello\\", \\"world\\", \\"salary\\"]), (2, [\\"map\\", \\"book\\"])]) [(652, 1), (427, 1)] >>> find_highest_numeric_code(1, [(1, [\\"test\\"])]) [(448, 1)] >>> find_highest_numeric_code(1, [(4, [\\"abc\\", \\"bca\\", \\"cab\\", \\"bac\\"])]) [(294, 4)] >>> find_highest_numeric_code(1, [(3, [\\"a\\", \\"b\\", \\"c\\"])]) [(99, 1)] >>> find_highest_numeric_code(1, [(2, [\\"a\\" * 100, \\"z\\" * 100])]) [(12200, 1)]","solution":"def find_highest_numeric_code(T, test_cases): results = [] for case in test_cases: N, strings = case numeric_codes = [sum(ord(char) for char in string) for string in strings] highest_code = max(numeric_codes) count_highest_code = numeric_codes.count(highest_code) results.append((highest_code, count_highest_code)) return results"},{"question":"from typing import List, Tuple def most_frequent_integer(n: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Find the most frequently occurring integer in the subarray from index l to index r for each query. If there are multiple integers with the same maximum frequency, return the smallest integer among them. >>> most_frequent_integer(5, [1, 2, 2, 3, 1], [(1, 3), (2, 4), (1, 5)]) [2, 2, 1] >>> most_frequent_integer(7, [2, 1, 2, 3, 4, 2, 1], [(1, 3), (4, 5), (6, 7)]) [2, 3, 1] pass # Unit tests def test_query_results(): n = 5 array = [1, 2, 2, 3, 1] queries = [(1, 3), (2, 4), (1, 5)] assert most_frequent_integer(n, array, queries) == [2, 2, 1] def test_all_same_elements(): n = 5 array = [1, 1, 1, 1, 1] queries = [(1, 5), (2, 4), (1, 3)] assert most_frequent_integer(n, array, queries) == [1, 1, 1] def test_non_overlapping_queries(): n = 7 array = [2, 1, 2, 3, 4, 2, 1] queries = [(1, 3), (4, 5), (6, 7)] assert most_frequent_integer(n, array, queries) == [2, 3, 1] def test_single_element_query(): n = 5 array = [3, 1, 4, 1, 2] queries = [(1, 1), (3, 3), (5, 5)] assert most_frequent_integer(n, array, queries) == [3, 4, 2] def test_mixed_frequencies(): n = 6 array = [1, 2, 2, 3, 3, 3] queries = [(1, 4), (2, 6), (1, 6)] assert most_frequent_integer(n, array, queries) == [2, 3, 3] def test_minimum_element_with_maximum_frequency(): n = 8 array = [5, 3, 3, 1, 2, 2, 4, 4] queries = [(1, 8), (3, 8), (1, 4)] assert most_frequent_integer(n, array, queries) == [2, 2, 3]","solution":"def most_frequent_integer(n, array, queries): from collections import defaultdict results = [] for l, r in queries: freq_map = defaultdict(int) for i in range(l - 1, r): freq_map[array[i]] += 1 max_frequency = max(freq_map.values()) most_frequent_elements = [key for key, cnt in freq_map.items() if cnt == max_frequency] results.append(min(most_frequent_elements)) return results # Example usage n = 5 array = [1, 2, 2, 3, 1] queries = [(1, 3), (2, 4), (1, 5)] print(most_frequent_integer(n, array, queries)) # Output: [2, 2, 1]"},{"question":"from typing import List def min_steps_to_reach_destination(m: int, n: int, grid: List[List[str]]) -> int: Determine the minimum number of steps required to move from the top-left corner to the bottom-right corner of the grid. >>> min_steps_to_reach_destination(3, 3, [['.', '#', '#'], ['.', '.', '.'], ['#', '#', '.']]) 4 >>> min_steps_to_reach_destination(3, 4, [['.', '#', '.', '.'], ['.', '.', '#', '.'], ['#', '#', '#', '.']]) -1","solution":"from collections import deque def min_steps_to_reach_destination(m, n, grid): if grid[0][0] == '#' or grid[m-1][n-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, column, steps) visited = set([(0, 0)]) while queue: row, col, steps = queue.popleft() if row == m - 1 and col == n - 1: return steps for dr, dc in directions: nrow, ncol = row + dr, col + dc if 0 <= nrow < m and 0 <= ncol < n and grid[nrow][ncol] == '.' and (nrow, ncol) not in visited: visited.add((nrow, ncol)) queue.append((nrow, ncol, steps + 1)) return -1"},{"question":"def total_travel_distance(distances_str: str) -> int: Returns the total travel distance for a given list of distances. Args: distances_str (str): A string of space-separated integers where each integer represents the distance between consecutive destinations. Returns: int: The sum of all the distances. >>> total_travel_distance(\\"150 300 450 600\\") 1500 >>> total_travel_distance(\\"1000\\") 1000","solution":"def total_travel_distance(distances_str): Returns the total travel distance for a given list of distances. Args: distances_str (str): A string of space-separated integers where each integer represents the distance between consecutive destinations. Returns: int: The sum of all the distances. distances = map(int, distances_str.split()) return sum(distances)"},{"question":"def sum_of_absolute_differences(test_cases): For each test case, computes and returns the sum of absolute differences among all pairs in the array. pass def transform_input(input_list): Transforms the input into a suitable format for the function sum_of_absolute_differences. pass import pytest def test_sample_input(): input_data = [ \\"2\\", \\"3\\", \\"3 -1 9\\", \\"4\\", \\"1 3 7 8\\" ] test_cases = transform_input(input_data) results = sum_of_absolute_differences(test_cases) assert results == [20, 25] def test_single_element(): input_data = [ \\"1\\", \\"1\\", \\"5\\" ] test_cases = transform_input(input_data) results = sum_of_absolute_differences(test_cases) assert results == [0] def test_two_elements(): input_data = [ \\"1\\", \\"2\\", \\"1 3\\" ] test_cases = transform_input(input_data) results = sum_of_absolute_differences(test_cases) assert results == [2] def test_large_values(): input_data = [ \\"1\\", \\"3\\", \\"1000000000 -1000000000 0\\" ] test_cases = transform_input(input_data) results = sum_of_absolute_differences(test_cases) assert results == [4000000000] def test_negative_values(): input_data = [ \\"1\\", \\"3\\", \\"-1 -2 -3\\" ] test_cases = transform_input(input_data) results = sum_of_absolute_differences(test_cases) assert results == [4]","solution":"def sum_of_absolute_differences(test_cases): For each test case, computes and returns the sum of absolute differences among all pairs in the array. results = [] for case in test_cases: N, arr = case total = 0 # Sort the array to make the sum of absolute differences calculation easier. arr.sort() # Precompute prefix and suffix sums prefix_sum = [0] * (N + 1) suffix_sum = [0] * (N + 2) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] for i in range(N, 0, -1): suffix_sum[i] = suffix_sum[i + 1] + arr[i - 1] for i in range(1, N + 1): total += (arr[i - 1] * (2 * i - N - 1)) results.append(total) return results def transform_input(input_list): Transforms the input into a suitable format for the function sum_of_absolute_differences. T = int(input_list[0]) index = 1 test_cases = [] for _ in range(T): N = int(input_list[index]) arr = list(map(int, input_list[index + 1].split())) test_cases.append((N, arr)) index += 2 return test_cases"},{"question":"def can_transform(initial, target, queries): Determine if it is possible to transform subarrays of initial array into subarrays of target array. >>> can_transform( [1, -2, 3, 4, -5], [-1, 2, 3, -4, 5], [(1, 3, 2, 4), (2, 4, 1, 3), (1, 5, 1, 5), (3, 5, 3, 5)] ) '0011' >>> can_transform( [0, 0, 0], [0, 0, 0], [(1, 3, 1, 3), (1, 2, 1, 2), (2, 3, 1, 2)] ) '111' >>> can_transform( [1000, -1000, 1000], [1000, 1000, -1000], [(1, 2, 2, 3), (1, 3, 1, 3)] ) '11' >>> can_transform([0], [0], [(1, 1, 1, 1)]) '1' >>> can_transform( [-1, 1, -1], [1, -1, 1], [(1, 3, 1, 3), (1, 1, 1, 1)] ) '11'","solution":"def can_transform(initial, target, queries): n = len(initial) m = len(target) # Calculate absolute value prefix sums for the initial array initial_abs_prefix_sums = [0] * (n + 1) for i in range(1, n + 1): initial_abs_prefix_sums[i] = initial_abs_prefix_sums[i - 1] + abs(initial[i - 1]) # Calculate absolute value prefix sums for the target array target_abs_prefix_sums = [0] * (m + 1) for i in range(1, m + 1): target_abs_prefix_sums[i] = target_abs_prefix_sums[i - 1] + abs(target[i - 1]) results = [] for a, b, c, d in queries: sum_initial = initial_abs_prefix_sums[b] - initial_abs_prefix_sums[a - 1] sum_target = target_abs_prefix_sums[d] - target_abs_prefix_sums[c - 1] if sum_initial == sum_target: results.append('1') else: results.append('0') return ''.join(results)"},{"question":"def are_isomorphic(str1: str, str2: str) -> str: Determines if two given strings are isomorphic. Two strings str1 and str2 are isomorphic if the characters in str1 can be replaced to get str2. All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself. >>> are_isomorphic(\\"egg\\", \\"add\\") \\"YES\\" >>> are_isomorphic(\\"foo\\", \\"bar\\") \\"NO\\" >>> are_isomorphic(\\"paper\\", \\"title\\") \\"YES\\" >>> are_isomorphic(\\"abc\\", \\"ab\\") \\"NO\\" pass def process_test_cases(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Processes T test cases and returns a list of results for the isomorphism check. >>> T = 3 >>> test_cases = [(\\"egg\\", \\"add\\"), (\\"foo\\", \\"bar\\"), (\\"paper\\", \\"title\\")] >>> process_test_cases(T, test_cases) ['YES', 'NO', 'YES'] pass","solution":"def are_isomorphic(str1, str2): Determines if two strings str1 and str2 are isomorphic. if len(str1) != len(str2): return \\"NO\\" map_str1_to_str2 = {} map_str2_to_str1 = {} for char1, char2 in zip(str1, str2): if char1 in map_str1_to_str2: if map_str1_to_str2[char1] != char2: return \\"NO\\" else: if char2 in map_str2_to_str1: return \\"NO\\" map_str1_to_str2[char1] = char2 map_str2_to_str1[char2] = char1 return \\"YES\\" def process_test_cases(T, test_cases): Processes T test cases and returns a list of results for the isomorphism check. results = [] for str1, str2 in test_cases: results.append(are_isomorphic(str1, str2)) return results"},{"question":"def largest_square_of_plants(gardens: List[List[List[int]]]) -> List[int]: Returns a list containing the size of the largest square areas of plants for each garden. >>> largest_square_of_plants([ [ [1, 1, 0, 0], [1, 1, 0, 0], [0, 0, 1, 1], [0, 0, 1, 1] ], [ [1, 0, 1], [0, 1, 0], [1, 1, 0] ] ]) [2, 1] >>> largest_square_of_plants([ [ [0] ], [ [1] ] ]) [0, 1] >>> largest_square_of_plants([ [ [1, 0], [1, 1] ], [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] ]) [1, 3] >>> largest_square_of_plants([[]]) [0]","solution":"def largest_square_of_plants(gardens): Returns a list containing the size of the largest square areas of plants for each garden. results = [] for garden in gardens: n = len(garden) if n == 0: results.append(0) continue dp = [[0] * n for _ in range(n)] max_side = 0 for i in range(n): for j in range(n): if garden[i][j] == 1: if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side = max(max_side, dp[i][j]) results.append(max_side) return results"},{"question":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings that can be attended. :param meetings: List of tuples, where each tuple contains the start and end times of a meeting. :return: Integer, maximum number of non-overlapping meetings. >>> max_non_overlapping_meetings([(1, 3), (2, 4), (3, 5), (7, 8), (5, 6)]) 4 >>> max_non_overlapping_meetings([(1, 2), (2, 3), (3, 4), (5, 6)]) 4 >>> max_non_overlapping_meetings([(1, 4), (2, 5), (3, 6)]) 1","solution":"def max_non_overlapping_meetings(meetings): Returns the maximum number of non-overlapping meetings can be attended. :param meetings: List of tuples, where each tuple contains the start and end times of a meeting. :return: Integer, maximum number of non-overlapping meetings. # Sort meetings based on their end time meetings.sort(key=lambda x: x[1]) # Initialize the count and the end time of the last attended meeting count = 0 last_end_time = 0 for start_time, end_time in meetings: if start_time >= last_end_time: count += 1 last_end_time = end_time return count"},{"question":"def longest_subarray_with_same_element(n: int, sequence: List[int], k: int) -> int: Returns the length of the longest subarray that consists of the same element and that element must be greater than or equal to k. >>> longest_subarray_with_same_element(7, [3, 3, 4, 4, 4, 5, 5], 4) == 3 >>> longest_subarray_with_same_element(6, [1, 1, 2, 2, 3, 3], 2) == 2 >>> longest_subarray_with_same_element(5, [7, 7, 7, 7, 7], 8) == 0 >>> longest_subarray_with_same_element(9, [6, 6, 6, 3, 3, 3, 4, 4, 4], 6) == 3","solution":"def longest_subarray_with_same_element(n, sequence, k): Returns the length of the longest subarray that consists of the same element and that element must be greater than or equal to k. max_len = 0 current_len = 0 current_val = None for num in sequence: if num >= k and num == current_val: current_len += 1 elif num >= k: current_val = num current_len = 1 else: current_len = 0 current_val = None if current_len > max_len: max_len = current_len return max_len"},{"question":"def max_sum_kxk_submatrix(matrix, n, m, k): Given a rectangular matrix with n rows and m columns, determine the maximum sum of any submatrix of size kxk. Parameters: matrix (List[List[int]]): The input matrix. n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. k (int): The size of the submatrix. Returns: int: The maximum sum of any kxk submatrix. Example: >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> n, m, k = 4, 4, 2 >>> max_sum_kxk_submatrix(matrix, n, m, k) 54","solution":"def max_sum_kxk_submatrix(matrix, n, m, k): max_sum = float('-inf') # Compute sum of all k x k submatrices for i in range(n - k + 1): for j in range(m - k + 1): current_sum = 0 for a in range(k): for b in range(k): current_sum += matrix[i + a][j + b] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def generate_ids(n: int) -> list[int]: Generates a list of n unique and valid 3-digit ID numbers. Parameters: n (int): The number of unique, non-consecutive ID numbers to generate. Returns: List[int]: A list containing n unique and valid 3-digit ID numbers. >>> generate_ids(5) [102, 204, 306, 408, 501] >>> generate_ids(3) [147, 258, 369] from solution import generate_ids def test_generate_ids_valid_length(): result = generate_ids(5) assert len(result) == 5 def test_generate_ids_uniqueness(): result = generate_ids(10) assert len(result) == len(set(result)) def test_generate_ids_first_digit_non_zero(): result = generate_ids(10) assert all(str(id)[0] != '0' for id in result) def test_generate_ids_non_consecutive(): result = generate_ids(10) assert all(abs(result[i] - result[i+1]) > 1 for i in range(len(result) - 1)) def test_generate_ids_max_n(): result = generate_ids(900) assert len(result) == 900 def test_generate_ids_edge_case(): result = generate_ids(1) assert len(result) == 1 and 100 <= result[0] < 1000 def test_generate_ids_exceed_bound(): try: generate_ids(901) except ValueError as e: assert str(e) == \\"n must be between 1 and 900 inclusive\\" else: assert False, \\"ValueError not raised for n > 900\\"","solution":"from random import sample def generate_ids(n: int) -> list[int]: Generates a list of n unique and valid 3-digit ID numbers. Parameters: n (int): The number of unique, non-consecutive ID numbers to generate. Returns: List[int]: A list containing n unique and valid 3-digit ID numbers. if not (1 <= n <= 900): raise ValueError(\\"n must be between 1 and 900 inclusive\\") # Generating all valid 3-digit IDs valid_ids = [i for i in range(100, 1000) if str(i)[0] != '0'] # Shuffle and pick n unique IDs in non-consecutive order return sorted(sample(valid_ids, k=n))"},{"question":"from typing import List def is_prime(num: int) -> bool: Check if the given number is a prime number. >>> is_prime(2) True >>> is_prime(4) False pass def evaluate_expressions(expressions: List[str]) -> List[str]: Evaluate a list of mathematical expressions and determine if the results are prime numbers. >>> evaluate_expressions([\\"2 + 3 * (5 - 2)\\", \\"(7 - 2) * 2\\"]) [\\"Prime\\", \\"Not Prime\\"] >>> evaluate_expressions([\\"11 / 1\\", \\"6 / 2\\"]) [\\"Prime\\", \\"Prime\\"] pass","solution":"def is_prime(num): Check if the given number is a prime number. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def evaluate_expressions(expressions): Evaluate a list of mathematical expressions and determine if their results are prime numbers. results = [] for expr in expressions: # Evaluate the mathematical expression value = eval(expr) if is_prime(value): results.append(\\"Prime\\") else: results.append(\\"Not Prime\\") return results"},{"question":"def determine_winner(N: int, M: int, grid: List[List[int]], L: int, targets: List[int], K: int, first_player: str) -> str: Determine the winner of the game given a 2D grid, target values, number of special moves, and starting player. >>> determine_winner(3, 3, [[1, 2, 3], [4, 1, 6], [7, 8, 5]], 3, [1, 3, 5], 1, 'D') == 'D' >>> determine_winner(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, [1, 4, 7, 3], 2, 'C') == 'D' >>> determine_winner(2, 3, [[1, 2, 3], [5, 1, 6]], 3, [1, 6, 5], 0, 'D') == 'C' >>> determine_winner(2, 2, [[10, 20], [30, 40]], 2, [30, 20], 2, 'C') == 'D' >>> determine_winner(2, 2, [[1, 2], [2, 1]], 1, [1], 0, 'D') == 'C'","solution":"def determine_winner(N, M, grid, L, targets, K, first_player): # Create a set of target values for O(1) checks target_set = set(targets) # Count the number of cells that have target values target_count = sum(cell in target_set for row in grid for cell in row) # Determine number of turns theoretically turns = target_count + K # The player who will take the 'last' turn wins. if (turns % 2 == 0 and first_player == 'D') or (turns % 2 == 1 and first_player == 'C'): return 'C' else: return 'D'"},{"question":"def partition_list(nums: List[int]) -> Tuple[List[int], List[int]]: Partitions the list into two sublists such that the difference between the sum of integers in the first sublist and the sum of integers in the second sublist is minimized. Returns the two sublists in any order. >>> partition_list([3, 1, 4, 2]) ([3, 4], [1, 2]) >>> partition_list([-1, 2, 2, -3, 1]) ([-1, 2, 1], [2, -3])","solution":"def partition_list(nums): Partitions the list into two sublists such that the difference between the sum of integers in the first sublist and the sum of integers in the second sublist is minimized. Returns the two sublists in any order. total_sum = sum(nums) n = len(nums) # DP Table dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum // 2 + 1): dp[i][j] = dp[i-1][j] if j >= nums[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j - nums[i-1]] # Find the maximum value for s1 near to total_sum // 2 s1 = max(j for j in range(total_sum // 2 + 1) if dp[n][j]) s2 = total_sum - s1 # Backtrack to find the elements of the subsets subset1 = [] subset2 = nums[:] w = s1 for i in range(n, 0, -1): if not dp[i-1][w]: subset1.append(nums[i-1]) subset2.remove(nums[i-1]) w -= nums[i-1] return subset1, subset2"},{"question":"def min_trucks_needed(k: int, n: int, times: List[int]) -> int: Determines the minimum number of trucks required to complete all deliveries. Parameters: k (int): Maximum working hours for each truck driver in a day. n (int): Number of destinations. times (list): Time required for the round trip to each destination. Returns: int: Minimum number of trucks needed. Examples: >>> min_trucks_needed(10, 4, [2, 3, 4, 5]) 2 >>> min_trucks_needed(8, 3, [4, 4, 4]) 2 >>> min_trucks_needed(5, 2, [3, 4]) 2","solution":"def min_trucks_needed(k, n, times): Determines the minimum number of trucks required to complete all deliveries. Parameters: k (int): Maximum working hours for each truck driver in a day. n (int): Number of destinations. times (list): Time required for the round trip to each destination. Returns: int: Minimum number of trucks needed. # Sort the times in non-decreasing order times.sort() count = 0 i, j = 0, n - 1 while i <= j: # Check if the current longest and shortest trips can be combined if times[i] + times[j] <= k: i += 1 j -= 1 count += 1 return count"},{"question":"from typing import List, Tuple def find(parent, i): # Find the root of the set in which element i is located pass def union(parent, rank, x, y): # Perform union of two subsets x and y pass def min_cost_to_connect_islands(m: int, n: int, bridges: List[Tuple[int, int, int]]) -> int: Mayank the Architect is designing an archipelago of islands connected by bridges. Help him determine the minimum total construction cost needed to connect all islands. Args: m : int : number of islands n : int : number of candidate bridges bridges : List[Tuple[int, int, int]] : each tuple contains two integers u, v and w which describe a candidate bridge that can connect island u and island v with a construction cost of w. Returns: int : the minimum total construction cost to ensure that every island is reachable from every other island. Example: >>> min_cost_to_connect_islands(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 3, 2), (2, 4, 3)]) 6 pass","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def min_cost_to_connect_islands(m, n, bridges): # Sort all the bridges in non-decreasing order of their cost bridges = sorted(bridges, key=lambda item: item[2]) # Create parent and rank arrays parent = [] rank = [] for node in range(m): parent.append(node) rank.append(0) # Initialize result result = 0 # To store the minimum cost # Number of edges in the MST e = 0 # Index variable, used for sorted edges i = 0 # Iterate through all the sorted edges while e < m - 1: # Pick the smallest edge and increment the index u, v, w = bridges[i] i += 1 root_u = find(parent, u - 1) root_v = find(parent, v - 1) # If including this edge does not form a cycle if root_u != root_v: e += 1 result += w union(parent, rank, root_u, root_v) return result"},{"question":"def organize_stamps(num_stamps, compare_stamps): Organize the stamps into 3 piles based on the result of compare_stamps function. Parameters: num_stamps (int): the number of stamps. compare_stamps (function): function to compare stamps, takes a list of pairs and returns a list of '0' and '1'. Returns: tuple: A tuple (k1, k2, k3, pile1, pile2, pile3) where k1, k2, k3 are the sizes of the three piles, and pile1, pile2, pile3 are list of stamps in each pile. pass def test_organize_stamps(): def dummy_compare(stamps): # For 3 stamps case, consider 1 and 2 from one country and 3 from another if (1, 2) in stamps or (2, 1) in stamps: return ['1'] elif (1, 3) in stamps or (3, 1) in stamps: return ['0'] elif (2, 3) in stamps or (3, 2) in stamps: return ['0'] return ['0'] * len(stamps) k1, k2, k3, pile1, pile2, pile3 = organize_stamps(3, dummy_compare) assert k1 == 2 assert k2 == 1 assert k3 == 0 assert sorted(pile1) == [1, 2] assert sorted(pile2) == [3] assert pile3 == [] # Another test for 6 stamps def dummy_compare_6(stamps): same_pairs = { (1, 2), (2, 1), (3, 4), (4, 3), (5, 6), (6, 5) } results = [] for pair in stamps: if pair in same_pairs: results.append('1') else: results.append('0') return ''.join(results) k1, k2, k3, pile1, pile2, pile3 = organize_stamps(6, dummy_compare_6) assert k1 == 2 assert k2 == 2 assert k3 == 2 assert sorted(pile1) == [1, 2] assert sorted(pile2) == [3, 4] assert sorted(pile3) == [5, 6] if __name__ == \\"__main__\\": test_organize_stamps()","solution":"def organize_stamps(num_stamps, compare_stamps): Organize the stamps into 3 piles based on the result of compare_stamps function. Parameters: num_stamps (int): the number of stamps. compare_stamps (function): function to compare stamps, takes a list of pairs and returns a list of '0' and '1'. Returns: tuple: A tuple (k1, k2, k3, pile1, pile2, pile3) where k1, k2, k3 are the sizes of the three piles, and pile1, pile2, pile3 are list of stamps in each pile. from collections import defaultdict, deque # Initial labels for the stamps, None means unlabelled labels = [None] * (num_stamps + 1) labels[1] = 0 # We start with assigning the first stamp a label pairs_to_query = [(1, i) for i in range(2, num_stamps + 1)] results = compare_stamps(pairs_to_query) queues = [deque(range(1, num_stamps + 1))] countries = defaultdict(list) for i in range(1, num_stamps + 1): if labels[i] is None: current_queue = deque([i]) label = len(countries) while current_queue: stamp = current_queue.popleft() if labels[stamp] is not None: continue labels[stamp] = label for j in range(1, num_stamps + 1): if j != stamp and labels[j] is None: if compare_stamps([(stamp, j)]) == '1': current_queue.append(j) countries[label] = [index for index, value in enumerate(labels) if value == label] # Distribute the stamps into multiple piles based on collected data pile1, pile2, pile3 = [], [], [] for i, label in enumerate(labels[1:], start=1): if label == 0: pile1.append(i) elif label == 1: pile2.append(i) elif label == 2: pile3.append(i) return (len(pile1), len(pile2), len(pile3), pile1, pile2, pile3)"},{"question":"def num_decodings(s: str) -> int: Given an encoded message containing digits, determine the total number of ways to decode it. :param s: str, encoded message :return: int, total number of ways to decode it >>> num_decodings(\\"1\\") 1 >>> num_decodings(\\"9\\") 1 >>> num_decodings(\\"12\\") 2 >>> num_decodings(\\"26\\") 2 >>> num_decodings(\\"10\\") 1 >>> num_decodings(\\"27\\") 1 >>> num_decodings(\\"111\\") 3 >>> num_decodings(\\"1234\\") 3 >>> num_decodings(\\"2626\\") 4 >>> num_decodings(\\"1111111111\\") 89 >>> num_decodings(\\"123456789\\") 3 >>> num_decodings(\\"0\\") 0 >>> num_decodings(\\"\\") 0 >>> num_decodings(\\"110\\") 1","solution":"def num_decodings(s): Given an encoded message containing digits, determine the total number of ways to decode it. :param s: str, encoded message :return: int, total number of ways to decode it if not s: return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 if s[0] != '0' else 0 for i in range(2, n + 1): if 1 <= int(s[i-1:i]) <= 9: dp[i] += dp[i-1] if 10 <= int(s[i-2:i]) <= 26: dp[i] += dp[i-2] return dp[n]"},{"question":"def max_subarray_indices(arr): Find the subarray such that the sum of its elements is the largest possible. If multiple subarrays have the same maximum sum, choose the one with the smallest starting index; if there are still ties, choose the one with the smallest ending index. Args: arr (List[int]): An array of integers. Returns: Tuple[int, int]: The starting and ending indices of the subarray (1-indexed) with the maximum sum. pass def process_test_cases(T, test_cases): Process multiple test cases to find subarrays with the maximum sum. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains the number of elements and the array. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains the starting and ending indices for the subarray with the maximum sum. pass import pytest from solution import process_test_cases def test_example_case(): T = 2 test_cases = [ (9, [-2, 1, -3, 4, -1, 2, 1, -5, 4]), (3, [3, -1, 2]) ] assert process_test_cases(T, test_cases) == [(4, 7), (1, 3)] def test_case_with_all_negative_numbers(): T = 1 test_cases = [ (5, [-1, -2, -3, -4, -5]) ] assert process_test_cases(T, test_cases) == [(1, 1)] def test_case_with_all_positive_numbers(): T = 1 test_cases = [ (5, [1, 2, 3, 4, 5]) ] assert process_test_cases(T, test_cases) == [(1, 5)] def test_case_with_single_element(): T = 2 test_cases = [ (1, [5]), (1, [-5]) ] assert process_test_cases(T, test_cases) == [(1, 1), (1, 1)] def test_case_with_mixed_elements(): T = 1 test_cases = [ (8, [4, -1, 2, 1, -5, 4, -3, 2]) ] assert process_test_cases(T, test_cases) == [(1, 4)] if __name__ == \\"__main__\\": pytest.main()","solution":"def max_subarray_indices(arr): max_so_far = -float('inf') max_ending_here = 0 start = end = s = 0 for i in range(len(arr)): max_ending_here += arr[i] if max_ending_here > max_so_far: max_so_far = max_ending_here start = s end = i if max_ending_here < 0: max_ending_here = 0 s = i + 1 return (start + 1, end + 1) def process_test_cases(T, test_cases): results = [] for t in range(T): N = test_cases[t][0] arr = test_cases[t][1] result = max_subarray_indices(arr) results.append(result) return results"},{"question":"def flatten_and_sort_matrix(matrix): Flattens the matrix and sorts all elements in non-decreasing order. Args: matrix (list of list of int): The input matrix. Returns: list of int: The sorted list of all elements in the matrix. >>> flatten_and_sort_matrix([ ... [9, 3, 8], ... [6, 1, 2], ... [7, 4, 5] ... ]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_and_sort_matrix([ ... [10, 20, 30, 40], ... [5, 15, 25, 35] ... ]) [5, 10, 15, 20, 25, 30, 35, 40] from solution import flatten_and_sort_matrix def test_flatten_and_sort_matrix_example1(): matrix = [ [9, 3, 8], [6, 1, 2], [7, 4, 5] ] assert flatten_and_sort_matrix(matrix) == [1, 2, 3, 4, 5, 6, 7, 8, 9] def test_flatten_and_sort_matrix_example2(): matrix = [ [10, 20, 30, 40], [5, 15, 25, 35] ] assert flatten_and_sort_matrix(matrix) == [5, 10, 15, 20, 25, 30, 35, 40] def test_flatten_and_sort_matrix_single_element(): matrix = [ [42] ] assert flatten_and_sort_matrix(matrix) == [42] def test_flatten_and_sort_matrix_empty(): matrix = [[]] assert flatten_and_sort_matrix(matrix) == [] def test_flatten_and_sort_matrix_multiple_same_elements(): matrix = [ [3, 3, 3], [3, 3, 3], [3, 3, 3] ] assert flatten_and_sort_matrix(matrix) == [3, 3, 3, 3, 3, 3, 3, 3, 3] def test_flatten_and_sort_matrix_large_matrix(): matrix = [ [12, 9, 16, 7], [18, 5, 20, 2], [11, 14, 8, 6] ] assert flatten_and_sort_matrix(matrix) == [2, 5, 6, 7, 8, 9, 11, 12, 14, 16, 18, 20]","solution":"def flatten_and_sort_matrix(matrix): Flattens the matrix and sorts all elements in non-decreasing order. Args: matrix (list of list of int): The input matrix. Returns: list of int: The sorted list of all elements in the matrix. # Flattening the matrix using a list comprehension flattened_list = [element for row in matrix for element in row] # Sorting the flattened list sorted_list = sorted(flattened_list) return sorted_list # Example usage if __name__ == \\"__main__\\": n = int(input()) m = int(input()) matrix = [list(map(int, input().split())) for _ in range(n)] result = flatten_and_sort_matrix(matrix) print(\\" \\".join(map(str, result)))"},{"question":"def max_lights(N: int, L: int, capacities: List[int], powers: List[int]) -> int: Returns the maximum number of lights that can be placed across the houses without exceeding any house's power capacity. Args: N : int : The number of houses L : int : The number of lights capacities : List[int] : The power capacity of each house powers : List[int] : The power consumption of each light Returns: int : The maximum number of lights that can be placed across the houses without exceeding any house's power capacity. Example: >>> max_lights(5, 3, [5, 10, 15, 20, 25], [4, 5, 6]) 3 >>> max_lights(4, 5, [10, 15, 20, 25], [5, 5, 5, 15, 10]) 4 pass # Add your implementation here.","solution":"def max_lights(N, L, capacities, powers): Returns the maximum number of lights that can be placed across the houses without exceeding any house's power capacity. capacities.sort() # Sort house capacities powers.sort() # Sort light powers max_lights_count = 0 house_index = 0 light_index = 0 # Try to place each light in the first house that can hold it while house_index < N and light_index < L: if powers[light_index] <= capacities[house_index]: max_lights_count += 1 light_index += 1 # Move to the next light house_index += 1 # Move to the next house for each comparison return max_lights_count"},{"question":"def largest_contiguous_plot(m: int, n: int, farm: List[str]) -> int: Calculates the size of the largest contiguous plot of crops. Parameters: m (int): number of rows n (int): number of columns farm (list): MxN grid of characters Returns: int: size of the largest contiguous plot of crops Examples: >>> largest_contiguous_plot(4, 4, [\\"**..\\", \\"*.*.\\", \\"**.*\\", \\"..**\\"]) 5 >>> largest_contiguous_plot(3, 3, [\\"*.*\\", \\".*.\\", \\"*.*\\"]) 1","solution":"def largest_contiguous_plot(m, n, farm): Calculates the size of the largest contiguous plot of crops. Parameters: m (int): number of rows n (int): number of columns farm (list): MxN grid of characters Returns: int: size of the largest contiguous plot of crops def bfs(x, y): queue = [(x, y)] visited[x][y] = True count = 0 while queue: cx, cy = queue.pop(0) count += 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and farm[nx][ny] == '*': visited[nx][ny] = True queue.append((nx, ny)) return count visited = [[False] * n for _ in range(m)] max_size = 0 for i in range(m): for j in range(n): if farm[i][j] == '*' and not visited[i][j]: max_size = max(max_size, bfs(i, j)) return max_size"},{"question":"from typing import List, Tuple, Union def deliver_message(n: int, m: int, initial_open_routes: List[Tuple[int, int]]) -> Union[int, Tuple[int, List[int]]]: A secret agent needs to travel through a network of safe houses in different cities to deliver an important message. The network consists of \`n\` safe houses, where each pair of safe houses is connected by a two-way route that can be open or closed. The mission starts at the first safe house and the message needs to be delivered to the last safe house. When the agent travels from a safe house \`x\` to a safe house \`y\` using an open route, all routes connected to the safe house \`x\` will toggle their states — all open routes become closed and all closed routes become open. The agent needs to find the optimal path with the minimum number of route changes, or determine if delivering the message is impossible. Args: n (int): The number of safe houses. m (int): The number of initially open routes. initial_open_routes (List[Tuple[int, int]]): The list of initially open routes, where each route is a tuple of two integers. Returns: Union[int, Tuple[int, List[int]]]: The minimum number of routes the agent should pass through and the sequence of safe houses the agent should visit in order, or -1 if there is no path. >>> deliver_message(6, 7, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (1, 3), (4, 6)]) (3, [1, 3, 4, 6]) >>> deliver_message(6, 2, [(1, 2), (5, 6)]) -1","solution":"from collections import deque, defaultdict def find_shortest_path(n, m, routes): if n == 2 and m == 0: return -1 graph = defaultdict(list) for u, v in routes: graph[u].append(v) graph[v].append(u) dist = [-1] * (n + 1) visited = [False] * (n + 1) dist[1] = 0 visited[1] = True queue = deque([(1, [1])]) while queue: node, path = queue.popleft() if node == n: return dist[node], path for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True dist[neighbor] = dist[node] + 1 queue.append((neighbor, path + [neighbor])) return -1 # Function that formats the output according to problem requirements def deliver_message(n, m, initial_open_routes): result = find_shortest_path(n, m, initial_open_routes) if result == -1: return -1 else: distance, path = result return distance, path"},{"question":"def exist(grid: List[List[str]], word: str) -> bool: Given a matrix of characters grid and a string word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cells, where \\"adjacent\\" cells are horizontally or vertically neighboring. The same letter cell may not be used more than once. >>> exist([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"ABCCED\\") True >>> exist([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"SEE\\") True >>> exist([ ... ['A','B','C','E'], ... ['S','F','C','S'], ... ['A','D','E','E'] ... ], \\"ABCB\\") False","solution":"def exist(grid, word): if not grid or not word: return False rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp = grid[r][c] grid[r][c] = \\"\\" # mark cell as visited found = (dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1)) grid[r][c] = temp # unmark cell return found for i in range(rows): for j in range(cols): if grid[i][j] == word[0] and dfs(i, j, 0): return True return False"},{"question":"def has_subset_sum_zero(arr): This function returns True if there's a non-empty subset of the array that sums to zero, else False. >>> has_subset_sum_zero([4, -1, 1, 2]) True >>> has_subset_sum_zero([1, 2, 3, 4, 5]) False >>> has_subset_sum_zero([-3, 1, 2, -2, 3]) True def team_building_challenge(t, test_cases): This function processes multiple test cases to check if a subset with zero sum exists for each array. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, arr), where n (int): Length of the array arr (list of int): The array elements Returns: list of str: The result for each test case, \\"YES\\" or \\"NO\\" >>> test_team_building_challenge() [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def has_subset_sum_zero(arr): This function returns True if there's a non-empty subset of the array that sums to zero, else False. n = len(arr) prefix_sums = {0} # Initialize prefix sums set with zero to handle the case when single element is zero. current_sum = 0 for num in arr: current_sum += num if current_sum in prefix_sums: return True prefix_sums.add(current_sum) return False def team_building_challenge(t, test_cases): This function processes multiple test cases to check if a subset with zero sum exists for each array. Parameters: t (int): Number of test cases test_cases (list of tuples): Each tuple contains (n, arr), where n (int): Length of the array arr (list of int): The array elements Returns: list of str: The result for each test case, \\"YES\\" or \\"NO\\" results = [] for n, arr in test_cases: if has_subset_sum_zero(arr): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_operations(n: int) -> int: Returns the minimum number of operations required to reduce n to 1. >>> min_operations(7) 4 >>> min_operations(1) 0 >>> min_operations(2) 1 >>> min_operations(3) 2 >>> min_operations(10) 4 >>> min_operations(16) 4 >>> min_operations(31) 6","solution":"def min_operations(n): Returns the minimum number of operations required to reduce n to 1. from collections import deque # Initial check for edge case where n is already 1 if n == 1: return 0 # We use a deque for BFS queue = deque([(n, 0)]) visited = set() while queue: current, steps = queue.popleft() # Apply operations and check our visited set to avoid redundant work if current == 1: return steps if current not in visited: visited.add(current) # If the number is even if current % 2 == 0: queue.append((current // 2, steps + 1)) else: # If the number is odd queue.append((current + 1, steps + 1)) queue.append((current - 1, steps + 1))"},{"question":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, idx, delta): while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def prefix_sum(self, idx): sum = 0 while idx > 0: sum += self.tree[idx] idx -= idx & -idx return sum def range_sum(self, l, r): return self.prefix_sum(r) - self.prefix_sum(l - 1) def process_operations(n: int, q: int, arr: List[int], operations: List[List[int]]) -> List[int]: Given an array with n elements, perform q operations. Each operation can be one of the following two types: 1. \`1 l r\`: Print the sum of the elements in the sub-array from index l to r (both inclusive). 2. \`2 x y\`: Replace the element at index x with y. The array is indexed from 1. The function should process these operations efficiently. :param n: Number of elements in the array :param q: Number of operations :param arr: Initial elements of the array :param operations: List of operations to perform :return: List of results for type 1 operations >>> n, q = 5, 4 >>> arr = [1, 2, 3, 4, 5] >>> operations = [[1, 1, 3], [2, 3, 6], [1, 1, 3], [1, 2, 5]] >>> process_operations(n, q, arr, operations) [6, 9, 17] >>> n, q = 3, 3 >>> arr = [10, 20, 30] >>> operations = [[1, 1, 3], [2, 2, 25], [1, 2, 3]] >>> process_operations(n, q, arr, operations) [60, 55]","solution":"class FenwickTree: def __init__(self, size): self.size = size self.tree = [0] * (size + 1) def update(self, idx, delta): while idx <= self.size: self.tree[idx] += delta idx += idx & -idx def prefix_sum(self, idx): sum = 0 while idx > 0: sum += self.tree[idx] idx -= idx & -idx return sum def range_sum(self, l, r): return self.prefix_sum(r) - self.prefix_sum(l - 1) def process_operations(n, q, arr, operations): fenwick_tree = FenwickTree(n) for i in range(n): fenwick_tree.update(i + 1, arr[i]) results = [] for operation in operations: if operation[0] == 1: l = operation[1] r = operation[2] results.append(fenwick_tree.range_sum(l, r)) elif operation[0] == 2: idx = operation[1] new_value = operation[2] current_value = arr[idx - 1] delta = new_value - current_value arr[idx - 1] = new_value fenwick_tree.update(idx, delta) return results"},{"question":"def min_sensors_to_cover_cities(t: int, scenarios: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the minimum number of sensors required to cover the road between the two farthest cities in multiple scenarios. Args: t (int): Number of scenarios. scenarios (List[Tuple[Tuple[int, int], List[int]]]): A list of scenarios. Each scenario is a tuple where the first element is a tuple containing the number of cities (n) and the range of each sensor (r). The second element is a list of integers representing the positions of the cities. Returns: List[int]: For each scenario, return a single integer representing the minimum number of sensors required to cover all cities from the leftmost city to the rightmost city. Example: >>> min_sensors_to_cover_cities(2, [((4, 5), [1, 11, 6, 15]), ((3, 10), [2, 5, 12])]) [2, 1] >>> min_sensors_to_cover_cities(1, [((1, 1), [5])]) [1] pass from solution import min_sensors_to_cover_cities def test_example_cases(): assert min_sensors_to_cover_cities(2, [((4, 5), [1, 11, 6, 15]), ((3, 10), [2, 5, 12])]) == [2, 1] def test_single_city(): assert min_sensors_to_cover_cities(2, [((1, 1), [5]), ((1, 1000), [5000])]) == [1, 1] def test_cities_within_range(): assert min_sensors_to_cover_cities(1, [((5, 5), [1, 2, 3, 4, 5])]) == [1] def test_cities_out_of_range(): assert min_sensors_to_cover_cities(1, [((3, 3), [1, 10, 20])]) == [3] def test_large_input(): assert min_sensors_to_cover_cities(1, [((10, 2), [1, 4, 7, 10, 13, 16, 19, 22, 25, 28])]) == [5]","solution":"def min_sensors_to_cover_cities(t, scenarios): results = [] for i in range(t): n, r = scenarios[i][0] cities = sorted(scenarios[i][1]) sensors = 0 covered_until = -1 i = 0 while i < n: # If the current city is already covered, move to the next city if cities[i] <= covered_until: i += 1 continue # Place the sensor at the furthest city still within range sensors += 1 place_sensor_at = cities[i] + r covered_until = place_sensor_at + r # Skip all cities that are within the range of this sensor while i < n and cities[i] <= covered_until: i += 1 results.append(sensors) return results"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(test_cases: List[str]) -> List[int]: Process multiple test cases and returns a list of results. Each result is the length of the longest substring without repeating characters for each test case. >>> process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases([\\"abcdef\\"]) [6] >>> process_test_cases([\\"aaaaaa\\"]) [1] from typing import List def test_example_cases(): assert process_test_cases([\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) == [3, 1, 3] def test_single_character_string(): assert process_test_cases([\\"a\\"]) == [1] def test_all_unique_characters(): assert process_test_cases([\\"abcdef\\"]) == [6] def test_all_same_characters(): assert process_test_cases([\\"aaaaaa\\"]) == [1] def test_mix_of_unique_and_repeated(): assert process_test_cases([\\"abacabc\\", \\"abcdabc\\"]) == [3, 4] def test_multiple_test_cases(): assert process_test_cases([\\"aab\\", \\"dvdf\\", \\"nfpdmpi\\"]) == [2, 3, 5]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. start = 0 max_length = 0 used_chars = {} for i, char in enumerate(s): if char in used_chars and start <= used_chars[char]: start = used_chars[char] + 1 else: max_length = max(max_length, i - start + 1) used_chars[char] = i return max_length def process_test_cases(test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"from typing import List, Tuple def can_form_binary_tree(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determine if the devices can be configured as a valid binary tree. Args: n (int): The number of devices. m (int): The number of allowed direct connections. connections (List[Tuple[int, int]]): The list of device connections. Returns: str: \\"YES\\" if it's possible to configure the network as a valid binary tree, otherwise \\"NO\\". Examples: >>> can_form_binary_tree(3, 2, [(1, 2), (1, 3)]) \\"YES\\" >>> can_form_binary_tree(4, 3, [(1, 2), (2, 3), (2, 4)]) \\"NO\\" >>> can_form_binary_tree(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)]) \\"YES\\" def test_can_form_binary_tree(): assert can_form_binary_tree(3, 2, [(1, 2), (1, 3)]) == \\"YES\\" assert can_form_binary_tree(4, 3, [(1, 2), (1, 3), (3, 4)]) == \\"YES\\" assert can_form_binary_tree(4, 3, [(1, 2), (2, 3), (2, 4)]) == \\"NO\\" assert can_form_binary_tree(5, 4, [(1, 2), (1, 3), (2, 4), (3, 5)]) == \\"YES\\" assert can_form_binary_tree(1, 0, []) == \\"YES\\" assert can_form_binary_tree(3, 3, [(1, 2), (2, 3), (1, 3)]) == \\"NO\\" assert can_form_binary_tree(4, 2, [(1, 2), (2, 3)]) == \\"NO\\" assert can_form_binary_tree(3, 2, [(1, 2), (2, 3)]) == \\"YES\\" assert can_form_binary_tree(4, 2, [(1, 2), (3, 4)]) == \\"NO\\" assert can_form_binary_tree(4, 3, [(1, 2), (1, 3), (1, 4)]) == \\"NO\\" if __name__ == \\"__main__\\": test_can_form_binary_tree() print(\\"All tests passed.\\")","solution":"def can_form_binary_tree(n, m, connections): # A binary tree must have exactly n-1 edges if m != n - 1: return \\"NO\\" from collections import defaultdict, deque adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) adj_list[v].append(u) # Each node should not have more than 2 connections in a binary tree for node in adj_list: if len(adj_list[node]) > 2: return \\"NO\\" # Perform a BFS to check if the graph is connected and acyclic (tree property) visited = set() queue = deque([1]) visited.add(1) while queue: current = queue.popleft() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) if len(visited) == n: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_rearrange_binary_string(n: int, k: int, m: int, binary_string: str) -> str: Determines if a binary string can be rearranged to meet the requirement that every substring of length k has exactly m '1's. Parameters: n (int): Length of the binary string. k (int): Length of the required substrings. m (int): Number of '1's each substring of length k should have. binary_string (str): Input binary string. Returns: str: \\"YES\\" if the binary string can be rearranged to meet the requirement, \\"NO\\" otherwise. # Unit Test def test_example_1(): assert can_rearrange_binary_string(5, 3, 2, '11010') == \\"YES\\" def test_example_2(): assert can_rearrange_binary_string(5, 3, 3, '11001') == \\"NO\\" def test_all_ones(): assert can_rearrange_binary_string(5, 3, 3, '11111') == \\"YES\\" def test_all_zeroes(): assert can_rearrange_binary_string(5, 3, 0, '00000') == \\"YES\\" def test_insufficient_ones(): assert can_rearrange_binary_string(5, 3, 2, '10000') == \\"NO\\" def test_excess_ones(): assert can_rearrange_binary_string(5, 3, 1, '11111') == \\"NO\\" def test_edge_case_min_values(): assert can_rearrange_binary_string(1, 1, 0, '0') == \\"YES\\" def test_edge_case_max_values(): assert can_rearrange_binary_string(100, 1, 1, '1' * 100) == \\"YES\\"","solution":"def can_rearrange_binary_string(n, k, m, binary_string): Determines if a binary string can be rearranged to meet the requirement that every substring of length k has exactly m '1's. Parameters: n (int): Length of the binary string. k (int): Length of the required substrings. m (int): Number of '1's each substring of length k should have. binary_string (str): Input binary string. Returns: str: \\"YES\\" if the binary string can be rearranged to meet the requirement, \\"NO\\" otherwise. ones_count = binary_string.count('1') zeros_count = n - ones_count # checking the feasibility of rearranging the binary string if m * n // k != ones_count: return \\"NO\\" return \\"YES\\""},{"question":"def find_kth_smallest(n: int, K: int, A: List[int]) -> int: Given an integer array A and an integer K, find the Kth smallest element in the array. >>> find_kth_smallest(5, 3, [7, 10, 4, 20, 15]) 10 >>> find_kth_smallest(1, 1, [100]) 100","solution":"def find_kth_smallest(n, K, A): Returns the Kth smallest element in the array A of size n. A.sort() return A[K - 1]"},{"question":"def count_islands(grid) -> int: Returns the number of islands in the grid. An island is defined as a group of connected 'L' cells horizontally or vertically. >>> grid = [['L', 'L', 'L'], ['L', 'L', 'L'], ['L', 'L', 'L']] >>> count_islands(grid) 1 >>> grid = [['L', 'L', 'W', 'L', 'L'], ['L', 'W', 'W', 'L', 'L'], ['W', 'W', 'W', 'L', 'L'], ['L', 'L', 'W', 'L', 'W']] >>> count_islands(grid) 3 >>> grid = [['W', 'W', 'W'], ['W', 'W', 'W'], ['W', 'W', 'W']] >>> count_islands(grid) 0 >>> grid = [['L', 'L', 'L'], ['L', 'L', 'L']] >>> count_islands(grid) 1 >>> grid = [['L', 'L', 'L'], ['L', 'W', 'L'], ['L', 'L', 'L']] >>> count_islands(grid) 1 >>> grid = [['L', 'W', 'L'], ['W', 'W', 'W'], ['L', 'W', 'L']] >>> count_islands(grid) 4 >>> grid = [['L', 'W', 'L'], ['W', 'L', 'W'], ['L', 'W', 'L']] >>> count_islands(grid) 5","solution":"def count_islands(grid): Returns the number of islands in the grid. An island is defined as a group of connected 'L' cells horizontally or vertically. def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 'L': return grid[x][y] = 'W' # Mark as visited for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: dfs(x + dx, y + dy) if not grid: return 0 n, m = len(grid), len(grid[0]) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': island_count += 1 dfs(i, j) return island_count # Example usage: # grid = [ # ['L', 'L', 'W', 'L', 'L'], # ['L', 'W', 'W', 'L', 'L'], # ['W', 'W', 'W', 'L', 'L'], # ['L', 'L', 'W', 'L', 'W'] # ] # print(count_islands(grid)) # Output: 3"},{"question":"def can_transform(target: str, typed: str) -> str: Determines if the typed string can be transformed into the target string by possibly adding one extra character to each key press. Parameters: target (str): The string that Alice wants to type. typed (str): The string that Alice has actually typed. Returns: str: \\"YES\\" if the typed string can be transformed into the target string, \\"NO\\" otherwise. >>> can_transform(\\"hello\\", \\"heelllo\\") \\"YES\\" >>> can_transform(\\"world\\", \\"worlld\\") \\"YES\\" >>> can_transform(\\"typing\\", \\"typpping\\") \\"NO\\" >>> can_transform(\\"game\\", \\"gaem\\") \\"NO\\" # Test cases def test_example_hello(): assert can_transform(\\"hello\\", \\"heelllo\\") == \\"YES\\" def test_example_world(): assert can_transform(\\"world\\", \\"worlld\\") == \\"YES\\" def test_example_typing(): assert can_transform(\\"typing\\", \\"typpping\\") == \\"NO\\" def test_example_game(): assert can_transform(\\"game\\", \\"gaem\\") == \\"NO\\" def test_target_too_short(): assert can_transform(\\"short\\", \\"shortt\\") == \\"YES\\" def test_typed_extra_character(): assert can_transform(\\"abc\\", \\"abcc\\") == \\"YES\\" def test_typed_missing_character(): assert can_transform(\\"abc\\", \\"aac\\") == \\"NO\\" def test_exact_match(): assert can_transform(\\"exact\\", \\"exact\\") == \\"YES\\"","solution":"def can_transform(target, typed): Determines if the typed string can be transformed into the target string by possibly adding one extra character to each key press. Parameters: target (str): The string that Alice wants to type. typed (str): The string that Alice has actually typed. Returns: str: \\"YES\\" if the typed string can be transformed into the target string, \\"NO\\" otherwise. i, j = 0, 0 while i < len(target) and j < len(typed): if target[i] == typed[j]: i += 1 j += 1 elif j + 1 < len(typed) and typed[j + 1] == target[i]: j += 1 # Skip the extra character else: return \\"NO\\" if i == len(target): return \\"YES\\" else: return \\"NO\\""},{"question":"def calculate_final_scores(P: int, S: int, problem_points: List[int], submissions: List[Tuple[str, int, int]]) -> List[str]: Calculate the final score for each participant and return the participant names sorted by their scores. Parameters: P (int): Number of problems. S (int): Number of submissions. problem_points (List[int]): Points for each problem. submissions (List[Tuple[str, int, int]]): List of tuples representing the submissions. Each tuple contains the participant name, the problem index, and a boolean indicating the correctness. Returns: List[str]: List of participant names sorted by their final scores in descending order. Examples: >>> P, S = 5, 7 >>> problem_points = [100, 200, 150, 80, 50] >>> submissions = [ ... ('alice', 2, 1), ... ('bob', 1, 1), ... ('alice', 3, 0), ... ('alice', 4, 1), ... ('bob', 5, 1), ... ('charlie', 2, 1), ... ('charlie', 3, 1) ... ] >>> calculate_final_scores(P, S, problem_points, submissions) [\\"charlie\\", \\"alice\\", \\"bob\\"] >>> P, S = 3, 4 >>> problem_points = [300, 500, 400] >>> submissions = [ ... ('dave', 1, 1), ... ('dave', 3, 1), ... ('emma', 2, 0), ... ('emma', 3, 1) ... ] >>> calculate_final_scores(P, S, problem_points, submissions) [\\"dave\\", \\"emma\\"] >>> P, S = 3, 3 >>> problem_points = [100, 200, 300] >>> submissions = [ ... ('xander', 1, 0), ... ('yara', 2, 0), ... ('zack', 3, 0) ... ] >>> calculate_final_scores(P, S, problem_points, submissions) [] >>> P, S = 2, 4 >>> problem_points = [50, 150] >>> submissions = [ ... ('alice', 1, 1), ... ('bob', 2, 1), ... ('alice', 2, 1), ... ('bob', 1, 1) ... ] >>> calculate_final_scores(P, S, problem_points, submissions) [\\"alice\\", \\"bob\\"]","solution":"def calculate_final_scores(P, S, problem_points, submissions): scores = {} for submission in submissions: name, problem_index, is_correct = submission problem_index -= 1 # convert to 0-based index if is_correct: if name not in scores: scores[name] = 0 scores[name] += problem_points[problem_index] sorted_results = sorted(scores.items(), key=lambda x: (-x[1], x[0])) return [name for name, score in sorted_results]"},{"question":"def final_position(commands: List[Tuple[str, int]]) -> Tuple[int, int, int]: Calculates the final position of the robot given a list of commands. Directions: - \\"UP\\" increases the z-coordinate. - \\"DOWN\\" decreases the z-coordinate. - \\"LEFT\\" decreases the x-coordinate. - \\"RIGHT\\" increases the x-coordinate. - \\"FORWARD\\" increases the y-coordinate. - \\"BACKWARD\\" decreases the y-coordinate. Args: commands: List of tuples where each tuple contains a direction and a distance. Returns: Tuple of three integers representing the final coordinates (x, y, z). >>> final_position([(\\"UP\\", 5)]) (0, 0, 5) >>> final_position([(\\"BACKWARD\\", 7)]) (0, -7, 0) >>> final_position([(\\"UP\\", 5), (\\"FORWARD\\", 2), (\\"RIGHT\\", 3)]) (3, 2, 5) >>> final_position([(\\"FORWARD\\", 10), (\\"BACKWARD\\", 5), (\\"LEFT\\", 2), (\\"RIGHT\\", 3)]) (1, 5, 0) >>> final_position([(\\"UP\\", 1), (\\"DOWN\\", 1), (\\"LEFT\\", 2), (\\"RIGHT\\", 2)]) (0, 0, 0)","solution":"def final_position(commands): Calculates the final position of the robot given a list of commands. Args: commands: List of tuples where each tuple contains a direction and a distance. Returns: Tuple of three integers representing the final coordinates (x, y, z). x, y, z = 0, 0, 0 for direction, distance in commands: if direction == \\"UP\\": z += distance elif direction == \\"DOWN\\": z -= distance elif direction == \\"LEFT\\": x -= distance elif direction == \\"RIGHT\\": x += distance elif direction == \\"FORWARD\\": y += distance elif direction == \\"BACKWARD\\": y -= distance return x, y, z"},{"question":"from typing import List def closest_greater_element(matrix: List[List[int]], target: int) -> int: Find the closest greater element in a matrix relative to the target value. >>> closest_greater_element([[4, 8, 10],[2, 15, 1],[6, 9, 3]], 7) == 8 >>> closest_greater_element([[1, 2],[3, 4]], 5) == -1 >>> closest_greater_element([[7]], 5) == 7 >>> closest_greater_element([[10, 20],[30, 40]], 5) == 10 >>> closest_greater_element([[-10, -5, 0],[1, 2, 3],[4, 5, 6]], -6) == -5 >>> closest_greater_element([[1, 3, 5],[2, 4, 6]], 4) == 5 >>> closest_greater_element([[i for i in range(1000)] for _ in range(1000)], 500) == 501","solution":"def closest_greater_element(matrix, target): closest = -1 min_diff = float('inf') for row in matrix: for elem in row: if elem > target and (elem - target) < min_diff: min_diff = elem - target closest = elem return closest"},{"question":"def find_anagram_substring(s1: str, s2: str) -> int: Write a function that receives two strings, \`s1\` and \`s2\`, and determines whether \`s1\` is an anagram of a substring of \`s2\`. If it is, return the start index of the substring in \`s2\` that forms the anagram. If multiple start indices are possible, return the smallest one. If no such substring exists, return -1. >>> find_anagram_substring(\\"abc\\", \\"cbaebabacd\\") 0 >>> find_anagram_substring(\\"xyz\\", \\"cbaebabacd\\") -1 >>> find_anagram_substring(\\"abcd\\", \\"abc\\") -1 >>> find_anagram_substring(\\"ab\\", \\"abxaba\\") 0 >>> find_anagram_substring(\\"abc\\", \\"defghi\\") -1 >>> find_anagram_substring(\\"a\\", \\"a\\") 0 >>> find_anagram_substring(\\"a\\", \\"b\\") -1 >>> find_anagram_substring(\\"a\\", \\"aaabaaa\\") 0 >>> find_anagram_substring(\\"aab\\", \\"aaabaaa\\") 1 >>> find_anagram_substring(\\"@bc\\", \\"@cbaeb@b@cd\\") 0","solution":"def find_anagram_substring(s1: str, s2: str) -> int: from collections import Counter len_s1 = len(s1) len_s2 = len(s2) if len_s1 > len_s2: return -1 s1_counter = Counter(s1) window_counter = Counter(s2[:len_s1]) for i in range(len_s2 - len_s1 + 1): if i > 0: # Slide the window: remove previous character, add new character prev_char = s2[i-1] new_char = s2[i+len_s1-1] window_counter[prev_char] -= 1 if window_counter[prev_char] == 0: del window_counter[prev_char] window_counter[new_char] += 1 if window_counter == s1_counter: return i return -1"},{"question":"import math def is_prime(n: int) -> bool: Determine if a given number is prime. pass # Implement this function def is_beautiful_number(binary_string: str) -> str: Determines if a given binary-like number is beautiful according to the alien numeral system. A beautiful number is defined as one having a prime number of '1's. Args: binary_string (str): The number in the alien numeral system represented as a string of '0's and '1's. Returns: str: \\"YES\\" if the number is beautiful, otherwise \\"NO\\". Examples: >>> is_beautiful_number(\\"101011\\") 'NO' >>> is_beautiful_number(\\"100000\\") 'NO' >>> is_beautiful_number(\\"11100\\") 'YES' pass # Replace with implementation # Unit Test def test_is_beautiful_number(): assert is_beautiful_number(\\"101011\\") == \\"NO\\" assert is_beautiful_number(\\"100000\\") == \\"NO\\" assert is_beautiful_number(\\"11100\\") == \\"YES\\" assert is_beautiful_number(\\"1\\") == \\"NO\\" assert is_beautiful_number(\\"1111\\") == \\"NO\\" assert is_beautiful_number(\\"11111\\") == \\"YES\\" assert is_beautiful_number(\\"10101\\") == \\"YES\\" assert is_beautiful_number(\\"\\") == \\"NO\\" # Edge case when input is an empty string assert is_beautiful_number(\\"0\\") == \\"NO\\" # Edge case when input contains no '1's","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_beautiful_number(binary_string): count_of_ones = binary_string.count('1') if is_prime(count_of_ones): return \\"YES\\" else: return \\"NO\\""},{"question":"def remaining_string_length(s: str) -> int: Returns the length of the remaining string after all possible adjacent duplicate removals. >>> remaining_string_length(\\"abccba\\") 0 >>> remaining_string_length(\\"ababa\\") 5 >>> remaining_string_length(\\"aabbaa\\") 0 >>> remaining_string_length(\\"abcdef\\") 6 >>> remaining_string_length(\\"aaaa\\") 0 >>> remaining_string_length(\\"a\\") 1 >>> remaining_string_length(\\"a\\" * (10**5)) 0 import pytest def test_example_1(): assert remaining_string_length(\\"abccba\\") == 0 def test_example_2(): assert remaining_string_length(\\"ababa\\") == 5 def test_example_3(): assert remaining_string_length(\\"aabbaa\\") == 0 def test_no_removals_needed(): assert remaining_string_length(\\"abcdef\\") == 6 def test_all_adjacents(): assert remaining_string_length(\\"aaaa\\") == 0 def test_single_character(): assert remaining_string_length(\\"a\\") == 1 def test_large_input(): # String with no adjacent duplicates of length 10^5 assert remaining_string_length(\\"a\\" * (10**5)) == 0","solution":"def remaining_string_length(s: str) -> int: Returns the length of the remaining string after all possible adjacent duplicate removals. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def search_range(nums, target): Returns the starting and ending positions of a given target value in the list. If the target is not found in the list, returns [-1, -1]. Args: nums (List[int]): A list of integers, sorted in non-decreasing order. target (int): The target integer to find in the list. Returns: List[int]: A list with two integers representing the starting and ending positions of the target value in the list. If the target is not found, return [-1, -1]. Examples: >>> search_range([5, 7, 7, 8, 8, 10], 8) [3, 4] >>> search_range([5, 7, 7, 8, 8, 10], 6) [-1, -1] >>> search_range([], 0) [-1, -1]","solution":"def search_range(nums, target): Returns the starting and ending positions of a given target value in the list. If the target is not found in the list, returns [-1, -1]. def find_start(nums, target): left, right = 0, len(nums) - 1 start = -1 while left <= right: mid = (left + right) // 2 if nums[mid] >= target: right = mid - 1 else: left = mid + 1 if nums[mid] == target: start = mid return start def find_end(nums, target): left, right = 0, len(nums) - 1 end = -1 while left <= right: mid = (left + right) // 2 if nums[mid] <= target: left = mid + 1 else: right = mid - 1 if nums[mid] == target: end = mid return end start = find_start(nums, target) end = find_end(nums, target) return [start, end]"},{"question":"def can_be_strictly_increasing(N, sequence): Determines if it is possible to make the sequence strictly increasing by modifying exactly one element. Parameters: N (int): Number of elements in the sequence. sequence (list): List of N positive integers. Returns: str: \\"YES\\" if it's possible to modify exactly one element to make the sequence strictly increasing, otherwise \\"NO\\". pass import pytest def test_example_1(): assert can_be_strictly_increasing(5, [1, 3, 2, 5, 7]) == \\"YES\\" def test_example_2(): assert can_be_strictly_increasing(4, [4, 5, 3, 2]) == \\"NO\\" def test_example_3(): assert can_be_strictly_increasing(3, [10, 9, 10]) == \\"YES\\" def test_already_increasing(): assert can_be_strictly_increasing(4, [1, 3, 5, 7]) == \\"YES\\" def test_multiple_conflicts(): assert can_be_strictly_increasing(6, [10, 1, 5, 3, 5, 6]) == \\"NO\\" def test_conflict_at_start(): assert can_be_strictly_increasing(4, [3, 1, 2, 3]) == \\"YES\\" def test_conflict_at_end(): assert can_be_strictly_increasing(5, [1, 3, 5, 7, 6]) == \\"YES\\" def test_large_numbers(): assert can_be_strictly_increasing(5, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == \\"NO\\" def test_single_change(): assert can_be_strictly_increasing(5, [1, 2, 3, 2, 5]) == \\"YES\\"","solution":"def can_be_strictly_increasing(N, sequence): Determines if it is possible to make the sequence strictly increasing by modifying exactly one element. Parameters: N (int): Number of elements in the sequence. sequence (list): List of N positive integers. Returns: str: \\"YES\\" if it's possible to modify exactly one element to make the sequence strictly increasing, otherwise \\"NO\\". def is_strictly_increasing(seq): return all(seq[i] < seq[i + 1] for i in range(len(seq) - 1)) # Check if the sequence is already strictly increasing if is_strictly_increasing(sequence): return \\"YES\\" # Find the point of conflict conflicts = 0 for i in range(1, N): if sequence[i] <= sequence[i - 1]: conflicts += 1 if conflicts > 1: return \\"NO\\" # Try to fix the conflict by modifying exactly one element for i in range(1, N): if sequence[i] <= sequence[i - 1]: original = sequence[i] sequence[i] = sequence[i - 1] + 1 if is_strictly_increasing(sequence): return \\"YES\\" sequence[i] = original sequence[i - 1] = sequence[i] - 1 if is_strictly_increasing(sequence): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def find_exploration_sequence(n: int, m: int, animal_types: List[int], edges: List[Tuple[int, int]]) -> List[int]: Find a valid exploration sequence in the forest. :param n: Number of areas (nodes). :param m: Number of paths (edges). :param animal_types: List of animal types in each area. :param edges: List of bidirectional paths between areas. :return: List of areas in the valid exploration sequence. Example: >>> find_exploration_sequence(3, 2, [1, 2, 3], [(1, 2), (2, 3)]) [1, 2, 3] >>> find_exploration_sequence(1, 0, [1], []) [1] >>> find_exploration_sequence(3, 3, [1, 2, 3], [(1, 2), (2, 3), (1, 3)]) [1, 2, 3] >>> find_exploration_sequence(4, 2, [1, 2, 3, 4], [(1, 2), (3, 4)]) [-1] :raises ValueError: If a valid exploration sequence cannot be found. pass # Example usage: from solution import find_exploration_sequence def test_single_path(): assert find_exploration_sequence(3, 2, [1, 2, 3], [(1, 2), (2, 3)]) == [1, 2, 3] def test_single_node(): assert find_exploration_sequence(1, 0, [1], []) == [1] def test_fully_connected(): assert find_exploration_sequence(3, 3, [1, 2, 3], [(1, 2), (2, 3), (1, 3)]) == [1, 2, 3] or [1, 3, 2] def test_disconnected_graph(): assert find_exploration_sequence(4, 2, [1, 2, 3, 4], [(1, 2), (3, 4)]) == [-1] def test_example_case(): n = 6 m = 7 animal_types = [2, 1, 3, 2, 1, 3] edges = [ (1, 2), (2, 3), (1, 4), (4, 5), (5, 6), (3, 6), (4, 3) ] result = find_exploration_sequence(n, m, animal_types, edges) assert len(result) == n # Ensure we have exactly n nodes in the result assert sorted(result) == list(range(1, n + 1)) # Ensure we visit all nodes","solution":"from collections import defaultdict, deque def find_exploration_sequence(n, m, animal_types, edges): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) # Sort adjacency lists by animal type to ensure we can traverse in lexicographical order for key in graph: graph[key] = sorted(graph[key], key=lambda x: (animal_types[x - 1], x)) def dfs(node, visited, sequence): visited.add(node) sequence.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, visited, sequence) # We try DFS from every starting node best_sequence = None for start in range(1, n + 1): visited = set() sequence = [] dfs(start, visited, sequence) if len(visited) == n: if best_sequence is None or len(sequence) < len(best_sequence): best_sequence = sequence if best_sequence is None: return [-1] return best_sequence # Example usage: # Input: n = 6 m = 7 animal_types = [2, 1, 3, 2, 1, 3] edges = [ (1, 2), (2, 3), (1, 4), (4, 5), (5, 6), (3, 6), (4, 3) ] print(find_exploration_sequence(n, m, animal_types, edges))"},{"question":"def combination_sum(arr: List[int], target: int) -> List[List[int]]: Given an integer array \`arr\` of positive numbers and another integer \`target\`, find all unique combinations in \`arr\` where the sum of the combination is equal to \`target\`. The same number may be chosen from \`arr\` an unlimited number of times. >>> combination_sum([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> combination_sum([2, 4, 6], 8) [[2, 2, 2, 2], [2, 2, 4], [4, 4], [6, 2]] >>> combination_sum([5, 10, 12], 7) [] >>> combination_sum([3], 6) [[3, 3]] >>> combination_sum([2, 3, 2], 4) [[2, 2]]","solution":"def combination_sum(arr, target): def backtrack(start, target, path): if target == 0: result.append(path) return if target < 0: return for i in range(start, len(arr)): # ensure the element is greater than zero if arr[i] <= target: backtrack(i, target - arr[i], path + [arr[i]]) arr = sorted(set(arr)) # remove duplicates and sort result = [] backtrack(0, target, []) return result"},{"question":"def max_sloped_segment_length(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the maximum length of a sloped segment for each test case. A sloped segment is strictly increasing or strictly decreasing and has at least two elements. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains (n, array) where n is the length of the array and array is the list of integers. Returns: list of int: Maximum lengths of the sloped segments for each test case. Example: >>> max_sloped_segment_length(3, [(5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [7, 7, 7, 7, 7, 7])]) [3, 4, 0]","solution":"def max_sloped_segment_length(t, test_cases): Returns the maximum length of a sloped segment for each test case. Parameters: t (int): Number of test cases. test_cases (list of tuples): Each tuple contains (n, array) where n is the length of the array and array is the list of integers. Returns: list of int: Maximum lengths of the sloped segments for each test case. results = [] for n, arr in test_cases: max_length = current_length = 0 direction = 0 # 0 means not yet determined, 1 means increasing, -1 means decreasing for i in range(1, n): if arr[i] > arr[i - 1]: if direction != 1: current_length = 2 direction = 1 else: current_length += 1 elif arr[i] < arr[i - 1]: if direction != -1: current_length = 2 direction = -1 else: current_length += 1 else: current_length = 0 direction = 0 max_length = max(max_length, current_length) results.append(max_length) return results # Example usage: # test_cases = [(5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [7, 7, 7, 7, 7, 7])] # print(max_sloped_segment_length(3, test_cases))"},{"question":"def busiest_customer(n: int, records: List[Tuple[str, str]]) -> str: Identifies the busiest customer who made multiple purchases during the busiest time. :param n: Number of purchase records. :param records: List of tuples containing customer identifier and timestamp. :return: The customer identifier that is the busiest. >>> busiest_customer(1, [(\\"alice\\", \\"12:30\\")]) \\"alice\\" >>> busiest_customer(7, [(\\"alice\\", \\"12:30\\"), (\\"bob\\", \\"12:30\\"), (\\"charlie\\", \\"12:30\\"), (\\"alice\\", \\"13:00\\"), (\\"bob\\", \\"13:00\\"), (\\"alice\\", \\"13:01\\"), (\\"bob\\", \\"14:00\\")]) \\"alice\\" >>> busiest_customer(2, [(\\"alice\\", \\"12:30\\"), (\\"bob\\", \\"14:00\\")]) \\"alice\\" >>> busiest_customer(5, [(\\"bob\\", \\"12:30\\"), (\\"charlie\\", \\"12:30\\"), (\\"alice\\", \\"12:30\\"), (\\"charlie\\", \\"13:00\\"), (\\"bob\\", \\"14:00\\")]) \\"alice\\" >>> busiest_customer(5, [(\\"alice\\", \\"12:30\\"), (\\"bob\\", \\"12:30\\"), (\\"alice\\", \\"12:30\\"), (\\"bob\\", \\"12:30\\"), (\\"charlie\\", \\"13:00\\")]) \\"alice\\"","solution":"def busiest_customer(n, records): Identifies the busiest customer who made multiple purchases during the busiest time. :param n: Number of purchase records. :param records: List of tuples containing customer identifier and timestamp. :return: The customer identifier that is the busiest. from collections import defaultdict time_count = defaultdict(int) customer_time_count = defaultdict(lambda: defaultdict(int)) for customer, timestamp in records: time_count[timestamp] += 1 customer_time_count[customer][timestamp] += 1 busiest_time = max(time_count, key=lambda x: time_count[x]) max_customer_purchases = 0 busiest_customer = \\"\\" for customer in customer_time_count: if customer_time_count[customer][busiest_time] > max_customer_purchases or (customer_time_count[customer][busiest_time] == max_customer_purchases and customer < busiest_customer): max_customer_purchases = customer_time_count[customer][busiest_time] busiest_customer = customer return busiest_customer"},{"question":"from itertools import product from typing import List def generate_prime_digit_numbers(n: int) -> List[str]: Generate all prime digit numbers of length n. >>> generate_prime_digit_numbers(1) ['2', '3', '5', '7'] >>> generate_prime_digit_numbers(2) ['22', '23', '25', '27', '32', '33', '35', '37', '52', '53', '55', '57', '72', '73', '75', '77'] def prime_digit_numbers(t: int, test_cases: List[int]) -> List[List[str]]: Generate all prime digit numbers for each test case. >>> prime_digit_numbers(2, [1, 2]) [['2', '3', '5', '7'], ['22', '23', '25', '27', '32', '33', '35', '37', '52', '53', '55', '57', '72', '73', '75', '77']]","solution":"from itertools import product def generate_prime_digit_numbers(n): Generate all prime digit numbers of length n. prime_digits = ['2', '3', '5', '7'] return [''.join(p) for p in product(prime_digits, repeat=n)] def prime_digit_numbers(t, test_cases): Generate all prime digit numbers for each test case. results = [] for n in test_cases: results.append(generate_prime_digit_numbers(n)) return results"},{"question":"from typing import List, Tuple def max_sum_remaining_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases, find the maximum possible sum of the remaining sequence after replacing any number of contiguous subsequences with their sum. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, each containing the length of the sequence and the sequence itself. Returns: List[int]: A list containing the maximum possible sums for each test case. >>> max_sum_remaining_sequence(3, [(3, [1, 2, 3]), (5, [-1, -2, -3, -4, -5]), (6, [5, -2, 3, -1, 6, -4])]) [6, -1, 11] >>> max_sum_remaining_sequence(1, [(1, [5])]) [5] >>> max_sum_remaining_sequence(1, [(1, [-5])]) [-5] >>> max_sum_remaining_sequence(1, [(5, [2, -1, 2, 3, -4])]) [6] >>> max_sum_remaining_sequence(1, [(3, [-1, -2, -3])]) [-1] >>> max_sum_remaining_sequence(1, [(4, [1, -2, 3, -4])]) [3]","solution":"def max_sum_remaining_sequence(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] sequence = test_cases[i][1] max_sum = float('-inf') current_sum = 0 for num in sequence: current_sum += num if current_sum > max_sum: max_sum = current_sum if current_sum < 0: current_sum = 0 results.append(max_sum) return results"},{"question":"def rle_compress(s: str) -> str: Encode the string using run-length encoding in the compact form. >>> rle_compress(\\"aaabbcc\\") 'a(3)b(2)c(2)' >>> rle_compress(\\"abc\\") 'abc' >>> rle_compress(\\"aaAA\\") 'a(2)A(2)' >>> rle_compress(\\"a\\") 'a' >>> rle_compress(\\"\\") '' >>> rle_compress(\\"aaaaaaaaaa\\") 'a(10)' >>> rle_compress(\\"aabbbCCCCdDDDD\\") 'a(2)b(3)C(4)dD(4)' >>> rle_compress(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' >>> rle_compress(\\"AAAaaaBBBbbbCCCccc\\") 'A(3)a(3)B(3)b(3)C(3)c(3)'","solution":"def rle_compress(s: str) -> str: if not s: return \\"\\" result = [] count = 1 prev_char = s[0] for char in s[1:]: if char == prev_char: count += 1 else: if count > 1: result.append(f\\"{prev_char}({count})\\") else: result.append(prev_char) prev_char = char count = 1 # Add the last run if count > 1: result.append(f\\"{prev_char}({count})\\") else: result.append(prev_char) return \\"\\".join(result)"},{"question":"def shortest_subsequence_length(s: str) -> int: Determine the length of the shortest subsequence of the string that contains every letter of the alphabet at least once. Args: s (str): The input string. Returns: int: Length of the shortest subsequence containing all letters of the alphabet, or -1 if it's not possible. Examples: >>> shortest_subsequence_length(\\"abcdefghijklmnopqrstuvwxyz\\") 26 >>> shortest_subsequence_length(\\"thequickbrownfoxjumpsoverthelazydog\\") 26 >>> shortest_subsequence_length(\\"abcd\\") -1 pass # Unit Tests def test_all_alphabet_in_order(): assert shortest_subsequence_length(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 def test_all_alphabet_mixed_order(): assert shortest_subsequence_length(\\"thequickbrownfoxjumpsoverthelazydog\\") == 26 def test_missing_numbers(): assert shortest_subsequence_length(\\"abcd\\") == -1 def test_repeated_characters(): assert shortest_subsequence_length(\\"aaaabcdefghijklmnoooopqrstuvwwwwxyzzzz\\") == 26 def test_single_repeated_character(): assert shortest_subsequence_length(\\"aaaaaaaaaaaaaaaaaaaaa\\") == -1 def test_almost_alphabet(): assert shortest_subsequence_length(\\"abcdefghijklmnopqrstuvwxy\\") == -1 def test_partial_alphabet_with_repeated(): assert shortest_subsequence_length(\\"aaaabbbbcccccdddddeeeeeffffggggghhhhiii\\") == -1","solution":"def shortest_subsequence_length(s): Determine the length of the shortest subsequence of the string that contains every letter of the alphabet at least once. Args: s (str): The input string. Returns: int: Length of the shortest subsequence containing all letters of the alphabet, or -1 if it's not possible. import string # The set of all characters in the alphabet alphabet_set = set(string.ascii_lowercase) # Iterate through the string and collect characters found_characters = set() for char in s: if char in alphabet_set: found_characters.add(char) if found_characters == alphabet_set: return len(found_characters) # If not all characters are found, return -1 return -1"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the given number n. >>> sum_of_digits(123) 6 >>> sum_of_digits(456) 15 >>> sum_of_digits(789) 24 pass def categorize_books_by_digit_sum(datasets: List[List[int]]) -> List[Dict[int, List[int]]]: Categorizes book IDs by the sum of their digits. Args: datasets (list of list): A list where each element is a list representing a dataset of book IDs. Returns: dict: A dictionary where keys are sums of digits and values are lists of book IDs. >>> categorize_books_by_digit_sum([[5, 123, 456, 789, 101112, 131415], [3, 111111, 123456, 654321]]) [{'6': [123, 101112], '15': [456, 131415], '24': [789]}, {'6': [111111], '21': [123456, 654321]}] pass","solution":"def sum_of_digits(n): Returns the sum of the digits of the given number n. return sum(int(digit) for digit in str(n)) def categorize_books_by_digit_sum(datasets): Categorizes book IDs by the sum of their digits. Args: datasets (list of list): A list where each element is a list representing a dataset of book IDs. Returns: dict: A dictionary where keys are sums of digits and values are lists of book IDs. result = [] for dataset in datasets: k = dataset[0] book_ids = dataset[1:] categorized = {} for book_id in book_ids: sum_digits = sum_of_digits(book_id) if sum_digits not in categorized: categorized[sum_digits] = [] categorized[sum_digits].append(book_id) result.append(categorized) return result"},{"question":"def can_place_two_bots(m, n, grid): Determine if it is possible to place two new bots ('N') in the grid such that no two bots (either existing 'B' or new 'N') are in direct line-of-sight of each other. >>> can_place_two_bots(5, 5, [\\".....\\", \\".B...\\", \\".....\\", \\"..B..\\", \\".....\\"]) 'YES' >>> can_place_two_bots(3, 4, [\\"....\\", \\".B..\\", \\"....\\"]) 'YES' >>> can_place_two_bots(2, 3, [\\".B.\\", \\".B.\\"]) 'NO' from solution import can_place_two_bots def test_example_1(): assert can_place_two_bots(5, 5, [\\".....\\", \\".B...\\", \\".....\\", \\"..B..\\", \\".....\\"]) == \\"YES\\" def test_example_2(): assert can_place_two_bots(3, 4, [\\"....\\", \\".B..\\", \\"....\\"]) == \\"YES\\" def test_example_3(): assert can_place_two_bots(2, 3, [\\".B.\\", \\".B.\\"]) == \\"NO\\" def test_single_empty_grid(): assert can_place_two_bots(1, 1, [\\".\\"]) == \\"NO\\" def test_no_empty_space(): assert can_place_two_bots(3, 3, [\\"BBB\\", \\"BBB\\", \\"BBB\\"]) == \\"NO\\" def test_possible_many_cells(): assert can_place_two_bots(4, 5, [\\"...B.\\", \\".....\\", \\".....\\", \\".B...\\"]) == \\"YES\\" def test_no_possible_due_to_existing_bots(): assert can_place_two_bots(3, 4, [\\".B..\\", \\".B..\\", \\"....\\"]) == \\"NO\\"","solution":"def can_place_two_bots(m, n, grid): rows = [0] * m cols = [0] * n for i in range(m): for j in range(n): if grid[i][j] == 'B': rows[i] = 1 cols[j] = 1 empty_cells = [(i, j) for i in range(m) for j in range(n) if grid[i][j] == '.'] for i in range(len(empty_cells)): for j in range(i+1, len(empty_cells)): (r1, c1), (r2, c2) = empty_cells[i], empty_cells[j] if r1 != r2 and c1 != c2 and rows[r1] == 0 and rows[r2] == 0 and cols[c1] == 0 and cols[c2] == 0: return \\"YES\\" return \\"NO\\""},{"question":"def has_pair_with_sum(N, M, tokens): Determines if there exists a pair of tokens that sum up to M. Parameters: N (int): The number of tokens. M (int): The target sum. tokens (list): A list of unique positive integers representing token values. Returns: str: \\"Yes\\" if there exists a pair with sum M, otherwise \\"No\\".","solution":"def has_pair_with_sum(N, M, tokens): Determines if there exists a pair of tokens that sum up to M. Parameters: N (int): The number of tokens. M (int): The target sum. tokens (list): A list of unique positive integers representing token values. Returns: str: \\"Yes\\" if there exists a pair with sum M, otherwise \\"No\\". seen = set() for token in tokens: if M - token in seen: return \\"Yes\\" seen.add(token) return \\"No\\""},{"question":"def is_team_balanced(n: int, project_team_info: List[Tuple[int, int, int, int]]) -> List[str]: Determine if the teams are balanced according to the project's requirements. Each project-team pair is given as a tuple (l, p, t, a) where: l: The number of roles that must be filled by leaders. p: The number of roles that can be filled by either leaders or participants. t: The total number of employees on the team. a: The number of leaders in the team. The function should return a list of \\"YES\\" or \\"NO\\" for each project depending on whether the team satisfies the requirements. >>> is_team_balanced(3, [(3, 2, 5, 3), (2, 1, 4, 1), (1, 4, 5, 2)]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> is_team_balanced(2, [(4, 2, 5, 2), (1, 3, 3, 1)]) [\\"NO\\", \\"NO\\"] >>> is_team_balanced(1, [(0, 100, 100, 0)]) [\\"YES\\"] >>> is_team_balanced(1, [(100, 0, 100, 100)]) [\\"YES\\"] >>> is_team_balanced(1, [(100, 100, 200, 100)]) [\\"YES\\"] >>> is_team_balanced(1, [(1, 1, 1, 0)]) [\\"NO\\"]","solution":"def is_team_balanced(n, project_team_info): result = [] for data in project_team_info: l, p, t, a = data if a >= l and t >= (l + p): result.append(\\"YES\\") else: result.append(\\"NO\\") return result"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int, int]]) -> List[int]: Process the queries efficiently. :param n: Number of elements in the array :param q: Number of queries :param array: List of integers :param queries: List of query tuples, each containing (l, r, x, y) :return: List of results for each query >>> process_queries(5, 3, [1, 3, 2, 5, 4], [(1, 3, 2, 4), (2, 5, 1, 3), (1, 5, 3, 5)]) [2, 2, 3] >>> process_queries(6, 2, [10, 30, 20, 40, 50, 60], [(2, 4, 15, 35), (3, 6, 25, 55)]) [2, 2] from solution import process_queries def test_case_1(): n = 5 q = 3 array = [1, 3, 2, 5, 4] queries = [(1, 3, 2, 4), (2, 5, 1, 3), (1, 5, 3, 5)] expected = [2, 2, 3] assert process_queries(n, q, array, queries) == expected def test_case_2(): n = 6 q = 2 array = [10, 30, 20, 40, 50, 60] queries = [(2, 4, 15, 35), (3, 6, 25, 55)] expected = [2, 2] assert process_queries(n, q, array, queries) == expected def test_case_3(): n = 5 q = 1 array = [5, 5, 5, 5, 5] queries = [(1, 5, 5, 5)] expected = [5] assert process_queries(n, q, array, queries) == expected def test_case_4(): n = 4 q = 2 array = [1, 2, 3, 4] queries = [(2, 3, 1, 2), (1, 4, 3, 4)] expected = [1, 2] assert process_queries(n, q, array, queries) == expected def test_case_5(): n = 6 q = 2 array = [6, 5, 4, 3, 2, 1] queries = [(2, 5, 1, 4), (1, 6, 2, 6)] expected = [3, 5] assert process_queries(n, q, array, queries) == expected","solution":"def process_queries(n, q, array, queries): Process the queries efficiently. :param n: Number of elements in the array :param q: Number of queries :param array: List of integers :param queries: List of query tuples, each containing (l, r, x, y) :return: List of results for each query results = [] for query in queries: l, r, x, y = query count = sum(1 for i in range(l-1, r) if x <= array[i] <= y) results.append(count) return results"},{"question":"def maximize_string_length(s: str) -> int: Calculate the maximum possible length of the string after removing all occurrences of a single character such that no character appears more times than any character that comes after it in the sorted order of characters by frequency. >>> maximize_string_length(\\"aabbcc\\") 4 >>> maximize_string_length(\\"abcabc\\") 4 >>> maximize_string_length(\\"aaaa\\") 0","solution":"from collections import Counter def maximize_string_length(s: str) -> int: # Count the frequency of each character freq = Counter(s) # Get the list of frequencies freq_values = sorted(freq.values()) max_length = 0 # Try removing each character and calculate the resulting lengths for char, count in freq.items(): modified_freq = freq_values[:] modified_freq.remove(count) # Check for non-decreasing condition if all(modified_freq[i] <= modified_freq[i + 1] for i in range(len(modified_freq) - 1)): max_length = max(max_length, len(s) - count) return max_length"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Determine the length of the longest palindromic substring in the given string. >>> longest_palindromic_substring_length(\\"babad\\") == 3 >>> longest_palindromic_substring_length(\\"cbbd\\") == 2 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases to find the length of the longest palindromic substring for each. >>> process_test_cases(2, [\\"babad\\", \\"cbbd\\"]) == [3, 2] >>> process_test_cases(3, [\\"a\\", \\"bb\\", \\"abcdedcba\\"]) == [1, 2, 9]","solution":"def longest_palindromic_substring_length(s): n = len(s) if n == 0: return 0 dp = [[False] * n for _ in range(n)] max_length = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(longest_palindromic_substring_length(case)) return results"},{"question":"def min_window_substring(S: str, T: str) -> str: The Smallest Window Substring problem is a classical and challenging problem in string manipulation. Given two strings S and T, find the smallest substring in S that contains all the characters of T (including their frequency). A substring is defined as a contiguous sequence of characters within a string. Args: S (str): The string to search within. T (str): The string containing characters to be searched. Returns: str: The smallest substring of S that contains all the characters of T. If no such substring exists, returns an empty string. Example: >>> min_window_substring(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> min_window_substring(\\"ADOBECODEBANC\\", \\"XYZ\\") \\"\\"","solution":"from collections import Counter def min_window_substring(S, T): if not S or not T: return \\"\\" dict_t = Counter(T) required = len(dict_t) l, r = 0, 0 formed = 0 window_counts = {} ans = float(\\"inf\\"), None, None while r < len(S): character = S[r] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_t and window_counts[character] == dict_t[character]: formed += 1 while l <= r and formed == required: character = S[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) window_counts[character] -= 1 if character in dict_t and window_counts[character] < dict_t[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else S[ans[1]: ans[2] + 1]"},{"question":"def reorder_string(s: str) -> str: Reorder the characters in the string so that all the letters come before the digits, while maintaining their respective order. >>> reorder_string(\\"a1b2c3\\") 'abc123' >>> reorder_string(\\"4g1h2j\\") 'ghj412'","solution":"def reorder_string(s): Reorders the input string s such that all letters come before all digits, while maintaining their respective order. :param s: input string containing letters and digits :return: reordered string letters = [char for char in s if char.isalpha()] digits = [char for char in s if char.isdigit()] return ''.join(letters + digits)"},{"question":"def is_sorted(stones: List[str]) -> str: Determines if the list of stone serial numbers is sorted in alphabetical order. Args: stones : List[str] : List of stone serial numbers. Returns: str : \\"YES\\" if the collection is sorted; otherwise, \\"NO\\" followed by the position (1-based) and the serial number of the first stone that breaks the order. pass # Test cases def test_sorted_example(): stones = [\\"001XZ\\", \\"AA12\\", \\"ZZ99\\"] assert is_sorted(stones) == \\"YES\\" def test_unsorted_example(): stones = [\\"A112\\", \\"A111\\", \\"A123\\", \\"AA19\\"] assert is_sorted(stones) == \\"NO 2 A111\\" def test_single_stone(): stones = [\\"A111\\"] assert is_sorted(stones) == \\"YES\\" def test_all_identical_stones(): stones = [\\"A111\\", \\"A111\\", \\"A111\\"] assert is_sorted(stones) == \\"YES\\" def test_edge_case_last_out_of_order(): stones = [\\"A100\\", \\"A110\\", \\"A119\\", \\"A101\\"] assert is_sorted(stones) == \\"NO 4 A101\\" def test_edge_case_first_out_of_order(): stones = [\\"B100\\", \\"A110\\", \\"A119\\", \\"A120\\"] assert is_sorted(stones) == \\"NO 2 A110\\"","solution":"def is_sorted(stones): Determines if the list of stone serial numbers is sorted in alphabetical order. Args: stones : List[str] : List of stone serial numbers. Returns: str : \\"YES\\" if the collection is sorted; otherwise, \\"NO\\" followed by the position (1-based) and the serial number of the first stone that breaks the order. for i in range(1, len(stones)): if stones[i] < stones[i-1]: return f\\"NO {i+1} {stones[i]}\\" return \\"YES\\""},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters in the given string s. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 def process_test_cases(n: int, test_cases: List[str]) -> List[int]: Processes multiple test cases to find the length of the longest substring without repeating characters. >>> process_test_cases(3, [\\"abcabcbb\\", \\"bbbbb\\", \\"pwwkew\\"]) [3, 1, 3] >>> process_test_cases(2, [\\"\\", \\"a\\"]) [0, 1]","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters in the given string s. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length def process_test_cases(n, test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring(s)) return results"},{"question":"def kth_permutation(k: int, s: str) -> str: Finds the k-th smallest lexicographic permutation of the string s. >>> kth_permutation(1, \\"abc\\") 'abc' >>> kth_permutation(2, \\"abc\\") 'acb' >>> kth_permutation(3, \\"abc\\") 'bac' >>> kth_permutation(6, \\"cba\\") 'cba'","solution":"import math def kth_permutation(k, s): Returns the k-th smallest lexicographic permutation of the string s. n = len(s) s = sorted(s) permutation = [] k -= 1 # 0-indexed for i in range(n, 0, -1): factorial = math.factorial(i - 1) index = k // factorial permutation.append(s.pop(index)) k %= factorial return ''.join(permutation)"},{"question":"def sort_playlist_durations(N: int, durations: List[int]) -> List[int]: Sorts the playlist durations in non-decreasing order. Parameters: N : int : number of songs in the playlist durations : list of int : list containing the durations of the songs Returns: list of int : sorted list of song durations >>> sort_playlist_durations(6, [300, 200, 150, 400, 250, 350]) [150, 200, 250, 300, 350, 400] >>> sort_playlist_durations(1, [500]) [500] >>> sort_playlist_durations(4, [100, 200, 300, 400]) [100, 200, 300, 400] >>> sort_playlist_durations(4, [400, 300, 200, 100]) [100, 200, 300, 400] >>> sort_playlist_durations(5, [200, 200, 150, 150, 300]) [150, 150, 200, 200, 300] >>> sort_playlist_durations(3, [1000000, 500000, 750000]) [500000, 750000, 1000000]","solution":"def sort_playlist_durations(N, durations): Sorts the playlist durations in non-decreasing order. Parameters: N : int : number of songs in the playlist durations : list of int : list containing the durations of the songs Returns: list of int : sorted list of song durations return sorted(durations)"},{"question":"def find_min_max_tasks(N, M, friends_tasks): Yara and her friends are organizing a surprise party and need to create a detailed plan to communicate each task among themselves. However, they realized that they might be overwriting each other's plans due to poor coordination. They decided that each friend should have a specific set of tasks and, for any overlap, the tasks should be reallocated such that only one person is responsible for any particular task. Your task is to help Yara by writing a program that finds out the minimum number of tasks each friend will end up with, ensuring that there's no overlap. Given N tasks and M friends, along with a list specifying which tasks each friend wants to do, determine the final distribution where no tasks overlap. Args: N (int): The number of tasks. M (int): The number of friends. friends_tasks (List[List[int]]): The list of tasks each friend wants to do. Returns: int: The minimum number of tasks the most-loaded friend has after reallocation. Examples: >>> find_min_max_tasks(5, 3, [[0, 1], [1, 2, 3], [3, 4]]) 2 >>> find_min_max_tasks(5, 3, [[0, 1], [2, 3], [4]]) 2","solution":"def find_min_max_tasks(N, M, friends_tasks): task_to_friends = {} for friend_id, tasks in enumerate(friends_tasks): for task in tasks: if task not in task_to_friends: task_to_friends[task] = [] task_to_friends[task].append(friend_id) # List to count tasks assigned to each friend tasks_count = [0] * M for task, friends in task_to_friends.items(): if len(friends) > 1: least_loaded_friend = min(friends, key=lambda f: tasks_count[f]) tasks_count[least_loaded_friend] += 1 else: tasks_count[friends[0]] += 1 return max(tasks_count) # Example usage N = 5 M = 3 friends_tasks = [ [0, 1], [1, 2, 3], [3, 4] ] print(find_min_max_tasks(N, M, friends_tasks)) # Output: 2"},{"question":"def find_winner(n, m, times, difficulties): Determine the winner of the marathon who completes the segments in the least total adjusted time. Parameters: n (int): Number of runners m (int): Number of segments times (list of list of int): Time taken by each runner for each segment difficulties (list of int): Difficulty levels for each segment Returns: int: 1-based index of the winner >>> n = 3 >>> m = 4 >>> times = [ ... [5, 6, 7, 8], ... [6, 5, 7, 6], ... [5, 5, 5, 5] ... ] >>> difficulties = [2, 3, 4, 3] >>> find_winner(n, m, times, difficulties) 3","solution":"def find_winner(n, m, times, difficulties): Determine the winner of the marathon who completes the segments in the least total adjusted time. Parameters: n (int): Number of runners m (int): Number of segments times (list of list of int): Time taken by each runner for each segment difficulties (list of int): Difficulty levels for each segment Returns: int: 1-based index of the winner total_times = [] for runner in range(n): total_time = 0 for segment in range(m): total_time += times[runner][segment] * difficulties[segment] total_times.append(total_time) winner = total_times.index(min(total_times)) + 1 return winner"},{"question":"def does_subsequence_sum_exist(arr: List[int], s: int) -> bool: Determine if there exists a continuous subsequence within the array which sums up to a given integer \`s\`. Parameters: arr (list of int): The integer array. s (int): The target sum. Returns: bool: True if such a subsequence exists, otherwise False. >>> does_subsequence_sum_exist([1, 2, 3, 7, 8], 15) True >>> does_subsequence_sum_exist([5, 6, -1, 4, 9], 20) False","solution":"def does_subsequence_sum_exist(arr, s): Determine if there exists a continuous subsequence within the array which sums up to a given integer \`s\`. Parameters: arr (list of int): The integer array. s (int): The target sum. Returns: bool: True if such a subsequence exists, otherwise False. n = len(arr) for start in range(n): current_sum = 0 for end in range(start, n): current_sum += arr[end] if current_sum == s: return True return False"},{"question":"def min_meeting_rooms(workshops: List[Tuple[str, str]]) -> int: Determine the minimum number of meeting rooms required to accommodate all workshops. :param workshops: List of tuples where each tuple contains two string values representing the start and end time of a workshop in \\"HH:MM\\" format. :return: Integer representing the minimum number of rooms required. >>> min_meeting_rooms([(\\"09:00\\", \\"10:30\\"), (\\"09:15\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")]) 2 >>> min_meeting_rooms([(\\"09:00\\", \\"10:00\\")]) 1 >>> min_meeting_rooms([(\\"09:00\\", \\"10:00\\"), (\\"10:01\\", \\"11:00\\")]) 1 >>> min_meeting_rooms([(\\"09:00\\", \\"10:30\\"), (\\"09:00\\", \\"10:30\\"), (\\"09:00\\", \\"10:30\\")]) 3 >>> min_meeting_rooms([(\\"09:00\\", \\"10:00\\"), (\\"09:30\\", \\"10:30\\"), (\\"10:00\\", \\"11:00\\")]) 2 >>> min_meeting_rooms([]) 0 pass","solution":"def min_meeting_rooms(workshops): Determine the minimum number of meeting rooms required to accommodate all workshops. :param workshops: List of tuples where each tuple contains two string values representing the start and end time of a workshop in \\"HH:MM\\" format. :return: Integer representing the minimum number of rooms required. if not workshops: return 0 intervals = [] for start, end in workshops: start_hour, start_minute = map(int, start.split(':')) end_hour, end_minute = map(int, end.split(':')) start_total_minutes = start_hour * 60 + start_minute end_total_minutes = end_hour * 60 + end_minute intervals.append((start_total_minutes, end_total_minutes)) intervals.sort() import heapq room_heap = [] for interval in intervals: if room_heap and room_heap[0] <= interval[0]: heapq.heappop(room_heap) heapq.heappush(room_heap, interval[1]) return len(room_heap) # Example usage: # workshops = [(\\"09:00\\", \\"10:30\\"), (\\"09:15\\", \\"11:00\\"), (\\"11:00\\", \\"12:00\\")] # print(min_meeting_rooms(workshops)) # Output: 2"},{"question":"def smallest_subarray_with_sum(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Find the smallest subarray with sum equal to k for multiple test cases. Args: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list containing tuples, where each tuple contains: - A tuple with two integers n (length of the array) and k (target sum). - A list of integers representing the array. Returns: List[int]: A list containing the lengths of the smallest subarrays with sum equal to k for each test case, or -1 if no such subarray exists. Example: >>> smallest_subarray_with_sum(3, [((5, 15), [1, 2, 3, 4, 5]), ((7, 10), [1, 2, 3, 4, 5, 6, 7]), ((8, 15), [1, 2, 3, 4, 5, 6, 7, 8])]) [5, 4, 2]","solution":"def smallest_subarray_with_sum(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] arr = test_cases[i][1] left = 0 current_sum = 0 min_length = float('inf') for right in range(n): current_sum += arr[right] while current_sum >= k: if current_sum == k: min_length = min(min_length, right - left + 1) current_sum -= arr[left] left += 1 results.append(min_length if min_length != float('inf') else -1) return results"},{"question":"def longest_arith_seq_length(nums: List[int]) -> int: Create a function that takes a list of integers and returns the length of the longest subsequence where the difference between consecutive elements is consistent. >>> longest_arith_seq_length([1, 7, 3, 5, 9, 4]) 3 >>> longest_arith_seq_length([10, 8, 6, 4, 2]) 5 >>> longest_arith_seq_length([10]) 1 >>> longest_arith_seq_length([]) 0 >>> longest_arith_seq_length([5, 5, 5, 5, 5]) 5 >>> longest_arith_seq_length([1, 2, 3, 4, 5]) 5 >>> longest_arith_seq_length([5, 4, 3, 2, 1]) 5 >>> longest_arith_seq_length([9, 4, 7, 2, 10]) 3","solution":"def longest_arith_seq_length(nums): if not nums: return 0 n = len(nums) if n == 1: return 1 # dp will store the length of the longest arithmetic subsequence ending at i with difference d dp = {} max_length = 1 for i in range(n): for j in range(i): diff = nums[i] - nums[j] if (j, diff) in dp: dp[(i, diff)] = dp[(j, diff)] + 1 else: dp[(i, diff)] = 2 max_length = max(max_length, dp[(i, diff)]) return max_length"},{"question":"class DataManager: Class to manage records with operations to add, update, find, and delete records identified by unique numeric identifiers. def __init__(self): self.records = {} def add_record(self, id: int, value: int): Add a new record with identifier id and value. def update_record(self, id: int, value: int): Update the value of an existing record with identifier id. def find_record(self, id: int) -> int: Find and return the value of the record with identifier id. def delete_record(self, id: int): Delete the record with identifier id. def handle_operations(q: int, operations: List[str]) -> List[int]: Handle a series of operations on the records. Args: q : int - The number of operations. operations : list of str - List of operation strings. Returns: list of int - The results of \\"3 id\\" operations. >>> operations = [ \\"1 101 200\\", \\"3 101\\", \\"2 101 400\\", \\"3 101\\", \\"1 102 300\\", \\"3 102\\", \\"4 101\\", \\"3 101\\" ] >>> handle_operations(8, operations) [200, 400, 300, None]","solution":"class DataManager: def __init__(self): self.records = {} def add_record(self, id, value): if id not in self.records: self.records[id] = value def update_record(self, id, value): if id in self.records: self.records[id] = value def find_record(self, id): if id in self.records: return self.records[id] def delete_record(self, id): if id in self.records: del self.records[id] def handle_operations(q, operations): data_manager = DataManager() results = [] for operation in operations: parts = operation.split() op_type = int(parts[0]) if op_type == 1: id = int(parts[1]) value = int(parts[2]) data_manager.add_record(id, value) elif op_type == 2: id = int(parts[1]) value = int(parts[2]) data_manager.update_record(id, value) elif op_type == 3: id = int(parts[1]) results.append(data_manager.find_record(id)) elif op_type == 4: id = int(parts[1]) data_manager.delete_record(id) return results"},{"question":"def minimum_water_stations(n: int, distances: List[int]) -> int: Determines the minimum number of water stations needed to ensure every participant can reach a water station without exceeding their maximum distance limit. :param n: Number of participants :param distances: List of integers representing the maximum distance each participant can run without rest :return: Minimum number of water stations needed >>> minimum_water_stations(3, [1, 3, 2]) == 100 >>> minimum_water_stations(2, [2, 4]) == 50 >>> minimum_water_stations(1, [100]) == 1 >>> minimum_water_stations(1, [50]) == 2 >>> minimum_water_stations(3, [3, 3, 3]) == 34 >>> minimum_water_stations(4, [10, 30, 50, 70]) == 10 >>> minimum_water_stations(5, [25, 30, 35, 80, 100]) == 4","solution":"def minimum_water_stations(n, distances): Determines the minimum number of water stations needed to ensure every participant can reach a water station without exceeding their maximum distance limit. :param n: Number of participants :param distances: List of integers representing the maximum distance each participant can run without rest :return: Minimum number of water stations needed if n == 0: return 0 # The maximum distance any participant can run without taking a break min_distance = min(distances) # Number of water stations is equal to the minimum distance any participant can run return (100 + min_distance - 1) // min_distance # Or simply ceil(100 / min_distance)"},{"question":"def beauty_of_matrices(t: int, test_cases: List[int]) -> List[int]: For given number of test cases, return the integers from 1 to n that can be represented as the beauty of any matrix. Parameters: t : int : number of test cases test_cases : list of int : each entry is the value of n for that test case Returns: list of int : for each test case, return n itself as the number of beauties match. pass # Example test cases from solution import beauty_of_matrices def test_single_test_case(): assert beauty_of_matrices(1, [3]) == [3] def test_multiple_test_cases(): assert beauty_of_matrices(3, [3, 5, 7]) == [3, 5, 7] def test_edge_cases(): assert beauty_of_matrices(2, [1, 1000000]) == [1, 1000000] def test_uniform_values(): assert beauty_of_matrices(4, [4, 4, 4, 4]) == [4, 4, 4, 4]","solution":"def beauty_of_matrices(t, test_cases): For given number of test cases, return the integers from 1 to n that can be represented as the beauty of any matrix. Parameters: t : int : number of test cases test_cases : list of int : each entry is the value of n for that test case Returns: list of int : for each test case, return n itself as the number of beauties match. return test_cases"},{"question":"from typing import List def max_resource_submatrix(matrix: List[List[int]], k: int) -> int: Returns the maximum sum of a k x k submatrix in the given n x n matrix. :param matrix: List of lists of integers, where each sublist is a row in an n x n grid. :param k: Integer, the size of the submatrix. :return: Maximum sum of the resources in any contiguous submatrix of size k x k. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> k = 2 >>> max_resource_submatrix(matrix, k) 28 >>> matrix = [ ... [1, -1, 0], ... [-1, 1, -1], ... [1, 1, 1] ... ] >>> k = 2 >>> max_resource_submatrix(matrix, k) 2 pass","solution":"def max_resource_submatrix(matrix, k): Returns the maximum sum of a k x k submatrix in the given n x n matrix. :param matrix: List of lists of integers, where each sublist is a row in an n x n grid. :param k: Integer, the size of the submatrix. :return: Maximum sum of the resources in any contiguous submatrix of size k x k. n = len(matrix) # Precompute the prefix sum for the matrix prefix_sum = [[0] * (n + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, n + 1): prefix_sum[i][j] = ( matrix[i - 1][j - 1] + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] ) max_sum = float('-inf') # Use the prefix sums to compute the sum of each k x k submatrix for i in range(k, n + 1): for j in range(k, n + 1): sum_k_k = ( prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k] ) if sum_k_k > max_sum: max_sum = sum_k_k return max_sum"},{"question":"def is_strong_password(password: str) -> bool: Check if a given password is strong based on the following conditions: - At least 8 characters long. - Contains at least one lowercase letter. - Contains at least one uppercase letter. - Contains at least one digit. - Contains at least one special character (!@#%^&*()-+). :param password: str, password to check :return: bool, True if the password is strong, False otherwise >>> is_strong_password('Password@123') True >>> is_strong_password('weakpass') False >>> is_strong_password('Str0ng!') False","solution":"def is_strong_password(password: str) -> bool: Check if a given password is strong based on the following conditions: - At least 8 characters long. - Contains at least one lowercase letter. - Contains at least one uppercase letter. - Contains at least one digit. - Contains at least one special character (!@#%^&*()-+). :param password: str, password to check :return: bool, True if the password is strong, False otherwise if len(password) < 8: return False has_lower = any(char.islower() for char in password) has_upper = any(char.isupper() for char in password) has_digit = any(char.isdigit() for char in password) has_special = any(char in \\"!@#%^&*()-+\\" for char in password) return has_lower and has_upper and has_digit and has_special"},{"question":"def most_frequent_integer(n: int, nums: List[int]) -> int: Returns the integer that appears the most in the list. If there is a tie, returns the smallest one. >>> most_frequent_integer(6, [1, 1, 2, 2, 2, 3]) == 2 >>> most_frequent_integer(5, [4, 4, 1, 2, 2]) == 2","solution":"def most_frequent_integer(n, nums): Returns the integer that appears the most in the list. If there is a tie, returns the smallest one. from collections import Counter counts = Counter(nums) max_count = max(counts.values()) most_frequent = [num for num, count in counts.items() if count == max_count] return min(most_frequent)"},{"question":"def interleave_sequences(n: int, seq1: List[int], seq2: List[int]) -> List[int]: Interleave two sequences of the same length. >>> interleave_sequences(3, [1, 2, 3], [4, 5, 6]) [1, 4, 2, 5, 3, 6] >>> interleave_sequences(4, [9, 8, 7, 6], [5, 4, 3, 2]) [9, 5, 8, 4, 7, 3, 6, 2] >>> interleave_sequences(1, [0], [1]) [0, 1] >>> interleave_sequences(2, [999, 888], [777, 666]) [999, 777, 888, 666] >>> interleave_sequences(3, [1, 1, 1], [1, 1, 1]) [1, 1, 1, 1, 1, 1]","solution":"def interleave_sequences(n, seq1, seq2): Interleave two sequences of the same length. Args: n (int): The length of each sequence. seq1 (list of int): The first sequence of non-negative integers. seq2 (list of int): The second sequence of non-negative integers. Returns: list of int: The interleaved sequence. interleaved = [] for i in range(n): interleaved.append(seq1[i]) interleaved.append(seq2[i]) return interleaved"},{"question":"def assign_hills_to_participants(n: int, capacities: List[int], heights: List[int]) -> Union[str, Tuple[str, List[int]]]: Determines if it is possible to assign hills to participants in such a way that: 1. Each participant runs on exactly one hill. 2. No participant runs on a hill that exceeds their capacity. If possible, returns a tuple (\\"Yes\\", assignment_list) where assignment_list is the permutation of 1 to n representing the assignment of hills to participants. Otherwise, returns \\"No\\". :param n: int - Number of participants and hills :param capacities: List[int] - Maximum heights each participant can run :param heights: List[int] - Heights of the hills in increasing order :return: Union[str, Tuple[str, List[int]]] - \\"No\\" if assignment is not possible, otherwise \\"Yes\\" and the assignment list pass from solution import assign_hills_to_participants def test_assign_hills_to_participants_possible(): n = 4 capacities = [3, 14, 7, 10] heights = [1, 2, 6, 11] result = assign_hills_to_participants(n, capacities, heights) assert result[0] == \\"Yes\\" assert sorted(result[1]) == [1, 2, 3, 4] def test_assign_hills_to_participants_impossible(): n = 3 capacities = [2, 5, 1] heights = [3, 4, 5] result = assign_hills_to_participants(n, capacities, heights) assert result == \\"No\\" def test_assign_hills_to_participants_edge_case(): n = 1 capacities = [10] heights = [5] result = assign_hills_to_participants(n, capacities, heights) assert result[0] == \\"Yes\\" assert result[1] == [1] def test_assign_hills_to_participants_all_same_capacity(): n = 4 capacities = [5, 5, 5, 5] heights = [1, 2, 3, 4] result = assign_hills_to_participants(n, capacities, heights) assert result[0] == \\"Yes\\" assert sorted(result[1]) == [1, 2, 3, 4] def test_assign_hills_to_participants_all_same_height(): n = 4 capacities = [5, 6, 7, 8] heights = [5, 5, 5, 5] result = assign_hills_to_participants(n, capacities, heights) assert result[0] == \\"Yes\\" assert sorted(result[1]) == [1, 2, 3, 4]","solution":"def assign_hills_to_participants(n, capacities, heights): Determines if it is possible to assign hills to participants in such a way that: 1. Each participant runs on exactly one hill. 2. No participant runs on a hill that exceeds their capacity. If possible, returns a tuple (\\"Yes\\", assignment_list) where assignment_list is the permutation of 1 to n representing the assignment of hills to participants. Otherwise, returns \\"No\\". :param n: int - Number of participants and hills :param capacities: List[int] - Maximum heights each participant can run :param heights: List[int] - Heights of the hills in increasing order :return: Union[str, Tuple[str, List[int]]] - \\"No\\" if assignment is not possible, otherwise \\"Yes\\" and the assignment list capacity_with_indices = sorted((capacity, i) for i, capacity in enumerate(capacities)) assignment = [0] * n for i in range(n): if capacity_with_indices[i][0] < heights[i]: return \\"No\\" assignment[capacity_with_indices[i][1]] = i + 1 return \\"Yes\\", assignment"},{"question":"def max_coins(grid: List[List[int]]) -> int: Computes the maximum number of coins that can be collected moving from the top-left corner to the bottom-right corner of the grid by moving only right or down. >>> max_coins([ ... [0, 3, 1, 1], ... [2, 0, 0, 4], ... [1, 5, 3, 1] ... ]) 12 >>> max_coins([ ... [1, 2, 3, 4, 5] ... ]) 15 >>> max_coins([ ... [1], ... [2], ... [3], ... [4], ... [5] ... ]) 15 >>> max_coins([[0]]) 0 >>> max_coins([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 29 >>> max_coins([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def max_coins(grid): Computes the maximum number of coins that can be collected moving from the top-left corner to the bottom-right corner of the grid by moving only right or down. N = len(grid) M = len(grid[0]) # Create a 2D array to store maximum coins collected up to each cell dp = [[0] * M for _ in range(N)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, M): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, N): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the grid for i in range(1, N): for j in range(1, M): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner has the maximum coins collected return dp[N - 1][M - 1]"},{"question":"def surviving_trees(trees): Determines the number of trees that survive in the row after adjacent trees fight for sunlight repeatedly, until no more trees can die. Parameters: trees (List[int]): A list of integers representing the heights of the trees. Returns: int: The number of trees that survive. Example: >>> surviving_trees([1, 3, 2, 1, 4, 5]) 2 >>> surviving_trees([4, 4, 4, 4, 4]) 5 pass def solution(test_cases): Processes multiple test cases to determine the number of surviving trees for each case. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer representing the number of trees and a list of integers representing the heights of each tree. Returns: List[int]: A list of integers, where each integer represents the number of trees that survive for each test case. pass def read_input(input_str): Reads and parses the input string into a format suitable for processing. Parameters: input_str (str): A string representation of the input. Returns: List[Tuple[int, List[int]]]: A list of test cases, where each test case contains an integer and a list of integers representing the heights of the trees. pass # Example unit tests for the solution def test_solution_with_example_cases(): input_str = 2 6 1 3 2 1 4 5 5 4 4 4 4 4 test_cases = read_input(input_str) results = solution(test_cases) assert results == [2, 5] def test_solution_with_all_same_height(): input_str = 1 4 2 2 2 2 test_cases = read_input(input_str) results = solution(test_cases) assert results == [4] def test_solution_with_no_survivors(): input_str = 1 5 1 2 3 4 5 test_cases = read_input(input_str) results = solution(test_cases) assert results == [1] def test_solution_with_alternating_heights(): input_str = 1 6 1 3 1 3 1 3 test_cases = read_input(input_str) results = solution(test_cases) assert results == [3] def test_solution_with_single_tree(): input_str = 1 1 7 test_cases = read_input(input_str) results = solution(test_cases) assert results == [1]","solution":"def surviving_trees(trees): while True: new_trees = [trees[0]] for i in range(1, len(trees)): if trees[i] <= trees[i-1]: new_trees.append(trees[i]) if len(new_trees) == len(trees): return len(new_trees) trees = new_trees def solution(test_cases): results = [] for t in test_cases: N, heights = t results.append(surviving_trees(heights)) return results def read_input(input_str): input_lines = input_str.strip().split('n') T = int(input_lines[0]) test_cases = [] line_idx = 1 for _ in range(T): N = int(input_lines[line_idx]) heights = list(map(int, input_lines[line_idx + 1].split())) test_cases.append((N, heights)) line_idx += 2 return test_cases"},{"question":"def max_sum_after_rotations(arr): Returns the maximum sum of the array when rotated any number of times. Since rotating the array doesn't change the sum, the maximum sum is just the sum of the elements in the array. >>> max_sum_after_rotations([1, 2, 3, 4]) 10 >>> max_sum_after_rotations([5, 5, 5, 5, 5]) 25 >>> max_sum_after_rotations([-1, -2, -3]) -6 def process_test_cases(T, test_cases): Processes multiple test cases and returns the result for each one. >>> process_test_cases(1, [(4, [1, 2, 3, 4])]) [10] >>> process_test_cases(3, [(4, [1, 2, 3, 4]), (5, [5, 5, 5, 5, 5]), (3, [-1, -2, -3])]) [10, 25, -6]","solution":"def max_sum_after_rotations(arr): Returns the maximum sum of the array when rotated any number of times. Since rotating the array doesn't change the sum, the maximum sum is just the sum of the elements in the array. return sum(arr) def process_test_cases(T, test_cases): Processes multiple test cases and returns the result for each one. results = [] for i in range(T): N, arr = test_cases[i] results.append(max_sum_after_rotations(arr)) return results"},{"question":"def min_insertions_to_make_palindrome(s: str) -> int: Returns the minimum number of insertions needed to make a string s a palindrome. def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases to find the minimum number of insertions needed for each string to become a palindrome. >>> process_test_cases(3, [\\"race\\", \\"abc\\", \\"noon\\"]) [3, 2, 0] def test_min_insertions_to_make_palindrome(): test_cases = [ (\\"race\\", 3), (\\"abc\\", 2), (\\"noon\\", 0), (\\"a\\", 0), (\\"ab\\", 1), (\\"abcd\\", 3), (\\"abcca\\", 1), (\\"abcde\\", 4), (\\"aibohphobia\\", 0) # Already a palindrome ] for s, expected in test_cases: assert min_insertions_to_make_palindrome(s) == expected def test_process_test_cases(): T = 3 test_cases = [\\"race\\", \\"abc\\", \\"noon\\"] expected_results = [3, 2, 0] assert process_test_cases(T, test_cases) == expected_results","solution":"def min_insertions_to_make_palindrome(s): Returns the minimum number of insertions needed to make a string s a palindrome. n = len(s) # Create a table to store results of subproblems dp = [[0 for x in range(n)] for y in range(n)] # Fill the table for gap in range(1, n): for l in range(n-gap): h = l + gap if s[l] == s[h]: dp[l][h] = dp[l+1][h-1] else: dp[l][h] = min(dp[l][h-1], dp[l+1][h]) + 1 return dp[0][n-1] def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(min_insertions_to_make_palindrome(s)) return results"},{"question":"def min_cost_to_connect_routers(n: int, m: int, channels: List[Tuple[int, int, int]]) -> int: Find the minimum cost to connect all routers such that there exists a path between any pair of routers. If it is impossible to connect all routers, return -1. >>> min_cost_to_connect_routers(4, 5, [(1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3)]) 6 >>> min_cost_to_connect_routers(4, 2, [(1, 2, 1), (3, 4, 2)]) -1 import pytest from typing import List, Tuple def test_example_1(): n = 4 m = 5 channels = [ (1, 2, 1), (1, 3, 4), (2, 3, 2), (2, 4, 6), (3, 4, 3) ] assert min_cost_to_connect_routers(n, m, channels) == 6 def test_example_2(): n = 4 m = 2 channels = [ (1, 2, 1), (3, 4, 2) ] assert min_cost_to_connect_routers(n, m, channels) == -1 def test_single_node(): n = 1 m = 0 channels = [] assert min_cost_to_connect_routers(n, m, channels) == 0 def test_not_enough_edges(): n = 4 m = 2 channels = [ (1, 2, 10), (2, 3, 5) ] assert min_cost_to_connect_routers(n, m, channels) == -1 def test_large_connected_graph(): n = 5 m = 7 channels = [ (1, 2, 2), (1, 3, 3), (1, 4, 4), (1, 5, 5), (2, 3, 6), (3, 4, 7), (4, 5, 8) ] assert min_cost_to_connect_routers(n, m, channels) == 14","solution":"class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, p): if self.parent[p] != p: self.parent[p] = self.find(self.parent[p]) return self.parent[p] def union(self, p, q): rootP = self.find(p) rootQ = self.find(q) if rootP != rootQ: if self.rank[rootP] > self.rank[rootQ]: self.parent[rootQ] = rootP elif self.rank[rootP] < self.rank[rootQ]: self.parent[rootP] = rootQ else: self.parent[rootQ] = rootP self.rank[rootP] += 1 return True return False def min_cost_to_connect_routers(n, m, channels): if n == 1: return 0 if m < n - 1: return -1 channels.sort(key=lambda edge: edge[2]) uf = UnionFind(n) total_cost = 0 edges_used = 0 for u, v, cost in channels: if uf.union(u - 1, v - 1): total_cost += cost edges_used += 1 if edges_used == n - 1: return total_cost return -1"},{"question":"import heapq from typing import List from collections import Counter def rearrange_string(S: str) -> str: Rearranges characters of the string S such that no two adjacent characters are the same. If it's not possible, returns \\"Not Possible\\". >>> rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] True >>> rearrange_string(\\"aaab\\") 'Not Possible'","solution":"import heapq from collections import Counter def rearrange_string(S): Rearranges characters of the string S such that no two adjacent characters are the same. If it's not possible, returns \\"Not Possible\\". # Count frequency of each character char_count = Counter(S) # Create a max heap based on character frequency max_heap = [(-freq, char) for char, freq in char_count.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) # Add previous character back to the heap if its frequency is still > 0 if prev_char and prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Append the current character to the result result.append(char) # Update the previous character and frequency prev_char = char prev_freq = freq + 1 # since we are using negative frequencies # Check if the resultant length is same as the input string length if len(result) == len(S): return ''.join(result) else: return \\"Not Possible\\""},{"question":"def smallest_subarray_with_sum(arr: List[int], x: int) -> int: Determine the smallest subarray whose sum is greater than a given value x. If no such subarray exists, return -1. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 11) 3 >>> smallest_subarray_with_sum([1, 10, 5, 2, 7, 1], 8) 1 >>> smallest_subarray_with_sum([1, 2, 5, 1], 15) -1","solution":"def smallest_subarray_with_sum(arr, x): n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum > x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def max_sum_sequence(n: int, sequence: List[int]) -> int: Given a sequence of n integers, returns the maximum possible sum of the sequence after any number of moves where in each move, two elements a_i and a_j can be replaced with a_i + a_j. >>> max_sum_sequence(3, [1, 2, 3]) == 6 >>> max_sum_sequence(4, [2, 7, 1, 8]) == 18 >>> max_sum_sequence(5, [1, 1, 1, 1, 1]) == 5","solution":"def max_sum_sequence(n, sequence): Given a sequence of n integers, returns the maximum possible sum of the sequence after any number of moves where in each move, two elements a_i and a_j can be replaced with a_i + a_j. # The maximum sum is the sum of the initial elements of the sequence. return sum(sequence)"},{"question":"import json from typing import List def sort_vehicles_by_speed(vehicle_json: str) -> List[str]: Sorts vehicles by their maximum speed in descending order. Parameters: vehicle_json (str): A JSON string where keys are vehicle names and values are their maximum speeds Returns: List[str]: A list of vehicle names sorted by their maximum speed in descending order >>> input_json = json.dumps({ ... \\"Car\\": 150, ... \\"Bike\\": 120, ... \\"Truck\\": 100, ... \\"Motorcycle\\": 130, ... \\"Bicycle\\": 30 ... }) >>> sort_vehicles_by_speed(input_json) [\\"Car\\", \\"Motorcycle\\", \\"Bike\\", \\"Truck\\", \\"Bicycle\\"] >>> input_json = json.dumps({}) >>> sort_vehicles_by_speed(input_json) []","solution":"import json def sort_vehicles_by_speed(vehicle_json): Sorts vehicles by their maximum speed in descending order. Parameters: vehicle_json (str): A JSON string where keys are vehicle names and values are their maximum speeds Returns: list: A list of vehicle names sorted by their maximum speed in descending order vehicle_dict = json.loads(vehicle_json) sorted_vehicles = sorted(vehicle_dict.items(), key=lambda x: x[1], reverse=True) return [vehicle[0] for vehicle in sorted_vehicles]"},{"question":"def can_assign(preferences, N, M, limit): Helper function to check if it is possible to assign projects within the given limit. pass def find_minimum_maximum(N, M, preferences): Determine the minimum possible maximum number of students assigned to any single project by optimal assignment of students to projects. >>> find_minimum_maximum(3, 4, [[2, 1, 3, 4], [1, 3, 2, 4], [3, 2, 4, 1]]) 1 pass def main(input_str): Main function to parse the input and call the function to get result. >>> main(\\"3 4n2 1 3 4n1 3 2 4n3 2 4 1\\") 1 >>> main(\\"5 5n1 2 3 4 5n2 3 1 5 4n3 4 2 1 5n4 5 3 2 1n5 1 4 3 2\\") 1 >>> main(\\"4 3n1 2 3n2 1 3n3 1 2n2 3 1\\") 2 >>> main(\\"2 2n1 2n2 1\\") 1 >>> main(\\"6 3n1 2 3n2 1 3n1 3 2n3 2 1n2 3 1n3 1 2\\") 2 pass","solution":"import collections def can_assign(preferences, N, M, limit): counters = [0] * M for pref in preferences: assigned = False for i in range(M): project_index = pref[i] - 1 if counters[project_index] < limit: counters[project_index] += 1 assigned = True break if not assigned: return False return True def find_minimum_maximum(N, M, preferences): left, right = 1, N result = N while left <= right: mid = (left + right) // 2 if can_assign(preferences, N, M, mid): result = mid right = mid - 1 else: left = mid + 1 return result def main(input_str): data = input_str.strip().split('n') N, M = map(int, data[0].split()) preferences = [list(map(int, line.split())) for line in data[1:]] return find_minimum_maximum(N, M, preferences)"},{"question":"def steps_to_transform_to_one(n: int) -> int: Determine the number of steps required to transform the number n to 1 by applying the following rules: - If the number is even, divide it by 2. - If the number is odd, multiply it by 3 and add 1. The process is repeated until the number becomes 1. >>> steps_to_transform_to_one(6) 8 >>> steps_to_transform_to_one(27) 111 >>> steps_to_transform_to_one(1) 0 >>> steps_to_transform_to_one(16) 4 >>> steps_to_transform_to_one(7) 16 >>> steps_to_transform_to_one(1000000) 152 >>> steps_to_transform_to_one(100) 25","solution":"def steps_to_transform_to_one(n): steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = n * 3 + 1 steps += 1 return steps"},{"question":"def is_k_palindrome(k: int, s: str) -> str: Determines if the given string s can be a palindrome with at most k character changes. Arguments: k : int : The maximum number of characters that can be changed. s : str : The input string. Returns: str : \\"YES\\" if the string can be a k-palindrome, otherwise \\"NO\\". Examples: >>> is_k_palindrome(1, \\"abca\\") \\"YES\\" >>> is_k_palindrome(2, \\"abcdef\\") \\"NO\\"","solution":"def is_k_palindrome(k, s): Determines if the given string s can be a palindrome with at most k character changes. Args: k (int): The maximum number of characters that can be changed. s (str): The input string. Returns: str: \\"YES\\" if the string can be a k-palindrome, otherwise \\"NO\\". # Calculate the number of mismatched characters n = len(s) mismatches = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatches += 1 return \\"YES\\" if mismatches <= k else \\"NO\\""},{"question":"def max_coins(n: int, coins: List[int]) -> int: Determines the maximum number of coins Lena can collect from a series of boxes arranged in a line such that no two boxes in the chosen subset are adjacent. >>> max_coins(4, [1, 2, 9, 4]) 10 >>> max_coins(5, [2, 7, 9, 3, 1]) 12 >>> max_coins(1, [5]) 5 >>> max_coins(2, [3, 5]) 5 >>> max_coins(5, [0, 0, 0, 0, 0]) 0 >>> max_coins(6, [5, 1, 5, 1, 5, 1]) 15","solution":"def max_coins(n, coins): if n == 0: return 0 if n == 1: return coins[0] dp = [0] * n dp[0] = coins[0] dp[1] = max(coins[0], coins[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + coins[i]) return dp[-1] if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) coins = list(map(int, data[1:])) print(max_coins(n, coins))"},{"question":"from collections import deque from typing import List def min_steps_to_exit_maze(n: int, grid: List[str]) -> int: Returns the minimum number of steps required to move from the top-left corner to the bottom-right corner of the grid. If it is not possible, return -1. >>> min_steps_to_exit_maze(4, [ ... \\"....\\", ... \\"..\\", ... \\"....\\", ... \\".#..\\" ... ]) 6 >>> min_steps_to_exit_maze(3, [ ... \\".#.\\", ... \\".\\", ... \\".\\" ... ]) -1 >>> min_steps_to_exit_maze(1, [\\".\\"]) 0 >>> min_steps_to_exit_maze(1, [\\"#\\"]) -1 >>> min_steps_to_exit_maze(8, [ ... \\"........\\", ... \\"#..#..#.\\", ... \\".......#\\", ... \\".#....\\", ... \\".#..#...\\", ... \\".#.....#\\", ... \\"..\\", ... \\"........\\" ... ]) 14 >>> min_steps_to_exit_maze(3, [ ... \\"...\\", ... \\"#\\", ... \\"...\\" ... ]) -1","solution":"from collections import deque def min_steps_to_exit_maze(n, grid): Returns the minimum number of steps required to move from the top-left corner to the bottom-right corner of the grid. # Directions for movement: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Check if the starting or ending point is a wall if grid[0][0] == '#' or grid[n-1][n-1] == '#': return -1 # BFS initialization queue = deque([(0, 0, 0)]) # (row, column, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() # If reached the target if r == n-1 and c == n-1: return steps for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < n and grid[nr][nc] == '.' and (nr, nc) not in visited: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) # If end is not reachable return -1"},{"question":"def max_plantics_survive(m: int, n: int, grid: List[List[int]], k: int, requirements: List[int]) -> int: Determines the maximum number of Plantics that can survive given the grid and their Foodium requirements. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (list of list of int): the grid containing Foodium amounts. k (int): the number of Plantics. requirements (list of int): the Foodium requirements for each Plantic. Returns: int: the maximum number of Plantics that can survive for the day. pass from typing import List def test_max_plantics_survive(): # Test case 1 m = 3 n = 3 grid = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] k = 3 requirements = [50, 80, 30] assert max_plantics_survive(m, n, grid, k, requirements) == 3 # Test case 2 m = 2 n = 2 grid = [ [5, 7], [8, 9] ] k = 4 requirements = [7, 8, 5, 9] assert max_plantics_survive(m, n, grid, k, requirements) == 4 # Test case 3 m = 2 n = 2 grid = [ [1, 2], [2, 3] ] k = 3 requirements = [2, 3, 1] assert max_plantics_survive(m, n, grid, k, requirements) == 3 # Test case 4: Duplicate requirements m = 3 n = 3 grid = [ [10, 10, 10], [10, 20, 10], [30, 10, 10] ] k = 2 requirements = [10, 10] assert max_plantics_survive(m, n, grid, k, requirements) == 2 # Test case 5: No requirements met m = 3 n = 3 grid = [ [10, 20, 30], [40, 50, 60], [70, 80, 90] ] k = 3 requirements = [100, 110, 120] assert max_plantics_survive(m, n, grid, k, requirements) == 0","solution":"def max_plantics_survive(m, n, grid, k, requirements): Determines the maximum number of Plantics that can survive given the grid and their Foodium requirements. Args: m (int): number of rows in the grid. n (int): number of columns in the grid. grid (list of list of int): the grid containing Foodium amounts. k (int): the number of Plantics. requirements (list of int): the Foodium requirements for each Plantic. Returns: int: the maximum number of Plantics that can survive for the day. from collections import deque def bfs(i, j, target): seen = set() queue = deque([(i, j, 0)]) while queue: x, y, steps = queue.popleft() if (x, y) in seen: continue seen.add((x, y)) if grid[x][y] == target: grid[x][y] = -1 # Mark as visited return True for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in seen: queue.append((nx, ny, steps + 1)) return False requirements.sort() # Sort to allocate from smallest to largest requirement count = 0 for req in requirements: found = False for i in range(m): for j in range(n): if grid[i][j] == req: if bfs(i, j, req): found = True break if found: break if found: count += 1 return count"},{"question":"def team_with_highest_score(t: int, scores: List[List[int]]) -> int: Returns the 1-based index of the team with the highest total score. Args: t : int : An integer representing the number of teams. scores : List[List[int]] : A list of lists, where each inner list contains three integers representing the scores of a team. Returns: int : The 1-based index of the team with the highest total score. Examples: >>> team_with_highest_score(3, [[10, 20, 30], [30, 20, 10], [15, 25, 35]]) 3 >>> team_with_highest_score(3, [[10, 20, 30], [10, 20, 10], [15, 20, 25]]) 3","solution":"def team_with_highest_score(t, scores): Returns the 1-based index of the team with the highest total score. :param t: An integer representing the number of teams :param scores: A list of lists, where each inner list contains three integers representing the scores of a team highest_score = float('-inf') highest_team_index = -1 for i in range(t): team_score = sum(scores[i]) if team_score > highest_score: highest_score = team_score highest_team_index = i + 1 return highest_team_index"},{"question":"import math from typing import List def find_open_lockers(num_lockers: int) -> List[int]: Given the number of lockers, returns the locker numbers that are open after performing the operations. Lockers that are open are the ones that are perfect squares up to num_lockers. open_lockers = [] for i in range(1, int(math.sqrt(num_lockers)) + 1): open_lockers.append(i * i) return open_lockers def process_test_cases(test_cases: List[int]) -> List[str]: Processes multiple test cases and returns a list of results with open lockers for each test case. results = [] for num_lockers in test_cases: open_lockers = find_open_lockers(num_lockers) results.append(' '.join(map(str, open_lockers))) return results # Tests def test_find_open_lockers(): assert find_open_lockers(5) == [1, 4] assert find_open_lockers(10) == [1, 4, 9] assert find_open_lockers(1) == [1] assert find_open_lockers(15) == [1, 4, 9] assert find_open_lockers(16) == [1, 4, 9, 16] def test_process_test_cases(): assert process_test_cases([5, 10]) == [\\"1 4\\", \\"1 4 9\\"] assert process_test_cases([1]) == [\\"1\\"] assert process_test_cases([16]) == [\\"1 4 9 16\\"] assert process_test_cases([25, 30]) == [\\"1 4 9 16 25\\", \\"1 4 9 16 25\\"] assert process_test_cases([4, 8, 12]) == [\\"1 4\\", \\"1 4\\", \\"1 4 9\\"]","solution":"import math def find_open_lockers(num_lockers): Given the number of lockers, returns the locker numbers that are open after performing the operations. Lockers that are open are the ones that are perfect squares up to num_lockers. open_lockers = [] for i in range(1, int(math.sqrt(num_lockers)) + 1): open_lockers.append(i * i) return open_lockers def process_test_cases(test_cases): Processes multiple test cases and returns a list of results with open lockers for each test case. results = [] for num_lockers in test_cases: open_lockers = find_open_lockers(num_lockers) results.append(' '.join(map(str, open_lockers))) return results"},{"question":"from typing import List def lcm(a: int, b: int) -> int: Returns the least common multiple of a and b. >>> lcm(1, 2) 2 >>> lcm(2, 3) 6 pass # Replace with implementation def lcm_multiple(numbers: List[int]) -> int: Returns the least common multiple of a list of numbers. >>> lcm_multiple([1, 2, 3]) 6 >>> lcm_multiple([5, 10, 15, 20]) 60 pass # Replace with implementation def earliest_report_time(n: int, update_intervals: List[int]) -> int: Returns the earliest time at which the central monitoring system can compile a complete report for the entire building. Parameters: n (int): Number of sensors update_intervals (list): List of update intervals for the sensors Returns: int: The earliest time for a complete report >>> earliest_report_time(3, [1, 2, 3]) 6 >>> earliest_report_time(4, [5, 10, 15, 20]) 60 pass # Replace with implementation","solution":"import math from functools import reduce def lcm(a, b): Returns the least common multiple of a and b. return abs(a * b) // math.gcd(a, b) def lcm_multiple(numbers): Returns the least common multiple of a list of numbers. return reduce(lcm, numbers) def earliest_report_time(n, update_intervals): Returns the earliest time at which the central monitoring system can compile a complete report for the entire building. Parameters: n (int): Number of sensors update_intervals (list): List of update intervals for the sensors Returns: int: The earliest time for a complete report return lcm_multiple(update_intervals)"},{"question":"def longest_arithmetic_substring(S: str) -> int: Returns the length of the longest arithmetic substring in S. An arithmetic sequence is a sequence of numbers where the difference between any two consecutive numbers is the same. Args: S (str): A numerical string consisting of digits '0' through '9'. Returns: int: The length of the longest arithmetic substring. Examples: >>> longest_arithmetic_substring(\\"123459764320\\") 5 >>> longest_arithmetic_substring(\\"5\\") 1 pass # Unit tests def test_example_case(): assert longest_arithmetic_substring(\\"123459764320\\") == 5 def test_single_digit(): assert longest_arithmetic_substring(\\"5\\") == 1 def test_two_digits(): assert longest_arithmetic_substring(\\"58\\") == 2 def test_same_digits(): assert longest_arithmetic_substring(\\"1111111\\") == 7 def test_long_arithmetic_sequence(): assert longest_arithmetic_substring(\\"0123456789\\") == 10 def test_alternating_difference(): assert longest_arithmetic_substring(\\"121212\\") == 2 def test_decreasing_sequence(): assert longest_arithmetic_substring(\\"9876543210\\") == 10 def test_mixed_sequences(): assert longest_arithmetic_substring(\\"123421011111\\") == 5 def test_equal_substrings(): assert longest_arithmetic_substring(\\"1234512345\\") == 5","solution":"def longest_arithmetic_substring(S): Returns the length of the longest arithmetic substring in S. n = len(S) if n < 2: return n max_length = 1 current_length = 1 current_diff = None for i in range(1, n): diff = int(S[i]) - int(S[i - 1]) if current_diff is None or diff == current_diff: current_length += 1 else: current_length = 2 current_diff = diff max_length = max(max_length, current_length) return max_length"},{"question":"def will_exit_maze(test_cases: List[str]) -> List[str]: Determines if the light ray can reach the last corridor in the Mirror Maze. >>> will_exit_maze([\\"////\\", \\"//////\\", \\"\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> will_exit_maze([\\"\\", \\"\\"]) [\\"NO\\", \\"NO\\"] >>> will_exit_maze([\\"////\\", \\"/\\"]) [\\"YES\\", \\"YES\\"] >>> will_exit_maze([\\"//\\", \\"//////\\"]) [\\"YES\\", \\"YES\\"] >>> will_exit_maze([\\"/\\"]) [\\"YES\\"] >>> will_exit_maze([\\"/\\" * 100000]) [\\"YES\\"]","solution":"def will_exit_maze(test_cases): results = [] for mirrors in test_cases: n = len(mirrors) if '/' in mirrors: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Input reading function for testing purpose def read_input(): t = int(input()) test_cases = [] for _ in range(t): test_cases.append(input().strip()) return test_cases"},{"question":"def max_final_magical_value(t, test_cases): Determine the largest possible final magical value of the last remaining crystal. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing the number of crystals and their magical values. Returns: List[int]: The largest possible final magical value for each test case. Examples: >>> max_final_magical_value(1, [(3, [1, 2, 3])]) [3] >>> max_final_magical_value(1, [(4, [5, 1, 2, 9])]) [15] >>> max_final_magical_value(1, [(2, [8, 7])]) [15]","solution":"def max_final_magical_value(t, test_cases): results = [] for i in range(t): n, crystals = test_cases[i] # Perform bitwise XOR cumulatively over all crystal values max_xor_value = 0 for value in crystals: max_xor_value |= value results.append(max_xor_value) return results"},{"question":"def sum_even_numbers(a, b): Returns the sum of all even numbers between a and b inclusive. >>> sum_even_numbers(2, 8) 20 >>> sum_even_numbers(3, 7) 10 >>> sum_even_numbers(5, 5) 0 >>> sum_even_numbers(8, 2) 20","solution":"def sum_even_numbers(a, b): Returns the sum of all even numbers between a and b inclusive. if a > b: a, b = b, a # Ensure a starts with the nearest even number if it's odd if a % 2 != 0: a += 1 # Ensure b is the nearest even number if it's odd if b % 2 != 0: b -= 1 # Calculate number of terms in the sequence n = ((b - a) // 2) + 1 if a <= b else 0 # Sum of an arithmetic series: n/2 * (first term + last term) sum_even = n * (a + b) // 2 return sum_even"},{"question":"def generate_recipients(friends: List[str], num_days: int) -> List[List[str]]: Determine the sequence of recipients for each friend over the given number of days. >>> friends = [\\"alice\\", \\"bob\\", \\"charlie\\"] >>> num_days = 2 >>> generate_recipients(friends, num_days) [[\\"bob\\", \\"charlie\\", \\"alice\\"], [\\"charlie\\", \\"alice\\", \\"bob\\"]] >>> friends = [\\"anna\\", \\"bella\\", \\"carla\\", \\"diana\\"] >>> num_days = 3 >>> generate_recipients(friends, num_days) [[\\"bella\\", \\"carla\\", \\"diana\\", \\"anna\\"], [\\"carla\\", \\"diana\\", \\"anna\\", \\"bella\\"], [\\"diana\\", \\"anna\\", \\"bella\\", \\"carla\\"]]","solution":"def generate_recipients(friends, num_days): m = len(friends) recipients = [] for day in range(num_days): day_recipients = [] for i in range(m): day_recipients.append(friends[(i + day + 1) % m]) recipients.append(day_recipients) return recipients"},{"question":"def longest_substring(k: int, s: str) -> int: Find the length of the longest substring of s that contains at most k distinct characters. >>> longest_substring(2, \\"eceba\\") 3 >>> longest_substring(3, \\"aaabbcc\\") 7 >>> longest_substring(1, \\"aabbcc\\") 2 def process_test_cases(test_cases: List[Tuple[int, str]]) -> List[int]: Processes multiple test cases and returns results for each. >>> process_test_cases([(2, \\"eceba\\"), (3, \\"aaabbcc\\"), (1, \\"aabbcc\\")]) [3, 7, 2] from solution import process_test_cases def test_longest_substring_basic(): test_cases = [ (2, \\"eceba\\"), (3, \\"aaabbcc\\"), (1, \\"aabbcc\\") ] expected_results = [3, 7, 2] results = process_test_cases(test_cases) assert results == expected_results def test_longest_substring_edge_cases(): test_cases = [ (0, \\"a\\"), # Edge case: k=0, should return 0 (1, \\"\\"), # Edge case: empty string, should return 0 (1, \\"bbbb\\") # Single character repeated ] expected_results = [0, 0, 4] results = process_test_cases(test_cases) assert results == expected_results def test_longest_substring_varied_lengths(): test_cases = [ (2, \\"ababababab\\"), # Alternating characters (2, \\"aaabbbccc\\"), ] expected_results = [10, 6] results = process_test_cases(test_cases) assert results == expected_results def test_longest_substring_large_input(): test_cases = [ (3, \\"abc\\" * 10000) # very large input ] expected_results = [30000] results = process_test_cases(test_cases) assert results == expected_results","solution":"def longest_substring(k, s): from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 left = 0 char_count = defaultdict(int) max_length = 0 for right in range(n): char_count[s[right]] += 1 while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_length = max(max_length, right - left + 1) return max_length def process_test_cases(test_cases): results = [] for k, s in test_cases: results.append(longest_substring(k, s)) return results"},{"question":"def is_path_possible(N, M, grid): Determines if there is a path from the top-left corner to the bottom-right corner consisting of only 'G' cells. >>> is_path_possible(3, 3, [\\"GGG\\", \\"GWG\\", \\"GGG\\"]) \\"YES\\" >>> is_path_possible(3, 3, [\\"GGG\\", \\"WWW\\", \\"GGG\\"]) \\"NO\\" def main(N, M, grid): High-level function to check if there is a valid path in the grid. >>> main(3, 3, [\\"GGG\\", \\"GWG\\", \\"GGG\\"]) \\"YES\\" >>> main(3, 3, [\\"GGG\\", \\"WWW\\", \\"GGG\\"]) \\"NO\\"","solution":"def is_path_possible(N, M, grid): def dfs(x, y): if x < 0 or y < 0 or x >= N or y >= M or visited[x][y] or grid[x][y] == 'W': return False visited[x][y] = True if x == N - 1 and y == M - 1: return True if (dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1)): return True return False visited = [[False for _ in range(M)] for _ in range(N)] return dfs(0, 0) def main(N, M, grid): if grid[0][0] == 'W' or grid[N-1][M-1] == 'W': return \\"NO\\" if is_path_possible(N, M, grid): return \\"YES\\" else: return \\"NO\\""},{"question":"def max_droids(C: int, component_avail: List[int], D: int, droid_reqs: List[List[int]]) -> int: Determine the maximum number of completed droids that can be assembled given the available components and the requirements for each droid. Args: C (int): The number of different component types available. component_avail (List[int]): The quantity available for each component type. D (int): The number of different types of droids that can be constructed. droid_reqs (List[List[int]]): The required quantity of each component type for each droid. Returns: int: The maximum number of droid units that can potentially be constructed using the available components. Examples: >>> max_droids(3, [10, 6, 8], 2, [[2, 2, 2], [1, 1, 5]]) 3 >>> max_droids(2, [5, 10], 3, [[1, 2], [2, 5], [1, 1]]) 5 pass # Unit Test def test_max_droids(): assert max_droids(3, [10, 6, 8], 2, [[2, 2, 2], [1, 1, 5]]) == 3 assert max_droids(2, [5, 10], 3, [[1, 2], [2, 5], [1, 1]]) == 5 assert max_droids(3, [7, 5, 9], 2, [[3, 1, 2], [2, 2, 3]]) == 2 assert max_droids(2, [1, 1], 2, [[2, 2], [3, 3]]) == 0","solution":"def max_droids(C, component_avail, D, droid_reqs): max_droids_count = 0 for droid in range(D): count = float('inf') for i in range(C): if droid_reqs[droid][i] == 0: continue count = min(count, component_avail[i] // droid_reqs[droid][i]) max_droids_count = max(max_droids_count, count) return max_droids_count # Example usage C = 3 component_avail = [10, 6, 8] D = 2 droid_reqs = [ [2, 2, 2], [1, 1, 5] ] print(max_droids(C, component_avail, D, droid_reqs)) # Output: 3"},{"question":"def find_lcm_pair(k: int) -> tuple: Given a positive integer 'k', find a pair of integers (a, b) such that: 1. 1 <= a, b <= k 2. The least common multiple (LCM) of a and b is exactly k. Examples: >>> find_lcm_pair(8) (1, 8) >>> find_lcm_pair(7) (1, 7) >>> find_lcm_pair(12) (1, 12) >>> find_lcm_pair(1) (1, 1) >>> find_lcm_pair(1000000) (1, 1000000)","solution":"def find_lcm_pair(k): Returns a pair of integers (a, b) such that 1 <= a, b <= k and LCM(a, b) = k. :param k: A positive integer :return: A tuple (a, b) # The simplest pair that will satisfy the conditions is (1, k) return (1, k)"},{"question":"def k_th_tallest_student(heights: List[int], k: int) -> int: Determines the k-th tallest student from the list of heights. Parameters: heights (list of int): List of student heights. k (int): The k-th position to find in the sorted list. Returns: int: Height of the k-th tallest student or -1 if there are fewer than k students. Examples: >>> k_th_tallest_student([160, 150, 170, 180, 165], 3) 165 >>> k_th_tallest_student([180, 175, 170], 5) -1","solution":"def k_th_tallest_student(heights, k): Determines the k-th tallest student from the list of heights. Parameters: heights (list of int): List of student heights. k (int): The k-th position to find in the sorted list. Returns: int: Height of the k-th tallest student or -1 if there are fewer than k students. if len(heights) < k: return -1 heights.sort(reverse=True) return heights[k-1]"},{"question":"def robot_return_to_origin(movements: str) -> str: Determines if the robot returns to the origin after the given sequence of movements. >>> robot_return_to_origin(\\"UDLR\\") 'Yes' >>> robot_return_to_origin(\\"UUU\\") 'No' >>> robot_return_to_origin(\\"LRLR\\") 'Yes' >>> robot_return_to_origin(\\"URDLU\\") 'No'","solution":"def robot_return_to_origin(movements): Determines if the robot returns to the origin after the given sequence of movements. Parameters: movements (str): A string representing the sequence of movements. Returns: str: \\"Yes\\" if the robot returns to the origin, otherwise \\"No\\". x, y = 0, 0 for move in movements: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 if x == 0 and y == 0: return \\"Yes\\" else: return \\"No\\""},{"question":"def maximum_subtree_sum(N: int, node_values: List[int], edges: List[Tuple[int, int]]) -> int: Compute the maximum sum of any subtree in the tree. >>> maximum_subtree_sum(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 15 >>> maximum_subtree_sum(1, [10], []) 10 >>> maximum_subtree_sum(3, [1, 2, 3], [(1, 2), (2, 3)]) 6 >>> maximum_subtree_sum(4, [5, 3, 2, 7], [(1, 2), (1, 3), (1, 4)]) 17 >>> maximum_subtree_sum(7, [1, 2, 3, 4, 5, 6, 7], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) 28","solution":"def maximum_subtree_sum(N, node_values, edges): from collections import defaultdict def dfs(node, parent): subtotal = node_values[node - 1] for neighbor in tree[node]: if neighbor != parent: subtotal += dfs(neighbor, node) subtree_sums[node] = subtotal return subtotal # Initialize tree representation and other needed variables tree = defaultdict(list) subtree_sums = [0] * (N + 1) for u, v in edges: tree[u].append(v) tree[v].append(u) # Perform DFS to calculate subtree sums starting from the root (node 1) dfs(1, -1) # Return the maximum subtree sum found return max(subtree_sums[1:]) # Example usage N = 5 node_values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] print(maximum_subtree_sum(N, node_values, edges)) # Output: 15"},{"question":"def find_sequence(n: int, pairs: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Restore the sequence of players' numbers in the game \\"Number Chains\\". Args: n (int): the number of players pairs (List[Tuple[int, int]]): the pairs of numbers written down by each player Returns: List[Tuple[int, int]]: the original sequence of players' numbers from the first player to the last one. Examples: >>> find_sequence(3, [(5, 10), (1, 5), (10, 15)]) [(1, 5), (5, 10), (10, 15)] >>> find_sequence(2, [(1, 2), (2, 3)]) [(1, 2), (2, 3)]","solution":"def find_sequence(n, pairs): from collections import defaultdict next_dict = {} count_second_number = defaultdict(int) for a, b in pairs: next_dict[a] = b count_second_number[b] += 1 # Find start player start = None for a, b in pairs: if count_second_number[a] == 0: start = a break # Reconstruct the sequence result = [] while len(result) < n: result.append((start, next_dict[start])) start = next_dict[start] return result"},{"question":"def min_cost_to_equal_heights(n: int, heights: List[int]) -> int: Returns the minimum cost to make all toy structures the same height. The cost is computed by transforming all heights to the same median value. Parameters: n (int): number of toy structures. heights (list): list of heights of the toy structures. Returns: int: minimum cost Examples: >>> min_cost_to_equal_heights(5, [3, 1, 2, 2, 1]) 3 >>> min_cost_to_equal_heights(3, [5, 9, 15]) 10","solution":"def min_cost_to_equal_heights(n, heights): Returns the minimum cost to make all toy structures the same height. The cost is computed by transforming all heights to the same median value. Parameters: n (int): number of toy structures. heights (list): list of heights of the toy structures. Returns: int: minimum cost heights.sort() median = heights[n // 2] # use the median height total_cost = sum(abs(height - median) for height in heights) return total_cost"},{"question":"def traffic_light_control(V, E, edges, Tmax, N_vehicles, vehicle_info): Simulates the traffic light control system. Returns a list of light states for each time cycle. >>> traffic_light_control(6, 8, [(1, 2, 4), (2, 3, 3), (3, 4, 5), (4, 5, 2), (5, 6, 6), (6, 1, 7), (2, 5, 3), (3, 6, 4)], 10, 3, [(1, 1, 4), (2, 2, 6), (3, 3, 1)]) [\\"G\\", \\"R\\", \\"G\\", \\"R\\", \\"G\\", \\"R\\", \\"G\\", \\"R\\", \\"G\\", \\"R\\"] >>> traffic_light_control(2, 1, [(1, 2, 1)], 1, 0, []) [\\"G\\"] >>> traffic_light_control(3, 3, [(1, 2, 2), (2, 3, 2), (3, 1, 2)], 4, 1, [(1, 1, 3)]) [\\"G\\", \\"R\\", \\"G\\", \\"R\\"] >>> traffic_light_control(4, 4, [(1, 2, 3), (2, 3, 3), (3, 4, 3), (4, 1, 3)], 5, 0, []) [\\"G\\", \\"R\\", \\"G\\", \\"R\\", \\"G\\"]","solution":"def traffic_light_control(V, E, edges, Tmax, N_vehicles, vehicle_info): Simulates the traffic light control system. Returns a list of light states for each time cycle. light_states = [] # Initialize traffic light states, assuming the initial state is green. current_state = \\"G\\" for t in range(Tmax): light_states.append(current_state) # Alternate the state for the next cycle current_state = \\"R\\" if current_state == \\"G\\" else \\"G\\" return light_states"},{"question":"from typing import List, Tuple def lexicographically_smallest_list(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Given a list of integers, find the lexicographically smallest list possible by swapping any two adjacent elements any number of times. >>> lexicographically_smallest_list(2, [(3, [3, 2, 1]), (5, [1, 5, 3, 2, 4])]) [[1, 2, 3], [1, 2, 3, 4, 5]] >>> lexicographically_smallest_list(1, [(4, [4, 3, 2, 1])]) [[1, 2, 3, 4]] >>> lexicographically_smallest_list(3, [(2, [2, 1]), (6, [6, 5, 3, 2, 4, 1]), (4, [4, 1, 2, 3])]) [[1, 2], [1, 2, 3, 4, 5, 6], [1, 2, 3, 4]] pass","solution":"def lexicographically_smallest_list(t, test_cases): results = [] for case in test_cases: n, array = case sorted_array = sorted(array) results.append(sorted_array) return results"},{"question":"import math def count_open_lockers(n: int) -> int: Returns the number of lockers that remain open after n rounds. >>> count_open_lockers(6) 2 >>> count_open_lockers(10) 3","solution":"import math def count_open_lockers(n): Returns the number of lockers that remain open after n rounds. return int(math.sqrt(n))"},{"question":"class GameSystem: System to manage players and their scores in an online game. Supports the following operations: 1. Add a new player with a given initial score. 2. Update the score of a specific player. 3. Get the current score of a specific player. 4. Get the IDs of the top k players with the highest scores. >>> gs = GameSystem() >>> gs.add_player(1, 100) >>> gs.get_score(1) 100 >>> gs.update_score(1, 150) >>> gs.get_score(1) 150 >>> gs.add_player(2, 200) >>> gs.top_players(2) [2, 1] >>> gs.add_player(3, 150) >>> gs.top_players(2) [2, 3] def __init__(self): pass def add_player(self, player_id, initial_score): pass def update_score(self, player_id, new_score): pass def get_score(self, player_id): pass def top_players(self, num_players): pass","solution":"class GameSystem: def __init__(self): self.players = {} # player_id -> score self.order = [] # ordering of added player_ids def add_player(self, player_id, initial_score): if player_id not in self.players: self.players[player_id] = initial_score self.order.append(player_id) def update_score(self, player_id, new_score): if player_id in self.players: self.players[player_id] = new_score def get_score(self, player_id): return self.players.get(player_id, 0) def top_players(self, num_players): sorted_players = sorted(self.players.items(), key=lambda x: (-x[1], self.order.index(x[0]))) return [player_id for player_id, score in sorted_players[:num_players]]"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(17) True >>> is_prime(20) False def generate_rotations(s: str) -> List[str]: Generate all rotations of the string s. >>> generate_rotations(\\"123\\") [\\"123\\", \\"231\\", \\"312\\"] >>> generate_rotations(\\"111\\") [\\"111\\", \\"111\\", \\"111\\"] >>> generate_rotations(\\"12\\") [\\"12\\", \\"21\\"] def is_circular_prime(s: str) -> str: Check if the string s represents a circular prime. >>> is_circular_prime(\\"197\\") \\"YES\\" >>> is_circular_prime(\\"2\\") \\"YES\\" >>> is_circular_prime(\\"11\\") \\"YES\\" >>> is_circular_prime(\\"132\\") \\"NO\\" >>> is_circular_prime(\\"29\\") \\"NO\\"","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_rotations(s): Generate all rotations of the string s. rotations = [] for i in range(len(s)): rotations.append(s[i:] + s[:i]) return rotations def is_circular_prime(s): Check if the string s represents a circular prime. rotations = generate_rotations(s) for rot in rotations: if not is_prime(int(rot)): return \\"NO\\" return \\"YES\\""},{"question":"def buildings_with_unobstructed_view(heights): Determines the number of buildings that have an unobstructed view from the leftmost position. :param heights: List of integers representing the heights of buildings. :return: Integer, the number of buildings with an unobstructed view. pass def test_no_buildings(): assert buildings_with_unobstructed_view([]) == 0 def test_single_building(): assert buildings_with_unobstructed_view([10]) == 1 def test_all_buildings_decreasing_height(): assert buildings_with_unobstructed_view([5, 4, 3, 2, 1]) == 1 def test_all_buildings_increasing_height(): assert buildings_with_unobstructed_view([1, 2, 3, 4, 5]) == 5 def test_mixed_heights(): assert buildings_with_unobstructed_view([3, 7, 8, 3, 6, 1]) == 3 def test_same_height_buildings(): assert buildings_with_unobstructed_view([2, 2, 2, 2, 2]) == 1 def test_large_building_at_end(): assert buildings_with_unobstructed_view([1, 1, 1, 1, 10]) == 2 def test_large_building_at_beginnning(): assert buildings_with_unobstructed_view([10, 1, 1, 1, 1]) == 1","solution":"def buildings_with_unobstructed_view(heights): Determines the number of buildings that have an unobstructed view from the leftmost position. :param heights: List of integers representing the heights of buildings. :return: Integer, the number of buildings with an unobstructed view. if not heights: return 0 max_height = 0 count = 0 for height in heights: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def min_operations_to_non_decreasing(A: List[int]) -> int: Returns the minimum number of operations required to transform array A into a non-decreasing array. >>> min_operations_to_non_decreasing([3, 2, 5, 1, 6]) 5 >>> min_operations_to_non_decreasing([1, 2, 3]) 0 >>> min_operations_to_non_decreasing([4, 3, 2, 1]) 6 pass def test_case_1(): assert min_operations_to_non_decreasing([3, 2, 5, 1, 6]) == 5 def test_case_2(): assert min_operations_to_non_decreasing([1, 2, 3]) == 0 def test_case_3(): assert min_operations_to_non_decreasing([4, 3, 2, 1]) == 6 def test_case_4(): assert min_operations_to_non_decreasing([10, 10, 10]) == 0 def test_case_5(): assert min_operations_to_non_decreasing([1]) == 0 def test_case_6(): assert min_operations_to_non_decreasing([0, -1, -2, -3, -4]) == 10 def test_case_7(): assert min_operations_to_non_decreasing([5, 4, 3, 5, 6, 7, 2]) == 8 def test_case_8(): assert min_operations_to_non_decreasing([-1, 0, 1, 1, -1, 2, 3, 3, -2, 4]) == 7","solution":"def min_operations_to_non_decreasing(A): Returns the minimum number of operations required to transform array A into a non-decreasing array n = len(A) if n == 1: return 0 operations = 0 for i in range(1, n): if A[i] < A[i-1]: operations += A[i-1] - A[i] A[i] = A[i-1] return operations"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root): Determine if a binary tree is a valid Binary Search Tree (BST). The left subtree of a node contains only nodes with values less than the node's value. The right subtree of a node contains only nodes with values greater than the node's value. Both the left and right subtrees must also be binary search trees. def create_tree_from_list(tree_list): if not tree_list or tree_list[0][0] == -1: return None nodes = {} for val, left, right in tree_list: if val not in nodes: nodes[val] = TreeNode(val) node = nodes[val] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[tree_list[0][0]] def validate_bst_for_test_cases(test_cases): result = [] for case in test_cases: n, nodes = case tree = create_tree_from_list(nodes) result.append(isValidBST(tree)) return result def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): n = int(lines[idx]) nodes = [] for j in range(n): nodes.append(tuple(map(int, lines[idx + j + 1].split()))) test_cases.append((n, nodes)) idx += n + 1 return test_cases","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isValidBST(root): def validate(node, low=float('-inf'), high=float('inf')): # Empty trees are valid BSTs if not node: return True # The current node's value must be between low and high if node.val <= low or node.val >= high: return False # Recursively validate the left and right subtrees return validate(node.left, low, node.val) and validate(node.right, node.val, high) return validate(root) def create_tree_from_list(tree_list): if not tree_list or tree_list[0][0] == -1: return None nodes = {} for val, left, right in tree_list: if val not in nodes: nodes[val] = TreeNode(val) node = nodes[val] if left != -1: if left not in nodes: nodes[left] = TreeNode(left) node.left = nodes[left] if right != -1: if right not in nodes: nodes[right] = TreeNode(right) node.right = nodes[right] return nodes[tree_list[0][0]] def validate_bst_for_test_cases(test_cases): result = [] for case in test_cases: n, nodes = case tree = create_tree_from_list(nodes) result.append(isValidBST(tree)) return result def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): n = int(lines[idx]) nodes = [] for j in range(n): nodes.append(tuple(map(int, lines[idx + j + 1].split()))) test_cases.append((n, nodes)) idx += n + 1 return test_cases"},{"question":"from typing import List, Tuple def max_non_overlapping_routes(n: int, routes: List[Tuple[int, int]]) -> int: Computes the maximum number of non-overlapping delivery routes. Parameters: n (int): Number of delivery routes. routes (List[Tuple[int, int]]): List of routes with start and end times. Returns: int: Maximum number of non-overlapping routes. Examples: >>> max_non_overlapping_routes(5, [(1, 3), (2, 5), (3, 6), (6, 8), (8, 10)]) 4 >>> max_non_overlapping_routes(0, []) 0 >>> max_non_overlapping_routes(3, [(0, 1), (1, 2), (2, 3)]) 3 >>> max_non_overlapping_routes(3, [(0, 10), (1, 11), (2, 12)]) 1 >>> max_non_overlapping_routes(4, [(1, 4), (2, 5), (3, 6), (6, 8)]) 2 >>> max_non_overlapping_routes(3, [(1, 5), (1, 5), (1, 5)]) 1","solution":"def max_non_overlapping_routes(n, routes): Computes the maximum number of non-overlapping delivery routes. Parameters: n (int): Number of delivery routes. routes (List[Tuple[int, int]]): List of routes with start and end times. Returns: int: Maximum number of non-overlapping routes. # Sorting routes by their end times routes.sort(key=lambda route: route[1]) max_routes = 0 end_time = -1 for start, end in routes: if start >= end_time: # Take this route max_routes += 1 end_time = end return max_routes # Example to test the function: n = 5 routes = [ (1, 3), (2, 5), (3, 6), (6, 8), (8, 10) ] print(max_non_overlapping_routes(n, routes)) # Output should be 4"},{"question":"def shortest_path(n: int, m: int, grid: List[List[int]]) -> int: Find the shortest path from the top-left corner to the bottom-right corner of the grid. :param n: number of rows in the grid :param m: number of columns in the grid :param grid: 2D list representing the grid where 0 is traversable and 1 is blocked :return: the length of the shortest path or -1 if no path exists >>> shortest_path(3, 3, [[0, 0, 1], [0, 1, 0], [0, 0, 0]]) 5 >>> shortest_path(4, 4, [[0, 1, 0, 0], [0, 1, 0, 1], [0, 0, 0, 1], [1, 1, 0, 0]]) 7 >>> shortest_path(2, 2, [[0, 1], [1, 0]]) -1 >>> shortest_path(1, 1, [[0]]) 1 >>> shortest_path(2, 2, [[1, 0], [0, 0]]) -1 >>> shortest_path(2, 2, [[0, 0], [0, 1]]) -1","solution":"from collections import deque def shortest_path(n, m, grid): Find the shortest path from the top-left corner to the bottom-right corner of the grid. :param n: number of rows in the grid :param m: number of columns in the grid :param grid: 2D list representing the grid where 0 is traversable and 1 is blocked :return: the length of the shortest path or -1 if no path exists if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 directions = [(1,0), (0,1), (-1,0), (0,-1)] queue = deque([(0, 0, 1)]) # (row, col, distance) visited = set((0, 0)) while queue: x, y, distance = queue.popleft() if x == n - 1 and y == m - 1: return distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, distance + 1)) return -1"},{"question":"def fibonacci_sum(n): Returns the sum of the first n numbers in the Fibonacci sequence. >>> fibonacci_sum(1) == 0 >>> fibonacci_sum(2) == 1 >>> fibonacci_sum(3) == 2 >>> fibonacci_sum(4) == 4 >>> fibonacci_sum(5) == 7 >>> fibonacci_sum(6) == 12 >>> fibonacci_sum(7) == 20 >>> fibonacci_sum(8) == 33 def process_cases(t, cases): Process multiple test cases for the Fibonacci sum function. >>> process_cases(2, [4, 5]) == [4, 7] >>> process_cases(3, [1, 2, 3]) == [0, 1, 2] >>> process_cases(4, [6, 7, 8, 9]) == [12, 20, 33, 54]","solution":"def fibonacci_sum(n): Returns the sum of the first n numbers in the Fibonacci sequence. if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 total = a + b for _ in range(2, n): a, b = b, a + b total += b return total def process_cases(t, cases): Process multiple test cases for the Fibonacci sum function. results = [] for n in cases: results.append(fibonacci_sum(n)) return results"},{"question":"def minimal_maximum_difference(n: int, k: int) -> int: This function calculates the minimal possible value of the maximum difference in the number of students between any two groups. >>> minimal_maximum_difference(10, 3) 1 >>> minimal_maximum_difference(15, 4) 1 >>> minimal_maximum_difference(7, 3) 1 >>> minimal_maximum_difference(5, 5) 0 from solution import minimal_maximum_difference def test_case_1(): assert minimal_maximum_difference(10, 3) == 1 def test_case_2(): assert minimal_maximum_difference(15, 4) == 1 def test_case_3(): assert minimal_maximum_difference(7, 3) == 1 def test_case_4(): assert minimal_maximum_difference(5, 5) == 0 def test_case_5(): assert minimal_maximum_difference(20, 4) == 0 def test_case_6(): assert minimal_maximum_difference(9, 3) == 0 def test_case_7(): assert minimal_maximum_difference(100000, 99999) == 1 def test_case_8(): assert minimal_maximum_difference(100000, 2) == 0 def test_case_9(): assert minimal_maximum_difference(100000, 50000) == 0 def test_case_10(): assert minimal_maximum_difference(5, 3) == 1","solution":"def minimal_maximum_difference(n, k): This function calculates the minimal possible value of the maximum difference in the number of students between any two groups. Parameters: n (int): Number of students k (int): Number of groups Returns: int: Minimal possible value of the maximum difference # The number of students per group if distributed as evenly as possible base_group_size = n // k # Remaining students after even distribution remaining_students = n % k # If there are remaining students, the maximal difference will be 1 if remaining_students > 0: return 1 else: return 0"},{"question":"def decode_string(s: str) -> str: Decodes an encoded string according to the pattern k[encoded_string]. Parameters: s (str): Encoded string following the pattern k[encoded_string], where k is a number representing the number of repetitions for \`encoded_string\`. Returns: str: Decoded string. def test_decode_string_single_repetition(): assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" def test_decode_string_nested_repetition(): assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" def test_decode_string_multiple_patterns(): assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" def test_decode_string_no_repetition(): assert decode_string(\\"a\\") == \\"a\\" def test_decode_string_single_character_repetition(): assert decode_string(\\"10[a]\\") == \\"aaaaaaaaaa\\"","solution":"def decode_string(s: str) -> str: Decodes an encoded string according to the pattern k[encoded_string]. Parameters: s (str): Encoded string following the pattern k[encoded_string], where k is a number representing the number of repetitions for \`encoded_string\`. Returns: str: Decoded string. stack = [] for char in s: if char != ']': stack.append(char) else: # Process the substring inside the brackets substr = [] while stack and stack[-1] != '[': substr.append(stack.pop()) substr.reverse() stack.pop() # pop the '[' # Retrieve the number k k = [] while stack and stack[-1].isdigit(): k.append(stack.pop()) k.reverse() k = int(''.join(k)) # Repeat the substring k times and push back to stack decoded_string = ''.join(substr) * k stack.extend(decoded_string) # Join and return the final decoded string return ''.join(stack)"},{"question":"def longest_consecutive_subsequence(N, sequence): Given an integer N and a sequence of N integers, find the longest subsequence with consecutive elements differing by exactly 1. Args: N (int): The number of elements in the sequence. sequence (List[int]): The sequence of integers. Returns: int: The length of the longest subsequence where the absolute difference between consecutive elements is exactly 1. >>> longest_consecutive_subsequence(5, [10, 9, 4, 5, 4]) 3 >>> longest_consecutive_subsequence(6, [1, 2, 3, 2, 1, 5]) 5 >>> longest_consecutive_subsequence(1, [7]) 1 >>> longest_consecutive_subsequence(4, [1, 2, 3, 4]) 4 >>> longest_consecutive_subsequence(4, [4, 4, 4, 4]) 1 def process_test_cases(test_cases): Process multiple test cases for the longest_consecutive_subsequence function. Args: test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains the number of elements and the sequence of integers. Returns: List[int]: List with the results for each test case. >>> process_test_cases([(5, [10, 9, 4, 5, 4]), (6, [1, 2, 3, 2, 1, 5])]) [3, 5] >>> process_test_cases([(1, [7]), (4, [1, 2, 3, 4])]) [1, 4] >>> process_test_cases([(4, [4, 4, 4, 4])]) [1]","solution":"def longest_consecutive_subsequence(N, sequence): if N == 1: return 1 max_length = 1 current_length = 1 for i in range(1, N): if abs(sequence[i] - sequence[i - 1]) == 1: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length def process_test_cases(test_cases): results = [] for N, sequence in test_cases: results.append(longest_consecutive_subsequence(N, sequence)) return results"},{"question":"def max_books_on_shelf(N: int, W: int, books: List[Tuple[int, int]]) -> int: Determine the maximum number of books that can be placed on the shelf. The rule is that a book can only be placed on the shelf if its height is less than or equal to the height of the book immediately to its left. The width of the shelf is limited as well. Books can be placed next to each other if there is enough remaining width on the shelf, and the height condition is met. Args: N (int): The number of books. W (int): The maximum width of the shelf. books (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers representing the height and width of a book. Returns: int: The maximum number of books that can be placed on the shelf. >>> max_books_on_shelf(5, 10, [(5, 1), (6, 2), (4, 3), (3, 4), (2, 2)]) == 4 >>> max_books_on_shelf(4, 15, [(7, 5), (6, 4), (5, 3), (4, 2)]) == 4 >>> max_books_on_shelf(3, 8, [(5, 1), (3, 5), (4, 2)]) == 3 >>> max_books_on_shelf(1, 1, [(1, 1)]) == 1 >>> max_books_on_shelf(3, 10000, [(10000, 10000), (9999, 9999), (9998, 9998)]) == 1 >>> max_books_on_shelf(0, 10, []) == 0","solution":"def max_books_on_shelf(N, W, books): books.sort(key=lambda x: x[0]) dp = [0] * (W + 1) for h, w in books: for i in range(W, w - 1, -1): dp[i] = max(dp[i], dp[i - w] + 1) return max(dp)"},{"question":"def minimum_moves_to_equalize_stacks(n: int, arr: List[int]) -> int: Returns the minimum number of move operations required to make all stacks in the array have the same height. Args: n (int): Number of stacks. arr (List[int]): Heights of each stack. Returns: int: Minimum number of move operations required. Examples: >>> minimum_moves_to_equalize_stacks(5, [1, 1, 1, 1, 1]) 0 >>> minimum_moves_to_equalize_stacks(4, [1, 2, 1, 2]) 2 >>> minimum_moves_to_equalize_stacks(3, [1, 0, 5]) 6","solution":"def minimum_moves_to_equalize_stacks(n, arr): Returns the minimum number of move operations required to make all stacks in the array have the same height. target_height = sum(arr) // n moves = sum(abs(height - target_height) for height in arr) return moves"},{"question":"def can_rearrange_books(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if it's possible to rearrange the books such that no two consecutive books have the same height. >>> can_rearrange_books(3, [ ... (5, [3, 1, 2, 3, 4]), ... (4, [1, 1, 1, 1]), ... (6, [4, 5, 4, 4, 6, 4]) ... ]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> can_rearrange_books(1, [(6, [4, 5, 4, 4, 6, 4])]) [\\"NO\\"]","solution":"def can_rearrange_books(t, test_cases): def is_possible(n, heights): from collections import Counter counter = Counter(heights) most_common_count = counter.most_common(1)[0][1] # Only need one book of each remaining height, hence (remaining unique) ≥ (most common count - 1) if most_common_count > (n + 1) // 2: return \\"NO\\" else: return \\"YES\\" results = [] for i in range(t): n, heights = test_cases[i] results.append(is_possible(n, heights)) return results"},{"question":"def longest_subsequence_length(n: int, k: int, array: List[int]) -> int: Find the length of the longest subsequence where the difference between the maximum and the minimum element of the subsequence is at most k. >>> longest_subsequence_length(7, 5, [1, 3, 6, 2, 9, 5, 8]) 5 >>> longest_subsequence_length(5, 0, [1, 1, 1, 2, 3]) 3","solution":"def longest_subsequence_length(n, k, array): array.sort() max_length = 0 i = 0 for j in range(n): while array[j] - array[i] > k: i += 1 max_length = max(max_length, j - i + 1) return max_length"},{"question":"from typing import List, Tuple def max_sub_array_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers, answer several queries about sub-arrays. Each query provides a range of indices within which you need to determine the maximum sum of any contiguous sub-array. The length of the array and the number of queries may be large, so consider the efficiency of your solution. >>> max_sub_array_sum([1, -2, 3, 4, -5], [(1, 3), (2, 5), (1, 5)]) [3, 7, 7] >>> max_sub_array_sum([-5], [(1, 1)]) [-5] >>> max_sub_array_sum([1, 2, 3, 4, 5], [(1, 5), (1, 3), (3, 5)]) [15, 6, 12] >>> max_sub_array_sum([0] * 100 + [1, -2, 3, 4, -5] + [0] * 100, [(1, 205)]) [7] >>> max_sub_array_sum([10, -1, 2, -3, 4, -5], [(3, 4), (1, 6), (4, 6)]) [2, 12, 4] def test_max_sub_array_sum(): assert max_sub_array_sum([1, -2, 3, 4, -5], [(1, 3), (2, 5), (1, 5)]) == [3, 7, 7] assert max_sub_array_sum([-5], [(1, 1)]) == [-5] assert max_sub_array_sum([1, 2, 3, 4, 5], [(1, 5), (1, 3), (3, 5)]) == [15, 6, 12] assert max_sub_array_sum([0] * 100 + [1, -2, 3, 4, -5] + [0] * 100, [(1, 205)]) == [7] assert max_sub_array_sum([10, -1, 2, -3, 4, -5], [(3, 4), (1, 6), (4, 6)]) == [2, 12, 4]","solution":"def max_sub_array_sum(arr, queries): def kadane(arr): max_sum = float('-inf') current_sum = 0 for value in arr: current_sum = max(value, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum results = [] for l, r in queries: sub_array = arr[l-1:r] results.append(kadane(sub_array)) return results"},{"question":"def can_drone_complete_journey(n, route, m, interceptors): Determine if the drone can complete its journey without being intercepted. Parameters: - n (int): Number of coordinates in the route - route (list of int): Coordinates of the route - m (int): Number of interceptor positions - interceptors (list of int): Interceptor positions Returns: - str: \\"SAFE\\" if the drone can complete the journey, \\"INTERCEPTED\\" otherwise Examples: >>> can_drone_complete_journey(4, [10, 20, 30, 40], 1, [25]) 'SAFE' >>> can_drone_complete_journey(5, [1, 2, 3, 4, 5], 2, [3, 5]) 'INTERCEPTED'","solution":"def can_drone_complete_journey(n, route, m, interceptors): Determine if the drone can complete its journey without being intercepted. Parameters: - n (int): Number of coordinates in the route - route (list of int): Coordinates of the route - m (int): Number of interceptor positions - interceptors (list of int): Interceptor positions Returns: - str: \\"SAFE\\" if the drone can complete the journey, \\"INTERCEPTED\\" otherwise # Create a set of interceptor positions for quick lookup interceptor_set = set(interceptors) # Check if any route coordinate is in the interceptor positions for coordinate in route: if coordinate in interceptor_set: return \\"INTERCEPTED\\" return \\"SAFE\\""},{"question":"def minimum_weight_difference(n: int, weights: List[int]) -> int: Determines the minimum possible absolute difference between the total weights of the two groups. The input is taken as: n (int): number of boxes weights (List[int]): list containing weights of the boxes Returns: int: minimum possible absolute difference between the total weights of the two groups. >>> minimum_weight_difference(4, [1, 2, 3, 4]) 0 >>> minimum_weight_difference(5, [3, 1, 4, 2, 2]) 0 >>> minimum_weight_difference(1, [1]) 1 >>> minimum_weight_difference(4, [2, 2, 4, 4]) 0 >>> minimum_weight_difference(3, [5, 3, 4]) 2","solution":"def minimum_weight_difference(n, weights): Determines the minimum possible absolute difference between the total weights of the two groups. total_weight = sum(weights) target = total_weight // 2 dp = [0] * (target + 1) for weight in weights: for j in range(target, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) closest = dp[target] difference = abs(total_weight - 2 * closest) return difference"},{"question":"def process_rides(requests): Processes ride requests and returns matches based on compatibility criteria. Args: requests (list): A list of dictionaries where each dictionary represents a rider's request. Returns: None: Print the list of matches for each rider request. Example: >>> requests = [ {\\"rider_id\\": 1, \\"desired_riders\\": 3, \\"earliest_start\\": 300, \\"latest_arrival\\": 600}, {\\"rider_id\\": 2, \\"desired_riders\\": 3, \\"earliest_start\\": 320, \\"latest_arrival\\": 580}, {\\"rider_id\\": 3, \\"desired_riders\\": 2, \\"earliest_start\\": 400, \\"latest_arrival\\": 700}, {\\"rider_id\\": 4, \\"desired_riders\\": 3, \\"earliest_start\\": 310, \\"latest_arrival\\": 590}, {\\"rider_id\\": 5, \\"desired_riders\\": 3, \\"earliest_start\\": 350, \\"latest_arrival\\": 650}, {\\"rider_id\\": 6, \\"desired_riders\\": 4, \\"earliest_start\\": 300, \\"latest_arrival\\": 600}, ] >>> process_rides(requests) 1: no match 2: match 1 2 3: no match 4: match 1 2 4 5: match 2 4 5 6: no match # Implement the function here import pytest def test_solution(): requests = [ {\\"rider_id\\": 1, \\"desired_riders\\": 3, \\"earliest_start\\": 300, \\"latest_arrival\\": 600}, {\\"rider_id\\": 2, \\"desired_riders\\": 3, \\"earliest_start\\": 320, \\"latest_arrival\\": 580}, {\\"rider_id\\": 3, \\"desired_riders\\": 2, \\"earliest_start\\": 400, \\"latest_arrival\\": 700}, {\\"rider_id\\": 4, \\"desired_riders\\": 3, \\"earliest_start\\": 310, \\"latest_arrival\\": 590}, {\\"rider_id\\": 5, \\"desired_riders\\": 3, \\"earliest_start\\": 350, \\"latest_arrival\\": 650}, {\\"rider_id\\": 6, \\"desired_riders\\": 4, \\"earliest_start\\": 300, \\"latest_arrival\\": 600}, ] expected_output = [ \\"1: no match\\", \\"2: match 1 2\\", \\"3: no match\\", \\"4: match 1 2 4\\", \\"5: match 2 4 5\\", \\"6: no match\\", ] process_rides(requests) # Here we capture the output to a list for verification - remove this comment and implement capture # Run the tests pytest.main()","solution":"def process_rides(requests): Processes ride requests and returns matches based on compatibility criteria. def is_compatible(rider1, rider2): Checks if rider1 and rider2 are compatible based on the given rules. start_time = max(rider1[\\"earliest_start\\"], rider2[\\"earliest_start\\"]) arrival_time = min(rider1[\\"latest_arrival\\"], rider2[\\"latest_arrival\\"]) if start_time > arrival_time: return False return rider1[\\"desired_riders\\"] == rider2[\\"desired_riders\\"] riders = [] matches = {} for rider in requests: rider_id = rider['rider_id'] possible_matches = [] for other_rider in riders: if is_compatible(rider, other_rider): possible_matches.append(other_rider[\\"rider_id\\"]) if len(possible_matches) >= rider[\\"desired_riders\\"] - 1: possible_riders = possible_matches[:rider[\\"desired_riders\\"] - 1] possible_riders.append(rider_id) for r in possible_riders: matches[r] = possible_riders result = f\\"{rider_id}: match \\" + \\" \\".join(map(str, possible_riders)) else: matches[rider_id] = [] result = f\\"{rider_id}: no match\\" riders.append(rider) print(result) # Example Usage requests = [ {\\"rider_id\\": 1, \\"desired_riders\\": 3, \\"earliest_start\\": 300, \\"latest_arrival\\": 600}, {\\"rider_id\\": 2, \\"desired_riders\\": 3, \\"earliest_start\\": 320, \\"latest_arrival\\": 580}, {\\"rider_id\\": 3, \\"desired_riders\\": 2, \\"earliest_start\\": 400, \\"latest_arrival\\": 700}, {\\"rider_id\\": 4, \\"desired_riders\\": 3, \\"earliest_start\\": 310, \\"latest_arrival\\": 590}, {\\"rider_id\\": 5, \\"desired_riders\\": 3, \\"earliest_start\\": 350, \\"latest_arrival\\": 650}, {\\"rider_id\\": 6, \\"desired_riders\\": 4, \\"earliest_start\\": 300, \\"latest_arrival\\": 600}, ] process_rides(requests)"},{"question":"from typing import List def min_moves_to_reach_target(m: int, n: int, grid: List[List[int]], sr: int, sc: int, tr: int, tc: int) -> int: Determine the minimum number of moves required for the robot to reach the target dirty cell. If the target is unreachable, return -1. :param m: number of rows in the grid :param n: number of columns in the grid :param grid: the grid room represented by m x n matrix with 0 for cleanable cells and 1 for obstacles :param sr: starting row index of the robot :param sc: starting column index of the robot :param tr: target row index of the dirty cell :param tc: target column index of the dirty cell :return: minimum number of moves required to reach the target dirty cell, or -1 if unreachable >>> min_moves_to_reach_target(5, 5, [[0, 0, 1, 0, 0], [0, 0, 1, 1, 0], [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]], 0, 0, 3, 4) 7 >>> min_moves_to_reach_target(3, 3, [[0, 1, 0], [1, 0, 1], [0, 1, 0]], 0, 0, 2, 2) -1","solution":"from collections import deque def min_moves_to_reach_target(m, n, grid, sr, sc, tr, tc): if grid[sr][sc] == 1 or grid[tr][tc] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(sr, sc, 0)]) # (current row, current column, current move count) visited = set((sr, sc)) while queue: r, c, moves = queue.popleft() if (r, c) == (tr, tc): return moves for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < m and 0 <= nc < n and (nr, nc) not in visited and grid[nr][nc] == 0: queue.append((nr, nc, moves + 1)) visited.add((nr, nc)) return -1"},{"question":"def rotate_and_sum(n, k, arr): Rotates the array \`arr\` to the right by \`k\` positions and returns the sum of the elements. Parameters: n (int): The number of elements in the array. k (int): The number of rotations to the right. arr (list of int): The array to be rotated. Returns: int: The sum of the elements of the rotated array. Examples: >>> rotate_and_sum(5, 2, [3, 8, 9, 7, 6]) 33 >>> rotate_and_sum(3, 0, [1, 2, 3]) 6 >>> rotate_and_sum(4, 4, [1, 2, 3, 4]) 10 >>> rotate_and_sum(4, 1, [1, 2, 3, 4]) 10 >>> rotate_and_sum(4, 2, [1, -2, 3, -4]) -2 >>> rotate_and_sum(5, 7, [1, 2, 3, 4, 5]) 15 >>> rotate_and_sum(5, 3, [0, 0, 0, 0, 0]) 0","solution":"def rotate_and_sum(n, k, arr): Rotates the array \`arr\` to the right by \`k\` positions and returns the sum of the elements. Parameters: n (int): The number of elements in the array. k (int): The number of rotations to the right. arr (list of int): The array to be rotated. Returns: int: The sum of the elements of the rotated array. # Perform the rotation k = k % n # In case k is greater than n rotated_arr = arr[-k:] + arr[:-k] # Calculate the sum of the rotated array return sum(rotated_arr)"},{"question":"def max_non_overlapping_launches(N, launch_windows): Determine the maximum number of non-overlapping satellites that can be launched using the given schedule. :param N: int, number of satellites. :param launch_windows: list of tuples, each representing the start and end time of the launch window for each satellite. :return: int, maximum number of non-overlapping satellites. >>> max_non_overlapping_launches(6, [(1, 4), (2, 3), (3, 5), (0, 6), (5, 7), (8, 9)]) 4 >>> max_non_overlapping_launches(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_launches(3, [(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_launches(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) 2 >>> max_non_overlapping_launches(1, [(1, 2)]) 1 >>> max_non_overlapping_launches(1000, [(i, i+1) for i in range(1000)]) 1000","solution":"def max_non_overlapping_launches(N, launch_windows): Returns the maximum number of non-overlapping satellites that can be launched. :param N: int, number of satellites. :param launch_windows: list of tuples, each representing the start and end time of the launch window for each satellite. :return: int, maximum number of non-overlapping satellites. # First, sort the launch windows by their end times launch_windows.sort(key=lambda x: x[1]) max_launches = 0 current_time = 0 for start, end in launch_windows: if start >= current_time: max_launches += 1 current_time = end return max_launches"},{"question":"def process_instructions_and_queries(N: int, D: int, instructions: List[Tuple[int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Given a set of N integers, modify the array by processing D instructions and then determine the sum of the values in the modified array based on Q queries. Args: N : int : number of integers in the array D : int : number of instructions instructions : List[Tuple[int, int]] : list of instructions where each item is a tuple (P, K) Q : int : number of queries queries : List[Tuple[int, int]] : list of queries where each item is a tuple (L, R) Returns: List[int] : list of results for each query Example: >>> process_instructions_and_queries(5, 3, [(1, 5), (2, 3), (5, 2)], 2, [(1, 5), (2, 4)]) [10, 3]","solution":"def process_instructions_and_queries(N, D, instructions, Q, queries): array = [0] * N # Apply each instruction for P, K in instructions: array[P-1] += K # Precompute prefix sums prefix_sums = [0] * (N + 1) for i in range(1, N + 1): prefix_sums[i] = prefix_sums[i-1] + array[i-1] result = [] for L, R in queries: result.append(prefix_sums[R] - prefix_sums[L-1]) return result"},{"question":"def min_socks_to_guarantee_pair(n): Returns the minimum number of socks to pick to guarantee at least one matching pair. Parameters: n (int): Number of pairs of socks in the drawer. Returns: int: Minimum number of socks to pick. pass def test_min_socks_to_guarantee_pair(): assert min_socks_to_guarantee_pair(2) == 3 assert min_socks_to_guarantee_pair(4) == 5 assert min_socks_to_guarantee_pair(1) == 2 assert min_socks_to_guarantee_pair(10) == 11 assert min_socks_to_guarantee_pair(1000) == 1001","solution":"def min_socks_to_guarantee_pair(n): Returns the minimum number of socks to pick to guarantee at least one matching pair. Parameters: n (int): Number of pairs of socks in the drawer. Returns: int: Minimum number of socks to pick. # The worst case is if we pick one sock from each pair without forming any pair. # Therefore, we need to pick at most one additional sock after picking one from each pair return n + 1"},{"question":"def distinct_characters(T: int, test_cases: List[Tuple[str, List[Tuple[int, int]]]]) -> List[int]: Given a number of test cases, where each test case contains a string and a list of queries, determine the number of distinct characters in each substring specified by the queries. Args: T (int): The number of test cases. test_cases (List[Tuple[str, List[Tuple[int, int]]]]): A list of test cases, where each test case is a tuple containing a string and a list of query tuples. Returns: List[int]: A list containing the result for each query in each test case. >>> distinct_characters(2, [(\\"abcabc\\", [(0, 3), (1, 4)]), (\\"aaaaaaa\\", [(0, 7)])]) [3, 3, 1] # Your implementation here","solution":"def distinct_characters(T, test_cases): results = [] for case in test_cases: S, queries = case for L, R in queries: substr = S[L:R] distinct_chars = len(set(substr)) results.append(distinct_chars) return results # Example usage: # T = 2 # test_cases = [ # (\\"abcabc\\", [(0, 3), (1, 4)]), # (\\"aaaaaaa\\", [(0, 7)]) # ] # print(distinct_characters(T, test_cases)) # Output should be: # [3, 3, 1]"},{"question":"def calculate_weights(N: int, Q: int, S: str, P: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the weights of substrings based on given queries. :param N: Integer, the length of the string S :param Q: Integer, the number of queries :param S: String, the input string of length N :param P: List of integers, the power array corresponding to each character in the string :param queries: List of tuples, each containing two integers (L, R) :return: List of integers, the weights for each query >>> calculate_weights(5, 3, 'abcde', [1, 2, 3, 4, 5], [(1, 3), (2, 5), (1, 5)]) [6, 14, 15] >>> calculate_weights(1, 1, 'a', [10], [(1, 1)]) [10] >>> calculate_weights(4, 1, 'abcd', [10, 20, 30, 40], [(1, 4)]) [100] >>> calculate_weights(5, 4, 'abcde', [1, 2, 3, 4, 5], [(1, 1), (1, 2), (1, 3), (1, 4)]) [1, 3, 6, 10] >>> calculate_weights(5, 2, 'abcde', [1000000, 2000000, 3000000, 4000000, 5000000], [(1, 3), (2, 5)]) [6000000, 14000000]","solution":"def calculate_weights(N, Q, S, P, queries): Calculate the weights of substrings based on given queries. :param N: Integer, the length of the string S :param Q: Integer, the number of queries :param S: String, the input string of length N :param P: List of integers, the power array corresponding to each character in the string :param queries: List of tuples, each containing two integers (L, R) :return: List of integers, the weights for each query # Convert string positions in queries to 0-based index and calculate prefix sums prefix_sums = [0] * (N + 1) for i in range(N): prefix_sums[i + 1] = prefix_sums[i] + P[i] result = [] for L, R in queries: result.append(prefix_sums[R] - prefix_sums[L - 1]) return result"},{"question":"from typing import List def find_missing_pages(n: int, notebook_pages: List[int], m: int, present_pages: List[int]) -> List[int]: Determine the numbers of the missing pages in ascending order. Parameters: n (int): The total number of pages in the notebook. notebook_pages (List[int]): A list of integers representing the number on each page of the notebook, in arbitrary order. m (int): The number of present pages. present_pages (List[int]): A list of integers representing the numbers of the present pages, in arbitrary order. Returns: List[int]: A list of integers representing the numbers of the missing pages in ascending order. Examples: >>> find_missing_pages(5, [1, 3, 5, 7, 9], 3, [1, 5, 7]) [3, 9] >>> find_missing_pages(5, [1, 2, 3, 4, 5], 5, [1, 2, 3, 4, 5]) [] >>> find_missing_pages(5, [1, 2, 3, 4, 5], 0, []) [1, 2, 3, 4, 5] >>> find_missing_pages(0, [], 0, []) [] >>> find_missing_pages(4, [10, 20, 30, 40], 2, [10, 30]) [20, 40]","solution":"def find_missing_pages(n, notebook_pages, m, present_pages): Returns the numbers of the missing pages in ascending order. Parameters: n (int): The total number of pages in the notebook. notebook_pages (list): A list of integers representing pages in the notebook. m (int): The number of present pages. present_pages (list): A list of integers representing the present pages. Returns: list: A list of integers representing the missing pages in ascending order. notebook_set = set(notebook_pages) present_set = set(present_pages) missing_pages = sorted(notebook_set - present_set) return missing_pages"},{"question":"def can_rearrange_to_diff_of_one(sequence: List[int]) -> str: Determines if it's possible to rearrange the sequence so that the difference between any two consecutive elements is exactly one. Args: sequence: List[int] - A list of integers representing the sequence. Returns: str - \\"YES\\" if it's possible, \\"NO\\" otherwise. >>> can_rearrange_to_diff_of_one([3, 7, 8, 6]) \\"NO\\" >>> can_rearrange_to_diff_of_one([1, 3, 2, 4]) \\"YES\\"","solution":"def can_rearrange_to_diff_of_one(sequence): Determines if it's possible to rearrange the sequence so that the difference between any two consecutive elements is exactly one. Args: sequence: List[int] - A list of integers representing the sequence. Returns: str - \\"YES\\" if it's possible, \\"NO\\" otherwise. if len(sequence) < 2: return \\"NO\\" sequence = sorted(sequence) for i in range(1, len(sequence)): if sequence[i] - sequence[i - 1] != 1: return \\"NO\\" return \\"YES\\""},{"question":"def determine_winner(a: int, k: int, m: int, b: List[int]) -> str: Determines the winner of the game given the initial integer a, the length of the sequence k, and the set of integers that can be added to the sequence b. >>> determine_winner(2, 3, 2, [1, 2]) \\"Alice\\" >>> determine_winner(1, 4, 3, [2, 3, 5]) \\"Bob\\"","solution":"def determine_winner(a, k, m, b): Determines the winner of the game given the initial integer a, the length of the sequence k, and the set of integers that can be added to the sequence b. # If the sequence length is odd, Alice wins if the starting number is even, Bob wins otherwise. if k % 2 == 1: return \\"Alice\\" if a % 2 == 0 else \\"Bob\\" else: # The final number's parity only depends on the parity of the starting number \`a\` and the parities of numbers in \`b\`. if all(x % 2 == 0 for x in b): return \\"Alice\\" if a % 2 == 0 else \\"Bob\\" else: return \\"Bob\\" if a % 2 == 0 else \\"Bob\\""},{"question":"def sum_of_digits(num: int) -> int: Returns the sum of the digits of the given integer num. >>> sum_of_digits(123) 6 >>> sum_of_digits(456) 15 >>> sum_of_digits(7890) 24 def process_input(T: int, numbers: List[int]) -> List[int]: Processes a list of numbers and applies sum_of_digits function to each number. Returns a list of the results. >>> process_input(3, [123, 456, 7890]) [6, 15, 24] >>> process_input(1, [1]) [1] >>> process_input(2, [100, 200]) [1, 2] >>> process_input(0, []) []","solution":"def sum_of_digits(num): Returns the sum of the digits of the given integer num. return sum(int(digit) for digit in str(num)) def process_input(T, numbers): Processes a list of numbers and applies sum_of_digits function to each number. Returns a list of the results. results = [sum_of_digits(num) for num in numbers] return results"},{"question":"def max_delivery_sum(n: int, m: int, k: int, delivery: List[int]) -> int: Returns the maximum total sum of values from selecting exactly k non-overlapping ranges of length m. Parameters: n (int): The total number of deliveries. m (int): The length of each range to be selected. k (int): The number of ranges to select. delivery (List[int]): A list of delivery amounts. Returns: int: The maximum total sum of the values from selecting exactly k non-overlapping ranges of length m. Examples: >>> max_delivery_sum(8, 3, 2, [3, 1, 4, 1, 5, 9, 2, 6]) 27 >>> max_delivery_sum(10, 2, 2, [7, 6, 3, 5, 2, 8, 9, 0, 4, 1]) 30 pass","solution":"def max_delivery_sum(n, m, k, delivery): Returns the maximum total sum of values from selecting exactly k non-overlapping ranges of length m. # Calculate prefix sums to support quick range sum calculations prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + delivery[i] # Define dp array dp = [[0] * (k + 1) for _ in range(n + 1)] for j in range(1, k + 1): for i in range(j * m, n + 1): dp[i][j] = max(dp[i - m][j - 1] + (prefix_sums[i] - prefix_sums[i - m]), dp[i - 1][j]) return dp[n][k]"},{"question":"def max_dishes_washed(N: int, M: int, K: int, A: List[int], B: List[int]) -> int: Calculate the maximum number of dishes that can be washed from two sets within K minutes. >>> max_dishes_washed(3, 4, 240, [60, 90, 120], [80, 150, 80, 150]) 3 >>> max_dishes_washed(3, 4, 730, [60, 90, 120], [80, 150, 80, 150]) 7 >>> max_dishes_washed(5, 4, 1, [1000000000, 1000000000, 1000000000, 1000000000, 1000000000], [1000000000, 1000000000, 1000000000, 1000000000]) 0 >>> max_dishes_washed(3, 3, 0, [1, 2, 3], [4, 5, 6]) 0 >>> max_dishes_washed(3, 3, 6, [1, 2, 3], [4, 5, 6]) 3 >>> max_dishes_washed(1, 1, 2, [1], [1]) 2","solution":"def max_dishes_washed(N, M, K, A, B): A.sort() B.sort() prefix_sum_A = [0] * (N + 1) prefix_sum_B = [0] * (M + 1) for i in range(1, N + 1): prefix_sum_A[i] = prefix_sum_A[i - 1] + A[i - 1] for i in range(1, M + 1): prefix_sum_B[i] = prefix_sum_B[i - 1] + B[i - 1] max_dishes = 0 j = M for i in range(N + 1): if prefix_sum_A[i] <= K: while j > 0 and prefix_sum_A[i] + prefix_sum_B[j] > K: j -= 1 max_dishes = max(max_dishes, i + j) return max_dishes"},{"question":"def has_overlap(n: int, tasks: List[Tuple[int, int]]) -> str: Determines if there is any overlap among the scheduled tasks. >>> has_overlap(3, [(1, 3), (2, 5), (6, 8)]) \\"YES\\" >>> has_overlap(2, [(2, 5), (5, 7)]) \\"NO\\"","solution":"def has_overlap(n, tasks): Determines if any tasks overlap. :param n: Number of tasks :param tasks: List of tuples representing start and end times of each task :return: \\"YES\\" if there is an overlap, otherwise \\"NO\\" # Sort the tasks by start time tasks.sort() # Check for any overlap for i in range(1, n): if tasks[i-1][1] > tasks[i][0]: return \\"YES\\" return \\"NO\\""},{"question":"def knapsack(N, W, items): Returns the maximum total value of items that can be put into the box with capacity W using the given items with their weights and values. Example: >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> knapsack(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90","solution":"def knapsack(N, W, items): Returns the maximum total value of items that can be put into the box with capacity W using the given items with their weights and values. # Initialize DP table dp = [[0] * (W + 1) for _ in range(N + 1)] for i in range(1, N + 1): weight, value = items[i - 1] for w in range(W + 1): if weight > w: dp[i][w] = dp[i - 1][w] else: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) return dp[N][W] def knapsack_from_input(): import sys input = sys.stdin.read data = input().strip().split() N = int(data[0]) W = int(data[1]) items = [(int(data[i*2+2]), int(data[i*2+3])) for i in range(N)] print(knapsack(N, W, items))"},{"question":"from typing import List def max_visitors(logs: List[str]) -> int: This function takes a list of log entries and returns the maximum number of visitors in the zoo at any given time. >>> max_visitors([\\"3 enter\\", \\"5 enter\\", \\"7 enter\\", \\"8 exit\\", \\"10 exit\\", \\"12 exit\\", \\"0\\"]) == 3 >>> max_visitors([\\"2 enter\\", \\"4 exit\\", \\"8 enter\\", \\"10 enter\\", \\"12 exit\\", \\"15 exit\\", \\"0\\"]) == 2 pass def process_input(input_data: str) -> List[int]: Processes the multiline input data and returns the results as a list. >>> process_input(3 enter 5 enter 7 enter 8 exit 10 exit 12 exit 0 2 enter 4 exit 8 enter 10 enter 12 exit 15 exit 0 #) == [3, 2] >>> process_input(1 enter 2 enter 3 enter 4 exit 5 exit 6 exit 0 5 enter 6 enter 7 enter 8 exit 9 exit 10 exit 0 #) == [3, 3] pass","solution":"def max_visitors(logs): This function takes a list of log entries and returns the maximum number of visitors in the zoo at any given time. max_count = 0 current_count = 0 for log in logs: if log == \\"0\\": return max_count time_stamp, event = log.split() if event == \\"enter\\": current_count += 1 elif event == \\"exit\\": current_count -= 1 max_count = max(max_count, current_count) return max_count def process_input(input_data): Processes the multiline input data and returns the results as a list. datasets = input_data.split(\\"n#\\")[0].strip().split(\\"n0n\\") result = [] for data in datasets: logs = data.strip().split(\\"n\\") result.append(max_visitors(logs)) return result"},{"question":"from typing import List def arrayPairSum(nums: List[int]) -> int: Returns the maximum sum of min(a_i, b_i) pairs that you can get by pairing elements from the array. >>> arrayPairSum([1, 4, 3, 2]) 4 >>> arrayPairSum([-1, -4, -3, -2]) -6 >>> arrayPairSum([6, 2, 6, 5, 1, 2]) 9 >>> arrayPairSum(list(range(1, 101))) 2500 >>> arrayPairSum([1, 1, 1, 1, 1, 1]) 3 >>> arrayPairSum([1, 2]) 1","solution":"from typing import List def arrayPairSum(nums: List[int]) -> int: Returns the maximum sum of min(a_i, b_i) pairs that you can get by pairing elements from the array. # Sort the nums array nums.sort() # Initialize sum to 0 max_sum = 0 # Iterate through the sorted array in steps of 2 to sum up the minimum elements of pairs for i in range(0, len(nums), 2): max_sum += nums[i] return max_sum"},{"question":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines whether there exists a pair of indices (i, j) such that arr[i] + arr[j] is equal to the target value. Parameters: arr (List[int]): The list of integers. target (int): The target sum we are looking for. Returns: bool: True if such a pair exists, False otherwise. Examples: >>> has_pair_with_sum([1, 2, 3, 9], 8) False >>> has_pair_with_sum([1, 2, 4, 4], 8) True # Example usage: # arr = [1, 2, 3, 9] # target = 8 # print(has_pair_with_sum(arr, target)) # Should output: False # arr = [1, 2, 4, 4] # target = 8 # print(has_pair_with_sum(arr, target)) # Should output: True","solution":"from typing import List def has_pair_with_sum(arr: List[int], target: int) -> bool: Determines whether there exists a pair of indices (i, j) such that arr[i] + arr[j] is equal to the target value. Parameters: arr (List[int]): The list of integers. target (int): The target sum we are looking for. Returns: bool: True if such a pair exists, False otherwise. seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def missing_number(nums: List[int]) -> int: Finds the smallest positive integer that is missing from the list. >>> missing_number([3, 4, -1, 1]) 2 >>> missing_number([1, 2, 0]) 3 >>> missing_number([7, 8, 9, 11, 12]) 1","solution":"def missing_number(nums): Finds the smallest positive integer that is missing from the list. Args: nums: List[int] - a list of integers Returns: int - the smallest positive integer missing from the list # Filter out all non-positive numbers nums = [num for num in nums if num > 0] # Convert the list to a set for faster membership testing nums_set = set(nums) # Iterate through the numbers starting from 1 to len(nums)+1 for i in range(1, len(nums) + 2): if i not in nums_set: return i"},{"question":"from typing import List, Tuple def max_boundaries(N: int, M: int) -> Tuple[int, int]: Given dimensions N (rows) and M (columns) of the farmer's field, computes the maximum number of rows and columns that can contain a boundary between wheat and barley. >>> max_boundaries(4, 3) (3, 2) >>> max_boundaries(5, 2) (4, 1) >>> max_boundaries(6, 6) (5, 5) pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Processes multiple test cases and returns a list of results for each test case. >>> process_test_cases([(4, 3), (5, 2), (6, 6), (1, 1), (2, 1000)]) [(3, 2), (4, 1), (5, 5), (0, 0), (1, 999)] pass","solution":"def max_boundaries(N, M): Given dimensions N (rows) and M (columns) of the farmer's field, computes the maximum number of rows and columns that can contain a boundary between wheat and barley. max_rows_boundary = N - 1 if N > 1 else 0 max_cols_boundary = M - 1 if M > 1 else 0 return max_rows_boundary, max_cols_boundary def process_test_cases(test_cases): results = [] for N, M in test_cases: results.append(max_boundaries(N, M)) return results"},{"question":"def can_arrange_layers(n: int, layers: List[int]) -> str: Determines if it is possible to arrange the cake layers such that there are equal numbers of vanilla and chocolate layers, and no two consecutive layers are of the same flavor. >>> can_arrange_layers(4, [1, 2, 1, 2]) \\"YES\\" >>> can_arrange_layers(3, [1, 1, 2]) \\"NO\\"","solution":"def can_arrange_layers(n, layers): Determines if it is possible to arrange the cake layers such that there are equal numbers of vanilla and chocolate layers, and no two consecutive layers are of the same flavor. vanilla_count = layers.count(1) chocolate_count = layers.count(2) # Check if the number of vanilla and chocolate layers are equal if vanilla_count != chocolate_count: return \\"NO\\" # Check for consecutive similar layers for i in range(n - 1): if layers[i] == layers[i + 1]: return \\"NO\\" return \\"YES\\" # Example Usage # n = 4 # layers = [1, 2, 1, 2] # print(can_arrange_layers(n, layers)) # Output: \\"YES\\" # n = 3 # layers = [1, 1, 2] # print(can_arrange_layers(n, layers)) # Output: \\"NO\\""},{"question":"from typing import List def group_anagrams(weapons: List[str]) -> List[List[str]]: Group weapons that are anagrams of each other (case insensitive). :param weapons: List of weapon names (strings) :return: List of lists, where each sublist contains anagrams >>> group_anagrams([\\"Sword\\", \\"Rodws\\", \\"Gun\\", \\"nGu\\", \\"Bow\\", \\"Wob\\", \\"Arrow\\"]) [['Sword', 'Rodws'], ['Gun', 'nGu'], ['Bow', 'Wob'], ['Arrow']] >>> group_anagrams([\\"Axe\\", \\"Dagger\\", \\"Hammer\\"]) [['Axe'], ['Dagger'], ['Hammer']] >>> group_anagrams([\\"net\\", \\"ten\\", \\"ent\\"]) [['net', 'ten', 'ent']] >>> group_anagrams([]) [] >>> group_anagrams([\\"Evil\\", \\"vile\\", \\"Live\\", \\"Vill\\", \\"Bow\\"]) [['Evil', 'vile', 'Live'], ['Vill'], ['Bow']]","solution":"def group_anagrams(weapons): Group weapons that are anagrams of each other (case insensitive). :param weapons: List of weapon names (strings) :return: List of lists, where each sublist contains anagrams from collections import defaultdict anagram_dict = defaultdict(list) for weapon in weapons: sorted_weapon = ''.join(sorted(weapon.lower())) anagram_dict[sorted_weapon].append(weapon) return list(anagram_dict.values())"},{"question":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: Given an integer array arr of length n, this function rearranges its elements such that all negative numbers appear before all positive numbers while maintaining the relative order of the negative numbers as well as the positive numbers. Parameters: arr (List[int]): The list of integers to rearrange. Returns: List[int]: The rearranged list. Examples: >>> rearrange_array([2, -1, -3, 4, -2, 5]) [-1, -3, -2, 2, 4, 5] >>> rearrange_array([1, 3, 5, 2, 4]) [1, 3, 5, 2, 4]","solution":"from typing import List def rearrange_array(arr: List[int]) -> List[int]: This function rearranges the elements of the array such that all negative numbers come before all positive numbers while maintaining the relative order of both negative and positive numbers. Parameters: arr (List[int]): The list of integers to rearrange. Returns: List[int]: The rearranged list. # Separate the array into negative and positive lists negatives = [x for x in arr if x < 0] positives = [x for x in arr if x >= 0] # Combine the negative and positive lists return negatives + positives"},{"question":"def find_winner(S: str) -> str: Determine the winner of the game given the string S. Parameters: S (str): The initial string composed of lowercase English letters. Returns: str: \\"Alice\\" if Alice wins, \\"Brown\\" if Brown wins. Examples: >>> find_winner(\\"abac\\") \\"Alice\\" >>> find_winner(\\"racecar\\") \\"Brown\\"","solution":"def find_winner(S): Determine the winner of the game given the string S. Parameters: S (str): The initial string composed of lowercase English letters. Returns: str: \\"Alice\\" if Alice wins, \\"Brown\\" if Brown wins. if S == S[::-1]: # Check if the string is a palindrome return \\"Brown\\" else: return \\"Alice\\""},{"question":"def min_multiplications(A: int, B: int) -> int: Determine if A can be transformed into B by repeatedly multiplying by 2. Returns the minimum number of multiplications required, or -1 if it is not possible. >>> min_multiplications(2, 16) 3 >>> min_multiplications(3, 24) 3 >>> min_multiplications(6, 28) -1 >>> min_multiplications(1, 1) 0 >>> min_multiplications(1, 512) 9 >>> min_multiplications(1000, 8000) 3 >>> min_multiplications(1000, 999999) -1","solution":"def min_multiplications(A, B): Returns the minimum number of multiplications required to transform A into B by repeatedly multiplying by 2, or -1 if it is not possible. if B % A != 0: return -1 quotient = B // A count = 0 while quotient > 1: if quotient % 2 != 0: return -1 quotient //= 2 count += 1 return count"},{"question":"def update_inventory(n: int, operations: List[Tuple[str, int]]) -> int: Updates the inventory based on a series of operations. Parameters: n (int): Initial inventory count. operations (list): List of tuples where each tuple contains: a string (\\"add\\" or \\"remove\\") and an integer (amount). Returns: int: Final inventory count after processing all operations. >>> update_inventory(100, [(\\"add\\", 50), (\\"remove\\", 30), (\\"add\\", 20), (\\"remove\\", 150)]) 140 >>> update_inventory(0, [(\\"add\\", 50)]) 50 >>> update_inventory(200, [(\\"remove\\", 50), (\\"remove\\", 30)]) 120 >>> update_inventory(100, [(\\"remove\\", 30), (\\"add\\", 50), (\\"remove\\", 150), (\\"add\\", 20)]) 140 >>> update_inventory(50, []) 50 >>> update_inventory(10**9, [(\\"add\\", 10**6), (\\"remove\\", 10**6), (\\"remove\\", 1)]) 999999999 # Your code here","solution":"def update_inventory(n, operations): Updates the inventory based on a series of operations. Parameters: n (int): Initial inventory count. operations (list): List of tuples where each tuple contains: a string (\\"add\\" or \\"remove\\") and an integer (amount). Returns: int: Final inventory count after processing all operations. current_inventory = n for operation, amount in operations: if operation == \\"add\\": current_inventory += amount elif operation == \\"remove\\": if current_inventory >= amount: current_inventory -= amount return current_inventory"},{"question":"def is_prime(n: int) -> bool: Returns True if n is a prime number, False otherwise. >>> is_prime(2) True >>> is_prime(4) False pass def sum_of_primes_subarray(arr: List[int], L: int, R: int) -> int: Returns the sum of prime numbers in the subarray defined by the indices L and R (inclusive). >>> sum_of_primes_subarray([2, 4, 6, 7, 11, 13], 1, 3) 2 >>> sum_of_primes_subarray([2, 4, 6, 7, 11, 13], 4, 6) 31 pass def process_queries(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Processes each query and returns the results as a list. >>> process_queries([2, 4, 6, 7, 11, 13], [(1, 3), (4, 6)]) [2, 31] >>> process_queries([1, 3, 5, 8, 13], [(1, 5), (2, 4)]) [21, 8] pass","solution":"def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sum_of_primes_subarray(arr, L, R): Returns the sum of prime numbers in the subarray defined by the indices L and R (inclusive). return sum(x for x in arr[L-1:R] if is_prime(x)) def process_queries(arr, queries): Processes each query and returns the results as a list. results = [] for L, R in queries: results.append(sum_of_primes_subarray(arr, L, R)) return results"},{"question":"def collatz_steps(n: int) -> int: Computes the number of steps required for a given integer to reach 1 using the Collatz sequence. Parameters: n (int): A positive integer representing the starting number of the sequence. Returns: int: The number of steps required for the sequence to reach 1. Examples: >>> collatz_steps(7) 16 >>> collatz_steps(1) 0","solution":"def collatz_steps(n): Computes the number of steps required for a given integer to reach 1 using the Collatz sequence. Parameters: n (int): A positive integer representing the starting number of the sequence. Returns: int: The number of steps required for the sequence to reach 1. steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"def can_transform_to_identical_array(n: int, arr: List[int]) -> str: Determine if it is possible to transform the array into an array of identical elements using exactly \`n-1\` operations. If it is possible, print \\"YES\\" on the first line and the sequence of operations in each of the next \`n-1\` lines. If it is not possible, print \\"NO\\". >>> can_transform_to_identical_array(4, [2, 2, 2, 2]) 'YESn1 2n2 3n3 4' >>> can_transform_to_identical_array(3, [1, 5, 3]) 'NO'","solution":"def can_transform_to_identical_array(n, arr): unique_elements = set(arr) if len(unique_elements) == 1: return \\"YESn\\"+ \\"n\\".join(f\\"{i+1} {i+2}\\" for i in range(n-1)) else: return \\"NO\\""},{"question":"def max_subarray_sum(n, sequence): Finds the sum of the contiguous subarray with the largest sum. Parameters: - n: int, the length of the sequence - sequence: list of ints, the sequence of numbers Returns: - int, the maximum sum of any contiguous subarray >>> max_subarray_sum(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(5, [2, -1, 2, 3, -4, 3]) 6 >>> max_subarray_sum(1, [5]) 5 >>> max_subarray_sum(1, [-5]) -5 >>> large_sequence = [i for i in range(1, 10001)] >>> max_subarray_sum(10000, large_sequence) 50005000","solution":"def max_subarray_sum(n, sequence): Finds the sum of the contiguous subarray with the largest sum. Parameters: - n: int, the length of the sequence - sequence: list of ints, the sequence of numbers Returns: - int, the maximum sum of any contiguous subarray max_sum = sequence[0] current_sum = sequence[0] for i in range(1, n): current_sum = max(sequence[i], current_sum + sequence[i]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def sum_of_squares(n: int) -> int: Returns the sum of the squares of the first n positive integers. >>> sum_of_squares(3) 14 >>> sum_of_squares(5) 55 >>> sum_of_squares(10) 385","solution":"def sum_of_squares(n): Returns the sum of the squares of the first n positive integers. return sum(i ** 2 for i in range(1, n + 1))"},{"question":"def sort_panels_to_minimize_diff(T, test_cases): Sort the panel heights in each test case to minimize the maximum height difference between any two consecutive panels. Args: T: integer representing the number of test cases. test_cases: list of tuples where each tuple contains an integer N (number of panels) and a list of N integers representing the heights of the panels. Returns: List of lists - Each list contains the sorted heights of panels for a test case in a way that minimizes the maximum height difference between any two consecutive panels. Example: >>> T = 2 >>> test_cases = [(4, [1, 3, 7, 5]), (5, [4, 1, 8, 3, 2])] >>> sort_panels_to_minimize_diff(T, test_cases) [[1, 3, 5, 7], [1, 2, 3, 4, 8]]","solution":"def sort_panels_to_minimize_diff(T, test_cases): Sort the panel heights in each test case to minimize the maximum height difference between any two consecutive panels. Args: T: int - number of test cases test_cases: list of tuples - Each tuple contains a number of panels (N) and a list of heights of the panels Returns: List of lists - Each list contains the sorted heights of panels for a test case in a way that minimizes the maximum height difference. result = [] for case in test_cases: N, heights = case heights.sort() result.append(heights) return result # Example Usage: # T = 2 # test_cases = [ # (4, [1, 3, 7, 5]), # (5, [4, 1, 8, 3, 2]) # ] # print(sort_panels_to_minimize_diff(T, test_cases)) # Output: [[1, 3, 5, 7], [1, 2, 3, 4, 8]]"},{"question":"def minimum_coins(n, m, denominations, amounts): Find the minimum number of coins required to make each amount in the list. If a particular amount cannot be formed with the given denominations, return -1 for that amount. Args: n (int): number of different coin denominations. m (int): number of amounts to find the minimum number of coins. denominations (List[int]): list of coin denominations. amounts (List[int]): list of amounts to find the minimum number of coins. Returns: List[int]: list of minimum number of coins required for each amount or -1 if it's not possible. >>> minimum_coins(3, 2, [1, 3, 5], [11, 7]) [3, 3] >>> minimum_coins(2, 2, [2, 4], [2, 4]) [1, 1] >>> minimum_coins(5, 3, [1, 5, 10, 25, 50], [37, 5, 50]) [4, 1, 1] >>> minimum_coins(3, 1, [5, 10, 20], [7]) [-1]","solution":"def minimum_coins(n, m, denominations, amounts): def coin_change(coins, amount): # Create a DP array to store the minimum coins for each amount dp = [float('inf')] * (amount + 1) dp[0] = 0 for coin in coins: for x in range(coin, amount + 1): dp[x] = min(dp[x], dp[x - coin] + 1) return dp[amount] if dp[amount] != float('inf') else -1 results = [] for amount in amounts: results.append(coin_change(denominations, amount)) return results"},{"question":"def can_reach_end(steps: List[int]) -> str: Determines if it is possible to reach the last integer in the sequence using the step sizes provided. :param steps: List[int] – sequence of step sizes :return: str – \\"Yes\\" if it is possible to reach the end, otherwise \\"No\\"","solution":"def can_reach_end(steps): Determines if it is possible to reach the last integer in the sequence using the step sizes provided. :param steps: List[int] – sequence of step sizes :return: str – \\"Yes\\" if it is possible to reach the end, otherwise \\"No\\" furthest_reach = 0 last_index = len(steps) - 1 for i in range(len(steps)): if i > furthest_reach: break furthest_reach = max(furthest_reach, i + steps[i]) if furthest_reach >= last_index: return \\"Yes\\" return \\"No\\""},{"question":"def remove_extra_spaces(s: str) -> str: Removes extra spaces from the input string such that there is exactly one space between words, and there are no leading or trailing spaces. >>> remove_extra_spaces(' hello world ') # 'hello world' >>> remove_extra_spaces('the quick brown fox ') # 'the quick brown fox' >>> remove_extra_spaces('coding is fun') # 'coding is fun' >>> remove_extra_spaces(' a b ') # 'a b' >>> remove_extra_spaces(' single ') # 'single' >>> remove_extra_spaces(' ') # '' >>> remove_extra_spaces('word') # 'word'","solution":"def remove_extra_spaces(s): Removes extra spaces from the input string such that there is exactly one space between words, and there are no leading or trailing spaces. # Split the string based on one or more spaces words = s.split() # Join the words with a single space and return the result return ' '.join(words)"},{"question":"from typing import List def min_steps_with_token(n: int, m: int, grid: List[str]) -> int: Find the minimum number of steps required for Maria to reach the bottom-right corner of the grid using at most one magic token to remove an obstacle. >>> min_steps_with_token(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 4 >>> min_steps_with_token(3, 4, [\\"....\\", \\"..#.\\", \\"..#.\\"]) 5 >>> min_steps_with_token(3, 3, [\\".#.\\", \\"#\\", \\"..#\\"]) -1 >>> min_steps_with_token(4, 4, [\\"....\\", \\".#..\\", \\"..#.\\", \\"...#\\"]) 6 >>> min_steps_with_token(1, 1, [\\".\\"]) 0","solution":"from collections import deque def min_steps_with_token(n, m, grid): directions = [(1, 0), (0, 1)] # down, right start = (0, 0, 0) # (row, col, token_used) queue = deque([(start)]) visited = set([(0, 0, 0)]) # (row, col, token_used) steps = 0 while queue: for _ in range(len(queue)): row, col, token_used = queue.popleft() if (row, col) == (n-1, m-1): return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m: if grid[new_row][new_col] == '.' and (new_row, new_col, token_used) not in visited: queue.append((new_row, new_col, token_used)) visited.add((new_row, new_col, token_used)) elif grid[new_row][new_col] == '#' and token_used == 0 and (new_row, new_col, 1) not in visited: queue.append((new_row, new_col, 1)) visited.add((new_row, new_col, 1)) steps += 1 return -1"},{"question":"def is_balanced(s: str) -> str: Determines if the string of brackets is balanced. Parameters: s (str): A string containing only \`()[]{}\`<>\` characters. Returns: str: 'YES' if the string is balanced, 'NO' otherwise. >>> is_balanced(\\"{[()]}<>\\") 'YES' >>> is_balanced(\\"[{]}\\") 'NO' >>> is_balanced(\\"<[{()}]>\\") 'YES' >>> is_balanced(\\"<({[>}]\\") 'NO' pass","solution":"def is_balanced(s): Determines if the string of brackets is balanced. Parameters: s (str): A string containing only \`()[]{}\`<>\` characters. Returns: str: 'YES' if the string is balanced, 'NO' otherwise. stack = [] bracket_map = { ')': '(', ']': '[', '}': '{', '>': '<' } for char in s: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or stack.pop() != bracket_map[char]: return 'NO' else: continue return 'YES' if stack == [] else 'NO'"},{"question":"def can_reach_bottom_right(n: int, m: int, w: int, grid: List[List[int]]) -> str: Determines if the robot can reach the bottom-right corner of the garden grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. w (int): Initial amount of water. grid (list of list of int): Water requirements of each cell in the grid. Returns: str: \\"YES\\" if the robot can reach the bottom-right corner, otherwise \\"NO\\". >>> can_reach_bottom_right(3, 3, 10, [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ]) \\"YES\\" >>> can_reach_bottom_right(3, 3, 5, [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ]) \\"NO\\" >>> can_reach_bottom_right(2, 2, 3, [ [1, 2], [2, 1] ]) \\"NO\\" >>> can_reach_bottom_right(2, 2, 5, [ [1, 2], [1, 1] ]) \\"YES\\"","solution":"def can_reach_bottom_right(n, m, w, grid): Determines if the robot can reach the bottom-right corner of the garden grid. Parameters: n (int): Number of rows in the grid. m (int): Number of columns in the grid. w (int): Initial amount of water. grid (list of list of int): Water requirements of each cell in the grid. Returns: str: \\"YES\\" if the robot can reach the bottom-right corner, otherwise \\"NO\\". if w < grid[0][0]: return \\"NO\\" # Create a 2D list to track the maximum water remaining at each cell remaining_water = [[-1] * m for _ in range(n)] remaining_water[0][0] = w - grid[0][0] # Traverse the grid for i in range(n): for j in range(m): if remaining_water[i][j] == -1: continue if i + 1 < n and remaining_water[i][j] >= grid[i + 1][j]: remaining_water[i + 1][j] = max(remaining_water[i + 1][j], remaining_water[i][j] - grid[i + 1][j]) if j + 1 < m and remaining_water[i][j] >= grid[i][j + 1]: remaining_water[i][j + 1] = max(remaining_water[i][j + 1], remaining_water[i][j] - grid[i][j + 1]) return \\"YES\\" if remaining_water[n - 1][m - 1] >= 0 else \\"NO\\""},{"question":"def find_max_area_histogram(heights): Calculate the largest rectangular area possible in a given histogram. :param heights: List of non-negative integers representing the heights of the histogram's bars. :return: The area of the largest possible rectangle. def parse_input(input_str): Parse the input string to extract the heights of the histogram. :param input_str: Input string containing the number of heights followed by the heights themselves. :return: List of non-negative integers representing the heights of the histogram's bars. def solve(input_str): Solve the problem using the parsed input and calculate the maximum rectangular area. :param input_str: Input string containing the number of heights followed by the heights themselves. :return: The area of the largest possible rectangle. # Unit Test def test_parse_input(): input_str = \\"6n2 1 5 6 2 3n\\" assert parse_input(input_str) == [2, 1, 5, 6, 2, 3] def test_find_max_area_histogram(): assert find_max_area_histogram([2, 1, 5, 6, 2, 3]) == 10 assert find_max_area_histogram([4, 4, 4, 4, 4]) == 20 assert find_max_area_histogram([6, 2, 5, 4, 5, 1, 6]) == 12 assert find_max_area_histogram([2]) == 2 assert find_max_area_histogram([2, 1, 2]) == 3 assert find_max_area_histogram([2, 1]) == 2 assert find_max_area_histogram([1, 2, 3, 4, 5]) == 9 def test_solve(): assert solve(\\"6n2 1 5 6 2 3n\\") == 10 assert solve(\\"5n4 4 4 4 4n\\") == 20 assert solve(\\"7n6 2 5 4 5 1 6n\\") == 12 assert solve(\\"1n2n\\") == 2 assert solve(\\"3n2 1 2n\\") == 3","solution":"def find_max_area_histogram(heights): Calculate the largest rectangular area possible in a given histogram. :param heights: List of non-negative integers representing the heights of the histogram's bars. :return: The area of the largest possible rectangle. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area def parse_input(input_str): lines = input_str.strip().split('n') n = int(lines[0]) heights = list(map(int, lines[1].strip().split())) return heights def solve(input_str): heights = parse_input(input_str) return find_max_area_histogram(heights)"},{"question":"def can_make_all_elements_equal(n: int, arr: List[int]) -> str: Determines whether all elements of the array can be made equal using the specified operation any number of times. :param n: int, number of elements in the array :param arr: list of int, the elements of the array :return: str, \\"YES\\" if we can make all elements equal, otherwise \\"NO\\" >>> can_make_all_elements_equal(4, [6, 4, 24, 8]) \\"YES\\" >>> can_make_all_elements_equal(3, [1, 2, 3]) \\"NO\\" # --- function implementation begin # --- function implementation end","solution":"def can_make_all_elements_equal(n, arr): Determines whether all elements of the array can be made equal using the specified operation any number of times. :param n: int, number of elements in the array :param arr: list of int, the elements of the array :return: str, \\"YES\\" if we can make all elements equal, otherwise \\"NO\\" if n == 1: return \\"YES\\" from math import gcd from functools import reduce # Compute the GCD of the entire array overall_gcd = reduce(gcd, arr) # If the overall GCD is 1, then we cannot make all elements equal if overall_gcd == 1: return \\"NO\\" else: return \\"YES\\""},{"question":"def format_poem(draft: str) -> str: Formats Vlad's unformatted poem draft by adding proper capitalization and punctuation. >>> format_poem(\\"thequickbrownfoxjumpsoverthelazydog thesunsetsinthewestsilentnight\\") \\"Thequickbrownfoxjumpsoverthelazydog. Thesunsetsinthewestsilentnight.\\" >>> format_poem(\\"rosesloverosesredvioletsblue everythingsbeautiful\\") \\"Rosesloverosesredvioletsblue. Everythingsbeautiful.\\"","solution":"def format_poem(draft): Formats Vlad's unformatted poem draft by adding proper capitalization and punctuation. # Find the position of the single space separating two sentences separator_position = draft.index(' ') # Get each sentence, capitalize the first letter, and add a full stop at the end first_sentence = draft[:separator_position].capitalize() + '.' second_sentence = draft[separator_position + 1:].capitalize() + '.' # Join the two sentences with a space formatted_poem = first_sentence + ' ' + second_sentence return formatted_poem"},{"question":"from typing import List def longest_even_count_substring(n: int, s: str) -> int: Returns the length of the longest substring where each letter appears an even number of times. >>> longest_even_count_substring(9, \\"abacbabcab\\") 6 >>> longest_even_count_substring(6, \\"aaaaaa\\") 6 >>> longest_even_count_substring(4, \\"abcd\\") 0 >>> longest_even_count_substring(1, \\"a\\") 0 >>> longest_even_count_substring(5, \\"abcde\\") 0 >>> longest_even_count_substring(6, \\"aabbcc\\") 6 >>> longest_even_count_substring(100000, \\"a\\" * 50000 + \\"b\\" * 50000) 100000","solution":"def longest_even_count_substring(n, s): Returns the length of the longest substring where each letter appears an even number of times. from collections import defaultdict # Dictionary to store first occurrence of each state pos = defaultdict(lambda: -1) pos[0] = 0 # Array to store frequency masks mask = 0 max_len = 0 for i in range(n): # Calculate the bitmask for current character mask ^= 1 << (ord(s[i]) - ord('a')) # If this mask has been seen before, update max_len if mask in pos: max_len = max(max_len, i + 1 - pos[mask]) else: pos[mask] = i + 1 return max_len"},{"question":"def min_operations_to_make_ones_contiguous(S: str) -> int: Given a binary string S, returns the minimum number of operations required to transform S into a string where all '1's are contiguous. Parameters: S (str): A binary string consisting of characters '0' and '1'. Returns: int: The minimum number of operations required. >>> min_operations_to_make_ones_contiguous(\\"110100111\\") 2 >>> min_operations_to_make_ones_contiguous(\\"10101\\") 2 >>> min_operations_to_make_ones_contiguous(\\"11111\\") 0 >>> min_operations_to_make_ones_contiguous(\\"00000\\") 0","solution":"def min_operations_to_make_ones_contiguous(S): Returns the minimum number of operations required to make all '1's contiguous in S. ones_blocks = 0 in_block = False for char in S: if char == '1': if not in_block: ones_blocks += 1 in_block = True else: in_block = False # The minimum number of operations needed is the number of '1' blocks minus 1 return max(0, ones_blocks - 1)"},{"question":"def longest_arithmetic_subsequence(arr: List[int]) -> Tuple[int, int]: Write a program that takes an integer array and identifies the longest subsequence where the difference between any two consecutive elements is the same. If there are multiple subsequences with the same maximum length, return the first of them. The program should return the length of this subsequence and the starting index of this subsequence in the original array (0-based indexing). >>> longest_arithmetic_subsequence([1, 2, 3, 4, 3, 2]) (4, 0) >>> longest_arithmetic_subsequence([-1, -4, -7, -10, 2]) (4, 0) from longest_arithmetic_subsequence import longest_arithmetic_subsequence def test_example_1(): arr = [1, 2, 3, 4, 3, 2] assert longest_arithmetic_subsequence(arr) == (4, 0) def test_example_2(): arr = [-1, -4, -7, -10, 2] assert longest_arithmetic_subsequence(arr) == (4, 0) def test_single_element(): arr = [5] assert longest_arithmetic_subsequence(arr) == (1, 0) def test_no_arithmetic_subsequence(): arr = [1, 2, 4, 7] assert longest_arithmetic_subsequence(arr) == (2, 0) def test_multiple_same_length_subsequences(): arr = [1, 2, 3, 1, 2, 3] assert longest_arithmetic_subsequence(arr) == (3, 0) def test_long_arithmetic_subsequence(): arr = [1, 3, 5, 7, 9, 11, 13, 14, 15, 16] assert longest_arithmetic_subsequence(arr) == (7, 0) def test_arithmetic_subsequence_with_negative_numbers(): arr = [-1, -2, -3, -4, -5, 0, 1, 2] assert longest_arithmetic_subsequence(arr) == (5, 0)","solution":"def longest_arithmetic_subsequence(arr): n = len(arr) if n == 1: return 1, 0 longest_length = 0 starting_index = 0 for i in range(n-1): diff = arr[i+1] - arr[i] length = 2 for j in range(i+2, n): if arr[j] - arr[j-1] == diff: length += 1 else: break if length > longest_length: longest_length = length starting_index = i return longest_length, starting_index # Example Usage if __name__ == \\"__main__\\": N = 6 arr = [1, 2, 3, 4, 3, 2] length, start_index = longest_arithmetic_subsequence(arr) print(length, start_index)"},{"question":"from typing import List, Tuple def possible_to_retain_roads(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[Tuple[str, int, List[Tuple[int, int]]]]: Bob is designing a traffic system in his city. The city consists of n intersections connected by m one-way roads. Due to budget constraints, Bob needs to minimize the number of roads to keep only essential ones while ensuring that it is still possible to travel from any intersection to any other intersection using the remaining roads. Determine whether it is possible to retain only a subset of the roads such that the resulting graph is still strongly connected (there is a path between any pair of nodes in both directions) and has the minimum number of roads. Args: test_cases: A list of tuples where each tuple contains: - an integer n representing the number of intersections - an integer m representing the number of roads - a list of tuples representing the roads (each tuple contains two integers u and v denoting a one-way road from u to v) Returns: A list of tuples where each tuple contains: - a string \\"YES\\" or \\"NO\\" indicating if it is possible to retain a subset of the roads - an integer k indicating the number of roads in the retained subset - a list of k tuples each containing two integers a and b indicating a one-way road from a to b in the final subset Example: >>> possible_to_retain_roads([(4, 5, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)]), (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [('YES', 5, [(1, 2), (2, 3), (3, 4), (4, 1), (2, 4)]), ('YES', 3, [(1 2), (2, 3), (3, 1)]), ('NO',)] >>> possible_to_retain_roads([(4, 3, [(1, 2), (2, 3), (3, 4)])]) [('NO',)]","solution":"from collections import defaultdict, deque def find_sccs(n, graph): index = [None] * n lowlink = [None] * n on_stack = [False] * n stack = [] sccs = [] current_index = 0 def strongconnect(node): nonlocal current_index index[node] = current_index lowlink[node] = current_index current_index += 1 stack.append(node) on_stack[node] = True for neighbor in graph[node]: if index[neighbor] is None: strongconnect(neighbor) lowlink[node] = min(lowlink[node], lowlink[neighbor]) elif on_stack[neighbor]: lowlink[node] = min(lowlink[node], index[neighbor]) if lowlink[node] == index[node]: scc = [] while True: w = stack.pop() on_stack[w] = False scc.append(w) if w == node: break sccs.append(scc) for i in range(n): if index[i] is None: strongconnect(i) return sccs def possible_to_retain_roads(test_cases): results = [] for n, m, roads in test_cases: graph = defaultdict(list) for u, v in roads: graph[u - 1].append(v - 1) sccs = find_sccs(n, graph) if len(sccs) == 1: results.append((\\"YES\\", m, roads)) else: results.append((\\"NO\\",)) return results"},{"question":"def shortest_length_after_palindrome_removal(s: str) -> int: Returns the length of the shortest string that can be obtained after removing palindromic substrings. >>> shortest_length_after_palindrome_removal('abba') == 0 >>> shortest_length_after_palindrome_removal('racecar') == 0 >>> shortest_length_after_palindrome_removal('abcd') == 1","solution":"def shortest_length_after_palindrome_removal(s): Returns the length of the shortest string that can be obtained after removing palindromic substrings. # If the entire string is a palindrome, the shortest length is 0 if s == s[::-1]: return 0 # Otherwise, the shortest length is 1 (if the string is not a palindrome) return 1"},{"question":"def find_min_subarrays(arr): Returns the minimum number of subarrays required such that each subarray can be rearranged to form a non-decreasing sequence. n = len(arr) if n == 1: return 1 # It is optimal to split whenever we see a decrease in the array count = 1 for i in range(1, n): if arr[i] < arr[i - 1]: count += 1 return count def solve(test_cases): Solves multiple test cases and returns a list of results. results = [] for arr in test_cases: results.append(find_min_subarrays(arr)) return results # Test Cases def test_example_cases(): assert find_min_subarrays([4, 3, 5, 2, 1, 6]) == 4 assert find_min_subarrays([3, 3, 3, 3]) == 1 def test_single_element(): assert find_min_subarrays([10]) == 1 def test_non_decreasing_sequences(): assert find_min_subarrays([1, 2, 3, 4, 5, 6]) == 1 def test_strictly_decreasing(): assert find_min_subarrays([6, 5, 4, 3, 2, 1]) == 6 def test_oscillating_sequence(): assert find_min_subarrays([1, 3, 2, 3, 2, 3]) == 3 def test_solve_multiple_test_cases(): test_cases = [ [4, 3, 5, 2, 1, 6], [3, 3, 3, 3] ] assert solve(test_cases) == [4, 1] test_cases = [ [1], [10, 9, 8, 7, 6] ] assert solve(test_cases) == [1, 5]","solution":"def find_min_subarrays(arr): Returns the minimum number of subarrays required such that each subarray can be rearranged to form a non-decreasing sequence. n = len(arr) if n == 1: return 1 # It is optimal to split whenever we see a decrease in the array count = 1 for i in range(1, n): if arr[i] < arr[i - 1]: count += 1 return count def solve(test_cases): Solves multiple test cases and returns a list of results. results = [] for arr in test_cases: results.append(find_min_subarrays(arr)) return results"},{"question":"def trap_rainwater(heights: List[int]) -> int: Given a list of building heights, returns the units of water that can be trapped after rainfall. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 >>> trap_rainwater([]) 0 >>> trap_rainwater([1, 2, 3]) 0 >>> trap_rainwater([3, 2, 1]) 0 >>> trap_rainwater([4]) 0 >>> trap_rainwater([2, 2]) 0 >>> trap_rainwater([3, 0, 2, 0, 4]) 7 >>> trap_rainwater([10000, 10000, 10000, 10000, 10000]) 0 >>> trap_rainwater([0] * 100000 + [10000] + [0] * 100000) 0","solution":"def trap_rainwater(heights): Given list of building heights, returns the units of water that can be trapped after rainfall. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water = 0 # Fill the left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill the right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the accumulated water for i in range(n): water += min(left_max[i], right_max[i]) - heights[i] return water"},{"question":"def count_failing_grades(grades: List[int]) -> int: Given a list of grades, return the number of failing grades. A failing grade is any grade strictly less than 40. >>> count_failing_grades([55, 23, 67, 45, 0, 89, 38]) 3 >>> count_failing_grades([40, 40, 40, 40, 40]) 0","solution":"from typing import List def count_failing_grades(grades: List[int]) -> int: Given a list of grades, return the number of failing grades. A failing grade is any grade strictly less than 40. return sum(1 for grade in grades if grade < 40)"},{"question":"from typing import List, Tuple, Any def process_queries(N: int, Q: int, array: List[int], queries: List[List[int]]) -> List[int]: Processes a series of queries on a given array and returns the results. Each query is one of the following types: - T_i = 1: Count the number of elements divisible by X_i. - T_i = 2: Calculate the sum of the elements between indices L_i and R_i inclusive. - T_i = 3: Remove the first element from the array that is equal to X_i. Params: - N: Length of the array. - Q: Number of queries. - array: List of integers representing the array. - queries: List of queries to process. Returns: - A list of results for each query of type 1 or 2. Example Usage: >>> N = 5 >>> Q = 4 >>> array = [1, 2, 3, 4, 5] >>> queries = [ ... [1, 2], ... [2, 1, 3], ... [3, 2], ... [2, 0, 4] ... ] >>> process_queries(N, Q, array, queries) [2, 9, 13]","solution":"def process_queries(N, Q, array, queries): results = [] for query in queries: if query[0] == 1: X = query[1] count = sum(1 for x in array if x % X == 0) results.append(count) elif query[0] == 2: L, R = query[1], query[2] results.append(sum(array[L:R+1])) elif query[0] == 3: X = query[1] if X in array: array.remove(X) return results # Example usage N = 5 Q = 4 array = [1, 2, 3, 4, 5] queries = [ [1, 2], [2, 1, 3], [3, 2], [2, 0, 4] ] result = process_queries(N, Q, array, queries) for res in result: print(res)"},{"question":"def can_find_triplet_sum_divisible(n: int, d: int, sequence: List[int]) -> str: Determines if there exist three indices i, j, k (1 ≤ i < j < k ≤ n) such that the sum a_i + a_j + a_k is divisible by a given integer d. Args: n (int): length of the list of integers. d (int): the divisor. sequence (list): list of integers. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO pass # Example usage: def test_case_1(): n = 5 d = 7 sequence = [1, 2, 3, 4, 5] assert can_find_triplet_sum_divisible(n, d, sequence) == \\"YES\\" def test_case_2(): n = 4 d = 10 sequence = [10, 20, 30, 40] assert can_find_triplet_sum_divisible(n, d, sequence) == \\"YES\\" def test_case_3(): n = 4 d = 5 sequence = [1, 2, 3, 4] assert can_find_triplet_sum_divisible(n, d, sequence) == \\"NO\\" def test_case_4(): n = 6 d = 9 sequence = [1, 1, 1, 2, 2, 2] assert can_find_triplet_sum_divisible(n, d, sequence) == \\"NO\\" def test_case_5(): n = 5 d = 6 sequence = [1, 5, 7, 10, 12] assert can_find_triplet_sum_divisible(n, d, sequence) == \\"YES\\"","solution":"def can_find_triplet_sum_divisible(n, d, sequence): Determines if there exist three indices i, j, k (1 ≤ i < j < k ≤ n) such that the sum a_i + a_j + a_k is divisible by a given integer d. Args: n (int): length of the list of integers. d (int): the divisor. sequence (list): list of integers. Returns: str: \\"YES\\" if such indices exist, otherwise \\"NO\\" # Check all combinations of i, j, k for i in range(n - 2): for j in range(i + 1, n - 1): for k in range(j + 1, n): if (sequence[i] + sequence[j] + sequence[k]) % d == 0: return \\"YES\\" return \\"NO\\" # Example usage: input_data = \\"5 7n1 2 3 4 5\\" lines = input_data.split(\\"n\\") n, d = map(int, lines[0].split()) sequence = list(map(int, lines[1].split())) print(can_find_triplet_sum_divisible(n, d, sequence)) # output should be \\"YES\\""},{"question":"def max_remaining_quality(S: int, C: int, quality_ratings: List[int]) -> int: Given the number of stores S, the number of chocolate bars C, and their quality_ratings, this function determines the maximum possible quality rating remaining after distributing chocolates to all stores such that each store receives at least one contiguous segment. :param S: int - Number of stores :param C: int - Number of chocolate bars :param quality_ratings: list of int - Quality ratings of chocolate bars :return: int - Maximum possible quality rating remaining pass # Unit tests def test_max_remaining_quality_case_1(): S = 2 C = 5 quality_ratings = [7, 5, 8, 6, 9] assert max_remaining_quality(S, C, quality_ratings) == 9 def test_max_remaining_quality_case_2(): S = 3 C = 6 quality_ratings = [3, 4, 1, 7, 6, 5] assert max_remaining_quality(S, C, quality_ratings) == 7 def test_max_remaining_quality_case_3(): S = 1 C = 3 quality_ratings = [10, 15, 20] assert max_remaining_quality(S, C, quality_ratings) == 20 def test_max_remaining_quality_case_4(): S = 3 C = 8 quality_ratings = [10, 30, 20, 25, 15, 35, 40, 5] assert max_remaining_quality(S, C, quality_ratings) == 40 def test_no_remaining_chocolate(): S = 3 C = 3 quality_ratings = [10, 15, 20] assert max_remaining_quality(S, C, quality_ratings) == -1 def test_no_distributing_needed(): S = 2 C = 2 quality_ratings = [10, 15] assert max_remaining_quality(S, C, quality_ratings) == -1 # Parsing the input and calling the function would be done elsewhere, in the main application part","solution":"def max_remaining_quality(S, C, quality_ratings): Given the number of stores S, the number of chocolate bars C, and their quality_ratings, this function determines the maximum possible quality rating remaining after distributing chocolates to all stores such that each store receives at least one contiguous segment. :param S: int - Number of stores :param C: int - Number of chocolate bars :param quality_ratings: list of int - Quality ratings of chocolate bars :return: int - Maximum possible quality rating remaining # Each store has to receive at least one chocolate bar min_chocolates_distributed = S if min_chocolates_distributed >= C: # If the minimum chocolates distributed is not less than the count of bars, # it means all bars will be distributed, so no bar remains in factory. return -1 # The best possible remaining chocolate is the highest quality rating from the list return max(quality_ratings) # Parsing the input and calling the function would be done elsewhere, in the main application part"},{"question":"def generate_keys(N: int, initial_key: int, vals: List[int]) -> List[int]: Generates a sequence of \`N\` keys based on the initial key and vals array. Args: - N: int, the number of keys to generate. - initial_key: int, the starting key in the series. - vals: list of int, values used to derive the subsequent keys. Returns: - list of int: the generated series of keys. Examples: >>> generate_keys(5, 3, [1, 2, 3, 4, 5]) [2, 0, 3, 7, 2] >>> generate_keys(4, 10, [5, 7, 8, 10]) [15, 8, 0, 10]","solution":"def generate_keys(N, initial_key, vals): Generates a sequence of \`N\` keys based on the initial key and vals array. Args: - N: int, the number of keys to generate. - initial_key: int, the starting key in the series. - vals: list of int, values used to derive the subsequent keys. Returns: - list of int: the generated series of keys. keys = [] current_key = initial_key for i in range(N): current_key = current_key ^ vals[i] keys.append(current_key) return keys"},{"question":"def longest_palindromic_substring(s: str) -> str: Returns the longest palindromic substring in s. >>> longest_palindromic_substring(\\"babad\\") in (\\"bab\\", \\"aba\\") True >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"abcd\\") 'a' >>> longest_palindromic_substring(\\"racecar\\") 'racecar' >>> longest_palindromic_substring(\\"abcbahello\\") 'abcba' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"aa\\") 'aa'","solution":"def longest_palindromic_substring(s): Returns the longest palindromic substring in s. n = len(s) # Edge case for single character string if n <= 1: return s # table to store the palindrome status dp = [[False] * n for _ in range(n)] start = 0 max_length = 1 # All substrings of length 1 are palindromes for i in range(n): dp[i][i] = True # Check for sub-strings of length 2. for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2. for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True if length > max_length: start = i max_length = length return s[start:start + max_length]"},{"question":"def is_reachable(n: int, m: int, grid: List[str]) -> str: Determines if it is possible to reach the cell (n,m) from the cell (1,1) in the grid. Parameters: n (int): number of rows m (int): number of columns grid (list of strings): representation of the grid Returns: str: \\"YES\\" if the cell (n,m) is reachable, \\"NO\\" otherwise >>> is_reachable(5, 5, [\\".....\\", \\".#.#.\\", \\".#...\\", \\".#...\\", \\".....\\"]) \\"YES\\" >>> is_reachable(3, 4, [\\"....\\", \\"#.\\", \\"...#\\"]) \\"NO\\"","solution":"def is_reachable(n, m, grid): Determines if it is possible to reach the cell (n,m) from the cell (1,1) in the grid. Parameters: n (int): number of rows m (int): number of columns grid (list of strings): representation of the grid Returns: str: \\"YES\\" if the cell (n,m) is reachable, \\"NO\\" otherwise if grid[0][0] == '#' or grid[n-1][m-1] == '#': return \\"NO\\" visited = [[False] * m for _ in range(n)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] def dfs(x, y): if x == n-1 and y == m-1: return True visited[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and not visited[nx][ny] and grid[nx][ny] == '.': if dfs(nx, ny): return True return False return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"from typing import List def find_longest_valid_word(s: str, n: int, words: List[str]) -> str: Sophie is a vocabulary enthusiast. She loves discovering new words from a set of given letters. A word is considered valid if it can be formed by using the letters from the given set exactly as they appear in the word, without reusing any letter. Sophie now wants to find the longest valid word she can form from a list of given words using the letters from her set. Args: s (str): The string of lowercase English letters representing the set of letters Sophie has. n (int): The number of words in the list. words (List[str]): The list of words. Returns: str: The longest valid word. If there are multiple longest valid words, print the one that comes first lexicographically. If no valid word exists, return an empty string. Examples: >>> find_longest_valid_word(\\"abcdefghijklmnopqrstuvwxyz\\", 3, [\\"apple\\", \\"orange\\", \\"grape\\"]) 'orange' >>> find_longest_valid_word(\\"abcdefg\\", 5, [\\"ecc\\", \\"bee\\", \\"ace\\", \\"father\\", \\"dog\\"]) 'ace' >>> find_longest_valid_word(\\"abc\\", 3, [\\"dog\\", \\"cat\\", \\"mouse\\"]) '' >>> find_longest_valid_word(\\"abcde\\", 4, [\\"ace\\", \\"bed\\", \\"de\\", \\"abcde\\"]) 'abcde' >>> find_longest_valid_word(\\"a\\", 3, [\\"a\\", \\"aa\\", \\"aaa\\"]) 'a' >>> find_longest_valid_word(\\"abcdef\\", 3, [\\"bed\\", \\"fed\\", \\"dab\\"]) 'bed' pass","solution":"def find_longest_valid_word(s, n, words): from collections import Counter s_count = Counter(s) def is_valid(word): word_count = Counter(word) for letter in word_count: if word_count[letter] > s_count.get(letter, 0): return False return True longest_word = \\"\\" for word in words: if is_valid(word): if len(word) > len(longest_word) or (len(word) == len(longest_word) and word < longest_word): longest_word = word return longest_word"},{"question":"def canFormPalindrome(s: str) -> bool: Determine whether it is possible to rearrange the characters of the string to form a palindrome. >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"aabbcc\\") True >>> canFormPalindrome(\\"a\\") True >>> canFormPalindrome(\\"abccba\\") True >>> canFormPalindrome(\\"aaabbbb\\") True >>> canFormPalindrome(\\"abcdef\\") False >>> canFormPalindrome(\\"aabb\\" * 10000) True","solution":"def canFormPalindrome(s: str) -> bool: from collections import Counter # Count the frequency of each character in the string freq = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in freq.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def sum_of_divisibles(n: int, k: int) -> int: Returns the sum of all integers from 1 to n that are divisible by k. >>> sum_of_divisibles(10, 2) 30 >>> sum_of_divisibles(15, 5) 30 >>> sum_of_divisibles(100, 7) 735 >>> sum_of_divisibles(20, 1) 210 >>> sum_of_divisibles(1, 1) 1 def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes a list of test cases and returns the result for each one. >>> process_test_cases([(10, 2), (15, 5), (100, 7)]) [30, 30, 735] >>> process_test_cases([(20, 1), (1, 1)]) [210, 1]","solution":"def sum_of_divisibles(n, k): Returns the sum of all integers from 1 to n that are divisible by k. # Calculate the number of multiples of k up to n m = n // k # Sum of first m multiples of k (k, 2k, 3k, ..., mk) sum_multiples = k * m * (m + 1) // 2 return sum_multiples def process_test_cases(test_cases): Processes a list of test cases and returns the result for each one. results = [] for n, k in test_cases: results.append(sum_of_divisibles(n, k)) return results"},{"question":"def min_palindrome_cost(s: str) -> int: Returns the minimum cost required to transform the given string s into a palindrome. Examples: >>> min_palindrome_cost(\\"abca\\") 4 >>> min_palindrome_cost(\\"racecar\\") 0 >>> min_palindrome_cost(\\"abcde\\") 15","solution":"def min_palindrome_cost(s: str) -> int: Returns the minimum cost required to transform the given string s into a palindrome. n = len(s) def is_palindrome(t): return t == t[::-1] if is_palindrome(s): return 0 dp = [[0] * n for _ in range(n)] for length in range(2, n+1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = dp[i+1][j-1] else: dp[i][j] = min(dp[i+1][j] + (i+1), dp[i][j-1] + (j+1)) return dp[0][n-1]"},{"question":"def max_sum_diffs(n: int) -> int: Returns the maximum possible sum of differences between adjacent book identifiers when they are arranged optimally. >>> max_sum_diffs(2) 2 >>> max_sum_diffs(3) 4 >>> max_sum_diffs(4) 6 >>> max_sum_diffs(5) 8 >>> max_sum_diffs(6) 10","solution":"def max_sum_diffs(n): Returns the maximum possible sum of differences between adjacent book identifiers when they are arranged optimally. # The maximum sum of differences between adjacent elements can be calculated directly # without building the sequence. # The optimal strategy involves alternating large and small values. # For n = 4, a sample sequence like [1, 4, 2, 3] can be transformed into: # 1, n, n-2, n-4, ..., 2, 1, n-1, n-3, n-5, ... sum_diffs = 2 * (n - 1) return sum_diffs"},{"question":"def count_distinct_substrings(S: str) -> int: Returns the count of distinct substrings of the input string S. >>> count_distinct_substrings(\\"ababa\\") 9 >>> count_distinct_substrings(\\"abc\\") 6 from solution import count_distinct_substrings def test_example_1(): assert count_distinct_substrings(\\"ababa\\") == 9 def test_example_2(): assert count_distinct_substrings(\\"abc\\") == 6 def test_single_character(): assert count_distinct_substrings(\\"a\\") == 1 def test_repeated_characters(): assert count_distinct_substrings(\\"aaaa\\") == 4 def test_mixed_characters(): assert count_distinct_substrings(\\"abcabc\\") == 15 def test_distinct_characters(): assert count_distinct_substrings(\\"abcdefgh\\") == 36","solution":"def count_distinct_substrings(S): Returns the count of distinct substrings of the input string S. n = len(S) substrings = set() for i in range(n): for j in range(i + 1, n + 1): substrings.add(S[i:j]) return len(substrings)"},{"question":"def count_unique_splits(strings: List[str]) -> List[int]: For each string in the list, returns the number of unique ways to split it into two non-empty valid parts. >>> count_unique_splits([\\"apple\\", \\"banana\\", \\"cheese\\"]) [4, 5, 5] >>> count_unique_splits([\\"a\\"]) [0] >>> count_unique_splits([\\"ab\\", \\"cd\\"]) [1, 1]","solution":"def count_unique_splits(strings): For each string in the list, returns the number of unique ways to split it into two non-empty valid parts. results = [] for s in strings: # The number of unique splits of a string \`s\` of length n is (n-1) results.append(len(s) - 1) return results"},{"question":"def can_remove_one_char_to_make_palindrome(s: str) -> str: Determine if it is possible to remove exactly one letter from the given string to make it a palindrome. >>> can_remove_one_char_to_make_palindrome(\\"abca\\") \\"YES\\" >>> can_remove_one_char_to_make_palindrome(\\"abc\\") \\"NO\\"","solution":"def can_remove_one_char_to_make_palindrome(s): def is_palindrome(st): return st == st[::-1] n = len(s) for i in range(n): if is_palindrome(s[:i] + s[i+1:]): return \\"YES\\" return \\"NO\\""},{"question":"def distinct_subarrays_count(n: int, array: List[int]) -> int: Chef loves doing various operations on arrays. One day, while playing with an array, he thought of splitting it into multiple subarrays. A subarray is defined as a contiguous segment of the array. Chef wants to know the total number of distinct subarrays for a given array A. Given an array of integers, output the total number of distinct subarrays that can be formed from this array. The result can be very large, so output it modulo 1000000007 (10^9 + 7). >>> distinct_subarrays_count(3, [1, 2, 1]) 6 >>> distinct_subarrays_count(5, [1, 1, 1, 1, 1]) 15 >>> distinct_subarrays_count(4, [1, 2, 3, 4]) 10 >>> distinct_subarrays_count(1, [1]) 1 >>> distinct_subarrays_count(7, [1, 2, 1, 3, 4, 2, 1]) 28 >>> distinct_subarrays_count(6, [3, 3, 3, 3, 3, 3]) 21 >>> distinct_subarrays_count(10**5, [1] * 10**5) == (10**5 * (10**5 + 1) // 2) % 1000000007 True","solution":"def distinct_subarrays_count(n, array): MOD = 1000000007 suffix_map = {} result = 0 suffix_sum = 0 start = 0 for end in range(n): suffix_sum += array[end] while suffix_sum in suffix_map: suffix_sum -= array[start] start += 1 suffix_map[suffix_sum] = end result = (result + (end - start + 1)) % MOD return result"},{"question":"from collections import defaultdict, deque def find_min_max_distances(N, roads): Given the number of towns N and roads connecting the towns with their lengths, return the minimum and maximum distance between any two towns. >>> find_min_max_distances(4, [(1, 2, 3), (2, 3, 2), (2, 4, 4)]) (2, 7) >>> find_min_max_distances(3, [(1, 2, 1), (2, 3, 1)]) (1, 2) >>> find_min_max_distances(5, [(1, 2, 3), (1, 3, 3), (3, 4, 3), (3, 5, 3)]) (3, 9) >>> find_min_max_distances(2, [(1, 2, 5)]) (5, 5)","solution":"from collections import defaultdict, deque def find_min_max_distances(N, roads): def bfs(start): q = deque([start]) distances = [-1] * (N+1) distances[start] = 0 max_dist = 0 max_dist_node = start while q: node = q.popleft() for neighbor, length in adj[node]: if distances[neighbor] == -1: distances[neighbor] = distances[node] + length q.append(neighbor) if distances[neighbor] > max_dist: max_dist = distances[neighbor] max_dist_node = neighbor return max_dist_node, max_dist adj = defaultdict(list) min_distance = float('inf') for u, v, w in roads: adj[u].append((v, w)) adj[v].append((u, w)) min_distance = min(min_distance, w) # Finding the diameter of the tree (maximum distance) # First BFS to find one endpoint of the longest path start_node = 1 farthest_node, _ = bfs(start_node) # Second BFS from the farthest node found in the previous BFS _, max_distance = bfs(farthest_node) return min_distance, max_distance # Example usage with provided sample input N = 4 roads = [ (1, 2, 3), (2, 3, 2), (2, 4, 4) ] min_distance, max_distance = find_min_max_distances(N, roads) print(min_distance, max_distance) # Expected Output: 2 7"},{"question":"def check_palindrome_and_longest_substring(s: str) -> Tuple[str, str]: Create a program that checks if a given string is a valid palindrome and then determines the longest palindromic substring within that string. >>> check_palindrome_and_longest_substring(\\"racecar\\") (\\"YES\\", \\"racecar\\") >>> check_palindrome_and_longest_substring(\\"banana\\") (\\"NO\\", \\"anana\\") from typing import Tuple def test_palindrome_string(): assert check_palindrome_and_longest_substring(\\"racecar\\") == (\\"YES\\", \\"racecar\\") def test_non_palindrome_string(): assert check_palindrome_and_longest_substring(\\"banana\\") == (\\"NO\\", \\"anana\\") def test_mixed_case(): assert check_palindrome_and_longest_substring(\\"aabcb\\") == (\\"NO\\", \\"bcb\\") def test_single_character(): assert check_palindrome_and_longest_substring(\\"a\\") == (\\"YES\\", \\"a\\") def test_empty_string(): assert check_palindrome_and_longest_substring(\\"\\") == (\\"YES\\", \\"\\") def test_odd_length_palindrome(): assert check_palindrome_and_longest_substring(\\"aba\\") == (\\"YES\\", \\"aba\\") def test_even_length_palindrome(): assert check_palindrome_and_longest_substring(\\"abba\\") == (\\"YES\\", \\"abba\\") def test_large_string_with_multiple_palindromes(): assert check_palindrome_and_longest_substring(\\"abaxyzzyxf\\") == (\\"NO\\", \\"xyzzyx\\")","solution":"def is_palindrome(s): Checks if the entire string s is a palindrome. return s == s[::-1] def longest_palindromic_substring(s): Finds the longest palindromic substring in s. n = len(s) if n == 0: return \\"\\" # Initialize the table to store palindrome status table = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromes for i in range(n): table[i][i] = True start = 0 max_length = 1 # Check for substring of length 2 for i in range(n - 1): if s[i] == s[i + 1]: table[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 # Check if s[i] to s[j] is a palindrome if s[i] == s[j] and table[i + 1][j - 1]: table[i][j] = True start = i max_length = length return s[start:start + max_length] def check_palindrome_and_longest_substring(s): if is_palindrome(s): return \\"YES\\", s else: return \\"NO\\", longest_palindromic_substring(s)"},{"question":"class CircularBuffer: A circular buffer is a fixed-size data structure that operates in a FIFO (first-in, first-out) manner. Methods: - __init__(self, size: int): Initializes the buffer with a specified size. - append(self, value: int) -> None: Adds an element to the buffer. If the buffer is full, it overwrites the oldest element. - get(self) -> list: Returns a list of elements in the buffer in the correct order, starting from the oldest element. >>> buffer = CircularBuffer(3) >>> buffer.append(1) >>> buffer.append(2) >>> buffer.append(3) >>> buffer.get() [1, 2, 3] >>> buffer.append(4) >>> buffer.get() [2, 3, 4]","solution":"class CircularBuffer: def __init__(self, size: int): Initializes the buffer with a specified size. self.size = size self.buffer = [None] * size self.start = 0 self.count = 0 def append(self, value: int) -> None: Adds an element to the buffer. If the buffer is full, it overwrites the oldest element. if self.count < self.size: self.buffer[(self.start + self.count) % self.size] = value self.count += 1 else: self.buffer[self.start] = value self.start = (self.start + 1) % self.size def get(self) -> list: Returns a list of elements in the buffer in the correct order, starting from the oldest element. return [self.buffer[(self.start + i) % self.size] for i in range(self.count)]"},{"question":"def rank_employees(n: int, scores: List[int]) -> List[int]: Returns the ranks of employees based on their performance scores. Each rank is calculated based on the number of employees with higher scores. Employees with the same score receive the same rank. Parameters: n (int): Number of employees scores (list of int): Integer performance scores of the employees. Returns: list of int: Ranking of each employee based on performance. >>> rank_employees(4, [4, 3, 2, 4]) [1, 3, 4, 1] >>> rank_employees(2, [100, 200]) [2, 1] >>> rank_employees(5, [10, 20, 10, 20, 10]) [3, 1, 3, 1, 3]","solution":"def rank_employees(n, scores): Returns the ranks of employees based on their performance scores. Parameters: n (int): Number of employees scores (list of int): Integer performance scores of the employees. Returns: list of int: Ranking of each employee based on performance. # Create a list of tuples (score, index) and sort it by score in descending order indexed_scores = sorted(enumerate(scores), key=lambda x: x[1], reverse=True) ranks = [0] * n current_rank = 1 previous_score = indexed_scores[0][1] for i, (index, score) in enumerate(indexed_scores): if score != previous_score: current_rank = i + 1 ranks[index] = current_rank previous_score = score return ranks"},{"question":"def extract_ith_element(i: int, elements: List[int]) -> int: Extract the ith element from the list of elements. Parameters: i (int): Index to extract (1-based index). elements (list): List of elements to extract from. Returns: int: The ith element from the list. Raises: IndexError: If i is out of bounds. >>> extract_ith_element(1, [1, 2, 3, 4, 5]) 1 >>> extract_ith_element(5, [1, 2, 3, 4, 5]) 5 >>> extract_ith_element(8, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]) 8","solution":"def extract_ith_element(i, elements): Returns the ith element from the elements list. Parameters: i (int): Index to extract (1-based index). elements (list): List of elements to extract from. if 1 <= i <= len(elements): return elements[i-1] else: raise IndexError(\\"Index out of bounds\\")"},{"question":"def sort_array_by_parity(arr: List[int]) -> List[int]: Sort the array such that even numbers come before odd numbers, while maintaining the relative order of both even and odd numbers. >>> sort_array_by_parity([3, 1, 2, 4, 5]) [2, 4, 3, 1, 5] >>> sort_array_by_parity([1, 2, 3, 4, 5, 6, 7, 8]) [2, 4, 6, 8, 1, 3, 5, 7] >>> sort_array_by_parity([2, 4, 6, 8]) [2, 4, 6, 8] >>> sort_array_by_parity([1, 3, 5, 7]) [1, 3, 5, 7] >>> sort_array_by_parity([2]) [2] >>> sort_array_by_parity([1]) [1] >>> sort_array_by_parity([]) [] >>> sort_array_by_parity([4, 2]) [4, 2] >>> sort_array_by_parity([1, 3]) [1, 3] >>> sort_array_by_parity([i for i in range(1, 1001)]) == [(i for i in range(2, 1001, 2)) + (i for i in range(1, 1000, 2))] True","solution":"def sort_array_by_parity(arr): This function sorts the array such that even numbers come before odd numbers, while maintaining the relative order of both even and odd numbers. even_numbers = [num for num in arr if num % 2 == 0] odd_numbers = [num for num in arr if num % 2 != 0] return even_numbers + odd_numbers"},{"question":"def max_layers(layers: List[Tuple[int, int]]) -> int: Given a list of layers' dimensions, returns the maximum number of layers that can be stacked. >>> max_layers([(4, 6), (7, 8), (3, 4), (5, 6), (6, 7)]) 4 >>> max_layers([(2, 3), (2, 5), (3, 2)]) 1 >>> max_layers([(5, 5)]) 1 >>> max_layers([(5, 4), (5, 4), (5, 4)]) 1 >>> max_layers([(5, 5), (4, 4), (3, 3), (2, 2), (1, 1)]) 5 >>> max_layers([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 5 >>> max_layers([(3, 6), (7, 8), (2, 4), (3, 5), (6, 7)]) 4","solution":"def max_layers(layers): Given a list of layers' dimensions, returns the maximum number of layers that can be stacked. # Sort the layers by width first, if widths are the same, sort by height sorted_layers = sorted(layers, key=lambda x: (x[0], x[1])) # Initialize DP array where dp[i] means the maximum stack ending with layer i dp = [1] * len(layers) # Compute the longest increasing subsequence based on height for i in range(len(layers)): for j in range(i): if sorted_layers[j][0] < sorted_layers[i][0] and sorted_layers[j][1] < sorted_layers[i][1]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) # Example usage n = 5 layers = [(4, 6), (7, 8), (3, 4), (5, 6), (6, 7)] print(max_layers(layers)) # Output: 4"},{"question":"def count_palindromes(n: int) -> int: Returns the total number of n-digit numeric palindromes. >>> count_palindromes(1) 9 >>> count_palindromes(2) 9 >>> count_palindromes(3) 90 def process_input(test_cases: List[int]) -> List[int]: Processes multiple test cases and returns a list of results for each. >>> process_input([1, 2, 3, 4, 5]) [9, 9, 90, 90, 900]","solution":"def count_palindromes(n): Returns the total number of n-digit numeric palindromes. if n == 1: return 9 elif n % 2 == 0: return 9 * 10 ** (n//2 - 1) else: return 9 * 10 ** (n//2) def process_input(test_cases): results = [count_palindromes(n) for n in test_cases] return results"},{"question":"def first_non_repeating_character(s: str): Returns the first non-repeating character in the string or -1 if there is none. Example: >>> first_non_repeating_character(\\"abcdabce\\") 'd' >>> first_non_repeating_character(\\"aabbcc\\") -1 >>> first_non_repeating_character(\\"abc\\") 'a'","solution":"def first_non_repeating_character(s): Returns the first non-repeating character in the string or -1 if there is none. char_count = {} # Count each character in the string for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Find the first character that has a count of 1 for char in s: if char_count[char] == 1: return char return -1"},{"question":"def max_questions_prepared(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of questions Ivan can prepare by the end of N weeks for each test case. Args: T: int - the number of test cases. test_cases: List of tuples, where each tuple contains: - an integer N, the number of weeks - a list of N integers representing the maximum number of questions that can be prepared each week Returns: List of integers - each representing the maximum number of questions that can be prepared in total by the end of N weeks for each test case. Example: >>> max_questions_prepared(2, [(3, [5, 3, 4]), (4, [2, 1, 7, 3])]) [12, 13]","solution":"def max_questions_prepared(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] questions_per_week = test_cases[i][1] max_questions = sum(questions_per_week) results.append(max_questions) return results # Example Usage T = 2 test_cases = [ (3, [5, 3, 4]), (4, [2, 1, 7, 3]) ] print(max_questions_prepared(T, test_cases)) # Should print [12, 13]"},{"question":"def minimum_additional_candies(t, test_cases): Given the number of test cases and the details of each test case, returns the minimum number of additional candies required to satisfy the preferences of all children. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains: - Two integers n and C (number of children and initial number of candies) - A list p of lengths n indicating each child's candy preferences. Returns: list: A list of integers where each integer is the minimum number of additional candies required for each test case. pass from solution import minimum_additional_candies def test_case_1(): assert minimum_additional_candies(3, [(3, 10, [2, 3, 5]), (4, 9, [3, 3, 3, 3]), (5, 15, [1, 2, 3, 4, 5])]) == [0, 3, 0] def test_case_2(): assert minimum_additional_candies(2, [(2, 5, [1, 2]), (3, 6, [2, 2, 2])]) == [0, 0] def test_case_3(): assert minimum_additional_candies(1, [(4, 7, [1, 2, 2, 4])]) == [2] def test_case_4(): assert minimum_additional_candies(1, [(1, 0, [0])]) == [0] def test_case_5(): assert minimum_additional_candies(2, [(3, 8, [3, 3, 3]), (2, 1, [0, 0])]) == [1, 0]","solution":"def minimum_additional_candies(t, test_cases): Given the number of test cases and the details of each test case, returns the minimum number of additional candies required to satisfy the preferences of all children. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains: - Two integers n and C (number of children and initial number of candies) - A list p of lengths n indicating each child's candy preferences. Returns: list: A list of integers where each integer is the minimum number of additional candies required for each test case. results = [] for n, C, p in test_cases: total_preferences = sum(p) if total_preferences > C: results.append(total_preferences - C) else: results.append(0) return results"},{"question":"def min_rest_days(n: int, activities: List[int]) -> int: Determines the minimum number of rest days Valeria can manage under the given conditions. >>> min_rest_days(5, [0, 1, 3, 3, 2]) 1 >>> min_rest_days(4, [3, 3, 3, 3]) 2 >>> min_rest_days(3, [1, 2, 3]) 0","solution":"def min_rest_days(n, activities): # Constants for types of activities REST = 0 CONTEST = 1 STUDY = 2 BOTH = 3 # Initialize the variables for rest days count and the last activity type rest_days = 0 last_activity = REST for day in activities: if day == REST: rest_days += 1 last_activity = REST elif day == CONTEST: if last_activity in [CONTEST, BOTH]: rest_days += 1 last_activity = REST else: last_activity = CONTEST elif day == STUDY: if last_activity in [STUDY, BOTH]: rest_days += 1 last_activity = REST else: last_activity = STUDY elif day == BOTH: if last_activity == REST: last_activity = BOTH elif last_activity == STUDY: last_activity = CONTEST elif last_activity == CONTEST: last_activity = STUDY else: rest_days += 1 last_activity = REST return rest_days"},{"question":"def fibonacci(n): Returns the nth Fibonacci number using matrix exponentiation. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025","solution":"def fibonacci(n): Returns the nth Fibonacci number using matrix exponentiation. def matrix_mult(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(mat, p): result = [[1, 0], [0, 1]] # Identity matrix base = mat while p: if p % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) p //= 2 return result if n == 0: return 0 elif n == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_pow(F, n - 1) return result[0][0]"},{"question":"def max_simultaneous_sessions(sessions): Returns the maximum number of simultaneous user sessions. sessions: List of tuples where each tuple contains two integers (start, end). Examples: >>> max_simultaneous_sessions([(1, 5), (2, 6), (4, 8)]) 3 >>> max_simultaneous_sessions([(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> max_simultaneous_sessions([(100, 200)]) 1 >>> max_simultaneous_sessions([(1, 10), (11, 20), (21, 30), (31, 40), (41, 50)]) 1 pass","solution":"def max_simultaneous_sessions(sessions): Returns the maximum number of simultaneous user sessions. sessions: List of tuples where each tuple contains two integers (start, end). events = [] for start, end in sessions: events.append((start, 'start')) events.append((end + 1, 'end')) # end + 1 to make intervals inclusive events.sort() current_sessions = 0 max_sessions = 0 for event in events: if event[1] == 'start': current_sessions += 1 max_sessions = max(max_sessions, current_sessions) else: current_sessions -= 1 return max_sessions"},{"question":"def longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. >>> longest_substring_two_distinct(\\"eceba\\") 3 >>> longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> longest_substring_two_distinct(\\"a\\") 1 >>> longest_substring_two_distinct(\\"aa\\") 2 >>> longest_substring_two_distinct(\\"aaaaa\\") 5 >>> longest_substring_two_distinct(\\"ab\\") 2 >>> longest_substring_two_distinct(\\"abcabcabc\\") 2 >>> longest_substring_two_distinct(\\"a\\" * (10**6 // 2) + \\"b\\" * (10**6 // 2)) 1000000","solution":"def longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. from collections import defaultdict n = len(s) if n < 3: return n left, right = 0, 0 hashmap = defaultdict(int) max_len = 2 while right < n: hashmap[s[right]] += 1 right += 1 while len(hashmap) > 2: hashmap[s[left]] -= 1 if hashmap[s[left]] == 0: del hashmap[s[left]] left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"def num_enclosed_territories(m, n, grid): Determine the number of fully enclosed territories of completed missions. Parameters: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[List[str]]): The grid representing completed ('1') and empty ('0') cells. Returns: int: The number of fully enclosed territories. >>> num_enclosed_territories(5, 5, [ ['1', '1', '1', '1', '0'], ['1', '0', '0', '1', '0'], ['1', '0', '0', '1', '0'], ['1', '0', '0', '0', '0'], ['1', '1', '1', '1', '1'] ]) == 1 >>> num_enclosed_territories(5, 5, [ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'], ['0', '0', '0', '1', '1'] ]) == 3 def process_input(input_data): Process input data to determine the number of fully enclosed territories for multiple test cases. Parameters: input_data (List[str]): The input data as list of strings. Returns: List[int]: A list of results for each test case. >>> input_data = [ \\"5 5\\", \\"11110\\", \\"10010\\", \\"10010\\", \\"10000\\", \\"11111\\", \\"5 5\\", \\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\", \\"00011\\", \\"0 0\\" ] >>> process_input(input_data) == [1, 3] def test_num_enclosed_territories(): # For the first example grid where there should be 1 enclosed territory assert num_enclosed_territories(5, 5, [ ['1', '1', '1', '1', '0'], ['1', '0', '0', '1', '0'], ['1', '0', '0', '1', '0'], ['1', '0', '0', '0', '0'], ['1', '1', '1', '1', '1'] ]) == 1 # For the second example grid where there should be 3 enclosed territories assert num_enclosed_territories(5, 5, [ ['1', '1', '0', '0', '0'], ['1', '1', '0', '0', '0'], ['0', '0', '1', '0', '0'], ['0', '0', '0', '1', '1'], ['0', '0', '0', '1', '1'] ]) == 3 def test_process_input(): input_data = [ \\"5 5\\", \\"11110\\", \\"10010\\", \\"10010\\", \\"10000\\", \\"11111\\", \\"5 5\\", \\"11000\\", \\"11000\\", \\"00100\\", \\"00011\\", \\"00011\\", \\"0 0\\" ] expected_output = [1, 3] assert process_input(input_data) == expected_output","solution":"def num_enclosed_territories(m, n, grid): def flood_fill(i, j): if i < 0 or i >= m or j < 0 or j >= n or grid[i][j] == '0': return grid[i][j] = '0' flood_fill(i + 1, j) flood_fill(i - 1, j) flood_fill(i, j + 1) flood_fill(i, j - 1) def is_enclosed(x, y): if x == 0 or x == m-1 or y == 0 or y == n-1: return False flood_fill(x, y) for direction in directions: nx, ny = x + direction[0], y + direction[1] if grid[nx][ny] == '1' and (nx == 0 or nx == m-1 or ny == 0 or ny == n-1): return False return True if m == 0 or n == 0: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] enclosed_territories = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': if is_enclosed(i, j): enclosed_territories += 1 return enclosed_territories def process_input(input_data): results = [] index = 0 while index < len(input_data): m, n = map(int, input_data[index].split()) if m == 0 and n == 0: break grid = [] for i in range(1, m+1): grid.append(list(input_data[index + i])) results.append(num_enclosed_territories(m, n, grid)) index += m + 1 return results if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().splitlines() results = process_input(input_data) for result in results: print(result)"},{"question":"def longest_even_occurrence_subsequence(n: int, sequence: List[int]) -> int: Find the length of the longest subsequence that is both an increasing subsequence and a subsequence where every element appears an even number of times in the original sequence. Args: n (int): the number of elements in the sequence (1 ≤ n ≤ 1000). sequence (List[int]): a list of integers representing the sequence. Returns: int: length of the longest valid subsequence Examples: >>> longest_even_occurrence_subsequence(6, [1, 2, 2, 3, 3, 3]) 4 >>> longest_even_occurrence_subsequence(8, [4, 4, 4, 4, 1, 1, 2, 2]) 4","solution":"def longest_even_occurrence_subsequence(n, sequence): from collections import Counter def is_valid(subseq, counter): count = Counter(subseq) for num in count: if count[num] % 2 != 0 or count[num] > counter[num]: return False return True max_length = 0 for i in range(2**n): subseq = [] for j in range(n): if i & (1 << j): subseq.append(sequence[j]) if sorted(subseq) == subseq and is_valid(subseq, Counter(sequence)): max_length = max(max_length, len(subseq)) return max_length"},{"question":"from typing import List def count_subarrays(distances: List[int], k: int, D: int) -> int: Jake is training for a marathon and is tracking his running progress over several days. Each day he notes the distance he ran in kilometers in a list. Jake has set a goal of running at least \`D\` kilometers on average over any consecutive \`k\` days. However, he's concerned that there might be periods where he fails to meet this goal. Therefore, he needs to check how many subarrays of length \`k\` have an average distance of at least \`D\` kilometers. >>> count_subarrays([5, 6, 4, 3, 8, 10], 3, 5) 3 >>> count_subarrays([1, 2, 3, 4, 5], 1, 3) 3 from solution import count_subarrays def test_example_case(): distances = [5, 6, 4, 3, 8, 10] k = 3 D = 5 assert count_subarrays(distances, k, D) == 3 def test_small_values(): distances = [1, 2, 3, 4, 5] k = 1 D = 3 assert count_subarrays(distances, k, D) == 3 def test_all_below_D(): distances = [2, 2, 2, 2] k = 2 D = 3 assert count_subarrays(distances, k, D) == 0 def test_all_distances_equal(): distances = [5, 5, 5, 5] k = 2 D = 5 assert count_subarrays(distances, k, D) == 3 def test_no_subarray_meeting_criteria(): distances = [2, 1, 2, 1] k = 2 D = 3 assert count_subarrays(distances, k, D) == 0 def test_large_n(): distances = [1000]*100000 k = 100000 D = 1000 assert count_subarrays(distances, k, D) == 1 def test_edge_case_one_element(): distances = [5] k = 1 D = 5 assert count_subarrays(distances, k, D) == 1 def test_edge_case_empty_array(): distances = [] k = 1 D = 1 assert count_subarrays(distances, k, D) == 0 def test_edge_case_k_equals_array_length(): distances = [5, 6, 7, 8, 9] k = 5 D = 6 assert count_subarrays(distances, k, D) == 1","solution":"from typing import List def count_subarrays(distances: List[int], k: int, D: int) -> int: count = 0 n = len(distances) current_sum = sum(distances[:k]) if current_sum / k >= D: count += 1 for i in range(k, n): current_sum = current_sum - distances[i - k] + distances[i] if current_sum / k >= D: count += 1 return count"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates the mathematical expression from left to right without considering traditional operator precedence. >>> evaluate_expression(\\"2+3*5\\") 25 >>> evaluate_expression(\\"1*2*3\\") 6 >>> evaluate_expression(\\"3+2+1\\") 6 >>> evaluate_expression(\\"4-2*3\\") 6 # (4-2)*3 >>> evaluate_expression(\\"7*4+5\\") 33 # (7*4)+5 >>> evaluate_expression(\\"1+1-1\\") 1 def evaluate_expressions(test_cases: List[str]) -> List[int]: Evaluates a list of mathematical expressions according to Athena's special rule. >>> evaluate_expressions([\\"2+3*5\\", \\"1*2*3\\"]) [25, 6] >>> evaluate_expressions([\\"3+2+1\\", \\"10-5*2\\"]) [6, 0] # 10-(5*2)=0 >>> evaluate_expressions([\\"4*3*2\\", \\"7+8+9\\"]) [24, 24] >>> evaluate_expressions([\\"6-5+1\\", \\"2*2*2\\"]) [2, 8] >>> evaluate_expressions([\\"2*3+4-5\\"]) [5] # (2*3)+4-5=5","solution":"def evaluate_expression(expression): Evaluates the mathematical expression from left to right without considering traditional operator precedence. # Split the expression into a list where numbers and operators are separated elements = [] current_number = '' for char in expression: if char.isdigit(): current_number += char else: elements.append(int(current_number)) elements.append(char) current_number = '' elements.append(int(current_number)) # Append the last number # Evaluate expression from left to right result = elements[0] i = 1 while i < len(elements): operator = elements[i] next_number = elements[i+1] if operator == '+': result += next_number elif operator == '-': result -= next_number elif operator == '*': result *= next_number i += 2 return result def evaluate_expressions(test_cases): Evaluates a list of mathematical expressions according to Athena's special rule. return [evaluate_expression(expression) for expression in test_cases]"},{"question":"def num_unique_strings(s: str) -> int: Calculate the number of unique strings that can be generated from the string \`s\` by replacing '?' with any single lowercase English letter and '*' with any sequence of lowercase English letters (including the empty string). >>> num_unique_strings(\\"ab?c\\") 26 >>> num_unique_strings(\\"a*bc\\") 777 >>> num_unique_strings(\\"?*\\") 20202 def test_no_special_characters(): assert num_unique_strings('abc') == 1 def test_single_question_mark(): assert num_unique_strings('a?c') == 26 def test_single_star(): assert num_unique_strings('a*c') == 777 def test_question_mark_and_star(): assert num_unique_strings('?*') == 26 * 777 def test_multiple_question_marks(): assert num_unique_strings('?a?') == 26 * 26 def test_multiple_stars(): assert num_unique_strings('a**') == 777 * 777 def test_mixed_special_characters(): assert num_unique_strings('a*bc?') == 777 * 26 def test_empty_string(): assert num_unique_strings('') == 1 def test_long_string_with_special_characters(): assert num_unique_strings('a'*25 + '*' + '?'*24) == 777 * (26 ** 24)","solution":"def num_unique_strings(s): Calculate the number of unique strings that can be generated from the string \`s\` by replacing '?' with any single lowercase English letter and '*' with any sequence of lowercase English letters (including the empty string). def count_possibilities(s): count_question = s.count('?') count_star = s.count('*') # 26 possibilities for each '?' question_possibilities = 26 ** count_question # As per problem, consider 777 combinations for '*' star_possibilities = 777 ** count_star return question_possibilities * star_possibilities return count_possibilities(s)"},{"question":"def max_honey(n: int, honey: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum amount of honey Limak can collect starting from the root vertex (vertex 1). Args: n (int): number of vertices in the tree honey (List[int]): the amount of honey at each vertex edges (List[Tuple[int, int]]): the edges connecting the vertices Returns: int: maximum amount of honey collected >>> max_honey(1, [5], []) == 5 >>> max_honey(3, [3, 4, 5], [(1, 2), (1, 3)]) == 8 >>> max_honey(6, [3, 4, 5, 6, 3, 2], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 13 >>> max_honey(6, [3, 4, 1, 6, 0, 2], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 13 >>> max_honey(6, [1, 1, 1, 1, 1, 10], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) == 12","solution":"from collections import defaultdict, deque def max_honey(n, honey, edges): # Create adjacency list representation of tree tree = defaultdict(list) for a, b in edges: tree[a].append(b) tree[b].append(a) # Initialize visited nodes set and stack for DFS visited = set() stack = [(1, honey[0])] # (vertex, current_honey_sum) visited.add(1) max_honey_collected = 0 while stack: vertex, current_honey = stack.pop() max_honey_collected = max(max_honey_collected, current_honey) for neighbor in tree[vertex]: if neighbor not in visited: visited.add(neighbor) stack.append((neighbor, current_honey + honey[neighbor - 1])) return max_honey_collected"},{"question":"def count_pairs_with_sum(arr: List[int], target: int) -> int: Counts the number of pairs (i, j) in the array such that i < j and the sum of arr[i] and arr[j] is equal to the target value. Parameters: arr (list of int): List of integers. target (int): The target sum value. Returns: int: The number of pairs with the sum equal to the target value. >>> count_pairs_with_sum([1, 5, 7, -1, 5], 6) 3 >>> count_pairs_with_sum([1, 2, 3, 4, 5], 5) 2 >>> count_pairs_with_sum([0, 0, 0, 0], 0) 6 >>> count_pairs_with_sum([-1, -2, -3, -4, -5], -5) 2 >>> count_pairs_with_sum([10, 12, 10, 15, -1, 7, 6, 5, 4, 2, 1, 1, 1], 11) 9 >>> count_pairs_with_sum([1, 2, 3, 4], 10) 0 >>> count_pairs_with_sum([5, 5, 5, 5], 10) 6","solution":"def count_pairs_with_sum(arr, target): Counts the number of pairs (i, j) in the array such that i < j and the sum of arr[i] and arr[j] is equal to the target value. Parameters: arr (list of int): List of integers. target (int): The target sum value. Returns: int: The number of pairs with the sum equal to the target value. # Mapping to store frequency of elements freq_map = {} count = 0 for num in arr: # Calculate the complement complement = target - num # If complement is found in the map, add its frequency to the count if complement in freq_map: count += freq_map[complement] # Update the frequency map if num in freq_map: freq_map[num] += 1 else: freq_map[num] = 1 return count"},{"question":"def find_pairs_with_sum(arr, target): Returns all unique pairs of indices where the numbers at those indices add up to the target sum. Parameters: arr (list of int): List of integers target (int): Target sum Returns: list of tuples: List of unique pairs of indices or \\"No pairs found\\" if no such pairs exist. Examples: >>> find_pairs_with_sum([2, 7, 11, 15, 1, 8], 9) [(0, 1), (4, 5)] >>> find_pairs_with_sum([1, 2, 3, 4, 5], 10) \\"No pairs found\\" >>> find_pairs_with_sum([1, 2, 3, 4, 3], 6) [(1, 3), (2, 4)] >>> find_pairs_with_sum([1000000, -1000000, 0, 500000, -500000], 0) [(0, 1), (3, 4)] >>> find_pairs_with_sum([-1, -2, -3, -4, -5], -8) [(2, 4)] >>> find_pairs_with_sum([5], 5) \\"No pairs found\\"","solution":"def find_pairs_with_sum(arr, target): Returns all unique pairs of indices where the numbers at those indices add up to the target sum. Parameters: arr (list of int): List of integers target (int): Target sum Returns: list of tuples: List of unique pairs of indices index_map = {} result = set() for i, num in enumerate(arr): complement = target - num if complement in index_map: for comp_idx in index_map[complement]: result.add((comp_idx, i) if comp_idx < i else (i, comp_idx)) if num in index_map: index_map[num].append(i) else: index_map[num] = [i] if not result: return \\"No pairs found\\" sorted_result = sorted(result, key=lambda x: (x[0], x[1])) return sorted_result"},{"question":"def count_matching_queries(n: int, length_q: int, m: int, query: str, data: List[str]) -> int: Count the number of strings in data that have a substring matching the search query Q with at most m character mismatches. Args: n (int): Number of customer data queries length_q (int): Length of the search query string m (int): Maximum allowed mismatches query (str): The search query string data (List[str]): List of customer data queries Returns: int: Number of matching queries Examples: >>> count_matching_queries(3, 5, 2, \\"HELLO\\", [\\"HJLLPLOVE\\", \\"WORLD\\", \\"HELLOCODE\\"]) 2 >>> count_matching_queries(2, 5, 0, \\"HELLO\\", [\\"HELLO\\", \\"HELLOTHERE\\"]) 2 >>> count_matching_queries(2, 3, 3, \\"XYZ\\", [\\"ABCDXYZ\\", \\"XYF\\"]) 2 >>> count_matching_queries(3, 4, 1, \\"TEST\\", [\\"ABCDEF\\", \\"GHIJKL\\", \\"MNOPQR\\"]) 0 >>> count_matching_queries(3, 1, 0, \\"A\\", [\\"A\\", \\"B\\", \\"C\\"]) 1","solution":"def count_matching_queries(n, length_q, m, query, data): def mismatch_count(s1, s2): return sum(1 for a, b in zip(s1, s2) if a != b) count = 0 for customer_query in data: if len(customer_query) < length_q: continue for i in range(len(customer_query) - length_q + 1): substring = customer_query[i:i + length_q] if mismatch_count(substring, query) <= m: count += 1 break return count"},{"question":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list of integers. >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) 3 pass def parse_input(input_string): Parses the input string into a list of integers. >>> parse_input(\\"6n10 9 2 5 3 7 101 18\\") [10, 9, 2, 5, 3, 7, 101, 18] >>> parse_input(\\"8n3 10 2 1 20\\") [3, 10, 2, 1, 20] pass","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given list of integers. if not arr: return 0 n = len(arr) lis = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def parse_input(input_string): Parses the input string into a list of integers. lines = input_string.strip().split('n') n = int(lines[0]) arr = list(map(int, lines[1].split())) return arr"},{"question":"def min_operations_to_equalize(lst): Given a list of integers, this function returns the minimum number of operations required to make all elements of the list equal. One operation consists of either adding or subtracting 1 from any element in the list. >>> min_operations_to_equalize([1, 2, 3, 4, 5]) 6 >>> min_operations_to_equalize([2, 2, 2]) 0 >>> min_operations_to_equalize([1, 10, 2, 9]) 16","solution":"def min_operations_to_equalize(lst): Given a list of integers, this function returns the minimum number of operations required to make all elements of the list equal. One operation consists of either adding or subtracting 1 from any element in the list. if not lst: # handle empty list return 0 # Step 1: Find the median, as moving all elements to the median requires the minimum operations lst_sorted = sorted(lst) n = len(lst) median = lst_sorted[n // 2] if n % 2 != 0 else lst_sorted[n // 2 - 1] # Step 2: Compute the total operations needed to make all elements equal to the median operations = sum(abs(x - median) for x in lst) return operations"},{"question":"def longest_dup_substring(s: str) -> str: Identify the longest duplicated substring within a given string. >>> longest_dup_substring(\\"banana\\") in [\\"ana\\"] >>> longest_dup_substring(\\"abcd\\") == \\"\\" >>> longest_dup_substring(\\"aaaaa\\") in [\\"aaaa\\"] >>> longest_dup_substring(\\"mississippi\\") in [\\"issi\\", \\"issi\\"] >>> longest_dup_substring(\\"abcabcabc\\") in [\\"abcabc\\"] >>> longest_dup_substring(\\"abacabadabacaba\\") in [\\"abacaba\\"] >>> longest_dup_substring(\\"abcde\\") == \\"\\" >>> longest_dup_substring(\\"abcabc\\") in [\\"abc\\"] >>> longest_dup_substring(\\"testingtest\\") in [\\"test\\"] >>> longest_dup_substring(\\"\\") == \\"\\"","solution":"def longest_dup_substring(s: str) -> str: def search(length): seen = set() for start in range(len(s) - length + 1): substring = s[start:start + length] if substring in seen: return start seen.add(substring) return -1 left, right = 1, len(s) start = 0 while left <= right: mid = (left + right) // 2 idx = search(mid) if idx != -1: start = idx left = mid + 1 else: right = mid - 1 if left == 1: return \\"\\" return s[start:start + left - 1]"},{"question":"def longest_consecutive_sequence(x: int, y: int) -> int: Returns the longest sequence of consecutive integers that can be placed in an x-by-y grid. >>> longest_consecutive_sequence(3, 3) == 9 >>> longest_consecutive_sequence(1, 1) == 1 >>> longest_consecutive_sequence(2, 3) == 6 >>> longest_consecutive_sequence(100, 50) == 5000 >>> longest_consecutive_sequence(10, 10) == 100","solution":"def longest_consecutive_sequence(x, y): Returns the longest sequence of consecutive integers that can be placed in an x-by-y grid. return x * y"},{"question":"def min_cost_to_equalize_bacteria(N: int, B: List[int]) -> int: Returns the minimum total cost to equalize the number of bacteria across all dishes. Args: N : int : Number of Petri dishes B : list<int> : List of bacteria counts in each dish. Returns: int : Minimum cost to equalize all dishes. Examples: >>> min_cost_to_equalize_bacteria(3, [6, 2, 4]) 4 >>> min_cost_to_equalize_bacteria(4, [10, 10, 10, 10]) 0 Test Cases: def test_min_cost_to_equalize_bacteria_case1(): assert min_cost_to_equalize_bacteria(3, [6, 2, 4]) == 4 def test_min_cost_to_equalize_bacteria_case2(): assert min_cost_to_equalize_bacteria(4, [10, 10, 10, 10]) == 0 def test_min_cost_to_equalize_bacteria_case3(): assert min_cost_to_equalize_bacteria(5, [1, 2, 3, 4, 5]) == 6 def test_min_cost_to_equalize_bacteria_case4(): assert min_cost_to_equalize_bacteria(3, [7, 1, 3]) == 6 def test_min_cost_to_equalize_bacteria_case5(): assert min_cost_to_equalize_bacteria(2, [1, 1000000000]) == 999999999","solution":"def min_cost_to_equalize_bacteria(N, B): Returns the minimum total cost to equalize the number of bacteria across all dishes. Args: N : int : Number of Petri dishes B : list<int> : List of bacteria counts in each dish. Returns: int : Minimum cost to equalize all dishes. B.sort() median = B[N // 2] total_cost = sum(abs(b - median) for b in B) return total_cost"},{"question":"def count_distinct_elements(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns a list of the number of distinct elements for each query range. Parameters: arr (list of int): the array of integers queries (list of tuples): list of (l, r) tuples representing query ranges Returns: list of int: one integer per query denoting number of distinct elements Examples: >>> count_distinct_elements([1, 2, 1, 3, 2, 2], [(1, 3), (2, 4), (3, 6)]) [2, 3, 3] >>> count_distinct_elements([4, 4, 4, 4, 4, 4, 4, 4], [(1, 8), (3, 5)]) [1, 1]","solution":"def count_distinct_elements(arr, queries): Returns a list of the number of distinct elements for each query range. Parameters: arr (list of int): the array of integers queries (list of tuples): list of (l, r) tuples representing query ranges Returns: list of int: one integer per query denoting number of distinct elements def get_distinct_count(l, r): return len(set(arr[l-1:r])) result = [] for l, r in queries: result.append(get_distinct_count(l, r)) return result"},{"question":"def kth_longest_trail(test_cases): Returns the k-th longest trail for each test case. Parameters: - test_cases: A list of tuples where each tuple contains (n, trails, k): - n: Integer, number of trails. - trails: List of integers, lengths of the trails. - k: Integer, the k-th longest trail to find. Returns: - A list of integers where each integer is the k-th longest trail length for a test case. >>> kth_longest_trail([(5, [3, 1, 4, 1, 2], 2), (4, [10, 20, 15, 25], 3)]) [3, 15] >>> kth_longest_trail([(1, [5], 1)]) [5] >>> kth_longest_trail([(5, [10, 10, 10, 10, 10], 3)]) [10] >>> kth_longest_trail([(3, [5, 8, 3], 1), (3, [5, 8, 3], 2), (3, [5, 8, 3], 3)]) [8, 5, 3] >>> kth_longest_trail([(1000, list(range(1000, 0, -1)), 500)]) [501]","solution":"def kth_longest_trail(test_cases): Returns the k-th longest trail for each test case. Parameters: - test_cases: A list of tuples where each tuple contains (n, trails, k): - n: Integer, number of trails. - trails: List of integers, lengths of the trails. - k: Integer, the k-th longest trail to find. Returns: - A list of integers where each integer is the k-th longest trail length for a test case. results = [] for n, trails, k in test_cases: # Sort the trails in descending order sorted_trails = sorted(trails, reverse=True) # Append the k-th longest trail to results results.append(sorted_trails[k-1]) return results"},{"question":"def count_consecutive_sum_ways(N: int) -> int: Returns the number of ways to express N as the sum of two or more consecutive positive integers. >>> count_consecutive_sum_ways(15) 3 >>> count_consecutive_sum_ways(10) 1","solution":"def count_consecutive_sum_ways(N): Returns the number of ways to express N as the sum of two or more consecutive positive integers. count = 0 m = 1 while m * (m + 1) < 2 * N: if (N - m * (m + 1) // 2) % (m + 1) == 0: count += 1 m += 1 return count"},{"question":"def morse_to_text(morse_dict: dict, morse_code: str) -> str: Translates a morse code string to regular English text using the provided morse dictionary. Parameters: morse_dict (dict): A dictionary containing the morse code mappings to English characters. morse_code (str): A string containing the morse code to be converted. Returns: str: The translated English text. Example Usage: >>> morse_dict = { ... 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', ... 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', ... 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', ... 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', ... '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.' ... } >>> morse_code = '.... . .-.. .-.. --- .-- --- .-. .-.. -..' >>> morse_to_text(morse_dict, morse_code) 'HELLO WORLD' >>> morse_code = '-- --- .-. ... . -.-. --- -.. .' >>> morse_to_text(morse_dict, morse_code) 'MORSE CODE'","solution":"def morse_to_text(morse_dict, morse_code): Translates a morse code string to regular English text using the provided morse dictionary. Parameters: morse_dict (dict): A dictionary containing the morse code mappings to English characters morse_code (str): A string containing the morse code to be converted Returns: str: The translated English text reverse_morse_dict = {value: key for key, value in morse_dict.items()} morse_characters = morse_code.split(' ') translated_text = [] for morse_character in morse_characters: if morse_character == '': translated_text.append(' ') # Two spaces indicates a word break else: translated_text.append(reverse_morse_dict[morse_character]) # Join characters into the final string and return return ''.join(translated_text).replace(' ', ' ') # Example usage: # morse_dict = { ... } # morse_code = '.... . .-.. .-.. --- .-- --- .-. .-.. -..' # print(morse_to_text(morse_dict, morse_code))"},{"question":"def min_sociability_difference(n: int, k: int, sociabilities: List[int]) -> int: You are organizing a party and you want to divide the guests into multiple tables for dinner. Each guest i has a specific level of sociability \`s_i\`, which represents how well they can engage in a conversation. You want to arrange the guests in such a way that each table has roughly the same overall level of sociability. Specifically, given the number of guests n and their sociability levels, you need to divide the guests into k tables such that the difference between the total sociability of the most sociable table and the least sociable table is minimized. Args: n (int): The number of guests. k (int): The number of tables. sociabilities (List[int]): The sociability levels of the guests. Returns: int: The minimum possible difference between the total sociability of the most sociable table and the least sociable table. pass # Unit Tests def test_min_sociability_difference(): assert min_sociability_difference(6, 3, [10, 20, 30, 20, 10, 40]) == 10 assert min_sociability_difference(1, 1, [100]) == 0 assert min_sociability_difference(5, 1, [10, 20, 30, 40, 50]) == 0 assert min_sociability_difference(4, 2, [10, 10, 10, 10]) == 0 assert min_sociability_difference(5, 2, [50, 20, 10, 40, 30]) == 10 assert min_sociability_difference(2, 3, [10, 20]) == 20 assert min_sociability_difference(3, 3, [1, 2, 3]) == 2","solution":"def min_sociability_difference(n, k, sociabilities): Splits guests into k tables such that the difference between the most sociable table and the least sociable table is minimized. # Sort the sociability list in descending order sociabilities.sort(reverse=True) # Initialize a list to hold total sociability of each table table_sociabilities = [0] * k # Distribute guests to the tables to minimize the max difference for s in sociabilities: # Assign the current guest to the table with the smallest current sociability table_sociabilities.sort() table_sociabilities[0] += s return max(table_sociabilities) - min(table_sociabilities) # Example usage # n = 6, k = 3 # sociabilities = [10, 20, 30, 20, 10, 40] # min_sociability_difference(6, 3, [10, 20, 30, 20, 10, 40]) should output 10"},{"question":"def largest_balanced_substring_length(T: int, strings: List[str]) -> List[int]: Given a number of test cases and a list of strings, return a list of the length of the largest balanced substring for each string. A balanced substring contains an equal number of uppercase and lowercase letters. Args: T (int): The number of test cases. strings (List[str]): A list of strings for each test case. Returns: List[int]: A list containing the length of the largest balanced substring for each string. Examples: >>> largest_balanced_substring_length(3, [\\"AaBbCc\\", \\"aabbCC\\", \\"AaAA\\"]) [6, 4, 2] >>> largest_balanced_substring_length(1, [\\"ABC\\"]) [0]","solution":"def largest_balanced_substring_length(T, strings): def is_balanced(sub): lower_count = sum(1 for c in sub if c.islower()) upper_count = len(sub) - lower_count return lower_count == upper_count results = [] for s in strings: max_len = 0 n = len(s) for i in range(n): for j in range(i + 1, n + 1): if is_balanced(s[i:j]) and j - i > max_len: max_len = j - i results.append(max_len) return results # Example usage T = 3 strings = [\\"AaBbCc\\", \\"aabbCC\\", \\"AaAA\\"] output = largest_balanced_substring_length(T, strings) print(output) # This will output [6, 4, 2]"},{"question":"from typing import List def count_students_above_average(scores: List[int]) -> int: Returns the number of students who scored above the average score. >>> count_students_above_average([10, 20, 30, 40, 50]) 2 >>> count_students_above_average([60, 60, 60, 60]) 0","solution":"def count_students_above_average(scores): Returns the number of students who scored above the average score. n = len(scores) if n == 0: return 0 average_score = sum(scores) / n count_above_average = sum(score > average_score for score in scores) return count_above_average"},{"question":"def perform_operations(operations: List[str]) -> List[str]: Perform operations as described in the problem and return the results of \`typeof\` operations. >>> perform_operations([ \\"append 3 A\\", \\"append 5 A\\", \\"typeof 1 A\\", \\"typeof 2 A\\" ]) [\\"int\\", \\"errtype\\"] >>> perform_operations([ \\"append 3 A\\", \\"append 5 A\\", \\"typeof 1 A\\", \\"typeof 2 A\\", \\"reverse A\\", \\"typeof 1 A\\", \\"append 7 A\\", \\"typeof 2 A\\" ]) [\\"int\\", \\"errtype\\", \\"int\\", \\"int\\"] >>> perform_operations([ \\"append 10 B\\", \\"extend B C\\", \\"typeof 0 B\\", \\"extend C B\\", \\"reverse C\\", \\"typeof 1 C\\" ]) [\\"int\\", \\"errtype\\"] >>> perform_operations([ \\"typeof 0 A\\", \\"typeof 1 A\\", \\"typeof 0 B\\" ]) [\\"errtype\\", \\"errtype\\", \\"errtype\\"] >>> perform_operations([ \\"append 1 X\\", \\"append 2 X\\", \\"append 3 X\\", \\"append 4 Y\\", \\"append 5 Y\\", \\"extend X Y\\", \\"reverse X\\", \\"typeof 0 X\\", \\"typeof 4 X\\", \\"typeof 8 X\\", \\"typeof 0 Y\\", \\"typeof 1 Y\\", \\"typeof 2 Y\\" ]) [\\"int\\", \\"int\\", \\"errtype\\", \\"int\\", \\"int\\", \\"errtype\\"]","solution":"def perform_operations(operations): Perform operations as described in the problem and return the results of \`typeof\` operations. lists = {} results = [] for operation in operations: op = operation.split() cmd = op[0] if cmd == 'append': _, x, L = op x = int(x) if L not in lists: lists[L] = [] lists[L].append(x) elif cmd == 'extend': _, L1, L2 = op if L1 not in lists: lists[L1] = [] if L2 in lists: lists[L1].extend(lists[L2]) elif cmd == 'reverse': _, L = op if L in lists: lists[L].reverse() elif cmd == 'typeof': _, x, L = op x = int(x) if L in lists and 0 <= x < len(lists[L]): results.append(\\"int\\") else: results.append(\\"errtype\\") return results"},{"question":"def remove_duplicates(nums): Removes duplicate integers from the list while preserving the order of the first occurrence. :param nums: List of non-negative integers. :return: List of integers with duplicates removed. pass def test_remove_duplicates_example1(): assert remove_duplicates([4, 5, 9, 1, 1, 4, 3, 5, 8, 9]) == [4, 5, 9, 1, 3, 8] def test_remove_duplicates_example2(): assert remove_duplicates([7, 2, 2, 1, 7, 6, 2]) == [7, 2, 1, 6] def test_remove_duplicates_no_duplicates(): assert remove_duplicates([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_remove_duplicates_all_duplicates(): assert remove_duplicates([1, 1, 1, 1, 1]) == [1] def test_remove_duplicates_empty_list(): assert remove_duplicates([]) == [] def test_remove_duplicates_single_element(): assert remove_duplicates([4]) == [4]","solution":"def remove_duplicates(nums): Removes duplicate integers from the list while preserving the order of the first occurrence. :param nums: List of non-negative integers. :return: List of integers with duplicates removed. result = [] seen = set() for num in nums: if num not in seen: seen.add(num) result.append(num) return result"},{"question":"def verify_password(password: str) -> str: Verifies if the given password meets specific security criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character from the set !@#%^&*()-+ - Does not contain spaces Returns \\"Valid Password\\" if all criteria are met, otherwise returns a string explaining the failures. >>> verify_password(\\"StrongPass1!\\") \\"Valid Password\\" >>> verify_password(\\"Abc1!\\") \\"Invalid Password: Must be at least 8 characters long\\" >>> verify_password(\\"No_digit!\\") \\"Invalid Password: Must contain at least one digit\\" >>> verify_password(\\"NoSpecialCharacter123\\") \\"Invalid Password: Must contain at least one special character from the set !@#%^&*()-+\\" >>> verify_password(\\"Space Inv@der 123\\") \\"Invalid Password: Must not contain spaces\\"","solution":"def verify_password(password: str) -> str: Verifies if the given password meets security criteria: - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character from the set !@#%^&*()-+ - Does not contain spaces import re failed_criteria = [] special_characters = set(\\"!@#%^&*()-+\\") if len(password) < 8: failed_criteria.append(\\"Must be at least 8 characters long\\") if not re.search(\\"[A-Z]\\", password): failed_criteria.append(\\"Must contain at least one uppercase letter\\") if not re.search(\\"[a-z]\\", password): failed_criteria.append(\\"Must contain at least one lowercase letter\\") if not re.search(\\"[0-9]\\", password): failed_criteria.append(\\"Must contain at least one digit\\") if not any(char in special_characters for char in password): failed_criteria.append(\\"Must contain at least one special character from the set !@#%^&*()-+\\") if \\" \\" in password: failed_criteria.append(\\"Must not contain spaces\\") if failed_criteria: return \\"Invalid Password: \\" + \\", \\".join(failed_criteria) return \\"Valid Password\\""},{"question":"def find_path(grid: List[List[str]]) -> List[Tuple[int, int]]: Determines if there is a path from the top-left corner to the bottom-right corner of the grid while navigating around obstacles. If a path exists, returns the path as a list of tuples representing the coordinates of each cell in the path. If no path exists, returns an empty list. >>> find_path([['.', '.', '.', '.'], ['.', '#', '#', '.'], ['.', '.', '.', '#']]) [(1, 1), (1, 2), (1, 3), (1, 4), (2, 4), (3, 4)] >>> find_path([['.', '#'], ['#', '.']]) [] >>> find_path([['.']]) [(1, 1)] >>> find_path([['.', '.', '.'], ['.', '.', '.'], ['.', '.', '.']]) [(1, 1), (1, 2), (1, 3), (2, 3), (3, 3)] >>> find_path([['.', '#', '.'], ['.', '.', '.'], ['#', '.', '.']]) [(1, 1), (2, 1), (2, 2), (2, 3), (3, 3)]","solution":"def find_path(grid): n, m = len(grid), len(grid[0]) path = [] def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == '.' def dfs(x, y): if x == n-1 and y == m-1: path.append((x+1, y+1)) return True if not is_valid(x, y): return False # mark as visited grid[x][y] = '#' path.append((x+1, y+1)) # move right if y+1 < m and dfs(x, y+1): return True # move down if x+1 < n and dfs(x+1, y): return True # backtrack path.pop() grid[x][y] = '.' return False if dfs(0, 0): return path else: return [] # Example usage: grid = [ ['.', '.', '.', '.'], ['.', '#', '#', '.'], ['.', '.', '.', '#'] ] print(find_path(grid)) # Should return [(1, 1), (1, 2), (1, 3), (1, 4), (2, 4), (3, 4)]"},{"question":"def longest_increasing_streak(N: int, difficulty: List[int]) -> int: Returns the length of the longest streak of consecutive levels with strictly increasing difficulty scores. >>> longest_increasing_streak(7, [1, 3, 5, 4, 7, 6, 9]) 3 >>> longest_increasing_streak(5, [2, 2, 2, 2, 2]) 1 >>> longest_increasing_streak(4, [1, 2, 3, 4]) 4 >>> longest_increasing_streak(1, [5]) 1 >>> longest_increasing_streak(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_streak(9, [10, 12, 10, 11, 12, 13, 2, 3, 4]) 4","solution":"def longest_increasing_streak(N, difficulty): Returns the length of the longest streak of consecutive levels with strictly increasing difficulty scores. if N == 0: return 0 max_streak = 1 current_streak = 1 for i in range(1, N): if difficulty[i] > difficulty[i-1]: current_streak += 1 max_streak = max(max_streak, current_streak) else: current_streak = 1 return max_streak"},{"question":"def can_form_subset(arr, k, m): Determines if there exists a subset of arr such that: 1. The sum of the subset's elements is exactly k. 2. All elements of this subset are distinct and each element appears no more than m times in the original array. >>> can_form_subset([3, 34, 4, 12, 5], 9, 2) == \\"YES\\" >>> can_form_subset([3, 3, 3], 10, 1) == \\"NO\\" >>> can_form_subset([1, 2, -1, -2], 0, 1) == \\"YES\\"","solution":"def can_form_subset(arr, k, m): Determines if there exists a subset of arr such that: 1. The sum of the subset's elements is exactly k. 2. All elements of this subset are distinct and each element appears no more than m times in the original array. from itertools import combinations # Generate power set of arr n = len(arr) for r in range(1, n + 1): for subset in combinations(arr, r): if sum(subset) == k and all(subset.count(x) == 1 for x in subset) and all(arr.count(x) <= m for x in subset): return \\"YES\\" return \\"NO\\""},{"question":"def is_balanced_parentheses(expression: str) -> str: Checks if the parentheses in the given expression are balanced. Parameters: expression (str): The mathematical expression to be checked. Returns: str: \\"YES\\" if the parentheses are balanced, otherwise \\"NO\\". >>> is_balanced_parentheses(\\"3 + (2 * (4 - 1)) + (7 / (9 + 3))\\") \\"YES\\" >>> is_balanced_parentheses(\\"5 + (3 * (2 + 1)) - (4 / (3 - (2 * (8 / 4)))\\") \\"NO\\" # Function implementation should ensure that parentheses are balanced.","solution":"def is_balanced_parentheses(expression): Checks if the parentheses in the given expression are balanced. Parameters: expression (str): The mathematical expression to be checked. Returns: str: \\"YES\\" if the parentheses are balanced, otherwise \\"NO\\". stack = [] for char in expression: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\""},{"question":"def min_vehicles_needed(M: int, vehicle_ranges: List[Tuple[int, int]], N: int, office_coords: List[int]) -> int: Determine the minimum number of vehicles needed to ensure that all offices receive at least one package. >>> min_vehicles_needed(3, [(0, 5), (6, 10), (11, 15)], 5, [1, 4, 8, 9, 12]) 3 >>> min_vehicles_needed(2, [(0, 7), (8, 10)], 6, [1, 2, 3, 8, 9, 10]) 2 >>> min_vehicles_needed(1, [(0, 0)], 1, [1]) -1 >>> min_vehicles_needed(1, [(0, 10)], 5, [5, 5, 5, 5, 5]) 1 >>> min_vehicles_needed(2, [(0, 3), (5, 10)], 5, [1, 2, 4, 6, 7]) -1 pass","solution":"def min_vehicles_needed(M, vehicle_ranges, N, office_coords): # Sort office coordinates to cover them sequentially office_coords.sort() # Sort vehicles by their start points, then by their end points vehicle_ranges.sort(key=lambda x: (x[0], x[1])) covered_offices = 0 num_vehicles = 0 while covered_offices < N: max_reach = -1 while (num_vehicles < M and vehicle_ranges[num_vehicles][0] <= office_coords[covered_offices]): max_reach = max(max_reach, vehicle_ranges[num_vehicles][1]) num_vehicles += 1 if max_reach < office_coords[covered_offices]: return -1 # Not possible to cover this office while (covered_offices < N and office_coords[covered_offices] <= max_reach): covered_offices += 1 return num_vehicles"},{"question":"def graph_diameter(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph with n nodes and m edges, determine the maximum distance between any two nodes in the graph, also known as the diameter of the graph. If the graph is not connected, return -1. >>> graph_diameter(5, 4, [(1, 2), (1, 3), (3, 4), (4, 5)]) 4 >>> graph_diameter(4, 3, [(1, 2), (2, 3), (2, 4)]) 2 >>> graph_diameter(3, 1, [(1, 2)]) -1 >>> graph_diameter(1, 0, []) 0 >>> graph_diameter(5, 2, [(1, 2), (3, 4)]) -1 >>> graph_diameter(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 5 >>> graph_diameter(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) 1 pass","solution":"from collections import deque def bfs_max_distance(graph, start_node, n): distances = [-1] * n queue = deque([(start_node, 0)]) distances[start_node] = 0 max_distance = 0 while queue: node, distance = queue.popleft() for neighbor in graph[node]: if distances[neighbor] == -1: # Not visited distances[neighbor] = distance + 1 queue.append((neighbor, distance + 1)) max_distance = max(max_distance, distance + 1) return max_distance, distances def graph_diameter(n, m, edges): if n == 1: return 0 graph = [[] for _ in range(n)] for u, v in edges: graph[u - 1].append(v - 1) graph[v - 1].append(u - 1) first_bfs_max_distance, first_bfs_distances = bfs_max_distance(graph, 0, n) if -1 in first_bfs_distances: return -1 farthest_node = first_bfs_distances.index(first_bfs_max_distance) diameter, _ = bfs_max_distance(graph, farthest_node, n) return diameter"},{"question":"from typing import List def max_price_difference(previous_prices: List[int], current_prices: List[int]) -> int: Identify the maximum price difference for any product between the two days, considering only those products which have a higher price on the current day compared to the previous day. >>> max_price_difference([10, 20, 15, 8, 25], [12, 18, 15, 10, 30]) 5 >>> max_price_difference([5, 5, 5], [5, 5, 5]) 0 def test_no_price_increase(): assert max_price_difference([5, 5, 5], [5, 5, 5]) == 0 def test_all_prices_decrease_or_stay_same(): assert max_price_difference([10, 20, 30], [9, 15, 25]) == 0 def test_mixed_price_changes(): assert max_price_difference([10, 20, 15, 8, 25], [12, 18, 15, 10, 30]) == 5 def test_all_prices_increase(): assert max_price_difference([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]) == 5 def test_large_input(): previous_prices = [i for i in range(1, 100001)] current_prices = [i + 1 for i in range(1, 100001)] assert max_price_difference(previous_prices, current_prices) == 1 def test_single_element_increase(): assert max_price_difference([1], [10]) == 9 def test_single_element_no_increase(): assert max_price_difference([1], [1]) == 0","solution":"from typing import List def max_price_difference(previous_prices: List[int], current_prices: List[int]) -> int: max_difference = 0 for prev, curr in zip(previous_prices, current_prices): if curr > prev: max_difference = max(max_difference, curr - prev) return max_difference"},{"question":"from typing import List def max_square_cages(n: int, plank_lengths: List[int]) -> int: Calculate the maximum number of square cages that can be built using the available planks. Args: n (int): The number of wooden planks. plank_lengths (List[int]): List of lengths of the wooden planks in millimeters. Returns: int: Maximum number of square cages that can be built. Examples: >>> max_square_cages(8, [2, 2, 2, 2, 3, 3, 3, 3]) 2 >>> max_square_cages(5, [7, 7, 7, 7, 7]) 1 >>> max_square_cages(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) 0","solution":"def max_square_cages(n, plank_lengths): from collections import Counter plank_counter = Counter(plank_lengths) cages = 0 for length in plank_counter: cages += plank_counter[length] // 4 return cages"},{"question":"def longest_substring_with_one_distinct_char(S: str, K: int) -> int: You are given a string S containing only lowercase alphabets and an integer K. Your task is to replace exactly K characters in the string such that the resulting string has the longest possible substring that contains only one distinct character. >>> longest_substring_with_one_distinct_char(\\"abbac\\", 2) 4 >>> longest_substring_with_one_distinct_char(\\"aabccdee\\", 1) 3","solution":"def longest_substring_with_one_distinct_char(S, K): n = len(S) max_len = 0 for i in range(26): char_to_try = chr(i + ord('a')) left = 0 changes = 0 for right in range(n): if S[right] != char_to_try: changes += 1 while changes > K: if S[left] != char_to_try: changes -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def max_points(grid: List[List[int]]) -> int: Determine the maximum number of points the character can collect on the way to the bottom-right corner of the grid. >>> max_points([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_points([[1, 2], [1, 1]]) 4 >>> max_points([[5]]) 5 >>> max_points([[1, 2, 3, 4]]) 10 >>> max_points([[1], [2], [3]]) 6 >>> max_points([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def max_points(grid): n = len(grid) m = len(grid[0]) # Create a DP table initialized with zeros dp = [[0] * m for _ in range(n)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the maximum points we can collect return dp[-1][-1]"},{"question":"def smallest_n_digit_number(n: int, k: int) -> int: Given an integer n, finds the smallest n-digit number such that the sum of its digits is divisible by a given integer k. Parameters: n (int): number of digits. k (int): the integer by which the sum of the digits should be divisible. Returns: int: the smallest n-digit number meeting the criteria. >>> smallest_n_digit_number(2, 4) == 13 >>> smallest_n_digit_number(3, 5) == 104","solution":"def smallest_n_digit_number(n, k): Returns the smallest n-digit number whose sum of digits is divisible by k. def digit_sum(x): return sum(int(d) for d in str(x)) # The smallest n-digit number is 10**(n-1) start = 10**(n-1) end = 10**n # End is 10**n because it is the smallest (n+1)-digit number for number in range(start, end): if digit_sum(number) % k == 0: return number return -1 # In case there is no such number"},{"question":"def product_of_four_integers(b1: int, b2: int, b3: int, b4: int) -> int: Returns the product of four integers b1, b2, b3, b4. >>> product_of_four_integers(1, 5, 7, 2) 70 >>> product_of_four_integers(6, 9, 3, 12) 1944 >>> product_of_four_integers(10, 4, 2, 8) 640 >>> product_of_four_integers(20, 15, 5, 10) 15000","solution":"def product_of_four_integers(b1, b2, b3, b4): Returns the product of four integers b1, b2, b3, b4. return b1 * b2 * b3 * b4"},{"question":"def merge_sorted_lists(n: int, m: int, list1: List[int], list2: List[int]) -> List[int]: Merges two sorted lists into one sorted list in non-decreasing order. Parameters: n (int): Length of the first list. m (int): Length of the second list. list1 (list of int): The first sorted list. list2 (list of int): The second sorted list. Returns: list of int: A merged sorted list. Examples: >>> merge_sorted_lists(7, 5, [1, 3, 5, 7, 9, 11, 13], [2, 4, 6, 8, 10]) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13] >>> merge_sorted_lists(4, 0, [1, 3, 5, 7], []) [1, 3, 5, 7] >>> merge_sorted_lists(0, 3, [], [2, 4, 6]) [2, 4, 6] >>> merge_sorted_lists(0, 0, [], []) [] >>> merge_sorted_lists(1, 1, [0], [0]) [0, 0] >>> merge_sorted_lists(3, 3, [1, 2, 3], [1, 2, 3]) [1, 1, 2, 2, 3, 3] >>> merge_sorted_lists(3, 2, [-1000000000, 0, 1000000000], [-500000000, 500000000]) [-1000000000, -500000000, 0, 500000000, 1000000000] >>> merge_sorted_lists(1, 1, [1], [2]) [1, 2] >>> merge_sorted_lists(1, 1, [2], [1]) [1, 2] >>> merge_sorted_lists(1, 0, [1], []) [1] >>> merge_sorted_lists(0, 1, [], [1]) [1]","solution":"def merge_sorted_lists(n, m, list1, list2): Merges two sorted lists into one sorted list in non-decreasing order. Parameters: n (int): Length of the first list. m (int): Length of the second list. list1 (list of int): The first sorted list. list2 (list of int): The second sorted list. Returns: list of int: A merged sorted list. i = 0 j = 0 merged_list = [] while i < n and j < m: if list1[i] <= list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 while i < n: merged_list.append(list1[i]) i += 1 while j < m: merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"def count_odd_product_pairs(n: int, sequence: List[int]) -> int: Returns the number of pairs (i, j) where 1 ≤ i < j ≤ n and the product of the ith and jth elements is odd. :param n: int, number of elements in the sequence :param sequence: list of int, the sequence of distinct integers :return: int, number of pairs with odd product >>> count_odd_product_pairs(4, [3, 4, 7, 10]) == 1 >>> count_odd_product_pairs(5, [1, 2, 3, 4, 5]) == 3 >>> count_odd_product_pairs(3, [1, 3, 5]) == 3 >>> count_odd_product_pairs(6, [2, 4, 6, 8, 10, 12]) == 0 >>> count_odd_product_pairs(1, [1]) == 0 >>> count_odd_product_pairs(2, [2, 3]) == 0 >>> count_odd_product_pairs(3, [1, 2, 3]) == 1","solution":"def count_odd_product_pairs(n, sequence): Returns the number of pairs (i, j) where 1 ≤ i < j ≤ n and the product of the ith and jth elements is odd. :param n: int, number of elements in the sequence :param sequence: list of int, the sequence of distinct integers :return: int, number of pairs with odd product odd_count = sum(1 for x in sequence if x % 2 != 0) # All possible pairs (i, j) where i < j and both are odd return odd_count * (odd_count - 1) // 2"},{"question":"def calculate_trapped_water(heights: List[int]) -> int: Calculates the total amount of water trapped between buildings. >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([1, 1, 1, 1]) 0 >>> calculate_trapped_water([1, 0, 1]) 1 >>> calculate_trapped_water([0, 1, 2, 3, 4]) 0 >>> calculate_trapped_water([4, 3, 2, 1, 0]) 0 >>> calculate_trapped_water([]) 0 >>> calculate_trapped_water([0]) 0 >>> calculate_trapped_water([1, 2, 1, 2, 1]) 1","solution":"def calculate_trapped_water(heights): Calculates the total amount of water trapped between buildings. :param heights: List of integers representing the heights of the buildings :return: Integer representing the total water trapped if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def repeat_first_char(S: str, N: int) -> str: Returns a string with the first character of S repeated N times, followed by the rest of the original string S. >>> repeat_first_char(\\"hello\\", 3) == \\"hhhello\\" >>> repeat_first_char(\\"a\\", 5) == \\"aaaaa\\" >>> repeat_first_char(\\"world\\", 10) == \\"wwwwwwwwwworld\\" >>> repeat_first_char(\\"python\\", 1) == \\"python\\" >>> repeat_first_char(\\"example\\", 0) == \\"example\\" >>> repeat_first_char(\\"\\", 3) == \\"\\"","solution":"def repeat_first_char(S, N): Returns a string with the first character of S repeated N times, followed by the rest of the original string S. if not S or N <= 0: return S first_char = S[0] repeated_string = first_char * N + S[1:] return repeated_string"},{"question":"def check_stock(n: int, t_reorder: int, changes: List[Tuple[int, int]]) -> str: Determines the stock level at the latest recorded timestamp and decides whether more stock is required. Args: n (int): number of stock changes t_reorder (int): reorder threshold changes (list): a list of tuples (t, q), where t is time and q is quantity change Returns: str: \\"Order More Stock\\" or \\"Stock Level Sufficient\\" # Your code here # Test cases def test_check_stock_order_more(): n = 3 t_reorder = 50 changes = [(5, 30), (10, -20), (15, 25)] assert check_stock(n, t_reorder, changes) == \\"Order More Stock\\" def test_check_stock_stock_sufficient(): n = 2 t_reorder = 10 changes = [(5, 10), (10, 5)] assert check_stock(n, t_reorder, changes) == \\"Stock Level Sufficient\\" def test_check_stock_exact_threshold(): n = 4 t_reorder = 100 changes = [(1, 50), (2, 30), (3, 10), (4, 10)] assert check_stock(n, t_reorder, changes) == \\"Stock Level Sufficient\\" def test_check_stock_negative_stock(): n = 2 t_reorder = 0 changes = [(5, -100), (10, 50)] assert check_stock(n, t_reorder, changes) == \\"Order More Stock\\" def test_check_stock_zero_threshold(): n = 3 t_reorder = 0 changes = [(1, -5), (2, -10), (3, 20)] assert check_stock(n, t_reorder, changes) == \\"Stock Level Sufficient\\"","solution":"def check_stock(n, t_reorder, changes): Determines the stock level at the latest recorded timestamp and decides whether more stock is required. Args: n (int): number of stock changes t_reorder (int): reorder threshold changes (list): a list of tuples (t, q), where t is time and q is quantity change Returns: str: \\"Order More Stock\\" or \\"Stock Level Sufficient\\" final_stock = 0 for change in changes: time, quantity = change final_stock += quantity if final_stock < t_reorder: return \\"Order More Stock\\" else: return \\"Stock Level Sufficient\\""},{"question":"from typing import List, Tuple def minimum_completion_time(n: int, task_times: List[int], d: int, dependencies: List[Tuple[int, int]]) -> int: Determine the minimum number of days required to complete all tasks, considering their dependencies and execution times. Parameters: n (int): Number of tasks task_times (List[int]): Execution times for each task d (int): Number of dependencies dependencies (List[Tuple[int, int]]): List of dependencies Returns: int: Minimum number of days to complete all tasks Examples: >>> minimum_completion_time(5, [3, 2, 1, 4, 6], 4, [(1, 2), (1, 3), (3, 4), (2, 5)]) 11 >>> minimum_completion_time(3, [5, 3, 2], 0, []) 5 >>> minimum_completion_time(4, [1, 2, 3, 4], 3, [(1, 2), (2, 3), (3, 4)]) 10","solution":"from collections import defaultdict, deque def minimum_completion_time(n, task_times, d, dependencies): # Create a graph representation graph = defaultdict(list) in_degree = [0] * n min_completion_time = [0] * n for u, v in dependencies: graph[u-1].append(v-1) in_degree[v-1] += 1 # Queue for tasks with no dependencies queue = deque() for i in range(n): if in_degree[i] == 0: queue.append(i) min_completion_time[i] = task_times[i] while queue: current_task = queue.popleft() for neighbor in graph[current_task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) min_completion_time[neighbor] = max(min_completion_time[neighbor], min_completion_time[current_task] + task_times[neighbor]) return max(min_completion_time) # Example usage: # tasks = 5 # task_times = [3, 2, 1, 4, 6] # dependencies = [(1, 2), (1, 3), (3, 4), (2, 5)] # print(minimum_completion_time(tasks, task_times, len(dependencies), dependencies)) # Output: 11"},{"question":"def find_pair_with_sum(n: int, arr: List[int], target: int) -> str: Returns \\"Yes\\" if there exists at least one pair of integers in the list whose sum is equal to the target value. Otherwise, returns \\"No\\". >>> find_pair_with_sum(5, [1, 2, 3, 4, 5], 9) == \\"Yes\\" >>> find_pair_with_sum(4, [2, 7, 11, 15], 18) == \\"Yes\\" >>> find_pair_with_sum(3, [1, 2, 3], 7) == \\"No\\" def test_example_1(): assert find_pair_with_sum(5, [1, 2, 3, 4, 5], 9) == \\"Yes\\" def test_example_2(): assert find_pair_with_sum(4, [2, 7, 11, 15], 18) == \\"Yes\\" def test_example_3(): assert find_pair_with_sum(3, [1, 2, 3], 7) == \\"No\\" def test_no_pair(): assert find_pair_with_sum(4, [1, 2, 3, 4], 8) == \\"No\\" def test_pair_with_negatives(): assert find_pair_with_sum(5, [-1, -2, -3, -4, -5], -8) == \\"Yes\\" def test_pair_include_zero(): assert find_pair_with_sum(3, [0, 2, -2], 0) == \\"Yes\\" def test_large_numbers(): assert find_pair_with_sum(2, [1000000000, 1000000000], 2000000000) == \\"Yes\\" def test_no_pair_large_range(): assert find_pair_with_sum(4, [-1000000000, -100000000, 100000, 999999999], 2000000000) == \\"No\\"","solution":"def find_pair_with_sum(n, arr, target): Returns \\"Yes\\" if there exists at least one pair of integers in the list whose sum is equal to the target value x. Otherwise, returns \\"No\\". seen = set() for num in arr: if target - num in seen: return \\"Yes\\" seen.add(num) return \\"No\\""},{"question":"def max_continuous_plus_sections(ropes: List[str]) -> List[int]: Returns the maximum number of continuous '+' sections in any piece of each rope. :param ropes: List of strings where each string represents a rope with '+' and '-' characters. :return: List of integers where each integer is the maximum number of continuous '+' sections in each rope. Example: >>> max_continuous_plus_sections([\\"++--+--++-+++\\"]) [3] >>> max_continuous_plus_sections([\\"++++++++++++++\\"]) [14] >>> max_continuous_plus_sections([\\"+----+-++-+-+-+\\"]) [2]","solution":"def max_continuous_plus_sections(ropes): Returns the maximum number of continuous '+' sections in any piece of each rope. :param ropes: List of strings where each string represents a rope with '+' and '-' characters. :return: List of integers where each integer is the maximum number of continuous '+' sections in each rope. result = [] for rope in ropes: max_section = 0 current_section = 0 for char in rope: if char == '+': current_section += 1 if current_section > max_section: max_section = current_section else: current_section = 0 result.append(max_section) return result"},{"question":"def longest_nice_substring(n: int, s: str) -> int: Finds the length of the longest \\"nice\\" substring in the given string. A substring is considered \\"nice\\" if it contains at least one vowel and one consonant. Parameters: n (int): Length of the string s. s (str): Given string consisting of lowercase English letters. Returns: int: Length of the longest \\"nice\\" substring. If no such substring exists, returns 0. >>> longest_nice_substring(10, \\"abcdeffghi\\") 10 >>> longest_nice_substring(6, \\"aaaaaa\\") 0 pass","solution":"def longest_nice_substring(n, s): Finds the length of the longest \\"nice\\" substring in the given string. A substring is considered \\"nice\\" if it contains at least one vowel and one consonant. Parameters: n (int): Length of the string s. s (str): Given string consisting of lowercase English letters. Returns: int: Length of the longest \\"nice\\" substring. If no such substring exists, returns 0. vowels = {'a', 'e', 'i', 'o', 'u'} longest_nice_len = 0 for start in range(n): has_vowel = False has_consonant = False for end in range(start, n): if s[end] in vowels: has_vowel = True else: has_consonant = True if has_vowel and has_consonant: longest_nice_len = max(longest_nice_len, end - start + 1) return longest_nice_len"},{"question":"def sort_and_merge(N: int, K: int, A: List[int]) -> List[int]: Sorts and merges the array after splitting into subarrays of size K. Args: N : int - size of array A K : int - size of each subarray A : list of int - the array to be processed Returns: list of int - the final sorted array after operations # Your code # Unit tests def test_sort_and_merge_sample_input_1(): N = 10 K = 2 A = [3, 1, 2, 6, 8, 4, 5, 7, 9, 0] expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] assert sort_and_merge(N, K, A) == expected def test_sort_and_merge_single_element_subarrays(): N = 5 K = 1 A = [5, 3, 4, 1, 2] expected = [1, 2, 3, 4, 5] assert sort_and_merge(N, K, A) == expected def test_sort_and_merge_whole_array_one_subarray(): N = 5 K = 5 A = [5, 3, 4, 1, 2] expected = [1, 2, 3, 4, 5] assert sort_and_merge(N, K, A) == expected def test_sort_and_merge_equal_elements(): N = 6 K = 3 A = [2, 2, 2, 1, 1, 1] expected = [1, 1, 1, 2, 2, 2] assert sort_and_merge(N, K, A) == expected def test_sort_and_merge_large_k(): N = 8 K = 4 A = [7, 6, 5, 8, 4, 3, 2, 1] expected = [1, 2, 3, 4, 5, 6, 7, 8] assert sort_and_merge(N, K, A) == expected def test_sort_and_merge_all_elements_different(): N = 9 K = 3 A = [9, 8, 7, 6, 5, 4, 3, 2, 1] expected = [1, 2, 3, 4, 5, 6, 7, 8, 9] assert sort_and_merge(N, K, A) == expected def test_sort_and_merge_single_element(): N = 1 K = 1 A = [1] expected = [1] assert sort_and_merge(N, K, A) == expected","solution":"def sort_and_merge(N, K, A): Sorts and merges the array after splitting into subarrays of size K. Args: N : int - size of array A K : int - size of each subarray A : list of int - the array to be processed Returns: list of int - the final sorted array after operations result = [] for i in range(0, N, K): subarray = A[i:i+K] subarray.sort() result.extend(subarray) result.sort() return result"},{"question":"def clean_email_records(n, records): Cleans the email records by removing redundant inactive records and retaining only the necessary records. :param n: Number of email records in the database :param records: List of tuples, each containing an email and its status indicator :return: List of cleaned email records Examples: >>> clean_email_records(1, [(\\"alice@example.com\\", \\"active\\")]) [(\\"alice@example.com\\", \\"active\\")] >>> clean_email_records(2, [(\\"bob@example.com\\", \\"inactive\\"), (\\"bob@example.com\\", \\"inactive\\")]) [(\\"bob@example.com\\", \\"inactive\\")] >>> clean_email_records(2, [(\\"charlie@example.org\\", \\"active\\"), (\\"charlie@example.org\\", \\"active\\")]) [(\\"charlie@example.org\\", \\"active\\")] >>> clean_email_records(2, [(\\"dave@example.net\\", \\"inactive\\"), (\\"dave@example.net\\", \\"active\\")]) [(\\"dave@example.net\\", \\"active\\")] >>> clean_email_records(7, [ (\\"alice@example.com\\", \\"active\\"), (\\"bob@example.com\\", \\"inactive\\"), (\\"alice@example.com\\", \\"inactive\\"), (\\"charlie@example.org\\", \\"active\\"), (\\"alice@example.com\\", \\"active\\"), (\\"bob@example.com\\", \\"inactive\\"), (\\"dave@example.net\\", \\"active\\")]) [ (\\"alice@example.com\\", \\"active\\"), (\\"bob@example.com\\", \\"inactive\\"), (\\"charlie@example.org\\", \\"active\\"), (\\"dave@example.net\\", \\"active\\") ]","solution":"def clean_email_records(n, records): Cleans the email records by removing redundant inactive records and retaining only the necessary records. :param n: Number of email records in the database :param records: List of tuples, each containing an email and its status indicator :return: List of cleaned email records email_status = {} for email, status in records: if email in email_status: if status == \\"active\\": email_status[email] = \\"active\\" else: email_status[email] = status cleaned_records = [(email, status) for email, status in email_status.items()] return cleaned_records"},{"question":"def employee_performance_statistics(input_data): Given a list of datasets where each dataset represents the performance scores of an employee over several months, this function calculates the average performance score, the highest performance score, and the lowest performance score for each dataset. Parameters: input_data (list of lists): List of datasets where each dataset is a list containing the number of months followed by the performance scores. Returns: list of tuples: Each tuple contains the average performance score, highest performance score, and lowest performance score for an employee in the corresponding dataset. >>> employee_performance_statistics([ [4, 95, 85, 90, 100], [3, 70, 60, 80], [2, 100, 85], [0] ]) [(92.50, 100, 85), (70.00, 80, 60), (92.50, 100, 85)] >>> employee_performance_statistics([ [1, 50], [0] ]) [(50.0, 50, 50)] >>> employee_performance_statistics([ [5, 75, 75, 75, 75, 75], [0] ]) [(75.0, 75, 75)] >>> employee_performance_statistics([ [3, 0, 50, 100], [0] ]) [(50.0, 100, 0)] >>> employee_performance_statistics([ [0] ]) []","solution":"def employee_performance_statistics(input_data): Given a list of datasets where each dataset represents the performance scores of an employee over several months, this function calculates the average performance score, the highest performance score, and the lowest performance score for each dataset. Parameters: input_data (list of lists): List of datasets where each dataset is a list containing the number of months followed by the performance scores. Returns: list of tuples: Each tuple contains the average performance score, highest performance score, and lowest performance score for an employee in the corresponding dataset. results = [] for data in input_data: if data[0] == 0: break n = data[0] scores = data[1:n+1] average_score = round(sum(scores) / n, 2) highest_score = max(scores) lowest_score = min(scores) results.append((average_score, highest_score, lowest_score)) return results # Sample Input and Output to test the function input_data = [ [4, 95, 85, 90, 100], [3, 70, 60, 80], [2, 100, 85], [0] ] print(employee_performance_statistics(input_data)) # Expected Output: [(92.5, 100, 85), (70.0, 80, 60), (92.5, 100, 85)]"},{"question":"def count_complete_orders(pie_codes: str) -> int: This function takes in a string representing pie codes and returns the maximum number of complete orders that can be fulfilled. >>> count_complete_orders(\\"ABCEDCABACDC\\") 2 >>> count_complete_orders(\\"AAA\\") 0 >>> count_complete_orders(\\"ABCDEABCDEABCDE\\") 3","solution":"def count_complete_orders(pie_codes): This function takes in a string representing pie codes and returns the maximum number of complete orders that can be fulfilled. from collections import Counter # Count the occurrences of each pie code pie_count = Counter(pie_codes) # Initialize the number of complete orders to an arbitrarily large number complete_orders = float('inf') # The required pies for a complete order required_pies = 'ABCDE' for pie in required_pies: # How many times can we use this pie in a complete order complete_orders = min(complete_orders, pie_count[pie] // required_pies.count(pie)) return complete_orders"},{"question":"def min_path_cost(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum total cost to reach the bottom-right cell from the top-left cell given a grid of costs. >>> min_path_cost(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 True >>> min_path_cost(1, 1, [ ... [5] ... ]) == 5 True >>> min_path_cost(1, 3, [ ... [1, 2, 3] ... ]) == 6 True >>> min_path_cost(3, 1, [ ... [1], ... [2], ... [3] ... ]) == 6 True >>> min_path_cost(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 5 True pass","solution":"def min_path_cost(n, m, grid): Returns the minimum total cost to reach the bottom-right cell from the top-left cell given a grid of costs. # Create a 2D dp array to store the minimum cost to reach each cell dp = [[0] * m for _ in range(n)] # Initialize the top-left corner with the starting cell cost dp[0][0] = grid[0][0] # Initialize the first row (can only come from the left) for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Initialize the first column (can only come from above) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp array for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[n-1][m-1]"},{"question":"def total_work_time(N: int, K: int, A: List[int]) -> int: Calculate the total time robots will work before overheating. Parameters: N (int): Number of subtasks K (int): Threshold difficulty level A (list of int): List representing the difficulty levels of the subtasks Returns: int: Total work time before overheating pass def test_no_overheating(): assert total_work_time(5, 4, [1, 2, 3, 4, 5]) == 15 def test_overheating(): assert total_work_time(7, 3, [1, 3, 3, 3, 2, 1, 4]) == 7 def test_no_subtasks(): assert total_work_time(0, 3, []) == 0 def test_all_subtasks_below_threshold(): assert total_work_time(4, 5, [1, 2, 3, 4]) == 10 def test_overheating_at_end(): assert total_work_time(6, 3, [2, 2, 3, 3, 3, 2]) == 10 def test_overheating_early(): assert total_work_time(5, 3, [3, 3, 3, 2, 1]) == 6 def test_single_subtask(): assert total_work_time(1, 2, [3]) == 3 def test_two_subtasks_no_consecutive_overheat(): assert total_work_time(2, 2, [2, 2]) == 4 def test_three_subtasks_no_overheat(): assert total_work_time(3, 4, [1, 3, 2]) == 6","solution":"def total_work_time(N, K, A): Calculate the total time robots will work before overheating. Parameters: N (int): Number of subtasks K (int): Threshold difficulty level A (list of int): List representing the difficulty levels of the subtasks Returns: int: Total work time before overheating total_time = 0 for i in range(N): if i >= 2 and A[i] >= K and A[i-1] >= K and A[i-2] >= K: return total_time total_time += A[i] return total_time"},{"question":"from typing import List, Tuple def problems_in_range(n: int, difficulties: List[int], q: int, queries: List[Tuple[int, int]]) -> List[int]: Given the number of problems \`n\` and list of \`difficulties\` of the problems, along with \`q\` number of queries where each query contains a range \`[l, r]\`, returns a list containing number of problems that fall within each range. >>> problems_in_range(5, [1, 10, 5, 7, 3], 3, [(1, 5), (6, 10), (2, 8)]) [3, 2, 3] >>> problems_in_range(5, [1, 10, 5, 7, 3], 1, [(11, 15)]) [0] >>> problems_in_range(5, [1, 10, 5, 7, 3], 1, [(1, 10)]) [5] >>> problems_in_range(5, [1, 10, 5, 7, 3], 1, [(10, 10)]) [1] >>> problems_in_range(1, [500000000], 1, [(500000000, 500000000)]) [1] >>> problems_in_range(100000, list(range(1, 100001)), 1, [(50000, 50000)]) [1]","solution":"from bisect import bisect_left, bisect_right def problems_in_range(n, difficulties, q, queries): Given the number of problems \`n\` and list of \`difficulties\` of the problems, along with \`q\` number of queries where each query contains a range \`[l, r]\`, returns a list containing number of problems that fall within each range. difficulties.sort() results = [] for l, r in queries: left_index = bisect_left(difficulties, l) right_index = bisect_right(difficulties, r) - 1 count = 0 if left_index <= right_index: count = right_index - left_index + 1 results.append(count) return results"},{"question":"from typing import List def verify_sorting(original: List[int], sorted_by_algorithm: List[int]) -> str: Verifies whether the array sorted_by_algorithm matches the array sorted by Python's standard sorting function. Parameters: - original: List[int] - the original unsorted array. - sorted_by_algorithm: List[int] - the array sorted by Alex's algorithm. Returns: - str: \\"Correct\\" if sorted_by_algorithm matches the array sorted by the standard library, otherwise \\"Incorrect\\". >>> verify_sorting([3, 1, 4, 1, 5], [1, 1, 3, 4, 5]) 'Correct' >>> verify_sorting([3, 1, 4, 1, 5], [1, 3, 4, 5, 1]) 'Incorrect' >>> verify_sorting([], []) 'Correct' >>> verify_sorting([2, 3, 1], [2, 1, 3]) 'Incorrect'","solution":"from typing import List def verify_sorting(original: List[int], sorted_by_algorithm: List[int]) -> str: Verifies whether the array sorted_by_algorithm matches the array sorted by Python's standard sorting function. Parameters: - original: List[int] - the original unsorted array. - sorted_by_algorithm: List[int] - the array sorted by Alex's algorithm. Returns: - str: \\"Correct\\" if sorted_by_algorithm matches the array sorted by the standard library, otherwise \\"Incorrect\\". if sorted(original) == sorted_by_algorithm: return \\"Correct\\" else: return \\"Incorrect\\""},{"question":"class Spreadsheet: def __init__(self, rows, cols): Initialize your data structure here. self.rows = rows self.cols = cols self.sheet = [[0] * cols for _ in range(rows)] def set_cell(self, row, col, value): Set the value of a specific cell. self.sheet[row][col] = value def get_cell(self, row, col): Get the value of a specific cell. return self.sheet[row][col] def sum_range(self, row_start, col_start, row_end, col_end): Calculate the sum of values within a rectangular range of cells. return sum(self.sheet[i][j] for i in range(row_start, row_end + 1) for j in range(col_start, col_end + 1)) def set_range(self, row_start, col_start, row_end, col_end, value): Set the value of all cells within a rectangular range. for i in range(row_start, row_end + 1): for j in range(col_start, col_end + 1): self.sheet[i][j] = value # Example: spreadsheet = Spreadsheet(3, 3) spreadsheet.set_cell(0, 0, 5) spreadsheet.set_cell(0, 1, 3) spreadsheet.set_cell(0, 2, 8) spreadsheet.set_cell(1, 0, 6) spreadsheet.set_cell(2, 2, 2) print(spreadsheet.get_cell(0, 1)) # Output: 3 print(spreadsheet.sum_range(0, 0, 1, 1)) # Output: 14 spreadsheet.set_range(1, 1, 2, 2, 10) print(spreadsheet.sum_range(1, 1, 2, 2)) # Output: 40","solution":"class Spreadsheet: def __init__(self, rows, cols): Initialize your data structure here. self.rows = rows self.cols = cols self.sheet = [[0] * cols for _ in range(rows)] def set_cell(self, row, col, value): Set the value of a specific cell. self.sheet[row][col] = value def get_cell(self, row, col): Get the value of a specific cell. return self.sheet[row][col] def sum_range(self, row_start, col_start, row_end, col_end): Calculate the sum of values within a rectangular range of cells. return sum(self.sheet[i][j] for i in range(row_start, row_end + 1) for j in range(col_start, col_end + 1)) def set_range(self, row_start, col_start, row_end, col_end, value): Set the value of all cells within a rectangular range. for i in range(row_start, row_end + 1): for j in range(col_start, col_end + 1): self.sheet[i][j] = value"},{"question":"def is_palindrome(word: str) -> str: Check if a given word is a palindrome, ignoring case. Returns \\"YES\\" if word is a palindrome, otherwise \\"NO\\". def process_words(words: List[str]) -> List[str]: Process a list of words to determine if each is a palindrome. Returns a list of results with \\"YES\\" or \\"NO\\" for each word. # Unit tests def test_is_palindrome(): assert is_palindrome(\\"Madam\\") == \\"YES\\" assert is_palindrome(\\"Hello\\") == \\"NO\\" assert is_palindrome(\\"Racecar\\") == \\"YES\\" assert is_palindrome(\\"World\\") == \\"NO\\" assert is_palindrome(\\"a\\") == \\"YES\\" assert is_palindrome(\\"Aa\\") == \\"YES\\" assert is_palindrome(\\"AbBa\\") == \\"YES\\" assert is_palindrome(\\"ab\\") == \\"NO\\" def test_process_words(): words = [\\"Madam\\", \\"Hello\\", \\"Racecar\\", \\"World\\"] expected = [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] assert process_words(words) == expected words = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] expected = [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] assert process_words(words) == expected words = [\\"AbBa\\", \\"abba\\", \\"abBa\\", \\"aBbA\\"] expected = [\\"YES\\", \\"YES\\", \\"YES\\", \\"YES\\"] assert process_words(words) == expected words = [\\"abc\\", \\"def\\", \\"ghi\\"] expected = [\\"NO\\", \\"NO\\", \\"NO\\"] assert process_words(words) == expected words = [\\"ab\\", \\"ba\\", \\"cc\\"] expected = [\\"NO\\", \\"NO\\", \\"YES\\"] assert process_words(words) == expected","solution":"def is_palindrome(word): Check if a given word is a palindrome, ignoring case. Returns \\"YES\\" if word is a palindrome, otherwise \\"NO\\". word = word.lower() if word == word[::-1]: return \\"YES\\" else: return \\"NO\\" def process_words(words): Process a list of words to determine if each is a palindrome. Returns a list of results with \\"YES\\" or \\"NO\\" for each word. return [is_palindrome(word) for word in words]"},{"question":"from typing import List, Tuple def process_queries(n: int, array: List[int], q: int, queries: List[Tuple[int, int, int]]) -> List[int]: Processes a sequence of n integers and performs a series of operations on subsequences of the array. Possible operations are: - sum(b, e): calculates and returns the sum of the elements a_b, a_{b+1}, ..., a_{e-1} - product(b, e): calculates and returns the product of the elements a_b, a_{b+1}, ..., a_{e-1} Args: n (int): The number of elements in the array. array (List[int]): The list of elements. q (int): The number of queries. queries (List[Tuple[int, int, int]]): The list of queries where each query is represented as a tuple (command, b, e). Returns: List[int]: The list of results for each query. Example: >>> process_queries(8, [1, 2, 3, 4, 5, 6, 7, 8], 3, [(0, 0, 4), (1, 1, 5), (0, 3, 8)]) [10, 120, 30]","solution":"from functools import reduce import operator def process_queries(n, array, q, queries): results = [] for command, b, e in queries: subsequence = array[b:e] if command == 0: result = sum(subsequence) elif command == 1: result = reduce(operator.mul, subsequence, 1) results.append(result) return results"},{"question":"def second_highest_salary_employees(employees: List[Tuple[int, int]]) -> Union[List[int], str]: Identifies the employees with the second highest salary from the input list of employees. Args: employees (list of tuples): List of tuples where each tuple contains an employee ID and a salary. Returns: list or str: List of employee IDs with the second highest salary sorted in ascending order, or a string \\"No second highest salary\\" if no such employee exists. >>> second_highest_salary_employees([(101, 50000), (102, 60000), (103, 50000), (104, 70000), (105, 60000)]) [102, 105] >>> second_highest_salary_employees([(201, 40000), (202, 40000), (203, 40000)]) \\"No second highest salary\\"","solution":"def second_highest_salary_employees(employees): Identifies the employees with the second highest salary from the input list of employees. Args: employees (list of tuples): List of tuples where each tuple contains an employee ID and a salary. Returns: list or str: List of employee IDs with the second highest salary sorted in ascending order, or a string \\"No second highest salary\\" if no such employee exists. if len(employees) < 2: return \\"No second highest salary\\" # Get unique salaries sorted in descending order unique_salaries = sorted(set(salary for _, salary in employees), reverse=True) # Check if we have at least two unique salaries if len(unique_salaries) < 2: return \\"No second highest salary\\" # Second highest salary second_highest_salary = unique_salaries[1] # Get employee IDs with the second highest salary candidates = sorted(emp_id for emp_id, salary in employees if salary == second_highest_salary) return candidates"},{"question":"from typing import List def min_distance(s: str, t: str) -> int: Returns the minimum number of operations required to convert string s to string t. >>> min_distance(\\"abcdef\\", \\"azced\\") 3 >>> min_distance(\\"sunday\\", \\"saturday\\") 3","solution":"def min_distance(s, t): Returns the minimum number of operations required to convert string s to string t. n = len(s) m = len(t) dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) return dp[n][m]"},{"question":"class SequenceManager: def __init__(self, n: int, a: List[int]): Initialize the sequence manager with a sequence of n integers. Args: n (int): The number of integers in the sequence. a (List[int]): The initial sequence of integers. def add_to_subarray(self, l: int, r: int, x: int) -> None: Add a given integer to each element in the subarray from index l to index r (inclusive). Args: l (int): The starting index of the subarray (1-based). r (int): The ending index of the subarray (1-based). x (int): The integer to add to each element in the subarray. def multiply_subarray(self, l: int, r: int, x: int) -> None: Multiply each element in the subarray from index l to index r (inclusive) by a given integer. Args: l (int): The starting index of the subarray (1-based). r (int): The ending index of the subarray (1-based). x (int): The integer to multiply each element in the subarray by. def sum_subarray(self, l: int, r: int) -> int: Retrieve the sum of all elements in the subarray from index l to index r (inclusive). Args: l (int): The starting index of the subarray (1-based). r (int): The ending index of the subarray (1-based). Returns: int: The sum of all elements in the subarray. def test_add_to_subarray(): manager = SequenceManager(5, [1, 2, 3, 4, 5]) manager.add_to_subarray(1, 3, 2) assert manager.a == [3, 4, 5, 4, 5] def test_multiply_subarray(): manager = SequenceManager(5, [3, 4, 5, 4, 5]) manager.multiply_subarray(2, 4, 3) assert manager.a == [3, 12, 15, 12, 5] def test_sum_subarray(): manager = SequenceManager(5, [3, 12, 15, 12, 5]) assert manager.sum_subarray(1, 5) == 47 def test_add_to_subarray_again(): manager = SequenceManager(5, [3, 12, 15, 12, 5]) manager.add_to_subarray(3, 5, 1) assert manager.a == [3, 12, 16, 13, 6] def test_sum_subarray_again(): manager = SequenceManager(5, [3, 12, 16, 13, 6]) assert manager.sum_subarray(1, 5) == 50","solution":"class SequenceManager: def __init__(self, n, a): self.n = n self.a = a[:] def add_to_subarray(self, l, r, x): for i in range(l - 1, r): self.a[i] += x def multiply_subarray(self, l, r, x): for i in range(l - 1, r): self.a[i] *= x def sum_subarray(self, l, r): return sum(self.a[l - 1:r])"},{"question":"def num_ways_to_traverse(n: int, m: int, grid: List[str]) -> int: Determine the number of ways to traverse from the top-left corner of the grid to the bottom-right corner. You are given a grid with n rows and m columns. Each cell in the grid can either be empty or occupied by an obstacle. You can only move right or down at each step, while avoiding obstacles. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid where '.' is an empty cell and '#' is an obstacle. Returns: int: The number of ways to reach the bottom-right corner modulo 1,000,000,007. Examples: >>> num_ways_to_traverse(2, 3, [\\"...\\", \\".#.\\"]) 1 >>> num_ways_to_traverse(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2","solution":"def num_ways_to_traverse(n, m, grid): MOD = 1000000007 dp = [[0]*m for _ in range(n)] if grid[0][0] == '#': return 0 dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[n-1][m-1] # Auxiliary function to facilitate testing with given examples def grid_ways_from_input(input_str): lines = input_str.strip().split(\\"n\\") n, m = map(int, lines[0].strip().split()) grid = [lines[i + 1].strip() for i in range(n)] return num_ways_to_traverse(n, m, grid)"},{"question":"def find_auction_winner(n, bids, t): Returns the winner's name in the auction or \\"No bids\\" if no valid bids exist. Args: n (int): Number of bids bids (List[Tuple[str, int, int]]): List of tuples containing bidder's name, bid time, and bid amount t (int): Auction end time Returns: str: Winner's name or \\"No bids\\" if no valid bids pass # Main auction function to process input def auction(input_data): Processes the auction input data and determines the winner. Args: input_data (str): Multiline string representing the auction data Returns: str: Winner's name or \\"No bids\\" if no valid bids pass # Unit Test def test_auction(): input_data1 = \\"5nalice 100 150nbob 200 200ncarol 300 150nalice 250 200nbob 150 200n250\\" assert auction(input_data1) == \\"bob\\" input_data2 = \\"2nalice 50 100nbob 60 100n30\\" assert auction(input_data2) == \\"No bids\\" input_data3 = \\"3nalice 100 150nbob 200 200ncarol 300 150n250\\" assert auction(input_data3) == \\"bob\\" input_data4 = \\"1nalice 100 150n50\\" assert auction(input_data4) == \\"No bids\\" input_data5 = \\"3nalice 100 150nbob 100 200ncarol 100 200n100\\" assert auction(input_data5) == \\"bob\\" input_data6 = \\"5nalice 100 150nbob 100 200ncarol 100 200nalice 200 300nbob 150 150n200\\" assert auction(input_data6) == \\"alice\\"","solution":"def find_auction_winner(n, bids, t): Returns the winner's name in the auction or \\"No bids\\" if no valid bids exist. valid_bids = [bid for bid in bids if bid[1] <= t] if not valid_bids: return \\"No bids\\" valid_bids.sort(key=lambda x: (-x[2], x[1])) return valid_bids[0][0] # Main auction function to process input def auction(input_data): lines = input_data.strip().split(\\"n\\") n = int(lines[0]) bids = [] for line in lines[1:n+1]: parts = line.split() name = parts[0] time = int(parts[1]) amount = int(parts[2]) bids.append((name, time, amount)) t = int(lines[n+1]) return find_auction_winner(n, bids, t)"},{"question":"def unique_path_count(m: int, n: int) -> int: Return the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. >>> unique_path_count(3, 7) 28 >>> unique_path_count(3, 3) 6 >>> unique_path_count(1, 1) 1 >>> unique_path_count(1, 10) 1 >>> unique_path_count(10, 1) 1 >>> unique_path_count(2, 2) 2 >>> unique_path_count(5, 5) 70 >>> unique_path_count(100, 1) 1 >>> unique_path_count(1, 100) 1 >>> unique_path_count(10, 10) 48620 >>> unique_path_count(20, 20) 35345263800 >>> unique_path_count(2, 1) 1 >>> unique_path_count(1, 2) 1 >>> unique_path_count(10, 2) 10 >>> unique_path_count(2, 10) 10","solution":"def unique_path_count(m, n): Returns the number of unique paths from the top-left corner to the bottom-right corner of an m x n grid. # Create a 2D dp array with (m+1)x(n+1) dimension to accommodate 1-based index dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base case: there's one way to be at the start (1,1) dp[1][1] = 1 # Fill the dp table for i in range(1, m + 1): for j in range(1, n + 1): if i == 1 and j == 1: continue # Skip the starting point as it's already initialized dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m][n]"},{"question":"def roman_to_integer(roman: str) -> int: Convert a given Roman numeral into its decimal (integer) form. >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IV\\") 4 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994","solution":"def roman_to_integer(roman): # Dictionary to hold Roman numeral values values = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000} total = 0 prev_value = 0 # Iterate over the Roman numeral from right to left for char in reversed(roman): current_value = values[char] # If the current value is less than the previous value, subtract it from total if current_value < prev_value: total -= current_value else: total += current_value prev_value = current_value return total"},{"question":"def encode_text(text: str, shift: int) -> str: Encodes the given text by shifting each character forward by 'shift' positions in the alphabet. >>> encode_text('hello', 3) 'khoor' >>> encode_text('abcxyz', 5) 'fghcde' >>> encode_text('hello', 0) 'hello' >>> encode_text('abc', 25) 'zab' >>> encode_text('a', 1) 'b' >>> encode_text('z', 1) 'a'","solution":"def encode_text(text, shift): Encodes the given text by shifting each character forward by 'shift' positions in the alphabet. encoded_chars = [] for char in text: # Calculate the new character, wrapping around if necessary new_char = chr((ord(char) - ord('a') + shift) % 26 + ord('a')) encoded_chars.append(new_char) return ''.join(encoded_chars)"},{"question":"def count_elements_with_two_prime_factors(n: int, array: List[int]) -> int: Returns the number of elements in the array that have at least two distinct prime factors. Examples: >>> count_elements_with_two_prime_factors(5, [10, 15, 21, 30, 31]) 4 >>> count_elements_with_two_prime_factors(3, [5, 7, 11]) 0 >>> count_elements_with_two_prime_factors(6, [6, 18, 24, 25, 27, 35]) 4 pass # Unit tests def test_count_elements_with_two_prime_factors_example1(): assert count_elements_with_two_prime_factors(5, [10, 15, 21, 30, 31]) == 4 def test_count_elements_with_two_prime_factors_example2(): assert count_elements_with_two_prime_factors(3, [5, 7, 11]) == 0 def test_count_elements_with_two_prime_factors_example3(): assert count_elements_with_two_prime_factors(6, [6, 18, 24, 25, 27, 35]) == 4 def test_count_elements_with_two_prime_factors_edge_cases(): assert count_elements_with_two_prime_factors(1, [1]) == 0 assert count_elements_with_two_prime_factors(1, [2]) == 0 assert count_elements_with_two_prime_factors(1, [3]) == 0 def test_count_elements_with_two_prime_factors_large_input(): assert count_elements_with_two_prime_factors(1, [10**9]) == 1","solution":"def count_elements_with_two_prime_factors(n, array): Returns the number of elements in the array that have at least two distinct prime factors. def prime_factors_count(x): Returns the count of distinct prime factors of x. count = 0 if x % 2 == 0: count += 1 while x % 2 == 0: x //= 2 for i in range(3, int(x**0.5) + 1, 2): if x % i == 0: count += 1 while x % i == 0: x //= i if x > 2: count += 1 return count elements_count = 0 for elem in array: if prime_factors_count(elem) >= 2: elements_count += 1 return elements_count"},{"question":"def max_group_size_difference(n: int, m: int, book_titles: List[str]) -> int: Determine the maximum possible difference in the number of books between the largest and smallest group when the books are divided into up to m groups in alphabetical order. Args: n (int): The number of books. m (int): The number of groups. book_titles (List[str]): The list of book titles. Returns: int: The maximum possible difference in the number of books between the largest and smallest group. Example: >>> max_group_size_difference(5, 3, [\\"apple\\", \\"orange\\", \\"banana\\", \\"peach\\", \\"grape\\"]) 1 >>> max_group_size_difference(7, 2, [\\"cat\\", \\"dog\\", \\"elephant\\", \\"bear\\", \\"antelope\\", \\"zebra\\", \\"lion\\"]) 2","solution":"import math def max_group_size_difference(n, m, book_titles): This function calculates the maximum possible size difference between the largest and smallest group when the books are divided into up to m groups in alphabetical order. book_titles.sort() # Sort books alphabetically if m >= n: return 0 # Each book can be its own group # Minimum books in each group base_size = n // m # Number of groups that will have an extra book groups_with_extra_book = n % m largest_size = base_size + 1 if groups_with_extra_book > 0 else base_size smallest_size = base_size return largest_size - smallest_size"},{"question":"def longest_palindromic_substring_permutation(s: str) -> str: Returns the longest substring of s that can be rearranged to form a palindrome. >>> longest_palindromic_substring_permutation(\\"abccccdd\\") 'dccaccd' >>> longest_palindromic_substring_permutation(\\"aabbccddee\\") 'aabbccdde' # or any permutation of a substring that has the same length and can form a palindrome.","solution":"from collections import Counter def longest_palindromic_substring_permutation(s): Returns the longest substring of s that can be rearranged to form a palindrome. char_count = Counter(s) longest_palindrome = [] middle_char = \\"\\" for char, count in char_count.items(): if count % 2 == 1: if len(middle_char) == 0 or count > char_count[middle_char]: middle_char = char for char, count in char_count.items(): longest_palindrome += [char] * (count // 2) longest_palindrome = ''.join(longest_palindrome) if middle_char: return longest_palindrome + middle_char + longest_palindrome[::-1] else: return longest_palindrome + longest_palindrome[::-1]"},{"question":"def max_active_projects(n: int, schedules: List[Tuple[int, int]]) -> int: Find the maximum number of projects that were active simultaneously at any given point in time. A project is considered active on both its start date and its end date. Args: n (int): The number of projects. schedules (List[Tuple[int, int]]): A list where each tuple contains start and end dates of the projects. Returns: int: The maximum number of active projects at any point in time. Examples: >>> max_active_projects(5, [(1, 3), (2, 5), (4, 6), (7, 8), (5, 9)]) 3 >>> max_active_projects(4, [(1, 2), (2, 4), (3, 5), (6, 7)]) 2 pass","solution":"def max_active_projects(n, schedules): events = [] for start, end in schedules: events.append((start, 1)) # Project starts events.append((end + 1, -1)) # Project ends events.sort() max_active = 0 current_active = 0 for event in events: current_active += event[1] max_active = max(max_active, current_active) return max_active"},{"question":"def categorize_and_sort_anagrams(test_cases): Given a collection of words, categorize these words based on their anagrams and then sort the anagram groups lexicographically within each group. Each group should be printed on a new line with words separated by a space, sorted by the first word of each group in lexicographical order. Example: >>> categorize_and_sort_anagrams([[\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"], [\\"rat\\", \\"tar\\", \\"art\\", \\"tars\\"]]) ['ate eat teanbatnnat tan', 'art rat tarntars'] >>> categorize_and_sort_anagrams([[\\"dog\\", \\"cat\\", \\"bird\\"]]) ['birdncatndog'] >>> categorize_and_sort_anagrams([[\\"aab\\", \\"aba\\", \\"baa\\"]]) ['aab aba baa'] >>> categorize_and_sort_anagrams([[\\"listen\\", \\"silent\\", \\"enlist\\", \\"it\\", \\"nit\\", \\"tin\\"]]) ['enlist listen silentnitnnit tin'] def gather_input(input_lines): Process the input lines and return the structured test cases. Example: >>> gather_input([\\"2\\", \\"6\\", \\"eat tea tan ate nat bat\\", \\"4\\", \\"rat tar art tars\\"]) [['eat', 'tea', 'tan', 'ate', 'nat', 'bat'], ['rat', 'tar', 'art', 'tars']]","solution":"def categorize_and_sort_anagrams(test_cases): result = [] for words in test_cases: # Group words by sorted tuple of characters anagram_dict = {} for word in words: sorted_word = tuple(sorted(word)) if sorted_word not in anagram_dict: anagram_dict[sorted_word] = [] anagram_dict[sorted_word].append(word) # Sort the words within each anagram group lexicographically sorted_anagram_groups = [] for anagram_group in anagram_dict.values(): sorted_anagram_groups.append(sorted(anagram_group)) # Sort the anagram groups based on the first word of each group sorted_anagram_groups.sort(key=lambda x: x[0]) # Convert each group to a single string of space-separated words for group in sorted_anagram_groups: result.append(' '.join(group)) # Append a blank line to separate test case results result.append('') # Join the results into a single string and print while removing the last blank line return 'n'.join(result).strip() def gather_input(input_lines): index = 0 t = int(input_lines[index]) index += 1 test_cases = [] for _ in range(t): n = int(input_lines[index]) index += 1 words = input_lines[index].split() index += 1 test_cases.append(words) return test_cases"},{"question":"def count_consecutive_sum_ways(n: int) -> int: Returns the number of ways to represent n as the sum of two or more consecutive positive integers. >>> count_consecutive_sum_ways(15) 3 >>> count_consecutive_sum_ways(9) 2 >>> count_consecutive_sum_ways(1) 0 >>> count_consecutive_sum_ways(5) 1 >>> count_consecutive_sum_ways(100) 2 >>> count_consecutive_sum_ways(30) 3 >>> count_consecutive_sum_ways(2) 0","solution":"def count_consecutive_sum_ways(n): Returns the number of ways to represent n as the sum of two or more consecutive positive integers. count = 0 k = 1 while (k * (k + 1)) // 2 < n: if (n - (k * (k + 1)) // 2) % (k + 1) == 0: count += 1 k += 1 return count"},{"question":"def calculate_average_pages(N: int, pages: List[int]) -> Union[float, str]: Computes the average number of pages read per student who read at least 10 pages. If no student qualifies, returns \\"No Qualifying Students\\". :param N: Number of students :param pages: List of integers representing the pages each student read :return: The average number of pages as a float or the string \\"No Qualifying Students\\" >>> calculate_average_pages(5, [15, 20, 5, 8, 30]) 21.7 >>> calculate_average_pages(3, [5, 6, 7]) 'No Qualifying Students'","solution":"def calculate_average_pages(N, pages): Returns the average number of pages read per student who read at least 10 pages. If no such student exists, return the string \\"No Qualifying Students\\". :param N: Number of students :param pages: List of integers representing the pages each student read :return: The average number of pages or \\"No Qualifying Students\\" qualifying_pages = [page for page in pages if page >= 10] if not qualifying_pages: return \\"No Qualifying Students\\" average_pages = sum(qualifying_pages) / len(qualifying_pages) return round(average_pages, 1)"},{"question":"def calculate_magical_influence(data: List[List[int]]) -> List[int]: Calculate the total magical influence of lanterns positioned along the boulevard. >>> calculate_magical_influence([[4, 0, 10, 20, 30], [3, 5, 15, 25], [2, 0, 1000], [0]]) [-3000, -2000, -1000000000] >>> calculate_magical_influence([[2, 1, 2], [0]]) [-1] >>> calculate_magical_influence([[2, 0, 1000], [0]]) [-1000000000] >>> calculate_magical_influence([[3, 0, 0, 0], [0]]) [0] >>> calculate_magical_influence([[3, 30, 20, 10], [0]]) [2000] >>> calculate_magical_influence([[3, 10, 20, 30], [0]]) [-2000]","solution":"def calculate_magical_influence(data): results = [] for line in data: n = int(line[0]) if n == 0: break lanterns = list(map(int, line[1:])) total_influence = 0 for i in range(n - 1): distance = lanterns[i] - lanterns[i + 1] total_influence += distance ** 3 results.append(total_influence) return results"},{"question":"def count_special_flowers(n, magic_values): Returns the number of special flowers in the garden. A flower is special if its magic value is greater than the magic value of each of its neighboring flowers. >>> count_special_flowers(5, [3, 1, 4, 5, 2]) 1 >>> count_special_flowers(4, [3, 2, 1, 4]) 0 >>> count_special_flowers(3, [1, 5, 2]) 1 >>> count_special_flowers(6, [1, 3, 2, 4, 3, 5]) 2 >>> count_special_flowers(3, [1, 3, 1]) 1","solution":"def count_special_flowers(n, magic_values): Returns the number of special flowers in the garden. A flower is special if its magic value is greater than the magic value of each of its neighboring flowers. special_count = 0 for i in range(1, n - 1): if magic_values[i] > magic_values[i - 1] and magic_values[i] > magic_values[i + 1]: special_count += 1 return special_count"},{"question":"class FileSystem: A class to mimic a simple file system similar to UNIX. The file system supports the following operations: 1. mkdir(path) - Creates a new directory at the specified path. 2. addFile(filePath, content) - Creates or updates a file with the given content. 3. ls(path) - Lists the contents of the specified directory or file. 4. getFileContent(filePath) - Returns the content of the specified file. Example: >>> fs = FileSystem() >>> fs.mkdir(\\"/a/b/c\\") >>> fs.ls(\\"/\\") == [\\"a\\"] True >>> fs.addFile(\\"/a/b/d\\", \\"hello\\") >>> fs.ls(\\"/a/b\\") == [\\"c\\", \\"d\\"] True >>> fs.getFileContent(\\"/a/b/d\\") == \\"hello\\" True >>> fs.addFile(\\"/a/b/d\\", \\"world\\") >>> fs.getFileContent(\\"/a/b/d\\") == \\"world\\" True >>> fs.mkdir(\\"/x/y\\") >>> fs.ls(\\"/x\\") == [\\"y\\"] True >>> fs.ls(\\"/a/b/d\\") == [\\"d\\"] True def __init__(self): # Initialize the file system root. def mkdir(self, path: str): # Create a new directory at the specified path. # All intermediate directories should be created if not exist. def addFile(self, filePath: str, content: str): # Create a new file at the specified file path with the given content. # If the file already exists, update its content. # Intermediate directories should be created if not exist. def ls(self, path: str): # Lists the content of the directory at the specified path. # If the path points to a file, it returns just the file name. # The contents should be listed in lexicographical order. def getFileContent(self, filePath: str) -> str: # Returns the content of the specified file. # If the file does not exist, return an empty string. # Example test cases import pytest def test_mkdir(): fs = FileSystem() fs.mkdir(\\"/a/b/c\\") assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a/b\\") == [\\"c\\"] def test_addFile(): fs = FileSystem() fs.addFile(\\"/a/b/d\\", \\"hello\\") assert fs.ls(\\"/\\") == [\\"a\\"] assert fs.ls(\\"/a\\") == [\\"b\\"] assert fs.ls(\\"/a/b\\") == [\\"d\\"] assert fs.getFileContent(\\"/a/b/d\\") == \\"hello\\" fs.addFile(\\"/a/b/d\\", \\"world\\") assert fs.ls(\\"/a/b\\") == [\\"d\\"] assert fs.getFileContent(\\"/a/b/d\\") == \\"world\\" def test_ls(): fs = FileSystem() fs.mkdir(\\"/x/y\\") assert fs.ls(\\"/x\\") == [\\"y\\"] fs.addFile(\\"/x/y/z\\", \\"content\\") assert fs.ls(\\"/x/y\\") == [\\"z\\"] assert fs.ls(\\"/x/y/z\\") == [\\"z\\"] def test_getFileContent(): fs = FileSystem() fs.addFile(\\"/a/b/d\\", \\"hello\\") assert fs.getFileContent(\\"/a/b/d\\") == \\"hello\\" fs.addFile(\\"/a/b/d\\", \\"world\\") assert fs.getFileContent(\\"/a/b/d\\") == \\"world\\" fs.addFile(\\"/a/b/e\\", \\"test\\") assert fs.getFileContent(\\"/a/b/e\\") == \\"test\\"","solution":"class FileSystem: def __init__(self): self.fs = {'/': {}} def mkdir(self, path: str): parts = path.strip('/').split('/') current = self.fs['/'] for part in parts: if part not in current: current[part] = {} current = current[part] def addFile(self, filePath: str, content: str): parts = filePath.strip('/').split('/') current = self.fs['/'] for part in parts[:-1]: if part not in current: current[part] = {} current = current[part] current[parts[-1]] = content def ls(self, path: str): parts = path.strip('/').split('/') current = self.fs['/'] if not(parts == ['']): for part in parts: current = current[part] if isinstance(current, str): return [parts[-1]] else: return sorted(current.keys()) def getFileContent(self, filePath: str) -> str: parts = filePath.strip('/').split('/') current = self.fs['/'] for part in parts: current = current[part] if isinstance(current, str): return current return \\"\\""},{"question":"def find_nth_number_in_sequence(N: int) -> int: Returns the Nth number in the special sequence defined by: - Start with 1 and 2. - If the number is odd, the next number is obtained by multiplying it by 3 and adding 1. - If the number is even, the next number is obtained by dividing it by 2. >>> find_nth_number_in_sequence(1) == 1 >>> find_nth_number_in_sequence(2) == 2 >>> find_nth_number_in_sequence(3) == 1 >>> find_nth_number_in_sequence(4) == 4 >>> find_nth_number_in_sequence(5) == 2 >>> find_nth_number_in_sequence(6) == 1 >>> assert isinstance(find_nth_number_in_sequence(10**6), int) # Checking large index pass","solution":"def find_nth_number_in_sequence(N): Returns the Nth number in the special sequence defined by: - Start with 1 and 2. - If the number is odd, the next number is obtained by multiplying it by 3 and adding 1. - If the number is even, the next number is obtained by dividing it by 2. # Sequence starts with 1 and 2 sequence = [1, 2] while len(sequence) < N: last_number = sequence[-1] if last_number % 2 == 0: next_number = last_number // 2 else: next_number = last_number * 3 + 1 sequence.append(next_number) return sequence[N - 1]"},{"question":"def generate_acronym(phrase: str) -> str: Generates an acronym for the given phrase. The acronym consists of the initial letters of each word in the phrase, all in uppercase. >>> generate_acronym(\\"Machine Learning and Artificial Intelligence\\") \\"MLAAI\\" >>> generate_acronym(\\"central processing unit\\") \\"CPU\\" >>> generate_acronym(\\"Python\\") \\"P\\" >>> generate_acronym(\\"Graphic User Interface\\") \\"GUI\\" >>> generate_acronym(\\"read Only memory\\") \\"ROM\\" >>> generate_acronym(\\"HYPER TEXT MARKUP LANGUAGE\\") \\"HTML\\" >>> generate_acronym(\\" leading spaces in phrase \\") \\"LSIP\\" >>> generate_acronym(\\"many spaces between words\\") \\"MSBW\\" >>> generate_acronym(\\"\\") \\"\\"","solution":"def generate_acronym(phrase: str) -> str: Generates an acronym for the given phrase. The acronym consists of the initial letters of each word in the phrase, all in uppercase. :param phrase: A string containing the technical term or phrase. :return: A string representing the acronym of the given phrase in uppercase letters. acronym = ''.join(word[0] for word in phrase.split()).upper() return acronym"},{"question":"def min_boxes_after_operation(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of boxes remaining in a warehouse after exactly one operation. The robot can choose any two consecutive boxes and combine their widgets such that all widgets from both boxes are moved to either the i-th or (i+1)th box, leaving the other box empty. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer n (number of boxes) and a list of integers representing the number of widgets in each box. Returns: List[int]: A list of integers representing the minimum number of boxes remaining after the operation for each test case. Example: >>> min_boxes_after_operation(5, [ ... (4, [4, 3, 2, 1]), ... (4, [2, 2, 2, 2]), ... (3, [1, 100, 1]), ... (5, [1, 2, 3, 4, 5]), ... (2, [1, 2]) ... ]) [3, 3, 2, 4, 1]","solution":"def min_boxes_after_operation(t, test_cases): results = [] for case in test_cases: n = case[0] widgets = case[1] if n == 2: results.append(1) # With only 2 boxes, combining them leaves 1 box. else: results.append(n - 1) # Combining any two consecutive boxes always leaves n-1 boxes. return results"},{"question":"from collections import defaultdict, Counter from typing import List, Tuple def most_frequent_product_sequence(T: int, P: int, purchases: List[Tuple[int, int, str]]) -> Tuple[str, str, str]: Find the most frequently purchased product sequence of length 3 within a given timeframe. If there are multiple sequences with the same highest frequency, return the lexicographically smallest one. Args: T: int - The timeframe in seconds. P: int - The number of purchases. purchases: List of tuples - user ID, timestamp, and product ID of each purchase. Returns: Tuple of strings representing the most frequently purchased product sequence of length 3. >>> most_frequent_product_sequence(600, 10, [(1, 100, 'apple'), (1, 200, 'banana'), (1, 300, 'orange'), (1, 500, 'apple'), (2, 110, 'apple'), (2, 220, 'banana'), (2, 330, 'apple'), (2, 440, 'banana'), (2, 550, 'orange'), (3, 60, 'apple')]) ('apple', 'banana', 'orange') >>> most_frequent_product_sequence(300, 8, [(1, 100, 'apple'), (1, 200, 'apple'), (1, 300, 'apple'), (1, 400, 'banana'), (1, 500, 'banana'), (2, 110, 'apple'), (2, 220, 'apple'), (2, 330, 'apple')]) ('apple', 'apple', 'apple')","solution":"from collections import defaultdict, Counter from itertools import combinations def most_frequent_product_sequence(T, P, purchases): # Sorting purchases by user_id and timestamp purchases.sort(key=lambda x: (x[0], x[1])) user_sequences = defaultdict(list) sequence_counts = Counter() for user_id, timestamp, product_id in purchases: user_sequences[user_id].append(product_id) if len(user_sequences[user_id]) > 3: user_sequences[user_id].pop(0) if len(user_sequences[user_id]) == 3: sequence = tuple(user_sequences[user_id]) sequence_counts[sequence] += 1 most_common_sequence = min(sequence_counts, key=lambda x: (-sequence_counts[x], x)) return most_common_sequence # Helper function to read from standard input def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) P = int(data[1]) purchases = [] for i in range(P): user_id = int(data[2 + 3*i]) timestamp = int(data[2 + 3*i + 1]) product_id = data[2 + 3*i + 2] purchases.append((user_id, timestamp, product_id)) result = most_frequent_product_sequence(T, P, purchases) print(' '.join(result))"},{"question":"def reorder_even_first(nums: List[int]) -> List[int]: Reorders the list such that all the even numbers come before all the odd numbers, preserving the original relative order of the even and odd numbers. :param nums: List of integers :return: Reordered list with evens first, odds second. >>> reorder_even_first([3, 1, 2, 4, 5]) [2, 4, 3, 1, 5] >>> reorder_even_first([7, 8, 6, 5, 10]) [8, 6, 10, 7, 5] >>> reorder_even_first([2, 4, 6, 8]) [2, 4, 6, 8] >>> reorder_even_first([3, 5, 7, 9]) [3, 5, 7, 9] >>> reorder_even_first([3, 2, 1, 4, 6, 5]) [2, 4, 6, 3, 1, 5] >>> reorder_even_first([]) [] >>> reorder_even_first([1]) [1] >>> reorder_even_first([2]) [2]","solution":"def reorder_even_first(nums): Reorders the list such that all the even numbers come before all the odd numbers, preserving the original relative order of the even and odd numbers. :param nums: List of integers :return: Reordered list with evens first, odds second. evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] return evens + odds"},{"question":"def can_assign_unique_ids(s: int, n: int) -> str: Determines if it's possible to assign unique IDs to s students such that no ID exceeds n. Args: s (int): The number of students. n (int): The maximum allowable value for any student ID. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. >>> can_assign_unique_ids(5, 10) \\"YES\\" >>> can_assign_unique_ids(15, 14) \\"NO\\" >>> can_assign_unique_ids(500, 500) \\"YES\\" >>> can_assign_unique_ids(1000, 1) \\"NO\\"","solution":"def can_assign_unique_ids(s, n): Determines if it's possible to assign unique IDs to s students such that no ID exceeds n. Args: s (int): The number of students. n (int): The maximum allowable value for any student ID. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. if s <= n: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_contiguous_subsequence_length(n: int, sequence: List[int]) -> int: Find the length of the longest contiguous subsequence where all the integers are the same. Args: n : int : Number of elements in the sequence. sequence : list of int : The elements of the sequence. Returns: int : The length of the longest contiguous subsequence where all the integers are the same. Examples: >>> longest_contiguous_subsequence_length(10, [1, 2, 2, 2, 3, 3, 4, 4, 4, 4]) 4 >>> longest_contiguous_subsequence_length(6, [5, 5, 5, 5, 5, 5]) 6","solution":"def longest_contiguous_subsequence_length(n, sequence): Finds the length of the longest contiguous subsequence where all the integers are the same. Args: n : int : Number of elements in the sequence sequence : list of int : The elements of the sequence Returns: int : The length of the longest contiguous subsequence where all the integers are the same if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if sequence[i] == sequence[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def min_traversal_time(n: int, m: int, grid: List[List[int]]) -> int: Calculates the minimum time required to travel from the top-left corner of the grid to the bottom-right corner. You can only move right or down from a given tile. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (List[List[int]]): 2D list representing the tile traversal time for the grid. Returns: int: The minimum traversal time. Examples: >>> min_traversal_time(3, 3, [ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 7 >>> min_traversal_time(1, 1, [ ... [5] ... ]) == 5 pass # Unit Test def test_min_traversal_time(): assert min_traversal_time(3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) == 7 assert min_traversal_time(1, 1, [ [5] ]) == 5 assert min_traversal_time(1, 4, [ [1, 2, 3, 4] ]) == 10 assert min_traversal_time(4, 1, [ [1], [2], [3], [4] ]) == 10 assert min_traversal_time(2, 2, [ [1000, 1000], [1000, 1000] ]) == 3000","solution":"def min_traversal_time(n, m, grid): dp = [[0] * m for _ in range(n)] # Create a DP table # Initialize the top-left corner dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill in the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner contains the result return dp[n-1][m-1] # Example usage code (would normally be outside the function file) n, m = 3, 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] result = min_traversal_time(n, m, grid) print(result) # Output should be 7"},{"question":"def is_balanced(N: int, M: int, roads: List[Tuple[int, int, int]]) -> str: Determine if we can redistribute travel times to make every city balanced. >>> is_balanced(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 1)]) 'YES' >>> is_balanced(4, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 1, 2), (1, 3, 5), (2, 4, 1)]) 'NO'","solution":"def is_balanced(N, M, roads): Determine if we can redistribute travel times to make every city balanced. from collections import defaultdict # Creating a graph representation with a dictionary of lists graph = defaultdict(list) for u, v, t in roads: graph[u].append((v, t)) graph[v].append((u, t)) # Compute the total travel time from each city to every other city total_travel_time = [0] * (N + 1) for u in range(1, N + 1): for v, t in graph[u]: total_travel_time[u] += t # Check if all cities have the same total travel time expected_time = total_travel_time[1] for i in range(2, N + 1): if total_travel_time[i] != expected_time: return \\"NO\\" return \\"YES\\""},{"question":"def find_triplet_with_zero_sum(arr: List[int]) -> str: Given an array of n integers, find out if there exist three elements whose sum is zero. >>> find_triplet_with_zero_sum([-1, 2, 1, -4, 2]) \\"YES\\" >>> find_triplet_with_zero_sum([1, 2, 3]) \\"NO\\"","solution":"def find_triplet_with_zero_sum(arr): arr.sort() n = len(arr) for i in range(n - 2): left = i + 1 right = n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == 0: return \\"YES\\" elif current_sum < 0: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def max_monsters_defeated(n: int, k: int, energies: List[int]) -> int: Determines the maximum number of monsters that can be defeated without exceeding the given total energy, k. Args: n (int): Number of monsters. k (int): Total units of energy available. energies (list of int): Energy required to defeat each monster. Returns: int: Maximum number of monsters that can be defeated. >>> max_monsters_defeated(5, 50, [10, 20, 30, 40, 50]) 2 >>> max_monsters_defeated(6, 25, [5, 5, 5, 5, 5, 5]) 5","solution":"def max_monsters_defeated(n, k, energies): Determines the maximum number of monsters that can be defeated without exceeding the given total energy, k. Args: n (int): Number of monsters. k (int): Total units of energy available. energies (list of int): Energy required to defeat each monster. Returns: int: Maximum number of monsters that can be defeated. # Sort the energy requirements energies.sort() defeated_monsters = 0 total_energy = 0 for energy in energies: if total_energy + energy <= k: total_energy += energy defeated_monsters += 1 else: break return defeated_monsters"},{"question":"def game_queries(n, scores, q, queries): You are given a list of integers representing scores of players in a game. Each player plays a sequence of rounds, and their scores are recorded in a list which may contain positive or negative integers representing points gained or lost. You need to answer queries based on these scores. The types of queries you need to support are: 1. \\"max k\\" - return the maximum score among all players after k rounds. 2. \\"sum a b\\" - return the sum of scores from round a to round b (inclusive) for all players, given two indices (1-indexed). 3. \\"update i x\\" - update the score of the i-th player to x. Input: - n (int): The number of players. - scores (List[int]): The initial scores of the players. - q (int): The number of queries. - queries (List[str]): The list of queries. Output: - List[int]: The results of the queries \\"max k\\" and \\"sum a b\\". Example: >>> n = 5 >>> scores = [10, 20, -5, 15, 25] >>> q = 7 >>> queries = [ ... \\"max 3\\", ... \\"sum 2 4\\", ... \\"update 3 30\\", ... \\"max 5\\", ... \\"sum 1 5\\", ... \\"update 1 -10\\", ... \\"max 2\\", ... ] >>> game_queries(n, scores, q, queries) [20, 30, 30, 100, 20]","solution":"def game_queries(n, scores, q, queries): results = [] for query in queries: parts = query.split() command = parts[0] if command == \\"max\\": k = int(parts[1]) results.append(max(scores[:k])) elif command == \\"sum\\": a = int(parts[1]) - 1 b = int(parts[2]) - 1 results.append(sum(scores[a:b + 1])) elif command == \\"update\\": i = int(parts[1]) - 1 x = int(parts[2]) scores[i] = x return results"},{"question":"from typing import List def longest_special_palindrome(s: str) -> int: Determines the length of the longest special palindrome that can be constructed using the characters from the given string. A special palindrome allows every character to appear an even number of times except for at most one character that can appear an odd number of times. Args: s (str): A string consisting of lowercase English letters. Returns: int: The length of the longest special palindrome. Examples: >>> longest_special_palindrome(\\"abccccdd\\") 7 >>> longest_special_palindrome(\\"aabbcc\\") 6","solution":"def longest_special_palindrome(s): from collections import Counter char_count = Counter(s) length = 0 odd_count_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_found = True if odd_count_found: length += 1 # Add the central odd-count character, if any return length"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 def test_single_character(): assert count_palindromic_substrings(\\"a\\") == 1 def test_two_same_characters(): assert count_palindromic_substrings(\\"aa\\") == 3 def test_two_different_characters(): assert count_palindromic_substrings(\\"ab\\") == 2 def test_example_1(): assert count_palindromic_substrings(\\"abba\\") == 6 def test_example_2(): assert count_palindromic_substrings(\\"abc\\") == 3 def test_example_3(): assert count_palindromic_substrings(\\"aaa\\") == 6 def test_long_palindrome(): assert count_palindromic_substrings(\\"racecar\\") == 10 def test_no_palindromes(): assert count_palindromic_substrings(\\"abcd\\") == 4 def test_entire_string_palindrome(): assert count_palindromic_substrings(\\"aaaa\\") == 10","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 # Function to expand around center indices and count palindromic substrings def expand_around_center(left, right): nonlocal count while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 for i in range(n): # Odd length palindromes: Single letter center expand_around_center(i, i) # Even length palindromes: Two letter center expand_around_center(i, i + 1) return count"},{"question":"def can_reach_end(N: int, grid: List[List[int]]) -> str: Determines if the player can reach the bottom-right corner from the top-left corner of the grid. Parameters: N (int): Size of the grid. grid (list of list of int): N x N matrix representing the grid where 0 is an empty cell and 1 is a cell with a monster. Returns: str: \\"YES\\" if the player can reach the bottom-right corner, otherwise \\"NO\\". Examples: >>> can_reach_end(4, [ ... [0, 0, 1, 0], ... [0, 0, 1, 1], ... [1, 0, 0, 0], ... [1, 1, 1, 0] ... ]) == \\"YES\\" >>> can_reach_end(3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ]) == \\"NO\\"","solution":"def can_reach_end(N, grid): Determines if the player can reach the bottom-right corner from the top-left corner of the grid. Parameters: N (int): Size of the grid. grid (list of list of int): N x N matrix representing the grid where 0 is an empty cell and 1 is a cell with a monster. Returns: str: \\"YES\\" if the player can reach the bottom-right corner, otherwise \\"NO\\". from collections import deque def is_within_bounds(x, y): return 0 <= x < N and 0 <= y < N def bfs(): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set() visited.add((0, 0)) while queue: x, y = queue.popleft() if (x, y) == (N-1, N-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy while is_within_bounds(nx, ny) and grid[nx][ny] == 0: if (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) nx += dx ny += dy return \\"NO\\" if grid[0][0] == 1 or grid[N-1][N-1] == 1: return \\"NO\\" return bfs()"},{"question":"def count_unique_designs(N: int, M: int) -> int: Determine the number of unique floor designs Mia can create for a given N x M floor such that no 2x2 square of tiles is of the same color. >>> count_unique_designs(4, 4) 2 >>> count_unique_designs(1, 1) 2 >>> count_unique_designs(2, 2) 2 >>> count_unique_designs(3, 3) 2 >>> count_unique_designs(50, 50) 2 >>> count_unique_designs(10, 10) 2 >>> count_unique_designs(50, 1) 2 >>> count_unique_designs(1, 50) 2","solution":"def count_unique_designs(N, M): Returns the number of unique designs possible for a N x M floor such that no 2x2 squares of tiles are of the same color. # There are exactly 2 ways to tile the floor such that no 2x2 squares are of the same color. # One way is to use an alternating coloring pattern starting with black, # and the other way is to start with white. # [(black, white), (white, black)] return 2"},{"question":"def max_possible_value_after_operations(n: int, arr: List[int]) -> int: Determine the maximum possible integer value that can be achieved in the array after performing any number of operations. Parameters: n (int): The length of the array. arr (List[int]): The elements of the array. Returns: int: The maximum possible value in the array after operations. Examples: >>> max_possible_value_after_operations(5, [1, 2, 3, 4, 5]) 5 >>> max_possible_value_after_operations(3, [10, 100, 1000]) 1000 >>> max_possible_value_after_operations(4, [6, 7, 8, 9]) 9","solution":"def max_possible_value_after_operations(n, arr): Returns the maximum possible integer value that can be achieved in the array after performing any number of operations. return max(arr)"},{"question":"def max_non_consecutive_sum(n: int, nums: List[int]) -> int: Returns the largest possible sum of a subsequence of the list where no two elements are consecutive in the original list. >>> max_non_consecutive_sum(5, [3, 2, 5, 10, 7]) 15 >>> max_non_consecutive_sum(4, [3, 2, 7, 10]) 13","solution":"def max_non_consecutive_sum(n, nums): Returns the largest possible sum of a subsequence where no two elements are consecutive. if n == 0: return 0 if n == 1: return max(0, nums[0]) incl = max(0, nums[0]) # Maximum sum that includes the current element excl = 0 # Maximum sum that doesn't include the current element for i in range(1, n): new_excl = max(incl, excl) incl = excl + nums[i] excl = new_excl return max(incl, excl)"},{"question":"def sort_vanya_way(n: int, integers: List[int]) -> List[int]: Sort the non-negative integers in ascending order while keeping the negative integers in their original positions. :param n: Number of integers in the collection :param integers: List of integers in the collection :return: Modified list after sorting as per Vanya's rule >>> sort_vanya_way(5, [4, -2, -5, 1, 3]) [1, -2, -5, 3, 4] >>> sort_vanya_way(3, [-1, -3, -2]) [-1, -3, -2] >>> sort_vanya_way(4, [7, 3, -1, 2]) [2, 3, -1, 7] >>> sort_vanya_way(6, [-10, 1, 5, -8, 8, -3]) [-10, 1, 5, -8, 8, -3] >>> sort_vanya_way(4, [9, 7, 5, 3]) [3, 5, 7, 9] >>> sort_vanya_way(0, []) [] >>> sort_vanya_way(1, [0]) [0] >>> sort_vanya_way(1, [-1]) [-1]","solution":"def sort_vanya_way(n, integers): Sort the non-negative integers in ascending order while keeping the negative integers in their original positions. :param n: Number of integers in the collection :param integers: List of integers in the collection :return: Modified list after sorting as per Vanya's rule if n == 0: return [] # Extract non-negative integers and sort them non_negatives = sorted([x for x in integers if x >= 0]) # Create a result list and a pointer for the non-negative sorted list result = [] j = 0 for i in range(n): if integers[i] < 0: result.append(integers[i]) # keep negative in the same position else: result.append(non_negatives[j]) # replace with sorted non-negative j += 1 return result"},{"question":"def frequency_of_largest_number(grid): Returns the frequency of the largest number in the grid. :param grid: List of lists representing the grid. :return: Frequency of the largest number in the grid. # Implementation here def test_frequency_of_largest_number(): grid1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] grid2 = [ [-1, -2, -3, -4], [-1, -2, -3, -4] ] grid3 = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] grid4 = [ [1000, -1000, 500], [500, 1000, -1000] ] grid5 = [ [-1, -1, -1], [-1, -1, -1], [-1, -1, -1] ] assert frequency_of_largest_number(grid1) == 1 assert frequency_of_largest_number(grid2) == 2 assert frequency_of_largest_number(grid3) == 9 assert frequency_of_largest_number(grid4) == 2 assert frequency_of_largest_number(grid5) == 9","solution":"def frequency_of_largest_number(grid): Returns the frequency of the largest number in the grid. :param grid: List of lists representing the grid. :return: Frequency of the largest number in the grid. max_num = max(map(max, grid)) max_num_count = sum(row.count(max_num) for row in grid) return max_num_count"},{"question":"def classify_binary_numbers(binary_numbers: List[str]) -> Tuple[List[str], List[str]]: Classifies binary numbers into even and odd based on their last digit. Parameters: binary_numbers (list of str): List of binary numbers (strings). Returns: tuple: A tuple containing two lists, one with even binary numbers and another with odd binary numbers. pass # Test cases def test_classify_binary_numbers(): binary_numbers = ['1010', '1001', '1100', '1111', '100'] even, odd = classify_binary_numbers(binary_numbers) assert even == ['1010', '1100', '100'] assert odd == ['1001', '1111'] binary_numbers = ['0', '1', '10', '11'] even, odd = classify_binary_numbers(binary_numbers) assert even == ['0', '10'] assert odd == ['1', '11'] binary_numbers = ['1110', '1011', '1101', '111'] even, odd = classify_binary_numbers(binary_numbers) assert even == ['1110'] assert odd == ['1011', '1101', '111'] def test_empty_input(): binary_numbers = [] even, odd = classify_binary_numbers(binary_numbers) assert even == [] assert odd == [] def test_all_even(): binary_numbers = ['0', '10', '100'] even, odd = classify_binary_numbers(binary_numbers) assert even == ['0', '10', '100'] assert odd == [] def test_all_odd(): binary_numbers = ['1', '11', '111'] even, odd = classify_binary_numbers(binary_numbers) assert even == [] assert odd == ['1', '11', '111']","solution":"def classify_binary_numbers(binary_numbers): Classifies binary numbers into even and odd based on their last digit. Parameters: binary_numbers (list of str): List of binary numbers (strings). Returns: tuple: A tuple containing two lists, one with even binary numbers and another with odd binary numbers. even_numbers = [] odd_numbers = [] for binary in binary_numbers: if binary[-1] == '0': even_numbers.append(binary) else: odd_numbers.append(binary) return even_numbers, odd_numbers"},{"question":"def check_overlap(tasks: list) -> str: Check if any tasks overlap. Args: tasks (list of str): Each string contains start and end time of a task in \\"HH:MM-HH:MM\\" format. Returns: str: \\"Overlap detected!\\" if any tasks overlap, otherwise \\"No overlap!\\". Example: >>> check_overlap([\\"09:00-10:30\\", \\"10:20-11:00\\", \\"11:30-12:00\\"]) \\"Overlap detected!\\" >>> check_overlap([\\"08:00-09:30\\", \\"09:30-10:30\\"]) \\"No overlap!\\" def parse_input(input_str: str) -> list: Parses the input string into tasks. Args: input_str (str): Multi-line input string. Returns: list: List of tasks in \\"HH:MM-HH:MM\\" format. Example: >>> parse_input(\\"3n09:00-10:30n10:20-11:00n11:30-12:00\\") [\\"09:00-10:30\\", \\"10:20-11:00\\", \\"11:30-12:00\\"] def main(input_str: str) -> str: Determines if there is an overlap among tasks. Args: input_str (str): Multi-line input string. Returns: str: \\"Overlap detected!\\" if any tasks overlap, otherwise \\"No overlap!\\". Example: >>> main(\\"3n09:00-10:30n10:20-11:00n11:30-12:00\\") \\"Overlap detected!\\" >>> main(\\"2n08:00-09:30n09:30-10:30\\") \\"No overlap!\\" def test_no_overlap(): input_str = \\"2n08:00-09:30n09:30-10:30\\" assert main(input_str) == \\"No overlap!\\" def test_overlap_detected(): input_str = \\"3n09:00-10:30n10:20-11:00n11:30-12:00\\" assert main(input_str) == \\"Overlap detected!\\" def test_multiple_overlaps(): input_str = \\"3n08:00-09:00n08:30-09:30n09:15-10:00\\" assert main(input_str) == \\"Overlap detected!\\" def test_edge_case_adjacent_tasks(): input_str = \\"3n08:00-09:00n09:00-10:00n10:00-11:00\\" assert main(input_str) == \\"No overlap!\\" def test_single_task(): input_str = \\"1n08:00-09:00\\" assert main(input_str) == \\"No overlap!\\" def test_minimal_tasks(): input_str = \\"2n00:00-00:01n00:01-00:02\\" assert main(input_str) == \\"No overlap!\\"","solution":"def check_overlap(tasks): Check if any tasks overlap. Args: tasks (list of tuples): Each tuple contains start and end time of a task in \\"HH:MM-HH:MM\\" format. Returns: str: \\"Overlap detected!\\" if any tasks overlap, otherwise \\"No overlap!\\". # Convert task times to list of tuples containing start and end times in minutes format task_times = [] for task in tasks: start, end = task.split('-') start_hour, start_minute = map(int, start.split(':')) end_hour, end_minute = map(int, end.split(':')) start_time_in_minutes = start_hour * 60 + start_minute end_time_in_minutes = end_hour * 60 + end_minute task_times.append((start_time_in_minutes, end_time_in_minutes)) # Sort tasks based on start time task_times.sort() # Check if there is any overlap for i in range(1, len(task_times)): if task_times[i][0] < task_times[i-1][1]: return \\"Overlap detected!\\" return \\"No overlap!\\" def parse_input(input_str): Parses the input string into tasks. Args: input_str (str): Multi-line input string. Returns: list of str: List of tasks in \\"HH:MM-HH:MM\\" format. lines = input_str.strip().split('n') n = int(lines[0]) tasks = lines[1:n+1] return tasks def main(input_str): tasks = parse_input(input_str) return check_overlap(tasks)"},{"question":"def manage_account(operations: List[str]) -> Union[int, str]: Determines the final status of John's bank account. Parameters: operations (list of str): List of operations, where each operation is in the form '+x' or '-x'. Returns: int or str: Final balance if valid, otherwise \\"Error\\". >>> manage_account([\\"+10\\", \\"-5\\", \\"+15\\"]) 20 >>> manage_account([\\"+5\\", \\"-10\\", \\"+20\\", \\"-7\\"]) \\"Error\\" >>> manage_account([]) 0","solution":"def manage_account(operations): Determines the final status of John's bank account. Parameters: operations (list of str): List of operations, where each operation is in the form '+x' or '-x'. Returns: int or str: Final balance if valid, otherwise \\"Error\\". balance = 0 for operation in operations: amount = int(operation[1:]) if operation[0] == '+': balance += amount elif operation[0] == '-': if balance < amount: return \\"Error\\" balance -= amount return balance"},{"question":"from typing import List, Tuple def minimum_time_to_destination(m: int, n: int, grid: List[List[int]], start: Tuple[int, int], end: Tuple[int, int]) -> int: Computes the minimum time required to reach the destination from the start in a maze. >>> m, n = 3, 3 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> minimum_time_to_destination(m, n, grid, start, end) 21 >>> m, n = 2, 2 >>> grid = [ ... [1, 2], ... [3, 4] ... ] >>> start = (0, 0) >>> end = (1, 1) >>> minimum_time_to_destination(m, n, grid, start, end) 7 >>> m, n = 1, 1 >>> grid = [ ... [1] ... ] >>> start = (0, 0) >>> end = (0, 0) >>> minimum_time_to_destination(m, n, grid, start, end) 1 >>> m, n = 3, 3 >>> grid = [ ... [1, 1, 1], ... [1, 100, 1], ... [1, 1, 1] ... ] >>> start = (0, 0) >>> end = (2, 2) >>> minimum_time_to_destination(m, n, grid, start, end) 5 >>> m, n = 2, 3 >>> grid = [ ... [1, 1, 100], ... [100, 1, 1] ... ] >>> start = (0, 0) >>> end = (1, 2) >>> minimum_time_to_destination(m, n, grid, start, end) 4 pass","solution":"import heapq def minimum_time_to_destination(m, n, grid, start, end): # Create a priority queue to store cells to visit, starting with the start cell pq = [(grid[start[0]][start[1]], start[0], start[1])] # (time, x, y) visited = set() directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while pq: current_time, x, y = heapq.heappop(pq) if (x, y) in visited: continue visited.add((x, y)) if (x, y) == end: return current_time for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited: heapq.heappush(pq, (current_time + grid[nx][ny], nx, ny)) return \\"IMPOSSIBLE\\" # Sample Usage m, n = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] start = (0, 0) end = (2, 2) print(minimum_time_to_destination(m, n, grid, start, end)) # Output: 21"},{"question":"def can_form_arithmetic_progression(n: int, arr: List[int]) -> str: Determine if it can be rearranged into an arithmetic progression. >>> can_form_arithmetic_progression(5, [7, 1, 10, 4, 13]) 'YES' >>> can_form_arithmetic_progression(3, [1, 3, 6]) 'NO' # Your code here","solution":"def can_form_arithmetic_progression(n, arr): if n == 1: return \\"YES\\" arr.sort() common_diff = arr[1] - arr[0] for i in range(1, n - 1): if arr[i + 1] - arr[i] != common_diff: return \\"NO\\" return \\"YES\\""},{"question":"def max_total_friendliness(N: int, sectors: List[Tuple[int, int]]) -> int: Determine the maximum total friendliness possible for a meeting without violating the adjacency rule. >>> max_total_friendliness(5, [(10, 5), (40, 2), (30, 3), (50, 4), (20, 1)]) 90 >>> max_total_friendliness(4, [(20, 1), (30, 2), (10, 3), (25, 1)]) 55","solution":"def max_total_friendliness(N, sectors): # Initialize the dp (Dynamic Programming) array # dp[i] will store the maximum friendliness up to sector i dp = [0] * (N + 1) for i in range(1, N + 1): Fi, Ai = sectors[i - 1] dp[i] = Fi if i > 1: # Consider the maximum friendliness up to the previous non-adjacent sectors dp[i] = max(dp[i], dp[i - 1]) if i > 2: dp[i] = max(dp[i], Fi + dp[i - 2]) return dp[N]"},{"question":"def valid_palindrome(s: str) -> str: Determine whether s can be converted into a valid palindrome by removing at most one character. >>> valid_palindrome(\\"abca\\") \\"YES\\" >>> valid_palindrome(\\"aaaa\\") \\"YES\\" >>> valid_palindrome(\\"abc\\") \\"NO\\" >>> valid_palindrome(\\"racecar\\") \\"YES\\" >>> valid_palindrome(\\"abccba\\") \\"YES\\" >>> valid_palindrome(\\"deeeeeeeeeeeed\\") \\"YES\\" >>> valid_palindrome(\\"a\\") \\"YES\\" >>> valid_palindrome(\\"ab\\") \\"YES\\" >>> valid_palindrome(\\"abcba\\") \\"YES\\" >>> valid_palindrome(\\"aedbcba\\") \\"NO\\" >>> valid_palindrome(\\"abcdedcba\\") \\"YES\\"","solution":"def valid_palindrome(s): Determine if a string can be converted into a palindrome by removing at most one character. def is_palindrome_range(st, i, j): return all(st[k] == st[j - k + i] for k in range(i, (j + i) // 2 + 1)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: return \\"YES\\" if is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1) else \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def max_sweets_eaten(N: int, T: int, times: List[int]) -> int: Determines the maximum number of different types of sweets Takahashi can eat within the time limit. :param N: int, number of different types of sweets :param T: int, total time limit :param times: List[int], time required to eat each type of sweet :return: int, maximum number of different types of sweets Takahashi can eat >>> max_sweets_eaten(5, 100, [20, 30, 50, 10, 5]) 4 >>> max_sweets_eaten(4, 20, [5, 5, 5, 5]) 4 >>> max_sweets_eaten(3, 15, [7, 8, 9]) 2 >>> max_sweets_eaten(7, 30, [10, 10, 10, 10, 10, 10, 10]) 3","solution":"def max_sweets_eaten(N, T, times): Determines the maximum number of different types of sweets Takahashi can eat within the time limit. :param N: int, number of different types of sweets :param T: int, total time limit :param times: List[int], time required to eat each type of sweet :return: int, maximum number of different types of sweets Takahashi can eat times.sort() total_time = 0 count = 0 for time in times: if total_time + time <= T: total_time += time count += 1 else: break return count"},{"question":"def has_exactly_three_divisors(n: int) -> str: Determine if n has exactly three distinct positive divisors. >>> has_exactly_three_divisors(4) \\"Yes\\" >>> has_exactly_three_divisors(6) \\"No\\" >>> has_exactly_three_divisors(9) \\"Yes\\" >>> has_exactly_three_divisors(8) \\"No\\" >>> has_exactly_three_divisors(1) \\"No\\" >>> has_exactly_three_divisors(25) \\"Yes\\" >>> has_exactly_three_divisors(49) \\"Yes\\" >>> has_exactly_three_divisors(10**9) \\"No\\"","solution":"def has_exactly_three_divisors(n): Determine if n has exactly three distinct positive divisors. if n < 2: return \\"No\\" def is_prime(x): if x < 2: return False for i in range(2, int(x**0.5) + 1): if x % i == 0: return False return True root = int(n**0.5) if root * root == n and is_prime(root): return \\"Yes\\" else: return \\"No\\""},{"question":"def check_beautiful_sequence(n: int, arr: List[int]) -> Tuple[str, List[int]]: Returns whether it's possible to reorder the array to form a beautiful sequence. >>> check_beautiful_sequence(5, [4, 3, 3, 1, 2]) (\\"YES\\", [1, 2, 3, 3, 4]) >>> check_beautiful_sequence(4, [4, 4, 4, 3]) (\\"YES\\", [3, 4, 4, 4]) >>> check_beautiful_sequence(1, [10]) (\\"YES\\", [10]) >>> check_beautiful_sequence(3, [1, 2, 3]) (\\"YES\\", [1, 2, 3]) >>> check_beautiful_sequence(4, [5, 5, 5, 5]) (\\"YES\\", [5, 5, 5, 5]) >>> check_beautiful_sequence(5, [5, 4, 3, 2, 1]) (\\"YES\\", [1, 2, 3, 4, 5]) >>> check_beautiful_sequence(7, [10, 9, 8, 7, 6, 5, 4]) (\\"YES\\", [4, 5, 6, 7, 8, 9, 10])","solution":"def check_beautiful_sequence(n, arr): Returns whether it's possible to reorder the array to form a beautiful sequence. arr.sort() return \\"YES\\", arr # Example usage: result = check_beautiful_sequence(5, [4, 3, 3, 1, 2]) print(result) # Should print: ('YES', [1, 2, 3, 3, 4]) result = check_beautiful_sequence(4, [4, 4, 4, 3]) print(result) # Should print: ('YES', [3, 4, 4, 4])"},{"question":"def sum_of_primes(n: int) -> int: Returns the sum of all prime numbers less than or equal to n. >>> sum_of_primes(10) == 17 >>> sum_of_primes(1) == 0 >>> sum_of_primes(2) == 2 >>> sum_of_primes(30) == 129 >>> sum_of_primes(100) == 1060 >>> sum_of_primes(1000000) == 37550402023 # This is a large test, give it few seconds to compute","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. Uses the Sieve of Eratosthenes algorithm for finding prime numbers efficiently. if n < 2: return 0 # Initialize a boolean array to detect prime numbers sieve = [True] * (n + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for i in range(2, int(n**0.5) + 1): if sieve[i]: for j in range(i * i, n + 1, i): sieve[j] = False # Sum up the prime numbers prime_sum = sum(i for i, is_prime in enumerate(sieve) if is_prime) return prime_sum"},{"question":"def largest_subgrid_of_1s(t: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Find the area of the largest subgrid consisting entirely of 1s for each test case. Args: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[List[int]]]]): List of test cases, each containing a tuple with grid dimensions and the grid itself. Returns: List[int]: List of the area of the largest subgrid consisting entirely of 1s for each test case. >>> t = 3 >>> test_cases = [ ... ((4, 5), [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]), ... ((2, 2), [ ... [0, 0], ... [0, 0] ... ]), ... ((3, 3), [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ]), ... ] >>> largest_subgrid_of_1s(t, test_cases) [6, 0, 3]","solution":"def largest_subgrid_of_1s(t, test_cases): def maximalRectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) heights = [0] * m max_area = 0 for i in range(n): for j in range(m): if matrix[i][j] == 0: heights[j] = 0 else: heights[j] += 1 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): heights.append(0) stack = [-1] max_area = 0 for i in range(len(heights)): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area results = [] for i in range(t): n, m = test_cases[i][0] grid = test_cases[i][1] results.append(maximalRectangle(grid)) return results"},{"question":"def factorial(n): Returns the factorial of n. >>> factorial(1) 1 >>> factorial(2) 2 >>> factorial(3) 6 >>> factorial(4) 24 pass def sum_of_factorials(N): Returns the sum of factorials from 1 to N. >>> sum_of_factorials(1) 1 >>> sum_of_factorials(3) 9 >>> sum_of_factorials(5) 153 pass from solution import factorial, sum_of_factorials def test_factorial(): assert factorial(1) == 1 assert factorial(2) == 2 assert factorial(3) == 6 assert factorial(4) == 24 assert factorial(5) == 120 assert factorial(6) == 720 def test_sum_of_factorials(): assert sum_of_factorials(1) == 1 assert sum_of_factorials(2) == 3 # 1! + 2! = 1 + 2 = 3 assert sum_of_factorials(3) == 9 # 1! + 2! + 3! = 1 + 2 + 6 = 9 assert sum_of_factorials(4) == 33 # 1! + 2! + 3! + 4! = 1 + 2 + 6 + 24 = 33 assert sum_of_factorials(5) == 153 # 1! + 2! + 3! + 4! + 5! = 1 + 2 + 6 + 24 + 120 = 153 assert sum_of_factorials(6) == 873 # 1! + 2! + 3! + 4! + 5! + 6! = 1 + 2 + 6 + 24 + 120 + 720 = 873 assert sum_of_factorials(10) == 4037913 # Sum of factorials from 1 to 10","solution":"def factorial(n): Returns the factorial of n. if n == 0 or n == 1: return 1 else: return n * factorial(n - 1) def sum_of_factorials(N): Returns the sum of factorials from 1 to N. return sum(factorial(i) for i in range(1, N + 1))"},{"question":"def find_final_integer(N: int, A: List[int], M: int) -> int: Find the final integer after performing a series of summing and remainder operations. >>> find_final_integer(5, [1, 2, 3, 4, 5], 2) 1 >>> find_final_integer(4, [1000, 2000, 3000, 4000], 3) 1","solution":"def find_final_integer(N, A, M): while len(A) > 1: sum_first_M = sum(A[:M]) remainder = sum_first_M % M A = [remainder] + A[M:] return A[0]"},{"question":"from collections import Counter def max_intersections(n: int, wells: List[Tuple[int, int]]) -> int: Finds the maximum number of wells that can be intersected by a horizontal canal at an optimal y-coordinate. Args: n : int : The number of wells wells : list : A list of tuples representing the coordinates of the wells Returns: int : The maximum number of wells that can be intersected >>> max_intersections(5, [(2, 3), (4, 3), (1, 1), (2, 5), (2, 3)]) 3 >>> max_intersections(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 1 >>> max_intersections(5, [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]) 5 >>> max_intersections(6, [(1, 1), (2, 1), (3, 1), (4, 2), (5, 2), (6, 2)]) 3 >>> max_intersections(100000, [(i, i % 10) for i in range(100000)]) 10000 # Implement the function here","solution":"from collections import Counter def max_intersections(n, wells): Finds the maximum number of wells that can be intersected by a horizontal canal at an optimal y-coordinate. Args: n : int : The number of wells wells : list : A list of tuples representing the coordinates of the wells Returns: int : The maximum number of wells that can be intersected # Extract the y-coordinates y_coords = [well[1] for well in wells] # Count the occurrences of each y-coordinate y_counter = Counter(y_coords) # Find the maximum count max_intersect = max(y_counter.values()) return max_intersect"},{"question":"def max_contiguous_subarray_sum(arr): Function to find the maximum contiguous subarray sum using Kadane's algorithm. def process_test_cases(test_cases): Function to process multiple test cases. def main(): Main function to read input and produce output. def test_max_contiguous_subarray_sum(): assert max_contiguous_subarray_sum([2, -1, 2, 3, 4]) == 10 assert max_contiguous_subarray_sum([-5, -1, -2, -3]) == -1 assert max_contiguous_subarray_sum([1, 2, 3, -2, 5]) == 9 assert max_contiguous_subarray_sum([3, -1, -1, 3]) == 4 assert max_contiguous_subarray_sum([-3, -2, -1, -4]) == -1 def test_process_test_cases(): test_cases = [ (5, [2, -1, 2, 3, 4]), (4, [-5, -1, -2, -3]) ] results = process_test_cases(test_cases) assert results == [10, -1] def test_integration(): import io import sys input_str = \\"2n5n2 -1 2 3 4n4n-5 -1 -2 -3n\\" sys.stdin = io.StringIO(input_str) captured_output = io.StringIO() sys.stdout = captured_output main() sys.stdout = sys.__stdout__ sys.stdin = sys.__stdin__ assert captured_output.getvalue().strip() == \\"10n-1\\" # Execute the tests test_max_contiguous_subarray_sum() test_process_test_cases() test_integration()","solution":"def max_contiguous_subarray_sum(arr): Function to find the maximum contiguous subarray sum using Kadane's algorithm. max_sum = arr[0] current_sum = arr[0] for i in range(1, len(arr)): current_sum = max(arr[i], current_sum + arr[i]) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): Function to process multiple test cases. results = [] for N, arr in test_cases: results.append(max_contiguous_subarray_sum(arr)) return results # Main function to read input and produce output. def main(): import sys input = sys.stdin.read data = input().split() T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 arr = list(map(int, data[index:index + N])) index += N test_cases.append((N, arr)) results = process_test_cases(test_cases) for result in results: print(result)"},{"question":"def josephus_position(n: int, k: int) -> int: Determine the position of the last remaining person in the Josephus problem. Arguments: n -- the number of people in the circle k -- the interval of elimination Returns: The position of the last person remaining. >>> josephus_position(5, 2) 3 >>> josephus_position(7, 3) 4 >>> josephus_position(10, 1) 10 pass def solve_josephus(test_cases: List[Tuple[int, int]]) -> List[int]: Returns the positions of the last remaining persons for multiple test cases. Arguments: test_cases -- a list of tuples where each tuple contains two integers (N, K) Returns: A list of results for each test case. >>> solve_josephus([(5, 2), (7, 3), (10, 1)]) [3, 4, 10] pass # Test cases from solution import josephus_position, solve_josephus def test_josephus_position(): assert josephus_position(5, 2) == 3 assert josephus_position(7, 3) == 4 assert josephus_position(10, 1) == 10 assert josephus_position(1, 1) == 1 assert josephus_position(6, 2) == 5 def test_solve_josephus(): assert solve_josephus([(5, 2), (7, 3), (10, 1)]) == [3, 4, 10] assert solve_josephus([(1, 1)]) == [1] assert solve_josephus([(6, 2), (5, 4)]) == [5, 1] def test_edge_cases(): assert josephus_position(10**6, 1) == 10**6 # Large N, K=1 assert josephus_position(2, 10**9) == 1 # Small N, Large K","solution":"def josephus_position(n, k): Determine the position of the last remaining person in the Josephus problem. Arguments: n -- the number of people in the circle k -- the interval of elimination Returns: The position of the last person remaining. result = 0 for i in range(1, n+1): result = (result + k) % i return result + 1 def solve_josephus(test_cases): Returns the positions of the last remaining persons for multiple test cases. Arguments: test_cases -- a list of tuples where each tuple contains two integers (N, K) Returns: A list of results for each test case. return [josephus_position(n, k) for n, k in test_cases]"},{"question":"def is_stable(s: str) -> bool: Determine if a given string is 'stable', where every letter appears the same number of times. >>> is_stable(\\"aabbcc\\") True >>> is_stable(\\"aabbccc\\") False >>> is_stable(\\"abcabc\\") True >>> is_stable(\\"aabb\\") True","solution":"def is_stable(s: str) -> bool: from collections import Counter # Count the frequency of each character counter = Counter(s) # Get the set of frequency values frequency_set = set(counter.values()) # String is stable if all characters have the same frequency return len(frequency_set) == 1"},{"question":"def compress_string(s: str) -> str: Compress the string using Run-Length Encoding (RLE). If the compressed string is not smaller than the original string, returns the original string. :param s: Original string to be compressed :return: Compressed string or original string if compression is not effective >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abcdef\\") 'abcdef' >>> compress_string(\\"aaaaa\\") 'a5' >>> compress_string(\\"aabbcc\\") 'aabbcc' >>> compress_string(\\"aaabbbcccaa\\") 'a3b3c3a2'","solution":"def compress_string(s): Compress the string using Run-Length Encoding (RLE). If the compressed string is not smaller than the original string, returns the original string. :param s: Original string to be compressed :return: Compressed string or original string if compression is not effective if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def arrange_lily_pads(n: int) -> List[int]: Returns a list of numbers representing the number of lily pads in each column such that: - Each number is unique. - The numbers are in non-decreasing order. >>> arrange_lily_pads(1) [1] >>> arrange_lily_pads(2) [1, 2] >>> arrange_lily_pads(3) [1, 2, 3]","solution":"def arrange_lily_pads(n): Returns a list of numbers representing the number of lily pads in each column such that: - Each number is unique. - The numbers are in non-decreasing order. return list(range(1, n + 1))"},{"question":"from typing import List def min_energy_path(grid: List[List[int]]) -> int: Find the minimum energy required for the robot to reach the bottom-right corner of the grid from the top-left corner. >>> min_energy_path([[1, 3, 2], [4, 3, 8], [5, 3, 1]]) 4 >>> min_energy_path([[1, 2], [3, 4]]) 3 >>> min_energy_path([[0]]) 0 >>> min_energy_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 0 >>> min_energy_path([[1, 10], [100, 1000]]) 999","solution":"def min_energy_path(grid): import heapq if not grid or not grid[0]: return 0 n = len(grid) directions = [(0, 1), (1, 0)] # Only right and down movements heap = [(0, 0, 0)] # (energy, x, y) visited = set((0, 0)) energy_matrix = [[float('inf')] * n for _ in range(n)] energy_matrix[0][0] = 0 while heap: energy, x, y = heapq.heappop(heap) if x == n - 1 and y == n - 1: return energy for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: new_energy = energy + abs(grid[nx][ny] - grid[x][y]) if new_energy < energy_matrix[nx][ny]: energy_matrix[nx][ny] = new_energy visited.add((nx, ny)) heapq.heappush(heap, (new_energy, nx, ny)) return energy_matrix[n - 1][n - 1] def read_input_and_compute_min_energy(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) grid = [] idx = 1 for i in range(n): row = list(map(int, data[idx:idx + n])) grid.append(row) idx += n result = min_energy_path(grid) print(result)"},{"question":"def min_transformations(source: str, target: str) -> int: Determines the minimum number of single-character transformations required to change the source word into the target word. Return -1 if the transformation is not possible. >>> min_transformations(\\"abcdef\\", \\"azcdef\\") 1 >>> min_transformations(\\"cat\\", \\"bat\\") 1 >>> min_transformations(\\"kitten\\", \\"sitten\\") 1 >>> min_transformations(\\"abc\\", \\"xyz\\") -1 from solution import min_transformations def test_transformation_possible(): assert min_transformations(\\"abcdef\\", \\"azcdef\\") == 1 assert min_transformations(\\"cat\\", \\"bat\\") == 1 assert min_transformations(\\"kitten\\", \\"sitten\\") == 1 def test_transformation_not_possible(): assert min_transformations(\\"abc\\", \\"xyz\\") == -1 assert min_transformations(\\"abc\\", \\"abcd\\") == -1 assert min_transformations(\\"abcd\\", \\"ab\\") == -1 def test_no_transformation_needed(): assert min_transformations(\\"hello\\", \\"hello\\") == 0 def test_multiple_transformations(): assert min_transformations(\\"aaaa\\", \\"bbbb\\") == 4 assert min_transformations(\\"apple\\", \\"appla\\") == 1","solution":"def min_transformations(source, target): Determines the minimum number of single-character transformations required to change the source word into the target word. Return -1 if the transformation is not possible. if len(source) != len(target): return -1 transformation_count = 0 for s, t in zip(source, target): if s != t: transformation_count += 1 return transformation_count"},{"question":"def number_of_islands(gardens): Returns a list of the number of distinct islands for each garden in gardens. Args: gardens (List[Tuple[int, int, List[List[int]]]]): List of gardens, where each garden is represented by its dimensions and the grid of water and land cells. Returns: List[int]: A list where each element is the number of distinct islands for the corresponding garden. Example: >>> gardens = [ ... (4, 5, [ ... [1, 1, 0, 0, 0], ... [1, 1, 0, 0, 1], ... [0, 0, 0, 1, 1], ... [0, 0, 0, 0, 0] ... ]), ... (3, 3, [ ... [1, 1, 1], ... [0, 1, 0], ... [1, 0, 1] ... ]), ... ] >>> number_of_islands(gardens) [2, 3] pass def test_number_of_islands(): gardens = [ (4, 5, [ [1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0] ]), (3, 3, [ [1, 1, 1], [0, 1, 0], [1, 0, 1] ]), ] assert number_of_islands(gardens) == [2, 3] def test_single_garden_all_land(): gardens = [ (3, 3, [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ]), ] assert number_of_islands(gardens) == [1] def test_single_garden_all_water(): gardens = [ (3, 3, [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ]), ] assert number_of_islands(gardens) == [0] def test_mixed_land_and_water(): gardens = [ (3, 3, [ [1, 0, 1], [0, 1, 0], [1, 0, 1] ]), ] assert number_of_islands(gardens) == [5]","solution":"def number_of_islands(gardens): Returns a list of the number of distinct islands for each garden in gardens. def dfs(grid, x, y, n, m, visited): # Directions for right, left, up, down directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] stack = [(x, y)] while stack: i, j = stack.pop() for dir in directions: ni, nj = i + dir[0], j + dir[1] if 0 <= ni < n and 0 <= nj < m and not visited[ni][nj] and grid[ni][nj] == 1: visited[ni][nj] = True stack.append((ni, nj)) results = [] for garden in gardens: n, m, grid = garden visited = [[False for _ in range(m)] for _ in range(n)] count = 0 for i in range(n): for j in range(m): if grid[i][j] == 1 and not visited[i][j]: visited[i][j] = True dfs(grid, i, j, n, m, visited) count += 1 results.append(count) return results"},{"question":"def can_transform_to_special_string(s: str) -> str: Determines if the string \`s\` can be transformed into a special string by changing exactly one character at one position. >>> can_transform_to_special_string(\\"abbac\\") \\"YES\\" >>> can_transform_to_special_string(\\"abcabc\\") \\"NO\\" >>> can_transform_to_special_string(\\"aaa\\") \\"YES\\" >>> can_transform_to_special_string(\\"abababa\\") \\"NO\\"","solution":"def can_transform_to_special_string(s): Determines if the string \`s\` can be transformed into a special string by changing exactly one character at one position. n = len(s) for i in range(1, n): if s[i] == s[i-1]: # Try replacing s[i] with a different character for char in \\"abc\\": if char != s[i] and char != s[i-1] and (i+1 == n or char != s[i+1]): return \\"YES\\" # Try replacing s[i-1] with a different character for char in \\"abc\\": if char != s[i-1] and char != s[i] and (i-2 < 0 or char != s[i-2]): return \\"YES\\" return \\"NO\\" # If no consecutive characters are the same # It means no modification is needed if n > 1 and all(s[i] != s[i-1] for i in range(1, n)): return \\"NO\\" return \\"YES\\""},{"question":"def find_anagrams(s: str, p: str) -> List[int]: Find all starting indices of substrings in s that are anagrams of p. Parameters: s (str): The input string. p (str): The pattern string. Returns: List[int]: List of starting indices of substrings that are anagrams of p. >>> find_anagrams(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_anagrams(\\"abcdefg\\", \\"hij\\") [] >>> find_anagrams(\\"abab\\", \\"ab\\") [0, 1, 2] >>> find_anagrams(\\"aaaaaaaaaa\\", \\"aaa\\") [0, 1, 2, 3, 4, 5, 6, 7] >>> find_anagrams(\\"a\\", \\"aa\\") [] >>> find_anagrams(\\"abcde\\", \\"e\\") [4] pass","solution":"def find_anagrams(s, p): Find all starting indices of substrings in s that are anagrams of p. Parameters: s (str): The input string. p (str): The pattern string. Returns: List[int]: List of starting indices of substrings that are anagrams of p. from collections import Counter # Lengths of the input string and the pattern string len_s, len_p = len(s), len(p) # Early return if pattern length is greater than the string length if len_p > len_s: return [] # Result list to store the starting indices of the anagrams of p in s result = [] # Create frequency counters for the pattern and the initial window in the string p_counter = Counter(p) s_counter = Counter(s[:len_p-1]) # Iterate over the string s with a sliding window of length len_p for i in range(len_p-1, len_s): # Include the next character in the sliding window s_counter[s[i]] += 1 # If the sliding window matches the pattern frequency, add starting index to result if s_counter == p_counter: result.append(i - len_p + 1) # Remove the oldest character from the sliding window s_counter[s[i - len_p + 1]] -= 1 if s_counter[s[i - len_p + 1]] == 0: del s_counter[s[i - len_p + 1]] return result"},{"question":"def handle_queries(n: int, e: int, q: int, edges: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[Union[int, str]]: Manage a set of servers organized into several disjoint clusters and answer several queries about the connectivity of these clusters. Args: n : int : number of servers e : int : number of existing connections (edges) q : int : number of queries edges : list : list of tuples representing direct connections between servers queries : list : list of tuples representing queries about potential bridges between servers Returns: list : the number of new clusters if the bridge is added, or \\"SAME CLUSTER\\" if the two servers are already in the same cluster Example: >>> handle_queries(5, 3, 4, [(1, 2), (2, 3), (4, 5)], [(1, 4), (1, 3), (3, 4), (2, 5)]) [1, \\"SAME CLUSTER\\", 1, 1] >>> handle_queries(3, 0, 3, [], [(1, 2), (2, 3), (1, 3)]) [1, 1, 1]","solution":"class UnionFind: def __init__(self, size): self.root = list(range(size)) self.rank = [1] * size def find(self, x): if self.root[x] == x: return x self.root[x] = self.find(self.root[x]) return self.root[x] def union(self, x, y): rootX = self.find(x) rootY = self.find(y) if rootX != rootY: if self.rank[rootX] > self.rank[rootY]: self.root[rootY] = rootX elif self.rank[rootX] < self.rank[rootY]: self.root[rootX] = rootY else: self.root[rootY] = rootX self.rank[rootX] += 1 def connected(self, x, y): return self.find(x) == self.find(y) def handle_queries(n, e, q, edges, queries): uf = UnionFind(n + 1) result = [] for u, v in edges: uf.union(u, v) for x, y in queries: if uf.connected(x, y): result.append(\\"SAME CLUSTER\\") else: result.append(1) return result"},{"question":"def is_prime(num: int) -> bool: Returns True if num is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True def largest_prime_in_sequence(n: int, sequence: List[int]) -> int: Returns the largest prime number in the given sequence. If there are no prime numbers, returns -1. >>> largest_prime_in_sequence(5, [1, 2, 3, 4, 5]) 5 >>> largest_prime_in_sequence(4, [10, 14, 22, 35]) -1 >>> largest_prime_in_sequence(6, [17, 29, 1, 8, 31, 37]) 37","solution":"def is_prime(num): Returns True if num is a prime number, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def largest_prime_in_sequence(n, sequence): Returns the largest prime number in the given sequence. If there are no prime numbers, returns -1. largest_prime = -1 for number in sequence: if is_prime(number) and number > largest_prime: largest_prime = number return largest_prime"},{"question":"def count_employees_at_level(N, Q, employees, queries): Given the hierarchical structure of the company, count the number of employees at given levels. Args: N (int): Number of employees. Q (int): Number of queries. employees (List[Tuple[int, int, List[int]]]): List of employee details. queries (List[int]): List of levels to query. Returns: List[int]: Number of employees at each queried level. def test_count_employees_at_level(): N = 5 Q = 3 employees = [ (1, 1, [2, 3]), (2, 2, [4, 5]), (3, 2, []), (4, 3, []), (5, 3, []) ] queries = [2, 3, 4] expected = [2, 2, 0] assert count_employees_at_level(N, Q, employees, queries) == expected def test_single_employee(): N = 1 Q = 1 employees = [ (1, 1, []) ] queries = [1] expected = [1] assert count_employees_at_level(N, Q, employees, queries) == expected def test_no_subordinates(): N = 3 Q = 2 employees = [ (1, 1, [2, 3]), (2, 2, []), (3, 2, []) ] queries = [1, 2] expected = [1, 2] assert count_employees_at_level(N, Q, employees, queries) == expected def test_levels_with_no_employees(): N = 4 Q = 3 employees = [ (1, 1, [2]), (2, 2, [3]), (3, 3, [4]), (4, 4, []) ] queries = [2, 3, 5] expected = [1, 1, 0] assert count_employees_at_level(N, Q, employees, queries) == expected def test_large_input(): N = 1000 Q = 100 employees = [(i+1, (i % 100) + 1, []) for i in range(N)] queries = list(range(1, 101)) expected = [10] * 100 assert count_employees_at_level(N, Q, employees, queries) == expected","solution":"def count_employees_at_level(N, Q, employees, queries): Given the hierarchical structure of the company, count the number of employees at given levels. Args: N (int): Number of employees. Q (int): Number of queries. employees (List[Tuple[int, int, List[int]]]): List of employee details. queries (List[int]): List of levels to query. Returns: List[int]: Number of employees at each queried level. from collections import defaultdict # Create a dictionary to count employees at each level level_count = defaultdict(int) for emp in employees: emp_id, level, subordinates = emp level_count[level] += 1 # Answer each query results = [level_count[query] for query in queries] return results"},{"question":"class TrafficSimulator: def __init__(self): self.vehicles = [] def add_vehicle(self, type_vehicle, speed): Add a vehicle of given type and speed to the road. Args: type_vehicle (str): Type of vehicle (\\"car\\" or \\"truck\\"). speed (int): Speed of the vehicle. pass def move_vehicles(self, distance): Move all vehicles forward by their respective speeds multiplied by the given distance. Args: distance (int): Distance to move each vehicle. pass def count_vehicles(self): Count the number of vehicles currently on the road. Returns: int: Number of vehicles on the road. pass def get_kth_vehicle_speed(self, k): Get the speed of the k-th vehicle from the entry point. Args: k (int): Position of the vehicle. Returns: int: Speed of the k-th vehicle, or -1 if fewer than k vehicles. pass def clear_vehicles(self, ns, np): Remove vehicles within a certain distance of a specified point on the road. Args: ns (int): Position on the road from which to clear vehicles. np (int): Distance within which vehicles should be cleared. Returns: int: Number of vehicles removed. pass def simulate_traffic(queries): Simulate traffic based on a series of queries and return the results for each query requiring output. Args: queries (List[str]): List of queries to process. Returns: List[str]: List of results from the queries requiring output. pass # Test cases for the Traffic Simulator from solution import TrafficSimulator, simulate_traffic def test_add_vehicle(): simulator = TrafficSimulator() simulator.add_vehicle(\\"car\\", 50) assert len(simulator.vehicles) == 1 def test_move_vehicles(): simulator = TrafficSimulator() simulator.add_vehicle(\\"car\\", 50) simulator.move_vehicles(1) assert simulator.vehicles[0][2] == 50 def test_count_vehicles(): simulator = TrafficSimulator() simulator.add_vehicle(\\"car\\", 50) assert simulator.count_vehicles() == 1 def test_get_kth_vehicle_speed(): simulator = TrafficSimulator() simulator.add_vehicle(\\"car\\", 50) simulator.add_vehicle(\\"truck\\", 75) assert simulator.get_kth_vehicle_speed(2) == 75 assert simulator.get_kth_vehicle_speed(3) == -1 def test_clear_vehicles(): simulator = TrafficSimulator() simulator.add_vehicle(\\"car\\", 50) simulator.add_vehicle(\\"truck\\", 75) simulator.move_vehicles(2) removed = simulator.clear_vehicles(100, 20) assert removed == 1 assert len(simulator.vehicles) == 1 def test_simulate_traffic(): queries = [ \\"0 car 50\\", \\"0 truck 75\\", \\"0 car 60\\", \\"1 1\\", \\"2\\", \\"3 2\\", \\"4 100 20 15\\", \\"0 0\\" ] results = simulate_traffic(queries) assert results == [ \\"vehicles 3\\", \\"speed 75\\", \\"cleared 0\\" ]","solution":"class TrafficSimulator: def __init__(self): self.vehicles = [] def add_vehicle(self, type_vehicle, speed): self.vehicles.append((type_vehicle, speed, 0)) def move_vehicles(self, distance): for i in range(len(self.vehicles)): vehicle = self.vehicles[i] self.vehicles[i] = (vehicle[0], vehicle[1], vehicle[2] + (vehicle[1] * distance)) def count_vehicles(self): return len(self.vehicles) def get_kth_vehicle_speed(self, k): if 0 < k <= len(self.vehicles): return self.vehicles[k - 1][1] return -1 def clear_vehicles(self, ns, np): removed_count = 0 remaining_vehicles = [] for vehicle in self.vehicles: _, _, position = vehicle if abs(position - ns) <= np: removed_count += 1 else: remaining_vehicles.append(vehicle) self.vehicles = remaining_vehicles return removed_count def simulate_traffic(queries): simulator = TrafficSimulator() results = [] for query in queries: parts = query.split() if parts[0] == \\"0\\" and len(parts) == 3: type_vehicle = parts[1] speed = int(parts[2]) simulator.add_vehicle(type_vehicle, speed) elif parts[0] == \\"1\\": p = int(parts[1]) simulator.move_vehicles(p) elif parts[0] == \\"2\\": results.append(f\\"vehicles {simulator.count_vehicles()}\\") elif parts[0] == \\"3\\": k = int(parts[1]) speed = simulator.get_kth_vehicle_speed(k) results.append(f\\"speed {speed if speed != -1 else '-1'}\\") elif parts[0] == \\"4\\": ns = int(parts[1]) np = int(parts[2]) removed_v = simulator.clear_vehicles(ns, np) results.append(f\\"cleared {removed_v}\\") elif parts[0] == \\"0\\" and parts[1] == \\"0\\": break return results"},{"question":"def remove_duplicates(s: str) -> str: Remove all duplicate characters from the given string s, retaining the original order of characters. >>> remove_duplicates(\\"abcabc\\") \\"abc\\" >>> remove_duplicates(\\"programming\\") \\"progamin\\" >>> remove_duplicates(\\"aabbcc\\") \\"abc\\" ...","solution":"def remove_duplicates(s): Removes duplicate characters from the string s and retains the original order of characters. :param s: A string containing only lowercase English letters. :return: A string with all duplicate characters removed, retaining the original order. seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"from typing import List def longest_uniform_substring_with_transformations(n: int, k: int, s: str) -> int: Determine the length of the longest substring of \`s\` that can be made to consist of the same character using at most \`k\` transformations. Parameters: n (int): The length of the string \`s\`. k (int): The maximum number of transformations allowed. s (str): The input string consisting of lowercase English letters. Returns: int: The length of the longest uniform substring achievable with up to \`k\` transformations. Examples: >>> longest_uniform_substring_with_transformations(8, 1, \\"abracadabra\\") 3 >>> longest_uniform_substring_with_transformations(5, 2, \\"abcde\\") 3 def test_sample1(): assert longest_uniform_substring_with_transformations(8, 1, \\"abracadabra\\") == 3 def test_sample2(): assert longest_uniform_substring_with_transformations(5, 2, \\"abcde\\") == 3 def test_no_transformation_needed(): assert longest_uniform_substring_with_transformations(5, 0, \\"aaaab\\") == 4 def test_full_transformation(): assert longest_uniform_substring_with_transformations(4, 4, \\"abcd\\") == 4 def test_one_character(): assert longest_uniform_substring_with_transformations(1, 1, \\"a\\") == 1 def test_all_same_characters(): assert longest_uniform_substring_with_transformations(6, 2, \\"aaaaaa\\") == 6 def test_zero_transformations(): assert longest_uniform_substring_with_transformations(7, 0, \\"abacada\\") == 1","solution":"from collections import defaultdict def longest_uniform_substring_with_transformations(n, k, s): def max_length_with_char(ch): max_len = 0 left = 0 count_diff = 0 for right in range(n): if s[right] != ch: count_diff += 1 while count_diff > k: if s[left] != ch: count_diff -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len max_length = 0 for char in set(s): max_length = max(max_length, max_length_with_char(char)) return max_length"},{"question":"def doofonacci(n): Returns the first n numbers of the Doofonacci sequence modulo 10. >>> doofonacci(1) [0] >>> doofonacci(2) [0, 1] >>> doofonacci(5) [0, 1, 1, 2, 3] >>> doofonacci(10) [0, 1, 1, 2, 3, 5, 8, 3, 1, 4] def process_test_cases(test_cases): results = [] for n in test_cases: results.append(' '.join(map(str, doofonacci(n)))) return results def test_doofonacci_one(): assert doofonacci(1) == [0] def test_doofonacci_two(): assert doofonacci(2) == [0, 1] def test_doofonacci_five(): assert doofonacci(5) == [0, 1, 1, 2, 3] def test_doofonacci_ten(): assert doofonacci(10) == [0, 1, 1, 2, 3, 5, 8, 3, 1, 4] def test_process_test_cases(): assert process_test_cases([5]) == ['0 1 1 2 3'] assert process_test_cases([10]) == ['0 1 1 2 3 5 8 3 1 4'] assert process_test_cases([1, 2, 3]) == ['0', '0 1', '0 1 1']","solution":"def doofonacci(n): Returns the first n numbers of the Doofonacci sequence modulo 10. if n == 1: return [0] elif n == 2: return [0, 1] sequence = [0, 1] for i in range(2, n): next_number = (sequence[-1] + sequence[-2]) % 10 sequence.append(next_number) return sequence def process_test_cases(test_cases): results = [] for n in test_cases: results.append(' '.join(map(str, doofonacci(n)))) return results"},{"question":"def find_pair_with_sum(N: int, T: int, numbers: List[int]) -> str: Determine if there exists a pair of distinct integers in the set that add up to the target number. >>> find_pair_with_sum(5, 10, [1, 2, 3, 4, 7]) == \\"YES\\" >>> find_pair_with_sum(4, 8, [1, 2, 4, 4]) == \\"YES\\" >>> find_pair_with_sum(3, 9, [1, 5, 3]) == \\"NO\\" >>> find_pair_with_sum(6, 0, [-1, 1, -2, 2, -3, 3]) == \\"YES\\" # Tests from solution import find_pair_with_sum def test_example1(): assert find_pair_with_sum(5, 10, [1, 2, 3, 4, 7]) == \\"YES\\" def test_example2(): assert find_pair_with_sum(4, 8, [1, 2, 4, 4]) == \\"YES\\" def test_example3(): assert find_pair_with_sum(3, 9, [1, 5, 3]) == \\"NO\\" def test_example4(): assert find_pair_with_sum(6, 0, [-1, 1, -2, 2, -3, 3]) == \\"YES\\" def test_no_pairs(): assert find_pair_with_sum(5, 15, [1, 2, 3, 4, 5]) == \\"NO\\" def test_large_numbers(): assert find_pair_with_sum(5, -10, [-10**9, 10**9, -10**9 + 1, 0, 10**9 - 1]) == \\"NO\\" def test_negative_target(): assert find_pair_with_sum(5, -4, [-1, -2, -3, -4, -5]) == \\"YES\\"","solution":"def find_pair_with_sum(N, T, numbers): Determine if there exists a pair of distinct integers in the set that add up to the target number. :param N: Integer, the number of integers in the set. :param T: Integer, the target sum number. :param numbers: List of integers, the set of numbers. :return: String \\"YES\\" if such a pair exists, otherwise \\"NO\\". seen = set() for num in numbers: if T - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) T = int(data[1]) S = list(map(int, data[2:2+N])) print(find_pair_with_sum(N, T, S))"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"aa\\") 2 >>> longest_palindromic_subsequence(\\"ab\\") 1 >>> longest_palindromic_subsequence(\\"bananas\\") 5 >>> longest_palindromic_subsequence(\\"aaaaaa\\") 6 >>> longest_palindromic_subsequence(\\"abcdef\\") 1","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. n = len(s) # dp[i][j] will store the length of the longest palindromic subsequence in s[i:j+1] dp = [[0] * n for _ in range(n)] # A single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Check subsequences of length greater than 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) # Length of longest palindromic subsequence will be dp[0][n-1] return dp[0][n-1]"},{"question":"from typing import List def find_max_sum_rectangle(n: int, m: int, grid: List[List[int]]) -> int: Finds the maximum sum of any rectangle within the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid :return: Maximum sum of any rectangle in the grid >>> find_max_sum_rectangle(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 >>> find_max_sum_rectangle(2, 3, [[1, 2, 3], [4, 5, 6]]) == 21 >>> find_max_sum_rectangle(1, 1, [[100]]) == 100 >>> find_max_sum_rectangle(3, 2, [[1, 2], [3, 4], [5, 6]]) == 21 >>> find_max_sum_rectangle(4, 4, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) == 136 pass # Your code goes here","solution":"def find_max_sum_rectangle(n, m, grid): Finds the maximum sum of any rectangle within the grid. :param n: Number of rows in the grid :param m: Number of columns in the grid :param grid: 2D list representing the grid :return: Maximum sum of any rectangle in the grid max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += grid[i][right] current_max = kadane_algorithm(temp) max_sum = max(max_sum, current_max) return max_sum def kadane_algorithm(array): Helper function to find the maximum sum subarray using Kadane's algorithm. :param array: List of integers :return: Maximum sum of any subarray max_sum = float('-inf') current_sum = 0 for value in array: current_sum = max(value, current_sum + value) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_problems_solved(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Determine the maximum number of problems a participant can solve within the given time limit. >>> max_problems_solved(3, [ ... [(4, 10), [2, 2, 3, 4]], ... [(5, 20), [4, 2, 8, 5, 1]], ... [(3, 7), [5, 5, 5]] ... ]) == [3, 5, 1] >>> max_problems_solved(1, [ ... [(5, 15), [3, 3, 3, 3, 3]] ... ]) == [5] >>> max_problems_solved(1, [ ... [(1, 5), [6]] ... ]) == [0]","solution":"def max_problems_solved(T, test_cases): results = [] for i in range(T): n, t = test_cases[i][0] problems = test_cases[i][1] problems.sort() total_time = 0 solved_count = 0 for problem_time in problems: if total_time + problem_time <= t: total_time += problem_time solved_count += 1 else: break results.append(solved_count) return results"},{"question":"def find_kth_largest(nums: List[int], k: int) -> int: Returns the k-th largest element in the list without sorting the list. >>> find_kth_largest([3, 2, 1, 5, 6, 4, 8, 7], 2) 7 >>> find_kth_largest([3, 2, 1, 5, 6, 4, 8, 7], 1) 8 >>> find_kth_largest([3, 2, 1, 5, 6, 4, 8, 7], 8) 1 >>> find_kth_largest([3, 2, 1, 5, 6, 4, 8, 7], 10) None >>> find_kth_largest([1], 1) 1 >>> find_kth_largest([1, 2], 2) 1 >>> find_kth_largest([1, 2], 1) 2 >>> find_kth_largest([1, 1, 1, 1, 1, 1, 1, 1], 1) 1 >>> find_kth_largest([1, 1, 1, 1, 1, 1, 1, 2], 2) 1","solution":"def find_kth_largest(nums, k): Returns the k-th largest element in the list without sorting the list. import heapq if k > len(nums): return None return heapq.nlargest(k, nums)[-1]"},{"question":"from typing import List def maxXORValue(arr: List[int]) -> int: Write a function that takes in an array of integers and returns the maximum XOR value of any pair of elements in the array. >>> maxXORValue([1, 2, 3, 4, 5]) 7 >>> maxXORValue([8, 1, 2, 12, 7, 6]) 15 pass # Example Unit Tests def test_maxXORValue_basic(): arr = [1, 2, 3, 4, 5] assert maxXORValue(arr) == 7 def test_maxXORValue_example_2(): arr = [8, 1, 2, 12, 7, 6] assert maxXORValue(arr) == 15 def test_maxXORValue_large_gap(): arr = [0, 2147483647] assert maxXORValue(arr) == 2147483647 def test_maxXORValue_identical_elements(): arr = [10, 10, 10] assert maxXORValue(arr) == 0 def test_maxXORValue_all_zeros(): arr = [0, 0, 0] assert maxXORValue(arr) == 0 def test_maxXORValue_mixed_values(): arr = [3, 10, 5, 25, 2, 8] assert maxXORValue(arr) == 28 def test_maxXORValue_single_element(): arr = [5] assert maxXORValue(arr) == 0 # since we need at least a pair for XOR","solution":"def maxXORValue(arr): Function to find the maximum XOR value of any pair of elements in the array. max_xor = 0 mask = 0 # Iterate from the most significant bit to the least significant bit for i in range(30, -1, -1): mask |= (1 << i) prefixes = {num & mask for num in arr} candidate = max_xor | (1 << i) for prefix in prefixes: if candidate ^ prefix in prefixes: max_xor = candidate break return max_xor"},{"question":"def can_be_palindrome_by_removing_one_char(s: str) -> str: Returns 'YES' if the string can be transformed into a palindrome by removing at most one character, otherwise 'NO'. >>> can_be_palindrome_by_removing_one_char(\\"abca\\") 'YES' >>> can_be_palindrome_by_removing_one_char(\\"abc\\") 'NO'","solution":"def can_be_palindrome_by_removing_one_char(s): Returns 'YES' if the string can be transformed into a palindrome by removing at most one character, otherwise 'NO'. def is_palindrome_range(s, left, right): while left < right: if s[left] != s[right]: return False left += 1 right -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: if is_palindrome_range(s, left + 1, right) or is_palindrome_range(s, left, right - 1): return 'YES' else: return 'NO' left += 1 right -= 1 return 'YES'"},{"question":"def fill_missing_populations(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Union[str, int]]: Fill the missing population data in such a way that the change in population between two consecutive cities is the minimum possible. Args: t (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): list of tuples where each tuple contains an integer n (number of cities) and a list of n integers representing the populations of the cities, where -1 indicates missing data. Returns: List[Union[str, int]]: List of strings representing the modified population lists or -1 if it's impossible to fill in the missing data. >>> t = 2 >>> test_cases = [(5, [1, -1, 3, 4, 5]), (4, [-1, -1, 3, 4])] >>> fill_missing_populations(t, test_cases) [\\"1 2 3 4 5\\", -1] >>> t = 1 >>> test_cases = [(4, [10, -1, 20, -1])] >>> fill_missing_populations(t, test_cases) [-1] >>> t = 1 >>> test_cases = [(4, [-1, 10, 20, 30])] >>> fill_missing_populations(t, test_cases) [-1] >>> t = 1 >>> test_cases = [(4, [5, 10, 15, 20])] >>> fill_missing_populations(t, test_cases) [\\"5 10 15 20\\"] >>> t = 1 >>> test_cases = [(5, [1, -1, 3, -1, 5])] >>> fill_missing_populations(t, test_cases) [\\"1 2 3 4 5\\"]","solution":"def fill_missing_populations(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] populations = test_cases[i][1] if populations[0] == -1 or populations[-1] == -1: results.append(-1) continue for j in range(1, n - 1): if populations[j] == -1: prev_population = populations[j - 1] next_population = populations[j + 1] if next_population != -1: populations[j] = (prev_population + next_population) // 2 else: results.append(-1) break else: results.append(' '.join(map(str, populations))) continue results.append(-1) return results # Example usage t = 2 test_cases = [ (5, [1, -1, 3, 4, 5]), (4, [-1, -1, 3, 4]) ] fill_missing_populations(t, test_cases)"},{"question":"def max_subarray_score(n: int, cards: List[int]) -> int: Finds the maximum subarray score for a given list of cards. Parameters: n (int): The number of cards. cards (List[int]): The values of the cards. Returns: int: The maximum score Grace can achieve by picking any subarray of the sequence. Examples: >>> max_subarray_score(5, [-1, 2, 3, -5, 4]) 5 >>> max_subarray_score(4, [-2, -3, -1, -4]) -1 Test Cases: >>> max_subarray_score(1, [5]) 5 >>> max_subarray_score(1, [-5]) -5 >>> max_subarray_score(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_score(5, [-1, 3, -2, 3, -1]) 4 >>> max_subarray_score(8, [1, -2, 3, 4, -1, 2, 1, -5]) 9","solution":"def max_subarray_score(n, cards): Finds the maximum subarray score for a given list of cards. max_ending_here = cards[0] max_so_far = cards[0] for i in range(1, n): max_ending_here = max(cards[i], max_ending_here + cards[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from typing import List def find_largest_product_of_three(nums: List[int]) -> int: Returns the largest product that can be obtained from any three integers in the list. >>> find_largest_product_of_three([1, 2, 3, 4, 5]) 60 >>> find_largest_product_of_three([-10, -10, 5, 2, 3, 7]) 700 >>> find_largest_product_of_three([-10, -10, -5, -2, -3, -7]) -30 >>> find_largest_product_of_three([-1, -2, -3, -4, -5]) -6 >>> find_largest_product_of_three([1, 2, 3]) 6 >>> find_largest_product_of_three([-1, 0, 1, 2, 3]) 6 >>> find_largest_product_of_three([-1, 0, 0, 2, 3, 4]) 24 >>> find_largest_product_of_three([-1, -2, 0, 1, 2]) 4","solution":"def find_largest_product_of_three(nums): Returns the largest product that can be obtained from any three integers in the list. nums.sort() # The maximum product can be from the three largest numbers or two smallest and the largest number. return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def min_cost_path(grid): Returns the minimum cost to reach the bottom-right corner of the grid. >>> min_cost_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path([[1, 2], [1, 1]]) 3 def solve_min_cost_path(t, test_cases): Solves the minimum cost path for multiple test cases. >>> solve_min_cost_path(2, [((3, 3), [[1, 3, 1], [1, 5, 1], [4, 2, 1]]), ((2, 2), [[1, 2], [1, 1]])]) [7, 3]","solution":"def min_cost_path(grid): Returns the minimum cost to reach the bottom-right corner of the grid. n = len(grid) m = len(grid[0]) # Create a 2D array to store the minimum path cost up to each cell dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][m-1] def solve_min_cost_path(t, test_cases): results = [] for case in test_cases: n, m = case[0] grid = case[1] results.append(min_cost_path(grid)) return results"},{"question":"from typing import List def longest_equal_subseq_length(s: str) -> int: Returns the length of the longest contiguous subsequence of the string \`s\` that contains an equal number of '0's and '1's. >>> longest_equal_subseq_length(\\"11000111\\") 6 >>> longest_equal_subseq_length(\\"10101\\") 4 >>> longest_equal_subseq_length(\\"111000\\") 6 pass def process_queries(t: int, queries: List[str]) -> List[int]: Processes multiple queries and returns the length of the longest contiguous subsequence for each query. >>> process_queries(3, [\\"11000111\\", \\"10101\\", \\"111000\\"]) [6, 4, 6] pass","solution":"def longest_equal_subseq_length(s): Returns the length of the longest contiguous subsequence of the string \`s\` that contains an equal number of '0's and '1's. count_dict = {0: -1} max_length = count = 0 for i, char in enumerate(s): count += 1 if char == '1' else -1 if count in count_dict: max_length = max(max_length, i - count_dict[count]) else: count_dict[count] = i return max_length def process_queries(t, queries): return [longest_equal_subseq_length(query) for query in queries]"},{"question":"def is_controversial(u: int, d: int) -> str: Determines whether a post is controversial based on the number of upvotes and downvotes. Args: u (int): Number of upvotes d (int): Number of downvotes Returns: str: \\"Controversial\\" if the post is controversial, \\"Not Controversial\\" otherwise >>> is_controversial(7, 5) \\"Controversial\\" >>> is_controversial(20, 5) \\"Not Controversial\\" >>> is_controversial(5, 5) \\"Controversial\\" >>> is_controversial(3, 9) \\"Not Controversial\\" >>> is_controversial(4, 1) \\"Not Controversial\\" >>> is_controversial(10, 15) \\"Controversial\\" >>> is_controversial(0, 0) \\"Not Controversial\\" >>> is_controversial(500000, 500005) \\"Controversial\\"","solution":"def is_controversial(u, d): Determines whether a post is controversial based on the number of upvotes and downvotes. Args: u (int): Number of upvotes d (int): Number of downvotes Returns: str: \\"Controversial\\" if the post is controversial, \\"Not Controversial\\" otherwise if abs(u - d) <= 5 and (u + d) >= 10: return \\"Controversial\\" else: return \\"Not Controversial\\""},{"question":"def distinct_topics_in_days(n: int, t: int, topics: List[int]) -> int: Returns the total number of distinct topics reviewed in t days. Args: n (int): Number of distinct topics. t (int): Number of days until the exams. topics (list): List of distinct topics. Returns: int: Total distinct topics reviewed in t days. >>> distinct_topics_in_days(5, 12, [1, 2, 3, 4, 5]) 5 >>> distinct_topics_in_days(5, 3, [1, 2, 3, 4, 5]) 3 >>> distinct_topics_in_days(4, 100, [6, 7, 8, 9]) 4 >>> distinct_topics_in_days(1, 10, [1]) 1 >>> distinct_topics_in_days(5, 1, [1, 2, 3, 4, 5]) 1 >>> distinct_topics_in_days(5, 5, [1, 2, 3, 4, 5]) 5","solution":"def distinct_topics_in_days(n, t, topics): Returns the total number of distinct topics reviewed in t days. Args: n (int): Number of distinct topics. t (int): Number of days until the exams. topics (list): List of distinct topics. Returns: int: Total distinct topics reviewed in t days. # Simon ensures to review each topic once before starting over. # Thus, in t days, Simon will have reviewed each topic. return min(n, t) # Because Simon can only review up to \`n\` distinct topics no matter how many days."},{"question":"def find_duplicates(lst: List[int]) -> List[int]: This function takes a list of integers and returns a new list containing only elements that appear more than once in the original list, preserving the order of their first occurrence. >>> find_duplicates([4, 7, 2, 7, 4, 7, 6, 4, 4]) == [4, 7] >>> find_duplicates([1, 2, 3, 4, 5]) == [] >>> find_duplicates([1, 1, 1, 1]) == [1] >>> find_duplicates([1, 2, 2, 3, 1, 4, 5, 6, 2, 7, 3, 8, 1]) == [1, 2, 3] >>> find_duplicates([4, 7, 4, 4, 7, 4]) == [4, 7] >>> find_duplicates([]) == [] >>> find_duplicates([3, 6, 9, 12, 15]) == [] >>> find_duplicates([i for i in range(500)] + [i for i in range(500)]) == [i for i in range(500)]","solution":"def find_duplicates(lst): This function takes a list of integers and returns a new list containing only elements that appear more than once in the original list, preserving the order of their first occurrence. seen = {} duplicates = [] for num in lst: if num in seen: seen[num] += 1 else: seen[num] = 1 for num in lst: if seen[num] > 1 and num not in duplicates: duplicates.append(num) return duplicates"},{"question":"def is_prime(n: int) -> bool: Helper function to check if a number is prime. >>> is_prime(2) # True >>> is_prime(4) # False >>> is_prime(17) # True def longest_prime_subsequence_length(arr: List[int]) -> int: Given an array, returns the length of the longest prime subsequence. >>> longest_prime_subsequence_length([10, 3, 7, 8, 5, 2]) # 4 >>> longest_prime_subsequence_length([1, 4, 6, 8, 10]) # 0","solution":"def is_prime(n): Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def longest_prime_subsequence_length(arr): Given an array, returns the length of the longest prime subsequence. prime_subsequence = [x for x in arr if is_prime(x)] return len(prime_subsequence)"},{"question":"def find_parent(parents, city): if parents[city] == city: return city parents[city] = find_parent(parents, parents[city]) return parents[city] def union(parents, rank, u, v): rootU = find_parent(parents, u) rootV = find_parent(parents, v) if rootU != rootV: if rank[rootU] > rank[rootV]: parents[rootV] = rootU elif rank[rootU] < rank[rootV]: parents[rootU] = rootV else: parents[rootV] = rootU rank[rootU] += 1 def additional_roads_needed(N, M, roads): Determine the minimum number of additional roads needed to ensure that there is a path between any pair of cities. Args: N: int : Number of cities M: int : Number of existing roads roads: List[Tuple[int, int]] : List of tuples representing roads between cities Returns: int : Minimum number of additional roads needed Examples: >>> additional_roads_needed(4, 2, [(1, 2), (2, 3)]) 1 >>> additional_roads_needed(1, 0, []) 0 >>> additional_roads_needed(3, 3, [(1, 2), (2, 3), (3, 1)]) 0 >>> additional_roads_needed(5, 2, [(1, 2), (3, 4)]) 2 >>> additional_roads_needed(3, 2, [(1, 2), (2, 3)]) 0 >>> additional_roads_needed(6, 3, [(1, 2), (2, 3), (4, 5)]) 2 >>> additional_roads_needed(4, 0, []) 3","solution":"def find_parent(parents, city): if parents[city] == city: return city parents[city] = find_parent(parents, parents[city]) return parents[city] def union(parents, rank, u, v): rootU = find_parent(parents, u) rootV = find_parent(parents, v) if rootU != rootV: if rank[rootU] > rank[rootV]: parents[rootV] = rootU elif rank[rootU] < rank[rootV]: parents[rootU] = rootV else: parents[rootV] = rootU rank[rootU] += 1 def additional_roads_needed(N, M, roads): parents = list(range(N + 1)) rank = [0] * (N + 1) for u, v in roads: union(parents, rank, u, v) connected_components = len(set(find_parent(parents, i) for i in range(1, N + 1))) - 1 return connected_components"},{"question":"def classify_strings(strings): Classify each string in the input list as \\"Secure\\" or \\"Not Secure\\" based on the presence of both uppercase and lowercase letters. >>> classify_strings([\\"helloWorld\\", \\"PythonIsFun\\", \\"SecUrity\\"]) ['Secure', 'Secure', 'Secure'] >>> classify_strings([\\"HELLOWORLD\\", \\"12345\\", \\"aaaaaaa\\"]) ['Not Secure', 'Not Secure', 'Not Secure'] >>> classify_strings([\\"helloWorld\\", \\"HELLOWORLD\\", \\"hello1234\\"]) ['Secure', 'Not Secure', 'Not Secure'] >>> classify_strings([\\"hElLoWoRlD\\", \\"h\\", \\"H\\", \\"Zy\\"]) ['Secure', 'Not Secure', 'Not Secure', 'Secure'] >>> classify_strings([\\"\\"]) ['Not Secure']","solution":"def classify_strings(strings): Classify each string in the input list as \\"Secure\\" or \\"Not Secure\\" based on the presence of both uppercase and lowercase letters. results = [] for s in strings: has_upper = any(c.isupper() for c in s) has_lower = any(c.islower() for c in s) if has_upper and has_lower: results.append(\\"Secure\\") else: results.append(\\"Not Secure\\") return results"},{"question":"def largest_lexicographical_string(s: str, k: int) -> str: Returns the largest possible lexicographical string after at most k operations. In one operation, you can choose any character of the string and replace it with any lowercase English letter. >>> largest_lexicographical_string(\\"abcdef\\", 1) 'zbcdef' >>> largest_lexicographical_string(\\"xyz\\", 0) 'xyz'","solution":"def largest_lexicographical_string(s, k): Returns the largest possible lexicographical string after at most k operations. In one operation, you can choose any character of the string and replace it with any lowercase English letter. # Convert the string into a list of characters s = list(s) n = len(s) # Try to replace up to k characters starting from the left for i in range(min(k, n)): s[i] = 'z' return ''.join(s)"},{"question":"def max_tasks(datasets): Returns the list of maximum number of tasks that can be completed before their deadlines for each dataset. >>> max_tasks([(5, [4, 3, 1, 2, 5])]) [5] >>> max_tasks([(6, [2, 2, 2, 2, 2, 2])]) [2] def process_input(input_data): Processes the input data and returns a list of datasets. >>> process_input(\\"5n4 3 1 2 5n6n2 2 2 2 2 2n5n1 2 3 4 5n0\\") [(5, [4, 3, 1, 2, 5]), (6, [2, 2, 2, 2, 2, 2]), (5, [1, 2, 3, 4, 5])] # Unit test for max_tasks def test_single_dataset_all_tasks_meet_deadline(): datasets = [(5, [4, 3, 1, 2, 5])] assert max_tasks(datasets) == [5] def test_single_dataset_some_tasks_miss_deadline(): datasets = [(6, [2, 2, 2, 2, 2, 2])] assert max_tasks(datasets) == [2] def test_single_dataset_all_tasks_meet_deadline_ordered(): datasets = [(5, [1, 2, 3, 4, 5])] assert max_tasks(datasets) == [5] def test_multiple_datasets(): datasets = [(5, [4, 3, 1, 2, 5]), (6, [2, 2, 2, 2, 2, 2]), (5, [1, 2, 3, 4, 5])] assert max_tasks(datasets) == [5, 2, 5] def test_process_input(): input_data = \\"5n4 3 1 2 5n6n2 2 2 2 2 2n5n1 2 3 4 5n0\\" expected_output = [(5, [4, 3, 1, 2, 5]), (6, [2, 2, 2, 2, 2, 2]), (5, [1, 2, 3, 4, 5])] assert process_input(input_data) == expected_output def test_edge_case_large_deadline_values(): datasets = [(3, [1000, 1000, 1000])] assert max_tasks(datasets) == [3]","solution":"def max_tasks(datasets): Returns the list of maximum number of tasks that can be completed before their deadlines for each dataset. results = [] for dataset in datasets: N, deadlines = dataset deadlines.sort() day = 0 completed_tasks = 0 for deadline in deadlines: day += 1 if day <= deadline: completed_tasks += 1 else: break results.append(completed_tasks) return results def process_input(input_data): Processes the input data and returns a list of datasets. datasets = [] lines = input_data.strip().split('n') i = 0 while i < len(lines): N = int(lines[i].strip()) if N == 0: break deadlines = list(map(int, lines[i + 1].strip().split())) datasets.append((N, deadlines)) i += 2 return datasets"},{"question":"def vegetable_farm(n, m, q, grid, queries): Given the initial values of the crops in the grid, a series of modifications, and a number of sub-rectangle queries, determine the maximum value of crops in a specific sub-rectangle after each modification. Args: n (int): number of rows in the grid m (int): number of columns in the grid q (int): number of queries grid (List[List[int]]): the initial values of the crops in the grid queries (List[List[int]]): list of queries or modifications Returns: List[int]: results of sub-rectangle maximum value queries >>> n, m, q = 4, 3, 5 >>> grid = [ ... [4, 2, 3], ... [1, 5, 6], ... [3, 7, 8], ... [9, 1, 2] ... ] >>> queries = [ ... [1, 2, 3, 10], ... [2, 1, 1, 3, 3], ... [1, 4, 3, 11], ... [2, 2, 2, 4, 3], ... [2, 1, 2, 4, 3] ... ] >>> vegetable_farm(n, m, q, grid, queries) [10, 11, 11] >>> n, m, q = 3, 3, 4 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... [2, 1, 1, 3, 3], ... [1, 1, 1, 10], ... [2, 1, 1, 3, 3], ... [2, 2, 2, 2, 2] ... ] >>> vegetable_farm(n, m, q, grid, queries) [9, 10, 5] >>> n, m, q = 2, 2, 2 >>> grid = [ ... [100000, 99999], ... [99998, 99997] ... ] >>> queries = [ ... [2, 1, 1, 2, 2], ... [1, 2, 2, 100001], ... [2, 1, 1, 2, 2] ... ] >>> vegetable_farm(n, m, q, grid, queries) [100000, 100001]","solution":"def vegetable_farm(n, m, q, grid, queries): results = [] for query in queries: if query[0] == 1: # Modification query _, x, y, z = query grid[x - 1][y - 1] = z elif query[0] == 2: # Sub-rectangle max query _, x1, y1, x2, y2 = query max_value = -1 for i in range(x1 - 1, x2): for j in range(y1 - 1, y2): max_value = max(max_value, grid[i][j]) results.append(max_value) return results"},{"question":"def count_islands(grid, n, m): Counts the number of distinct islands in the grid. :param grid: List of list of characters ('L' and 'W') representing the grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :return: The number of distinct islands. def main(input_data): Parses the input data to find number of islands in each dataset. :param input_data: A multiline string where each dataset ends with EOF. :return: A list of integers where each entry is number of islands in respective dataset. import pytest from solution import main def test_example_input(): input_data = \\"3 4nL W L WnL L W WnW W L Ln5 5nL L W W WnL W W W WnW W L L LnL L W W LnL W W L Ln\\" expected_output = [3, 3] assert main(input_data) == expected_output def test_single_island(): input_data = \\"3 3nL L LnL L LnL L Ln\\" expected_output = [1] assert main(input_data) == expected_output def test_mixed_land_water(): input_data = \\"4 4nL W L WnW L W LnL W L WnW L W Ln\\" expected_output = [8] assert main(input_data) == expected_output def test_no_land(): input_data = \\"2 2nW WnW Wn\\" expected_output = [0] assert main(input_data) == expected_output def test_one_row(): input_data = \\"1 5nL W L W Ln\\" expected_output = [3] assert main(input_data) == expected_output def test_one_column(): input_data = \\"5 1nLnWnLnWnLn\\" expected_output = [3] assert main(input_data) == expected_output def test_large_input(): input_data = \\"3 3nL L LnL L LnL L Ln3 3nW W WnW W WnW W Wn\\" expected_output = [1, 0] assert main(input_data) == expected_output","solution":"def count_islands(grid, n, m): Counts the number of distinct islands in the grid. :param grid: List of list of characters ('L' and 'W') representing the grid. :param n: Number of rows in the grid. :param m: Number of columns in the grid. :return: The number of distinct islands. def dfs(x, y): # Stack for DFS stack = [(x, y)] # Explore all connected 'L' cells while stack: cx, cy = stack.pop() for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] == 'L': stack.append((nx, ny)) grid[nx][ny] = 'V' # Mark as visited num_islands = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': num_islands += 1 dfs(i, j) return num_islands def main(input_data): Parses the input data to find number of islands in each dataset. :param input_data: A multiline string where each dataset ends with EOF. :return: A list of integers where each entry is number of islands in respective dataset. data = input_data.strip().split(\\"n\\") index = 0 results = [] while index < len(data): # Read dimensions n, m = map(int, data[index].strip().split()) index += 1 # Read grid grid = [] for i in range(n): grid.append(data[index].strip().split()) index += 1 # Count islands results.append(count_islands(grid, n, m)) return results"},{"question":"def maximize_attention_distribution(n: int, priorities: List[int]) -> List[int]: Assign projects to teams such that high-priority projects are assigned first, followed by medium-priority projects, and then low-priority projects. >>> maximize_attention_distribution(5, [2, 1, 0, 2, 1]) [1, 4, 2, 5, 3] >>> maximize_attention_distribution(4, [2, 0, 1, 0]) [1, 3, 2, 4] >>> maximize_attention_distribution(3, [0, 0, 0]) [1, 2, 3] >>> maximize_attention_distribution(3, [2, 2, 2]) [1, 2, 3]","solution":"def maximize_attention_distribution(n, priorities): projects = list(enumerate(priorities, 1)) # Sort projects by priority in descending order sorted_projects = sorted(projects, key=lambda x: -x[1]) # Extract the sorted project indices assignment = [project[0] for project in sorted_projects] return assignment"},{"question":"def can_transform(S: str, T: str) -> bool: Determines if string S can be transformed into string T by removing some characters. >>> can_transform('abcdef', 'acf') True >>> can_transform('abcdef', 'zab') False >>> can_transform('abc', 'abc') True >>> can_transform('a', 'a') True >>> can_transform('a', 'b') False >>> can_transform('axyz', 'ay') True >>> can_transform('abcdef', '') True >>> can_transform('', 'a') False >>> can_transform('a' * 50 + 'b' * 50, 'abb') True >>> can_transform('a' * 50 + 'b' * 50, 'abbc') False","solution":"def can_transform(S, T): Determines if string S can be transformed into string T by removing some characters. it = iter(S) return all(char in it for char in T)"},{"question":"def inventory_system(stock_items, orders): Determine if orders can be fulfilled based on stock levels. Args: stock_items (List[Tuple[int, int]]): List of tuples containing item ID and stock quantity. orders (List[Tuple[int, int]]): List of tuples containing item ID and order quantity. Returns: List[str]: List of strings \\"Fulfilled\\" or \\"Not Fulfilled\\" for each order. >>> inventory_system([(101, 20), (102, 15), (103, 10), (104, 30), (105, 25)], [(101, 5), (103, 12), (102, 15), (105, 30)]) ['Fulfilled', 'Not Fulfilled', 'Fulfilled', 'Not Fulfilled'] >>> inventory_system([(110, 5), (111, 3)], [(110, 6), (111, 4)]) ['Not Fulfilled', 'Not Fulfilled'] >>> inventory_system([(120, 10)], [(120, 5), (120, 5), (120, 1)]) ['Fulfilled', 'Fulfilled', 'Not Fulfilled'] >>> inventory_system([(130, 5)], [(130, 5)]) ['Fulfilled'] >>> inventory_system([], [(140, 1)]) ['Not Fulfilled'] >>> inventory_system([(150, 10)], []) [] >>> inventory_system([(200 + i, 1000) for i in range(200)], [(200 + i, 1) for i in range(200)]) ['Fulfilled'] * 200","solution":"def inventory_system(stock_items, orders): stock = {item_id: quantity for item_id, quantity in stock_items} results = [] for item_id, quantity in orders: if item_id in stock and stock[item_id] >= quantity: stock[item_id] -= quantity results.append(\\"Fulfilled\\") else: results.append(\\"Not Fulfilled\\") return results"},{"question":"def distribute_food(s: int, p: int, stations: List[Tuple[int, int]], penguins: List[List[int]]) -> List[str]: Distributes food packages to penguins based on their preferences. Args: s (int): Number of supply stations. p (int): Number of penguins. stations (List[Tuple[int, int]]): List of food supply station coordinates. penguins (List[List[int]]): List of penguin preferences. Returns: List[str]: List of allocated food packages coordinates or \\"UNSATISFIED\\" if no food can be allocated. >>> s = 3 >>> p = 3 >>> stations = [(1, 1), (2, 2), (3, 3)] >>> penguins = [ ... [3, 1, 1, 2, 2, 3, 3], ... [2, 2, 2, 1, 1], ... [1, 3, 3] ... ] >>> distribute_food(s, p, stations, penguins) ['1 1', '2 2', '3 3'] >>> s = 3 >>> p = 4 >>> stations = [(1, 1), (2, 2), (3, 3)] >>> penguins = [ ... [3, 1, 1, 2, 2, 3, 3], ... [2, 2, 2, 1, 1], ... [1, 3, 3], ... [1, 3, 3] ... ] >>> distribute_food(s, p, stations, penguins) ['1 1', '2 2', '3 3', 'UNSATISFIED']","solution":"def distribute_food(s, p, stations, penguins): from collections import defaultdict # Initialize food availability at each station food_supply = defaultdict(int) for (xi, yi) in stations: food_supply[(xi, yi)] += 1 result = [] for penguin in penguins: food_allocated = None preferences = penguin[1:] for i in range(len(preferences)//2): station = (preferences[2*i], preferences[2*i + 1]) if food_supply[station] > 0: food_supply[station] -= 1 food_allocated = station break if food_allocated: result.append(f\\"{food_allocated[0]} {food_allocated[1]}\\") else: result.append(\\"UNSATISFIED\\") return result # Inputs s = 3 p = 3 stations = [(1, 1), (2, 2), (3, 3)] penguins = [ [3, 1, 1, 2, 2, 3, 3], [2, 2, 2, 1, 1], [1, 3, 3] ] # Getting the output by calling the function output = distribute_food(s, p, stations, penguins) # Printing the output for out in output: print(out)"},{"question":"def search_notes(n: int, notes_details: List[Tuple[str, str]], q: int, queries: List[str]) -> List[Tuple[int, str]]: Search for notes containing specified words either in their title or body text. Args: n: Integer, number of notes. notes_details: List of tuples, each containing title and body text of a note. q: Integer, number of queries. queries: List of strings, each string is a query. Returns: List of tuples, each with the number of matches and the title of any matched note. Examples: >>> search_notes(3, [(\\"Meeting\\", \\"Discuss project timelines\\"), (\\"Shopping\\", \\"Buy milk, eggs, and bread\\"), (\\"Project Update\\", \\"Report the latest status of the project\\")], 4, [\\"project\\", \\"milk\\", \\"status\\", \\"office\\"]) [(2, \\"Meeting\\"), (1, \\"Shopping\\"), (1, \\"Project Update\\"), (0, \\"-\\")] >>> search_notes(2, [(\\"Meeting\\", \\"Discuss timelines\\"), (\\"Shopping\\", \\"Buy eggs and bread\\")], 2, [\\"milk\\", \\"project\\"]) [(0, \\"-\\"), (0, \\"-\\")]","solution":"def search_notes(n, notes_details, q, queries): Search for notes containing specified words either in their title or body text. Args: n: Integer, number of notes. notes_details: List of tuples, each containing title and body text of a note. q: Integer, number of queries. queries: List of strings, each string is a query. Returns: List of tuples, each with the number of matches and the title of any matched note. result = [] notes_data = [{'title': title, 'body': body} for title, body in notes_details] for query in queries: matched_titles = [note['title'] for note in notes_data if query in note['title'] or query in note['body']] if matched_titles: result.append((len(matched_titles), matched_titles[0])) else: result.append((0, '-')) return result"},{"question":"from typing import List, Tuple def max_research_output(n: int, k: int, scores: List[int], edges: List[Tuple[int, int]]) -> int: A program to determine the maximum possible sum of research output scores for any connected subgraph of a given size in the university network. :param n: The number of nodes in the graph :param k: The required size of the subgraph :param scores: A list of scores for each node :param edges: A list of tuples representing the edges between the nodes :return: The maximum possible sum of research output scores for any connected subgraph of size k Examples: >>> max_research_output(6, 3, [10, 20, 30, 40, 50, 60], [(0, 1), (0, 2), (1, 3), (2, 4), (2, 5)]) 150 >>> max_research_output(1, 1, [10], []) 10 >>> max_research_output(6, 2, [10, 20, 30, 40, 50, 60], [(0, 1), (2, 3), (4, 5)]) 110","solution":"def max_research_output(n, k, scores, edges): from itertools import combinations from collections import defaultdict # Build adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # Function to perform DFS and collect connected component def dfs(node, visited): stack = [node] connected_component = [] while stack: current = stack.pop() if current not in visited: visited.add(current) connected_component.append(current) for neighbor in adj_list[current]: if neighbor not in visited: stack.append(neighbor) return connected_component # Find all connected components visited = set() connected_components = [] for i in range(n): if i not in visited: connected_component = dfs(i, visited) connected_components.append(connected_component) max_sum = 0 for component in connected_components: if len(component) >= k: comb = combinations(component, k) for c in comb: total_score = sum(scores[x] for x in c) if total_score > max_sum: max_sum = total_score return max_sum"},{"question":"def min_changes_to_match_inventory(s1: str, s2: str) -> int: Determine the minimum number of changes required to convert the inventory list to the expected list. >>> min_changes_to_match_inventory(\\"inventory\\", \\"invtorya\\") 3 >>> min_changes_to_match_inventory(\\"abcde\\", \\"fghij\\") 5 # Initialize a table to store results of subproblems m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]","solution":"def min_changes_to_match_inventory(s1, s2): Returns the minimum number of changes required to convert s1 to s2. # Initialize a table to store results of subproblems m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] # Fill dp array for i in range(m + 1): for j in range(n + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore last character and recur for remaining string elif s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If the last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[m][n]"},{"question":"def evaluate_expression(expression: str, x: int) -> int: Evaluates a parametric expression with the variable x. Parameters: expression (str): The parametric expression string. x (int): The value of the variable x. Returns: int/float: The computed result of the expression. Examples: >>> evaluate_expression(\\"2*x+3-4\\", 5) 9 >>> evaluate_expression(\\"2*x*3+4\\", 5) 34","solution":"def evaluate_expression(expression, x): Evaluates a parametric expression with the variable x. Parameters: expression (str): The parametric expression string. x (int): The value of the variable x. Returns: int/float: The computed result of the expression. # Replace 'x' in the expression with the actual value of x modified_expression = expression.replace('x', str(x)) try: # Evaluate the expression result = eval(modified_expression) return result except Exception as e: raise ValueError(f\\"Invalid expression: {expression}\\") from e"},{"question":"def is_beautiful_sequence(arr): Checks if the array can be rearranged to form a strictly increasing or strictly decreasing sequence. def beautiful_sequence_check(test_cases): Checks each provided test case to determine if the sequence can be rearranged into a 'Beautiful' sequence. results = [] for n, arr in test_cases: if is_beautiful_sequence(arr): results.append(\\"Yes\\") else: results.append(\\"No\\") return results # Test Cases def test_single_element(): assert beautiful_sequence_check([(1, [1])]) == [\\"Yes\\"] def test_all_elements_unique(): assert beautiful_sequence_check([(3, [1, 2, 3])]) == [\\"Yes\\"] assert beautiful_sequence_check([(4, [4, 3, 2, 1])]) == [\\"Yes\\"] def test_duplicates_in_array(): assert beautiful_sequence_check([(5, [2, 2, 2, 3, 4])]) == [\\"No\\"] assert beautiful_sequence_check([(4, [1, 3, 2, 2])]) == [\\"No\\"] def test_all_elements_same(): assert beautiful_sequence_check([(3, [1, 1, 1])]) == [\\"No\\"] def test_mixed_cases(): test_cases = [ (5, [2, 2, 2, 3, 4]), (4, [1, 3, 2, 2]), (3, [9, 8, 7]) ] assert beautiful_sequence_check(test_cases) == [\\"No\\", \\"No\\", \\"Yes\\"]","solution":"def is_beautiful_sequence(arr): Checks if the array can be rearranged to form a strictly increasing or strictly decreasing sequence. unique_elements = set(arr) sorted_arr = sorted(unique_elements) reversed_arr = list(reversed(sorted_arr)) # A sequence is beautiful if it can either be strictly increasing or strictly decreasing. return len(unique_elements) == len(arr) def beautiful_sequence_check(test_cases): Checks each provided test case to determine if the sequence can be rearranged into a 'Beautiful' sequence. results = [] for n, arr in test_cases: if is_beautiful_sequence(arr): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def max_sum_submatrix(matrix, n, m): Find the largest sum of any contiguous submatrix within the given matrix. The submatrix should contain at least one element. Args: matrix (List[List[int]]): 2D list representing the matrix of integers n (int): number of rows in the matrix m (int): number of columns in the matrix Returns: int: The maximum sum of a contiguous submatrix. Examples: >>> max_sum_submatrix([[-1, -2, 3], [4, 5, 6]], 2, 3) 15 >>> max_sum_submatrix([[1, 2, -1], [-3, 4, 5], [6, -7, 8]], 3, 3) 15 def test_single_case(): matrix = [ [-1, -2, 3], [4, 5, 6] ] assert max_sum_submatrix(matrix, 2, 3) == 15 def test_multiple_cases(): case1 = [ [1, 2, -1], [-3, 4, 5], [6, -7, 8] ] case2 = [ [-1, -2, 3], [4, 5, 6] ] assert max_sum_submatrix(case1, 3, 3) == 15 assert max_sum_submatrix(case2, 2, 3) == 15 def test_simple_case(): matrix = [ [1] ] assert max_sum_submatrix(matrix, 1, 1) == 1 def test_negative_elements(): matrix = [ [-1, -2, -3], [-4, -5, -6] ] assert max_sum_submatrix(matrix, 2, 3) == -1 def test_mixed_elements(): matrix = [ [-1, 2, 3], [-3, 4, -5], [1, 2, 1] ] assert max_sum_submatrix(matrix, 3, 3) == 8","solution":"def max_sum_submatrix(matrix, n, m): def max_subarray_sum(arr): max_sum, current_sum = float('-inf'), 0 for num in arr: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum max_sum = float('-inf') for left in range(m): temp = [0] * n for right in range(left, m): for i in range(n): temp[i] += matrix[i][right] max_sum = max(max_sum, max_subarray_sum(temp)) return max_sum def process_input(): import sys input = sys.stdin.read data = input().strip().split() idx = 0 t = int(data[idx]) idx += 1 results = [] for _ in range(t): n = int(data[idx]) m = int(data[idx + 1]) idx += 2 matrix = [] for i in range(n): row = list(map(int, data[idx: idx + m])) idx += m matrix.append(row) results.append(max_sum_submatrix(matrix, n, m)) for result in results: print(result) # Sample usage if __name__ == \\"__main__\\": process_input()"},{"question":"def calculate_median(scores: List[int]) -> float: Calculate the median score from a list of scores. Args: scores (List[int]): A list of integers representing scores. Returns: float: The median score. >>> calculate_median([70]) == 70.0 >>> calculate_median([70, 50, 90, 85, 95]) == 85.0 >>> calculate_median([40, 60, 80, 20]) == 50.0 >>> calculate_median([15, 64, 32, 58, 12, 44, 92, 33, 78, 48]) == 46.0 >>> calculate_median([34, 21, 12, 98, 67, 43, 56, 78, 99]) == 56.0","solution":"def calculate_median(scores): Returns the median of the given scores. scores.sort() n = len(scores) if n % 2 == 1: # Odd number of elements median = scores[n // 2] else: # Even number of elements median = (scores[n // 2 - 1] + scores[n // 2]) / 2 return float(median)"},{"question":"def inventory_management(n, transactions): Develop an inventory management system for a small bookshop. The program reads a sequence of transactions and keeps an updated count of the unique book titles available in the inventory after each transaction. Parameters: n (int): The number of transactions transactions (list of str): A list of transaction strings in the form 'add t x' or 'remove t x'. Returns: list of int: A list containing the number of unique book titles in the inventory after each transaction. Examples: >>> inventory_management(5, [\\"add HarryPotter 5\\", \\"add LOTR 3\\", \\"remove HarryPotter 2\\", \\"remove LOTR 3\\", \\"add ArtOfWar 1\\"]) [1, 2, 2, 1, 2]","solution":"def inventory_management(n, transactions): from collections import defaultdict inventory = defaultdict(int) unique_books_count = [] for transaction in transactions: action, title, count = transaction.split() count = int(count) if action == 'add': inventory[title] += count elif action == 'remove': inventory[title] -= count if inventory[title] <= 0: del inventory[title] unique_books_count.append(len(inventory)) return unique_books_count"},{"question":"def num_irrigation_systems(m: int, n: int, grid: List[List[int]]) -> int: Compute the minimum number of irrigation systems needed to water all sections of the field. >>> num_irrigation_systems(4, 5, [ ... [1, 1, 0, 2, 2], ... [1, 0, 0, 2, 2], ... [0, 0, 1, 1, 1], ... [0, 2, 2, 2, 0] ... ]) == 4 >>> num_irrigation_systems(3, 3, [ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) == 0 >>> num_irrigation_systems(3, 3, [ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) == 1 >>> num_irrigation_systems(4, 4, [ ... [1, 2, 0, 2], ... [1, 2, 2, 2], ... [0, 0, 2, 1], ... [1, 1, 0, 0] ... ]) == 4 >>> num_irrigation_systems(4, 4, [ ... [1, 0, 2, 0], ... [0, 1, 0, 2], ... [2, 0, 1, 0], ... [0, 2, 0, 1] ... ]) == 8 pass","solution":"def num_irrigation_systems(m, n, grid): if not grid or not grid[0]: return 0 visited = [[False for _ in range(n)] for _ in range(m)] def dfs(i, j, plant_type): stack = [(i, j)] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while stack: x, y = stack.pop() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == plant_type: visited[nx][ny] = True stack.append((nx, ny)) irrigation_systems = 0 for i in range(m): for j in range(n): if grid[i][j] != 0 and not visited[i][j]: visited[i][j] = True dfs(i, j, grid[i][j]) irrigation_systems += 1 return irrigation_systems"},{"question":"from typing import List def compress_string(s: str) -> str: Compress a single string representing a schedule. >>> compress_string(\\"aaabbcccaa\\") 'a3b2c3a2' >>> compress_string(\\"aabbcc\\") 'a2b2c2' >>> compress_string(\\"abc\\") 'a1b1c1' >>> compress_string(\\"\\") '' >>> compress_string(\\"a\\") 'a1' >>> compress_string(\\"aaaaaaa\\") 'a7' >>> compress_string(\\"aabbaa\\") 'a2b2a2' def compress_schedules(test_cases: List[str]) -> List[str]: Compress a list of strings representing schedules. >>> compress_schedules([\\"aaabbcccaa\\", \\"aabbcc\\", \\"abc\\"]) ['a3b2c3a2', 'a2b2c2', 'a1b1c1'] from solution import compress_schedules def test_compress_string(): test_cases = [ (\\"aaabbcccaa\\", \\"a3b2c3a2\\"), (\\"aabbcc\\", \\"a2b2c2\\"), (\\"abc\\", \\"a1b1c1\\"), (\\"\\", \\"\\"), (\\"a\\", \\"a1\\"), (\\"aaaaaaa\\", \\"a7\\"), (\\"aabbaa\\", \\"a2b2a2\\") ] for input_str, expected in test_cases: assert compress_schedules([input_str])[0] == expected def test_multiple_cases(): input_cases = [\\"aaabbcccaa\\", \\"aabbcc\\", \\"abc\\"] expected_results = [\\"a3b2c3a2\\", \\"a2b2c2\\", \\"a1b1c1\\"] assert compress_schedules(input_cases) == expected_results def test_large_input(): input_case = \\"a\\" * 100000 expected = \\"a100000\\" assert compress_schedules([input_case])[0] == expected","solution":"def compress_string(s): Returns the compressed form of the string s. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(f\\"{s[i - 1]}{count}\\") count = 1 compressed.append(f\\"{s[-1]}{count}\\") return ''.join(compressed) def compress_schedules(test_cases): results = [] for case in test_cases: results.append(compress_string(case)) return results"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Count the number of distinct palindromic substrings in a given string. >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 >>> count_distinct_palindromic_substrings(\\"a\\") 1 >>> count_distinct_palindromic_substrings(\\"abcd\\") 4 >>> count_distinct_palindromic_substrings(\\"aaaa\\") 4 >>> count_distinct_palindromic_substrings(\\"aabaa\\") 5 >>> count_distinct_palindromic_substrings(\\"abacdfgdcaba\\") 7","solution":"def count_distinct_palindromic_substrings(s): def is_palindrome(st): return st == st[::-1] palindromic_subsets = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): subset = s[i:j] if is_palindrome(subset): palindromic_subsets.add(subset) return len(palindromic_subsets)"},{"question":"def calculate_total_cost(n, f, comfort_scores, s): Calculate the total cost for the workshop based on the number of chairs, the comfort scores of those chairs, and the number of students attending. Parameters: n (int): Number of chairs. f (int): Fine for each standing student. comfort_scores (list of int): Comfort scores for the chairs. s (int): Number of students. Returns: int: The total cost which is the sum of the comfort scores of the chairs used minus the fines paid for the standing students. pass # Test Cases def test_calculate_total_cost_example1(): assert calculate_total_cost(3, 2, [3, 1, 2], 4) == 4 def test_calculate_total_cost_example2(): assert calculate_total_cost(3, 5, [3, 2, 1], 2) == 5 def test_calculate_total_cost_students_less_than_chairs(): assert calculate_total_cost(5, 5, [4, 5, 1, 2, 3], 3) == 12 def test_calculate_total_cost_students_equal_chairs(): assert calculate_total_cost(3, 1, [3, 2, 1], 3) == 6 def test_calculate_total_cost_all_students_standing(): assert calculate_total_cost(0, 3, [], 4) == -12 def test_calculate_total_cost_no_fine(): assert calculate_total_cost(4, 0, [4, 3, 2, 1], 4) == 10 def test_calculate_total_cost_no_students(): assert calculate_total_cost(3, 2, [4, 5, 6], 0) == 0","solution":"def calculate_total_cost(n, f, comfort_scores, s): Calculate the total cost for the workshop based on the number of chairs, the comfort scores of those chairs, and the number of students attending. Parameters: n (int): Number of chairs. f (int): Fine for each standing student. comfort_scores (list of int): Comfort scores for the chairs. s (int): Number of students. Returns: int: The total cost which is the sum of the comfort scores of the chairs used minus the fines paid for the standing students. # Sort the comfort scores in descending order comfort_scores.sort(reverse=True) # Calculate the number of students who will sit and the number who will stand students_who_sit = min(n, s) students_who_stand = max(0, s - n) # Calculate the total comfort score for the sitting students total_comfort = sum(comfort_scores[:students_who_sit]) # Calculate the total fine for the standing students total_fine = students_who_stand * f # Calculate the total cost total_cost = total_comfort - total_fine return total_cost"},{"question":"def minimum_cost_road_network(t: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]]]]) -> List[Union[int, str]]: Given the number of test cases, and for each test case the number of cities and roads, finds the minimum cost to connect all the cities or determine if it is impossible. >>> minimum_cost_road_network(2, [(4, 2, [(1, 2, 3), (3, 4, 4)]), (3, 3, [(1, 2, 1), (2, 3, 2), (3, 1, 4)])]) [\\"Impossible\\", 3] >>> minimum_cost_road_network(1, [(3, 0, [])]) [\\"Impossible\\"] >>> minimum_cost_road_network(1, [(1, 0, [])]) [0] >>> minimum_cost_road_network(1, [(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)])]) [6] >>> minimum_cost_road_network(1, [(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4)])]) [6]","solution":"from heapq import heappop, heappush def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): parent = list(range(n + 1)) rank = [0] * (n + 1) edges.sort(key=lambda x: x[2]) mst_weight = 0 edges_used = 0 for u, v, weight in edges: root_u = find(parent, u) root_v = find(parent, v) if root_u != root_v: union(parent, rank, root_u, root_v) mst_weight += weight edges_used += 1 if edges_used == n - 1: break if edges_used != n - 1: return \\"Impossible\\" return mst_weight def minimum_cost_road_network(t, test_cases): results = [] for i in range(t): n, m, roads = test_cases[i] if n == 1: results.append(0) else: result = kruskal(n, roads) results.append(result) return results"},{"question":"def best_hand(cards: List[Tuple[int, int]]) -> str: Determine the best possible hand from a given set of five cards. Each card is represented as a tuple (suit, rank). Returns one of the following string representations: \\"Straight Flush\\", \\"Four of a Kind\\", \\"Full House\\", \\"Flush\\", \\"Straight\\", \\"Three of a Kind\\", \\"Two Pair\\", \\"Pair\\", \\"High Card\\". >>> best_hand([(1, 10), (1, 11), (1, 12), (1, 13), (1, 9)]) == \\"Straight Flush\\" >>> best_hand([(2, 5), (3, 5), (4, 5), (1, 5), (2, 7)]) == \\"Four of a Kind\\" >>> best_hand([(3, 2), (4, 2), (1, 2), (3, 3), (4, 3)]) == \\"Full House\\" >>> best_hand([(2, 3), (2, 5), (2, 7), (2, 9), (2, 12)]) == \\"Flush\\" >>> best_hand([(1, 3), (4, 4), (2, 5), (3, 6), (1, 7)]) == \\"Straight\\" >>> best_hand([(1, 4), (2, 4), (3, 4), (4, 5), (1, 6)]) == \\"Three of a Kind\\" >>> best_hand([(1, 4), (2, 4), (3, 6), (4, 6), (1, 8)]) == \\"Two Pair\\" >>> best_hand([(1, 4), (2, 4), (3, 6), (4, 8), (1, 9)]) == \\"Pair\\" >>> best_hand([(1, 2), (2, 5), (3, 7), (4, 9), (1, 13)]) == \\"High Card\\"","solution":"def best_hand(cards): Determine the best possible hand from a given set of five cards. Each card is represented as a tuple (suit, rank). Returns one of the following string representations: \\"Straight Flush\\", \\"Four of a Kind\\", \\"Full House\\", \\"Flush\\", \\"Straight\\", \\"Three of a Kind\\", \\"Two Pair\\", \\"Pair\\", \\"High Card\\". from collections import Counter suits = [card[0] for card in cards] ranks = [card[1] for card in cards] rank_counts = Counter(ranks) suit_counts = Counter(suits) unique_ranks = sorted(set(ranks)) def is_consecutive(ranks): return ranks == list(range(min(ranks), max(ranks)+1)) is_flush = len(suit_counts) == 1 is_straight = is_consecutive(unique_ranks) and len(unique_ranks) == 5 if is_flush and is_straight: return \\"Straight Flush\\" if 4 in rank_counts.values(): return \\"Four of a Kind\\" if 3 in rank_counts.values() and 2 in rank_counts.values(): return \\"Full House\\" if is_flush: return \\"Flush\\" if is_straight: return \\"Straight\\" if 3 in rank_counts.values(): return \\"Three of a Kind\\" pairs = [count for count in rank_counts.values() if count == 2] if len(pairs) == 2: return \\"Two Pair\\" if len(pairs) == 1: return \\"Pair\\" return \\"High Card\\""},{"question":"def stalls_with_higher_prices(n, k, prices): This function calculates the number of stalls with fruit prices strictly greater than k. Parameters: n (int): The number of stalls. k (int): The given price threshold. prices (list of int): The prices of the fruits in non-decreasing order. Returns: int: The number of stalls with prices strictly greater than k. >>> stalls_with_higher_prices(5, 7, [1, 3, 7, 10, 12]) 2 >>> stalls_with_higher_prices(5, 7, [1, 3, 4, 5, 6]) 0 >>> stalls_with_higher_prices(5, 2, [3, 4, 5, 6, 7]) 5 >>> stalls_with_higher_prices(1, 3, [3]) 0 >>> stalls_with_higher_prices(100000, -999999999, [i for i in range(0, 100000)]) 100000","solution":"def stalls_with_higher_prices(n, k, prices): This function calculates the number of stalls with fruit prices strictly greater than k. Parameters: n (int): The number of stalls. k (int): The given price threshold. prices (list of int): The prices of the fruits in non-decreasing order. Returns: int: The number of stalls with prices strictly greater than k. count = 0 for price in prices: if price > k: count += 1 return count"},{"question":"def minInsertionsPalindrome(s: str) -> int: Calculates the minimum number of insertions needed to make the given string a palindrome. Example: >>> minInsertionsPalindrome(\\"ab\\") 1 >>> minInsertionsPalindrome(\\"aebcbda\\") 2 >>> minInsertionsPalindrome(\\"race\\") 3 >>> minInsertionsPalindrome(\\"level\\") 0 >>> minInsertionsPalindrome(\\"abcddcba\\") 0","solution":"def minInsertionsPalindrome(s): Calculates the minimum number of insertions needed to make the given string a palindrome. # Helper function to find the length of the longest palindromic subsequence def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: dp[i][j] = 2 + dp[i+1][j-1] else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] n = len(s) lps = longest_palindromic_subsequence(s) return n - lps"},{"question":"def determine_functionality(N, cogs, D): Determine if a specific arrangement of cogs will result in a properly functioning clock. >>> determine_functionality(5, [4, 6, 5, 8, 7], 3) \\"FUNCTIONAL\\" >>> determine_functionality(4, [1, 3, 7, 2], 2) \\"NON-FUNCTIONAL\\" >>> determine_functionality(6, [1, 2, 3, 4, 5, 6], 1) \\"FUNCTIONAL\\" def process_input(input_data): Process input data to determine functionality of each arrangement of cogs.","solution":"def determine_functionality(N, cogs, D): for i in range(N-1): if abs(cogs[i] - cogs[i+1]) > D: return \\"NON-FUNCTIONAL\\" return \\"FUNCTIONAL\\" def process_input(input_data): lines = input_data.strip().split('n') index = 0 results = [] while index < len(lines): if lines[index] == '0': break N = int(lines[index]) cogs = list(map(int, lines[index + 1].split())) D = int(lines[index + 2]) results.append(determine_functionality(N, cogs, D)) index += 3 return results"},{"question":"from typing import List def next_symmetrical_identifier(num: int) -> int: Finds the smallest symmetrical identifier that is greater than or equal to the given number. pass def find_smallest_symmetrical_identifiers(identifiers: List[int]) -> List[int]: Given a list of server identifiers, find the smallest symmetrical identifier possible that is greater than or equal to each of the given server identifiers. >>> find_smallest_symmetrical_identifiers([123, 199, 888]) [131, 202, 888] >>> find_smallest_symmetrical_identifiers([1, 10, 11]) [1, 11, 11] pass","solution":"def next_symmetrical_identifier(num): Finds the smallest symmetrical identifier that is greater than or equal to the given number. def is_symmetrical(n): return str(n) == str(n)[::-1] while not is_symmetrical(num): num += 1 return num def find_smallest_symmetrical_identifiers(identifiers): result = [] for identifier in identifiers: result.append(next_symmetrical_identifier(identifier)) return result"},{"question":"class FileSystem: def __init__(self): self.structure = {} def add_directory(self, path, name): full_path = \\"{}/{}\\".format(path.rstrip('/'), name) if full_path not in self.structure: self.structure[full_path] = {\\"files\\": [], \\"subdirs\\": []} if path not in self.structure: self.structure[path] = {\\"files\\": [], \\"subdirs\\": []} self.structure[path]['subdirs'].append(full_path) def add_file(self, path, name, size): if path not in self.structure: self.structure[path] = {\\"files\\": [], \\"subdirs\\": []} self.structure[path]['files'].append({\\"name\\": name, \\"size\\": size}) def get_total_size(self, target_dir): total_size = 0 dirs_to_visit = [target_dir] while dirs_to_visit: current_dir = dirs_to_visit.pop() if current_dir in self.structure: for file in self.structure[current_dir]['files']: total_size += file['size'] dirs_to_visit.extend(self.structure[current_dir]['subdirs']) return total_size def calculate_directory_size(n, entries, target_dir): Calculate the total size of all files within a target directory, including files in all its subdirectories. >>> calculate_directory_size(10, [\\"dir / home\\", \\"dir /home user1\\", \\"file /home/user1 file1.txt 150\\", \\"file /home/user1 file2.txt 200\\", \\"dir /home/user1 docs\\", \\"file /home/user1/docs file3.txt 100\\", \\"dir /home user2\\", \\"file /home/user2 file4.txt 300\\", \\"dir /home/user2 pics\\", \\"file /home/user2/pics pic1.jpg 400\\"], \\"/home/user1\\") 450 >>> calculate_directory_size(5, [\\"dir / projects\\", \\"file /projects proj1.txt 500\\", \\"file /projects proj2.txt 600\\", \\"dir /projects deptA\\", \\"file /projects/deptA report.doc 300\\"], \\"/projects/deptA\\") 300 import pytest from solution import calculate_directory_size def test_example_case_1(): n = 10 entries = [ \\"dir / home\\", \\"dir /home user1\\", \\"file /home/user1 file1.txt 150\\", \\"file /home/user1 file2.txt 200\\", \\"dir /home/user1 docs\\", \\"file /home/user1/docs file3.txt 100\\", \\"dir /home user2\\", \\"file /home/user2 file4.txt 300\\", \\"dir /home/user2 pics\\", \\"file /home/user2/pics pic1.jpg 400\\" ] target_dir = \\"/home/user1\\" assert calculate_directory_size(n, entries, target_dir) == 450 def test_example_case_2(): n = 5 entries = [ \\"dir / projects\\", \\"file /projects proj1.txt 500\\", \\"file /projects proj2.txt 600\\", \\"dir /projects deptA\\", \\"file /projects/deptA report.doc 300\\" ] target_dir = \\"/projects/deptA\\" assert calculate_directory_size(n, entries, target_dir) == 300 def test_no_files(): n = 4 entries = [ \\"dir / data\\", \\"dir /data images\\", \\"dir /data/images 2021\\", \\"dir /data/images 2022\\" ] target_dir = \\"/data/images/2021\\" assert calculate_directory_size(n, entries, target_dir) == 0 def test_single_file(): n = 1 entries = [ \\"file / test.txt 1000\\" ] target_dir = \\"/\\" assert calculate_directory_size(n, entries, target_dir) == 1000 def test_nested_directories(): n = 6 entries = [ \\"dir / level1\\", \\"dir /level1 level2\\", \\"dir /level1/level2 level3\\", \\"file /level1/level2/level3 file.txt 200\\", \\"dir /level1 other\\", \\"file /level1/other file2.txt 300\\" ] target_dir = \\"/level1\\" assert calculate_directory_size(n, entries, target_dir) == 500","solution":"class FileSystem: def __init__(self): self.structure = {} def add_directory(self, path, name): full_path = \\"{}/{}\\".format(path.rstrip('/'), name) if full_path not in self.structure: self.structure[full_path] = {\\"files\\": [], \\"subdirs\\": []} if path not in self.structure: self.structure[path] = {\\"files\\": [], \\"subdirs\\": []} self.structure[path]['subdirs'].append(full_path) def add_file(self, path, name, size): if path not in self.structure: self.structure[path] = {\\"files\\": [], \\"subdirs\\": []} self.structure[path]['files'].append({\\"name\\": name, \\"size\\": size}) def get_total_size(self, target_dir): total_size = 0 dirs_to_visit = [target_dir] while dirs_to_visit: current_dir = dirs_to_visit.pop() if current_dir in self.structure: for file in self.structure[current_dir]['files']: total_size += file['size'] dirs_to_visit.extend(self.structure[current_dir]['subdirs']) return total_size def calculate_directory_size(n, entries, target_dir): fs = FileSystem() for entry in entries: parts = entry.split() if parts[0] == 'dir': _, dir_path, dir_name = parts fs.add_directory(dir_path, dir_name) elif parts[0] == 'file': _, file_dir_path, file_name, size = parts fs.add_file(file_dir_path, file_name, int(size)) return fs.get_total_size(target_dir) # Example of parsing the input and using the function if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip().split('n') n = int(input_data[0]) entries = input_data[1:n+1] target_dir = input_data[n+1] print(calculate_directory_size(n, entries, target_dir))"},{"question":"def can_perform_k_operations(N: int, K: int, M: int, A: List[int]) -> str: Determine if it is possible to perform exactly K operations on the sequence. Each operation consists of choosing a subarray with a sum >= M and reversing it. Args: N : int : Length of sequence K : int : Number of operations to perform M : int : Minimum sum required for subarray A : List[int] : The sequence of integers Returns: str : \\"YES\\" if it is possible to perform the operation exactly K times, otherwise \\"NO\\" >>> can_perform_k_operations(5, 2, 3, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_perform_k_operations(5, 3, 7, [1, 2, 3, 4, 5]) \\"NO\\"","solution":"def can_perform_k_operations(N, K, M, A): prefix_sums = [0] * (N + 1) # Calculate the prefix sums for i in range(N): prefix_sums[i + 1] = prefix_sums[i] + A[i] # Initialize dynamic programming table and find starting points dp = [0] * (K + 1) dp[0] = 1 # Base case for i in range(1, N + 1): for j in range(i): if prefix_sums[i] - prefix_sums[j] >= M: for k in range(K, 0, -1): if dp[k-1] and i > dp[k-1]: dp[k] = i return \\"YES\\" if dp[K] > 0 else \\"NO\\""},{"question":"def can_be_partitioned_to_strictly_increasing_subarrays(n: int, A: List[int]) -> str: Determine if the array can be broken into exactly 3 non-empty contiguous subarrays with strictly increasing elements in each subarray. Parameters: n (int): The size of the array. A (list): The list of integers. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". >>> can_be_partitioned_to_strictly_increasing_subarrays(6, [1, 2, 3, 2, 3, 4]) == \\"YES\\" >>> can_be_partitioned_to_strictly_increasing_subarrays(4, [4, 3, 2, 1]) == \\"NO\\" >>> can_be_partitioned_to_strictly_increasing_subarrays(7, [5, 1, 2, 3, 4, 1, 2]) == \\"YES\\"","solution":"def can_be_partitioned_to_strictly_increasing_subarrays(n, A): Determine if the array can be broken into exactly 3 non-empty contiguous subarrays with strictly increasing elements in each subarray. Parameters: n (int): The size of the array. A (list): The list of integers. Returns: str: \\"YES\\" if it is possible, otherwise \\"NO\\". if n < 3: return \\"NO\\" left = [0] * n right = [0] * n left[0] = 1 for i in range(1, n): if A[i] > A[i-1]: left[i] = left[i-1] + 1 else: left[i] = 1 right[n-1] = 1 for i in range(n-2, -1, -1): if A[i] < A[i+1]: right[i] = right[i+1] + 1 else: right[i] = 1 for i in range(1, n-1): if left[i-1] > 1 and right[i+1] > 1: return \\"YES\\" return \\"NO\\""},{"question":"def lexicographically_smallest_string(n: int, s: str) -> str: Returns the lexicographically smallest string after exactly one adjacent swap. >>> lexicographically_smallest_string(4, \\"dcba\\") \\"cdba\\" >>> lexicographically_smallest_string(3, \\"abc\\") \\"abc\\"","solution":"def lexicographically_smallest_string(n, s): Returns the lexicographically smallest string after exactly one adjacent swap. s_list = list(s) for i in range(n - 1): if s_list[i] > s_list[i + 1]: s_list[i], s_list[i + 1] = s_list[i + 1], s_list[i] return ''.join(s_list) return s"},{"question":"def polygon_area(n: int, vertices: List[Tuple[int, int]]) -> float: Calculate the area of an n-sided polygon using the shoelace formula. Args: n (int): The number of vertices of the polygon. vertices (List[Tuple[int, int]]): The coordinates of the vertices in counter-clockwise order. Returns: float: The area of the polygon rounded to six decimal places. >>> polygon_area(4, [(0, 0), (4, 0), (4, 3), (0, 3)]) 12.000000 >>> polygon_area(3, [(1, 1), (2, 3), (3, 1)]) 2.000000 pass def string_to_polygon_area(input_string: str) -> float: Converts an input string to the area of an n-sided polygon using the shoelace formula. Args: input_string (str): Input string containing the number of vertices and their coordinates. Returns: float: The area of the polygon rounded to six decimal places. >>> string_to_polygon_area(\\"4n0 0 4 0 4 3 0 3n\\") 12.000000 >>> string_to_polygon_area(\\"3n1 1 2 3 3 1n\\") 2.000000 pass","solution":"def polygon_area(n, vertices): Calculate the area of an n-sided polygon using the shoelace formula. Args: n (int): The number of vertices of the polygon. vertices (List[Tuple[int, int]]): The coordinates of the vertices in counter-clockwise order. Returns: float: The area of the polygon rounded to six decimal places. area = 0.0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += (x1 * y2) - (y1 * x2) area = abs(area) / 2.0 return round(area, 6) def string_to_polygon_area(input_string): lines = input_string.strip().split(\\"n\\") n = int(lines[0].strip()) coordinates = list(map(int, lines[1].strip().split())) vertices = [(coordinates[i], coordinates[i + 1]) for i in range(0, 2*n, 2)] return polygon_area(n, vertices)"},{"question":"def calculate_ranks(scores): Calculates the rank for each player based on their scores. Parameters: scores (list): List of integers representing scores of the players. Returns: list: Ranks of the players based on their scores. Example: >>> calculate_ranks([100, 200, 100, 50, 200]) [3, 1, 3, 5, 1] >>> calculate_ranks([30, 10, 20, 30]) [1, 4, 3, 1]","solution":"def calculate_ranks(scores): Calculates the rank for each player based on their scores. Parameters: scores (list): List of integers representing scores of the players. Returns: list: Ranks of the players based on their scores. sorted_scores = sorted(scores, reverse=True) ranks = [] for score in scores: rank = sorted_scores.index(score) + 1 ranks.append(rank) return ranks"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def min_completion_time_for_project(tasks: List[Tuple[str, int, str]]) -> int: Calculate the minimum number of days required to complete all tasks given their durations and dependencies. Args: tasks (List[Tuple[str, int, str]]): List of tasks where each task is represented as a tuple (task name, time required, dependencies). Returns: int: Minimum number of days required to complete all tasks. pass def process_input(input_text: str) -> List[int]: Process the input text and return the minimum completion times for each project described in the input. Args: input_text (str): The input in the specified format containing multiple test cases. Returns: List[int]: List of minimum completion times for each test case. >>> input_text = \\"4ntaskA 5 -ntaskB 10 taskAntaskC 3 taskA,taskBntaskD 2 taskCn0n\\" >>> process_input(input_text) [20] >>> input_text = \\"4ntaskA 5 -ntaskB 10 taskAntaskC 3 taskA,taskBntaskD 2 taskCn3nfrontend 10 -nbackend 15 frontendndatabase 5 backendn0n\\" >>> process_input(input_text) [20, 30] >>> input_text = \\"3ntaskA 5 -ntaskB 10 -ntaskC 3 -n0n\\" >>> process_input(input_text) [10] >>> input_text = \\"3ntaskA 5 -ntaskB 10 taskAntaskC 3 taskBn0n\\" >>> process_input(input_text) [18] >>> input_text = \\"1ntaskA 5 -n0n\\" >>> process_input(input_text) [5] pass if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"from collections import defaultdict, deque def min_completion_time_for_project(tasks): task_durations = {} dependencies = defaultdict(list) in_degree = defaultdict(int) for task in tasks: name, time, deps = task time = int(time) task_durations[name] = time if deps != '-': deps = deps.split(',') for dep in deps: dependencies[dep].append(name) in_degree[name] += 1 else: in_degree[name] = 0 # Topological sorting using Kahn's algorithm queue = deque([task for task in task_durations if in_degree[task] == 0]) completion_time = {task: 0 for task in task_durations} while queue: current_task = queue.popleft() current_finish_time = completion_time[current_task] + task_durations[current_task] for dependent in dependencies[current_task]: in_degree[dependent] -= 1 completion_time[dependent] = max(completion_time[dependent], current_finish_time) if in_degree[dependent] == 0: queue.append(dependent) return max(completion_time[task] + task_durations[task] for task in task_durations) def process_input(input_text): lines = input_text.strip().split('n') i = 0 result = [] while i < len(lines): T = int(lines[i].strip()) if T == 0: break tasks = [] for j in range(i+1, i+1+T): parts = lines[j].strip().split(maxsplit=2) name = parts[0] time = parts[1] dependencies = parts[2] if len(parts) > 2 else '-' tasks.append((name, time, dependencies)) result.append(min_completion_time_for_project(tasks)) i += T + 1 return result"},{"question":"def max_treasure_chests(n: int, ships: List[Tuple[int, int]]) -> int: Calculates the maximum number of treasure chests that can be distributed across the fleet. Args: n (int): The number of ships. ships (list of tuples): Each tuple contains two integers representing the speed and the capacity of the ship. Returns: int: The maximum number of treasure chests that can be distributed. >>> max_treasure_chests(3, [(10, 100), (20, 150), (30, 200)]) 450 >>> max_treasure_chests(5, [(15, 100), (25, 120), (35, 130), (20, 140), (10, 90)]) 580 >>> max_treasure_chests(1, [(10, 1000)]) 1000 >>> max_treasure_chests(2, [(50, 500), (50, 500)]) 1000 >>> max_treasure_chests(4, [(10, 50), (20, 50), (30, 50), (40, 50)]) 200","solution":"def max_treasure_chests(n, ships): Calculates the maximum number of treasure chests that can be distributed across the fleet. Args: n (int): The number of ships. ships (list of tuples): Each tuple contains two integers representing the speed and the capacity of the ship. Returns: int: The maximum number of treasure chests that can be distributed. total_capacity = sum(capacity for speed, capacity in ships) return total_capacity"},{"question":"def min_removals_to_almost_sorted(arr): Returns the minimum number of elements to remove from the array to make it almost sorted. >>> min_removals_to_almost_sorted([3, 2, 5, 1, 6, 7]) 2 >>> min_removals_to_almost_sorted([1, 2, 3, 4, 2]) 1 >>> min_removals_to_almost_sorted([10, 1, 5, 2]) 2","solution":"def min_removals_to_almost_sorted(arr): Returns the minimum number of elements to remove from the array to make it almost sorted. def is_sorted_with_removal(arr, skip_index): temp_arr = [arr[i] for i in range(len(arr)) if i != skip_index] return all(temp_arr[i] <= temp_arr[i+1] for i in range(len(temp_arr) - 1)) n = len(arr) if any(is_sorted_with_removal(arr, i) for i in range(n)): return 1 return 2"},{"question":"def min_changes_to_palindrome(s: str) -> int: Returns the minimum number of character changes needed to make the string a palindrome. >>> min_changes_to_palindrome(\\"a\\") 0 >>> min_changes_to_palindrome(\\"racecar\\") 0 >>> min_changes_to_palindrome(\\"abca\\") 1 >>> min_changes_to_palindrome(\\"racear\\") 1 >>> min_changes_to_palindrome(\\"abcdef\\") 3 >>> min_changes_to_palindrome(\\"abbaa\\") 1 >>> min_changes_to_palindrome(\\"aBcDeF\\") 3 pass","solution":"def min_changes_to_palindrome(s): Returns the minimum number of character changes needed to make the string a palindrome. n = len(s) changes = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: changes += 1 return changes"},{"question":"def smallest_final_integer(n: int, nums: List[int]) -> int: Jane loves playing with numbers. One day, she came up with an interesting problem while counting small integers. She has a list of n integers, and Jane can perform a special operation on this list. The operation is defined as follows: Select any two integers from the list, remove them, and add their sum to the list. Jane can perform this operation as many times as she likes. Her goal is to transform the list into a single integer by repeatedly applying the operation. However, she wants to know the smallest possible value of this final integer. Write a program that computes the smallest possible value of the final integer after performing the operation any number of times. Input The first line contains an integer n (2 ≤ n ≤ 105) - the number of integers in the list. The second line contains n integers - the integers in the list. Each integer is between 1 and 1000, inclusive. Output Output a single integer — the smallest possible value of the final integer. Examples >>> smallest_final_integer(3, [1, 2, 3]) 6 >>> smallest_final_integer(4, [4, 3, 2, 1]) 10 >>> smallest_final_integer(4, [1, 1, 1, 1]) 4 >>> smallest_final_integer(3, [1000, 1000, 1000]) 3000 >>> smallest_final_integer(5, [1, 500, 2, 999, 3]) 1505","solution":"def smallest_final_integer(n, nums): Computes the smallest possible value of the final integer after performing the defined operation any number of times. return sum(nums)"},{"question":"def longest_repeated_substring_length(s: str) -> int: Returns the length of the longest substring that consists of the same character repeated. >>> longest_repeated_substring_length(\\"aaabbbaaacccaaa\\") 3 >>> longest_repeated_substring_length(\\"abcde\\") 1 >>> longest_repeated_substring_length(\\"aaaaa\\") 5 >>> longest_repeated_substring_length(\\"ababababa\\") 1 >>> longest_repeated_substring_length(\\"a\\") 1 >>> longest_repeated_substring_length(\\"\\") 0","solution":"def longest_repeated_substring_length(s): Returns the length of the longest substring that consists of the same character repeated. if not s: return 0 max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def minimum_adjacent_swaps_to_sort(sweetness: List[int]) -> int: Ursula is a baker who prepares a variety of cakes every day. She arranges the cakes in a row in her bakery. Each cake has a different sweetness level, represented as an integer. Ursula wants to ensure that the cakes are arranged in such a way that every cake is sweeter than the cake before it. However, she can only swap two adjacent cakes at a time to achieve this arrangement. Your task is to find out the minimum number of adjacent swaps she needs to make the sweetness levels of the cakes sorted in strictly increasing order. >>> minimum_adjacent_swaps_to_sort([3, 2, 1, 4]) 3 >>> minimum_adjacent_swaps_to_sort([1, 5, 4, 3, 2]) 6 >>> minimum_adjacent_swaps_to_sort([1, 2, 3]) 0","solution":"def minimum_adjacent_swaps_to_sort(sweetness): Returns the minimum number of adjacent swaps needed to sort the sweetness levels in strictly increasing order. def merge_and_count(arr, temp_arr, left, mid, right): i = left j = mid + 1 k = left inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid - i + 1) j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count n = len(sweetness) temp_arr = [0]*n return merge_sort_and_count(sweetness, temp_arr, 0, n-1)"},{"question":"def max_magical_power(n, potions): Given a list of potion power values, this function returns the maximum possible magical power of the final potion after mixing all possible combinations of potions with different powers. >>> max_magical_power(3, [1, 2, 3]) 6 >>> max_magical_power(4, [4, 4, 4, 5]) 9","solution":"def max_magical_power(n, potions): Given a list of potion power values, returns the maximum possible magical power of the final potion after mixing all possible combinations of potions with different powers. unique_potions = list(set(potions)) return sum(unique_potions)"},{"question":"from typing import List def is_toeplitz_matrix(matrix: List[List[int]]) -> bool: Determines if a given matrix is a Toeplitz matrix. A Toeplitz matrix is a matrix where every diagonal from top-left to bottom-right has the same elements. Args: matrix (List[List[int]]): A two-dimensional list of integers representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, otherwise False. Examples: >>> is_toeplitz_matrix([ ... [1, 2, 3], ... [4, 1, 2], ... [6, 4, 1] ... ]) True >>> is_toeplitz_matrix([ ... [1, 2], ... [2, 2] ... ]) False >>> is_toeplitz_matrix([ ... [3], ... ]) True","solution":"def is_toeplitz_matrix(matrix): Checks if the given matrix is a Toeplitz matrix. A matrix is a Toeplitz matrix if every diagonal from top-left to bottom-right has the same elements. Args: matrix (List[List[int]]): A two-dimensional list of integers representing the matrix. Returns: bool: True if the matrix is a Toeplitz matrix, otherwise False. rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return False return True"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence that can be obtained by removing characters from the string s. >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"abcdef\\") 1 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"agbdba\\") 5","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the string s. n = len(s) # Create a table to store lengths of longest palindromic subsequences of substring s[i:j+1] dp = [[0]*n for _ in range(n)] # Every single character is a palindrome of length 1 for i in range(n): dp[i][i] = 1 # Build the table. The outer loop is for substrings of different lengths for cl in range(2, n+1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j]: if cl == 2: dp[i][j] = 2 else: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) # length of longest palindromic subseq will be in dp[0][n-1] return dp[0][n-1]"},{"question":"def min_operations_to_transform(initial_grid, target_grid): Calculate the minimum number of operations required to transform the initial grid into the target grid. >>> initial_grid = [ ... \\".T.\\", ... \\"..T\\", ... \\"T..\\" ... ] >>> target_grid = [ ... \\"T..\\", ... \\".T.\\", ... \\".T.\\" ... ] >>> min_operations_to_transform(initial_grid, target_grid) 3 >>> initial_grid = [ ... \\"TT\\", ... \\"..\\" ... ] >>> target_grid = [ ... \\"..\\", ... \\"TT\\" ... ] >>> min_operations_to_transform(initial_grid, target_grid) 2 >>> initial_grid = [ ... \\"TT\\", ... \\"TT\\" ... ] >>> target_grid = [ ... \\"TT\\", ... \\"TT\\" ... ] >>> min_operations_to_transform(initial_grid, target_grid) 0 >>> initial_grid = [ ... \\"TTT\\", ... \\"TTT\\" ... ] >>> target_grid = [ ... \\"...\\", ... \\"...\\" ... ] >>> min_operations_to_transform(initial_grid, target_grid) 6 >>> initial_grid = [ ... \\"...\\", ... \\"...\\" ... ] >>> target_grid = [ ... \\"TTT\\", ... \\"TTT\\" ... ] >>> min_operations_to_transform(initial_grid, target_grid) 6 >>> initial_grid = [ ... \\"T.T\\", ... \\"T.T\\" ... ] >>> target_grid = [ ... \\".T.\\", ... \\".T.\\" ... ] >>> min_operations_to_transform(initial_grid, target_grid) 4","solution":"def min_operations_to_transform(initial_grid, target_grid): n = len(initial_grid) m = len(initial_grid[0]) cut_tree = 0 plant_tree = 0 swaps_needed = 0 for i in range(n): for j in range(m): if initial_grid[i][j] == 'T' and target_grid[i][j] == '.': cut_tree += 1 elif initial_grid[i][j] == '.' and target_grid[i][j] == 'T': plant_tree += 1 elif initial_grid[i][j] == 'T' and target_grid[i][j] == 'T': pass elif initial_grid[i][j] == '.' and target_grid[i][j] == '.': pass swaps_needed = min(cut_tree, plant_tree) remaining_operations = abs(cut_tree - plant_tree) return swaps_needed + remaining_operations"},{"question":"def max_weight(W, N, weights): Determine the maximum weight that can be loaded into the truck without exceeding the weight limit W. :param W: int, maximum weight limit of the truck :param N: int, number of packages :param weights: list, list of weight of each package :return: int, maximum weight that can be loaded without exceeding the limit >>> max_weight(50, 5, [10, 20, 30, 40, 50]) 50 >>> max_weight(50, 5, [5, 10, 15, 20, 25]) 50 >>> max_weight(45, 4, [10, 20, 30, 45]) 45","solution":"def max_weight(W, N, weights): Determine the maximum weight that can be loaded into the truck without exceeding the weight limit W. :param W: int, maximum weight limit of the truck :param N: int, number of packages :param weights: list, list of weight of each package :return: int, maximum weight that can be loaded without exceeding the limit dp = [0] * (W + 1) for weight in weights: for j in range(W, weight - 1, -1): dp[j] = max(dp[j], dp[j - weight] + weight) return dp[W]"},{"question":"def can_meet_water_demand(N: int, M: int, R: int, demands: List[int], tanks: List[Tuple[int, int]]) -> str: Determines if the water demand for all houses can be met with given water tanks. Parameters: N (int): Number of houses. M (int): Number of water tanks. R (int): Maximum distance water can flow from the tank. demands (List[int]): A list of water demands for each house. tanks (List[Tuple[int, int]]): A list of tuples where each tuple contains the position of the tank and its capacity. Returns: str: \\"YES\\" if it is possible to meet the water demands of every house; otherwise, \\"NO\\". Examples: >>> can_meet_water_demand(5, 3, 2, [10, 20, 30, 40, 50], [(1, 30), (3, 50), (5, 80)]) \\"YES\\" >>> can_meet_water_demand(5, 1, 2, [10, 20, 30, 40, 50], [(1, 10)]) \\"NO\\" >>> can_meet_water_demand(1, 1, 0, [10], [(1, 10)]) \\"YES\\" >>> can_meet_water_demand(10, 3, 3, [10, 10, 10, 10, 10, 10, 10, 10, 10, 10], [(1, 50), (5, 50), (10, 50)]) \\"YES\\" >>> can_meet_water_demand(3, 2, 1, [20, 30, 40], [(1, 25), (3, 50)]) \\"NO\\"","solution":"def can_meet_water_demand(N, M, R, demands, tanks): Determines if the water demand for all houses can be met with given water tanks. house_demand = demands[:] for pos, cap in tanks: pos -= 1 # convert to 0-based index for calculation start = max(0, pos - R) end = min(N - 1, pos + R) for i in range(start, end + 1): if cap == 0: break if house_demand[i] > 0: if house_demand[i] <= cap: cap -= house_demand[i] house_demand[i] = 0 else: house_demand[i] -= cap cap = 0 return \\"YES\\" if sum(house_demand) == 0 else \\"NO\\""},{"question":"def num_islands(grid: List[List[str]]) -> int: Calculate the number of distinct islands in a 2D grid. >>> num_islands([ ['L', 'W', 'W', 'L', 'L'], ['W', 'W', 'L', 'L', 'L'], ['L', 'L', 'L', 'L', 'W'], ['L', 'W', 'L', 'W', 'W'] ]) == 2 >>> num_islands([ ['L', 'L', 'L'], ['L', 'L', 'L'], ['L', 'L', 'L'] ]) == 1 >>> num_islands([ ['W', 'W', 'W'], ['W', 'W', 'W'], ['W', 'W', 'W'] ]) == 0 >>> num_islands([ ['L', 'W', 'L'], ['W', 'L', 'W'], ['L', 'W', 'L'] ]) == 5 >>> num_islands([ ['L'] ]) == 1 >>> num_islands([ ['W'] ]) == 0 >>> num_islands([ ['L', 'L', 'W', 'W'], ['L', 'L', 'W', 'W'], ['W', 'W', 'L', 'L'], ['W', 'W', 'L', 'L'] ]) == 2","solution":"def num_islands(grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] == 'W': return grid[x][y] = 'W' dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) n = len(grid) m = len(grid[0]) island_count = 0 for i in range(n): for j in range(m): if grid[i][j] == 'L': dfs(i, j) island_count += 1 return island_count"},{"question":"def gcd(x: int, y: int) -> int: Determine the greatest common divisor (GCD) of X and Y. >>> gcd(48, 18) 6 >>> gcd(1000000000, 999999999) 1 >>> gcd(100, 100) 100 >>> gcd(1, 999999999) 1 >>> gcd(987654321, 123456789) 9 >>> gcd(13, 17) 1","solution":"def gcd(x, y): Returns the greatest common divisor (GCD) of x and y. while y: x, y = y, x % y return x"},{"question":"def max_consecutive_pairs(s: str) -> int: Returns the maximum number of consecutive pairs of identical gems in the string. >>> max_consecutive_pairs(\\"aabbbcc\\") == 2 >>> max_consecutive_pairs(\\"abcabcabcd\\") == 0 >>> max_consecutive_pairs(\\"aabaa\\") == 1 >>> max_consecutive_pairs(\\"a\\") == 0 >>> max_consecutive_pairs(\\"abcdef\\") == 0 >>> max_consecutive_pairs(\\"aaaaaaa\\") == 6 >>> max_consecutive_pairs(\\"aabbbbccdddd\\") == 3","solution":"def max_consecutive_pairs(s: str) -> int: Returns the maximum number of consecutive pairs of identical gems in the string. max_pairs = 0 current_pairs = 0 n = len(s) for i in range(1, n): if s[i] == s[i - 1]: current_pairs += 1 max_pairs = max(max_pairs, current_pairs) else: current_pairs = 0 return max_pairs"},{"question":"def process_input(input_string: str) -> int: Schedule several events over a period of time to maximize the total weight of non-overlapping events. Each event has a start time, end time, and weight. The function returns the maximum total weight of non-overlapping events. Args: input_string (str): Multiline string where the first line contains an integer n representing the number of events. Each of the next n lines contains three integers start, end, and weight of the event. Returns: int: The maximum total weight of non-overlapping events. Examples: >>> process_input(\\"3n1 3 4n2 5 3n4 6 2\\") 6 >>> process_input(\\"4n1 2 5n1 3 4n4 6 6n5 8 1\\") 11 >>> process_input(\\"2n1 4 3n2 5 2\\") 3","solution":"from bisect import bisect_right def find_max_weight(events): # Sort events by their end time to facilitate the choice of non-overlapping events events.sort(key=lambda x: x[1]) n = len(events) # dp[i] will store the maximum weight of non-overlapping events till the ith event dp = [0] * n # Store the weight of the first event dp[0] = events[0][2] for i in range(1, n): # Option 1: Exclude the current event weight_including_current = events[i][2] # Find the latest event that doesn't overlap with the current event j = bisect_right([events[k][1] for k in range(i)], events[i][0]) - 1 if j != -1: weight_including_current += dp[j] # Option 2: Exclude the current event dp[i] = max(dp[i-1], weight_including_current) return dp[-1] def process_input(input_string): input_data = input_string.strip().split('n') n = int(input_data[0]) events = [tuple(map(int, line.split())) for line in input_data[1:]] return find_max_weight(events)"},{"question":"def marathon_participants(n: int, bib_numbers: List[int]) -> Tuple[int, Union[None, List[int]]]: Determine the count of unique bib numbers and the duplicate bib numbers. :param n: The number of participants. :param bib_numbers: A list of integers representing bib numbers. :return: A tuple containing the count of unique bib numbers and a list of duplicate bib numbers. >>> marathon_participants(6, [1, 2, 3, 4, 5, 6]) (6, None) >>> marathon_participants(5, [1, 2, 2, 3, 4]) (4, [2]) >>> marathon_participants(5, [1, 1, 1, 1, 1]) (1, [1]) >>> marathon_participants(7, [3, 3, 3, 2, 2, 1, 1]) (3, [1, 2, 3])","solution":"def marathon_participants(n, bib_numbers): Returns the count of unique bib numbers and the duplicate bib numbers. :param n: The number of participants. :param bib_numbers: A list of integers representing bib numbers. :return: A tuple containing the count of unique bib numbers and a list of duplicate bib numbers. from collections import Counter counter = Counter(bib_numbers) unique_count = len(counter) duplicates = sorted([bib for bib, count in counter.items() if count > 1]) return unique_count, duplicates if duplicates else None"},{"question":"def max_subarray_sum(arr): Returns the largest sum of elements in any contiguous subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1]) -1","solution":"def max_subarray_sum(arr): Returns the largest sum of elements in any contiguous subarray. if not arr: return 0 max_so_far = arr[0] max_ending_here = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"from collections import deque from typing import List def min_path_in_grid(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of cells required to traverse from the top-left to the bottom-right corner of the grid or return -1 if not possible. >>> min_path_in_grid(4, 4, [\\"....\\", \\"..#.\\", \\".#..\\", \\"....\\"]) 7 >>> min_path_in_grid(3, 3, [\\".#.\\", \\".\\", \\"...\\"]) -1","solution":"from collections import deque def min_path_in_grid(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] queue = deque([(0, 0, 1)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if (x, y) == (n - 1, m - 1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def max_elevation_difference(n: int, m: int, grid: List[List[int]]) -> int: Returns the maximum elevation difference along any path from the top-left corner to the bottom-right corner of the grid. Args: n (int): Number of rows in the grid. m (int): Number of columns in the grid. grid (List[List[int]]): 2D list representing the grid with elevation values. Returns: int: The maximum difference in elevation along any path from (1, 1) to (n, m). Example: >>> max_elevation_difference(3, 3, [[1, 2, 3], [6, 5, 4], [7, 8, 9]]) 8 >>> max_elevation_difference(1, 1, [[42]]) 0 >>> max_elevation_difference(4, 4, [[1, 100, 100, 100], [1, 1, 1, 1], [100, 100, 100, 1], [100, 100, 100, 100]]) 99 >>> max_elevation_difference(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 8 >>> max_elevation_difference(2, 2, [[0, 1000000000], [1000000000, 0]]) 1000000000","solution":"def max_elevation_difference(n, m, grid): Returns the maximum elevation difference along any path from the top-left corner to the bottom-right corner of the grid. # Initialize dp array min_elevation = [[float('inf')] * m for _ in range(n)] max_elevation = [[-float('inf')] * m for _ in range(n)] # Starting point min_elevation[0][0] = grid[0][0] max_elevation[0][0] = grid[0][0] # Fill the dp array for each cell for i in range(n): for j in range(m): if i > 0: min_elevation[i][j] = min(min_elevation[i][j], min_elevation[i-1][j]) max_elevation[i][j] = max(max_elevation[i][j], max_elevation[i-1][j]) if j > 0: min_elevation[i][j] = min(min_elevation[i][j], min_elevation[i][j-1]) max_elevation[i][j] = max(max_elevation[i][j], max_elevation[i][j-1]) # Update current cell elevation min_elevation[i][j] = min(min_elevation[i][j], grid[i][j]) max_elevation[i][j] = max(max_elevation[i][j], grid[i][j]) # Maximum difference return max_elevation[-1][-1] - min_elevation[-1][-1]"},{"question":"def restore_permutation(n: int, arr: List[int]) -> List[int]: Restores the given array to a permutation of the first n natural numbers, fixing duplicate and missing numbers while maintaining the original order as much as possible. >>> restore_permutation(5, [2, 1, 0, 4, 4]) [2, 1, 3, 4, 5] >>> restore_permutation(6, [0, 0, 2, 5, 5, 6]) [1, 3, 2, 5, 4, 6] >>> restore_permutation(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> restore_permutation(4, [4, 3, 2, 1]) [4, 3, 2, 1] >>> restore_permutation(3, [0, 0, 0]) [1, 2, 3] >>> restore_permutation(4, [0, 0, 0, 0]) [1, 2, 3, 4] >>> restore_permutation(5, [0, 1, 3, 0, 0]) [2, 1, 3, 4, 5] >>> restore_permutation(7, [4, 5, 7, 3, 0, 0, 0]) [4, 5, 7, 3, 1, 2, 6] >>> restore_permutation(1, [0]) [1]","solution":"def restore_permutation(n, arr): Restores the given array to a permutation of the first n natural numbers, fixing duplicate and missing numbers while maintaining the original order as much as possible. Parameters: n (int): The size of the permutation. arr (list of int): The array containing the permutation with possible zeros and duplicates. Returns: list of int: The restored permutation of the first n natural numbers. # Find missing numbers and duplicates existing_nums = set() duplicates_position = [] missing_nums = set(range(1, n + 1)) for i, num in enumerate(arr): if num == 0: duplicates_position.append(i) elif num in existing_nums: duplicates_position.append(i) else: existing_nums.add(num) missing_nums.discard(num) missing_nums = sorted(list(missing_nums)) # Replace the duplicates and zeros with missing numbers for position in duplicates_position: arr[position] = missing_nums.pop(0) return arr"},{"question":"def get_workshop_target(W): Returns the target audience for the workshop based on the workshop number W. Args: W (int): Workshop number. Returns: str: Target audience of the workshop (\\"Beginners\\", \\"Intermediate\\", \\"Advanced\\" or \\"Expert\\"). >>> get_workshop_target(1) 'Intermediate' >>> get_workshop_target(2) 'Advanced' >>> get_workshop_target(3) 'Expert' >>> get_workshop_target(4) 'Beginners' pass def process_workshops(Q, workshops): Processes multiple workshop queries and returns their corresponding target audience. Args: Q (int): Number of workshop queries. workshops (list of int): List of workshop numbers. Returns: list of str: List of target audiences for each workshop number. >>> process_workshops(5, [1, 2, 3, 4, 5]) ['Intermediate', 'Advanced', 'Expert', 'Beginners', 'Intermediate'] >>> process_workshops(3, [10, 12, 13]) ['Advanced', 'Beginners', 'Intermediate'] pass","solution":"def get_workshop_target(W): Returns the target audience for the workshop based on the workshop number W. if W % 4 == 0: return \\"Beginners\\" elif W % 4 == 1: return \\"Intermediate\\" elif W % 4 == 2: return \\"Advanced\\" elif W % 4 == 3: return \\"Expert\\" def process_workshops(Q, workshops): Processes multiple workshop queries and returns their corresponding target audience. results = [] for W in workshops: results.append(get_workshop_target(W)) return results"},{"question":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane's Algorithm. >>> max_subarray_sum([1, -2, 3, 4, -1]) 7 >>> max_subarray_sum([-1, -3, -5]) -1 >>> max_subarray_sum([2, 3, -2, 4]) 7 >>> max_subarray_sum([8, -19, 5, -4, 20]) 21 >>> max_subarray_sum([1]) 1 def process_test_cases(test_cases): Function to process multiple test cases and return the results. >>> test_cases = [(5, [1, -2, 3, 4, -1]), (3, [-1, -3, -5]), (4, [2, 3, -2, 4])] >>> process_test_cases(test_cases) [7, -1, 7]","solution":"def max_subarray_sum(arr): Function to find the maximum sum of a contiguous subarray using Kadane's Algorithm. max_so_far = arr[0] max_ending_here = arr[0] for num in arr[1:]: max_ending_here = max(num, max_ending_here + num) max_so_far = max(max_so_far, max_ending_here) return max_so_far def process_test_cases(test_cases): Function to process multiple test cases and return the results. results = [] for n, arr in test_cases: results.append(max_subarray_sum(arr)) return results"},{"question":"def count_passed_widgets(t, test_cases): Count the number of widgets that passed all quality control checks based on the events. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[str]]]): A list of test cases, each containing the number of events and the list of events. Returns: List[int]: A list of integers representing the number of widgets that passed all checks for each test case. >>> count_passed_widgets(2, [(5, [\\"P 1\\", \\"P 2\\", \\"F 1\\", \\"P 3\\", \\"P 4\\"]), (6, [\\"P 10\\", \\"P 11\\", \\"F 10\\", \\"F 12\\", \\"P 12\\", \\"P 11\\"])]) [3, 1] >>> count_passed_widgets(1, [(4, [\\"P 1\\", \\"F 1\\", \\"P 1\\", \\"P 2\\"])]) [1] >>> count_passed_widgets(1, [(4, [\\"P 1000000000\\", \\"F 1000000000\\", \\"P 999999999\\", \\"P 1000000000\\"])]) [1] >>> count_passed_widgets(1, [(3, [\\"P 1\\", \\"F 2\\", \\"P 2\\"])]) [1] >>> count_passed_widgets(2, [(0, []), (1, [\\"F 1\\"])]) [0, 0]","solution":"def count_passed_widgets(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] events = test_cases[i][1] passed_widgets = set() failed_widgets = set() for event in events: action, widget_id = event.split() widget_id = int(widget_id) if action == 'P': if widget_id not in failed_widgets: passed_widgets.add(widget_id) elif action == 'F': if widget_id in passed_widgets: passed_widgets.remove(widget_id) failed_widgets.add(widget_id) results.append(len(passed_widgets)) return results"},{"question":"def calculate_potions_power(n, k, ingredients, queries): Calculate the power of potions made by mixing sequences of ingredients with the given power levels. Args: n (int): The number of ingredients. k (int): The magical divisor. ingredients (list of int): List of power levels of the ingredients. queries (list of tuples): List of queries with each query as a tuple (li, ri) indicating the range of ingredients. Returns: list of int: List of final powers for each query. >>> calculate_potions_power(8, 100, [4, 7, 2, 9, 3, 6, 5, 8], [(1, 3), (2, 5), (1, 8), (4, 6), (3, 8)]) [13, 21, 44, 18, 33] >>> calculate_potions_power(5, 50, [10, 20, 30, 40, 50], [(1, 3), (2, 4), (3, 5), (1, 5)]) [10, 40, 20, 0] >>> calculate_potions_power(4, 25, [8, 15, 7, 10], [(1, 2), (3, 4), (1, 4)]) [23 % 25, 17 % 25, 40 % 25] >>> calculate_potions_power(3, 10, [1, 2, 3], [(1, 3), (2, 2), (1, 1)]) [6 % 10, 2 % 10, 1 % 10] >>> calculate_potions_power(1, 2, [5], [(1, 1)]) [1] >>> calculate_potions_power(3, 1, [1, 1, 1], [(1, 3)]) [0] >>> calculate_potions_power(6, 200, [20, 30, 40, 50, 60, 70], [(1, 6), (3, 5), (2, 6)]) [270 % 200, 150 % 200, 250 % 200]","solution":"def calculate_potions_power(n, k, ingredients, queries): # Create prefix sums prefix_sums = [0] * (n + 1) for i in range(1, n + 1): prefix_sums[i] = prefix_sums[i - 1] + ingredients[i - 1] # Process each query results = [] for li, ri in queries: # Sum from li to ri (1-based indexing) total_power = prefix_sums[ri] - prefix_sums[li - 1] # Apply the magical formula to get the final power final_power = total_power % k results.append(final_power) return results # Example Usage # Input n = 8 k = 100 ingredients = [4, 7, 2, 9, 3, 6, 5, 8] queries = [(1, 3), (2, 5), (1, 8), (4, 6), (3, 8)] # Output print(calculate_potions_power(n, k, ingredients, queries))"},{"question":"def find_shortest_path(N: int, M: int, roads: List[Tuple[int, int, int]], A: int, B: int) -> int: Determine the shortest path between two colonies in Xylon. >>> find_shortest_path(6, 7, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (2, 4, 7), (3, 5, 3), (4, 6, 1), (5, 6, 5)], 1, 6) 10 >>> find_shortest_path(2, 1, [(1, 2, 5)], 1, 2) 5 >>> find_shortest_path(4, 2, [(1, 2, 3), (3, 4, 4)], 1, 4) -1 >>> find_shortest_path(3, 2, [(1, 2, 1), (2, 3, 1)], 1, 1) 0","solution":"import heapq def find_shortest_path(N, M, roads, A, B): graph = {i: [] for i in range(1, N+1)} for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(source, target): min_heap = [(0, source)] distances = {i: float('inf') for i in range(1, N+1)} distances[source] = 0 visited = set() while min_heap: current_dist, current_node = heapq.heappop(min_heap) if current_node in visited: continue visited.add(current_node) if current_node == target: return current_dist for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return -1 # target is not reachable return dijkstra(A, B)"},{"question":"def longest_subarray_sum(nums, n): Find the length of the longest contiguous subarray of nums that sums up to n. >>> longest_subarray_sum([1, 2, 3, 4, 5], 10) 4 >>> longest_subarray_sum([1, 2, 3, 4, 5, -1], 15) 5 >>> longest_subarray_sum([1, 2, 3], 7) 0 >>> longest_subarray_sum([-1, -1, -1], 1) 0 >>> longest_subarray_sum([1, 2, 3, 4, 5], 15) 5 >>> longest_subarray_sum([-1, 2, -1, 1], 1) 4 >>> longest_subarray_sum([1, -1, 5, -2, 3], 3) 4 >>> longest_subarray_sum([-2, -1, 2, 1], 1) 2 >>> longest_subarray_sum([0, 0, 0, 0], 0) 4 >>> longest_subarray_sum([-3, 1, 2, -3, 4], 3) 3","solution":"def longest_subarray_sum(nums, n): Returns the length of the longest contiguous subarray that sums up to n. sum_indices = {0: -1} current_sum = 0 max_length = 0 for i, num in enumerate(nums): current_sum += num if current_sum - n in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - n]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"def min_meeting_rooms(intervals): Finds the minimum number of meeting rooms required to accommodate all meetings. :param intervals: List of tuples where each tuple contains two integers representing start and end time of a meeting. :return: Integer representing the minimum number of meeting rooms required. >>> min_meeting_rooms([(0, 30), (5, 10), (15, 20)]) 2 >>> min_meeting_rooms([(0, 10), (10, 20), (20, 30)]) 1 >>> min_meeting_rooms([(0, 10), (9, 20), (20, 30)]) 2","solution":"from heapq import heappush, heappop def min_meeting_rooms(intervals): Finds the minimum number of meeting rooms required to accommodate all meetings. :param intervals: List of tuples where each tuple contains two integers representing start and end time of a meeting. :return: Integer representing the minimum number of meeting rooms required. if not intervals: return 0 # Sort intervals by start time intervals.sort(key=lambda x: x[0]) # Use a min-heap to keep track of end times of meetings heap = [] # Iterate over sorted intervals for interval in intervals: start, end = interval # If the heap is not empty and the earliest meeting to end is before the current meeting starts, # we can reuse the room (i.e., remove the top of the heap) if heap and heap[0] <= start: heappop(heap) # Add the current meeting's end time to the heap heappush(heap, end) # The size of the heap is the number of rooms required return len(heap)"},{"question":"from collections import defaultdict, deque from typing import List def max_width(n: int, parents: List[int]) -> int: Determine the maximum width of a tree. :param n: Total number of plants (nodes) in the tree :param parents: List where the ith integer represents the parent of the ith plant. If the ith integer is −1, it means the ith plant is the root. :return: The maximum width of the tree. >>> max_width(6, [-1, 0, 0, 1, 1, 2]) 3 >>> max_width(7, [-1, 0, 0, 1, 1, 1, 2]) 4 pass def test_max_width_single_node(): assert max_width(1, [-1]) == 1 def test_max_width_example_1(): assert max_width(6, [-1, 0, 0, 1, 1, 2]) == 3 def test_max_width_example_2(): assert max_width(7, [-1, 0, 0, 1, 1, 1, 2]) == 4 def test_max_width_multiple_children(): assert max_width(6, [-1, 0, 0, 0, 0, 0]) == 5 def test_max_width_one_child_each(): assert max_width(5, [-1, 0, 1, 2, 3]) == 1","solution":"from collections import defaultdict, deque def max_width(n, parents): # Create a dictionary to hold children for each node tree = defaultdict(list) root = -1 # Build the tree using the parents list for child, parent in enumerate(parents): if parent == -1: root = child else: tree[parent].append(child) # BFS to calculate the width of each level max_width = 0 queue = deque([(root, 0)]) # (node, level) current_level = 0 current_level_count = 0 while queue: node, level = queue.popleft() if level == current_level: current_level_count += 1 else: max_width = max(max_width, current_level_count) current_level = level current_level_count = 1 for child in tree[node]: queue.append((child, level + 1)) # Last level check max_width = max(max_width, current_level_count) return max_width"},{"question":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Given an integer array \`arr\`, find the length of the longest increasing subsequence in the array. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. An increasing subsequence is a subsequence in which each subsequent element is greater than the preceding one. Args: arr (List[int]): A list of integers where 1 ≤ len(arr) ≤ 2000, and -10^4 ≤ arr[i] ≤ 10^4. Returns: int: The length of the longest increasing subsequence in the array. Examples: >>> longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> longest_increasing_subsequence([0, 1, 0, 3, 2, 3]) 4 >>> longest_increasing_subsequence([7, 7, 7, 7, 7, 7, 7]) 1","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given array. n = len(arr) if n == 0: return 0 # Initialize the dp array, each element represents the length of LIS ending at that element dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, x): Append the string x to the end of the current text and save state for undo. pass def delete(self, n): Delete the last n characters from the current text and save state for undo. pass def print_text(self): Print the current state of the text. pass def undo(self): Undo the last append or delete operation and revert the text to its previous state. pass def process_operations(operations): Process a list of operations for the text editor. editor = TextEditor() for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"APPEND\\": editor.append(\\" \\".join(parts[1:])) elif cmd == \\"DELETE\\": editor.delete(int(parts[1])) elif cmd == \\"PRINT\\": editor.print_text() elif cmd == \\"UNDO\\": editor.undo() if __name__ == \\"__main__\\": # Example of input processing for demonstration Q = int(input()) operations = [input().strip() for _ in range(Q)] process_operations(operations)","solution":"class TextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, x): # Save the current state to history before appending self.history.append(self.text) self.text += x def delete(self, n): # Save the current state to history before deleting self.history.append(self.text) self.text = self.text[:-n] def print_text(self): print(self.text) def undo(self): # Revert to the last state in history if available if self.history: self.text = self.history.pop() def process_operations(operations): editor = TextEditor() for operation in operations: parts = operation.split() cmd = parts[0] if cmd == \\"APPEND\\": editor.append(\\" \\".join(parts[1:])) elif cmd == \\"DELETE\\": editor.delete(int(parts[1])) elif cmd == \\"PRINT\\": editor.print_text() elif cmd == \\"UNDO\\": editor.undo() if __name__ == \\"__main__\\": # Sample input processing for demonstration Q = int(input()) operations = [input().strip() for _ in range(Q)] process_operations(operations)"},{"question":"def min_operations_to_palindrome(s: str, k: int) -> int: Determines the minimum number of operations required to transform the string \`s\` into a palindrome using at most \`k\` operations. If it's not possible, returns -1. >>> min_operations_to_palindrome(\\"abcba\\", 1) 0 >>> min_operations_to_palindrome(\\"ab\\", 1) 1 >>> min_operations_to_palindrome(\\"abcd\\", 2) 2 def solve(test_cases: List[Tuple[str, int]]) -> List[int]: Solves multiple test cases to determine the minimum number of operations required to transform each string into a palindrome. >>> solve([(\\"abcba\\", 1), (\\"ab\\", 1), (\\"abcd\\", 2)]) [0, 1, 2] def main(): t = int(input().strip()) test_cases = [] for _ in range(t): s, k = input().strip().split() test_cases.append((s, int(k))) results = solve(test_cases) for result in results: print(result)","solution":"def min_operations_to_palindrome(s, k): Determines the minimum number of operations required to transform the string \`s\` into a palindrome using at most \`k\` operations. If it's not possible, returns -1. n = len(s) left, right = 0, n - 1 operations = 0 while left < right: if s[left] != s[right]: operations += 1 left += 1 right -= 1 if operations > k: return -1 return operations def solve(test_cases): results = [] for s, k in test_cases: results.append(min_operations_to_palindrome(s, int(k))) return results def main(): t = int(input().strip()) test_cases = [] for _ in range(t): s, k = input().strip().split() test_cases.append((s, k)) results = solve(test_cases) for result in results: print(result)"},{"question":"def minimum_edges_to_connect_graph(T: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Given an undirected graph with N nodes and M edges, determine the minimum number of edges to be added to make the graph connected. >>> minimum_edges_to_connect_graph(3, [ ... [(4, 2), [(1, 2), (3, 4)]], ... [(5, 0), []], ... [(3, 2), [(1, 2), (2, 3)]] ... ]) [1, 4, 0] >>> minimum_edges_to_connect_graph(1, [ ... [(6, 4), [(1, 2), (1, 3), (4, 5), (5, 6)]] ... ]) [1] >>> minimum_edges_to_connect_graph(2, [ ... [(6, 0), []], ... [(3, 3), [(1, 2), (2, 3), (3, 1)]] ... ]) [5, 0]","solution":"def minimum_edges_to_connect_graph(T, test_cases): def dfs(node, visited, adj): stack = [node] while stack: v = stack.pop() if not visited[v]: visited[v] = True for neighbor in adj[v]: if not visited[neighbor]: stack.append(neighbor) results = [] for i in range(T): N, M = test_cases[i][0] edges = test_cases[i][1] adj = [[] for _ in range(N)] for u, v in edges: adj[u - 1].append(v - 1) adj[v - 1].append(u - 1) visited = [False] * N num_components = 0 for j in range(N): if not visited[j]: dfs(j, visited, adj) num_components += 1 results.append(num_components - 1) return results"},{"question":"def can_permute_palindrome(S: str) -> str: Determines if any permutation of the string S can be a palindrome. >>> can_permute_palindrome(\\"civic\\") \\"Yes\\" >>> can_permute_palindrome(\\"ivicc\\") \\"Yes\\" >>> can_permute_palindrome(\\"hello\\") \\"No\\" >>> can_permute_palindrome(\\"aabb\\") \\"Yes\\"","solution":"def can_permute_palindrome(S): Determines if any permutation of the string S can be a palindrome. from collections import Counter char_count = Counter(S) odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For a string to be able to form a palindrome: # 1. If the string length is even, no characters should have an odd count. # 2. If the string length is odd, only one character should have an odd count. if odd_count > 1: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List, Tuple def min_transformation_cost(t: int, cases: List[Tuple[str, str]]) -> List[int]: Calculate the minimum cost of transforming s1 into s2 by rearranging and replacing characters. >>> min_transformation_cost(3, [(\\"abc\\", \\"def\\"), (\\"aabbcc\\", \\"ddeeff\\"), (\\"aaa\\", \\"bbb\\")]) [3, 6, 3] >>> min_transformation_cost(2, [(\\"a\\", \\"a\\"), (\\"a\\", \\"b\\")]) [0, 1] >>> min_transformation_cost(4, [(\\"abc\\", \\"abd\\"), (\\"bb\\", \\"bb\\"), (\\"xyz\\", \\"yxz\\"), (\\"abcd\\", \\"abcf\\")]) [1, 0, 0, 1] >>> min_transformation_cost(1, [(\\"abcd\\", \\"ab\\")]) [-1] >>> min_transformation_cost(1, [(\\"abcd\\", \\"dbca\\")]) [0]","solution":"def min_transformation_cost(t, cases): results = [] for s1, s2 in cases: if len(s1) != len(s2): results.append(-1) continue from collections import Counter count_s1 = Counter(s1) count_s2 = Counter(s2) total_cost = 0 for char in count_s1: if char in count_s2: total_cost += abs(count_s1[char] - count_s2[char]) else: total_cost += count_s1[char] for char in count_s2: if char not in count_s1: total_cost += count_s2[char] total_cost //= 2 # Fix the double counting of changes results.append(total_cost) return results"},{"question":"def assign_objects(m: int, k: int, objects: List[int], skills: List[int]) -> str: Assign each object to a friend such that no friend juggles an object with a difficulty higher than their skill level. If it is possible to assign all objects to friends, return \\"Possible\\" followed by m space-separated integers, where the j-th integer is the index of the friend assigned to the j-th object. If it is not possible to assign all objects, return \\"Impossible\\". Examples: >>> assign_objects(3, 3, [4, 5, 2], [5, 5, 3]) 'Possiblen2 1 3' >>> assign_objects(4, 2, [8, 7, 6, 5], [6, 6]) 'Impossible'","solution":"def assign_objects(m, k, objects, skills): # Sort the objects with their original indices for final output indexed_objects = sorted((difficulty, idx) for idx, difficulty in enumerate(objects)) # Create tuples holding the skill and the original index, and sort them indexed_skills = sorted((skill, idx + 1) for idx, skill in enumerate(skills)) j = 0 assignment = [-1] * m for difficulty, original_index in indexed_objects: while j < k and indexed_skills[j][0] < difficulty: j += 1 if j == k: return \\"Impossible\\" assignment[original_index] = indexed_skills[j][1] j += 1 return \\"Possiblen\\" + ' '.join(map(str, assignment)) # Example usage: # print(assign_objects(3, 3, [4, 5, 2], [5, 5, 3])) -> \\"Possiblen2 1 3\\" # print(assign_objects(4, 2, [8, 7, 6, 5], [6, 6])) -> \\"Impossible\\""},{"question":"def count_visible_buildings(heights: List[int]) -> int: Counts the number of distinct buildings that are visible from the left side. Parameters: heights (list): List of integers representing the heights of buildings. Returns: int: Number of distinct visible buildings. Example: >>> count_visible_buildings([3, 7, 8, 3, 6, 1]) 3 >>> count_visible_buildings([4, 3, 2, 3, 5]) 2 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5","solution":"def count_visible_buildings(heights): Counts the number of distinct buildings that are visible from the left side. Parameters: heights (list): List of integers representing the heights of buildings. Returns: int: Number of distinct visible buildings. if not heights: return 0 max_height = 0 visible_count = 0 for height in heights: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def update_tree(n, p, m, operations): Perform operations on a Balanced Binary Search Tree (BBST) represented by a parent array. Args: n (int): Number of nodes in the initial tree. p (list of int): Parent array where p[i] represents the parent of i-th node. m (int): Number of operations to be performed. operations (list of str): List of operations to be performed on the tree. Returns: list of int: The parent array of the BBST after all operations, or 'Invalid operation' if any invalid operations are attempted. Operations: - \\"INSERT x y\\": Insert node y as a child of node x. - \\"DELETE x\\": Delete node x. - \\"PRINT\\": Print the parent array currently representing the BBST. >>> update_tree(6, [-1, 0, 0, 1, 1, 2], 4, [\\"INSERT 2 6\\", \\"DELETE 4\\", \\"INSERT 2 7\\", \\"PRINT\\"]) [-1, 0, 0, 1, -1, 2, 2, 2] >>> update_tree(6, [-1, 0, 0, 1, 1, 2], 1, [\\"INSERT 10 7\\"]) 'Invalid operation' >>> update_tree(6, [-1, 0, 0, 1, 1, 2], 1, [\\"DELETE 2\\"]) 'Invalid operation' >>> update_tree(6, [-1, 0, 0, 1, 1, 2], 3, [\\"DELETE 4\\", \\"INSERT 1 6\\", \\"PRINT\\"]) [-1, 0, 0, 1, -1, 2, 1] >>> update_tree(3, [-1, 0, 1], 0, []) [-1, 0, 1]","solution":"def update_tree(n, p, m, operations): def insert_node(parent, child): if parent >= n or parent < 0: return \\"Invalid operation\\" p.append(parent) return \\"Success\\" def delete_node(i): if i < 0 or i >= n: return \\"Invalid operation\\" if len([x for x in p if x == i]) > 0: # Check if it has children return \\"Invalid operation\\" p[i] = -1 return \\"Success\\" for operation in operations: if operation.startswith(\\"INSERT\\"): _, x, y = operation.split() x, y = int(x), int(y) result = insert_node(x, y) if result == \\"Invalid operation\\": return \\"Invalid operation\\" elif operation.startswith(\\"DELETE\\"): _, x = operation.split() x = int(x) result = delete_node(x) if result == \\"Invalid operation\\": return \\"Invalid operation\\" elif operation == \\"PRINT\\": print(p) else: return \\"Invalid operation\\" return p"},{"question":"from typing import List, Tuple def find_unique_pairs(arr: List[int], target: int) -> List[Tuple[int, int]]: This function finds all unique pairs of integers in the list that add up to a given target sum. Each pair is sorted in non-decreasing order, and the list of pairs is sorted in lexicographical order. >>> find_unique_pairs([1, 2, 3, 4], 5) [(1, 4), (2, 3)] >>> find_unique_pairs([1, 2, 3], 10) [] >>> find_unique_pairs([2, 2, 2, 2], 4) [(2, 2)] >>> find_unique_pairs([10000, 9999, 1, 2], 10001) [(1, 10000), (2, 9999)] def format_output(pairs: List[Tuple[int, int]]) -> str: Formats the output to match the desired format. >>> format_output([(1, 4), (2, 3)]) '2n1 4n2 3n' >>> format_output([]) '0n' from solution import find_unique_pairs, format_output def test_single_pair(): arr = [1, 2, 3, 4] target = 5 pairs = find_unique_pairs(arr, target) output = format_output(pairs) assert output.strip() == \\"2n1 4n2 3\\" def test_multiple_pairs(): arr = [1, 2, 3, 4, 3, 2] target = 5 pairs = find_unique_pairs(arr, target) output = format_output(pairs) assert output.strip() == \\"2n1 4n2 3\\" def test_no_pairs(): arr = [1, 2, 3] target = 10 pairs = find_unique_pairs(arr, target) output = format_output(pairs) assert output.strip() == \\"0\\" def test_with_duplicate_numbers(): arr = [2, 2, 2, 2] target = 4 pairs = find_unique_pairs(arr, target) output = format_output(pairs) assert output.strip() == \\"1n2 2\\" def test_with_large_numbers(): arr = [10000, 9999, 1, 2] target = 10001 pairs = find_unique_pairs(arr, target) output = format_output(pairs) assert output.strip() == \\"2n1 10000n2 9999\\"","solution":"def find_unique_pairs(arr, target): This function finds all unique pairs of integers in the list that add up to a given target sum. :param arr: List of integers :param target: target sum :return: List of unique pairs unique_pairs = set() seen = set() for number in arr: complement = target - number if complement in seen: pair = tuple(sorted((number, complement))) unique_pairs.add(pair) seen.add(number) result = sorted(list(unique_pairs)) return result def format_output(pairs): Formats the output to match the desired format. :param pairs: List of pairs :return: Formatted string output = f\\"{len(pairs)}n\\" for pair in pairs: output += f\\"{pair[0]} {pair[1]}n\\" return output"},{"question":"def min_steps_to_meet(X1: int, Y1: int, X2: int, Y2: int) -> int: Returns the minimum number of steps required for two robots to meet at any grid cell. If it is not possible for them to meet, returns -1. >>> min_steps_to_meet(1, 2, 4, 6) 7 >>> min_steps_to_meet(0, 0, 0, 0) 0 >>> min_steps_to_meet(-1, -2, 3, 4) 10 >>> min_steps_to_meet(1, 1, 4, 5) 7 >>> min_steps_to_meet(1000000000, 1000000000, 999999999, 999999999) 2 >>> min_steps_to_meet(-1000000000, -1000000000, -999999999, -999999999) 2 >>> min_steps_to_meet(-100, 200, 50, -150) 500","solution":"def min_steps_to_meet(X1, Y1, X2, Y2): Returns the minimum number of steps required for two robots to meet at any grid cell. If it is not possible for them to meet, returns -1. # Calculate the Manhattan distance between the two points distance = abs(X1 - X2) + abs(Y1 - Y2) # The robots can always meet because they can move in four directions return distance"},{"question":"def determine_winner(N: int) -> str: Determines if Alice can always win the coin game given N coins. Args: N (int): The initial number of coins. Returns: str: \\"Alice\\" if Alice can always win, otherwise \\"Bob\\". >>> determine_winner(4) \\"Bob\\" >>> determine_winner(7) \\"Alice\\" >>> determine_winner(2) \\"Bob\\" >>> determine_winner(1) \\"Alice\\" >>> determine_winner(1000000000000) \\"Bob\\" >>> determine_winner(999999999999) \\"Alice\\" >>> determine_winner(3) \\"Alice\\" >>> determine_winner(10) \\"Bob\\" >>> determine_winner(15) \\"Alice\\" >>> determine_winner(20) \\"Bob\\"","solution":"def determine_winner(N): Determines if Alice can always win the coin game given N coins. Args: N (int): The initial number of coins. Returns: str: \\"Alice\\" if Alice can always win, otherwise \\"Bob\\". if N % 2 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def is_valid_parentheses(sequence: str) -> str: Determines if the given sequence of parentheses is valid. >>> is_valid_parentheses(\\"()\\") \\"YES\\" >>> is_valid_parentheses(\\"()()\\") \\"YES\\" >>> is_valid_parentheses(\\"(())\\") \\"YES\\" >>> is_valid_parentheses(\\"(()\\") \\"NO\\" >>> is_valid_parentheses(\\")(\\") \\"NO\\" def check_multiple_sequences(sequences: List[str]) -> List[str]: Takes a list of sequences and returns a list of results for each sequence. >>> check_multiple_sequences([\\"()()()\\", \\"(())\\", \\"(()(\\", \\")()(\\"]) [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] >>> check_multiple_sequences([\\")\\", \\"(\\"]) [\\"NO\\", \\"NO\\"]","solution":"def is_valid_parentheses(sequence): Determines if the given sequence of parentheses is valid. stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if not stack: return \\"NO\\" stack.pop() return \\"YES\\" if not stack else \\"NO\\" def check_multiple_sequences(sequences): Takes a list of sequences and returns a list of results for each sequence. return [is_valid_parentheses(seq) for seq in sequences]"},{"question":"def count_treasure_parts(N: int, M: int, K: int, coordinates: List[Tuple[int, int]]) -> int: Determines the total number of parts of treasure hidden on the island. Inputs: - N: int, the number of rows in the grid - M: int, the number of columns in the grid - K: int, the number of coordinates provided - coordinates: list of tuples, each tuple contains two integers (x, y) representing the row and column of a cell Returns: - int, the total number of parts of the treasure >>> count_treasure_parts(5, 5, 0, []) 0 >>> count_treasure_parts(5, 5, 1, [(2, 3)]) 1 >>> count_treasure_parts(5, 5, 4, [(1, 2), (2, 3), (4, 4), (5, 1)]) 4 >>> count_treasure_parts(3, 3, 3, [(1, 1), (2, 2), (3, 3)]) 3 >>> count_treasure_parts(5, 5, 5, [(1, 1), (1, 5), (5, 1), (5, 5), (3, 3)]) 5","solution":"def count_treasure_parts(N, M, K, coordinates): Returns the total number of parts of the treasure hidden on the island. Inputs: - N: int, the number of rows in the grid - M: int, the number of columns in the grid - K: int, the number of coordinates provided - coordinates: list of tuples, each tuple contains two integers (x, y) representing the row and column of a cell Returns: - int, the total number of parts of the treasure # The number of parts of the treasure is just the number of given coordinates return K"},{"question":"def isValid(sequence: str) -> str: Returns 'Valid' if the bracket sequence is valid, otherwise 'Invalid'. >>> isValid(\\"()\\") \\"Valid\\" >>> isValid(\\"()[]{}\\") \\"Valid\\" >>> isValid(\\"({[]})\\") \\"Valid\\" >>> isValid(\\"(]\\") \\"Invalid\\" >>> isValid(\\"([)]\\") \\"Invalid\\" >>> isValid(\\"{[()]}\\") \\"Valid\\" >>> isValid(\\"{[(])}\\") \\"Invalid\\" def validate_sequences(sequences: List[str]) -> List[str]: Takes a list of bracket sequences and returns a list with \\"Valid\\" or \\"Invalid\\" for each sequence. >>> validate_sequences([\\"()\\", \\"()[]{}\\", \\"({[]})\\", \\"(]\\", \\"([)]\\", \\"end\\"]) [\\"Valid\\", \\"Valid\\", \\"Valid\\", \\"Invalid\\", \\"Invalid\\"] >>> validate_sequences([\\"(((((\\", \\"}}}}}}\\", \\"{[()]}\\", \\"{[(])}\\", \\"end\\"]) [\\"Invalid\\", \\"Invalid\\", \\"Valid\\", \\"Invalid\\"] >>> validate_sequences([\\"\\", \\"end\\"]) [\\"Valid\\"] >>> validate_sequences([\\"()\\", \\"(\\", \\"end\\"]) [\\"Valid\\", \\"Invalid\\"] >>> validate_sequences([\\"(([]))\\", \\"([{}])\\", \\"end\\"]) [\\"Valid\\", \\"Valid\\"]","solution":"def isValid(sequence): Returns 'Valid' if the bracket sequence is valid, otherwise 'Invalid'. stack = [] close_map = {')': '(', '}': '{', ']': '['} for char in sequence: if char in close_map.values(): stack.append(char) elif char in close_map.keys(): if stack == [] or close_map[char] != stack.pop(): return \\"Invalid\\" else: return \\"Invalid\\" return \\"Valid\\" if stack == [] else \\"Invalid\\" def validate_sequences(sequences): Takes a list of bracket sequences and returns a list with \\"Valid\\" or \\"Invalid\\" for each sequence. results = [] for sequence in sequences: if sequence == \\"end\\": break results.append(isValid(sequence)) return results"},{"question":"def are_anagrams(word1: str, word2: str) -> bool: Helper function to check if two words are anagrams. >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"evil\\", \\"vile\\") True >>> are_anagrams(\\"apple\\", \\"pale\\") False pass def check_anagrams(T: int, test_cases: List[Tuple[str, int, List[str]]]) -> List[str]: Function to check if the word W can be rearranged to form any word in the collection. >>> check_anagrams(2, [(\\"listen\\", 3, [\\"enlist\\", \\"silent\\", \\"apple\\"]), (\\"evil\\", 3, [\\"live\\", \\"veil\\", \\"pan\\"])]) [\\"YES\\", \\"YES\\"] >>> check_anagrams(1, [(\\"cat\\", 2, [\\"tac\\", \\"act\\"])]) [\\"YES\\"] >>> check_anagrams(1, [(\\"hello\\", 2, [\\"world\\", \\"python\\"])]) [\\"NO\\"] >>> check_anagrams(1, [(\\"anagram\\", 3, [\\"nagaram\\", \\"anagrams\\", \\"notanagram\\"])]) [\\"YES\\"] >>> check_anagrams(1, [(\\"rat\\", 1, [\\"car\\"])]) [\\"NO\\"] pass from typing import List, Tuple def test_are_anagrams(): assert are_anagrams(\\"listen\\", \\"silent\\") == True assert are_anagrams(\\"evil\\", \\"vile\\") == True assert are_anagrams(\\"apple\\", \\"pale\\") == False def test_check_anagrams(): assert check_anagrams(2, [ (\\"listen\\", 3, [\\"enlist\\", \\"silent\\", \\"apple\\"]), (\\"evil\\", 3, [\\"live\\", \\"veil\\", \\"pan\\"]) ]) == [\\"YES\\", \\"YES\\"] assert check_anagrams(1, [ (\\"cat\\", 2, [\\"tac\\", \\"act\\"]) ]) == [\\"YES\\"] assert check_anagrams(1, [ (\\"hello\\", 2, [\\"world\\", \\"python\\"]) ]) == [\\"NO\\"] assert check_anagrams(1, [ (\\"anagram\\", 3, [\\"nagaram\\", \\"anagrams\\", \\"notanagram\\"]) ]) == [\\"YES\\"] assert check_anagrams(1, [ (\\"rat\\", 1, [\\"car\\"]) ]) == [\\"NO\\"]","solution":"def are_anagrams(word1, word2): Helper function to check if two words are anagrams. return sorted(word1) == sorted(word2) def check_anagrams(T, test_cases): results = [] for i in range(T): W = test_cases[i][0] N = test_cases[i][1] words_collection = test_cases[i][2] found = any(are_anagrams(W, word) for word in words_collection) if found: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_changes_to_make_beautiful(s: str) -> int: Determine the minimum number of changes needed to make the string beautiful. A string s is called beautiful if it does not contain the sequence \\"010\\" as a substring. Args: s (str): a string consisting of 0s and 1s. Returns: int: minimum number of changes required to make the string beautiful. Examples: >>> min_changes_to_make_beautiful(\\"0101010\\") 2 >>> min_changes_to_make_beautiful(\\"111000\\") 0 from solution import min_changes_to_make_beautiful def test_example1(): assert min_changes_to_make_beautiful(\\"0101010\\") == 2 def test_example2(): assert min_changes_to_make_beautiful(\\"111000\\") == 0 def test_no_change_needed(): assert min_changes_to_make_beautiful(\\"1111111\\") == 0 def test_single_change_needed(): assert min_changes_to_make_beautiful(\\"010\\") == 1 def test_with_multiple_sequences(): assert min_changes_to_make_beautiful(\\"010010010\\") == 3 def test_with_no_sequences(): assert min_changes_to_make_beautiful(\\"110011\\") == 0 def test_with_full_sequences(): assert min_changes_to_make_beautiful(\\"010010\\") == 2 def test_edge_case_min_length(): assert min_changes_to_make_beautiful(\\"0\\") == 0 assert min_changes_to_make_beautiful(\\"1\\") == 0 def test_edge_case_length_three(): assert min_changes_to_make_beautiful(\\"000\\") == 0 assert min_changes_to_make_beautiful(\\"111\\") == 0 assert min_changes_to_make_beautiful(\\"010\\") == 1","solution":"def min_changes_to_make_beautiful(s): Returns the minimum number of changes needed to make the string beautiful. count = 0 i = 0 while i <= len(s) - 3: if s[i:i+3] == \\"010\\": count += 1 i += 3 # Skip to the next character after the \\"010\\" else: i += 1 return count"},{"question":"def max_subarray_sum(arr: List[int]) -> int: Finds the maximum sum of a contiguous subarray in the given array using Kadane's Algorithm. Parameters: arr (list of int): List of integers representing the array. Returns: int: The maximum sum of any contiguous subarray. Examples: >>> max_subarray_sum([1, -3, 2, 1, -1]) 3 >>> max_subarray_sum([-1, -2, -3, -4]) -1 def test_max_subarray_sum_positive_numbers(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_max_subarray_sum_negative_numbers(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_max_subarray_sum_mixed_numbers(): assert max_subarray_sum([3, -2, 5, -1]) == 6 assert max_subarray_sum([1, -3, 2, 1, -1]) == 3 def test_max_subarray_sum_single_element(): assert max_subarray_sum([10]) == 10 assert max_subarray_sum([-10]) == -10 def test_max_subarray_sum_empty_array(): try: max_subarray_sum([]) except IndexError: assert True # Expecting an IndexError for empty list else: assert False # If no error is raised, something is wrong","solution":"def max_subarray_sum(arr): Finds the maximum sum of a contiguous subarray in the given array using Kadane's Algorithm. Parameters: arr (list of int): List of integers representing the array. Returns: int: The maximum sum of any contiguous subarray. max_ending_here = max_so_far = arr[0] for x in arr[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def minimum_travel_cost(n: int, m: int, happiness: List[int], roads: List[Tuple[int, int, int]]) -> int: Determine the minimum travel cost for the traveler to visit all the cities exactly once. Args: n (int): Number of cities. m (int): Number of roads. happiness (List[int]): A list of happiness levels for each city. roads (List[Tuple[int, int, int]]): A list of roads where each road is represented by a tuple (u, v, w) indicating a road between cities u and v with cost w. Returns: int: The minimum travel cost. Examples: >>> n, m = 3, 3 >>> happiness = [5, 10, 15] >>> roads = [(1, 2, 3), (2, 3, 4), (1, 3, 2)] >>> minimum_travel_cost(n, m, happiness, roads) == 5 >>> n, m = 4, 4 >>> happiness = [8, 2, 3, 5] >>> roads = [(1, 2, 1), (1, 3, 2), (2, 4, 3), (3, 4, 4)] >>> minimum_travel_cost(n, m, happiness, roads) == 6","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def kruskal(n, edges): edges.sort(key=lambda x: x[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) result = [] i = 0 e = 0 while e < n - 1: u, v, w = edges[i] i = i + 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append((u, v, w)) union(parent, rank, x, y) final_cost = sum([w for _, _, w in result]) return final_cost def minimum_travel_cost(n, m, happiness, roads): edges = [] for road in roads: u, v, w = road edges.append((u - 1, v - 1, w)) # converting to 0-based index return kruskal(n, edges)"},{"question":"def longest_common_prefix(strings): This function takes in a list of strings and returns the longest common prefix among them. If there is no common prefix, it returns an empty string. >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"fluent\\"]) 'fl' >>> longest_common_prefix([\\"dog\\", \\"racecar\\", \\"car\\"]) '' >>> longest_common_prefix([\\"interspecies\\", \\"intersection\\"]) 'inters' >>> longest_common_prefix([\\"same\\", \\"same\\", \\"same\\"]) 'same' >>> longest_common_prefix([\\"single\\"]) 'single' >>> longest_common_prefix([]) '' >>> longest_common_prefix([\\"a\\", \\"a\\", \\"a\\"]) 'a' >>> longest_common_prefix([\\"a\\", \\"b\\", \\"c\\"]) '' >>> longest_common_prefix([\\"interview\\", \\"intermediate\\", \\"internal\\"]) 'inter' >>> longest_common_prefix([\\"dog\\", \\"\\", \\"car\\"]) ''","solution":"def longest_common_prefix(strings): This function takes in a list of strings and returns the longest common prefix among them. If there is no common prefix, it returns an empty string. if not strings: return \\"\\" # Initialize the prefix to the first string prefix = strings[0] # Compare the prefix with each string for s in strings[1:]: # Reduce the prefix length until it matches the beginning of s while s[:len(prefix)] != prefix and prefix: prefix = prefix[:len(prefix)-1] # If the prefix becomes empty, return immediately if not prefix: return \\"\\" return prefix"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of a non-negative integer. Parameters: n (int): A non-negative integer. Returns: int: The sum of the digits of the integer n. >>> sum_of_digits(1234) 10 >>> sum_of_digits(98765) 35 >>> sum_of_digits(0) 0 >>> sum_of_digits(2147483647) 46 >>> sum_of_digits(1234567890) 45","solution":"def sum_of_digits(n): Returns the sum of the digits of a non-negative integer. Parameters: n (int): A non-negative integer. Returns: int: The sum of the digits of the integer n. if n < 0: raise ValueError(\\"The input should be a non-negative integer\\") return sum(int(digit) for digit in str(n))"},{"question":"def generate_restocking_list(n: int, c: int, k: int, priorities: List[int], products: List[Tuple[int, int, int]]) -> List[int]: Generates a restocking list based on category priorities and stock quantities. :param n: Number of products :param c: Number of categories :param k: Maximum number of products to be restocked :param priorities: List indicating the priority level of each category :param products: List of tuples where each tuple contains (product ID, category ID, quantity in stock) :return: List of product IDs in the order they should be restocked >>> generate_restocking_list(10, 3, 5, [5, 1, 3], [(1, 1, 2), (2, 2, 1), (3, 3, 2), (4, 1, 4), (5, 1, 6), (6, 2, 2), (7, 3, 5), (8, 1, 1), (9, 2, 3), (10, 3, 4)]) [8, 1, 4, 5, 3] >>> generate_restocking_list(4, 2, 5, [3, 2], [(1, 1, 2), (2, 2, 1), (3, 1, 3), (4, 2, 4)]) [1, 3, 2, 4] >>> generate_restocking_list(5, 2, 3, [1, 1], [(1, 1, 5), (2, 1, 3), (3, 2, 7), (4, 2, 2), (5, 1, 4)]) [2, 5, 1] >>> generate_restocking_list(3, 1, 10, [5], [(1, 1, 2), (2, 1, 1), (3, 1, 3)]) [2, 1, 3] >>> generate_restocking_list(1, 1, 1, [1], [(1, 1, 10)]) [1] pass","solution":"def generate_restocking_list(n, c, k, priorities, products): Generates a restocking list based on category priorities and stock quantities. :param n: Number of products :param c: Number of categories :param k: Maximum number of products to be restocked :param priorities: List indicating the priority level of each category :param products: List of tuples where each tuple contains (product ID, category ID, quantity in stock) :return: List of product IDs in the order they should be restocked from heapq import heappop, heappush # Priority dictionary {category_id: priority} priority_dict = {i + 1: priorities[i] for i in range(c)} # Categorize products by category_id categorized_products = {i + 1: [] for i in range(c)} for pid, cid, qty in products: categorized_products[cid].append((qty, pid)) # Prepare a list to heapify category priorities category_heap = [] for cid, priority in priority_dict.items(): heappush(category_heap, (-priority, cid)) restocking_list = [] while category_heap and len(restocking_list) < k: priority, cid = heappop(category_heap) product_heap = categorized_products[cid] # Use a minheap based on quantity for products in this category product_heap.sort() while product_heap and len(restocking_list) < k: qty, pid = heappop(product_heap) restocking_list.append(pid) return restocking_list"},{"question":"from typing import List, Tuple def remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: This function detects and removes any conflicting events in the user's schedule, returning the non-conflicting schedule as a list of events. >>> remove_conflicts([(60, 120), (180, 240), (90, 150), (270, 330)]) [(60, 120), (180, 240), (270, 330)] # Unit tests def test_no_conflicts(): assert remove_conflicts([(60, 120), (180, 240), (300, 360)]) == [(60, 120), (180, 240), (300, 360)] def test_one_conflict(): assert remove_conflicts([(60, 120), (90, 150), (180, 240)]) == [(60, 120), (180, 240)] def test_multiple_conflicts(): assert remove_conflicts([(60, 120), (90, 150), (115, 175), (300, 360)]) == [(60, 120), (300, 360)] def test_all_conflicting(): assert remove_conflicts([(60, 120), (60, 120), (60, 120)]) == [(60, 120)] def test_edge_case_single_event(): assert remove_conflicts([(60, 120)]) == [(60, 120)] def test_edge_case_zero_min_event(): assert remove_conflicts([(0, 0), (0, 30), (10, 20)]) == [(0, 0), (10, 20)] def test_events_touching_each_other(): assert remove_conflicts([(60, 120), (120, 180), (180, 240)]) == [(60, 120), (120, 180), (180, 240)]","solution":"from typing import List, Tuple def remove_conflicts(events: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Sort events by their end times (second item in the tuple) events.sort(key=lambda x: x[1]) # Initialize the list of non-conflicting events with the first event non_conflicting = [] # Initialize the end time of the last added event to -1 last_end_time = -1 for event in events: start, end = event # If the start time of the current event is after the end time of the last added event if start >= last_end_time: # Add the current event to the non-conflicting schedule non_conflicting.append(event) # Update the end time of the last added event last_end_time = end return non_conflicting"},{"question":"def minAddToMakeValid(s: str) -> int: Given a string of parentheses, find the minimum number of parentheses to be added to make the string valid. A string of parentheses is considered valid if every opening parenthesis has a corresponding closing parenthesis and the pairs of parentheses are properly nested. >>> minAddToMakeValid(\\"())\\") 1 >>> minAddToMakeValid(\\"(((\\") 3 >>> minAddToMakeValid(\\")))\\") 3 >>> minAddToMakeValid(\\"()\\") 0 >>> minAddToMakeValid(\\"((())())\\") 0 >>> minAddToMakeValid(\\"((()()))(()\\") 1 >>> minAddToMakeValid(\\"\\") 0 >>> minAddToMakeValid(\\"((((()))))\\") 0","solution":"def minAddToMakeValid(s: str) -> int: open_count = 0 add_count = 0 for char in s: if char == '(': open_count += 1 else: if open_count > 0: open_count -= 1 else: add_count += 1 return add_count + open_count"},{"question":"def count_subarrays_with_sum(arr, target): Returns the number of subarrays that have a sum equal to the target value. >>> count_subarrays_with_sum([1, 1, 1], 2) 2 >>> count_subarrays_with_sum([1, 2, 3, -2, 2], 3) 4 def find_subarray_counts(test_cases): Given a list of test cases, return the respective count of subarrays that sum to the target value for each test case. >>> test_cases = [ ... (3, [1, 1, 1], 2), ... (5, [1, 2, 3, -2, 2], 3), ... ] >>> find_subarray_counts(test_cases) [2, 4]","solution":"def count_subarrays_with_sum(arr, target): Returns the number of subarrays with a sum equal to the target value. count = 0 current_sum = 0 prefix_sum_counts = {0: 1} for num in arr: current_sum += num if (current_sum - target) in prefix_sum_counts: count += prefix_sum_counts[current_sum - target] if current_sum in prefix_sum_counts: prefix_sum_counts[current_sum] += 1 else: prefix_sum_counts[current_sum] = 1 return count def find_subarray_counts(test_cases): results = [] for case in test_cases: n, arr, target = case result = count_subarrays_with_sum(arr, target) results.append(result) return results"},{"question":"def is_subsequence(s: str, t: str) -> bool: Determines if string t is a subsequence of string s. >>> is_subsequence(\\"abcde\\", \\"ace\\") True >>> is_subsequence(\\"abcde\\", \\"aec\\") False","solution":"def is_subsequence(s, t): Determines if string t is a subsequence of string s. Parameters: s (str): The original string. t (str): The string to check as a subsequence of s. Returns: bool: True if t is a subsequence of s, False otherwise. t_index = 0 t_len = len(t) if t_len == 0: return True for char in s: if char == t[t_index]: t_index += 1 if t_index == t_len: return True return t_index == t_len"},{"question":"def max_flower_beds(N: int, A: int, dimensions: List[Tuple[int, int]]) -> int: Returns the maximum number of flower beds that can fit within the given total area. Args: N : int : number of different types of flower beds A : int : total available area of the park dimensions : list of tuples : each tuple contains two integers representing the length and width of a flower bed type. Returns: int : the maximum number of flower beds that can fit within the given total area. >>> max_flower_beds(3, 100, [(4, 2), (5, 6), (2, 2)]) # 25 >>> max_flower_beds(2, 500, [(15, 10), (30, 20)]) # 3 >>> max_flower_beds(1, 100, [(10, 10)]) # 1 # Function that reads input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = int(data[1]) dimensions = [(int(data[i]), int(data[i+1])) for i in range(2, len(data), 2)] print(max_flower_beds(N, A, dimensions)) if __name__ == \\"__main__\\": main()","solution":"def max_flower_beds(N, A, dimensions): Returns the maximum number of flower beds that can fit within the given total area. Args: N : int : number of different types of flower beds A : int : total available area of the park dimensions : list of tuples : each tuple contains two integers representing the length and width of a flower bed type. Returns: int : the maximum number of flower beds that can fit within the given total area. max_beds = 0 for length, width in dimensions: area = length * width if area <= A: max_beds = max(max_beds, A // area) return max_beds # Function that reads input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = int(data[1]) dimensions = [(int(data[i]), int(data[i+1])) for i in range(2, len(data), 2)] print(max_flower_beds(N, A, dimensions)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List def maxViewableBuildings(heights: List[int], L: int) -> int: You are given an array of integers representing the heights of buildings in a row, and an integer \`L\` representing the maximum number of buildings you can view from any position if you are standing on top of a building. From a given building position \`i\`, you can view another building if it is within the range \`[i-L, i+L]\` and is less than or equal to the height of the current building. Args: heights : List[int] : An array of integers representing the heights of the buildings. L : int : The maximum number of buildings you can view to the left and right of a given building. Returns: int : Maximum number of buildings that can be viewed from any building including itself. Examples: >>> maxViewableBuildings([3, 1, 4, 1, 5, 9, 2, 6, 5, 3], 2) 5 >>> maxViewableBuildings([1], 1) 1 pass def test_single_building(): assert maxViewableBuildings([1], 1) == 1 def test_all_same_height(): heights = [3, 3, 3, 3, 3] assert maxViewableBuildings(heights, 2) == 5 def test_all_different_height(): heights = [1, 2, 3, 4, 5] assert maxViewableBuildings(heights, 3) == 4 def test_general_case(): heights = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3] assert maxViewableBuildings(heights, 2) == 5 def test_large_L(): heights = [2, 1, 2, 1, 2] assert maxViewableBuildings(heights, 10) == 5 def test_edge_case_with_highest_building(): heights = [1, 2, 3, 4, 5] assert maxViewableBuildings(heights, 1) == 2 def test_varied_heights(): heights = [5, 9, 8, 7, 10, 6, 15] assert maxViewableBuildings(heights, 2) == 4 def test_equal_height_small_L(): heights = [1, 1, 1, 1, 1, 1] assert maxViewableBuildings(heights, 1) == 3","solution":"from typing import List def maxViewableBuildings(heights: List[int], L: int) -> int: n = len(heights) max_count = 0 for i in range(n): count = 1 # start by including the current building itself for j in range(1, L+1): if i - j >= 0 and heights[i - j] <= heights[i]: count += 1 if i + j < n and heights[i + j] <= heights[i]: count += 1 max_count = max(max_count, count) return max_count"},{"question":"def is_prime(n: int) -> bool: Check if a number is prime. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True pass def longest_prime_subsequence_sum(sequence: List[int]) -> int: Returns the sum of the longest contiguous subsequence consisting solely of prime numbers. >>> longest_prime_subsequence_sum([6, 2, 3, 4, 5, 7, 11, 13]) 36 >>> longest_prime_subsequence_sum([1, 4, 6, 8, 10, 12]) 0 >>> longest_prime_subsequence_sum([2, 3, 5, 6, 7, 11, 13, 17, 1, 19]) 48 pass import pytest def test_longest_prime_subsequence_sum(): assert longest_prime_subsequence_sum([6, 2, 3, 4, 5, 7, 11, 13]) == 36 assert longest_prime_subsequence_sum([1, 4, 6, 8, 10, 12]) == 0 assert longest_prime_subsequence_sum([2, 3, 5, 6, 7, 11, 13, 17, 1, 19]) == 48 assert longest_prime_subsequence_sum([2, 3, 5, 7, 11]) == 28 assert longest_prime_subsequence_sum([]) == 0 assert longest_prime_subsequence_sum([4, 6, 8, 10, 12]) == 0 assert longest_prime_subsequence_sum([3, 5, 7, 11, 0, 2, 3, 5]) == 26 def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(6) == False assert is_prime(17) == True assert is_prime(19) == True assert is_prime(22) == False if __name__ == \\"__main__\\": pytest.main()","solution":"import math def is_prime(n): Check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def longest_prime_subsequence_sum(sequence): Returns the sum of the longest contiguous subsequence consisting solely of prime numbers. max_sum = 0 current_sum = 0 max_len = 0 current_len = 0 for num in sequence: if is_prime(num): current_sum += num current_len += 1 else: if current_len > max_len: max_len = current_len max_sum = current_sum elif current_len == max_len: max_sum = max(max_sum, current_sum) current_sum = 0 current_len = 0 # Check the last subsequence if current_len > max_len: max_sum = current_sum elif current_len == max_len: max_sum = max(max_sum, current_sum) return max_sum # Read input def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) sequence = list(map(int, data[1:])) result = longest_prime_subsequence_sum(sequence) print(result) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def find_mode(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a set of queries, each with two integers \`l\` and \`r\`, determine the mode of the subarray from index \`l\` to \`r\` (both inclusive). The mode of a set of values is the value that appears most frequently. If multiple values are modes, return the smallest value among them. Args: arr: List of integers. queries: List of tuples, where each tuple contains two integers \`l\` and \`r\`. Returns: List of integers representing the mode for each query. >>> find_mode([1, 2, 2, 3, 3], [(1, 3)]) [2] >>> find_mode([1, 2, 2, 3, 3], [(1, 3), (2, 4), (1, 5)]) [2, 2, 2] >>> find_mode([1] * 10**5, [(1, 100000)]) [1] >>> find_mode([2, 2, 2, 2, 2], [(1, 5)]) [2] >>> find_mode([1, 2, 2, 3, 3], [(1, 5)]) [2] >>> find_mode([1, 2, 4, 2, 3, 3, 4], [(1, 7)]) [2] >>> find_mode([1, 1, 2, 2, 3, 3], [(1, 2), (3, 4), (5, 6)]) [1, 2, 3]","solution":"from collections import Counter def find_mode(arr, queries): results = [] for l, r in queries: subarray = arr[l-1:r] freq = Counter(subarray) max_freq = max(freq.values()) mode = min([num for num in freq if freq[num] == max_freq]) results.append(mode) return results"},{"question":"def max_evaluation(S: str) -> int: Given a string S which contains only digits and the characters '+' and '*', determine the maximum possible value of the expression by adding parentheses. Operator precedence must be considered where multiplication '*' has higher precedence than addition '+'. You cannot add additional digits or operators. >>> max_evaluation(\\"3+2*2\\") 7 >>> max_evaluation(\\"1+2*3+4\\") 11 >>> max_evaluation(\\"2*3+4*5\\") 26 >>> max_evaluation(\\"1*2*3*4\\") 24 pass","solution":"def max_evaluation(S): Returns the maximum possible value of the expression by adding parentheses. Operator precedence must be considered where multiplication '*' has higher precedence than addition '+'. def eval_expr(expr): tokens = [] num = 0 for char in expr: if char.isdigit(): num = num * 10 + int(char) else: tokens.append(num) tokens.append(char) num = 0 tokens.append(num) # Step 1: Evaluate all '*' in the expression stack = [] i = 0 while i < len(tokens): if tokens[i] == '*': prev_num = stack.pop() next_num = tokens[i + 1] stack.append(prev_num * next_num) i += 2 else: stack.append(tokens[i]) i += 1 # Step 2: Sum all remaining numbers (this takes care of '+') result = stack[0] for i in range(1, len(stack), 2): if stack[i] == '+': result += stack[i + 1] return result return eval_expr(S)"},{"question":"def shifted_fibonacci(a1: int, a2: int, k: int) -> list: Generates the first k terms of the shifted Fibonacci sequence starting with a1 and a2. Parameters: a1 (int): The first term of the sequence. a2 (int): The second term of the sequence. k (int): The number of terms to generate. Returns: list: A list containing the first k terms of the sequence. >>> shifted_fibonacci(1, 1, 5) [1, 1, 2, 3, 5] >>> shifted_fibonacci(2, 3, 6) [2, 3, 5, 8, 13, 21] >>> shifted_fibonacci(1, 1, 1) [1] >>> shifted_fibonacci(5, 8, 2) [5, 8]","solution":"def shifted_fibonacci(a1, a2, k): Generates the first k terms of the shifted Fibonacci sequence starting with a1 and a2. Parameters: a1 (int): The first term of the sequence. a2 (int): The second term of the sequence. k (int): The number of terms to generate. Returns: list: A list containing the first k terms of the sequence. if k == 1: return [a1] elif k == 2: return [a1, a2] result = [a1, a2] for _ in range(2, k): next_term = result[-1] + result[-2] result.append(next_term) return result"},{"question":"def generate_encouragement_messages(n: int, names: List[str]) -> List[str]: Generates personalized encouragement message for each student. Parameters: n (int): The number of students. names (list of str): The list of student names. Returns: list of str: The list of encouragement messages. >>> generate_encouragement_messages(1, [\\"Alice\\"]) [\\"Keep it up, Alice! You can do it!\\"] >>> generate_encouragement_messages(3, [\\"Alice\\", \\"Bob\\", \\"Charlie\\"]) [ \\"Keep it up, Alice! You can do it!\\", \\"Keep it up, Bob! You can do it!\\", \\"Keep it up, Charlie! You can do it!\\" ]","solution":"def generate_encouragement_messages(n, names): Generates personalized encouragement message for each student. Parameters: n (int): The number of students. names (list of str): The list of student names. Returns: list of str: The list of encouragement messages. messages = [] for name in names: message = f\\"Keep it up, {name}! You can do it!\\" messages.append(message) return messages"},{"question":"from typing import List def rank_poker_hand(hand: List[str]) -> str: Evaluates a poker hand and returns its rank. >>> rank_poker_hand('A♠ K♠ Q♠ J♠ T♠'.split()) == 'Straight Flush' >>> rank_poker_hand('9♦ 9♣ 9♥ 9♠ 3♦'.split()) == 'Four of a Kind' >>> rank_poker_hand('3♣ 3♦ 3♠ 6♣ 6♦'.split()) == 'Full House' >>> rank_poker_hand('2♥ 4♥ 6♥ 8♥ T♥'.split()) == 'Flush' >>> rank_poker_hand('8♠ J♠ 9♣ T♣ Q♦'.split()) == 'Straight' >>> rank_poker_hand('5♥ 5♦ 5♠ 2♠ 3♣'.split()) == 'Three of a Kind' >>> rank_poker_hand('2♠ 2♦ 3♠ 3♦ 4♠'.split()) == 'Two Pair' >>> rank_poker_hand('4♠ 4♦ 2♠ 3♣ 5♠'.split()) == 'One Pair' >>> rank_poker_hand('A♣ K♦ 7♠ 4♣ 9♥'.split()) == 'High Card' pass def rank_all_hands(hands: List[str]) -> List[str]: Evaluates a list of poker hands and returns a list of their ranks. >>> hands = ['A♠ K♠ Q♠ J♠ T♠', '9♦ 9♣ 9♥ 9♠ 3♦', '3♣ 3♦ 3♠ 6♣ 6♦', '2♥ 4♥ 6♥ 8♥ T♥', '8♠ J♠ 9♣ T♣ Q♦'] >>> expected = ['Straight Flush', 'Four of a Kind', 'Full House', 'Flush', 'Straight'] >>> rank_all_hands(hands) == expected pass","solution":"from collections import Counter def rank_poker_hand(hand): ranks_dict = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14} def is_flush(hand): suits = [card[-1] for card in hand] return len(set(suits)) == 1 def is_straight(hand): ranks = sorted([ranks_dict[card[:-1]] for card in hand]) return len(set(ranks)) == 5 and (ranks[-1] - ranks[0] == 4 or ranks == [2, 3, 4, 5, 14]) def count_ranks(hand): return Counter(card[:-1] for card in hand) def classify_by_rank(counts): values = sorted(counts.values(), reverse=True) if values == [4, 1]: return \\"Four of a Kind\\" if values == [3, 2]: return \\"Full House\\" if values == [3, 1, 1]: return \\"Three of a Kind\\" if values == [2, 2, 1]: return \\"Two Pair\\" if values == [2, 1, 1, 1]: return \\"One Pair\\" return \\"High Card\\" flush = is_flush(hand) straight = is_straight(hand) counts = count_ranks(hand) if flush and straight: return \\"Straight Flush\\" if flush: return \\"Flush\\" if straight: return \\"Straight\\" return classify_by_rank(counts) def rank_all_hands(hands): result = [] for hand in hands: result.append(rank_poker_hand(hand.strip().split())) return result"},{"question":"def is_mirrored_array(arr): Determine if the given array is a 'Mirrored Array'. An array is considered a 'Mirrored Array' if for every element at position \`i\` from the start, its mirrored element at position \`n-1-i\` from the end is the same. >>> is_mirrored_array([1, 2, 3, 2, 1]) 1 >>> is_mirrored_array([1, 2, 2, 1]) 1 >>> is_mirrored_array([1, 2, 3]) 0 def check_mirrored_arrays(test_cases): Given multiple test cases, determine if each array is a 'Mirrored Array'. Each test case starts with an integer N, the number of elements in the array, followed by N integers which are the elements of the array. The function returns a list with a 1 if the array is a 'Mirrored Array' and 0 otherwise. >>> check_mirrored_arrays([ >>> [5, 1, 2, 3, 2, 1], >>> [4, 1, 2, 2, 1], >>> [3, 1, 2, 3] >>> ]) [1, 1, 0]","solution":"def is_mirrored_array(arr): n = len(arr) for i in range(n // 2): if arr[i] != arr[n - 1 - i]: return 0 return 1 def check_mirrored_arrays(test_cases): results = [] for case in test_cases: n = case[0] arr = case[1:] results.append(is_mirrored_array(arr)) return results"},{"question":"def encrypt_message(key: int, message: str) -> str: Encrypts the message using a cyclic shift defined by the key. >>> encrypt_message(3, \\"abcde\\") \\"defgh\\" >>> encrypt_message(2, \\"xyz\\") \\"zab\\" def check_encryption(T: int, cases: List[Tuple[int, str, str]]) -> List[str]: Determines if the reference encrypted messages can be obtained by encrypting the messages with the given keys. >>> check_encryption(2, [(3, \\"abcde\\", \\"defgh\\"), (2, \\"xyz\\", \\"yza\\")]) [\\"MATCH\\", \\"NO MATCH\\"] import pytest def test_encrypt_message(): # Test case 1 assert encrypt_message(3, \\"abcde\\") == \\"defgh\\" # Test case 2 assert encrypt_message(2, \\"xyz\\") == \\"zab\\" # Test case 3 assert encrypt_message(0, \\"abc\\") == \\"abc\\" # Test case 4 assert encrypt_message(25, \\"abc\\") == \\"zab\\" def test_check_encryption(): # Test case 1 T = 2 cases = [ (3, \\"abcde\\", \\"defgh\\"), (2, \\"xyz\\", \\"yza\\") ] assert check_encryption(T, cases) == [\\"MATCH\\", \\"NO MATCH\\"] # Test case 2 T = 1 cases = [ (1, \\"hello\\", \\"ifmmp\\") ] assert check_encryption(T, cases) == [\\"MATCH\\"] # Test case 3 T = 1 cases = [ (0, \\"same\\", \\"same\\") ] assert check_encryption(T, cases) == [\\"MATCH\\"] # Test case 4 T = 1 cases = [ (4, \\"abcd\\", \\"efgh\\") ] assert check_encryption(T, cases) == [\\"MATCH\\"] if __name__ == '__main__': pytest.main()","solution":"def encrypt_message(key, message): encrypted_message = [] for char in message: shifted_char = chr(((ord(char) - ord('a') + key) % 26) + ord('a')) encrypted_message.append(shifted_char) return ''.join(encrypted_message) def check_encryption(T, cases): results = [] for i in range(T): key, message, reference = cases[i] if encrypt_message(key, message) == reference: results.append(\\"MATCH\\") else: results.append(\\"NO MATCH\\") return results"},{"question":"def min_circles_to_cover(N: int, points: List[Tuple[int, int]]) -> int: Determine the minimum number of circular roads required to cover all cities in the kingdom. Each city is represented as a point in a 2D plane given by its coordinates (x_i, y_i). Args: N (int): The number of cities. points (List[Tuple[int, int]]): A list of tuples where each tuple contains coordinates (x_i, y_i) of city i. Returns: int: The minimum number of circular roads needed to cover all cities. Examples: >>> min_circles_to_cover(5, [(1, 1), (2, 2), (3, 3), (1, 4), (4, 1)]) 1 >>> min_circles_to_cover(6, [(0, 0), (2, 2), (4, 0), (1, -1), (5, 5), (10, 0)]) 2 from typing import List, Tuple def test_single_point(): assert min_circles_to_cover(1, [(1, 1)]) == 1 def test_two_points(): assert min_circles_to_cover(2, [(1, 1), (2, 2)]) == 1 def test_collinear_points(): assert min_circles_to_cover(3, [(1, 1), (2, 2), (3, 3)]) == 1 def test_non_collinear_triangle_points(): assert min_circles_to_cover(3, [(1, 1), (2, 3), (3, 1)]) == 2 def test_more_than_three_points_non_collinear(): assert min_circles_to_cover(5, [(1, 1), (2, 2), (3, 3), (1, 4), (4, 1)]) == 1 def test_example_two(): assert min_circles_to_cover(6, [(0, 0), (2, 2), (4, 0), (1, -1), (5, 5), (10, 0)]) == 2","solution":"import math def distance(p1, p2): return math.hypot(p2[0] - p1[0], p2[1] - p1[1]) def is_collinear(points): if len(points) < 3: return True (x1, y1), (x2, y2), (x3, y3) = points[:3] return (y2 - y1) * (x3 - x2) == (y3 - y2) * (x2 - x1) def min_circles_to_cover(N, points): # If there are only one or two points, one circle is enough if N < 3: return 1 # Check if all points are collinear if is_collinear(points): return 1 # Otherwise, at most, we would need two circles (for general position cases) return 2"},{"question":"from typing import List def categorize_products(n: int, categories: List[str]) -> List[str]: Returns a summary report of categories starting letters and their counts. Args: n (int): number of categories categories (List[str]): list of category names Returns: List[str]: summary report in alphabetical order Examples: >>> categorize_products(5, [\\"Books\\", \\"Bags\\", \\"Pens\\", \\"Erasers\\", \\"Envelopes\\"]) [\\"B 2\\", \\"E 2\\", \\"P 1\\"] >>> categorize_products(3, [\\"Books\\", \\"Bags\\", \\"Balloons\\"]) [\\"B 3\\"]","solution":"def categorize_products(n, categories): Returns a summary report of categories starting letters and their counts. Args: n (int): number of categories categories (list of str): list of category names Returns: list of str: summary report in alphabetical order from collections import defaultdict count_dict = defaultdict(int) for category in categories: initial = category[0] count_dict[initial] += 1 sorted_counts = sorted(count_dict.items()) result = [f\\"{char} {count}\\" for char, count in sorted_counts] return result"},{"question":"def smallest_missing_positive(n, arr): Finds the smallest positive integer missing from the array. >>> smallest_missing_positive(5, [1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive(3, [3, 4, -1, 1]) 2 >>> smallest_missing_positive(5, [1, 2, 0, -1, 3]) 4 def test_examples(): assert smallest_missing_positive(5, [1, 2, 3, 4, 5]) == 6 assert smallest_missing_positive(3, [3, 4, -1, 1]) == 2 assert smallest_missing_positive(5, [1, 2, 0, -1, 3]) == 4 def test_edge_cases(): assert smallest_missing_positive(1, [1]) == 2 assert smallest_missing_positive(1, [2]) == 1 assert smallest_missing_positive(0, []) == 1 assert smallest_missing_positive(3, [0, 0, 0]) == 1 def test_large_input(): large_array = list(range(1, 100001)) # 1 to 100000 assert smallest_missing_positive(100000, large_array) == 100001 large_array[50000] = 0 # Missing 50001 assert smallest_missing_positive(100000, large_array) == 50001","solution":"def smallest_missing_positive(n, arr): Finds the smallest positive integer missing from the array. present = [False] * (n + 1) # Keep track of presence of numbers from 1 to n # Mark all positive numbers that are present in the array for num in arr: if 1 <= num <= n: present[num] = True # Find the first index which is not marked for i in range(1, n + 1): if not present[i]: return i # If all numbers from 1 to n are present, then the missing number is n+1 return n + 1"},{"question":"def max_path_length(n: int, lengths: List[int]) -> int: Returns the maximum possible length of the path such that no two consecutive sticks have the same length. >>> max_path_length(5, [4, 7, 2, 4, 5]) == 18 >>> max_path_length(3, [3, 3, 3]) == 3 >>> max_path_length(6, [1, 1, 1, 2, 2, 2]) == 3 >>> max_path_length(5, [5, 10, 15, 20, 25]) == 75 >>> max_path_length(1, [42]) == 42 >>> max_path_length(2, [7, 7]) == 7 >>> max_path_length(8, [1, 2, 2, 3, 4, 4, 5, 6]) == 21","solution":"def max_path_length(n, lengths): Returns the maximum possible length of the path such that no two consecutive sticks have the same length. from collections import Counter # Count the occurrences of each stick length length_count = Counter(lengths) # Create a list of unique stick lengths sorted by length unique_lengths = sorted(length_count.keys()) # Construct the path using the sorted unique lengths max_length = 0 for length in unique_lengths: max_length += length return max_length"},{"question":"def max_customers_can_serve(n: int, patience_levels: List[int]) -> int: Given the patience levels of the customers and the time it takes to serve each customer (which is always 1 unit of time), determine the maximum number of customers the baker can serve before any of them leave. Parameters: n (int): the number of customers in line patience_levels (List[int]): the patience levels of the customers Returns: int: the maximum number of customers that can be served Examples: >>> max_customers_can_serve(5, [1, 2, 3, 4, 5]) 5 >>> max_customers_can_serve(5, [3, 3, 3, 3, 3]) 3 >>> max_customers_can_serve(3, [1, 1, 1]) 1 pass","solution":"def max_customers_can_serve(n, patience_levels): # Sort patience levels in ascending order patience_levels.sort() served_customers = 0 for i in range(n): if patience_levels[i] > served_customers: served_customers += 1 return served_customers"},{"question":"def largest_group_of_similar_compounds(n: int, compounds: List[str]) -> int: Finds the largest group of similar compounds that can be transformed into each other. Args: n : int : the number of compounds compounds : list of str : list of compound strings Returns: int : the size of the largest group of similar compounds","solution":"def largest_group_of_similar_compounds(n, compounds): Finds the largest group of similar compounds that can be transformed into each other. Args: n : int : the number of compounds compounds : list of str : list of compound strings Returns: int : the size of the largest group of similar compounds from collections import defaultdict group_count = defaultdict(int) for compound in compounds: key = ''.join(sorted(compound)) group_count[key] += 1 return max(group_count.values())"},{"question":"[Completion Task in Python] def is_subsequence(s: str, t: str) -> bool: Determines if s is a subsequence of t. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False def check_subsequences(test_cases: List[Tuple[str, str]]) -> List[str]: For each test case, determines if the first string is a subsequence of the second. >>> check_subsequences([(\\"abc\\", \\"ahbgdc\\"), (\\"axc\\", \\"ahbgdc\\"), (\\"ace\\", \\"abcde\\"), (\\"aec\\", \\"abcde\\")]) [\\"YES\\", \\"NO\\", \\"YES\\", \\"NO\\"] def read_test_cases(input_string: str) -> List[Tuple[str, str]]: Reads the input string to extract test cases. >>> read_test_cases(\\"2nabcnahbgdcnaxcnahbgdcn\\") [(\\"abc\\", \\"ahbgdc\\"), (\\"axc\\", \\"ahbgdc\\")] def main(input_string: str) -> str: Executes the process for reading test cases, checking subsequences, and generating output string. >>> main(\\"2nabcnahbgdcnaxcnahbgdcn\\") \\"YESnNO\\" if __name__ == \\"__main__\\": input_string = input() print(main(input_string))","solution":"def is_subsequence(s, t): Determines if s is a subsequence of t. it = iter(t) return all(char in it for char in s) def check_subsequences(test_cases): For each test case, determines if the first string is a subsequence of the second. results = [] for s, t in test_cases: if is_subsequence(s, t): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Function to read test cases, to be used in unit tests def read_test_cases(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [(lines[i*2+1], lines[i*2+2]) for i in range(T)] return test_cases # Function to execute the process def main(input_string): test_cases = read_test_cases(input_string) results = check_subsequences(test_cases) return \\"n\\".join(results) # Example Run input_string = 2 abc ahbgdc axc ahbgdc print(main(input_string))"},{"question":"def min_unique_colors(n: int, heights: List[int]) -> int: Determine the minimum number of unique colors needed to paint the flags such that no two adjacent buildings have flags with the same color. Parameters: n (int): The number of buildings. heights (list of int): The heights of the buildings. Returns: int: The minimum number of unique colors needed. >>> min_unique_colors(5, [2, 3, 3, 2, 4]) 2 >>> min_unique_colors(3, [5, 5, 5]) 1 >>> min_unique_colors(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) 2 >>> min_unique_colors(1, [7]) 1 >>> min_unique_colors(2, [4, 6]) 2 >>> min_unique_colors(2, [9, 9]) 1 >>> min_unique_colors(4, [1, 1, 1, 1]) 1 >>> min_unique_colors(4, [1, 2, 1, 2]) 2 >>> min_unique_colors(4, [3, 3, 3, 2]) 2 pass","solution":"def min_unique_colors(n, heights): Determine the minimum number of unique colors needed to paint the flags such that no two adjacent buildings have flags with the same color. Parameters: n (int): The number of buildings. heights (list of int): The heights of the buildings. Returns: int: The minimum number of unique colors needed. if n == 1: return 1 max_adjacent = 1 for i in range(n-1): if heights[i] != heights[i+1]: max_adjacent = 2 return max_adjacent"},{"question":"def first_missing_letter(s: str) -> str: Returns the first missing letter in the alphabet from the string s. If no letter is missing, return \\"None\\". >>> first_missing_letter(\\"abcdf\\") \\"e\\" >>> first_missing_letter(\\"abcdefghijklmnopqrstuvwxyz\\") \\"None\\"","solution":"def first_missing_letter(s): Returns the first missing letter in the alphabet from the string s. If no letter is missing, return \\"None\\". import string # Create a set of all lowercase letters all_letters = set(string.ascii_lowercase) # Create a set of letters in the input string letters_in_s = set(s) # Find the difference which gives the missing letters missing_letters = all_letters - letters_in_s if not missing_letters: # If no letters are missing, return \\"None\\" return \\"None\\" # Sort the missing letters and return the first one return sorted(missing_letters)[0]"},{"question":"def min_trucks_required(test_cases): Determine the minimum number of trucks required to carry all packages without exceeding the capacity of any truck. Args: test_cases (List[Tuple[int, int, List[int]]]): List of tuples where each tuple represents a test case with capacity of truck, number of packages, and a list of package weights. Returns: List[int]: List of integers representing the minimum number of trucks required for each test case. >>> min_trucks_required([(10, 4, [2, 3, 7, 1]), (8, 5, [4, 3, 5, 6, 2])]) [2, 3] >>> min_trucks_required([(10, 1, [10]), (15, 3, [5, 5, 5]), (5, 6, [2, 1, 4, 3, 2, 1]), (10, 5, [10, 10, 10, 10, 10])]) [1, 1, 3, 5] pass def solve(input_lines): Parse input lines, determine the minimum number of trucks required for each test case and return the results. Args: input_lines (List[str]): List of input strings representing multiple test cases. Returns: List[int]: List of integers representing the minimum number of trucks required for each test case parsed from input lines. >>> solve([\\"2\\", \\"10\\", \\"4\\", \\"2 3 7 1\\", \\"8\\", \\"5\\", \\"4 3 5 6 2\\"]) [2, 3] >>> solve([\\"1\\", \\"10\\", \\"1\\", \\"10\\"]) [1] >>> solve([\\"1\\", \\"15\\", \\"3\\", \\"5 5 5\\"]) [1] >>> solve([\\"1\\", \\"5\\", \\"6\\", \\"2 1 4 3 2 1\\"]) [3] >>> solve([\\"1\\", \\"10\\", \\"5\\", \\"10 10 10 10 10\\"]) [5] pass","solution":"def min_trucks_required(test_cases): results = [] for case in test_cases: C, P, weights = case weights.sort(reverse=True) trucks = 0 while weights: capacity = C i = 0 while i < len(weights): if weights[i] <= capacity: capacity -= weights.pop(i) else: i += 1 trucks += 1 results.append(trucks) return results def solve(input_lines): index = 0 T = int(input_lines[index]) index += 1 test_cases = [] for _ in range(T): C = int(input_lines[index]) index += 1 P = int(input_lines[index]) index += 1 weights = list(map(int, input_lines[index].split())) index += 1 test_cases.append((C, P, weights)) return min_trucks_required(test_cases)"},{"question":"def count_common_divisors(A: int, B: int) -> int: You are given two integers A and B. Count the number of common divisors of A and B. >>> count_common_divisors(12, 15) 2 >>> count_common_divisors(100, 75) 3 >>> count_common_divisors(17, 23) 1","solution":"import math def count_common_divisors(A, B): Returns the number of common divisors of A and B. gcd_val = math.gcd(A, B) common_divisors = 0 for i in range(1, int(gcd_val**0.5) + 1): if gcd_val % i == 0: common_divisors += 1 if i != gcd_val // i: common_divisors += 1 return common_divisors"},{"question":"def is_subarray_with_sum(arr, S): Determine if there exists a contiguous subarray that sums to a given integer S. Parameters: arr (list): A list of integers representing the array. S (int): The target sum to check for. Returns: bool: True if such a subarray exists, and False otherwise. Example: >>> is_subarray_with_sum([1, 2, 3, -2, 5, 4, -10, 3, 1, 4], 7) True >>> is_subarray_with_sum([1, 2, 3, 4, 5], 20) False","solution":"def is_subarray_with_sum(arr, S): Determine if there exists a contiguous subarray that sums to a given integer S. Parameters: arr (list): A list of integers representing the array. S (int): The target sum to check for. Returns: bool: True if such a subarray exists, and False otherwise. current_sum = 0 sum_set = set() for num in arr: current_sum += num if current_sum == S: return True if (current_sum - S) in sum_set: return True sum_set.add(current_sum) return False"},{"question":"def max_power_difference(n, powers): Returns the maximum power difference between the knights in the squad. Parameters: n (int): The number of knights. powers (list): A list of integers representing the powers of each knight. Returns: int: The maximum power difference. >>> max_power_difference(5, [10, 20, 30, 40, 50]) == 40 >>> max_power_difference(4, [5, 3, 8, 1]) == 7 >>> max_power_difference(1, [10]) == 0 >>> max_power_difference(4, [5, 5, 5, 5]) == 0 >>> max_power_difference(2, [10, 20]) == 10 >>> max_power_difference(3, [10000, 20000, 30000]) == 20000","solution":"def max_power_difference(n, powers): Returns the maximum power difference between the knights in the squad. Parameters: n (int): The number of knights. powers (list): A list of integers representing the powers of each knight. Returns: int: The maximum power difference. if n < 2: return 0 max_power = max(powers) min_power = min(powers) return max_power - min_power # Example usage: # print(max_power_difference(5, [10, 20, 30, 40, 50])) # Output: 40"},{"question":"from datetime import datetime from typing import List, Dict def calculate_hours_worked(records: List[Dict[str, str]], date: str) -> Dict[str, float]: Calculate the total number of hours worked by each employee on a given date. :param records: List of dictionaries, each containing: - 'employee_id': string, employee's ID - 'start': string, start time in 'YYYY-MM-DD HH:MM:SS' format - 'end': string, end time in 'YYYY-MM-DD HH:MM:SS' format :param date: string, the date to calculate hours for in 'YYYY-MM-DD' format :return: Dictionary where keys are employee IDs and values are total hours worked on the given date. >>> records = [ ... {'employee_id': 'E123', 'start': '2023-05-12 09:00:00', 'end': '2023-05-12 17:00:00'}, ... {'employee_id': 'E123', 'start': '2023-05-12 19:00:00', 'end': '2023-05-12 21:00:00'}, ... {'employee_id': 'E456', 'start': '2023-05-12 08:00:00', 'end': '2023-05-12 16:00:00'}, ... {'employee_id': 'E456', 'start': '2023-05-13 07:00:00', 'end': '2023-05-13 15:00:00'} ...] >>> date = '2023-05-12' >>> calculate_hours_worked(records, date) == {'E123': 10.00, 'E456': 8.00} True >>> records = [ ... {'employee_id': 'E123', 'start': '2023-05-12 09:00:00', 'end': '2023-05-12 13:00:00'} ...] >>> date = '2023-05-12' >>> calculate_hours_worked(records, date) == {'E123': 4.00} True >>> records = [ ... {'employee_id': 'E123', 'start': '2023-05-11 09:00:00', 'end': '2023-05-11 17:00:00'} ...] >>> date = '2023-05-12' >>> calculate_hours_worked(records, date) == {} True","solution":"from datetime import datetime def calculate_hours_worked(records, date): Calculate the total number of hours worked by each employee on a given date. :param records: List of dictionaries, each containing: - 'employee_id': string, employee's ID - 'start': string, start time in 'YYYY-MM-DD HH:MM:SS' format - 'end': string, end time in 'YYYY-MM-DD HH:MM:SS' format :param date: string, the date to calculate hours for in 'YYYY-MM-DD' format :return: Dictionary where keys are employee IDs and values are total hours worked on the given date. work_hours = {} for record in records: # Parse the start and end times start_time = datetime.strptime(record['start'], '%Y-%m-%d %H:%M:%S') end_time = datetime.strptime(record['end'], '%Y-%m-%d %H:%M:%S') # Check if the session is on the correct date if start_time.strftime('%Y-%m-%d') == date: employee = record['employee_id'] hours_worked = (end_time - start_time).total_seconds() / 3600 if employee in work_hours: work_hours[employee] += hours_worked else: work_hours[employee] = hours_worked # Round the hours to two decimal places for employee in work_hours: work_hours[employee] = round(work_hours[employee], 2) return work_hours"},{"question":"def total_data_received(p: int, n: int, log_entries: list) -> int: Calculate the total amount of data successfully received by the server at the end of the given period. Args: p (int): the period in minutes (1 ≤ p ≤ 1440) n (int): the number of log entries (1 ≤ n ≤ 100000) log_entries (list): a list of tuples where each tuple contains three integers (ti, ai, di) representing the minute data is sent (1 ≤ ti ≤ 1440), the amount of data sent (1 ≤ ai ≤ 10^6), and the time taken to send that data respectively (1 ≤ di ≤ 60). Returns: int: the total amount of data successfully received by the server. Examples: >>> total_data_received(60, 3, [(10, 500, 5), (20, 300, 2), (30, 700, 10)]) 1500 >>> total_data_received(120, 5, [(10, 500, 30), (25, 600, 15), (40, 700, 20), (55, 800, 25), (70, 900, 30)]) 3500 >>> total_data_received(90, 4, [(15, 400, 10), (30, 500, 20), (45, 600, 15), (60, 700, 25)]) 2200 from solution import total_data_received def test_example_1(): assert total_data_received(60, 3, [(10, 500, 5), (20, 300, 2), (30, 700, 10)]) == 1500 def test_example_2(): assert total_data_received(120, 5, [(10, 500, 30), (25, 600, 15), (40, 700, 20), (55, 800, 25), (70, 900, 30)]) == 3500 def test_example_3(): assert total_data_received(90, 4, [(15, 400, 10), (30, 500, 20), (45, 600, 15), (60, 700, 25)]) == 2200 def test_no_data_received(): assert total_data_received(10, 3, [(11, 500, 5), (12, 300, 2), (13, 700, 10)]) == 0 def test_all_data_received(): assert total_data_received(60, 3, [(10, 500, 50), (20, 300, 20), (30, 700, 30)]) == 1500 def test_mixed_data_received(): assert total_data_received(50, 3, [(10, 500, 20), (30, 300, 15), (35, 700, 20)]) == 800 def test_large_amounts_of_data(): assert total_data_received(100, 2, [(10, 1000000, 10), (20, 1000000, 10)]) == 2000000","solution":"def total_data_received(p, n, log_entries): Calculate the total amount of data successfully received by the server at the end of the given period. Args: p (int): the period in minutes n (int): the number of log entries log_entries (list): a list of tuples where each tuple contains three integers (ti, ai, di) representing the minute data is sent, the amount of data sent, and the time taken to send that data respectively. Returns: int: the total amount of data successfully received by the server. total_data = 0 for ti, ai, di in log_entries: if ti + di <= p: total_data += ai return total_data"},{"question":"def is_valid_alternating_sequence(s: str) -> str: Returns \\"YES\\" if the string is a valid alternating sequence of 'A' and 'B' starting with 'A', otherwise \\"NO\\". >>> is_valid_alternating_sequence(\\"ABABA\\") \\"YES\\" >>> is_valid_alternating_sequence(\\"ABBABA\\") \\"NO\\"","solution":"def is_valid_alternating_sequence(s): Returns \\"YES\\" if the string is a valid alternating sequence of 'A' and 'B' starting with 'A', otherwise \\"NO\\". if not s or s[0] != 'A': return \\"NO\\" for i in range(1, len(s)): if s[i] == s[i-1]: return \\"NO\\" return \\"YES\\""},{"question":"def find_bounding_rectangle(n: int, locations: List[Tuple[int, int]]) -> Tuple[Tuple[int, int], Tuple[int, int]]: Given a number of locations and their coordinates, find the smallest bounding rectangle that contains all locations with sides parallel to the x and y axes. Args: n: The number of locations. locations: A list of tuples, where each tuple contains two integers representing the x and y coordinates of a location. Returns: A tuple containing two tuples: - The first tuple contains the coordinates of the bottom-left corner of the bounding rectangle (x_min, y_min). - The second tuple contains the coordinates of the top-right corner of the bounding rectangle (x_max, y_max). >>> find_bounding_rectangle(5, [(1, 3), (4, 4), (2, 2), (0, 5), (3, 1)]) ((0, 1), (4, 5)) >>> find_bounding_rectangle(1, [(2, 3)]) ((2, 3), (2, 3)) >>> find_bounding_rectangle(3, [(2, 2), (2, 2), (2, 2)]) ((2, 2), (2, 2)) >>> find_bounding_rectangle(4, [(3, 1), (3, 5), (3, 2), (3, 4)]) ((3, 1), (3, 5)) >>> find_bounding_rectangle(4, [(1, 3), (5, 3), (2, 3), (4, 3)]) ((1, 3), (5, 3)) >>> find_bounding_rectangle(4, [(-1, -1), (-5, -5), (-10, 2), (3, -2)]) ((-10, -5), (3, 2))","solution":"def find_bounding_rectangle(n, locations): Given a number of locations and their coordinates, finds the smallest bounding rectangle that contains all locations with sides parallel to the x and y axes. Args: n: The number of locations. locations: A list of tuples, where each tuple contains two integers representing the x and y coordinates of a location. Returns: A tuple containing two tuples: - The first tuple contains the coordinates of the bottom-left corner of the bounding rectangle (x_min, y_min). - The second tuple contains the coordinates of the top-right corner of the bounding rectangle (x_max, y_max). x_min = min(locations, key=lambda loc: loc[0])[0] y_min = min(locations, key=lambda loc: loc[1])[1] x_max = max(locations, key=lambda loc: loc[0])[0] y_max = max(locations, key=lambda loc: loc[1])[1] return (x_min, y_min), (x_max, y_max) # Example usage: n = 5 locations = [(1, 3), (4, 4), (2, 2), (0, 5), (3, 1)] print(find_bounding_rectangle(n, locations)) # Output: ((0, 1), (4, 5))"},{"question":"def max_height_difference(grid, R, C): Find the maximum height difference between any two connected ground cells in the grid. >>> max_height_difference([ ... [1, 2, '*'], ... [2, '*', 3], ... [1, 3, 4] ... ], 3, 3) == 3 >>> max_height_difference([ ... [10, 20, '*', '*'], ... ['*', '*', 15, 30], ... [25, '*', '*', 5], ... ['*', 10, 20, 30] ... ], 4, 4) == 25","solution":"def max_height_difference(grid, R, C): def dfs(x, y, visited): stack = [(x, y)] heights = [] while stack: cx, cy = stack.pop() if (cx, cy) not in visited: visited.add((cx, cy)) heights.append(grid[cx][cy]) for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < R and 0 <= ny < C and (nx, ny) not in visited and grid[nx][ny] != '*': stack.append((nx, ny)) return heights max_diff = 0 visited = set() for i in range(R): for j in range(C): if grid[i][j] != '*' and (i, j) not in visited: heights = dfs(i, j, visited) if heights: max_diff = max(max_diff, max(heights) - min(heights)) return max_diff"},{"question":"from typing import List, Tuple def subarray_sums(n: int, q: int, array: List[int], queries: List[Tuple[int, int]]) -> List[int]: Determine the sum of the elements in the subarray defined by the indices L and R (inclusive). Parameters: - n (int): the length of the array - q (int): the number of queries - array (list of int): the list of integers - queries (list of tuples): each tuple contains two integers representing the bounds L and R of the subarray Returns: - list of int: the sum of each subarray defined by the queries >>> subarray_sums(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> subarray_sums(4, 4, [10, 20, 30, 40], [(1, 1), (2, 2), (3, 3), (4, 4)]) [10, 20, 30, 40] >>> subarray_sums(3, 1, [5, 5, 5], [(1, 3)]) [15]","solution":"def subarray_sums(n, q, array, queries): This function returns the sum of subarrays defined by the queries. Parameters: - n (int): the length of the array - q (int): the number of queries - array (list of int): the list of integers - queries (list of tuples): each tuple contains two integers representing the bounds L and R of the subarray Returns: - list of int: the sum of each subarray defined by the queries # Precompute prefix sums prefix_sums = [0] * (n + 1) for i in range(n): prefix_sums[i + 1] = prefix_sums[i] + array[i] # Process each query results = [] for L, R in queries: subarray_sum = prefix_sums[R] - prefix_sums[L - 1] results.append(subarray_sum) return results"},{"question":"def count_unique_codes(ability: str, weapons: List[str]) -> int: Returns the number of unique secret codes generated by concatenating the ability string with each weapon string. Parameters: ability (str): The ability string consisting of lowercase Latin letters. weapons (list of str): A list of weapon strings consisting of lowercase Latin letters. Returns: int: The number of unique secret codes. Examples: >>> count_unique_codes(\\"strength\\", [\\"sword\\", \\"axe\\", \\"bow\\"]) 3 >>> count_unique_codes(\\"power\\", [\\"hammer\\", \\"shield\\"]) 2 >>> count_unique_codes(\\"magic\\", [\\"wand\\", \\"staff\\", \\"orb\\"]) 3 >>> count_unique_codes(\\"speed\\", [\\"boots\\", \\"dagger\\", \\"cloak\\", \\"ring\\"]) 4 >>> count_unique_codes(\\"agility\\", [\\"gloves\\"]) 1","solution":"def count_unique_codes(ability, weapons): Returns the number of unique secret codes generated by concatenating the ability string with each weapon string. Parameters: ability (str): The ability string consisting of lowercase Latin letters. weapons (list of str): A list of weapon strings consisting of lowercase Latin letters. Returns: int: The number of unique secret codes. unique_codes = set() for weapon in weapons: unique_code = ability + weapon unique_codes.add(unique_code) return len(unique_codes)"},{"question":"class ListNode: def __init__(self, x): self.val = x self.next = None def rearrange_list(head: ListNode) -> ListNode: Rearranges a linked list such that all nodes with even values come before all nodes with odd values. The relative order of even and odd values should be preserved. >>> head = ListNode(1) >>> head.next = ListNode(4) >>> head.next.next = ListNode(3) >>> head.next.next.next = ListNode(2) >>> head.next.next.next.next = ListNode(5) >>> rearranged_head = rearrange_list(head) >>> while rearranged_head: ... print(rearranged_head.val, end=\\" -> \\") ... rearranged_head = rearranged_head.next 4 -> 2 -> 1 -> 3 -> 5 -> def linked_list_from_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head def list_from_linked_list(head): values = [] current = head while current: values.append(current.val) current = current.next return values def test_rearrange_list_example(): head = linked_list_from_list([1, 4, 3, 2, 5]) rearranged_head = rearrange_list(head) assert list_from_linked_list(rearranged_head) == [4, 2, 1, 3, 5] def test_rearrange_list_all_even(): head = linked_list_from_list([2, 4, 6, 8]) rearranged_head = rearrange_list(head) assert list_from_linked_list(rearranged_head) == [2, 4, 6, 8] def test_rearrange_list_all_odd(): head = linked_list_from_list([1, 3, 5, 7]) rearranged_head = rearrange_list(head) assert list_from_linked_list(rearranged_head) == [1, 3, 5, 7] def test_rearrange_list_mixed(): head = linked_list_from_list([2, 1, 4, 3, 6, 5]) rearranged_head = rearrange_list(head) assert list_from_linked_list(rearranged_head) == [2, 4, 6, 1, 3, 5] def test_rearrange_list_single_element(): head = linked_list_from_list([1]) rearranged_head = rearrange_list(head) assert list_from_linked_list(rearranged_head) == [1] def test_rearrange_list_empty_list(): head = linked_list_from_list([]) rearranged_head = rearrange_list(head) assert rearranged_head is None","solution":"class ListNode: def __init__(self, x): self.val = x self.next = None def rearrange_list(head: ListNode) -> ListNode: if not head: return head even_dummy = ListNode(0) odd_dummy = ListNode(0) even_tail, odd_tail = even_dummy, odd_dummy current = head while current: if current.val % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = odd_dummy.next odd_tail.next = None return even_dummy.next"},{"question":"def minimum_moves_to_even_groups(t: int, test_cases: List[Tuple[int, ...]]) -> List[int]: Determine the minimum number of moves required to make all groups have even animals. >>> minimum_moves_to_even_groups(3, [(4, 1, 3, 5, 7), (2, 10, 15), (3, 2, 4, 6)]) [4, 1, 0] >>> minimum_moves_to_even_groups(1, [(5, 1, 3, 5, 7, 9)]) [5]","solution":"def minimum_moves_to_even_groups(t, test_cases): results = [] for i in range(t): n, *animals = test_cases[i] moves = 0 for animal in animals: if animal % 2 != 0: moves += 1 results.append(moves) return results"},{"question":"def can_form_palindrome(s: str) -> bool: Determines if the input string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"Tact Coa\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"abba\\") True >>> can_form_palindrome(\\"abcd\\") False >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"abcde\\") False >>> can_form_palindrome(\\"AbaBa\\") True >>> can_form_palindrome(\\"A man a plan a canal Panama\\") True","solution":"def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. Parameters: s (str): The input string. Returns: bool: True if it can be rearranged to form a palindrome, False otherwise. # Convert to lower case and remove spaces s = s.replace(\\" \\", \\"\\").lower() # Create a dictionary to count occurrences of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters that have an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"def number_of_rounds(participants: int) -> int: Given the number of participants, returns the number of rounds required for a champion to be determined. >>> number_of_rounds(8) 3 >>> number_of_rounds(16) 4 >>> number_of_rounds(7) 3 >>> number_of_rounds(1) 0 >>> number_of_rounds(100) 7 >>> number_of_rounds(1000) 10","solution":"import math def number_of_rounds(participants): Given the number of participants, returns the number of rounds required for a champion to be determined. if participants < 1: raise ValueError(\\"Number of participants must be at least 1\\") # The number of rounds will be the ceiling value of the base 2 logarithm of the number of participants return math.ceil(math.log2(participants))"},{"question":"def count_isolated_seats(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Calculate the total number of isolated empty seats in the entire conference hall for each test case. >>> count_isolated_seats(2, [(3, 5, [\\"10101\\", \\"10001\\", \\"11011\\"]), (2, 7, [\\"1100011\\", \\"0111010\\"])]) [3, 1] >>> count_isolated_seats(1, [(2, 5, [\\"11111\\", \\"00000\\"])]) [0] >>> count_isolated_seats(1, [(1, 5, [\\"10101\\"])]) [2] >>> count_isolated_seats(1, [(0, 0, [])]) [0] >>> count_isolated_seats(1, [(3, 7, [\\"1111110\\", \\"0111111\\", \\"1101111\\"])]) [1] >>> count_isolated_seats(1, [(3, 6, [\\"110110\\", \\"110110\\", \\"110110\\"])]) [3]","solution":"def count_isolated_seats(T, test_cases): result = [] for i in range(T): R, C, seating = test_cases[i] count = 0 for row in seating: for j in range(1, C-1): if row[j] == '0' and row[j-1] == '1' and row[j+1] == '1': count += 1 result.append(count) return result"},{"question":"def can_divide_driving_hours(hours: List[int]) -> str: Determines if the total driving hours can be equally divided among three friends. Args: hours (list of int): A list of integers representing driving times in hours. Returns: str: \\"YES\\" if the driving hours can be equally divided among three friends, otherwise \\"NO\\". >>> can_divide_driving_hours([2, 4, 6]) \\"YES\\" >>> can_divide_driving_hours([1, 2, 3, 4]) \\"NO\\"","solution":"def can_divide_driving_hours(hours): Determines if the total driving hours can be equally divided among three friends. Args: hours (list of int): A list of integers representing driving times in hours. Returns: str: \\"YES\\" if the driving hours can be equally divided among three friends, otherwise \\"NO\\". total_hours = sum(hours) if total_hours % 3 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def length_of_LIS(sequence: List[int]) -> int: Finds the length of the longest increasing subsequence in a sequence of numbers. Parameters: sequence (List[int]): A list of integers representing the sequence. Returns: int: The length of the longest increasing subsequence. # Write your code here def find_lis_lengths(T: int, sequences: List[List[int]]) -> List[int]: Finds the length of the longest increasing subsequence for multiple sequences. Parameters: T (int): The number of sequences. sequences (List[List[int]]): A list of sequences where each sequence is a list of integers. Returns: List[int]: A list of lengths of the longest increasing subsequence for each sequence. # Write your code here # Test cases def test_example_cases(): assert find_lis_lengths(3, [ [10, 9, 2, 5, 3, 7, 101, 18], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15], [3, 10, 2, 1, 20] ]) == [4, 6, 3] def test_single_element(): assert find_lis_lengths(1, [[1]]) == [1] def test_identical_elements(): assert find_lis_lengths(1, [[2, 2, 2, 2, 2]]) == [1] def test_strictly_increasing(): assert find_lis_lengths(1, [[1, 2, 3, 4, 5]]) == [5] def test_strictly_decreasing(): assert find_lis_lengths(1, [[5, 4, 3, 2, 1]]) == [1] def test_mixed_sequence(): assert find_lis_lengths(1, [[3, 4, -1, 5, 8, 2, 3, 12, 7, 9, 10]]) == [6] def test_empty_sequence(): assert find_lis_lengths(1, [[]]) == [0]","solution":"def length_of_LIS(sequence): if not sequence: return 0 n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j]: lis[i] = max(lis[i], lis[j] + 1) return max(lis) def find_lis_lengths(T, sequences): Finds the length of the longest increasing subsequence for multiple sequences. Parameters: T (int): The number of sequences. sequences (List[List[int]]): A list of sequences where each sequence is a list of integers. Returns: List[int]: A list of lengths of the longest increasing subsequence for each sequence. lengths = [] for seq in sequences: lengths.append(length_of_LIS(seq)) return lengths"},{"question":"def generate_gift_distribution_patterns(n: int) -> List[List[int]]: Returns a list of lists representing the distribution of gifts. Each list contains a unique permutation of gifts for each group. >>> generate_gift_distribution_patterns(1) [[1]] >>> generate_gift_distribution_patterns(2) [[1, 2], [2, 1]] >>> generate_gift_distribution_patterns(3) [[1, 2, 3], [2, 3, 1], [3, 1, 2]] >>> generate_gift_distribution_patterns(4) [[1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3]]","solution":"def generate_gift_distribution_patterns(n): Returns a list of lists representing the distribution of gifts. Each list contains a unique permutation of gifts for each group. patterns = [] base_pattern = list(range(1, n + 1)) for i in range(n): pattern = base_pattern[i:] + base_pattern[:i] patterns.append(pattern) return patterns"},{"question":"def print_triangle(): Prints a right-angle triangle pattern using stars (*). >>> print_triangle() * ** *** **** ***** ****** ******* ******** ********* **********","solution":"def print_triangle(): Prints a right-angle triangle pattern using stars (*). for i in range(1, 11): print('*' * i)"},{"question":"import math from typing import Tuple def lcm(n: int, k: int) -> int: Returns the least common multiple (LCM) of integers n and k. :param n: an integer :param k: an integer :return: LCM of n and k >>> lcm(6, 3) 6 >>> lcm(15, 20) 60 >>> lcm(500, 300) 1500 >>> lcm(7, 13) 91 >>> lcm(5, 5) 5 >>> lcm(1, 10) 10 >>> lcm(10, 1) 10","solution":"import math def lcm(n, k): Returns the least common multiple (LCM) of integers n and k. return (n * k) // math.gcd(n, k)"},{"question":"from typing import List def max_sum_submatrix(n: int, m: int, k: int, matrix: List[List[int]]) -> int: Find the maximum sum of elements in a submatrix such that the submatrix contains at most k elements. :param n: Number of rows in the matrix :param m: Number of columns in the matrix :param k: Maximum number of elements in the submatrix :param matrix: List of lists representing the matrix :return: The maximum sum of a submatrix that contains at most k elements pass def test_example_case(): matrix = [ [1, 2, 3], [-1, -2, -3], [4, 5, 6] ] n, m, k = 3, 3, 4 assert max_sum_submatrix(n, m, k, matrix) == 15 def test_single_element_case(): matrix = [ [10] ] n, m, k = 1, 1, 1 assert max_sum_submatrix(n, m, k, matrix) == 10 def test_full_matrix(): matrix = [ [1, 2], [3, 4] ] n, m, k = 2, 2, 4 assert max_sum_submatrix(n, m, k, matrix) == 10 def test_partial_matrix(): matrix = [ [1, 2], [3, 4] ] n, m, k = 2, 2, 2 assert max_sum_submatrix(n, m, k, matrix) == 7 def test_negative_numbers(): matrix = [ [-1, -2], [-3, -4] ] n, m, k = 2, 2, 2 assert max_sum_submatrix(n, m, k, matrix) == -1 def test_mixed_numbers(): matrix = [ [1, -2], [-3, 4] ] n, m, k = 2, 2, 3 assert max_sum_submatrix(n, m, k, matrix) == 4","solution":"def max_sum_submatrix(n, m, k, matrix): Find the maximum sum of elements in a submatrix such that the submatrix contains at most k elements. import itertools # Function to get all submatrices of a given matrix def get_submatrices(matrix): n, m = len(matrix), len(matrix[0]) submatrices = [] for i in range(n): for j in range(m): for i2 in range(i, n): for j2 in range(j, m): submatrix = [] for x in range(i, i2 + 1): submatrix.append(matrix[x][j:j2 + 1]) submatrices.append(submatrix) return submatrices # Function to calculate the sum of elements in a submatrix def get_sum_of_matrix(matrix): return sum(sum(row) for row in matrix) # Get all potential submatrices submatrices = get_submatrices(matrix) max_sum = float('-inf') # Iterate over each submatrix and check its sum for submatrix in submatrices: flattened = list(itertools.chain.from_iterable(submatrix)) if len(flattened) <= k: current_sum = sum(flattened) if current_sum > max_sum: max_sum = current_sum return max_sum # Example input to test the function n = 3 m = 3 k = 4 matrix = [ [1, 2, 3], [-1, -2, -3], [4, 5, 6] ] print(max_sum_submatrix(n, m, k, matrix)) # Output: 15"},{"question":"MOD = 10**9 + 7 def count_sequences(n): Returns the number of valid sequences of length n modulo 10^9 + 7. def process_test_cases(test_cases): Processes multiple test cases and returns results for each one. import pytest from solution import process_test_cases, count_sequences def test_single_sequence(): assert process_test_cases([1]) == [4] def test_double_sequences(): assert process_test_cases([2]) == [12] def test_multiple_sequences(): assert process_test_cases([1, 2, 3]) == [4, 12, 36] def test_large_n(): # For n = 10^18, this tests if the function handles large inputs properly assert process_test_cases([10**18]) == [(4 * pow(3, 10**18 - 1, 10**9 + 7)) % (10**9 + 7)] def test_various_n(): # Test a mix of various small n values assert process_test_cases([3, 4, 5, 10]) == [ (4 * pow(3, 2, 10**9 + 7)) % (10**9 + 7), (4 * pow(3, 3, 10**9 + 7)) % (10**9 + 7), (4 * pow(3, 4, 10**9 + 7)) % (10**9 + 7), (4 * pow(3, 9, 10**9 + 7)) % (10**9 + 7) ]","solution":"MOD = 10**9 + 7 def count_sequences(n): Returns the number of valid sequences of length n modulo 10^9 + 7. if n == 1: return 4 elif n == 2: return 12 # 4 initial ways to pick the first character, then 3 choices for every subsequent character # result = 4 * (3^(n-1)) % (10^9 + 7) return (4 * pow(3, n - 1, MOD)) % MOD def process_test_cases(test_cases): results = [] for n in test_cases: results.append(count_sequences(n)) return results"},{"question":"def min_weight_path_with_k_edges(n, m, k, edges, a, b): You are given an undirected graph with n vertices and m edges. Each edge has an associated non-negative weight. You are also given two special vertices, a and b. Your task is to find the minimum weight of a path from vertex a to vertex b, where the path uses exactly k edges. :param n: Number of vertices :param m: Number of edges :param k: Number of edges in the path :param edges: List of edges where each edge is represented as (u, v, w) :param a: Starting vertex :param b: Ending vertex :return: Minimum weight of a path from a to b using exactly k edges, or -1 if no such path exists >>> min_weight_path_with_k_edges(4, 5, 3, [(1, 2, 5), (2, 3, 10), (3, 4, 1), (1, 3, 4), (2, 4, 6)], 1, 4) 16 >>> min_weight_path_with_k_edges(4, 2, 3, [(1, 2, 5), (2, 3, 10)], 1, 4) -1 >>> min_weight_path_with_k_edges(3, 3, 1, [(1, 2, 5), (2, 3, 10), (1, 3, 15)], 1, 3) 15 >>> min_weight_path_with_k_edges(3, 3, 2, [(1, 3, 1), (1, 2, 1), (2, 3, 1)], 1, 3) 2 >>> min_weight_path_with_k_edges(3, 3, 2, [(1, 2, 1000), (2, 3, 1000), (1, 3, 2000)], 1, 3) 2000","solution":"def min_weight_path_with_k_edges(n, m, k, edges, a, b): # Initialize dp table with infinities INF = float('inf') dp = [[[INF] * (k + 1) for _ in range(n + 1)] for _ in range(n + 1)] # Distance to reach any node from itself with 0 edges is 0 for i in range(1, n + 1): dp[i][i][0] = 0 # Conversion of edges to adjacency matrix for easier updates for u, v, w in edges: dp[u][v][1] = w # Update dp for paths with j edges for j in range(2, k + 1): for u in range(1, n + 1): for v in range(1, n + 1): for p in range(1, n + 1): if dp[u][p][j - 1] != INF and dp[p][v][1] != INF: dp[u][v][j] = min(dp[u][v][j], dp[u][p][j - 1] + dp[p][v][1]) result = dp[a][b][k] return result if result != INF else -1"},{"question":"def can_complete_race(M: int, E: int, heights: List[int]) -> str: Determine if Achilles can complete the race given the initial energy level and hurdles' heights. >>> can_complete_race(3, 5, [2, 3]) 'YES' >>> can_complete_race(4, 10, [5, 3, 2]) 'YES' >>> can_complete_race(4, 3, [5, 3, 2]) 'NO' >>> can_complete_race(3, 4, [1, 4]) 'NO' >>> can_complete_race(2, 1, [1]) 'NO' def solve(T: int, cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Solve multiple test cases to determine if Achilles can complete the race in each case. >>> solve(2, [[(3, 5), [2, 3]], [(4, 10), [5, 3, 2]]]) ['YES', 'YES'] >>> solve(2, [[(4, 3), [5, 3, 2]], [(3, 4), [1, 4]]]) ['NO', 'NO'] >>> solve(3, [[(3, 5), [2, 3]], [(4, 10), [5, 3, 2]], [(2, 1), [1]]]) ['YES', 'YES', 'NO']","solution":"def can_complete_race(M, E, heights): Determine if Achilles can complete the race given the initial energy level and hurdles' heights. for height in heights: if E <= height: return \\"NO\\" E -= 1 return \\"YES\\" def solve(T, cases): results = [] for case in cases: M, E = case[0] heights = case[1] results.append(can_complete_race(M, E, heights)) return results"},{"question":"def find_ancestors(tree, individual): Given a tree (dictionary) where keys are children and values are parents, this function returns a set of ancestors for the given individual. ancestors = set() while individual in tree: individual = tree[individual] ancestors.add(individual) return ancestors def find_cca(tree, individual1, individual2): Given a tree (dictionary) and two individuals, this function returns the closest common ancestor (CCA) of the two individuals. ancestors1 = find_ancestors(tree, individual1) ancestors2 = find_ancestors(tree, individual2) common_ancestors = ancestors1.intersection(ancestors2) # Return the closest common ancestor by checking the shortest path for ancestor in [individual1] + [tree.get(individual1)] + [tree.get(tree.get(individual1))]: if ancestor in common_ancestors: return ancestor return \\"No common ancestor\\" def closest_common_ancestor(n, relationships, individual1, individual2): Given the number of relationships (n), a list of relationships, and two individuals, this function returns the closest common ancestor (CCA) of the two individuals. >>> closest_common_ancestor(8, [(\\"Adam\\", \\"Bob\\"), (\\"Adam\\", \\"Charlie\\"), (\\"Bob\\", \\"David\\"), (\\"Bob\\", \\"Ellen\\"), (\\"Charlie\\", \\"Frank\\"), (\\"Charlie\\", \\"Grace\\"), (\\"Ellen\\", \\"Henry\\"), (\\"Ellen\\", \\"Isaac\\")], 'David', 'Henry') 'Bob' >>> closest_common_ancestor(8, [(\\"Adam\\", \\"Bob\\"), (\\"Adam\\", \\"Charlie\\"), (\\"Bob\\", \\"David\\"), (\\"Bob\\", \\"Ellen\\"), (\\"Charlie\\", \\"Frank\\"), (\\"Charlie\\", \\"Grace\\"), (\\"Ellen\\", \\"Henry\\"), (\\"Ellen\\", \\"Isaac\\")], 'Frank', 'David') 'Adam' tree = {} for parent, child in relationships: tree[child] = parent return find_cca(tree, individual1, individual2)","solution":"def find_ancestors(tree, individual): ancestors = set() while individual in tree: individual = tree[individual] ancestors.add(individual) return ancestors def find_cca(tree, individual1, individual2): ancestors1 = find_ancestors(tree, individual1) ancestors2 = find_ancestors(tree, individual2) common_ancestors = ancestors1.intersection(ancestors2) # Return the closest common ancestor by checking the shortest path for ancestor in [individual1] + [tree.get(individual1)] + [tree.get(tree.get(individual1))]: if ancestor in common_ancestors: return ancestor return \\"No common ancestor\\" def closest_common_ancestor(n, relationships, individual1, individual2): tree = {} for parent, child in relationships: tree[child] = parent return find_cca(tree, individual1, individual2) # Example usage input_data = [ (8, [(\\"Adam\\", \\"Bob\\"), (\\"Adam\\", \\"Charlie\\"), (\\"Bob\\", \\"David\\"), (\\"Bob\\", \\"Ellen\\"), (\\"Charlie\\", \\"Frank\\"), (\\"Charlie\\", \\"Grace\\"), (\\"Ellen\\", \\"Henry\\"), (\\"Ellen\\", \\"Isaac\\"), (\\"David\\", \\"Henry\\")], \\"David\\", \\"Henry\\") ] for n, relationships, individual1, individual2 in input_data: print(closest_common_ancestor(n, relationships, individual1, individual2))"},{"question":"def longest_word_length(s: str) -> int: Returns the length of the longest word that can be formed using some or all of the letters of the string without repeating any letters. >>> longest_word_length(\\"abcabc\\") == 3 >>> longest_word_length(\\"a\\") == 1 >>> longest_word_length(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 >>> longest_word_length(\\"aaaaa\\") == 1 >>> longest_word_length(\\"aabbccddeeff\\") == 6 >>> longest_word_length(\\"\\") == 0 # edge case: though input length >= 1 >>> longest_word_length(\\"a\\" * 100000) == 1 # Large input case with a single repeated character","solution":"def longest_word_length(s): Returns the length of the longest word that can be formed using some or all of the letters of the string without repeating any letters. return len(set(s))"},{"question":"def smallest_subarray_with_sum(n: int, t: int, arr: List[int]) -> int: Finds the length of the smallest subarray with a sum greater than or equal to t. If no such subarray exists, returns -1. :param n: int - the number of elements in the array :param t: int - the target sum :param arr: list of int - the array of integers :return: int - length of the smallest subarray or -1 if no such subarray exists >>> smallest_subarray_with_sum(5, 11, [1, 2, 3, 4, 5]) == 3 >>> smallest_subarray_with_sum(4, 15, [1, 10, 5, 2]) == 2 >>> smallest_subarray_with_sum(4, 20, [1, 2, 3, 4]) == -1 from solution import smallest_subarray_with_sum def test_smallest_subarray_with_sum_example_1(): assert smallest_subarray_with_sum(5, 11, [1, 2, 3, 4, 5]) == 3 def test_smallest_subarray_with_sum_example_2(): assert smallest_subarray_with_sum(4, 15, [1, 10, 5, 2]) == 2 def test_smallest_subarray_with_sum_example_3(): assert smallest_subarray_with_sum(4, 20, [1, 2, 3, 4]) == -1 def test_smallest_subarray_with_sum_edge_case_1(): assert smallest_subarray_with_sum(1, 1, [1]) == 1 def test_smallest_subarray_with_sum_edge_case_2(): assert smallest_subarray_with_sum(1, 2, [1]) == -1 def test_smallest_subarray_with_sum_large_numbers(): assert smallest_subarray_with_sum(5, 25, [5, 5, 5, 5, 5]) == 5 def test_smallest_subarray_with_sum_single_element(): assert smallest_subarray_with_sum(1, 10000, [10000]) == 1","solution":"def smallest_subarray_with_sum(n, t, arr): Finds the length of the smallest subarray with a sum greater than or equal to t. If no such subarray exists, returns -1. :param n: int - the number of elements in the array :param t: int - the target sum :param arr: list of int - the array of integers :return: int - length of the smallest subarray or -1 if no such subarray exists current_sum = 0 start = 0 min_length = float('inf') for end in range(n): current_sum += arr[end] while current_sum >= t: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"import heapq from typing import List def min_reading_time(n: int, times: List[int]) -> int: Alice loves reading books, and she also likes to organize her bookshelf optimally. Given the number of books on her shelf and the time to read each book, Alice wants to determine the minimum time required to read all the books if she reads them in the most optimal order. You are given a list of integers where each integer represents the time (in minutes) it takes to read each book. Alice can read books in any order but wants to minimize the sum of the reading times. Alice employs the following strategy: She reads the two shortest unread books first, then replaces them with a single book whose reading time is the sum of the two she just read. She repeats this process until only one unread book remains. The total time spent reading is the sum of the time spent on all these book reading sessions. Args: n (int): The number of books on Alice’s shelf. times (List[int]): A list of integers where the i-th integer represents the time needed to read the i-th book. Returns: int: The minimum total reading time for all books using Alice’s strategy. >>> min_reading_time(4, [4, 3, 2, 6]) 29 >>> min_reading_time(2, [5, 3]) 8","solution":"import heapq def min_reading_time(n, times): if n == 1: return times[0] heapq.heapify(times) total_time = 0 while len(times) > 1: first = heapq.heappop(times) second = heapq.heappop(times) combined_time = first + second total_time += combined_time heapq.heappush(times, combined_time) return total_time"},{"question":"def find_safest_route(n: int, m: int, u: int, v: int, roads: List[Tuple[int, int, int]]) -> int: Determine the minimum number of dangerous roads the king needs to travel through to reach the target castle. >>> find_safest_route(5, 6, 1, 5, [(1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0), (1, 4, 1), (2, 5, 1)]) == 1 >>> find_safest_route(4, 3, 1, 4, [(1, 2, 0), (2, 3, 0), (3, 4, 1)]) == 1 >>> find_safest_route(3, 2, 1, 3, [(1, 2, 0), (2, 1, 0)]) == -1 pass def handle_input(data: List[Tuple]) -> List[int]: Handle multiple datasets and return a list of results. pass def test_find_safest_route(): # Test case 1 n, m = 5, 6 u, v = 1, 5 roads = [ (1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0), (1, 4, 1), (2, 5, 1) ] assert find_safest_route(n, m, u, v, roads) == 1 # Test case 2 n, m = 4, 3 u, v = 1, 4 roads = [ (1, 2, 0), (2, 3, 0), (3, 4, 1) ] assert find_safest_route(n, m, u, v, roads) == 1 # Test case 3 - Impossible case n, m = 3, 2 u, v = 1, 3 roads = [ (1, 2, 0), (2, 1, 0) ] assert find_safest_route(n, m, u, v, roads) == -1 def test_handle_input(): data = [ (5, 6), (1, 5), (1, 2, 1), (2, 3, 0), (3, 4, 1), (4, 5, 0), (1, 4, 1), (2, 5, 1), (4, 3), (1, 4), (1, 2, 0), (2, 3, 0), (3, 4, 1), (0, 0) ] expected_output = [1, 1] assert handle_input(data) == expected_output","solution":"import heapq def find_safest_route(n, m, u, v, roads): graph = {i: [] for i in range(1, n + 1)} for x, y, d in roads: graph[x].append((y, d)) graph[y].append((x, d)) # Dijkstra's algorithm to find the minimum dangerous roads heap = [(0, u)] visited = {i: float('inf') for i in range(1, n + 1)} visited[u] = 0 while heap: dangerous_roads, current_castle = heapq.heappop(heap) if current_castle == v: return dangerous_roads for neighbor, danger in graph[current_castle]: new_dangerous_roads = dangerous_roads + danger if new_dangerous_roads < visited[neighbor]: visited[neighbor] = new_dangerous_roads heapq.heappush(heap, (new_dangerous_roads, neighbor)) return -1 # Function to handle multiple datasets def handle_input(data): results = [] i = 0 while i < len(data): n, m = data[i] if n == 0 and m == 0: break u, v = data[i + 1] roads = data[i + 2:i + 2 + m] result = find_safest_route(n, m, u, v, roads) results.append(result) i += 2 + m return results"},{"question":"def find_unique_pairs(n: int, array: List[int], target: int) -> str: Given an array of positive integers and a target integer, find all unique pairs of numbers in the array that add up to the target integer. Pairs should be printed in ascending order of their first element, and if the first elements are the same, then by the second element. If there are no such pairs, return \\"-1\\". Args: n (int): The size of the array. array (List[int]): An array of positive integers. target (int): The target integer. Returns: str: A string representation of unique pairs adding up to the target or \\"-1\\" if no such pairs exist. >>> find_unique_pairs(5, [1, 2, 3, 4, 5], 5) \\"1 4n2 3\\" >>> find_unique_pairs(6, [1, 1, 2, 3, 4, 4], 8) \\"4 4\\" >>> find_unique_pairs(4, [1, 2, 3, 9], 10) \\"1 9\\" >>> find_unique_pairs(3, [1, 5, 7], 10) \\"-1\\" >>> find_unique_pairs(2, [5, 5], 10) \\"5 5\\" >>> find_unique_pairs(6, [10**9, 10**9, 5, 10**9 - 5, 1, 2], 10**9 + 1) \\"1 1000000000\\"","solution":"def find_unique_pairs(n, array, target): Find all unique pairs in array that add up to the target. array.sort() pairs = set() seen = {} for num in array: complement = target - num if complement in seen: pair = tuple(sorted((complement, num))) pairs.add(pair) seen[num] = True if not pairs: return \\"-1\\" result = 'n'.join(f\\"{x} {y}\\" for x, y in sorted(pairs)) return result"},{"question":"from typing import List def longest_increasing_sequence(n: int, heights: List[int]) -> int: Compute the length of the longest sequence of consecutive buildings where each building is taller than the previous one. >>> longest_increasing_sequence(6, [1, 2, 2, 3, 4, 1]) 3 >>> longest_increasing_sequence(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_sequence(10, [1, 2, 3, 1, 2, 3, 4, 5, 1, 2]) 5","solution":"def longest_increasing_sequence(n, heights): if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if heights[i] > heights[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def tickets_bought(n: int, k: int, people: List[Tuple[int, int]]) -> int: Calculate the number of people who will successfully buy a ticket given their speeds and patience levels. Args: n (int): The number of people in the queue. k (int): The ticket processing time. people (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers s_i and p_i, the speed at which the person buys the ticket and their patience level. Returns: int: The number of people who successfully buy a ticket. Examples: >>> tickets_bought(5, 2, [(3, 4), (2, 5), (1, 3), (4, 6), (2, 4)]) == 3 >>> tickets_bought(4, 2, [(3, 2), (2, 3), (4, 3), (5, 1)]) == 0 >>> tickets_bought(3, 2, [(1, 10), (1, 10), (1, 10)]) == 3 >>> tickets_bought(5, 2, [(2, 3), (1, 4), (3, 3), (1, 1), (2, 2)]) == 2 >>> tickets_bought(1, 2, [(3, 5)]) == 1 >>> tickets_bought(1, 2, [(3, 1)]) == 0","solution":"def tickets_bought(n, k, people): successful_count = 0 for i in range(n): buy_time, patience = people[i] if patience >= (buy_time * (i + 1)): successful_count += 1 return successful_count # Example usage: # n = 5, k = 2 # people = [(3, 4), (2, 5), (1, 3), (4, 6), (2, 4)] # The output should be 3 n = 5 k = 2 people = [(3, 4), (2, 5), (1, 3), (4, 6), (2, 4)] print(tickets_bought(n, k, people)) # Expected output is 3"},{"question":"def magical_plant_growth(N: int) -> (int, int): Simulate the growth of a magical plant. The plant starts with 1 stem of length 1 and 1 leaf on the first day. During leaf growth days (odd days), the plant grows by tripling the number of leaves. During stem growth days (even days), the plant grows by doubling the stem length. :param N: Number of days to simulate the growth. :return: A tuple containing the total number of leaves and the total stem length after N days. >>> magical_plant_growth(1) (3, 1) >>> magical_plant_growth(4) (9, 4) >>> magical_plant_growth(7) (81, 8) pass def process_test_cases(T: int, test_cases: list) -> list: Process multiple test cases for the magical plant growth simulation. :param T: The number of test cases. :param test_cases: A list containing the number of days for each test case. :return: A list containing the results for each test case in the format \\"leaves stem_length\\". >>> T = 3 >>> test_cases = [1, 4, 7] >>> process_test_cases(T, test_cases) [\\"3 1\\", \\"9 4\\", \\"81 8\\"] pass","solution":"def magical_plant_growth(N): leaves = 1 stem_length = 1 for day in range(1, N + 1): if day % 2 != 0: # Odd days: leaf growth leaves *= 3 else: # Even days: stem growth stem_length *= 2 return leaves, stem_length def process_test_cases(T, test_cases): results = [] for N in test_cases: leaves, stem_length = magical_plant_growth(N) results.append(f\\"{leaves} {stem_length}\\") return results"},{"question":"from typing import List, Tuple def can_accommodate_employees(num_cases: int, cases: List[Tuple[int, int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if it is possible to accommodate all employees within the budget for multiple test cases. Args: num_cases (int): The number of test cases. cases (List[Tuple[int, int, int, List[Tuple[int, int]]]]): Each test case containing the number of employees, the budget, the number of different activities, and the details of each activity. Returns: List[str]: \\"Yes\\" or \\"No\\" for each test case indicating if it is possible to organize the event. Example: >>> can_accommodate_employees(1, [(10, 1000, 3, [(150, 5), (200, 10), (300, 5)])]) [\\"Yes\\"] >>> can_accommodate_employees(1, [(4, 500, 2, [(200, 2), (300, 3)])]) [\\"No\\"] >>> can_accommodate_employees(1, [(50, 100, 1, [(1000, 100)])]) [\\"No\\"] >>> can_accommodate_employees(3, [(10, 1000, 3, [(150, 5), (200, 10), (300, 5)]), (4, 500, 2, [(200, 2), (300, 3)]), (50, 100, 1, [(1000, 100)])]) [\\"Yes\\", \\"No\\", \\"No\\"] >>> can_accommodate_employees(1, [(500, 1000000, 1, [(1000000, 1000)])]) [\\"Yes\\"]","solution":"def can_accommodate_employees(num_cases, cases): results = [] for case in cases: n, b, k, activities = case possible = False for cost, max_participants in activities: if max_participants >= n and b >= cost: possible = True break results.append(\\"Yes\\" if possible else \\"No\\") return results # Example usage: if __name__ == \\"__main__\\": t = 3 cases = [ (10, 1000, 3, [(150, 5), (200, 10), (300, 5)]), (4, 500, 2, [(200, 2), (300, 3)]), (50, 100, 1, [(1000, 100)]), ] results = can_accommodate_employees(t, cases) for result in results: print(result)"},{"question":"def minimum_buses_required(schedule): Determine the minimum number of buses required to operate the given schedule without any delays. schedule: List of tuples containing departure and arrival times for each bus trip. Each tuple is formatted as (\\"hh:mm:ss\\", \\"hh:mm:ss\\"). Returns: An integer representing the minimum number of buses required.","solution":"from heapq import heappush, heappop from datetime import datetime def minimum_buses_required(schedule): Determine the minimum number of buses required to operate the given schedule without any delays. schedule: List of tuples containing departure and arrival times for each bus trip. Each tuple is formatted as (\\"hh:mm:ss\\", \\"hh:mm:ss\\"). Returns: An integer representing the minimum number of buses required. if not schedule: return 0 # Convert time string to datetime object to make it easy to compare times def convert_time(t): return datetime.strptime(t, \\"%H:%M:%S\\") # Transform the schedule into a list of (departure, arrival) tuples with datetime objects trips = [(convert_time(dep), convert_time(arr)) for dep, arr in schedule] # Sort trips by departure time trips.sort(key=lambda x: x[0]) min_heap = [] buses_required = 0 for dep, arr in trips: # Remove buses that have returned and are available for a new trip while min_heap and min_heap[0] <= dep: heappop(min_heap) # Add the current bus trip's arrival time to the heap heappush(min_heap, arr) # The size of the heap represents the number of concurrent buses needed buses_required = max(buses_required, len(min_heap)) return buses_required"},{"question":"def min_operations(S: str, T: str) -> int: Returns the minimum number of operations required to transform S into T, where the operations allowed are: 1. Replace a character in S with another lowercase alphabet character. 2. Delete a character from S. 3. Insert a character into S. >>> min_operations(\\"kitten\\", \\"sitting\\") 3 >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"\\", \\"nonempty\\") 8 >>> min_operations(\\"nonempty\\", \\"\\") 8 >>> min_operations(\\"same\\", \\"same\\") 0 >>> min_operations(\\"a\\", \\"b\\") 1 >>> min_operations(\\"a\\", \\"ab\\") 1 >>> min_operations(\\"a\\", \\"ba\\") 1 >>> min_operations(\\"ab\\", \\"a\\") 1 >>> min_operations(\\"ab\\", \\"b\\") 1","solution":"def min_operations(S, T): Returns the minimum number of operations required to transform S into T. len_s, len_t = len(S), len(T) dp = [[0] * (len_t + 1) for _ in range(len_s + 1)] for i in range(len_s + 1): for j in range(len_t + 1): if i == 0: dp[i][j] = j # Inserting all characters of T elif j == 0: dp[i][j] = i # Deleting all characters of S else: if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j - 1], # Replace dp[i - 1][j], # Delete dp[i][j - 1]) # Insert return dp[len_s][len_t]"},{"question":"def cumulative_growth(test_cases): Calculate the cumulative growth of each plant over a specified time span. >>> cumulative_growth([{'N': 3, 'growth_rates': [5, 3, 2], 'D': 7}]) [[35, 21, 14]] >>> cumulative_growth([{'N': 2, 'growth_rates': [10, 15], 'D': 10}]) [[100, 150]]","solution":"def cumulative_growth(test_cases): results = [] for case in test_cases: N = case['N'] growth_rates = case['growth_rates'] D = case['D'] total_growth = [rate * D for rate in growth_rates] results.append(total_growth) return results"},{"question":"def process_transactions(transactions): Processes a list of library transactions to determine the current status of borrowed books. Parameters: transactions (list of str): List of transaction strings. Returns: list of str: A list of strings representing the current status of borrowed books. pass import pytest def test_process_transactions_example(): transactions = [ \\"BORROW 123 Alice\\", \\"BORROW 456 Bob\\", \\"RETURN 123\\", \\"BORROW 789 Carol\\", \\"BORROW 123 David\\", \\"RETURN 456\\" ] assert process_transactions(transactions) == [\\"123: David\\", \\"789: Carol\\"] def test_process_transactions_all_returned(): transactions = [ \\"BORROW 123 Alice\\", \\"RETURN 123\\", \\"BORROW 456 Bob\\", \\"RETURN 456\\", \\"BORROW 789 Carol\\", \\"RETURN 789\\" ] assert process_transactions(transactions) == [\\"No books are currently borrowed.\\"] def test_process_transactions_no_returns(): transactions = [ \\"BORROW 123 Alice\\", \\"BORROW 456 Bob\\", \\"BORROW 789 Carol\\" ] assert process_transactions(transactions) == [\\"123: Alice\\", \\"456: Bob\\", \\"789: Carol\\"] def test_process_transactions_empty(): transactions = [] assert process_transactions(transactions) == [\\"No books are currently borrowed.\\"] def test_process_transactions_multiple_borrows_same_book(): transactions = [ \\"BORROW 123 Alice\\", \\"BORROW 123 Bob\\", \\"BORROW 123 Carol\\" ] assert process_transactions(transactions) == [\\"123: Carol\\"] def test_process_transactions_random_order(): transactions = [ \\"BORROW 789 Carol\\", \\"RETURN 789\\", \\"BORROW 456 Bob\\", \\"BORROW 123 Alice\\" ] assert process_transactions(transactions) == [\\"123: Alice\\", \\"456: Bob\\"] def test_process_transactions_non_sequential(): transactions = [ \\"BORROW 456 Bob\\", \\"BORROW 123 Alice\\", \\"RETURN 123\\", \\"BORROW 789 Carol\\", \\"RETURN 456\\" ] assert process_transactions(transactions) == [\\"789: Carol\\"]","solution":"def process_transactions(transactions): Processes a list of library transactions to determine the current status of borrowed books. Parameters: transactions (list of str): List of transaction strings. Returns: list of str: A list of strings representing the current status of borrowed books. borrowed_books = {} for transaction in transactions: parts = transaction.split() action = parts[0] book_id = int(parts[1]) if action == \\"BORROW\\": patron_name = parts[2] borrowed_books[book_id] = patron_name elif action == \\"RETURN\\": if book_id in borrowed_books: del borrowed_books[book_id] if not borrowed_books: return [\\"No books are currently borrowed.\\"] result = [f\\"{book_id}: {patron_name}\\" for book_id, patron_name in sorted(borrowed_books.items())] return result"},{"question":"def maxSubgridSum(n: int, m: int, K: int, grid: List[List[int]]) -> int: You are given an n x m grid filled with non-negative integers. You need to help Alice find the maximum sum of a sub-grid located in the top-left corner that contains exactly K cells. Alice can choose any contiguous sub-grid with K cells, but it should include the top-left cell (i.e., cell at position (1, 1)). Args: n : int : Number of rows in the grid. m : int : Number of columns in the grid. K : int : Number of cells that should be included in the sub-grid. grid : List[List[int]] : A 2D list of integers representing the grid. Returns: int : Maximum sum of the sub-grid with K cells starting from the top-left corner. Examples: >>> maxSubgridSum(3, 3, 4, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 12 >>> maxSubgridSum(1, 1, 1, [[5]]) 5","solution":"def maxSubgridSum(n, m, K, grid): max_sum = -float('inf') for height in range(1, n + 1): for width in range(1, m + 1): if height * width == K: current_sum = 0 for i in range(height): for j in range(width): current_sum += grid[i][j] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def generate_sequence(N: int, G: int) -> List[int]: Constructs a sequence of N integers such that the GCD of any pair is exactly G. Args: N : int : Number of elements in the sequence. G : int : Desired GCD of the sequence. Returns: list[int]: A list of N integers with the desired GCD property. Examples -------- >>> generate_sequence(3, 2) [2, 4, 6] >>> generate_sequence(5, 10) [10, 20, 30, 40, 50]","solution":"def generate_sequence(N, G): Generates a sequence of N integers such that the GCD of any pair is G. Args: N : int : Number of elements in the sequence. G : int : Desired GCD of the sequence. Returns: list[int]: A list of N integers with the desired GCD property. sequence = [G * i for i in range(1, N + 1)] return sequence"},{"question":"def sum_of_scores(n: int, m: int, scores: List[List[int]], q: int, queries: List[Tuple[int, int, int]]) -> List[int]: Calculates the sum of scores of a specified participant within a given range of days for each query. Args: n (int): Number of participants. m (int): Number of days. scores (list of list of int): Score matrix of size n x m. q (int): Number of queries. queries (list of tuple): List of queries where each query is (pi, di, dj). Returns: list of int: List containing result for each query. # Implementation here from typing import List, Tuple from solution import sum_of_scores def test_simple_case(): n = 3 m = 5 scores = [ [10, 20, 30, 40, 50], [5, 15, 25, 35, 45], [100, 200, 300, 400, 500] ] q = 2 queries = [(1, 1, 3), (3, 2, 4)] result = sum_of_scores(n, m, scores, q, queries) assert result == [60, 900] def test_single_day_range(): n = 2 m = 4 scores = [ [10, 20, 30, 40], [5, 15, 25, 35] ] q = 2 queries = [(1, 3, 3), (2, 1, 1)] result = sum_of_scores(n, m, scores, q, queries) assert result == [30, 5] def test_full_range(): n = 2 m = 3 scores = [ [1, 2, 3], [4, 5, 6] ] q = 2 queries = [(1, 1, 3), (2, 1, 3)] result = sum_of_scores(n, m, scores, q, queries) assert result == [6, 15] def test_multiple_queries(): n = 3 m = 3 scores = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] q = 3 queries = [(1, 1, 2), (2, 2, 3), (3, 1, 3)] result = sum_of_scores(n, m, scores, q, queries) assert result == [3, 11, 24]","solution":"def sum_of_scores(n, m, scores, q, queries): Calculates the sum of scores of a specified participant within a given range of days for each query. Args: n (int): Number of participants. m (int): Number of days. scores (list of list of int): Score matrix of size n x m. q (int): Number of queries. queries (list of tuple): List of queries where each query is (pi, di, dj). Returns: list of int: List containing result for each query. results = [] # Process each query for pi, di, dj in queries: # Convert to zero-based index pi -= 1 di -= 1 dj -= 1 # Calculate the sum for the given range. query_sum = sum(scores[pi][di:dj + 1]) results.append(query_sum) return results"},{"question":"def generate_palindromic_numbers(a: int, b: int): Returns a list of all palindromic numbers between a and b (inclusive). If there are no palindromic numbers, return \\"No palindromic numbers\\". >>> generate_palindromic_numbers(10, 50) [11, 22, 33, 44] >>> generate_palindromic_numbers(130, 140) [131] >>> generate_palindromic_numbers(123, 128) \\"No palindromic numbers\\" >>> generate_palindromic_numbers(121, 121) [121] >>> generate_palindromic_numbers(1, 1000) [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 22, 33, 44, 55, 66, 77, 88, 99, 101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]","solution":"def generate_palindromic_numbers(a, b): Returns a list of all palindromic numbers between a and b (inclusive). If there are no palindromic numbers, return \\"No palindromic numbers\\". palindromic_numbers = [] for num in range(a, b + 1): if str(num) == str(num)[::-1]: palindromic_numbers.append(num) if palindromic_numbers: return palindromic_numbers else: return \\"No palindromic numbers\\""},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Returns the number of distinct palindromic substrings in the given string s. >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 def process_test_cases(input_data: List[str]) -> List[int]: Process the test cases and return the results as a list of integers. >>> process_test_cases([\\"2\\", \\"ababa\\", \\"abc\\"]) [5, 3] >>> process_test_cases([\\"3\\", \\"aaa\\", \\"a\\", \\"racecar\\"]) [3, 1, 7]","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the given string s. def is_palindrome(sub): return sub == sub[::-1] distinct_palindromes = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substring = s[i:j] if is_palindrome(substring): distinct_palindromes.add(substring) return len(distinct_palindromes) def process_test_cases(input_data): T = int(input_data[0]) results = [] for i in range(1, T + 1): s = input_data[i] result = count_distinct_palindromic_substrings(s) results.append(result) return results # Function for receiving the input and printing the results. def main(): import sys input_data = sys.stdin.read().strip().split() results = process_test_cases(input_data) for result in results: print(result)"},{"question":"def transform_list(n: int, arr: List[int]) -> Union[List[int], int]: Given a list of integers, transform it into a sequence where every odd index (1-based) contains an odd number and every even index (1-based) contains an even number. If multiple solutions exist, return any of them. If it's not possible, return \`-1\`. Args: n : int : length of the list arr : List[int] : list of space-separated integers Returns: Union[List[int], int] : transformed list or -1 if transformation is not possible >>> transform_list(5, [3, 8, 5, 2, 1]) [3, 8, 5, 2, 1] >>> transform_list(4, [2, 2, 2, 2]) -1 >>> transform_list(6, [1, 2, 3, 4, 5, 6]) [1, 2, 3, 4, 5, 6] from solution import transform_list def test_valid_case1(): assert transform_list(5, [3, 8, 5, 2, 1]) == [3, 8, 5, 2, 1] def test_valid_case2(): result = transform_list(6, [1, 2, 3, 4, 5, 6]) expected_outputs = [ [1, 2, 3, 4, 5, 6], [3, 2, 5, 4, 1, 6], [5, 2, 1, 4, 3, 6] ] assert any(result == eo for eo in expected_outputs) def test_invalid_case(): assert transform_list(4, [2, 2, 2, 2]) == -1 def test_minimum_length(): assert transform_list(1, [1]) == [1] def test_one_even_one_odd(): assert transform_list(2, [2, 1]) == [1, 2] def test_more_odds_than_evens(): assert transform_list(4, [1, 3, 5, 7]) == -1 def test_more_evens_than_odds(): assert transform_list(4, [2, 4, 6, 8]) == -1 def test_mixed_elements(): result = transform_list(4, [1, 4, 2, 3]) expected_outputs = [ [1, 4, 3, 2], [3, 4, 1, 2] ] assert any(result == eo for eo in expected_outputs)","solution":"def transform_list(n, arr): odd_indices = [x for x in arr if x % 2 == 1] even_indices = [x for x in arr if x % 2 == 0] if len(odd_indices) >= (n + 1) // 2 and len(even_indices) >= n // 2: result = [0] * n odd_position = 0 even_position = 1 for odd in odd_indices: if odd_position < n: result[odd_position] = odd odd_position += 2 for even in even_indices: if even_position < n: result[even_position] = even even_position += 2 return result else: return -1"},{"question":"def find_winner(N: int, M: int) -> str: Determines the winner of the game given the dimensions of the grid (N x M). Alice always starts first. Returns \\"Alice\\" if Alice has a winning strategy, otherwise \\"Bob\\". >>> find_winner(3, 2) 'Alice' >>> find_winner(4, 4) 'Bob' >>> find_winner(5, 3) 'Alice'","solution":"def find_winner(N, M): Determines the winner of the game given the dimensions of the grid (N x M). Alice always starts first. Returns \\"Alice\\" if Alice has a winning strategy, otherwise \\"Bob\\". # Alice has a winning strategy if either N or M is odd because then she # can always force Bob into a previously visited cell first. if N % 2 == 1 or M % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of distinct non-empty palindromic substrings of the given string s. >>> count_palindromic_substrings(\\"abba\\") 4 >>> count_palindromic_substrings(\\"abcd\\") 4 >>> count_palindromic_substrings(\\"a\\") 1 >>> count_palindromic_substrings(\\"aaaa\\") 4 >>> count_palindromic_substrings(\\"aabaa\\") 5 >>> count_palindromic_substrings(\\"racecar\\") 7 >>> count_palindromic_substrings(\\"xyz\\") 3","solution":"def count_palindromic_substrings(s): Returns the number of distinct non-empty palindromic substrings of the given string s. def is_palindrome(substr): return substr == substr[::-1] palindromes = set() length = len(s) for i in range(length): for j in range(i+1, length+1): substr = s[i:j] if is_palindrome(substr): palindromes.add(substr) return len(palindromes)"},{"question":"def min_reversals_to_balance(s: str) -> int: Returns the minimum number of reversals required to balance the brackets in string s. If it is not possible, returns -1. >>> min_reversals_to_balance(\\"}{\\") 2 >>> min_reversals_to_balance(\\"{{{\\") -1 >>> min_reversals_to_balance(\\"{{}{}}\\") 0 >>> min_reversals_to_balance(\\"{{{{{\\") -1","solution":"def min_reversals_to_balance(s): Returns the minimum number of reversals required to balance the brackets in string s. If it is not possible, returns -1. # Check if the length of the string is odd if len(s) % 2 != 0: return -1 # Stack to keep track of unbalanced brackets stack = [] # Traverse through the string for char in s: if char == '{': stack.append(char) else: # This is a closing bracket if stack and stack[-1] == '{': stack.pop() # Balanced part else: stack.append(char) # Unbalanced closing bracket # Now stack contains only unbalanced brackets unbalanced_len = len(stack) # Find number of '{' and '}' at the end of the array open_brackets = 0 while stack and stack[-1] == '{': stack.pop() open_brackets += 1 close_brackets = unbalanced_len - open_brackets # Minimum reversals required return (close_brackets // 2) + (open_brackets // 2) + (close_brackets % 2) + (open_brackets % 2)"},{"question":"def custom_sort(n: int, arr: List[int]) -> List[int]: Sort an array using Alice's CustomSort algorithm. The algorithm partitions the array into distinct groups of elements with the same value, sorts those groups by value in descending order, and then sorts each group internally in descending order. Args: n -- the number of elements in the array. arr -- the elements of the array. >> custom_sort(5, [4, 1, 2, 2, 4]) [4, 4, 2, 2, 1] >> custom_sort(3, [-1, 3, -1]) [3, -1, -1]","solution":"def custom_sort(n, arr): from collections import Counter counter = Counter(arr) sorted_unique_values = sorted(counter.keys(), reverse=True) result = [] for value in sorted_unique_values: result.extend([value] * counter[value]) return result"},{"question":"def max_boxes_collected(grid: List[List[int]]) -> int: Returns the maximum number of boxes that can be collected from the top-left to the bottom-right corner of the grid. :param grid: List[List[int]], the grid representing the number of boxes in each unit. :return: int, maximum number of boxes that can be collected. Example: >>> max_boxes_collected([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_boxes_collected([[1, 2], [3, 4]]) 8","solution":"def max_boxes_collected(grid): Returns the maximum number of boxes that can be collected from the top-left to the bottom-right corner of the grid. :param grid: List[List[int]], the grid representing the number of boxes in each unit. :return: int, maximum number of boxes that can be collected. n = len(grid) m = len(grid[0]) # DP table to store the maximum number of boxes collected up to each cell. dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the remainder of the DP table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right corner will have the maximum boxes collected return dp[-1][-1]"},{"question":"from typing import List, Tuple def longest_path_sum(n: int, m: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Compute the sum of values along the longest path in a directed acyclic graph (DAG). Args: n: Number of nodes in the graph. m: Number of edges in the graph. values: List of node values. edges: List of directed edges represented as tuples. Returns: The sum of values along the longest path in the graph. Example usage: >>> longest_path_sum(5, 6, [1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (1, 3), (4, 5), (2, 4)]) 15 >>> longest_path_sum(4, 3, [5, 3, 6, 2], [(1, 2), (2, 3), (3, 4)]) 16 >>> longest_path_sum(3, 2, [3, 2, 1], [(1, 2), (2, 3)]) 6 >>> longest_path_sum(1, 0, [10], []) 10 >>> longest_path_sum(5, 4, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)]) 150","solution":"from collections import defaultdict, deque def longest_path_sum(n, m, values, edges): graph = defaultdict(list) indegree = [0] * (n + 1) for u, v in edges: graph[u].append(v) indegree[v] += 1 topological_order = [] queue = deque() for i in range(1, n + 1): if indegree[i] == 0: queue.append(i) while queue: node = queue.popleft() topological_order.append(node) for neighbor in graph[node]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) dp = [0] * (n + 1) for node in topological_order: dp[node] = max(dp[node], values[node - 1]) for neighbor in graph[node]: dp[neighbor] = max(dp[neighbor], dp[node] + values[neighbor - 1]) return max(dp) # Example usage: n = 5 m = 6 values = [1, 2, 3, 4, 5] edges = [(1, 2), (2, 3), (3, 4), (1, 3), (4, 5), (2, 4)] print(longest_path_sum(n, m, values, edges)) # Output: 15"},{"question":"def can_unlock_all_locks(keys: List[int], locks: List[List[int]]) -> bool: Determines if the given set of keys can open all locks. :param keys: A list of integers representing the available keys. :param locks: A list of lists, where each inner list represents the keys that can open that specific lock. :return: True if all locks can be opened with the given keys, otherwise False. >>> can_unlock_all_locks([1, 2, 3, 4, 5], [[1, 2, 3], [4, 5], [1, 2, 3, 5]]) True >>> can_unlock_all_locks([1, 2, 3], [[1, 2, 3], [4, 5], [1, 2, 3, 5]]) False >>> can_unlock_all_locks([], [[1, 2], [3, 4]]) False >>> can_unlock_all_locks([1, 2, 3], []) True >>> can_unlock_all_locks([1], [[1, 2, 3]]) True >>> can_unlock_all_locks([3, 4], [[1, 2], [2, 3], [4, 5], [6, 3]]) False","solution":"from typing import List def can_unlock_all_locks(keys: List[int], locks: List[List[int]]) -> bool: Determines if the given set of keys can open all locks. :param keys: A list of integers representing the available keys. :param locks: A list of lists, where each inner list represents the keys that can open that specific lock. :return: True if all locks can be opened with the given keys, otherwise False. keys_set = set(keys) # Convert list to set for O(1) average time complexity on lookups for lock in locks: can_open = False for key in lock: if key in keys_set: can_open = True break if not can_open: return False return True"},{"question":"def word_pattern(pattern: str, sequence: str) -> str: Determines if a given sequence of words follows the same pattern. >>> word_pattern(\\"abba\\", \\"dog cat cat dog\\") \\"true\\" >>> word_pattern(\\"abba\\", \\"dog cat cat fish\\") \\"false\\" >>> word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") \\"true\\" def process_input(n: int, pattern: str, sequences: List[str]) -> List[str]: Processes multiple test cases to determine if each sequence of words follows the given pattern. >>> process_input(3, \\"abba\\", [\\"dog cat cat dog\\", \\"dog cat cat fish\\", \\"dog dog dog dog\\"]) [\\"true\\", \\"false\\", \\"true\\"] from typing import List def test_word_pattern_match(): assert word_pattern(\\"abba\\", \\"dog cat cat dog\\") == \\"true\\" assert word_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == \\"true\\" assert word_pattern(\\"abab\\", \\"red blue red blue\\") == \\"true\\" def test_word_pattern_mismatch(): assert word_pattern(\\"abba\\", \\"dog cat cat fish\\") == \\"false\\" assert word_pattern(\\"aaaa\\", \\"dog cat cat dog\\") == \\"false\\" assert word_pattern(\\"abba\\", \\"dog dog dog dog\\") == \\"false\\" def test_word_pattern_length_mismatch(): assert word_pattern(\\"aaaa\\", \\"dog dog dog\\") == \\"false\\" assert word_pattern(\\"a\\", \\"dog dog\\") == \\"false\\" def test_process_input(): n = 3 pattern = \\"abba\\" sequences = [ \\"dog cat cat dog\\", \\"dog cat cat fish\\", \\"dog dog dog dog\\" ] expected = [\\"true\\", \\"false\\", \\"true\\"] assert process_input(n, pattern, sequences) == expected n = 2 pattern = \\"abcd\\" sequences = [ \\"horse cat cow dog\\", \\"cat cat cat cat\\" ] expected = [\\"true\\", \\"false\\"] assert process_input(n, pattern, sequences) == expected","solution":"def word_pattern(pattern, sequence): words = sequence.split() if len(pattern) != len(words): return \\"false\\" char_to_word = {} word_to_char = {} for p, w in zip(pattern, words): if p not in char_to_word: if w in word_to_char: return \\"false\\" char_to_word[p] = w word_to_char[w] = p else: if char_to_word[p] != w: return \\"false\\" return \\"true\\" def process_input(n, pattern, sequences): results = [] for sequence in sequences: results.append(word_pattern(pattern, sequence)) return results"},{"question":"def can_complete_marathon(initial_stamina: int, path: str) -> str: Determines if Emma can complete the marathon given the initial stamina and path. Parameters: initial_stamina (int): Initial stamina Emma starts with. path (str): String representing the marathon path. Returns: str: \\"YES\\" if Emma can complete the marathon, \\"NO\\" otherwise. >>> can_complete_marathon(6, \\"RUSDDR\\") \\"YES\\" >>> can_complete_marathon(5, \\"RUUUD\\") \\"NO\\" >>> can_complete_marathon(3, \\"DDD\\") \\"YES\\" >>> can_complete_marathon(0, \\"R\\") \\"NO\\" >>> can_complete_marathon(0, \\"\\") \\"YES\\" >>> can_complete_marathon(100, \\"R\\" * 50 + \\"U\\" * 5) \\"YES\\"","solution":"def can_complete_marathon(initial_stamina, path): Determines if Emma can complete the marathon given the initial stamina and path. Parameters: initial_stamina (int): Initial stamina Emma starts with. path (str): String representing the marathon path. Returns: str: \\"YES\\" if Emma can complete the marathon, \\"NO\\" otherwise. stamina = initial_stamina for section in path: if section == 'R': stamina -= 1 elif section == 'S': stamina -= 2 elif section == 'U': stamina -= 3 elif section == 'D': stamina += 1 if stamina < 0: return \\"NO\\" return \\"YES\\""},{"question":"def can_form_palindrome(s: str) -> str: You are given a string \`s\` consisting of lowercase English letters and question marks (?). A question mark can be replaced by any lowercase English letter. Your task is to determine if it is possible to replace all the question marks in such a way that the resulting string becomes a palindrome. A palindrome is a string that reads the same forward and backward. If it is possible to transform \`s\` into a palindrome, print \\"YES\\" and the resulting palindrome. Otherwise, print \\"NO\\". If there are multiple possible answers, you may print any of them. Examples: >>> can_form_palindrome(\\"a?c\\") 'YESnaca' >>> can_form_palindrome(\\"??\\") 'YESnaa' >>> can_form_palindrome(\\"abc\\") 'NO'","solution":"def can_form_palindrome(s): n = len(s) s = list(s) # Convert the string to a list to modify it for i in range(n // 2): if s[i] == '?' and s[n - 1 - i] == '?': s[i] = s[n - 1 - i] = 'a' elif s[i] == '?': s[i] = s[n - 1 - i] elif s[n - 1 - i] == '?': s[n - 1 - i] = s[i] elif s[i] != s[n - 1 - i]: return \\"NO\\" if n % 2 == 1 and s[n // 2] == '?': s[n // 2] = 'a' return \\"YESn\\" + \\"\\".join(s)"},{"question":"from typing import List def min_steps_to_exit_maze(m: int, n: int, grid: List[str]) -> int: Determines the minimum number of steps required for Sage to reach the bottom-right corner of the maze. Args: m (int): Number of rows in the grid. n (int): Number of columns in the grid. grid (List[str]): The maze representation where '.' is an open path and '#' is a wall. Returns: int: Minimum number of steps to reach the bottom-right corner, or -1 if it is impossible. >>> min_steps_to_exit_maze(4, 4, ['....', '..#.', '..#.', '....']) 6 >>> min_steps_to_exit_maze(3, 3, ['.#.', '#', '.#.']) -1 def test_min_steps_example1(): m, n = 4, 4 grid = [ '....', '..#.', '..#.', '....' ] assert min_steps_to_exit_maze(m, n, grid) == 6 def test_min_steps_example2(): m, n = 3, 3 grid = [ '.#.', '#', '.#.' ] assert min_steps_to_exit_maze(m, n, grid) == -1 def test_single_cell_open(): m, n = 1, 1 grid = ['.'] assert min_steps_to_exit_maze(m, n, grid) == 0 def test_single_cell_blocked(): m, n = 1, 1 grid = ['#'] assert min_steps_to_exit_maze(m, n, grid) == -1 def test_large_maze(): m, n = 5, 5 grid = [ '.....', '.#.', '.....', '.#.', '.....' ] assert min_steps_to_exit_maze(m, n, grid) == 8 def test_no_possible_path(): m, n = 3, 4 grid = [ '....', '', '....' ] assert min_steps_to_exit_maze(m, n, grid) == -1","solution":"from collections import deque def min_steps_to_exit_maze(m, n, grid): if grid[0][0] == '#' or grid[m-1][n-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # Store (row, col, steps) visited = [[False] * n for _ in range(m)] visited[0][0] = True while queue: row, col, steps = queue.popleft() if row == m - 1 and col == n - 1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < m and 0 <= new_col < n and not visited[new_row][new_col] and grid[new_row][new_col] == '.': queue.append((new_row, new_col, steps + 1)) visited[new_row][new_col] = True return -1"},{"question":"def max_readability_score(n: int, W: int, thicknesses: List[int], readability_scores: List[int]) -> int: Find the maximum readability score of a continuous subsequence of books that fit within given width W. >>> max_readability_score(5, 9, [2, 3, 1, 2, 4], [1, 4, 3, -2, 5]) 8 >>> max_readability_score(4, 5, [2, 2, 2, 2], [1, -1, 5, 3]) 8","solution":"def max_readability_score(n, W, thicknesses, readability_scores): max_score = float('-inf') current_score = 0 current_thickness = 0 start = 0 for end in range(n): current_thickness += thicknesses[end] current_score += readability_scores[end] while current_thickness > W: current_thickness -= thicknesses[start] current_score -= readability_scores[start] start += 1 max_score = max(max_score, current_score) return max_score"},{"question":"def trapWater(heights): Calculate the total units of water trapped between buildings. :param heights: List[int] - List of integers representing building heights :return: int - Total units of trapped water >>> trapWater([4, 2, 0, 3, 2, 5]) == 9 >>> trapWater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> trapWater([3, 0, 1, 3, 0, 5]) == 8 >>> trapWater([2, 0, 2]) == 2 >>> trapWater([]) == 0 >>> trapWater([0]) == 0 >>> trapWater([0, 0, 0]) == 0 >>> trapWater([3, 3, 3]) == 0 >>> trapWater([3, 0, 3]) == 3 >>> trapWater([9, 6, 8, 8, 5, 6, 3]) == 3","solution":"def trapWater(heights): Calculate the total units of water trapped between buildings. :param heights: List[int] - List of integers representing building heights :return: int - Total units of trapped water if not heights: return 0 n = len(heights) left_max = [0]*n right_max = [0]*n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def can_form_arithmetic_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine whether a given number sequence can be reordered to form a strictly increasing arithmetic sequence. A sequence is strictly increasing arithmetic if the difference between any two consecutive numbers is a positive constant. Parameters: t (int): the number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples containing the number of elements and the sequence of numbers for each test case. Returns: List[str]: \\"YES\\" if the sequence can be reordered to form a strictly increasing arithmetic sequence, otherwise \\"NO\\".","solution":"def can_form_arithmetic_sequence(t, test_cases): results = [] for case in test_cases: n, sequence = case sequence.sort() is_arithmetic = True common_difference = sequence[1] - sequence[0] for i in range(1, n): if sequence[i] - sequence[i-1] != common_difference: is_arithmetic = False break results.append(\\"YES\\" if is_arithmetic else \\"NO\\") return results"},{"question":"def process_events(events: List[str]) -> List[List[str]]: Process a series of events representing participants' submissions and calculate the ranking of participants based on their total score. Each submission increases a participant's score by the points specified in the submission. Args: events (List[str]): A list of events, where each event is either \\"SUBMIT x y\\" or \\"LEADERBOARD\\". Returns: List[List[str]]: A list of lists, each containing the leaderboard ranking for each \\"LEADERBOARD\\" event. Example: >>> process_events([\\"SUBMIT Alice 50\\", \\"SUBMIT Bob 20\\", \\"LEADERBOARD\\"]) [[\\"Alice 50\\", \\"Bob 20\\"]] >>> process_events([\\"SUBMIT Alice 50\\", \\"LEADERBOARD\\", \\"SUBMIT Bob 20\\", \\"LEADERBOARD\\"]) [[\\"Alice 50\\"], [\\"Alice 50\\", \\"Bob 20\\"]] # Function logic here","solution":"def process_events(events): participants = {} results = [] for event in events: if event.startswith(\\"SUBMIT\\"): parts = event.split() name = parts[1] score = int(parts[2]) if name in participants: participants[name] += score else: participants[name] = score elif event == \\"LEADERBOARD\\": if not participants: results.append([\\"No participants\\"]) else: leaderboard = sorted(participants.items(), key=lambda x: (-x[1], x[0])) results.append([f\\"{name} {score}\\" for name, score in leaderboard]) return results"},{"question":"from typing import List def min_preparation_time(n: int, k: int, prep_times: List[int]) -> int: Determine the minimum time required to prepare all items in an order given the constraints of working stations. Parameters: - n (int): The number of items in the order. - k (int): The number of working stations available. - prep_times (List[int]): List containing the preparation time for each item. Returns: - int: The minimum time required to prepare all items. Example: >>> min_preparation_time(8, 3, [4, 3, 2, 5, 7, 2, 1, 6]) 13 >>> min_preparation_time(1, 1, [5]) 5 >>> min_preparation_time(4, 1, [3, 6, 1, 8]) 18 >>> min_preparation_time(3, 5, [2, 5, 4]) 5 >>> min_preparation_time(5, 5, [1, 2, 3, 4, 5]) 5 >>> min_preparation_time(5, 2, [1, 3, 5, 7, 9]) 15","solution":"import heapq def min_preparation_time(n, k, prep_times): if k >= n: return max(prep_times) # Initialize a min-heap to simulate the working stations heap = [0] * k for time in prep_times: # Put the next item on the station that gets free the earliest heapq.heappush(heap, heapq.heappop(heap) + time) # The minimum time required will be the last time found in our heap return max(heap)"},{"question":"from typing import List, Tuple def find_duplicates(records: List[str]) -> List[object]: Identify and count duplicate entries based on the \`id\` field. Args: records (List[str]): A list of records in the format \\"id:name:value\\". Returns: List[object]: A list where the first element is the number of unique ids, followed by strings in the format \\"id:count\\" for each duplicate id. pass def parse_input(input_string: str) -> Tuple[int, List[str]]: Parse input string to extract number of records and the records themselves. Args: input_string (str): A string representing number of records followed by records each in the format \\"id:name:value\\". Returns: Tuple[int, List[str]]: Number of records and a list of records. pass def main(input_string: str) -> List[object]: Main function to execute the program logic. Args: input_string (str): A string representing number of records and the records. Returns: List[object]: A list where the first element is the number of unique ids, followed by strings in the format \\"id:count\\" for each duplicate id. pass # Example Test Cases import pytest def test_find_duplicates_single_record(): assert find_duplicates([\\"123:Alice:100\\"]) == [1] def test_find_duplicates_multiple_records(): assert find_duplicates([ \\"123:Alice:100\\", \\"124:Bob:200\\", \\"123:Carol:150\\", \\"125:Eve:-50\\", \\"123:Dave:120\\" ]) == [2, \\"123:3\\"] def test_find_duplicates_with_different_ids(): assert find_duplicates([ \\"abc:John:10\\", \\"xyz:Jane:20\\", \\"abc:Anna:30\\", \\"def:Tom:40\\", \\"xyz:Jerry:50\\", \\"ghi:Mick:60\\", \\"def:Nina:70\\" ]) == [1, \\"abc:2\\", \\"def:2\\", \\"xyz:2\\"] def test_main_example_input(): input_string = \\"5n123:Alice:100n124:Bob:200n123:Carol:150n125:Eve:-50n123:Dave:120\\" assert main(input_string) == [2, \\"123:3\\"] def test_parse_input(): input_string = \\"5n123:Alice:100n124:Bob:200n123:Carol:150n125:Eve:-50n123:Dave:120\\" n, records = parse_input(input_string) assert n == 5 assert records == [\\"123:Alice:100\\", \\"124:Bob:200\\", \\"123:Carol:150\\", \\"125:Eve:-50\\", \\"123:Dave:120\\"]","solution":"def find_duplicates(records): from collections import defaultdict id_count = defaultdict(int) for record in records: id_field = record.split(':')[0] id_count[id_field] += 1 unique_ids = [k for k, v in id_count.items() if v == 1] duplicate_ids = {k: v for k, v in id_count.items() if v > 1} result = [len(unique_ids)] for id, count in sorted(duplicate_ids.items()): result.append(f\\"{id}:{count}\\") return result def parse_input(input_string): input_lines = input_string.strip().split('n') n = int(input_lines[0].strip()) records = input_lines[1:] return n, records def main(input_string): n, records = parse_input(input_string) return find_duplicates(records)"},{"question":"def can_reach_exit(n: int, m: int, maze: List[List[str]]) -> str: Determine if Emilia can reach the exit ('E') from the starting point ('S') in the maze following the given rules. >>> can_reach_exit(5, 5, [['S', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '.', '.', '#', '.'], ['.', '#', '#', '#', '.'], ['.','.','.','.','E']]) \\"Yes\\" >>> can_reach_exit(3,3, [['S', '#', '.'], ['.', '#', 'E'], ['#', '#', '.']]) \\"No\\" >>> can_reach_exit(4, 4, [['S', '.', '#', '.'], ['#', '#', '#', '#'], ['.', '#', '.', '#'], ['.', '#', '.', 'E']]) \\"No\\" def test_case_1(): n = 5 m = 5 maze = [ list(\\"S....\\"), list(\\".#.\\"), list(\\"...#.\\"), list(\\".#.\\"), list(\\"....E\\"), ] assert can_reach_exit(n, m, maze) == \\"Yes\\" def test_case_2(): n = 3 m = 3 maze = [ list(\\"S#.\\"), list(\\".#E\\"), list(\\".\\") ] assert can_reach_exit(n, m, maze) == \\"No\\" def test_case_3(): n = 4 m = 4 maze = [ list(\\"S.#.\\"), list(\\"\\"), list(\\".#.E\\"), list(\\".#.#\\") ] assert can_reach_exit(n, m, maze) == \\"No\\"","solution":"def can_reach_exit(n, m, maze): def dfs(x, y): # If out of bounds or cell is a wall or already visited, return False if x < 0 or x >= n or y < 0 or y >= m or maze[x][y] == '#': return False # If it's the exit, return True if maze[x][y] == 'E': return True # Mark the current cell as visited by turning it into a wall maze[x][y] = '#' # Explore the 4 possible directions if dfs(x + 1, y) or dfs(x - 1, y) or dfs(x, y + 1) or dfs(x, y - 1): return True return False # Find the start point start_x, start_y = -1, -1 for i in range(n): for j in range(m): if maze[i][j] == 'S': start_x, start_y = i, j break if start_x != -1: break # Start DFS from the starting point if dfs(start_x, start_y): return \\"Yes\\" else: return \\"No\\""},{"question":"from typing import List, Tuple def longest_communication(n: int, messages: List[Tuple[int, int, int]]) -> int: Determine the length of the longest valid communication sequence between any two employees. >>> longest_communication(5, [(1, 1, 2), (2, 2, 1), (3, 1, 2), (4, 2, 1), (5, 3, 4)]) 4 >>> longest_communication(4, [(1, 1, 2), (2, 1, 3), (3, 2, 1), (4, 2, 3)]) 2","solution":"from collections import defaultdict def longest_communication(n, messages): # Dictionary to maintain sequences between pairs of employees sequences = defaultdict(int) # Sort messages by timestamp to process in order messages.sort() max_length = 0 for timestamp, sender, receiver in messages: # Use tuple with (min, max) to ensure unique pair representation pair = tuple(sorted((sender, receiver))) # Increase the sequence count for the current pair sequences[pair] += 1 # Update the max_length if a longer sequence is found max_length = max(max_length, sequences[pair]) return max_length # Example usage: # n = 5 # messages = [(1, 1, 2), (2, 2, 1), (3, 1, 2), (4, 2, 1), (5, 3, 4)] # print(longest_communication(n, messages)) # Output: 4"},{"question":"from typing import List def min_keys_to_reach_door(n: int, portals: List[int]) -> int: Determine the minimum number of keys required for Alice to reach door \`n\` from door \`1\` using the given portal connections. :param n: The number of doors in the hallway. :param portals: A list where the i-th integer represents the door that the i-th portal transports Alice to. :return: The minimum number of keys required to reach door \`n\` from door \`1\`, or -1 if it is impossible to reach door \`n\`. >>> min_keys_to_reach_door(5, [2, 3, 4, 5, 5]) 4 >>> min_keys_to_reach_door(4, [2, 3, 1, 3]) -1 >>> min_keys_to_reach_door(2, [2, 2]) 1 >>> min_keys_to_reach_door(3, [2, 1, 3]) -1 >>> min_keys_to_reach_door(6, [2, 3, 4, 5, 6, 1]) 5 >>> min_keys_to_reach_door(3, [1, 2, 3]) -1 >>> min_keys_to_reach_door(4, [4, 3, 2, 1]) 1 >>> min_keys_to_reach_door(5, [3, 1, 5, 4, 4]) 2","solution":"from collections import deque def min_keys_to_reach_door(n, portals): Returns the minimum number of keys required to reach door n or -1 if unreachable. visited = [False] * n queue = deque([(0, 0)]) # (current_door, keys_used) visited[0] = True while queue: current_door, keys_used = queue.popleft() if current_door == n - 1: return keys_used next_door = portals[current_door] - 1 if not visited[next_door]: visited[next_door] = True queue.append((next_door, keys_used + 1)) return -1"},{"question":"def earliest_completion_time(n: int, conveyor_belts: List[Tuple[int, int, int]]) -> int: Determine the earliest possible time at which all items will have successfully moved off the last conveyor belt. Parameters: n (int): The number of conveyor belts. conveyor_belts (List[Tuple[int, int, int]]): A list of tuples where each tuple contains three integers representing the maximum load capacity, operation time, and reactivation time of each conveyor belt. Returns: int: The earliest time at which all items have moved off the last conveyor belt. Examples: >>> earliest_completion_time(3, [(10, 5, 15), (12, 8, 20), (7, 4, 10)]) 37 >>> earliest_completion_time(2, [(8, 6, 12), (10, 3, 7)]) 18 pass # Example test cases def test_example_1(): n = 3 conveyor_belts = [ (10, 5, 15), (12, 8, 20), (7, 4, 10) ] assert earliest_completion_time(n, conveyor_belts) == 37 def test_example_2(): n = 2 conveyor_belts = [ (8, 6, 12), (10, 3, 7) ] assert earliest_completion_time(n, conveyor_belts) == 18 def test_minimal_input(): n = 1 conveyor_belts = [ (5, 2, 5) ] assert earliest_completion_time(n, conveyor_belts) == 2 def test_all_same_time(): n = 4 conveyor_belts = [ (8, 3, 10), (7, 3, 9), (6, 3, 11), (5, 3, 8) ] assert earliest_completion_time(n, conveyor_belts) == 12","solution":"def earliest_completion_time(n, conveyor_belts): total_time = 0 for i in range(n): c_i, t_i, r_i = conveyor_belts[i] total_time += t_i return total_time # Example usage: n = 3 conveyor_belts = [ (10, 5, 15), (12, 8, 20), (7, 4, 10) ] print(earliest_completion_time(n, conveyor_belts)) # Output: 37"},{"question":"def can_alice_guarantee_win(n: int) -> str: Determines if Alice can guarantee a win given the number n. Args: n (int): the initial number (1 ≤ n ≤ 10^9) Returns: str: \\"Alice wins\\" if Alice can guarantee a win, otherwise \\"Draw\\". >>> can_alice_guarantee_win(10) 'Draw' >>> can_alice_guarantee_win(23) 'Alice wins' >>> can_alice_guarantee_win(37) 'Alice wins' >>> can_alice_guarantee_win(25) 'Draw' >>> can_alice_guarantee_win(1) 'Alice wins' >>> can_alice_guarantee_win(2) 'Alice wins' >>> can_alice_guarantee_win(5) 'Draw' >>> can_alice_guarantee_win(9) 'Alice wins' >>> can_alice_guarantee_win(19) 'Alice wins'","solution":"def can_alice_guarantee_win(n): Determines if Alice can guarantee a win given the number n. if n % 10 == 0 or n % 10 == 5: return \\"Draw\\" else: return \\"Alice wins\\""},{"question":"def exists_path(N: int, M: int, grid: List[List[int]]) -> str: Determine if there is a path from the top-left intersection to the bottom-right intersection such that all traffic lights encountered on this path are green (false). >>> exists_path(3, 3, [ [0, 0, 1], [1, 0, 0], [1, 1, 0] ]) \\"YES\\" >>> exists_path(3, 3, [ [0, 1, 1], [1, 1, 0], [1, 1, 0] ]) \\"NO\\"","solution":"def exists_path(N, M, grid): def dfs(x, y): if x < 0 or x >= N or y < 0 or y >= M or grid[x][y] == 1: return False if (x, y) == (N-1, M-1): return True grid[x][y] = 1 # mark as visited return dfs(x+1, y) or dfs(x, y+1) or dfs(x-1, y) or dfs(x, y-1) if grid[0][0] == 1 or grid[N-1][M-1] == 1: return \\"NO\\" return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"def min_drones(n: int, weights: List[int], max_capacity: int) -> int: Determines the minimum number of drones required to deliver all the packages. Parameters: n (int): Number of packages. weights (List[int]): List of weights of the packages. max_capacity (int): Maximum weight capacity of a drone. Returns: int: Minimum number of drones required. >>> min_drones(5, [10, 20, 30, 40, 50], 100) 2 >>> min_drones(6, [70, 50, 80, 30, 20, 60], 150) 3","solution":"def min_drones(n, weights, max_capacity): Determines the minimum number of drones required to deliver all packages given the weights of the packages and the maximum weight capacity of a drone. Parameters: n (int): Number of packages. weights (list): List of integers representing the weight of each package. max_capacity (int): Maximum weight capacity of a drone. Returns: int: Minimum number of drones required. weights.sort(reverse=True) drones = 0 while weights: current_weight = 0 i = 0 while i < len(weights): if current_weight + weights[i] <= max_capacity: current_weight += weights.pop(i) else: i += 1 drones += 1 return drones"},{"question":"def num_islands(grid): Count the number of distinct islands in the given grid map. An island is formed by connecting neighboring land cells horizontally or vertically. Parameters: grid (List[List[str]]): A 2D grid map where 'L' represents land and 'W' represents water. Returns: int: Number of distinct islands. pass def count_islands(test_cases): Given multiple test cases with grid maps, count the number of distinct islands for each test case. Parameters: test_cases (List[List[str]]): A list where each element is a grid map represented as a list of strings. Returns: List[int]: A list where each element is the number of islands in the corresponding grid map. >>> count_islands([ ... [ ... \\"LWLLW\\", ... \\"LWLWW\\", ... \\"WWLWL\\", ... \\"LLWWW\\" ... ], ... [ ... \\"LLL\\", ... \\"LLL\\", ... \\"LLL\\" ... ], ... [ ... \\"LWLWL\\", ... \\"WLWLW\\", ... \\"LWLWL\\", ... \\"WLWLW\\", ... \\"LWLWL\\" ... ] ... ]) == [4, 1, 13] pass","solution":"def num_islands(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == 'W' or visited[x][y]: return visited[x][y] = True dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) island_count = 0 for i in range(m): for j in range(n): if grid[i][j] == 'L' and not visited[i][j]: dfs(i, j) island_count += 1 return island_count def count_islands(test_cases): results = [] for grid in test_cases: results.append(num_islands(grid)) return results"},{"question":"def process_queries(n: int, q: int, array: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes a series of increase/decrease operations on subarrays and returns the sum of the array after each query. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list of int): The initial list of integers. queries (list of tuple): Each tuple contains three elements (t, l, r) representing a query. Returns: list of int: The sums of the array after each query. pass # Example test cases def test_example_1(): n = 5 q = 3 array = [1, 2, 3, 4, 5] queries = [(1, 1, 3), (2, 2, 4), (1, 1, 5)] expected_output = [15, 18, 15, 20] assert process_queries(n, q, array, queries) == expected_output def test_example_2(): n = 4 q = 2 array = [10, 20, 30, 40] queries = [(2, 1, 2), (1, 3, 4)] expected_output = [100, 98, 100] assert process_queries(n, q, array, queries) == expected_output def test_no_queries(): n = 3 q = 0 array = [1, 2, 3] queries = [] expected_output = [6] assert process_queries(n, q, array, queries) == expected_output def test_single_element_array(): n = 1 q = 2 array = [5] queries = [(1, 1, 1), (2, 1, 1)] expected_output = [5, 6, 5] assert process_queries(n, q, array, queries) == expected_output def test_negative_numbers(): n = 4 q = 2 array = [10, 20, -30, 40] queries = [(2, 1, 2), (1, 3, 4)] expected_output = [40, 38, 40] assert process_queries(n, q, array, queries) == expected_output","solution":"def process_queries(n, q, array, queries): Processes a series of increase/decrease operations on subarrays and returns the sum of the array after each query. Parameters: n (int): Number of elements in the array. q (int): Number of queries. array (list of int): The initial list of integers. queries (list of tuple): Each tuple contains three elements (t, l, r) representing a query. Returns: list of int: The sums of the array after each query. results = [] current_sum = sum(array) results.append(current_sum) for t, l, r in queries: if t == 1: for i in range(l - 1, r): array[i] += 1 current_sum += 1 elif t == 2: for i in range(l - 1, r): array[i] -= 1 current_sum -= 1 results.append(current_sum) return results"},{"question":"from typing import List def min_moves_to_castle(n: int, m: int, grid: List[List[str]]) -> int: The legendary hero, Zelda, is on a quest to reach the Sacred Castle, where the final battle against the Dark Lord awaits. The kingdom is represented as a grid of n x m cells, where each cell can be either empty or contain an obstacle. Zelda starts from the top-left cell (1, 1) and aims to reach the bottom-right cell (n, m). Input: - An integer n representing the number of rows in the grid. - An integer m representing the number of columns in the grid. - A list of lists representing the grid, where each element is either '.' for an empty cell or '#' for an obstacle. Output: - An integer representing the minimum number of moves required to reach the bottom-right cell (n, m), or -1 if it's impossible. >>> min_moves_to_castle(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 4 >>> min_moves_to_castle(3, 3, [['.', '#', '.'], ['#', '.', '#'], ['.', '#', '.']]) -1","solution":"from collections import deque def min_moves_to_castle(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(0, 1), (1, 0)] queue = deque([(0, 0, 0)]) # row, col, distance visited = set((0, 0)) while queue: x, y, dist = queue.popleft() if (x, y) == (n-1, m-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"from typing import List def count_subsets_with_sum(n: int, k: int, elements: List[int]) -> int: Beatrice has a set of n integers and a target sum k. She wants to determine the total number of distinct non-empty subsets of her set where the sum of the subset’s elements is exactly equal to k. Args: n (int): Number of elements in the set. k (int): Target sum. elements (List[int]): List of integers representing the set. Returns: int: Number of distinct non-empty subsets with sum equal to k. Examples: >>> count_subsets_with_sum(5, 9, [2, 3, 4, 5, 6]) 3 >>> count_subsets_with_sum(3, 8, [1, 1, 2]) 0 >>> count_subsets_with_sum(4, 5, [1, 2, 3, 2]) 3","solution":"import itertools def count_subsets_with_sum(n, k, elements): Returns the number of distinct non-empty subsets whose sum is exactly k. count = 0 # Generate all possible non-empty subsets for r in range(1, n+1): # Combination lengths from 1 to n for subset in itertools.combinations(elements, r): if sum(subset) == k: count += 1 return count"},{"question":"def total_candies_per_day(n: int, candies: List[int]) -> List[int]: Returns a list of cumulative candies eaten by Chef up to each day. :param n: Number of days (1 ≤ n ≤ 1000) :param candies: List of integers where candies[i] represents the number of candies eaten on day i (1 ≤ candies[i] ≤ 1000) :return: List of integers where the i-th integer represents the total number of candies eaten from day 1 to day i >>> total_candies_per_day(5, [1, 2, 3, 4, 5]) [1, 3, 6, 10, 15] >>> total_candies_per_day(3, [4, 1, 4]) [4, 5, 9] >>> total_candies_per_day(1, [10]) [10] >>> total_candies_per_day(4, [3, 3, 3, 3]) [3, 6, 9, 12] >>> total_candies_per_day(4, [1, 3, 5, 7]) [1, 4, 9, 16]","solution":"def total_candies_per_day(n, candies): Returns a list of cumulative candies eaten by Chef up to each day. :param n: Number of days (1 ≤ n ≤ 1000) :param candies: List of integers where candies[i] represents the number of candies eaten on day i (1 ≤ candies[i] ≤ 1000) :return: List of integers where the i-th integer represents the total number of candies eaten from day 1 to day i cumulative_candies = [] total = 0 for day_candies in candies: total += day_candies cumulative_candies.append(total) return cumulative_candies"},{"question":"def process_bids(input_text: str) -> str: Processes a series of auction bids and identifies the highest bidder for each item. Each test case is separated by a blank line. The input ends with a single '0'. Args: input_text: Multi-line string where each line contains either a number of bids or bid details. Returns: A string containing the highest bidder for each item at the end of the auction, sorted alphabetically by item name. >>> process_bids('3npainting 100 Alicenvase 150 Bobnpainting 200 Caroln0') 'painting Carol 200nvase Bob 150' >>> process_bids('3npainting 100 Alicenvase 150 Bobnpainting 200 Caroln2nvase 120 Alicenvase 150 Bobn0') 'painting Carol 200nvase Bob 150nnvase Bob 150'","solution":"def process_bids(input_text): lines = input_text.strip().split('n') results = [] i = 0 while i < len(lines): test_case_lines = [] n = int(lines[i]) i += 1 if n == 0: break test_case_bids = {} for _ in range(n): item, bid_amount, bidder = lines[i].rsplit(' ', 2) bid_amount = int(bid_amount) if item not in test_case_bids or bid_amount > test_case_bids[item][0]: test_case_bids[item] = (bid_amount, bidder, lines[i]) elif bid_amount == test_case_bids[item][0]: test_case_bids[item] = (bid_amount, bidder, lines[i]) i += 1 sorted_items = sorted(test_case_bids.keys()) for item in sorted_items: bid_amount, bidder, _ = test_case_bids[item] test_case_lines.append(f'{item} {bidder} {bid_amount}') results.append(\\"n\\".join(test_case_lines)) return \\"nn\\".join(results)"},{"question":"def count_remaining_strings(N: int, strings: List[str], M: int, instructions: List[str]) -> int: Count the number of unique strings remaining after applying the given instructions to remove certain strings. :param N: Total number of initial strings. :param strings: List of initial strings. :param M: Number of instructions. :param instructions: List of instructions to remove certain strings. :return: Number of unique strings remaining. from typing import List def test_example1(): N = 5 strings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"apple\\"] M = 3 instructions = [\\"apple\\", \\"cherry\\", \\"banana\\"] assert count_remaining_strings(N, strings, M, instructions) == 1 def test_example2(): N = 6 strings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"apple\\", \\"banana\\"] M = 4 instructions = [\\"apple\\", \\"date\\", \\"mango\\", \\"banana\\"] assert count_remaining_strings(N, strings, M, instructions) == 1 def test_all_removed(): N = 4 strings = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] M = 4 instructions = [\\"a\\", \\"b\\", \\"c\\", \\"d\\"] assert count_remaining_strings(N, strings, M, instructions) == 0 def test_no_instructions(): N = 3 strings = [\\"a\\", \\"b\\", \\"c\\"] M = 0 instructions = [] assert count_remaining_strings(N, strings, M, instructions) == 3 def test_some_duplicates(): N = 5 strings = [\\"a\\", \\"b\\", \\"a\\", \\"c\\", \\"c\\"] M = 2 instructions = [\\"a\\", \\"c\\"] assert count_remaining_strings(N, strings, M, instructions) == 1","solution":"def count_remaining_strings(N, strings, M, instructions): Count the number of unique strings remaining after applying the given instructions to remove certain strings. :param N: Total number of initial strings. :param strings: List of initial strings. :param M: Number of instructions. :param instructions: List of instructions to remove certain strings. :return: Number of unique strings remaining. unique_strings = set(strings) for instr in instructions: if instr in unique_strings: unique_strings.remove(instr) return len(unique_strings)"},{"question":"def min_steps_to_reach_end(grid: List[List[int]]) -> int: Determine the minimum number of steps required to reach the bottom-right corner of the grid starting from the top-left corner with strictly increasing costs. :param grid: List of lists of integers representing the grid :return: Minimum number of steps if possible, otherwise -1 >>> min_steps_to_reach_end([ ... [1, 2, 3], ... [2, 3, 4], ... [3, 4, 5] ... ]) == 4 >>> min_steps_to_reach_end([ ... [1, 2, 3], ... [4, 5, 6], ... [3, 2, 1] ... ]) == -1 pass","solution":"from collections import deque def min_steps_to_reach_end(grid): Determine the minimum number of steps to reach the bottom-right corner of the grid starting from the top-left corner with strictly increasing costs. :param grid: List of lists of integers representing the grid :return: Minimum number of steps if possible, otherwise -1 m = len(grid) n = len(grid[0]) # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Queue for BFS: (current_row, current_col, steps) queue = deque([(0, 0, 0)]) visited = [[False] * n for _ in range(m)] visited[0][0] = True while queue: x, y, steps = queue.popleft() # If we reached the bottom-right corner, return the steps if x == m - 1 and y == n - 1: return steps # Traverse the grid in the four possible directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] > grid[x][y]: visited[nx][ny] = True queue.append((nx, ny, steps + 1)) # If no valid path found, return -1 return -1"},{"question":"def min_prime_numbers_sum(N: int) -> int: Find the minimum number of prime numbers whose sum equals a given number N. >>> min_prime_numbers_sum(10) 2 >>> min_prime_numbers_sum(28) 2 >>> min_prime_numbers_sum(3) 1 # Implement the function here def test_min_prime_numbers_sum_10(): assert min_prime_numbers_sum(10) == 2 def test_min_prime_numbers_sum_28(): assert min_prime_numbers_sum(28) == 2 def test_min_prime_numbers_sum_3(): assert min_prime_numbers_sum(3) == 1 def test_min_prime_numbers_sum_prime(): assert min_prime_numbers_sum(17) == 1 def test_min_prime_numbers_sum_even(): assert min_prime_numbers_sum(26) == 2 def test_min_prime_numbers_sum_odd(): assert min_prime_numbers_sum(27) == 3 def test_min_prime_numbers_sum_large_even(): assert min_prime_numbers_sum(100000) == 2 def test_min_prime_numbers_sum_large_odd(): assert min_prime_numbers_sum(99999) == 3 def test_min_prime_numbers_sum_minimum(): assert min_prime_numbers_sum(2) == 1","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def min_prime_numbers_sum(N): if is_prime(N): return 1 if N % 2 == 0: return 2 # By Goldbach’s conjecture, any even number > 2 can be represented as the sum of two primes if is_prime(N - 2): return 2 # If N is odd and N-2 is prime, then N = 2 + (N-2) return 3 # In general, any odd number can be represented as the sum of three primes"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring without repeating characters. char_map = {} left = 0 max_length = 0 for right in range(len(s)): if s[right] in char_map and char_map[s[right]] >= left: left = char_map[s[right]] + 1 char_map[s[right]] = right max_length = max(max_length, right - left + 1) return max_length"},{"question":"import collections from typing import List, Any, Tuple def process_list(n: int, elements: List[int]) -> Tuple[int, Any]: This function determines the number of distinct integers in the list and checks for majority element. Args: n: the number of elements in the list elements: the list of integers Returns: A tuple with two elements: - the number of distinct integers in the list - the majority element or \\"NO MAJORITY ELEMENT\\" if no majority element exists. >>> process_list(5, [1, 2, 2, 3, 3]) (3, \\"NO MAJORITY ELEMENT\\") >>> process_list(7, [4, 4, 4, 4, 5, 5, 5]) (2, 4) pass def handle_test_cases(test_cases: List[List[int]]) -> List[Tuple[int, Any]]: This function processes multiple test cases and returns the results for each. Args: test_cases: a list where each test case is represented as a list of integers. The first integer is the number of elements in the list, followed by the elements themselves. Returns: A list of tuples with two elements: - the number of distinct integers in the list for each test case - the majority element or \\"NO MAJORITY ELEMENT\\" >>> test_cases = [ ... [5, 1, 2, 2, 3, 3], ... [7, 4, 4, 4, 4, 5, 5, 5] ... ] >>> handle_test_cases(test_cases) [(3, \\"NO MAJORITY ELEMENT\\"), (2, 4)] pass def test_process_list(): assert process_list(5, [1, 2, 2, 3, 3]) == (3, \\"NO MAJORITY ELEMENT\\") assert process_list(7, [4, 4, 4, 4, 5, 5, 5]) == (2, 4) assert process_list(3, [1, 1, 1]) == (1, 1) assert process_list(6, [1, 2, 3, 4, 5, 6]) == (6, \\"NO MAJORITY ELEMENT\\") assert process_list(4, [4, 4, 2, 4]) == (2, 4) def test_handle_test_cases(): test_cases = [ [5, 1, 2, 2, 3, 3], [7, 4, 4, 4, 4, 5, 5, 5], [3, 1, 1, 1], [6, 1, 2, 3, 4, 5, 6], [4, 4, 4, 2, 4] ] expected_results = [ (3, \\"NO MAJORITY ELEMENT\\"), (2, 4), (1, 1), (6, \\"NO MAJORITY ELEMENT\\"), (2, 4) ] results = handle_test_cases(test_cases) assert results == expected_results","solution":"def process_list(n, elements): This function determines the number of distinct integers in the list and checks for majority element. from collections import Counter count = Counter(elements) distinct_count = len(count) majority_element = \\"NO MAJORITY ELEMENT\\" majority_threshold = n // 2 for key, value in count.items(): if value > majority_threshold: majority_element = key break return distinct_count, majority_element def handle_test_cases(test_cases): results = [] for case in test_cases: n, elements = case[0], case[1:] distinct_count, majority_element = process_list(n, elements) results.append((distinct_count, majority_element)) return results"},{"question":"def mirror_encrypt(n: int, numbers: List[int]) -> List[int]: Laura has recently become interested in encryption and wants to try a simple numerical encryption method. She decided to create her encryption system based on a transformation of integers. In her system, every digit of a given number is replaced by its mirror image from the sequence of single-digit numbers. >>> mirror_encrypt(3, [123, 456, 789]) == [876, 543, 210] >>> mirror_encrypt(2, [10, 320]) == [89, 679]","solution":"def mirror_encrypt(n, numbers): mirror_map = { '0': '9', '1': '8', '2': '7', '3': '6', '4': '5', '5': '4', '6': '3', '7': '2', '8': '1', '9': '0' } result = [] for number in numbers: mirrored = ''.join(mirror_map[digit] for digit in str(number)) result.append(int(mirrored)) return result"},{"question":"def generate_spiral_matrix(n: int) -> List[List[int]]: Generates an n x n spiral matrix filled with elements from 1 to n^2 in a clockwise order. >>> generate_spiral_matrix(1) [[1]] >>> generate_spiral_matrix(2) [[1, 2], [4, 3]] >>> generate_spiral_matrix(3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(4) [[1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7]] >>> generate_spiral_matrix(5) [[1, 2, 3, 4, 5], [16, 17, 18, 19, 6], [15, 24, 25, 20, 7], [14, 23, 22, 21, 8], [13, 12, 11, 10, 9]]","solution":"def generate_spiral_matrix(n): Generates an n x n spiral matrix filled with elements from 1 to n^2 in a clockwise order. if n == 1: return [[1]] matrix = [[0] * n for _ in range(n)] num = 1 left, right, top, bottom = 0, n-1, 0, n-1 while left <= right and top <= bottom: # Fill from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Fill from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 # Fill from right to left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 # Fill from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"import json from datetime import datetime from typing import List def parse_log_entry(entry: str) -> dict: Parses a single log entry and returns a dictionary with timestamp, level, and message keys. pass def log_level_to_number(level: str) -> int: Converts a log level to a number for easy comparison. pass def filter_logs(n: int, min_level: str, logs: List[str]) -> str: Filters and formats log entries based on the minimum log level. Parameters: n (int): number of log entries min_level (str): the minimum log level to include (INFO, WARN, ERROR) logs (List[str]): list of log entries in the format \\"[yyyy-mm-dd hh:mm:ss] [LEVEL] Message text\\" Returns: str: JSON array containing the filtered log entries sorted by timestamp in ascending order. pass # Unit Tests def test_info_level(): n = 3 min_level = \\"INFO\\" logs = [ \\"[2023-01-01 08:00:00] [INFO] Info log entry\\", \\"[2023-01-01 09:00:00] [WARN] Warning log entry\\", \\"[2023-01-01 10:00:00] [ERROR] Error log entry\\" ] expected_output = json.dumps([ {\\"timestamp\\": \\"2023-01-01 08:00:00\\", \\"level\\": \\"INFO\\", \\"message\\": \\"Info log entry\\"}, {\\"timestamp\\": \\"2023-01-01 09:00:00\\", \\"level\\": \\"WARN\\", \\"message\\": \\"Warning log entry\\"}, {\\"timestamp\\": \\"2023-01-01 10:00:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Error log entry\\"} ], indent=2) assert filter_logs(n, min_level, logs) == expected_output def test_warn_level(): n = 4 min_level = \\"WARN\\" logs = [ \\"[2023-01-01 10:00:00] [INFO] Startup complete\\", \\"[2023-01-01 10:05:00] [WARN] Low disk space\\", \\"[2023-01-01 10:10:00] [ERROR] Disk full\\", \\"[2023-01-01 11:00:00] [INFO] User logged in\\" ] expected_output = json.dumps([ {\\"timestamp\\": \\"2023-01-01 10:05:00\\", \\"level\\": \\"WARN\\", \\"message\\": \\"Low disk space\\"}, {\\"timestamp\\": \\"2023-01-01 10:10:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Disk full\\"} ], indent=2) assert filter_logs(n, min_level, logs) == expected_output def test_error_level(): n = 3 min_level = \\"ERROR\\" logs = [ \\"[2023-01-01 08:00:00] [INFO] Info log entry\\", \\"[2023-01-01 09:00:00] [WARN] Warning log entry\\", \\"[2023-01-01 10:00:00] [ERROR] Error log entry\\" ] expected_output = json.dumps([ {\\"timestamp\\": \\"2023-01-01 10:00:00\\", \\"level\\": \\"ERROR\\", \\"message\\": \\"Error log entry\\"} ], indent=2) assert filter_logs(n, min_level, logs) == expected_output def test_no_logs(): n = 0 min_level = \\"ERROR\\" logs = [] expected_output = json.dumps([], indent=2) assert filter_logs(n, min_level, logs) == expected_output def test_single_log(): n = 1 min_level = \\"INFO\\" logs = [ \\"[2023-01-01 10:00:00] [INFO] Single log entry\\" ] expected_output = json.dumps([ {\\"timestamp\\": \\"2023-01-01 10:00:00\\", \\"level\\": \\"INFO\\", \\"message\\": \\"Single log entry\\"} ], indent=2) assert filter_logs(n, min_level, logs) == expected_output","solution":"import json from datetime import datetime def parse_log_entry(entry): Parses a single log entry and returns a dictionary with timestamp, level, and message keys. time, level, message = entry.split('] ', 2) timestamp = time.strip('[') level = level.strip('[').strip(']') return { \\"timestamp\\": timestamp, \\"level\\": level, \\"message\\": message.strip() } def log_level_to_number(level): Converts a log level to a number for easy comparison. levels = {\\"INFO\\": 1, \\"WARN\\": 2, \\"ERROR\\": 3} return levels[level] def filter_logs(n, min_level, logs): Filters and formats log entries based on the minimum log level. min_level_number = log_level_to_number(min_level) filtered_logs = [] for log in logs: parsed_log = parse_log_entry(log) if log_level_to_number(parsed_log[\\"level\\"]) >= min_level_number: filtered_logs.append(parsed_log) # Sort logs by timestamp filtered_logs = sorted(filtered_logs, key=lambda x: datetime.strptime(x[\\"timestamp\\"], \\"%Y-%m-%d %H:%M:%S\\")) return json.dumps(filtered_logs, indent=2) # Example usage if __name__ == \\"__main__\\": n = 4 min_level = \\"WARN\\" logs = [ \\"[2023-01-01 10:00:00] [INFO] Startup complete\\", \\"[2023-01-01 10:05:00] [WARN] Low disk space\\", \\"[2023-01-01 10:10:00] [ERROR] Disk full\\", \\"[2023-01-01 11:00:00] [INFO] User logged in\\" ] result = filter_logs(n, min_level, logs) print(result)"},{"question":"def find_pair_with_target_sum(n: int, target: int, array: List[int]) -> Union[Tuple[int, int], str]: Returns two indices i and j (0-indexed) in ascending order such that array[i] + array[j] = target. If there is no such pair, returns \\"No solution\\". >>> find_pair_with_target_sum(5, 9, [2, 7, 11, 15, 1]) (0, 1) >>> find_pair_with_target_sum(5, 10, [5, 5, 3, 7, 2]) (0, 1) >>> find_pair_with_target_sum(4, 8, [1, 2, 3, 4]) \\"No solution\\"","solution":"def find_pair_with_target_sum(n, target, array): Returns two indices i and j (0-indexed) in ascending order such that array[i] + array[j] = target. If there is no such pair, returns \\"No solution\\". index_map = {} for i in range(n): complement = target - array[i] if complement in index_map: return index_map[complement], i index_map[array[i]] = i return \\"No solution\\""},{"question":"def tournament_ranking(input_data: str) -> str: Calculates the ranking of teams based on their scores in the tournament. The input consists of multiple datasets describing teams, their matches, and scores. For each dataset, print the final ranking of the teams in descending order of points. In case of tied points, sort by goals scored. If there is still a tie, sort alphabetically by team name. >>> input_data = \\"3 3nTeamA 0nTeamB 0nTeamC 0nTeamA TeamB 2 1nTeamB TeamC 0 0nTeamA TeamC 1 1n0 0n\\" >>> tournament_ranking(input_data) \\"TeamAnTeamCnTeamB\\" >>> input_data = \\"4 2nTeamX 5nTeamY 3nTeamZ 4nTeamW 2nTeamX TeamY 0 0nTeamZ TeamW 3 1n0 0n\\" >>> tournament_ranking(input_data) \\"TeamZnTeamXnTeamYnTeamW\\" # Your code here","solution":"def calculate_ranking(input_data): def parse_input(input_data): data = input_data.strip().split('n') datasets = [] i = 0 while i < len(data): N, M = map(int, data[i].split()) if N == 0 and M == 0: break i += 1 teams = {} for _ in range(N): team_line = data[i].split() team_name = ' '.join(team_line[:-1]) initial_score = int(team_line[-1]) teams[team_name] = {'points': 0, 'goals': 0, 'initial_score': initial_score} i += 1 matches = [] for _ in range(M): match_data = data[i].split() matches.append((match_data[0], match_data[1], int(match_data[2]), int(match_data[3]))) i += 1 datasets.append((teams, matches)) return datasets def process_matches(teams, matches): for team in teams: teams[team]['points'] += teams[team]['initial_score'] for teamA, teamB, scoreA, scoreB in matches: if scoreA > scoreB: teams[teamA]['points'] += 3 elif scoreA < scoreB: teams[teamB]['points'] += 3 else: teams[teamA]['points'] += 1 teams[teamB]['points'] += 1 teams[teamA]['goals'] += scoreA teams[teamB]['goals'] += scoreB sorted_teams = sorted(teams.items(), key=lambda t: (-t[1]['points'], -t[1]['goals'], t[0])) return [team[0] for team in sorted_teams] datasets = parse_input(input_data) results = [] for teams, matches in datasets: results.append(process_matches(teams, matches)) return results def format_output(results): output = [] for result in results: output.append(\\"n\\".join(result)) output.append(\\"\\") return \\"n\\".join(output).strip() def tournament_ranking(input_data): results = calculate_ranking(input_data) return format_output(results)"},{"question":"def max_sum_subarray_index(n: int, k: int, arr: List[int]) -> int: Finds the starting index of the subarray of length k with the maximum sum. :param n: Length of the array :param k: Length of the subarray :param arr: The input array :return: Starting index of the subarray with the maximum sum pass def test_max_sum_subarray_index_example1(): assert max_sum_subarray_index(8, 3, [1, -2, 3, 4, -5, 6, 7, -8]) == 4 def test_max_sum_subarray_index_example2(): assert max_sum_subarray_index(5, 2, [4, -1, 2, 1, -5]) == 0 def test_max_sum_subarray_index_single_element(): assert max_sum_subarray_index(1, 1, [10]) == 0 def test_max_sum_subarray_index_all_negative(): assert max_sum_subarray_index(5, 2, [-3, -4, -2, -1, -6]) == 2 def test_max_sum_subarray_index_multiple_max_sums(): assert max_sum_subarray_index(6, 2, [1, 2, 1, 2, 1, 2]) == 0 def test_max_sum_subarray_index_large_array(): n = 10**6 k = 10 arr = [1] * n assert max_sum_subarray_index(n, k, arr) == 0","solution":"def max_sum_subarray_index(n, k, arr): Finds the starting index of the subarray of length k with the maximum sum. :param n: Length of the array :param k: Length of the subarray :param arr: The input array :return: Starting index of the subarray with the maximum sum # Compute the sum of the first 'k' elements current_sum = sum(arr[:k]) max_sum = current_sum max_start_idx = 0 # Sliding window to compute sums of other subarrays of length 'k' for i in range(1, n - k + 1): current_sum = current_sum - arr[i - 1] + arr[i + k - 1] if current_sum > max_sum: max_sum = current_sum max_start_idx = i return max_start_idx"},{"question":"def staircase_ways(n: int) -> int: Returns the number of distinct ways to reach the top of a staircase with n steps. Each time you can either climb 1 or 2 steps. :param n: Integer, number of steps in the staircase. :return: Integer, number of distinct ways to reach the top. >>> staircase_ways(4) 5 >>> staircase_ways(3) 3 >>> staircase_ways(0) 0 def test_staircase_ways_base_cases(): assert staircase_ways(0) == 0 assert staircase_ways(1) == 1 assert staircase_ways(2) == 2 def test_staircase_ways_general_cases(): assert staircase_ways(3) == 3 assert staircase_ways(4) == 5 assert staircase_ways(5) == 8 assert staircase_ways(6) == 13 assert staircase_ways(7) == 21 def test_staircase_ways_larger_cases(): assert staircase_ways(10) == 89 assert staircase_ways(20) == 10946 assert staircase_ways(30) == 1346269","solution":"def staircase_ways(n): Returns the number of distinct ways to reach the top of a staircase with n steps. Each time you can either climb 1 or 2 steps. :param n: Integer, number of steps in the staircase. :return: Integer, number of distinct ways to reach the top. if n == 0: return 0 if n == 1: return 1 if n == 2: return 2 prev1, prev2 = 1, 2 for i in range(3, n + 1): curr = prev1 + prev2 prev1, prev2 = prev2, curr return curr"},{"question":"def minDrivers(packages): Find the minimum number of delivery drivers needed to deliver all packages without overlapping delivery windows. >>> minDrivers([(1, 4), (2, 5), (7, 9), (6, 8)]) 2 >>> minDrivers([(1, 3), (4, 5), (6, 7), (8, 10)]) 1 >>> minDrivers([(1, 5), (2, 6), (4, 7), (6, 9)]) 3","solution":"def minDrivers(packages): Find the minimum number of delivery drivers needed to deliver all packages without overlapping delivery windows. # Sort packages by start time packages.sort(key=lambda x: x[0]) # Min heap to keep track of end times of packages import heapq heap = [] for package in packages: # If the min end time in the heap is less than or equal to the current package start time, # it means a driver has finished delivery and hence we can re-use the driver. if heap and heap[0] <= package[0]: heapq.heappop(heap) # Push the current package end time into the heap heapq.heappush(heap, package[1]) # The size of the heap will give us the minimum number of delivery drivers needed return len(heap)"},{"question":"def process_numbers(n, numbers): Processes a list of numbers according to specific rules. Args: n (int): The number of elements in the numbers list. numbers (list of int): List of integers to process. Returns: list: Processed list of strings as described in the task. >>> process_numbers(5, [6, 10, 15, 20, 25]) [\\"6 numismatum\\", \\"10 numismatum\\", \\"15 euronum\\", \\"20 numismatum\\", \\"25 euronum\\"] >>> process_numbers(4, [2, 3, 4, 5]) [\\"2 numismatum\\", \\"4 numismatum\\", \\"5 euronum\\"]","solution":"def process_numbers(n, numbers): Processes a list of numbers according to specific rules. Args: n (int): The number of elements in the numbers list. numbers (list of int): List of integers to process. Returns: list: Processed list of strings as described in the task. result = [] for num in numbers: if num % 2 == 0 and num % 5 == 0: result.append(f\\"{num} numismatum\\") elif num % 5 == 0: result.append(f\\"{num} euronum\\") elif num % 2 == 0: result.append(f\\"{num} numismatum\\") return result"},{"question":"def can_schedule_all_classes(n: int, classes: List[Tuple[int, int]]) -> str: Determines if it is possible to schedule all classes without conflicts. :param n: Number of classes :param classes: List of tuples where each tuple contains start and end time of a class :return: \\"YES\\" if all classes can be scheduled without conflicts, otherwise \\"NO\\" >>> can_schedule_all_classes(3, [(9, 12), (13, 16), (16, 18)]) 'YES' >>> can_schedule_all_classes(3, [(9, 12), (11, 14), (13, 16)]) 'NO'","solution":"def can_schedule_all_classes(n, classes): Determines if it is possible to schedule all classes without conflicts. :param n: Number of classes :param classes: List of tuples where each tuple contains start and end time of a class :return: \\"YES\\" if all classes can be scheduled without conflicts, otherwise \\"NO\\" # Sort the classes by their starting time classes.sort() # Check for conflicts for i in range(1, n): if classes[i][0] < classes[i - 1][1]: return \\"NO\\" return \\"YES\\""},{"question":"def count_unique_pairs(arr: List[int], target: int) -> int: Returns the number of unique pairs of elements in the array that sum up to the target. >>> count_unique_pairs([1, 5, 7, -1, 5], 6) 2 >>> count_unique_pairs([-1, 0, 1, 2, -1, -4, 3, -3], 0) 2","solution":"def count_unique_pairs(arr, target): Returns the number of unique pairs of elements in the array that sum up to the target. seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return len(pairs)"},{"question":"def max_sum_of_subarray_with_length_k(arr: List[int], k: int) -> int: Returns the maximum sum of difficulties of a contiguous subarray with length exactly k. >>> max_sum_of_subarray_with_length_k([10, 20, 30, 40, 50], 2) == 90 >>> max_sum_of_subarray_with_length_k([7, 3, -1, -3, 5, 3, 6, 7], 3) == 16 >>> max_sum_of_subarray_with_length_k([1, 2, 3, 4], 4) == 10","solution":"def max_sum_of_subarray_with_length_k(arr, k): Returns the maximum sum of difficulties of a contiguous subarray with length exactly k. :param arr: List[int] - List of integers representing the problem difficulties. :param k: int - Length of the subarray. :return: int - Maximum sum of the contiguous subarray with length exactly k. n = len(arr) if n < k: return 0 # Initialize the sum of the first window of size k max_sum = current_sum = sum(arr[:k]) # Use a sliding window to find the maximum sum of subarray with length exactly k for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def find_common_elements(A, B): Returns the unique elements common to both A and B in the order they appear in A. >>> find_common_elements([1, 2, 2, 3, 4, 5], [4, 3, 3, 2, 2]) [2, 3, 4] >>> find_common_elements([1, 2, 3, 4], [5, 6, 7, 8]) [] >>> find_common_elements([1, 1, 1, 1], [1]) [1] >>> find_common_elements([1, 2, 3, 4], [4, 3, 2, 1]) [1, 2, 3, 4] >>> find_common_elements([], [1, 2, 3]) [] >>> find_common_elements([1, 2, 3], []) []","solution":"def find_common_elements(A, B): Returns the unique elements common to both A and B in the order they appear in A. # Convert B to a set for O(1) average time complexity for membership checking set_B = set(B) # Initialize an empty set to track elements already included in the result seen = set() # Initialize an empty list to store the result result = [] for element in A: if element in set_B and element not in seen: result.append(element) seen.add(element) return result"},{"question":"def max_team_strength(N: int, K: int, strengths: List[int]) -> int: Given the number of participants N, the maximum team length K, and the list of participants' strengths, determine the maximum possible team strength achievable from consecutive participants. Args: N (int): The number of participants. K (int): The maximum team length. strengths (List[int]): The list of participants' strengths. Returns: int: The maximum possible team strength. >>> max_team_strength(7, 3, [3, 8, 5, 6, 2, 1, 4]) 19 >>> max_team_strength(1, 1, [1]) 1 >>> max_team_strength(5, 3, [5, 5, 5, 5, 5]) 15 >>> max_team_strength(5, 10, [1, 2, 3, 4, 5]) 15 >>> max_team_strength(5, 1, [100, 200, 300, 400, 500]) 500 >>> max_team_strength(5, 5, [1, 3, 1, 1, 1]) 7 >>> max_team_strength(5, 2, [5, 4, 3, 2, 1]) 9 >>> max_team_strength(5, 2, [1, 2, 3, 4, 5]) 9","solution":"def max_team_strength(N, K, strengths): max_strength = 0 # We are going to use sliding window technique to find the maximum sum of at most K consecutive elements for i in range(N): current_strength = 0 # Check only K participants from current index or till the end of the list if less than K remains for j in range(i, min(i + K, N)): current_strength += strengths[j] # Update the max_strength if current team's strength is higher max_strength = max(max_strength, current_strength) return max_strength # Sample Input # N = 7 # K = 3 # strengths = [3, 8, 5, 6, 2, 1, 4] # print(max_team_strength(N, K, strengths)) # Output: 19"},{"question":"def min_operations(s: str, t: str) -> int: Calculate the minimum number of operations required to transform s into t. >>> min_operations(\\"intention\\", \\"execution\\") 5 >>> min_operations(\\"abcd\\", \\"abdc\\") 2 >>> min_operations(\\"abc\\", \\"yabd\\") 2 >>> min_operations(\\"a\\", \\"a\\") 0 >>> min_operations(\\"\\", \\"abc\\") 3 >>> min_operations(\\"abc\\", \\"\\") 3 >>> min_operations(\\"aaaaaaaaaa\\", \\"aaaaaa\\") 4","solution":"def min_operations(s: str, t: str) -> int: Calculate the minimum number of operations required to transform s into t. m, n = len(s), len(t) # Create a 2D array to store the minimum operations dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the base cases for i in range(m + 1): dp[i][0] = i # Cost of deleting all characters from s for j in range(n + 1): dp[0][j] = j # Cost of inserting all characters from t # Fill dp array for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Delete from s dp[i][j - 1], # Insert into s dp[i - 1][j - 1] # Replace in s ) return dp[m][n]"},{"question":"def max_items(costs, budget): Returns the maximum number of items that can be bought without exceeding the budget. Arguments: costs -- list of integers representing the cost of items budget -- integer representing the available budget Examples: >>> max_items([1, 3, 2, 5, 4], 10) 4 >>> max_items([10, 10, 10, 10], 20) 2 def process_input(input_string): Processes the input string and returns the results for each dataset. Arguments: input_string -- multiline string representing the datasets Examples: >>> input_data = \\"5n1 3 2 5 4n10n4n10 10 10 10n20n7n1 2 3 4 5 6 7n28n0n\\" >>> process_input(input_data) [4, 2, 7]","solution":"def max_items(costs, budget): Returns the maximum number of items that can be bought without exceeding the budget. Arguments: costs -- list of integers representing the cost of items budget -- integer representing the available budget costs.sort() count = 0 total_cost = 0 for cost in costs: if total_cost + cost <= budget: total_cost += cost count += 1 else: break return count def process_input(input_string): Processes the input string and returns the results for each dataset. Arguments: input_string -- multiline string representing the datasets lines = input_string.strip().split('n') i = 0 results = [] while i < len(lines): n = int(lines[i]) if n == 0: break costs = list(map(int, lines[i + 1].split())) budget = int(lines[i + 2]) results.append(max_items(costs, budget)) i += 3 return results"},{"question":"def is_harmonious(n: int, arr: List[int]) -> str: Determine if the given list is harmonious. A list is harmonious if the difference between every pair of adjacent elements is exactly 1. Parameters: n (int): The number of elements in the list. arr (List[int]): The list of integers. Returns: str: \\"Harmonious\\" if the list is harmonious, \\"Not Harmonious\\" otherwise. >>> is_harmonious(4, [3, 4, 5, 6]) 'Harmonious' >>> is_harmonious(3, [1, 3, 2]) 'Not Harmonious'","solution":"def is_harmonious(n, arr): Determines if the difference between every pair of adjacent elements in the list is exactly 1. for i in range(n - 1): if abs(arr[i] - arr[i + 1]) != 1: return \\"Not Harmonious\\" return \\"Harmonious\\""},{"question":"def unique_paths(m: int, n: int) -> int: Returns the number of unique paths from top-left to bottom-right of an m x n grid. >>> unique_paths(3, 7) 28 >>> unique_paths(3, 2) 3 >>> unique_paths(1, 1) 1 >>> unique_paths(5, 5) 70 >>> unique_paths(100, 100) 22750883079422934966181954039568885395604168260154104734000","solution":"def unique_paths(m, n): Returns the number of unique paths from top-left to bottom-right of an m x n grid. :param m: Number of rows :param n: Number of columns :return: Number of unique paths # Create a 2D list initialized with 1 dp = [[1] * n for _ in range(m)] # Start populating the dp table from (1, 1) for i in range(1, m): for j in range(1, n): dp[i][j] = dp[i-1][j] + dp[i][j-1] return dp[m-1][n-1]"},{"question":"def num_paths_with_obstacles(n: int, m: int, board: List[str]) -> int: Calculate the number of distinct paths from the top-left to the bottom-right corner of a rectangular board, moving only right or down and avoiding obstacles. >>> num_paths_with_obstacles(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) 2 >>> num_paths_with_obstacles(2, 2, [\\"..\\", \\"#.\\"]) 1","solution":"def num_paths_with_obstacles(n, m, board): MOD = 10**9 + 7 dp = [[0] * m for _ in range(n)] if board[0][0] == '#' or board[n-1][m-1] == '#': return 0 dp[0][0] = 1 for i in range(n): for j in range(m): if board[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] dp[i][j] %= MOD return dp[n-1][m-1]"},{"question":"def remove_consecutive_triples(s: str) -> str: Removes the minimal number of letters such that no three consecutive letters in the string are the same. Parameters: s (str): The input string. Returns: str: The resulting string with no three consecutive letters the same. Examples: >>> remove_consecutive_triples(\\"aabbbac\\") 'aabbac' >>> remove_consecutive_triples(\\"mmmnnmmm\\") 'mmnnmm'","solution":"def remove_consecutive_triples(s): Removes the minimal number of letters such that no three consecutive letters in the string are the same. Parameters: s (str): The input string. Returns: str: The resulting string with no three consecutive letters the same. result = [] for char in s: if len(result) >= 2 and char == result[-1] == result[-2]: continue result.append(char) return \\"\\".join(result)"},{"question":"def find_common_tags(n: int, m: int, photos: List[List[int]]) -> str: Returns the common tag ids shared by every photo in the album. :param n: The number of photos. :param m: The maximum number of different tags a photo can have. :param photos: A list of lists, where each inner list contains tag ids of a photo. :return: A space-separated string of tag ids that are common across all photos, or \\"No common tags\\" if none exist. >>> n = 4 >>> m = 5 >>> photos = [[1, 2, 3, 4, 5], [2, 3, 5, 6], [1, 3, 5, 7, 8], [3, 5, 9]] >>> find_common_tags(n, m, photos) '3 5' >>> n = 3 >>> m = 4 >>> photos = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> find_common_tags(n, m, photos) 'No common tags'","solution":"def find_common_tags(n, m, photos): Returns the common tag ids shared by every photo in the album. # Initial set with tags of the first photo common_tags = set(photos[0]) # Intersect with the sets of tags of remaining photos for i in range(1, n): common_tags.intersection_update(photos[i]) if common_tags: return \\" \\".join(map(str, sorted(common_tags))) else: return \\"No common tags\\""},{"question":"def min_key_presses(n: int) -> int: Determines the minimum number of key presses required to print a string of length n consisting of the character 'x'. >>> min_key_presses(5) 5 >>> min_key_presses(6) 6 >>> min_key_presses(1) 1 >>> min_key_presses(100) 100 >>> min_key_presses(50) 50","solution":"def min_key_presses(n): Determines the minimum number of key presses required to print a string of length n consisting of the character 'x'. return n"},{"question":"class MessageBoard: def __init__(self): Initializes the message board with necessary data structures. def post_message(self, content: str, parent_id: int = None) -> int: Creates a new message with a unique ID and optionally specifies a parent message. Args: content (str): The content of the message. parent_id (int, optional): The ID of the parent message, if it is a reply. Returns: int: The unique ID of the new message. def get_message(self, message_id: int) -> str: Returns the full content of a message given its ID. Args: message_id (int): The ID of the message. Returns: str: The content of the message. def get_thread(self, message_id: int) -> str: Returns the full threaded conversation including all replies to the given message and their nested replies, in hierarchical order. Args: message_id (int): The ID of the message to start the thread from. Returns: str: The threaded conversation starting from the message. def test_post_message(): mb = MessageBoard() assert mb.post_message(\\"Hello World!\\") == 1 assert mb.post_message(\\"This is a reply\\", 1) == 2 def test_get_message(): mb = MessageBoard() mb.post_message(\\"Hello World!\\") mb.post_message(\\"This is a reply\\", 1) assert mb.get_message(1) == \\"Hello World!\\" assert mb.get_message(2) == \\"This is a reply\\" def test_get_thread(): mb = MessageBoard() mb.post_message(\\"Hello World!\\") mb.post_message(\\"This is a reply\\", 1) mb.post_message(\\"Another reply to the first message\\", 1) mb.post_message(\\"Reply to the second message\\", 2) thread = mb.get_thread(1) expected_thread = Hello World! This is a reply Reply to the second message Another reply to the first message assert thread == expected_thread def test_complex_thread(): mb = MessageBoard() mb.post_message(\\"Root message\\") mb.post_message(\\"First reply\\", 1) mb.post_message(\\"Second reply\\", 1) mb.post_message(\\"Reply to first reply\\", 2) mb.post_message(\\"Reply to reply of first reply\\", 4) mb.post_message(\\"Reply to second reply\\", 3) thread = mb.get_thread(1) expected_thread = Root message First reply Reply to first reply Reply to reply of first reply Second reply Reply to second reply assert thread == expected_thread","solution":"class MessageBoard: def __init__(self): self.messages = {} self.replies = {} self.next_id = 1 def post_message(self, content, parent_id=None): message_id = self.next_id self.next_id += 1 self.messages[message_id] = content if parent_id: if parent_id not in self.replies: self.replies[parent_id] = [] self.replies[parent_id].append(message_id) return message_id def get_message(self, message_id): return self.messages[message_id] def get_thread(self, message_id): def retrieve_thread(mid, depth): messages_list.append((' ' * depth) + self.messages[mid]) if mid in self.replies: for reply_id in self.replies[mid]: retrieve_thread(reply_id, depth + 1) messages_list = [] retrieve_thread(message_id, 0) return 'n'.join(messages_list) # Example of using the MessageBoard class in the main function, to handle multiple inputs and outputs. def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") board = MessageBoard() for command in data: parts = command.split(' ', 2) if parts[0] == 'POST': if len(parts) == 3: board.post_message(parts[2], int(parts[1])) else: board.post_message(parts[1]) elif parts[0] == 'GET': print(board.get_message(int(parts[1]))) elif parts[0] == 'THREAD': print(board.get_thread(int(parts[1]))) if __name__ == \\"__main__\\": main()"},{"question":"def max_sum_sublist(lst, k): Returns the maximum sum of the elements in a sublist of length k. A sublist is defined as a contiguous part of the original list. Parameters: lst (list of int): The list of integers. k (int): The desired sublist length. Returns: int: The maximum sum of the elements in a sublist of length k. Examples: >>> max_sum_sublist([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) 27 >>> max_sum_sublist([-1, -2, -3, -4, -5], 2) -3 >>> max_sum_sublist([5, -2, 3, -1, 2, -3, 4], 3) 6 pass def test_max_sum_sublist_standard_case(): assert max_sum_sublist([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3) == 27 def test_max_sum_sublist_all_negative(): assert max_sum_sublist([-1, -2, -3, -4, -5], 2) == -3 def test_max_sum_sublist_mixed(): assert max_sum_sublist([5, -2, 3, -1, 2, -3, 4], 3) == 6 def test_max_sum_sublist_single_element(): assert max_sum_sublist([5], 1) == 5 def test_max_sum_sublist_entire_list(): assert max_sum_sublist([5, -2, 3, -1, 2, -3, 4], 7) == 8 def test_max_sum_sublist_length_one(): assert max_sum_sublist([5, -2, 3, -1, 2, -3, 4], 1) == 5 def test_max_sum_sublist_k_equals_list_length(): assert max_sum_sublist([1, 2, 3, 4], 4) == 10 def test_max_sum_sublist_empty_list(): assert max_sum_sublist([], 3) == 0 def test_max_sum_sublist_k_zero(): assert max_sum_sublist([1, 2, 3, 4], 0) == 0 def test_max_sum_sublist_k_greater_than_list_length(): assert max_sum_sublist([1, 2], 3) == 0","solution":"def max_sum_sublist(lst, k): Returns the maximum sum of the elements in a sublist of length k. if not lst or k <= 0 or k > len(lst): return 0 # Initial sum of the first sublist of length k max_sum = current_sum = sum(lst[:k]) for i in range(k, len(lst)): current_sum += lst[i] - lst[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def countBinarySubstrings(s: str) -> int: Count the number of non-empty substrings which have the same number of continuous '1's and '0's. >>> countBinarySubstrings(\\"00110011\\") 6 >>> countBinarySubstrings(\\"10101\\") 4","solution":"def countBinarySubstrings(s: str) -> int: groups = [] count = 1 # Group the lengths of consecutive '0's or '1's for i in range(1, len(s)): if s[i] != s[i-1]: groups.append(count) count = 1 else: count += 1 groups.append(count) # Now count valid substrings based on the group sizes result = 0 for i in range(1, len(groups)): result += min(groups[i-1], groups[i]) return result"},{"question":"def robot_returns_to_origin(movements: str) -> str: Determine if the robot returns to the origin after completing all the steps. Parameters: movements (str): A sequence of characters 'L' and 'R'. Returns: str: \\"Yes\\" if the robot returns to the origin, otherwise \\"No\\". Examples: >>> robot_returns_to_origin(\\"LR\\") 'Yes' >>> robot_returns_to_origin(\\"LL\\") 'No' >>> robot_returns_to_origin(\\"RRLL\\") 'Yes' >>> robot_returns_to_origin(\\"LRLRLRLRRR\\") 'No'","solution":"def robot_returns_to_origin(movements): Determine if the robot returns to the origin after completing all the steps. Parameters: movements (str): A sequence of characters 'L' and 'R'. Returns: str: \\"Yes\\" if the robot returns to the origin, otherwise \\"No\\". return \\"Yes\\" if movements.count('L') == movements.count('R') else \\"No\\""},{"question":"from typing import List def max_pairs(stick_lengths: List[int]) -> int: Given an array of integers representing stick lengths, returns the maximum number of pairs that can be made. >>> max_pairs([1, 2, 1, 2, 3, 3, 4, 2]) 3 >>> max_pairs([5, 5, 5, 5, 5]) 2 >>> max_pairs([1, 1, 1, 1, 1, 1, 1, 1]) 4 >>> max_pairs([1, 2, 3, 4, 5, 6, 7, 8]) 0","solution":"from typing import List from collections import Counter def max_pairs(stick_lengths: List[int]) -> int: Given an array of integers representing stick lengths, returns the maximum number of pairs that can be made. # Count the frequency of each stick length stick_count = Counter(stick_lengths) # Calculate the number of pairs for each stick length pairs = 0 for count in stick_count.values(): pairs += count // 2 return pairs"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of all digits of the given integer n. >>> sum_of_digits(12345) 15 >>> sum_of_digits(9876543210) 45 >>> sum_of_digits(1000000000000000000) 1 >>> sum_of_digits(7) 7 >>> sum_of_digits(0) 0","solution":"def sum_of_digits(n): Returns the sum of all digits of the given integer n. return sum(int(digit) for digit in str(n))"},{"question":"from typing import Tuple def left_rotate_binary(binary_num: str, k: int) -> str: Performs a cyclic left rotation on a given binary number by a specified number of positions. Args: binary_num (str): The binary number as a string of '0's and '1's. k (int): The number of positions to rotate the binary number to the left. Returns: str: The binary number after rotating it left by k positions. Examples: >>> left_rotate_binary(\\"1101\\", 2) '0111' >>> left_rotate_binary(\\"001011\\", 3) '011001'","solution":"def left_rotate_binary(binary_num: str, k: int) -> str: Performs a cyclic left rotation on a given binary number by a specified number of positions. Args: binary_num (str): The binary number as a string of '0's and '1's. k (int): The number of positions to rotate the binary number to the left. Returns: str: The binary number after rotating it left by k positions. n = len(binary_num) k = k % n # In case k is larger than the length of the binary number return binary_num[k:] + binary_num[:k]"},{"question":"def is_non_decreasing(arr: List[int]) -> str: Determines if the array is in non-decreasing order. >>> is_non_decreasing([1, 2, 2, 4, 5]) \\"yes\\" >>> is_non_decreasing([3, 1, 4, 2]) \\"no\\" >>> is_non_decreasing([7, 7, 8]) \\"yes\\"","solution":"def is_non_decreasing(arr): Determines if the array is in non-decreasing order. Parameters: arr (list of int): The array of integers. Returns: str: \\"yes\\" if the array is in non-decreasing order, otherwise \\"no\\". for i in range(len(arr) - 1): if arr[i] > arr[i + 1]: return \\"no\\" return \\"yes\\" def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:n + 1])) print(is_non_decreasing(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def maximize_diff_sum(n: int, a: List[int]) -> int: You are given an array of integers \`a\` of size \`n\`. Each element of this array may be incremented by any non-negative integer value. Define a function \`f(a)\` which is the sum of differences of the neighboring elements in the array. f(a) = |a[1] - a[2]| + |a[2] - a[3]| + ... + |a[n-1] - a[n]| Your task is to maximize the value of \`f(a)\`. >>> maximize_diff_sum(5, [1, 3, -1, 2, 0]) 8 >>> maximize_diff_sum(3, [2, 2, 2]) 0 >>> maximize_diff_sum(1, [42]) 0 >>> maximize_diff_sum(2, [1, 10]) 18 >>> maximize_diff_sum(4, [-1, 0, 1, 2]) 6 >>> maximize_diff_sum(3, [-1000000000, 0, 1000000000]) 4000000000","solution":"def maximize_diff_sum(n, a): a_sorted = sorted(a) max_value = 0 for i in range(1, n): max_value += abs(a_sorted[i] - a_sorted[i-1]) max_value *= 2 return max_value"},{"question":"from typing import List def is_valid_sudoku(grid: List[List[int]]) -> str: Returns 'VALID' if the provided 9x9 Sudoku grid is a valid solution, otherwise returns 'INVALID'. Examples: >>> is_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 9, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) \\"VALID\\" >>> is_valid_sudoku([ ... [5, 3, 4, 6, 7, 8, 9, 1, 2], ... [6, 7, 2, 1, 9, 5, 3, 4, 8], ... [1, 9, 8, 3, 4, 2, 5, 6, 7], ... [8, 5, 9, 7, 6, 1, 4, 2, 3], ... [4, 2, 6, 8, 5, 3, 7, 1, 1], ... [7, 1, 3, 9, 2, 4, 8, 5, 6], ... [9, 6, 1, 5, 3, 7, 2, 8, 4], ... [2, 8, 7, 4, 1, 9, 6, 3, 5], ... [3, 4, 5, 2, 8, 6, 1, 7, 9] ... ]) \\"INVALID\\"","solution":"def is_valid_sudoku(grid): Returns 'VALID' if the provided 9x9 Sudoku grid is a valid solution, otherwise returns 'INVALID'. def is_valid_block(block): return sorted(block) == list(range(1, 10)) for i in range(9): row = [grid[i][j] for j in range(9)] if not is_valid_block(row): return \\"INVALID\\" col = [grid[j][i] for j in range(9)] if not is_valid_block(col): return \\"INVALID\\" for i in range(0, 9, 3): for j in range(0, 9, 3): square = [grid[i+x][j+y] for x in range(3) for y in range(3)] if not is_valid_block(square): return \\"INVALID\\" return \\"VALID\\""},{"question":"def find_optimal_hub_city(N: int, M: int, city_roads: List[Tuple[int, int, int]]) -> int: Determine the optimal central city such that the maximum distance from the central city to all other cities is minimized. Args: N (int): Number of cities. M (int): Number of roads. city_roads (List[Tuple[int, int, int]]): List of tuples where each tuple represents a road between two cities and the distance between them. Returns: int: The index of the optimal central city. Examples: >>> find_optimal_hub_city(5, 5, [(1,2,3), (1,3,2), (2,4,4), (3,4,1), (4,5,2)]) 4 >>> find_optimal_hub_city(7, 8, [(1,2,5), (1,3,2), (3,4,1), (3,5,4), (2,4,3), (2,6,6), (5,7,2), (6,7,1)]) 3 >>> find_optimal_hub_city(3, 3, [(1,2,2), (2,3,3), (1,3,1)]) 1","solution":"import heapq def compute_distances(N, roads, start): distances = [float('inf')] * N distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, u = heapq.heappop(priority_queue) if current_distance > distances[u]: continue for v, weight in roads[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) return distances def find_optimal_hub_city(N, M, city_roads): # Create graph representation roads = [[] for _ in range(N)] for u, v, d in city_roads: roads[u-1].append((v-1, d)) roads[v-1].append((u-1, d)) min_max_distance = float('inf') optimal_city = -1 # Compute maximum distance from each city for city in range(N): distances = compute_distances(N, roads, city) max_distance = max(distances) if max_distance < min_max_distance: min_max_distance = max_distance optimal_city = city elif max_distance == min_max_distance: optimal_city = min(optimal_city, city) return optimal_city + 1 # converting back to 1-based index"},{"question":"def check_temperature(threshold, required_duration, recordings): Check if the temperature exceeded the given threshold for at least the required duration. :param threshold: Temperature threshold :param required_duration: Required duration in hours :param recordings: List of tuples containing temperature and interval duration :return: \\"Exceeded\\" if the temperature exceeded the threshold for at least the required duration, otherwise \\"Not Exceeded\\" >>> check_temperature(30, 5, [(25, 2), (31, 3), (28, 1), (32, 2)]) \\"Exceeded\\" >>> check_temperature(30, 6, [(25, 2), (31, 3), (28, 1), (32, 2)]) \\"Not Exceeded\\" def process_input(data): Process the input data to determine if the temperature exceeded the specified threshold. :param data: List of strings representing the input data :return: List of strings \\"Exceeded\\" or \\"Not Exceeded\\" for each dataset >>> process_input([ ... \\"30 5\\", ... \\"4\\", ... \\"25 2\\", ... \\"31 3\\", ... \\"28 1\\", ... \\"32 2\\", ... \\"30 6\\", ... \\"4\\", ... \\"25 2\\", ... \\"31 3\\", ... \\"28 1\\", ... \\"32 2\\", ... \\"0 0\\" ... ]) [\\"Exceeded\\", \\"Not Exceeded\\"] >>> process_input([ ... \\"25 2\\", ... \\"1\\", ... \\"26 3\\", ... \\"0 0\\" ... ]) [\\"Exceeded\\"]","solution":"def check_temperature(threshold, required_duration, recordings): Check if the temperature exceeded the given threshold for at least the required duration. :param threshold: Temperature threshold :param required_duration: Required duration in hours :param recordings: List of tuples containing temperature and interval duration :return: \\"Exceeded\\" if the temperature exceeded the threshold for at least the required duration, otherwise \\"Not Exceeded\\" total_exceeding_duration = 0 for temperature, duration in recordings: if temperature > threshold: total_exceeding_duration += duration if total_exceeding_duration >= required_duration: return \\"Exceeded\\" else: return \\"Not Exceeded\\" def process_input(data): results = [] index = 0 while index < len(data): threshold, required_duration = map(int, data[index].split()) if threshold == 0 and required_duration == 0: break index += 1 num_recordings = int(data[index]) index += 1 recordings = [] for _ in range(num_recordings): temperature, duration = map(int, data[index].split()) recordings.append((temperature, duration)) index += 1 result = check_temperature(threshold, required_duration, recordings) results.append(result) return results"},{"question":"def has_simple_path_of_k_edges(n: int, m: int, k: int, edges: List[Tuple[int, int]]) -> str: Determine if there exists a simple path of exactly \`k\` edges between any two nodes in the graph. >>> has_simple_path_of_k_edges(4, 3, 2, [(1, 2), (2, 3), (3, 4)]) \\"YES\\" >>> has_simple_path_of_k_edges(3, 1, 2, [(1, 2)]) \\"NO\\" >>> has_simple_path_of_k_edges(3, 2, 1, [(1, 2), (2, 3)]) \\"YES\\" >>> has_simple_path_of_k_edges(100, 2, 2, [(1, 2), (99, 100)]) \\"NO\\" >>> has_simple_path_of_k_edges(5, 5, 4, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)]) \\"YES\\" >>> has_simple_path_of_k_edges(4, 2, 1, [(1, 2), (3, 4)]) \\"YES\\" >>> has_simple_path_of_k_edges(4, 2, 2, [(1, 2), (3, 4)]) \\"NO\\" pass","solution":"def has_simple_path_of_k_edges(n, m, k, edges): from collections import defaultdict # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) def dfs(node, edges_left, visited): if edges_left < 0: return False if edges_left == 0: return True visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, edges_left - 1, visited): return True visited.remove(node) return False # Check for each vertex if there's a k-length path starting from it for start_node in range(1, n + 1): visited = set() if dfs(start_node, k, visited): return \\"YES\\" return \\"NO\\""},{"question":"def count_distinct_subarrays(arr: List[int], k: int) -> int: Returns the number of distinct subarrays of size exactly k. >>> count_distinct_subarrays([1, 2, 1, 3, 4, 2, 3], 3) 5 >>> count_distinct_subarrays([1, 2, 3, 4, 5], 1) 5 >>> count_distinct_subarrays([1, 2, 3], 4) 0 >>> count_distinct_subarrays([1, 1, 1, 1, 1], 2) 1 >>> count_distinct_subarrays([1, 2, 3, 4], 2) 3 >>> count_distinct_subarrays([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 6","solution":"def count_distinct_subarrays(arr, k): Returns the number of distinct subarrays of size exactly k. if k > len(arr): return 0 subarrays = set() for i in range(len(arr) - k + 1): sub = tuple(arr[i:i+k]) subarrays.add(sub) return len(subarrays) # Example usage #print(count_distinct_subarrays([1, 2, 1, 3, 4, 2, 3], 3)) # Output should be 5"},{"question":"def calculate_fuel_and_max_distance(M, distances): Calculate the total fuel required and the maximum distance between any two consecutive planets. Parameters: M (int): The number of distances between consecutive planets. distances (List[int]): List of distances between consecutive planets. Returns: tuple: Total fuel required and the maximum distance between any two consecutive planets. >>> calculate_fuel_and_max_distance(5, [10, 20, 30, 40, 50]) (150, 50) >>> calculate_fuel_and_max_distance(1, [1000000]) (1000000, 1000000) >>> calculate_fuel_and_max_distance(1, [1]) (1, 1) >>> calculate_fuel_and_max_distance(4, [500000, 1000000, 250000, 750000]) (2500000, 1000000)","solution":"def calculate_fuel_and_max_distance(M, distances): Calculate the total fuel required and the maximum distance between any two consecutive planets. Parameters: M (int): The number of distances between consecutive planets. distances (List[int]): List of distances between consecutive planets. Returns: tuple: Total fuel required and the maximum distance between any two consecutive planets. total_fuel = sum(distances) max_distance = max(distances) return total_fuel, max_distance"},{"question":"def remaining_element(n: int, sequence: List[int]) -> int: Determine the remaining element after Alice completes the game. >>> remaining_element(5, [1, 2, 3, 4, 5]) 3 >>> remaining_element(4, [7, 8, 9, 10]) 8","solution":"def remaining_element(n, sequence): while len(sequence) > 1: if len(sequence) % 2 == 1: sequence.pop(0) else: sequence.pop(-1) return sequence[0]"},{"question":"def sum_of_digits(n): Returns the sum of digits of n. pass def is_prime(n): Determines if a number n is prime. pass def generate_prime_series(N): Generates the series of numbers starting with prime N, continuously adding the sum of its digits until the number is no longer prime. >>> generate_prime_series(3) [3, 6] >>> generate_prime_series(11) [11, 13, 17, 25] pass # Unit tests def test_sum_of_digits(): assert sum_of_digits(123) == 6 assert sum_of_digits(0) == 0 assert sum_of_digits(987) == 24 def test_is_prime(): assert is_prime(2) == True assert is_prime(4) == False assert is_prime(13) == True assert is_prime(1) == False assert is_prime(17) == True def test_generate_prime_series(): assert generate_prime_series(3) == [3, 6] assert generate_prime_series(11) == [11, 13, 17, 25] # Additional test cases assert generate_prime_series(17) == [17, 25] assert generate_prime_series(23) == [23, 28] # Example usage and printing the series for the input 11 if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def sum_of_digits(n): Returns the sum of digits of n. return sum(int(digit) for digit in str(n)) def is_prime(n): Determines if a number n is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_prime_series(N): Generates the series of numbers starting with prime N, continuously adding the sum of its digits until the number is no longer prime. result = [] current = N while is_prime(current): result.append(current) current += sum_of_digits(current) result.append(current) # Adding the non-prime ending number return result # Example usage and printing the series for the input 11 if __name__ == \\"__main__\\": test_input = 11 series = generate_prime_series(test_input) for number in series: print(number)"},{"question":"def longest_equal_subsequence(arr): Given an array of integers, find the length of the longest subsequence where all elements are equal. :param arr: List[int] - List representing the array of integers :return: int - Length of the longest subsequence of equal elements >>> longest_equal_subsequence([1, 2, 2, 3, 3, 3, 4]) 3 >>> longest_equal_subsequence([1, 1, 1, 1, 1]) 5 >>> longest_equal_subsequence([1, 2, 3, 4, 5, 6]) 1","solution":"def longest_equal_subsequence(arr): Given an array of integers, find the length of the longest subsequence where all elements are equal. :param arr: List[int] - List representing the array of integers :return: int - Length of the longest subsequence of equal elements if not arr: return 0 freq_map = {} # Calculate frequencies of each element for num in arr: if num in freq_map: freq_map[num] += 1 else: freq_map[num] = 1 # Find the maximum frequency longest_subsequence_length = max(freq_map.values()) return longest_subsequence_length"},{"question":"def max_coins(n: int, m: int, coin_appearances: List[Tuple[int, int, int]]) -> int: Calculate the maximum number of coins the player can collect by planning their movements. >>> max_coins(10, 3, [(2, 5, 3), (7, 3, 5), (5, 10, 8)]) 18 >>> max_coins(10, 0, []) 0 >>> max_coins(1, 1, [(1, 10, 10)]) 10 >>> max_coins(5, 1, [(3, 5, 1)]) 5 >>> max_coins(4, 4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) 14 >>> max_coins(3, 3, [(1, 1, 1), (2, 2, 2), (3, 3, 3)]) 6 >>> max_coins(5, 3, [(1, 2, 2), (2, 3, 3), (3, 4, 4)]) 9 >>> max_coins(100, 10, [(10, 100, 10), (20, 200, 20), (30, 300, 30), (40, 400, 40), (50, 500, 50), (60, 600, 60), (70, 700, 70), (80, 800, 80), (90, 900, 90), (100, 1000, 100)]) 5500","solution":"def max_coins(n, m, coin_appearances): # Initialize the dp array where dp[j] indicates the max coins collectible at segment j dp = [0] * (n + 1) # Iterate through each coin appearance for si, ci, ti in coin_appearances: # Create a new_dp to store updated values new_dp = [0] * (n + 1) for j in range(1, n + 1): # Calculate maximum coins collectible at each segment j considering movement to si new_dp[j] = dp[j] + ci if abs(j - si) <= ti else dp[j] dp = new_dp # Return the maximum coins collectible at any segment return max(dp) # Example case n = 10 m = 3 coin_appearances = [ (2, 5, 3), (7, 3, 5), (5, 10, 8) ] print(max_coins(n, m, coin_appearances)) # Output: 18"},{"question":"def min_replacements_to_palindrome(n: int, binary_string: str) -> int: Calculate the minimum number of character replacements needed to make the binary string a palindrome. :param n: Length of the binary string :param binary_string: The binary string composed of 'a' and 'b' :return: Minimum number of replacements >>> min_replacements_to_palindrome(5, 'ababa') 0 >>> min_replacements_to_palindrome(4, 'aabb') 2","solution":"def min_replacements_to_palindrome(n, binary_string): Calculate the minimum number of character replacements needed to make the binary string a palindrome. :param n: Length of the binary string :param binary_string: The binary string composed of 'a' and 'b' :return: Minimum number of replacements replacements = 0 for i in range(n // 2): if binary_string[i] != binary_string[n - i - 1]: replacements += 1 return replacements"},{"question":"def calculate_skyline_area(n: int, heights: list[int]) -> int: Calculate the total area of the skyline formed by buildings of given heights. Parameters: - n (int): Number of buildings. - heights (list of int): Heights of the buildings. Returns: - int: Total area of the skyline. Examples: >>> calculate_skyline_area(6, [2, 1, 5, 6, 2, 3]) 10 >>> calculate_skyline_area(5, [0, 3, 0, 2, 0]) 3 from solution import calculate_skyline_area def test_calculate_skyline_area_example1(): assert calculate_skyline_area(6, [2, 1, 5, 6, 2, 3]) == 10 def test_calculate_skyline_area_example2(): assert calculate_skyline_area(5, [0, 3, 0, 2, 0]) == 3 def test_calculate_skyline_area_single_building(): assert calculate_skyline_area(1, [4]) == 4 def test_calculate_skyline_area_all_same_height(): assert calculate_skyline_area(4, [3, 3, 3, 3]) == 12 def test_calculate_skyline_area_increasing_heights(): assert calculate_skyline_area(5, [1, 2, 3, 4, 5]) == 9 # Rectangle from index 0 to 2 def test_calculate_skyline_area_decreasing_heights(): assert calculate_skyline_area(5, [5, 4, 3, 2, 1]) == 9 # Rectangle from index 2 to 4","solution":"def calculate_skyline_area(n, heights): Calculate the total area of the skyline formed by buildings of given heights. Parameters: n (int): Number of buildings. heights (list of int): Heights of the buildings. Returns: int: Total area of the skyline. stack = [] max_area = 0 index = 0 while index < n: if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = heights[top_of_stack] * (index - stack[-1] - 1 if stack else index) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = heights[top_of_stack] * (index - stack[-1] - 1 if stack else index) max_area = max(max_area, area) return max_area"},{"question":"import heapq from typing import List def min_altitude_change(matrix: List[List[int]]) -> int: Computes the minimum altitude change required to move from the top-left corner to the bottom-right corner of the matrix. >>> min_altitude_change([ ... [1, 3, 2], ... [4, 5, 8], ... [6, 7, 9] ... ]) 2 >>> min_altitude_change([ ... [5, 3], ... [2, 1] ... ]) 2","solution":"import heapq def min_altitude_change(matrix): n, m = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] def in_bounds(x, y): return 0 <= x < n and 0 <= y < m heap = [(0, 0, 0)] # (change, row, col) seen = [[False] * m for _ in range(n)] max_change = 0 while heap: change, x, y = heapq.heappop(heap) max_change = max(max_change, change) if x == n-1 and y == m-1: return max_change if seen[x][y]: continue seen[x][y] = True for dx, dy in directions: nx, ny = x + dx, y + dy if in_bounds(nx, ny) and not seen[nx][ny]: altitude_change = abs(matrix[nx][ny] - matrix[x][y]) heapq.heappush(heap, (altitude_change, nx, ny)) return max_change"},{"question":"def longest_ap_subsequence(arr: List[int]) -> int: Find the length of the longest subsequence that is an arithmetic progression (AP). An arithmetic progression is a sequence of numbers such that the difference of any two successive members of the sequence is a constant. >>> longest_ap_subsequence([3, 6, 9, 12]) 4 >>> longest_ap_subsequence([1, 7, 10, 13, 14, 19]) 4 >>> longest_ap_subsequence([1, 5, 9, 3, 7]) 3 >>> longest_ap_subsequence([10, 20, 30, 40, 15, 25]) 4 >>> longest_ap_subsequence([42]) 1 >>> longest_ap_subsequence([1, 4, 15, 10, 30]) 2 >>> longest_ap_subsequence([-1, 0, 1, 2, 3, 4]) 6 >>> longest_ap_subsequence([-5, -1, 3, 7]) 4","solution":"from typing import List def longest_ap_subsequence(arr: List[int]) -> int: if len(arr) <= 1: return len(arr) # Create a dictionary to store the length of AP ending with arr[j] having a common difference of diff dp = [{} for _ in range(len(arr))] max_length = 1 for i in range(len(arr)): for j in range(i): diff = arr[i] - arr[j] # If there is a preceding subsequence with this common difference, extend it; otherwise, start a new one if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 # Start a new subsequence with at least length 2 (arr[j], arr[i]) # Update the overall maximum length of arithmetic progression found max_length = max(max_length, dp[i][diff]) return max_length"},{"question":"def count_divisible_pairs(n, k, array): Find the number of pairs (i, j) in the array such that i < j and the sum of array elements at these indices is divisible by k. >>> count_divisible_pairs(5, 5, [1, 2, 3, 4, 5]) 2 >>> count_divisible_pairs(4, 3, [1, 3, 2, 6]) 2 >>> count_divisible_pairs(6, 10, [10, 20, 30, 40, 50, 60]) 15 >>> count_divisible_pairs(5, 2, [1, 2, 3, 4, 5]) 4 >>> count_divisible_pairs(5, 1, [1, 2, 3, 4, 5]) 10","solution":"def count_divisible_pairs(n, k, array): remainder_count = [0] * k # Count the remainders for num in array: remainder_count[num % k] += 1 # Calculate pairs with remainder 0 count = remainder_count[0] * (remainder_count[0] - 1) // 2 # Calculate pairs with complementing remainders for i in range(1, (k // 2) + 1): if i != k - i: count += remainder_count[i] * remainder_count[k - i] # Handle the case where k is even if k % 2 == 0: count += remainder_count[k // 2] * (remainder_count[k // 2] - 1) // 2 return count"},{"question":"def is_fibonacci_number(n: int) -> str: Determines if the given integer n is a Fibonacci number. A number is Fibonacci if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. >>> is_fibonacci_number(21) == \\"Yes\\" >>> is_fibonacci_number(34) == \\"Yes\\" >>> is_fibonacci_number(50) == \\"No\\"","solution":"import math def is_fibonacci_number(n): Determines if the given integer n is a Fibonacci number. A number is Fibonacci if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) is a perfect square. def is_perfect_square(x): s = int(math.sqrt(x)) return s * s == x return \\"Yes\\" if is_perfect_square(5 * n * n + 4) or is_perfect_square(5 * n * n - 4) else \\"No\\""},{"question":"def can_plant_saplings(N: int, M: int, K: int, park: List[str]) -> str: Determine if it is possible to plant all K saplings in the park according to the rules. >>> can_plant_saplings(5, 5, 4, [\\".....\\", \\".T.T.\\", \\".....\\", \\".T.T.\\", \\".....\\"]) == \\"Yes\\" >>> can_plant_saplings(4, 4, 3, [\\"T.TT\\", \\".T.T\\", \\"T.TT\\", \\".T.T\\"]) == \\"No\\" >>> can_plant_saplings(3, 3, 1, [\\"TTT\\", \\"TTT\\", \\"TTT\\"]) == \\"No\\" >>> can_plant_saplings(3, 3, 9, [\\"...\\", \\"...\\", \\"...\\"]) == \\"No\\" >>> can_plant_saplings(3, 3, 2, [\\"T.T\\", \\"...\\", \\"T.T\\"]) == \\"Yes\\"","solution":"def can_plant_saplings(N, M, K, park): def is_safe(x, y, park): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] for dx, dy in directions: nx, ny = x + dx, y + dy if nx >= 0 and ny >= 0 and nx < N and ny < M and park[nx][ny] == 'S': return False return True saplings_planted = 0 for i in range(N): for j in range(M): if park[i][j] == '.' and is_safe(i, j, park): park[i] = park[i][:j] + 'S' + park[i][j+1:] saplings_planted += 1 if saplings_planted == K: return \\"Yes\\" return \\"No\\" # Example usage: N, M, K = 5, 5, 4 park = [ \\".....\\", \\".T.T.\\", \\".....\\", \\".T.T.\\", \\".....\\" ] print(can_plant_saplings(N, M, K, park)) # Output: Yes"},{"question":"def min_possible_final_integer(n: int, arr: List[int]) -> int: Given n integers, this function performs a series of operations to reduce the list to a single integer using the given operation and returns the minimum possible value of the final integer. >>> min_possible_final_integer(4, [1, 2, 3, 4]) 7 >>> min_possible_final_integer(3, [7, 14, 3]) 15","solution":"def min_possible_final_integer(n, arr): Given n integers, this function performs a series of operations to reduce the list to a single integer using the given operation and returns the minimum possible value of the final integer. result = arr[0] for num in arr: result |= num return result"},{"question":"from typing import List def can_form_palindrome(s: str) -> bool: Determines if the characters of the string s can be rearranged to form a palindrome. >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"abc\\") False >>> can_form_palindrome(\\"aabb\\") True >>> can_form_palindrome(\\"racecar\\") True >>> can_form_palindrome(\\"aaabbb\\") False def process_test_cases(t: int, test_cases: List[str]) -> List[str]: Processes multiple test cases and returns results for each one. >>> process_test_cases(3, [\\"aabbcc\\", \\"abc\\", \\"aabb\\"]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> process_test_cases(1, [\\"racecar\\"]) [\\"YES\\"] >>> process_test_cases(2, [\\"aaabbb\\", \\"abccba\\"]) [\\"NO\\", \\"YES\\"]","solution":"def can_form_palindrome(s): Determines if the characters of the string s can be rearranged to form a palindrome. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) return odd_count <= 1 def process_test_cases(t, test_cases): Processes multiple test cases and returns results for each one. results = [] for case in test_cases: if can_form_palindrome(case): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"}]`),E={name:"App",components:{PoemCard:j},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const n=this.searchQuery.trim().toLowerCase();return n?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(n)||e.solution&&e.solution.toLowerCase().includes(n)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(n=>setTimeout(n,1e3)),this.visibleCount+=4,this.isLoading=!1}}},A={class:"search-container"},D={class:"card-container"},C={key:0,class:"empty-state"},F=["disabled"],I={key:0},z={key:1};function O(n,e,u,c,r,a){const f=h("PoemCard");return s(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",A,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",D,[(s(!0),i(x,null,y(a.displayedPoems,(o,p)=>(s(),w(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),i("div",C,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),i("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),i("span",z,"Loading...")):(s(),i("span",I,"See more"))],8,F)):l("",!0)])}const P=d(E,[["render",O],["__scopeId","data-v-b23939ec"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/26.md","filePath":"guide/26.md"}'),Y={name:"guide/26.md"},W=Object.assign(Y,{setup(n){return(e,u)=>(s(),i("div",null,[v(P)]))}});export{B as __pageData,W as default};
