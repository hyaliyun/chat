import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},I={class:"review-title"},E={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",I,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",E,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-8c6784bb"]]),N=JSON.parse('[{"question":"# Problem Statement: Circular Array Duplicate Detection You are given an array of integers that represent a circular list. Your task is to implement a function that detects if there are any duplicates in the array considering its circular nature. A circular list means that the last element of the array loops back to the first element (i.e., next element after the last element is the first element of the list). # Function Specifications detect_circular_duplicates **Parameters**: - `arr`: A list of integers representing the circular array. **Returns**: - A boolean indicating whether there are duplicates in the circular array. Example ```python def detect_circular_duplicates(arr: list) -> bool: # Your implementation here ``` Input: ```python arr = [1, 2, 3, 4, 5, 1] ``` Output: ```python True ``` Input: ```python arr = [1, 2, 3, 4, 5] ``` Output: ```python False ``` Constraints - ( 0 leq |arr| leq 100 ) - Elements in the array can range from -10^6 to 10^6 # Notes - Consider the circular nature when looking for duplicates. - Ensure your function handles edge cases such as empty arrays efficiently. - Aim for an optimized solution that gracefully handles potentially large number ranges efficiently. - Test your solution with varied input to ensure correctness across different scenarios.","solution":"def detect_circular_duplicates(arr: list) -> bool: Detects if there are any duplicates in the circular array. Parameters: arr (list): A list of integers representing the circular array. Returns: bool: True if there are duplicates, False otherwise. return len(arr) != len(set(arr))"},{"question":"# Coding Assessment Question **Scenario:** A logistics company manages a fleet of delivery trucks each able to carry a maximum load. The company aims to optimize the loading process, ensuring each truck is filled as much as possible without exceeding its weight limit. They have an existing algorithm that calculates the maximum load for each truck using a form of the knapsack problem but need to enhance it to return the combination of items loaded. **Task:** Implement the 0/1 Knapsack algorithm to determine the maximum weight that can be carried by a truck and to identify which items are included. # Requirements: 1. **Function 1:** `knapsack(capacity: int, weights: list[int], values: list[int]) -> int` - Takes the maximum capacity of the truck (`capacity`), a list of weights `weights` and a list of corresponding values `values`. - Returns the maximum value that can be carried within the given capacity. 2. **Function 2:** `find_items(capacity: int, weights: list[int], values: list[int]) -> list[int]` - Takes the same inputs as `knapsack`. - Returns a list representing the indices of the items included in the optimal combination. # Input: - **`capacity`**: An integer representing the maximum capacity of the truck (e.g., 50). - **`weights`**: A list of integers representing the weights of the items (e.g., [10, 20, 30]). - **`values`**: A list of integers representing the values of the items (e.g., [60, 100, 120]). # Output: - **From `knapsack`**: An integer representing the maximum value within the given capacity. - **From `find_items`**: An integer list representing the indices of items included in the optimal solution. # Constraints: - Weights and values lists are non-empty and of the same length. - Elements in weights and values lists are positive integers. - Capacity is a non-negative integer. # Example: ```python capacity = 50 weights = [10, 20, 30] values = [60, 100, 120] max_value = knapsack(capacity, weights, values) print(max_value) # Output: 220 items = find_items(capacity, weights, values) print(items) # Output: [1, 2] ``` **Edge Cases to Consider:** 1. Capacity is zero. 2. All items weigh more than the capacity. 3. Large lists requiring optimized memory or processing time.","solution":"def knapsack(capacity, weights, values): Returns the maximum value that can be carried within the given capacity. n = len(weights) K = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: K[i][w] = 0 elif weights[i-1] <= w: K[i][w] = max(values[i-1] + K[i-1][w-weights[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] return K[n][capacity] def find_items(capacity, weights, values): Returns the list of indices representing the items included in the optimal solution. n = len(weights) K = [[0 for _ in range(capacity + 1)] for _ in range(n + 1)] for i in range(n + 1): for w in range(capacity + 1): if i == 0 or w == 0: K[i][w] = 0 elif weights[i-1] <= w: K[i][w] = max(values[i-1] + K[i-1][w-weights[i-1]], K[i-1][w]) else: K[i][w] = K[i-1][w] # Traceback to find the items to include selected_items = [] w = capacity for i in range(n, 0, -1): if K[i][w] != K[i-1][w]: selected_items.append(i-1) w -= weights[i-1] selected_items.reverse() return selected_items"},{"question":"# Problem: Implement Custom HashMap with Collision Resolution You are required to implement a custom HashMap class in Python. This class should support basic operations like insertion, deletion, and retrieval of key-value pairs, along with handling collisions using chaining (linked list method). Instructions: 1. **Create the HashMap Class**: Define a class `CustomHashMap` that uses an array of linked lists to store key-value pairs. Each array index will represent a bucket that can contain multiple items in case of collisions. 2. **Implement Basic Operations**: - `put(key, value)`: Inserts the key-value pair into the HashMap. If the key already exists, update the value. - `get(key)`: Retrieves the value associated with the key if it exists, else return `None`. - `remove(key)`: Removes the key-value pair from the HashMap if it exists. 3. Ensure that the class efficiently handles collisions using linked lists, and provides average-case constant-time complexity for the operations. Example Usage: ```python # Instantiate CustomHashMap hash_map = CustomHashMap() # Insert key-value pairs hash_map.put(1, \\"value1\\") hash_map.put(2, \\"value2\\") hash_map.put(3, \\"value3\\") # Retrieve values print(hash_map.get(1)) # Output: \\"value1\\" print(hash_map.get(2)) # Output: \\"value2\\" print(hash_map.get(4)) # Output: None # Remove a key hash_map.remove(2) print(hash_map.get(2)) # Output: None ``` Constraints: - You may assume that keys are integers and values can be any type. - Implement the code in Python. - You are not allowed to use Python’s built-in dictionary for this implementation. - Aim to minimize the time complexity of each operation. Assume a reasonable size for the underlying array of buckets (e.g., initial size of 1000, and resize as needed). Details: Each bucket in your HashMap will be a linked list. Design a simple linked list structure to store key-value pairs where each node contains: - `key`: The key associated with this node. - `value`: The value associated with this node. - `next`: A pointer to the next node in the list (or `None` if it’s the end of the list). You will be graded on: - Correctness: The implementation of the `put`, `get`, and `remove` methods handling all edge cases. - Efficiency: Proper collision handling and time complexity. - Code quality: Clear, readable code with proper documentation and comments. Implement the `CustomHashMap` class and ensure it passes all provided test cases.","solution":"class Node: def __init__(self, key, value): self.key = key self.value = value self.next = None class CustomHashMap: def __init__(self, initial_size=1000): self.size = initial_size self.buckets = [None] * self.size def _hash(self, key): return key % self.size def put(self, key, value): index = self._hash(key) if self.buckets[index] is None: self.buckets[index] = Node(key, value) else: current = self.buckets[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) def get(self, key): index = self._hash(key) current = self.buckets[index] while current is not None: if current.key == key: return current.value current = current.next return None def remove(self, key): index = self._hash(key) current = self.buckets[index] prev = None while current is not None: if current.key == key: if prev is None: # head node self.buckets[index] = current.next else: prev.next = current.next return prev = current current = current.next"},{"question":"# Binary Tree Path Sum As a software engineer, you may often encounter problems related to tree data structures. One common problem is finding paths in a binary tree that sum to a given value. This task involves writing a function that finds all root-to-leaf paths where each path\'s sum equals the given sum. # Problem Statement You need to write a function `path_sum(root: TreeNode, sum: int) -> List[List[int]]` that finds all paths in a binary tree where each path\'s sum is equal to the given sum. # Constraints * The function should return a list of lists, where each inner list represents a path from the root to a leaf node that sums up to the given value. * If no such path exists, return an empty list. * TreeNode is a class that represents a node in a binary tree, and each node has a value, a left child, and a right child. You may assume the value of each node is an integer. # Input - `root`: The root node of the binary tree. - `sum`: An integer representing the desired path sum. # Output A list of lists of integers, where each inner list represents a path from the root to a leaf node that sums up to the given sum. # Examples ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: TreeNode, sum: int) -> List[List[int]]: pass if __name__ == \\"__main__\\": # Example Test Cases root = TreeNode(5) root.left = TreeNode(4) root.right = TreeNode(8) root.left.left = TreeNode(11) root.right.left = TreeNode(13) root.right.right = TreeNode(4) root.left.left.left = TreeNode(7) root.left.left.right = TreeNode(2) root.right.right.left = TreeNode(5) root.right.right.right = TreeNode(1) print(path_sum(root, 22)) # Expected [[5, 4, 11, 2], [5, 8, 4, 5]] print(path_sum(root, 26)) # Expected [[5, 8, 13]] print(path_sum(root, 18)) # Expected [[5, 8, 4, 1]] print(path_sum(None, 22)) # Expected [] ``` # Additional Information * You may assume that the input tree is a binary tree, and each node contains a single integer value. * Consider using Depth-First Search (DFS) to traverse the tree and track the paths that sum to the given value. # Hint * Think about recursive approaches to traverse the tree. * Keep track of the current path and sum as you traverse each node. If you reach a leaf node and the path sum equals the given sum, record the path.","solution":"from typing import List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def path_sum(root: TreeNode, sum: int) -> List[List[int]]: def dfs(node, current_path, total, res): if not node: return current_path.append(node.val) total += node.val if not node.left and not node.right and total == sum: res.append(list(current_path)) else: dfs(node.left, current_path, total, res) dfs(node.right, current_path, total, res) current_path.pop() result = [] dfs(root, [], 0, result) return result"},{"question":"# Coding Assessment Question **Title**: Optimal Path Sum in a Grid **Problem Statement**: You are given a 2D grid of integers where each cell contains a value representing the cost to step on that cell. Write a function `min_cost_path(grid: list[list[int]]) -> int` that finds the minimum cost path from the top-left corner to the bottom-right corner of the grid. You can only move right or down at any point in time. **Input**: - A list of lists of integers, where each inner list represents a row and contains the cost values for the respective cells in that row. The grid will contain at least one row and one column. **Output**: - An integer representing the minimum cost to reach the bottom-right corner from the top-left corner. **Constraints**: - The grid dimensions will not exceed ( 100 times 100 ). - The cost values in the grid will be non-negative integers. **Performance Requirements**: - The solution should efficiently handle grids close to the constraint limits. **Examples**: ```python grid1 = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_cost_path(grid1)) # Expected output: 7 grid2 = [ [1, 2, 3], [4, 5, 6] ] print(min_cost_path(grid2)) # Expected output: 12 grid3 = [ [10] ] print(min_cost_path(grid3)) # Expected output: 10 ``` **Scenario**: Imagine you are developing a navigation system for a delivery robot that must find the optimal route through a grid-like warehouse. Each cell in the grid represents a section of the warehouse with a specific traversal cost. Implement the `min_cost_path` function to ensure the robot always takes the route with the lowest total cost. **Additional Notes**: - Ensure that your solution gracefully handles grids with a single cell. - Utilize dynamic programming to achieve optimal performance. - Edge cases such as grids with no potential paths should be considered and handled appropriately.","solution":"def min_cost_path(grid): Returns the minimum cost to reach the bottom-right corner from the top-left corner of the grid. if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a cost matrix to store the minimum cost path to each cell cost = [[0] * cols for _ in range(rows)] # Initialize the cost for the first cell cost[0][0] = grid[0][0] # Initialize the first column of the cost matrix for i in range(1, rows): cost[i][0] = cost[i-1][0] + grid[i][0] # Initialize the first row of the cost matrix for j in range(1, cols): cost[0][j] = cost[0][j-1] + grid[0][j] # Compute the cost for the rest of the cells for i in range(1, rows): for j in range(1, cols): cost[i][j] = min(cost[i-1][j], cost[i][j-1]) + grid[i][j] return cost[rows-1][cols-1]"},{"question":"# Matrix Path Sum - Minimum Path from Top Left to Bottom Right As an aspiring software developer, you are tasked with solving a classic dynamic programming problem involving matrix path sums. The goal is to find the minimum sum path from the top-left corner to the bottom-right corner of a given matrix. You can only move either down or right at any point in time. **Objective**: Write a function `min_path_sum(matrix)` that computes the minimum path sum for a given `matrix`. **Function Specification**: - **Input**: * `matrix` - a list of lists of integers, representing the grid. The dimensions of the matrix are m x n (1 ≤ m, n ≤ 100). - **Output**: * Returns an integer representing the minimum path sum from the top-left to the bottom-right corner of the matrix. **Constraints**: - You can only move right or down, starting from the top-left corner of the matrix. **Example**: *Input*: ```python matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] ``` *Output*: ```python 7 ``` **Explanation**: The path that gives the minimum sum is: 1 → 3 → 1 → 1 → 1, which sums to 7. **Implementation Details**: 1. **Boundary Conditions**: - If the matrix is empty, return 0. - If the matrix has only one cell, return its value. 2. **Dynamic Programming Approach**: - Use a 2D dp array where `dp[i][j]` represents the minimum path sum to reach `matrix[i][j]`. - Initialize `dp[0][0]` with `matrix[0][0]`, as that\'s the starting point. - Fill the dp array by iterating through the matrix and applying the recurrence relation: `dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1])` for `i>0` and `j>0`. 3. **Edge Handling**: - For the first row (`i=0`), `dp[0][j] = dp[0][j-1] + matrix[0][j]`. - For the first column (`j=0`), `dp[i][0] = dp[i-1][0] + matrix[i][0]`. ```python def min_path_sum(matrix): if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1] # Example usage and testing the function: matrix = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] print(min_path_sum(matrix)) # Expected output: 7 ``` The proposed question adheres to the style, length, difficulty level, and topic alignment of the provided sample question, focusing on a common algorithmic problem involving dynamic programming. The example usage and detailed explanation are provided to guide users in implementing the solution.","solution":"def min_path_sum(matrix): Function to compute the minimum path sum from the top-left to the bottom-right corner of a given matrix. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1]"},{"question":"# Problem Statement Implement a function to evaluate a provided mathematical expression given as a string and return the computed result. The function should adhere to the standard precedence of operators (PEMDAS/BODMAS rules, without considering parenthesis). # Allowed Operators - Addition (`+`) - Subtraction (`-`) - Multiplication (`*`) - Division (`/`) # Input - `expression` (string): A string containing a mathematical expression. The expression may contain digits, operators, and spaces. The input string length will be at most 100 characters. # Output - A float representing the computed result of the expression. # Constraints 1. The expression will only contain valid operators and digits. 2. Division by zero should return `None`. 3. The result should be rounded to 2 decimal places. # Function Signature ```python def evaluate_expression(expression: str) -> float: ``` # Example ```python >>> evaluate_expression(\\"3 + 5 * 2\\") 13.0 >>> evaluate_expression(\\"12 / 4 - 1\\") 2.0 >>> evaluate_expression(\\"10 + 3 * 2 / 2\\") 13.0 >>> evaluate_expression(\\"100 / 25 * 4 + 7 - 3\\") 20.0 >>> evaluate_expression(\\"50 * 2 / 0\\") None ``` # Clarifications 1. Ensure to handle edge cases like division by zero and spaces within the expression correctly. 2. Avoid overcomplicating the implementation with support for additional operators or functions beyond the specified ones. 3. Aim for a clear and maintainable code structure that accurately reflects the intent of the problem statement.","solution":"def evaluate_expression(expression: str) -> float: Evaluates a mathematical expression provided as a string, following the standard precedence of operators (PEMDAS/BODMAS rules), while handling potential division by zero. Args: expression (str): The mathematical expression to evaluate. Returns: float: The computed result rounded to 2 decimal places, or None if there\'s a division by zero. try: result = eval(expression) return round(result, 2) except ZeroDivisionError: return None"},{"question":"**Problem Statement:** You are tasked with implementing a system that identifies the longest alternating sequence in a given array of positive integers. An alternating sequence is defined as a sequence of numbers where each number is either higher or lower than the preceding one, forming a zigzag pattern. Write a function `longest_alternating_sequence(array: list[int]) -> int` that: - Receives an array of positive integers `array`. - Returns the length of the longest alternating sequence found in the array. # Constraints: - All elements in `array` are positive integers. - 1 ≤ length of `array` ≤ 200. # Input: - `array`: List of positive integers. # Output: - An integer denoting the length of the longest alternating sequence. # Example: Example 1: ``` Input: array = [1, 7, 4, 9, 2, 5] Output: 6 Explanation: The longest alternating sequence is the entire array: [1, 7, 4, 9, 2, 5]. ``` Example 2: ``` Input: array = [9, 8, 7, 6, 5] Output: 2 Explanation: The longest alternating sequence could be just two elements, e.g., [9, 8] or [8, 7]. ``` Example 3: ``` Input: array = [1, 2, 3, 4] Output: 2 Explanation: The longest alternating sequence could be just two elements, e.g., [1, 2] or [2, 3]. ``` Implement a solution that ensures optimal performance.","solution":"def longest_alternating_sequence(array: list[int]) -> int: Returns the length of the longest alternating sequence in the given array. if not array: return 0 n = len(array) if n == 1: return 1 up = 1 down = 1 for i in range(1, n): if array[i] > array[i - 1]: up = down + 1 elif array[i] < array[i - 1]: down = up + 1 return max(up, down)"},{"question":"**Problem Statement**: You are given a list `nums` of integers and an integer `target`. Your task is to implement the function `two_sum(nums: List[int], target: int) -> Tuple[int, int]` which returns a pair of indices `(i, j)` such that `nums[i] + nums[j] == target`. If no such pair exists, return `None`. **Input Format**: * `nums`: A list of integers. * `target`: An integer representing the sum to find. **Output Format**: * A tuple of two integers representing the indices of the elements that sum up to `target`. If no pair is found, return `None`. **Constraints**: * All integers in the `nums` list can be positive, negative or zero. * The length of `nums` is not fixed and can vary within reasonable limits (0 ≤ len(nums) ≤ 10^5). * Assume there is exactly one solution and you may not use the same element twice. * The elements in the `nums` list are unique. **Performance Requirements**: * Your solution should aim to have an average time complexity of O(n) where n is the number of elements in `nums`. **Example**: ```python def two_sum(nums, target): # your code here print(two_sum([2, 7, 11, 15], 9)) # Output: (0, 1) print(two_sum([3, 2, 4], 6)) # Output: (1, 2) print(two_sum([3, 3], 6)) # Output: (0, 1) print(two_sum([1, 2, 3], 4)) # Output: (0, 2) print(two_sum([0, 4, 3, 0], 0)) # Output: (0, 3) print(two_sum([1], 2)) # Output: None ``` **Your Task**: * Implement the `two_sum` function using a hashmap (dictionary) approach for an optimal performance. Verify edge cases and ensure the solution handles all provided constraints effectively.","solution":"from typing import List, Tuple def two_sum(nums: List[int], target: int) -> Tuple[int, int]: Finds two distinct indices in nums such that their values add up to target. Parameters: nums (List[int]): The list of integers. target (int): The target sum. Returns: Tuple[int, int]: A tuple of the two indices whose values add up to target, or None if no such pair exists. num_map = {} for i, num in enumerate(nums): complement = target - num if complement in num_map: return (num_map[complement], i) num_map[num] = i return None"},{"question":"# List Rotation Challenge In this task, you will be required to implement a method that rotates a list of integers either to the left or right by a given number of steps. The rotation should be performed in a circular manner. CustomListRotator A utility class for rotating lists based on the given direction and number of steps. Implement the following methods: 1. `__init__(self, lst: list)`: Initializes the class with a list of integers. 2. `rotate(self, direction: str, steps: int)`: Rotates the list either to the \'left\' or \'right\' by the specified number of steps. * Raise `ValueError` if the direction is not \'left\' or \'right\'. * Raise `IndexError` if the steps are negative or exceed the length of the list. 3. `__str__(self) -> str`: Returns a string representation of the list. # Input and Output * `__init__(self, lst)` accepts a list of integers. * `rotate(self, direction, steps)` accepts a direction (\'left\' or \'right\') and number of steps (non-negative integer). * String representation should reflect the current state of the list. # Example ```python rotator = CustomListRotator([1, 2, 3, 4, 5]) print(rotator) # [1, 2, 3, 4, 5] rotator.rotate(\'left\', 2) print(rotator) # [3, 4, 5, 1, 2] rotator.rotate(\'right\', 3) print(rotator) # [4, 5, 1, 2, 3] ``` Implement the class `CustomListRotator` with the specified methods and ensure your code passes the above examples. # Performance Requirements Ensure that your implementation is efficient: * `rotate`: O(n) where n is the length of the list. * String representation should be efficient.","solution":"class CustomListRotator: def __init__(self, lst: list): Initializes the class with a list of integers. self.lst = lst def rotate(self, direction: str, steps: int): Rotates the list either to the \'left\' or \'right\' by the specified number of steps. :param direction: A string that should be either \'left\' or \'right\'. :param steps: A non-negative integer specifying the number of steps to rotate the list. if direction not in [\'left\', \'right\']: raise ValueError(\\"Direction must be either \'left\' or \'right\'\\") n = len(self.lst) if steps < 0 or steps > n: raise IndexError(\\"Steps must be between 0 and the length of the list\\") if direction == \'left\': self.lst = self.lst[steps:] + self.lst[:steps] elif direction == \'right\': self.lst = self.lst[-steps:] + self.lst[:-steps] def __str__(self) -> str: return str(self.lst)"},{"question":"# Fibonacci Sequence with Matrix Exponentiation You are required to implement an efficient algorithm to find the Nth number in the Fibonacci sequence using matrix exponentiation. # Task 1. Implement the `matrix_multiply` function to multiply two 2x2 matrices. 2. Implement the `matrix_exponentiate` function to raise a 2x2 matrix to the power of an integer. 3. Implement the `fib` function to compute the Nth Fibonacci number leveraging matrix exponentiation for efficiency. # Input - An integer `N` representing the position in the Fibonacci sequence. # Output An integer representing the Nth Fibonacci number. # Example ```python N = 10 ``` **Output**: ``` 55 ``` # Constraints - 0 ≤ N ≤ 10^9 # Notes 1. The Fibonacci sequence starts with F(0) = 0 and F(1) = 1. 2. Use the given `matrix_multiply`, `matrix_exponentiate`, and `fib` templates to build your solution. 3. Ensure the `fib` function works efficiently for large values of `N` up to 10^9. 4. Optimize for performance to handle the upper constraint efficiently. ```python def matrix_multiply(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: # Your implementation here def matrix_exponentiate(matrix: list[list[int]], power: int) -> list[list[int]]: # Your implementation here def fib(N: int) -> int: if N == 0: return 0 elif N == 1: return 1 F = [[1, 1], [1, 0]] result = matrix_exponentiate(F, N - 1) return result[0][0] if __name__ == \\"__main__\\": N = int(input(\\"Enter the position in the Fibonacci sequence: \\")) print(f\\"F({N}) = {fib(N)}\\") ``` # Remarks * Test the implementation with different values of N, including edge cases such as 0 and 1. * Consider and properly handle large values of N efficiently using matrix exponentiation. * Ensure your implementation is optimized for performance to handle high constraints.","solution":"def matrix_multiply(A: list[list[int]], B: list[list[int]]) -> list[list[int]]: Multiplies two 2x2 matrices A and B. return [ [ A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1] ], [ A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1] ] ] def matrix_exponentiate(matrix: list[list[int]], power: int) -> list[list[int]]: Calculates matrix raised to a power using exponentiation by squaring. result = [[1, 0], [0, 1]] base = matrix while power: if power % 2 == 1: result = matrix_multiply(result, base) base = matrix_multiply(base, base) power //= 2 return result def fib(N: int) -> int: Finds the Nth Fibonacci number using matrix exponentiation. if N == 0: return 0 F = [[1, 1], [1, 0]] result = matrix_exponentiate(F, N - 1) return result[0][0]"},{"question":"# Array Rotation Challenge Problem Statement Write a function `rotate_array` that takes an array of integers and a positive integer `k`, and rotates the array to the right by `k` steps. If the result exceeds the size of the array, it should wrap around. Constraints 1. The input array will have a length between 1 and 10^5. 2. The integer `k` will be within the range from 1 to 10^5. 3. The array will not be empty and will contain integers only. 4. Ensure the function operates efficiently to handle large inputs. Input * An array of integers. Example: [1, 2, 3, 4, 5], [9, 8, 7], etc. * An integer `k`. Output * Returns an array of integers, rotated to the right by `k` steps. Example ```python rotate_array([1, 2, 3, 4, 5], 2) # Returns: [4, 5, 1, 2, 3] rotate_array([7, 8, 9], 1) # Returns: [9, 7, 8] rotate_array([1, 2], 3) # Returns: [2, 1] rotate_array([10, 20, 30], 0) # Returns: [10, 20, 30] ``` Note * The array rotation should be done in-place if possible, to optimize space utilization. * Consider edge cases, such as when `k` is larger than the length of the array, or when `k` is zero. * The function should be robust to handle large arrays and high values of `k` efficiently.","solution":"def rotate_array(nums, k): Rotates the array `nums` to the right by `k` steps. n = len(nums) k = k % n # Ensure k is within the bounds of the array length nums[:] = nums[-k:] + nums[:-k] # Rotate the array by slicing return nums"},{"question":"# Coding Assessment Question: Longest Increasing Subsequence Problem Statement You are given an array of integers. Write a function `longest_increasing_subsequence` that determines the length of the longest increasing subsequence (LIS) in the array. An increasing subsequence is defined as a portion of the array where each element is larger than the previous one. Write a class `SubsequenceAnalyzer` that includes the following methods: 1. `__init__()`: Initialization method. 2. `longest_increasing_subsequence(self, nums: List[int]) -> int`: This method calculates the length of the longest increasing subsequence within the given array. Requirements: - **Input Format**: - `nums`: A list of integers (`List[int]`). - **Output Format**: - An integer representing the length of the longest increasing subsequence (`int`). Constraints: - The length of the array can be up to `2500`. - Each element\'s value should be between `-10000` and `10000`. # Scenario Consider the following scenario to ensure clarity of the problem: You are given the array `[10, 9, 2, 5, 3, 7, 101, 18]`. The longest increasing subsequence (LIS) is `[2, 3, 7, 101]`, which has a length of `4`. Therefore, your method should return `4`. Example of array and expected output: - Input: `[0, 1, 0, 3, 2, 3]` - Output: `4` (The LIS is `[0, 1, 2, 3]`) Example: - Input: `[7, 7, 7, 7, 7, 7, 7]` - Output: `1` (Since all elements are the same and the LIS length is `1`) You can use the following template to create the function: ```python from typing import List class SubsequenceAnalyzer: def __init__(self): pass def longest_increasing_subsequence(self, nums: List[int]) -> int: if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) ``` Ensure to optimize your solution for performance to handle the upper limits efficiently.","solution":"from typing import List class SubsequenceAnalyzer: def __init__(self): pass def longest_increasing_subsequence(self, nums: List[int]) -> int: if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"# Question Write a function to check whether a given year is a leap year. A year is a leap year if it is divisible by 4; however, years divisible by 100 are not leap years unless they are also divisible by 400. Your function should handle a list of years and return a list of boolean values indicating whether each corresponding year is a leap year or not. # Function Signature ```python def check_leap_years(years: list[int]) -> list[bool]: Determine if the given years are leap years. Parameters: years (list[int]): A list of years to check. Returns: list[bool]: A list of boolean values, where True indicates the corresponding year is a leap year and False otherwise. ``` # Input - `years`: a list of `n` (1 <= n <= 10^6) integers representing years. # Output - Return a list of boolean values where each boolean corresponds to whether the year at that position in the input list is a leap year. # Constraints - The `years` list will contain valid years ranging from 1 to 9999. # Examples ```python # Example 1: years = [2020, 2021, 1900, 2000] print(check_leap_years(years)) # Output: [True, False, False, True] # Example 2: years = [1600, 1700, 1800, 1900, 2000] print(check_leap_years(years)) # Output: [True, False, False, False, True] # Example 3: years = [2016, 2017, 2018, 2019, 2024] print(check_leap_years(years)) # Output: [True, False, False, False, True] # Example 4: years = [1, 4, 104, 400, 9999] print(check_leap_years(years)) # Output: [False, True, True, True, False] ``` # Requirements 1. Implement the `check_leap_years` function. 2. Ensure the function is efficient to handle lists containing up to 10^6 years. # Notes - Focus on correctly implementing the leap year rules. - Test the function with edge cases: years at the lower and upper bounds of the valid range.","solution":"def check_leap_years(years: list[int]) -> list[bool]: Determine if the given years are leap years. Parameters: years (list[int]): A list of years to check. Returns: list[bool]: A list of boolean values, where True indicates the corresponding year is a leap year and False otherwise. def is_leap_year(year): if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False return [is_leap_year(year) for year in years]"},{"question":"# Coding Question: You are given a list of transactions where each transaction is represented by a tuple `(customer_id, transaction_amount)` and a threshold amount. Your task is to write a function `flag_customers` that identifies customers who have total transactions exceeding the given threshold. A transaction is represented as a tuple `(customer_id, transaction_amount)`: * `customer_id` (int): The unique identifier of the customer. * `transaction_amount` (float): The amount of the transaction. Input: * A list of tuples, each representing a transaction. * A float representing the threshold amount. Output: * A list of unique customer IDs whose total transaction amounts exceed the given threshold, sorted in ascending order. Constraints: * If no transactions are provided, raise a `ValueError` with the message \\"No transactions provided\\". * If the threshold is negative, raise a `ValueError` with the message \\"Threshold must be non-negative\\". **Examples:** ```python >>> flag_customers([(1, 50), (2, 20.5), (1, 30), (3, 100)], 70) [1, 3] >>> flag_customers([(1, 50), (2, 20.5), (1, 30), (3, 100)], 150) [] >>> flag_customers([(1, 50), (2, 20.5), (1, 30), (2, 60)], 50) [1, 2] >>> flag_customers([(1, 50), (2, 20.5), (1, 30), (3, 100)], -10) Traceback (most recent call last): ... ValueError: Threshold must be non-negative >>> flag_customers([]) Traceback (most recent call last): ... ValueError: No transactions provided ``` Write the implementation of the function `flag_customers(transactions: list[tuple[int, float]], threshold: float) -> list[int]` below.","solution":"def flag_customers(transactions, threshold): if not transactions: raise ValueError(\\"No transactions provided\\") if threshold < 0: raise ValueError(\\"Threshold must be non-negative\\") customer_totals = {} for customer_id, transaction_amount in transactions: if customer_id in customer_totals: customer_totals[customer_id] += transaction_amount else: customer_totals[customer_id] = transaction_amount flagged_customers = [customer_id for customer_id, total in customer_totals.items() if total > threshold] return sorted(flagged_customers)"},{"question":"# Problem Statement Your task is to create a class `MatrixOperations` that provides methods for various matrix-related operations. The class should implement the functionalities as described below, with careful handling of edge cases and appropriate error handling. # Method Specifications: 1. **transpose(matrix: list) -> list**: - Returns the transpose of the given matrix. - **Input**: A 2D list representing a matrix of integers `matrix` (1 <= len(matrix), len(matrix[0]) <= 100). - **Output**: A 2D list representing the transposed matrix. - **Constraints**: Raise a ValueError if the input is not a valid 2D list. 2. **multiply(matrix1: list, matrix2: list) -> list**: - Multiplies two matrices and returns the resulting matrix. - **Input**: Two 2D lists `matrix1` and `matrix2` representing matrices of integers (1 <= len(matrix1), len(matrix2) <= 100). - **Output**: A 2D list representing the product of the two matrices. - **Constraints**: Raise a ValueError if the multiplication cannot be performed due to dimension mismatch or if the inputs are not valid 2D lists. 3. **determinant(matrix: list) -> int**: - Computes and returns the determinant of the given square matrix. - **Input**: A 2D list `matrix` representing a square matrix of integers (1 <= len(matrix) <= 25). - **Output**: An integer representing the determinant of the matrix. - **Constraints**: Raise a ValueError if the input is not a valid square matrix. 4. **inverse(matrix: list) -> list**: - Computes and returns the inverse of the given square matrix. - **Input**: A 2D list `matrix` representing a square matrix of integers (1 <= len(matrix) <= 25). - **Output**: A 2D list representing the inverse of the matrix. - **Constraints**: Raise a ValueError if the matrix is singular or if the input is not a valid square matrix. # Implementation Details - The class should be efficient and handle edge cases appropriately. - You may use any helper functions if needed, but they should be encapsulated within the class. - Ensure proper error handling for all edge cases. Here is an initial structure of the class for reference: ```python class MatrixOperations: def transpose(self, matrix: list) -> list: # Your code here pass def multiply(self, matrix1: list, matrix2: list) -> list: # Your code here pass def determinant(self, matrix: list) -> int: # Your code here pass def inverse(self, matrix: list) -> list: # Your code here pass ``` **Note** - Ensure to adhere to the method signatures. - Python’s built-in capabilities can be utilized for computations. - Raise a `ValueError` for invalid inputs according to the constraints mentioned for each method. # Example Usage ```python mo = MatrixOperations() matrix1 = [[1, 2], [3, 4]] matrix2 = [[2, 0], [1, 2]] print(mo.transpose(matrix1)) # Output: [[1, 3], [2, 4]] print(mo.multiply(matrix1, matrix2)) # Output: [[4, 4], [10, 8]] print(mo.determinant(matrix1)) # Output: -2 print(mo.inverse(matrix1)) # Output: [[-2.0, 1.0], [1.5, -0.5]] ```","solution":"class MatrixOperations: def transpose(self, matrix: list) -> list: if not self.is_valid_matrix(matrix): raise ValueError(\\"Input is not a valid 2D list.\\") return [list(row) for row in zip(*matrix)] def multiply(self, matrix1: list, matrix2: list) -> list: if not (self.is_valid_matrix(matrix1) and self.is_valid_matrix(matrix2)): raise ValueError(\\"Input is not a valid 2D list.\\") if len(matrix1[0]) != len(matrix2): raise ValueError(\\"Matrix multiplication not possible due to dimension mismatch.\\") result = [[0] * len(matrix2[0]) for _ in range(len(matrix1))] for i in range(len(matrix1)): for j in range(len(matrix2[0])): for k in range(len(matrix2)): result[i][j] += matrix1[i][k] * matrix2[k][j] return result def determinant(self, matrix: list) -> int: if not self.is_square(matrix): raise ValueError(\\"Input is not a valid square matrix.\\") return self._determinant_recursive(matrix) def _determinant_recursive(self, matrix: list) -> int: if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0] det = 0 for c in range(len(matrix)): det += ((-1)**c) * matrix[0][c] * self._determinant_recursive(self._get_matrix_minor(matrix, 0, c)) return det def _get_matrix_minor(self, matrix: list, i: int, j: int) -> list: return [row[:j] + row[j+1:] for row in (matrix[:i] + matrix[i+1:])] def inverse(self, matrix: list) -> list: det = self.determinant(matrix) if det == 0: raise ValueError(\\"Matrix is singular and cannot be inverted.\\") n = len(matrix) adjugate = self._adjugate_matrix(matrix) inverse_matrix = [[adjugate[i][j] / det for j in range(n)] for i in range(n)] return inverse_matrix def _adjugate_matrix(self, matrix: list) -> list: n = len(matrix) cofactors = [] for r in range(n): cofactorRow = [] for c in range(n): minor = self._get_matrix_minor(matrix, r, c) cofactorRow.append(((-1) ** (r + c)) * self._determinant_recursive(minor)) cofactors.append(cofactorRow) cofactors = self.transpose(cofactors) return cofactors def is_valid_matrix(self, matrix: list) -> bool: if not isinstance(matrix, list) or not all(isinstance(row, list) for row in matrix): return False row_len = len(matrix[0]) if not all(len(row) == row_len for row in matrix): return False return True def is_square(self, matrix: list) -> bool: return self.is_valid_matrix(matrix) and len(matrix) == len(matrix[0])"},{"question":"# Problem Statement Create a function `find_substring_indices` that scans through a given string `text` to find all starting indices where a provided substring `pattern` occurs. Ensure that the function handles edge cases such as overlapping substrings and returns an empty list if no occurrences are found. Your function should meet the following requirements: 1. Identify and return all starting indices (0-based) of `pattern` in `text`. 2. If `pattern` is an empty string, return an empty list. 3. Raise a `ValueError` if either `pattern` or `text` is not a string. # Function Signature ```python def find_substring_indices(text: str, pattern: str) -> list: pass ``` # Input * `text` (str): The string within which to search. * `pattern` (str): The substring to find within `text`. # Output * The function should return a list of integers representing the starting indices of all occurrences of `pattern` in `text`. # Constraints * Both `text` and `pattern` can contain any printable ASCII characters. * The length of `text` and `pattern` can range from 0 to 1000. # Example ```python >>> find_substring_indices(\\"abracadabra\\", \\"abra\\") [0, 7] >>> find_substring_indices(\\"aaaa\\", \\"aa\\") [0, 1, 2] >>> find_substring_indices(\\"abracadabra\\", \\"cad\\") [4] >>> find_substring_indices(\\"abracadabra\\", \\"\\") [] >>> find_substring_indices(123, \\"12\\") Traceback (most recent call last): ... ValueError: Both text and pattern should be strings >>> find_substring_indices(\\"abracadabra\\", 123) Traceback (most recent call last): ... ValueError: Both text and pattern should be strings >>> find_substring_indices(\\"abracadabra\\", \\"xyz\\") [] ``` # Notes * Pay attention to the edge cases where `pattern` is an empty string or longer than `text`. * Ensure that your implementation passes the provided example test cases.","solution":"def find_substring_indices(text, pattern): if not isinstance(text, str) or not isinstance(pattern, str): raise ValueError(\\"Both text and pattern should be strings\\") if pattern == \\"\\": return [] indices = [] pattern_len = len(pattern) for i in range(len(text) - pattern_len + 1): if text[i:i + pattern_len] == pattern: indices.append(i) return indices"},{"question":"# Coding Assessment Question: Your task is to implement the Insertion Sort algorithm to sort an unsorted list of integers in ascending order. Write a function `insertion_sort(arr)` that takes a list of integers `arr` and sorts it using the Insertion Sort algorithm. Input: * A list of integers `arr` (1 ≤ len(arr) ≤ 1000, -10^6 ≤ arr[i] ≤ 10^6). Output: * A sorted list of integers in ascending order. Example: ```python assert insertion_sort([4, 2, 5, 3, 0, 1]) == [0, 1, 2, 3, 4, 5] assert insertion_sort([]) == [] assert insertion_sort([2]) == [2] assert insertion_sort([5, 1, 4, 2, 3]) == [1, 2, 3, 4, 5] ``` Your function will be evaluated on the following: * Correctness of sorting algorithm. * Handling of edge cases such as empty input and single-element input. * Proper placement of elements during the sort. **Constraints**: * Do not use Python’s built-in sort() method or any external libraries for sorting. * Ensure your implementation considers performance and avoids unnecessary computations. **Performance Requirement**: Ensure your implementation is reasonably efficient for the given constraints, targeting a solution that can handle the upper limit of input size within acceptable runtime.","solution":"def insertion_sort(arr): Sorts an array of integers in ascending order using the Insertion Sort algorithm. Args: arr (list): A list of integers. Returns: list: Sorted list of integers. for i in range(1, len(arr)): key = arr[i] j = i - 1 while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Question Context: You are developing a feature for an e-commerce platform that involves tracking the prices of products. You need to frequently determine the median price of items in a given category as new items are added. # Coding Task: Implement a class `MedianPriceTracker` that allows you to add product prices and efficiently find the median price of all added products at any point in time. Use two heaps (a max heap and a min heap) to maintain the prices for efficient median calculation. # Methods: 1. `add_price(price: int) -> None`: Adds a new product price to the tracker. 2. `find_median() -> float`: Returns the median of the current set of product prices. # Input: * Price values are integers. # Output: * `add_price` does not return any value. * `find_median` returns the median price as a float. # Constraints: * Prices are positive integers. * The median of an even set of numbers is the average of the two middle numbers. # Performance Requirements: * The add operation should be performed in O(log n) time. * The find median operation should be performed in O(1) time. # Scenario: Consider the following example scenario to better understand the task requirements. ```python class MedianPriceTracker: def __init__(self): # Your data structure initialization here pass def add_price(self, price: int) -> None: # Your implementation here pass def find_median(self) -> float: # Your implementation here pass # Example: tracker = MedianPriceTracker() tracker.add_price(10) tracker.add_price(20) print(tracker.find_median()) # Output: 15.0 tracker.add_price(30) print(tracker.find_median()) # Output: 20.0 ``` The output should correspond to the median prices as new prices are added. The first call to `find_median` should return 15.0 (the average of 10 and 20), and the second call should return 20.0 as 20 is the middle value in [10, 20, 30].","solution":"import heapq class MedianPriceTracker: def __init__(self): self.min_heap = [] # min heap to store the larger half of the prices self.max_heap = [] # max heap to store the smaller half of the prices def add_price(self, price: int) -> None: heapq.heappush(self.max_heap, -price) # Ensuring the first max_heap element is always less than or equal to the first min_heap element if self.max_heap and self.min_heap and (-self.max_heap[0] > self.min_heap[0]): heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) # Rebalance heaps if the sizes differ by more than one if len(self.max_heap) > len(self.min_heap) + 1: heapq.heappush(self.min_heap, -heapq.heappop(self.max_heap)) if len(self.min_heap) > len(self.max_heap): heapq.heappush(self.max_heap, -heapq.heappop(self.min_heap)) def find_median(self) -> float: if len(self.max_heap) > len(self.min_heap): return float(-self.max_heap[0]) else: return (-self.max_heap[0] + self.min_heap[0]) / 2.0"},{"question":"In this exercise, you are tasked with creating a system to manage a simple inventory for a small shop. The shop keeps track of various items, each identified by a unique item code. An inventory management system should be able to add new items, update the quantity of existing items, and generate a report listing all items with their quantities. # Classes to Implement 1. **Item**: This class should represent an item with the following attributes: - `code` (str): The unique code for the item. - `name` (str): The name of the item. - `quantity` (int): The quantity of the item in stock. 2. **InventoryManagement**: This class should manage the inventory with the following methods: - `add_item(code: str, name: str, quantity: int) -> None`: Adds a new item to the inventory. - `update_quantity(code: str, quantity: int) -> None`: Updates the quantity of an existing item. - `generate_report() -> str`: Generates a report listing all items with their codes, names, and quantities. # Input and Output * **Input**: - For `add_item`: - `code` (str): A unique identifier for the item. - `name` (str): The name of the item. - `quantity` (int): The number of units of the item. - For `update_quantity`: - `code` (str): The unique identifier of the item to update. - `quantity` (int): The new quantity to set for the item. - For `generate_report`: No input. * **Output**: - For `add_item`: No output. - For `update_quantity`: No output. - For `generate_report`: A string report listing all items in the format: \\"<code>: <name>, Quantity: <quantity>n\\". # Constraints * The item code will contain only uppercase letters and numbers, and will be at most 10 characters long. * The item name will contain only letters and spaces, and will be at most 50 characters long. * Quantities will be non-negative integers and at most 10^6. # Example ```python class Item: def __init__(self, code: str, name: str, quantity: int): pass class InventoryManagement: def __init__(self): pass def add_item(self, code: str, name: str, quantity: int) -> None: pass def update_quantity(self, code: str, quantity: int) -> None: pass def generate_report(self) -> str: pass # Example usage: inventory = InventoryManagement() inventory.add_item(\\"A123\\", \\"Apple\\", 50) inventory.add_item(\\"B456\\", \\"Banana\\", 100) inventory.update_quantity(\\"A123\\", 75) print(inventory.generate_report()) # Example Output: # A123: Apple, Quantity: 75 # B456: Banana, Quantity: 100 ``` # Requirements 1. Implement the `Item` class to accurately represent an item in the shop\'s inventory. 2. Design the `InventoryManagement` class to handle adding items, updating their quantities, and generating reports correctly. 3. Ensure that items are added and updated based on their unique codes. The report should list items in the order they were added.","solution":"class Item: def __init__(self, code: str, name: str, quantity: int): self.code = code self.name = name self.quantity = quantity class InventoryManagement: def __init__(self): self.items = {} def add_item(self, code: str, name: str, quantity: int) -> None: if code not in self.items: self.items[code] = Item(code, name, quantity) def update_quantity(self, code: str, quantity: int) -> None: if code in self.items: self.items[code].quantity = quantity def generate_report(self) -> str: report_lines = [] for item in self.items.values(): report_lines.append(f\\"{item.code}: {item.name}, Quantity: {item.quantity}\\") return \\"n\\".join(report_lines)"},{"question":"# Binary Search Tree Insertion Context A Binary Search Tree (BST) is a binary tree in which each node has at most two children, referred to as the left child and the right child. For every node, all values in the left subtree are less than the node\'s value, and all values in the right subtree are greater or equal to the node\'s value. This property makes BST an efficient data structure for search, insertion, and deletion operations. Problem Write a Python function `insert_into_bst` that inserts a value into a Binary Search Tree and returns the root of the updated tree with the following signature: ```python def insert_into_bst(root, value): pass ``` Input & Output **Input:** - **root** (TreeNode): The root of the BST, which is a binary tree node defined as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - **value** (int): The value to be inserted into the BST. **Output:** - **Result:** (TreeNode) The root of the updated BST. Constraints 1. The `value` to be inserted is a valid integer. 2. Each node in the BST is an instance of `TreeNode` and follows the BST properties. Performance Constraints The function should have a time complexity of (O(h)) where (h) is the height of the tree and a space complexity of (O(1)) for the iterative approach or (O(h)) for the recursive approach due to call stack utilization. Examples ```python >>> class TreeNode: ... def __init__(self, val=0, left=None, right=None): ... self.val = val ... self.left = left ... self.right = right >>> def in_order_traversal(root, result=[]): ... if root: ... in_order_traversal(root.left, result) ... result.append(root.val) ... in_order_traversal(root.right, result) ... return result >>> root = TreeNode(5) >>> root = insert_into_bst(root, 3) >>> root = insert_into_bst(root, 7) >>> in_order_traversal(root) [3, 5, 7] >>> root = None >>> root = insert_into_bst(root, 3) >>> in_order_traversal(root) [3] >>> root = TreeNode(3, TreeNode(1), TreeNode(4)) >>> root = insert_into_bst(root, 2) >>> in_order_traversal(root) [1, 2, 3, 4] ``` Note 1. You can assume the binary tree nodes are defined using the `TreeNode` class as provided in the example. 2. The `insert_into_bst` function can be implemented using either an iterative or a recursive approach.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root, value): Inserts a value into the Binary Search Tree and returns the root of the updated tree. if root is None: return TreeNode(value) if value < root.val: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root"},{"question":"# Image Segmentation Using K-Means You are tasked with implementing an image segmentation algorithm using the K-Means clustering method. Image segmentation aims to partition an image into multiple segments (superpixels) to simplify or change the representation of an image into something more meaningful and easier to analyze. # Task Your task is to create a function that segments a given 2D grayscale image using the K-Means clustering algorithm. The function should: 1. **Initialize Clusters**: Randomly initialize cluster centers within the pixel value range. 2. **Assign Pixels to Clusters**: Assign each image pixel to the nearest cluster center. 3. **Update Cluster Centers**: Recalculate the cluster centers as the average of all pixels assigned to it. 4. **Iterate**: Repeat steps 2 and 3 for a fixed number of iterations or until convergence. 5. **Output Segmented Image**: Produce a segmented version of the input image where each pixel is replaced with the value of its corresponding cluster center. # Input - `img (numpy.ndarray)`: A 2D grayscale image with pixel values ranging between 0 and 1. - `num_clusters (int)`: The number of segments/clusters to divide the image into. - `max_iterations (int)`: The maximum number of iterations to perform. # Output - A 2D numpy array with the same dimensions as the input, where each pixel\'s value is replaced by its corresponding cluster center value. # Constraints - `num_clusters` must be a positive integer and less than or equal to the number of unique pixel values in the image. - `max_iterations` must be a positive integer. - The function should be efficient enough to handle images of size up to 2048x2048 pixels. # Example Usage ```python import numpy as np img = np.random.rand(256, 256) num_clusters = 5 max_iterations = 100 segmented_img = kmeans_segmentation(img, num_clusters, max_iterations) ``` # Note You may use any standard libraries available in Python for numerical computations such as `numpy`. Ensure your solution is efficient, clear, and handles edge cases appropriately. # Extension Points - Add comments and documentation to make your code understandable. - Implement unit tests to validate the correctness of your function against different inputs and edge cases.","solution":"import numpy as np def kmeans_segmentation(img, num_clusters, max_iterations): Segments a given 2D grayscale image using the K-Means clustering algorithm. Parameters: - img (numpy.ndarray): A 2D grayscale image with pixel values ranging between 0 and 1. - num_clusters (int): The number of segments/clusters to divide the image into. - max_iterations (int): The maximum number of iterations to perform. Returns: - A 2D numpy array with the same dimensions as the input, where each pixel\'s value is replaced by its corresponding cluster center value. # Flatten the image to a 1D array for easier processing flat_img = img.flatten() # Initialize cluster centers by randomly selecting pixel values cluster_centers = np.random.choice(flat_img, num_clusters, replace=False) for iteration in range(max_iterations): # Assign each pixel to the nearest cluster center distances = np.abs(flat_img[:, np.newaxis] - cluster_centers) closest_clusters = np.argmin(distances, axis=1) # Recalculate the cluster centers new_cluster_centers = np.array([flat_img[closest_clusters == k].mean() for k in range(num_clusters)]) # Check for convergence if np.all(cluster_centers == new_cluster_centers): break cluster_centers = new_cluster_centers # Replace each pixel with the value of its corresponding cluster center segmented_img = np.array([cluster_centers[cluster] for cluster in closest_clusters]) # Reshape the 1D array back to the original image shape segmented_img = segmented_img.reshape(img.shape) return segmented_img"},{"question":"# Scenario Bob is working on a problem where he needs to determine the longest substring within a given string of alphanumeric characters that contains at most two distinct characters. He has asked you to write a function to help with this task. # Coding Task Write a function `longest_substring_two_distinct(s: str) -> int` that finds the length of the longest substring that contains at most two distinct characters. # Input and Output Format - **Input**: - `s` (a string consisting of alphanumeric characters, 1 ≤ len(s) ≤ 1000) - **Output**: - An integer representing the length of the longest substring that contains at most two distinct characters. # Constraints and Assumptions: - The given string `s` will contain only alphanumeric characters (\'0\'-\'9\', \'a\'-\'z\', \'A\'-\'Z\'). - The length of the string `s` will be between 1 and 1000, inclusive. # Example - Example 1: - `s = \\"eceba\\"` - Output: `3` (the substring is \\"ece\\" which contains \'e\' and \'c\') - Example 2: - `s = \\"ccaabbb\\"` - Output: `5` (the substring is \\"aabbb\\" which contains \'a\' and \'b\') **Note**: Consider edge cases such as strings with repeating characters and strings that are already within the constraint.","solution":"def longest_substring_two_distinct(s: str) -> int: Finds the length of the longest substring that contains at most two distinct characters. if len(s) == 0: return 0 max_len = 0 start = 0 char_count = {} for end in range(len(s)): char_end = s[end] char_count[char_end] = char_count.get(char_end, 0) + 1 while len(char_count) > 2: char_start = s[start] char_count[char_start] -= 1 if char_count[char_start] == 0: del char_count[char_start] start += 1 max_len = max(max_len, end - start + 1) return max_len"},{"question":"# Problem Statement You work for a software company that needs to generate unique usernames for new users. Usernames are created using a combination of users\' first and last names. If a username already exists, a numerical suffix should be added to create a unique variant. # Requirements: Implement a function `generate_usernames` that takes in: 1. A list of tuples, where each tuple contains the user\'s first and last name as strings. Your function should return a list of unique usernames generated by the following rules: 1. The initial username is the concatenation of the first and last name in lowercase (e.g., \\"John Doe\\" becomes \\"johndoe\\"). 2. If a username already exists in the list, append a numerical suffix starting at 1 and incrementing by 1 (e.g., \\"johndoe1\\", \\"johndoe2\\", etc.). Constraints: * All names contain only alphabetic characters. * The list of tuples is non-empty. * Each first and last name pair in the tuples are non-empty strings. # Function Signature: ```python from typing import List, Tuple def generate_usernames(names: List[Tuple[str, str]]) -> List[str]: pass ``` # Example: ```python def generate_usernames(names: List[Tuple[str, str]]) -> List[str]: # Your implementation here # Example Usage names = [(\\"John\\", \\"Doe\\"), (\\"Jane\\", \\"Smith\\"), (\\"John\\", \\"Doe\\")] print(generate_usernames(names)) # Output: [\\"johndoe\\", \\"janesmith\\", \\"johndoe1\\"] ``` # Additional Examples: ```python names = [(\\"John\\", \\"Doe\\"), (\\"John\\", \\"Smith\\"), (\\"Jane\\", \\"Doe\\"), (\\"John\\", \\"Doe\\")] print(generate_usernames(names)) # Output: [\\"johndoe\\", \\"johnsmith\\", \\"janedoe\\", \\"johndoe1\\"] names = [(\\"Alice\\", \\"Wonderland\\"), (\\"Alice\\", \\"Wonderland\\"), (\\"Alice\\", \\"Wonderland\\")] print(generate_usernames(names)) # Output: [\\"alicewonderland\\", \\"alicewonderland1\\", \\"alicewonderland2\\"] names = [(\\"Bob\\", \\"Builder\\"), (\\"Bob\\", \\"Builder\\"), (\\"Bob\\", \\"Builder\\"), (\\"Bob\\", \\"Builder\\")] print(generate_usernames(names)) # Output: [\\"bobbuilder\\", \\"bobbuilder1\\", \\"bobbuilder2\\", \\"bobbuilder3\\"] ``` # Notes: * Ensure the function is case-insensitive by converting names to lowercase. * Use a dictionary or other data structure to efficiently check and store existing usernames. * Handle the case of multiple repeated names efficiently.","solution":"from typing import List, Tuple def generate_usernames(names: List[Tuple[str, str]]) -> List[str]: username_counts = {} unique_usernames = [] for first_name, last_name in names: base_username = (first_name + last_name).lower() if base_username not in username_counts: username_counts[base_username] = 0 unique_usernames.append(base_username) else: username_counts[base_username] += 1 new_username = base_username + str(username_counts[base_username]) unique_usernames.append(new_username) return unique_usernames"},{"question":"# Problem: Validate Word Ladder Implementation You are provided with two code snippets implementing methods to solve the Word Ladder problem. The objective is to validate these implementations and fix any flaws. Instructions: 1. **Fix the Bidirectional BFS Implementation**: The provided `word_ladder_bidirectional_bfs` function contains logic errors that cause incorrect results or inefficiencies for certain test cases. Identify and correct these issues. 2. **Fix the Standard BFS Implementation**: Similarly, the provided `word_ladder_bfs` function needs debugging to handle all edge cases properly and run efficiently. 3. Implement both solutions within the provided framework, ensuring that all provided test cases pass successfully. Input: - `beginWord`: a string representing the starting word. - `endWord`: a string representing the target word. - `wordList`: a list of strings representing the dictionary of words available for transformations. Output: - An integer representing the number of transformations needed to convert `beginWord` to `endWord`. If no such transformation sequence exists, return 0. Constraints: - The length of all words is the same. - All strings contain only lowercase alphabetical characters. - The dictionary does not contain duplicates. - The transformation must change exactly one character at a time. Example Usage: ```python beginWord = \\"hit\\" endWord = \\"cog\\" wordList = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"] print(word_ladder_bidirectional_bfs(beginWord, endWord, wordList)) # 5 print(word_ladder_bfs(beginWord, endWord, wordList)) # 5 beginWord2 = \\"hit\\" endWord2 = \\"cog\\" wordList2 = [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"] print(word_ladder_bidirectional_bfs(beginWord2, endWord2, wordList2)) # 0 print(word_ladder_bfs(beginWord2, endWord2, wordList2)) # 0 ``` Constraints: - (1 leq text{wordList length} leq 5000) - (1 leq text{word length} leq 10) You will be graded on: - Correctness: The fixed implementation should handle all edge cases correctly. - Efficiency: Ensure that the solution operates within acceptable time and space complexity limits. - Clarity: Code readability and proper documentation. Make sure to test your implementation thoroughly against all provided test cases.","solution":"# Fixing the Bidirectional BFS Implementation def word_ladder_bidirectional_bfs(beginWord, endWord, wordList): from collections import deque, defaultdict if endWord not in wordList: return 0 L = len(beginWord) all_combo_dict = defaultdict(list) for word in wordList: for i in range(L): all_combo_dict[word[:i] + \'*\' + word[i+1:]].append(word) queue_begin = deque([(beginWord, 1)]) queue_end = deque([(endWord, 1)]) visited_begin = {beginWord: 1} visited_end = {endWord: 1} def visit_word_node(queue, visited, other_visited): current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \'*\' + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word in other_visited: return level + other_visited[word] if word not in visited: visited[word] = level + 1 queue.append((word, level + 1)) return None while queue_begin and queue_end: ans = visit_word_node(queue_begin, visited_begin, visited_end) if ans: return ans ans = visit_word_node(queue_end, visited_end, visited_begin) if ans: return ans return 0 # Fixing the Standard BFS Implementation def word_ladder_bfs(beginWord, endWord, wordList): from collections import deque, defaultdict if endWord not in wordList: return 0 L = len(beginWord) all_combo_dict = defaultdict(list) for word in wordList: for i in range(L): all_combo_dict[word[:i] + \'*\' + word[i+1:]].append(word) queue = deque([(beginWord, 1)]) visited = {beginWord: True} while queue: current_word, level = queue.popleft() for i in range(L): intermediate_word = current_word[:i] + \'*\' + current_word[i+1:] for word in all_combo_dict[intermediate_word]: if word == endWord: return level + 1 if word not in visited: visited[word] = True queue.append((word, level + 1)) all_combo_dict[intermediate_word] = [] return 0"},{"question":"# Problem Statement Write a function `find_first_non_repeating_char` that identifies the first non-repeating character in a given string. If all characters are repeating, the function should return an underscore (\'_\'). The function should be case-sensitive. # Function Signature ```python def find_first_non_repeating_char(s: str) -> str: ``` # Input * `s`: A string containing the characters to be processed. # Output * A single character that is the first non-repeating character in the string. * If there is no non-repeating character, return the underscore (\'_\'). # Constraints * The string `s` will have a length between 1 and 10^5. * The string will only contain printable ASCII characters. # Example ```python # Example usage s = \\"swiss\\" print(find_first_non_repeating_char(s)) # Output: \\"w\\" s = \\"hello\\" print(find_first_non_repeating_char(s)) # Output: \\"h\\" s = \\"aabbcc\\" print(find_first_non_repeating_char(s)) # Output: \\"_\\" s = \\"aAbBcC\\" print(find_first_non_repeating_char(s)) # Output: \\"a\\" s = \\"\\" print(find_first_non_repeating_char(s)) # Output: \\"_\\" ``` # Additional Notes * Ensure your implementation is efficient in terms of both time and space complexity, considering the upper constraint of the string length. * Pay attention to case sensitivity; \'a\' and \'A\' should be considered different characters.","solution":"def find_first_non_repeating_char(s: str) -> str: Identifies the first non-repeating character in a given string. If all characters are repeating, returns an underscore (\'_\'). Parameters: s (str): The string to be processed. Returns: str: The first non-repeating character or \'_\' if all characters are repeating. char_count = {} # First pass: count occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Second pass: find the first character with a count of 1 for char in s: if char_count[char] == 1: return char return \'_\'"},{"question":"# Coding Challenge: Order Management System Your task is to create a Python script to manage orders in an e-commerce system. You should implement functionality to add new orders, update existing orders, and retrieve information about an order. Function Signatures ```python def add_order(order_id: int, customer_name: str, order_details: dict) -> str: Add a new order to the order management system. Args: order_id (int): Unique identifier for the order. customer_name (str): Name of the customer who placed the order. order_details (dict): Details of the order including items and quantities. Returns: str: Confirmation message indicating the order was added successfully. def update_order(order_id: int, updates: dict) -> str: Update an existing order in the order management system. Args: order_id (int): Unique identifier for the order. updates (dict): Updated details of the order including items and quantities. Returns: str: Confirmation message indicating the order was updated successfully or an error message if the order does not exist. def get_order(order_id: int) -> dict: Retrieve details of an order from the order management system. Args: order_id (int): Unique identifier for the order. Returns: dict: Details of the order including customer name and order items or an error message if the order does not exist. ``` # Instructions 1. **Order Management**: - Implement the `add_order` function to add a new order to the system. Ensure that order IDs are unique. - Implement the `update_order` function to update an existing order. If the order does not exist, return an appropriate error message. - Implement the `get_order` function to fetch details of an order. If the order does not exist, return an appropriate error message. 2. **Data Handling**: - Store orders in an appropriate data structure to facilitate efficient read and write operations. - Each order should include the customer name and a dictionary of items with their respective quantities. 3. **Error Handling**: - Handle cases where order IDs already exist when adding a new order. - Handle cases where an order update is attempted on a non-existent order. - Handle cases where an order retrieval is attempted on a non-existent order. 4. **Testing**: - Write tests covering various scenarios including adding orders, updating orders, retrieving orders, and handling non-existent orders. # Constraints - Order IDs are unique positive integers. - Assume valid input formats for customer names and order details. ```python orders = {} def add_order(order_id: int, customer_name: str, order_details: dict) -> str: if order_id in orders: return \\"Error: Order ID already exists.\\" orders[order_id] = {\\"customer_name\\": customer_name, \\"order_details\\": order_details} return \\"Order added successfully.\\" def update_order(order_id: int, updates: dict) -> str: if order_id not in orders: return \\"Error: Order does not exist.\\" orders[order_id][\\"order_details\\"].update(updates) return \\"Order updated successfully.\\" def get_order(order_id: int) -> dict: if order_id not in orders: return {\\"Error\\": \\"Order does not exist.\\"} return orders[order_id] if __name__ == \\"__main__\\": from pprint import pprint # Example usage order_id = 1 customer_name = \\"Alice\\" order_details = {\\"item1\\": 2, \\"item2\\": 1} print(add_order(order_id, customer_name, order_details)) print(get_order(order_id)) updates = {\\"item1\\": 3, \\"item3\\": 4} print(update_order(order_id, updates)) pprint(get_order(order_id)) ``` # Example ```python >>> add_order(1, \\"Alice\\", {\\"item1\\": 2, \\"item2\\": 1}) \'Order added successfully.\' >>> get_order(1) {\'customer_name\': \'Alice\', \'order_details\': {\'item1\': 2, \'item2\': 1}} >>> update_order(1, {\\"item1\\": 3, \\"item3\\": 4}) \'Order updated successfully.\' >>> get_order(1) {\'customer_name\': \'Alice\', \'order_details\': {\'item1\': 3, \'item2\': 1, \'item3\': 4}} >>> get_order(2) {\'Error\': \'Order does not exist.\'} ``` Ensure your functions handle the specified requirements and examples efficiently.","solution":"orders = {} def add_order(order_id: int, customer_name: str, order_details: dict) -> str: if order_id in orders: return \\"Error: Order ID already exists.\\" orders[order_id] = {\\"customer_name\\": customer_name, \\"order_details\\": order_details} return \\"Order added successfully.\\" def update_order(order_id: int, updates: dict) -> str: if order_id not in orders: return \\"Error: Order does not exist.\\" orders[order_id][\\"order_details\\"].update(updates) return \\"Order updated successfully.\\" def get_order(order_id: int) -> dict: if order_id not in orders: return {\\"Error\\": \\"Order does not exist.\\"} return orders[order_id]"},{"question":"# Problem Statement You are tasked with implementing functions to enhance a binary search tree (BST) with additional functionality. The implementation provided already covers fundamental operations, we will build on it to add a few more complex and practical functions. # Requirements 1. Implement a function `find_height` that returns the height of the BST. Height is defined as the number of edges in the longest path from the root to a leaf node. 2. Implement a function `is_balanced` that checks if the BST is height-balanced. A BST is height-balanced if for every node, the difference in height between the left and right subtrees is no more than 1. 3. Implement a function `find_kth_smallest` that returns the k-th smallest element in the BST. 4. Enhance the `delete` function to ensure it works correctly even when deleting nodes with two children. # Provided Code You have the implementation of `TreeNode` and `BinarySearchTree` classes, and you will need to add your implementations to the `BinarySearchTree` class. # Function Signatures ```python def find_height(self) -> int: pass def is_balanced(self) -> bool: pass def find_kth_smallest(self, k: int) -> int: pass def delete(self, key: int) -> None: pass ``` # Input and Output Formats * **find_height**: - **Input**: No additional input. - **Output**: Integer representing the height of the tree. * **is_balanced**: - **Input**: No additional input. - **Output**: Boolean indicating if the tree is balanced. * **find_kth_smallest**: - **Input**: An integer k. - **Output**: The k-th smallest element in the BST. * **delete**: - **Input**: An integer key representing the node to be deleted. - **Output**: No output, modifies the tree in place. # Constraints 1. Your solution should handle large BSTs efficiently. 2. Pay attention to edge cases like empty trees, single-node trees, and trees with only left or right subtrees. 3. For `is_balanced`, the tree is said to be balanced if for every node, the height of its left and right subtree differs by at most 1. 4. For `find_kth_smallest`, assume k is valid and within the range of the number of elements in the BST. # Scenario Mary is a data scientist working with hierarchical data structures represented in binary search trees. She needs to quickly determine the tree\'s height, check if it\'s balanced, efficiently find the k-th smallest element, and handle node deletions robustly. Implement the functions to aid Mary in her tasks. # Usage Example ```python bst = BinarySearchTree() elements = [20, 10, 30, 5, 15, 25, 35] for element in elements: bst.insert(element) print(bst.find_height()) # Output: 2 print(bst.is_balanced()) # Output: True print(bst.find_kth_smallest(3)) # Output: 15 bst.delete(10) print(bst.find_kth_smallest(3)) # Output: 20 ``` To implement the `find_height`, `is_balanced`, `find_kth_smallest`, and enhanced `delete` methods, add them to your `BinarySearchTree` class accordingly and test them with the provided scenarios.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, node, key): if key < node.val: if node.left is None: node.left = TreeNode(key) else: self._insert(node.left, key) else: if node.right is None: node.right = TreeNode(key) else: self._insert(node.right, key) def find_height(self): def _find_height(node): if not node: return -1 left_height = _find_height(node.left) right_height = _find_height(node.right) return 1 + max(left_height, right_height) return _find_height(self.root) def is_balanced(self): def _check_balance(node): if not node: return (True, -1) left_balanced, left_height = _check_balance(node.left) right_balanced, right_height = _check_balance(node.right) current_balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) current_height = 1 + max(left_height, right_height) return (current_balanced, current_height) is_bal, height = _check_balance(self.root) return is_bal def find_kth_smallest(self, k): def _inorder_traverse(node): if not node: return [] return _inorder_traverse(node.left) + [node.val] + _inorder_traverse(node.right) elements = _inorder_traverse(self.root) return elements[k - 1] if 0 <= k - 1 < len(elements) else None def delete(self, key): def _delete(node, key): if node is None: return node if key < node.val: node.left = _delete(node.left, key) elif key > node.val: node.right = _delete(node.right, key) else: if node.left is None: return node.right elif node.right is None: return node.left temp = self._min_value_node(node.right) node.val = temp.val node.right = _delete(node.right, temp.val) return node self.root = _delete(self.root, key) def _min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Coding Assessment Question You are working on a text processing application that needs to accurately identify and highlight all the palindromes in a given sentence. A palindrome is a word that reads the same backward as forwards, ignoring case and punctuation. Your task is to create a function that can identify these palindromes and format them with special markers. # Task Write a function `highlight_palindromes(sentence: str) -> str` that: 1. Identifies all palindromic words in the provided sentence. 2. Highlights these palindromic words by surrounding them with `**` markers. 3. Ignores punctuation and cases while checking for palindromic nature but retains the original casing in the output. 4. Can handle sentences containing various punctuation marks and whitespace. # Constraints - The function should work efficiently even for longer sentences (up to 1000 characters long). - Only consider words of length 3 or more as potential palindromes. # Input - `sentence` (str): A sentence containing multiple words, spaces, and punctuation (e.g., \\"A man, a plan, a canal, Panama\\"). # Output - Returns a string where all palindromic words are highlighted with `**` markers. # Example ```python print(highlight_palindromes(\\"Anna went to see civic structures in the radar area.\\")) ``` *Output*: ``` **Anna** went to see **civic** structures in the **radar** area. ``` # Implementation Notes - Use regular expressions to identify and separate words from punctuation. - Convert words to lowercase for palindrome comparison but preserve their original forms in the output. - Ensure the function handles edge cases such as single-word sentences, and sentences with no palindromes.","solution":"import re def highlight_palindromes(sentence: str) -> str: Identifies palindromic words in the input sentence and highlights them with ** markers. def is_palindrome(word: str) -> bool: # Check for palindromes of length 3 or more, ignoring case word = re.sub(r\'[^w]\', \'\', word).lower() return len(word) >= 3 and word == word[::-1] words = re.findall(r\'bw+b\', sentence) highlighted_sentence = sentence for word in words: if is_palindrome(word): highlighted_sentence = re.sub(r\'b\'+re.escape(word)+r\'b\', f\'**{word}**\', highlighted_sentence) return highlighted_sentence"},{"question":"# Coding Challenge: Finding Subarray with Maximum Product Scenario You are tasked as a software developer to enhance the performance of a financial analytics tool. One of the features that need optimization is a function that determines the subarray with the highest product from an array of integers. This tool is used for analyzing trends in profit and loss figures over specific periods, where finding the segment with the peak multiplication value is crucial for forecasting and recommendations. Question Write a Python function that finds the subarray within a list of integers that has the maximum product and returns that maximum product. Function Signature ```python def max_product_subarray(nums: List[int]) -> int: Given a list of integers, returns the maximum product of a contiguous subarray. Args: nums: List[int] - A list of integers (both positive and negative). Returns: int - The maximum product of a contiguous subarray. ``` Input/Output * **Input**: A list of integers, `nums` where -10 ≤ nums[i] ≤ 10, and the length of `nums` is between 1 and 100. * **Output**: An integer representing the maximum product of a contiguous subarray. Constraints 1. The list contains at least one number. 2. The list may contain both positive and negative numbers, as well as zero. 3. The function should handle all edge cases efficiently. Performance Requirement Ensure that your solution runs in O(n) time complexity. Example ```python max_product_subarray([2, 3, -2, 4]) # Expected output: 6 max_product_subarray([-2, 0, -1]) # Expected output: 0 ``` **Note**: Leverage dynamic programming techniques to efficiently solve this problem.","solution":"from typing import List def max_product_subarray(nums: List[int]) -> int: if not nums: return 0 max_product = nums[0] min_product = nums[0] result = nums[0] for num in nums[1:]: if num < 0: max_product, min_product = min_product, max_product max_product = max(num, max_product * num) min_product = min(num, min_product * num) result = max(result, max_product) return result"},{"question":"# Coding Question: Implement Circular Buffer Objective Write a class that implements a circular buffer with fixed size, supporting standard operations such as insert, remove, and get. The buffer should rely on circular array logic to efficiently manage inserts and removals. Class Signature ```python class CircularBuffer: def __init__(self, size: int): Initialize a circular buffer with the given size. def insert(self, value: int) -> None: Insert an element into the circular buffer. If the buffer is full, the oldest element will be overwritten. def remove(self) -> int: Remove and return the oldest element from the circular buffer. Raises IndexError if the buffer is empty. def get(self) -> list: Return a list of elements currently in the buffer, starting from the oldest to the newest. ``` Description **You need to implement a class `CircularBuffer` that simulates a circular buffer with a fixed size.** Input and Output Formats **Input**: * `size` (in `__init__`): An integer specifying the size of the buffer (number of slots it can hold). * `value` (in `insert` method): An integer to insert into the buffer. **Output**: * `remove` method should return an integer, the element being removed from the buffer. * `get` method should return a list of integers, representing the buffer\'s content from oldest to newest. Constraints 1. The buffer size must be a positive integer greater than 0. 2. The `insert` method should handle overwriting the oldest data if the buffer is full. 3. The `remove` method should raise an `IndexError` if the buffer is empty. Examples ```python # Example Usage cb = CircularBuffer(3) cb.insert(1) cb.insert(2) cb.insert(3) print(cb.get()) # [1, 2, 3] cb.insert(4) print(cb.get()) # [2, 3, 4] print(cb.remove()) # 2 print(cb.get()) # [3, 4] cb.insert(5) print(cb.get()) # [3, 4, 5] cb.insert(6) print(cb.get()) # [4, 5, 6] cb.insert(7) cb.insert(8) print(cb.get()) # [6, 7, 8] print(cb.remove()) # 6 print(cb.remove()) # 7 print(cb.remove()) # 8 # Removing from empty buffer should raise an error # cb.remove() # Raises IndexError ``` Implementation Notes * Internally manage the buffer using a list. * Maintain indices to track the start (oldest element) and the number of current elements in the buffer. * Optimize insert and remove operations to be O(1) by properly managing indices. * Ensure that the `get` method assembles the list of elements in the correct order. This new question fits well with the coding assessment by testing understanding of data structures, logic for circular operations, and class implementation in Python without relying on simple built-in functionalities. It provides a clear, structured problem that students or candidates can follow and solves common algorithmic challenges related to data management.","solution":"class CircularBuffer: def __init__(self, size: int): Initialize a circular buffer with the given size. self.size = size self.buffer = [None] * size self.start = 0 self.count = 0 def insert(self, value: int) -> None: Insert an element into the circular buffer. If the buffer is full, the oldest element will be overwritten. # Calculate index to insert the element index = (self.start + self.count) % self.size # Insert the value self.buffer[index] = value # If buffer is already full, move start to next position if self.count == self.size: self.start = (self.start + 1) % self.size else: self.count += 1 def remove(self) -> int: Remove and return the oldest element from the circular buffer. Raises IndexError if the buffer is empty. if self.count == 0: raise IndexError(\\"remove from empty buffer\\") # Get the value from the start position value = self.buffer[self.start] # Set the position to None (optional) self.buffer[self.start] = None # Move start to the next position self.start = (self.start + 1) % self.size self.count -= 1 return value def get(self) -> list: Return a list of elements currently in the buffer, starting from the oldest to the newest. result = [] for i in range(self.count): index = (self.start + i) % self.size result.append(self.buffer[index]) return result"},{"question":"# Problem Statement You are required to implement two utility functions: `base64_encode` and `base64_decode`. These functions will perform encoding of binary data into base64 format and decoding of such base64 strings back to binary data correspondingly. **Function 1: `base64_encode`** - **Input**: A `bytes` object `data`. - **Output**: A `str` object representing the corresponding base64 encoding of the input data. - **Constraints**: - The output base64 string must be padded to a multiple of 4 characters using `=` characters if necessary. - The input `data` can be an empty byte string. **Function 2: `base64_decode`** - **Input**: A `str` object `data` representing base64 encoded data. - **Output**: A `bytes` object which is the decoded representation of the input data. - **Constraints**: - The input `data` must be properly padded with `=` characters if necessary. - The input `data` can only contain valid base64 characters (A-Z, a-z, 0-9, +, /). - If the input data is invalid, the function should raise a `ValueError` with a descriptive message. # Example ```python def base64_encode(data: bytes) -> str: \'\'\' This function encodes the input bytes into a base64 encoded string. \'\'\' pass # TODO: Write the implementation here def base64_decode(data: str) -> bytes: \'\'\' This function decodes the input base64 encoded string back into bytes. \'\'\' pass # TODO: Write the implementation here # Test Cases assert base64_encode(b\'Hello World!\') == \'SGVsbG8gV29ybGQh\' assert base64_encode(b\'HELLO WORLD!\') == \'SEVMTE8gV09STEQh\' assert base64_encode(b\'\') == \'\' assert base64_decode(\'SGVsbG8gV29ybGQh\') == b\'Hello World!\' assert base64_decode(\'SEVMTE8gV09STEQh\') == b\'HELLO WORLD!\' assert base64_decode(\'\') == b\'\' try: base64_decode(\'SGVsbG8gV29ybGQh\') except ValueError as e: assert str(e) == \'Base64 encoded data is invalid: Contains invalid characters.\' try: base64_decode(\'SGVsbG8gV29ybGQ\') except ValueError as e: assert str(e) == \'Base64 encoded data is invalid: Input is poorly padded or has invalid length.\' ``` **Additional Note**: - Ensure your code handles edge cases and invalid inputs appropriately, raising exceptions with meaningful messages. - The implementation should be efficient and correctly handle very large input data within the constraints.","solution":"import base64 def base64_encode(data: bytes) -> str: Encodes the input bytes into a base64 encoded string. return base64.b64encode(data).decode(\'utf-8\') def base64_decode(data: str) -> bytes: Decodes the input base64 encoded string back into bytes. try: return base64.b64decode(data, validate=True) except (ValueError, base64.binascii.Error): raise ValueError(\\"Base64 encoded data is invalid: Input is poorly padded or contains invalid characters.\\")"},{"question":"**Context:** Given the increasing importance of data manipulation and processing in software development, efficiently merging data structures is a vital skill. One such task is merging two sorted arrays into one sorted array. **Question:** Write a function `merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]` that merges two given sorted arrays `arr1` and `arr2` into one sorted array without using any built-in sorting functions. **Expected Input and Output:** * **Input:** Two sorted lists of integers `arr1` and `arr2`. For example, `arr1 = [1, 3, 5]` and `arr2 = [2, 4, 6]`. * **Output:** A single sorted list containing all elements from both input lists in ascending order. Using the given example, the output should be `[1, 2, 3, 4, 5, 6]`. **Function Signature:** ```python from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: pass ``` **Constraints:** - Each input array may contain up to (10^5) elements. - The elements in each input array are sorted in ascending order. - The combined array should be sorted in ascending order.","solution":"from typing import List def merge_sorted_arrays(arr1: List[int], arr2: List[int]) -> List[int]: Merges two sorted arrays into one sorted array. Parameters: arr1 (List[int]): First sorted array. arr2 (List[int]): Second sorted array. Returns: List[int]: The merged sorted array. merged_array = [] i = 0 j = 0 # Use a two-pointer approach to merge the arrays while i < len(arr1) and j < len(arr2): if arr1[i] < arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Add the remaining elements from arr1, if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 # Add the remaining elements from arr2, if any while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"**Problem Statement:** As an application developer, you are tasked with designing a file system simulation. Using simple commands, this file system will allow users to create directories, create files, read from files, and write to files. Your task is to implement a class that manages the file system and responds to a series of commands. **Class Signature:** ```python class SimpleFileSystem: def __init__(self): pass def create_file(self, path: str, content: str) -> bool: pass def create_directory(self, path: str) -> bool: pass def read_file(self, path: str) -> str: pass def write_file(self, path: str, content: str) -> bool: pass ``` **Input/Output Descriptions:** - `__init__()`: Initializes the file system with a root directory. - `create_file(path: str, content: str) -> bool`: Creates a file at the specified `path` with the given `content`. Returns `True` if the file is created successfully, and `False` if the path is invalid or the file already exists. - `create_directory(path: str) -> bool`: Creates a directory at the specified `path`. Returns `True` if the directory is created successfully, and `False` if the path is invalid or the directory already exists. - `read_file(path: str) -> str`: Reads the content of the file at the specified `path` and returns it. If the file does not exist, returns an empty string. - `write_file(path: str, content: str) -> bool`: Writes the given `content` to the file at the specified `path`. Returns `True` if the content is written successfully, and `False` if the file does not exist. **Constraints:** - The `path` always starts with a forward slash (\'/\'), representing the root directory. - Path components are separated by forward slashes (\'/\'). - Directory and file names consist of alphanumeric characters only, with a maximum length of 255 characters. - Directories and files cannot have the same name at the same level. **Example:** ```python fs = SimpleFileSystem() assert fs.create_directory(\'/home\') == True assert fs.create_file(\'/home/file.txt\', \'Hello, World!\') == True assert fs.read_file(\'/home/file.txt\') == \'Hello, World!\' assert fs.write_file(\'/home/file.txt\', \'Goodbye, World!\') == True assert fs.read_file(\'/home/file.txt\') == \'Goodbye, World!\' assert fs.create_file(\'/home/file.txt\', \'Overwrite?\') == False assert fs.create_directory(\'/home\') == False assert fs.create_directory(\'/home/docs\') == True assert fs.create_file(\'/home/docs/readme.md\', \'# Readme\') == True assert fs.read_file(\'/home/docs/readme.md\') == \'# Readme\' assert fs.read_file(\'/nonexistent/file.txt\') == \'\' print(\\"All test cases passed!\\") ``` **Explanation:** - This example demonstrates the creation of directories and files, reading from and writing to files, and handling edge cases where the path is invalid or the file already exists. Implementing this file system will help you understand directory and file management in a simplified environment.","solution":"class SimpleFileSystem: def __init__(self): self.fs = {\\"type\\": \\"directory\\", \\"content\\": {}} def _traverse_path(self, path: str): components = path.strip(\\"/\\").split(\\"/\\") current = self.fs for component in components[:-1]: if \\"content\\" in current and component in current[\\"content\\"] and current[\\"content\\"][component][\\"type\\"] == \\"directory\\": current = current[\\"content\\"][component] else: return None, None return current, components[-1] def create_file(self, path: str, content: str) -> bool: dir_node, file_name = self._traverse_path(path) if dir_node is None or file_name in dir_node[\\"content\\"]: return False dir_node[\\"content\\"][file_name] = {\\"type\\": \\"file\\", \\"content\\": content} return True def create_directory(self, path: str) -> bool: dir_node, new_dir_name = self._traverse_path(path) if dir_node is None or new_dir_name in dir_node[\\"content\\"]: return False dir_node[\\"content\\"][new_dir_name] = {\\"type\\": \\"directory\\", \\"content\\": {}} return True def read_file(self, path: str) -> str: dir_node, file_name = self._traverse_path(path) if dir_node is None or file_name not in dir_node[\\"content\\"] or dir_node[\\"content\\"][file_name][\\"type\\"] != \\"file\\": return \'\' return dir_node[\\"content\\"][file_name][\\"content\\"] def write_file(self, path: str, content: str) -> bool: dir_node, file_name = self._traverse_path(path) if dir_node is None or file_name not in dir_node[\\"content\\"] or dir_node[\\"content\\"][file_name][\\"type\\"] != \\"file\\": return False dir_node[\\"content\\"][file_name][\\"content\\"] = content return True"},{"question":"Array Manipulations # Context: In data processing, it\'s common to perform a sequence of operations on an array of numbers. These operations could range from updating specific elements, incrementing a range of values, or even reversing a segment of the array. You are given an array of integers and a series of operations to perform on this array. Each operation is of one of three types: 1. **Update Operation:** Set the value at a specific index to a given number. 2. **Increment Operation:** Increment all elements in a specific range by a given number. 3. **Reverse Operation:** Reverse the segment of the array between two given indices. Your task is to implement functions to perform these operations and return the final state of the array after all operations. # Task: Write a Python function that performs a series of operations on an array and returns the array after all operations have been applied. # Requirements: 1. Implement a function `array_operations(arr: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]` where: - `arr` is the initial array of integers. - `operations` is a list of operations, where each operation is a tuple `(op_type, start, end, value)`. - `op_type` is a string that can be `\\"update\\"`, `\\"increment\\"`, or `\\"reverse\\"`. - `start` and `end` are indices in the array (inclusive) where the operation should be applied. - `value` is the new value for an update operation or the increment amount for an increment operation. It is ignored for reverse operations. 2. The function should handle edge cases such as operations on empty arrays and invalid indices appropriately. # Constraints: * Assume the array length does not exceed 1000. * The operations list length does not exceed 1000. * Indices provided in operations are valid and within array bounds. * `value` for increment operations is an integer between -1000 and 1000. * `update` and `increment` operations should be performed optimally to handle large arrays and numerous operations efficiently. # Example: ```python def array_operations(arr: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]: # Your implementation here # Example usage: initial_array = [1, 2, 3, 4, 5] ops = [ (\\"update\\", 1, 1, 10), # arr becomes [1, 10, 3, 4, 5] (\\"increment\\", 0, 2, 3), # arr becomes [4, 13, 6, 4, 5] (\\"reverse\\", 1, 3, 0) # arr becomes [4, 4, 6, 13, 5] ] result = array_operations(initial_array, ops) print(result) # Expected output: [4, 4, 6, 13, 5] ``` # Performance: Ensure that your solution considers the efficiency of operations, especially for large arrays and numerous operations. Aim for optimal time and space complexity, possibly utilizing techniques such as lazy updates or segment trees for range operations.","solution":"from typing import List, Tuple def array_operations(arr: List[int], operations: List[Tuple[str, int, int, int]]) -> List[int]: def update(arr: List[int], index: int, value: int): arr[index] = value def increment(arr: List[int], start: int, end: int, value: int): for i in range(start, end + 1): arr[i] += value def reverse(arr: List[int], start: int, end: int): arr[start:end + 1] = arr[start:end + 1][::-1] for op_type, start, end, value in operations: if op_type == \\"update\\": update(arr, start, value) elif op_type == \\"increment\\": increment(arr, start, end, value) elif op_type == \\"reverse\\": reverse(arr, start, end) return arr"},{"question":"# Matrix Multiplication Context Matrix multiplication is a fundamental operation in linear algebra, used frequently in scientific computing, engineering, and computer graphics. Given two matrices ( A ) and ( B ), the product ( C ) is a matrix such that ( C[i][j] = sum_{k=1}^{n} A[i][k] times B[k][j] ). Objective Write a function `matrix_multiplication(A, B)` that takes two 2D lists of numbers as input representing matrices ( A ) and ( B ), and returns a 2D list representing the resultant matrix ( C ) after performing matrix multiplication. Input - Two 2D lists `A` and `B` such that: * `A` is of dimensions ( m times n ). * `B` is of dimensions ( n times p ). * Each element in both matrices is a float. * ( 1 leq m, n, p leq 100 ). Output - A 2D list `C` of dimensions ( m times p ) representing the result of matrix multiplication. Example ```python A = [ [1, 2], [3, 4], [5, 6] ] B = [ [7, 8, 9], [10, 11, 12] ] C = matrix_multiplication(A, B) # C should be: # [ # [27, 30, 33], # [61, 68, 75], # [95, 106, 117] # ] ``` Constraints 1. Do not use any external libraries except for basic mathematical operations. 2. Ensure that the dimensions of ( A ) and ( B ) are compatible for matrix multiplication. 3. Handle edge cases gracefully. 4. Your function should terminate within a reasonable time for the given constraints. Note - If ( A ) is of dimensions ( m times n ) and ( B ) is ( n times p ), then the resultant matrix ( C ) will have dimensions ( m times p ).","solution":"def matrix_multiplication(A, B): Multiplies two matrices A and B and returns the result as a new matrix. :param A: List of lists representing matrix A (dimensions m x n) :param B: List of lists representing matrix B (dimensions n x p) :return: List of lists representing matrix C (dimensions m x p) m = len(A) n = len(A[0]) p = len(B[0]) # Initialize the result matrix with zeros C = [[0 for _ in range(p)] for _ in range(m)] for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"Question: Implementing and Optimizing a Simplified Social Network Graph # Background You have been hired by a tech startup to develop a component of their new social network platform. One key feature is the \\"friend recommendation\\" system, which suggests new friends based on mutual friends. Your task is to build the core graph functionalities supporting this feature, namely friend connections and mutual friend detection. # Task Modify the provided `SocialNetworkGraph` class to: 1. **Manage Friend Connections**: - Implement methods to add and remove friend connections between users. - Implement a method to retrieve all friends of a specific user. 2. **Mutual Friend Recommendation**: - Implement a method to recommend new friends for a user based on mutual friends. - Utilize an efficient algorithm that can handle large networks. # Specifications 1. **Friend Connections**: - Implement `add_friend(user1, user2)` that establishes a friendship between `user1` and `user2`. - Implement `remove_friend(user1, user2)` that ends the friendship between `user1` and `user2`. - Implement `get_friends(user)` that returns a list of friends for the specified `user`. 2. **Friend Recommendation**: - Implement `recommend_friends(user)` that returns a list of suggested friends for the specified `user` based on the number of mutual friends. # Requirements - **Input**: - The `SocialNetworkGraph` class should be initialized and the users should be added using the existing methods. - Users can be represented as integers or strings (as unique identifiers). - **Output**: - `add_friend` and `remove_friend` methods should update the graph\'s state. - `get_friends` should return a list of friends. - `recommend_friends` should return a sorted list of users based on mutual friend count, in descending order of mutual friends. - **Constraints**: - Assume the network can have up to 50,000 users. - Each user can have up to 1,000 friends. - Ensure efficient implementation to handle large data sets. # Example ```python # Example usage: sn = SocialNetworkGraph() sn.add_user(\'Alice\') sn.add_user(\'Bob\') sn.add_user(\'Charlie\') sn.add_user(\'David\') sn.add_friend(\'Alice\', \'Bob\') sn.add_friend(\'Alice\', \'Charlie\') sn.add_friend(\'Bob\', \'Charlie\') sn.add_friend(\'Bob\', \'David\') print(sn.get_friends(\'Alice\')) # Output: [\'Bob\', \'Charlie\'] print(sn.recommend_friends(\'Alice\')) # Output: [\'David\'] since \'Bob\' and \'Charlie\' are common friends to \'David\' ``` # Evaluation - Ensure the graph maintains accurate friend relationships. - Efficiently implement mutual friend recommendation. - Handle large networks with high performance.","solution":"class SocialNetworkGraph: def __init__(self): self.network = {} def add_user(self, user): if user not in self.network: self.network[user] = set() def add_friend(self, user1, user2): self.add_user(user1) self.add_user(user2) self.network[user1].add(user2) self.network[user2].add(user1) def remove_friend(self, user1, user2): if user1 in self.network and user2 in self.network[user1]: self.network[user1].remove(user2) if not self.network[user1]: del self.network[user1] if user2 in self.network and user1 in self.network[user2]: self.network[user2].remove(user1) if not self.network[user2]: del self.network[user2] def get_friends(self, user): if user in self.network: return list(self.network[user]) return [] def recommend_friends(self, user): if user not in self.network: return [] friends = self.network[user] mutual_friend_count = {} for friend in friends: for potential_friend in self.network[friend]: if potential_friend != user and potential_friend not in friends: if potential_friend not in mutual_friend_count: mutual_friend_count[potential_friend] = 0 mutual_friend_count[potential_friend] += 1 sorted_recommendations = sorted(mutual_friend_count.items(), key=lambda x: (-x[1], x[0])) return [user for user, count in sorted_recommendations]"},{"question":"# Matrix Transpose Checker Objective Implement a function that checks if two matrices are transposes of each other. Problem Statement Implement a function `is_transpose(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool` that verifies if `matrix2` is the transpose of `matrix1`. Input and Output * **Input**: * `matrix1`: A 2-D list of integers representing the first matrix. * `matrix2`: A 2-D list of integers representing the second matrix. * **Output**: * Returns `True` if `matrix2` is the transpose of `matrix1`, otherwise returns `False`. Constraints * Both matrices will have valid dimensions, i.e., if `matrix1` is of size m x n, then `matrix2` will be of size n x m. * Each matrix can have up to 10^4 elements. Performance Requirement The function should run in (O(m times n)) time complexity where `m` and `n` are the dimensions of `matrix1`. Example ```python >>> is_transpose([[1, 2, 3], [4, 5, 6]], [[1, 4], [2, 5], [3, 6]]) True >>> is_transpose([[1, 2], [3, 4]], [[1, 3], [2, 5]]) False >>> is_transpose([[1]], [[1]]) True >>> is_transpose([[1, 2], [3, 4]], [[1, 3], [2, 4]]) True >>> is_transpose([[1, 2, 3]], [[1], [2], [3]]) True ``` Note * The transpose of a matrix is obtained by swapping rows with columns. For example, the transpose of matrix `[[1, 2, 3], [4, 5, 6]]` is `[[1, 4], [2, 5], [3, 6]]`. * The function must handle empty matrices as well. Function Signature ```python from typing import List def is_transpose(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: # Your implementation here ```","solution":"from typing import List def is_transpose(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Returns True if matrix2 is the transpose of matrix1, otherwise False. if len(matrix1) == 0 and len(matrix2) == 0: return True if len(matrix1) == 0 or len(matrix2) == 0 or len(matrix1[0]) != len(matrix2) or len(matrix2[0]) != len(matrix1): return False for i in range(len(matrix1)): for j in range(len(matrix1[0])): if matrix1[i][j] != matrix2[j][i]: return False return True"},{"question":"# Context You are given a string `s` consisting of lowercase alphabetical characters. Your goal is to determine the most frequent k-length substring in `s`. If there are multiple such substrings with the same highest frequency, return the lexicographically smallest substring among them. # Problem Statement Write a function `most_frequent_k_length_substr(s: str, k: int) -> str` that takes a string `s` and an integer `k` and returns the most frequent k-length substring in `s`. If multiple substrings are tied for the highest frequency, return the smallest one lexicographically. # Expected Input and Output Formats - **Input**: A string and an integer. - Example: `(\\"ababab\\", 2)` - **Output**: A string representing the most frequent k-length substring. - Example for the above input: `ab` # Constraints 1. The string will contain only lowercase alphabetical characters. 2. The length of the string `s` will not exceed 100,000 characters. 3. The integer `k` will be less than or equal to the length of the string. # Performance Requirements - Your solution should be efficient in terms of time and space complexities, able to handle the highest constraints smoothly. # Notes - A k-length substring is a contiguous sequence of characters of length k. - Example for `s = \\"ababab\\"` and `k = 2`: - Possible substrings: \\"ab\\", \\"ba\\", \\"ab\\", \\"ba\\", \\"ab\\" - Frequencies: \\"ab\\" -> 3, \\"ba\\" -> 2 - The most frequent substring is \\"ab\\" with frequency 3. # Implementation Implement the function with the following signature: ```python def most_frequent_k_length_substr(s: str, k: int) -> str: # Your implementation here ```","solution":"def most_frequent_k_length_substr(s: str, k: int) -> str: from collections import defaultdict substring_count = defaultdict(int) # Iterate through the string and count the k-length substrings for i in range(len(s) - k + 1): substring = s[i:i + k] substring_count[substring] += 1 # Find the most frequent k-length substring, and in case of ties, the lexicographically smallest one max_frequency = 0 result_substring = \\"\\" for substring, count in substring_count.items(): if count > max_frequency or (count == max_frequency and substring < result_substring): max_frequency = count result_substring = substring return result_substring"},{"question":"# Coding Assessment Question You are given a pattern and a string of lowercase alphabets. You need to determine if the string follows the same pattern. Implement the function `does_follow_pattern(pattern: str, s: str) -> bool` which takes a pattern and a string and returns `True` if the string follows the pattern, otherwise `False`. **Function Signature**: ```python def does_follow_pattern(pattern: str, s: str) -> bool: pass ``` # Input * A string `pattern` of length `m`, where `1 <= m <= 1000`. * A string `s` of lowercase alphabets, where `1 <= len(s) <= 1000`. # Output * Return a boolean `True` if the input string `s` follows the pattern `pattern`, otherwise return `False`. # Example ```python assert does_follow_pattern(\\"abba\\", \\"dog cat cat dog\\") == True assert does_follow_pattern(\\"abba\\", \\"dog cat cat fish\\") == False assert does_follow_pattern(\\"aaaa\\", \\"dog dog dog dog\\") == True assert does_follow_pattern(\\"abba\\", \\"dog dog dog dog\\") == False ``` # Constraints * Each word in `s` is separated by a single space. * Both `pattern` and `s` contain only lowercase letters. # Performance Requirements * Your solution should efficiently handle the constraints provided, optimally mapping patterns to words and checking the conditions within the permissible limits. # Explanation Consider providing comments within your code explaining the steps or approaches taken, especially around: * Parsing the input string into individual words. * Mapping characters from the pattern to words in the string. * Checking for bi-directional consistency to ensure a one-to-one mapping. * Handling of exceptional scenarios and edge cases. Good luck!","solution":"def does_follow_pattern(pattern: str, s: str) -> bool: words = s.split() # If pattern and words length do not match, immediately return False if len(pattern) != len(words): return False char_to_word = {} word_to_char = {} for char, word in zip(pattern, words): if char not in char_to_word: if word in word_to_char: return False char_to_word[char] = word word_to_char[word] = char else: if char_to_word[char] != word: return False return True"},{"question":"# Problem Statement: You are tasked with implementing a function that finds the longest sub-array with the maximum sum from a given array of integers. The array may contain both positive and negative numbers, including zeros. If there are multiple sub-arrays with the same maximum sum, return the one with the smallest starting index. If the length of the longest sub-array with the same maximum sum is greater than 1, return the one with the smallest length. # Function Signature: ```python def longest_max_subarray(arr: list[int]) -> list[int]: pass ``` # Input: - `arr` (List[int]): An array of integers, which can include positive, negative, and zero values. # Output: - (List[int]): A sub-array that represents the longest sub-array with the maximum sum. If there are ties in the longest sub-array with the maximum sum, choose the one which has the smallest starting index. If there are further ties, choose the shortest one. # Constraints: - You must solve the problem with (O(n)) time complexity. - The space complexity should be (O(1)), not counting the input and output arrays. # Examples: ```python assert longest_max_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == [4, -1, 2, 1] assert longest_max_subarray([1, -2, 3, -1, 2, 4, 7, -3, -5]) == [3, -1, 2, 4, 7] assert longest_max_subarray([-2, -3, -1, -2]) == [-1] assert longest_max_subarray([1, 2, 3, -2, 1, 2, 3, -4, 5, 6]) == [1, 2, 3, -2, 1, 2, 3, -4, 5, 6] assert longest_max_subarray([5, 5, 5, -5, 5, 5, 5]) == [5, 5, 5, -5, 5, 5, 5] ``` # Explanation of the Example: - In the first example, the sub-array `[4, -1, 2, 1]` has the maximum sum (6) and is the longest with that sum. - In the second example, the sub-array `[3, -1, 2, 4, 7]` has the maximum sum and is the longest with that sum. - In the third example, the sub-array `[-1]` has the maximum sum, as it is the only element greater than the others. - In the fourth example, the sub-array `[1, 2, 3, -2, 1, 2, 3, -4, 5, 6]` has the maximum sum and is the longest with that sum. - In the fifth example, the sub-array `[5, 5, 5, -5, 5, 5, 5]` has the maximum sum and is the longest with that sum. # Additional Notes: - You might consider using Kadane\'s algorithm but modified to keep track of the start and end indices of the current sub-array as well as the best sub-array. - Make sure to handle edge cases such as when the array is empty or contains only negative numbers.","solution":"def longest_max_subarray(arr: list[int]) -> list[int]: n = len(arr) if n == 0: return [] max_sum = float(\'-inf\') current_sum = 0 best_start = best_end = 0 current_start = 0 for i in range(n): current_sum += arr[i] if current_sum > max_sum or (current_sum == max_sum and (i - current_start > best_end - best_start)): max_sum = current_sum best_start = current_start best_end = i if current_sum < 0: current_sum = 0 current_start = i + 1 return arr[best_start: best_end + 1]"},{"question":"# Anagram Finder in Python An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. # Objective: Write a function to check whether two given strings are anagrams of each other. # Context: You are developing a software module for a word game that checks if two given words are anagrams. An efficient solution is required since the game involves checking a large number of word pairs. # Function Signature: ```python def are_anagrams(str1: str, str2: str) -> bool: pass ``` # Input: - `str1`: The first string (non-empty). - `str2`: The second string (non-empty). # Output: - Returns `True` if `str1` and `str2` are anagrams, otherwise `False`. # Constraints: - The strings only contain lowercase English alphabetic characters. - The length of each string is between 1 and 100,000 characters. # Performance Requirements: - The solution should have a time complexity of O(n), where n is the length of the strings. - Minimize the usage of additional memory. # Scenario: ```python # Example test cases: print(are_anagrams(\\"listen\\", \\"silent\\")) # True (anagrams) print(are_anagrams(\\"hello\\", \\"billion\\")) # False (not anagrams) print(are_anagrams(\\"triangle\\", \\"integral\\")) # True (anagrams) ``` # Hints: 1. Consider using a hashmap or a fixed array to count character frequencies for both strings. 2. Compare character counts to determine if the two strings are anagrams.","solution":"def are_anagrams(str1: str, str2: str) -> bool: Checks if two strings are anagrams of each other. if len(str1) != len(str2): return False # Create a frequency dictionary for characters in str1 char_count = {} for char in str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Decrement the frequency based on characters in str2 for char in str2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False # If char_count is empty, it means the strings are anagrams return not char_count"},{"question":"# Problem Statement: You are required to implement a function that identifies the articulation points (or cut vertices) in an undirected graph. Articulation points are vertices that, when removed along with their associated edges, cause an increase in the number of connected components of the graph. # Function Signature: ```python def find_articulation_points(graph: dict) -> set: pass ``` # Input: - `graph`: A dictionary representing an undirected graph. Each key is an integer representing a vertex, and the value is a list of integers representing adjacent vertices. # Output: - Returns a set of integers representing the articulation points in the graph. # Constraints: - Vertices are represented as non-negative integers. - The input graph can be empty, but not `None`. - The graph is connected. - No repeated edges or self-loops. # Example: ```plaintext graph = { 0: [1, 2, 3], 1: [0, 2], 2: [0, 1, 3, 4], 3: [0, 2], 4: [2, 5], 5: [4] } find_articulation_points(graph) # Output: {2, 4} ``` # Explanation: In this graph, vertices 2 and 4 are articulation points. When you remove vertex 2 along with its edges, multiple components result: {0, 1, 3} and {4, 5}. Removing vertex 4 also causes a similar increase in components. # Other Considerations: - Make use of Depth First Search (DFS) and backtracking to identify articulation points. - Be prepared to handle edge cases like an empty graph or graphs with single nodes (which have no articulation points).","solution":"def find_articulation_points(graph: dict) -> set: Function to find the articulation points in an undirected graph. Parameters: graph (dict): A dictionary representing an undirected graph where each key is a vertex and the value is a list of adjacent vertices. Returns: set: A set of articulation points in the graph. if not graph: return set() def dfs(u, discovery_times, low, parent, time, visited, articulation_points): children = 0 visited[u] = True discovery_times[u] = low[u] = time[0] time[0] += 1 for v in graph[u]: if not visited[v]: parent[v] = u children += 1 dfs(v, discovery_times, low, parent, time, visited, articulation_points) # Check if the subtree rooted at v has a connection back to one of the ancestors of u low[u] = min(low[u], low[v]) # u is an articulation point in the following cases: # Case 1: u is the root of DFS tree and has 2 or more children if parent[u] is None and children > 1: articulation_points.add(u) # Case 2: u is not the root and low value of one of its children v is greater than discovery value of u if parent[u] is not None and low[v] >= discovery_times[u]: articulation_points.add(u) elif v != parent[u]: # Update low value of u for parent function calls low[u] = min(low[u], discovery_times[v]) visited = {u: False for u in graph} discovery_times = {u: float(\'inf\') for u in graph} low = {u: float(\'inf\') for u in graph} parent = {u: None for u in graph} articulation_points = set() # Initial time counter time = [0] # For handling the case when the graph is not connected for u in graph: if not visited[u]: dfs(u, discovery_times, low, parent, time, visited, articulation_points) return articulation_points"},{"question":"# Problem Statement You are given a 2D grid representing a height map where: * Each cell contains an integer indicating the elevation height at that point. Your task is to implement a function that calculates the total water volume that has been trapped after it rains. The height map grid is surrounded by an external boundary that is considered as walls and would not allow overflow of water. # Function Signature ```python def trapRainWater(heightMap: list[list[int]]) -> int: pass ``` # Input 1. `heightMap`: A 2D list of integers representing the height map of the terrain. # Output * Returns an integer representing the total volume of trapped rainwater. # Constraints * The height map grid will have at least one cell (1 ≤ number of rows and columns ≤ 100). # Example ```python heightMap = [ [1, 4, 3, 1, 3, 2], [3, 2, 1, 5, 2, 4], [2, 3, 3, 4, 3, 2] ] print(trapRainWater(heightMap)) # Output: 4 ``` # Note * Water cannot flow over the boundaries of the height map. * Water can only be trapped in depressions where all surrounding cells are higher than the current cell. * Make sure to handle edge cases such as maps with no trapped water or maps with varying elevation sizes.","solution":"import heapq def trapRainWater(heightMap: list[list[int]]) -> int: if not heightMap or not heightMap[0]: return 0 rows, cols = len(heightMap), len(heightMap[0]) visited = [[False] * cols for _ in range(rows)] min_heap = [] for r in range(rows): for c in [0, cols-1]: heapq.heappush(min_heap, (heightMap[r][c], r, c)) visited[r][c] = True for c in range(1, cols-1): for r in [0, rows-1]: heapq.heappush(min_heap, (heightMap[r][c], r, c)) visited[r][c] = True water_trapped = 0 directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and not visited[nx][ny]: visited[nx][ny] = True water_trapped += max(0, height - heightMap[nx][ny]) heapq.heappush(min_heap, (max(height, heightMap[nx][ny]), nx, ny)) return water_trapped"},{"question":"# Validate Parentheses **Scenario**: You are developing a syntax checker for a programming language that uses parentheses for expressions. It is crucial to determine whether every opening parenthesis has a corresponding closing parenthesis, and they are properly nested. **Task**: Write a function `validate_parentheses` that checks if a given string containing only parentheses characters is valid. A string of parentheses is considered valid if all opening parentheses \'(\' have corresponding closing parentheses \')\' and the pairs of parentheses are properly nested. **Function Signature**: ```python def validate_parentheses(parentheses: str) -> bool: pass ``` **Input**: - `parentheses`: A string containing only the characters \'(\' and \')\'. **Output**: - Return a boolean value: `True` if the string is valid, and `False` if it is not. **Constraints**: - The input string will only contain characters \'(\' and \')\'. - The function should be efficient to handle long strings. **Examples**: ```python assert validate_parentheses(\\"()\\") == True assert validate_parentheses(\\"(())\\") == True assert validate_parentheses(\\"(()\\") == False assert validate_parentheses(\\")(\\") == False assert validate_parentheses(\\"((())())\\") == True assert validate_parentheses(\\"(()))(\\") == False ``` In this question, students are expected to leverage their understanding of data structures, such as a stack, to implement a solution that correctly verifies the validity of nested parentheses while considering proper handling of edge cases.","solution":"def validate_parentheses(parentheses: str) -> bool: Checks if a given string containing only parentheses characters is valid. A string of parentheses is considered valid if all opening parentheses \'(\' have corresponding closing parentheses \')\' and the pairs of parentheses are properly nested. stack = [] for char in parentheses: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack"},{"question":"# Validate Postcodes Objective: Create a function that validates whether a given string is a valid postal code. The postal code can be composed of uppercase letters, digits, and optionally spaces. It must match a specific pattern to be considered valid. The valid postal code pattern is: - 1st character: Letter - 2nd character: Digit - 3rd character: Letter - 4th character: space (optional) - 5th character: Digit - 6th character: Letter - 7th character: Digit Valid examples of postal codes include: \\"A1B 2C3\\", \\"A1B2C3\\", \\"K7L 5A9\\". Function Signature: ```python def validate_postcode(postcode: str) -> bool: ... ``` Inputs: * `postcode` (str): A string representing the postal code. Constraints: ( 1 leq text{len(postcode)} leq 10 ) Output: * `bool`: Returns True if the input matches the valid postal code pattern; otherwise, returns False. Examples: ```python validate_postcode(\\"A1B 2C3\\") # returns True validate_postcode(\\"A1B2C3\\") # returns True validate_postcode(\\"K7L 5A9\\") # returns True validate_postcode(\\"1234567\\") # returns False validate_postcode(\\"A2 C4\\") # returns False validate_postcode(\\"A1B 2C34\\") # returns False validate_postcode(\\"a1b 2c3\\") # returns False ``` Edge Cases to Consider: 1. Presence of lowercase letters. 2. Incorrect number of characters. 3. Inclusion of invalid characters or separators. 4. Combination of valid and invalid parts (e.g., extra spaces). Performance Requirements: - Your solution should efficiently validate the input under the given size constraint and complete within a reasonable time frame.","solution":"import re def validate_postcode(postcode: str) -> bool: Validates whether the given string is a valid postal code. Args: postcode (str): The postal code to validate. Returns: bool: True if the postal code is valid, otherwise False. # Regular expression pattern for validating the postal code pattern = re.compile(r\'^[A-Z]d[A-Z] ?d[A-Z]d\') return bool(pattern.match(postcode))"},{"question":"**Context**: You are working on optimizing a database query system to efficiently retrieve customer purchase histories. The task involves designing a data structure that allows quick insertion of purchase records and fast retrieval of the purchase history for any customer. **Task**: 1. Implement a class `CustomerPurchaseHistory` that optimizes the storage and retrieval of purchase records. 2. Implement a function `get_purchase_history` within this class to fetch the purchase history of a given customer. # Class Definition ```python class CustomerPurchaseHistory: def __init__(self): Initializes an empty customer purchase history storage. # Implement this method pass def record_purchase(self, customer_id: str, item: str, amount: float) -> None: Records a purchase made by a customer. :param customer_id: ID of the customer making the purchase. :param item: The item purchased. :param amount: The amount spent on the purchase. # Implement this method pass def get_purchase_history(self, customer_id: str) -> list[tuple[str, float]]: Retrieves the purchase history of a customer. :param customer_id: ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent. # Implement this method pass ``` # Function Definition ```python def fetch_customer_history(transactions: list[tuple[str, str, float]], customer_id: str) -> list[tuple[str, float]]: Fetches the purchase history of a specified customer from a list of transactions. :param transactions: A list of transactions, each represented as a tuple (customer_id, item, amount). :param customer_id: The ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent by the specified customer. # Implement this method pass ``` # Constraints: 1. The number of customers, `C`, will not exceed 10000. 2. The number of transactions, `T`, will not exceed 100000. 3. The length of `customer_id` and `item` strings will not exceed 50 characters. 4. The amount spent on any purchase will not exceed 10^6. # Example: ```python transactions = [ (\'cust1\', \'itemA\', 50.0), (\'cust2\', \'itemB\', 30.0), (\'cust1\', \'itemC\', 20.0), (\'cust3\', \'itemA\', 60.0), (\'cust2\', \'itemA\', 20.0) ] result = fetch_customer_history(transactions, \'cust1\') ``` **Note**: The output should be a list of tuples where each tuple contains the item name and amount spent by the customer specified. For example, `[(\'itemA\', 50.0), (\'itemC\', 20.0)]` for `cust1`.","solution":"class CustomerPurchaseHistory: def __init__(self): Initializes an empty customer purchase history storage. self.purchase_history = {} def record_purchase(self, customer_id: str, item: str, amount: float) -> None: Records a purchase made by a customer. :param customer_id: ID of the customer making the purchase. :param item: The item purchased. :param amount: The amount spent on the purchase. if customer_id not in self.purchase_history: self.purchase_history[customer_id] = [] self.purchase_history[customer_id].append((item, amount)) def get_purchase_history(self, customer_id: str) -> list[tuple[str, float]]: Retrieves the purchase history of a customer. :param customer_id: ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent. return self.purchase_history.get(customer_id, []) def fetch_customer_history(transactions: list[tuple[str, str, float]], customer_id: str) -> list[tuple[str, float]]: Fetches the purchase history of a specified customer from a list of transactions. :param transactions: A list of transactions, each represented as a tuple (customer_id, item, amount). :param customer_id: The ID of the customer whose purchase history is being queried. :return: A list of tuples with item names and amount spent by the specified customer. history = CustomerPurchaseHistory() for cust_id, item, amount in transactions: history.record_purchase(cust_id, item, amount) return history.get_purchase_history(customer_id)"},{"question":"# Scenario You are tasked with designing a simple text analyzer that processes a given text file and generates a report on the most frequent words. The text file will contain multiple lines of text, and the words will be separated by spaces or punctuation marks. # Task Write a Python function `most_frequent_words` that takes one parameter: 1. `filename`: The path to the text file to be analyzed. The function should: 1. Read the contents of the text file. 2. Normalize the text by converting all words to lowercase and removing punctuation. 3. Count the frequency of each word in the text. 4. Return a list of tuples, each containing a word and its frequency, sorted by frequency in descending order. If two words have the same frequency, they should be sorted alphabetically. # Input * `filename`: A string representing the path to the text file. # Output * A list of tuples, where each tuple contains a word and its corresponding frequency, sorted by frequency in descending order. # Constraints * The function should handle the file reading exceptions gracefully. * The text file will be plain text and may include punctuation. * Assume no word exceeds 100 characters in length. # Example ```python def most_frequent_words(filename: str): pass # Example of usage result = most_frequent_words(\'sample.txt\') print(result) ``` If `sample.txt` contains: ``` Hello, world! This is a sample text file. Hello, hello world. ``` The function should return: ``` [(\'hello\', 3), (\'world\', 2), (\'a\', 1), (\'file\', 1), (\'is\', 1), (\'sample\', 1), (\'text\', 1), (\'this\', 1)] ``` This function should reliably process the input text file and generate the desired word frequency report.","solution":"import re from collections import Counter def most_frequent_words(filename: str): Reads a text file and returns a list of tuples with words and their frequencies, sorted by frequency in descending order. If two words have the same frequency, they are sorted alphabetically. try: with open(filename, \'r\', encoding=\'utf-8\') as file: text = file.read().lower() # Remove punctuation and split into words words = re.findall(r\'bw+b\', text) # Count the frequency of each word word_counts = Counter(words) # Sort the words by frequency (highest first) and then alphabetically sorted_word_counts = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) return sorted_word_counts except Exception as e: print(f\\"Error reading file {filename}: {e}\\") return []"},{"question":"# Problem Statement You are given a string containing both uppercase and lowercase alphabetic characters and digits. Your task is to implement a function `longest_substring_unique(s: str) -> int` that finds the length of the longest substring without repeating characters. Input and Output Formats: * **Input**: - `s`: A string containing alphanumeric characters. * **Output**: - Returns an integer representing the length of the longest substring with all unique characters. Constraints: * The length of the string may be between 0 to 10^5 characters. * The string contains only (A-Z, a-z, 0-9). Performance Requirements: * The solution must run in O(n) time complexity, where n is the length of the input string. Example: 1. `longest_substring_unique(\\"abcabcbb\\")` should return `3`. - Explanation: The longest substring without repeating characters is \\"abc\\" with a length of 3. 2. `longest_substring_unique(\\"bbbbb\\")` should return `1`. - Explanation: The longest substring without repeating characters is \\"b\\" with a length of 1. 3. `longest_substring_unique(\\"pwwkew\\")` should return `3`. - Explanation: The longest substring without repeating characters is \\"wke\\" with a length of 3. Note that \\"pwke\\" is a longer substring but contains a repeating character. 4. `longest_substring_unique(\\"dvdf\\")` should return `3`. - Explanation: The longest substring without repeating characters is \\"vdf\\" with a length of 3. Use these test cases to verify the accuracy of your implementation.","solution":"def longest_substring_unique(s: str) -> int: This function finds the length of the longest substring without repeating characters in the given string. Parameters: s (str): The input string containing alphanumeric characters. Returns: int: The length of the longest substring with all unique characters. # Dictionary to store the last positions of each character. char_index = {} max_length = 0 start_idx = 0 # start index of the current non-repeating substring for end_idx, char in enumerate(s): if char in char_index and char_index[char] >= start_idx: # Move the start index to the right of the same character last found start_idx = char_index[char] + 1 # Update the last seen index of the character char_index[char] = end_idx # Calculate the maximum length of non-repeating substring. max_length = max(max_length, end_idx - start_idx + 1) return max_length"},{"question":"# Scenario: You are developing a tool to analyze text similarity for plagiarism detection. Your task is to write a function that calculates the cosine similarity between two given strings. Cosine similarity is a measure of similarity between two non-zero vectors of an inner product space that measures the cosine of the angle between them. # Function Requirements: * Implement a function `calculate_cosine_similarity` that takes two strings and returns their cosine similarity score. * Tokenize the strings into words and create term frequency vectors. * Handle punctuation and case sensitivity appropriately. * Output the similarity score as a float rounded to four decimal places. # Constraints: * Both input strings will be non-empty. * Strings will contain only alphanumeric characters and spaces. # Function Signature: ```python def calculate_cosine_similarity(text1: str, text2: str) -> float: pass ``` # Example: ```python assert round(calculate_cosine_similarity(\\"This is a sample text\\", \\"This text is a sample\\"), 4) == 1.0000 assert round(calculate_cosine_similarity(\\"Hello world\\", \\"Hi there\\"), 4) == 0.0000 ``` # Input: - `text1` (string): The first text to compare. - `text2` (string): The second text to compare. # Output: - (float): The cosine similarity score between the two strings, rounded to four decimal places. **Good luck!**","solution":"import re from collections import Counter import math def calculate_cosine_similarity(text1: str, text2: str) -> float: def tokenize(text): # Convert the text to lowercase and remove punctuation text = re.sub(r\'[^ws]\', \'\', text.lower()) return text.split() def vectorize(tokens): return Counter(tokens) def dot_product(v1, v2): return sum(v1[key] * v2.get(key, 0) for key in v1) def magnitude(vector): return math.sqrt(sum(val * val for val in vector.values())) tokens1 = tokenize(text1) tokens2 = tokenize(text2) vec1 = vectorize(tokens1) vec2 = vectorize(tokens2) dot_prod = dot_product(vec1, vec2) magnitude1 = magnitude(vec1) magnitude2 = magnitude(vec2) if not magnitude1 or not magnitude2: return 0.0 cosine_similarity = dot_prod / (magnitude1 * magnitude2) return round(cosine_similarity, 4)"},{"question":"# Travelling Salesperson Problem (TSP) Solver **Objective**: Develop a function to solve the Travelling Salesperson Problem using a heuristic approach. Function: TSP Solver Implement a TSP solver function based on the nearest neighbor heuristic as described in the given template: ```python def tsp_nearest_neighbor(cities: list[tuple[float, float]]) -> list[int]: Solves the Travelling Salesperson Problem using the nearest neighbor heuristic. Args: cities: A list of tuples where each tuple represents the coordinates of a city. Returns: A list of indices representing the order in which to visit the cities to achieve a near-optimal TSP route. pass ``` **Input**: * A list of tuples, where each tuple represents the coordinates of a city, e.g., `[(0,0), (1,2), (4,3), (6,1)]`. **Output**: * A list of indices corresponding to the order of cities to visit. **Constraints**: * The number of cities will be at least 2 and at most 100. * Coordinates are non-negative integers. **Notes**: * The nearest neighbor heuristic starts from the first city and iteratively visits the nearest unvisited city. * Implement a distance function to calculate the Euclidean distance between cities. Example ```python cities = [(0,0), (1,2), (4,3), (6,1)] order = tsp_nearest_neighbor(cities) print(order) # Output could be [0, 1, 2, 3] ``` **Evaluation**: * Correctness in calculating the order of visiting cities to approximate the shortest possible route. * Accuracy of the distance calculations and heuristic implementation. --- # Analysis and Justification **Question Style**: The new question follows a similar pattern and format to the provided sample question, with its two parts: building the structure (KD-Tree) and performing a search (nearest neighbor). Here, it involves defining the TSP solver function and utilizing a heuristic to find a near-optimal solution. **Question Length**: The new question is of comparable length to the sample. It includes the function signature, clear input/output specifications, constraints, and a sample example to illustrate usage. **Difficulty Level**: The complexity is matched with the requirement of understanding and implementing a heuristic algorithm involving concepts related to distance measurement and iterative solutions. **Topic Alignment**: The problem remains within the realm of data structures and algorithms, focusing on optimization and spatial understanding, similar to the original topic of nearest neighbor search within KD-Trees. **Question Uniqueness**: The problem posed is distinct yet analogous in concept. It explores TSP, thus introducing a different but relevant algorithmic challenge that leverages spatial reasoning and nearest neighbor calculations. This ensures it seamlessly integrates with the original set.","solution":"import math def tsp_nearest_neighbor(cities: list[tuple[float, float]]) -> list[int]: Solves the Travelling Salesperson Problem using the nearest neighbor heuristic. Args: cities: A list of tuples where each tuple represents the coordinates of a city. Returns: A list of indices representing the order in which to visit the cities to achieve a near-optimal TSP route. def euclidean_distance(c1, c2): return math.sqrt((c1[0] - c2[0])**2 + (c1[1] - c2[1])**2) n = len(cities) visited = [False] * n tour = [0] # Start the tour with the first city visited[0] = True current_city = 0 for _ in range(n - 1): next_city = -1 min_distance = float(\'inf\') for i in range(n): if not visited[i]: distance = euclidean_distance(cities[current_city], cities[i]) if distance < min_distance: min_distance = distance next_city = i tour.append(next_city) visited[next_city] = True current_city = next_city return tour"},{"question":"# Problem Statement: Evaluate Mathematical Expressions from a String You are required to implement a function in Python that can evaluate a basic mathematical expression provided as a string. The string will contain non-negative integers and the operators \'+\', \'-\', \'*\', \'/\'. The function should correctly handle the order of operations (PEMDAS/BODMAS rules). Whitespace should be ignored and any invalid characters should result in an error. # Function Signature ```python def evaluate_expression(expr: str) -> float: pass ``` # Input * `expr` - A string that represents a mathematical expression. Example: `\\" 3 + 5 / 2 \\"`. # Output * A float which is the result of the evaluated expression. # Constraints * The input string contains valid mathematical characters (digits, operators, spaces). * The division operator `/` should perform floating-point division. * Do not use Python\'s `eval()` function for this task. # Requirements * Raise a `ValueError` with a descriptive error message in case of invalid inputs or conditions. * Implement the function to follow the correct order of operations and handle whitespace appropriately. # Example Usage ```python >>> evaluate_expression(\\"3+2*2\\") 7.0 >>> evaluate_expression(\\" 3/2 \\") 1.5 >>> evaluate_expression(\\"3 + 5 / 2\\") 5.5 >>> evaluate_expression(\\"3 + 5 // 2\\") Traceback (most recent call last): ... ValueError: Invalid character \'//\' found in expression >>> evaluate_expression(\\"3 + a\\") Traceback (most recent call last): ... ValueError: Invalid character \'a\' found in expression >>> evaluate_expression(\\"\\") Traceback (most recent call last): ... ValueError: Empty string was passed to the function >>> evaluate_expression(\\"2 * ( 3 + 4 )\\") Traceback (most recent call last): ... ValueError: Parentheses are not supported ``` # Additional Notes * Your function should not use Python\'s built-in `eval()` or `exec()` for this task. * Implement a parser that respects the rules of PEMDAS/BODMAS to ensure the correct order of operations. * Consider edge cases such as empty strings and strings with invalid characters.","solution":"def evaluate_expression(expr: str) -> float: import re # Remove any whitespace expr = expr.replace(\' \', \'\') # Check for empty input if not expr: raise ValueError(\\"Empty string was passed to the function\\") # Validate characters in the expression if re.search(r\'[^d+-*/]\', expr): raise ValueError(\\"Invalid character found in the expression\\") # Validate unsupported characters or combinations if \'//\' in expr or \'**\' in expr: raise ValueError(\\"Invalid character \'//\' or \'**\' found in expression\\") # Implement the shunting yard algorithm to convert infix to postfix precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} def greater_precedence(op1, op2): return precedence[op1] > precedence[op2] def to_postfix(expression): stack = [] output = [] i = 0 while i < len(expression): if expression[i].isdigit(): num = \'\' while i < len(expression) and expression[i].isdigit(): num += expression[i] i += 1 output.append(num) i -= 1 # step back to account for main loop increment elif expression[i] in precedence: while (stack and stack[-1] in precedence and greater_precedence(stack[-1], expression[i])): output.append(stack.pop()) stack.append(expression[i]) i += 1 while stack: output.append(stack.pop()) return output def evaluate_postfix(postfix): stack = [] for token in postfix: if token.isdigit(): stack.append(float(token)) else: b = stack.pop() a = stack.pop() if token == \'+\': stack.append(a + b) elif token == \'-\': stack.append(a - b) elif token == \'*\': stack.append(a * b) elif token == \'/\': stack.append(a / b) return stack[0] postfix_expr = to_postfix(expr) result = evaluate_postfix(postfix_expr) return result"},{"question":"# Balanced Delimiter Checker Problem Statement You are given a string containing different types of delimiters: parentheses `()`, square brackets `[]`, and curly braces `{}`. Your task is to determine if the string contains a valid sequence of balanced delimiters. A sequence of delimiters is balanced if: - Each opening delimiter has a corresponding closing delimiter. - The delimiters are correctly nested. Create a function `is_balanced(s: str) -> bool` that returns `True` if the string is balanced, and `False` otherwise. Input Format - `s`: A string containing only the characters `()`, `[]`, and `{}`. Output Format - A boolean value: `True` if the string is balanced, and `False` if it is not. Constraints - The length of `s` is between ( 0 ) and ( 10^4 ). - Only the characters `()`, `[]`, `{}` are present in the string. Examples 1. `is_balanced(\\"()\\")` returns `True` (as the sequence is balanced). 2. `is_balanced(\\"([{}])\\")` returns `True` (as the sequence is correctly nested). 3. `is_balanced(\\"([)]\\")` returns `False` (as the sequence is not correctly nested). 4. `is_balanced(\\"(((()\\"))` returns `False` (as there are unmatched opening parentheses). Provide a Python implementation for the `is_balanced` function that adheres to these requirements.","solution":"def is_balanced(s: str) -> bool: Returns True if the delimiters in the string \'s\' are balanced and correctly nested, otherwise False. stack = [] matching_bracket = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in \'([{\': stack.append(char) elif char in \')]}\': if not stack or stack[-1] != matching_bracket[char]: return False stack.pop() return not stack"},{"question":"# Context: You are tasked to implement a simple versioned key-value store that supports storing, retrieving, and deleting key-value pairs, with the added functionality of tracking versions. Each `set` operation should increment the version number for the affected key, allowing the user to retrieve the value of a key at a specific version. # Task: **Implement** the versioned key-value store described below. # Function Definitions: 1. **set** (`key: str, value: any`) -> `None`: - **Input**: A string `key` and its associated `value` (any data type). - **Output**: None. Stores the key-value pair, incrementing the version number for that key. 2. **get** (`key: str, version: int = None`) -> `any`: - **Input**: A string `key` and an optional integer `version` (defaults to the latest version if not specified). - **Output**: The value associated with the specified key and version. If the version is not provided, the latest version is returned. If the key or version does not exist, returns `None`. 3. **delete** (`key: str`) -> `None`: - **Input**: A string `key`. - **Output**: None. Deletes the key and all its versions. # Constraints: - Version numbers start at 1 for each key and increment with each `set` operation. - Keys are unique strings and case-sensitive. - Values can be of any data type that is JSON serializable. # Example: ```python class VersionedKVStore: def __init__(self): self.store = {} def set(self, key: str, value: any) -> None: # Your implementation here pass def get(self, key: str, version: int = None) -> any: # Your implementation here pass def delete(self, key: str) -> None: # Your implementation here pass if __name__ == \\"__main__\\": vkv = VersionedKVStore() vkv.set(\\"foo\\", \\"bar\\") vkv.set(\\"foo\\", \\"baz\\") print(vkv.get(\\"foo\\")) # Outputs: baz print(vkv.get(\\"foo\\", 1)) # Outputs: bar vkv.delete(\\"foo\\") print(vkv.get(\\"foo\\")) # Outputs: None ``` **Example Usage**: ```python vkv = VersionedKVStore() vkv.set(\\"foo\\", \\"bar\\") vkv.set(\\"foo\\", \\"baz\\") print(vkv.get(\\"foo\\")) # Should return \\"baz\\" print(vkv.get(\\"foo\\", 1)) # Should return \\"bar\\" vkv.delete(\\"foo\\") print(vkv.get(\\"foo\\")) # Should return None ```","solution":"class VersionedKVStore: def __init__(self): self.store = {} def set(self, key: str, value: any) -> None: if key in self.store: versions = self.store[key] versions[len(versions) + 1] = value else: self.store[key] = {1: value} def get(self, key: str, version: int = None) -> any: if key not in self.store: return None versions = self.store[key] if version is None: return versions[max(versions.keys())] return versions.get(version, None) def delete(self, key: str) -> None: if key in self.store: del self.store[key]"},{"question":"# Coding Question: Zero Matrix Transformation Given a 2D matrix of integers, implement a function that converts the matrix such that if an element is zero, its entire row and column are set to zeroes. 1. **Function: `zero_matrix(matrix: list[list[int]]) -> list[list[int]]`**: * **Input**: A 2D list `matrix` of integers. * **Output**: The transformed 2D list. * **Constraints**: The matrix has at least one element. # Example ```python # Test case 1 matrix = [ [1, 2, 3], [4, 0, 6], [7, 8, 9] ] # After transformation: # [ # [1, 0, 3], # [0, 0, 0], # [7, 0, 9] # ] assert zero_matrix(matrix) == [ [1, 0, 3], [0, 0, 0], [7, 0, 9] ] # Test case 2 matrix = [ [1, 2, 0], [4, 5, 6], [7, 8, 9], [0, 11, 12] ] # After transformation: # [ # [0, 0, 0], # [4, 5, 0], # [7, 8, 0], # [0, 0, 0], # ] assert zero_matrix(matrix) == [ [0, 0, 0], [4, 5, 0], [7, 8, 0], [0, 0, 0] ] # Test case 3 matrix = [ [1] ] # After transformation: # [ # [1] # ] assert zero_matrix(matrix) == [ [1] ] ``` # Your implementation should handle edge cases such as: * A matrix with no zero elements. * A matrix where the zero element is at the boundary. * A matrix with multiple zero elements.","solution":"def zero_matrix(matrix): Given a 2D matrix, this function sets entire row and column to zeroes if an element is zero. if not matrix or not matrix[0]: return matrix # handle edge case of empty matrix rows = len(matrix) cols = len(matrix[0]) # First pass to find all zeroes zero_rows = set() zero_cols = set() for r in range(rows): for c in range(cols): if matrix[r][c] == 0: zero_rows.add(r) zero_cols.add(c) # Second pass to set zeroes for r in range(rows): for c in range(cols): if r in zero_rows or c in zero_cols: matrix[r][c] = 0 return matrix"},{"question":"# Question Objective Implement a `find_duplicate` function that finds and returns the first duplicate value in a list of integers. If no such duplicate exists, it should return `-1`. The function should have a time complexity of O(n) and a space complexity of O(n). Algorithm Explanation The function should iterate through the list of integers while keeping track of elements you\'ve seen so far using a set: 1. Traverse the list from the beginning. 2. For each element, check if it is already in the set of seen elements. 3. If it is, return that element as it\'s the first duplicate. 4. If not, add the element to the set and continue to the next element. 5. If no duplicates are found and the end of the list is reached, return `-1`. Input and Output * **Input**: A list of integers `numbers`. * **Output**: The first duplicate integer value. If no duplicate is found, return `-1`. Constraints * The number of integers `n` in the list can be between 0 and 10^6. * The integers in the list are within the range of -10^6 to 10^6. * The function signature should be: `def find_duplicate(numbers: list) -> int`. Scenario Consider a set of student IDs where you need to check for duplicate entries for an exam registration process. Example ```python >>> numbers = [1, 2, 3, 4, 2, 5] >>> find_duplicate(numbers) 2 >>> numbers = [10, 22, 5, 10, 13, 22] >>> find_duplicate(numbers) 10 >>> numbers = [5, 4, 3, 2, 1] >>> find_duplicate(numbers) -1 >>> numbers = [] >>> find_duplicate(numbers) -1 ``` Develop the `find_duplicate` function to correctly identify the first duplicate integer in the provided list of numbers.","solution":"def find_duplicate(numbers: list) -> int: Finds and returns the first duplicate value in the list. If no duplicate exists, returns -1. seen = set() for number in numbers: if number in seen: return number seen.add(number) return -1"},{"question":"# Maximum Sum Subarray Using Sliding Window In this task, you need to implement a function that finds the contiguous subarray within a given array which has the largest sum. The function should use the sliding window technique to achieve this. # Function Signature ```python def max_sum_subarray(arr: List[int]) -> int: ``` # Input - A list of integers `arr` ( (1 leq len(arr) leq 10^5, -10^4 leq arr[i] leq 10^4) ): the input array in which you need to find the subarray with the largest sum. # Output - An integer representing the sum of the contiguous subarray with the largest sum. # Constraints - The function should handle large input sizes efficiently considering both time and space complexities. - You must use the sliding window technique to solve the problem. # Example ```python print(max_sum_subarray([1, -3, 2, 1, -1])) # Output: 3 print(max_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])) # Output: 6 ``` # Notes 1. In `max_sum_subarray([1, -3, 2, 1, -1])`, the maximum sum subarray is [2, 1], which sums to 3. 2. In `max_sum_subarray([-2, 1, -3, 4, -1, 2, 1, -5, 4])`, the maximum sum subarray is [4, -1, 2, 1], which sums to 6. # Tips - The edge cases include when the array contains all negative numbers or when it contains a mix of positive and negative numbers. - Ensure that the implementation efficiently finds the maximum sum without iterating over all possible subarrays.","solution":"from typing import List def max_sum_subarray(arr: List[int]) -> int: Returns the sum of the contiguous subarray with the largest sum using the sliding window (Kadane\'s Algorithm). if not arr: return 0 max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"# Question: In-place Array Rotation Context You are developing software that processes large datasets stored in arrays, often requiring elements to be shifted or rotated to achieve certain configurations. Optimizing these operations is crucial for performance when handling significant volumes of data. Task Implement the function `rotate_array(arr: list, k: int) -> None` that rotates the array to the right by `k` steps in place, meaning that you cannot use extra space for another array. The array modifications should be done inside the function so the changes reflect outside the function scope. Function Signature ```python def rotate_array(arr: list, k: int) -> None: pass ``` Input * A list `arr` of integers where `0 <= len(arr) <= 10^5`. * An integer `k` where `0 <= k <= 10^5`. Output * The function does not return anything. The list `arr` should be modified in-place. Constraints * If `arr` is empty, the function should do nothing. * Consider the case where `k` is greater than the length of `arr`. Example ```python arr = [1, 2, 3, 4, 5, 6, 7] rotate_array(arr, 3) print(arr) ➞ [5, 6, 7, 1, 2, 3, 4] arr = [-1, -100, 3, 99] rotate_array(arr, 2) print(arr) ➞ [3, 99, -1, -100] arr = [1, 2, 3, 4, 5] rotate_array(arr, 0) print(arr) ➞ [1, 2, 3, 4, 5] arr = [1, 2] rotate_array(arr, 3) print(arr) ➞ [2, 1] ``` Additional Notes * Consider edge cases where `k` is 0, the array is empty, or `k` is larger than the length of the array. * You may assume all elements of `arr` are integers.","solution":"def rotate_array(arr: list, k: int) -> None: Rotates the array `arr` to the right by `k` steps in place. if not arr or k <= 0: return n = len(arr) k %= n # In case k is larger than n arr[:] = arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment Question Background: You are building a basic recommendation system for a movie streaming platform. The platform maintains user data including their ratings for various movies. The goal is to suggest the top `N` highest-rated movies by genre based on the available ratings. Task: You need to implement a function `recommend_movies(user_data: list, genre: str, top_n: int) -> list` that suggests the top `N` movies by average rating for a specific genre. The function should follow these steps: 1. Filter the movie data to only include movies of the specified genre. 2. Calculate the average rating for each movie within the specified genre. 3. Return the titles of the top `N` movies sorted by average rating in descending order. If two movies have the same average rating, they should be sorted alphabetically by title. If there are fewer than `N` movies available, return all the movies sorted as specified. Input: - `user_data` (list): A list of dictionaries where each dictionary contains the keys \'title\', \'genre\', and \'ratings\'. \'ratings\' is a list of integers. Example: ```python [ {\'title\': \'Movie1\', \'genre\': \'Action\', \'ratings\': [4, 5, 3]}, {\'title\': \'Movie2\', \'genre\': \'Comedy\', \'ratings\': [2, 3]}, {\'title\': \'Movie3\', \'genre\': \'Action\', \'ratings\': [5, 5, 4]}, # ... more movie data ] ``` - `genre` (str): The genre to filter movies by. - `top_n` (int): The number of top-rated movies to return. Output: - Returns a list of strings where each string is a movie title, representing the top `N` highest-rated movies in the specified genre. Constraints: - All ratings are between 1 and 5 inclusive. - A movie will always have at least one rating. - Movies have unique titles. Performance Requirements: - The function should handle datasets with up to tens of thousands of movies efficiently. Example: Given `user_data`, `genre=\'Action\'`, `top_n=2`, the function could return: ```python [\'Movie3\', \'Movie1\'] ``` where \'Movie3\' has an average rating of 4.67 and \'Movie1\' has an average rating of 4. Function Signature: ```python def recommend_movies(user_data: list, genre: str, top_n: int) -> list: pass ```","solution":"def recommend_movies(user_data: list, genre: str, top_n: int) -> list: Suggests the top `N` movies by average rating for a specific genre. Parameters: user_data (list): A list of dictionaries where each dictionary contains the keys \'title\', \'genre\', and \'ratings\'. genre (str): The genre to filter movies by. top_n (int): The number of top-rated movies to return. Returns: list: A list of movie titles representing the top `N` highest-rated movies in the specified genre. # Filter movies by the specified genre genre_movies = [movie for movie in user_data if movie[\'genre\'] == genre] # Calculate the average rating for each movie avg_ratings = [ (movie[\'title\'], sum(movie[\'ratings\']) / len(movie[\'ratings\'])) for movie in genre_movies ] # Sort the movies by average rating (descending) and then by title (alphabetical) if ratings are equal sorted_movies = sorted(avg_ratings, key=lambda x: (-x[1], x[0])) # Extract movie titles top_movies = [title for title, rating in sorted_movies[:top_n]] return top_movies"},{"question":"# Prime Path Check Write a function to determine whether there exists a \\"prime path\\" between two given prime numbers. A prime path is a sequence of prime numbers where each consecutive pair of primes in the sequence differs by exactly 2 (i.e., twin primes). Implementation Requirements 1. **Function to Implement**: - `prime_path_exists(start: int, end: int) -> bool`: - This function takes two integers, `start` and `end`, and returns a boolean indicating whether a prime path exists between the two prime numbers. - If either `start` or `end` is not a prime number, the function should raise a `ValueError`. 2. **Prime Path Definition**: - A prime path exists between two numbers if there is a sequence of prime numbers (all greater than or equal to `start` and less than or equal to `end`), where each pair of consecutive primes in the sequence differs by exactly 2. 3. **Helper Function** (Suggestion): - You may create a helper function `is_prime(n: int) -> bool` to check if a number is prime. - You can also create a helper function to generate all prime numbers in a given range: `generate_primes_in_range(start: int, end: int) -> List[int]`. 4. **Edge Cases**: - If start and end are the same and are prime, return True. - Ensure correct handling for ranges where no primes exist or where the twin prime condition is unachievable. 5. **Error Handling**: - Raise a `ValueError` if `start` or `end` is not a prime number with an appropriate error message. **Function Signature**: ```python def prime_path_exists(start: int, end: int) -> bool: ... ``` **Constraints**: - `start` and `end` will be non-negative integers. - Use only Python standard libraries. - Ensure that the input constraints (valid primes) are stringently verified. **Example**: ```python prime_path_exists(3, 11) # True: Sequence [3, 5, 7] or [5, 7, 11] prime_path_exists(7, 19) # True: Sequence [7, 11, 13, 17, 19] prime_path_exists(11, 11) # True: Single prime # Example where no path exists: prime_path_exists(14, 19) # Raises ValueError: 14 is not prime ``` **Note**: To solve this problem, you can implement a prime number checking utility, generate relevant prime numbers within the given range, and then verify the existence of a sequence that meets the twin primes condition.","solution":"def is_prime(n: int) -> bool: Returns True if n is a prime number, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def generate_primes_in_range(start: int, end: int) -> list: Generates a list of prime numbers in the inclusive range from start to end. primes = [] for num in range(start, end + 1): if is_prime(num): primes.append(num) return primes def prime_path_exists(start: int, end: int) -> bool: Returns True if there is a prime path from start to end, otherwise False. if not is_prime(start) or not is_prime(end): raise ValueError(f\\"Both start({start}) and end({end}) must be prime numbers.\\") if start == end: return True primes = generate_primes_in_range(start, end) for i in range(len(primes) - 1): if primes[i+1] - primes[i] == 2 or primes[i] - primes[i+1] == 2: return True return False"},{"question":"# Coding Assessment Task Scenario You are designing algorithms for a social media platform that involves processing streams of data. One of the core functionalities requested by your team is the ability to track the longest streak of user activity over a certain period. This helps in analyzing engagement and activity patterns on the platform. Question Write a function `longest_activity_streak(data: List[int]) -> int` that takes a list of integers, `data`, representing days a user was active (sorted in ascending order) and returns the length of the longest consecutive streak of daily activity. Input * A list of integers `data` where each integer represents a day the user was active. The list is sorted in ascending order and can have up to 10^5 elements. The days are represented as positive integers. Output * An integer representing the length of the longest consecutive streak of active days. Constraints 1. The list can be empty, in which case the function should return 0. 2. Ensure the function is optimized to handle the maximum input size efficiently. Examples ```python assert longest_activity_streak([1, 2, 3, 7, 8, 9, 15]) == 3 assert longest_activity_streak([10, 11, 12, 13, 20, 21, 22, 23, 24]) == 5 assert longest_activity_streak([5, 10, 15, 20]) == 1 assert longest_activity_streak([]) == 0 assert longest_activity_streak([1, 2, 4, 5, 6]) == 3 ``` Requirements * Your solution should have a time complexity of O(n). * Your solution should have a space complexity not exceeding O(1). * Proper handling of edge cases and valid input inspection is required.","solution":"def longest_activity_streak(data): This function takes a list of integers representing days a user was active and returns the length of the longest consecutive streak of daily activity. The list of integers is assumed to be sorted in ascending order. if not data: return 0 longest_streak = 1 current_streak = 1 for i in range(1, len(data)): if data[i] == data[i - 1] + 1: current_streak += 1 longest_streak = max(longest_streak, current_streak) else: current_streak = 1 return longest_streak"},{"question":"# Implement a Simple Directed Graph using Adjacency List You are required to implement a simple directed graph using an adjacency list. Your graph should support the following operations: 1. Adding a vertex to the graph. 2. Adding an edge between two vertices. 3. Checking if there is an edge between two vertices. 4. Performing Breadth-First Search (BFS) from a given starting vertex and returning the order of visited vertices. # Function Requirements 1. `add_vertex(self, vertex)`: Add a vertex to the graph. 2. `add_edge(self, start_vertex, end_vertex)`: Add a directed edge from `start_vertex` to `end_vertex`. 3. `has_edge(self, start_vertex, end_vertex)`: Check if there is an edge from `start_vertex` to `end_vertex`. 4. `bfs(self, start_vertex)`: Perform BFS starting from `start_vertex` and return the list of visited vertices in BFS order. # Input and Output - `add_vertex(self, vertex)` - **Input**: An integer or string `vertex`. - **Output**: None. - `add_edge(self, start_vertex, end_vertex)` - **Input**: Two integers or strings `start_vertex` and `end_vertex`. - **Output**: None. - `has_edge(self, start_vertex, end_vertex)` - **Input**: Two integers or strings `start_vertex` and `end_vertex`. - **Output**: Boolean `True` if the edge exists, `False` otherwise. - `bfs(self, start_vertex)` - **Input**: An integer or string `start_vertex`. - **Output**: A list of vertices visited in BFS order. # Constraints - The graph should handle both integer and string vertex identifiers. - Assume the graph does not contain duplicate edges or self-loops. - The methods should be efficient in terms of time complexity. # Example ```python graph = Graph() # Add vertices graph.add_vertex(1) graph.add_vertex(2) graph.add_vertex(3) graph.add_vertex(4) graph.add_vertex(5) # Add edges graph.add_edge(1, 2) graph.add_edge(1, 3) graph.add_edge(2, 4) graph.add_edge(3, 5) # Check edges print(graph.has_edge(1, 2)) # => True print(graph.has_edge(4, 5)) # => False # Perform BFS print(graph.bfs(1)) # => [1, 2, 3, 4, 5] or any other valid BFS traversal order ``` # Implementation Implement the necessary methods to complete the `Graph` class, focusing on the characteristics and principles of a directed graph using an adjacency list.","solution":"from collections import deque, defaultdict class Graph: def __init__(self): self.adjacency_list = defaultdict(list) def add_vertex(self, vertex): if vertex not in self.adjacency_list: self.adjacency_list[vertex] = [] def add_edge(self, start_vertex, end_vertex): if start_vertex in self.adjacency_list and end_vertex not in self.adjacency_list[start_vertex]: self.adjacency_list[start_vertex].append(end_vertex) def has_edge(self, start_vertex, end_vertex): return end_vertex in self.adjacency_list[start_vertex] def bfs(self, start_vertex): visited = set() queue = deque([start_vertex]) visited_order = [] while queue: vertex = queue.popleft() if vertex not in visited: visited.add(vertex) visited_order.append(vertex) queue.extend(self.adjacency_list[vertex]) return visited_order"},{"question":"# Problem Statement Write a function that takes in a list of integers and an integer target, and returns a list of unique triplets `[a, b, c]` from the input list such that `a + b + c = target`. Function Signature ```python def three_sum(nums: List[int], target: int) -> List[List[int]]: ``` Inputs * `nums` (List[int]): A list of integers that might contain both negative, zero, and positive values. The list can have up to `10^4` elements. * `target` (int): An integer that represents the target sum for the triplets. Outputs * Returns a list of unique triplets `[a, b, c]` such that `a + b + c = target`. * Each triplet must be sorted in ascending order. * The result list must not contain duplicate triplets. Constraints * The triplet elements can be in any order, but only unique triplets should be part of the output. * The function should operate within a reasonable time complexity to handle the upper limit of input size. Example ```python assert three_sum([-1, 0, 1, 2, -1, -4], 0) == [[-1, -1, 2], [-1, 0, 1]] assert three_sum([1, 2, 3, 4, 5], 9) == [[1, 3, 5], [2, 3, 4]] assert three_sum([0, 0, 0, 0], 0) == [[0, 0, 0]] assert three_sum([-2, 0, 1, 1, 2], 1) == [[-2, 1, 2]] ``` Performance Requirements * Ensure the function runs in O(n^2) time complexity where n is the number of elements in the input list. * The space complexity should be carefully managed to avoid excessive use of extra memory. # Instructions Implement the `three_sum` function based on the provided signature. Your solution should handle edge cases appropriately and produce a list of unique triplets that sum up to the target value.","solution":"from typing import List def three_sum(nums: List[int], target: int) -> List[List[int]]: Returns a list of unique triplets [a, b, c] from the input list such that a + b + c = target. nums.sort() result = [] for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue # Skip duplicates for the first number of the triplet left, right = i + 1, len(nums) - 1 while left < right: sum = nums[i] + nums[left] + nums[right] if sum == target: result.append([nums[i], nums[left], nums[right]]) while left < right and nums[left] == nums[left + 1]: left += 1 # Skip duplicates for the second number of the triplet while left < right and nums[right] == nums[right - 1]: right -= 1 # Skip duplicates for the third number of the triplet left += 1 right -= 1 elif sum < target: left += 1 else: right -= 1 return result"},{"question":"**Balanced Binary Search Tree (BST) with Augmented Data Structure** You are given a basic implementation of a Binary Search Tree (BST) that supports insertion and searching of nodes. However, this implementation does not keep the tree balanced. Your task is to enhance this BST to maintain balance during insertions, ensuring optimal search times. Additionally, augment the tree to support querying the k-th smallest element efficiently. # Task 1. **Balance the BST**: Modify the BST to use AVL tree properties to keep it balanced during insertions. 2. **Augment Data Structure**: Update nodes to store an additional `size` attribute representing the size of the subtree rooted at that node. 3. **Implement Query Function**: - `find_kth_smallest` to return the k-th smallest element in the BST. # Requirements 1. **insert**: - Input: Value to be inserted. - Functionality: Insert the value while maintaining the balanced nature of the AVL tree. 2. **balance**: - Input: Node of the tree. - Functionality: Ensure the node (and its subtree) is balanced according to AVL tree properties after insertion or rotations. 3. **rotate_left** and **rotate_right**: - Input: Node of the tree. - Functionality: Perform the necessary rotation to maintain balance. 4. **find_kth_smallest**: - Input: Root of the tree, k. - Output: The k-th smallest element in the BST. # Constraints - Insertions are guaranteed to have unique values. - The tree may contain at most `10^5` nodes. - Ensure that balance and k-th smallest queries are handled efficiently. # Example ```python bst = AVLTree() bst.insert(5) bst.insert(3) bst.insert(8) bst.insert(2) bst.insert(4) bst.insert(7) bst.insert(9) print(bst.find_kth_smallest(bst.root, 3)) # Output: 4 print(bst.find_kth_smallest(bst.root, 5)) # Output: 7 print(bst.find_kth_smallest(bst.root, 1)) # Output: 2 ``` # AVLTree Class Implementation ```python class AVLTreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.size = 1 # Size of the subtree rooted at this node self.key = key class AVLTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = AVLTreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return AVLTreeNode(key) if key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) root.size = 1 + self.get_size(root.left) + self.get_size(root.right) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.rotate_right(root) if balance < -1 and key > root.right.key: return self.rotate_left(root) if balance > 1 and key > root.left.key: root.left = self.rotate_left(root.left) return self.rotate_right(root) if balance < -1 and key < root.right.key: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.size = 1 + self.get_size(z.left) + self.get_size(z.right) y.size = 1 + self.get_size(y.left) + self.get_size(y.right) return y def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.size = 1 + self.get_size(z.left) + self.get_size(z.right) y.size = 1 + self.get_size(y.left) + self.get_size(y.right) return y def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def get_size(self, node): if not node: return 0 return node.size def find_kth_smallest(self, root, k): if not root: return None left_size = self.get_size(root.left) if k <= left_size: return self.find_kth_smallest(root.left, k) elif k == left_size + 1: return root.key else: return self.find_kth_smallest(root.right, k - left_size - 1) ```","solution":"class AVLTreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.size = 1 # Size of the subtree rooted at this node self.key = key class AVLTree: def __init__(self): self.root = None def insert(self, key): if not self.root: self.root = AVLTreeNode(key) else: self.root = self._insert(self.root, key) def _insert(self, root, key): if not root: return AVLTreeNode(key) if key < root.key: root.left = self._insert(root.left, key) else: root.right = self._insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) root.size = 1 + self.get_size(root.left) + self.get_size(root.right) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.rotate_right(root) if balance < -1 and key > root.right.key: return self.rotate_left(root) if balance > 1 and key > root.left.key: root.left = self.rotate_left(root.left) return self.rotate_right(root) if balance < -1 and key < root.right.key: root.right = self.rotate_right(root.right) return self.rotate_left(root) return root def rotate_left(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.size = 1 + self.get_size(z.left) + self.get_size(z.right) y.size = 1 + self.get_size(y.left) + self.get_size(y.right) return y def rotate_right(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) z.size = 1 + self.get_size(z.left) + self.get_size(z.right) y.size = 1 + self.get_size(y.left) + self.get_size(y.right) return y def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def get_size(self, node): if not node: return 0 return node.size def find_kth_smallest(self, root, k): if not root: return None left_size = self.get_size(root.left) if k <= left_size: return self.find_kth_smallest(root.left, k) elif k == left_size + 1: return root.key else: return self.find_kth_smallest(root.right, k - left_size - 1)"},{"question":"# Data Structure Manipulation: Library Management Context: You have been given the task of managing a small library\'s catalog using a Python program. The library needs a system to add books, update book statuses (available/borrowed), and search for books by either title or author. Requirements: 1. Implement a class `Library` that maintains the catalog with the following functionalities: - **Add a book**: Add a new book to the catalog. - **Update the status of a book**: Mark a book as borrowed or available. - **Search for books**: Return a list of books matching a given title or author. 2. Each book should be represented as an instance of the `Book` class with the following attributes: - `title` (string): The title of the book. - `author` (string): The author of the book. - `status` (string): The status of the book, either \\"available\\" or \\"borrowed\\". 3. Ensure that the methods handle edge cases like adding duplicate books, searching for books that don\'t exist, and updating the status of non-existent books. Implementation: Create the `Book` and `Library` classes and implement the required methods within the `Library` class. # Class Definitions: ```python class Book: def __init__(self, title: str, author: str, status: str = \\"available\\"): pass class Library: def __init__(self): pass def add_book(self, title: str, author: str): pass def update_status(self, title: str, status: str): pass def search_books(self, query: str, search_by: str): pass ``` # Input/Output Specifications: * **add_book(title, author)**: - **Input**: - `title` (str): The title of the book. - `author` (str): The author of the book. - **Output**: None * **update_status(title, status)**: - **Input**: - `title` (str): The title of the book. - `status` (str): The new status of the book, either \\"available\\" or \\"borrowed\\". - **Output**: None * **search_books(query, search_by)**: - **Input**: - `query` (str): The search query. - `search_by` (str): The criterion to search by, either \\"title\\" or \\"author\\". - **Output**: - List of `Book` objects that match the search criteria. # Constraints: * The title and author are case insensitive. * Methods should handle edge cases gracefully such as duplicate additions or invalid updates. * There can be books with the same title written by different authors. # Examples: ```python # Create a library instance library = Library() # Add books library.add_book(\'The Great Gatsby\', \'F. Scott Fitzgerald\') library.add_book(\'To Kill a Mockingbird\', \'Harper Lee\') # Search for books by title result = library.search_books(\'The Great Gatsby\', \'title\') assert len(result) == 1 assert result[0].author == \'F. Scott Fitzgerald\' # Update book status library.update_status(\'The Great Gatsby\', \'borrowed\') assert library.search_books(\'The Great Gatsby\', \'title\')[0].status == \'borrowed\' # Search for books by author result = library.search_books(\'Harper Lee\', \'author\') assert len(result) == 1 assert result[0].title == \'To Kill a Mockingbird\' # Handle edge cases library.add_book(\'The Great Gatsby\', \'F. Scott Fitzgerald\') # Duplicate should be ignored library.update_status(\'1984\', \'borrowed\') # Non-existent book, no change should occur ```","solution":"class Book: def __init__(self, title: str, author: str, status: str = \\"available\\"): self.title = title.lower() self.author = author.lower() self.status = status class Library: def __init__(self): self.catalog = [] def add_book(self, title: str, author: str): title = title.lower() author = author.lower() for book in self.catalog: if book.title == title and book.author == author: return new_book = Book(title, author) self.catalog.append(new_book) def update_status(self, title: str, status: str): title = title.lower() for book in self.catalog: if book.title == title: book.status = status def search_books(self, query: str, search_by: str): query = query.lower() matched_books = [] if search_by == \\"title\\": matched_books = [book for book in self.catalog if book.title == query] elif search_by == \\"author\\": matched_books = [book for book in self.catalog if book.author == query] return matched_books"},{"question":"# Objective Write a function that identifies all \\"happy numbers\\" within a given inclusive range `[start, end]`. A happy number is defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits in base-ten, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle that does not include 1. Those numbers for which this process ends in 1 are considered happy numbers. # Function Signature ```python def find_happy_numbers(start: int, end: int) -> list: Returns a list of all happy numbers in the range [start, end] ``` # Input and Output - **Input**: - `start` (int): The starting number of the range (inclusive). - `end` (int): The ending number of the range (inclusive). - **Output**: - (list): A list of all happy numbers within the specified range. # Constraints - Both `start` and `end` are non-negative integers where `start <= end`. - The function should handle a range of up to 100,000 numbers efficiently. # Performance Requirements - The solution must be efficient and avoid unnecessary computations, utilizing memoization or other optimization techniques. # Scenario In certain number theory problems, identifying special series of numbers like happy numbers can be crucial for further analysis. Your task is to write a function that enumerates these happy numbers within a specified range. # Example ```python # Given the range from 1 to 10 print(find_happy_numbers(1, 10)) # Output: [1, 7, 10] # Given the range from 15 to 25 print(find_happy_numbers(15, 25)) # Output: [19] ```","solution":"def find_happy_numbers(start: int, end: int) -> list: Returns a list of all happy numbers in the range [start, end]. def is_happy(n): seen = set() while n != 1 and n not in seen: seen.add(n) n = sum(int(digit) ** 2 for digit in str(n)) return n == 1 happy_numbers = [] for num in range(start, end + 1): if is_happy(num): happy_numbers.append(num) return happy_numbers"},{"question":"# Binary Tree Vertical Order Traversal Context You are given the root of a binary tree. You need to perform a vertical order traversal of the binary tree. In vertical order traversal, nodes with the same horizontal distance from the root are grouped together. Nodes have a horizontal distance defined as follows: - The horizontal distance of the root is 0. - The horizontal distance of a left child is horizontal distance of the parent minus 1. - The horizontal distance of a right child is horizontal distance of the parent plus 1. You should output the values in each vertical traversal from left to right. Task Implement the `verticalOrderTraversal` method of the `BinaryTree` class in Python. Method Details 1. **verticalOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]**: - **Input**: `root` - The root node of the binary tree, where TreeNode is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - **Output**: A list of lists, where each list contains integers representing nodes\' values in the vertical order from left to right. - **Example**: ```python # Example tree: # 3 # / # 9 20 # / # 15 7 binary_tree = BinaryTree() root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) assert binary_tree.verticalOrderTraversal(root) == [[9], [3, 15], [20], [7]] ``` Constraints - The number of nodes in the binary tree can be up to 10,000. - Each node\'s value is unique. - The binary tree will have at least one node. Performance - Aim for linear processing time relative to the number of nodes in the tree. - Ensure minimal additional space usage beyond what is necessary for processing the traversal.","solution":"from collections import defaultdict, deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right class BinaryTree: def verticalOrderTraversal(self, root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] # Dictionary to store the nodes according to their horizontal distance column_table = defaultdict(list) # Queue to perform BFS, storing tuples of node and its column index queue = deque([(root, 0)]) while queue: node, column = queue.popleft() if node: column_table[column].append(node.val) # If the current node has a left child, enqueue it with column - 1 if node.left: queue.append((node.left, column - 1)) # If the current node has a right child, enqueue it with column + 1 if node.right: queue.append((node.right, column + 1)) # Extract the columns in sorted order and generate the output sorted_columns = sorted(column_table.keys()) return [column_table[x] for x in sorted_columns]"},{"question":"# Problem Statement Write a function that takes a list of integers and filters out all prime numbers from the list. The function should return a new list containing non-prime numbers only. # Function Signature ```python def filter_non_primes(numbers: List[int]) -> List[int]: pass ``` # Input/Output Requirements * **Input**: A single argument: - `numbers` (List[int]): A list of integers. * **Output**: - Returns a list of integers which are non-prime. # Constraints - Each number in the list will be a positive integer. - The list will contain at most 10^6 numbers. - Each integer in the list will be at most 10^6. # Performance Requirements - The function should have an average time complexity around O(n √m), where n is the number of integers in the list and m is the maximum integer value in the list. - The space complexity should not exceed O(n). # Scenario You are building a mathematical tool for analyzing datasets that contain a large number of integers. As part of the simplification process, your task is to remove prime numbers from these datasets, leaving only composite numbers which are of greater interest for a particular analysis. # Example ```python >>> filter_non_primes([2, 3, 4, 5, 10, 13, 17]) [4, 10] >>> filter_non_primes([29, 33, 35, 36, 37, 39]) [33, 35, 36, 39] ``` # Solution Requirements - Implement the `filter_non_primes` function following the given specifications. - Ensure the solution handles large inputs efficiently. - Use an appropriate algorithm to check for prime numbers, such as the Sieve of Eratosthenes. ```python def filter_non_primes(numbers: List[int]) -> List[int]: def is_prime(n: int) -> bool: if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True return [num for num in numbers if not is_prime(num)] ```","solution":"def filter_non_primes(numbers): def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while (i * i) <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True # return a list excluding prime numbers return [num for num in numbers if not is_prime(num)]"},{"question":"# **Anagram Checker Using Sorting** Background An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. You need to create a function to check if two strings are anagrams of each other. Task Write a Python function `are_anagrams(str1: str, str2: str) -> bool` that takes two strings as input and returns `True` if the strings are anagrams of each other, and `False` otherwise. Your implementation should use sorting to determine if the strings are anagrams. Details: 1. **Input Format**: Two strings, `str1` and `str2`. 2. **Output Format**: A boolean indicating whether the input strings are anagrams of each other. Constraints: - The function should raise a `TypeError` if either of the inputs is not a string. - Ignore spaces and consider letters as case-insensitive for the purpose of comparison. Examples: ``` are_anagrams(\\"listen\\", \\"silent\\") # True, because both strings contain the same letters are_anagrams(\\"triangle\\", \\"integral\\") # True, because both strings contain the same letters are_anagrams(\\"apple\\", \\"pale\\") # False, because the strings do not contain the same letters are_anagrams(\\"The eyes\\", \\"They see\\") # True, spaces are ignored and letters are case-insensitive are_anagrams(\\"hello\\", 123) # Raises TypeError are_anagrams(256, \\"silent\\") # Raises TypeError ``` Notes: 1. Validate your input before performing any operations. 2. Ignore spaces and convert both strings to lowercase before comparing. 3. Write appropriate test cases to handle possible edge cases. ```python def are_anagrams(str1, str2): if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Input values must be strings\\") def clean_string(s): return \'\'.join(sorted(s.replace(\\" \\", \\"\\").lower())) return clean_string(str1) == clean_string(str2) # Test cases print(are_anagrams(\\"listen\\", \\"silent\\")) # True print(are_anagrams(\\"triangle\\", \\"integral\\")) # True print(are_anagrams(\\"apple\\", \\"pale\\")) # False print(are_anagrams(\\"The eyes\\", \\"They see\\")) # True ```","solution":"def are_anagrams(str1, str2): if not isinstance(str1, str) or not isinstance(str2, str): raise TypeError(\\"Input values must be strings\\") def clean_string(s): return \'\'.join(sorted(s.replace(\\" \\", \\"\\").lower())) return clean_string(str1) == clean_string(str2)"},{"question":"# Question: Analyze and Optimize the Prime Number Generation Context: You are working on an application that requires generating a list of prime numbers up to a given limit `n`. The current implementation uses a basic method that is inefficient for larger values of `n`. Therefore, you need to implement a more efficient algorithm known as the Sieve of Eratosthenes. Task: Write a function `sieve_of_eratosthenes(n)` that generates all prime numbers up to the given limit `n` efficiently. Input: * `n`: An integer representing the upper limit for generating prime numbers (inclusive). Output: * A list of integers representing all the prime numbers from 2 up to `n`. Examples: ```python >>> sieve_of_eratosthenes(10) [2, 3, 5, 7] >>> sieve_of_eratosthenes(20) [2, 3, 5, 7, 11, 13, 17, 19] >>> sieve_of_eratosthenes(1) [] >>> sieve_of_eratosthenes(2) [2] ``` Constraints: * The function should handle values of `n` up to 10,000 efficiently. * You must implement the Sieve of Eratosthenes algorithm and ensure it runs in O(n log log n) time complexity. * Do not use external libraries for prime generation. Sieve of Eratosthenes Algorithm Explanation: 1. Create a boolean array `is_prime` of size `n + 1` and initialize all elements to `True`, except for indices 0 and 1. 2. Starting from the first prime number (2), mark all of its multiples as `False` (indicating they are not primes). 3. Move to the next number in the array that is still marked True and repeat step 2 until you reach the square root of `n`. 4. All remaining indices marked `True` in the array correspond to prime numbers. ```python def sieve_of_eratosthenes(n): if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [num for num in range(2, n + 1) if is_prime[num]] # Test cases print(sieve_of_eratosthenes(10)) # Output: [2, 3, 5, 7] print(sieve_of_eratosthenes(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] print(sieve_of_eratosthenes(1)) # Output: [] print(sieve_of_eratosthenes(2)) # Output: [2] ```","solution":"def sieve_of_eratosthenes(n): Generate all prime numbers up to the given limit n using the Sieve of Eratosthenes algorithm. Parameters: n (int): The upper limit for generating prime numbers (inclusive). Returns: list: A list containing all prime numbers from 2 up to n. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0], is_prime[1] = False, False p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [num for num in range(2, n + 1) if is_prime[num]]"},{"question":"Additional Coding Assessment Question Scenario You are a software engineer leading a project that involves optimizing the processing time for large-scale data tasks. Your task is to implement an efficient scheduling algorithm that determines the minimum number of meeting rooms required to accommodate all given meetings. Function to Implement Implement the function `min_meeting_rooms(intervals: list) -> int` which calculates the minimum number of meeting rooms required to hold all the meetings. Input 1. `intervals`: A list of tuples where each tuple represents the start and end time of a meeting `(start, end)`. Output The function should return an integer representing the minimum number of meeting rooms required. Constraints 1. The number of meetings (N) is between 1 and 10^4. 2. Meeting times are given as non-negative integers. 3. Ensure that edge cases like overlapping meetings and non-overlapping meetings are handled properly. Performance Requirements - The function should efficiently handle up to 10,000 meetings. - Aim for a time complexity better than O(N^2), preferably O(N log N). Example ```python intervals = [(0, 30), (5, 10), (15, 20)] assert min_meeting_rooms(intervals) == 2 intervals = [(7, 10), (2, 4)] assert min_meeting_rooms(intervals) == 1 ``` **Note**: Make sure to account for meetings that have overlapping times and those that start the moment another ends. The input list of intervals can be unsorted.","solution":"def min_meeting_rooms(intervals): Returns the minimum number of meeting rooms required. Parameters: intervals (list of tuples): Each tuple contains the start and end time of a meeting. Returns: int: The minimum number of meeting rooms required to hold all meetings. if not intervals: return 0 # Extract the start and end times from the intervals start_times = sorted([i[0] for i in intervals]) end_times = sorted([i[1] for i in intervals]) start_pointer = 0 end_pointer = 0 rooms_needed = 0 # Iterate over meetings to determine the number of rooms needed while start_pointer < len(intervals): if start_times[start_pointer] >= end_times[end_pointer]: rooms_needed -= 1 end_pointer += 1 rooms_needed += 1 start_pointer += 1 return rooms_needed"},{"question":"# Problem Statement **Balanced Parentheses Sequences** A balanced parentheses sequence is a string consisting only of characters \'(\' and \')\' which satisfies the following conditions: 1. For every opening parenthesis \'(\', there exists a corresponding closing parenthesis \')\'. 2. The substring formed by any prefix of the sequence has at least as many opening parentheses as closing parentheses. Write a function `balanced_parentheses_sequences(n: int) -> int` that calculates the total number of distinct balanced parentheses sequences of length `2n`. **Constraints**: - `1 <= n <= 20` Input - `n` (int): The number of pairs of parentheses. Output - `int`: The total number of distinct balanced parentheses sequences of length `2n`. Example ```python def balanced_parentheses_sequences(n: int) -> int: # Implementation here… print(balanced_parentheses_sequences(3)) # Should output the number of balanced sequences of length 6 ``` Notes - Utilize dynamic programming or combinatorial methods to achieve an efficient solution. - The length of the sequence will always be even. Hints - The nth Catalan number provides the count of balanced parentheses sequences of length `2n`. You may implement a direct calculation using combinatorial properties or via dynamic programming.","solution":"def balanced_parentheses_sequences(n: int) -> int: Returns the total number of distinct balanced parentheses sequences of length 2n. This is equivalent to finding the nth Catalan number. # Use dynamic programming to compute the Catalan number C = [0] * (n + 1) C[0] = 1 for i in range(1, n + 1): C[i] = 0 for j in range(i): C[i] += C[j] * C[i - 1 - j] return C[n]"},{"question":"# Problem: Reversing a List of Strings Task Write a function `reverse_strings(input_list: List[str]) -> List[str]` that takes a list of strings and returns a new list with each string reversed while maintaining their respective positions. Input - `input_list` (List[str]): A list of strings where each string can contain alphanumeric characters, spaces, and punctuation. Output - Returns a list of strings where each string from the input list is reversed in order. The order of strings in the list itself remains unchanged. Constraints - The input list can contain up to (10^5) strings. - Each string in the list will have a maximum length of (10^3). - The input must be a list of strings. If not, raise a `ValueError` with a message indicating the type of the input found. Function Signature ```python def reverse_strings(input_list: List[str]) -> List[str]: pass ``` Examples ```python >>> reverse_strings([\\"hello\\", \\"world\\"]) [\'olleh\', \'dlrow\'] >>> reverse_strings([\\"Python\\", \\"is\\", \\"fun!\\"]) [\'nohtyP\', \'si\', \'!nuf\'] >>> reverse_strings([\\"madam\\", \\"racecar\\", \\"deified\\"]) [\'madam\', \'racecar\', \'deified\'] >>> reverse_strings([\\"12345\\", \\"Hi There!\\"]) [\'54321\', \'!erehT iH\'] ``` **Note**: Ensure your function efficiently handles lists up to the specified length and performs necessary checks for correct input type. The reversed strings must maintain the same relative positions as in the original list.","solution":"from typing import List def reverse_strings(input_list: List[str]) -> List[str]: Receives a list of strings and returns a new list with each string reversed while maintaining their respective positions. Args: input_list (List[str]): A list of strings. Returns: List[str]: A list where each string is reversed. Raises: ValueError: If the input is not a list of strings. if not isinstance(input_list, list): raise ValueError(f\\"Expected a list but got {type(input_list).__name__}\\") for item in input_list: if not isinstance(item, str): raise ValueError(f\\"Expected all elements in the list to be strings but found {type(item).__name__}\\") return [item[::-1] for item in input_list]"},{"question":"# Coding Assessment Question Dynamic Array Element Insertion with Auto-Resizing You are to enhance an existing `DynamicArray` class to support automatic resizing when elements are inserted. The array should dynamically resize when it reaches its maximum capacity to ensure normalization and efficient memory usage. Task 1. Implement a method `insert` that inserts an element into the array and resizes the array if the current capacity is reached. 2. Implement auto-resizing logic such that each time the capacity is reached, the array doubles in size. 3. Track the current size and capacity of the array. Additional Guidelines - Resizing Strategy: - When the array reaches its maximum capacity, create a new array double the size of the current one and copy all elements into the new array. Function Signatures and Expected Behavioral Outline ```python class DynamicArray: def __init__(self, capacity=2): # Initialize the dynamic array with default capacity of 2 pass def insert(self, element): # Insert element and resize if needed pass def get(self, index): # Retrieve element at the given index pass def size(self): # Return the current size of the array pass def capacity(self): # Return the current capacity of the array pass ``` Input Examples and Output Expectations ```python # Initialize a dynamic array dyn_array = DynamicArray() # Insert elements into the dynamic array dyn_array.insert(5) dyn_array.insert(10) # Array should resize here dyn_array.insert(15) # Retrieve elements print(dyn_array.get(0)) # Output: 5 print(dyn_array.get(1)) # Output: 10 print(dyn_array.get(2)) # Output: 15 # Insert more elements dyn_array.insert(20) dyn_array.insert(25) # Array should resize here again dyn_array.insert(30) # Print current size and capacity of dynamic array print(dyn_array.size()) # Output: 6 print(dyn_array.capacity()) # Output: 8 ``` - **Constraints**: - The initial capacity of the array should be >= 2. - The array should automatically resize when it reaches maximum capacity. - **Performance Requirements**: - Ensure the insertion operation remains efficient even after multiple resizes. - Minimize the overhead during the array resizing to maintain optimal performance. Evaluate the correctness of element retrieval and the efficiency of dynamic resizing through various insertions.","solution":"class DynamicArray: def __init__(self, capacity=2): self._capacity = capacity self._size = 0 self._array = [None] * capacity def insert(self, element): if self._size == self._capacity: self._resize() self._array[self._size] = element self._size += 1 def _resize(self): new_capacity = self._capacity * 2 new_array = [None] * new_capacity for i in range(self._size): new_array[i] = self._array[i] self._array = new_array self._capacity = new_capacity def get(self, index): if 0 <= index < self._size: return self._array[index] else: raise IndexError(\\"Index out of bounds\\") def size(self): return self._size def capacity(self): return self._capacity"},{"question":"# Problem Statement You\'ve been asked to implement a scheduling application for a conference. The conference consists of multiple speakers and sessions, but no two sessions should overlap in time. You must determine the maximum number of non-overlapping sessions that can be attended given a list of session time intervals. # Function Signature ```python def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: pass ``` # Input and Output The function should take: * `sessions`: a list of tuples where each tuple represents a session with a start and end time `(start, end)`. The function should return an integer representing the maximum number of non-overlapping sessions that can be attended. # Constraints * Each session\'s start and end time will be positive integers, and `start < end`. * The length of the `sessions` list will be at most `10^4`. * Sessions may be sorted in no particular order. # Example ```python max_non_overlapping_sessions([(1, 3), (2, 4), (3, 5)]) ``` Should return `2` because you can attend session `(1, 3)` and `(3, 5)`, which do not overlap. # Explanation To solve this problem: 1. Sort the sessions based on their end times. 2. Iterate through the sorted sessions and maintain a count of the non-overlapping sessions. 3. Keep track of the end time of the last attended session and if the start of the current session is after or exactly at the end of the last attended session, include it in the count. Example Walkthrough Given the sessions `[(1, 3), (2, 4), (3, 5)]`, sort them by their end times to get: ``` [(1, 3), (2, 4), (3, 5)] ``` - Start with an empty end time. - Attend the session `(1, 3)` and update the end time to `3`. - Skip session `(2, 4)` because its start time `2` is less than the end time `3`. - Attend the session `(3, 5)` and update the end time to `5`. Thus, the maximum number of non-overlapping sessions is `2`. # Note Ensure the implementation handles edge cases, including: * No sessions provided (should return 0). * Sessions that all overlap where only one can be selected.","solution":"from typing import List, Tuple def max_non_overlapping_sessions(sessions: List[Tuple[int, int]]) -> int: # Sort the sessions by their ending times sessions.sort(key=lambda x: x[1]) # Initialize the last end time and count last_end_time = float(\'-inf\') count = 0 for start, end in sessions: if start >= last_end_time: count += 1 last_end_time = end return count"},{"question":"# Coding Assessment Question Unique Character Combinations: You are asked to determine the number of unique 4-character strings that can be generated using a given input string. Each character in the input string must be used at most once per generated string. Your objective is to implement a function that counts the total number of unique 4-character combinations that can be formed. Function Definition: Implement the function `unique_combinations(s: str) -> int` that takes a single parameter: - `s` (a string of lowercase alphabets, 1 <= len(s) <= 10) and returns an integer representing the total number of unique 4-character combinations that can be formed using the characters of `s`. Input: - A single string `s` containing lowercase English alphabets. Output: - An integer, the number of unique 4-character combinations. Example: ```python >>> result = unique_combinations(\'abcde\') >>> print(result) 120 >>> result = unique_combinations(\'abcd\') >>> print(result) 24 >>> result = unique_combinations(\'ab\') >>> print(result) 0 ``` Explanation: - For the string \'abcde\', the possible 4-character combinations are formed by selecting any 4 characters out of 5, which is calculated through permutations. - For the string \'abcd\', there is only 1 way to form a 4-character combination with all characters used. - For the string \'ab\', it is impossible to form a 4-character combination, thus the output is 0. Constraints: 1. Assume the input string contains only unique characters. 2. The input string will not be empty. 3. Efficiently handle the generation and counting of combinations to ensure performance. Best of luck!","solution":"from itertools import permutations def unique_combinations(s: str) -> int: Returns the number of unique 4-character combinations that can be formed from the input string s. if len(s) < 4: return 0 all_combinations = set(permutations(s, 4)) return len(all_combinations)"},{"question":"# Frequency of Most Frequent Substring You are tasked with writing a function that finds and returns the maximum frequency of any substring of a given length in a string. If there are multiple substrings with the same maximum frequency, return the frequency of any one of those substrings. Requirements: 1. Implement a `max_freq_substring` function that takes a string `s` and an integer `k` as input parameters. 2. The function should return the maximum frequency that any substring of length `k` appears in the given string `s`. 3. You should consider the substrings as case-insensitive. Expected Input and Output: - Input: A string `s` and an integer `k`. - Output: An integer representing the maximum frequency of any substring of length `k`. Constraints: - Substring length `k` is a positive integer and `k` <= length of string `s`. - The input string `s` is non-empty and contains only alphabetic characters (either lowercase or uppercase). Performance Requirements: - Time Complexity: (O(n cdot k)), where (n) is the length of the string. - Space Complexity: (O(n)), accounting for the storage of substring frequencies. # Example: ```python print(max_freq_substring(\\"ababcababa\\", 3)) # Output: 3 (The substring \\"aba\\" appears 3 times) print(max_freq_substring(\\"hellohello\\", 2)) # Output: 2 (The substrings \\"he\\", \\"el\\", \\"ll\\", \\"lo\\" all appear 2 times) print(max_freq_substring(\\"aabbcc\\", 1)) # Output: 2 (Each of the substrings \\"a\\", \\"b\\", and \\"c\\" appear 2 times) ``` Implement the function `max_freq_substring` as per the above requirements.","solution":"def max_freq_substring(s, k): Returns the maximum frequency of any substring of length k in the given string s. from collections import Counter # Convert the string to lower case to make it case-insensitive s = s.lower() # Create a counter to count the frequency of each substring of length k counter = Counter(s[i:i+k] for i in range(len(s) - k + 1)) # Return the maximum frequency found return max(counter.values())"},{"question":"# Coding Assessment Question **Title**: Kth Smallest Element in Sorted Matrix **Context**: Matrix manipulation is a common task in coding interviews and competitive programming. Given a sorted matrix, finding an element\'s position involves understanding how to navigate ordered structures efficiently. This problem will test your ability to work with two-dimensional arrays and apply sorting algorithms effectively. **Objective**: Write a function `kth_smallest(matrix: list[list[int]], k: int) -> int` that finds the k-th smallest element in a sorted `n x n` matrix. The matrix is sorted in non-decreasing order both row-wise and column-wise. **Input**: - `matrix`: An n x n matrix of integers, where each row and column is sorted in non-decreasing order. - `k`: An integer representing the position (1-based) of the smallest element to find. **Output**: - An integer representing the k-th smallest element in the matrix. **Constraints**: - `1 ≤ n ≤ 300` to ensure reasonable computation limits. - `1 ≤ matrix[i][j] ≤ 10^9` to match typical integer bounds in programming problems. - `1 ≤ k ≤ n^2` to ensure `k` is valid within the matrix elements. **Requirements**: - The function must find the k-th smallest element efficiently, considering the matrix\'s sorted property. **Example**: ```python def kth_smallest(matrix: list[list[int]], k: int) -> int: # Your solution here # Example Usage: print(kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8)) # Expected output: 13 print(kth_smallest([[1, 2], [1, 3]], 3)) # Expected output: 2 ``` **Hints**: - Consider using a min-heap to track the smallest elements in the matrix. - Think about binary search in the value range rather than index-based search for optimization.","solution":"import heapq def kth_smallest(matrix, k): Returns the k-th smallest element in a sorted n x n matrix. Args: - matrix (list of list of int): The sorted matrix (rows and columns sorted in non-decreasing order). - k (int): Position of the smallest element to find (1-based). Returns: - int: The k-th smallest element in the matrix. n = len(matrix) min_heap = [] for r in range(min(k, n)): # Add the first element of each row to the heap heapq.heappush(min_heap, (matrix[r][0], r, 0)) for _ in range(k - 1): value, r, c = heapq.heappop(min_heap) if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return heapq.heappop(min_heap)[0]"},{"question":"# Question: Efficient Smallest Positive Integer Finder Not In List Given a list of integers, implement a function `find_smallest_missing_positive(nums)` that finds the smallest positive integer which is not present in the list. The original function continuously scans and checks for missing numbers, resulting in an O(n^2) time complexity. Your task is to improve this process to achieve a better time complexity. Your optimized function should handle larger inputs efficiently. Implement the function: ```python def find_smallest_missing_positive(nums): pass ``` # Input/Output Input * `nums`: a list of integers containing the numbers in arbitrary order. Output * Returns an integer representing the smallest positive integer not present in the list. # Constraints * The length of the list `nums` is between 1 and 10^6 * The list can contain duplicates and negative numbers. * The integers in the list range from -10^6 to 10^6. # Example ```python assert find_smallest_missing_positive([1, 2, 0]) == 3 assert find_smallest_missing_positive([3, 4, -1, 1]) == 2 assert find_smallest_missing_positive([7, 8, 9, 11, 12]) == 1 ``` # Notes 1. Your solution should have a time complexity better than O(n^2). Ideally, target O(n) time complexity with O(1) space complexity (excluding the input list itself). 2. Use an efficient algorithm to handle large lists and a wide range of values effectively.","solution":"def find_smallest_missing_positive(nums): n = len(nums) # Step 1: Mark numbers (num < 0) and (num >= n) which are not useful as they are not in the range [1, n]. for i in range(n): if nums[i] <= 0 or nums[i] > n: nums[i] = n + 1 # Step 2: Mark each cell appearing in the array as negative # index = value - 1 for i in range(n): num = abs(nums[i]) if num <= n: nums[num - 1] = -abs(nums[num - 1]) # Step 3: Find the first positive number for i in range(n): if nums[i] > 0: return i + 1 return n + 1"},{"question":"# Rearrange Characters to Create Palindrome **Scenario**: You are working on a project to enhance a text-based puzzle game that involves creating palindromic strings. The player is given a string and must rearrange its characters to form a palindrome, if possible. **Task**: Write a function `can_form_palindrome(s: str) -> bool` that checks whether the characters of the given string can be rearranged into a palindrome. A string can be rearranged to a palindrome if and only if at most one character has an odd frequency. **Input**: * `s` - A string consisting of lowercase English letters. **Output**: * Return `True` if the characters can be rearranged to form a palindrome, otherwise return `False`. **Constraints**: * 1 <= len(s) <= 10^5 Your function needs to verify the possibility of forming a palindrome with efficient time complexity. **Example**: ```python >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aabbcc\\") True >>> can_form_palindrome(\\"aabbccd\\") True >>> can_form_palindrome(\\"abc\\") False ``` **Note**: - Remember that for a string to be rearranged into a palindrome, characters with even frequencies can be paired symmetrically, and at most one character can have an odd frequency to sit in the middle if the string length is odd. - Think about using a dictionary to count the occurrences of each character and then verifying the frequency conditions.","solution":"def can_form_palindrome(s: str) -> bool: Checks whether the characters of the given string can be rearranged into a palindrome. :param s: A string consisting of lowercase English letters. :return: True if the characters can be rearranged to form a palindrome, otherwise False. from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # For it to be rearranged to form a palindrome, at most one character can have an odd count. return odd_count <= 1"},{"question":"# Question: Implement a Decision Tree Classifier with Gini Index Your task is to implement a simple decision tree classifier using the Gini index as the splitting criterion. The decision tree should support binary classification. Requirements: 1. Create a `DecisionTreeClassifier` class. 2. Implement the constructor to initialize the tree and set any parameters (for this task, no parameters are required). 3. Implement the `fit` method to build the decision tree from training data using the Gini index for splitting. 4. Implement a `predict` method to classify new observations using the trained tree. 5. Ensure the class has appropriate helper methods to handle tasks like calculating the Gini index, finding the best split, and creating tree nodes. Input: - Observations: A 2D list or ndarray where each sub-list or ndarray represents the feature vectors of the training data. - Classes: A list or ndarray of integers {0, 1} representing the class labels of the training data. - A single test observation: A list or ndarray representing a new data point to classify. Output: - Predicted class: An integer value from {0, 1} corresponding to the predicted class of the observation. Constraints: - Inputs to the `fit` method can have up to 1,000 observations with up to 50 features each. - Each feature will be a numerical value. - Inputs to the `predict` method must be the same dimensionality as the observations used in `fit`. # Example: ```python # Define your Decision Tree Classifier here. class DecisionTreeClassifier: def __init__(self): self.tree = None def fit(self, X, y): # Method to build the decision tree using Gini index. pass def predict(self, observation): # Method to predict the class for a new observation. pass def _gini_index(self, groups, classes): # Helper method to calculate the Gini index for a split. pass def _split(self, index, value, dataset): # Helper method to split the dataset based on a feature index and value. pass def _get_best_split(self, dataset): # Helper method to find the best split point for the dataset. pass def _build_tree(self, node, max_depth, min_size, depth): # Helper method to build the tree recursively. pass # Sample usage of the Decision Tree Classifier # Initialize the Decision Tree dtc = DecisionTreeClassifier() # Fit the Decision Tree with training data observations = [ [2.771244718, 1.784783929], [1.728571309, 1.169761413], [3.678319846, 2.81281357], [3.961043357, 2.61995032], [2.999208922, 2.209014212], [7.497545867, 3.162953546], [9.00220326, 3.339047188], [7.444542326, 0.476683375], [10.12493903, 3.234550982], [6.642287351, 3.319983761] ] classes = [0, 0, 0, 0, 0, 1, 1, 1, 1, 1] dtc.fit(observations, classes) # Predict a new observation new_observation = [3.5, 2.0] print(dtc.predict(new_observation)) # Expected output: 0 (example output) ``` Ensure your code meets these requirements and passes the provided example tests.","solution":"class DecisionTreeClassifier: def __init__(self): self.tree = None def fit(self, X, y): dataset = [row + [label] for row, label in zip(X, y)] self.tree = self._build_tree(dataset) def predict(self, observation): return self._predict_one(self.tree, observation) def _predict_one(self, node, observation): if isinstance(node, dict): if observation[node[\'index\']] < node[\'value\']: return self._predict_one(node[\'left\'], observation) else: return self._predict_one(node[\'right\'], observation) else: return node def _gini_index(self, groups, classes): n_instances = float(sum([len(group) for group in groups])) gini = 0.0 for group in groups: size = float(len(group)) if size == 0: continue score = 0.0 for class_val in classes: proportion = [row[-1] for row in group].count(class_val) / size score += proportion * proportion gini += (1.0 - score) * (size / n_instances) return gini def _split(self, index, value, dataset): left, right = list(), list() for row in dataset: if row[index] < value: left.append(row) else: right.append(row) return left, right def _get_best_split(self, dataset): class_values = list(set(row[-1] for row in dataset)) best_index, best_value, best_score, best_groups = float(\'inf\'), float(\'inf\'), float(\'inf\'), None for index in range(len(dataset[0])-1): for row in dataset: groups = self._split(index, row[index], dataset) gini = self._gini_index(groups, class_values) if gini < best_score: best_index, best_value, best_score, best_groups = index, row[index], gini, groups return {\'index\': best_index, \'value\': best_value, \'groups\': best_groups} def _to_terminal(self, group): outcomes = [row[-1] for row in group] return max(set(outcomes), key=outcomes.count) def _split_and_create_node(self, node, depth, max_depth=5, min_size=1): left, right = node[\'groups\'] del(node[\'groups\']) if not left or not right: node[\'left\'] = node[\'right\'] = self._to_terminal(left + right) return if depth >= max_depth: node[\'left\'], node[\'right\'] = self._to_terminal(left), self._to_terminal(right) return if len(left) <= min_size: node[\'left\'] = self._to_terminal(left) else: node[\'left\'] = self._get_best_split(left) self._split_and_create_node(node[\'left\'], depth+1, max_depth, min_size) if len(right) <= min_size: node[\'right\'] = self._to_terminal(right) else: node[\'right\'] = self._get_best_split(right) self._split_and_create_node(node[\'right\'], depth+1, max_depth, min_size) def _build_tree(self, train, max_depth=5, min_size=1): root = self._get_best_split(train) self._split_and_create_node(root, 1, max_depth, min_size) return root"},{"question":"# Problem Statement A company uses a specific inventory numbering scheme where each item is assigned a unique code. The code is a string consisting of uppercase English letters followed by digits. The ordering of inventory is based on a custom sorting rule: 1. Strings with more letters are given higher priority. 2. If two strings have the same number of letters, they are sorted alphabetically by the letters portion. 3. If the letters portions are identical, they are sorted by the numerical portion as an integer. Your task is to implement the function `sort_inventory_codes`: ```python def sort_inventory_codes(codes: list) -> list: Sort a list of inventory codes based on the custom rule described above. Args: - codes (list): A list of strings representing the inventory codes. Returns: - list: The sorted list of codes. ``` # Example: ```python assert sort_inventory_codes([\'AB12\', \'A1\', \'B12\', \'AA2\', \'A123\']) == [\'AA2\', \'AB12\', \'A1\', \'A123\', \'B12\'] assert sort_inventory_codes([\'A1\', \'A2\', \'AA10\', \'B1\', \'AA1\']) == [\'AA1\', \'AA10\', \'A1\', \'A2\', \'B1\'] ``` # Constraints: * The length of each inventory code string does not exceed 100 characters. * The list of codes has at most 10,000 elements. * Each string contains at least one letter and one digit.","solution":"def sort_inventory_codes(codes: list) -> list: Sort a list of inventory codes based on the custom rule described above. 1. Strings with more letters are given higher priority. 2. If two strings have the same number of letters, they are sorted alphabetically by the letters portion. 3. If the letters portions are identical, they are sorted by the numerical portion as an integer. Args: - codes (list): A list of strings representing the inventory codes. Returns: - list: The sorted list of codes. # Function to extract the letter and digit parts def split_code(code): letters = \'\'.join([char for char in code if char.isalpha()]) digits = \'\'.join([char for char in code if char.isdigit()]) return (letters, int(digits)) # Sort based on the custom rules sorted_codes = sorted(codes, key=lambda x: (-len(\'\'.join(filter(str.isalpha, x))), split_code(x))) return sorted_codes"},{"question":"# Maximum Sum of Non-Adjacent Elements You are given an integer array `nums`. Your task is to write a function that returns the maximum sum of non-adjacent elements in the array. The function signature is as follows: ```python def max_sum_non_adjacent(nums: list[int]) -> int: ``` # Input * `nums` (1 ≤ len(nums) ≤ 1000): An array of integers where each integer can be negative or positive. # Output * An integer representing the maximum sum of non-adjacent elements in `nums`. # Constraints * Your solution should have a time complexity of O(n) and a space complexity of O(1). # Example Example 1: Input: nums = [3, 2, 5, 10, 7] Output: 15 Explanation: The maximum sum is obtained by selecting elements 3, 5, and 7. Example 2: Input: nums = [-1, 3, 4, -2, 5] Output: 9 Explanation: The maximum sum is obtained by selecting elements 3 and 5 (ignore -1). # Notes * Consider edge cases such as arrays of length 1, arrays with all negative numbers, and arrays where the optimal solution requires skipping several elements in a row.","solution":"def max_sum_non_adjacent(nums: list[int]) -> int: Returns the maximum sum of non-adjacent elements in the nums array. if not nums: return 0 # If there is only one element, return it. if len(nums) == 1: return nums[0] # Initialize the variables for the maximum sum including and excluding the current element incl = 0 # max sum including the previous element excl = 0 # max sum excluding the previous element for num in nums: # Current max excluding the current number new_excl = max(incl, excl) # Current max including the current number incl = excl + num excl = new_excl # Return the maximum of incl and excl return max(incl, excl)"},{"question":"# Coding Assessment Question: **Objective**: Implement a class to handle matrix calculations, including the capability to perform addition, subtraction, and matrix multiplication while ensuring the matrices adhere to the rules of matrix operations. **Instructions**: Implement a `MatrixOperations` class with the following methods: 1. `__init__(self, matrix: List[List[int]])`: Initialize the class with the given matrix. 2. `matrix_addition(self, other: \'MatrixOperations\') -> \'MatrixOperations\'`: Add the current matrix with another matrix. 3. `matrix_subtraction(self, other: \'MatrixOperations\') -> \'MatrixOperations\'`: Subtract another matrix from the current matrix. 4. `matrix_multiplication(self, other: \'MatrixOperations\') -> \'MatrixOperations\'`: Multiply the current matrix with another matrix. 5. `__str__(self) -> str`: Return a string representation of the matrix with rows converted to strings and joined by newlines. **Constraints**: * Matrices will contain integer values and should have dimensions that allow the specified operations: * For addition and subtraction: Both matrices must have the same dimensions. * For multiplication: Number of columns in the first matrix must be equal to the number of rows in the second matrix. * Matrices can have dimensions up to 100x100. **Example**: ```python matrix1 = MatrixOperations([[1, 2, 3], [4, 5, 6]]) matrix2 = MatrixOperations([[7, 8, 9], [10, 11, 12]]) added_matrix = matrix1.matrix_addition(matrix2) print(added_matrix) # Expected output: # 8 10 12 # 14 16 18 subtracted_matrix = matrix1.matrix_subtraction(matrix2) print(subtracted_matrix) # Expected output: # -6 -6 -6 # -6 -6 -6 matrix3 = MatrixOperations([[1, 2], [3, 4], [5, 6]]) multiplied_matrix = matrix1.matrix_multiplication(matrix3) print(multiplied_matrix) # Expected output: # 22 28 # 49 64 ``` **Detailed Requirements**: * Ensure compatibility in matrix dimensions before performing operations and handle any dimension mismatch with appropriate error handling. * Each method should return a new `MatrixOperations` object containing the resultant matrix. * Provide a clear string representation of the matrix where each row appears on a new line. Good luck!","solution":"from typing import List class MatrixOperations: def __init__(self, matrix: List[List[int]]): self.matrix = matrix def __validate_same_dimension(self, other: \'MatrixOperations\'): if len(self.matrix) != len(other.matrix) or len(self.matrix[0]) != len(other.matrix[0]): raise ValueError(\\"Matrices must have the same dimensions for this operation.\\") def __validate_multiplication_dimension(self, other: \'MatrixOperations\'): if len(self.matrix[0]) != len(other.matrix): raise ValueError(\\"Number of columns of the first matrix must be equal to the number of rows of the second matrix.\\") def matrix_addition(self, other: \'MatrixOperations\') -> \'MatrixOperations\': self.__validate_same_dimension(other) result = [ [self.matrix[i][j] + other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixOperations(result) def matrix_subtraction(self, other: \'MatrixOperations\') -> \'MatrixOperations\': self.__validate_same_dimension(other) result = [ [self.matrix[i][j] - other.matrix[i][j] for j in range(len(self.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixOperations(result) def matrix_multiplication(self, other: \'MatrixOperations\') -> \'MatrixOperations\': self.__validate_multiplication_dimension(other) result = [ [sum(self.matrix[i][k] * other.matrix[k][j] for k in range(len(self.matrix[0]))) for j in range(len(other.matrix[0]))] for i in range(len(self.matrix)) ] return MatrixOperations(result) def __str__(self) -> str: return \'n\'.join([\' \'.join(map(str, row)) for row in self.matrix])"},{"question":"# Given Context You are developing a Python utility to format text files based on specific styling rules. The utility will read a text file, process its content, and write the formatted output to a new file. Each line in the input file should be trimmed of leading and trailing whitespace, and empty lines should be removed. # Task 1. Implement a function `format_text_file` that reads an input text file, processes each line according to the rules, and writes the formatted content to an output file. 2. Create another function `validate_format` that checks if an output file matches the expected formatted content. # Input and Output Formats * **Functions to implement**: * `format_text_file(input_file: str, output_file: str) -> None` * `input_file` - path to the input text file. * `output_file` - path to the output text file where the formatted content will be written. * `validate_format(output_file: str, expected_output: str) -> bool` * `output_file` - path to the output text file to validate. * `expected_output` - path to a text file with the expected formatted content. * **Constraints**: * The `format_text_file` function must read the input file line by line. * Leading and trailing whitespace should be removed from each line. * Empty lines should be omitted from the output file. * The `validate_format` function should return `True` if the output file content matches the expected content, otherwise `False`. # Example Scenario 1. Given an input file `input.txt`: ``` Hello World This is a test. Another line. ``` and an expected file `expected_output.txt`: ``` Hello World This is a test. Another line. ``` 2. The `format_text_file` function should process `input.txt` and produce an output file: ``` Hello World This is a test. Another line. ``` The `validate_format` function should return `True` if the output file content matches `expected_output.txt`, `False` otherwise. # Starter Code ```python def format_text_file(input_file: str, output_file: str) -> None: with open(input_file, \'r\') as file: lines = file.readlines() with open(output_file, \'w\') as file: for line in lines: formatted_line = line.strip() if formatted_line: file.write(formatted_line + \'n\') def validate_format(output_file: str, expected_output: str) -> bool: with open(output_file, \'r\') as output: output_content = output.read() with open(expected_output, \'r\') as expected: expected_content = expected.read() return output_content == expected_content ``` # Note You should thoroughly test your utility to ensure it handles various text formatting scenarios correctly.","solution":"def format_text_file(input_file: str, output_file: str) -> None: with open(input_file, \'r\') as infile: lines = infile.readlines() with open(output_file, \'w\') as outfile: for line in lines: formatted_line = line.strip() if formatted_line: outfile.write(formatted_line + \'n\') def validate_format(output_file: str, expected_output: str) -> bool: with open(output_file, \'r\') as outfile: output_content = outfile.read() with open(expected_output, \'r\') as expectedfile: expected_content = expectedfile.read() return output_content == expected_content"},{"question":"# Problem Statement You are given a list of integers `nums` and an integer `k`. Your goal is to find the length of the shortest subarray with a sum equal to or greater than `k`. If no such subarray exists, return -1. # Function Signature ```python def shortest_subarray_with_sum(nums: List[int], k: int) -> int: pass ``` # Input * `nums`: A list of integers where `1 <= len(nums) <= 100000` and `-10^5 <= nums[i] <= 10^5`. * `k`: An integer where `1 <= k <= 10^9`. # Output * Returns an integer representing the length of the shortest subarray with a sum equal to or greater than k. If no such subarray exists, return -1. # Constraints * The function should efficiently handle lists with a length up to 100,000. * The elements of the list can be both positive and negative. # Examples The function should operate as follows: ```python assert shortest_subarray_with_sum([2, -1, 2], 3) == 3 assert shortest_subarray_with_sum([1, 2, 3, 4, 5], 11) == 3 assert shortest_subarray_with_sum([-1, -1, -1], 2) == -1 ``` # Additional Notes * Consider both positive and negative numbers within the subarrays. * Ensure to handle large lists efficiently while keeping the time complexity acceptable. # Hints 1. Think about using a sliding window approach or a deque to maintain efficient time complexity. 2. Consider how you can use prefix sums along with a monotonically increasing deque to keep track of potential subarrays.","solution":"from typing import List from collections import deque def shortest_subarray_with_sum(nums: List[int], k: int) -> int: # Initialize the prefix sum array and a deque to store indices prefix_sum = [0] for num in nums: prefix_sum.append(prefix_sum[-1] + num) # The deque will store tuples of (prefix_sum, index) deque_candidate = deque() min_length = float(\'inf\') for i in range(len(prefix_sum)): # Check and update the minimum length for the current prefix sum while deque_candidate and prefix_sum[i] - deque_candidate[0][0] >= k: min_length = min(min_length, i - deque_candidate.popleft()[1]) # Maintain a monotonic increasing deque while deque_candidate and deque_candidate[-1][0] >= prefix_sum[i]: deque_candidate.pop() deque_candidate.append((prefix_sum[i], i)) return min_length if min_length != float(\'inf\') else -1"},{"question":"# Coding Question: Matrix Exponentiation through Fast Exponentiation Background In computer science, matrix exponentiation can be a powerful technique to calculate powers of matrices efficiently. This technique uses the fast exponentiation method, similar to binary exponentiation used for scalar values, but adapted for matrices. Objective You are required to implement a function that performs matrix exponentiation using the fast exponentiation method. Given a square matrix and an integer exponent, return the resulting matrix after raising the input matrix to the specified power. Function Signature ```python def matrix_exponentiation(matrix: List[List[int]], exponent: int) -> List[List[int]]: ``` Input 1. **matrix**: A list of lists of integers representing the square matrix. * Constraints: 1 ≤ len(matrix) × len(matrix) ≤ 100, -10^4 ≤ matrix[i][j] ≤ 10^4. 2. **exponent**: An integer representing the exponent. * Constraints: 1 ≤ exponent ≤ 10^9. Output Return a list of lists of integers representing the matrix after exponentiation. Examples ```python >>> matrix_exponentiation([[1, 2], [3, 4]], 2) [[7, 10], [15, 22]] >>> matrix_exponentiation([[2, 0], [0, 2]], 3) [[8, 0], [0, 8]] >>> matrix_exponentiation([[1, 1], [1, 0]], 5) [[8, 5], [5, 3]] ``` Note * Consider implementing the helper functions to multiply two matrices and to perform matrix exponentiation using the fast exponentiation method. * Ensure to handle large exponents efficiently with time complexity in O(log(exponent) * len(matrix)^3).","solution":"from typing import List def matrix_multiply(A: List[List[int]], B: List[List[int]], size: int) -> List[List[int]]: Helper function to multiply two matrices A and B. C = [[0] * size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): C[i][j] += A[i][k] * B[k][j] return C def matrix_exponentiation(matrix: List[List[int]], exponent: int) -> List[List[int]]: Performs matrix exponentiation using fast exponentiation method. size = len(matrix) # Initialize the result as the identity matrix result = [[1 if i == j else 0 for j in range(size)] for i in range(size)] base = matrix while exponent > 0: if exponent % 2 == 1: result = matrix_multiply(result, base, size) base = matrix_multiply(base, base, size) exponent //= 2 return result"},{"question":"# Balanced Binary Search Tree Implementation You are tasked with implementing a balanced binary search tree (BST) and using it to efficiently perform range queries. A range query searches for all items within a specified range [low, high]. **Task**: 1. Implement a balanced BST class that maintains the balance using rotations. 2. Implement methods for inserting elements into the BST and performing range queries. 3. Modify the given `filter_array` function to utilize the balanced BST for efficient range queries. **Function Signatures**: 1. `class BalancedBST:` 2. `def __init__(self): -> None` 3. `def insert(self, value: int): -> None` 4. `def range_query(self, low: int, high: int): -> list[int]` 5. `def filter_array(array: list[int], low: int, high: int): -> list[int]` **Input Format**: - `array`: A 1D list of integers. - `low`: An integer representing the lower bound of the range (inclusive). - `high`: An integer representing the upper bound of the range (inclusive). **Output Format**: - A list of integers from the input array that fall within the given range [low, high]. **Constraints**: - Each integer in `array` falls within the range of `-10^4` to `10^4`. - The number of integers in `array` does not exceed `10^5`. **Performance Requirement**: - The range query should be optimized to handle large datasets efficiently, ensuring the BST operations maintain an average time complexity of O(log n). **Example**: ```python # Example Input Array array = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] # Example Range Query low = 35 high = 75 # Expected Filtered Output result = filter_array(array, low, high) # Output: [40, 50, 60, 70] ``` The new question involves implementing and utilizing a balanced binary search tree to efficiently perform range queries on an integer array. This task maintains a similar complexity and scope to the nearest neighbor search optimization using a KD-Tree. It also introduces a new data structure and algorithms while still being aligned with the programming concepts of optimization and efficient searching.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.height = 1 self.key = key class BalancedBST: def __init__(self): self.root = None def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return TreeNode(key) elif key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) balance = self.get_balance(node) if balance > 1 and key < node.left.key: return self.right_rotate(node) if balance < -1 and key > node.right.key: return self.left_rotate(node) if balance > 1 and key > node.left.key: node.left = self.left_rotate(node.left) return self.right_rotate(node) if balance < -1 and key < node.right.key: node.right = self.right_rotate(node.right) return self.left_rotate(node) return node def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def get_height(self, node): if not node: return 0 return node.height def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def range_query(self, low, high): result = [] self._range_query(self.root, low, high, result) return result def _range_query(self, node, low, high, result): if not node: return if low < node.key: self._range_query(node.left, low, high, result) if low <= node.key <= high: result.append(node.key) if high > node.key: self._range_query(node.right, low, high, result) def filter_array(array, low, high): tree = BalancedBST() for num in array: tree.insert(num) return tree.range_query(low, high)"},{"question":"# String Permutation Check You are provided with two strings, and your task is to write a function that determines whether one string is a permutation of the other. A permutation is defined as rearranging the characters of one string to form another string. # Task Write a function that checks if the given two strings are permutations of each other. The function should be case-sensitive and consider white spaces as different characters. # Input - `s1 (str)`: The first string. - `s2 (str)`: The second string. # Output - `bool`: `True` if `s1` is a permutation of `s2`, `False` otherwise. # Constraints - The input strings can contain any printable ASCII characters. - The length of each string will not exceed 10^5 characters. # Example Usage ```python print(is_permutation(\\"abc\\", \\"cab\\")) # True print(is_permutation(\\"hello\\", \\"bello\\")) # False print(is_permutation(\\"Dormitory\\", \\"dirty room\\")) # False print(is_permutation(\\"Listen\\", \\"Silent\\")) # False ``` # Note You may assume that the solution should have an efficient time complexity, preferably O(n log n) or O(n), where n is the length of the input strings. # Extension Points - Consider edge cases such as empty strings. - Ensure your function handles large inputs efficiently. - Write unit tests to verify the correctness of your function. # Implementation ```python def is_permutation(s1, s2): if len(s1) != len(s2): return False return sorted(s1) == sorted(s2) ```","solution":"def is_permutation(s1, s2): Determines whether one string is a permutation of the other. Parameters: s1 (str): The first string. s2 (str): The second string. Returns: bool: True if s1 is a permutation of s2, False otherwise. if len(s1) != len(s2): return False return sorted(s1) == sorted(s2)"},{"question":"# Problem Statement **Second Largest Element** You are tasked with writing a function that finds the second largest element in a given list of integers. Your function should handle various potential edge cases, including lists with duplicate elements and lists with fewer than two distinct elements. **Function Signature**: ```python def second_largest_element(nums: List[int]) -> int: pass ``` # Input * `nums` (List[int]): A list of integers which can be positive, negative, or zero. # Output * `int`: The second largest integer in the list. If there is no such element, raise a `ValueError` with an appropriate message. # Constraints * The function should raise a `ValueError` if input list has fewer than two distinct elements. * The list may contain both negative and positive integers, as well as zeros. * Avoid using built-in sorting functions to ensure algorithmic comprehension. # Example ```python print(second_largest_element([2, 3, 1])) # Output: 2 print(second_largest_element([-1, 0, 1, 1])) # Output: 0 print(second_largest_element([10])) # Raises ValueError: Not enough distinct elements print(second_largest_element([2, 2, 2])) # Raises ValueError: Not enough distinct elements ``` # Additional Requirements 1. Handle edge cases, such as lists with all identical elements and lists with mixed positive and negative numbers. 2. Consider both performance and readability of your code - implementation should be clear and concise. 3. Do not use Python\'s built-in `sorted()` function or other high-level sorting functions. # Hints * Iterate through the list to find the largest and then the second largest while checking for distinct values. * Consider initializing two variables to store the largest and second largest values and update them conditionally as you traverse the list.","solution":"from typing import List def second_largest_element(nums: List[int]) -> int: if len(nums) < 2: raise ValueError(\\"Not enough distinct elements\\") first = second = float(\'-inf\') for num in nums: if num > first: second = first first = num elif first > num > second: second = num if second == float(\'-inf\'): raise ValueError(\\"Not enough distinct elements\\") return second"},{"question":"# Coding Challenge: Detect Negative Weight Cycle Scenario: You are given a weighted directed graph where each edge has a weight that can be positive, negative, or zero. Your task is to determine if the graph contains a negative weight cycle. A negative weight cycle is a cycle whose edges sum up to a negative number, indicating the possibility of infinite negative weight on repeated traversal. Task: Implement a function `detect_negative_cycle` that takes the number of vertices and the weighted edges as input and returns `True` if there is a negative weight cycle in the graph, otherwise `False`. Function Signature: ```python def detect_negative_cycle(n: int, edges: list[tuple[int, int, int]]) -> bool: ``` Input: - `n` (int): The number of vertices in the graph. - `edges` (list of tuples of int): Each tuple `(u, v, w)` represents a directed edge from vertex `u` to vertex `v` with weight `w`. Output: - `bool`: `True` if there exists a negative weight cycle in the graph, `False` otherwise. Constraints: - `1 <= n <= 10^3` (number of vertices) - `0 <= len(edges) <= 5 * 10^4` (number of edges) - Weight `w` can be any integer (-1000 <= w <= 1000). - Vertex IDs are numbered from 0 to n-1. Example: ```python n = 5 edges = [(0, 1, 1), (1, 2, -1), (2, 0, -1), (3, 4, 3)] print(detect_negative_cycle(n, edges)) # Expected Output: True n = 4 edges = [(0, 1, 2), (1, 2, 3), (2, 3, 4)] print(detect_negative_cycle(n, edges)) # Expected Output: False ``` Requirements: - Use the Bellman-Ford algorithm or any other suitable algorithm to detect the presence of a negative weight cycle. - Implement the algorithm in a way that ensures efficiency within provided constraints. - Write additional helper functions if necessary. Notes: - Consider edge cases like an empty graph (n = 0, edges = []), graphs with self-loops, and graphs with multiple disjoint subgraphs. - Ensure the algorithm terminates and does not get stuck in infinite loops.","solution":"def detect_negative_cycle(n, edges): Detect if there is a negative weight cycle in the given graph using the Bellman-Ford algorithm. :param n: Number of vertices in the graph. :param edges: List of edges represented as tuples (u, v, w) where \'u\' is the start vertex, \'v\' is the end vertex, and \'w\' is the weight of the edge. :return: True if there is a negative weight cycle, False otherwise. # Initialize distances with INF except the start vertex inf = float(\'inf\') distance = [inf] * n distance[0] = 0 # Relax edges up to n-1 times for _ in range(n - 1): for u, v, w in edges: if distance[u] != inf and distance[u] + w < distance[v]: distance[v] = distance[u] + w # Check for negative weight cycles for u, v, w in edges: if distance[u] != inf and distance[u] + w < distance[v]: return True return False"},{"question":"# Context You are tasked with developing a Python function that models a basic warehouse inventory management system. The system should be able to add new items and update the quantity of existing items in the inventory. Additionally, the system should handle cases where an item is removed from the inventory if its quantity falls to zero or below. # Task Write three functions `add_item`, `update_quantity`, and `remove_item` to manage the inventory. Ensure the functions handle edge cases and maintain the integrity of the inventory. # Function Signatures ```python def add_item(inventory: dict, item: str, quantity: int) -> dict: Add a new item to the inventory or update the quantity if it already exists. Args: inventory (dict): The current state of the inventory. item (str): The item to add or update. quantity (int): The quantity of the item to add. Returns: dict: The updated inventory. pass def update_quantity(inventory: dict, item: str, quantity: int) -> dict: Update the quantity of an existing item in the inventory. Remove the item if the quantity falls to zero or below. Args: inventory (dict): The current state of the inventory. item (str): The item to update. quantity (int): The new quantity of the item. Returns: dict: The updated inventory. pass def remove_item(inventory: dict, item: str) -> dict: Remove an item from the inventory. Args: inventory (dict): The current state of the inventory. item (str): The item to remove. Returns: dict: The updated inventory. pass ``` # Constraints - The `add_item` function should increase the quantity of an existing item or add the item with the given quantity if it\'s not in the inventory. - The `update_quantity` function should update the quantity of an existing item and remove the item if the quantity is zero or negative. - The `remove_item` function should remove the item from the inventory regardless of its quantity. # Example Usage ```python inventory = { \\"apple\\": 10, \\"banana\\": 5 } # Adding a new item inventory = add_item(inventory, \\"orange\\", 7) print(inventory) # Should output: {\'apple\': 10, \'banana\': 5, \'orange\': 7} # Updating the quantity of an existing item inventory = update_quantity(inventory, \\"apple\\", -3) print(inventory) # Should output: {\'apple\': 7, \'banana\': 5, \'orange\': 7} # Removing an item that falls to zero quantity inventory = update_quantity(inventory, \\"banana\\", -5) print(inventory) # Should output: {\'apple\': 7, \'orange\': 7} # Removing an item explicitly inventory = remove_item(inventory, \\"orange\\") print(inventory) # Should output: {\'apple\': 7} ``` # Objective - Implement `add_item` to correctly increase the quantity of an existing item or add a new one. - Implement `update_quantity` to adjust item quantities and remove items if their quantity falls to zero or below. - Implement `remove_item` to delete an item from the inventory.","solution":"def add_item(inventory, item, quantity): Add a new item to the inventory or update the quantity if it already exists. Args: inventory (dict): The current state of the inventory. item (str): The item to add or update. quantity (int): The quantity of the item to add. Returns: dict: The updated inventory. if item in inventory: inventory[item] += quantity else: inventory[item] = quantity return inventory def update_quantity(inventory, item, quantity): Update the quantity of an existing item in the inventory. Remove the item if the quantity falls to zero or below. Args: inventory (dict): The current state of the inventory. item (str): The item to update. quantity (int): The new quantity of the item. Returns: dict: The updated inventory. if item in inventory: inventory[item] += quantity if inventory[item] <= 0: del inventory[item] return inventory def remove_item(inventory, item): Remove an item from the inventory. Args: inventory (dict): The current state of the inventory. item (str): The item to remove. Returns: dict: The updated inventory. if item in inventory: del inventory[item] return inventory"},{"question":"# Coding Task: Write an Optimized A* Search Algorithm A* search algorithm is widely used in pathfinding and graph traversal. It is an extension of Dijkstra\'s shortest path algorithm to find the shortest path from a start node to a goal node in a weighted graph. # Objective Implement the **A* Search Algorithm**. You will provide a function `a_star_search` that takes in a graph, a start node, a goal node, and a heuristic function to estimate the distance from a node to the goal. # Details Input * A graph represented as an adjacency list where nodes are keys and edges are tuples `(neighbor, weight)`. * A `start` node from which the search begins. * A `goal` node which the search aims to reach. * A `heuristic` function that takes a node and returns a numeric estimation. Output * A list of nodes representing the shortest path from `start` to `goal`. Example ```python graph = { \'A\': [(\'B\', 1), (\'C\', 3)], \'B\': [(\'D\', 1), (\'E\', 4)], \'C\': [(\'D\', 1)], \'D\': [(\'F\', 2)], \'E\': [(\'F\', 1)], } def heuristic(node): h_values = {\'A\': 5, \'B\': 2, \'C\': 2, \'D\': 1, \'E\': 1, \'F\': 0} return h_values[node] print(a_star_search(graph, \'A\', \'F\', heuristic)) # Expected Output: [\'A\', \'B\', \'D\', \'F\'] ``` # Constraints * All node and edge weights are positive integers. * The graph is non-empty and the start and goal nodes exist in the graph. * The heuristic function is admissible (it never overestimates the cost). # Performance Requirements * Optimal time complexity: O((V + E) * log(V)) where V is the number of nodes and E is the number of edges. * Optimal space complexity: O(V) for the data structures used in the algorithm. # Notes * Your solution should not use any graph libraries or built-in shortest-path functions. * Implement efficient handling of the priority queue. * Ensure the heuristic function guides the search efficiently toward the goal without compromising the optimality. ```python import heapq def a_star_search(graph, start, goal, heuristic): # Implement this function based on A* Search Algorithm open_list = [] heapq.heappush(open_list, (0 + heuristic(start), 0, start)) came_from = {} cost_so_far = {start: 0} while open_list: _, current_cost, current_node = heapq.heappop(open_list) if current_node == goal: path = [] while current_node: path.append(current_node) current_node = came_from.get(current_node) return path[::-1] for neighbor, weight in graph.get(current_node, []): new_cost = current_cost + weight if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]: cost_so_far[neighbor] = new_cost priority = new_cost + heuristic(neighbor) heapq.heappush(open_list, (priority, new_cost, neighbor)) came_from[neighbor] = current_node return [] # Test cases to verify correctness of the implementation def test_a_star_search(): graph = { \'A\': [(\'B\', 2), (\'C\', 4)], \'B\': [(\'C\', 1)], \'C\': [(\'D\', 2)], \'D\': [] } def heuristic(node): h_values = {\'A\': 4, \'B\': 2, \'C\': 1, \'D\': 0} return h_values[node] assert a_star_search(graph, \'A\', \'D\', heuristic) == [\'A\', \'B\', \'C\', \'D\'] test_a_star_search() ``` # Challenge * Beyond basic functionality, ensure that your implementation handles graphs with varying edge weights efficiently and finds the shortest path even in large, complex graphs. Good luck!","solution":"import heapq def a_star_search(graph, start, goal, heuristic): Implements the A* search algorithm. Returns the shortest path from start to goal in a weighted graph. open_list = [] heapq.heappush(open_list, (0 + heuristic(start), 0, start)) came_from = {} cost_so_far = {start: 0} while open_list: _, current_cost, current_node = heapq.heappop(open_list) if current_node == goal: path = [] while current_node: path.append(current_node) current_node = came_from.get(current_node) return path[::-1] for neighbor, weight in graph.get(current_node, []): new_cost = current_cost + weight if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]: cost_so_far[neighbor] = new_cost priority = new_cost + heuristic(neighbor) heapq.heappush(open_list, (priority, new_cost, neighbor)) came_from[neighbor] = current_node return []"},{"question":"# Objective Design and implement a function to generate the nth term of a custom mathematical sequence defined by a particular recurrence relation. This problem will illustrate recursive thinking and optimization techniques. # Question You need to create a function that generates the nth term of a sequence where each term is defined as follows: - `a(1) = 1` - `a(2) = 2` - `a(n) = a(n-1) * a(n-2)` for `n > 2` # Function Signature ```python def generate_sequence(n: int) -> int: Generate the nth term of the sequence defined by the given recurrence relation. Parameters: - n (int): The term of the sequence to generate, where 1 <= n <= 30. Returns: - int: The nth term of the sequence. ``` # Input/Output - **Input**: An integer n, where 1 <= n <= 30. - **Output**: An integer representing the nth term of the sequence. # Constraints - You need to efficiently handle the computation especially for larger values of n (up to 30). # Performance Requirement - Aim to implement the function with an O(n) complexity using memoization to avoid redundant computations. # Context Here\'s an example of how the first few terms of the sequence look like: - a(1) = 1 - a(2) = 2 - a(3) = 2 (1 * 2) - a(4) = 4 (2 * 2) - a(5) = 8 (2 * 4) # Example ```python def generate_sequence(n: int) -> int: memo = {1: 1, 2: 2} def helper(n): if n in memo: return memo[n] memo[n] = helper(n-1) * helper(n-2) return memo[n] return helper(n) # Example usage print(generate_sequence(4)) # Output: 4 print(generate_sequence(5)) # Output: 8 ``` # Notes: 1. Ensure your function handles different sizes of n correctly. 2. Optimize your implementation to avoid excessive recursion and redundant calculations using memoization.","solution":"def generate_sequence(n: int) -> int: Generate the nth term of the sequence defined by the given recurrence relation. Parameters: - n (int): The term of the sequence to generate, where 1 <= n <= 30. Returns: - int: The nth term of the sequence. # Base cases if n == 1: return 1 elif n == 2: return 2 # Initialize memoization dictionary with base cases memo = {1: 1, 2: 2} # Recursive helper function with memoization def helper(n): if n in memo: return memo[n] memo[n] = helper(n-1) * helper(n-2) return memo[n] return helper(n)"},{"question":"# Question: Counting Valid Sudoku Boards **Context**: A Sudoku board is a 9x9 grid where each cell can either be a number from 1 to 9 or empty (represented by 0). For a Sudoku board to be valid, each row, column, and 3x3 sub-grid must contain no duplicate numbers from 1 to 9. **Task**: Write a function `count_valid_sudoku_boards` that takes in a list of Sudoku boards and returns the number of valid Sudoku boards. **Function Signature**: ```python def count_valid_sudoku_boards(boards: List[List[List[int]]]) -> int: ``` **Input**: - `boards` (List of 9x9 grids): Each board is a list of 9 lists, where each inner list represents a row of 9 integers. Constraints: `1 <= len(boards) <= 100`. **Output**: - Returns an integer representing the count of valid Sudoku boards from the input list. **Example**: ```python sudoku_boards = [ [ [5,3,0, 0,7,0, 0,0,0], [6,0,0, 1,9,5, 0,0,0], [0,9,8, 0,0,0, 0,6,0], [8,0,0, 0,6,0, 0,0,3], [4,0,0, 8,0,3, 0,0,1], [7,0,0, 0,2,0, 0,0,6], [0,6,0, 0,0,0, 2,8,0], [0,0,0, 4,1,9, 0,0,5], [0,0,0, 0,8,0, 0,7,9] ], [ [5,3,4, 6,7,8, 9,1,2], [6,7,2, 1,9,5, 3,4,8], [1,9,8, 3,4,2, 5,6,7], [8,5,9, 7,6,1, 4,2,3], [4,2,6, 8,5,3, 7,9,1], [7,1,3, 9,2,4, 8,5,6], [9,6,1, 5,3,7, 2,8,4], [2,8,7, 4,1,9, 6,3,5], [3,4,5, 2,8,6, 1,7,9] ] ] assert count_valid_sudoku_boards(sudoku_boards) == 1 ``` **Explanation**: - In the provided example, the first board is incomplete but valid, meaning it doesn\'t violate any Sudoku rules. The second board is a completely filled valid Sudoku board. Thus, the function should return 1 as only one board is valid according to Sudoku rules.","solution":"from typing import List def is_valid_sudoku(board: List[List[int]]) -> bool: def is_valid_group(group: List[int]) -> bool: numbers = [num for num in group if num != 0] return len(numbers) == len(set(numbers)) def get_subgrid(board: List[List[int]], start_row: int, start_col: int) -> List[int]: subgrid = [] for r in range(start_row, start_row + 3): for c in range(start_col, start_col + 3): subgrid.append(board[r][c]) return subgrid for i in range(9): row = board[i] if not is_valid_group(row): return False col = [board[r][i] for r in range(9)] if not is_valid_group(col): return False for r in range(0, 9, 3): for c in range(0, 9, 3): subgrid = get_subgrid(board, r, c) if not is_valid_group(subgrid): return False return True def count_valid_sudoku_boards(boards: List[List[List[int]]]) -> int: count = 0 for board in boards: if is_valid_sudoku(board): count += 1 return count"},{"question":"# Question: Count the Number of Subarrays with Sum Equal to Target Given an array of integers `nums` and an integer `target`, write a function that returns the number of continuous subarrays whose sum equals to `target`. Your task is to implement the following function: ```python def count_subarrays(nums: List[int], target: int) -> int: pass ``` Input - `nums`: A list of integers. - `target`: An integer representing the target subarray sum. Output - The function should return an integer representing the number of continuous subarrays whose sum equals to `target`. # Constraints 1. The length of `nums` is between 1 and 10^5. 2. Each element of `nums` is an integer between -10^4 and 10^4. # Example Example 1 ```python print(count_subarrays([1, 1, 1], 2)) ``` **Expected Output**: ``` 2 ``` Example 2 ```python print(count_subarrays([1, 2, 3], 3)) ``` **Expected Output**: ``` 2 ``` # Tips - Use a cumulative sum approach to check for subarrays efficiently. - Consider using a hashmap to store the cumulative sum frequencies for quick look-ups. - Ensure to handle edge cases such as negative numbers and single-element arrays.","solution":"from typing import List def count_subarrays(nums: List[int], target: int) -> int: cumulative_sum = 0 count = 0 sum_frequency = {0: 1} # To handle subarrays starting from index 0 for num in nums: cumulative_sum += num required_sum = cumulative_sum - target if required_sum in sum_frequency: count += sum_frequency[required_sum] if cumulative_sum in sum_frequency: sum_frequency[cumulative_sum] += 1 else: sum_frequency[cumulative_sum] = 1 return count"},{"question":"# Linked List Rotation Problem Context: You are given a singly linked list and a positive integer `k`. You need to write a function that rotates the linked list to the right by `k` places. Rotating a linked list means moving the last `k` elements to the front while preserving the order of the remaining elements. Function Signature: ```python class ListNode: def __init__(self, val: int = 0, next: \'ListNode\' = None): self.val = val self.next = next def rotate_linked_list(head: ListNode, k: int) -> ListNode: ``` Input: * **head (ListNode)**: The head of a singly linked list where each node is defined as `ListNode(val, next)`. * **k (int)**: A positive integer representing the number of positions to rotate the linked list. Output: * **ListNode**: The head of the rotated linked list. Constraints: 1. The linked list contains non-negative integers. 2. The length of the linked list is between 1 and (10^4). 3. `1 <= k <= 10^4`. Example: ```python # Example 1 l = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5))))) print_linked_list(rotate_linked_list(l, 2)) # Output: 4 -> 5 -> 1 -> 2 -> 3 # Example 2 l = ListNode(0, ListNode(1, ListNode(2))) print_linked_list(rotate_linked_list(l, 4)) # Output: 2 -> 0 -> 1 ``` Errors: 1. Raise `ValueError` with an appropriate message if the linked list is empty (i.e., head is None). 2. Raise `ValueError` with an appropriate message if `k` is not a positive integer. Implementation Instructions: 1. Validate the input to check for any violations of constraints mentioned above. 2. Calculate the effective number of rotations as `k % length_of_list` to handle cases where `k` is greater than the length of the list. 3. Find the new head after the required rotations. 4. Adjust the links to make the rotated list. 5. Return the new head of the rotated linked list. Note: You may find it useful to write a helper function to traverse the linked list and calculate its length.","solution":"class ListNode: def __init__(self, val: int = 0, next: \'ListNode\' = None): self.val = val self.next = next def rotate_linked_list(head: ListNode, k: int) -> ListNode: if not head: raise ValueError(\\"The linked list is empty.\\") if k <= 0: raise ValueError(\\"k must be a positive integer.\\") # Calculate the length of the list length = 1 current = head while current.next: current = current.next length += 1 # Reduce the effective number of rotations k = k % length if k == 0: return head # Find the new end of the list current.next = head # Make it a circular linked list first steps_to_new_tail = length - k new_tail = head for _ in range(steps_to_new_tail - 1): new_tail = new_tail.next # Get the new head and break the cycle new_head = new_tail.next new_tail.next = None return new_head # Helper function to print and check the linked list (for validation) def print_linked_list(head: ListNode): vals = [] while head: vals.append(head.val) head = head.next return \\" -> \\".join(map(str, vals))"},{"question":"# Question: **String Permutations Check** Given two strings (`str1` and `str2`), write a function to determine if one string is a permutation of the other. In other words, if one string\'s characters can be rearranged to form the other string. Your function should return `True` if the strings are permutations of each other and `False` otherwise. # Constraints: - The strings are case-sensitive. - Both strings consist of only lowercase and uppercase English letters and have no spaces or other characters. - The solution should handle typical edge cases efficiently. # Example: ```python def is_permutation(str1: str, str2: str) -> bool: pass # Example 1 print(is_permutation(\\"abc\\", \\"cab\\")) # Output: True # Example 2 print(is_permutation(\\"abc\\", \\"abcd\\")) # Output: False # Example 3 print(is_permutation(\\"abc\\", \\"abC\\")) # Output: False # Example 4 print(is_permutation(\\"god\\", \\"dog\\")) # Output: True # Example 5 print(is_permutation(\\"Listen\\", \\"Silent\\")) # Output: False ``` # Notes: - You are expected to implement the `is_permutation` function. - Consider the efficiency of your solution, especially for larger inputs. - Remember to test with various edge cases to ensure correctness.","solution":"def is_permutation(str1: str, str2: str) -> bool: Checks if str1 is a permutation of str2. Args: - str1 (str): First string. - str2 (str): Second string. Returns: - bool: True if str1 is a permutation of str2, otherwise False. return sorted(str1) == sorted(str2)"},{"question":"# Problem: Meeting Rooms II Context: You\'re developing a scheduling system for a company with multiple meeting rooms. Each meeting room can host one meeting at a time, and meetings cannot overlap if they are in the same room. To improve efficiency, you need to determine the minimum number of meeting rooms required to accommodate all scheduled meetings. Objective: Implement a function `min_meeting_rooms(intervals: List[List[int]]) -> int` that takes a list of meeting time intervals and returns the minimum number of meeting rooms required. # Constraints: - The length of the intervals list is between 1 and 10^4. - Each interval is a list of two integers [start, end], where 0 <= start < end <= 10^6. # Input: - `intervals`: A list of meeting time intervals, where each interval is represented by `[start, end]`. # Output: - Return the minimum number of meeting rooms required for the given set of meetings. # Performance Requirements: - Aim for a solution with a time complexity of O(n log n), where n is the number of intervals. Example: ```python def min_meeting_rooms(intervals: List[List[int]]) -> int: pass # your implementation here # Test cases print(min_meeting_rooms([[0, 30], [5, 10], [15, 20]])) # 2 print(min_meeting_rooms([[7, 10], [2, 4]])) # 1 print(min_meeting_rooms([[1, 5], [8, 9], [8, 9]])) # 2 print(min_meeting_rooms([[2, 11], [6, 16], [11, 16]])) # 2 print(min_meeting_rooms([[4, 5], [2, 3], [2, 2], [2, 2], [2, 2]])) # 2 ``` This problem requires tracking the start and end times of meetings and efficiently determining the necessary number of rooms by managing these intervals. The goal is to achieve the task with optimal performance, ensuring it scales well even with larger inputs.","solution":"from typing import List import heapq def min_meeting_rooms(intervals: List[List[int]]) -> int: if not intervals: return 0 # Sort the intervals by the start time intervals.sort(key=lambda x: x[0]) # Initialize a min-heap to track the end times of meetings heap = [] # Add the end time of the first meeting heapq.heappush(heap, intervals[0][1]) # Iterate over the remaining intervals for i in range(1, len(intervals)): # If the room due to free up the earliest is free, remove it from the heap if intervals[i][0] >= heap[0]: heapq.heappop(heap) # Add the current meeting end time to the heap heapq.heappush(heap, intervals[i][1]) # The size of the heap is the minimum number of meeting rooms required return len(heap)"},{"question":"# Question: Evaluate Expression Tree You are given a binary tree that represents an arithmetic expression. Each leaf node represents an operand, and each internal node represents an operator. Your task is to implement a function that evaluates the expression represented by the tree. Function Signature: ```python class TreeNode: def __init__(self, value: str): self.value = value self.left = None self.right = None def evaluate_expression_tree(root: TreeNode) -> int: pass ``` Input: * `root`: The root node of the binary tree where each node is an instance of the `TreeNode` class. Output: * Return an integer which is the result of the arithmetic expression evaluation. Constraints: * Operand values are integers. * Valid operators are `+`, `-`, `*`, and `/`. * Division results in integer division (use `//` operator if necessary). Example: ```python # Constructing the expression tree for ((3 + (2 * 5)) - 9) node1 = TreeNode(\'3\') node2 = TreeNode(\'2\') node3 = TreeNode(\'5\') node4 = TreeNode(\'*\') node5 = TreeNode(\'+\') node6 = TreeNode(\'9\') node7 = TreeNode(\'-\') node4.left = node2 node4.right = node3 node5.left = node1 node5.right = node4 node7.left = node5 node7.right = node6 assert evaluate_expression_tree(node7) == 4 ``` Notes: * Carefully handle cases with different operator precedence. * Ensure division by zero is avoided and handled appropriately. * This problem assumes a correctly formed binary tree representing a valid arithmetic expression. Good luck!","solution":"class TreeNode: def __init__(self, value: str): self.value = value self.left = None self.right = None def evaluate_expression_tree(root: TreeNode) -> int: # Base case: if the tree node is a leaf, return its value as an integer if not root.left and not root.right: return int(root.value) # Evaluate the left and right subtrees left_val = evaluate_expression_tree(root.left) right_val = evaluate_expression_tree(root.right) # Apply the operator at the current root if root.value == \'+\': return left_val + right_val elif root.value == \'-\': return left_val - right_val elif root.value == \'*\': return left_val * right_val elif root.value == \'/\': return left_val // right_val else: raise ValueError(f\\"Invalid operator: {root.value}\\")"},{"question":"# Coding Assessment Question You are working on a financial application and need to implement a system to calculate the annual effective interest rate given nominal interest rates compounded at different frequencies. The annual effective interest rate is the interest rate that, if applied once per year, would give the same end-of-year investment value as the nominal rate compounded multiple times per year. The formula to convert a nominal interest rate to an annual effective interest rate is: [ AER = left(1 + frac{r}{n}right)^n - 1 ] where: - `AER` is the annual effective rate. - `r` is the nominal interest rate. - `n` is the number of compounding periods per year. Write a function that calculates the annual effective rate given the nominal interest rate and the number of compounding periods. Function Signature ```python def calculate_aer(nominal_rate: float, compounding_periods: int) -> float: ``` Input - `nominal_rate` : A float representing the nominal interest rate (as a decimal, e.g., for 5%, use 0.05). - `compounding_periods` : An integer representing the number of times interest is compounded per year. Output - A float representing the annual effective interest rate (as a decimal). Constraints - Ensure the nominal rate and compounding periods are positive values. - Handle cases where `compounding_periods` is 1 (annually compounded). Examples 1. `calculate_aer(0.05, 4)` should return approximately `0.050945336914062`. 2. `calculate_aer(0.06, 2)` should return approximately `0.0609`. 3. `calculate_aer(0.08, 12)` should return approximately `0.083`. # Code Implementation ```python def calculate_aer(nominal_rate: float, compounding_periods: int) -> float: if nominal_rate <= 0 or compounding_periods <= 0: raise ValueError(\\"The nominal rate and compounding periods must be positive values.\\") aer = (1 + nominal_rate / compounding_periods) ** compounding_periods - 1 return aer ```","solution":"def calculate_aer(nominal_rate: float, compounding_periods: int) -> float: Calculates the annual effective interest rate given the nominal interest rate and the number of compounding periods per year. Parameters: nominal_rate (float): The nominal interest rate (as a decimal, e.g., for 5%, use 0.05). compounding_periods (int): The number of times interest is compounded per year. Returns: float: The annual effective interest rate (as a decimal). if nominal_rate <= 0 or compounding_periods <= 0: raise ValueError(\\"The nominal rate and compounding periods must be positive values.\\") aer = (1 + nominal_rate / compounding_periods) ** compounding_periods - 1 return aer"},{"question":"# Leetcode-like Problem on Binary Tree Traversal **Context**: Binary trees are essential structures in computer science, used in various applications like expression parsing, search operations, and data organization. Each node may have two children, referred to as the left and right child. **Objective**: Write a function to determine if a given binary tree is symmetric. A binary tree is symmetric if the left subtree is a mirror reflection of the right subtree. **Function Signature**: ```python def is_symmetric(root: Optional[TreeNode]) -> bool: ``` **Definitions**: - `TreeNode` is defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - `root`: The root node of the binary tree. It may be `None`. **Input**: - `root` (TreeNode): The root node of the binary tree. **Output**: - Returns a boolean value `True` if the binary tree is symmetric, and `False` otherwise. **Examples**: ```python >>> root = TreeNode(1, TreeNode(2, TreeNode(3), TreeNode(4)), TreeNode(2, TreeNode(4), TreeNode(3))) >>> is_symmetric(root) True >>> root = TreeNode(1, TreeNode(2, TreeNode(3), None), TreeNode(2, TreeNode(3), None)) >>> is_symmetric(root) False >>> is_symmetric(None) True ``` **Constraints**: - The number of nodes in the tree is in the range `[0, 1000]`. - The node values are of type `int`. **Performance Requirements**: - The solution should aim for a time complexity of O(n), where n is the number of nodes in the tree. **Notes**: - Consider both iterative and recursive approaches, explaining their computational complexity. - Ensure that your implementation handles edge cases, such as an empty tree or a tree with only one node. **Task**: Implement the `is_symmetric` function to meet the above specifications.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def is_symmetric(root: Optional[TreeNode]) -> bool: def is_mirror(t1: Optional[TreeNode], t2: Optional[TreeNode]) -> bool: if t1 is None and t2 is None: return True if t1 is None or t2 is None: return False return (t1.val == t2.val) and is_mirror(t1.right, t2.left) and is_mirror(t1.left, t2.right) if root is None: return True return is_mirror(root.left, root.right)"},{"question":"# Scenario: As a software engineer, you are tasked with designing a service that processes large sets of log data to identify and report unique IP addresses that have accessed the system. The objective is to examine access patterns and detect potential security issues or unauthorized access attempts. # Task: Implement a service that reads through a log file, extracts IP addresses, and outputs a list of unique IP addresses that accessed the system. The log data will be provided as a text file where each line contains an entry that may include various information, including IP addresses. # Instructions: 1. **Log File Handling**: * Download a sample log file from [here](https://www.example.com/sample/logfile.log). * Read the contents of the log file, ensuring to handle large files efficiently. 2. **IP Address Extraction**: * Extract all IP addresses from the log file. IP addresses are of the form `xxx.xxx.xxx.xxx`, where `xxx` is between 0 and 255. 3. **Unique Address Identification**: * Identify and store all unique IP addresses found in the log file. 4. **Output the Results**: * Write the list of unique IP addresses to an output file named `unique_ips.txt`. # Constraints: * The log file may contain up to 1 million lines. * Each line in the log file may vary in format but will include at least one valid IP address. * The solution should handle edge cases such as lines with no IP address. # Expected Functions: You need to implement the function `find_unique_ips(logfile_path)` which: - Reads and processes the log file. - Extracts and stores unique IP addresses. - Writes the unique IP addresses to an output file. # Example: ```python def find_unique_ips(logfile_path): # Your code to read the log file, extract IP addresses, and identify unique ones # Write the unique IPs to an output file with open(\'unique_ips.txt\', \'w\') as f: for ip in unique_ips: f.write(ip + \'n\') ``` # Additional Requirements: * Optimize your solution for both time and space complexity. * Ensure the implementation robustly handles edge cases, such as malformed lines or those without IP addresses.","solution":"import re def find_unique_ips(logfile_path): Reads a log file, extracts unique IP addresses, and writes them to an output file. :param logfile_path: The path to the log file. ip_pattern = re.compile(r\'b(?:d{1,3}.){3}d{1,3}b\') unique_ips = set() # Reading the log file efficiently with open(logfile_path, \'r\') as file: for line in file: ips = ip_pattern.findall(line) for ip in ips: if is_valid_ip(ip): unique_ips.add(ip) # Writing the unique IP addresses to the output file with open(\'unique_ips.txt\', \'w\') as output_file: for ip in sorted(unique_ips): output_file.write(ip + \'n\') def is_valid_ip(ip): Validate the extracted IP address to ensure each segment is between 0 and 255 :param ip: The IP address string. :return: True if the IP address is valid, False otherwise. segments = ip.split(\'.\') return all(0 <= int(segment) < 256 for segment in segments)"},{"question":"# Rectangle Diagonal Calculation Scenario In computer graphics programming, you often need to compute the diagonal length of rectangles for various purposes like fitting meshes, bounding boxes, or determining screen space. Given the width (w) and height (h) of a rectangle, the diagonal length (d) can be calculated using the Pythagorean theorem: ( d = sqrt{w^2 + h^2} ). Your task is to implement a function that computes the diagonal length of a rectangle when its width and height are provided. Task Implement a function `calculate_diagonal` that determines the diagonal length of a rectangle given its width and height. Function Signature ```python def calculate_diagonal(width: float, height: float) -> float: pass ``` Parameters - `width (float)`: The width of the rectangle. - `height (float)`: The height of the rectangle. Returns - A float representing the diagonal length of the rectangle, rounded to 2 decimal places. Constraints - The width and height should be positive numbers greater than zero. - If either the width or height is non-positive, raise a `ValueError` with the appropriate message. Examples - `calculate_diagonal(width=3, height=4)` should return `5.0` - `calculate_diagonal(width=5, height=12)` should return `13.0` - `calculate_diagonal(width=8, height=15)` should return `17.0` - `calculate_diagonal(width=10, height=-2)` should raise `ValueError(\\"Width and height must be positive numbers\\")`. - `calculate_diagonal(width=0, height=5)` should raise `ValueError(\\"Width and height must be positive numbers\\")`.","solution":"import math def calculate_diagonal(width: float, height: float) -> float: Calculate the diagonal length of a rectangle using the Pythagorean theorem. Parameters: width (float): The width of the rectangle. height (float): The height of the rectangle. Returns: float: The diagonal length of the rectangle, rounded to 2 decimal places. Raises: ValueError: If the width or height is non-positive. if width <= 0 or height <= 0: raise ValueError(\\"Width and height must be positive numbers\\") diagonal = math.sqrt(width**2 + height**2) return round(diagonal, 2)"},{"question":"**Scenario**: You are developing a feature for a file management system that maintains a log of file operations. The goal is to implement a mechanism to detect duplicate file names and automatically resolve conflicts by appending a number to the duplicate file name. When a new file is added, if the file name already exists, the system should rename the new file by appending a number starting from 1 and increasing with each additional duplicate. **Objective**: Create the `rename_on_conflict` function, which will handle the renaming logic to resolve file name conflicts. # Function Signature ```python def rename_on_conflict(existing_files: List[str], new_file: str) -> str: pass ``` # Input - `existing_files`: A list of strings representing the names of existing files. - `new_file`: A string representing the name of the new file to be added. # Output - A string representing the resolved unique file name. # Constraints - The `existing_files` list may contain any number of elements, including zero. - The `new_file` string and elements in `existing_files` will not be empty and may contain alphanumeric characters and underscores. - The function must return a unique file name by appending the minimum necessary number to make the name unique. # Example Usage ```python >>> existing_files = [\\"file\\", \\"file1\\", \\"file2\\", \\"file3\\", \\"file4\\"] >>> rename_on_conflict(existing_files, \\"file\\") \\"file5\\" >>> existing_files = [\\"report\\", \\"report1\\", \\"report2\\"] >>> rename_on_conflict(existing_files, \\"report\\") \\"report3\\" >>> existing_files = [\\"document\\"] >>> rename_on_conflict(existing_files, \\"document\\") \\"document1\\" >>> existing_files = [] >>> rename_on_conflict(existing_files, \\"newfile\\") \\"newfile\\" ``` # Additional Notes - Implement edge case handling when there are no conflicts (return the `new_file` as-is). - Optimize the function to handle large lists efficiently. - Ensure the function works correctly even if the filenames have gaps in their numbering (e.g., \\"file\\" and \\"file2\\" without \\"file1\\").","solution":"from typing import List def rename_on_conflict(existing_files: List[str], new_file: str) -> str: if new_file not in existing_files: return new_file counter = 1 while f\\"{new_file}{counter}\\" in existing_files: counter += 1 return f\\"{new_file}{counter}\\""},{"question":"# Reverse Words in a Sentence Background: Reversing words in a sentence is a common problem that helps solidify one\'s understanding of string manipulation and data structures. This type of problem is particularly useful in interviews to evaluate a candidate\'s ability to decompose and solve a problem, handle edge cases, and work with basic string operations. Task: You need to implement a function `reverse_words` that takes a sentence (a string) as input and returns the sentence with the words in the reverse order. The words must be separated by a single space, and there should be no extra spaces at the beginning or end of the returned string. Function Definition and Requirements: 1. `reverse_words(sentence: str) -> str`: * **Input**: A string representing a sentence. * **Output**: A string with the words in reverse order. * **Constraints**: * The input string may contain multiple spaces between words. * The input string may have leading or trailing spaces. * The function should handle an empty string gracefully. Example Usage: ```python >>> reverse_words(\\"Hello World!\\") \\"World! Hello\\" >>> reverse_words(\\" This is a test \\") \\"test a is This\\" >>> reverse_words(\\"single\\") \\"single\\" >>> reverse_words(\\" \\") \\"\\" ``` # Guidelines: * Focus on string manipulation and handling edge cases related to spaces. * Ensure your solution efficiently splits and reverses the words without introducing extra spaces. * Use standard libraries and functions where appropriate to simplify your implementation. The solution should maintain the clarity and integrity of the task, ensuring it aligns well with the given constraints and example usages.","solution":"def reverse_words(sentence: str) -> str: Reverses the order of words in a given sentence. Parameters: sentence (str): A string representing the sentence to be reversed. Returns: str: A string with the words in reverse order. # Split the sentence into words by spaces, omitting any empty words words = sentence.split() # Reverse the list of words and join them back into a string with single spaces reversed_sentence = \' \'.join(reversed(words)) return reversed_sentence"},{"question":"Sure, here’s an additional question that aligns with the provided example in terms of style, complexity, and topic alignment: # Question You are given three lists representing the edges of a graph: - `edges_a` (list of tuples representing edges of the first subgraph), - `edges_b` (list of tuples representing edges of the second subgraph), - `edges_c` (list of tuples representing edges connecting vertices across the subgraphs). Your task is to implement the function `weakly_connected_components` that computes the number of weakly connected components in an undirected graph formed by combining the subgraphs represented by `edges_a`, `edges_b`, and the connecting edges `edges_c`. # Constraints 1. All edges are tuples (u, v) where u and v are integers representing vertices. 2. The graph can have multiple disjoint subgraphs. # Function Signature ```python def weakly_connected_components( edges_a: list[tuple[int, int]], edges_b: list[tuple[int, int]], edges_c: list[tuple[int, int]], ) -> int: ... ``` # Input Format - `edges_a`: A list of tuples representing edges of the first subgraph. - `edges_b`: A list of tuples representing edges of the second subgraph. - `edges_c`: A list of tuples representing edges connecting vertices across the subgraphs. # Output Format - An integer representing the number of weakly connected components. # Example ```python edges_a = [(1, 2), (2, 3)] edges_b = [(4, 5), (5, 6)] edges_c = [(3, 4)] output = weakly_connected_components(edges_a, edges_b, edges_c) print(output) # Expected: 1 edges_a = [(1, 2), (2, 3)] edges_b = [(4, 5), (5, 6)] edges_c = [] output = weakly_connected_components(edges_a, edges_b, edges_c) print(output) # Expected: 2 ``` # Additional Requirements: 1. Raise a `ValueError` if any edge tuple contains invalid data (e.g., non-integer elements). 2. Raise a `ValueError` if edges_a, edges_b, or edges_c are not lists of tuples.","solution":"def weakly_connected_components( edges_a: list[tuple[int, int]], edges_b: list[tuple[int, int]], edges_c: list[tuple[int, int]], ) -> int: from collections import defaultdict, deque def validate_edges(edges): if not isinstance(edges, list): raise ValueError(\\"Edges should be a list.\\") for edge in edges: if not isinstance(edge, tuple) or len(edge) != 2: raise ValueError(\\"Each edge should be a tuple of two integers.\\") u, v = edge if not (isinstance(u, int) and isinstance(v, int)): raise ValueError(\\"Each edge should contain two integer vertex identifiers.\\") def bfs(start, visited, graph): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) validate_edges(edges_a) validate_edges(edges_b) validate_edges(edges_c) graph = defaultdict(list) for edge in edges_a + edges_b + edges_c: u, v = edge graph[u].append(v) graph[v].append(u) visited = set() components = 0 for node in graph: if node not in visited: components += 1 visited.add(node) bfs(node, visited, graph) return components"},{"question":"# Coding Assessment Question You have been appointed as a software developer to enhance a service that monitors and processes cryptocurrency prices in real-time. Your task is to refactor and expand the current solution to support better error handling, data processing, and feature extension. **Your tasks are:** 1. **Implement a function to fetch cryptocurrency prices from an alternative API.** - The new API should conform to the same structure as the current CoinGecko API data, including timestamp-based price history. - Fetch data from an alternative endpoint such as \\"https://alternative-api.com/cryptocurrencies\\". 2. **Enhance error handling:** - Implement comprehensive error handling to manage scenarios such as network failures, API response errors, and unexpected data formats. - Ensure appropriate error messages are logged, and implement a retry mechanism for failed requests, adhering to a specified retry limit. 3. **Extend the features:** - Modify the `display_prices` function to include additional data - historical prices over the past month (if available from the new API). - Ensure the application gracefully handles cases where data might not be available, displaying `N/A` or similar indicators where appropriate. 4. **Optimize data processing:** - Improve the `calculate_average_price` function to compute the average price over the past month more efficiently. - Optimize the algorithm for better time complexity and ensure it accurately deals with edge cases such as missing or duplicated timestamps. **Input:** - An integer representing the retry limit for failed network requests. **Output:** - A formatted table displaying the current price of the top 10 cryptocurrencies and their historical average prices over the past month. **Constraints:** - The alternative API endpoint must return data in a JSON format containing the cryptocurrency details. - Timestamps will be provided in standard ISO 8601 format. - Ensure you handle up to 3 retries for network failures. **Scenario Context:** Assume you are part of a fintech startup tasked with replacing the current cryptocurrency pricing service provider with a new one while maintaining uninterrupted service delivery. The platform must continue to display accurate and real-time prices and average historical prices of the top 10 cryptocurrencies. --- By following these guidelines, your implementation should seamlessly integrate with the overall application, providing robust error handling, efficient data processing, and enhanced features.","solution":"import requests from datetime import datetime, timedelta def fetch_crypto_prices(api_url, retries=3): Fetches cryptocurrency prices from an alternative API with retry mechanism. Args: - api_url (str): The URL of the API to fetch data from. - retries (int): The number of retries for failed requests. Returns: - dict: A dictionary containing the cryptocurrency prices and historical data. attempt = 0 while attempt < retries: try: response = requests.get(api_url) response.raise_for_status() return response.json() except requests.RequestException as e: print(f\\"Request failed: {e}, attempt {attempt + 1} of {retries}\\") attempt += 1 raise Exception(\\"Failed to fetch data after multiple attempts\\") def calculate_average_price(prices): Calculates the average price given a list of price data with timestamps. Args: - prices (list): A list of dictionaries with \'timestamp\' and \'price\' keys. Returns: - float: The average price. if not prices: return 0.0 total_price = 0 count = 0 for data in prices: total_price += data.get(\'price\', 0) count += 1 return total_price / count if count else 0 def display_prices(api_url): Displays the current and historical average prices of cryptocurrencies. Args: - api_url (str): The URL of the API to fetch data from. try: data = fetch_crypto_prices(api_url) if \'cryptocurrencies\' not in data: raise ValueError(\\"Invalid data format received from API\\") for crypto in data[\'cryptocurrencies\']: name = crypto.get(\'name\', \'N/A\') current_price = crypto.get(\'current_price\', \'N/A\') historical_prices = crypto.get(\'historical_prices\', []) avg_price = calculate_average_price(historical_prices) print(f\\"Name: {name}\\") print(f\\"Current Price: {current_price}\\") print(f\\"Average Historical Price: {avg_price}\\") print(\\"-\\" * 30) except Exception as e: print(f\\"Error displaying prices: {e}\\") # Example usage # The actual URL and structure of the response should conform to the chosen alternative API api_url = \\"https://alternative-api.com/cryptocurrencies\\" display_prices(api_url)"},{"question":"# Quick Sort Implementation Scenario: You are given an array of integers that you need to sort using the Quick Sort algorithm. Quick Sort is a divide-and-conquer algorithm that selects a \'pivot\' element from the array and partitions the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. This process continues until the base case of empty or single-element sub-array is reached. Task: Write a function `quick_sort` that takes a list of integers and sorts it in ascending order using the Quick Sort algorithm. Function Signature: ```python def quick_sort(arr: list) -> list: pass ``` Input: - `arr` (list): A list of integers that needs to be sorted. Output: - Returns a list of integers sorted in ascending order. Constraints: - The input list can have 0 or more integers. - The integers can be both positive and negative. Performance Requirements: - The function should efficiently handle up to 10,000 integers in the list with an average time complexity of O(n log n). Examples: ```python >>> quick_sort([3, 6, 8, 10, 1, 2, 1]) [1, 1, 2, 3, 6, 8, 10] >>> quick_sort([]) [] >>> quick_sort([3]) [3] >>> quick_sort([10, 7, 8, 9, 1, 5]) [1, 5, 7, 8, 9, 10] >>> quick_sort([-3, 0, -1, 5, 2, -2]) [-3, -2, -1, 0, 2, 5] ``` Ensure to implement the Quick Sort algorithm correctly, keeping in mind the edge cases and performance constraints. Efficiently choose and handle pivot elements to maximize sorting speed and stability.","solution":"def quick_sort(arr: list) -> list: Sorts a list of integers in ascending order using the Quick Sort algorithm. :param arr: List of integers to sort. :return: Sorted list of integers. if len(arr) <= 1: return arr else: pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return quick_sort(left) + middle + quick_sort(right)"},{"question":"**Problem Statement:** You are tasked with developing a feature to find the longest contiguous subarray where the difference between the maximum and minimum elements is less than or equal to a given threshold. Write a function `longest_subarray_within_limit(array: list[int], limit: int) -> int` that: - Receives an array of integers `array` and an integer `limit`. - Returns the length of the longest contiguous subarray where the difference between the maximum and minimum elements within this subarray is less than or equal to `limit`. # Constraints: - All elements in `array` are integers. - 1 ≤ length of `array` ≤ 100000. - -10^9 ≤ `array[i]` ≤ 10^9 for each integer in the array. - 0 ≤ `limit` ≤ 10^9. # Input: - `array`: List of integers. - `limit`: An integer representing the maximum allowed difference between the maximum and minimum elements in a subarray. # Output: - An integer denoting the length of the longest contiguous subarray satisfying the condition. # Example: Example 1: ``` Input: array = [8, 2, 4, 7] limit = 4 Output: 2 Explanation: The longest contiguous subarray with a difference of 4 or less between the maximum and minimum elements is [2, 4], or any other subarray of length 2 with a <= limit. ``` Example 2: ``` Input: array = [10, 1, 2, 4, 7, 2] limit = 5 Output: 4 Explanation: The longest subarray that fulfills the requirement is [2, 4, 7, 2]. ``` Example 3: ``` Input: array = [4, 2, 2, 2, 4, 4, 2, 2] limit = 0 Output: 3 Explanation: The longest subarray that fulfills the requirement is [2, 2, 2] or any other subarray of length 3 with all equal elements. ``` Implement an efficient solution with a time complexity of O(n) using data structures such as sliding window technique and deques to track the minimum and maximum elements within the current window.","solution":"from collections import deque def longest_subarray_within_limit(array, limit): if not array: return 0 max_deque = deque() # Store indices of array elements in a decreasing order min_deque = deque() # Store indices of array elements in an increasing order left = 0 max_length = 0 for right in range(len(array)): while max_deque and array[max_deque[-1]] < array[right]: max_deque.pop() while min_deque and array[min_deque[-1]] > array[right]: min_deque.pop() max_deque.append(right) min_deque.append(right) while array[max_deque[0]] - array[min_deque[0]] > limit: left += 1 if max_deque[0] < left: max_deque.popleft() if min_deque[0] < left: min_deque.popleft() max_length = max(max_length, right - left + 1) return max_length"},{"question":"# Question: Implement a Function to Calculate Eigenvalues using the Power Iteration Method Given a square matrix, your task is to write a function that approximates the dominant eigenvalue and corresponding eigenvector using the power iteration method. This method is a simple iterative algorithm to find the largest eigenvalue and its associated eigenvector. # Function Signature ```python def power_iteration(matrix: np.ndarray, num_iterations: int = 1000, tolerance: float = 1e-6) -> Any: pass ``` # Input - `matrix` (numpy.ndarray): A square matrix (can be real or complex-valued). - `num_iterations` (int): The maximum number of iterations to perform. Defaults to 1000. - `tolerance` (float): The tolerance for convergence. Defaults to 1e-6. # Output - Returns a tuple containing: - The approximated dominant eigenvalue. - The corresponding eigenvector as a numpy array. # Constraints - Matrix dimensions: `matrix` is of size `n x n` where `1 ≤ n ≤ 1000`. # Requirements - Initialize the eigenvector with a random vector of appropriate dimension. - Implement the power iteration method. - The iteration should stop if the difference between consecutive eigenvalues is below the given tolerance. - No external libraries other than numpy are allowed. # Performance - Aim for an efficient implementation considering both time and space complexity under the given constraints. # Example ```python import numpy as np matrix = np.array([ [6, 5], [1, 2] ]) eig_value, eig_vector = power_iteration(matrix) print(\'Dominant eigenvalue:\', eig_value) print(\'Corresponding eigenvector:\', eig_vector) # Output: # Dominant eigenvalue: 7.0 # Corresponding eigenvector: array([0.98058068, 0.19611614]) ``` # Note - Ensure you thoroughly test your function with various edge cases and input sizes. - The initial eigenvector should be normalized to prevent overflow issues during iterations.","solution":"import numpy as np def power_iteration(matrix: np.ndarray, num_iterations: int = 1000, tolerance: float = 1e-6): n, m = matrix.shape assert n == m, \\"Matrix must be square\\" # Initialize the eigenvector with a random vector b_k = np.random.rand(n) for _ in range(num_iterations): # Calculate the matrix-by-vector product Ab b_k1 = np.dot(matrix, b_k) # Calculate the norm of the resultant vector b_k1_norm = np.linalg.norm(b_k1) # Re normalize the vector b_k = b_k1 / b_k1_norm # Compute the Rayleigh quotient as an estimate of the eigenvalue eigenvalue = np.dot(b_k.T, np.dot(matrix, b_k)) # Check for convergence if np.linalg.norm(np.dot(matrix, b_k) - eigenvalue * b_k) < tolerance: break return eigenvalue, b_k"},{"question":"# Problem Statement You are given a matrix of integers where each row in the matrix is sorted in ascending order from left to right, and each column is sorted in ascending order from top to bottom. Write a function `search_value_in_matrix` that takes in a matrix and a target value, and returns a tuple indicating the position of the target value within the matrix. If the target value is not found, return `(-1, -1)`. # Input * A 2D list of integers, `matrix`, where (0 leq text{len(matrix)}, text{len(matrix[0])} leq 10^3 ). * An integer, `target`. # Output * A tuple (row, col) representing the position of the target value within the matrix, or (-1, -1) if the target value is not found. # Function Signature ```python def search_value_in_matrix(matrix: list[list[int]], target: int) -> tuple: pass ``` # Constraints * Each row of the matrix is sorted in ascending order. * Each column of the matrix is sorted in ascending order. * Ensure that the solution is optimized with regard to time complexity. # Example ```python >>> matrix = [ ... [1, 4, 7, 11], ... [2, 5, 8, 12], ... [3, 6, 9, 16], ... [10, 13, 14, 17] ... ] >>> target = 5 >>> search_value_in_matrix(matrix, target) (1, 1) >>> target = 15 >>> search_value_in_matrix(matrix, target) (-1, -1) >>> target = 13 >>> search_value_in_matrix(matrix, target) (3, 1) ``` # Detailed Explanation * Start searching from the top-right corner of the matrix. This position allows us to determine whether to move left or down based on comparisons with the target value. * If the current number is equal to the target, return its position. * If the current number is greater than the target, move left to a smaller number. * If the current number is less than the target, move down to a larger number. * Continue this process until you find the target value or move out of the bounds of the matrix. * The function should handle edge cases effectively, including empty matrices and matrix bounds.","solution":"def search_value_in_matrix(matrix, target): if not matrix or not matrix[0]: return (-1, -1) rows, cols = len(matrix), len(matrix[0]) row, col = 0, cols - 1 # start from the top-right corner while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 # move left else: row += 1 # move down return (-1, -1)"},{"question":"# Context Sorting algorithms are a crucial part of computer science and programming. They are used in various applications for organizing data, optimizing search algorithms, and in solving larger complex problems. Different sorting algorithms have different time complexities and efficiency. # Problem Statement You need to implement the following sorting algorithms in the given `Sorting` class: 1. **QuickSort**: Implement a method `quick_sort` to sort an array of integers using the QuickSort algorithm. 2. **MergeSort**: Implement a method `merge_sort` to sort an array of integers using the MergeSort algorithm. # Function Specifications: QuickSort: **Input**: - `arr` (List[int]): The list of integers to be sorted. **Output**: - Returns a new list of integers sorted in ascending order. MergeSort: **Input**: - `arr` (List[int]): The list of integers to be sorted. **Output**: - Returns a new list of integers sorted in ascending order. # Example: ```python sorting = Sorting() arr = [3, 1, 4, 1, 5, 9, 2, 6] # QuickSort example: sorted_arr_quick = sorting.quick_sort(arr) print(sorted_arr_quick) # Output: [1, 1, 2, 3, 4, 5, 6, 9] # MergeSort example: sorted_arr_merge = sorting.merge_sort(arr) print(sorted_arr_merge) # Output: [1, 1, 2, 3, 4, 5, 6, 9] ``` # Constraints: - You may assume the input list will always contain integers only, and the length of the list can be between 0 and 10^4. - You must not use any built-in sorting functions such as Python’s `sorted()`, `sort()`, etc. - Consider the edge cases such as an empty list or a list with a single element. # Additional Notes: - You can use any standard approach to implement QuickSort and MergeSort, but ensure that the methods follow the specified input-output format. - Pay attention to optimizing the runtime and space complexity of the algorithms.","solution":"class Sorting: def quick_sort(self, arr): if len(arr) <= 1: return arr pivot = arr[len(arr) // 2] left = [x for x in arr if x < pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x > pivot] return self.quick_sort(left) + middle + self.quick_sort(right) def merge_sort(self, arr): if len(arr) <= 1: return arr def merge(left, right): result = [] i = j = 0 while i < len(left) and j < len(right): if left[i] < right[j]: result.append(left[i]) i += 1 else: result.append(right[j]) j += 1 result.extend(left[i:]) result.extend(right[j:]) return result middle = len(arr) // 2 left = self.merge_sort(arr[:middle]) right = self.merge_sort(arr[middle:]) return merge(left, right)"},{"question":"# Unique Characters Count - Programming Question You are required to implement a function that calculates the number of unique characters in a string. The function should be case-insensitive and ignore all non-alphabetic characters. **Function Signature**: ```python def unique_char_count(input_str: str) -> int: :param input_str: A string potentially containing various characters. :return: An integer representing the count of unique alphabetic characters (case-insensitive). >>> unique_char_count(\\"Hello, World!\\") 7 >>> unique_char_count(\\"Python123\\") 6 >>> unique_char_count(\\"aAaAaA\\") 1 >>> unique_char_count(\\"\\") 0 >>> unique_char_count(\\"123456!\\") 0 pass ``` # Constraints: 1. The input must be a string. 2. The function should ignore case, treating \'A\' and \'a\' as the same character. 3. The function should only consider alphabetic characters. # Edge Cases to Consider: - Empty input string. - Strings containing no alphabetic characters. - Strings with mixed case and special characters. - Handling non-ASCII alphabetic characters should not be considered. # Inputs: - `input_str`: A string containing any characters. # Outputs: - An integer representing the number of unique alphabetic characters in the input string. Implement the function `unique_char_count` to compute the result based on the provided template and constraints.","solution":"def unique_char_count(input_str: str) -> int: Returns the count of unique alphabetic characters in the input string, case-insensitive. Non-alphabetic characters are ignored. :param input_str: A string potentially containing various characters. :return: An integer representing the count of unique alphabetic characters (case-insensitive). >>> unique_char_count(\\"Hello, World!\\") 7 >>> unique_char_count(\\"Python123\\") 6 >>> unique_char_count(\\"aAaAaA\\") 1 >>> unique_char_count(\\"\\") 0 >>> unique_char_count(\\"123456!\\") 0 # Convert the input string to lower case input_str = input_str.lower() # Create a set to hold unique alphabetic characters unique_chars = set() # Iterate through the string and add alphabetic characters to the set for char in input_str: if char.isalpha(): unique_chars.add(char) # The size of the set is the count of unique alphabetic characters return len(unique_chars)"},{"question":"# Problem Description You have been tasked with implementing a basic in-memory database using Python where you can perform a set of operations. The database should support inserting key-value pairs, deleting keys, updating values, and retrieving values. Additionally, you need to ensure the database maintains consistent performance. # Task Implement a class `InMemoryDatabase` that allows for adding, deleting, updating, and retrieving key-value pairs. Your solution should utilize appropriate data structures to ensure that all operations execute in constant time, on average. # Class Methods ```python class InMemoryDatabase: def __init__(self): pass def insert(self, key: str, value: int) -> None: pass def delete(self, key: str) -> bool: pass def update(self, key: str, value: int) -> bool: pass def get(self, key: str) -> int: pass ``` # Input - `key` (str): A string that represents the identifier for the value. - `value` (int): An integer value associated with the key. # Output - `insert` method: No return value. - `delete` method: Returns `True` if the key existed and was deleted, otherwise returns `False`. - `update` method: Returns `True` if the key existed and was updated, otherwise returns `False`. - `get` method: Returns the value associated with the key if it exists, otherwise returns -1. # Constraints - Keys are unique within the database. - The usual CRUD operations must perform efficiently. - Should handle edge cases gracefully, such as retrieving or deleting non-existent keys. # Examples ```python # Creating InMemoryDatabase object db = InMemoryDatabase() # Example Operations db.insert(\'key1\', 10) assert db.get(\'key1\') == 10 # returns the value of \'key1\' assert db.update(\'key1\', 20) == True assert db.get(\'key1\') == 20 assert db.delete(\'key1\') == True assert db.get(\'key1\') == -1 # since \'key1\' is deleted, it should return -1 assert db.update(\'key2\', 30) == False # \'key2\' does not exist assert db.delete(\'key2\') == False # \'key2\' does not exist assert db.get(\'key2\') == -1 # \'key2\' does not exist ``` # Hints - Consider using a dictionary to store the key-value pairs, as it allows for average O(1) time complexity for insert, delete, update, and get operations. - Ensure that the methods handle situations where the key may not exist in the database.","solution":"class InMemoryDatabase: def __init__(self): self.store = {} def insert(self, key: str, value: int) -> None: self.store[key] = value def delete(self, key: str) -> bool: if key in self.store: del self.store[key] return True return False def update(self, key: str, value: int) -> bool: if key in self.store: self.store[key] = value return True return False def get(self, key: str) -> int: return self.store.get(key, -1)"},{"question":"# Longest Increasing Subsequence Challenge You are tasked to design an efficient algorithm to find the length of the longest increasing subsequence in a given sequence of integers. A subsequence is a sequence that can be derived from another sequence by deleting some or either none of the elements without changing the order of the remaining elements. # Task Implement a function to compute the length of the longest increasing subsequence in the given array of integers. # Input - An integer `n` representing the number of integers in the sequence. - An array of `n` integers. # Output - Print the length of the longest increasing subsequence. # Constraints - `1 <= n <= 10^5` - `-10^9 <= array[i] <= 10^9` for all `0 <= i < n` # Example Input ``` 8 10 9 2 5 3 7 101 18 ``` Output ``` 4 ``` Explanation The longest increasing subsequence is `[2, 3, 7, 101]`, thus the length is 4. # Notes Your implementation should be optimized to run efficiently within the given constraints. Use dynamic programming with binary search for optimal performance.","solution":"import bisect def length_of_LIS(nums): Returns the length of the longest increasing subsequence. if not nums: return 0 lis = [] for num in nums: pos = bisect.bisect_left(lis, num) if pos == len(lis): lis.append(num) else: lis[pos] = num return len(lis)"},{"question":"# String Compression Objective Implement a function to compress a string such that \'aaabbbccc\' becomes \'a3b3c3\'. This tests your understanding of string manipulation and efficient use of loops and conditionals. Function Signature ```python def compress_string(s: str) -> str: pass ``` Inputs - `s` (str): The input string consisting of only lowercase English letters. Outputs - A string where consecutive characters in the input string are replaced by the character followed by the count of consecutive repeats. Constraints - The length of the input string `s` will be between 1 and 10^5. Example ```python print(compress_string(\\"aaabbbccc\\")) # \\"a3b3c3\\" print(compress_string(\\"aabccc\\")) # \\"a2b1c3\\" print(compress_string(\\"abcd\\")) # \\"a1b1c1d1\\" print(compress_string(\\"aaaabbbcccddddd\\")) # \\"a4b3c3d5\\" ``` Scenario You are developing a feature for a text editor that allows users to compress long repetitive sections of a document for easier readability and storage efficiency. Implement the `compress_string` function to perform this compression.","solution":"def compress_string(s: str) -> str: Compresses a string by replacing sequences of the same character with the character followed by the number of its repetitions. if not s: return \\"\\" compressed = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed.append(f\\"{current_char}{count}\\") current_char = char count = 1 compressed.append(f\\"{current_char}{count}\\") return \\"\\".join(compressed)"},{"question":"# Problem Statement You\'re tasked with developing a library for a calendar application. One of the critical features users need is the ability to find the nth day of a specific weekday in a given month and year. For example, users may want to know the date of the 3rd Tuesday of March 2022 or the 1st Friday of October 2023. # Implementation Details Your implementation should include the following functionality: 1. **Function Signature**: ```python def get_nth_weekday(year: int, month: int, weekday: str, n: int) -> str: ``` 2. **Inputs**: * **year** (`int`): The year as a four-digit number, e.g., 2022. * **month** (`int`): The month as an integer (1 for January, 2 for February, etc.). * **weekday** (`str`): The day of the week as a three-letter abbreviation (\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\'). * **n** (`int`): The nth occurrence of the weekday in the month (1 for first, 2 for second, etc.). 3. **Outputs**: * Returns a string representing the date in \\"YYYY-MM-DD\\" format. 4. **Constraints**: * If the nth weekday does not exist in the given month, return an empty string. * The function should handle cases such as leap years and the varying lengths of months. * Inputs can assume valid year, month, and weekday values. # Example Usage ```python # Example 1: get_nth_weekday(2022, 3, \\"Tue\\", 3) # Output: \'2022-03-15\' # Example 2: get_nth_weekday(2023, 10, \\"Fri\\", 1) # Output: \'2023-10-06\' # Example 3: get_nth_weekday(2021, 2, \\"Mon\\", 5) # Output: \'\' ``` # Testing * Write tests to validate months with varying lengths, including leap years. * Test both common and edge cases, including the maximum and minimum bounds of inputs. * Ensure correct handling of non-existent nth weekdays and proper error messages. Implement this functionality using Python\'s `datetime` module and related functions to calculate the nth occurrence of a weekday accurately.","solution":"import calendar from datetime import datetime def get_nth_weekday(year: int, month: int, weekday: str, n: int) -> str: Returns the date of the nth occurrence of the specified weekday in the given month and year. Parameters: year (int): The year as a four-digit number (e.g., 2022). month (int): The month as an integer (1 for January, 2 for February, etc.). weekday (str): The day of the week as a three-letter abbreviation (\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\'). n (int): The nth occurrence of the weekday in the month (1 for first, 2 for second, etc.). Returns: str: The date in \\"YYYY-MM-DD\\" format, or an empty string if the nth weekday does not exist. weekdays = [\'Mon\', \'Tue\', \'Wed\', \'Thu\', \'Fri\', \'Sat\', \'Sun\'] weekday_index = weekdays.index(weekday) first_day_of_month = datetime(year, month, 1).weekday() day_offset = (weekday_index - first_day_of_month + 7) % 7 first_occurrence = 1 + day_offset nth_occurrence = first_occurrence + (n - 1) * 7 if nth_occurrence > calendar.monthrange(year, month)[1]: return \\"\\" return f\\"{year:04d}-{month:02d}-{nth_occurrence:02d}\\""},{"question":"# Problem Statement Scenario: You are developing a scheduling system for a conference where multiple sessions are held throughout multiple days. Each session has specific start and end times, and your task is to ensure that sessions do not overlap within the same day to avoid conflicts. You need to determine if all the scheduled sessions can fit seamlessly into the provided time slots without any overlap. Task: Write a function that checks whether the given list of sessions for each day can be scheduled without any overlaps. # Function Signature: ```python def can_schedule_sessions(sessions: List[List[Tuple[int, int]]]) -> bool: ``` Input: - `sessions`: A list of lists, where each inner list contains tuples representing the sessions for a particular day. Each tuple contains two integers `(start_time, end_time)` indicating the start and end times of a session in 24-hour format (0 ≤ start_time < end_time ≤ 23). Output: - Returns `True` if all sessions can be scheduled without any overlaps within each day, `False` otherwise. Constraints: - You may assume the input list contains at least one day and each day contains at least one session. - There will be no more than 10^5 sessions in total across all days. - Optimize for both time and space complexity. # Example: ```python can_schedule_sessions([ [(9, 11), (13, 15), (16, 18)], [(10, 12), (14, 16), (12, 14)], [(8, 12), (11, 13)] ]) # Expected Output: True can_schedule_sessions([ [(9, 11), (10, 12)], [(10, 12), (12, 14)] ]) # Expected Output: False can_schedule_sessions([ [(0, 23)], [(6, 18), (18, 23)] ]) # Expected Output: True ``` # Note: 1. Ensure the function handles edge cases, such as sessions that start at the same time the previous one ends. 2. Optimize the solution to handle a large number of sessions across multiple days efficiently.","solution":"from typing import List, Tuple def can_schedule_sessions(sessions: List[List[Tuple[int, int]]]) -> bool: for day_sessions in sessions: # Sort the sessions of the day by start time day_sessions.sort() for i in range(1, len(day_sessions)): prev_end_time = day_sessions[i-1][1] current_start_time = day_sessions[i][0] # If a session starts before the previous one ends, return False if current_start_time < prev_end_time: return False return True"},{"question":"# LRU Cache Implementation **Context**: In many real-world applications, efficient data retrieval is critical for performance. One common approach to speed up data access is using a cache. A popular type of cache is the Least Recently Used (LRU) cache, which discards the least recently used items first when the cache reaches its capacity. Task Implement the class `LRUCache` that simulates a Least Recently Used (LRU) Cache. Your cache should support two operations: `get` and `put`. 1. `get(key)`: Return the value (will always be positive) of the key if it exists in the cache, otherwise return -1. 2. `put(key, value)`: Insert or update the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item. Input Format * `n` operations, where each operation is either: - `(\\"get\\", key)` where `key` is an integer. - `(\\"put\\", key, value)` where `key` is an integer and `value` is a positive integer. Output Format * For each `get` operation, return the value associated with the key or -1 if the key is not present. * The operations will be given in a list of tuples. Constraints * 1 <= n <= 10^5 * 0 < capacity <= 10^3 * Time Complexity: O(1) for both `get` and `put` operations. * Space Complexity: O(capacity). Class Signature ```python class LRUCache: def __init__(self, capacity: int): pass def get(self, key: int) -> int: pass def put(self, key: int, value: int) -> None: pass ``` Example ```python # Example 1 actions = [(\\"put\\", 1, 1), (\\"put\\", 2, 2), (\\"get\\", 1), (\\"put\\", 3, 3), (\\"get\\", 2), (\\"put\\", 4, 4), (\\"get\\", 1), (\\"get\\", 3), (\\"get\\", 4)] cache = LRUCache(2) result = [] for action in actions: if action[0] == \\"get\\": result.append(cache.get(action[1])) elif action[0] == \\"put\\": cache.put(action[1], action[2]) print(result) # Output: [1, -1, -1, 3, 4] # Example 2 actions = [(\\"put\\", 2, 1), (\\"put\\", 2, 2), (\\"get\\", 2), (\\"put\\", 1, 1), (\\"put\\", 4, 1), (\\"get\\", 2)] cache = LRUCache(2) result = [] for action in actions: if action[0] == \\"get\\": result.append(cache.get(action[1])) elif action[0] == \\"put\\": cache.put(action[1], action[2]) print(result) # Output: [2, -1] ``` Notes * Implement your solution using a combination of a doubly-linked list and a hash map to achieve O(1) time complexity for both `get` and `put` operations. * Handle edge cases such as inserting into an empty cache or updating existing keys.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node) -> None: prev, nxt = node.prev, node.next prev.next = nxt nxt.prev = prev def _add(self, node: Node) -> None: prev, nxt = self.tail.prev, self.tail prev.next = node node.prev = prev node.next = nxt nxt.prev = node def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Question: Implement Efficient Primes Checker with Sieve Approach Context You are developing a backend for an application that frequently needs to check if numbers are prime. While individual checks can be performed using simple algorithms, a more efficient approach is required when dealing with multiple checks in a large range. Task Implement a **Primes Checker** function that utilizes the **Sieve of Eratosthenes** algorithm to precompute a list of prime numbers up to a given limit. Then use this precomputed data to efficiently respond to individual prime-check queries. # Requirements 1. **Function Signature**: `def primes_checker(limit: int) -> callable:` 2. **Input**: - A single integer, `limit`, which defines the upper range for precomputation of prime numbers. - Example: `20`, `100`, `1000` 3. **Output**: - A function that takes an integer as input and returns a boolean indicating if the number is prime. 4. **Constraints**: - The precomputation should use the Sieve of Eratosthenes algorithm. - The inner function should handle numbers up to the given `limit` efficiently. - Assume that follow-up queries will always be in the range [2, limit]. # Performance Expectations - The precomputation using the Sieve of Eratosthenes should run in **O(n log(log(n)))** time complexity where `n` is the given `limit` and **O(n)** space complexity. - The prime check function should have **O(1)** time complexity per query after precomputation. Example ```python >>> prime_check = primes_checker(20) >>> prime_check(17) True >>> prime_check(18) False >>> prime_check(19) True >>> prime_check(1) False >>> prime_check(15) False ``` # Code Template ```python def primes_checker(limit: int) -> callable: # Step 1: Precompute prime numbers up to \'limit\' is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(limit ** 0.5) + 1): if is_prime[start]: for multiple in range(start * start, limit + 1, start): is_prime[multiple] = False # Step 2: Return a function that checks primality using the precomputed list def is_prime_number(n: int) -> bool: if 2 <= n <= limit: return is_prime[n] return False # Anything outside the computed range is not handled return is_prime_number ``` In the provided example, the `prime_check` function is generated by `primes_checker` with a `limit` of 20. This function can then be used to efficiently determine the primality of various numbers up to the given limit.","solution":"def primes_checker(limit: int) -> callable: # Step 1: Precompute prime numbers up to \'limit\' using Sieve of Eratosthenes is_prime = [True] * (limit + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(limit ** 0.5) + 1): if is_prime[start]: for multiple in range(start * start, limit + 1, start): is_prime[multiple] = False # Step 2: Return a function that checks primality using the precomputed list def is_prime_number(n: int) -> bool: if 2 <= n <= limit: return is_prime[n] return False # Anything outside the computed range is not handled return is_prime_number"},{"question":"# Problem: Find the Shortest Path in a Weighted Graph You are provided with an implementation of Dijkstra\'s algorithm to find the shortest path in a weighted graph. Your task is to validate this implementation and fix any bugs or inefficiencies. Instructions: 1. **Fix the Dijkstra Implementation**: The provided `shortest_path` function has flaws that lead to incorrect shortest path calculations for some test cases. Pinpoint and correct these issues. 2. Ensure that the fixed solution handles all edge cases correctly and performs efficiently. Input: - A graph represented as an adjacency list using a dictionary. Each vertex points to a list of tuples `(neighbor, weight)`. Output: - A list of distances from the source vertex to every other vertex. Constraints: - Graph nodes are represented as integers. - Weights are non-negative integers. - The graph might be disconnected. Example Usage: ```python graph1 = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } graph2 = { 0: [(1, 2)], 1: [(2, 4)], 2: [], } print(shortest_path(graph1, 0)) # [0, 3, 1, 4] print(shortest_path(graph2, 0)) # [0, 2, 6] ``` Constraints: - The input graph consists of (1 le V le 10^5) vertices and (0 le E le 5 times 10^5) edges. You will be graded on: - Correctness: The fixed implementation should compute the shortest paths accurately for all input cases. - Efficiency: Ensure that the solution is optimized for large inputs. - Clarity: Maintain readability and proper documentation of the code. Ensure to test your implementation thoroughly against the provided examples and additional edge cases.","solution":"import heapq def shortest_path(graph, start_vertex): Finds the shortest path in a weighted graph from the start_vertex to all other vertices. :param graph: A dictionary where each key is a vertex, and the value is a list of tuples (neighbor, weight). :param start_vertex: The starting vertex for Dijkstra\'s algorithm. :return: A list of distances from the start_vertex to every other vertex. V = len(graph) distances = [float(\'inf\')] * V distances[start_vertex] = 0 min_heap = [(0, start_vertex)] while min_heap: current_distance, current_vertex = heapq.heappop(min_heap) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"# Number of Unique Words in Text You are required to implement functions for counting the number of unique words in a given text file. The task is to read the content of the file, clean and tokenize the text, and then count each unique word. # Problem 1. **Read Text File**: - Write a function `read_file(file_path)` that reads the contents of a text file given its path. - The function should return the content as a single string. 2. **Tokenize and Count Unique Words**: - Write a function `count_unique_words(text)` that takes a string of text and returns the number of unique words. - You should consider words to be case-insensitive (e.g., \\"Word\\" and \\"word\\" should be counted as the same word). - Punctuation should be removed, and words should only contain alphabetic characters. # Function Signatures ```python def read_file(file_path: str) -> str: # Implement this function def count_unique_words(text: str) -> int: # Implement this function ``` # Requirements 1. **Input**: - `read_file(file_path)`: a string representing the path to a text file. - `count_unique_words(text)`: a single string of text. 2. **Output**: - `read_file(file_path)`: returns the contents of the file as a string. - `count_unique_words(text)`: returns an integer representing the number of unique words in the text. 3. **Constraints**: - The text file contains valid English text. - The length of the text in the file is arbitrary but should fit into main memory. - Handle edge cases such as empty files and files with only punctuation. # Example Reading a file and counting unique words: ```python # Assume \'sample.txt\' contains the following text: # \\"Hello world! Hello everyone. This is an example text file. World of coding.\\" file_content = read_file(\'sample.txt\') unique_word_count = count_unique_words(file_content) print(unique_word_count) # Output: 8 ``` # Additional Notes - Ensure your functions handle large text files efficiently. - Utilize appropriate data structures for storing and counting words. - Consider using regular expressions for cleaning and tokenizing the text.","solution":"import re def read_file(file_path): Reads the contents of a text file and returns it as a string. :param file_path: str, path to the text file :return: str, content of the file with open(file_path, \'r\', encoding=\'utf-8\') as file: content = file.read() return content def count_unique_words(text): Counts the number of unique words in the given text. A word is defined as a sequence of alphabetic characters. Words are case-insensitive, meaning \\"Word\\" and \\"word\\" are considered the same. Punctuation is removed. :param text: str, input text :return: int, number of unique words # Convert text to lower case text = text.lower() # Remove punctuation and tokenize the text into words words = re.findall(r\'b[a-z]+b\', text) # Use a set to count unique words unique_words = set(words) return len(unique_words)"},{"question":"# Context In a social media platform, users can follow other users and have followers of their own. Sometimes, users want to find out the shortest path to reach another user through a series of connections. This can be represented as a graph where users are nodes and connections are directed edges. Your task is to determine the shortest path between two users. # Task You are to implement the function `shortest_path_to_user(connections, start, end)` that takes: 1. `connections`: A list of tuples where each tuple represents a directed connection (i.e., a user follows another user). 2. `start`: An integer representing the starting user. 3. `end`: An integer representing the target user. The function should return the shortest path as a list of integers starting from `start` and ending at `end`. If there is no path, return an empty list. # Input Format - `connections` is a list of tuples `(u, v)` where ( 0 leq u, v < n ) - `start` and `end` are integers such that (0 leq start, end < n) - It is guaranteed that the graph has at least one user. # Output Format - A list of integers representing the shortest path from `start` to `end`. # Constraints - ( 1 leq n leq 1000 ) - Each user can have multiple followers and can follow multiple users. # Example Input: ```python connections = [(0, 1), (1, 2), (2, 3), (4, 2), (4, 5), (5, 6)] start = 0 end = 3 ``` Output: ```python [0, 1, 2, 3] ``` # Function Signature ```python def shortest_path_to_user(connections: list[tuple[int, int]], start: int, end: int) -> list[int]: pass ```","solution":"from collections import deque, defaultdict def shortest_path_to_user(connections, start, end): def bfs(): queue = deque([(start, [start])]) visited = set() while queue: current, path = queue.popleft() if current == end: return path if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) return [] # Build the adjacency list for the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) # Perform BFS to find the shortest path return bfs()"},{"question":"# Problem Statement You are working on a feature for a word processing software that highlights sentences containing specific keywords. Your task is to develop a function that identifies which sentences contain any of the given keywords. # Requirements Write a function `highlight_sentences(paragraph: str, keywords: List[str]) -> List[str]` that takes a paragraph and a list of keywords, and returns a list of sentences from the paragraph that contain any of the keywords. # Input Format - `paragraph`: A single string composed of multiple sentences, where each sentence ends with a period, exclamation mark, or question mark. The paragraph has a length ( n ) (1 ≤ ( n ) ≤ 10,000). - `keywords`: A list of strings, where each string ( k_i ) (1 ≤ ( k_i ) ≤ 20) represents a keyword to search for. # Output Format - A list of strings, each representing a sentence from the input `paragraph` that contains at least one of the keywords from `keywords`. # Constraints - Sentences are delimited by one of the characters: \'.\', \'!\', \'?\'. - Keywords are case-insensitive (e.g., \\"Python\\" matches \\"python\\"). # Example ```python assert highlight_sentences(\\"This is a test. Does it work? Yes, indeed it works!\\", [\\"test\\", \\"indeed\\"]) == [\\"This is a test.\\", \\"Yes, indeed it works!\\"] assert highlight_sentences(\\"The quick brown fox jumps over the lazy dog. What a sight! Amazing, isn\'t it?\\", [\\"quick\\", \\"amazing\\"]) == [\\"The quick brown fox jumps over the lazy dog.\\", \\"Amazing, isn\'t it?\\"] ``` # Notes - Ensure your function handles punctuation correctly. - Optimize the function to work efficiently within the given input size constraints.","solution":"import re from typing import List def highlight_sentences(paragraph: str, keywords: List[str]) -> List[str]: Identifies sentences in a paragraph that contain any of the given keywords. Args: - paragraph: A string containing multiple sentences. - keywords: A list of keywords to search for. Returns: - A list of sentences from the paragraph containing any of the keywords. # Split the paragraph into sentences using regex to capture the sentence-ending punctuation sentences = re.split(r\'(?<=[.!?]) +\', paragraph) # Convert all keywords to lowercase for case-insensitive comparison keywords_lower = {kw.lower() for kw in keywords} # Filter sentences containing any of the keywords result = [ sentence for sentence in sentences if any(kw in sentence.lower() for kw in keywords_lower) ] return result"},{"question":"# Word Counter in a Paragraph Background: Understanding text analysis is a crucial aspect of programming that can be applied to various real-world tasks, such as analyzing word frequency, identifying key phrases, or summarizing text content. In this task, you will implement a function to count the occurrences of each word in a given paragraph. Task: You are required to implement the function `word_count` as described in the code snippet provided to compute the frequency of each word in a given paragraph of text. Your function should correctly handle edge cases such as punctuation and different cases of words (e.g., \'Word\' and \'word\' are considered the same). Function Signature: ```python def word_count(paragraph: str) -> dict: Calculate the frequency of each word in a given paragraph. Input Parameters: paragraph (str): A string representing the paragraph of text. Returns: dict: A dictionary where keys are the unique words (in lowercase) and values are their respective frequencies. ``` Example Tests: ```python >>> word_count(\\"Hello world! Welcome to the world of Python. Hello again.\\") { \'hello\': 2, \'world\': 2, \'welcome\': 1, \'to\': 1, \'the\': 1, \'of\': 1, \'python\': 1, \'again\': 1 } >>> word_count(\\"This is a test. This test is simple.\\") { \'this\': 2, \'is\': 2, \'a\': 1, \'test\': 2, \'simple\': 1 } >>> word_count(\\"\\") {} >>> word_count(\\"A single word.\\") { \'a\': 1, \'single\': 1, \'word\': 1 } ``` Constraints: * The function should handle strings of length up to 10^4 characters. * The function should correctly normalize words by converting them to lowercase. * Punctuation marks should be ignored in counting words. * Ensure efficient handling of text to perform the word count with a time complexity as close as possible to O(n), where n is the length of the paragraph. Utilize Python\'s built-in string handling capabilities, such as `str.split`, `str.lower`, and `re` module for regular expressions, to ensure the functionality is comprehensive and efficient.","solution":"import re from collections import defaultdict def word_count(paragraph: str) -> dict: Calculate the frequency of each word in a given paragraph. Input Parameters: paragraph (str): A string representing the paragraph of text. Returns: dict: A dictionary where keys are the unique words (in lowercase) and values are their respective frequencies. # Using regular expression to remove punctuation and split by whitespace words = re.findall(r\'bw+b\', paragraph.lower()) word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"# Problem Statement A \\"Deficient Number\\" is a number for which the sum of its proper divisors is less than the number itself. Given a list of numbers, implement a function to identify and return all deficient numbers from the list. Write a function `find_deficient_numbers(numbers: List[int]) -> List[int]` that takes as input a list of positive integers and returns a list of deficient numbers from the input list. # Input: - A list of positive integers where ( 1 leq text{number} leq 10^4 ) # Output: - A list of integers, each representing a deficient number from the input list. # Constraints: - Ensure the implementation handles errors accordingly for non-integer inputs. - Optimize the solution to handle the maximum constraint efficiently. # Example: ```python >>> find_deficient_numbers([6, 8, 10, 12, 15]) [8, 10, 15] ``` # Performance Requirements - The algorithm should process in ( O(n sqrt{m}) ) time complexity, where ( n ) is the number of input elements and ( m ) is the maximum integer in the input list.","solution":"from typing import List def find_deficient_numbers(numbers: List[int]) -> List[int]: def sum_of_proper_divisors(num: int) -> int: if num <= 1: return 0 total = 1 limit = int(num**0.5) for i in range(2, limit + 1): if num % i == 0: total += i if i != num // i: total += num // i return total deficient_numbers = [] for number in numbers: if sum_of_proper_divisors(number) < number: deficient_numbers.append(number) return deficient_numbers"},{"question":"# Context Binary Trees are a fundamental structure in many computer science problems. A `Complete Binary Tree` is a type of binary tree where all levels, except possibly the last, are completely filled, and all nodes are as far left as possible. # Task Implement a class `CompleteBinaryTree` to manage the list of nodes in level order and efficiently perform insertion while maintaining the complete binary tree property. # Your Task Function Implementations **Class**: `CompleteBinaryTree` 1. **__init__(self)** - **Functionality**: Initializes an empty tree. 2. **insert(self, value: int) -> None** - **Input**: A value `value` to be inserted into the tree. - **Functionality**: Inserts a new node with the given value into the tree while maintaining its completeness. - **Time Complexity**: O(log n), where `n` is the number of nodes in the tree. 3. **level_order_traversal(self) -> list[int]** - **Output**: Returns a list of elements in level order traversal. - **Time Complexity**: O(n), where `n` is the number of nodes in the tree. Constraints - The number of nodes in the tree will not exceed `10^5`. - Node values are integers in the range `-10^6` to `10^6`. # Example ```python # Assuming the implementation is already done. cbt = CompleteBinaryTree() # Insert values cbt.insert(10) cbt.insert(6) cbt.insert(8) cbt.insert(3) cbt.insert(7) cbt.insert(5) # Level-order traversal print(cbt.level_order_traversal()) # Output: [10, 6, 8, 3, 7, 5] ```","solution":"class CompleteBinaryTree: def __init__(self): self.nodes = [] def insert(self, value: int) -> None: self.nodes.append(value) index = len(self.nodes) - 1 while index > 0: parent_index = (index - 1) // 2 if self.nodes[parent_index] > self.nodes[index]: self.nodes[parent_index], self.nodes[index] = self.nodes[index], self.nodes[parent_index] index = parent_index else: break def level_order_traversal(self) -> list[int]: return self.nodes"},{"question":"# Movie Showtimes Organizer Context You manage a movie theater that needs to organize and display showtimes for a list of movies. Each movie can have multiple showtimes, and customer preferences require the showtimes to be clearly ordered. As a programmer, your task is to automate this organization. Objective * Create a function `organize_showtimes` that takes a dictionary of movies with tuple lists for showtimes and sorts the showtimes for each movie. * Include error handling for invalid time formats. Function Signature ```python def organize_showtimes(movies: Dict[str, List[str]]) -> Dict[str, List[str]]: Organize and sort the showtimes for each movie. Parameters: movies (Dict[str, List[str]]): A dictionary with movie titles as keys and lists of time strings in \\"HH:MM\\" 24-hour format as values. Returns: Dict[str, List[str]]: A dictionary with sorted showtimes for each movie. Example: >>> organize_showtimes({\'Avengers\': [\'18:00\', \'20:00\', \'17:00\'], \'Frozen\': [\'14:30\', \'16:30\', \'15:00\']}) {\'Avengers\': [\'17:00\', \'18:00\', \'20:00\'], \'Frozen\': [\'14:30\', \'15:00\', \'16:30\']} Raises: ValueError: For any invalid time format not following \\"HH:MM\\" 24-hour convention. ``` Constraints and Requirements * **Input Constraints**: - Movie titles are non-empty strings. - Showtimes for each movie are strings in the \\"HH:MM\\" format using the 24-hour convention. * **Output**: - The function returns a dictionary where each movie has sorted showtimes in ascending order. * **Error Handling**: - If any showtime string is incorrectly formatted, raise a ValueError indicating the specific issue. * **Performance**: - Aim for a sorting algorithm with a time complexity of O(n log n) for n time strings per movie. Implementation Details 1. Verify the format of each showtime string using regular expressions. 2. Parse the valid showtimes into a comparable format. 3. Sort the showtimes for each movie. 4. Return the sorted dictionary. ```python import re from typing import Dict, List def organize_showtimes(movies: Dict[str, List[str]]) -> Dict[str, List[str]]: Organize and sort the showtimes for each movie. Parameters: movies (Dict[str, List[str]]): A dictionary with movie titles as keys and lists of time strings in \\"HH:MM\\" 24-hour format as values. Returns: Dict[str, List[str]]: A dictionary with sorted showtimes for each movie. Raises: ValueError: For any invalid time format not following \\"HH:MM\\" 24-hour convention. time_pattern = re.compile(r\'^d{2}:d{2}\') def parse_time(t: str) -> int: if not time_pattern.match(t): raise ValueError(f\\"Invalid time format: {t}\\") hours, minutes = map(int, t.split(\':\')) if not (0 <= hours < 24 and 0 <= minutes < 60): raise ValueError(f\\"Invalid time value: {t}\\") return hours * 60 + minutes sorted_movies = {} for movie, showtimes in movies.items(): sorted_showtimes = sorted(showtimes, key=parse_time) sorted_movies[movie] = sorted_showtimes return sorted_movies ``` Ensure your implementation is robust to handle typical and edge cases, such as: - Valid and invalid showtimes. - Movies with multiple showtimes, single showtime, or no showtimes.","solution":"import re from typing import Dict, List def organize_showtimes(movies: Dict[str, List[str]]) -> Dict[str, List[str]]: Organize and sort the showtimes for each movie. Parameters: movies (Dict[str, List[str]]): A dictionary with movie titles as keys and lists of time strings in \\"HH:MM\\" 24-hour format as values. Returns: Dict[str, List[str]]: A dictionary with sorted showtimes for each movie. Raises: ValueError: For any invalid time format not following \\"HH:MM\\" 24-hour convention. time_pattern = re.compile(r\'^d{2}:d{2}\') def parse_time(t: str) -> int: if not time_pattern.match(t): raise ValueError(f\\"Invalid time format: {t}\\") hours, minutes = map(int, t.split(\':\')) if not (0 <= hours < 24 and 0 <= minutes < 60): raise ValueError(f\\"Invalid time value: {t}\\") return hours * 60 + minutes sorted_movies = {} for movie, showtimes in movies.items(): sorted_showtimes = sorted(showtimes, key=parse_time) sorted_movies[movie] = sorted_showtimes return sorted_movies"},{"question":"# Question: Create a Thread-Safe Singleton Logger Class Implement a thread-safe singleton class `Logger` that ensures only one instance of the class is created and used across multiple threads. The class should have methods to log messages, retrieve the log history, and clear the log. Specifically: 1. **Implement a `Logger` class** that uses the singleton pattern to ensure only one instance exists. - Ensure thread safety in the implementation. 2. **Provide methods** to: - Log a message with a timestamp. - Retrieve the entire log history. - Clear the log history. **Class Signature**: ```python class Logger: _instance = None _lock = threading.Lock() def __new__(cls, *args, **kwargs): pass def __init__(self): pass def log_message(self, message: str) -> None: pass def get_log_history(self) -> list[str]: pass def clear_log(self) -> None: pass ``` **Input/Output**: - `log_message(message: str)`: Logs the provided message with a timestamp. - *Example*: `logger.log_message(\\"Test log\\")` - *Output*: None - `get_log_history()`: Returns the list of all logged messages. - *Example*: `history = logger.get_log_history()` - *Output*: `[\'[2023-09-18 12:00:00] Test log\', ...]` - `clear_log()`: Clears all logged messages. - *Example*: `logger.clear_log()` - *Output*: None **Constraints**: - Ensure that the class remains a singleton and is thread-safe. - Use the `threading` module in Python. - Handle edge cases like logging from multiple threads and retrieving logs concurrently. Example Usage: ```python import threading import time def worker_thread(index: int): logger = Logger() logger.log_message(f\\"Log message from thread {index}\\") # Create Logger instance and log a message main_logger = Logger() main_logger.log_message(\\"Main thread log\\") # Create multiple threads threads = [] for i in range(5): thread = threading.Thread(target=worker_thread, args=(i,)) threads.append(thread) thread.start() # Wait for all threads to finish for thread in threads: thread.join() # Retrieve log history print(main_logger.get_log_history()) # Clear log history main_logger.clear_log() print(main_logger.get_log_history()) ``` Ensure you test your implementation under various threading scenarios to validate its correctness and thread safety.","solution":"import threading import time class Logger: _instance = None _lock = threading.Lock() def __new__(cls, *args, **kwargs): with cls._lock: if cls._instance is None: cls._instance = super().__new__(cls) cls._instance._log = [] cls._instance._log_lock = threading.Lock() return cls._instance def __init__(self): pass def log_message(self, message: str) -> None: timestamp = time.strftime(\'%Y-%m-%d %H:%M:%S\') log_entry = f\'[{timestamp}] {message}\' with self._log_lock: self._log.append(log_entry) def get_log_history(self) -> list: with self._log_lock: return self._log[:] def clear_log(self) -> None: with self._log_lock: self._log.clear()"},{"question":"# Problem Statement You are tasked with enhancing the functionality of a simple game leaderboard. The current leaderboard supports adding new scores and retrieving the highest score. Your objective is to extend this leaderboard with the following new methods: 1. **Top N Scores**: Write a method `top_n_scores` within the `Leaderboard` class that retrieves the top `N` highest scores from the leaderboard. 2. **Average Score**: Write a method `average_score` within the `Leaderboard` class that calculates and returns the average score of all entries in the leaderboard. # Expected Input and Output 1. **Top N Scores**: - **Input**: An integer `n` (invoked on a leaderboard instance) - **Output**: A list of top `N` scores in descending order - **Example**: ```python leaderboard = Leaderboard() leaderboard.add_score(50) leaderboard.add_score(70) leaderboard.add_score(30) leaderboard.add_score(90) print(leaderboard.top_n_scores(3)) # Output: [90, 70, 50] ``` 2. **Average Score**: - **Input**: None (invoked on a leaderboard instance) - **Output**: A float value representing the average score - **Example**: ```python leaderboard = Leaderboard() leaderboard.add_score(50) leaderboard.add_score(70) leaderboard.add_score(90) print(leaderboard.average_score()) # Output: 70.0 ``` # Constraints * The leaderboard can have any number of scores, including zero. * Scores are non-negative integers. * For the `top_n_scores` method, if `n` is greater than the number of available scores, return all scores. * Implement the `top_n_scores` and `average_score` methods in `Leaderboard` class based on the already provided leaderboard code.","solution":"class Leaderboard: def __init__(self): self.scores = [] def add_score(self, score): self.scores.append(score) def highest_score(self): return max(self.scores) if self.scores else None def top_n_scores(self, n): return sorted(self.scores, reverse=True)[:n] def average_score(self): if not self.scores: return 0.0 return sum(self.scores) / len(self.scores)"},{"question":"# Localizing Bug in Recursive Function In this task, you are required to identify and localize a bug in a provided recursive function. The goal is to understand the function\'s logic and correct the erroneous part of the code such that it performs as expected based on the given specifications. Task Description: The provided function `find_factorial` is intended to recursively calculate the factorial of a given non-negative integer. Your task is to debug and fix the function to ensure it works correctly for all valid inputs. Function Signature: ```python def find_factorial(n: int) -> int: ``` Input: * `n` (int): A non-negative integer for which the factorial is to be calculated. Output: * Returns the factorial of the given integer `n`. Constraints: * 0 ≤ n ≤ 15 Example: ```python n = 5 print(find_factorial(n)) # Output: 120 n = 0 print(find_factorial(n)) # Output: 1 ``` Provided Code Snippet: ```python def find_factorial(n: int) -> int: if n == 1: return 1 else: return n * find_factorial(n - 1) ``` Key Directions: 1. Test the provided function `find_factorial` with various inputs to identify where it fails. 2. Carefully analyze the recursive logic to understand why the function does not produce correct results. 3. Make appropriate corrections to the function, ensuring it adheres to the specification and handles all edge cases. 4. Ensure the function returns the correct factorial values for all inputs within the specified range. Hints: 1. Consider the base case of the recursion carefully, especially for the smallest possible input. 2. Verify how the function handles edge cases like when `n = 0`. 3. Understand the mathematical definition of factorials to identify logical errors. Explanation: The provided function does not handle the case of `n = 0`, which should return `1` since the factorial of `0` is `1` by definition. Adjust the base condition to ensure correctness for all inputs. ```python def find_factorial(n: int) -> int: if n == 0: return 1 else: return n * find_factorial(n - 1) ``` This adjustment ensures the function correctly calculates the factorial for `n = 0` and fits seamlessly with the overall recursive structure.","solution":"def find_factorial(n: int) -> int: Calculate the factorial of a non-negative integer n. Parameters: n (int): A non-negative integer whose factorial is to be computed. Returns: int: The factorial of the input number n. if n == 0: return 1 else: return n * find_factorial(n - 1)"},{"question":"# Scenario You are required to implement a function that simulates a basic ATM machine. The ATM should be able to perform deposits, withdrawals, and balance inquiries. Users interact with the ATM through a series of commands. # Task Write a Python function `atm_machine` that accepts a list of commands and processes them accordingly. Each command is a string where the first word specifies the action (either \\"DEPOSIT\\", \\"WITHDRAW\\", or \\"BALANCE\\"), followed by an integer for \\"DEPOSIT\\" and \\"WITHDRAW\\" commands indicating the amount. The function should return a list of integers representing the results of \\"BALANCE\\" commands. # Input * A list of `commands`, where each element is a string representing a command. # Output * A list of integers representing the balance after each \\"BALANCE\\" command. # Constraints * The ATM starts with a balance of 0. * A \\"WITHDRAW\\" command should only succeed if there are sufficient funds available; otherwise, ignore the command. * All amounts involved (deposits and withdrawals) are positive integers. * The list of commands will contain at least one command and no more than 10,000 commands. # Example ```python def atm_machine(commands): pass # Example usage commands = [\\"DEPOSIT 100\\", \\"BALANCE\\", \\"WITHDRAW 50\\", \\"BALANCE\\", \\"WITHDRAW 100\\", \\"BALANCE\\"] print(atm_machine(commands)) # Output: [100, 50, 50] ```","solution":"def atm_machine(commands): Simulates an ATM machine with deposit, withdrawal, and balance inquiry functionalities. Args: commands (list of str): List of commands to be processed. Returns: list of int: List of balances after each \\"BALANCE\\" command. balance = 0 results = [] for command in commands: parts = command.split() action = parts[0] if action == \\"DEPOSIT\\": amount = int(parts[1]) balance += amount elif action == \\"WITHDRAW\\": amount = int(parts[1]) if amount <= balance: balance -= amount elif action == \\"BALANCE\\": results.append(balance) return results"},{"question":"# Problem Statement Write a function `balance_tree_height` that creates a balanced binary search tree (BST) from a sorted list of unique integers. The tree\'s height should be minimal, ensuring the tree is as balanced as possible. Function Signature ```python def balance_tree_height(nums: list[int]) -> Optional[TreeNode]: ``` # Input * `nums`: A sorted list of unique integers. # Output * Returns the root of a balanced binary search tree of minimal height. # Constraints * Each integer in the input list will be within the range (-10^4, 10^4). * The input list will have a length in the range [0, 10^4]. # Performance Requirements * Aim for a solution that ensures the tree is constructed in O(n) time complexity, where `n` is the length of the input list. # Examples ```python assert balance_tree_height([1, 2, 3]) == TreeNode(2, TreeNode(1), TreeNode(3)) assert balance_tree_height([]) == None assert balance_tree_height([-10, -3, 0, 5, 9]) == TreeNode(0, TreeNode(-10, None, TreeNode(-3)), TreeNode(5, None, TreeNode(9))) ``` # Description The provided examples illustrate typical inputs where the function should create a balanced binary search tree. To achieve balance, you would typically pick the middle element of the sorted list as the root, recursively do the same for the left and right sublists to form the left and right subtrees. TreeNode class definition (to be provided in the test harness): ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def equals(tree1: Optional[TreeNode], tree2: Optional[TreeNode]) -> bool: if tree1 is None and tree2 is None: return True if tree1 is not None and tree2 is not None: return ( tree1.val == tree2.val and equals(tree1.left, tree2.left) and equals(tree1.right, tree2.right) ) return False ``` # Edge Cases * An empty list should return `None`. * A list with a single element should return a tree with only the root node. * Ensure that very large input lists are handled efficiently. Design your function `balance_tree_height` to minimize the height of the BST by choosing the middle element of the list at each step.","solution":"from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def balance_tree_height(nums: List[int]) -> Optional[TreeNode]: if not nums: return None def build_tree(left: int, right: int) -> Optional[TreeNode]: if left > right: return None mid = (left + right) // 2 root = TreeNode(nums[mid]) root.left = build_tree(left, mid - 1) root.right = build_tree(mid + 1, right) return root return build_tree(0, len(nums) - 1)"},{"question":"# Problem Statement You are required to write a function `generate_email_addresses(names: list, domain: str) -> list` which generates email addresses for a given list of names and a specific email domain. # Function Signature ```python def generate_email_addresses(names: list, domain: str) -> list: pass ``` # Input - **names**: A list of strings, where each string represents a person’s full name (first name and last name separated by a space). - **domain**: A string representing the email domain (e.g., \\"example.com\\"). # Output - Returns a list of strings, where each string is an email address generated by concatenating the person\'s first name, last name, and the given domain following the standard format: `first_name.last_name@domain`. - If the input list is empty or an error occurs during processing, the function should return an empty list. # Constraints - Assume that both the first name and last name will only contain alphabetic characters. - The function should handle cases where names might be in different cases (e.g., \\"John Doe\\", \\"jane DOE\\", \\"JANE doe\\"). - The domain should be properly formatted to begin with. # Requirements - Validate that the `names` list is not empty and the `domain` string is valid. - Convert all generated email addresses to lowercase. - Separate the first and last names in the input strings. - Handle potential errors gracefully by returning an empty list. # Example ```python >>> generate_email_addresses([\\"John Doe\\", \\"Jane Smith\\"], \\"example.com\\") [\'john.doe@example.com\', \'jane.smith@example.com\'] >>> generate_email_addresses([\\"Alice Johnson\\", \\"Bob Brown\\"], \\"test.org\\") [\'alice.johnson@test.org\', \'bob.brown@test.org\'] ``` # Notes - Consider edge cases such as mixed case names and invalid domain strings. - Ensure the resulting email addresses are all in lowercase. - Optimize handling for varying input sizes and potential errors in formatting.","solution":"def generate_email_addresses(names: list, domain: str) -> list: Generates email addresses for a given list of names and a specific email domain. if not names or not domain: return [] email_addresses = [] for name in names: try: first_name, last_name = name.strip().split() email = f\\"{first_name.lower()}.{last_name.lower()}@{domain.lower()}\\" email_addresses.append(email) except ValueError: # In case there is no space in the name or other formatting issues return [] return email_addresses"},{"question":"# Task Description You need to develop a class that simulates a simple banking system. This system should be able to handle multiple bank accounts, each with its own balance. The system should support the following operations: creating an account, depositing money, withdrawing money, and transferring money between accounts. # Class to Implement `Bank` * Attributes: - `accounts` (dict): A dictionary where the keys are account IDs (strings) and the values are the account balances (floats). Methods to Implement 1. **`__init__()`** - Initializes a new instance of the Bank class with an empty dictionary of accounts. 2. **`create_account(account_id: str)`** - **Input**: - `account_id` (str): The unique ID of the new account. - **Output**: - None. - **Behavior**: - Creates a new account with the given ID and an initial balance of 0.0. 3. **`deposit(account_id: str, amount: float)`** - **Input**: - `account_id` (str): The ID of the account to deposit money into. - `amount` (float): The amount of money to deposit. - **Output**: - None. - **Behavior**: - Increases the balance of the specified account by the given amount. 4. **`withdraw(account_id: str, amount: float)`** - **Input**: - `account_id` (str): The ID of the account to withdraw money from. - `amount` (float): The amount of money to withdraw. - **Output**: - Returns `False` if the account has insufficient funds, otherwise `True`. - **Behavior**: - Decreases the balance of the specified account by the given amount, if sufficient funds are available. 5. **`transfer(from_account: str, to_account: str, amount: float)`** - **Input**: - `from_account` (str): The ID of the account to transfer money from. - `to_account` (str): The ID of the account to transfer money to. - `amount` (float): The amount of money to transfer. - **Output**: - Returns `False` if the transfer fails due to insufficient funds or nonexistent accounts, otherwise `True`. - **Behavior**: - Withdraws the specified amount from the source account and deposits it into the destination account, if possible. # Example ```python # Example usage of the Bank class bank = Bank() bank.create_account(\\"acc1\\") bank.create_account(\\"acc2\\") bank.deposit(\\"acc1\\", 1000.0) bank.deposit(\\"acc2\\", 500.0) print(bank.withdraw(\\"acc1\\", 200.0)) # Output: True print(bank.transfer(\\"acc1\\", \\"acc2\\", 300.0)) # Output: True print(bank.accounts) # Output: {\\"acc1\\": 500.0, \\"acc2\\": 800.0} ``` # Constraints * The `account_id` for each account will be a unique, non-empty string. * The `amount` for any transaction will be a float greater than or equal to 0.0. * All operations should be efficient and run in constant time O(1), assuming dictionary operations are constant time. # Requirements 1. Ensure the class methods are properly implemented and handle edge cases like non-existent accounts gracefully. 2. Your implementation should properly update account balances based on the described operations. 3. Implement necessary validation to ensure correct and secure handling of funds within the system.","solution":"class Bank: def __init__(self): self.accounts = {} def create_account(self, account_id: str): if account_id not in self.accounts: self.accounts[account_id] = 0.0 def deposit(self, account_id: str, amount: float): if account_id in self.accounts: self.accounts[account_id] += amount def withdraw(self, account_id: str, amount: float) -> bool: if account_id in self.accounts and self.accounts[account_id] >= amount: self.accounts[account_id] -= amount return True return False def transfer(self, from_account: str, to_account: str, amount: float) -> bool: if from_account in self.accounts and to_account in self.accounts and self.accounts[from_account] >= amount: self.accounts[from_account] -= amount self.accounts[to_account] += amount return True return False"},{"question":"# Maximal Network Rank In this task, you are given an undirected graph represented as an adjacency list. Your goal is to determine the maximal network rank between any two vertices. The network rank of a pair of vertices is defined as the total number of unique edges incident to either vertex. Your Task Write a function `maximal_network_rank` that computes the maximal network rank for the given graph. * **Input**: - `n`: Integer denoting the number of vertices. - `roads`: List of lists, where each inner list contains two integers representing a bidirectional road between vertex `u` and vertex `v`. * **Output**: - Return the maximal network rank as an integer. Constraints * (2 leq n leq 100) * (0 leq text{len(roads)} leq 5000) * Each vertex (0 leq u, v < n). * No duplicate edges between the same pair of vertices. Example ```python def maximal_network_rank(n, roads): from collections import defaultdict graph = defaultdict(set) for u, v in roads: graph[u].add(v) graph[v].add(u) max_rank = 0 for i in range(n): for j in range(i + 1, n): if i != j: current_rank = len(graph[i]) + len(graph[j]) - (1 if j in graph[i] else 0) max_rank = max(max_rank, current_rank) return max_rank # Example usage n = 4 roads = [[0, 1], [0, 3], [1, 2], [1, 3]] print(maximal_network_rank(n, roads)) # Output: 4 ``` Expectations: 1. **Correctness**: Ensure all possible vertex pairs are considered and the correct maximal network rank is computed. 2. **Efficiency**: Implement the solution to handle up to the maximum constraints efficiently. 3. **Edge Cases**: Properly handle graphs with no roads and graphs where all vertices are connected to each other.","solution":"def maximal_network_rank(n, roads): from collections import defaultdict # Initialize adjacency set to store roads graph = defaultdict(set) # Populate the graph with roads for u, v in roads: graph[u].add(v) graph[v].add(u) max_rank = 0 # Iterate over all pairs of vertices for i in range(n): for j in range(i + 1, n): # Calculate the network rank of the pair (i, j) current_rank = len(graph[i]) + len(graph[j]) - (1 if j in graph[i] else 0) # Update the maximum network rank found max_rank = max(max_rank, current_rank) return max_rank"},{"question":"# Question: Image Color Inversion with Region Protection You are asked to implement a function that performs color inversion on an image but avoids inverting colors within specified protected regions. Function Signature ```python def invert_colors_with_protection(image: np.ndarray, protected_regions: List[Tuple[int, int, int, int]]) -> np.ndarray: ``` Inputs 1. `image`: A numpy array representing the image, with shape `(H, W, C)`, where `H` is the height, `W` is the width, and `C` is the number of channels (typically 3 for RGB). 2. `protected_regions`: A list of tuples, where each tuple contains four integers `(xmin, ymin, xmax, ymax)` representing the top-left and bottom-right coordinates of a protected region in the image. Outputs 1. `modified_image`: The resulting image as a numpy array, with colors inverted in all areas except the specified protected regions. Constraints - The protected regions will not overlap. - The protected regions are guaranteed to be within the image dimensions. - The input image will always have three channels (RGB). # Context You are developing an image processing application that allows users to apply artistic effects to their photos while preserving the original colors in certain areas of significance (e.g., faces, logos). Example ```python image = np.array([ [[100, 150, 200], [100, 150, 200], [100, 150, 200]], [[100, 150, 200], [200, 150, 100], [100, 150, 200]], [[100, 150, 200], [100, 150, 200], [100, 150, 200]] ]) protected_regions = [(1, 1, 2, 2)] modified_image = invert_colors_with_protection(image, protected_regions) print(modified_image) ``` Expected output of the `modified_image` array where the colors are inverted except for the protected region (1, 1) to (2, 2): ```python array([ [[155, 105, 55], [155, 105, 55], [155, 105, 55]], [[155, 105, 55], [200, 150, 100], [155, 105, 55]], [[155, 105, 55], [155, 105, 55], [155, 105, 55]] ]) ``` In the above example, the colors of the image are inverted except within the region specified by `(1, 1, 2, 2)`, which retains its original color values.","solution":"import numpy as np from typing import List, Tuple def invert_colors_with_protection(image: np.ndarray, protected_regions: List[Tuple[int, int, int, int]]) -> np.ndarray: Perform color inversion on an image while avoiding specified protected regions. Parameters: image (np.ndarray): The input image with shape (H, W, C). protected_regions (List[Tuple[int, int, int, int]]): List of protected regions as (xmin, ymin, xmax, ymax). Returns: np.ndarray: The resulting image with colors inverted except the protected regions. inverted_image = 255 - image for xmin, ymin, xmax, ymax in protected_regions: inverted_image[ymin:ymax, xmin:xmax] = image[ymin:ymax, xmin:xmax] return inverted_image"},{"question":"# Problem Statement Implement a function to compute the longest common subsequence (LCS) between two strings using dynamic programming. You must implement both the top-down (recursive with memoization) and bottom-up (iterative) approaches. # Function Signature ```python class LongestCommonSubsequence: def lcs_top_down(text1: str, text2: str) -> int: pass def lcs_bottom_up(text1: str, text2: str) -> int: pass ``` # Input - Two non-empty strings `text1` and `text2` with lengths `m` and `n` respectively. (1 <= m, n <= 1000) # Output - Return an integer representing the length of the longest common subsequence of `text1` and `text2`. # Examples ```python # Example 1: text1 = \\"abcde\\" text2 = \\"ace\\" LongestCommonSubsequence().lcs_top_down(text1, text2) # Expected output: 3 LongestCommonSubsequence().lcs_bottom_up(text1, text2) # Expected output: 3 # Example 2: text1 = \\"abc\\" text2 = \\"abc\\" LongestCommonSubsequence().lcs_top_down(text1, text2) # Expected output: 3 LongestCommonSubsequence().lcs_bottom_up(text1, text2) # Expected output: 3 # Example 3: text1 = \\"abc\\" text2 = \\"def\\" LongestCommonSubsequence().lcs_top_down(text1, text2) # Expected output: 0 LongestCommonSubsequence().lcs_bottom_up(text1, text2) # Expected output: 0 ``` # Constraints - Do not use any built-in functions that directly solve this problem. - The solution should be efficient in terms of time and space complexity. # Notes - Make sure to properly handle all edge cases. - Write clean, readable, and well-documented code.","solution":"class LongestCommonSubsequence: def lcs_top_down(self, text1: str, text2: str) -> int: memo = {} def dfs(i, j): if i == len(text1) or j == len(text2): return 0 if (i, j) in memo: return memo[(i, j)] if text1[i] == text2[j]: memo[(i, j)] = 1 + dfs(i + 1, j + 1) else: memo[(i, j)] = max(dfs(i + 1, j), dfs(i, j + 1)) return memo[(i, j)] return dfs(0, 0) def lcs_bottom_up(self, text1: str, text2: str) -> int: m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i - 1] == text2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"# Coding Assessment Question Context You are tasked with implementing a simple text-based file system. Users can create directories, add files with content, read files, and list directories\' contents. Task Implement a class `FileSystem` that supports the following methods: - `mkdir(path: str) -> None`: Creates a new directory at the given path. The entire path should be created if intermediate directories do not exist. - `addFile(path: str, content: str) -> None`: Adds a new file at the specified path and writes the given content to the file. If the file already exists, append the new content to the existing content. - `readFile(path: str) -> str`: Reads the content of the file at the specified path. - `ls(path: str) -> list`: Lists the names of files and directories within the given directory path, sorted lexicographically. If the path is a file, it returns a list containing just the file\'s name. Implementation * Your class should handle: - Valid paths consisting of directory and file names using `/` as the separator. - Directory and file names that contain alpha-numeric characters, periods (.), and hyphens (-). - Creating intermediate directories if they do not exist when adding a file or creating a directory. - Listing directory contents in lexicographical order. Constraints - All directory and file names are non-empty strings and follow the constraints described. - `2 <= len(path) <= 1000` - `3 <= len(content) <= 1000` Input/Output Format - Methods may be called in any order and will not exceed 10^4 operations in total. Example ```python class FileSystem: def __init__(self): # Your initialization code here def mkdir(self, path: str) -> None: # Your implementation here def addFile(self, path: str, content: str) -> None: # Your implementation here def readFile(self, path: str) -> str: # Your implementation here def ls(self, path: str) -> list: # Your implementation here # Example usage: fs = FileSystem() fs.mkdir(\\"/a/b/c\\") fs.addFile(\\"/a/b/c/d.txt\\", \\"Hello\\") print(fs.ls(\\"/\\")) # Output: [\'a\'] print(fs.ls(\\"/a/b/c\\")) # Output: [\'d.txt\'] fs.addFile(\\"/a/b/c/d.txt\\", \\" World\\") print(fs.readFile(\\"/a/b/c/d.txt\\")) # Output: \'Hello World\' fs.mkdir(\\"/a/b/x\\") print(fs.ls(\\"/a/b\\")) # Output: [\'c\', \'x\'] ``` The submitted code will be evaluated for correctness, efficiency, and adherence to problem constraints.","solution":"class FileSystem: def __init__(self): self.fs = {} def mkdir(self, path: str) -> None: dirs = path.split(\'/\') node = self.fs for dir in dirs: if dir: # skip empty strings from leading/trailing slashes if dir not in node: node[dir] = {} node = node[dir] def addFile(self, path: str, content: str) -> None: dirs = path.split(\'/\') *dirs, filename = dirs node = self.fs for dir in dirs: if dir: # skip empty strings from leading/trailing slashes if dir not in node: node[dir] = {} node = node[dir] if filename in node: node[filename] += content else: node[filename] = content def readFile(self, path: str) -> str: dirs = path.split(\'/\') *dirs, filename = dirs node = self.fs for dir in dirs: if dir: # skip empty strings from leading/trailing slashes node = node[dir] return node[filename] def ls(self, path: str) -> list: if path == \\"/\\": node = self.fs else: dirs = path.split(\'/\') node = self.fs for dir in dirs: if dir: # skip empty strings from leading/trailing slashes node = node.get(dir, {}) if isinstance(node, str): return [dirs[-1]] return sorted(node.keys())"},{"question":"# Coding Question You need to create a Python function that parses and analyzes log data from a specified log file. The function should extract specific information from each log entry based on certain criteria and return a summary report. Function Requirements: - **Function Name**: `analyze_log_data` - **Inputs**: - `log_file_path` (str): Path to the log file. - `criteria` (dict): A dictionary specifying the key-value pairs for filtering log entries. - **Outputs**: - A dictionary containing the `total_logs` (int) matching the criteria and a `breakdown` (dict) showing the count of logs per unique value of a specified key. - **Constraints**: - Handle file reading errors gracefully by raising an `OSError` with the message \\"File not found or unreadable\\". - Assume log entries are in JSON format, one per line. - If no log entries match the criteria, return a dictionary with `total_logs` set to 0 and an empty `breakdown`. - **Performance**: Optimize for processing large log files efficiently without excessive memory usage. - **Edge Cases**: - Empty log file. - Log file with invalid JSON entries. # Example Usage ```python try: summary = analyze_log_data( log_file_path=\\"/var/log/system.log\\", criteria={\\"status\\": \\"error\\", \\"service\\": \\"auth\\"} ) print(f\\"Total Logs: {summary[\'total_logs\']}\\") print(\\"Breakdown:\\") for key, value in summary[\'breakdown\'].items(): print(f\\" {key}: {value}\\") except OSError as oe: print(oe) ``` # Notes - Ensure the function can handle large files efficiently by processing them line-by-line. - Raise an `OSError` if the specified file cannot be read or does not exist. - The `criteria` dictionary will have fields that must all match for a log entry to be included in the result. # Example Solution Signature ```python def analyze_log_data( log_file_path: str, criteria: dict ) -> dict: # Your code here pass ```","solution":"import json def analyze_log_data(log_file_path, criteria): try: total_logs = 0 breakdown = {} with open(log_file_path, \'r\') as log_file: for line in log_file: try: log_entry = json.loads(line) except json.JSONDecodeError: continue if all(log_entry.get(k) == v for k, v in criteria.items()): total_logs += 1 unique_value = log_entry.get(\\"key\\", \\"unknown\\") if unique_value in breakdown: breakdown[unique_value] += 1 else: breakdown[unique_value] = 1 return {\\"total_logs\\": total_logs, \\"breakdown\\": breakdown} except IOError: raise OSError(\\"File not found or unreadable\\")"},{"question":"Personalized Movie Recommendation For this assessment, you are tasked with implementing a movie recommendation system using collaborative filtering. Given datasets of user ratings for various movies, you will predict movies that a user might like based on the ratings data provided. **Problem**: 1. Implement a function `prepare_data` that preprocesses and transforms the input data into a user-item matrix. 2. Implement a function `collaborative_filtering` that performs collaborative filtering to predict user ratings for movies. 3. Implement a `main` function to run the entire recommendation process and evaluate the predictions. # Input: 1. A dictionary `data` with keys: * `users` - A list of user identifiers. * `movies` - A list of movie titles. * `ratings` - A list of tuples, each containing a user, a movie, and the corresponding rating (user, movie, rating). # Output: 1. A predicted rating matrix of users and movies. 2. A list of top N recommended movies for a specified user. # Constraints: * Use collaborative filtering techniques such as user-based or item-based filtering. * Ensure the error metrics (Root Mean Square Error) are calculated correctly. * Handle any missing or sparse data rationally. # Example: ```python # Expected data format for input dictionary example_data = { \\"users\\": [\\"Alice\\", \\"Bob\\", \\"Charlie\\"], \\"movies\\": [\\"Movie1\\", \\"Movie2\\", \\"Movie3\\"], \\"ratings\\": [(\\"Alice\\", \\"Movie1\\", 5), (\\"Alice\\", \\"Movie2\\", 3), (\\"Bob\\", \\"Movie1\\", 4), (\\"Charlie\\", \\"Movie3\\", 2)] } # Define the functions def prepare_data(data): # Perform data preprocessing and transform the dataset into a user-item matrix pass def collaborative_filtering(user_item_matrix): # Apply collaborative filtering to predict user ratings for movies pass def main(): # Running the recommendation system pass if __name__ == \\"__main__\\": main() ``` # Evaluation: Evaluate your solution based on: 1. Correctness: Does the system accurately predict movie ratings and recommend movies that the user might like? 2. Efficiency: Is your solution optimized for given constraints and large datasets? 3. Robustness: Does your solution handle edge cases and sparse data gracefully?","solution":"import numpy as np import pandas as pd from sklearn.metrics.pairwise import cosine_similarity from sklearn.metrics import mean_squared_error from math import sqrt def prepare_data(data): Transforms input data into a user-item matrix. :param data: Dict containing \'users\', \'movies\', and \'ratings\' :return: Pandas DataFrame representing user-item matrix ratings = pd.DataFrame(data[\'ratings\'], columns=[\'user\', \'movie\', \'rating\']) user_item_matrix = ratings.pivot_table(index=\'user\', columns=\'movie\', values=\'rating\') return user_item_matrix def collaborative_filtering(user_item_matrix): Perform collaborative filtering to predict user ratings for movies. :param user_item_matrix: User-item matrix DataFrame :return: Predicted ratings matrix user_sim = cosine_similarity(user_item_matrix.fillna(0)) user_sim_df = pd.DataFrame(user_sim, index=user_item_matrix.index, columns=user_item_matrix.index) user_item_matrix_mean = user_item_matrix.subtract(user_item_matrix.mean(axis=1), axis=0) prediction_matrix = user_sim_df.dot(user_item_matrix_mean.fillna(0)).div(user_sim_df.sum(axis=1), axis=0) predictions = prediction_matrix.add(user_item_matrix.mean(axis=1), axis=0) return predictions def recommend_movies(predictions, user, top_n=5): Recommend top N movies for a given user. :param predictions: Predicted ratings matrix DataFrame :param user: User identifier :param top_n: Number of top recommendations to return :return: List of top N recommended movies for the user user_ratings = predictions.loc[user].sort_values(ascending=False) recommendations = user_ratings.index[user_ratings > 0].tolist() return recommendations[:top_n] def main(data, user, top_n=5): Run the entire recommendation process and evaluate the predictions. :param data: Raw input data containing \'users\', \'movies\', and \'ratings\' :param user: User identifier for whom recommendations are made :param top_n: Number of top recommendations to return user_item_matrix = prepare_data(data) predictions = collaborative_filtering(user_item_matrix) user_actual_ratings = user_item_matrix.loc[user].dropna() user_predicted_ratings = predictions.loc[user].loc[user_actual_ratings.index] rmse = sqrt(mean_squared_error(user_actual_ratings, user_predicted_ratings)) print(f\\"Root Mean Square Error (RMSE): {rmse}\\") top_recommendations = recommend_movies(predictions, user, top_n) print(f\\"Top {top_n} recommended movies for {user}: {top_recommendations}\\") return predictions, top_recommendations"},{"question":"# Binary Tree Maximum Path Sum **Context**: You are designing a feature for a data visualization tool that needs to analyze tree-based structures. One critical analysis is to find the maximum path sum within a binary tree. A path in a binary tree is any sequence of nodes starting from some starting node to any node in the tree along the parent-child connections. The path does not need to go through the root. **Problem Statement**: Implement a function `max_path_sum` that computes the maximum path sum for a given binary tree. The function will use a binary tree where each node contains an integer value. **Function Signature**: ```python class TreeNode: def __init__(self, value: int = 0, left = None, right = None): self.value = value self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: Computes the maximum path sum in a binary tree. :param root: the root node of the binary tree. :return: the maximum path sum. ``` **Input**: - `root`: The root node of a binary tree with each node containing an integer value. **Output**: - An integer representing the maximum path sum within the tree. **Constraints**: - The number of nodes in the tree is in the range [1, 3 * 10^4]. - Each node’s value is between -10^4 and 10^4. **Examples**: ```python # Example 1: root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) print(max_path_sum(root1)) # Output: 6 (2+1+3) # Example 2: root2 = TreeNode(-10) root2.left = TreeNode(9) root2.right = TreeNode(20) root2.right.left = TreeNode(15) root2.right.right = TreeNode(7) print(max_path_sum(root2)) # Output: 42 (15+20+7) # Example 3: root3 = TreeNode(1) root3.left = TreeNode(-2) root3.right = TreeNode(3) print(max_path_sum(root3)) # Output: 4 (1 + 3) # Example 4: root4 = TreeNode(5) print(max_path_sum(root4)) # Output: 5 (the node itself) ``` **Key Considerations**: - Ensure the function handles negative values and zeros correctly. - Make sure the solution works efficiently with large input sizes within the given constraints. - Think about the recursive nature of the problem and how you’ll traverse the tree to compute the maximum path sum.","solution":"class TreeNode: def __init__(self, value: int = 0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root: TreeNode) -> int: Computes the maximum path sum in a binary tree. :param root: the root node of the binary tree. :return: the maximum path sum. def helper(node): if not node: return 0 # Calculate maximum path sum with left and right child nodes left_max = max(0, helper(node.left)) right_max = max(0, helper(node.right)) # Check the maximum path sum at the current node current_max = node.value + left_max + right_max nonlocal max_sum max_sum = max(max_sum, current_max) # Return the maximum path sum where current node is the end point return node.value + max(left_max, right_max) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Context: In number theory, the Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. For this exercise, you\'ll implement a function to find the nth Fibonacci number. # Task: Write a function `nth_fibonacci(n)` that takes an integer `n` and returns the nth number in the Fibonacci sequence. # Input: - `n`: an integer representing the position in the Fibonacci sequence (0-based indexing). # Output: - An integer representing the nth Fibonacci number. # Constraints: - `0 <= n <= 50` # Example: ```python assert nth_fibonacci(0) == 0 assert nth_fibonacci(1) == 1 assert nth_fibonacci(2) == 1 assert nth_fibonacci(3) == 2 assert nth_fibonacci(10) == 55 assert nth_fibonacci(25) == 75025 ``` # Performance Requirements: - The function should efficiently compute the nth Fibonacci number using O(n) time complexity and O(1) space complexity.","solution":"def nth_fibonacci(n): Returns the nth Fibonacci number. :param n: The position in the Fibonacci sequence (0-based index) :return: The nth Fibonacci number if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 previous, current = 0, 1 for _ in range(2, n+1): previous, current = current, previous + current return current"},{"question":"# Coding Assessment Question Problem Statement You are tasked with designing a function that simulates the rolling of multiple dice and calculates the maximum points obtainable by considering different combinations of dice rolls. Specifically, you will implement a function that simulates rolling `n` six-sided dice, finds all possible sums of three dice picked from the total rolls, and returns the maximum sum obtained. Function Signature ```python def dice_max_sum(n: int) -> int: pass ``` Input - `n (int)`: Number of dice to be rolled (1 <= n <= 100). Output - Returns an integer representing the maximum possible sum of any three dice rolls. Constraints - Each die is six-sided, and each side has an equal probability of being rolled (values from 1 to 6). Requirements - **Efficiency**: Ensure the function runs efficiently, even for the upper limit of `n`. Example ```python assert dice_max_sum(5) == 18 # When rolling 5 dice, the maximum sum of three dice is 18 (6+6+6) assert dice_max_sum(3) == 18 # Only 3 dice, so the sum is the total of these (6+6+6) ``` --- Notes 1. If `n` is 1 or 2, the function should return the sum of all dice rolled as it\'s impossible to form a sum of three different dice. 2. Consider different scenarios and edge cases to ensure the correctness of the solution. 3. Ensure to handle the upper bound efficiently using appropriate data structures and algorithms. ---","solution":"def dice_max_sum(n: int) -> int: Returns the maximum sum obtainable from rolling \'n\' six-sided dice and picking the highest three dice rolls. If fewer than 3 dice are rolled, returns the sum of all dice. if n <= 0: return 0 # Since each die is six-sided, we simulate the maximum scenario where each roll is 6 max_dice_roll = 6 # If n is less than 3, we return the sum of all dice rolls if n <= 2: return n * max_dice_roll # If n is 3 or more, we return the sum of the highest three rolls return 3 * max_dice_roll"},{"question":"# Array Rotation **Context**: In a programming context, array manipulation is a fundamental aspect of problem-solving. One common manipulation is the rotation of an array where elements are shifted in a circular manner. This concept is widely used in various applications such as in data transformation, game development, and implementing certain algorithms. **Task**: Implement a function `rotate_array(arr: List[int], k: int) -> List[int]` that rotates the given array to the right by `k` steps. Rotation should be done efficiently with respect to time and space complexity. **Input**: * A list of integers `arr` representing the array to rotate. * An integer `k` representing the number of steps to rotate the array. **Output**: * A list of integers representing the rotated array. **Constraints**: * The array can have up to 10,000 elements. * `k` can be as large as 1,000,000. * Input values are integers. **Example**: ```python assert rotate_array([1, 2, 3, 4, 5, 6, 7], 3) == [5, 6, 7, 1, 2, 3, 4] assert rotate_array([1, 2, 3], 4) == [3, 1, 2] assert rotate_array([1], 7) == [1] ``` **Performance Requirement**: * Ensure that the rotation operation is performed in O(n) time complexity where n is the number of elements in the array. * The solution should use O(1) additional space, meaning the array should be modified in place if possible. **Hints**: * Consider the effect of large `k` values and how they can be optimized. * Explore the use of array slicing techniques or a three-step reverse approach.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: n = len(arr) if n == 0: return arr k = k % n # Normalize k to prevent unnecessary full rotations return arr[-k:] + arr[:-k] # Slice and concatenate to perform the rotation"},{"question":"# Coding Assessment Question: You are given a list of integers where each integer represents the volume of water at specific points. Implement a function called `calculate_trapped_water` that calculates the total amount of water that can be trapped after raining. Function Signature ```python def calculate_trapped_water(heights: List[int]) -> int: ``` Input * `heights` - A list of non-negative integers representing the height of each point. Output * Return a single integer representing the total amount of trapped water. Constraints 1. The length of the list `heights` will be between 0 and 10^4. 2. Each element in `heights` will be a non-negative integer not greater than 10^5. Explanation Water can only be trapped between points that form a \\"container-like\\" structure. For instance, given the list `[0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]`, the amount of water trapped would be `6` units. Performance Ensure your solution is efficient with regards to both time and space complexity. Example ```python >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([2, 0, 2]) 2 >>> calculate_trapped_water([0, 0, 0]) 0 >>> calculate_trapped_water([5]) 0 ``` Edge Cases to Consider * Lists with less than 3 points where no water can be trapped. * Lists where all heights are zero. * Lists with varying height patterns including ascending, descending, and peaks.","solution":"from typing import List def calculate_trapped_water(heights: List[int]) -> int: if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"# Decision Tree Classifier Implementation with Pruning Context As a data scientist at a financial institution, you are tasked with predicting whether a loan application will be approved (1) or rejected (0) based on applicant data. You choose to implement a Decision Tree classifier from scratch to perform this binary classification task. Additionally, you will incorporate a pruning mechanism to avoid overfitting and improve generalization. Objective Implement a Decision Tree classifier from scratch, including functionality to perform post-pruning based on a validation dataset. Input Format 1. A matrix `X` of shape (m, k) representing m loan applicants and k features. 2. A vector `y` of shape (m,) representing the binary class labels (0 for rejected, 1 for approved). 3. A matrix `X_val` of shape (n, k) representing the validation set with n samples. 4. A vector `y_val` of shape (n,) representing the binary class labels for the validation set. 5. Maximum depth `max_depth` (integer) for the decision tree. 6. Minimum samples per leaf `min_samples_leaf` (integer). Output Format 1. The root node of the pruned Decision Tree classifier. 2. Print the accuracy of the Decision Tree on the validation set before and after pruning. Constraints 1. Number of features `k` should be ≥ 1 and ≤ 50. 2. Number of training samples `m` should be ≥ 10 and ≤ 10000. 3. Number of validation samples `n` should be ≥ 10 and ≤ 10000. 4. `max_depth` should be ≥ 1 and ≤ 20. 5. `min_samples_leaf` should be ≥ 1 and ≤ 50. # Function Signature ```python def decision_tree_classifier(X: np.ndarray, y: np.ndarray, X_val: np.ndarray, y_val: np.ndarray, max_depth: int, min_samples_leaf: int): pass ``` # Example ```python X = np.array([[1, 2], [1, 3], [2, 3], [3, 2], [3, 3], [2, 2], [7, 8], [8, 7], [7, 7], [8, 8]]) y = np.array([0, 0, 1, 1, 1, 0, 1, 1, 1, 0]) X_val = np.array([[3, 3], [2, 3], [8, 8], [1, 2], [7, 7]]) y_val = np.array([1, 1, 0, 0, 1]) max_depth = 3 min_samples_leaf = 2 root = decision_tree_classifier(X, y, X_val, y_val, max_depth, min_samples_leaf) ``` In this example, the function `decision_tree_classifier` should: 1. Build a Decision Tree based on the training set (`X`, `y`). 2. Evaluate the tree on the validation set (`X_val`, `y_val`) before pruning and print the accuracy. 3. Prune the tree based on validation set accuracy. 4. Print the accuracy of the pruned tree on the validation set. # Requirements Implement the core operational steps for a Decision Tree classifier: 1. Compute the Gini impurity to determine the best splits. 2. Define the split function and node structure. 3. Implement tree-building recursively. 4. Implement a pruning mechanism where nodes are pruned based on validation accuracy. Good luck!","solution":"import numpy as np class TreeNode: def __init__(self, gini, num_samples, num_samples_per_class, predicted_class): self.gini = gini self.num_samples = num_samples self.num_samples_per_class = num_samples_per_class self.predicted_class = predicted_class self.feature_index = 0 self.threshold = 0 self.left = None self.right = None def gini_impurity(y): m = len(y) return 1.0 - sum((np.sum(y == c) / m) ** 2 for c in np.unique(y)) def grow_tree(X, y, depth=0, max_depth=None, min_samples_leaf=1): num_samples_per_class = [np.sum(y == i) for i in np.unique(y)] predicted_class = np.argmax(num_samples_per_class) node = TreeNode( gini=gini_impurity(y), num_samples=len(y), num_samples_per_class=num_samples_per_class, predicted_class=predicted_class, ) if depth < max_depth and len(y) >= min_samples_leaf and node.gini > 0: idx, thr = best_split(X, y) if idx is not None: indices_left = X[:, idx] < thr X_left, y_left = X[indices_left], y[indices_left] X_right, y_right = X[~indices_left], y[~indices_left] node.feature_index = idx node.threshold = thr node.left = grow_tree(X_left, y_left, depth + 1, max_depth, min_samples_leaf) node.right = grow_tree(X_right, y_right, depth + 1, max_depth, min_samples_leaf) return node def best_split(X, y): m, n = X.shape if m <= 1: return None, None num_parent = [np.sum(y == c) for c in np.unique(y)] best_gini = 1.0 - sum((num / m) ** 2 for num in num_parent) best_idx, best_thr = None, None for idx in range(n): thresholds, classes = zip(*sorted(zip(X[:, idx], y))) num_left = [0] * len(np.unique(y)) num_right = num_parent.copy() for i in range(1, m): c = classes[i - 1] num_left[y[i - 1]] += 1 num_right[y[i - 1]] -= 1 gini_left = 1.0 - sum((num_left[x] / i) ** 2 for x in range(len(np.unique(y)))) gini_right = 1.0 - sum((num_right[x] / (m - i)) ** 2 for x in range(len(np.unique(y)))) gini = (i * gini_left + (m - i) * gini_right) / m if thresholds[i] == thresholds[i - 1]: continue if gini < best_gini: best_gini = gini best_idx = idx best_thr = (thresholds[i - 1] + thresholds[i]) / 2 return best_idx, best_thr def prune_tree(node, X_val, y_val): if node.left and node.right: if node.left.left or node.left.right: prune_tree(node.left, X_val, y_val) if node.right.left or node.right.right: prune_tree(node.right, X_val, y_val) if not node.left.left and not node.left.right and not node.right.left and not node.right.right: acc_before_prune = accuracy_score(predict_tree(node, X_val), y_val) temp_left = node.left temp_right = node.right node.left = node.right = None acc_after_prune = accuracy_score(predict_tree(node, X_val), y_val) if acc_before_prune > acc_after_prune: node.left = temp_left node.right = temp_right def predict_tree(node, X): if node.left is None and node.right is None: return np.array([node.predicted_class]*X.shape[0]) predicts = [] for row in X: predicts.append(single_predict(node, row)) return np.array(predicts) def single_predict(node, row): if node.left is None and node.right is None: return node.predicted_class if row[node.feature_index] < node.threshold: return single_predict(node.left, row) else: return single_predict(node.right, row) def accuracy_score(y_true, y_pred): return np.sum(y_true == y_pred) / len(y_true) def decision_tree_classifier(X, y, X_val, y_val, max_depth, min_samples_leaf): tree = grow_tree(X, y, max_depth=max_depth, min_samples_leaf=min_samples_leaf) # Evaluate before pruning y_pred_before = predict_tree(tree, X_val) acc_before = accuracy_score(y_val, y_pred_before) print(f\'Validation Accuracy before pruning: {acc_before}\') # Prune prune_tree(tree, X_val, y_val) # Evaluate after pruning y_pred_after = predict_tree(tree, X_val) acc_after = accuracy_score(y_val, y_pred_after) print(f\'Validation Accuracy after pruning: {acc_after}\') return tree"},{"question":"Coding Assessment Question # Objective Write a function that finds and returns the longest increasing subsequence in a list of integers. Your implementation should be efficient in terms of both time and space complexity. # Scenario You are developing a tool that detects trends in stock price movements. One of the key tasks is identifying the longest period during which the stock prices are consistently increasing. This involves finding the longest increasing contiguous subsequence from a given list of daily stock prices. # Task Implement the function `find_longest_increasing_subsequence` with the following requirements: 1. **Input**: * A list of integers representing daily stock prices. 2. **Output**: * A list of integers representing the longest increasing contiguous subsequence of stock prices. 3. **Constraints**: * You must use a dynamic programming approach to solve this problem. * The implementation should have a time complexity of O(n^2) or better. # Constraints: * The length of the input list is between 1 and 10,000 elements. * The stock prices are integers in the range from 1 to 10,000. # Function Signature ```python def find_longest_increasing_subsequence(prices: List[int]) -> List[int]: ``` # Example ```python prices = [10, 22, 9, 33, 21, 50, 41, 60, 80] result = find_longest_increasing_subsequence(prices) # Output: [10, 22, 33, 50, 60, 80] prices = [3, 10, 2, 1, 20] result = find_longest_increasing_subsequence(prices) # Output: [3, 10, 20] ``` # Additional Task * Provide unit tests to validate your function with various test cases, including edge cases such as a single element list, all elements being the same, and strictly decreasing lists.","solution":"from typing import List def find_longest_increasing_subsequence(prices: List[int]) -> List[int]: if not prices: return [] n = len(prices) lengths = [1] * n predecessors = [-1] * n for i in range(1, n): for j in range(i): if prices[i] > prices[j] and lengths[i] < lengths[j] + 1: lengths[i] = lengths[j] + 1 predecessors[i] = j # Find the index of the maximum length LIS max_length = max(lengths) max_index = lengths.index(max_length) # Reconstruct the longest increasing subsequence lis = [] while max_index != -1: lis.append(prices[max_index]) max_index = predecessors[max_index] return lis[::-1]"},{"question":"# Question Context You are tasked with writing a function that calculates the average sales per quarter for a given dataset. Your solution should be robust and handle any potential data issues sensibly. # Problem Statement Implement a function called `average_sales_per_quarter` in Python that reads sales data from a CSV file and calculates the average sales for each quarter. The function should handle missing or malformed data by skipping those entries. # Requirements 1. **Function Definition**: ```python def average_sales_per_quarter(filename: str) -> dict: pass ``` 2. **Behavior**: - The function should read the sales data from the `filename` CSV file. - Each line of the CSV file represents a sales entry in the format: ```csv Year,Month,Sales 2023,01,5000 2023,02,4500 ... ``` - Calculate the average sales for each of the four quarters: - Q1: January, February, March - Q2: April, May, June - Q3: July, August, September - Q4: October, November, December - Handle any missing or malformed data by skipping those entries. 3. **Expected Output**: - Return a dictionary where the keys are \'Q1\', \'Q2\', \'Q3\', \'Q4\' and the values are the average sales for those quarters. # Expected Input and Output Formats - **Input**: - `filename`: A string representing the name of the CSV file containing the sales data. - **Output**: - A dictionary with the average sales per quarter, e.g., `{\'Q1\': 4500.0, \'Q2\': 5500.0, \'Q3\': 5200.0, \'Q4\': 4900.0}` # Constraints - Assume the file is in proper CSV format but may contain some rows with missing or non-numeric sales data. - Ensure the function handles any I/O operations sensibly, raising appropriate exceptions for issues like file not found. # Performance Requirements - The function should efficiently process files that might contain thousands of records. # Example Given Input File (`sales.csv`) ```csv Year,Month,Sales 2023,01,5000 2023,02,4500 2023,03,4000 2023,04,5500 2023,05,6000 ... ``` Expected Output ```python { \'Q1\': 4500.0, \'Q2\': 5500.0, \'Q3\': 5200.0, \'Q4\': 4900.0 } ``` # Implementation You are required to implement the `average_sales_per_quarter` function and ensure it meets the outlined specifications.","solution":"import csv def average_sales_per_quarter(filename: str) -> dict: quarters = {\'Q1\': [], \'Q2\': [], \'Q3\': [], \'Q4\': []} month_to_quarter = { \\"01\\": \\"Q1\\", \\"02\\": \\"Q1\\", \\"03\\": \\"Q1\\", \\"04\\": \\"Q2\\", \\"05\\": \\"Q2\\", \\"06\\": \\"Q2\\", \\"07\\": \\"Q3\\", \\"08\\": \\"Q3\\", \\"09\\": \\"Q3\\", \\"10\\": \\"Q4\\", \\"11\\": \\"Q4\\", \\"12\\": \\"Q4\\" } try: with open(filename, mode=\'r\') as file: reader = csv.DictReader(file) for row in reader: try: month = row[\'Month\'].zfill(2) # Ensure month is two digits quarter = month_to_quarter[month] sales = float(row[\'Sales\']) quarters[quarter].append(sales) except (KeyError, ValueError): # Skip the row if there is a KeyError or if the Sales data is not a float continue # Calculate the average for each quarter avg_sales = {} for quarter, sales in quarters.items(): avg_sales[quarter] = sum(sales) / len(sales) if sales else 0.0 return avg_sales except FileNotFoundError: raise Exception(\\"The file was not found.\\")"},{"question":"# Finding Articulation Points in a Network In network analysis, identifying critical points whose removal would increase the number of disconnected components is essential to maintaining the robustness of the system. These critical points are known as articulation points. You are given the task of writing a function to identify all articulation points in an undirected graph using Depth-First Search (DFS). An articulation point in an undirected graph is a vertex which, when removed (along with its associated edges), makes the graph more disconnected. **Function Signature**: ```python def find_articulation_points(n: int, edges: List[Tuple[int, int]]) -> List[int]: ``` **Input**: * `n`: (Integer) The number of vertices in the graph (0-indexed nodes). * `edges`: (List of Tuples) Each tuple consists of two values representing an undirected edge between vertices `u` and `v`. **Output**: * A list of vertices that are articulation points. The list should be sorted in ascending order. **Constraints**: * 1 ≤ n ≤ 1000 * The graph will be connected. * Each edge (u, v) will have u ≠ v. **Example**: ```python >>> n = 5 >>> edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4)] >>> find_articulation_points(n, edges) [1, 3] ``` Implement the `find_articulation_points` function: **Important Considerations**: * Ensure to handle the DFS recursively and keep track of discovery and low values of nodes for correctly identifying articulation points. * Take care of edge cases like leaf nodes and graphs with no articulation points efficiently. Good luck!","solution":"from typing import List, Tuple def find_articulation_points(n: int, edges: List[Tuple[int, int]]) -> List[int]: def dfs(u, discovery_time, low, parent, visited, articulation_points, adj): children = 0 visited[u] = True discovery_time[u] = low[u] = dfs.time dfs.time += 1 for v in adj[u]: if not visited[v]: parent[v] = u children += 1 dfs(v, discovery_time, low, parent, visited, articulation_points, adj) low[u] = min(low[u], low[v]) if parent[u] == -1 and children > 1: articulation_points.add(u) if parent[u] != -1 and low[v] >= discovery_time[u]: articulation_points.add(u) elif v != parent[u]: low[u] = min(low[u], discovery_time[v]) adj = [[] for _ in range(n)] for (u, v) in edges: adj[u].append(v) adj[v].append(u) discovery_time = [-1] * n low = [-1] * n parent = [-1] * n visited = [False] * n articulation_points = set() dfs.time = 0 for i in range(n): if not visited[i]: dfs(i, discovery_time, low, parent, visited, articulation_points, adj) return sorted(articulation_points)"},{"question":"# Coding Challenge: You are given a list of transactions performed in a day represented by a list of strings. Each transaction has a unique ID and a numerical value separated by a colon. Your task is to write a function that will detect and remove all fraudulent transactions, where a fraudulent transaction is defined as any transaction whose value is negative. **Function Signature**: ```python def remove_fraudulent_transactions(transactions: List[str]) -> List[str]: # Your code here ``` **Input**: - `transactions`: A list containing strings with the format `ID:Value` where `ID` is a unique identifier consisting of alphanumeric characters, and `Value` is an integer. The length of the transactions list will be `1 <= len(transactions) <= 100` and each transaction string will have a length `1 <= len(transaction) <= 20`. **Output**: - Returns a list of valid transactions (i.e., those that are not fraudulent). **Constraints**: - Each transaction string has the format `ID:Value` where `ID` consists of letters and digits. - `Value` can be a positive or negative integer (e.g., `123`, `-45`). **Example Input and Output**: ```python transactions = [ \\"T1:100\\", \\"T2:-200\\", \\"T3:300\\", \\"T4:-50\\", \\"T5:600\\" ] print(remove_fraudulent_transactions(transactions)) # Expected output -> [\'T1:100\', \'T3:300\', \'T5:600\'] ``` **Explanation**: From the given list of transactions, the transactions \\"T2:-200\\" and \\"T4:-50\\" are considered fraudulent because they have negative values. The function should return the remaining valid transactions [\'T1:100\', \'T3:300\', \'T5:600\']. **Requirements**: - Implement the function from scratch without using additional libraries. - Ensure the function correctly identifies and removes any transactions with negative values.","solution":"from typing import List def remove_fraudulent_transactions(transactions: List[str]) -> List[str]: This function removes all fraudulent transactions from the input list. A fraudulent transaction is defined as any transaction whose value is negative. :param transactions: List of transaction strings in the format \\"ID:Value\\". :return: List of transactions that are not fraudulent. valid_transactions = [] for transaction in transactions: id, value = transaction.split(\':\') if int(value) >= 0: valid_transactions.append(transaction) return valid_transactions"},{"question":"# Temperature Conversion Utility **Scenario**: You are working for a tech company that needs to implement a utility for temperature conversions between Celsius, Fahrenheit, and Kelvin. The company wants to provide accurate and user-friendly conversions for their scientific and industrial applications. **Requirements**: 1. Write a function `convert_temperature(value: float, from_unit: str, to_unit: str) -> float` that takes a temperature value and converts it from one unit to another. The accepted units are \\"C\\" for Celsius, \\"F\\" for Fahrenheit, and \\"K\\" for Kelvin. **Function Signature**: ```python def convert_temperature(value: float, from_unit: str, to_unit: str) -> float: pass ``` **Input/Output**: * `convert_temperature`: * **Input**: * A float `value` representing the temperature. * A string `from_unit` representing the unit of the input temperature (\\"C\\", \\"F\\", or \\"K\\"). * A string `to_unit` representing the unit to which the temperature should be converted (\\"C\\", \\"F\\", or \\"K\\"). * **Output**: * A float representing the converted temperature in the desired unit. **Conversion Formulas**: * Celsius to Fahrenheit: ( F = C times frac{9}{5} + 32 ) * Celsius to Kelvin: ( K = C + 273.15 ) * Fahrenheit to Celsius: ( C = (F - 32) times frac{5}{9} ) * Fahrenheit to Kelvin: ( K = (F - 32) times frac{5}{9} + 273.15 ) * Kelvin to Celsius: ( C = K - 273.15 ) * Kelvin to Fahrenheit: ( F = (K - 273.15) times frac{9}{5} + 32 ) **Constraints**: * The function should handle edge cases and provide meaningful error messages if the input units are invalid or if the conversion cannot be performed. * The floating point computations should be accurate up to 2 decimal places. * Ensure robustness in handling invalid inputs. **Example**: ```python >>> convert_temperature(100.0, \'C\', \'F\') 212.0 >>> convert_temperature(212.0, \'F\', \'C\') 100.0 >>> convert_temperature(0.0, \'C\', \'K\') 273.15 >>> convert_temperature(273.15, \'K\', \'C\') 0.0 >>> convert_temperature(32.0, \'F\', \'K\') 273.15 >>> convert_temperature(273.15, \'K\', \'F\') 32.0 ``` # Additional Notes: Your solution will be evaluated on correctness, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments. Make sure the function handles all edge cases, especially temperatures at critical points (e.g., absolute zero in Kelvin, or freezing and boiling points of water in Celsius and Fahrenheit).","solution":"def convert_temperature(value: float, from_unit: str, to_unit: str) -> float: Converts temperature from one unit to another. Supports conversion between Celsius (C), Fahrenheit (F), and Kelvin (K). :param value: float - the temperature value to be converted :param from_unit: str - the unit of the input temperature (\'C\', \'F\', \'K\') :param to_unit: str - the unit to convert the temperature to (\'C\', \'F\', \'K\') :return: float - the converted temperature value # Helper function to round the final result to two decimal places def round_two_decimals(value): return round(value, 2) # Convert from_unit to Celsius first if from_unit == \'C\': celsius_value = value elif from_unit == \'F\': celsius_value = (value - 32) * 5 / 9 elif from_unit == \'K\': celsius_value = value - 273.15 else: raise ValueError(f\\"Invalid from_unit: {from_unit}. Must be \'C\', \'F\', or \'K\'.\\") # Convert Celsius value to to_unit if to_unit == \'C\': return round_two_decimals(celsius_value) elif to_unit == \'F\': return round_two_decimals(celsius_value * 9 / 5 + 32) elif to_unit == \'K\': return round_two_decimals(celsius_value + 273.15) else: raise ValueError(f\\"Invalid to_unit: {to_unit}. Must be \'C\', \'F\', or \'K\'.\\")"},{"question":"Question Integrating various types of data structures is a common requirement in computational problems to achieve efficient operations. Write a function that merges two sorted linked lists into a single sorted linked list. The linked lists are both sorted in non-decreasing order. # Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: pass ``` # Input * Two `ListNode` objects `l1` and `l2` which are the heads of two sorted linked lists. Each linked list is sorted in non-decreasing order. The nodes contain integers. # Output * A `ListNode` object which is the head of the merged sorted linked list. # Examples ```python # Example 1: # l1: 1 -> 2 -> 4 # l2: 1 -> 3 -> 4 # Result: 1 -> 1 -> 2 -> 3 -> 4 -> 4 l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) merged_list = merge_two_sorted_lists(l1, l2) # Output should be linked list with elements: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # Example 2: # l1: Empty # l2: 0 # Result: 0 l1 = None l2 = ListNode(0) merged_list = merge_two_sorted_lists(l1, l2) # Output should be linked list with element: 0 ``` # Constraints * The number of nodes in both linked lists is in the range `[0, 50]`. * `-100 <= Node.val <= 100` * Both `l1` and `l2` are sorted in non-decreasing order. # Scenario In many applications, linked lists are used due to their efficient insertion and deletion properties. Merging sorted linked lists is a typical operation in merging data sets, such as combining user lists from two different databases. # Notes Implement the function to handle edge cases like one or both lists being empty. The merged list should have all elements in non-decreasing order, guaranteeing sorted sequential access. Efficient merging, rather than resorting to converting the lists, sorting, and reconstructing, is expected.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() # Dummy node to simplify edge cases current = dummy # Pointer to build the merged list while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # Append the remaining elements of l1 or l2 if l1: current.next = l1 elif l2: current.next = l2 # Return the next node of the dummy node which is the head of the merged list return dummy.next"},{"question":"# Problem Statement Develop a function that identifies and returns the length of the longest contiguous subarray where all of its elements have the same value. This problem ensures that you can handle scenarios involving array traversal and comparison to maintain an optimal solution. # Details 1. **Function Name**: `longest_uniform_subarray` 2. **Input**: A list, `arr` with `n` elements where each element is an integer. 3. **Output**: An integer representing the length of the longest contiguous subarray with identical elements. 4. **Constraints**: - 0 <= n <= 10^5 - The elements in the array can be any integers within the range of 32-bit signed integers. # Expectations: * **Correctness**: The function should correctly identify the longest contiguous subarray of identical elements. * **Performance**: The solution should run in O(n) time and use O(1) space. * **Edge Cases**: Consider empty arrays and arrays where no repeating elements exist. # Example ```python def longest_uniform_subarray(arr: list) -> int: # Your implementation here assert longest_uniform_subarray([1, 1, 2, 2, 2, 3, 3, 3, 3]) == 4 assert longest_uniform_subarray([5, 5, 5, 5, 5]) == 5 assert longest_uniform_subarray([10, 9, 8, 7]) == 1 assert longest_uniform_subarray([]) == 0 assert longest_uniform_subarray([7]) == 1 ``` # Code Constraints * You must implement the solution without using any additional libraries. * The solution must account for the edge cases and handle large input sizes efficiently.","solution":"def longest_uniform_subarray(arr): Returns the length of the longest contiguous subarray where all of its elements have the same value. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_len += 1 else: if current_len > max_len: max_len = current_len current_len = 1 return max(current_len, max_len)"},{"question":"File Content Hashing You are required to implement functions that calculate the MD5 hash of a file and compare the hashes of multiple files to find duplicates. Your implementation should include the following methods: 1. **calculate_md5_hash()**: Computes the MD5 hash for a single file. 2. **find_duplicate_files()**: Identifies duplicate files based on their MD5 hashes. Function Signatures: 1. `def calculate_md5_hash(file_path: str) -> str` 2. `def find_duplicate_files(file_paths: List[str]) -> List[List[str]]` Description: - `calculate_md5_hash(file_path: str)`: This function accepts a string representing the path to a file and returns the MD5 hash as a hexadecimal string. Handle any file-read exceptions appropriately. - `find_duplicate_files(file_paths: List[str])`: This function accepts a list of file paths and returns a list of lists, where each sublist contains file paths of files that are duplicates (i.e., having the same MD5 hash). Example: ```python >>> calculate_md5_hash(\'file1.txt\') \'d41d8cd98f00b204e9800998ecf8427e\' >>> file_paths = [\'file1.txt\', \'file2.txt\', \'duplicate1.txt\', \'duplicate2.txt\'] >>> find_duplicate_files(file_paths) [[\'file1.txt\', \'duplicate1.txt\'], [\'file2.txt\', \'duplicate2.txt\']] ``` Notes: - Ensure efficient handling for large files by reading in chunks. - Consider edge cases like empty files or non-existent file paths. - Utilize the `hashlib` library for generating MD5 hashes. - Each list returned in `find_duplicate_files` should contain paths of one set of duplicate files only.","solution":"import hashlib from typing import List, Dict def calculate_md5_hash(file_path: str) -> str: Compute the MD5 hash for a given file. Parameters: file_path (str): The path to the file. Returns: str: The MD5 hash of the file content as a hexadecimal string. md5_hash = hashlib.md5() try: with open(file_path, \'rb\') as file: while chunk := file.read(8192): md5_hash.update(chunk) except FileNotFoundError: return None return md5_hash.hexdigest() def find_duplicate_files(file_paths: List[str]) -> List[List[str]]: Identifies duplicate files based on their MD5 hashes. Parameters: file_paths (List[str]): List of file paths. Returns: List[List[str]]: List of lists, where each sublist contains paths of duplicate files. hash_map: Dict[str, List[str]] = {} duplicates = [] for file_path in file_paths: file_hash = calculate_md5_hash(file_path) if file_hash: if file_hash in hash_map: hash_map[file_hash].append(file_path) else: hash_map[file_hash] = [file_path] for paths in hash_map.values(): if len(paths) > 1: duplicates.append(paths) return duplicates"},{"question":"# Network Connection Stability You are creating a function to determine if a network of computers is stable based on their connections. A network is considered stable if every computer can communicate with every other computer either directly or indirectly through other computers. You are given a list of connections where each connection is represented as a tuple of two integers `(a, b)`, indicating a bidirectional connection between computer `a` and computer `b`. You must write a function `is_network_stable(n: int, connections: List[Tuple[int, int]]) -> bool` that takes an integer `n` representing the number of computers (labeled `0` through `n-1`) and a list of tuples `connections` representing the network connections, and returns a boolean indicating whether the network is stable. # Function Signature ```python def is_network_stable(n: int, connections: List[Tuple[int, int]]) -> bool: pass ``` # Input - `n`: A positive integer representing the number of computers, `1 <= n <= 10^4`. - `connections`: A list of tuples, each containing two integers, representing the connections between computers. There can be up to `100,000` connections. # Output - A boolean value: `True` if the network is stable, `False` otherwise. # Examples ```python print(is_network_stable(3, [(0, 1), (1, 2)])) # Expected output: True print(is_network_stable(4, [(0, 1), (2, 3)])) # Expected output: False print(is_network_stable(1, [])) # Expected output: True print(is_network_stable(5, [(0, 1), (1, 2), (2, 3), (3, 4), (0, 4)])) # Expected output: True ``` # Constraints - The maximum number of computers (`n`) will not exceed `10,000`. - The total number of connections will not exceed `100,000`. - Ensure your solution is efficient and can handle the upper limits of constraints. # Notes - You can use graph traversal techniques like Depth-First Search (DFS) or Breadth-First Search (BFS) to determine the connectivity of the network. - Consider edge cases where there may be isolated computers with no connections at all.","solution":"from typing import List, Tuple def is_network_stable(n: int, connections: List[Tuple[int, int]]) -> bool: def dfs(node, visited, adj_list): stack = [node] while stack: current = stack.pop() for neighbor in adj_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # If there are no computers or just one, it\'s trivially stable if n <= 1: return True # Create adjacency list adj_list = {i: [] for i in range(n)} for a, b in connections: adj_list[a].append(b) adj_list[b].append(a) # Perform DFS starting from the first computer visited = set() dfs(0, visited, adj_list) # Check if all computers are visited return len(visited) == n"},{"question":"**Data Analysis on Student Records** As part of a student information management system, you are tasked to develop a set of data analysis functions to handle student records. Each student record includes details such as student ID, name, scores across multiple subjects, and their attendance percentage. **Objective:** Complete the missing implementation for the following functions to perform data analysis on the student dataset, ensuring that the analysis pipeline functions end-to-end. **Requirements:** 1. **Calculate Average Scores**: - Implement a function that calculates the average score for each student across all subjects. - Refer to `calculate_average_scores`. 2. **Classify Students based on Attendance**: - Implement a function that classifies students into \'Regular\' and \'Irregular\' based on a given attendance threshold. - Refer to `classify_attendance`. 3. **Identify Top Performers**: - Implement a function that identifies the top N performers based on their average scores. - Refer to `top_performers`. 4. **Failed Subjects Identification**: - Implement a function that detects subjects in which a student has failed (score below passing threshold). - Refer to `failed_subjects`. 5. **Grade Calculation**: - Calculate the grade of each student based on the overall average score using standard grade thresholds. - Refer to `calculate_grade`. **Function Signatures**: ```python from typing import List, Dict, Tuple def calculate_average_scores(records: List[Dict[str, any]]) -> Dict[str, float]: # Implement the function to calculate average scores for each student pass def classify_attendance(records: List[Dict[str, any]], threshold: float) -> Dict[str, str]: # Implement the function to classify attendance pass def top_performers(records: List[Dict[str, any]], n: int) -> List[str]: # Implement the function to identify top performers pass def failed_subjects(records: List[Dict[str, any]], passing_threshold: float) -> Dict[str, List[str]]: # Implement the function to identify failed subjects for each student pass def calculate_grade(records: List[Dict[str, any]], grade_thresholds: Dict[str, float]) -> Dict[str, str]: # Implement the function to calculate grades based on average score pass ``` **Input and Output**: Input: 1. A list of student records. 2. An attendance threshold for classification. 3. The number of top performers to identify. 4. A score threshold to determine failed subjects. 5. Grade thresholds for grade calculation. Output: 1. A dictionary mapping student IDs to their average scores. 2. A dictionary classifying students based on attendance. 3. A list of student IDs of top performers. 4. A dictionary mapping student IDs to the subjects they failed. 5. A dictionary mapping student IDs to their grades. **Constraints**: - Student records will be provided in valid format. - The number of top performers to be identified will always be less than or equal to the number of students. **Example**: ```python records = [ {\\"student_id\\": \\"S1\\", \\"name\\": \\"Alice\\", \\"scores\\": {\\"math\\": 85, \\"science\\": 90, \\"english\\": 78}, \\"attendance\\": 95}, {\\"student_id\\": \\"S2\\", \\"name\\": \\"Bob\\", \\"scores\\": {\\"math\\": 65, \\"science\\": 70, \\"english\\": 60}, \\"attendance\\": 85}, {\\"student_id\\": \\"S3\\", \\"name\\": \\"Charlie\\", \\"scores\\": {\\"math\\": 45, \\"science\\": 56, \\"english\\": 72}, \\"attendance\\": 75}, ] attendance_threshold = 80 n = 2 passing_threshold = 50 grade_thresholds = {\\"A\\": 90, \\"B\\": 80, \\"C\\": 70, \\"D\\": 60, \\"F\\": 0} average_scores = calculate_average_scores(records) attendance_classification = classify_attendance(records, attendance_threshold) top_performers_list = top_performers(records, n) failed_subjects_list = failed_subjects(records, passing_threshold) grades = calculate_grade(records, grade_thresholds) ``` Output: ``` average_scores: {\'S1\': 84.33, \'S2\': 65.00, \'S3\': 57.67} attendance_classification: {\'S1\': \'Regular\', \'S2\': \'Regular\', \'S3\': \'Irregular\'} top_performers_list: [\'S1\', \'S2\'] failed_subjects_list: {\'S1\': [], \'S2\': [], \'S3\': [\'math\', \'science\']} grades: {\'S1\': \'B\', \'S2\': \'D\', \'S3\': \'D\'} ```","solution":"from typing import List, Dict, Any def calculate_average_scores(records: List[Dict[str, Any]]) -> Dict[str, float]: Calculates the average score for each student across all subjects. Args: records: List of student records, where each record is a dictionary. Returns: A dictionary mapping student IDs to their average scores. averages = {} for record in records: student_id = record[\'student_id\'] scores = record[\'scores\'] average_score = sum(scores.values()) / len(scores) averages[student_id] = round(average_score, 2) return averages def classify_attendance(records: List[Dict[str, Any]], threshold: float) -> Dict[str, str]: Classifies students into \'Regular\' and \'Irregular\' based on a given attendance threshold. Args: records: List of student records. threshold: The attendance percentage threshold. Returns: A dictionary mapping student IDs to their attendance classification. classification = {} for record in records: student_id = record[\'student_id\'] attendance = record[\'attendance\'] classification[student_id] = \'Regular\' if attendance >= threshold else \'Irregular\' return classification def top_performers(records: List[Dict[str, Any]], n: int) -> List[str]: Identifies the top N performers based on their average scores. Args: records: List of student records. n: Number of top performers to identify. Returns: A list of student IDs of the top performers. averages = calculate_average_scores(records) sorted_students = sorted(averages, key=lambda x: averages[x], reverse=True) return sorted_students[:n] def failed_subjects(records: List[Dict[str, Any]], passing_threshold: float) -> Dict[str, List[str]]: Detects subjects in which a student has failed. Args: records: List of student records. passing_threshold: The score threshold below which a student is considered to have failed. Returns: A dictionary mapping student IDs to the list of subjects they failed. failed = {} for record in records: student_id = record[\'student_id\'] scores = record[\'scores\'] failed_subjects_list = [subject for subject, score in scores.items() if score < passing_threshold] failed[student_id] = failed_subjects_list return failed def calculate_grade(records: List[Dict[str, Any]], grade_thresholds: Dict[str, float]) -> Dict[str, str]: Calculates the grade of each student based on the overall average score using standard grade thresholds. Args: records: List of student records. grade_thresholds: A dictionary mapping grades to their minimum average score. Returns: A dictionary mapping student IDs to their grades. averages = calculate_average_scores(records) grades = {} for student_id, average in averages.items(): for grade, threshold in sorted(grade_thresholds.items(), key=lambda x: x[1], reverse=True): if average >= threshold: grades[student_id] = grade break return grades"},{"question":"# Problem Statement The following problem involves implementing a function that computes the product of all elements in a given range within an array. # Scenario You are given an array of integers, and you need to find the product of integers within given ranges multiple times. Each range is defined by a starting and an ending index, inclusive. # Task Write a function `range_product(nums: List[int], ranges: List[Tuple[int, int]]) -> List[int]` that takes an array of integers `nums` and a list of tuples `ranges`, where each tuple contains two integers representing the starting and ending indices of the array. The function should return a list of products, each corresponding to the product of elements in the respective range. # Input * `nums` (List[int]): A list of integers representing the array. * `ranges` (List[Tuple[int, int]]): A list of tuples, each containing two integers `start` and `end`, representing the range of indices. # Output * Returns a list of integers where each integer is the product of elements in the respective range. # Constraints * The length of `nums` will be between 1 and 10000. * The length of `ranges` will be between 1 and 500. * Each range will have valid indices within the bounds of `nums`. * Elements of `nums` can be any integer between -100 and 100. * Values of `start` and `end` are inclusive and `start` ≤ `end`. # Examples ```python assert range_product([1, 2, 3, 4, 5], [(0, 2), (1, 3), (2, 4)]) == [6, 24, 60] assert range_product([-2, 4, -1, 3, 5], [(0, 1), (1, 4), (2, 3)]) == [-8, -60, -3] assert range_product([5, 10, 15, 20], [(0, 0), (0, 3), (2, 3)]) == [5, 15000, 300] ``` # Notes The function should handle edge cases such as: * Ranges that encompass only one element. * Negative and zero values within the array. * Large arrays with multiple query ranges efficiently. # Requirements Your implementation should aim to minimize redundant computations and optimize performance as much as possible.","solution":"from typing import List, Tuple def range_product(nums: List[int], ranges: List[Tuple[int, int]]) -> List[int]: Returns the product of integers within given ranges of an array. Parameters: nums (List[int]): List of integers. ranges (List[Tuple[int, int]]): List of tuples, each containing the start and end indices. Returns: List[int]: List of products for each range. products = [] for start, end in ranges: product = 1 for i in range(start, end + 1): product *= nums[i] products.append(product) return products"},{"question":"# Stack Implementation Using Linked List Implement a stack data structure using a singly linked list. Your implementation should include the following methods: 1. `push(value: int) -> None`: Adds an integer `value` to the top of the stack. 2. `pop() -> int`: Removes the integer from the top of the stack and returns it. If the stack is empty, raise an `IndexError` with the message \\"pop from empty stack\\". 3. `peek() -> int`: Returns the integer at the top of the stack without removing it. If the stack is empty, raise an `IndexError` with the message \\"peek from empty stack\\". 4. `is_empty() -> bool`: Returns `True` if the stack is empty, `False` otherwise. 5. `size() -> int`: Returns the number of elements in the stack. # Input Format * The methods will be called using an instance of your stack implementation. # Output Format * The output of `pop()` and `peek()` methods are integers. * For `is_empty()`, the output is a boolean. * The `size()` method outputs an integer. # Examples ```python stack = Stack() stack.push(10) stack.push(20) assert stack.peek() == 20 assert stack.pop() == 20 assert stack.size() == 1 assert stack.is_empty() == False stack.pop() assert stack.is_empty() == True try: stack.pop() except IndexError as e: assert str(e) == \\"pop from empty stack\\" ``` # Guidelines 1. Implement the stack using a class `Stack` and a helper class `Node` if needed. 2. The stack should operate with a constant time complexity O(1) for `push` and `pop` operations. 3. Ensure proper error handling for empty stack scenarios.","solution":"class Node: def __init__(self, value: int, next=None): self.value = value self.next = next class Stack: def __init__(self): self.top = None self._size = 0 def push(self, value: int) -> None: new_node = Node(value, self.top) self.top = new_node self._size += 1 def pop(self) -> int: if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.top.value self.top = self.top.next self._size -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.top.value def is_empty(self) -> bool: return self._size == 0 def size(self) -> int: return self._size"},{"question":"# Priority Queue with Custom Comparator Overview: You are given a list of tasks, where each task is represented as a tuple containing two elements: an identifier and a priority value. Your task is to implement a Priority Queue that orders tasks according to the priority value in descending order. Additionally, if two tasks have the same priority, they should be ordered based on their identifier in ascending order. Function Signature: ```python import heapq from typing import List, Tuple class PriorityQueue: def __init__(self): self.heap = [] def push(self, task: Tuple[int, int]) -> None: # Code to add a task to the priority queue def pop(self) -> Tuple[int, int]: # Code to remove and return the highest priority task def process_tasks(tasks: List[Tuple[int, int]]) -> List[Tuple[int, int]]: # Code to process tasks using the PriorityQueue ``` Input: - `tasks`: A list of tuples where each tuple contains an integer identifier and an integer priority value. Output: - A list of tasks (tuples) ordered according to the specified priority rules. Constraints: - Identifiers are non-negative integers. - Priority values are integers (they can be negative). - The list of tasks can be of any length but contains at least one task. Example: ```python input: [(1, 4), (2, 3), (3, 4), (4, 2), (5, 4), (6, 1)] output: [(1, 4), (3, 4), (5, 4), (2, 3), (4, 2), (6, 1)] input: [(10, 2), (3, 2), (6, 5), (8, 2), (5, 1)] output: [(6, 5), (3, 2), (8, 2), (10, 2), (5, 1)] ``` Requirements: 1. Create a class `PriorityQueue` with methods `push` and `pop` to handle tasks. 2. Ensure that the `push` method adds tasks to the priority queue according to the priority rules. 3. Ensure that the `pop` method removes tasks from the priority queue in the correct order. 4. Use the `PriorityQueue` class to process the input task list and return the tasks in the desired order. Scenario: You\'re working for a project management software company that needs a priority queue to efficiently manage incoming tasks. Each task has a priority level and a unique identifier. The highest priority tasks should be processed first, and among tasks with the same priority, the task with the smaller identifier should be processed first. Your goal is to implement this functionality in a way that handles dynamic task additions and processes tasks according to the specified rules.","solution":"import heapq from typing import List, Tuple class PriorityQueue: def __init__(self): self.heap = [] def push(self, task: Tuple[int, int]) -> None: # Use (-priority, identifier) to ensure max-heap based on priority heapq.heappush(self.heap, (-task[1], task[0])) def pop(self) -> Tuple[int, int]: # Pop the task with highest priority (max-heap functionality) priority, identifier = heapq.heappop(self.heap) return (identifier, -priority) def process_tasks(tasks: List[Tuple[int, int]]) -> List[Tuple[int, int]]: pq = PriorityQueue() for task in tasks: pq.push(task) result = [] while len(pq.heap) > 0: result.append(pq.pop()) return result"},{"question":"# Binary Search Tree (BST) Inversion You are required to implement a function that inverts a given Binary Search Tree (BST). Inverting a BST means swapping the left and right children of all nodes in the tree. Function Signature ```python def invert_bst(root) -> TreeNode: pass ``` Input: - `root`: The root node of the BST (or `None` if the tree is empty). Output: - Returns the root node of the inverted BST. Constraints: - The BST has at most (10^4) nodes. - Node values are unique. - Each node in the BST has the following structure: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Requirements: - The function should invert the tree in-place without using extra space for another tree. - The function should be efficient with a time complexity of ( O(n) ), where ( n ) is the number of nodes in the tree. Example: ```python # Example TreeNode class definition for testing: class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def print_tree_inorder(root): if root: print_tree_inorder(root.left) print(root.val, end=\' \') print_tree_inorder(root.right) # Create a sample BST: # 4 # / # 2 6 # / / # 1 3 5 7 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(6, TreeNode(5), TreeNode(7)) # Call the invert_bst function inverted_root = invert_bst(root) # The tree should be inverted to: # 4 # / # 6 2 # / / # 7 5 3 1 print_tree_inorder(inverted_root) # Expected output: 7 6 5 4 3 2 1 ``` Scenario: Imagine you are working on an application that requires manipulating a BST by mirroring its structure. By inverting the BST, you enable functionalities that reflect the symmetry of the tree, allowing for diverse traversal and search operations. Implement the `invert_bst` function to facilitate such requirements.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_bst(root) -> TreeNode: Inverts a given BST by swapping the left and right children of all nodes. Parameters: root (TreeNode): The root node of the BST. Returns: TreeNode: The root node of the inverted BST. if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively call the function on the left and right subtrees invert_bst(root.left) invert_bst(root.right) return root"},{"question":"# Task You are asked to implement a function in a class that calculates the moving average of the last `n` elements added to a data stream. This function should efficiently keep track of the last `n` elements and compute their average whenever a new element is added. # Function Signature ```python class MovingAverage: def __init__(self, size: int): ... def next(self, val: int) -> float: ... ``` # Input - `size` (int): The number of recent elements to consider for the moving average. - `val` (int): The new integer to add to the data stream. # Constraints: - The class should handle calls to `next` in constant time, O(1). - The maximum value for `size` is `10^4`. - The ranges for `val` and the number of calls to `next` are both within the range of a typical 32-bit signed integer. - Moving average calculations should use floating-point precision. # Output - The function `next` should return the moving average of the last `n` values after adding the new element as a float. # Example ```python >>> ma = MovingAverage(3) >>> ma.next(1) 1.0 >>> ma.next(10) 5.5 >>> ma.next(3) 4.666666666666667 >>> ma.next(5) 6.0 ``` # Considerations: - Ensure efficient management of the data within the given size constraint. - Handle edge cases such as when fewer than `n` elements have been added to the stream. - Consider how the class will maintain the sum and count of the last `n` elements to compute the average efficiently. # Hint: - Use a queue or another fixed-size data structure to keep track of the elements in the moving window. - Maintain a running sum of the elements in the moving window to speed up average calculations.","solution":"from collections import deque class MovingAverage: def __init__(self, size: int): Initialize the MovingAverage with a fixed size for the window. self.size = size self.queue = deque() self.sum = 0 def next(self, val: int) -> float: Add a new value to the stream and return the moving average of the last \'size\' values. if len(self.queue) == self.size: self.sum -= self.queue.popleft() self.queue.append(val) self.sum += val return self.sum / len(self.queue)"},{"question":"# Question: You are working on enhancing the functionality of a database management system. One critical component that needs optimization is the function responsible for finding the nearest value in a sorted list of numbers when a new number is inserted. Your task is to optimize the insertion and nearest value finding operation so that it maintains the sorted order efficiently. Function Signature: ```python def insert_and_find_nearest(sorted_list: List[int], num: int) -> int: ``` # Requirements: 1. Insert the given number `num` into the `sorted_list` while maintaining the sorted order. 2. Find and return the nearest value to `num` in the modified sorted list. 3. Ensure the operation is performed efficiently and handles edge cases such as: - Empty `sorted_list`. - Duplicate values in the list. 4. Validate correctness using the provided test cases and create additional tests if necessary. # Expected input and output formats: - **Input**: A sorted list of integers and a single integer to be inserted. - **Output**: The value from the updated sorted list which is nearest to the inserted integer. # Performance requirements: - **Aim for O(log n)** time complexity for the insertion operation and nearest value finding, where `n` is the length of the sorted list. # Sample Test Cases: ```python assert insert_and_find_nearest([1, 3, 5, 7], 4) == 3 assert insert_and_find_nearest([2, 4, 6, 8], 5) == 4 assert insert_and_find_nearest([], 10) == 10 ``` # Additional Context: - Utilize efficient insertion algorithms for sorted lists such as binary search. - Ensure that the solution does not excessively traverse the list, maintaining the desired performance. This question seamlessly fits into a coding assessment focused on algorithm optimization and efficient data management techniques.","solution":"from typing import List def insert_and_find_nearest(sorted_list: List[int], num: int) -> int: # Helper function to find the insertion point using binary search def binary_search_insert_position(lst, x): lo, hi = 0, len(lst) while lo < hi: mid = (lo + hi) // 2 if lst[mid] < x: lo = mid + 1 else: hi = mid return lo # Find the position to insert the number pos = binary_search_insert_position(sorted_list, num) sorted_list.insert(pos, num) # Insert the number at the correct position # Determine the nearest value to the inserted number if pos == 0: return sorted_list[1] if len(sorted_list) > 1 else num elif pos == len(sorted_list) - 1: return sorted_list[-2] else: left_diff = num - sorted_list[pos - 1] right_diff = sorted_list[pos + 1] - num if left_diff <= right_diff: return sorted_list[pos - 1] else: return sorted_list[pos + 1]"},{"question":"# Scenario As a developer, you are tasked with designing a URL shortening service similar to bit.ly or tinyurl.com. The service should generate unique shortened URLs for long URLs and provide the ability to retrieve the original URL when given the shortened version. # Task Implement a URL shortening service that efficiently handles URL creation and retrieval. Your implementation should: 1. Generate a unique shortened URL for each provided long URL. 2. Retrieve the original long URL when provided with the shortened version. 3. Ensure the shortened URLs are as short as possible while maintaining uniqueness. 4. Store the URL mappings in a persistent manner. 5. Handle collisions and edge cases gracefully. # Function Signature ```python class URLShortener: def __init__(self): # Initialize necessary data structures here pass def shorten(self, long_url: str) -> str: Generates a unique shortened URL for the provided long URL. Args: long_url (str): The original long URL to be shortened. Returns: str: The shortened URL. # Your implementation here def retrieve(self, short_url: str) -> str: Retrieves the original long URL given the shortened version. Args: short_url (str): The shortened URL. Returns: str: The original long URL. # Your implementation here ``` # Explanation 1. **long_url**: The original URL that needs to be shortened. 2. **short_url**: The shortened version of the URL that will be generated and used to retrieve the original URL. # Constraints - The length of the shortened URL should be minimized. - Handle up to 10,000 unique URL mappings. - Ensure that the shortened URL remains unique across different requests. - Provide meaningful error messages for invalid or non-existent shortened URLs. # Example ```python # Initialize the URL shortener service url_shortener = URLShortener() # Shorten a long URL short_url = url_shortener.shorten(\\"https://www.example.com/some/very/long/url/path\\") print(short_url) # Output: a shortened URL like \\"http://short.url/abc123\\" # Retrieve the original long URL original_url = url_shortener.retrieve(short_url) print(original_url) # Output: \\"https://www.example.com/some/very/long/url/path\\" ``` # Notes - Consider using techniques such as hashing, encoding, or base conversion to generate shortened URLs. - Think about how you would store the URL mappings (e.g., using a database or in-memory data structure). - Ensure that the service remains performant and scalable for a high number of requests.","solution":"import hashlib import string import random class URLShortener: def __init__(self): self.long_to_short = {} self.short_to_long = {} self.charset = string.ascii_letters + string.digits self.base_url = \\"http://short.url/\\" self.code_length = 6 def _generate_short_code(self): return \'\'.join(random.choice(self.charset) for _ in range(self.code_length)) def shorten(self, long_url: str) -> str: Generates a unique shortened URL for the provided long URL. Args: long_url (str): The original long URL to be shortened. Returns: str: The shortened URL. if long_url in self.long_to_short: return self.long_to_short[long_url] while True: short_code = self._generate_short_code() short_url = self.base_url + short_code if short_url not in self.short_to_long: self.long_to_short[long_url] = short_url self.short_to_long[short_url] = long_url break return short_url def retrieve(self, short_url: str) -> str: Retrieves the original long URL given the shortened version. Args: short_url (str): The shortened URL. Returns: str: The original long URL. if short_url in self.short_to_long: return self.short_to_long[short_url] else: raise KeyError(\\"Short URL not found\\")"},{"question":"# Problem Statement You are required to implement a function `serialize_matrix(matrix: List[List[int]]) -> str` that converts a 2D matrix into a single string where each row of the matrix is serialized and concatenated in a comma-separated format. Each row in the matrix should be separated by a new line character. # Input Format * A 2D list `matrix` of integers: * `matrix[i][j]` (0 <= matrix[i][j] <= 10^4) # Output Format * A string representation of the 2D matrix. # Constraints * The input 2D matrix can have dimensions: * 1 <= number of rows <= 1000 * 1 <= number of columns <= 1000 # Detailed Explanation * Serialize each row of the matrix as a comma-separated string of integers. * Concatenate these serialized rows with new line characters in between them. * Edge cases to consider: empty matrix, varying number of columns. # Performance Requirements * The solution should be efficient with respect to both time and space, considering the constraints on the input matrix size. # Example ```python from typing import List def serialize_matrix(matrix: List[List[int]]) -> str: result = [] for row in matrix: result.append(\\",\\".join(map(str, row))) return \\"n\\".join(result) # Test case print(serialize_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])) # Expected output: # 1,2,3 # 4,5,6 # 7,8,9 print(serialize_matrix([[10, 20], [30, 40], [50]])) # Expected output: # 10,20 # 30,40 # 50 ``` # Notes * Ensure to include thorough tests for edge cases, particularly for matrices with varying column lengths and empty matrices. Validate that the function handles these cases correctly. This additional question maintains the style, complexity, and scope of the provided sample question by focusing on a fundamental concept (string manipulation in this case) and requiring a clear understanding of iterating and formatting within typical coding problem constraints.","solution":"from typing import List def serialize_matrix(matrix: List[List[int]]) -> str: result = [] for row in matrix: result.append(\\",\\".join(map(str, row))) return \\"n\\".join(result)"},{"question":"# Coding Assessment Question Word Ladder Transformation You are developing a word game and one of the challenges involves transforming a given start word into an end word using a set of allowed intermediate words. Each transformation changes exactly one character at a time, and each intermediate word must exist in a given dictionary of words. **Task**: Write a Python function `word_ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int` that determines the minimum number of transformations needed to convert `beginWord` into `endWord`. If the transformation is not possible, return 0. **Parameters**: - `beginWord` (str): The starting word. - `endWord` (str): The word that we want to reach. - `wordList` (List[str]): A list of allowed words for transformation. **Return**: - (int): The minimum number of transformations needed to convert `beginWord` into `endWord`. **Input Constraints**: - All words have the same length. - All words will be lowercase letters. - The length of `beginWord` and `endWord` is at most 100. - There will be no duplicate words in `wordList`. - The maximum length of `wordList` is 5000. **Performance Requirement**: Your solution should be efficient and handle the provided constraints effectively. Example: ```python def word_ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: pass # Example Usage assert word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\",\\"cog\\"]) == 5 assert word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\",\\"dot\\",\\"dog\\",\\"lot\\",\\"log\\"]) == 0 ``` Explanation: - In the first example, the transformation sequence is \\"hit\\" -> \\"hot\\" -> \\"dot\\" -> \\"dog\\" -> \\"cog\\". There are 5 transformations. - In the second example, it is impossible to reach \\"cog\\" from \\"hit\\" using the provided word list, so the return value is 0.","solution":"from collections import deque from typing import List def word_ladder_length(beginWord: str, endWord: str, wordList: List[str]) -> int: if endWord not in wordList: return 0 word_set = set(wordList) queue = deque([(beginWord, 1)]) while queue: current_word, level = queue.popleft() if current_word == endWord: return level for i in range(len(current_word)): for c in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + c + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, level + 1)) return 0"},{"question":"# Coding Assessment Question **Scenario**: You have been asked to implement additional functionality to the provided `BinarySearchTree` class to enhance its capabilities and enable efficient data operations. Specifically, you need to add a method to calculate the height of the tree, implement an in-order traversal method, and ensure it handles different types of input correctly. **Requirements**: 1. **Tree Height Calculation**: Add a method to compute the height of the binary search tree. 2. **In-Order Traversal**: Implement a method to perform an in-order traversal of the tree and return the elements in sorted order. 3. **Edge Case Handling**: Ensure edge cases, such as an empty tree and a tree with a single node, are managed appropriately. **Function Implementation**: 1. **height() -> int** - No parameters. - Returns the height of the binary search tree. The height of a tree is the number of edges from the root to the deepest leaf node. 2. **in_order_traversal() -> list** - No parameters. - Performs an in-order traversal of the tree and returns a list of elements in sorted order. 3. **test edge cases**: - Ensure your solution handles trees with no nodes (empty tree) and trees with a single node correctly. **Input**: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(3) bst.insert(7) bst.insert(12) bst.insert(20) ``` **Output**: ```python # Tree height: 3 # In-order traversal: [3, 5, 7, 10, 12, 15, 20] ``` **Constraints**: - The binary search tree can contain up to 1000 nodes. - Tree node values are unique integers. - Ensure robustness and correctness by validating your solution with various edge cases and input scenarios. **Class Structure**: Here is a basic structure to start with for the `BinarySearchTree` and `TreeNode` classes: ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def height(self): # Implement your height method here pass def in_order_traversal(self): # Implement your in-order traversal method here pass ``` Ensure you validate your implementation with various test cases to confirm its robustness and correctness.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key class BinarySearchTree: def __init__(self): self.root = None def insert(self, key): if self.root is None: self.root = TreeNode(key) else: self._insert(self.root, key) def _insert(self, root, key): if key < root.val: if root.left is None: root.left = TreeNode(key) else: self._insert(root.left, key) else: if root.right is None: root.right = TreeNode(key) else: self._insert(root.right, key) def height(self): return self._height(self.root) def _height(self, node): if node is None: return -1 left_height = self._height(node.left) right_height = self._height(node.right) return 1 + max(left_height, right_height) def in_order_traversal(self): elements = [] self._in_order_traversal(self.root, elements) return elements def _in_order_traversal(self, root, elements): if root: self._in_order_traversal(root.left, elements) elements.append(root.val) self._in_order_traversal(root.right, elements)"},{"question":"# Coding Assessment Question Problem Statement You are tasked with implementing a utility function for converting temperatures between Celsius, Fahrenheit, and Kelvin scales. Your objective is to write a function that accepts a temperature value and its current scale, and returns the equivalent temperature value in the target scale. Detailed Description * **Function Name**: `convert_temperature` * **Inputs**: * `temperature` (float): The temperature value to be converted. * `from_scale` (string): The scale of the input temperature value. It can be one of `\\"C\\"`, `\\"F\\"`, `\\"K\\"` representing Celsius, Fahrenheit, and Kelvin respectively. * `to_scale` (string): The scale to which the temperature needs to be converted. It can be one of `\\"C\\"`, `\\"F\\"`, `\\"K\\"` representing Celsius, Fahrenheit, and Kelvin respectively. * **Output**: * Returns the equivalent temperature value in the target scale as a float. * **Constraints**: * The scales `from_scale` and `to_scale` must be one of the strings `\\"C\\"`, `\\"F\\"`, or `\\"K\\"`. * Temperature values in Kelvin must be non-negative. * Raise appropriate exceptions with helpful error messages if the constraints are violated. Formulas The conversions between different temperature scales are given by: * From Celsius (C) to Fahrenheit (F): ( F = frac{9}{5}C + 32 ) * From Fahrenheit (F) to Celsius (C): ( C = frac{5}{9}(F - 32) ) * From Celsius (C) to Kelvin (K): ( K = C + 273.15 ) * From Kelvin (K) to Celsius (C): ( C = K - 273.15 ) Example ```python >>> convert_temperature(0, \\"C\\", \\"F\\") 32.0 >>> convert_temperature(32, \\"F\\", \\"C\\") 0.0 >>> convert_temperature(0, \\"C\\", \\"K\\") 273.15 >>> convert_temperature(273.15, \\"K\\", \\"C\\") 0.0 >>> convert_temperature(32, \\"F\\", \\"K\\") 273.15 >>> convert_temperature(-273.16, \\"C\\", \\"K\\") # invalid temperature Traceback (most recent call last): ... Exception: Temperature value in Kelvin must be non-negative >>> convert_temperature(100, \\"Degree\\", \\"F\\") # invalid scale Traceback (most recent call last): ... Exception: Temperature scales must be one of \'C\', \'F\', or \'K\' ``` Implementation Implement the function in Python, structured as follows: ```python def convert_temperature(temperature: float, from_scale: str, to_scale: str) -> float: Converts temperature between Celsius, Fahrenheit, and Kelvin scales. Arguments: temperature : float : the temperature value to be converted from_scale : str : the scale of the input temperature value to_scale : str : the scale to which the temperature should be converted Returns: float : the equivalent temperature value in the target scale Examples: >>> convert_temperature(0, \\"C\\", \\"F\\") 32.0 >>> convert_temperature(32, \\"F\\", \\"C\\") 0.0 >>> convert_temperature(0, \\"C\\", \\"K\\") 273.15 >>> convert_temperature(273.15, \\"K\\", \\"C\\") 0.0 >>> convert_temperature(32, \\"F\\", \\"K\\") 273.15 >>> convert_temperature(-273.16, \\"C\\", \\"K\\") # invalid temperature Traceback (most recent call last): ... Exception: Temperature value in Kelvin must be non-negative >>> convert_temperature(100, \\"Degree\\", \\"F\\") # invalid scale Traceback (most recent call last): ... Exception: Temperature scales must be one of \'C\', \'F\', or \'K\' valid_scales = {\\"C\\", \\"F\\", \\"K\\"} if from_scale not in valid_scales or to_scale not in valid_scales: raise Exception(\\"Temperature scales must be one of \'C\', \'F\', or \'K\'\\") if from_scale == \\"K\\" and temperature < 0: raise Exception(\\"Temperature value in Kelvin must be non-negative\\") # Convert from any scale to Celsius if from_scale == \\"C\\": celsius_temp = temperature elif from_scale == \\"F\\": celsius_temp = (temperature - 32) * 5 / 9 elif from_scale == \\"K\\": celsius_temp = temperature - 273.15 # Convert from Celsius to the target scale if to_scale == \\"C\\": return celsius_temp elif to_scale == \\"F\\": return celsius_temp * 9 / 5 + 32 elif to_scale == \\"K\\": return celsius_temp + 273.15 ```","solution":"def convert_temperature(temperature: float, from_scale: str, to_scale: str) -> float: Converts temperature between Celsius, Fahrenheit, and Kelvin scales. Arguments: temperature : float : the temperature value to be converted from_scale : str : the scale of the input temperature value (C, F, K) to_scale : str : the scale to which the temperature should be converted (C, F, K) Returns: float : the equivalent temperature value in the target scale Raises: Exception : if invalid temperature scale is provided or if temperature in Kelvin is negative valid_scales = {\\"C\\", \\"F\\", \\"K\\"} if from_scale not in valid_scales or to_scale not in valid_scales: raise Exception(\\"Temperature scales must be one of \'C\', \'F\', or \'K\'\\") if from_scale == \\"K\\" and temperature < 0: raise Exception(\\"Temperature value in Kelvin must be non-negative\\") if from_scale == to_scale: return temperature # Convert from any scale to Celsius if from_scale == \\"C\\": celsius_temp = temperature elif from_scale == \\"F\\": celsius_temp = (temperature - 32) * 5 / 9 elif from_scale == \\"K\\": celsius_temp = temperature - 273.15 # Convert from Celsius to the target scale if to_scale == \\"C\\": return celsius_temp elif to_scale == \\"F\\": return celsius_temp * 9 / 5 + 32 elif to_scale == \\"K\\": return celsius_temp + 273.15"},{"question":"# Coding Problem: Optimal Stock Trading **Context**: You are a software developer at a financial analytics firm. The firm requires an algorithm that helps investors decide the optimal days to buy and sell stocks to maximize profits given a list of stock prices over a series of days. Your task is to write a function that identifies these days, ensuring the maximum profit possible. **Task**: Implement a function `max_profit_days` that calculates the best day to buy and the best day to sell to achieve the highest profit. # Function Signature ```python def max_profit_days(prices: List[int]) -> Tuple[int, int]: pass ``` # Input format * `prices`: A list of integers representing the stock prices over each day. # Output format * Return a tuple of two integers, where the first integer is the best day to buy and the second integer is the best day to sell. # Constraints * `1 <= len(prices) <= 10^5` * All prices are positive integers. * If no profit is possible, return a tuple `(0, 0)`. # Performance Requirements * The function should run in (O(n)) time complexity, where n is the length of the prices list. # Examples ```python assert max_profit_days([7, 1, 5, 3, 6, 4]) == (1, 4) assert max_profit_days([7, 6, 4, 3, 1]) == (0, 0) assert max_profit_days([3, 1, 4, 8, 7, 2]) == (1, 3) ``` # Notes * The days are zero-indexed, so if day 3 is the best day to buy, the output should reflect the day as 3. If all prices decrease each day resulting in no profit, return (0, 0). # Implementation Tip * Iterate through the list while keeping track of the minimum price encountered so far and the maximum profit achievable by comparing the difference between the current price and the minimum price. # Solution ```python from typing import List, Tuple def max_profit_days(prices: List[int]) -> Tuple[int, int]: if not prices: return (0, 0) min_price = float(\'inf\') max_profit = 0 buy_day = sell_day = 0 for i in range(len(prices)): if prices[i] < min_price: min_price = prices[i] buy_day = i potential_profit = prices[i] - min_price if potential_profit > max_profit: max_profit = potential_profit sell_day = i if max_profit == 0: return (0, 0) return (buy_day, sell_day) ``` This function will calculate the optimal trade days by iterating through the price list and keeping track of the minimum purchase price and the maximum achievable profit, ensuring (O(n)) time complexity.","solution":"from typing import List, Tuple def max_profit_days(prices: List[int]) -> Tuple[int, int]: if not prices: return (0, 0) min_price = float(\'inf\') max_profit = 0 buy_day = sell_day = 0 for i in range(len(prices)): if prices[i] < min_price: min_price = prices[i] buy_day = i potential_profit = prices[i] - min_price if potential_profit > max_profit: max_profit = potential_profit sell_day = i if max_profit == 0: return (0, 0) return (buy_day, sell_day)"},{"question":"# Scenario You are developing a utility function for a text processing suite that requires extracting unique words from a piece of text. The function should ignore the case of the words and exclude any punctuation marks. # Task Implement a function `extract_unique_words` that extracts all unique words from the input text, ignoring the case and punctuation. # Function Signature ```python def extract_unique_words(text: str) -> List[str]: Extracts unique words from the input text. :param text: A string containing the input text. :return: A sorted list of unique words (case-insensitive) without punctuation. pass ``` # Input - A string `text` containing the input text which may include various punctuation marks and case variations. # Output - A list of unique words sorted in alphabetical order. # Constraints - The input text will contain at most (10^6) characters. - Words are separated by spaces and punctuation marks include: . , ! ? ; : # Examples Example 1: ```python text = \\"Hello, world! Hello, Python.\\" print(extract_unique_words(text)) # Output: [\'hello\', \'python\', \'world\'] ``` Example 2: ```python text = \\"The quick brown fox jumps over the lazy dog. The quick brown!\\" print(extract_unique_words(text)) # Output: [\'brown\', \'dog\', \'fox\', \'jumps\', \'lazy\', \'over\', \'quick\', \'the\'] ``` # Additional Requirements - The function should handle large text inputs efficiently. - Utilize appropriate data structures to ensure minimal time and space complexity.","solution":"from typing import List import re def extract_unique_words(text: str) -> List[str]: Extracts unique words from the input text. :param text: A string containing the input text. :return: A sorted list of unique words (case-insensitive) without punctuation. # Normalize the text to lowercase text = text.lower() # Use a regular expression to find all words, ignore punctuation words = re.findall(r\'bw+b\', text) # Use a set to get unique words unique_words = set(words) # Return the sorted list of unique words return sorted(unique_words)"},{"question":"# Tree Height Calculator Objective Implement a function `calculate_tree_height` that calculates the height of a binary tree given its node values and structure. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_tree_height(root: TreeNode) -> int: ``` Input Parameters * `root` (TreeNode): The root node of the binary tree. Output * Return an integer representing the height of the binary tree. Constraints * The number of nodes in the tree is in the range [0, 10^4]. * The values of the nodes are integers in the range [-10^5, 10^5]. * A binary tree with a single node has a height of 1. Example ```python # Example 1: # Input: # 1 # / # 2 3 # / # 4 5 root1 = TreeNode(1) root1.left = TreeNode(2) root1.right = TreeNode(3) root1.left.left = TreeNode(4) root1.left.right = TreeNode(5) >>> calculate_tree_height(root1) 3 # Example 2: # Input: # 10 # / # 20 30 # / # 40 50 root2 = TreeNode(10) root2.left = TreeNode(20) root2.right = TreeNode(30) root2.right.left = TreeNode(40) root2.right.right = TreeNode(50) >>> calculate_tree_height(root2) 3 # Example 3: # Input: # 5 root3 = TreeNode(5) >>> calculate_tree_height(root3) 1 ``` Explanation * In the first example, the binary tree has 3 levels: [1], [2, 3], [4, 5]. * In the second example, the binary tree has 3 levels: [10], [20, 30], [40, 50]. * In the third example, the binary tree consists of a single node which is of height 1. Notes * Handle edge cases such as an empty tree (which should return a height of 0) appropriately. * Consider trees with varying degrees of depth and balance to ensure robust solution.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def calculate_tree_height(root: TreeNode) -> int: if not root: return 0 left_height = calculate_tree_height(root.left) right_height = calculate_tree_height(root.right) return max(left_height, right_height) + 1"},{"question":"# Container with Maximum Water Imagine you are given a list of non-negative integers representing the height of walls, where each integer corresponds to the height of a wall at that position. You are tasked with finding two walls that, together with the x-axis, form a container which holds the maximum amount of water. **Problem Statement**: Given an array of integers `height`, implement the `max_area` function to determine the maximum amount of water a container can hold. # Function Signature: ```python def max_area(height: List[int]) -> int: pass ``` # Input: * `height` (List[int]): A list of non-negative integers representing the height of walls. Length of the list can vary between 2 and 10^5. # Output: * Returns an integer that represents the maximum amount of water that can be held by any possible pair of walls. # Constraints: * The input list will contain at least two integers. * All heights are non-negative integers between 0 and 10^4. # Example: ```python # Walls heights are [1,8,6,2,5,4,8,3,7] print(max_area([1,8,6,2,5,4,8,3,7])) # Output: 49 # Walls heights are [1,1] print(max_area([1,1])) # Output: 1 # Walls heights are [4,3,2,1,4] print(max_area([4,3,2,1,4])) # Output: 16 # Walls heights are [1,2,1] print(max_area([1,2,1])) # Output: 2 ``` # Hints: 1. Try to use a two-pointer approach: initialize two pointers, one at the beginning and one at the end of the list. Move the pointers towards the center to find the maximum area. 2. Calculate the area for the current pair of walls and keep track of the maximum area found. 3. Adjust the pointers to attempt to find a larger area: move the pointer pointing to the shorter wall inward since this might result in a taller wall and larger area. # Tests: Provide test cases to cover various scenarios: - Minimum input size. - All heights are equal. - Heights vary significantly. - Heights array with values in decreasing or increasing order. - Large input size to check performance.","solution":"def max_area(height): Finds the maximum amount of water that can be held by any pair of walls. :param height: List of non-negative integers representing wall heights. :return: Integer representing the maximum water area. left, right = 0, len(height) - 1 max_water = 0 while left < right: # Calculate the width between the current pair of walls width = right - left # Calculate the height as the minimum of the two walls min_height = min(height[left], height[right]) # Calculate the current water area current_area = width * min_height # Update the maximum water area max_water = max(max_water, current_area) # Move the pointer that points to the shorter wall inwards if height[left] < height[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Coding Assessment Question **Scenario**: You are building an application for a financial services firm that needs to process and analyze large volumes of transaction data. One of the most critical tasks is to quickly compute the sum of transactions within a specific time range. To achieve this, you decide to implement a function that will quickly return the sum of all transactions that fall within a given range of dates. **Objective**: Implement a function `sum_transactions_in_range(transactions: List[Tuple[str, float]], start_date: str, end_date: str) -> float` that computes the total sum of transaction values within a given date range. The transactions are provided as a list of tuples, each containing a date (formatted as \\"YYYY-MM-DD\\") and a transaction value. **Function signature:** ```python def sum_transactions_in_range(transactions: List[Tuple[str, float]], start_date: str, end_date: str) -> float: # Your code here ``` # Inputs: - `transactions`: A list of tuples where each tuple contains a date (string in \\"YYYY-MM-DD\\" format) and a transaction value (float). - `start_date`: A string representing the start date of the range (inclusive), formatted as \\"YYYY-MM-DD\\". - `end_date`: A string representing the end date of the range (inclusive), formatted as \\"YYYY-MM-DD\\". # Outputs: - A float representing the total sum of transaction values within the specified date range. # Constraints: 1. The `start_date` and `end_date` will always be valid dates and `start_date` will not be after `end_date`. 2. The dates in the transactions list are not necessarily sorted. 3. The transactions list can contain up to 100,000 transactions. 4. Ensure the function handles large inputs efficiently. # Example: ```python transactions = [ (\\"2021-01-01\\", 100.0), (\\"2021-02-01\\", 150.0), (\\"2021-03-01\\", 200.0), (\\"2021-04-01\\", 250.0), (\\"2021-05-01\\", 300.0) ] start_date = \\"2021-02-01\\" end_date = \\"2021-04-01\\" # Should return 600.0 assert sum_transactions_in_range(transactions, start_date, end_date) == 600.0 ``` **Note**: Ensure to handle edge cases where there might be no transactions in the specified date range. Optimize the function to handle large inputs efficiently.","solution":"from typing import List, Tuple from datetime import datetime def sum_transactions_in_range(transactions: List[Tuple[str, float]], start_date: str, end_date: str) -> float: Computes the total sum of transaction values within a given date range. Parameters: transactions (List[Tuple[str, float]]): A list of tuples containing date and transaction value. start_date (str): The start date of the range in \\"YYYY-MM-DD\\" format. end_date (str): The end date of the range in \\"YYYY-MM-DD\\" format. Returns: float: Total sum of transactions within the specified date range. start = datetime.strptime(start_date, \\"%Y-%m-%d\\") end = datetime.strptime(end_date, \\"%Y-%m-%d\\") total_sum = 0.0 for date_str, value in transactions: date = datetime.strptime(date_str, \\"%Y-%m-%d\\") if start <= date <= end: total_sum += value return total_sum"},{"question":"# Problem Description You are given a list of integers and a target sum. Write a function `all_combinations(nums: list[int], target: int) -> list[list[int]]` that returns all unique combinations of elements from the list that add up to the target sum. Elements in the list can be used any number of times, and the combinations should be unique (order of elements does not matter). # Input * `nums`, a list of integers. * `target`, an integer representing the target sum. # Output * A list of lists, where each inner list is a combination of elements from `nums` that add up to the `target`. # Example ```python >>> all_combinations([2, 3, 6, 7], 7) [[2, 2, 3], [7]] >>> all_combinations([2, 3, 5], 8) [[2, 2, 2, 2], [2, 3, 3], [3, 5]] >>> all_combinations([2], 1) [] >>> all_combinations([1], 1) [[1]] ``` # Constraints * Numbers in the `nums` list can be used multiple times in forming the combinations. * The function should avoid duplicate combinations and should consider sets of numbers that are permutation-insensitive (e.g., [2, 3] is considered the same as [3, 2]). * The solution should efficiently handle larger inputs and constraints by utilizing an appropriate algorithm like backtracking with memoization or a dynamic programming approach.","solution":"def all_combinations(nums, target): def backtrack(start, target, path, res): if target < 0: return if target == 0: res.append(list(path)) return for i in range(start, len(nums)): path.append(nums[i]) backtrack(i, target - nums[i], path, res) path.pop() nums.sort() # Sort the numbers to help avoid duplicate combinations res = [] backtrack(0, target, [], res) return res"},{"question":"# Problem Description You are tasked with calculating the roots of a quadratic equation. Given the coefficients `a`, `b`, and `c` of the quadratic equation `ax^2 + bx + c = 0`, your goal is to implement a function to find its real roots (if any). Function: Quadratic Equation Solver Implement `solve_quadratic(a: float, b: float, c: float) -> List[float]`: * **Input**: - `a`: A floating-point number representing the coefficient of `x^2`. - `b`: A floating-point number representing the coefficient of `x`. - `c`: A floating-point number representing the constant term. * **Output**: A list of real roots (floating-point numbers). The list should: - Contain two elements if there are two distinct real roots. - Contain one element if there is exactly one real root. - Be empty if there are no real roots. # Constraints 1. The coefficients `a`, `b`, and `c` will be in the range of (-10^9, 10^9). 2. Ensure to handle the case where `a` can be zero, which reduces the equation to a linear equation `bx + c = 0`. # Example ```python assert solve_quadratic(1, -3, 2) == [2.0, 1.0] # Roots: x = 2 and x = 1 assert solve_quadratic(1, 2, 1) == [-1.0] # Root: x = -1 assert solve_quadratic(1, 0, 1) == [] # No real roots assert solve_quadratic(0, 2, -8) == [4.0] # Root: x = 4 (linear equation) assert solve_quadratic(0, 0, 1) == [] # No roots since the equation \\"1 = 0\\" cannot be true ``` Your task is to handle all these cases correctly: quadratic equations with two roots, one root, and no real roots, as well as linear equations when `a` is zero.","solution":"import math from typing import List def solve_quadratic(a: float, b: float, c: float) -> List[float]: Solves the quadratic equation ax^2 + bx + c = 0 for real roots. Parameters: a (float): Coefficient of x^2 b (float): Coefficient of x c (float): Constant term Returns: List[float]: A list containing real roots. Returns: - Two elements if there are two distinct real roots. - One element if there is exactly one real root. - An empty list if there are no real roots. - An empty list if a and b are zero (undefined equation). if a == 0: # Linear equation case: bx + c = 0 if b == 0: # Equation reduces to c = 0, if c is nonzero, no solution return [] if c != 0 else [] else: # Linear equation bx + c = 0 => x = -c / b return [-c / b] # Calculate the discriminant discriminant = b**2 - 4*a*c if discriminant > 0: # Two distinct real roots root1 = (-b + math.sqrt(discriminant)) / (2 * a) root2 = (-b - math.sqrt(discriminant)) / (2 * a) return [root1, root2] elif discriminant == 0: # One real root root = -b / (2 * a) return [root] else: # No real roots return []"},{"question":"# Question: Determine Presence of a Cycle in a Directed Graph Context In graph theory, detecting cycles in a directed graph is a fundamental task that can have significant implications in various applications such as detecting deadlocks in operating systems, verifying dependencies in task scheduling, and ensuring data integrity in databases. A cycle in a directed graph is a path that starts and ends at the same vertex, with all edges directed in the sequential order. Your objective is to implement a function to check whether a given directed graph contains a cycle. You will use Depth-First Search (DFS) to perform this check. Requirements Implement the following function: 1. `has_cycle(graph: Dict[int, List[int]]) -> bool`: * Use depth-first search to determine if the graph contains a cycle. * Input: `graph` - An adjacency list representing the directed graph. * Output: `True` if the graph contains a cycle, `False` otherwise. Constraints - The graph can contain up to `10^5` nodes and `10^6` edges. - Node identifiers are integers (both positive and negative). - An empty graph is considered to have no cycles. - Consider all possible edge cases, including disconnected components and invalid node identifiers. Example ```python from collections import defaultdict def has_cycle(graph): def dfs(node): if visiting[node]: # Node is being visited, so we found a cycle return True if visited[node]: # Node already completely processed, no cycle from this node return False visiting[node] = True # Mark the node as being processed for neighbor in graph[node]: if dfs(neighbor): return True visiting[node] = False # Mark the node as processed visited[node] = True return False visiting = defaultdict(bool) visited = defaultdict(bool) for node in graph: if not visited[node]: if dfs(node): return True return False graph1 = {0: [1], 1: [2], 2: [0]} print(has_cycle(graph1)) # True, 0->1->2->0 forms a cycle graph2 = {0: [1, 2], 1: [2], 2: [3], 3: []} print(has_cycle(graph2)) # False, no cycles graph3 = {0: [1], 1: [2], 2: [3], 3: [1]} print(has_cycle(graph3)) # True, 1->2->3->1 forms a cycle ``` This new question fits seamlessly with the existing set in terms of style, difficulty, and scope, requiring a similar level of understanding and skill in graph traversal and cycle detection.","solution":"from collections import defaultdict def has_cycle(graph): Detects if there is a cycle in the given directed graph using DFS. Parameters: graph (dict): The adjacency list representing the graph where keys are node identifiers and values are lists of neighboring nodes. Returns: bool: True if the graph contains a cycle, False otherwise. def dfs(node): if visiting[node]: # Node is being visited, meaning we found a cycle return True if visited[node]: # Node fully processed, no cycle from this node return False visiting[node] = True # Mark the node as being processed for neighbor in graph[node]: if dfs(neighbor): return True visiting[node] = False # Mark the node as processed visited[node] = True return False visiting = defaultdict(bool) visited = defaultdict(bool) for node in graph: if not visited[node]: if dfs(node): return True return False"},{"question":"# Question: Implement a Custom Decimal to Binary Converter You are tasked with creating a function that converts a given decimal number (base 10) into its binary representation (base 2). The function should handle both positive and negative integers. # Function Signature ```python def decimal_to_binary(n: int) -> str: Converts a given decimal number to its binary representation. Parameters: n (int): The decimal number to convert. Can be a positive or negative integer. Returns: str: A string representing the binary representation of the given decimal number. ``` # Input - `n` (int): The decimal number to be converted to binary. It can be positive or negative. # Output - Returns a string representing the binary form of the given decimal number. The output should handle: - Negative numbers by prefixing with a minus sign in the binary representation. - Positive numbers in plain binary form without any prefix. # Constraints - `n` will be in the range [-1,000,000, 1,000,000]. # Examples ```python >>> decimal_to_binary(10) \'1010\' >>> decimal_to_binary(-5) \'-101\' >>> decimal_to_binary(0) \'0\' >>> decimal_to_binary(256) \'100000000\' >>> decimal_to_binary(-1024) \'-10000000000\' ``` # Notes - Assume that input is always an integer and handle the conversion using appropriate bitwise operations or built-in functions. - Ensure the function can properly handle edge cases, such as zero and the largest/smallest integers in the specified range. - Aim for an efficient conversion without using pre-built functions for direct conversion if possible. # Implementation Implement your solution in the function `decimal_to_binary` as described.","solution":"def decimal_to_binary(n: int) -> str: Converts a given decimal number to its binary representation. Parameters: n (int): The decimal number to convert. Can be a positive or negative integer. Returns: str: A string representing the binary representation of the given decimal number. if n == 0: return \\"0\\" elif n > 0: return bin(n)[2:] else: return \'-\' + bin(n)[3:]"},{"question":"# Task: Optimizing Inventory Restocking Objective Write a function `calculate_restock_amount` that determines the optimal amount of stock to order for different products to meet the required minimum inventory levels. Scenario You are managing an inventory system for a store that tracks various products and their stock levels. Each product has a required minimum inventory level. Your task is to calculate how much more stock to order for each product to reach the required minimum levels. Function Signature ```python def calculate_restock_amount(current_stock: dict, min_levels: dict) -> dict: pass ``` Input 1. `current_stock` - A dictionary where keys are product names (strings) and values are the current stock levels (integers). 2. `min_levels` - A dictionary where keys are product names (strings) and values are the required minimum stock levels (integers). Output - A dictionary where keys are product names (strings) and values are the amounts to be ordered (integers) to restock each product to its required minimum level. Constraints - Both `current_stock` and `min_levels` will have the same keys. - All values in `current_stock` and `min_levels` will be non-negative integers. Examples ```python assert calculate_restock_amount({\'apples\': 30, \'bananas\': 10, \'carrots\': 15}, {\'apples\': 50, \'bananas\': 20, \'carrots\': 20}) == {\'apples\': 20, \'bananas\': 10, \'carrots\': 5} assert calculate_restock_amount({\'bread\': 5, \'milk\': 7, \'eggs\': 14}, {\'bread\': 10, \'milk\': 10, \'eggs\': 20}) == {\'bread\': 5, \'milk\': 3, \'eggs\': 6} ``` # Requirements 1. Ensure your solution efficiently calculates the restock amounts. 2. Handle edge cases such as when the current stock already meets or exceeds the minimum required levels. 3. Implement the solution in a time complexity that is proportional to the number of products. # Approach - Iterate over each product in the `current_stock` dictionary. - For each product, compare the current stock level with the required minimum level. - Calculate the difference, ensuring it is non-negative, and include it in the result dictionary.","solution":"def calculate_restock_amount(current_stock: dict, min_levels: dict) -> dict: Determines the optimal amount of stock to order for different products to meet the required minimum inventory levels. Parameters: - current_stock (dict): A dictionary with the current stock levels of products. - min_levels (dict): A dictionary with the required minimum stock levels for products. Returns: - dict: A dictionary with the amounts to be ordered for each product to restock to its required minimum level. restock_amount = {} for product, current in current_stock.items(): required_min = min_levels[product] order_amount = max(required_min - current, 0) restock_amount[product] = order_amount return restock_amount"},{"question":"**Context:** Queues are a widely used data structure in computer science, which follow the First In First Out (FIFO) principle. In this task, you are required to design a custom queue that not only adheres to basic queue operations but also provides an efficient way to retrieve the minimum element present in the queue at any given time. **Question:** Write a class `CustomQueue` that implements a queue supporting the following operations efficiently: 1. `enqueue(x: int)`: Add an integer `x` to the end of the queue. 2. `dequeue() -> int`: Remove and return the integer at the front of the queue. If the queue is empty, return `-1`. 3. `get_min() -> int`: Return the minimum element in the queue in constant time. If the queue is empty, return `-1`. **Expected Input and Output:** * `enqueue(x: int)`: Adds element `x` to the queue. * `dequeue() -> int`: Removes and returns the front element of the queue; returns `-1` if the queue is empty. * `get_min() -> int`: Returns the minimum element in the queue; returns `-1` if the queue is empty. **Example:** ```python q = CustomQueue() q.enqueue(3) q.enqueue(5) print(q.get_min()) # Outputs: 3 q.enqueue(2) q.enqueue(8) print(q.get_min()) # Outputs: 2 print(q.dequeue()) # Outputs: 3 print(q.get_min()) # Outputs: 2 print(q.dequeue()) # Outputs: 5 print(q.get_min()) # Outputs: 2 print(q.dequeue()) # Outputs: 2 print(q.get_min()) # Outputs: 8 ``` **Function Signature:** ```python class CustomQueue: def __init__(self): pass def enqueue(self, x: int) -> None: pass def dequeue(self) -> int: pass def get_min(self) -> int: pass ``` **Constraints:** - You may assume all integer inputs are between -(10^5) and (10^5). - The number of operations will not exceed (10^5).","solution":"from collections import deque import math class CustomQueue: def __init__(self): self.queue = deque() self.min_queue = deque() def enqueue(self, x: int) -> None: self.queue.append(x) while self.min_queue and self.min_queue[-1] > x: self.min_queue.pop() self.min_queue.append(x) def dequeue(self) -> int: if not self.queue: return -1 val = self.queue.popleft() if val == self.min_queue[0]: self.min_queue.popleft() return val def get_min(self) -> int: if not self.min_queue: return -1 return self.min_queue[0]"},{"question":"# Coding Question: Unique Element Extractor Write a Python function to identify and return unique elements from a list of integers in the order they first appear. Given a list of integers `arr`, the function should return a new list containing only the unique elements. Your Task Implement the function `extract_unique_elements(arr: list[int]) -> list[int]` that follows these rules: 1. The function accepts one parameter: * `arr` (list[int]): A list of integers. 2. Returns a list containing only the unique elements in the order they first appear in `arr`. 3. An element is considered unique if it appears only once in the list. 4. If `arr` is empty, return an empty list. Example Usage ```python assert extract_unique_elements([4, 5, 6, 7, 5, 4, 8]) == [6, 7, 8] assert extract_unique_elements([1, 2, 2, 3, 4, 4, 5]) == [1, 3, 5] assert extract_unique_elements([7, 1, 1, 7]) == [] assert extract_unique_elements([9, 10, 11]) == [9, 10, 11] assert extract_unique_elements([]) == [] ``` Constraints * The list length, `len(arr)`, is between `0` and `10^4`. * Each integer in the list `arr` is between `-10^4` and `10^4`. Performance Requirements * Aim for an efficient solution with O(n) time complexity. * Utilize appropriate data structures to manage and track occurrences of elements. # Notes * Maintain the order of first occurrence of each unique element. * Consider edge cases such as an empty list or a list with no unique elements.","solution":"def extract_unique_elements(arr: list[int]) -> list[int]: Returns a list containing the unique elements from the input list in the order they first appear. from collections import Counter if not arr: return [] counter = Counter(arr) unique_elements = [item for item in arr if counter[item] == 1] return unique_elements"},{"question":"# Problem Statement Scenario: You are developing a library management system where users can borrow and return books. A feature needs to be added to check if all borrowed books can be returned in a particular order, given that users might return books in any order they choose. The specific check requires determining if, starting with any initial stack of borrowed books, the books can all be returned in a sequence given a permissible order of book returns. Task: You need to implement a function that, given a sequence of borrowed books and their permissible return order, determines if all the borrowed books can be returned following that order. # Function Signature: ```python def can_return_books(borrowed: List[str], permissible: List[str]) -> bool: ``` Input: - `borrowed`: A list of strings (1 ≤ len(borrowed) ≤ 10^5), representing the sequence of borrowed books. - `permissible`: A list of strings, representing the allowable return order of books. Output: - Returns `True` if it\'s possible to return all borrowed books by following the permissible return order, `False` otherwise. Constraints: - Each book in the borrowed list will appear exactly once in the permissible list. - Optimize for both time and space complexity. Example: ```python can_return_books([\\"book1\\", \\"book2\\", \\"book3\\"], [\\"book3\\", \\"book1\\", \\"book2\\"]) # Expected Output: False can_return_books([\\"book1\\", \\"book2\\", \\"book3\\"], [\\"book1\\", \\"book2\\", \\"book3\\"]) # Expected Output: True can_return_books([\\"book1\\", \\"book2\\", \\"book3\\"], [\\"book2\\", \\"book3\\", \\"book1\\"]) # Expected Output: False ``` # Note: 1. Ensure the solution handles edge cases such as lists of length 1 or non-overlapping order properly. 2. Use the most efficient approach possible considering time and space complexity.","solution":"from typing import List def can_return_books(borrowed: List[str], permissible: List[str]) -> bool: Determines if the borrowed books can be returned in the permissible order. permissible_index = {book: i for i, book in enumerate(permissible)} last_index = -1 for book in borrowed: # Check if the current book\'s permissible index is greater than last_index if permissible_index[book] < last_index: return False last_index = permissible_index[book] return True"},{"question":"# Problem Statement You are given an integer `n` which represents the number of steps in a staircase. You can climb the staircase by taking steps of size 1 or 2. However, you have a peculiar jumping style: you can only switch the step size every two steps (i.e., if you take a step of size 2, the next two steps must be of size 1, and vice versa). We define the function `G(n)` to represent the number of different ways to reach the top of the staircase following your jumping pattern. Your task is to write a function: ```python def count_jumping_ways(n: int) -> int: Calculates and returns the number of ways to reach the top of a staircase of `n` steps following the peculiar jumping style. Parameters: - n (int): The number of steps in the staircase. Returns: - int: The number of ways to reach the top following the jumping pattern. pass ``` Constraints 1. (1 leq n leq 10^4) # Example ```python print(count_jumping_ways(4)) # Output: 3 print(count_jumping_ways(5)) # Output: 5 print(count_jumping_ways(10)) # Output: 35 ``` # Considerations 1. Ensure that your function is optimized to handle cases where `n` is at its upper bounds. 2. Consider edge cases, especially at the lower bounds of `n`. 3. Properly manage and access the dynamic programming array to avoid index errors. # Explanation 1. For `n = 4`, the ways are (1, 2, 1), (2, 1, 1), (1, 1, 1, 1), hence 3 ways. 2. For `n = 5`, the ways are (1, 2, 1, 1), (2, 1, 1, 1), (1, 1, 2, 1), (1, 2, 1, 1), (1, 1, 1, 1, 1), hence 5 ways. 3. For `n = 10`, there are 35 different ways following our jumping pattern.","solution":"def count_jumping_ways(n: int) -> int: Calculates and returns the number of ways to reach the top of a staircase of `n` steps following the peculiar jumping style. if n == 1: return 1 # dp[i] will store the number of ways to reach step i with 1 or 2 step jumps. dp = [0] * (n + 1) dp[0] = 1 # 1 way to stay at the ground level (do nothing) dp[1] = 1 # 1 way to reach step 1 for i in range(2, n + 1): # Number of ways to reach step i by jumping 1 dp_1 = dp[i - 1] # Number of ways to reach step i by jumping 2 if i is greater than or equal to 2 dp_2 = dp[i - 2] dp[i] = dp_1 + dp_2 return dp[n]"},{"question":"# Problem Statement You need to implement a function to evaluate a simple mathematical expression given in a string. The expression can contain non-negative integers and the operators: `+`, `-`, `*`, `/`. The expression must be evaluated following the standard order of operations (PEMDAS/BODMAS rules). Your function should correctly handle various edge cases, including spaces between characters and invalid characters or format. # Function Signature ```python def evaluate_expression(expression: str) -> int: ``` # Input - A string `expression` representing the mathematical expression, which can contain integers, operators (`+`, `-`, `*`, `/`), and possibly spaces. # Output - An integer result of evaluating the expression. # Constraints 1. The expression can only contain non-negative integers, the operators `+`, `-`, `*`, `/`, and space characters. 2. The input string will be non-empty and at most 1000 characters long. 3. The expression must be valid and well-formed. That means: - No division by zero. - No consecutive operators. - Valid use of spaces. # Performance Requirements - The function should run in linear time complexity O(n), where n is the length of the expression. # Scenario Implement a solution to evaluate a mathematical expression, ensuring it adheres to the standard order of operations and correctly handles variations in spaces. # Example ```python # Input: \'3+2*2\' # Output: 7 # Input: \' 3/2 \' # Output: 1 # Input: \' 3+5 / 2 \' # Output: 5 # Input: \'10 + 2 * 6\' # Output: 22 # Input: \'100 * 2 + 12\' # Output: 212 ``` # Implementation Guidelines 1. Start by removing all spaces from the input string. 2. Process the expression character by character while respecting the order of operations. 3. Use a stack to keep track of numbers and operators, applying operations when necessary. 4. Ensure that division is performed as integer division. You may use the provided code snippets as a reference for your evaluation process. Ensure that your function handles all edge cases and adheres to the constraints specified.","solution":"def evaluate_expression(expression: str) -> int: def apply_operator(operators, values): right = values.pop() left = values.pop() operator = operators.pop() if operator == \'+\': values.append(left + right) elif operator == \'-\': values.append(left - right) elif operator == \'*\': values.append(left * right) elif operator == \'/\': values.append(int(left / right)) # Use int() for the integer division truncation towards zero. def precedence(op): if op == \'+\' or op == \'-\': return 1 if op == \'*\' or op == \'/\': return 2 return 0 expression = expression.replace(\' \', \'\') values = [] operators = [] i = 0 while i < len(expression): if expression[i].isdigit(): val = 0 while i < len(expression) and expression[i].isdigit(): val = val * 10 + int(expression[i]) i += 1 values.append(val) i -= 1 else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operator(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operator(operators, values) return values[0]"},{"question":"# Problem Statement: You are provided with a list of integers representing the various prices of items in a store. Your task is to implement a function that determines the number of pairs of items whose price sum is exactly equal to a given target value. # Requirements Implement the function `count_pairs_with_sum(prices: list, target: int) -> int` such that: 1. The function accepts a list of integers `prices` and an integer `target`. 2. It returns an integer representing the number of unique pairs of items that have a total price equal to the `target`. 3. If the input `prices` is not a list of integers, the function should raise a `TypeError` with an appropriate message. # Input Format - `prices`: A list of integers representing the prices of items. - `target`: An integer representing the target total price. # Output Format - An integer representing the number of unique pairs of items that sum up to the `target`. # Constraints - You may assume the elements in the list and the target value are integers within the range [-10^6, 10^6]. - The size of the list, `n`, will be such that `0 <= n <= 10^4`. # Performance Requirements Ensure that the function is optimized to handle the upper constraint limits efficiently. # Example 1. Example 1: - Input: `prices = [1, 2, 3, 4, 3]`, `target = 6` - Output: `2` - Explanation: The pairs (2, 4) and (3, 3) sum up to 6. 2. Example 2: - Input: `prices = [1, 1, 1, 1]`, `target = 2` - Output: `6` - Explanation: There are 6 pairs (1, 1) in the list that sum up to 2. 3. Example 3: - Input: `prices = [-1, 0, 1]`, `target = 1` - Output: `1` - Explanation: The pair (0, 1) sums up to 1. # Edge Cases - The list of prices is empty. - Target sum is zero. - Non-list input types for prices. ```python def count_pairs_with_sum(prices: list, target: int) -> int: :param prices: a list of integers representing item prices :param target: an integer representing the target sum :return: an integer count of unique pairs of items whose price sum equals the target Raises: TypeError: If prices is not a list of integers. if not isinstance(prices, list) or not all(isinstance(x, int) for x in prices): raise TypeError(f\\"The input value of [prices={prices}] must be a list of integers\\") from collections import Counter count = 0 freq = Counter(prices) for price in prices: complement = target - price if complement in freq: count += freq[complement] if complement == price: count -= 1 return count // 2 # Test cases print(count_pairs_with_sum([1, 2, 3, 4, 3], 6)) # Output: 2 print(count_pairs_with_sum([1, 1, 1, 1], 2)) # Output: 6 print(count_pairs_with_sum([-1, 0, 1], 1)) # Output: 1 ``` Test your function with edge cases and various inputs to ensure robustness and correctness.","solution":"def count_pairs_with_sum(prices: list, target: int) -> int: :param prices: a list of integers representing item prices :param target: an integer representing the target sum :return: an integer count of unique pairs of items whose price sum equals the target Raises: TypeError: If prices is not a list of integers. if not isinstance(prices, list) or not all(isinstance(x, int) for x in prices): raise TypeError(\\"The input value of \'prices\' must be a list of integers\\") from collections import Counter count = 0 freq = Counter(prices) for price in prices: complement = target - price if complement in freq: count += freq[complement] if complement == price: count -= 1 return count // 2"},{"question":"# Problem Statement You are tasked with implementing a function that takes a string representation of a binary tree and serializes it into a specific format. A binary tree is a data structure in which each node has at most two children, referred to as the left and right child. # Requirements 1. **Input Parsing**: You need to parse a string representation of a binary tree. The input format consists of node values in level-order traversal separated by commas. If a node does not exist, it is represented by the string \\"null\\". 2. **Output Format**: You will then serialize the binary tree back into a string representation in the same level-order format. # Input * A string representing the binary tree in level-order traversal where each node value is separated by a comma, and non-existent nodes are represented by \\"null\\". # Output * A string representing the serialized binary tree in level-order traversal. # Constraints 1. Each node value will be an integer or \\"null\\". 2. The length of the input string will not exceed 1000 characters. # Example **Input**: ``` \\"1,2,3,null,null,4,5\\" ``` **Output**: ``` \\"1,2,3,null,null,4,5\\" ``` # Function Signature ```python def serialize_tree(tree: str) -> str: pass ``` # Note 1. Focus on accurately parsing the input string to reconstruct the binary tree structure. 2. Ensure your serialized output follows the exact same level-order format as given in the input. 3. Your function should handle edge cases efficiently, such as trees of varying shapes and sizes. # Hint You may find it useful to create a helper function to build the binary tree from the input string and then serialize it back after processing. Use a queue to facilitate reconstruction and traversal of the tree.","solution":"def serialize_tree(tree: str) -> str: Serializes a binary tree from its level-order traversal string representation. Args: tree (str): The string representation of a binary tree in level-order. Returns: str: The serialized level-order representation of the binary tree. # Simply return the input string, since the desired output is the same as the input return tree"},{"question":"# Problem Statement Create a function to determine if a given string is a permutation of a palindrome. A palindrome is a string that reads the same forwards and backwards. A permutation is a rearrangement of letters. **Input Format**: - A single string `s`, consisting of lowercase letters and possibly spaces. **Output Format**: - Return `True` if the string is a permutation of a palindrome, `False` otherwise. **Constraints**: 1. The input string will contain only lowercase alphabets and spaces. 2. The length of the string will not exceed 100,000 characters. Write your function: ```python def is_permutation_of_palindrome(s: str) -> bool: pass ``` **Example**: ```python >>> is_permutation_of_palindrome(\\"taco cat\\") True >>> is_permutation_of_palindrome(\\"atco cta\\") True >>> is_permutation_of_palindrome(\\"not a palindrome\\") False >>> is_permutation_of_palindrome(\\"aabb cc\\") True >>> is_permutation_of_palindrome(\\"abc\\") False ``` # Solution Explanation 1. **Character Frequency**: First, count the frequency of each character in the given string. 2. **Odd Frequency Check**: For a string to be a permutation of a palindrome, at most one character can have an odd frequency (this would be the middle character in the palindrome if it has an odd length). 3. **Ignoring Spaces**: Ignore spaces while calculating and checking frequencies. The provided examples include a variety of scenarios, including strings that are permutations of palindromes and those that are not. Each example tests the implementation\'s understanding of character frequency and permutation logic.","solution":"from collections import Counter def is_permutation_of_palindrome(s: str) -> bool: Check if the given string is a permutation of a palindrome. Parameters: s (str): The input string to check Returns: bool: True if the string is a permutation of a palindrome, False otherwise # Remove spaces from the string and convert to lowercase cleaned_s = s.replace(\\" \\", \\"\\").lower() # Count the frequency of each character char_count = Counter(cleaned_s) # Check the number of characters with odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # There can be at most one character with an odd count in a palindrome permutation return odd_count <= 1"},{"question":"# Question You are tasked with creating a simple task management system for a productivity app. The system should allow users to add tasks, mark tasks as completed, and list all tasks with their current status. Implement a class `TaskManager` with the following methods: Method 1: `add_task` * **Input**: A string `task` representing a new task description. * **Output**: None * **Functionality**: Adds the task with a status of \'incomplete\' to the task list. Method 2: `complete_task` * **Input**: An integer `task_id` representing the index of the task to be marked as completed. * **Output**: None * **Functionality**: Marks the task at `task_id` with the status \'complete\'. Method 3: `list_tasks` * **Output**: A list of tuples, each containing the task index, task description, and status. * **Functionality**: Returns a list of all tasks with their current status in the format (index, task_description, status). **Constraints**: - Tasks should be stored in the order they were added. - Indexing for tasks starts at 0. - Task descriptions will be unique strings. - Handle invalid task indices in `complete_task` gracefully by ignoring them. **Example Usage**: ```python # Create an instance of TaskManager tm = TaskManager() # Add tasks tm.add_task(\\"Buy groceries\\") tm.add_task(\\"Write report\\") tm.add_task(\\"Go for a walk\\") # List tasks print(tm.list_tasks()) # Output: [(0, \\"Buy groceries\\", \\"incomplete\\"), (1, \\"Write report\\", \\"incomplete\\"), (2, \\"Go for a walk\\", \\"incomplete\\")] # Mark a task as complete tm.complete_task(1) # List tasks again to see the change print(tm.list_tasks()) # Output: [(0, \\"Buy groceries\\", \\"incomplete\\"), (1, \\"Write report\\", \\"complete\\"), (2, \\"Go for a walk\\", \\"incomplete\\")] ``` Create this class and demonstrate its usage by implementing the necessary methods.","solution":"class TaskManager: def __init__(self): self.tasks = [] def add_task(self, task): Adds a task with a status of \'incomplete\' to the task list. self.tasks.append({\\"description\\": task, \\"status\\": \\"incomplete\\"}) def complete_task(self, task_id): Marks the task at `task_id` with the status \'complete\'. if 0 <= task_id < len(self.tasks): self.tasks[task_id][\\"status\\"] = \\"complete\\" def list_tasks(self): Returns a list of all tasks with their current status in the format (index, task_description, status). return [(index, task[\\"description\\"], task[\\"status\\"]) for index, task in enumerate(self.tasks)]"},{"question":"# Context You are implementing a simple parser for a subset of a programming language. Your task is to write a function that reads a string containing a sequence of arithmetic operations (addition and subtraction) and computes the final result. # Task 1. Implement the `evaluate_expression` function that takes a single string `expression` consisting of integers and the `+` and `-` operators. 2. Handle whitespace properly (ignore whitespace in the input string). 3. Assure that the function processes the input in a single left-to-right scan. # Constraints * The expression will be a valid sequence conforming to the rules provided. * No need to handle parentheses or other operators. * The expression will always have at least one number. * The numbers can be positive or negative. # Expected Input and Output * **evaluate_expression(expression: str) -> int**: The function takes a string `expression` as described above and returns the calculated integer result. # Example ```python print(evaluate_expression(\\"3 + 5 - 2\\")) # Output: 6 print(evaluate_expression(\\"10+20-30\\")) # Output: 0 print(evaluate_expression(\\" 7 - 3 + 2 \\")) # Output: 6 print(evaluate_expression(\\"-1 + 2 - 3\\")) # Output: -2 ``` # Performance Requirements * The function should process the string in a single pass and have a time complexity of O(n), where n is the length of the expression string.","solution":"def evaluate_expression(expression: str) -> int: Evaluates the arithmetic expression consisting of \'+\' and \'-\' operators and integers. Whitespace is ignored in the input string. # Remove all whitespaces from the expression expression = expression.replace(\\" \\", \\"\\") # Initialize variables to track the current result and the current number being processed result = 0 current_number = 0 sign = 1 # start with a default sign of positive for char in expression: if char.isdigit(): # Construct the current number digit by digit current_number = current_number * 10 + int(char) else: # If a sign is encountered, update result and reset current number result += sign * current_number current_number = 0 sign = 1 if char == \'+\' else -1 # Add the last processed number to the result result += sign * current_number return result"},{"question":"# Context: You are developing a function to parse and evaluate mathematical expressions given in Reverse Polish Notation (RPN). This form of notation is used extensively in stack-based and postfix calculators, where the operators follow their operands. Understanding how to process such expressions is fundamental to the design of certain types of parsers and interpreters. # Problem Statement: Write a function `evaluate_rpn` that receives a list of tokens representing a mathematical expression in Reverse Polish Notation and returns the evaluation of the expression as a floating-point number. # Specifications: - **Input**: - `tokens`: List of strings, where each string is either an operand (e.g., \\"2\\") or an operator (e.g., \\"+\\"). - **Output**: - The evaluation of the RPN expression as a floating-point number. # Function Signature: ```python def evaluate_rpn(tokens: list[str]) -> float: pass ``` # Constraints: - The list of tokens is guaranteed to form a valid RPN expression. - Operators are limited to `+`, `-`, `*`, and `/`. - Operands are valid integers or floating-point numbers. - Division by zero does not occur in the input expressions. - The input list is non-empty. # Example: ```python tokens = [\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"] result = evaluate_rpn(tokens) print(result) # Expected Output: 9.0 # Equivalent to ((2 + 1) * 3) tokens = [\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"] result = evaluate_rpn(tokens) print(result) # Expected Output: 6.0 # Equivalent to (4 + (13 / 5)) ``` # Explanation: - In the first example, the expression evaluates as: (2 + 1) * 3 = 9.0. - In the second example, the expression evaluates as: 4 + (13 / 5) = 6.0.","solution":"def evaluate_rpn(tokens: list[str]) -> float: Evaluate a mathematical expression in Reverse Polish Notation (RPN). Args: tokens (list): List of tokens representing the RPN expression. Returns: float: The evaluation result of the RPN expression. stack = [] for token in tokens: if token in {\\"+\\", \\"-\\", \\"*\\", \\"/\\"}: b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": stack.append(a / b) else: stack.append(float(token)) return stack.pop()"},{"question":"# Task Write a function `multiply_strings` that takes two non-negative integer strings `num1` and `num2` as input and returns their product as a string. # Input * Two non-negative integer strings `num1` and `num2`. # Output * A string representing the product of the input integers. # Constraints * Both `num1` and `num2` will be numeric strings with lengths up to 200 digits. * The function should perform the multiplication without directly converting the strings to integers. # Example ```python >>> multiply_strings(\\"123\\", \\"456\\") \\"56088\\" >>> multiply_strings(\\"0\\", \\"789\\") \\"0\\" >>> multiply_strings(\\"12345\\", \\"67890\\") \\"838102050\\" >>> multiply_strings(\\"1\\", \\"1\\") \\"1\\" >>> multiply_strings(\\"999\\", \\"999\\") \\"998001\\" ``` # Notes 1. Do not use any built-in functions that directly handle large integer multiplication. 2. Implement the multiplication logic manually, similar to how you would with pen and paper. 3. Handle leading zeros in the product appropriately, ensuring no extra zeros are present at the beginning of the result string unless the product is zero.","solution":"def multiply_strings(num1, num2): Multiply two non-negative integer strings and return the product as a string. if num1 == \\"0\\" or num2 == \\"0\\": return \\"0\\" len1, len2 = len(num1), len(num2) result = [0] * (len1 + len2) for i in range(len1 - 1, -1, -1): for j in range(len2 - 1, -1, -1): product = int(num1[i]) * int(num2[j]) position1, position2 = i + j, i + j + 1 sum = product + result[position2] result[position2] = sum % 10 result[position1] += sum // 10 # Remove leading zeros while len(result) > 1 and result[0] == 0: result.pop(0) return \'\'.join(map(str, result))"},{"question":"**Context**: A company needs to process large datasets and perform various operations on them efficiently. One common operation is determining the unions of multiple sets. **Task**: Implement the function `union_of_sets(*sets: List[Set[int]]) -> Set[int]` that computes the union of all provided sets. **Function Signature**: ```python def union_of_sets(*sets: List[Set[int]]) -> Set[int]: pass ``` **Input**: * `sets` (List[Set[int]]): A list of sets that may contain integers. The number of sets will be at most 10^5, and each set can have size up to 10^5. **Output**: * (Set[int]): A set containing the union of all input sets. **Constraints**: * The input sets can have a maximum combined number of elements equal to 10^7. **Requirements**: * Achieve linear time complexity O(n). * Ensure efficient management of large inputs. **Examples**: ```python assert union_of_sets({1, 2, 3}, {3, 4, 5}, {5, 6, 7}) == {1, 2, 3, 4, 5, 6, 7} assert union_of_sets({10, 20, 30}, {30, 40, 50}) == {10, 20, 30, 40, 50} assert union_of_sets(set(), {1, 2, 3}) == {1, 2, 3} assert union_of_sets({1, 2, 3},) == {1, 2, 3} assert union_of_sets({}) == set() ```","solution":"def union_of_sets(*sets): Returns the union of all provided sets. result_set = set() for s in sets: result_set.update(s) return result_set"},{"question":"# Coding Assessment Question Scenario Given a list of integers, you are required to implement a function that finds all unique triplets in the list which gives the sum of zero. This problem is important in financial calculations, where you might need to identify three transactions that negate each other, resulting in a net zero outcome. Task Write a Python function named `find_zero_sum_triplets` that takes a list of integers and returns a list containing all unique triplets in the form of tuples (a, b, c) where (a + b + c = 0). Each triplet in the list should be sorted in ascending order, and the list of triplets should not contain duplicate triplets. Function Signature ```python def find_zero_sum_triplets(nums: list) -> list: pass ``` Input - `nums`: A list of integers. Output - A list containing unique triplets (sorted tuples) that sum to zero. Constraints - The list size will be in the range of 0 to 1000. - Each integer in the list will be in the range of -10^6 to 10^6. Examples ```python print(find_zero_sum_triplets([-1, 0, 1, 2, -1, -4])) # Should return [(-1, -1, 2), (-1, 0, 1)] print(find_zero_sum_triplets([])) # Should return [] print(find_zero_sum_triplets([0, 0, 0])) # Should return [(0, 0, 0)] print(find_zero_sum_triplets([-2, 0, 1, 1, 2])) # Should return [(-2, 0, 2), (-2, 1, 1)] ``` Performance Requirements - The solution should ideally have a time complexity of O(n^2). Constraints and Error Handling - The solution must not include duplicate triplets in the output. - If the input list is empty, the function should return an empty list. No special error handling for incorrect types is required, adhering strictly to the expected input of a list of integers.","solution":"def find_zero_sum_triplets(nums): Returns a list of unique triplets (sorted tuples) that sum to zero. nums.sort() triplets = set() for i in range(len(nums) - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: triplets.add((nums[i], nums[left], nums[right])) left += 1 right -= 1 while left < right and nums[left] == nums[left - 1]: left += 1 while left < right and nums[right] == nums[right + 1]: right -= 1 elif current_sum < 0: left += 1 else: right -= 1 return list(triplets)"},{"question":"# Scenario You are developing a graphics rendering application where generating and manipulating different shapes is essential. One of the basic operations you need is to calculate the area of various shapes based on their dimensions. The application should support shapes like rectangles, circles, and triangles. Implementing this functionality accurately is critical for rendering the shapes correctly. # Task Write a function `calculate_area` that takes a shape type and its respective dimensions, then returns the area of the shape. The function should handle the following shapes: - Rectangle: specified by its `width` and `height` - Circle: specified by its `radius` - Triangle: specified by its `base` and `height` # Function Signature ```python def calculate_area(shape: str, **dimensions) -> float: ``` # Input - `shape`: A string indicating the type of shape (\\"rectangle\\", \\"circle\\", \\"triangle\\"). - `dimensions`: Keyword arguments containing the dimensions necessary to calculate the area of the shape. These can be: - For a rectangle: `width`, `height` - For a circle: `radius` - For a triangle: `base`, `height` # Output - Returns a float representing the area of the specified shape. # Constraints - `shape` will always be one of: \\"rectangle\\", \\"circle\\", \\"triangle\\". - Dimensions will always be positive numbers. # Examples ```python # Rectangle example print(calculate_area(\\"rectangle\\", width=5, height=10)) # Output: 50.0 # Circle example print(calculate_area(\\"circle\\", radius=3)) # Output: 28.274333882308138 (assuming π ~ 3.141592653589793) # Triangle example print(calculate_area(\\"triangle\\", base=4, height=7)) # Output: 14.0 ``` # Notes - Ensure your solution handles input validation and raises appropriate errors for missing or incorrect dimensions. - Use the value of π as `3.141592653589793`. - Simplify the logic by directly computing areas without additional libraries.","solution":"import math def calculate_area(shape: str, **dimensions) -> float: Calculate the area of the given shape with provided dimensions. Args: - shape (str): The type of shape (\\"rectangle\\", \\"circle\\", \\"triangle\\"). - dimensions (dict): The dimensions for calculating the area: - Rectangle: width, height - Circle: radius - Triangle: base, height Returns: - float: The calculated area of the shape. Raises: - ValueError: If a required dimension is missing or if the shape is unsupported. if shape == \\"rectangle\\": try: width = dimensions[\\"width\\"] height = dimensions[\\"height\\"] return width * height except KeyError: raise ValueError(\\"Missing dimensions \'width\' and/or \'height\' for rectangle.\\") elif shape == \\"circle\\": try: radius = dimensions[\\"radius\\"] return math.pi * (radius ** 2) except KeyError: raise ValueError(\\"Missing dimension \'radius\' for circle.\\") elif shape == \\"triangle\\": try: base = dimensions[\\"base\\"] height = dimensions[\\"height\\"] return 0.5 * base * height except KeyError: raise ValueError(\\"Missing dimensions \'base\' and/or \'height\' for triangle.\\") else: raise ValueError(\\"Unsupported shape type. Supported shapes are \'rectangle\', \'circle\', and \'triangle\'.\\")"},{"question":"# Question: Context: You are tasked with creating a feature for a text editor that helps users find and correct common misspellings. Specifically, you need to correct words based on a given dictionary of correct words. Task: Implement a function `correct_misspellings(text: str, dictionary: List[str]) -> str` which takes a string of text and a list of correct words as input and returns the text with misspellings corrected. If a word in the text is not in the dictionary, you should replace it with the most similar word from the dictionary. * You are required to implement a helper function `find_most_similar(word: str, dictionary: List[str]) -> str` to find the most similar word in the dictionary. Similarity can be defined using the Levenshtein distance (edit distance). * Ensure that your solution is efficient and can handle edge cases such as punctuation and case sensitivity. Constraints: * The length of `text` will be `1 <= len(text) <= 10^4` * The dictionary will contain up to `10^3` words, with each word being `1 <= len(word) <= 100` Input: * A string `text` where `1 <= len(text) <= 10^4` * A list of correct words `dictionary` containing up to `10^3` entries Output: * A corrected string where words not present in the dictionary are replaced with the most similar word from the dictionary. Example: ```python assert correct_misspellings(\\"Ths is a smple txt\\", [\\"This\\", \\"is\\", \\"a\\", \\"simple\\", \\"text\\"]) == \\"This is a simple text\\" assert correct_misspellings(\\"Helo wrld\\", [\\"Hello\\", \\"world\\"]) == \\"Hello world\\" ``` Requirements: * You must handle invalid inputs by raising an appropriate exception (TypeError). * Your solution should perform efficiently considering the constraints on input size.","solution":"from typing import List import difflib def find_most_similar(word: str, dictionary: List[str]) -> str: # Use difflib.get_close_matches to find the closest match from the dictionary matches = difflib.get_close_matches(word, dictionary, n=1, cutoff=0.0) if matches: return matches[0] else: return word def correct_misspellings(text: str, dictionary: List[str]) -> str: if not isinstance(text, str): raise TypeError(\\"The text parameter must be a string.\\") if not isinstance(dictionary, list) or not all(isinstance(w, str) for w in dictionary): raise TypeError(\\"The dictionary parameter must be a list of strings.\\") words = text.split() corrected_words = [] for word in words: if word in dictionary: corrected_words.append(word) else: corrected_words.append(find_most_similar(word, dictionary)) return \' \'.join(corrected_words)"},{"question":"Problem Statement You are given a list of integers and your task is to write a function `separate_even_odd` that separates the even and odd numbers from the list. The even numbers should be placed before the odd numbers, and both the even and odd numbers should retain their relative ordering from the original list. # Input * `nums` (list of integers): The list of integers to process. Constraints: The list length will be between (0) and (10^5), and each integer will be between (-10^9) and (10^9). # Output * A list of integers where all even numbers appear before all odd numbers, maintaining their original relative order. # Examples ```python separate_even_odd([1, 2, 3, 4, 5, 6]) # Expected output: [2, 4, 6, 1, 3, 5] separate_even_odd([4, 3, 2, 1]) # Expected output: [4, 2, 3, 1] separate_even_odd([7, 11, 5]) # Expected output: [7, 11, 5] separate_even_odd([8, 6, 4]) # Expected output: [8, 6, 4] separate_even_odd([]) # Expected output: [] ``` # Constraints * The function should handle an empty list by returning an empty list. * Maintain the relative order of even and odd numbers from the original list.","solution":"def separate_even_odd(nums): Separates the even and odd numbers in the list such that all even numbers come before all odd numbers. The relative order of both even and odd numbers is preserved. :param nums: List of integers :return: List of integers with evens before odds evens = [x for x in nums if x % 2 == 0] odds = [x for x in nums if x % 2 != 0] return evens + odds"},{"question":"# Problem Statement You are tasked with implementing a function that takes a string of words and returns the length of the longest subsequence of words such that each word starts with a different letter from the English alphabet. # Function Signature ```python def longest_unique_starting_subsequence(words: List[str]) -> int: pass ``` # Input and Output The function should take: * `words`: a list of strings representing the set of input words. The function should return an integer representing the length of the longest possible subsequence where each word starts with a unique letter. # Constraints * The words list will contain between 1 and 1000 words. * Each word in the list will contain only alphabetic characters and will have a length between 1 and 100. * Words are case insensitive (treat \'a\' and \'A\' as the same starting letter). # Example ``` longest_unique_starting_subsequence([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"apricot\\", \\"dog\\", \\"elephant\\"]) ``` This example involves the words: - \\"apple\\" and \\"apricot\\" both start with \'A\' - \\"banana\\" starts with \'B\' - \\"cherry\\" starts with \'C\' - \\"date\\" starts with \'D\' - \\"dog\\" starts with \'D\' - \\"elephant\\" starts with \'E\' From the list, we can select \\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elephant\\" or \\"apricot\\", \\"banana\\", \\"cherry\\", \\"dog\\", \\"elephant\\" among other combinations. The function will return: ``` 5 ``` # Explanation There are only 7 words, and assuming no two words start with the same letter after filtering, the maximum unique starting subsequence length is 5. # Note Ensure to manage edge cases effectively, including: * Lists with duplicate words * Case insensitivity (treat words starting with the same letter regardless of their cases as duplicates).","solution":"from typing import List def longest_unique_starting_subsequence(words: List[str]) -> int: Returns the length of the longest subsequence of words such that each word starts with a different letter from the English alphabet. seen_letters = set() for word in words: # Convert the starting letter to lower case and check if seen before first_letter = word[0].lower() if first_letter not in seen_letters: seen_letters.add(first_letter) return len(seen_letters)"},{"question":"# Question You are given two functions, `merge_sorted_iterative` and `merge_sorted_recursive`, which merge two sorted lists of numbers into a single sorted list using iterative and recursive methods respectively. However, to handle more complex real-world scenarios, another useful function is merging multiple sorted lists. Implement a function named `merge_k_sorted` that merges `k` sorted lists of numbers into a single sorted list using a recursive divide-and-conquer strategy. Unlike the provided `merge_sorted_recursive`, this function should handle merging `k` lists rather than just two. # Requirements * **Function Signature**: `def merge_k_sorted(lists: list[list[int | float]]) -> list[int | float]:` * **Parameters**: - `lists`: A list of lists, where each inner list is sorted in ascending order and contains integers or floats. * **Returns**: A single sorted list that contains all the elements from the `k` sorted lists. # Constraints 1. The `lists` will not be empty. 2. Each list within `lists` may have different lengths, including empty lists. 3. The function should be implemented using a recursive approach and must have a time complexity no worse than O(n log k), where `n` is the total number of elements and `k` is the number of lists. # Example ```python lists = [[1, 4, 5], [1, 3, 4], [2, 6]] print(merge_k_sorted(lists)) # Output should be [1, 1, 2, 3, 4, 4, 5, 6] lists = [[], [1], [2, 5, 8]] print(merge_k_sorted(lists)) # Output should be [1, 2, 5, 8] lists = [[10, 15, 30], [5, 6, 6], [1, 2, 3]] print(merge_k_sorted(lists)) # Output should be [1, 2, 3, 5, 6, 6, 10, 15, 30] ``` # Implementation Guidelines * You may find it helpful to implement a helper function for merging two sorted lists, which can then be used recursively to merge the `k` lists. * Consider using a divide-and-conquer strategy: divide the list of lists into two halves, recursively merge each half, and then combine the results. * Ensure that your implementation efficiently handles edge cases, such as empty lists or lists of significantly different lengths.","solution":"def merge_two_sorted_lists(l1, l2): result = [] i, j = 0, 0 while i < len(l1) and j < len(l2): if l1[i] < l2[j]: result.append(l1[i]) i += 1 else: result.append(l2[j]) j += 1 result.extend(l1[i:]) result.extend(l2[j:]) return result def merge_k_sorted(lists): if len(lists) == 1: return lists[0] if len(lists) == 2: return merge_two_sorted_lists(lists[0], lists[1]) mid = len(lists) // 2 left = merge_k_sorted(lists[:mid]) right = merge_k_sorted(lists[mid:]) return merge_two_sorted_lists(left, right)"},{"question":"# Coding Assessment: Knapsack Problem with Memoization Problem Statement You are provided with the classic 0/1 Knapsack problem. Your task is to implement a solution using memoization technique to optimize the performance. Objectives 1. Implement a `knapsack_memo` function that solves the 0/1 Knapsack problem using memoization. 2. Your implementation should find the maximum value that can be obtained within the given weight limit. Input - **Weights**: A list of integers where each integer represents the weight of an item. - **Values**: A list of integers where each integer represents the value of an item. - **Capacity**: An integer representing the maximum weight that the knapsack can hold. Output - An integer representing the maximum value that can be obtained with the given capacity. # Constraints 1. **Function Signature**: Your `knapsack_memo` function must have the following signature: ```python def knapsack_memo(weights: List[int], values: List[int], capacity: int) -> int: ``` 2. **Memoization Technique**: You should use a dictionary to store previously computed results to optimize the recursive calls. 3. **Performance Requirement**: Your implementation should efficiently handle the knapsack problem for typical input sizes. # Example Usage ```python weights = [1, 2, 4, 2, 5] values = [5, 3, 5, 3, 2] capacity = 10 max_value = knapsack_memo(weights, values, capacity) print(f\\"Maximum value that can be obtained: {max_value}\\") ``` # Example Explanation Given the weights `[1, 2, 4, 2, 5]` and values `[5, 3, 5, 3, 2]` with a capacity of 10, the optimal selection of items should provide the maximum value of 16. This example demonstrates how to use the `knapsack_memo` function to solve the problem and output the maximum value. --- # Additional Notes 1. **Input Validation**: Ensure your function handles edge cases such as empty lists and zero capacity. 2. **Efficiency Testing**: Validate the performance of your implementation with larger inputs to ensure it meets the required efficiency standards. # Sample Input ```python weights = [1, 3, 4, 5] values = [1, 4, 5, 7] capacity = 7 ``` # Sample Output ```python Maximum value that can be obtained: 9 ``` Implement the `knapsack_memo` function as per the provided requirements to solve the given problem efficiently using memoization.","solution":"from typing import List, Tuple def knapsack_memo(weights: List[int], values: List[int], capacity: int) -> int: memo = {} def helper(n: int, c: int) -> int: if n == 0 or c == 0: return 0 if (n, c) in memo: return memo[(n, c)] if weights[n-1] <= c: memo[(n, c)] = max(values[n-1] + helper(n-1, c-weights[n-1]), helper(n-1, c)) else: memo[(n, c)] = helper(n-1, c) return memo[(n, c)] return helper(len(weights), capacity)"},{"question":"# Binary Tree Depth Order Traversal **Objective**: Perform a depth-order traversal on a binary tree. The given algorithm should traverse each level of the binary tree, from the root to the leaves, ensuring nodes on the same level are visited before moving to the next level. **Problem Statement**: Write a function `depth_order_traversal(root: TreeNode) -> List[List[int]]` that returns the values of the nodes in the binary tree level by level. 1. **depth_order_traversal**: * Given the root of a binary tree, return a list of lists where each sublist contains the values of the nodes at the corresponding level of the tree from top to bottom. **Function Signature**: ```python from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: pass ``` **Requirements**: 1. **Input**: * A `TreeNode` object `root` that represents the root of the binary tree. If the tree is empty, `root` will be `None`. 2. **Output**: * A list of lists, with each sublist containing the node values at each level ordered from top to bottom. 3. **Constraints**: * The number of nodes in the tree is in the range `[0, 10^4]`. * The tree node values are integers in the range `[-10^5, 10^5]`. **Examples**: ```python # Example 1 # Input tree: # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20, TreeNode(15), TreeNode(7)) assert depth_order_traversal(root) == [[3], [9, 20], [15, 7]] # Example 2 # Input tree: # 1 # / # 2 3 # / / # 4 5 6 root = TreeNode(1) root.left = TreeNode(2, TreeNode(4)) root.right = TreeNode(3, TreeNode(5), TreeNode(6)) assert depth_order_traversal(root) == [[1], [2, 3], [4, 5, 6]] # Example 3 # Input tree: # 1 root = TreeNode(1) assert depth_order_traversal(root) == [[1]] # Example 4 # Input tree: # Empty tree (root is None) root = None assert depth_order_traversal(root) == [] ``` **Explanation**: 1. **Step by Step Approach for depth_order_traversal**: * Initialize an empty list to hold the result. * Use a queue to handle tree nodes level by level. * Start with the root node in the queue. * While the queue is not empty, extract nodes for the current level, and add their values to a temporary list. * Queue their non-null children for the next level. * Append the list of current level values to the result list. * Repeat until all levels are processed. **Notes**: * Handle edge cases such as an empty tree. * Ensure efficiency for trees with a large number of nodes without exceeding time or space complexity constraints.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def depth_order_traversal(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level = [] for _ in range(len(queue)): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Number Occurrence Counting Function Context: In various programming scenarios, analyzing the frequency of elements in a list can be valuable. Whether it\'s counting votes, tracking survey responses, or analyzing repeated elements, understanding how often each item appears is a fundamental task. Task: Write a function `count_occurrences(elements: list) -> dict` that counts the number of occurrences of each element in a given list. Specifications: 1. The function should process a list of elements, which can include integers, strings, and other hashable types. 2. The output should be a dictionary where the keys are the unique elements from the input list, and the values are the counts of each element. Input: - A single argument `elements`, which is a list of hashable items. Output: - A dictionary with the counts of each unique element in the input list. Constraints: - The input list may contain up to 10^6 elements. - Elements in the input list are hashable. Example: ```python assert count_occurrences([1, 2, 2, 3, 3, 3]) == {1: 1, 2: 2, 3: 3} assert count_occurrences([\'a\', \'b\', \'a\', \'c\', \'b\', \'a\']) == {\'a\': 3, \'b\': 2, \'c\': 1} assert count_occurrences([]) == {} ``` Notes: - Ensure your implementation efficiently handles the input list size constraints. - Consider edge cases such as an empty list or a list with all identical elements. ```python def count_occurrences(elements: list) -> dict: Returns a dictionary with the counts of each unique element in the given list. occurrence_dict = {} for element in elements: if element in occurrence_dict: occurrence_dict[element] += 1 else: occurrence_dict[element] = 1 return occurrence_dict ```","solution":"def count_occurrences(elements: list) -> dict: Returns a dictionary with the counts of each unique element in the given list. occurrence_dict = {} for element in elements: if element in occurrence_dict: occurrence_dict[element] += 1 else: occurrence_dict[element] = 1 return occurrence_dict"},{"question":"# Fibonacci Series Enhancement In this task, you will be implementing two functions related to the Fibonacci sequence to enhance its efficiency and provide additional information about the sequence elements. 1. Implement a function `fibonacci_memoized` that calculates the nth Fibonacci number using memoization. Memoization helps store previously computed values to avoid redundant calculations, thus optimizing the recursive approach. 2. Implement a function `is_fibonacci` that checks if a given number is a Fibonacci number. A number is a Fibonacci number if and only if one (or both) of (5*n*n + 4) or (5*n*n - 4) is a perfect square. Input and Output Formats 1. **Function `fibonacci_memoized(n: int, memo: dict = None) -> int`**: - **Input**: An integer `n` where `n >= 0`. - **Output**: An integer representing the nth Fibonacci number. 2. **Function `is_fibonacci(num: int) -> bool`**: - **Input**: An integer `num` where `num >= 0`. - **Output**: A boolean value indicating whether the given number is a Fibonacci number or not. Constraints - `n` and `num` will be integers such that `0 <= n, num <= 10^5`. Example ```python assert fibonacci_memoized(5) == 5 assert fibonacci_memoized(10) == 55 assert is_fibonacci(5) == True # 5 is a Fibonacci number. assert is_fibonacci(10) == False # 10 is not a Fibonacci number. ``` Write these functions and ensure that the constraints and edge cases are properly handled.","solution":"def fibonacci_memoized(n, memo=None): Calculate the nth Fibonacci number using memoization. if memo is None: memo = {} if n in memo: return memo[n] if n <= 1: return n memo[n] = fibonacci_memoized(n-1, memo) + fibonacci_memoized(n-2, memo) return memo[n] import math def is_fibonacci(num): Check if a given number is a Fibonacci number. A number is a Fibonacci number if and only if (5*num*num + 4) or (5*num*num - 4) is a perfect square. def is_perfect_square(x): s = int(math.sqrt(x)) return s*s == x return is_perfect_square(5*num*num + 4) or is_perfect_square(5*num*num - 4)"},{"question":"# Problem Statement A company tracks its employees\' performance based on a series of test scores recorded in a list. Your task is to write a function `average_score_above_threshold(scores: list, threshold: int) -> int` that calculates the number of employees whose average test score is strictly greater than a given threshold. Input - `scores`: A list of lists of integers, where each sublist contains the test scores of an individual employee. - `threshold`: An integer representing the minimum average score threshold. Output - An integer representing the number of employees whose average test score is strictly greater than the given threshold. Constraints - The number of employees, `n`, is an integer such that `1 <= n <= 100`. - Each employee has a number of test scores, `m`, such that `1 <= m <= 50`. - Each test score is an integer value in the range `0 <= scores[i][j] <= 100`. Example ```python scores = [ [70, 80, 90], [100, 85, 95], [60, 75, 65], [90, 95, 92] ] threshold = 85 print(average_score_above_threshold(scores, threshold)) # Output: 2 threshold = 70 print(average_score_above_threshold(scores, threshold)) # Output: 3 ``` Requirements - Calculate the average score for each employee and compare it against the threshold. - Return the count of employees with average scores strictly greater than the threshold.","solution":"def average_score_above_threshold(scores, threshold): Calculates the number of employees whose average test score is strictly greater than the given threshold. Args: scores: List[List[int]] - list of lists of integers where each sublist represents an employee\'s test scores. threshold: int - the minimum average score threshold. Returns: int - the number of employees whose average test score is strictly greater than the threshold. count = 0 for score_list in scores: avg_score = sum(score_list) / len(score_list) if avg_score > threshold: count += 1 return count"},{"question":"# Problem Statement **Custom String Manipulation** You are given a function template `custom_string_manipulation(s: str, operation_code: int) -> str`. This function performs string manipulations based on the provided operation code. The function should: 1. Reverse the string if the `operation_code` is `1`. 2. Convert the string to uppercase if the `operation_code` is `2`. 3. Convert the string to lowercase if the `operation_code` is `3`. 4. Replace all spaces with underscores if the `operation_code` is `4`. 5. Raise a `ValueError` if the `operation_code` is not between 1 and 4 with the message `\\"Invalid operation code\\"`. **Function Signature:** ```python def custom_string_manipulation(s: str, operation_code: int) -> str: pass ``` # Expected Input and Output Formats * **Input**: The function accepts two inputs. - ( text{s} ): A string ( text{s} ) to be manipulated. - ( text{operation_code} ): An integer ( text{operation_code} ) representing the operation to be performed. * **Output**: The function returns a manipulated string based on the operation code. * **Constraints**: - ( text{s} ) is a non-empty string. - ( text{operation_code} ) is an integer. - Only operation codes between 1 and 4 (inclusive) are valid. # Examples 1. **Example 1**: - Input: `s=\\"Hello World\\"`, `operation_code=1` - Output: `\\"dlroW olleH\\"` 2. **Example 2**: - Input: `s=\\"Hello World\\"`, `operation_code=2` - Output: `\\"HELLO WORLD\\"` 3. **Example 3**: - Input: `s=\\"Hello World\\"`, `operation_code=3` - Output: `\\"hello world\\"` 4. **Example 4**: - Input: `s=\\"Hello World\\"`, `operation_code=4` - Output: `\\"Hello_World\\"` Implement the function `custom_string_manipulation(s: str, operation_code: int) -> str` to fit the description above and pass all the test cases.","solution":"def custom_string_manipulation(s: str, operation_code: int) -> str: if operation_code == 1: return s[::-1] elif operation_code == 2: return s.upper() elif operation_code == 3: return s.lower() elif operation_code == 4: return s.replace(\\" \\", \\"_\\") else: raise ValueError(\\"Invalid operation code\\")"},{"question":"Task # DNA Sequence Matching In this problem, you are required to write a program that can identify and count occurrences of a specific DNA sequence within a longer DNA strand. You will implement a class `DNAMatcher` that encapsulates the functionality of searching for a sequence and handling invalid inputs. # Class and Methods Specification: Class: ```python class DNAMatcher: def __init__(self): pass def count_sequence_occurrences(self, dna_strand: str, sequence: str) -> int: pass def validate_sequence(self, *sequences: str) -> None: pass ``` # Method Description: * `__init__(self)`: Initialize the `DNAMatcher` instance. * `count_sequence_occurrences(self, dna_strand: str, sequence: str) -> int`: Counts the total number of times the specific `sequence` appears in the given longer `dna_strand`. Validates sequences using the `validate_sequence` method. * `validate_sequence(self, *sequences: str) -> None`: Validates that input sequences contain only valid DNA characters (\'A\', \'T\', \'C\', \'G\'): 1. Ensure all sequences contain only the characters \'A\', \'T\', \'C\', \'G\'. 2. Ensure sequences are non-empty. # Constraints: - Both `dna_strand` and `sequence` strings will always be uppercase. - Inputs will always be strings. # Examples: ```python dna_matcher = DNAMatcher() # Example for counting sequence occurrences: count = dna_matcher.count_sequence_occurrences(\\"ATGCGATATCGATCGTACGT\\", \\"ATCG\\") print(count) # Output should be 2 # Example for counting sequence occurrences: count = dna_matcher.count_sequence_occurrences(\\"GCTTGCAAGTT\\", \\"GCTT\\") print(count) # Output should be 1 ``` # Additional validation: 1. If any of the input sequences contain invalid characters or are empty, throw a ValueError with the message: `\'Invalid sequence input. Please enter sequences containing only A, T, C, or G.\'`. Make sure to test for multiple edge cases as shown above and ensure that your function handles invalid inputs gracefully.","solution":"class DNAMatcher: def __init__(self): pass def count_sequence_occurrences(self, dna_strand: str, sequence: str) -> int: self.validate_sequence(dna_strand, sequence) count = dna_strand.count(sequence) return count def validate_sequence(self, *sequences: str) -> None: valid_characters = {\'A\', \'T\', \'C\', \'G\'} for seq in sequences: if not seq or any(char not in valid_characters for char in seq): raise ValueError(\'Invalid sequence input. Please enter sequences containing only A, T, C, or G.\')"},{"question":"# Problem Description You have been tasked to create a simplified text editor that supports a basic feature: toggling the case of words in a sentence. Your function needs to take a sentence as input and output the same sentence with the case of each word toggled. Specifically, each uppercase letter in the sentence should be made lowercase and each lowercase letter should be made uppercase. # Function Requirements Write a function `toggle_case_sentence` that accepts a single string (sentence) and returns a new string with the case of each letter toggled. Input * `sentence` (str): A string representing a sentence. Output * str: The new sentence with the case of each letter toggled. Constraints 1. The input sentence will contain at most 10,000 characters. 2. Each sentence will consist of printable ASCII characters, including spaces and punctuation. 3. There will be at least one character in the input sentence. # Examples ```python assert toggle_case_sentence(\\"Hello World!\\") == \\"hELLO wORLD!\\" assert toggle_case_sentence(\\"Python3.8\\") == \\"pYTHON3.8\\" assert toggle_case_sentence(\\"SIMPLE test CASE.\\") == \\"simple TEST case.\\" assert toggle_case_sentence(\\"tOGGLE THIS.\\") == \\"Toggle this.\\" ``` # Instructions 1. Write the `toggle_case_sentence` function that processes the input `sentence` according to the requirements. 2. Ensure that your function correctly toggles the case of every letter in the sentence while keeping the rest of the characters (e.g., numbers, punctuation) unchanged. 3. Test your implementation with the provided examples to guarantee correctness.","solution":"def toggle_case_sentence(sentence): Toggles the case of each letter in the input sentence. Parameters: sentence (str): The sentence whose letter cases need to be toggled. Returns: str: A new sentence with each letter\'s case toggled. return sentence.swapcase()"},{"question":"# Problem Statement You are tasked with writing a function to determine the total mass of a substance after undergoing a series of radioactive decays. # Detailed Description A radioactive substance decays exponentially according to the formula: [M = M_0 cdot left(frac{1}{2}right)^{frac{t}{T}}] Where: - (M) is the mass of the substance after time (t). - (M_0) is the initial mass of the substance. - (t) is the total time elapsed. - (T) is the half-life of the substance. Input: * `initial_mass` (float): The initial mass of the substance, which is a non-negative number. * `time_elapsed` (float): The total time elapsed, which is a non-negative number. * `half_life` (float): The half-life of the substance, which is a positive number. Output: * A float indicating the remaining mass of the substance, rounded to 2 decimal places. Constraints: * The initial mass must be a non-negative float. * The time elapsed must be a non-negative float. * The half-life must be a positive float. # Example: ```python def radioactive_decay(initial_mass: float, time_elapsed: float, half_life: float) -> float: >>> round(radioactive_decay(100, 50, 10), 2) 3.12 >>> round(radioactive_decay(200, 100, 20), 2) 6.25 >>> round(radioactive_decay(50, 30, 5), 2) 0.78 >>> round(radioactive_decay(75, 0, 5), 2) 75.0 >>> round(radioactive_decay(10, -5, 5), 2) Traceback (most recent call last): ... ValueError: The time elapsed must be non-negative >>> round(radioactive_decay(-50, 10, 5), 2) Traceback (most recent call last): ... ValueError: The initial mass must be non-negative >>> round(radioactive_decay(50, 10, -5), 2) Traceback (most recent call last): ... ValueError: The half-life must be positive >>> round(radioactive_decay(100, 20, 10), 2) 25.0 >>> round(radioactive_decay(100, 10, 10), 2) 50.0 import math if initial_mass < 0: raise ValueError(\\"The initial mass must be non-negative\\") if time_elapsed < 0: raise ValueError(\\"The time elapsed must be non-negative\\") if half_life <= 0: raise ValueError(\\"The half-life must be positive\\") return initial_mass * (0.5 ** (time_elapsed / half_life)) ``` # Task: Implement the `radioactive_decay` function which takes `initial_mass`, `time_elapsed`, and `half_life` as input arguments and returns the remaining mass of the substance after the specified time.","solution":"def radioactive_decay(initial_mass: float, time_elapsed: float, half_life: float) -> float: Calculate the remaining mass of a substance after radioactive decay over a given period. :param initial_mass: Initial mass of the substance (non-negative float) :param time_elapsed: Total time elapsed (non-negative float) :param half_life: Half-life of the substance (positive float) :return: Remaining mass of the substance (float), rounded to 2 decimal places >>> round(radioactive_decay(100, 50, 10), 2) 3.12 >>> round(radioactive_decay(200, 100, 20), 2) 6.25 >>> round(radioactive_decay(50, 30, 5), 2) 0.78 >>> round(radioactive_decay(75, 0, 5), 2) 75.0 >>> round(radioactive_decay(-50, 10, 5), 2) Traceback (most recent call last): ... ValueError: The initial mass must be non-negative >>> round(radioactive_decay(10, -5, 5), 2) Traceback (most recent call last): ... ValueError: The time elapsed must be non-negative >>> round(radioactive_decay(50, 10, -5), 2) Traceback (most recent call last): ... ValueError: The half-life must be positive >>> round(radioactive_decay(100, 20, 10), 2) 25.0 >>> round(radioactive_decay(100, 10, 10), 2) 50.0 if initial_mass < 0: raise ValueError(\\"The initial mass must be non-negative\\") if time_elapsed < 0: raise ValueError(\\"The time elapsed must be non-negative\\") if half_life <= 0: raise ValueError(\\"The half-life must be positive\\") remaining_mass = initial_mass * (0.5 ** (time_elapsed / half_life)) return round(remaining_mass, 2)"},{"question":"# Problem Statement You are required to implement two functions to work with a list of non-negative integers. The first function should compute and return a list of squares of all the elements, and the second function should compute and return the list of cubes of all the elements in the list. Function Definitions 1. **Square Function (`compute_squares`)**: - **Input**: A list of non-negative integers `nums`. - **Output**: A list of integers representing the squares of each element in `nums`. 2. **Cube Function (`compute_cubes`)**: - **Input**: A list of non-negative integers `nums`. - **Output**: A list of integers representing the cubes of each element in `nums`. Example: ```python def compute_squares(nums: list) -> list: pass # Your implementation here. def compute_cubes(nums: list) -> list: pass # Your implementation here. ``` Requirements - Both functions should raise a `ValueError` if any element in the input list is a negative integer or if non-integer types are included. - Input constraints: ( 0 leq text{element} leq 10^6 ) with list length up to ( 10^4 ). Example Scenarios - **Compute Squares**: - `compute_squares([1, 2, 3, 4])` should return `[1, 4, 9, 16]`. - `compute_squares([0, 5, 10])` should return `[0, 25, 100]`. - **Compute Cubes**: - `compute_cubes([1, 2, 3, 4])` should return `[1, 8, 27, 64]`. - `compute_cubes([0, 5, 10])` should return `[0, 125, 1000]`. Constraints & Performance - The solution should handle large lists efficiently. - Ensure your code is robust and handles edge cases seamlessly. - Minimize the use of additional libraries or dependencies.","solution":"def compute_squares(nums): Computes and returns a list of squares of all the elements in the input list nums. Args: nums: list of non-negative integers Returns: list of integers representing squares of input integers Raises: ValueError: If any element in nums is negative or non-integer if any(type(num) is not int or num < 0 for num in nums): raise ValueError(\\"All elements in nums must be non-negative integers.\\") return [num * num for num in nums] def compute_cubes(nums): Computes and returns a list of cubes of all the elements in the input list nums. Args: nums: list of non-negative integers Returns: list of integers representing cubes of input integers Raises: ValueError: If any element in nums is negative or non-integer if any(type(num) is not int or num < 0 for num in nums): raise ValueError(\\"All elements in nums must be non-negative integers.\\") return [num * num * num for num in nums]"},{"question":"# Problem Statement You are given two arrays, `arr1` and `arr2`, each containing n unique integers. Your task is to determine if `arr2` is the result of shuffling `arr1`. Write a function to check if `arr2` contains all the elements from `arr1` but in any order. # Function Signature ```python def is_shuffle(arr1: list[int], arr2: list[int]) -> bool: pass ``` # Input * `arr1` - A list of unique integers. Each integer in the list can range from -10^9 to 10^9. * `arr2` - A list of unique integers. Each integer in the list can range from -10^9 to 10^9. # Output * Return `True` if `arr2` is a permutation (shuffle) of `arr1`. Return `False` otherwise. # Constraints * The length of each list `n` will be at most 10^5. * Both lists are of the same length. * Both arrays contain unique integers. # Detailed Requirements 1. Implement the function `is_shuffle` that checks if `arr2` is a permutation of `arr1`. 2. Handle edge cases where either array might be empty, though under the given constraints, this situation does not occur since both lists are guaranteed to have the same non-zero length. # Example ```python >>> is_shuffle([1, 2, 3, 4], [4, 3, 2, 1]) True >>> is_shuffle([1, 2, 3, 4], [1, 2, 2, 4]) False >>> is_shuffle([10, -15, 20, 5], [-15, 10, 5, 20]) True >>> is_shuffle([7, 8, 9], [1, 2, 3]) False ``` # Notes * Ensure your solution is efficient with an average time complexity of O(n), by leveraging suitable data structures for set comparisons. * Consider edge cases where the lists contain large integer values to prevent potential overflow issues. * Make sure that the function returns promptly and does not perform unnecessary computations beyond what is needed to determine if one list is a shuffle of the other.","solution":"def is_shuffle(arr1: list[int], arr2: list[int]) -> bool: Checks if arr2 is a permutation (shuffle) of arr1. Parameters: arr1 (list[int]): The first list of unique integers. arr2 (list[int]): The second list of unique integers. Returns: bool: True if arr2 is a permutation of arr1, False otherwise. if len(arr1) != len(arr2): return False return sorted(arr1) == sorted(arr2)"},{"question":"# Date Formatting and Validation **Context**: In software development, handling dates is a common requirement. Ensuring that dates are correctly formatted and valid is crucial to avoid errors in applications. The European date format typically used is `DD/MM/YYYY`. **Task**: Write a function `validate_date_format(date_str: str)` that takes a string representing a date in the format `DD/MM/YYYY` and performs the following checks: 1. Ensure the date matches the format `DD/MM/YYYY`. 2. Verify that the day (`DD`) is between 1 and 31. 3. Verify that the month (`MM`) is between 1 and 12. 4. Check if the year (`YYYY`) is a valid leap year if the date involves February 29. If the date is valid, return `True`, otherwise return `False`. **Function Signature**: ```python def validate_date_format(date_str: str) -> bool: pass ``` **Expected Output**: The function should return a boolean indicating the validity of the date string. **Constraints**: - The input date string should strictly match the format `DD/MM/YYYY`, including the slashes. - Handle edge cases such as invalid numbers of days for certain months (e.g., April having 31 days should be invalid). **Example**: ```python print(validate_date_format(\\"29/02/2020\\")) # Expected Output: True (Leap Year) print(validate_date_format(\\"31/04/2021\\")) # Expected Output: False (April has 30 days) print(validate_date_format(\\"15/13/2020\\")) # Expected Output: False (Invalid month) print(validate_date_format(\\"30/02/2021\\")) # Expected Output: False (February never has 30 days) print(validate_date_format(\\"01/01/2000\\")) # Expected Output: True (Valid date) ``` **Additional Requirements**: - Ensure the function handles invalid input gracefully and does not crash. - Self-contained solution without the use of external libraries like `datetime` to validate the date format. - Consider leap year rules: a year is a leap year if it is divisible by 4 but not by 100 unless it is also divisible by 400. # Solution ```python def validate_date_format(date_str: str) -> bool: if not isinstance(date_str, str) or len(date_str) != 10: return False if date_str[2] != \'/\' or date_str[5] != \'/\': return False try: day, month, year = map(int, date_str.split(\'/\')) except ValueError: return False if not (1 <= day <= 31) or not (1 <= month <= 12): return False if month in (4, 6, 9, 11) and day > 30: return False if month == 2: if is_leap_year(year): if day > 29: return False else: if day > 28: return False return True def is_leap_year(year: int) -> bool: if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True return False return True return False ``` This question integrates smoothly with the existing set by maintaining the provided problem structure, its complexity, and domain applicability, ensuring clarity and comprehensive requirements specification.","solution":"def validate_date_format(date_str): if not isinstance(date_str, str) or len(date_str) != 10: return False if date_str[2] != \'/\' or date_str[5] != \'/\': return False try: day, month, year = map(int, date_str.split(\'/\')) except ValueError: return False if not (1 <= day <= 31) or not (1 <= month <= 12): return False # Check for months that should not have 31 days if month in (4, 6, 9, 11) and day > 30: return False # Check for February days and leap year if month == 2: if is_leap_year(year): if day > 29: return False else: if day > 28: return False return True def is_leap_year(year): if year % 4 == 0: if year % 100 == 0: if year % 400 == 0: return True else: return False else: return True else: return False"},{"question":"# Programming Assessment Question **Context**: As part of an online bookstore\'s functionality, you need to develop a system that helps suggest the most relevant book titles based on customer searches. You aim to retrieve book titles that begin with a specific prefix. **Task**: Implement a function `autocomplete_book_titles()` that returns book titles from a given list that start with a given prefix. The function should use a Trie (prefix tree) for efficient prefix search. Function Signature: ```python def autocomplete_book_titles(titles: list[str], prefix: str) -> list[str]: pass ``` Input: * `titles`: List of strings, where each string represents a book title. * `prefix`: String, representing the prefix to search for. Output: * List of strings containing all book titles that start with the given prefix. The result should be sorted lexicographically. Constraints: * The input list `titles` will contain at most 100,000 book titles. * Each book title in the list has a maximum length of 200 characters. * The `prefix` string will have a maximum length of 100 characters. * If there are no titles that match the prefix, return an empty list. Requirements: * Use a Trie structure to manage the book titles and support efficient prefix searches. * Ensure the returned titles are sorted lexically. Example: ```python autocomplete_book_titles([\'The Great Gatsby\', \'The Grapes of Wrath\', \'To Kill a Mockingbird\', \'The Subtle Art of Not Giving a F*ck\'], \'The\') # Output: [\'The Grapes of Wrath\', \'The Great Gatsby\', \'The Subtle Art of Not Giving a F*ck\'] autocomplete_book_titles([\'Introduction to Algorithms\', \'Algorithms Unlocked\', \'Algorithm Design Manual\'], \'Algo\') # Output: [\'Algorithm Design Manual\', \'Algorithms Unlocked\'] autocomplete_book_titles([\'Pride and Prejudice\', \'Sense and Sensibility\'], \'War\') # Output: [] ``` Additional Notes: * Focus on building an efficient Trie for storing and querying book titles. * Handle cases where no titles match the prefix gracefully. * Ensure the solution is efficient and correctly follows all given constraints.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_title = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, title: str) -> None: node = self.root for char in title: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_title = True def search_with_prefix(self, prefix: str): node = self.root for char in prefix: if char not in node.children: return [] node = node.children[char] # Perform DFS from this node to get all titles with this prefix result = [] self._dfs(node, prefix, result) return result def _dfs(self, node, prefix, result): if node.is_end_of_title: result.append(prefix) for char, next_node in node.children.items(): self._dfs(next_node, prefix + char, result) def autocomplete_book_titles(titles: list[str], prefix: str) -> list[str]: trie = Trie() for title in titles: trie.insert(title) # Search for titles with the given prefix results = trie.search_with_prefix(prefix) # Return sorted results return sorted(results)"},{"question":"Task Write a function to simulate rolling two six-sided dice and calculate the probability of getting a sum of 7. Your function should perform the simulation for a specified number of rolls and return the estimated probability of rolling a sum of 7. # Details **Function Signature**: ```python def estimate_probability_of_seven(num_rolls: int) -> float: ... ``` # Parameters - `num_rolls`: An integer representing the number of times to roll the dice. # Output - A float representing the estimated probability of rolling a sum of 7 based on the number of simulations. # Constraints - The number of rolls `num_rolls` will always be a positive integer. # Example ```python num_rolls = 10000 probability = estimate_probability_of_seven(num_rolls) print(f\\"Estimated Probability of rolling a sum of 7: {probability:.4f}\\") ``` # Guidelines - Use Python’s random library to simulate the dice rolls. - Consider edge cases where `num_rolls` is a small number to ensure accuracy of the probability. - Your function should be efficient and handle large values of `num_rolls` effectively.","solution":"import random def estimate_probability_of_seven(num_rolls: int) -> float: Estimates the probability of rolling a sum of 7 with two six-sided dice. Args: num_rolls (int): The number of times to roll the dice. Returns: float: The estimated probability of getting a sum of 7. count_of_sevens = 0 for _ in range(num_rolls): roll1 = random.randint(1, 6) roll2 = random.randint(1, 6) if roll1 + roll2 == 7: count_of_sevens += 1 return count_of_sevens / num_rolls"},{"question":"# Problem Statement Implement a function to manipulate a square matrix by rotating it 90 degrees clockwise. Ensure your solution handles matrices of any size and does not use any auxiliary matrices for storage. Input: - A square matrix represented as a list of lists, where each inner list represents a row of the matrix. - For example: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` Output: - The same matrix after being rotated 90 degrees clockwise in-place. - For example: ```python out_matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` Examples: ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_90_clockwise(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [5, 1], ... [9, 3] ... ] >>> rotate_90_clockwise(matrix) >>> matrix [ [9, 5], [3, 1] ] >>> matrix = [ ... [1] ... ] >>> rotate_90_clockwise(matrix) >>> matrix [ [1] ] ``` Constraints: - The matrix will always be square, i.e., the number of rows equals the number of columns. - All elements within the matrix will be integers. Function Signature: ```python def rotate_90_clockwise(matrix: List[List[int]]) -> None: pass ``` Note: - You may use nested loops and list comprehensions to achieve the rotation. - The input matrix should be modified in place, with no new matrix created and returned.","solution":"from typing import List def rotate_90_clockwise(matrix: List[List[int]]) -> None: Rotates the given square matrix 90 degrees clockwise in-place. n = len(matrix) # Step 1: Transpose the matrix (swap rows with columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row to complete the 90-degree rotation for i in range(n): matrix[i].reverse()"},{"question":"# Question: Implement Robust Matrix Multiplication with Error Handling You are tasked with enhancing a matrix multiplication function to handle scenarios where inputs may be improperly shaped or contain invalid values. Problem Statement Modify the `MatrixMultiplier` class to include functionality for verifying the dimensions and values of the input matrices before performing the multiplication. Specifically, implement checks to ensure dimension compatibility and handle cases where matrices contain NaN or infinite values. Requirements 1. **Extend MatrixMultiplier\'s multiply function**: - Ensure that input matrices have compatible dimensions for multiplication (i.e., the number of columns in the first matrix must equal the number of rows in the second matrix). - Verify and handle cases where matrices contain NaN or infinite values, replacing them with suitable placeholder values (e.g., zero). 2. **Add Validation and Error Handling**: - Implement validation within the `multiply` function to raise appropriate errors if the input dimensions are incompatible. - Ensure that invalid values within the matrices are appropriately handled, and the user is informed about any replacements made. Input and Output - The `multiply` function should take two 2D numpy arrays as input and return their product if the dimensions are compatible. - If dimensions are incompatible, raise a `ValueError` with a descriptive message. - Replace any NaN or infinite values in the input matrices with zero before performing the multiplication. Constraints - Consider edge cases where input matrices are empty or contain invalid values. - Minimize changes to avoid breaking existing functionalities. - Ensure a clear notification mechanism for users about replaced invalid values. Testing and Performance - Ensure that the enhanced functionality does not introduce significant performance degradation. - Add test cases to validate the dimension checks, NaN/infinite handling, and edge cases. Example ```python class MatrixMultiplier: @staticmethod def multiply(matrix_a, matrix_b): # Implementation here # Test case matrix_a = np.array([[1, 2], [3, 4]]) matrix_b = np.array([[5, NaN], [7, 8]]) # Including NaN for testing try: result = MatrixMultiplier.multiply(matrix_a, matrix_b) print(\\"Result:n\\", result) except ValueError as e: print(\\"Error:\\", e) ``` Output: ```plaintext Warning: Replacing NaN or infinite values with zero in input matrices Result: [[19, 16] [43, 32]] ``` Implement the above solution ensuring that it successfully handles dimension compatibility, detects, and manages NaN or infinite values in the input matrices. Validate using the provided test cases and additional scenarios to ensure robustness.","solution":"import numpy as np class MatrixMultiplier: @staticmethod def multiply(matrix_a, matrix_b): # Check dimensions if matrix_a.shape[1] != matrix_b.shape[0]: raise ValueError(\\"Incompatible dimensions for matrix multiplication.\\") # Check and replace NaN and infinite values if np.isnan(matrix_a).any() or np.isinf(matrix_a).any() or np.isnan(matrix_b).any() or np.isinf(matrix_b).any(): print(\\"Warning: Replacing NaN or infinite values with zero in input matrices\\") matrix_a = np.nan_to_num(matrix_a, nan=0.0, posinf=0.0, neginf=0.0) matrix_b = np.nan_to_num(matrix_b, nan=0.0, posinf=0.0, neginf=0.0) # Perform matrix multiplication return np.matmul(matrix_a, matrix_b)"},{"question":"# Neural Network Activation Function You are given two popular activation functions used in neural networks: the Sigmoid function and the ReLU (Rectified Linear Unit) function. To explore their behavior, implement a function that computes the derivative of these functions at a given input. Objective Create a function `compare_activation_derivatives(x: float) -> Tuple[float, float]` that: 1. Computes the value of the Sigmoid function and its derivative at the given input x. 2. Computes the value of the ReLU function and its derivative at the given input x. 3. Returns a tuple of floats containing the derivatives of both the Sigmoid and ReLU functions. Your task is to: - Implement the `compare_activation_derivatives` function. - Ensure the proper handling of edge cases like inputs at typical threshold points (e.g., x = 0 for ReLU). - Properly document any assumptions and constraints. # Function Signature ```python def compare_activation_derivatives(x: float) -> Tuple[float, float]: pass ``` Input - `x`: A float representing the input at which to evaluate the derivative of the activation functions. Output - A tuple of two floats representing the derivatives of the Sigmoid and ReLU functions at point x. Example ```python x = -0.5 # Sigmoid derivative at x = -0.5 is approximately 0.235 # ReLU derivative at x = -0.5 is 0 print(compare_activation_derivatives(x)) ``` # Constraints - The derivative of the Sigmoid function (sigma(x)) is (sigma(x) cdot (1 - sigma(x))). - The derivative of the ReLU function is 1 if (x > 0), and 0 if (x leq 0). - Ensure your function handles potential floating-point precision issues appropriately.","solution":"import math from typing import Tuple def compare_activation_derivatives(x: float) -> Tuple[float, float]: Computes the derivatives of the Sigmoid and ReLU functions at the given input x. Args: x (float): The input value at which to evaluate the derivatives. Returns: Tuple[float, float]: A tuple containing the derivative of the Sigmoid function and the derivative of the ReLU function at x. # Sigmoid function and its derivative calculation sigmoid = 1 / (1 + math.exp(-x)) sigmoid_derivative = sigmoid * (1 - sigmoid) # ReLU function and its derivative calculation relu_derivative = 1 if x > 0 else 0 return (sigmoid_derivative, relu_derivative)"},{"question":"# Coding Assessment Question: Implement a Min-Heap Objective: Design and implement a Min-Heap data structure that supports insertion, deletion of the minimum element, and retrieval of the minimum element. Description: Implement a class `MinHeap` with the following methods: * `__init__(self)`: Initializes an empty min-heap. * `insert(self, element)`: Inserts the given element into the min-heap. * `get_min(self)`: Returns the minimum element from the min-heap without removing it. Returns `None` if the heap is empty. * `extract_min(self)`: Removes and returns the minimum element from the min-heap. Returns `None` if the heap is empty. * `heapify_down(self, index)`: Helps in maintaining the heap property by percolating the element at the given index downwards if needed. * `heapify_up(self, index)`: Helps in maintaining the heap property by percolating the element at the given index upwards if needed. Input/Output: * `__init__(self)`: No parameters, initializes an empty heap. * `insert(self, element)`: Inserts `element` into the heap. * `get_min(self)`: Returns the minimum element without removing it. * `extract_min(self)`: Removes and returns the minimum element. * `heapify_down(self, index)`: Ensures the element at `index` is moved down to maintain the heap property. * `heapify_up(self, index)`: Ensures the element at `index` is moved up to maintain the heap property. Constraints: * You may assume all elements are non-negative integers. * Maintain the heap property after every insert and extract operation. * Ensure the operations are efficient (Insertion and extraction should be O(log n)). Example: ```python # Example usage heap = MinHeap() heap.insert(20) heap.insert(15) heap.insert(10) heap.insert(30) heap.insert(40) print(heap.get_min()) # Output: 10 print(heap.extract_min()) # Output: 10 print(heap.extract_min()) # Output: 15 print(heap.get_min()) # Output: 20 print(heap.extract_min()) # Output: 20 print(heap.extract_min()) # Output: 30 print(heap.extract_min()) # Output: 40 print(heap.extract_min()) # Output: None ``` Requirements: * Properly handle edge cases such as extracting from an empty heap. * Implement the heapify methods to maintain the heap property during insertions and extractions. * Ensure the operations are performed in logarithmic time to ensure efficiency.","solution":"class MinHeap: def __init__(self): self.heap = [] def insert(self, element): self.heap.append(element) self.heapify_up(len(self.heap) - 1) def get_min(self): if not self.heap: return None return self.heap[0] def extract_min(self): if len(self.heap) == 0: return None if len(self.heap) == 1: return self.heap.pop() root = self.heap[0] self.heap[0] = self.heap.pop() self.heapify_down(0) return root def heapify_down(self, index): smallest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.heap[left_child] < self.heap[smallest]: smallest = left_child if right_child < len(self.heap) and self.heap[right_child] < self.heap[smallest]: smallest = right_child if smallest != index: self.heap[index], self.heap[smallest] = self.heap[smallest], self.heap[index] self.heapify_down(smallest) def heapify_up(self, index): parent = (index - 1) // 2 if index > 0 and self.heap[parent] > self.heap[index]: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self.heapify_up(parent)"},{"question":"# Maximum Independent Set Approximation Using Greedy Algorithm The **Maximum Independent Set Problem** is another classic problem in graph theory. Given an undirected graph, an independent set is a set of vertices such that no two vertices in the set are adjacent. The goal is to find the largest such set (maximum independent set). You are tasked with implementing a greedy approach to find an approximate solution to the maximum independent set. Function Signature ```python def greedy_max_independent_set(graph: dict) -> set: pass ``` Input * `graph` (dictionary): A graph represented as an adjacency list, where each key is a vertex, and its value is a list of adjacent vertices. Output * `chosen_vertices` (set): A set of vertices constituting the approximated maximum independent set. Constraints * The graph will have at most 1000 vertices and 5000 edges. * The vertices are represented by integers. * The graph can be disconnected. * Self-loops and parallel edges are not allowed. Performance Requirements * The time complexity should be O((n+m) log n) where n is the number of vertices and m is the number of edges. * The space complexity should be O(n), excluding the input graph. Example ```python graph = {0: [1, 3], 1: [0, 3], 2: [0, 3, 4], 3: [0, 1, 2], 4: [2, 3]} print(greedy_max_independent_set(graph)) # Output may vary but should be a valid independent set such as {1, 4} ``` # Prompt Write a Python function `greedy_max_independent_set(graph: dict)` that takes in an adjacency list representation of an undirected graph and returns a set of vertices forming the maximum independent set using a greedy approximation algorithm. Ensure to consider edge cases, avoid performance bottlenecks, handle error scenarios properly, and think of potential optimizations in your implementation.","solution":"def greedy_max_independent_set(graph: dict) -> set: Approximates the maximum independent set of a graph using a greedy algorithm. :param graph: An adjacency list representing the graph. :return: A set representing the approximated maximum independent set. # Sort vertices by increasing degree vertices = sorted(graph.keys(), key=lambda x: len(graph[x])) chosen_vertices = set() excluded_vertices = set() for vertex in vertices: if vertex not in excluded_vertices: chosen_vertices.add(vertex) # Exclude all neighbors of this vertex excluded_vertices.update(graph[vertex]) # Also exclude this vertex itself (for completeness) excluded_vertices.add(vertex) return chosen_vertices"},{"question":"# Pairwise Swap Nodes in Linked List # You are provided with a singly linked list and your task is to implement a method that swaps nodes of the linked list pairwise. This means that the nodes at positions 1 and 2 are swapped, then nodes at positions 3 and 4, and so on. If the number of nodes in the list is odd, the last node remains unchanged. Task: Implement a function `pairwise_swap` in the linked list class that performs this swap operation in place. # Inputs and Outputs: **Method: pairwise_swap** - **Input:** None (operates on the internal linked list) - **Output:** The method should return nothing. The linked list is modified in place. # Examples: 1. For `pairwise_swap`: ```python ll = LinkedList([1, 2, 3, 4, 5]) ll.pairwise_swap() ll.print_list() ``` **Output:** ``` 2 -> 1 -> 4 -> 3 -> 5 ``` 2. For another example of `pairwise_swap`: ```python ll = LinkedList([10, 20, 30, 40]) ll.pairwise_swap() ll.print_list() ``` **Output:** ``` 20 -> 10 -> 40 -> 30 ``` # Constraints: - The linked list length will be in the range [0, 10^4]. - The values of the linked list nodes can be any integers. # Implementation: ```python class Node: def __init__(self, data: int = None): self.data = data self.next = None class LinkedList: def __init__(self, values: list[int] = None): self.head = None if values: self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next def print_list(self) -> None: current = self.head while current: if current.next: print(f\\"{current.data} -> \\", end=\\"\\") else: print(current.data, end=\\"\\") current = current.next print() def pairwise_swap(self) -> None: Modifies the linked list such that nodes are swapped in pairs. if self.head is None or self.head.next is None: return prev = self.head self.head = self.head.next while True: next = prev.next temp = next.next next.next = prev if temp is None or temp.next is None: prev.next = temp break prev.next = temp.next prev = temp ```","solution":"class Node: def __init__(self, data: int = None): self.data = data self.next = None class LinkedList: def __init__(self, values: list[int] = None): self.head = None if values: self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next def print_list(self) -> None: current = self.head while current: if current.next: print(f\\"{current.data} -> \\", end=\\"\\") else: print(current.data, end=\\"\\") current = current.next print() def pairwise_swap(self) -> None: Modifies the linked list such that nodes are swapped in pairs. if self.head is None or self.head.next is None: return prev = self.head self.head = self.head.next while True: next = prev.next temp = next.next next.next = prev if temp is None or temp.next is None: prev.next = temp break prev.next = temp.next prev = temp def list_to_array(ll: LinkedList) -> list: arr = [] current = ll.head while current: arr.append(current.data) current = current.next return arr"},{"question":"# Problem Statement You are tasked with improving the performance of a web server application by identifying the top N most frequent IP addresses that access the server. This is crucial for various tasks such as load balancing, security analysis, and traffic monitoring. # Description Given a list of IP address strings, you need to write a function that returns the top N most frequent IP addresses. If there is a tie in frequency, the IPs should be returned in lexicographical order. # Objective Write a function `top_n_frequent_ips` that takes in a list of IP addresses and an integer N, and returns a list of the top N most frequent IP addresses. # Function Signature ```python def top_n_frequent_ips(ip_addresses: List[str], N: int) -> List[str]: pass ``` # Input - **ip_addresses** (List[str]): A list of strings where each string represents an IP address. - **N** (int): The number of top frequent IP addresses to return. # Output - Return a list of the top N most frequent IP addresses as strings. # Constraints - 1 <= len(ip_addresses) <= 10000 - 1 <= N <= len(ip_addresses) - Each IP address is a valid IPv4 address in dot-decimal notation. - In case of a tie, return the IP addresses in lexicographical order sorted as strings. # Examples **Example 1:** ```python ip_addresses = [\\"192.168.1.1\\", \\"192.168.1.1\\", \\"10.0.0.1\\", \\"10.0.0.1\\", \\"10.0.0.1\\", \\"172.16.0.1\\"] N = 2 print(top_n_frequent_ips(ip_addresses, N)) # Expected output: [\\"10.0.0.1\\", \\"192.168.1.1\\"] ``` **Example 2:** ```python ip_addresses = [\\"192.168.1.1\\", \\"10.0.0.1\\", \\"172.16.0.1\\"] N = 1 print(top_n_frequent_ips(ip_addresses, N)) # Expected output: [\\"10.0.0.1\\", \\"172.16.0.1\\", \\"192.168.1.1\\"] ``` **Example 3:** ```python ip_addresses = [\\"192.168.1.1\\", \\"192.168.1.1\\", \\"192.168.1.1\\", \\"192.168.1.1\\"] N = 1 print(top_n_frequent_ips(ip_addresses, N)) # Expected output: [\\"192.168.1.1\\"] ``` # Hints 1. Consider using a counter to efficiently tally the frequencies of each IP address. 2. Leverage sorting techniques to handle the lexicographical order in case of ties. 3. Ensure your solution is optimized for performance given the constraints.","solution":"from typing import List from collections import Counter def top_n_frequent_ips(ip_addresses: List[str], N: int) -> List[str]: Returns the top N most frequent IP addresses from the input list. In case of a tie, IP addresses are sorted lexicographically. :param ip_addresses: List of IP address strings. :param N: The number of top frequent IP addresses to return. :return: List of the top N most frequent IP addresses. # Count the occurrences of each IP address ip_count = Counter(ip_addresses) # Get the top N most frequent IP addresses with ties sorted lexicographically. top_ips = sorted(ip_count.items(), key=lambda x: (-x[1], x[0]))[:N] # Extract just the IP addresses from the sorted list of tuples return [ip for ip, count in top_ips]"},{"question":"# K-Means Clustering Implementation Challenge You are required to implement the K-Means clustering algorithm to group data points into specified clusters. Your function should accurately partition the dataset based on the principles outlined below. Description: Implement a function `k_means_clustering(data, k, max_iters)` which returns the cluster centroids and the assignment of each data point to a cluster. Input: - `data`: A 2D numpy array of shape (n_samples, n_features) representing the dataset. - `k`: An integer representing the number of clusters. - `max_iters`: An integer representing the maximum number of iterations for the algorithm. Output: - Returns two values: - A 2D numpy array of shape (k, n_features) representing the final cluster centroids. - A 1D numpy array of length n_samples containing the index of the cluster each data point belongs to. Constraints: - 1 <= `k` <= n_samples - 1 <= `max_iters` <= 1000 Requirements: - Your implementation must correctly initialize centroids and update them iteratively. - It should efficiently handle datasets of reasonably large size (up to 5000 samples and 50 features). - The algorithm should handle convergence within the specified maximum iterations. Additional Details: 1. Use a suitable method to initialize the centroids (e.g., random selection from the data points). 2. Consider implementing optimization techniques to speed up the convergence process. You are provided with a sample input and expected output below for reference: Sample Input: ```python import numpy as np data = np.array([ [1.0, 2.0], [1.5, 1.8], [5.0, 8.0], [8.0, 8.0], [1.0, 0.6], [9.0, 11.0] ]) k = 2 max_iters = 100 ``` Sample Output: ```python (array([ [1.16666667, 1.46666667], [7.33333333, 9.0] ]), array([0, 0, 1, 1, 0, 1])) ``` Implement the `k_means_clustering` function accordingly. Starter Code: ```python import numpy as np def k_means_clustering(data, k, max_iters): # Your code here pass ```","solution":"import numpy as np def k_means_clustering(data, k, max_iters): Perform k-means clustering on the given dataset. Parameters: data (numpy.ndarray): A 2D numpy array of shape (n_samples, n_features) representing the dataset. k (int): An integer representing the number of clusters. max_iters (int): An integer representing the maximum number of iterations for the algorithm. Returns: tuple: A tuple containing two elements: - centroids (numpy.ndarray): A 2D numpy array of shape (k, n_features) representing the final cluster centroids. - labels (numpy.ndarray): A 1D numpy array of length n_samples containing the index of the cluster each data point belongs to. n_samples, n_features = data.shape # Step 1: Initialize centroids by randomly selecting k data points np.random.seed(42) # For reproducibility random_indices = np.random.choice(n_samples, k, replace=False) centroids = data[random_indices] for iteration in range(max_iters): # Step 2: Assign each data point to the nearest centroid distances = np.linalg.norm(data[:, np.newaxis] - centroids, axis=2) labels = np.argmin(distances, axis=1) # Step 3: Calculate new centroids as the mean of assigned data points new_centroids = np.array([data[labels == i].mean(axis=0) for i in range(k)]) # Step 4: Check for convergence (if centroids do not change) if np.all(centroids == new_centroids): break centroids = new_centroids return centroids, labels"},{"question":"# Coding Challenge: Custom Binary Tree Traversal Scenario You are working for a company that deals with a variety of data structures to optimize data retrieval processes. Your current task involves manipulating a binary tree and traversing it in a specific custom order defined by the company. Question Write a Python function that performs a custom level-order traversal of a binary tree, where the tree is traversed level-by-level, but for nodes at every even level (starting from level 0), the nodes are visited from left to right, and for nodes at every odd level, the nodes are visited from right to left. Function Signature ```python from typing import List, Optional class TreeNode: def __init__(self, val: int=0, left: Optional[\'TreeNode\']=None, right: Optional[\'TreeNode\']=None): self.val = val self.left = left self.right = right def custom_level_order_traversal(root: Optional[TreeNode]) -> List[int]: Returns a list of integer values of the binary tree nodes in the custom level-order traversal. ``` Input/Output * **Input Format**: A binary tree denoted by its root node. * **Output Format**: A list of integers representing the values of nodes in the custom level-order traversal. Constraints 1. The number of nodes in the tree is in the range [0, 10^4]. 2. -10^4 <= Node.val <= 10^4 3. If the tree is empty, return an empty list. 4. Utilize depth-first or breadth-first algorithms where appropriate. Example ```python # Example Binary Tree # 1 # / # 2 3 # / / # 4 5 6 7 root = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7))) custom_level_order_traversal(root) # Expected output: [1, 3, 2, 4, 5, 6, 7] # Here: # Level 0: [1] - left to right # Level 1: [3, 2] - right to left # Level 2: [4, 5, 6, 7] - left to right ``` **Note**: Use appropriate data structures like queues or deques to manage the traversal order efficiently.","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val: int=0, left: Optional[\'TreeNode\']=None, right: Optional[\'TreeNode\']=None): self.val = val self.left = left self.right = right def custom_level_order_traversal(root: Optional[TreeNode]) -> List[int]: if not root: return [] result = [] queue = deque([root]) current_level = 0 while queue: level_size = len(queue) current_level_nodes = [] for _ in range(level_size): node = queue.popleft() current_level_nodes.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) if current_level % 2 == 1: current_level_nodes.reverse() result.extend(current_level_nodes) current_level += 1 return result"},{"question":"# Bucket Sort Implementation Challenge You have been provided with an empty class `BucketSort` that aims to implement the bucket sort algorithm. Bucket sort is particularly useful for sorting floating-point numbers that lie uniformly within a specified range. # Task Enhance the given `BucketSort` class by implementing the `sort` method, which will sort an array of floating-point numbers in ascending order using bucket sort. # Requirements 1. Implement the `sort` method within the `BucketSort` class. 2. Ensure that the `sort` method is efficient and leverages the bucket sort algorithm. # Input - An array of floating-point numbers `arr` with length `n`, where `0 <= arr[i] < 1`. # Output - The method should return a sorted list of floating-point numbers in ascending order. # Example ```python class BucketSort: def sort(self, arr): # Your implementation here # Example Usage: bucket_sorter = BucketSort() arr = [0.78, 0.17, 0.39, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68] print(bucket_sorter.sort(arr)) # Output should be: [0.12, 0.17, 0.21, 0.23, 0.39, 0.68, 0.72, 0.78, 0.94] ``` # Constraints 1. The input array `arr` will always have at least one element and at most 1000 elements. 2. All numbers in the input array will be in the range [0, 1). 3. It is guaranteed that the `sort` method will only be called with valid inputs. # Hints 1. Create buckets ranging between 0 and 1 and place each array element into its respective bucket. 2. Sort individual buckets and then concatenate them to get the final sorted array. 3. Consider using sorting algorithms like insertion sort for sorting individual buckets as it may be more efficient given the potentially small size of each bucket.","solution":"class BucketSort: def sort(self, arr): if len(arr) == 0: return arr # Create n empty buckets n = len(arr) buckets = [[] for _ in range(n)] # Put array elements in different buckets for j in range(n): index = int(n * arr[j]) buckets[index].append(arr[j]) # Sort individual buckets using insertion sort for i in range(n): buckets[i] = sorted(buckets[i]) # Concatenate all sorted buckets result = [] for i in range(n): result.extend(buckets[i]) return result"},{"question":"# Problem Statement You are tasked to implement a function that calculates the square root of a given number using the Newton-Raphson method. The function should take a non-negative number and return its square root approximated to a specified level of precision. Implement the following function: 1. `newton_sqrt(number: float, precision: float = 1e-10) -> float` Function Definition * **`newton_sqrt`**: * **Input**: * `number` (float): The number for which the square root is to be calculated. It must be a non-negative number. * `precision` (float, optional): The precision level of the approximation. Default value is `1e-10`. * **Output**: * `float`: The approximated square root value. Constraints * `number` should be a non-negative float or integer. * `precision` should be a positive float. Error Handling * If `number` is negative, raise a `ValueError` with the message: `\\"newton_sqrt() requires a non-negative number\\"`. * If `number` is not a float or integer, raise a `ValueError` with the message: `\\"newton_sqrt() requires either an int or float for number\\"`. * If `precision` is not a positive float, raise a `ValueError` with the message: `\\"newton_sqrt() requires a positive float for precision\\"`. Examples * `newton_sqrt(25)` should return approximately `5.0`. * `newton_sqrt(0.04)` should return approximately `0.2`. * `newton_sqrt(-1)` should raise a `ValueError`. * `newton_sqrt(2, 1e-5)` should return approximately `1.41421`.","solution":"def newton_sqrt(number: float, precision: float = 1e-10) -> float: Calculates the square root of a given number using the Newton-Raphson method. Parameters: number (float): The number for which the square root is to be calculated. precision (float): The precision level of the approximation. Default value is 1e-10. Returns: float: The approximated square root value. Raises: ValueError: If the input `number` is negative. ValueError: If the input `number` is not a float or integer. ValueError: If the input `precision` is not a positive float. if not isinstance(number, (int, float)): raise ValueError(\\"newton_sqrt() requires either an int or float for number\\") if number < 0: raise ValueError(\\"newton_sqrt() requires a non-negative number\\") if not isinstance(precision, float) or precision <= 0: raise ValueError(\\"newton_sqrt() requires a positive float for precision\\") if number == 0: return 0.0 guess = number / 2.0 while abs(guess * guess - number) > precision: guess = (guess + number / guess) / 2.0 return guess"},{"question":"Implement a priority queue using a binary heap. Your priority queue should support the basic operations such as inserting an element, extracting the minimum element, and peeking at the minimum element without removing it. # Implementation Details Implement the class `PriorityQueue` that supports the following methods: 1. `__init__(self) -> None`: - Initializes an empty priority queue. 2. `insert(self, item: T) -> None`: - Inserts an item into the priority queue. Raises `ValueError` if the item is `None`. 3. `extract_min(self) -> T`: - Removes and returns the minimum element from the priority queue. Raises `IndexError` if the queue is empty. 4. `peek_min(self) -> T`: - Returns the minimum element without removing it. Raises `IndexError` if the queue is empty. 5. `is_empty(self) -> bool`: - Returns `True` if the queue is empty, `False` otherwise. 6. `size(self) -> int`: - Returns the number of elements in the queue. # Constraints - All elements are comparable. - Duplicates are allowed in the priority queue. - Extracting or peeking into an empty queue should raise appropriate exceptions. # Example ```python pq = PriorityQueue() pq.insert(5) pq.insert(3) pq.insert(8) assert pq.peek_min() == 3 assert pq.extract_min() == 3 assert pq.size() == 2 assert pq.extract_min() == 5 assert pq.is_empty() == False assert pq.extract_min() == 8 assert pq.is_empty() == True ``` # Notes - The binary heap should be implemented as a list, with the parent of the node at index `i` being at `(i-1) // 2`, and the children at `2*i + 1` and `2*i + 2`. - Ensure efficient insertion and extraction of elements, respecting the properties of a min-heap. - Handle edge cases such as inserting `None` and extracting/peeking from an empty queue appropriately.","solution":"import heapq class PriorityQueue: def __init__(self): self.heap = [] def insert(self, item): if item is None: raise ValueError(\\"Cannot insert None into the PriorityQueue\\") heapq.heappush(self.heap, item) def extract_min(self): if self.is_empty(): raise IndexError(\\"Cannot extract from an empty PriorityQueue\\") return heapq.heappop(self.heap) def peek_min(self): if self.is_empty(): raise IndexError(\\"Cannot peek into an empty PriorityQueue\\") return self.heap[0] def is_empty(self): return len(self.heap) == 0 def size(self): return len(self.heap)"},{"question":"# Context As a part of the company\'s new security initiative, you\'re assigned to enhance the current login system to include a password validation feature. The system should ensure that passwords meet specific security standards to reduce the risk of unauthorized access. # Problem Statement Create a function `validate_password` which takes a single argument: 1. `password`: a string representing the password to be validated. The function should return a boolean value: `True` if the password is valid according to the specified criteria, and `False` otherwise. # Password Validation Criteria - The password must be at least 8 characters long. - The password must contain at least one uppercase letter. - The password must contain at least one lowercase letter. - The password must contain at least one digit. - The password must contain at least one special character from the set `!@#%^&*()-_`. # Input - `password`: A string (0 < len(password) ≤ 1000). # Output - Returns a boolean value: `True` if the password is valid, `False` otherwise. # Constraints Ensure your function handles edge cases efficiently, including: - Very short passwords (less than 8 characters). - Passwords with no uppercase letters, lowercase letters, digits, or special characters. - Passwords with all required characters but in insufficient quantities. # Example ```python print(validate_password(\\"Password123!\\")) # Expected Output: True print(validate_password(\\"pass123\\")) # Expected Output: False print(validate_password(\\"PASSWORD!\\")) # Expected Output: False print(validate_password(\\"password1!\\")) # Expected Output: False print(validate_password(\\"Pass123\\")) # Expected Output: False ``` # Notes - Ensure the function efficiently processes passwords and returns results quickly, especially for very long strings. - Conduct thorough testing to cover various edge cases. Ensure the function performs robustly under all possible inputs.","solution":"import re def validate_password(password): Validate the password according to specified criteria. - At least 8 characters long - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character from the set `!@#%^&*()-_` Args: password (str): Password string to validate Returns: bool: True if password is valid, False otherwise if len(password) < 8: return False if not re.search(r\\"[A-Z]\\", password): return False if not re.search(r\\"[a-z]\\", password): return False if not re.search(r\\"d\\", password): return False if not re.search(r\\"[!@#%^&*()-_]\\", password): return False return True"},{"question":"# Coding Assessment Question **Sudoku Solver** Write a function `solve_sudoku(board: List[List[str]]) -> bool` that solves a given 9x9 Sudoku puzzle and modifies the board in-place to represent the solved state. **Function Signature:** ```python def solve_sudoku(board: List[List[str]]) -> bool: ``` **Input:** * A 9x9 grid `board` filled with digits (\'1\' to \'9\') and empty spaces (\'.\'). **Output:** * The function should return `True` if the Sudoku puzzle is solved successfully. * It should return `False` if the board configuration is not solvable. **Constraints:** * The board will be a 9x9 grid containing only digits (\'1\' to \'9\') and characters \'.\'. * The given Sudoku board will have at least one solution. **Examples:** ```python >>> board = [ ... [\'5\', \'3\', \'.\', \'.\', \'7\', \'.\', \'.\', \'.\', \'.\'], ... [\'6\', \'.\', \'.\', \'1\', \'9\', \'5\', \'.\', \'.\', \'.\'], ... [\'.\', \'9\', \'8\', \'.\', \'.\', \'.\', \'.\', \'6\', \'.\'], ... [\'8\', \'.\', \'.\', \'.\', \'6\', \'.\', \'.\', \'.\', \'3\'], ... [\'4\', \'.\', \'.\', \'8\', \'.\', \'3\', \'.\', \'.\', \'1\'], ... [\'7\', \'.\', \'.\', \'.\', \'2\', \'.\', \'.\', \'.\', \'6\'], ... [\'.\', \'6\', \'.\', \'.\', \'.\', \'.\', \'2\', \'8\', \'.\'], ... [\'.\', \'.\', \'.\', \'4\', \'1\', \'9\', \'.\', \'.\', \'5\'], ... [\'.\', \'.\', \'.\', \'.\', \'8\', \'.\', \'.\', \'7\', \'9\'] ... ] >>> solve_sudoku(board) True >>> board [ [\'5\', \'3\', \'4\', \'6\', \'7\', \'8\', \'9\', \'1\', \'2\'], [\'6\', \'7\', \'2\', \'1\', \'9\', \'5\', \'3\', \'4\', \'8\'], [\'1\', \'9\', \'8\', \'3\', \'4\', \'2\', \'5\', \'6\', \'7\'], [\'8\', \'5\', \'9\', \'7\', \'6\', \'1\', \'4\', \'2\', \'3\'], [\'4\', \'2\', \'6\', \'8\', \'5\', \'3\', \'7\', \'9\', \'1\'], [\'7\', \'1\', \'3\', \'9\', \'2\', \'4\', \'8\', \'5\', \'6\'], [\'9\', \'6\', \'1\', \'5\', \'3\', \'7\', \'2\', \'8\', \'4\'], [\'2\', \'8\', \'7\', \'4\', \'1\', \'9\', \'6\', \'3\', \'5\'], [\'3\', \'4\', \'5\', \'2\', \'8\', \'6\', \'1\', \'7\', \'9\'] ] ``` **Context:** * Sudoku is a popular number puzzle where the player fills a 9x9 grid such that each column, each row, and each of the nine 3x3 subgrids contains all of the digits from 1 to 9. * This problem is often solved using constraint satisfaction techniques and backtracking algorithms. **Requirements:** 1. Implement a backtracking approach to solve the Sudoku puzzle. 2. Efficiently handle the constraints ensuring each digit appears once per row, per column, and per subgrid. 3. Modify the input `board` in-place to reflect the solved state.","solution":"from typing import List def solve_sudoku(board: List[List[str]]) -> bool: def is_valid(board, row, col, num): # Check the row for i in range(9): if board[row][i] == num: return False # Check the column for i in range(9): if board[i][col] == num: return False # Check the 3x3 sub-box start_row = row // 3 * 3 start_col = col // 3 * 3 for i in range(3): for j in range(3): if board[start_row + i][start_col + j] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == \'.\': for num in \'123456789\': if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = \'.\' return False return True return solve()"},{"question":"# Problem Statement: Write a function `binary_search_rotated(arr: List[int], target: int) -> int` to search for a target value in a rotated sorted array. A rotated sorted array is an array which was initially sorted in ascending order, but then was rotated at some pivot point unknown to you. The array does not contain any duplicates. Your function should return the index of the target if it is found in the array, otherwise return -1. You must solve this using O(log n) time complexity. # Input: * `arr` (List[int]): A list of integers representing the rotated sorted array. * `target` (int): The target integer value to search in the given array. # Output: * Returns an integer representing the index of the target in the rotated array, or -1 if the target is not present. # Example: ```python assert binary_search_rotated([4,5,6,7,0,1,2], 0) == 4 assert binary_search_rotated([4,5,6,7,0,1,2], 3) == -1 assert binary_search_rotated([1], 0) == -1 assert binary_search_rotated([6,7,1,2,3,4,5], 6) == 0 assert binary_search_rotated([6,7,1,2,3,4,5], 7) == 1 assert binary_search_rotated([6,7,1,2,3,4,5], 1) == 2 assert binary_search_rotated([6,7,1,2,3,4,5], 5) == 6 ``` # Constraints: * Array `arr` will have at least 1 element. * The elements in `arr` are unique. * The rotated array still satisfies the properties of a sorted array in parts separated by the pivot point. # Implementation Guidelines: 1. Apply binary search considering the rotation. 2. Determine in which part of the array (left half or right half) the target may exist. 3. Adjust the search area accordingly to achieve O(log n) time complexity. 4. Handle the edge scenarios like an array with only one element.","solution":"from typing import List def binary_search_rotated(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid if arr[left] <= arr[mid]: # Left half is sorted if arr[left] <= target < arr[mid]: right = mid - 1 else: left = mid + 1 else: # Right half is sorted if arr[mid] < target <= arr[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question You are given a list of integers where every element appears twice except for one. Your task is to implement the function `find_unique_number(nums: list[int]) -> int` that takes a list of integers `nums` and returns the integer that appears only once. **Function Signature**: ```python def find_unique_number(nums: list[int]) -> int: pass ``` # Input * A list of integers `nums` where `1 <= len(nums) <= 10^6` and each integer is in the range `-10^6 <= nums[i] <= 10^6`. # Output * Return the single unique integer that appears only once in the list. # Example ```python assert find_unique_number([4, 1, 2, 1, 2]) == 4 assert find_unique_number([2, 2, 3, 5, 5]) == 3 assert find_unique_number([7, 3, 5, 3, 5]) == 7 ``` # Constraints * The list will always contain one unique element and all other elements will appear exactly twice. * The function should raise a `ValueError` if the input list does not meet the problem requirements. # Performance Requirements * Your solution must run efficiently within the constraints provided, considering edge cases such as large values and a large number of elements. # Explanation Consider providing comments within your code explaining the steps or approaches taken, especially around: * Validation of input * Optimal strategy to find the unique number (e.g., using bitwise operations or mathematical properties). * Handling of exceptional scenarios Good luck!","solution":"def find_unique_number(nums: list[int]) -> int: Find the unique number in the list where every other number appears twice. Utilizes bitwise XOR to isolate the unique number. Args: nums (list[int]): The list of integers. Returns: int: The integer that appears only once. Raises: ValueError: If the input list does not meet the problem requirements. if not nums or len(nums) % 2 != 1: raise ValueError(\\"Input list must contain an odd number of elements\\") unique_number = 0 for num in nums: unique_number ^= num return unique_number"},{"question":"# Problem Statement You are tasked with writing a function to rearrange the characters of a given string such that all occurrences of a character are as far apart as possible. If it is impossible to rearrange such that no adjacent characters are the same, return an empty string. # Background: Given a string, it might be required to rearrange characters so no two adjacent characters are the same. This can be checked by ensuring all sequences of same characters are spaced out as much as possible. If characters cannot be separated according to the rules, the rearrangement is not possible. # Function Requirements: Implement the following function: ```python def rearrange_string(s: str) -> str: Rearranges the characters of the given string so that no two adjacent characters are the same. If this is not possible, return an empty string. :param s: Input string :return: Rearranged string or empty string if not possible Example: >>> rearrange_string(\\"aabb\\") \\"abab\\" # Your implementation here ``` # Constraints: * (1 leq len(s) leq 10^5) * Characters are lowercase English letters only. # Expected Input and Output: * **Input**: A string (s) * **Output**: A string with rearranged characters or an empty string if not possible. # Examples: ```python # Example 1 assert rearrange_string(\\"aabb\\") in [\\"abab\\", \\"baba\\"] # Example 2 assert rearrange_string(\\"aaab\\") == \\"\\" # Example 3 assert rearrange_string(\\"aab\\") in [\\"aba\\"] ``` # Performance Requirements: * Your solution should handle strings up to the maximum length efficiently. # Notes: - To solve the problem, you might need to use a priority queue or counter-based approaches to manage frequencies and positions of characters. - Consider edge cases such as strings with all identical characters. Implement the function with these guidelines and thinking about edge cases, performance, and correctness.","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s: str) -> str: if not s: return \\"\\" # Count the frequency of each character char_count = Counter(s) max_heap = [] # Create a max-heap based on the frequency of characters for char, count in char_count.items(): heappush(max_heap, (-count, char)) prev_char, prev_count = None, 0 result = [] while max_heap: count, char = heappop(max_heap) result.append(char) if prev_char and prev_count < 0: heappush(max_heap, (prev_count, prev_char)) prev_char = char prev_count = count + 1 # We decrease the count as we\'ve used one occurrence of \'char\' # If rearranged string length is not equal to original string, return empty string rearranged_string = \'\'.join(result) if len(rearranged_string) != len(s): return \\"\\" return rearranged_string"},{"question":"# Problem Statement You are given a sorted list of unique integers and a target integer. Write a function `find_closest` that finds the closest value to the target in the list. If two numbers are equally close to the target, return the smaller number. Assume the list is sorted in ascending order. # Function Signature ```python def find_closest(nums: list[int], target: int) -> int: Finds the closest integer to the target in the sorted list. Args: - nums: list[int] : Sorted list of unique integers. - target: int : The target integer to find the closest value to. Returns: - int: The closest value to the target in the list. Examples: - find_closest([1, 2, 4, 5, 6, 7, 8, 9], 11) -> 9 - find_closest([1, 3, 8, 10, 15], 12) -> 10 - find_closest([-5, -3, -1, 2, 3, 6, 8], 0) -> -1 pass ``` # Constraints and Assumptions * The array will always contain at least one integer. * The array is sorted in ascending order. * The array contains unique integers, no duplicates are present. * The target can be any integer (negative, positive, or zero). # Sample Input and Output ```python assert find_closest([1, 2, 4, 5, 6, 7, 8, 9], 11) == 9 assert find_closest([1, 3, 8, 10, 15], 12) == 10 assert find_closest([-5, -3, -1, 2, 3, 6, 8], 0) == -1 assert find_closest([1, 2, 3, 4, 5], 3) == 3 assert find_closest([10, 20, 30, 40, 50], 25) == 20 ``` # Notes Ensure that the comparison and selection of the closest number are done efficiently, and the solution handles edge cases like the target being outside the range of the list values correctly.","solution":"def find_closest(nums: list[int], target: int) -> int: Finds the closest integer to the target in the sorted list. Args: - nums: list[int] : Sorted list of unique integers. - target: int : The target integer to find the closest value to. Returns: - int: The closest value to the target in the list. left, right = 0, len(nums) - 1 while left <= right: mid = (left + right) // 2 if nums[mid] == target: return nums[mid] elif nums[mid] < target: left = mid + 1 else: right = mid - 1 # After binary search, \'left\' will be just greater than target, # \'right\' will be just less than target. if left >= len(nums): # Target is greater than all elements return nums[right] if right < 0: # Target is smaller than all elements return nums[left] # Compare which of nums[left] or nums[right] is closer to the target if abs(nums[left] - target) < abs(nums[right] - target): return nums[left] elif abs(nums[left] - target) > abs(nums[right] - target): return nums[right] else: # if they are equally close, return the smaller number return min(nums[left], nums[right])"},{"question":"# Coding Challenge: Unique Array Calculations In computational data analysis, sometimes it\'s necessary to manipulate arrays to extract unique values and perform calculations based on these distinct elements. This process aids in aggregate analysis and pattern detection in the dataset. Function Specification **Function 1**: `unique_sum(arr: list[int]) -> int` Your task is to complete the implementation of a function that returns the sum of all unique elements in the given list `arr`. - **Input**: - `arr` (list of integers): The list of numbers. - **Output**: - The sum of all unique integers in the list. - **Constraints**: - `arr` will not be empty. - All elements of `arr` are integers within the range `[-10^5, 10^5]`. - **Performance**: - Your solution must operate within O(n) time complexity. Example: ```python assert unique_sum([1, 2, 2, 3, 4, 4, 5]) == 15 # (1 + 2 + 3 + 4 + 5) = 15 assert unique_sum([4, 4, 4, 4, 4, 4]) == 4 # (4) = 4 assert unique_sum([-10, 10, -10, 10, -5, 5, -5, 5]) == 0 # (-10 + 10 + -5 + 5) = 0 ``` Implementation Requirements: 1. Ensure the function filters out non-unique elements and sums only the distinct values. 2. Use a data structure that supports efficient membership checks and insertions to maintain O(n) complexity. For example, consider using a set. Good luck! Your capability to handle unique values in data will significantly enhance aggregate data analysis tasks.","solution":"def unique_sum(arr): Returns the sum of all unique integers in the list arr. Parameters: arr (list of ints): The list of integers. Returns: int: The sum of all unique integers in the list. return sum(set(arr))"},{"question":"# Sorting Partially Sorted Array Scenario You are working on an application that handles large datasets which are partially sorted. These datasets are arrays where each element is at most `k` positions away from its sorted position. Your task is to ensure that these arrays are completely sorted efficiently. Task Implement the function `sort_partially_sorted_array(arr: List[int], k: int) -> List[int]`: This function sorts an array where each element is at most `k` positions away from its sorted position using an efficient algorithm. Input and Output Formats * The `arr` parameter is a list of integers. * The `k` parameter is an integer representing the maximum displacement of any element from its sorted position. * The function should return a new list of integers which is completely sorted. Constraints * The length of `arr` is between 1 and 10^6. * The value of `k` is between 1 and 1000. * Elements of the array are integers that fit within the standard integer range. Example ```python def sort_partially_sorted_array(arr: List[int], k: int) -> List[int]: # TODO: Implement this function pass >>> sort_partially_sorted_array([3, 2, 1, 5, 4, 8, 7, 6], 3) [1, 2, 3, 4, 5, 6, 7, 8] >>> sort_partially_sorted_array([10, 7, 8, 12, 11, 10, 15], 3) [7, 8, 10, 10, 11, 12, 15] ``` Notes * You may use additional helper functions if needed. * Consider using data structures such as heaps to achieve an efficient solution. * Ensure the implementation handles edge cases and is optimized for performance. This new question is designed to fit seamlessly with the existing set by examining similar technical concepts such as efficient sorting algorithms, working with arrays/lists, and handling constraints involving large datasets.","solution":"from typing import List import heapq def sort_partially_sorted_array(arr: List[int], k: int) -> List[int]: Sorts an array where each element is at most \'k\' positions away from its sorted position. if not arr: return [] # Initialize a min-heap with the first \'k + 1\' elements. min_heap = arr[:k + 1] heapq.heapify(min_heap) result = [] for i in range(k + 1, len(arr)): # Extract the smallest element from the heap and add to result. smallest = heapq.heappop(min_heap) result.append(smallest) # Add the next element from the array to the heap. heapq.heappush(min_heap, arr[i]) # Extract remaining elements from the heap and add to result. while min_heap: smallest = heapq.heappop(min_heap) result.append(smallest) return result"},{"question":"# Prime Factorization Challenge You are provided with a positive integer. Your task is to compute the prime factorization of the number and return the result as a list of prime factors in ascending order. Detailed Instructions: 1. Write a function `prime_factorization` with the following parameter: - `number`: A positive integer greater than 1. 2. The function should perform the following tasks: - Validate that the parameter is a positive integer greater than 1. - Compute the prime factorization of the number, ensuring each factor is included the correct number of times. - Return the prime factors as a list in ascending order. Constraints: - Do not use any additional libraries or modules. - Handle possible input errors gracefully by raising an appropriate ValueError. Function Signature: ```python def prime_factorization(number: int) -> list[int]: ``` Example: ```python # Example 1: number = 60 print(prime_factorization(number)) # Output: [2, 2, 3, 5] # Example 2: number = 97 print(prime_factorization(number)) # Output: [97] # Example 3: number = 100 print(prime_factorization(number)) # Output: [2, 2, 5, 5] ```","solution":"def prime_factorization(number): Returns the prime factorization of the given number as a list of primes in ascending order. if not isinstance(number, int) or number <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") factors = [] divisor = 2 while number >= divisor: while (number % divisor) == 0: factors.append(divisor) number //= divisor divisor += 1 return factors"},{"question":"# Coding Assessment Question **Scenario**: You are part of a logistics company developing a routing system for delivery trucks. One of the functionalities needed is to determine the most efficient order to visit a set of delivery points. **Task**: Implement a function `calculate_optimal_route` that receives a list of delivery points and computes the optimal order in which these points should be visited to minimize the total distance traveled. Each delivery point is represented by its (x, y) coordinates on a 2D plane. **Function Signature**: ```python def calculate_optimal_route(delivery_points: list) -> list: Calculates the optimal visiting order of delivery points to minimize the total travel distance. Args: delivery_points (list): List of tuples (x, y) representing the delivery points coordinates. Returns: list: List of tuples (x, y) representing the delivery points in the optimal visiting order. ``` **Example**: ```python points = [(0, 0), (1, 1), (2, 2), (0, 2)] optimal_route = calculate_optimal_route(points) print(f\\"Optimal Route: {optimal_route}\\") ``` **Constraints**: 1. Your function must: - Start from the first provided point (i.e., `delivery_points[0]`). - Use Euclidean distance to calculate the distance between points. - Return the delivery points in the optimal visiting order which forms a loop returning to the start point. 2. Implement the function considering efficiency for a reasonable number of delivery points (up to 10 points). **Performance Boundaries**: - The solution should run efficiently within the constraints, though it\'s acceptable for larger instances to take longer. **Additional Notes**: - You may use any standard algorithm for solving the traveling salesman problem (TSP), though a simple nearest neighbor approach can suffice for this task. - Ensure that the implementation is clear, with proper function naming and comments for maintainability.","solution":"import itertools import math def calculate_optimal_route(delivery_points: list) -> list: Calculates the optimal visiting order of delivery points to minimize the total travel distance. Args: delivery_points (list): List of tuples (x, y) representing the delivery points coordinates. Returns: list: List of tuples (x, y) representing the delivery points in the optimal visiting order. if not delivery_points: return [] # Calculate the Euclidean distance between two points def euclidean_distance(p1, p2): return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) # Calculate the total route distance def route_distance(route): return sum(euclidean_distance(route[i], route[i+1]) for i in range(len(route) - 1)) + euclidean_distance(route[-1], route[0]) # Generate all possible routes (permutations) starting from the first point start = delivery_points[0] other_points = delivery_points[1:] min_route = None min_distance = float(\'inf\') for permutation in itertools.permutations(other_points): current_route = [start] + list(permutation) current_distance = route_distance(current_route) if current_distance < min_distance: min_distance = current_distance min_route = current_route return min_route"},{"question":"# Problem: Finding Longest Subarray with Equal Number of 0s and 1s Given a binary array (an array consisting of only 0s and 1s), write a function `find_longest_subarray(nums: List[int]) -> int` that returns the length of the longest contiguous subarray that has an equal number of 0s and 1s. # Guidelines * Implement the function using a hash map to store indices to achieve an optimal solution. * Avoid using brute force approaches to ensure the solution is efficient. * Utilize prefix sums and hash maps to achieve linear time complexity. # Function Signature ```python def find_longest_subarray(nums: List[int]) -> int: pass ``` # Input * A list `nums` of integers (0 ≤ nums[i] ≤ 1) representing the binary array. # Output * Return an integer representing the length of the longest contiguous subarray that has an equal number of 0s and 1s. # Constraints * The input list can be empty, in which case the function should return 0. * The length of the array will not exceed 100,000 elements. * Focus on an optimal solution with a time complexity of O(n) where n is the number of elements in the array. # Example ```python assert find_longest_subarray([0, 1, 0]) == 2 assert find_longest_subarray([0, 1, 0, 1, 0, 1, 1]) == 6 assert find_longest_subarray([0, 0, 1, 1, 0]) == 4 assert find_longest_subarray([1, 1, 1, 1, 0, 0, 0, 0]) == 8 assert find_longest_subarray([]) == 0 ```","solution":"from typing import List def find_longest_subarray(nums: List[int]) -> int: # Dictionary to track the first occurrence of each cumulative count count_index_map = {0: -1} max_length = 0 count = 0 for index, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_index_map: max_length = max(max_length, index - count_index_map[count]) else: count_index_map[count] = index return max_length"},{"question":"# Question: Implement a Custom Data Type: SparseVector **Scenario**: In many applications, particularly those dealing with high-dimensional data like machine learning, it is common for data to be sparse - that is, only a few elements are non-zero. Storing these using normal dense vectors would be inefficient for both memory and computational tasks. To address this, you need to implement a custom data type, `SparseVector`, which efficiently stores and manages sparse data. Your task is to create a class `SparseVector` that supports the following operations: 1. **Creation**: Initialize the `SparseVector` with a dictionary where keys are indices, and values are the non-zero values at those indices. 2. **Dot Product**: Compute the dot product of two `SparseVector` instances. 3. **Addition**: Add two `SparseVector` instances together. # Requirements: * **Class Name**: `SparseVector` * **Methods**: - `__init__(self, values: dict)`: Initializes the `SparseVector` with a dictionary of values. - `dot(self, other: SparseVector) -> float`: Computes the dot product with another `SparseVector`. - `__add__(self, other: SparseVector) -> SparseVector`: Adds another `SparseVector` and returns a new `SparseVector`. # Constraints: * The vectors are sparse, so the dictionary keys will typically be much smaller in number than the possible dimensions of the vector. * You can assume that the dictionary will only contain non-zero values. * If different indices are present in two vectors, treat the missing indices as zero for dot product and addition operations. # Example: ```python vec1 = SparseVector({1: 3.0, 4: 5.0, 7: 2.0}) vec2 = SparseVector({1: 2.0, 2: 4.0, 4: 1.0}) # Dot product of vec1 and vec2 dot_product = vec1.dot(vec2) # Should return 11.0 # Addition of vec1 and vec2 result_vec = vec1 + vec2 # result_vec should be SparseVector({1: 5.0, 2: 4.0, 4: 6.0, 7: 2.0}) ``` # Function Signature: ```python class SparseVector: def __init__(self, values: dict): pass def dot(self, other: \'SparseVector\') -> float: pass def __add__(self, other: \'SparseVector\') -> \'SparseVector\': pass ```","solution":"class SparseVector: def __init__(self, values: dict): self.values = values def dot(self, other: \'SparseVector\') -> float: # Calculate dot product result = sum(self.values.get(k, 0) * other.values.get(k, 0) for k in self.values) return result def __add__(self, other: \'SparseVector\') -> \'SparseVector\': # Add two SparseVectors result = self.values.copy() for k, v in other.values.items(): if k in result: result[k] += v else: result[k] = v return SparseVector(result)"},{"question":"# Matrix Block Sum Coding Assessment Question Context You are part of a development team tasked with implementing efficient algorithms for matrix operations in a scientific computing application. One of the critical functionalities you need to support is calculating a specific summarized view of a matrix, known as the block sum. Description Write a function `matrix_block_sum(mat: List[List[int]], K: int) -> List[List[int]]` that computes the block sum of a given matrix. The block sum of a matrix `mat` is defined such that each element `B[i][j]` is the sum of all elements within the submatrix centered at `(i, j)` with a radius of `K`. This means every element `B[i][j]` contains the sum of all elements `mat[r][c]` where `max(0, i-K) <= r <= min(m-1, i+K)` and `max(0, j-K) <= c <= min(n-1, j+K)`. # Input - A 2D matrix `mat` of integers with dimensions `m x n`. - An integer `K` representing the radius of the submatrix. # Output - A 2D matrix `B` of integers with dimensions `m x n` where each element represents the block sum defined above. # Constraints - The matrix dimensions are within the range `[1, 100]` for both `m` and `n`. - The integer values within the matrix are within the range `[-10000, 10000]`. - `0 <= K <= min(m, n)`. # Example ```python from typing import List def matrix_block_sum(mat: List[List[int]], K: int) -> List[List[int]]: # Function implementation here # Example input mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] K = 1 # Expected output # The block sum matrix should be: # [ # [12, 21, 16], # [27, 45, 33], # [24, 39, 28] # ] result = matrix_block_sum(mat, K) print(result) # It should print the block sum matrix as shown in the expected output ``` # Notes - Ensure your function handles edge cases such as when `K` is 0 or when the matrix has only one element. - Optimize the function for efficiency, particularly for larger matrices. You might consider using prefix sums to speed up the sum calculations within the submatrices.","solution":"from typing import List def matrix_block_sum(mat: List[List[int]], K: int) -> List[List[int]]: m, n = len(mat), len(mat[0]) # Create a 2D prefix sum matrix prefix = [[0] * (n + 1) for _ in range(m + 1)] for i in range(m): for j in range(n): prefix[i + 1][j + 1] = mat[i][j] + prefix[i + 1][j] + prefix[i][j + 1] - prefix[i][j] # Function to get sum of elements from (r1, c1) to (r2, c2) def get_sum(r1, c1, r2, c2): r1, c1 = max(0, r1), max(0, c1) r2, c2 = min(m - 1, r2), min(n - 1, c2) return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1] result = [[0] * n for _ in range(m)] for i in range(m): for j in range(n): result[i][j] = get_sum(i - K, j - K, i + K, j + K) return result"},{"question":"# Question: Find the Longest Increasing Subsequence in an Array You are tasked with finding the longest increasing subsequence in a given array. Implement a function `longest_increasing_subsequence(arr: list) -> list` that takes an array of integers and returns the longest increasing subsequence. # Function Signature ```python def longest_increasing_subsequence(arr: list) -> list: ... ``` # Input - `arr`: A list of integers. # Output - Returns a list containing the longest increasing subsequence of the input array. If there are multiple sequences of the same length, return any one of them. # Constraints - The length of the array is between 1 and (10^4). - The elements of the array can range from (-10^5) to (10^5). # Scenario Imagine you are working in a company that processes large datasets to find useful patterns. One common analysis is to detect sequences of increasing values in the data over time. Your task is to implement a solution that extracts the longest increasing pattern in the provided dataset: - If the input array is `[10, 22, 9, 33, 21, 50, 41, 60, 80]`, one of the possible longest increasing subsequences is `[10, 22, 33, 50, 60, 80]`. - If the input array is `[3, 10, 2, 1, 20]`, the longest increasing subsequence could be `[3, 10, 20]`. # Example ```python arr = [10, 22, 9, 33, 21, 50, 41, 60, 80] assert longest_increasing_subsequence(arr) == [10, 22, 33, 50, 60, 80] # or any other valid sequence of the same length arr = [3, 10, 2, 1, 20] assert longest_increasing_subsequence(arr) == [3, 10, 20] arr = [3] assert longest_increasing_subsequence(arr) == [3] ``` # Performance Requirements - The function should have a time complexity of (O(n log n)) to handle larger datasets efficiently. - The implementation should be able to process input arrays with up to (10^4) integers seamlessly.","solution":"def longest_increasing_subsequence(arr): Returns the longest increasing subsequence in the given array. if not arr: return [] n = len(arr) # Initialize dp array to store the length of the LIS at each index dp = [1] * n # Initialize the parent array to reconstruct the sequence parent = [-1] * n # Iterate through the list to fill dp and parent arrays for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and dp[i] < dp[j] + 1: dp[i] = dp[j] + 1 parent[i] = j # Find the index of the maximum value in dp to get the length of LIS max_len = max(dp) max_index = dp.index(max_len) # Reconstruct the LIS using the parent array lis = [] while max_index != -1: lis.append(arr[max_index]) max_index = parent[max_index] return lis[::-1] # Reverse the list to get the correct order"},{"question":"# Coding Assessment Question: Word Ladder Transformation Objective Given two words `beginWord` and `endWord`, along with a list of words `wordList`, determine the length of the shortest transformation sequence from `beginWord` to `endWord`. Each transformed word must exist in `wordList`. Task Write a function `ladder_length(beginWord: str, endWord: str, wordList: list) -> int` which takes two strings and a list of strings as inputs. This function should: 1. Return the minimum number of words needed to transform `beginWord` to `endWord`. 2. If no such transformation is possible, return 0. Input - A string `beginWord` (1 ≤ length ≤ 10). - A string `endWord` (1 ≤ length ≤ 10). - A list of strings `wordList` containing between 1 and 5000 words, each word having the same length as `beginWord`. Output Format - An integer representing the length of the shortest transformation sequence or 0 if no such transformation is possible. Example ```python assert ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) == 5 assert ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) == 0 assert ladder_length(\\"hit\\", \\"hot\\", [\\"hot\\"]) == 2 ``` Constraints Use efficient algorithms to handle the computations as the input size can be comparatively large. Ensure that the solution handles various cases, including smallest and largest possible values of input parameters. Guidelines - Efficiently manage the traversal of word transformations possibly using breadth-first search (BFS). - Ensure optimal usage of data structures for quick look-ups and transformations. Code Snippet ```python from collections import deque def ladder_length(beginWord: str, endWord: str, wordList: list) -> int: # Your implementation # Utilize helper functions and appropriate algorithms as necessary. pass # Examples print(ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"])) # Should output: 5 print(ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"])) # Should output: 0 ``` This new question integrates seamlessly with the existing set by maintaining similar style, complexity, length, and addresses the concept of graph traversal and transformations within an allowable scope.","solution":"from collections import deque def ladder_length(beginWord: str, endWord: str, wordList: list) -> int: word_set = set(wordList) # Convert word list to a set for faster lookup if endWord not in word_set: return 0 # Initialize the queue for BFS queue = deque([(beginWord, 1)]) while queue: current_word, level = queue.popleft() if current_word == endWord: return level # Try all possible single letter transformations for i in range(len(current_word)): for char in \'abcdefghijklmnopqrstuvwxyz\': next_word = current_word[:i] + char + current_word[i+1:] if next_word in word_set: word_set.remove(next_word) queue.append((next_word, level + 1)) return 0"},{"question":"# Word Frequency Histogram You are tasked with implementing a class `TextAnalyzer` that processes a given text to analyze word frequency and generate histograms. This class will include methods to perform basic text cleaning, word counting, and histogram plotting. Tasks: 1. **TextAnalyzer Class Implementation**: - **Initialization**: Initialize with a string of text. - **Clean Text**: Implement a method to remove punctuation and convert text to lower case. - **Word Frequency**: Implement a method to count the frequency of each word. - **Top N Words**: Implement a method to return the top N most frequent words. - **Histogram**: Implement a method to generate and print a histogram of word frequencies. Constraints: - Text input will be a string with a maximum length of 10,000 characters. - Words will be separated by spaces. - Consider words to be case-insensitive (e.g., \\"Word\\" and \\"word\\" should be treated as the same). - Punctuation marks include: .,!?;:\'\\"()[]{}<>-_ Expected Input and Output Format: - **Input**: Operations by calling various methods. - **Output**: Printed results of operations: Example: ```python text = \\"Hello world! Hello, Python world. Let\'s code: Python, world, hello!\\" # Initialize the TextAnalyzer analyzer = TextAnalyzer(text) # Clean the text cleaned_text = analyzer.clean_text() print(cleaned_text) # Output: \\"hello world hello python world lets code python world hello\\" # Get word frequency word_freq = analyzer.word_frequency() print(word_freq) # Output: {\'hello\': 3, \'world\': 3, \'python\': 2, \'lets\': 1, \'code\': 1} # Get top N words top_words = analyzer.top_n_words(2) print(top_words) # Output: [(\'hello\', 3), (\'world\', 3)] # Generate and print histogram analyzer.histogram() # Output: # hello: *** # world: *** # python: ** # lets: * # code: * ```","solution":"import re from collections import Counter class TextAnalyzer: def __init__(self, text): self.text = text self.cleaned_text = self.clean_text() def clean_text(self): Cleans the text by removing punctuation and converting to lowercase. cleaned_text = re.sub(r\'[^ws]\', \'\', self.text).lower() return cleaned_text def word_frequency(self): Counts the frequency of each word in the cleaned text. words = self.cleaned_text.split() word_count = Counter(words) return word_count def top_n_words(self, n): Returns the top N most frequent words. word_count = self.word_frequency() return word_count.most_common(n) def histogram(self): Prints a histogram of word frequencies. word_count = self.word_frequency() for word, count in word_count.items(): print(f\\"{word}: {\'*\' * count}\\") # Example Usage # text = \\"Hello world! Hello, Python world. Let\'s code: Python, world, hello!\\" # analyzer = TextAnalyzer(text) # cleaned_text = analyzer.clean_text() # word_freq = analyzer.word_frequency() # top_words = analyzer.top_n_words(2) # analyzer.histogram()"},{"question":"# Coding Assessment: Matrix Factorization for Collaborative Filtering **Objective**: Implement a function for Matrix Factorization using Singular Value Decomposition (SVD) to predict missing values in a user-item ratings matrix. # Problem Given a user-item matrix `ratings` with some missing values denoted by zeroes, write a function `matrix_factorization` that predicts the missing values using Singular Value Decomposition (SVD). # Function Signature ```python def matrix_factorization(ratings: np.ndarray, k: int) -> np.ndarray: Predict the missing values in a user-item ratings matrix using SVD. Args: ratings (np.ndarray): A 2D numpy array where rows represent users and columns represent items. Entries can be ratings (values between 1 and 5), or zeroes where ratings are missing. k (int): The number of singular values to keep. Returns: np.ndarray: A 2D numpy array of the same shape as `ratings` with missing values predicted. pass ``` # Input * `ratings`: A numpy array of shape (m, n) where `m` is the number of users and `n` is the number of items, containing integer ratings between 1 and 5, or zeroes for missing ratings. * `k`: An integer representing the number of singular values to keep. # Output * A numpy array of shape (m, n) with the original ratings and the predicted ratings for the previously missing values. # Constraints * 1 ≤ m, n ≤ 10^3 (number of users and items) * 1 ≤ k ≤ min(m, n) # Example ```python import numpy as np ratings = np.array([ [5, 0, 3, 0], [4, 0, 0, 2], [0, 2, 0, 0], [0, 0, 4, 5] ]) k = 2 result = matrix_factorization(ratings, k) print(result) # Expected output should contain predicted values in place of zeroes. ``` # Instructions 1. Implement the function `matrix_factorization` using Singular Value Decomposition. 2. Use the numpy library to efficiently handle matrix operations. 3. Make sure the function replaces zeroes in the input matrix with predicted values while retaining non-zero entries. 4. Test your function with different values of `k` to ensure the correctness and sensitivity to the number of singular values retained. # Notes * Singular Value Decomposition decomposes the ratings matrix `R` into three matrices: `U`, `Σ`, and `V^T`. * Use the truncated SVD based on `k` to recompute the ratings matrix. * Ensure the predicted ratings are within the range [1, 5] and replace zeroes only.","solution":"import numpy as np def matrix_factorization(ratings: np.ndarray, k: int) -> np.ndarray: Predict the missing values in a user-item ratings matrix using SVD. Args: ratings (np.ndarray): A 2D numpy array where rows represent users and columns represent items. Entries can be ratings (values between 1 and 5), or zeroes where ratings are missing. k (int): The number of singular values to keep. Returns: np.ndarray: A 2D numpy array of the same shape as `ratings` with missing values predicted. # Perform Singular Value Decomposition U, sigma, Vt = np.linalg.svd(ratings, full_matrices=False) # Retain only the top k singular values sigma = np.diag(sigma[:k]) U_k = U[:, :k] Vt_k = Vt[:k, :] # Reconstruct the matrix using the top k singular values predicted_ratings = np.dot(np.dot(U_k, sigma), Vt_k) # Replace the zeroes in the original rating with the predicted values predicted_ratings_matrix = np.where(ratings == 0, predicted_ratings, ratings) # Clip the predicted ratings to be in the range [1, 5] predicted_ratings_matrix = np.clip(predicted_ratings_matrix, 1, 5) return predicted_ratings_matrix"},{"question":"# Password Strength Checker Implement a function that verifies the strength of a given password. The function should return `True` if the password meets the strength requirements, and `False` otherwise. Follow the constraints and rules outlined below. **Function Signature**: ```python def check_password_strength(password: str) -> bool: pass ``` # Constraints and Rules 1. **Length Requirement**: - The password must be at least 8 characters long. 2. **Character Requirements**: - The password must contain at least one lowercase letter. - The password must contain at least one uppercase letter. - The password must contain at least one digit. - The password must contain at least one special character from the set: `!@#%^&*()-_+=`. # Expected Input and Output Formats **Input**: - A string `password` representing the password to be checked. **Output**: - A boolean value `True` if the password meets the strength requirements, otherwise `False`. # Performance Requirements - The function should run in O(n) time complexity, where n is the length of the password string. # Example ```python assert check_password_strength(\\"A1b@7890\\") == True assert check_password_strength(\\"weakpassword\\") == False ```","solution":"def check_password_strength(password: str) -> bool: Checks if the given password meets the following strength requirements: - At least 8 characters long. - Contains at least one lowercase letter. - Contains at least one uppercase letter. - Contains at least one digit. - Contains at least one special character from the set: !@#%^&*()-_+= Args: password (str): The password to be checked. Returns: bool: True if the password meets the strength requirements, False otherwise. if len(password) < 8: return False has_lower = has_upper = has_digit = has_special = False special_characters = set(\\"!@#%^&*()-_+=\\") for char in password: if char.islower(): has_lower = True elif char.isupper(): has_upper = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_lower and has_upper and has_digit and has_special"},{"question":"# Coding Assessment Question **Scenario**: You are tasked with developing a utility that processes a list of students\' scores and categorizes them based on their performance. Your goal is to implement a function that categorizes students into three performance groups: \'Top\', \'Average\', and \'Below Average\'. **Objective**: Write a function `categorize_students` that: 1. Takes a list of tuples, where each tuple contains a student\'s name and their score. 2. Categorizes students into \'Top\', \'Average\', and \'Below Average\' based on the following criteria: - Top: Scores greater than or equal to 75 - Average: Scores between 50 and 74 (inclusive) - Below Average: Scores less than 50 3. Returns a dictionary with three keys: \'Top\', \'Average\', and \'Below Average\', each containing a list of student names falling into that category. **Function Signature**: ```python def categorize_students(scores: list[tuple[str, int]]) -> dict[str, list[str]]: Categorize students based on their scores. Args: - scores (list[tuple[str, int]]): A list of tuples where each tuple contains a student\'s name and their score. Returns: - dict[str, list[str]]: A dictionary with \'Top\', \'Average\', and \'Below Average\' as keys and lists of student names as values. ``` **Constraints**: - **Input**: - `scores`: A non-empty list of tuples, where each tuple consists of a string (student\'s name) and an integer (student\'s score). - **Output**: - A dictionary with the keys \'Top\', \'Average\', and \'Below Average\', each containing a list of student names as values. **Example**: ```python scores = [(\\"Alice\\", 85), (\\"Bob\\", 67), (\\"Charlie\\", 45), (\\"David\\", 72), (\\"Eve\\", 90)] result = categorize_students(scores) Expected Output: { \\"Top\\": [\\"Alice\\", \\"Eve\\"], \\"Average\\": [\\"Bob\\", \\"David\\"], \\"Below Average\\": [\\"Charlie\\"] } ``` **Guidelines for Implementation**: 1. **Input Validation**: Ensure the input list is non-empty and each element is a valid tuple with a string name and an integer score. 2. **Categorization Logic**: Implement the categorization based on the defined score ranges efficiently. 3. **Result Structure**: Return a dictionary with the specified keys and corresponding lists of student names. 4. **Edge Cases**: Handle cases with all scores being in one category, or when multiple students have the same score. --- This question is designed to test your ability to process and categorize data, ensure proper handling of input formats, and return structured data in a specific format. Implement the logic clearly and efficiently.","solution":"def categorize_students(scores: list[tuple[str, int]]) -> dict[str, list[str]]: Categorize students based on their scores. Args: - scores (list[tuple[str, int]]): A list of tuples where each tuple contains a student\'s name and their score. Returns: - dict[str, list[str]]: A dictionary with \'Top\', \'Average\', and \'Below Average\' as keys and lists of student names as values. categorized = { \'Top\': [], \'Average\': [], \'Below Average\': [] } for name, score in scores: if score >= 75: categorized[\'Top\'].append(name) elif 50 <= score < 75: categorized[\'Average\'].append(name) else: categorized[\'Below Average\'].append(name) return categorized"},{"question":"# Coding Assessment Question You are developing a file management system that needs to analyze and report the longest word in each file and its frequency. The system we\'ll create should provide this analysis efficiently to handle large text files. **Function Specification:** Implement the function `longest_word_frequency` that reads a file and returns a tuple containing the longest word in the file and its frequency of occurrence. ```python def longest_word_frequency(file_path: str) -> tuple[str, int]: pass ``` # Input - `file_path` (string): A string representing the path to the text file. # Output - Returns a tuple consisting of: - The longest word (string) in the file. - The frequency (integer) of the longest word in the file. # Constraints - Assume that words are separated by whitespace and ignore punctuation. - If there are multiple longest words of the same length, return the one which appears first. - The file could be large, so performance should be efficient. # Requirements - Handle edge cases such as an empty file by raising a `ValueError` with the message `\\"File is empty\\"`. - The solution should be implemented with a time complexity of (O(n)) where (n) is the number of characters in the file. - You can use Python\'s standard libraries, but avoid using external packages. # Functionality Tests Ensure your function passes the following test cases: Example Text File Content (`example.txt`) ``` Innovation distinguishes between a leader and a follower. The journey of a thousand miles begins with one step. Great minds discuss ideas; average minds discuss events; small minds discuss people. ``` ```python >>> longest_word_frequency(\\"example.txt\\") (\'distinguishes\', 1) ``` Empty Text File (`empty.txt`) ```python >>> longest_word_frequency(\\"empty.txt\\") Traceback (most recent call last): ... ValueError: File is empty ``` Another Text File Content (`another_example.txt`) ``` Python is powerful... and fast; plays well with others; runs everywhere; is friendly & easy to learn; is Open. ``` ```python >>> longest_word_frequency(\\"another_example.txt\\") (\'everywhere\', 1) ``` # Scenario In a digital library system, you want to analyze documents to find key terms. Using the `longest_word_frequency` function, you can extract and report the most critical term (the longest word) and how frequently it appears in any given file. This can help in creating summaries or creating searchable indexes for large collections of text documents.","solution":"import re def longest_word_frequency(file_path: str) -> tuple: try: with open(file_path, \'r\') as file: text = file.read().strip() if not text: raise ValueError(\\"File is empty\\") words = re.findall(r\'bw+b\', text) longest_word = \'\' frequency = 0 word_count = {} # Find the longest word and count the frequencies of all words for word in words: if len(word) > len(longest_word): longest_word = word frequency = 1 elif len(word) == len(longest_word): if word == longest_word: frequency += 1 # Since the task specifies to return the first appearing word, we do not change the longest_word word_count[word] = word_count.get(word, 0) + 1 return longest_word, word_count[longest_word] except FileNotFoundError: raise ValueError(\\"File not found\\") except Exception as e: raise ValueError(\\"An error occurred: \\" + str(e))"},{"question":"# Coding Question on Data Structures and Algorithms - Maximum Subarray Sum with Constraints Context In computer science, the maximum subarray problem is a canonical example of dynamic programming. You\'re tasked with extending this problem by applying additional constraints in the subarray selection process. Problem Design a function `max_subarray_sum_with_k_distinct(nums, k)`, where `nums` is a list of integers, and `k` is an integer representing the maximum number of distinct integers allowed in the subarray. The function should return the maximum possible sum of any contiguous subarray of `nums` that contains at most `k` distinct integers. Requirements To achieve this: 1. Implement an efficient algorithm to traverse through `nums` and keep track of subarrays with at most `k` distinct integers. 2. Use appropriate data structures to dynamically maintain the count of distinct integers in the current subarray. 3. Ensure the function responds efficiently for large lists with modern computational constraints. Input and Output * **Input**: - A list of integers `nums` (e.g., `[1, 2, 1, 2, 3]`) - An integer `k` representing the maximum number of distinct integers allowed in the subarray (e.g., `2`) * **Output**: - An integer representing the maximum sum of any subarray with at most `k` distinct integers. Implementation Constraints * Optimize for performance, especially with respect to handling large input sizes. * Make use of sliding window and hash table techniques to manage the subarray properties efficiently. Example ```python def max_subarray_sum_with_k_distinct(nums, k): # Your code here # Example: print(max_subarray_sum_with_k_distinct([1, 2, 1, 2, 3], 2)) # Expected output: 6 (subarray: [1, 2, 1, 2]) ``` You are required to provide a function definition for `max_subarray_sum_with_k_distinct(nums, k)` and ensure it accurately produces the expected output for the given example case. Utilize appropriate techniques to maintain optimal performance and correctness.","solution":"def max_subarray_sum_with_k_distinct(nums, k): Returns the maximum sum of any contiguous subarray of nums that contains at most k distinct integers. from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 left = 0 current_sum = 0 max_sum = float(\'-inf\') counts = defaultdict(int) for right in range(n): counts[nums[right]] += 1 current_sum += nums[right] while len(counts) > k: counts[nums[left]] -= 1 current_sum -= nums[left] if counts[nums[left]] == 0: del counts[nums[left]] left += 1 if len(counts) <= k: max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Statement **City Planning: Park Allocation Algorithm** You are assisting the city planning department of Greenfields City in implementing an algorithm for efficiently allocating parks to residential blocks. The block map is represented by a 2D grid where each cell contains either a `1` (representing a residential block) or a `0` (representing an empty space or park). You are assigned to check if each residential block has at least one park in its row or column. Write a Python function `has_access_to_park(grid: List[List[int]]) -> bool` that returns `True` if every residential block in the grid has access to at least one park in the same row or column; otherwise, returns `False`. **Input Format:** - A 2D list `grid` of size `m x n`, where each element is either `1` (residential block) or `0` (park). **Output Format:** - Returns `True` if every residential block in the grid has access to at least one park, otherwise returns `False`. **Constraints:** - The grid will have at least one row and one column. - The size of the grid does not exceed 100x100. **Examples:** ```python >>> has_access_to_park([[1, 0, 0], [0, 1, 0], [0, 0, 0]]) True >>> has_access_to_park([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) False >>> has_access_to_park([[0, 1, 0], [0, 0, 0], [1, 0, 1]]) True >>> has_access_to_park([[1, 0], [1, 1], [0, 1]]) True >>> has_access_to_park([[1]]) False >>> has_access_to_park([[0]]) True ``` Implement the function using the algorithm description provided.","solution":"from typing import List def has_access_to_park(grid: List[List[int]]) -> bool: rows = len(grid) cols = len(grid[0]) row_with_park = [False] * rows col_with_park = [False] * cols # Determine rows and columns that have parks for r in range(rows): for c in range(cols): if grid[r][c] == 0: row_with_park[r] = True col_with_park[c] = True # Check if each residential block has access to at least one park in its row or column for r in range(rows): for c in range(cols): if grid[r][c] == 1: if not row_with_park[r] and not col_with_park[c]: return False return True"},{"question":"**File System Management and Directory Traversal** # Problem Description You are tasked with writing a Python function that navigates through a given directory structure and returns the file paths of all text files (.txt) found within it. The function should search through all subdirectories recursively and return a list of text file paths relative to the initial directory. # Function Specification Write a function `find_text_files(directory_path: str) -> List[str]` which takes in the path to the directory and returns a list of relative file paths for all .txt files found. Input - `directory_path` (str): A string representing the path to the directory that needs to be scanned for text files. Output - A list of strings representing the relative paths to the text files found. Constraints - You can assume the directory path provided is valid and accessible. - The directory traversal should be recursive. - Return the file paths in relative format, starting from the given directory path. # Example ```python def find_text_files(directory_path: str) -> List[str]: # implement here # Consider the directory structure: # /testdir # │ # ├── file1.txt # ├── file2.txt # ├── subdir1 # │ ├── file3.txt # │ └── file4.doc # └── subdir2 # └── subdir3 # └── file5.txt directory_path = \'/testdir\' print(find_text_files(directory_path)) # Output: [\'file1.txt\', \'file2.txt\', \'subdir1/file3.txt\', \'subdir2/subdir3/file5.txt\'] ``` # Requirements - Handle edge cases where no text files are found. - Consider performance implications, ensuring that your solution is optimal even for deeply nested directories. - Ensure the function gracefully handles directories with a large number of files and subdirectories. Good luck!","solution":"import os from typing import List def find_text_files(directory_path: str) -> List[str]: def recursively_find_files(current_path: str, base_path: str) -> List[str]: files_found = [] for entry in os.listdir(current_path): full_path = os.path.join(current_path, entry) if os.path.isdir(full_path): files_found.extend(recursively_find_files(full_path, base_path)) elif os.path.isfile(full_path) and entry.endswith(\'.txt\'): relative_path = os.path.relpath(full_path, base_path) files_found.append(relative_path) return files_found return recursively_find_files(directory_path, directory_path)"},{"question":"Scenario Graph traversal algorithms form the basis of many complex computing tasks, from web crawling to network analysis. Testing your ability to implement such algorithms in an efficient manner is crucial. In this problem, you will use your knowledge of depth-first search (DFS) to explore a given graph. Problem Statement Given an undirected graph represented as an adjacency list, implement the function `graph_components(graph: Dict[int, List[int]]) -> List[List[int]]`, which identifies and returns all connected components of the graph. Input - `graph` (dictionary): A dictionary where the keys represent nodes and the values are lists of integers representing the nodes connected to the key node. Keys are unique integers. Output - Returns a list of lists, where each nested list represents a connected component of the graph, containing the node elements of that component. Each component should be listed in ascending order. Function Signature ```python def graph_components(graph: Dict[int, List[int]]) -> List[List[int]]: pass ``` Example ```python >>> graph_components({0: [1, 2], 1: [0, 2], 2: [0, 1], 3: [4], 4: [3]}) [[0, 1, 2], [3, 4]] >>> graph_components({1: [2], 2: [1, 3], 3: [2], 4: [5], 5: [4]}) [[1, 2, 3], [4, 5]] >>> graph_components({1: [], 2: [], 3: []}) [[1], [2], [3]] ``` Constraints - The graph does not contain any self-loops or parallel edges. - Nodes in each component list, as well as the component lists themselves, should be sorted in ascending order. - Attention should be paid to the efficiency of the DFS implementation to handle large graphs. Note Optimizations that minimize redundant node visits and ensure a linear traversal of the graph will be beneficial to achieving optimal performance.","solution":"from typing import Dict, List def graph_components(graph: Dict[int, List[int]]) -> List[List[int]]: def dfs(node, visited, component): stack = [node] while stack: current = stack.pop() if current not in visited: visited.add(current) component.append(current) for neighbor in graph.get(current, []): if neighbor not in visited: stack.append(neighbor) visited = set() components = [] for node in graph.keys(): if node not in visited: component = [] dfs(node, visited, component) components.append(sorted(component)) return sorted(components, key=lambda x: x[0])"},{"question":"Coding Question: Implement RGB to HSL Color Conversion Function # Context Color conversions between different color models (e.g., RGB to HSL) are common tasks in computer graphics, image processing, and web development. The HSL model represents a color in terms of its hue, saturation, and lightness components, which can be more intuitive to manipulate compared to the RGB model. # Task **Implement a function that converts colors from RGB format to HSL format. Your implementation should correctly process the given input even in cases of edge values, ensuring accuracy.** # Input - `r` (float): Red component of the color, ranging from 0 to 255. - `g` (float): Green component of the color, ranging from 0 to 255. - `b` (float): Blue component of the color, ranging from 0 to 255. # Output - A tuple (h, s, l) representing the color in HSL format, where: - `h` (float): Hue component, ranging from 0 to 360. - `s` (float): Saturation component, ranging from 0 to 1. - `l` (float): Lightness component, ranging from 0 to 1. # Requirements - Your function should handle edge cases where the RGB values are at extreme ends (0 or 255). - Ensure the conversion is accurate and numerically stable. # Constraints - The input values for r, g, and b will be within the range of 0 to 255. # Example ```python >>> rgb_to_hsl(255, 0, 0) (0.0, 1.0, 0.5) >>> rgb_to_hsl(0, 128, 0) (120.0, 1.0, 0.25) >>> rgb_to_hsl(255, 255, 255) (0.0, 0.0, 1.0) ``` # Implementation Notes 1. Normalize the RGB values to the range [0, 1] by dividing them by 255. 2. Use the standard formulas for converting from RGB to HSL. 3. Ensure your function handles edge values accurately, including cases where the RGB values are the same. ```python def rgb_to_hsl(r: float, g: float, b: float) -> tuple: Convert RGB color to HSL color. # Normalize RGB values to [0, 1] r /= 255 g /= 255 b /= 255 max_c = max(r, g, b) min_c = min(r, g, b) d = max_c - min_c # Calculate Lightness l = (max_c + min_c) / 2 if d == 0: # If there is no difference, it\'s a shade of gray h = 0.0 s = 0.0 else: # Calculate Saturation s = d / (1 - abs(2 * l - 1)) # Calculate Hue if max_c == r: h = 60 * (((g - b) / d) % 6) elif max_c == g: h = 60 * (((b - r) / d) + 2) elif max_c == b: h = 60 * (((r - g) / d) + 4) return h, s, l # Test cases if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` This question integrates into the existing set by maintaining the programming complexity and ensuring the handling of edge cases in color conversion, similar to the numerical stability required in the GELU function.","solution":"def rgb_to_hsl(r, g, b): Convert RGB color to HSL color. Args: r (float): Red component of the color, ranging from 0 to 255. g (float): Green component of the color, ranging from 0 to 255. b (float): Blue component of the color, ranging from 0 to 255. Returns: tuple: A tuple (h, s, l) representing the color in HSL format, where: - h (float): Hue component, ranging from 0 to 360. - s (float): Saturation component, ranging from 0 to 1. - l (float): Lightness component, ranging from 0 to 1. r /= 255.0 g /= 255.0 b /= 255.0 max_c = max(r, g, b) min_c = min(r, g, b) delta = max_c - min_c l = (max_c + min_c) / 2.0 if delta == 0: h = 0.0 s = 0.0 else: s = delta / (1.0 - abs(2.0 * l - 1.0)) if max_c == r: h = 60 * (((g - b) / delta) % 6) elif max_c == g: h = 60 * (((b - r) / delta) + 2) elif max_c == b: h = 60 * (((r - g) / delta) + 4) h = round(h, 2) s = round(s, 2) l = round(l, 2) return h, s, l"},{"question":"# Recursive Directory Listing with File Type Counting Implement a program that traverses a directory structure recursively and counts the occurrences of different file types. The file type is determined by the file extension. You should return a dictionary where the keys are the file extensions and the values are the counts of files with those extensions. # Instructions: 1. Create a function `count_file_types(directory_path: str)` that takes the path to the root directory. 2. Traverse the directory and its subdirectories recursively. 3. For each file encountered, determine its extension and update the count in a dictionary. 4. Ignore files that do not have an extension. 5. Return the dictionary with the file type counts. # Input: * Path to a root directory to begin traversal. # Output: * Dictionary where the keys are file extensions (including the dot, e.g., `.txt`) and the values are the counts of files with those extensions. # Constraints: * Use the `os` and `os.path` libraries for file system operations. * Do not count directories, only files. * Handle edge cases where the directory might be empty or contain files without an extension. # Example: ```python / |-- dir1 | |-- file1.txt | |-- file2.csv | |-- file3.txt |-- dir2 | |-- file4.csv | |-- file5 |-- dir3 | |-- file6.doc |-- file7.txt ``` Calling `count_file_types(\'/\')` should return: ```python { \'.txt\': 3, \'.csv\': 2, \'.doc\': 1 } ``` # Function Signature: ```python def count_file_types(directory_path: str) -> dict: pass # Usage Example directory_path = \\"/path/to/your/directory\\" result = count_file_types(directory_path) print(result) # Output example: {\'.txt\': 3, \'.csv\': 2, \'.doc\': 1} ```","solution":"import os def count_file_types(directory_path: str) -> dict: file_type_count = {} for root, _, files in os.walk(directory_path): for file in files: ext = os.path.splitext(file)[1] if ext: # Check if file has an extension if ext in file_type_count: file_type_count[ext] += 1 else: file_type_count[ext] = 1 return file_type_count"},{"question":"# Array Majority Element Finder In this task, you will find the majority element in a given list of integers. A majority element is an element that appears more than `n // 2` times in a list of size `n`. Scenario You are implementing a feature for a data analysis tool that needs to quickly identify the most frequent item in a dataset. To simplify, assume the task is to detect the majority element, if any, in an array of integers. Function Signature ```python def find_majority_element(nums: list[int]) -> int: This function receives a list of integers and finds the majority element in the list. Args: nums (list[int]): A list of integers. Returns: int: The majority element in the list. If no majority element exists, return -1. ``` Input - A list of integers `nums` which can have any integer values, including repetitions. Output - The integer that is the majority element if it exists, otherwise `-1`. Constraints - The length of the list `n` is at most 10^5. - The elements in the list fit within a signed 32-bit integer range. Examples ```python >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 5, 2, 4]) -1 >>> find_majority_element([1, 1, 1, 1, 2, 2, 2]) 1 >>> find_majority_element([1]) 1 >>> find_majority_element([1, 2, 3, 4, 5]) -1 ``` Requirements - Run in linear time O(n). - Use constant space O(1) beyond the input list Tips - Consider using the Boyer-Moore Voting Algorithm for an efficient solution. - Handle edge cases where the array length is less than or equal to 1. Implement the function `find_majority_element` and test it with appropriate inputs.","solution":"def find_majority_element(nums: list[int]) -> int: This function receives a list of integers and finds the majority element in the list. Args: nums (list[int]): A list of integers. Returns: int: The majority element in the list. If no majority element exists, return -1. candidate, count = 0, 0 # Step 1: Find a candidate for majority element for num in nums: if count == 0: candidate = num count += (1 if num == candidate else -1) # Step 2: Verify if the candidate is actually the majority element if nums.count(candidate) > len(nums) // 2: return candidate else: return -1"},{"question":"# Array Rotation Context In many applications such as data processing or game development, it\'s often necessary to manipulate arrays or lists by rotating their elements. Understanding and implementing efficient array manipulation techniques is pivotal for optimizing performance in such tasks. Task Develop a function that rotates an array to the right by a given number of steps. Specific Objectives 1. **Efficiency**: Ensure the algorithm performs in O(n) time complexity, where n is the number of elements in the array. 2. **Memory Usage**: Optimize for minimal additional memory usage. Function Signature ```python def rotate_array(nums: List[int], k: int) -> List[int]: pass ``` Input - `nums`: A list of integers of length `n`. - `k`: An integer representing the number of steps to rotate the array. Output - Returns a rotated list of integers of length `n`. Constraints - (1 leq n leq 10^5) - (0 leq k < 10^5) - (-10^9 leq text{nums}[i] leq 10^9) for all `nums[i]`. Requirements - Your solution should handle edge cases such as `k` being greater than the length of the array and `k` equal to 0. - Use an in-place algorithm if possible or optimize for minimal extra memory usage. - Rotate the elements of the array to the right by `k` steps, effectively bringing the last `k` elements to the front. Example ```python def rotate_array(nums: List[int], k: int) -> List[int]: n = len(nums) k %= n return nums[-k:] + nums[:-k] # Example print(rotate_array([1, 2, 3, 4, 5, 6, 7], 3)) # Output: [5, 6, 7, 1, 2, 3, 4] print(rotate_array([-1, -100, 3, 99], 2)) # Output: [3, 99, -1, -100] ``` Explanation In the example: - The first call rotates the array `[1, 2, 3, 4, 5, 6, 7]` by 3 steps to the right, resulting in `[5, 6, 7, 1, 2, 3, 4]`. - The second call rotates the array `[-1, -100, 3, 99]` by 2 steps to the right, resulting in `[3, 99, -1, -100]`. Good luck!","solution":"from typing import List def rotate_array(nums: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. n = len(nums) k %= n # In case k is greater than the length of the array return nums[-k:] + nums[:-k]"},{"question":"# Path Simplification in a Unix-like Filesystem You are required to implement a function that simplifies a given Unix-like absolute file path. Function Signature ```python def simplify_path(path: str) -> str: pass ``` Input: - `path` (str): An absolute Unix-like file path. Output: - Returns a simplified version of the absolute file path as a string. Constraints: - The input path will always start with a `/`. - The input path will only contain lowercase alphabets, `/`, `.` and `..`. - The return path must be a valid absolute path. - Avoid unnecessary elements like multiple consecutive slashes or `.` and simplify `..`. Requirements: - The function should run with a time complexity of ( O(n) ), where ( n ) is the length of the path. - The function should handle edge cases such as root directory and paths containing multiple `.` and `..`. Example: ```python result = simplify_path(\\"/a/./b/../../c/\\") print(result) # Expected output: \\"/c\\" result = simplify_path(\\"/home//foo/\\") print(result) # Expected output: \\"/home/foo\\" result = simplify_path(\\"/../\\") print(result) # Expected output: \\"/\\" result = simplify_path(\\"/home/../../\\") print(result) # Expected output: \\"/\\" ``` Scenario: Consider you are working with a system that needs to process a large number of file path entries. Simplifying the paths optimizes the subsequent file operations and reduces complexity. For instance, you might receive file paths containing redundant sequences like multiple slashes (`//`), current directory references (`.`), and parent directory references (`..`). Implement the `simplify_path` function to convert such paths to a canonical form, ensuring efficient file system navigation.","solution":"def simplify_path(path: str) -> str: Simplifies a given Unix-like absolute file path. Parameters: path (str): An absolute Unix-like file path. Returns: str: A simplified version of the absolute file path. parts = path.split(\'/\') stack = [] for part in parts: if part == \'..\': if stack: stack.pop() elif part and part != \'.\': stack.append(part) return \'/\' + \'/\'.join(stack)"},{"question":"# Coding Assessment Question **Scenario**: You have been asked to implement a feature in the `BinarySearchTree` class that enhances its capabilities to handle common tree operations more efficiently. Specifically, you need to add functionalities that will find the height of the tree, check if the tree is balanced, and handle duplicate values in a specified manner. **Requirements**: 1. **Height Calculation**: Implement a method to calculate the height of the binary search tree. 2. **Balanced Tree Check**: Provide a function to determine whether the binary search tree is balanced. 3. **Duplicate Handling**: Adjust the insertion logic to handle duplicate values: - If a duplicate value is encountered, increase a counter associated with that node instead of inserting a new node. **Function Implementation**: 1. **insert(value: int) -> None** - Parameter: - `value`: The integer value to insert into the binary search tree. - Inserts the value into the BST, maintaining BST properties. 2. **height() -> int** - Returns the height of the binary search tree. 3. **is_balanced() -> bool** - Returns `True` if the binary search tree is balanced, `False` otherwise. 4. **find(value: int) -> int** - Parameter: - `value`: The integer value to search for in the binary search tree. - Returns the count of the specified `value` in the binary search tree. **Definitions**: - **Balanced Tree**: A binary tree is balanced if the height of the two subtrees of any node never differ by more than one. **Input**: ```python bst = BinarySearchTree() bst.insert(10) bst.insert(5) bst.insert(15) bst.insert(5) bst.insert(2) bst.insert(20) ``` **Output**: ```python # After insertion: # Tree structure: # 10 # / # 5 15 # / # 2 20 # Duplicate 5 count: [5: 2] # Check the height of the tree: 3 # Check if the tree is balanced: True # Find value 5 in the BST: 2 ``` **Constraints**: - Nodes can have integer values ranging from -10^9 to 10^9. - The binary search tree can contain up to 10^5 nodes. - Implement the tree operations with optimal time complexities. Ensure your solution includes various test cases and edge conditions to confirm the accuracy, performance, and robustness of your changes.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.count = 1 # Start counter at 1 for the new node class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int) -> None: if not self.root: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, current_node, value): if value < current_node.value: if current_node.left: self._insert_recursive(current_node.left, value) else: current_node.left = TreeNode(value) elif value > current_node.value: if current_node.right: self._insert_recursive(current_node.right, value) else: current_node.right = TreeNode(value) else: current_node.count += 1 def height(self) -> int: def _height(node): if not node: return -1 left_height = _height(node.left) right_height = _height(node.right) return max(left_height, right_height) + 1 return _height(self.root) def is_balanced(self) -> bool: def _check_balance(node): if not node: return (True, 0) left_balanced, left_height = _check_balance(node.left) right_balanced, right_height = _check_balance(node.right) balanced = (left_balanced and right_balanced and abs(left_height - right_height) <= 1) height = max(left_height, right_height) + 1 return (balanced, height) balanced, _ = _check_balance(self.root) return balanced def find(self, value: int) -> int: def _find_recursive(node, value): if not node: return 0 if value < node.value: return _find_recursive(node.left, value) elif value > node.value: return _find_recursive(node.right, value) else: return node.count return _find_recursive(self.root, value)"},{"question":"# Scenario You are helping to develop a feature for a text processing application. One of the functionalities required is to find and return the longest substring of a given string that only contains unique characters. # Problem Statement Given a string `s`, write a function `longest_unique_substring(s: str) -> str` that returns the longest substring without repeating characters. # Input * `s` (String): The input string (1 ≤ len(s) ≤ 10^5). # Output * Return the longest substring of `s` that contains unique characters. # Example ```python >>> longest_unique_substring(\\"abcabcbb\\") \\"abc\\" >>> longest_unique_substring(\\"bbbbb\\") \\"b\\" >>> longest_unique_substring(\\"pwwkew\\") \\"wke\\" ``` # Constraints * If there are multiple substrings with the same maximum length, return the first one that appears. # Note Consider the use of a sliding window technique to optimize the time complexity of finding the longest substring without repeating characters. # Solution Explanation 1. Utilize a sliding window to maintain a window of unique characters. 2. Use a set or map to track characters and their positions in the current window. 3. Adjust the window boundaries to ensure all characters within the window are unique.","solution":"def longest_unique_substring(s: str) -> str: Returns the longest substring without repeating characters. start = 0 max_length = 0 max_substring = \\"\\" char_index_map = {} for end in range(len(s)): if s[end] in char_index_map and char_index_map[s[end]] >= start: start = char_index_map[s[end]] + 1 char_index_map[s[end]] = end current_length = end - start + 1 if current_length > max_length: max_length = current_length max_substring = s[start:end + 1] return max_substring"},{"question":"# Problem Statement You are given a 2D matrix of integers and an integer target value. Your task is to determine if the target value exists in the matrix. The matrix has the following properties: 1. Integers in each row are sorted in ascending order from left to right. 2. Integers in each column are sorted in ascending order from top to bottom. # Objective Write a function `search_2d_matrix(matrix, target)` that takes a 2D matrix and a target integer and returns `True` if the target value exists in the matrix, otherwise returns `False`. # Input - `matrix`: A list of lists of integers, representing the 2D matrix. Each list within the matrix represents a row. - `target`: An integer, representing the target value to be searched for in the matrix. # Output - Returns `True` if the target value exists in the matrix, otherwise returns `False`. # Constraints - The number of rows (m) and columns (n) in the matrix will be between 0 and 300. - Each integer in the matrix is within the range -10^9 to 10^9. - The matrix can be empty. # Performance Requirements The function should be optimized to handle the matrix efficiently, ideally with a time complexity of O(m + n). # Example ```python # Given matrix: # [ # [1, 4, 7, 11, 15], # [2, 5, 8, 12, 19], # [3, 6, 9, 16, 22], # [10, 13, 14, 17, 24], # [18, 21, 23, 26, 30] # ] # Target value: # 5 # The value 5 exists in the matrix, so the function should return True. matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 # Function to search the target value in 2D matrix def search_2d_matrix(matrix: list[list[int]], target: int) -> bool: if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False # Testing the function print(search_2d_matrix(matrix, target)) # Output: True ```","solution":"def search_2d_matrix(matrix, target): Search for a target value in a 2D matrix with sorted rows and columns. Args: matrix (list of list of int): The 2D matrix to search in. target (int): The target value to search for. Returns: bool: True if the target value is found, False otherwise. if not matrix or not matrix[0]: return False rows = len(matrix) cols = len(matrix[0]) # Start from the top-right corner of the matrix. row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"**Question: Circular Array Rotation** In many applications, such as cyclic queues, it is useful to rotate an array cyclically. The goal here is to perform a number of right rotations on an array, such that the elements wrap around from the end to the beginning. # Function Specification **Function**: `circular_array_rotation` **Input**: * `arr` (List[int]): The list of integers to be rotated. * `k` (int): The number of times to rotate the array to the right. **Output**: * `List[int]`: The array after `k` right rotations have been performed. # Constraints 1. The length of `arr` is between 1 and 10^5. 2. The values in `arr` are integers between -10^9 and 10^9. 3. `k` is a non-negative integer. # Requirements * Efficiently handle large input sizes and optimize for edge cases, such as rotating by the length of the array or when `k` is much larger than the length of the array. # Example ```python >>> circular_array_rotation([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_array_rotation([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> circular_array_rotation([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] >>> circular_array_rotation([1], 10) [1] ``` # Function Signature ```python from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: pass ``` Implement the function `circular_array_rotation` to meet the requirements and constraints laid out in the problem description.","solution":"from typing import List def circular_array_rotation(arr: List[int], k: int) -> List[int]: Rotates the array to the right by k steps. :param arr: List of integers to be rotated. :param k: Number of right rotations. :return: The array after k right rotations. n = len(arr) if n == 0: return arr # Normalize k to ensure it is within the bounds of the array length k = k % n # Split and concatenate the subarrays to form the rotated array return arr[-k:] + arr[:-k]"},{"question":"# Coding Assessment Question Context: You are given a list of continuous events happening within a day, characterized by their starting and ending times. Each event is represented by a tuple (start_time, end_time), where `0 ≤ start_time < end_time ≤ 1440`. Your task is to determine the maximum number of non-overlapping events that can be attended in a single day. Task: Implement a function `max_non_overlapping_events(events)` that takes a list of tuples representing the start and end times of events, and returns the maximum number of non-overlapping events that can be attended. Function Signature: ```python def max_non_overlapping_events(events: list[tuple[int, int]]) -> int: ``` Input: - `events`: A list of tuples, where each tuple contains two integers (`0 ≤ len(events) ≤ 10^5`, `0 ≤ start_time < end_time ≤ 1440`). Output: - An integer representing the maximum number of non-overlapping events. Examples: ```python assert max_non_overlapping_events([(1, 3), (2, 5), (6, 9), (8, 10)]) == 2 assert max_non_overlapping_events([(0, 30), (31, 60), (60, 90)]) == 3 assert max_non_overlapping_events([(0, 10), (15, 20), (10, 15), (25, 30)]) == 4 assert max_non_overlapping_events([(5, 10), (10, 15), (15, 20), (20, 25)]) == 4 assert max_non_overlapping_events([]) == 0 ``` Constraints: - The function should have a time complexity of (O(n log n)) and a space complexity of (O(1)). **Performance Requirements**: Ensure the implementation efficiently selects the non-overlapping events while considering the sorting criteria to minimize the ending times for optimal selection. Notes: - Sorting events by their ending time is a common strategy in the greedy algorithm to maximize the number of non-overlapping intervals. - Handle edge cases such as empty lists and events that occupy the entire time range effectively.","solution":"def max_non_overlapping_events(events): Returns the maximum number of non-overlapping events that can be attended. if not events: return 0 # Sort events by their ending times events.sort(key=lambda x: x[1]) count = 0 end_time = 0 # Iterate over the sorted events for start, end in events: if start >= end_time: # If the event does not overlap, attend it count += 1 end_time = end return count"},{"question":"# Coding Question - Node Depth Calculation in Binary Tree **Context**: You are given a basic implementation of a binary tree. Each node in the binary tree contains an integer value and pointers to its left and right children. The binary tree supports operations such as insertion and traversal. Your task is to add an additional function that calculates the depth at which each node is located within the tree. **Task**: Your task is to implement the `calculate_depths` function which will populate each node of the binary tree with an additional attribute `depth` that indicates its depth in the tree. The root node has a depth of 0. **Requirements**: 1. Implement the `calculate_depths` method: ```python def calculate_depths(self) -> None: # code to calculate depths of each node ``` 2. The method should traverse the entire tree and set the `depth` attribute for each node appropriately. 3. Modify the `BinaryTree` and `TreeNode` classes based on the provided structure to include this functionality. **Class Definitions**: ```python class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.depth = None # Depth attribute to be set by calculate_depths class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursively(self.root, value) def _insert_recursively(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursively(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursively(node.right, value) def calculate_depths(self) -> None: # Implement this method pass ``` **Example**: ```python tree = BinaryTree() tree.insert(10) tree.insert(5) tree.insert(15) tree.insert(3) tree.insert(7) tree.insert(12) tree.insert(17) tree.calculate_depths() # After calculating depths: # root node (10) depth should be 0 # nodes (5, 15) depth should be 1 # nodes (3, 7, 12, 17) depth should be 2 ``` **Function Signature**: ```python def calculate_depths(self) -> None: pass ``` **Example Execution**: ```python tree = BinaryTree() tree.insert(10) # Depth of 10 should be 0 tree.insert(5) # Depth of 5 should be 1 tree.insert(15) # Depth of 15 should be 1 tree.calculate_depths() print(tree.root.depth) # Outputs: 0 print(tree.root.left.depth) # Outputs: 1 print(tree.root.right.depth) # Outputs: 1 ``` **Constraints**: * The method should effectively compute depths in O(n) where n is the number of nodes in the tree. * Ensure the existing functionality of the tree remains intact while adding the new method. Implement your solution in the provided classes, making necessary adjustments to accommodate the new depth attribute.","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None self.depth = None # Depth attribute to be set by calculate_depths class BinaryTree: def __init__(self): self.root = None def insert(self, value): if self.root is None: self.root = TreeNode(value) else: self._insert_recursively(self.root, value) def _insert_recursively(self, node, value): if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursively(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursively(node.right, value) def calculate_depths(self) -> None: def _set_depths(node, depth): if node is not None: node.depth = depth _set_depths(node.left, depth + 1) _set_depths(node.right, depth + 1) _set_depths(self.root, 0)"},{"question":"# Problem Statement You are given a list of strings where each string can contain any characters. A special set of words is defined as a collection of strings where no string is a prefix of another string in the set. Your task is to find and return the maximum possible size of any special set of words that can be formed from the given list of strings. # Function Signature ```python def max_special_set(words: List[str]) -> int: ``` # Input * `words`: A list of strings (`List[str]`), where each string can be of length between 1 and 50. # Output * An integer representing the maximum possible size of a special set of words. # Constraints * The list `words` will not contain more than 1000 strings. * Each string consists of lowercase alphabets only. # Example ```python words = [\\"apple\\", \\"app\\", \\"banana\\", \\"ban\\", \\"bat\\", \\"batt\\"] print(max_special_set(words)) # Output: 3 ``` **Explanation**: * A special set of size 3 can be formed from the words [\\"banana\\", \\"bat\\", \\"apple\\"], none of which is a prefix of another word in the set.","solution":"def max_special_set(words): Returns the maximum possible size of a special set of words. words.sort() # Sort words to handle prefixes efficiently max_set = [] for word in words: is_prefix = False for w in max_set: if word.startswith(w): is_prefix = True break if not is_prefix: max_set.append(word) return len(max_set)"},{"question":"# Problem Statement You are provided with an implementation of a stack data structure in Python which includes the push and pop operations. Your task is to extend this stack class by adding a new function that finds and returns the minimum element in the stack without removing any elements from the stack. # Function Details Function Name: `get_min` * **Input**: None * **Output**: An integer representing the minimum element in the stack. * **Description**: This function should traverse the stack and return the smallest element currently stored. Do not remove any elements as part of this operation. # Example ```python >>> stack = Stack() >>> for value in [3, 5, 2, 1, 4]: ... stack.push(value) >>> stack.get_min() 1 >>> stack.pop() 4 >>> stack.get_min() 1 >>> stack.pop() 1 >>> stack.get_min() 2 ``` # Constraints 1. The stack can contain any number of elements, including being empty. 2. If the stack is empty, the function should return `None`. 3. You are not allowed to use any additional data structures; traverse the elements within the existing stack. **Note**: You may want to implement methods to traverse and print the stack for validation and testing purposes. Good luck, and ensure your solution is efficient and adheres to the stack principles as discussed.","solution":"class Stack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def pop(self): if not self.is_empty(): return self.stack.pop() def is_empty(self): return len(self.stack) == 0 def get_min(self): if self.is_empty(): return None min_value = self.stack[0] for value in self.stack: if value < min_value: min_value = value return min_value"},{"question":"**Context**: In many software applications, efficient searching algorithms are essential for retrieving information quickly. One such algorithm is the Binary Search, which operates on sorted collections and provides a logarithmic time complexity, making it highly efficient compared to linear search. # Problem Statement Implement a modified version of the Binary Search algorithm that returns the index of the target element in a sorted list of integers. Additionally, the algorithm should handle cases where the target element appears multiple times by returning the index of the first occurrence. # Requirements * **Function Name**: `binary_search_first_occurrence` * **Input**: A sorted list of integers `collection` and a target integer `target` * **Output**: The index of the first occurrence of the target integer in `collection`, or -1 if the target is not found # Constraints - Do not use built-in search functions. - The input list is assumed to be sorted in ascending order. # Performance - Aim for a time complexity of O(log n). # Example ```python def binary_search_first_occurrence(collection: list, target: int) -> int: # Your code here # Examples: print(binary_search_first_occurrence([1, 3, 3, 5, 7, 9], 3)) # Output: 1 print(binary_search_first_occurrence([1, 2, 4, 4, 4, 5, 6], 4)) # Output: 2 print(binary_search_first_occurrence([1, 2, 3, 4, 5, 6], 7)) # Output: -1 print(binary_search_first_occurrence([], 3)) # Output: -1 print(binary_search_first_occurrence([2, 4, 4, 4, 5, 6, 8, 8, 10], 8)) # Output: 6 ``` # Special Considerations - Your function should handle edge cases, such as an empty list or list without the target element. - Ensure that if the target element appears multiple times, the index of its first occurrence is returned. - Validate inputs and handle cases gracefully where the provided input does not meet the expected constraints. # Testing Create a series of unit tests to validate your function under different scenarios including edge cases, average random input, and worst-case scenarios.","solution":"def binary_search_first_occurrence(collection: list, target: int) -> int: Perform a modified binary search to find the first occurrence of the target element in a sorted list. Args: collection (list): A sorted list of integers. target (int): The target integer to be searched in the list. Returns: int: The index of the first occurrence of the target element in the collection, or -1 if the target is not found. left, right = 0, len(collection) - 1 result = -1 while left <= right: mid = (left + right) // 2 if collection[mid] == target: result = mid # Found the target, but keep searching to the left to find the first occurrence right = mid - 1 elif collection[mid] < target: left = mid + 1 else: right = mid - 1 return result"},{"question":"# Coding Exercise: Seamless Array Transformation You are given an array of integers `arr` where each element represents the time taken in milliseconds to process a particular task. You need to transform the array such that each transformation adheres to the following rules: - If `arr[i] > arr[j]` for `i < j`, swap `arr[i]` and `arr[j]`. - Continue the transformation until no qualifying pairs `(i, j)` exist. Essentially, this process results in a sorted array. Implement a function `transform_array(arr: List[int]) -> List[int]` that applies these transformations and returns the sorted array. Input * `arr` (1 ≤ len(arr) ≤ 10^5): An array of integers where each integer represents the time taken to process a particular task. Output * A list of integers, where the list is sorted in non-decreasing order after all transformations are applied. Constraints * Each transformation step must follow the given rule strictly. * Do not use any built-in sorting functions. # Example ```python def transform_array(arr: List[int]) -> List[int]: # Write your code here. # Example Usage arr = [4, 1, 3, 2] print(transform_array(arr)) # Expected Output: [1, 2, 3, 4] arr = [7, 5, 8, 6] print(transform_array(arr)) # Expected Output: [5, 6, 7, 8] ``` # Hints 1. **Bubble Sort Algorithm**: Consider implementing a variation of the bubble sort algorithm where you repeatedly step through the list, compare adjacent elements, and swap them if they are in the wrong order. 2. **In-Place Transformation**: Ensure your solution modifies the array in place without using additional arrays or Python’s built-in sort functions. 3. **Performance Considerations**: Although bubble sort has a worst-case time complexity of O(n^2), ensure your code handles larger arrays efficiently, and consider optimizations like stopping early if the array becomes sorted.","solution":"def transform_array(arr): Transforms the array in place following the given transformation rule to result in a sorted array. n = len(arr) for i in range(n): for j in range(n - 1): if arr[j] > arr[j + 1]: arr[j], arr[j + 1] = arr[j + 1], arr[j] return arr"},{"question":"# Title: Calculate Matrix Determinant # Description: A determinant is a special number that can be calculated from a square matrix. For a matrix ( A ) of order ( n times n ), the determinant determines whether the matrix is invertible. The determinant of a 2x2 matrix is given by: [ text{det}(A) = ad - bc ] where ( A = begin{bmatrix} a & b c & d end{bmatrix} ). For larger matrices, the determinant is computed using recursion with the Laplace expansion. Write a Python function `matrix_determinant(matrix: List[List[int]]) -> int` that computes the determinant of a given square matrix. # Input: * A list of lists representing the ( n times n ) matrix, with each element being an integer. # Output: * An integer representing the determinant of the matrix. # Constraints: * The matrix is square (number of rows equals number of columns). * The size of the matrix ( n ) is 1 <= n <= 10. * Each element in the matrix is an integer in the range -100 to 100. # Examples: ```python # Example function calls: print(matrix_determinant([[1, 2], [3, 4]])) # Output: -2 print(matrix_determinant([[3]])) # Output: 3 print(matrix_determinant([[2, -1, 0], [1, 2, 1], [-1, 1, 2]])) # Output: 9 ``` # Notes: * If the matrix is not square, raise a `ValueError`. * Utilize recursion for computing determinants of matrices larger than 2x2, and base cases for 1x1 and 2x2 matrices.","solution":"from typing import List def matrix_determinant(matrix: List[List[int]]) -> int: Computes the determinant of a given square matrix. :param matrix: A list of lists representing the n x n matrix. :return: An integer representing the determinant of the matrix. :raises ValueError: if the matrix is not square. n = len(matrix) # Ensure it\'s a square matrix if any(len(row) != n for row in matrix): raise ValueError(\\"The matrix must be square.\\") # Base case for 1x1 matrix if n == 1: return matrix[0][0] # Base case for 2x2 matrix if n == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] # Recursive case for n > 2 determinant = 0 for c in range(n): submatrix = [[matrix[r][cc] for cc in range(n) if cc != c] for r in range(1, n)] sign = (-1) ** c determinant += sign * matrix[0][c] * matrix_determinant(submatrix) return determinant"},{"question":"Problem Description You need to write a program that deals with text manipulation and transformation based on specific rules. This involves reversing words and capitalizing the first letter, while converting all other letters to lower case. Additionally, the program will handle punctuation in a specific way. Task 1. **reverse_and_capitalize**: * Reverse each word in a sentence. * Capitalize the first letter of the reversed word and convert all other letters to lower case. * Maintain punctuation at the end of each word in its original position, but do not reverse or capitalize it. # Input and Output Formats Function: `reverse_and_capitalize` * **Input**: * A `sentence` (string) containing words and punctuation (.,!?\'). * **Output**: * A string where each word is reversed, the first letter of each reversed word is capitalized, other letters are in lower case, and punctuation remains in its original places. * **Examples**: ```python reverse_and_capitalize(\\"Hello, world!\\") == \'Olleh, Dlrow!\' reverse_and_capitalize(\\"This is a test!\\") == \'Siht Si A Tset!\' reverse_and_capitalize(\\"Coding is fun.\\") == \'Gnidoc Si Nuf.\' ``` Implementation Details 1. Split the input `sentence` into individual words keeping punctuation. 2. Reverse each word while maintaining the punctuation as is. 3. Capitalize the first letter of each reversed word and convert all other letters to lower case. 4. Reconstruct the sentence with modified words. **Example Implementation**: ```python import re def reverse_and_capitalize(sentence): words = re.findall(r\'bw+b\', sentence) punctuations = re.findall(r\'[^ws]\', sentence) reversed_words = [] for word in words: reversed_word = word[::-1].lower().capitalize() reversed_words.append(reversed_word) result = \\"\\" index = 0 for char in sentence: if char.isalnum(): result += reversed_words[index] index += 1 else: result += char return result # Test cases print(reverse_and_capitalize(\\"Hello, world!\\")) # \'Olleh, Dlrow!\' print(reverse_and_capitalize(\\"This is a test!\\")) # \'Siht Si A Tset!\' print(reverse_and_capitalize(\\"Coding is fun.\\")) # \'Gnidoc Si Nuf.\' ``` # Notes - The implementation uses regular expressions to separate words and punctuations. - It handles capitalization and case conversion as part of reversing each word. - The solution reconstructs the result ensuring punctuation remains in place.","solution":"import re def reverse_and_capitalize(sentence): Reverse each word in the sentence, capitalize the first letter of each reversed word, lowercase all other letters, and maintain original punctuation positions. words = re.findall(r\'bw+b\', sentence) punctuations = re.findall(r\'[!.?,:;]\', sentence) reversed_words = [] for word in words: reversed_word = word[::-1].lower().capitalize() reversed_words.append(reversed_word) result = \\"\\" word_index = 0 char_index = 0 while char_index < len(sentence): if sentence[char_index].isalpha(): result += reversed_words[word_index] char_index += len(reversed_words[word_index]) word_index += 1 else: result += sentence[char_index] char_index += 1 return result"},{"question":"# Problem Statement You are provided with a string and are tasked with performing two types of operations: reversing the words in the string and counting the frequency of each character. Implement the functions `reverse_words` and `count_character_frequency`, adhering to the specifications and constraints provided below. Function 1: `reverse_words` Implement the function `reverse_words` that takes a string and reverses the order of the words. Words are considered as sequences of characters separated by spaces. ```python def reverse_words(s: str) -> str: ``` **Parameters**: - `s` (str): The input string. **Returns**: - `str`: A new string with the words in reversed order. **Example**: ```python result = reverse_words(\\"hello world this is a test\\") print(result) # Output: \\"test a is this world hello\\" ``` Function 2: `count_character_frequency` Implement the function `count_character_frequency` that counts the frequency of each character in the string. ```python def count_character_frequency(s: str) -> dict: ``` **Parameters**: - `s` (str): The input string. **Returns**: - `dict`: A dictionary where keys are characters and values are their respective counts. **Example**: ```python result = count_character_frequency(\\"hello world\\") print(result) # Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1} ``` Constraints * The input string will not contain leading or trailing spaces. * Words in the string are separated by a single space. * Handle edge cases like an empty string or a string with only one word. * Consider case-sensitivity for the character frequency count (i.e., \'A\' and \'a\' are different characters). Additional Requirements 1. Ensure your code handles edge cases effectively, such as an empty string in either of the functions. 2. Include appropriate error handling and documentation for the functions as applicable.","solution":"def reverse_words(s: str) -> str: Returns a string with the words in reversed order. :param s: The input string :return: A new string with the words in reversed order # Split the string by spaces to get words and then reverse the list words = s.split() reversed_words = words[::-1] # Join the reversed list of words back into a string return \' \'.join(reversed_words) def count_character_frequency(s: str) -> dict: Counts the frequency of each character in the string. :param s: The input string :return: A dictionary with characters as keys and their frequencies as values frequency = {} # Count each character in the string for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency"},{"question":"# Problem Statement You are a software developer for a travel application, and you need to implement a function that determines the optimal order to visit a series of attractions in a single day while minimizing travel time. The app provides distances between pairs of attractions. # Function Specification **Function Name**: `optimal_attraction_order` **Input**: - `start` (str): The starting point\'s name (can be any attraction). - `attractions` (List[str]): List of attractions to visit. Each attraction name is unique and does not include the start point. - `distances` (Dict[Tuple[str, str], int]): A dictionary where the keys are tuples representing pairs of attractions, and the values are the distances between them. Each distance is a positive integer. **Output**: - `order` (List[str]): The optimal order to visit the attractions, starting and ending at the `start` point. # Example ```python >>> start = \\"Home\\" >>> attractions = [\\"Museum\\", \\"Park\\", \\"Zoo\\"] >>> distances = { ... (\\"Home\\", \\"Museum\\"): 10, ... (\\"Home\\", \\"Park\\"): 20, ... (\\"Home\\", \\"Zoo\\"): 15, ... (\\"Museum\\", \\"Park\\"): 25, ... (\\"Museum\\", \\"Zoo\\"): 10, ... (\\"Park\\", \\"Zoo\\"): 30 ... } >>> optimal_attraction_order(start, attractions, distances) [\'Home\', \'Museum\', \'Zoo\', \'Park\', \'Home\'] ``` # Constraints - The number of attractions will not exceed 10. - All distances are positive integers. - The distances are symmetric, i.e., the distance from A to B is the same as the distance from B to A. # Requirements - Implement the function utilizing an appropriate algorithm to solve the travelling salesman problem (TSP) for small datasets efficiently. - Ensure that the function returns the complete cycle, starting and ending at the `start` point. - Optimize for time complexity wherever possible, considering the constraints. # Implementation Note Focus on implementing the function using a method that efficiently handles small datasets typical of the attraction list size provided.","solution":"from itertools import permutations def get_distance(start, end, distances): Get the distance between start and end points from the distances dictionary. It assumes that the distances are symmetric. if (start, end) in distances: return distances[(start, end)] else: return distances[(end, start)] def optimal_attraction_order(start, attractions, distances): Determine the optimal order to visit attractions to minimize travel time, starting and ending at `start`. min_distance = float(\'inf\') best_order = [] # Generate all permutations of attractions for perm in permutations(attractions): current_distance = 0 current_route = [start] # Calculate the distance for the current permutation current_route.extend(perm) current_route.append(start) for i in range(len(current_route) - 1): current_distance += get_distance(current_route[i], current_route[i + 1], distances) # Check if the current route is the best one if current_distance < min_distance: min_distance = current_distance best_order = current_route return best_order"},{"question":"# Problem: **LRU Cache Implementation** You need to implement the Least Recently Used (LRU) Cache to handle a series of operations while maintaining an efficient time complexity. Task: Design an LRU Cache class with the following capabilities: 1. **get(key)**: Return the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. 2. **put(key, value)**: Insert or update the value with the key into the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. Implement the LRUCache class: - `LRUCache(int capacity)`: Initialize the LRU cache with positive size capacity. - `int get(int key)`: Return the value of the key if the key exists in the cache, otherwise return -1. - `void put(int key, int value)`: Update the value of the key if the key exists, otherwise add the key-value pair to the cache. If the number of keys exceeds the capacity, evict the least recently used key. Input and Output Formats: 1. **get(key)**: - Input: An integer key - Output: The value associated with the key or -1 if the key does not exist in the cache 2. **put(key, value)**: - Input: Two integers, key and value - Output: None # Constraints: - The number of operations will fit within a 32-bit signed integer. - The capacity of the cache will be in the range [1, 1000]. - The keys and values will be non-negative integers. # Performance Requirements: - Ensure `get` and `put` operations have O(1) average time complexity. Example: ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # Output: 1 cache.put(3, 3) # Evicts key 2 print(cache.get(2)) # Output: -1 (not found) cache.put(4, 4) # Evicts key 1 print(cache.get(1)) # Output: -1 (not found) print(cache.get(3)) # Output: 3 print(cache.get(4)) # Output: 4 ``` Implement the `LRUCache` class with the specified methods and thoroughly test the functionality above.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 else: self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False)"},{"question":"# Scenario You\'re developing a web application that processes user uploaded images. To increase security, you decide to validate that each uploaded image is a valid JPEG file. You need to build a function that checks the file\'s magic number, which is a special signature identifying the file format at the beginning of the file. # Task 1. **Implement `is_valid_jpeg` function** - Input: A bytes-like object `file_content`. - Output: A boolean value indicating whether the file content is a valid JPEG file. - Constraints: - The function should return `True` if the file has the correct JPEG magic number and `False` otherwise. - The magic number for JPEG files is `FF D8` at the start and `FF D9` at the end of the file. - Throw a `TypeError` if the input is not a bytes-like object. # Requirements - Validate the file content based on the magic numbers specified. - Ensure proper handling for various types of inputs. - Your implementation should match the given doctest examples. - Optimize your function to handle only necessary checks without processing the entire file content unnecessarily. # Function Specifications # `is_valid_jpeg(file_content: bytes) -> bool` - **Input**: A bytes-like object. - **Output**: A boolean value. # Example Usage ```python # Valid JPEG Example jpeg_file = b\'xffxd8xffxdbx00x43x00xffxd9\' print(is_valid_jpeg(jpeg_file)) # True # Invalid JPEG Example (wrong ending) invalid_jpeg_file = b\'xffxd8xffxdbx00x43x00x00x00\' print(is_valid_jpeg(invalid_jpeg_file)) # False # Invalid input (not a bytes-like object) try: is_valid_jpeg(\'invalid input\') except TypeError as e: print(e) # \\"Expected a bytes-like object, but got str\\" ``` # Additional Considerations - Ensure the function correctly identifies valid and invalid JPEG files based on their magic numbers. - Handle erroneous input types gracefully by raising appropriate exceptions. - Keep the implementation efficient and focused on checking only the necessary parts of the file content.","solution":"def is_valid_jpeg(file_content): Check if the provided file content is a valid JPEG file based on its magic numbers. Args: - file_content (bytes): A bytes-like object representing the content of a file. Returns: - bool: True if the file content is a valid JPEG, False otherwise. Raises: - TypeError: If the input is not a bytes-like object. if not isinstance(file_content, (bytes, bytearray)): raise TypeError(f\\"Expected a bytes-like object, but got {type(file_content).__name__}\\") return ( len(file_content) >= 4 and file_content[:2] == b\'xffxd8\' and file_content[-2:] == b\'xffxd9\' )"},{"question":"# String Matching with Knuth-Morris-Pratt Algorithm In various text processing and data analysis applications, efficiently finding occurrences of a pattern in a given text is crucial. One effective way to achieve this is by utilizing the Knuth-Morris-Pratt (KMP) algorithm. Your task is to implement a function that locates all positions of a given pattern in a text using the KMP algorithm. # Function Signature ```python def find_pattern(text: str, pattern: str) -> List[int]: pass ``` # Input - `text`: A string representing the text in which the pattern is to be searched. - `pattern`: A string representing the pattern to be located in the text. # Output - A list of integers representing all starting indices in `text` where the `pattern` is found. # Constraints - Length of `text` and `pattern` can be up to 10^5 characters. - Both `text` and `pattern` consist of lowercase English letters only. # Example ```python # Example input text = \\"ababcabcabababd\\" pattern = \\"ababd\\" # Expected output result = find_pattern(text, pattern) # Result should be: [10] ``` # Note - Ensure that the implementation is optimized for large inputs as specified in the constraints. - Handle edge cases where the pattern cannot be found in the text or where the pattern is longer than the text. - You are free to use helper functions if necessary to aid in the implementation of the KMP algorithm.","solution":"from typing import List def compute_lps(pattern: str) -> List[int]: Computes the Longest Prefix Suffix (LPS) array for the given pattern. LPS array is used to avoid matching the characters that we know will anyway match. lps = [0] * len(pattern) length = 0 # Length of the previous longest prefix suffix i = 1 while i < len(pattern): if pattern[i] == pattern[length]: length += 1 lps[i] = length i += 1 else: if length != 0: length = lps[length - 1] else: lps[i] = 0 i += 1 return lps def find_pattern(text: str, pattern: str) -> List[int]: Implements the Knuth-Morris-Pratt (KMP) algorithm to find all occurrences of `pattern` in `text`. Returns a list of starting indices where `pattern` is found. if not pattern: return [] # Edge case: empty pattern lps = compute_lps(pattern) indices = [] i = 0 # Index for text j = 0 # Index for pattern while i < len(text): if pattern[j] == text[i]: i += 1 j += 1 if j == len(pattern): indices.append(i - j) j = lps[j - 1] elif i < len(text) and pattern[j] != text[i]: if j != 0: j = lps[j - 1] else: i += 1 return indices"},{"question":"# Prime Number in Range Objective Write a function that finds all prime numbers within a given inclusive range. Your solution should use the Sieve of Eratosthenes algorithm for efficient computation. Problem Statement Given two positive integers as range boundaries, return a list of all prime numbers within and including the range. Handle edge cases such as when the lower boundary is greater than the upper boundary. Input - Two positive integers `low` and `high` representing the range boundaries. Output - A list of integers representing the prime numbers within the specified range. - If `low` is greater than `high`, return an empty list. - If there are no prime numbers in the range, return an empty list. Function Signature ```python def primes_in_range(low: int, high: int) -> List[int]: ``` Constraints - The input integers will be within the range ([1, 10^6]). Examples ```python >>> primes_in_range(1, 10) [2, 3, 5, 7] >>> primes_in_range(10, 20) [11, 13, 17, 19] >>> primes_in_range(22, 29) [23, 29] >>> primes_in_range(30, 30) [] >>> primes_in_range(15, 10) [] ``` Performance Requirements - Must run in O(n log log n) time and require O(n) space where (n = high). Notes - Use the Sieve of Eratosthenes for generating primes up to the maximum boundary. - Ensure the input values are positive integers and the range is processed correctly.","solution":"from typing import List def primes_in_range(low: int, high: int) -> List[int]: Finds all prime numbers within a given inclusive range using the Sieve of Eratosthenes algorithm. :param low: lower boundary of the range :param high: upper boundary of the range :return: list of prime numbers within the range if low > high: return [] # Edge case: if high is less than 2, there are no prime numbers if high < 2: return [] # Sieve of Eratosthenes to find all primes up to \'high\' sieve = [True] * (high + 1) sieve[0] = sieve[1] = False # 0 and 1 are not prime numbers for start in range(2, int(high**0.5) + 1): if sieve[start]: for multiple in range(start*start, high + 1, start): sieve[multiple] = False # Collecting all prime numbers within the given range primes = [number for number in range(max(low, 2), high + 1) if sieve[number]] return primes"},{"question":"# Scenario: You are part of a team developing a system for managing parking garages. One of your tasks is to create a tracking function for vehicles entering and exiting the garage. Unlimited parking spots are available, and each vehicle is assumed to come with a unique identifier. # Problem Description: Implement a function `manage_parking` that initializes with an empty parking lot and processes a list of commands to manage vehicle entries and exits. Each command in the list will be a tuple in the format `(action, vehicle_id)`, where `action` is either `\\"enter\\"` or `\\"exit\\"` and `vehicle_id` is a string representing the unique identifier of the vehicle. Your function should track the vehicles currently parked in the garage and return a list of all vehicle IDs that are still parked after processing all commands. # Function Signature: `def manage_parking(commands: List[Tuple[str, str]]) -> List[str]:` # Input: - `commands`: A list of tuples where each tuple contains two elements: 1. An action, which is either `\\"enter\\"` or `\\"exit\\"`. 2. A `vehicle_id`, which is a string representing the unique ID of the vehicle. # Output: - Returns a list of strings representing the vehicle IDs still parked in the garage after all commands have been processed. # Constraints: - Each vehicle has a unique identifier and can only `exit` after an `enter` command. - The length of the `commands` list will be in the range [0, 10^5]. - Each `vehicle_id` will be a non-empty string containing alphanumeric characters only. # Example: ```python print(manage_parking([(\\"enter\\", \\"ABC123\\"), (\\"enter\\", \\"XYZ789\\"), (\\"exit\\", \\"ABC123\\")])) # Output: [\\"XYZ789\\"] print(manage_parking([(\\"enter\\", \\"VAN001\\"), (\\"enter\\", \\"CAR007\\"), (\\"exit\\", \\"CAR007\\"), (\\"exit\\", \\"VAN001\\")])) # Output: [] print(manage_parking([(\\"enter\\", \\"BUS123\\"), (\\"enter\\", \\"TRUCK456\\"), (\\"exit\\", \\"BIKE999\\"), (\\"enter\\", \\"CAR789\\")])) # Output: [\\"BUS123\\", \\"TRUCK456\\", \\"CAR789\\"] ``` # Notes: - Ensure that the function only considers valid operations, where an `exit` command only works if the vehicle is already in the garage. - Handle cases where an `exit` command is given for a vehicle not present in the garage gracefully but does not affect the remaining operations. This problem tests your ability to manage data efficiently, using data structures for tracking and processing commands involving vehicles in a parking system.","solution":"from typing import List, Tuple def manage_parking(commands: List[Tuple[str, str]]) -> List[str]: parked_vehicles = set() for action, vehicle_id in commands: if action == \\"enter\\": parked_vehicles.add(vehicle_id) elif action == \\"exit\\": parked_vehicles.discard(vehicle_id) return list(parked_vehicles)"},{"question":"# Problem: Daily Temperature Tracker You are required to implement the function `daily_temperatures(temperatures: List[int]) -> List[int]`. This function receives: - `temperatures`: a list of integers where each value represents the daily temperature recorded in a city. Your goal is to return a list of integers where each entry at index `i` represents the number of days you would have to wait after the `i-th` day to get a warmer temperature. If there is no future day where a warmer temperature occurs, put `0` in the corresponding index. Constraints - Each value in the `temperatures` list is an integer between `30` and `100`. - The length of the `temperatures` list is at most `10^5`. Example ```python temperatures = [73, 74, 75, 71, 69, 72, 76, 73] # Output should be [1, 1, 4, 2, 1, 1, 0, 0] because: # - For day 0 (73), the next warmer day is day 1 (74), so answer is 1. # - For day 1 (74), the next warmer day is day 2 (75), so answer is 1. # - For day 2 (75), the next warmer day is day 6 (76), so answer is 4. # - For day 3 (71), the next warmer day is day 5 (72), so answer is 2. # - and so on... assert daily_temperatures(temperatures) == [1, 1, 4, 2, 1, 1, 0, 0] ``` Function Signature ```python def daily_temperatures(temperatures: List[int]) -> List[int]: pass ``` # Requirements 1. Implement the function to efficiently handle the given constraints. 2. Consider edge cases like having no warmer days in the future. 3. Ensure adherence to Python best practices and conduct thorough testing.","solution":"from typing import List def daily_temperatures(temperatures: List[int]) -> List[int]: n = len(temperatures) res = [0] * n stack = [] # Stack of indices for i in range(n): # While stack is not empty and the current temperature is greater than the # temperature at the index stored at the top of the stack while stack and temperatures[i] > temperatures[stack[-1]]: last_index = stack.pop() res[last_index] = i - last_index stack.append(i) return res"},{"question":"# Problem Statement You are required to create a system to manage a streaming service\'s user statistics efficiently. The service receives real-time updates about users\' viewing sessions and needs to provide quick insights about user activity. Implement functionalities to add a session, update session details, remove a session, and query the current most active user. # Requirements 1. **Class Definition**: Define the class `UserActivityManager` to manage user viewing statistics. 2. **Add Session Method**: Implement the `add_session` method to add a new user\'s viewing session with a user ID and session duration. 3. **Update Session Method**: Implement the `update_session` method to update an existing session\'s duration. 4. **Remove Session Method**: Implement the `remove_session` method to remove a user\'s session given the user ID. 5. **Most Active User Method**: Implement the `most_active_user` method to return the user ID of the user with the current highest total viewing duration. 6. **Edge Cases Handling**: Ensure methods handle cases such as actions on non-existent user sessions gracefully. 7. **Constraints**: - User IDs are unique integers. - Session durations are non-negative integers. - The system should support at least 10^5 user sessions efficiently. # Function Signature ```python class UserActivityManager: def add_session(self, user_id: int, duration: int) -> None: # Your code here def update_session(self, user_id: int, duration: int) -> None: # Your code here def remove_session(self, user_id: int) -> None: # Your code here def most_active_user(self) -> int: # Your code here ``` # Input and Output * `add_session(user_id: int, duration: int) -> None`: adds or updates a user\'s viewing session with the given duration. * `update_session(user_id: int, duration: int) -> None`: updates the session duration for the given user. * `remove_session(user_id: int) -> None`: removes the user\'s session from the system. * `most_active_user() -> int`: returns the user ID of the most active user currently in the system. If there are no active users, return `-1`. # Example ```python manager = UserActivityManager() manager.add_session(1, 30) manager.add_session(2, 50) print(manager.most_active_user()) # Output: 2 manager.update_session(1, 60) print(manager.most_active_user()) # Output: 1 manager.remove_session(1) print(manager.most_active_user()) # Output: 2 manager.remove_session(2) print(manager.most_active_user()) # Output: -1 ``` # Performance Requirements * Ensure that adding, updating, removing sessions, and querying the most active user adhere to efficient time complexities. * Handle at least 10^5 user session updates efficiently. # Evaluation Criteria * **Correctness**: Accurate implementation of all required methods. * **Efficiency**: Time and space complexity of the solution must meet the requirements. * **Robustness**: Handling edge cases and constraints properly. * **Code Quality**: Clean, readable, and maintainable code.","solution":"class UserActivityManager: def __init__(self): self.user_sessions = {} self.max_duration = -1 self.most_active_user_id = -1 def add_session(self, user_id: int, duration: int) -> None: self.user_sessions[user_id] = duration self._update_most_active_user(user_id) def update_session(self, user_id: int, duration: int) -> None: if user_id in self.user_sessions: self.user_sessions[user_id] = duration self._update_most_active_user(user_id) def remove_session(self, user_id: int) -> None: if user_id in self.user_sessions: del self.user_sessions[user_id] if user_id == self.most_active_user_id: self.max_duration = -1 self.most_active_user_id = -1 for uid, dur in self.user_sessions.items(): self._update_most_active_user(uid) def most_active_user(self) -> int: return self.most_active_user_id def _update_most_active_user(self, user_id: int) -> None: if self.user_sessions[user_id] > self.max_duration: self.max_duration = self.user_sessions[user_id] self.most_active_user_id = user_id"},{"question":"# Sorting Department Employees Implement a function to sort a list of employee records based on their department and then by their names. You must ensure the solution adheres to the specified performance and constraints. Function Signature ```python def sort_employees(employees: List[Dict[str, str]]) -> List[Dict[str, str]]: Sort a list of employees first by department and then by name. ``` Input * A list of dictionaries, where each dictionary represents an employee with keys: - `department` (a string) - the department name (e.g., \\"HR\\", \\"Engineering\\"). - `name` (a string) - the employee\'s name (e.g., \\"Alice\\", \\"Bob\\"). Output * A new list of dictionaries sorted first by the `department` and then by the `name`, both in ascending order. Constraints and Requirements * The function should perform the sorting operation in O(n log n) time complexity. * Space complexity should remain O(n) for storing the resulting list. * The function should be case-insensitive when sorting names and departments. Example ```python employees = [ {\\"department\\": \\"Engineering\\", \\"name\\": \\"Alice\\"}, {\\"department\\": \\"HR\\", \\"name\\": \\"Bob\\"}, {\\"department\\": \\"Engineering\\", \\"name\\": \\"Charlie\\"}, {\\"department\\": \\"HR\\", \\"name\\": \\"alice\\"}, ] sorted_employees = sort_employees(employees) print(sorted_employees) # Output: # [ # {\\"department\\": \\"Engineering\\", \\"name\\": \\"Alice\\"}, # {\\"department\\": \\"Engineering\\", \\"name\\": \\"Charlie\\"}, # {\\"department\\": \\"HR\\", \\"name\\": \\"alice\\"}, # {\\"department\\": \\"HR\\", \\"name\\": \\"Bob\\"} # ] ``` Testing Design and include unittests to verify your implementation, ensuring the tests cover various edge cases, such as: * Departments with identical names varying only in case. * Employee names with identical characters in different cases. * Empty lists of employees.","solution":"from typing import List, Dict def sort_employees(employees: List[Dict[str, str]]) -> List[Dict[str, str]]: Sort a list of employees first by department and then by name. return sorted(employees, key=lambda x: (x[\'department\'].lower(), x[\'name\'].lower()))"},{"question":"# Matrix Rotation Challenge Objective Implement a function that rotates a given NxN matrix by 90 degrees clockwise. The function should modify the matrix in place, meaning that you should not use extra space for another matrix. Function Signature ```python def rotate_matrix(mat: list[list[int]]) -> None: pass ``` Inputs * A 2D list of integers `mat` representing an NxN matrix. Outputs * The function should modify the input matrix `mat` in place. There is no return value. Constraints * (1 leq N leq 100) * Elements in `mat` are integers. Contextual Example Consider a scenario where you are given a 3x3 matrix: ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] ``` After rotating the matrix by 90 degrees clockwise, the resulting matrix should be: ```python mat = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` # Requirements * Rotate the matrix 90 degrees clockwise without using additional space for another matrix. * Modify the matrix in place. Example ```python mat = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(mat) ``` Output: ```python [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] ``` ```python mat = [ [5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16] ] rotate_matrix(mat) ``` Output: ```python [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` # Constraints & Hints * Aim for an efficient in-place algorithm. * Consider performing the rotation in layers, starting from the outermost layer and working your way inwards. * Ensure to handle edge cases, like when (N = 1), where rotating the matrix should result in the same single element. Good luck with implementing the matrix rotation function!","solution":"def rotate_matrix(mat: list[list[int]]) -> None: Rotates the given NxN matrix by 90 degrees clockwise in place. n = len(mat) # Transpose the matrix for i in range(n): for j in range(i, n): mat[i][j], mat[j][i] = mat[j][i], mat[i][j] # Reverse each row for i in range(n): mat[i].reverse()"},{"question":"# Problem Statement You are tasked with designing a simple ticket vending system for a subway station. The system sells tickets for rides based on the distance between the origin and destination stations. The fare rates are as follows: - 2 for distances up to 2 km. - 5 for distances greater than 2 km and up to 10 km. - 10 for distances greater than 10 km. If the system sells multiple tickets in a single transaction, it offers a discount as follows: - For every 5 tickets, provide a 3 discount on the total cost. # Requirements Write a function `calculate_fare(ticket_count: int, distance: float) -> float` that: - Takes an integer `ticket_count` representing the number of tickets to be purchased. - Takes a float `distance` representing the distance in kilometers for each ticket. - Returns the total cost after applying the discount. # Constraints - `ticket_count` will be between 1 and 100, inclusive. - `distance` will be between 0.0 and 100.0, inclusive. # Function Signature ```python def calculate_fare(ticket_count: int, distance: float) -> float: pass ``` # Example ```python >>> calculate_fare(1, 1.5) 2.0 >>> calculate_fare(7, 3.0) 29.0 >>> calculate_fare(10, 11.0) 91.0 ``` # Explanation - For a single ticket with a distance of 1.5 km, the fare is 2. No discount is applied, so the total cost is 2. - For 7 tickets with a distance of 3.0 km, the fare for each ticket is 5. The total before the discount is 35. Since 7 tickets are sold, a 3 discount is applied (7 tickets result in one 3 discount), making the total cost 32. - For 10 tickets with a distance of 11.0 km, the fare for each ticket is 10. The total before the discount is 100. Since 10 tickets are sold, a 6 discount is applied (2 discounts of 3 each), making the total cost 94.","solution":"def calculate_fare(ticket_count: int, distance: float) -> float: Calculate the total fare for a given number of tickets and distance. :param ticket_count: int, the number of tickets to be purchased :param distance: float, the distance for each ticket in kilometers :return: float, the total cost after applying discounts if distance <= 2: fare_per_ticket = 2 elif distance <= 10: fare_per_ticket = 5 else: fare_per_ticket = 10 total_fare = fare_per_ticket * ticket_count discount = (ticket_count // 5) * 3 total_fare -= discount return total_fare"},{"question":"# Coding Assessment Question Context Implementing proper hierarchical structures is crucial for management and data organization in computer programs. One way to represent hierarchical structures is using trees where each node has a unique parent, except for the root node which has no parent. Given a company\'s hierarchy, you need to determine the longest chain of command from the root (CEO) down to any employee. Problem Statement Write a function to compute the maximum depth of a tree representing a company\'s hierarchy. The structure is provided as a dictionary where keys are employee ids and values are lists of ids of their direct reports. Input - **root** (Integer): The ID of the root node (CEO of the company). - **tree** (Dictionary): A dictionary where each key is an employee ID and the corresponding value is a list of IDs for the direct reports of that employee. Output - An integer representing the maximum depth of the tree. Constraints - `1 <= number of nodes <= 1000` - Each employee will have a unique integer ID. Function Signature ```python def max_depth(root: int, tree: dict) -> int: pass ``` Example ```python input: root = 1 tree = { 1: [2, 3], 2: [4, 5], 3: [6], 4: [], 5: [], 6: [7, 8], 7: [], 8: [] } output: 4 ``` Notes * The depth of a tree is the number of nodes along the longest path from the root node to any leaf node. * If an employee has no direct reports, they are considered a leaf node. * Consider edge cases where the tree might be very shallow or very deep.","solution":"def max_depth(root: int, tree: dict) -> int: def depth(node): if node not in tree or not tree[node]: return 1 return 1 + max(depth(child) for child in tree[node]) return depth(root)"},{"question":"# Question You are tasked with implementing a function that takes an encoded string and decodes it. The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is repeated exactly k times. Note that k is guaranteed to be a positive integer. The input string is guaranteed to be well-formed and consists only of letters, digits, and square brackets. # Function Signature ```python def decode_string(s: str) -> str: ``` # Input * `s: str` - A string which follows the encoding rule. It consists of lowercase letters, digits, and square brackets. # Output * `str` - The decoded string. # Constraints * The length of `s` will not exceed 30. * `s` is guaranteed to be valid and well-formed. # Examples ```python assert decode_string(\\"3[a]2[bc]\\") == \\"aaabcbc\\" assert decode_string(\\"3[a2[c]]\\") == \\"accaccacc\\" assert decode_string(\\"2[abc]3[cd]ef\\") == \\"abcabccdcdcdef\\" ``` # Implementation Guide 1. **Initialize Stack**: Use a stack to keep track of the characters and numbers. 2. **Iterate through the string**: Process each character in the string. 3. **Handle Different Characters**: - Append letters directly to the current segment. - Push digits onto the stack until a non-digit is encountered. - When encountering a [, push the current segment onto the stack and reset it. - When encountering a ], pop the stack to retrieve the last segment and the repetition factor. Append the repeated segment to the previous segment from the stack. 4. **Build the Final String**: Combine all segments to form the final decoded string. # Note - Nested brackets should be handled correctly. - The resulting string should be decoded as per the given encoding rules.","solution":"def decode_string(s: str) -> str: stack = [] current_num = 0 current_str = \'\' for char in s: if char.isdigit(): current_num = current_num * 10 + int(char) elif char == \'[\': stack.append((current_str, current_num)) current_str = \'\' current_num = 0 elif char == \']\': last_str, num = stack.pop() current_str = last_str + current_str * num else: current_str += char return current_str"},{"question":"**Question**: You are developing a system to manage a fleet of bicycles. Each bicycle can be rented, and the system must track the time each bicycle is rented out in order to charge the renter accordingly. Assume each bicycle has a unique identifier, and the rental fee is calculated based on the rental duration with the following rules: - The rental fee is 5 for the first hour (or any part of the hour). - Each additional hour adds 3 to the total cost. **Function Specification**: You need to implement the functions `rent_bicycle` and `return_bicycle` to manage bicycle rentals. **Function: `rent_bicycle(bike_id)`** - Starts renting a bicycle with the given `bike_id`. - There is no need to handle already rented bicycles explicitly in this function. *Parameters*: - `bike_id` (str): unique identifier of the bicycle. *Output*: - None **Function: `return_bicycle(bike_id, return_time)`** - Ends the rental and calculates the rental fee based on the total time the bicycle was rented. *Parameters*: - `bike_id` (str): unique identifier of the bicycle. - `return_time` (str): the time when the bicycle is returned in the format \\"YYYY-MM-DD HH:MM\\". *Output*: - (float): the total rental fee in dollars. **Database Model**: You may use an in-memory dictionary to store the rental start times, keyed by the `bike_id`. *Example*: ```python # Assume the current time is managed globally to simplify the problem. current_time = \\"2023-10-01 09:15\\" rent_bicycle(\\"bike123\\") # After some usage, time advances current_time = \\"2023-10-01 11:45\\" fee = return_bicycle(\\"bike123\\", current_time) print(fee) # Should print: 11.0 (5 for the first hour, 3 for each of the next 2 hours) ``` **Constraints**: - Use the `datetime` module to handle time calculations. - The `return_time` will always be after the `rent_time`. *Edge Cases*: - A bicycle returned within the first hour should only be charged 5. *Error Handling*: - Raise an appropriate exception if a nonexistent `bike_id` is returned. - Raise an appropriate exception if the `bike_id` being returned is not currently rented. Implement the two functions `rent_bicycle` and `return_bicycle` to fulfill the above requirements. ```python import datetime rental_data = {} def rent_bicycle(bike_id): current_time = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M\\") if bike_id in rental_data: raise ValueError(f\\"Bicycle {bike_id} is already rented\\") rental_data[bike_id] = current_time def return_bicycle(bike_id, return_time): if bike_id not in rental_data: raise ValueError(f\\"Bicycle {bike_id} not found in rental records\\") rent_time_str = rental_data.pop(bike_id) rent_time = datetime.datetime.strptime(rent_time_str, \\"%Y-%m-%d %H:%M\\") return_time_dt = datetime.datetime.strptime(return_time, \\"%Y-%m-%d %H:%M\\") rental_period = return_time_dt - rent_time rental_hours = rental_period.total_seconds() // 3600 rental_hours_remainder = rental_period.total_seconds() % 3600 if rental_hours_remainder > 0: rental_hours += 1 total_cost = 5 + max(0, rental_hours - 1) * 3 return total_cost ``` Make sure to test the functions with different scenarios to ensure robustness and correctness.","solution":"import datetime rental_data = {} def rent_bicycle(bike_id): Starts renting a bicycle with the given bike_id. Saves the current timestamp as the rent start time. current_time = datetime.datetime.now().strftime(\\"%Y-%m-%d %H:%M\\") if bike_id in rental_data: raise ValueError(f\\"Bicycle {bike_id} is already rented\\") rental_data[bike_id] = current_time def return_bicycle(bike_id, return_time): Ends the rental and calculates the rental fee based on the total time the bicycle was rented. if bike_id not in rental_data: raise ValueError(f\\"Bicycle {bike_id} not found in rental records\\") rent_time_str = rental_data.pop(bike_id) rent_time = datetime.datetime.strptime(rent_time_str, \\"%Y-%m-%d %H:%M\\") return_time_dt = datetime.datetime.strptime(return_time, \\"%Y-%m-%d %H:%M\\") rental_period = return_time_dt - rent_time rental_hours = rental_period.total_seconds() // 3600 rental_hours_remainder = rental_period.total_seconds() % 3600 if rental_hours_remainder > 0: rental_hours += 1 total_cost = 5 + max(0, rental_hours - 1) * 3 return total_cost"},{"question":"# Coding Challenge In computational geometry, calculating the intersection of two line segments is a common task. You are provided with a function template to determine if two line segments in a 2D plane intersect. Objective Your task is to implement a function `do_segments_intersect` that takes the coordinates of the endpoints of two line segments and returns a boolean indicating whether they intersect or not. Requirements - Implement the function `do_segments_intersect` that takes the coordinates of two line segments and returns `True` if they intersect, `False` otherwise. - Each segment is represented as a tuple of two points. Each point is itself represented as a tuple of two coordinates `(x, y)`. Function Signature ```python def do_segments_intersect(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> bool: pass ``` Input - `segment1`: A tuple containing two tuples representing the endpoints of the first line segment. - Example: `((x1, y1), (x2, y2))` - `segment2`: A tuple containing two tuples representing the endpoints of the second line segment. - Example: `((x3, y3), (x4, y4))` Output - A boolean value indicating whether the two line segments intersect. Constraints - The coordinates of the endpoints will be valid floating-point numbers. - The line segments can touch at exactly one endpoint. Example Here is an example of how your function should work: ```python >>> do_segments_intersect(((1.0, 1.0), (4.0, 4.0)), ((1.0, 4.0), (4.0, 1.0))) True >>> do_segments_intersect(((1.0, 1.0), (2.0, 2.0)), ((1.0, 2.0), (2.0, 3.0))) False ``` Code Template Use the following template to start your implementation: ```python from typing import Tuple def orientation(p: Tuple[float, float], q: Tuple[float, float], r: Tuple[float, float]) -> int: val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 # collinear return 1 if val > 0 else 2 # clock or counterclock wise def on_segment(p: Tuple[float, float], q: Tuple[float, float], r: Tuple[float, float]) -> bool: if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]): return True return False def do_segments_intersect(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> bool: p1, q1 = segment1 p2, q2 = segment2 o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) # General case if o1 != o2 and o3 != o4: return True # Special Cases if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"from typing import Tuple def orientation(p: Tuple[float, float], q: Tuple[float, float], r: Tuple[float, float]) -> int: val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]) if val == 0: return 0 # collinear return 1 if val > 0 else 2 # clock or counterclock wise def on_segment(p: Tuple[float, float], q: Tuple[float, float], r: Tuple[float, float]) -> bool: if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]): return True return False def do_segments_intersect(segment1: Tuple[Tuple[float, float], Tuple[float, float]], segment2: Tuple[Tuple[float, float], Tuple[float, float]]) -> bool: p1, q1 = segment1 p2, q2 = segment2 o1 = orientation(p1, q1, p2) o2 = orientation(p1, q1, q2) o3 = orientation(p2, q2, p1) o4 = orientation(p2, q2, q1) # General case if o1 != o2 and o3 != o4: return True # Special Cases if o1 == 0 and on_segment(p1, p2, q1): return True if o2 == 0 and on_segment(p1, q2, q1): return True if o3 == 0 and on_segment(p2, p1, q2): return True if o4 == 0 and on_segment(p2, q1, q2): return True return False"},{"question":"# Coding Assessment Question Context: You are designing a feature for a social media application where users can follow other users to see their posts. Each user\'s activity feed should display the latest posts from the users they follow. Your goal is to enhance the existing functionality to efficiently retrieve and display the top N most recent posts from the followed users. Task: Enhance the provided `fetch_feed` function to perform database queries concurrently, handle potential database errors gracefully, and implement caching for frequently accessed data for efficiency. Requirements: 1. **Function Signature**: ```python async def fetch_feed(user_id: int, limit: int, db_session, cache) -> list: ``` 2. **Input**: * `user_id` (int): The ID of the user whose feed is being retrieved. * `limit` (int): The maximum number of recent posts to retrieve. * `db_session`: The database session object for executing queries. * `cache`: The cache object for storing and retrieving cached data. 3. **Output**: * `list`: A list of dictionaries, where each dictionary represents a post with fields such as `post_id`, `user_id`, `content`, and `timestamp`. 4. **Constraints**: * Handle concurrent database queries efficiently. * Implement retry logic with up to 3 attempts for transient database errors. * Utilize caching to store and retrieve frequently accessed feed data. 5. **Performance Requirements**: * The function should minimize database load and reduce latency using concurrency and caching. * Aim for a quick response time even under high load conditions. Example Usage: ```python user_id = 1 limit = 10 db_session = get_db_session() cache = get_cache() result = await fetch_feed(user_id, limit, db_session, cache) # Expected Output Format # [ # {\\"post_id\\": 101, \\"user_id\\": 2, \\"content\\": \\"Hello world!\\", \\"timestamp\\": 1631475600}, # {\\"post_id\\": 102, \\"user_id\\": 3, \\"content\\": \\"Lovely day!\\", \\"timestamp\\": 1631475500}, # ... # ] ``` Hints: * Use the `asyncio` library to perform database queries concurrently. * Implement proper error handling to manage different types of potential failures. * Implement a caching mechanism to store and retrieve feed data to reduce database load. Good luck!","solution":"import asyncio import time from typing import List, Dict async def fetch_feed(user_id: int, limit: int, db_session, cache) -> List[Dict]: cache_key = f\\"user_feed_{user_id}_{limit}\\" cached_feed = cache.get(cache_key) if cached_feed: return cached_feed retry_attempts = 3 followed_users_query = SELECT followed_user_id FROM user_follows WHERE follower_user_id = :user_id posts_query = SELECT post_id, user_id, content, timestamp FROM posts WHERE user_id IN :user_ids ORDER BY timestamp DESC LIMIT :limit try: followed_users = await db_session.execute(followed_users_query, {\'user_id\': user_id}) followed_user_ids = [row.followed_user_id for row in followed_users] if not followed_user_ids: return [] for attempt in range(retry_attempts): try: posts_result = await db_session.execute(posts_query, {\'user_ids\': tuple(followed_user_ids), \'limit\': limit}) posts = [dict(row) for row in posts_result] cache.set(cache_key, posts, ttl=300) # Cache for 5 minutes return posts except Exception as e: if attempt < retry_attempts - 1: await asyncio.sleep(1) # Backoff before retrying else: raise e except Exception as e: # Handle error (e.g., log the error and return an empty list or another appropriate response) return []"},{"question":"# Pattern Matching in a Grid Scenario You are given a 2D grid of characters, and you need to find whether a given word can be constructed from the grid. The word can be formed by moving sequentially in any of the eight possible directions (horizontally, vertically, or diagonally) starting from any cell. Objective Write a function `find_word_in_grid` in Python that takes a 2D list of characters (the grid) and a string (the word), and returns a boolean value indicating whether the word exists in the grid. Function Signature ```python def find_word_in_grid(grid: list[list[str]], word: str) -> bool: ``` Input: 1. `grid`: A 2D list of characters (a list of lists, where each sub-list represents a row in the grid). 2. `word`: A string representing the word you need to find in the grid. Output: A boolean value indicating whether the word exists in the grid. Constraints: * The grid will have at least one row and one column. * Each element of the grid is a single lowercase English letter. * The length of the word will be between 1 and 10 characters. * The grid dimensions will not exceed 20x20. Requirements: 1. The word can be constructed only by moving to adjacent cells in all 8 possible directions. 2. A cell in the grid can be used only once while forming the word. Example: ```python # Examples grid = [ [\'a\', \'b\', \'c\', \'e\'], [\'s\', \'f\', \'c\', \'s\'], [\'a\', \'d\', \'e\', \'e\'] ] print(find_word_in_grid(grid, \'abcced\')) # Output: True print(find_word_in_grid(grid, \'see\')) # Output: True print(find_word_in_grid(grid, \'abcb\')) # Output: False grid = [ [\'h\', \'e\', \'l\', \'l\', \'o\'], [\'w\', \'o\', \'r\', \'l\', \'d\'], [\'a\', \'m\', \'a\', \'z\', \'e\'], [\'c\', \'o\', \'d\', \'e\', \'r\'] ] print(find_word_in_grid(grid, \'hello\')) # Output: True print(find_word_in_grid(grid, \'amazes\')) # Output: False print(find_word_in_grid(grid, \'coder\')) # Output: True grid = [ [\'x\', \'y\', \'z\'], [\'a\', \'b\', \'c\'], [\'d\', \'e\', \'f\'] ] print(find_word_in_grid(grid, \'abcdef\')) # Output: False ``` Note: Implement a Depth First Search (DFS) to explore all possible paths from every cell in the grid, and ensure each cell is visited only once per search instance.","solution":"def find_word_in_grid(grid, word): rows, cols = len(grid), len(grid[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or grid[r][c] != word[index]: return False temp, grid[r][c] = grid[r][c], \\"#\\" found = any(dfs(r + dr, c + dc, index + 1) for dr, dc in [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)]) grid[r][c] = temp return found for r in range(rows): for c in range(cols): if grid[r][c] == word[0] and dfs(r, c, 0): return True return False"},{"question":"# Scenario: You are developing a software application that helps users manage their productivity by tracking their tasks. One of the features of the application is to identify tasks that can be grouped together because they share similar keywords. Implement a solution that examines a list of tasks, identifies groups of tasks with common keywords, and returns these groups. # Task: Write a function named `group_tasks_by_keywords` that takes a list of task descriptions and a list of keywords. The function should return a dictionary where each key is a keyword and the value is a list of task descriptions that contain that keyword. # Function Definition: **group_tasks_by_keywords(tasks: List[str], keywords: List[str]) -> Dict[str, List[str]]** - Groups the given task descriptions by the provided keywords. # Input and Output Formats: - **Input**: - `tasks` (List[str]): A list of task descriptions, each being a string. - `keywords` (List[str]): A list of keywords to be used for grouping tasks. - **Output**: - Returns a dictionary where each key is a keyword and each value is a list of task descriptions that include that keyword. # Constraints: 1. The `tasks` list and `keywords` list will only contain alphanumeric characters and spaces. 2. Each keyword should group any task description that contains the keyword as a whole word (not as a substring of a longer word). 3. If a task description matches multiple keywords, include it in the lists of all relevant keywords. If no tasks match a keyword, omit that keyword from the dictionary. 4. Raises appropriate exceptions for invalid inputs, such as empty lists or non-list inputs. # Examples: - **Example 1**: ```python tasks = [\\"Complete the report\\", \\"Schedule meeting with team\\", \\"Call the client\\", \\"Email the report to the manager\\"] keywords = [\\"report\\", \\"meeting\\", \\"email\\"] group_tasks_by_keywords(tasks, keywords) # Output: { # \\"report\\": [\\"Complete the report\\", \\"Email the report to the manager\\"], # \\"meeting\\": [\\"Schedule meeting with team\\"], # \\"email\\": [\\"Email the report to the manager\\"] # } ``` - **Example 2**: ```python tasks = [\\"Buy groceries\\", \\"Clean the house\\", \\"Read a book\\"] keywords = [\\"read\\", \\"clean\\"] group_tasks_by_keywords(tasks, keywords) # Output: { # \\"clean\\": [\\"Clean the house\\"], # \\"read\\": [\\"Read a book\\"] # } ```","solution":"from typing import List, Dict def group_tasks_by_keywords(tasks: List[str], keywords: List[str]) -> Dict[str, List[str]]: Groups the given task descriptions by the provided keywords. Parameters: tasks (List[str]): A list of task descriptions. keywords (List[str]): A list of keywords to be used for grouping tasks. Returns: Dict[str, List[str]]: A dictionary where each key is a keyword and each value is a list of task descriptions that include that keyword as a whole word. # Check if the inputs are valid if not isinstance(tasks, list) or not isinstance(keywords, list): raise ValueError(\\"Both tasks and keywords must be lists.\\") for task in tasks: if not isinstance(task, str): raise ValueError(\\"All elements in the tasks list must be strings.\\") for keyword in keywords: if not isinstance(keyword, str): raise ValueError(\\"All elements in the keywords list must be strings.\\") # Dictionary to hold the groups of tasks by keywords grouped_tasks = {} for keyword in keywords: keyword = keyword.lower() keyword_tasks = [task for task in tasks if f\' {keyword} \' in f\' {task.lower()} \'] if keyword_tasks: grouped_tasks[keyword] = keyword_tasks return grouped_tasks"},{"question":"# Question: String Permutation Detection Context Given two strings, determine if one string is a permutation of the other. A permutation is a rearrangement of characters. The solution should compare different permutations by considering the frequency of each character in both strings. Task You need to implement a function `check_permutation(str1: str, str2: str) -> bool` that checks whether `str2` is a permutation of `str1`. The function should return `True` if the strings are permutations of each other, and `False` otherwise. Constraints * The strings consist of printable ASCII characters only. * The length of the strings is `0 <= len(str) <= 10^5`. Instructions 1. **Function definition**: Implement the function `check_permutation(str1: str, str2: str) -> bool`. 2. **Input**: * `str1`: First string (a string). * `str2`: Second string (a string). 3. **Output**: * A boolean value indicating whether the two strings are permutations of each other. Performance Requirements * Solve the problem efficiently by utilizing suitable data structures and algorithms to handle potentially large input sizes. Example: ```python >>> check_permutation(\\"abc\\", \\"bca\\") True >>> check_permutation(\\"abc\\", \\"abcd\\") False >>> check_permutation(\\"aabbcc\\", \\"ccbbaa\\") True ``` Additional Scenarios: Test your function with the following inputs: 1. `check_permutation(\\"hello\\", \\"oellh\\")` 2. `check_permutation(\\"test\\", \\"ttew\\")` 3. `check_permutation(\\"apple\\", \\"papel\\")`","solution":"def check_permutation(str1: str, str2: str) -> bool: Check if str2 is a permutation of str1. if len(str1) != len(str2): return False char_count = {} for char in str1: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 for char in str2: if char in char_count: char_count[char] -= 1 if char_count[char] == 0: del char_count[char] else: return False return len(char_count) == 0"},{"question":"# Coding Assessment Question **Context**: Efficient data storage and retrieval are crucial in software development. One common technique involves using dictionaries or hash maps to manage key-value pairs. **Question**: Implement a class `LRUCache` that simulates the behavior of a Least Recently Used (LRU) cache. The class should support two primary operations: `get` and `put`. **Class Definition**: ```python class LRUCache: def __init__(self, capacity: int): # Initializes the cache with a given capacity. def get(self, key: int) -> int: # Returns the value of the key if the key exists in the cache, otherwise returns -1. def put(self, key: int, value: int) -> None: # Updates the value of the key if the key exists. Otherwise, adds the key-value pair to the cache. # If the cache exceeds its capacity, it should invalidate the least recently used item. ``` **Input**: * `capacity` (int): An integer representing the maximum number of items that can be held by the cache. * For `get` operations: a key (int) to retrieve the associated value. * For `put` operations: a key (int) and value (int) to store in the cache. **Output**: * For `get` operations: the value associated with the key, or -1 if the key is not present. * For `put` operations: no output, but the internal state of the cache is updated accordingly. **Constraints**: * The capacity is between 1 and 1,000. * The `key` and `value` for `put` operations are integer numbers between 0 and 10,000. * The number of `get` and `put` operations combined will not exceed 10,000. **Performance Requirements**: * The `get` and `put` operations should run in O(1) average time complexity. * The solution should efficiently manage space, maintaining the cache size within the specified capacity. **Examples**: ```python # Example 1: cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 # Example 2: cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) cache.put(4, 4) assert cache.get(4) == 4 # returns 4 assert cache.get(3) == 3 # returns 3 assert cache.get(2) == 2 # returns 2 assert cache.get(1) == -1 # returns -1 (not found) cache.put(5, 5) assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 # returns 2 assert cache.get(3) == 3 # returns 3 assert cache.get(4) == -1 # returns -1 (not found) assert cache.get(5) == 5 # returns 5 ``` **Notes**: * You may assume that the `get` and `put` functions are called in valid order and do not require validation for input format or type. * The cache should prioritize the least recently used items when deciding which item to evict once capacity is exceeded.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: int) -> int: if key not in self.cache: return -1 # Move the accessed key to the end to indicate recent use self.cache.move_to_end(key) return self.cache[key] def put(self, key: int, value: int) -> None: if key in self.cache: # Update the value self.cache.move_to_end(key) self.cache[key] = value if len(self.cache) > self.capacity: # Pop the first item from the OrderedDict (least recently used) self.cache.popitem(last=False)"},{"question":"In the context of dynamic programming, consider a scenario where you are developing a software that manages online reservations for a hotel. The hotel has a limited number of rooms, and each reservation request asks for a specific range of dates. You need to efficiently allocate rooms such that the number of rooms used simultaneously on any given date is minimized. # Task Write a function to evaluate the maximum number of rooms used at any point during the reservation period. Function Signature ```python def min_rooms_needed(intervals: List[Tuple[int, int]]) -> int: # Implement this function ``` Input Format * A list `intervals` of size `n`, where each element is a tuple `(start, end)` representing the start and end dates of a reservation. Output Format * Return an integer representing the minimum number of rooms needed. Constraints * 1 ≤ n ≤ 10^5 * 1 ≤ start < end ≤ 10^5 * Each reservation request `(start, end)` will be made such that `start` and `end` are integers and `end` indicates the day the reservation ends, which means the room is free from this day. # Example ```python intervals = [(1, 3), (2, 5), (4, 6)] print(min_rooms_needed(intervals)) # Output: 2 intervals = [(1, 2), (2, 3), (3, 4)] print(min_rooms_needed(intervals)) # Output: 1 ``` # Notes * Optimize your solution to handle large input sizes efficiently. * Consider edge cases such as overlapping reservations and back-to-back reservations. # Additional Information Your function should aim to employ an optimal approach, possibly exploring sorting and efficient traversal methods to achieve the desired outcome.","solution":"from typing import List, Tuple def min_rooms_needed(intervals: List[Tuple[int, int]]) -> int: times = [] for interval in intervals: times.append((interval[0], \'start\')) times.append((interval[1], \'end\')) times.sort() max_rooms = 0 current_rooms = 0 for time, ttype in times: if ttype == \'start\': current_rooms += 1 max_rooms = max(max_rooms, current_rooms) else: current_rooms -= 1 return max_rooms"},{"question":"# Coding Assessment Question Task You are required to write a Python function that generates a lookup table for a given list of numbers and their corresponding squared values. Function Specifications Write a function `generate_square_lookup(numbers: List[int]) -> dict` that: * Takes a single input: * `numbers` (list of integers): The list of numbers you want to create a lookup table for. * Returns a dictionary where: * Each key is a number from the input list. * Each value is the square of the corresponding key. Constraints * The elements of the input list `numbers` will be unique. * The list `numbers` will have at least 1 and at most 100 elements. * The integers in the list `numbers` will range from -1000 to 1000. Example **Input:** ```python numbers = [1, 2, 3, 4, 5] lookup_table = generate_square_lookup(numbers) print(lookup_table) ``` **Expected Output:** ```python { 1: 1, 2: 4, 3: 9, 4: 16, 5: 25 } ``` Performance Requirements * The function should efficiently handle the input list, creating the lookup table in linear time. Additional Context Ensure your solution is robust and can handle edge cases, such as negative numbers and large values within the given constraints. The function should strictly adhere to the provided specifications and constraints.","solution":"from typing import List def generate_square_lookup(numbers: List[int]) -> dict: Generates a lookup table for a given list of numbers and their corresponding squared values. :param numbers: List of integers :return: Dictionary with numbers as keys and their squares as values return {num: num ** 2 for num in numbers}"},{"question":"# Unique Substrings Finder Objective: Implement an algorithm to find all unique substrings of a given string that have a specified length. # Task: Write a function `unique_substrings` that extracts all unique substrings of a specified length from a given string. # Function Specifications: 1. **unique_substrings(s: str, length: int) -> List[str]**: * Extracts all unique substrings of the specified length from the string `s`. * **Input**: * s: The input string from which to find substrings. * length: The length of each substring to extract. * **Output**: List of unique substrings of the specified length. The order of substrings in the output does not matter. # Constraints: - The length of the input string `s` will be between 1 and 10^4. - The length parameter will be an integer between 1 and the length of the string inclusive. - All characters in the string are lowercase English letters. # Example: ```python >>> s = \\"abcabc\\" >>> length = 3 >>> unique_substrings(s, length) [\'abc\', \'bca\', \'cab\'] >>> s = \\"hellohel\\" >>> length = 4 >>> unique_substrings(s, length) [\'hell\', \'ello\', \'llohe\', \'lohe\', \'ohel\'] ``` # Notes: - Be mindful of overlapping substrings. - Ensure that your function correctly handles various edge cases, including strings shorter than the specified length (in which case the output should be an empty list).","solution":"def unique_substrings(s: str, length: int): Returns all unique substrings of the specified length. Parameters: s (str): The input string. length (int): The length of the substrings to extract. Returns: List[str]: A list of unique substrings. if length > len(s): return [] substrings = set() for i in range(len(s) - length + 1): substrings.add(s[i:i + length]) return list(substrings)"},{"question":"# Coding Assessment Question Problem: You are required to create a function that determines the intersection point(s) of two given lines in a 2D plane, if any. Each line is represented by its slope and y-intercept in the form of the line equation (y = mx + b). Function Signature: ```python def find_line_intersection(slope1: float, intercept1: float, slope2: float, intercept2: float) -> str: Find the intersection point(s) of two lines given their slopes and y-intercepts. Input Parameters: ----------------- slope1: The slope of the first line intercept1: The y-intercept of the first line slope2: The slope of the second line intercept2: The y-intercept of the second line Returns: -------- A string representing the intersection point in the format \\"(x, y)\\" or one of the following: \\"No intersection\\" if the lines are parallel with different intercepts. \\"Infinite intersections\\" if the lines are identical. pass ``` Input: - `slope1` and `intercept1` are floating-point numbers defining the slope and y-intercept of the first line respectively. - `slope2` and `intercept2` are floating-point numbers defining the slope and y-intercept of the second line respectively. Output: - If the lines intersect, return the coordinates of the intersection point in the format \\"(x, y)\\", with x and y rounded to six decimal places. - If the lines are parallel but not coincident, return \\"No intersection\\". - If the lines are identical, return \\"Infinite intersections\\". Constraints: * All input values will be within the range of float precision limits. Example: ```python find_line_intersection(1, 2, -1, 3) # Output: \\"(0.500000, 2.500000)\\" find_line_intersection(2, 3, 2, -1) # Output: \\"No intersection\\" find_line_intersection(1, 2, 1, 2) # Output: \\"Infinite intersections\\" ``` You should handle special cases where the lines are either parallel or identical by considering the slopes and intercepts of the given lines.","solution":"def find_line_intersection(slope1: float, intercept1: float, slope2: float, intercept2: float) -> str: Find the intersection point(s) of two lines given their slopes and y-intercepts. Input Parameters: ----------------- slope1: The slope of the first line intercept1: The y-intercept of the first line slope2: The slope of the second line intercept2: The y-intercept of the second line Returns: -------- A string representing the intersection point in the format \\"(x, y)\\" or one of the following: \\"No intersection\\" if the lines are parallel with different intercepts. \\"Infinite intersections\\" if the lines are identical. if slope1 == slope2: if intercept1 == intercept2: return \\"Infinite intersections\\" else: return \\"No intersection\\" else: x = (intercept2 - intercept1) / (slope1 - slope2) y = slope1 * x + intercept1 return f\\"({x:.6f}, {y:.6f})\\""},{"question":"Problem Statement You are given an array of integers, where every integer appears exactly twice, except for one integer which appears exactly once. Write a function to find the unique integer that appears exactly once in the array. # Input: * An array of integers `nums` of size `n` (1 ≤ n ≤ 3*10^4), where every integer except one appears exactly twice. # Output: * An integer representing the unique integer. # Function signature: ```python def find_unique_integer(nums: List[int]) -> int: pass ``` # Example: ```python >>> find_unique_integer([2, 3, 2, 4, 4]) 3 >>> find_unique_integer([1, 1, 2]) 2 >>> find_unique_integer([10, 20, 10, 30, 20, 50, 30]) 50 ``` # Constraints: * The input array will have at least one non-repeated integer. * No input validation is required as input is guaranteed to be a valid array of the given constraints. # Performance Requirements: * Implement the function with a linear time complexity, (O(n)). * Utilize constant extra space for optimal performance, (O(1)). # Notes: * Consider leveraging bitwise operations to achieve the desired time and space complexity.","solution":"from typing import List def find_unique_integer(nums: List[int]) -> int: Finds the unique integer that appears exactly once in the array, where every other integer appears exactly twice. unique = 0 for num in nums: unique ^= num # XOR operation return unique"},{"question":"# Image Search with Euclidean Distance You are tasked with implementing an image search algorithm that utilizes the Euclidean distance metric to identify the most visually similar image(s) from a dataset. Each image is represented as a 1-dimensional vector of pixel intensities. # Requirements 1. Implement the function `euclidean_distance(vector_a: list, vector_b: list) -> float` that computes the Euclidean distance between two vectors. 2. Implement the function `image_search(dataset: list[list], query_images: list[list], k: int) -> list[list[list] | list]` that performs the image search. # Inputs * **dataset**: A list of lists, where each inner list represents an image vector. * **query_images**: A list of lists, where each inner list represents a query image vector. * **k**: An integer representing the number of most similar images to return for each query image. # Outputs * A list of lists, where each inner list contains: - The top `k` most similar image vectors from the dataset for the corresponding query image. - The Euclidean distances to these image vectors. # Constraints 1. All image vectors in `dataset` and `query_images` must have the same length. 2. The data types of all image vectors in `dataset` and `query_images` must be the same. 3. The value of `k` must be less than or equal to the number of images in the dataset. # Example ```python import math def euclidean_distance(vector_a: list, vector_b: list) -> float: return math.sqrt(sum((a - b) ** 2 for a, b in zip(vector_a, vector_b))) def image_search(dataset: list[list], query_images: list[list], k: int) -> list[list[list] | list]: if k > len(dataset): raise ValueError(\\"k cannot be greater than the number of images in the dataset.\\") for vector in dataset + query_images: if len(vector) != len(dataset[0]): raise ValueError(\\"All image vectors must have the same length.\\") result = [] for query_image in query_images: distances = [] for idx, dataset_image in enumerate(dataset): dist = euclidean_distance(query_image, dataset_image) distances.append((dist, dataset_image)) distances.sort(key=lambda x: x[0]) top_k_images = [image for _, image in distances[:k]] top_k_distances = [dist for dist, _ in distances[:k]] result.append([top_k_images, top_k_distances]) return result # Example Usage: dataset = [ [255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [255, 0, 255] ] query_images = [ [250, 10, 10], [0, 250, 5] ] k = 2 print(image_search(dataset, query_images, k)) # Output: [ # [[[255, 0, 0], [255, 255, 0]], [10.0, 355.0]], # [[[0, 255, 0], [255, 255, 0]], [10.295630140987, 355.0140843092685]] # ] # Explanation In this example, `dataset` contains five 3-dimensional image vectors, and `query_images` contains two 3-dimensional query image vectors. The function identifies the top 2 most similar image vectors from the `dataset` for each query image based on Euclidean distance. ```","solution":"import math def euclidean_distance(vector_a: list, vector_b: list) -> float: Computes the Euclidean distance between two vectors. return math.sqrt(sum((a - b) ** 2 for a, b in zip(vector_a, vector_b))) def image_search(dataset: list[list], query_images: list[list], k: int) -> list[list[list] | list]: Performs image search by finding the top k most similar images in dataset for each query image. Returns the images and their distances. if k > len(dataset): raise ValueError(\\"k cannot be greater than the number of images in the dataset.\\") for vector in dataset + query_images: if len(vector) != len(dataset[0]): raise ValueError(\\"All image vectors must have the same length.\\") result = [] for query_image in query_images: distances = [] for idx, dataset_image in enumerate(dataset): dist = euclidean_distance(query_image, dataset_image) distances.append((dist, dataset_image)) distances.sort(key=lambda x: x[0]) top_k_images = [image for _, image in distances[:k]] top_k_distances = [dist for dist, _ in distances[:k]] result.append([top_k_images, top_k_distances]) return result"},{"question":"# Array Manipulation for Maximum Sum Range Query You are given an integer array `nums` and a list of query ranges where each query is defined as a pair `(l, r)` representing the inclusive range [l, r]. For each query, you need to determine the sum of the elements within the range and return the maximum sum found across all queries. **Function Signature:** ```python def max_sum_range_query(nums: list[int], queries: list[tuple[int, int]]) -> int: Compute the sum of elements within each specified query range and return the maximum sum. Parameters: nums: List of integers representing the array of numbers. queries: List of tuple pairs representing the inclusive start and end indices of queries. Returns: The maximum sum obtained from any of the specified query ranges. Example: >>> nums = [1, 2, 3, 4, 5] >>> queries = [(0, 1), (1, 3), (0, 4)] >>> max_sum_range_query(nums, queries) 15 >>> nums = [5, -1, 3, 7, -2, 4] >>> queries = [(0, 2), (2, 5), (1, 4)] >>> max_sum_range_query(nums, queries) 12 # Implement the function here. pass ``` **Input:** * `nums`: List of integers. * `queries`: List of tuples, where each tuple contains two integers representing the start (`l`) and end (`r`) indices of a query. **Output:** * An integer representing the maximum sum obtained from any of the specified query ranges. **Constraints:** * 1 ≤ len(nums) ≤ 10^5 * Each value in `nums` is a valid integer. * 1 ≤ len(queries) ≤ 10^5 * For each `(l, r)`, 0 ≤ l ≤ r < len(nums) Example Scenarios 1. **Basic Range Queries** * **Input:** `nums = [1, 2, 3, 4, 5]`, `queries = [(0, 1), (1, 3), (0, 4)]` * **Output:** `15` 2. **Negative and Positive Values** * **Input:** `nums = [5, -1, 3, 7, -2, 4]`, `queries = [(0, 2), (2, 5), (1, 4)]` * **Output:** `12` Be sure to handle edge cases such as single-element ranges, all positive or all negative numbers, and large input sizes efficiently.","solution":"def max_sum_range_query(nums: list[int], queries: list[tuple[int, int]]) -> int: Compute the sum of elements within each specified query range and return the maximum sum. Parameters: nums: List of integers representing the array of numbers. queries: List of tuple pairs representing the inclusive start and end indices of queries. Returns: The maximum sum obtained from any of the specified query ranges. max_sum = float(\'-inf\') # Compute prefix sums prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): prefix_sums[i + 1] = prefix_sums[i] + nums[i] # Evaluate each query for l, r in queries: current_sum = prefix_sums[r + 1] - prefix_sums[l] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"Scenario You are working on an e-commerce platform, where customers can search for products by typing keywords. To improve search performance, you need to implement a function that removes common \\"stop words\\" (e.g., \'and\', \'the\', \'of\') from user queries, ensuring cleaner and more efficient searches. Task Write a function `clean_search_query(query: str, stop_words: set[str]) -> str` that takes a search query string and a set of stop words, and returns the cleaned query string with all stop words removed. Words in the query should be separated by spaces. # Functional Requirements 1. **Input**: - A string representing the search query. - A set of strings representing stop words. 2. **Output**: - A string where all stop words have been removed from the search query. # Constraints & Performance - The search query will contain only letters and spaces, and no punctuation. - The function should handle search queries of up to 200 characters efficiently. - Be case-insensitive when determining stop words (e.g., \\"The\\" and \\"the\\" should both be considered stop words). # Example ```python input_query = \\"The quick brown fox jumps over the lazy dog\\" stop_words = {\\"the\\", \\"over\\", \\"and\\"} expected_output = \\"quick brown fox jumps lazy dog\\" ``` # Notes - Ensure the function is case-insensitive and returns the cleaned query in the same casing as it appears (e.g., `The` or `the` should both be treated as stop words). - Maintain the order of words in the original query. You may use the following code template as a starting point: ```python def clean_search_query(query: str, stop_words: set[str]) -> str: cleaned_words = [] query_words = query.split() for word in query_words: if word.lower() not in stop_words: cleaned_words.append(word) return \' \'.join(cleaned_words) # Test the function input_query = \\"The quick brown fox jumps over the lazy dog\\" stop_words = {\\"the\\", \\"over\\", \\"and\\"} print(clean_search_query(input_query, stop_words)) # Output should be \\"quick brown fox jumps lazy dog\\" ```","solution":"def clean_search_query(query: str, stop_words: set[str]) -> str: Removes stop words from the search query. Args: query: str: The search query. stop_words: set[str]: A set of stop words to remove from the query. Returns: str: The cleaned query with stop words removed. cleaned_words = [] query_words = query.split() for word in query_words: if word.lower() not in stop_words: cleaned_words.append(word) return \' \'.join(cleaned_words)"},{"question":"# Problem Statement In the process of building a library for educational purposes, one of the functions you need to implement involves generating permutations of a string. In particular, you are required to create a function that, given a string of unique characters, returns all its possible permutations in a lexicographically sorted order. Function Signature ```python def sorted_permutations(input_string: str) -> list[str]: Generate and return all lexical permutations of the given string in sorted order. Args: input_string (str): A string of unique characters. Returns: list: A list of string permutations, sorted lexicographically. Example: >>> sorted_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] pass ``` # Constraints: * The input string will have unique characters only. * The length of the input string will be between 1 and 9 characters. * The function should handle different character sets, including both lowercase letters and digits. # Requirements: * The function should return a list of all permutations of the input string, sorted in lexicographical order. * Implement the function with a consideration for efficiency, in terms of both time and space. # Example: ```python >>> sorted_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> sorted_permutations(\\"123\\") [\'123\', \'132\', \'213\', \'231\', \'312\', \'321\'] >>> sorted_permutations(\\"ab\\") [\'ab\', \'ba\'] ```","solution":"from itertools import permutations def sorted_permutations(input_string: str) -> list[str]: Generate and return all lexical permutations of the given string in sorted order. Args: input_string (str): A string of unique characters. Returns: list: A list of string permutations, sorted lexicographically. perm = permutations(input_string) perm_list = [\'\'.join(p) for p in perm] return sorted(perm_list)"},{"question":"# Coding Question **Title: Rectangle Overlap Detection** **Background**: In computational geometry, one common problem is determining whether two rectangles overlap. Each rectangle in a 2D plane is defined by its bottom-left and top-right corners. Write a Python function `is_rectangle_overlap(rect1: List[int], rect2: List[int]) -> bool` that checks if two given rectangles overlap. Each rectangle is represented by a list of four integers: [x1, y1, x2, y2], where (x1, y1) is the bottom-left corner, and (x2, y2) is the top-right corner. **Function Signature**: ```python def is_rectangle_overlap(rect1: List[int], rect2: List[int]) -> bool: ``` **Input**: - `rect1` (List[int]): A list of four integers [x1, y1, x2, y2] representing the coordinates of the first rectangle. `-10000 <= x1 < x2 <= 10000` and `-10000 <= y1 < y2 <= 10000`. - `rect2` (List[int]): A list of four integers [x1, y1, x2, y2] representing the coordinates of the second rectangle. `-10000 <= x1 < x2 <= 10000` and `-10000 <= y1 < y2 <= 10000`. **Output**: - (bool): `True` if the rectangles overlap, `False` otherwise. **Constraints**: - Rectangles touch at the edges or corners do not count as overlapping. - Rectangles are axis-aligned and defined in the coordinate plane. **Examples**: ```python assert is_rectangle_overlap([0, 0, 2, 2], [1, 1, 3, 3]) == True assert is_rectangle_overlap([0, 0, 1, 1], [1, 0, 2, 1]) == False assert is_rectangle_overlap([0, 0, 3, 3], [3, 3, 4, 4]) == False ``` **Implementation Guidelines**: 1. For two rectangles to not overlap, one must be completely to the left or right, or completely above or below, of the other rectangle. 2. Use basic coordinate comparisons to determine if any of these non-overlapping conditions exist. 3. If none of these conditions hold, the rectangles overlap. 4. Ensure the function handles edge cases where rectangles just touch but do not overlap. **Notes**: - You can use the separating axis theorem to verify the non-overlapping conditions quickly. - Be cautious about the difference between touching and overlapping, particularly at the edges or corners.","solution":"from typing import List def is_rectangle_overlap(rect1: List[int], rect2: List[int]) -> bool: Determines if two rectangles overlap. Parameters: rect1 (List[int]): Coordinates of the first rectangle [x1, y1, x2, y2]. rect2 (List[int]): Coordinates of the second rectangle [x1, y1, x2, y2]. Returns: bool: True if the rectangles overlap, False otherwise. # Unpack the coordinates x1_1, y1_1, x2_1, y2_1 = rect1 x1_2, y1_2, x2_2, y2_2 = rect2 # Check if one rectangle is to the left of the other if x2_1 <= x1_2 or x2_2 <= x1_1: return False # Check if one rectangle is above the other if y2_1 <= y1_2 or y2_2 <= y1_1: return False return True"},{"question":"# Scenario You are designing a system for an online bookstore to efficiently manage their book inventory. The system needs to keep track of book sales and identify the top-selling book titles in a given period. As part of the development team, you are required to implement a function that will determine the most frequently sold book titles. # Question Write a function `get_top_selling_books(sales_data: List[Tuple[str, int]], top_n: int) -> List[str]` to find the top `n` selling book titles from the provided sales data: 1. **sales_data**: A list of tuples where each tuple contains a book title (string) and the number of copies sold (integer). 2. **top_n**: An integer specifying the number of top-selling book titles to return. # Input/Output Format - **Input**: - `sales_data`: a list of tuples, e.g., `[(\\"Book A\\", 50), (\\"Book B\\", 75), (\\"Book A\\", 25)]`. Each tuple includes: - `title`: a string representing the book title (1 ≤ len(title) ≤ 100) - `copies_sold`: an integer indicating the number of copies sold (0 ≤ copies_sold ≤ 10^6) - `top_n`: an integer (1 ≤ top_n ≤ len(sales_data)) - **Output**: - Returns a list of strings with the top `n` book titles, ordered by the total number of copies sold in descending order. If two titles have the same number of copies sold, they should be ordered alphabetically. # Constraints - Assume the system can handle a large number of sales records. - Ensure the function runs efficiently with optimal time complexity. # Examples ```python assert get_top_selling_books([(\\"Book A\\", 50), (\\"Book B\\", 75), (\\"Book A\\", 25)], 1) == [\\"Book A\\"] assert get_top_selling_books([(\\"Book A\\", 50), (\\"Book B\\", 75), (\\"Book C\\", 50)], 2) == [\\"Book A\\", \\"Book C\\"] assert get_top_selling_books([(\\"Book X\\", 10), (\\"Book Y\\", 20), (\\"Book Z\\", 15)], 3) == [\\"Book Y\\", \\"Book Z\\", \\"Book X\\"] assert get_top_selling_books([(\\"Book M\\", 100), (\\"Book N\\", 100), (\\"Book O\\", 50)], 2) == [\\"Book M\\", \\"Book N\\"] ```","solution":"from collections import defaultdict from typing import List, Tuple def get_top_selling_books(sales_data: List[Tuple[str, int]], top_n: int) -> List[str]: Returns the top n selling book titles. Parameters: - sales_data: List of tuples containing book title and copies sold. - top_n: Number of top selling book titles to return. Returns: List of top n selling book titles ordered by the number of copies sold. # Create a dictionary to count total sales for each book sales_count = defaultdict(int) for title, copies in sales_data: sales_count[title] += copies # Sort the books first by total sales (descending) and then alphabetically (ascending) sorted_books = sorted(sales_count.items(), key=lambda x: (-x[1], x[0])) # Return the top n book titles return [title for title, _ in sorted_books[:top_n]]"},{"question":"Implement a Tarjan\'s algorithm for finding Strongly Connected Components (SCCs) in a directed graph. A strongly connected component is a maximal subgraph where every vertex is reachable from every other vertex in the subgraph. # Task Implement the function `tarjan_scc(n: int, edges: list[tuple[int, int]]) -> list[list[int]]` to find all strongly connected components in the given directed graph. **Input**: - `n` (an integer): The number of vertices in the graph. - `edges` (a list of tuples): Each tuple represents a directed edge from `u` to `v` in the graph. **Output**: - Returns a list of lists, where each sub-list represents a strongly connected component containing the vertices within that component. **Constraints**: - 1 ≤ n ≤ 10^4 - 0 ≤ len(edges) ≤ 10^5 # Example ```python def tarjan_scc(n: int, edges: list[tuple[int, int]]) -> list[list[int]]: def dfs(v): nonlocal index indices[v] = lowlink[v] = index index += 1 stack.append(v) on_stack[v] = True for w in graph[v]: if indices[w] == -1: dfs(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: lowlink[v] = min(lowlink[v], indices[w]) if lowlink[v] == indices[v]: component = [] while True: w = stack.pop() on_stack[w] = False component.append(w) if w == v: break components.append(component) graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) index = 0 indices = [-1] * n lowlink = [-1] * n stack = [] on_stack = [False] * n components = [] for v in range(n): if indices[v] == -1: dfs(v) return components n = 7 edges = [(0, 1), (1, 2), (2, 0), (1, 3), (3, 4), (4, 5), (5, 3), (5, 6)] print(tarjan_scc(n, edges)) # Output: [[3, 4, 5], [6], [0, 1, 2]] ``` [Explanation]: - In the provided example, the directed graph has 7 vertices and multiple directed edges. - The output consists of three SCCs: `[3, 4, 5]`, `[6]`, and `[0, 1, 2]`. The vertices in each SCC are strongly connected to each other.","solution":"def tarjan_scc(n: int, edges: list[tuple[int, int]]) -> list[list[int]]: def dfs(v): nonlocal index indices[v] = lowlink[v] = index index += 1 stack.append(v) on_stack[v] = True for w in graph[v]: if indices[w] == -1: dfs(w) lowlink[v] = min(lowlink[v], lowlink[w]) elif on_stack[w]: lowlink[v] = min(lowlink[v], indices[w]) if lowlink[v] == indices[v]: component = [] while True: w = stack.pop() on_stack[w] = False component.append(w) if w == v: break components.append(component) graph = [[] for _ in range(n)] for u, v in edges: graph[u].append(v) index = 0 indices = [-1] * n lowlink = [-1] * n stack = [] on_stack = [False] * n components = [] for v in range(n): if indices[v] == -1: dfs(v) return components"},{"question":"# Determining the Most Frequent Element Context You are tasked with implementing an algorithm to find the most frequent element in a list of integers. If there is a tie for the most frequent element, return the smallest one. Ensure the algorithm is efficient for large lists. Function Definition Implement the `most_frequent_element(numbers: List[int]) -> int` function. **Input**: - `numbers` (List[int]): A list of integers. **Output**: - An integer representing the most frequent element in the list. Constraints: - The list will contain between 1 and 10^6 integers. - Each integer will be within the range [-10^5, 10^5]. Example: ```python assert most_frequent_element([1, 2, 3, 2, 1, 2, 4]) == 2 assert most_frequent_element([4, 4, 1, 1, 2, 2, 3]) == 1 assert most_frequent_element([5]) == 5 assert most_frequent_element([-1, -1, -2, -2, -1]) == -1 ``` Requirements: 1. The function must be efficient in terms of both time and space complexity. 2. Use appropriate data structures to optimize the counting and selection process.","solution":"from typing import List from collections import Counter def most_frequent_element(numbers: List[int]) -> int: Returns the most frequent element in the list. In case of a tie, the smallest element is returned. if not numbers: return None frequency = Counter(numbers) # Find the element with highest frequency. If tie, return the smallest element most_frequent = min(numbers, key=lambda x: (-frequency[x], x)) return most_frequent"},{"question":"# Coding Assessment Question You are tasked with developing a small library management system to help manage book checkouts and returns. This system should be able to record information about books, students, and checkout/return transactions. This exercise will test your ability to manage data using classes and implement basic CRUD (Create, Read, Update, Delete) operations. Your Task 1. **Class Definitions**: - Create classes for `Book`, `Student`, and `Library`. 2. **Book Class**: - Attributes: `book_id` (str), `title` (str), `author` (str), `is_checked_out` (bool) - Methods: - `checkout()`: Marks the book as checked out. - `return_book()`: Marks the book as returned. 3. **Student Class**: - Attributes: `student_id` (str), `name` (str), `borrowed_books` (list of Book objects) - Methods: - `borrow_book(book: Book)`: Adds a book to `borrowed_books`. - `return_book(book: Book)`: Removes a book from `borrowed_books`. 4. **Library Class**: - Attributes: `books` (list of Book objects), `students` (list of Student objects) - Methods: - `add_book(book: Book)`: Adds a new book to the library. - `add_student(student: Student)`: Adds a new student. - `checkout_book(book_id: str, student_id: str)`: Allows a student to checkout a book. - `return_book(book_id: str, student_id: str)`: Allows a student to return a book. - `get_book_info(book_id: str) -> dict`: Retrieves information about a specific book. - `get_student_info(student_id: str) -> dict`: Retrieves information about a specific student. # Implementation Details Required Classes and Methods: 1. **Class `Book`**: - `__init__(self, book_id: str, title: str, author: str)`: Initializes the book with the given ID, title, and author. The book is not checked out initially. - `checkout(self)`: Sets `is_checked_out` to True. - `return_book(self)`: Sets `is_checked_out` to False. 2. **Class `Student`**: - `__init__(self, student_id: str, name: str)`: Initializes the student with the given ID and name. - `borrow_book(self, book: Book)`: Adds a book to the student\'s `borrowed_books` if the book is not already checked out. - `return_book(self, book: Book)`: Removes a book from the student\'s `borrowed_books` if the book is already borrowed. 3. **Class `Library`**: - `__init__(self)`: Initializes an empty library. - `add_book(self, book: Book)`: Adds the book to the library\'s collection. - `add_student(self, student: Student)`: Adds the student to the library\'s student list. - `checkout_book(self, book_id: str, student_id: str)`: Allows a student to check out a book by ID if it\'s not already checked out. - `return_book(self, book_id: str, student_id: str)`: Allows a student to return a book by ID if they have borrowed it. - `get_book_info(self, book_id: str) -> dict`: Returns the book\'s details (ID, title, author, is_checked_out). - `get_student_info(self, student_id: str) -> dict`: Returns the student\'s details (ID, name, and list of borrowed books). Constraints: - Each book has a unique book ID. - Each student has a unique student ID. - A student can only borrow a book if it is not already checked out. - The library can hold a maximum of 1000 books. - No student can borrow more than 10 books at a time. Input/Output - **Input**: - Methods will be called with appropriate parameters to manage the library, books, and students. - **Output**: - Methods return the current state of books and students as dictionaries when queried. # Scenario You are given an empty library, and your objective is to implement the classes and methods described above. You\'ll add books and students, and simulate book checkouts and returns while keeping track of the library\'s inventory and records accurately. This ensures efficient management and retrieval of information regarding the books and students.","solution":"class Book: def __init__(self, book_id: str, title: str, author: str): self.book_id = book_id self.title = title self.author = author self.is_checked_out = False def checkout(self): self.is_checked_out = True def return_book(self): self.is_checked_out = False class Student: def __init__(self, student_id: str, name: str): self.student_id = student_id self.name = name self.borrowed_books = [] def borrow_book(self, book: Book): if not book.is_checked_out and len(self.borrowed_books) < 10: book.checkout() self.borrowed_books.append(book) return True return False def return_book(self, book: Book): if book in self.borrowed_books: book.return_book() self.borrowed_books.remove(book) return True return False class Library: def __init__(self): self.books = [] self.students = [] def add_book(self, book: Book): if len(self.books) < 1000: self.books.append(book) def add_student(self, student: Student): self.students.append(student) def checkout_book(self, book_id: str, student_id: str): book = self._find_book(book_id) student = self._find_student(student_id) if book and student: return student.borrow_book(book) return False def return_book(self, book_id: str, student_id: str): book = self._find_book(book_id) student = self._find_student(student_id) if book and student: return student.return_book(book) return False def get_book_info(self, book_id: str) -> dict: book = self._find_book(book_id) if book: return { \\"book_id\\": book.book_id, \\"title\\": book.title, \\"author\\": book.author, \\"is_checked_out\\": book.is_checked_out } return {} def get_student_info(self, student_id: str) -> dict: student = self._find_student(student_id) if student: return { \\"student_id\\": student.student_id, \\"name\\": student.name, \\"borrowed_books\\": [book.book_id for book in student.borrowed_books] } return {} def _find_book(self, book_id: str) -> Book: for book in self.books: if book.book_id == book_id: return book return None def _find_student(self, student_id: str) -> Student: for student in self.students: if student.student_id == student_id: return student return None"},{"question":"# Coding Question **Objective**: Write a function to generate the first N numbers in the look-and-say sequence. # Problem Statement The look-and-say sequence is a recursively defined sequence of numbers studied most notably by John Horton Conway. The sequence starts with `1` and each subsequent term is obtained by describing the previous term. For example, the next term after `1` is \\"one 1\\" (or `11`), the term after `11` is \\"two 1s\\" (or `21`), the term after `21` is \\"one 2, then one 1\\" (or `1211`), and so on. You need to write a function `look_and_say(n: int) -> List[str]` that takes an integer `n` as input and returns a list of the first `n` terms in the look-and-say sequence. # Input Format - A single integer `n`, where `1 <= n <= 20`. # Output Format - A list of strings representing the first `n` terms in the look-and-say sequence. - Example: For `n = 4`, the output should be `[\'1\', \'11\', \'21\', \'1211\']` # Constraints - `1 <= n <= 20` # Example ```python assert look_and_say(1) == [\'1\'] assert look_and_say(2) == [\'1\', \'11\'] assert look_and_say(5) == [\'1\', \'11\', \'21\', \'1211\', \'111221\'] assert look_and_say(0) == [] ``` # Requirements - Implement the function based on the description of the sequence. - Ensure the function handles the given constraints efficiently and correctly. # Notes - The sequence is defined recursively, so consider using either iteration or recursion to generate the terms. - Pay attention to how you describe each term to ensure accuracy in generating the sequence.","solution":"from typing import List def look_and_say(n: int) -> List[str]: if n <= 0: return [] sequence = [\\"1\\"] for i in range(1, n): previous_term = sequence[-1] next_term = \\"\\" count = 1 for j in range(1, len(previous_term)): if previous_term[j] == previous_term[j-1]: count += 1 else: next_term += str(count) + previous_term[j-1] count = 1 next_term += str(count) + previous_term[-1] sequence.append(next_term) return sequence"},{"question":"**Scenario**: You are tasked with developing an automated sorting system for a large library. The library\'s book collection is represented as a series of shelves, each holding books identified by their unique book IDs. Each shelf is represented as a list of integers, where each integer denotes a book ID. Your objective is to merge these shelves into a single, sorted list of book IDs in ascending order, ensuring there are no duplicates in the final list. **Problem Statement**: Implement the `merge_shelves` method to merge a list of shelves into a single, sorted list of unique book IDs. **Function Signature**: ```python def merge_shelves(shelves: List[List[int]]) -> List[int]: ``` **Input**: - `shelves`: A list of lists, where each sublist represents a shelf containing integers (book IDs). **Output**: - A sorted list of unique integers representing the merged book IDs from all shelves. **Constraints**: - Number of shelves: (1 leq N leq 100) - Number of books per shelf: (0 leq M leq 1000) - Book IDs are non-negative integers and can be in the range ([0, 10000]) **Example**: ```python shelves = [ [103, 203, 403], [123, 203, 403, 503], [1, 3, 103, 123, 1003] ] ``` Calculate merged sorted list: ```python print(merge_shelves(shelves)) # Output should be [1, 3, 103, 123, 203, 403, 503, 1003] ``` **Notes**: - Ensure the function handles edge cases like empty shelves or shelves with the same books. - Optimize the function for time and space efficiency as much as possible.","solution":"def merge_shelves(shelves): Merges a list of book shelves into a single sorted list of unique book IDs. Parameters: shelves (List[List[int]]): A list of shelves, each shelf is a list of book IDs. Returns: List[int]: A sorted list of unique book IDs. # Use a set to collect unique book IDs unique_books = set() # Iterate over each shelf and add book IDs to the set for shelf in shelves: for book_id in shelf: unique_books.add(book_id) # Convert the set to a sorted list and return return sorted(unique_books)"},{"question":"# Programming Assessment Question **Title:** Validate and Generate International Standard Book Numbers (ISBN-13) **Objective**: Write a function that validates a given ISBN-13 string for correctness and generates a valid new ISBN-13 from a given ISBN-10 string. **Requirements**: - **Function Signature:** `def validate_isbn(isbn: str) -> bool` - **Function Signature:** `def convert_isbn10_to_isbn13(isbn10: str) -> str` **Input**: - `isbn` (string): A 13-character string to be validated as an ISBN-13. - `isbn10` (string): A 10-character string representing an ISBN-10. **Output**: - For `validate_isbn`: Returns `True` if the given ISBN-13 is valid, otherwise returns `False`. - For `convert_isbn10_to_isbn13`: Returns a valid ISBN-13 generated from the provided ISBN-10. **Constraints**: - The input strings will only consist of digits, for simplicity. - An ISBN-13 is valid if its final character (check digit) matches the calculation. - ISBN-13 is generated from ISBN-10 by prefixing \'978\' and recalculating the check digit. **Examples**: ```python >>> validate_isbn(\\"9780306406157\\") True >>> validate_isbn(\\"9780306406158\\") False >>> convert_isbn10_to_isbn13(\\"0306406152\\") \'9780306406157\' >>> convert_isbn10_to_isbn13(\\"123456789X\\") \'9781234567897\' ``` **Scenario**: You are working in a library system updating records. You need to ensure the integrity of ISBNs stored in the database and also need to convert older ISBN-10 entries to the current ISBN-13 format. **HINT**: 1. For ISBN-13 validation, use the formula which alternates multiplying each digit by 1 or 3, and then sum the results. The sum should be divisible by 10. 2. For conversion, recall that ISBN-10-to-ISBN-13 transformation involves recalculating the check digit after prefixing \'978\' to the ISBN-10. --- This question tests understanding of string manipulation, algorithmic checking processes (like checksum calculations), and practical applications of converting between different standards.","solution":"def validate_isbn(isbn: str) -> bool: Validate the given ISBN-13 string. Parameters: isbn (str): A 13-character string to be validated as an ISBN-13. Returns: bool: True if the ISBN-13 is valid, False otherwise. if len(isbn) != 13 or not isbn.isdigit(): return False total = 0 for i in range(12): digit = int(isbn[i]) if i % 2 == 0: total += digit else: total += digit * 3 check_digit = (10 - (total % 10)) % 10 return check_digit == int(isbn[12]) def convert_isbn10_to_isbn13(isbn10: str) -> str: Convert a given ISBN-10 string to ISBN-13. Parameters: isbn10 (str): A 10-character string representing an ISBN-10. Returns: str: A valid ISBN-13 string generated from the provided ISBN-10. if len(isbn10) != 10: return \\"\\" isbn13_base = \'978\' + isbn10[:9] total = 0 for i in range(12): digit = int(isbn13_base[i]) if i % 2 == 0: total += digit else: total += digit * 3 check_digit = (10 - (total % 10)) % 10 return isbn13_base + str(check_digit)"},{"question":"# User Account Registration System You are developing a user account registration system for a web application. Your task is to implement the backend logic that validates and processes new user registrations. You are responsible for ensuring that only valid and unique usernames are accepted and that the passwords meet certain security criteria. **Function Signature:** ```python def register_user(users: dict, username: str, password: str) -> bool: ``` # Requirements: 1. The function should take a dictionary `users` where the keys are usernames and the values are their corresponding hashed passwords. 2. The `username` parameter should be a non-empty string containing only alphanumeric characters and underscores, with a length of 3 to 20 characters. 3. The `password` parameter must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, one digit, and one special character from `!@#%^&*()_+`. 4. If the `username` already exists in the `users` dictionary, the function should return `False`. 5. If the `username` and `password` meet the criteria, the function should hash the `password` using SHA-256, add the username and hashed password to the `users` dictionary, and return `True`. # Input: - A dictionary `users` with existing usernames and hashed passwords. - A string `username` representing the new username. - A string `password` representing the new password. # Output: - A boolean value `True` if the registration is successful, otherwise `False`. # Constraints: - Use the built-in `hashlib` library for password hashing. - Assume that inputs follow the standard types expected (`users` is always a dictionary, `username` and `password` are always strings). # Context/Use Case: This function is part of a web service that allows users to create new accounts. Ensuring strong password policies and preventing duplicate usernames is crucial for maintaining the security and integrity of the user database. # Example: ```python import hashlib def register_user(users: dict, username: str, password: str) -> bool: import re # Validate username if not (3 <= len(username) <= 20) or not re.match(r\'^w+\', username): return False # Validate password if (len(password) < 8 or not re.search(r\'[A-Z]\', password) or not re.search(r\'[a-z]\', password) or not re.search(r\'d\', password) or not re.search(r\'[!@#%^&*()_+]\', password)): return False # Check if username already exists if username in users: return False # Hash the password hashed_password = hashlib.sha256(password.encode()).hexdigest() # Register new user users[username] = hashed_password return True # Example usage existing_users = { \\"john_doe\\": \\"5e884898da28047151d0e56f8dc6292773603d0d6aabbdd3d743febae82ea411\\", } print(register_user(existing_users, \\"new_user\\", \\"Password123!\\")) # Output: True print(register_user(existing_users, \\"john_doe\\", \\"Password456!\\")) # Output: False (username exists) print(register_user(existing_users, \\"user!\\", \\"Pass123!\\")) # Output: False (invalid username) print(register_user(existing_users, \\"user123\\", \\"password\\")) # Output: False (weak password) ```","solution":"import hashlib import re def register_user(users: dict, username: str, password: str) -> bool: # Validate username if not (3 <= len(username) <= 20) or not re.match(r\'^w+\', username): return False # Validate password if (len(password) < 8 or not re.search(r\'[A-Z]\', password) or not re.search(r\'[a-z]\', password) or not re.search(r\'d\', password) or not re.search(r\'[!@#%^&*()_+]\', password)): return False # Check if username already exists if username in users: return False # Hash the password hashed_password = hashlib.sha256(password.encode()).hexdigest() # Register new user users[username] = hashed_password return True"},{"question":"# Objective: To implement a function that calculates the nth Fibonacci number using both a recursive and an iterative approach. Compare the performance of both methods for varying values of n. # Task: 1. Implement a `fib_recursive` function that takes an integer `n` and returns the nth Fibonacci number using a recursive method. 2. Implement a `fib_iterative` function that takes an integer `n` and returns the nth Fibonacci number using an iterative method. 3. Implement a `main` function to demonstrate both methods and compare their performance. # Function Signatures: ```python def fib_recursive(n: int) -> int: ``` ```python def fib_iterative(n: int) -> int: ``` # Input: * `n` (int): the position in the Fibonacci sequence to compute (0 ≤ n ≤ 30 for testing performance; can be higher for practical use). # Output: * The nth Fibonacci number as an integer. # Requirements: 1. The `fib_recursive` must use a pure recursive approach. 2. The `fib_iterative` must use an iterative approach with a loop. 3. The `main` function should compare the performance of both functions for `n` values 0 to the maximum practical value (e.g., 30) printing the results. # Constraints: * Comparing performance for `n` up to 30 provides a manageable and demonstrative test case of performance differences without excessively long computation times. # Examples: ```python >>> fib_recursive(0) 0 >>> fib_iterative(0) 0 >>> fib_recursive(5) 5 >>> fib_iterative(5) 5 >>> fib_recursive(10) 55 >>> fib_iterative(10) 55 ``` # Additional Information: Implement the `main` function to: 1. Prompt the user to input the maximum value `n` for comparison (suggested 30). 2. Calculate and print the nth Fibonacci number using both `fib_recursive` and `fib_iterative` functions. 3. Measure and display the time taken for each function to complete the calculation for each `n` up to the requested maximum. ```python import time def fib_recursive(n: int) -> int: if n <= 1: return n return fib_recursive(n-1) + fib_recursive(n-2) def fib_iterative(n: int) -> int: if n <= 1: return n a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b def main(): n = int(input(\\"Enter the maximum value of n for comparing Fibonacci calculation methods: \\")) print(f\\"nComparing performance for n from 0 to {n}:n\\") for i in range(n + 1): start_time = time.time() fib_recursive(i) recursive_time = time.time() - start_time start_time = time.time() fib_iterative(i) iterative_time = time.time() - start_time print(f\\"n={i:2d}: Recursive: {recursive_time:.6f} sec, Iterative: {iterative_time:.6f} sec\\") if __name__ == \\"__main__\\": main() ```","solution":"def fib_recursive(n: int) -> int: if n <= 1: return n return fib_recursive(n-1) + fib_recursive(n-2) def fib_iterative(n: int) -> int: if n <= 1: return n a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Implementation of a Decision Tree Classifier You are required to implement a basic Decision Tree classifier from scratch, including methods for training the model and making predictions. Task 1. **Complete the `fit` method**: The `fit` method takes a list of features and their respective class labels and builds a decision tree based on the criteria of Information Gain using entropy. 2. **Complete the `predict` method**: The `predict` method takes a new observation and traverses the decision tree to predict its class label. 3. **Implement a method `calculate_entropy`**: This method calculates the entropy of a dataset given the class labels. 4. **Implement functionality to handle continuous and discrete features**: Ensure the Decision Tree can handle both types of features effectively. # Input and Output Input * `fit` method: - `features`: List of NumPy arrays representing the feature vectors. - `labels`: NumPy array representing the class labels. * `predict` method: - `feature`: NumPy array representing a single feature vector. Output * `fit` method: None. This method constructs the decision tree. * `predict` method: The predicted class label for the input feature vector. # Constraints 1. You may assume that the dataset is not excessively large, so focus on clarity rather than performance optimizations. 2. The depth of the tree should be constrained to prevent overfitting, with a default maximum depth of 10, but this should be adjustable via an optional parameter. 3. The model should handle missing data entries in feature vectors by assigning a default value (e.g., the mean for continuous features). # Example Here\'s an example usage of the completed class and methods: ```python import numpy as np # Sample function for entropy calculation def calculate_entropy(labels): Calculate the entropy of the given class labels. Args: labels (ndarray): Array of class labels. Returns: float: Entropy of the class labels. from collections import Counter from math import log2 total = len(labels) class_counts = Counter(labels) entropy = -sum((count/total) * log2(count/total) for count in class_counts.values()) return entropy # Sample data for testing features = [np.array([2.7, 2.5]), np.array([1.6, 2.8]), np.array([3.0, 1.9]), np.array([1.2, 3.2])] labels = np.array([0, 0, 1, 1]) # DecisionTree initialization and training decision_tree = DecisionTree(max_depth=3) decision_tree.fit(features, labels) # Predicting new feature vector prediction = decision_tree.predict(np.array([2.5, 2.5])) print(prediction) # Expected output: 0 or 1 based on the constructed tree. ``` Incorporate the provided elements accurately and ensure that your implementation achieves robust functionality as specified. # Submission Guidelines For your submission, provide the complete implementation of the `DecisionTree` class, including the entropy calculation and other necessary elements. Ensure comprehensive testing for all implemented methods. Do not include example code or tests in your final submission, but ensure the class is capable of handling the above example correctly.","solution":"import numpy as np from collections import Counter from math import log2 class DecisionTree: def __init__(self, max_depth=10): self.max_depth = max_depth self.tree = None def fit(self, features, labels): data = list(zip(features, labels)) self.tree = self._build_tree(data, depth=0) def predict(self, feature): node = self.tree while isinstance(node, dict): split_param = list(node.keys())[0] threshold = node[split_param][\'threshold\'] if feature[split_param] <= threshold: node = node[split_param][\'left\'] else: node = node[split_param][\'right\'] return node def calculate_entropy(self, labels): total = len(labels) class_counts = Counter(labels) entropy = -sum((count / total) * log2(count / total) for count in class_counts.values() if count != 0) return entropy def _best_split(self, data): best_ig = -float(\\"inf\\") best_split_param = None best_threshold = None current_entropy = self.calculate_entropy([label for _, label in data]) for feature_index in range(len(data[0][0])): values = set(point[0][feature_index] for point in data) for threshold in values: left = [point for point in data if point[0][feature_index] <= threshold] right = [point for point in data if point[0][feature_index] > threshold] if not left or not right: continue left_entropy = self.calculate_entropy([label for _, label in left]) right_entropy = self.calculate_entropy([label for _, label in right]) weighted_entropy = (len(left) * left_entropy + len(right) * right_entropy) / len(data) information_gain = current_entropy - weighted_entropy if information_gain > best_ig: best_ig = information_gain best_split_param = feature_index best_threshold = threshold return best_split_param, best_threshold def _build_tree(self, data, depth): labels = [label for _, label in data] if depth == self.max_depth or len(set(labels)) == 1: return Counter(labels).most_common(1)[0][0] split_param, threshold = self._best_split(data) if split_param is None: return Counter(labels).most_common(1)[0][0] left = [point for point in data if point[0][split_param] <= threshold] right = [point for point in data if point[0][split_param] > threshold] return { split_param: { \'threshold\': threshold, \'left\': self._build_tree(left, depth + 1), \'right\': self._build_tree(right, depth + 1), } }"},{"question":"# Problem Statement In this task, you are required to develop a function that determines the cumulative product of the digits of a factorial of a given number. The goal is to assess your ability to calculate factorials, handle large integers, perform string manipulations, and effectively compute products in Python. # Function Signature ```python def digit_product_factorial(n: int) -> int: This function takes an integer n and returns the product of the digits of the factorial of n. :param n: An integer representing the number for which to calculate the factorial. :return: An integer representing the product of the digits of n!. ``` # Expected Input and Output - **Input**: A single integer `n` where 0 ≤ n ≤ 300. - Example: `digit_product_factorial(5)` - **Output**: A single integer representing the product of the digits of the factorial of the given number. - Example: `120` (since 5! = 120 and 1 * 2 * 0 = 0) # Constraints and Limitations 1. Ensure that the input is a non-negative integer and within the specified range (0 ≤ n ≤ 300). 2. Handle edge cases, particularly: - When `n` is 0 (should return 1 since 0! = 1). - Other small values such as 1 (should return 1 since 1! = 1). - Extreme values such as 300 should be handled efficiently. # Example Scenarios 1. **Scenario 1**: - Input: `digit_product_factorial(10)` - Output: `0` (since 10! = 3628800 and 3 * 6 * 2 * 8 * 8 * 0 * 0 = 0) 2. **Scenario 2**: - Input: `digit_product_factorial(7)` - Output: `0` (since 7! = 5040 and 5 * 0 * 4 * 0 = 0) 3. **Scenario 3**: - Input: `digit_product_factorial(4)` - Output: `24` (since 4! = 24 and 2 * 4 = 8) 4. **Scenario 4**: - Input: `digit_product_factorial(15)` - Output: `0` (since 15! ends with multiple zeros resulting in a product of 0) # Performance Requirements Ensure your implementation is efficient and can handle the input size within a reasonable time frame. The constraints guarantee calculations with potentially large numbers, so consider the computational cost of each operation involving large integers and digit manipulations.","solution":"from math import factorial from functools import reduce def digit_product_factorial(n: int) -> int: This function takes an integer n and returns the product of the digits of the factorial of n. :param n: An integer representing the number for which to calculate the factorial. :return: An integer representing the product of the digits of n!. factorial_result = factorial(n) digits = [int(digit) for digit in str(factorial_result)] product = reduce(lambda x, y: x * y, digits, 1) return product"},{"question":"# Scenario You are developing a text-based adventure game, and you need to implement a feature that processes player commands. The commands could involve movement directions (like \\"go north\\", \\"go south\\"), actions (like \\"take item\\", \\"drop item\\"), and system commands (like \\"save game\\", \\"load game\\"). Your task is to write a function that takes a command string and parses it into a structured format. # Task Write a function `parse_command(command: str) -> dict` that takes a string `command` and returns a dictionary with keys `action`, `direction` (if applicable), and `item` (if applicable). # Function Signature ```python def parse_command(command: str) -> dict: ``` # Expected Input and Output - **Input**: A string `command` consisting of multiple words separated by spaces. - **Output**: A dictionary with the parsed information. # Constraints - The input string will have a length between `1` and `100`. - Valid commands are combinations of verbs like [\\"go\\", \\"take\\", \\"drop\\", \\"save\\", \\"load\\"] with appropriate nouns if needed. - Directions can be [\\"north\\", \\"south\\", \\"east\\", \\"west\\"]. - Items are single-word strings that follow the verbs \\"take\\" or \\"drop\\". - The parsing should be case-insensitive but should maintain the format of output as specified below. # Performance Requirements - The function should run in `O(m)` time complexity where `m` is the length of the input string. - The space complexity should be `O(m)`. # Examples ```python assert parse_command(\\"Go North\\") == {\\"action\\": \\"go\\", \\"direction\\": \\"north\\"} assert parse_command(\\"take sword\\") == {\\"action\\": \\"take\\", \\"item\\": \\"sword\\"} assert parse_command(\\"drop shield\\") == {\\"action\\": \\"drop\\", \\"item\\": \\"shield\\"} assert parse_command(\\"save game\\") == {\\"action\\": \\"save\\"} assert parse_command(\\"load game\\") == {\\"action\\": \\"load\\"} assert parse_command(\\"go west\\") == {\\"action\\": \\"go\\", \\"direction\\": \\"west\\"} ``` # Notes - Make sure the function correctly identifies and extracts \\"action\\", \\"direction\\", and \\"item\\" based on the command. - Ensure the output dictionary includes only the relevant keys based on the command type. - Edge cases such as incorrect commands (e.g., \\"run east\\", \\"pickup item\\") should be handled by returning an empty dictionary `{}`.","solution":"def parse_command(command: str) -> dict: Parses a command string and returns a structured dictionary with keys action, direction, and item as applicable. command = command.lower().strip() words = command.split() if len(words) == 0: return {} action = words[0] valid_actions = [\\"go\\", \\"take\\", \\"drop\\", \\"save\\", \\"load\\"] directions = [\\"north\\", \\"south\\", \\"east\\", \\"west\\"] if action not in valid_actions: return {} result = {\\"action\\": action} if action == \\"go\\": if len(words) == 2 and words[1] in directions: result[\\"direction\\"] = words[1] else: return {} elif action == \\"take\\" or action == \\"drop\\": if len(words) == 2: result[\\"item\\"] = words[1] else: return {} return result"},{"question":"Problem Statement # Context You are developing a system that manages a series of financial transactions. To ensure data integrity, you need to compute the running median of transaction amounts as new transactions are added. The running median is the median of the data seen so far. # Task Write a Python class `RunningMedian` which maintains a stream of transaction amounts and provides the current median at any point. # Requirements * **Methods**: * `def __init__(self)`: Initializes the data structure. * `def add_transaction(amount: int) -> None`: Adds a transaction amount to the stream. * `def get_median() -> float`: Returns the median of all transaction amounts seen so far. # Constraints 1. Each transaction amount is an integer (0 ≤ amount ≤ 10^6). 2. You must handle up to 10^5 transactions efficiently. 3. Ensure that `get_median` has an average-case time complexity of O(1). # Class Definition ```python class RunningMedian: def __init__(self): pass def add_transaction(self, amount: int) -> None: pass def get_median(self) -> float: pass ``` # Example ```python rm = RunningMedian() rm.add_transaction(10) assert rm.get_median() == 10.0 rm.add_transaction(20) assert rm.get_median() == 15.0 rm.add_transaction(30) assert rm.get_median() == 20.0 rm.add_transaction(5) assert rm.get_median() == 15.0 ``` # Performance Considerations Your solution is expected to handle the insertion and retrieval operations efficiently, aiming for logarithmic or constant time complexity where feasible. Use appropriate data structures such as heaps to achieve the performance requirements.","solution":"import heapq class RunningMedian: def __init__(self): # Two heaps: max-heap for lower half, min-heap for upper half self.lower_half = [] # max-heap (inverted values to make it work with heapq which is a min-heap) self.upper_half = [] # min-heap def add_transaction(self, amount: int) -> None: # Adding a new transaction if not self.lower_half or amount <= -self.lower_half[0]: heapq.heappush(self.lower_half, -amount) else: heapq.heappush(self.upper_half, amount) # Balancing the heaps if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def get_median(self) -> float: # Get the median if len(self.lower_half) == len(self.upper_half): return (-self.lower_half[0] + self.upper_half[0]) / 2.0 else: return float(-self.lower_half[0])"},{"question":"# Coding Assessment Question: In-Memory Database with Transaction Support You have recently learned about implementing simple in-memory databases with support for basic CRUD operations. Now, it is your task to extend this knowledge by adding a transaction mechanism to the database. Scenario You are given an in-memory key-value store. The database needs to support transactions, which allow a group of operations to be performed atomically. You should be able to start a transaction, perform various operations, and either commit or rollback the transaction. Task Implement a class `InMemoryDatabase` with methods to handle transactions and basic key-value storage operations. Specifications 1. **Class `InMemoryDatabase`**: * **Methods**: * `def set(self, key: str, value: int) -> None`: Set the value for the given key. * `def get(self, key: str) -> Union[int, None]`: Get the value for the given key. Return `None` if the key does not exist. * `def delete(self, key: str) -> None`: Delete the given key from the database. * `def begin(self) -> None`: Start a new transaction. * `def commit(self) -> None`: Commit all operations of the current transaction. * `def rollback(self) -> None`: Rollback all operations of the current transaction. 2. **Transaction Behaviors**: * `begin()` starts a new transaction boundary. Transactions can be nested, meaning you can have multiple `begin()` calls before a `commit()` or `rollback()`. * `commit()` finalizes the current transaction, applying all changes made since the last `begin()`. * `rollback()` discards all changes made since the last `begin()`. * If there is no active transaction and `commit()` or `rollback()` is called, it should raise an appropriate exception. 3. **CRUD Operations**: * `set()`, `get()`, and `delete()` operations should work within the context of the currently active transaction. * If a transaction is rolled back, changes made within that transaction should not affect the database state. 4. **Edge Cases**: * Handle cases where multiple nested transactions are started and committed or rolled back in the correct order. * Handle operations on non-existent keys. Examples ```python db = InMemoryDatabase() db.set(\\"a\\", 10) assert db.get(\\"a\\") == 10 db.begin() db.set(\\"a\\", 20) assert db.get(\\"a\\") == 20 # value within transaction db.rollback() assert db.get(\\"a\\") == 10 # value restored after rollback db.begin() db.delete(\\"a\\") assert db.get(\\"a\\") is None # key does not exist within transaction db.commit() assert db.get(\\"a\\") is None # key deletion persisted after commit db.begin() db.set(\\"a\\", 30) db.begin() db.set(\\"a\\", 40) assert db.get(\\"a\\") == 40 # value within nested transaction db.rollback() assert db.get(\\"a\\") == 30 # value restored to outer transaction state db.commit() assert db.get(\\"a\\") == 30 # committed transaction state ``` Implement the `InMemoryDatabase` class ensuring compliance with the aforementioned requirements.","solution":"class InMemoryDatabase: def __init__(self): self.store = {} self.transactions = [] def set(self, key: str, value: int) -> None: if self.transactions: self.transactions[-1][key] = value else: self.store[key] = value def get(self, key: str) -> int: if self.transactions: for transaction in reversed(self.transactions): if key in transaction: return transaction[key] return self.store.get(key, None) def delete(self, key: str) -> None: if self.transactions: self.transactions[-1][key] = None else: if key in self.store: del self.store[key] def begin(self) -> None: self.transactions.append({}) def commit(self) -> None: if not self.transactions: raise Exception(\\"No active transaction to commit\\") current_transaction = self.transactions.pop() if self.transactions: self.transactions[-1].update(current_transaction) else: for key, value in current_transaction.items(): if value is None: self.store.pop(key, None) else: self.store[key] = value def rollback(self) -> None: if not self.transactions: raise Exception(\\"No active transaction to rollback\\") self.transactions.pop()"},{"question":"# Objective Implementing digital string processing and substring search algorithms to solve pattern matching problems. # Problem Statement You are required to implement a function that finds the starting index of the first occurrence of a given pattern within a string. If the pattern is not found, the function should return -1. Function Signature ```python def find_pattern(text: str, pattern: str) -> int: Finds the starting index of the first occurrence of the given pattern in the text. Parameters: text (str): The string in which to search for the pattern. pattern (str): The substring pattern to find. Returns: int: The starting index of the first occurrence of the pattern, or -1 if the pattern is not found. ``` # Requirements 1. **String Search Algorithm**: Implement an efficient string search algorithm, like the Knuth-Morris-Pratt (KMP), Boyer-Moore, or Rabin-Karp algorithm, to find the pattern within the text. 2. **Edge Cases Handling**: Consider edge cases such as empty strings, patterns longer than the text, and patterns not present in the text. # Example Input/Output ```python >>> find_pattern(\\"abracadabra\\", \\"cad\\") 4 >>> find_pattern(\\"hello world\\", \\"world\\") 6 >>> find_pattern(\\"test string\\", \\"nope\\") -1 >>> find_pattern(\\"a quick brown fox\\", \\"quick\\") 2 >>> find_pattern(\\"mississippi\\", \\"issip\\") 4 >>> find_pattern(\\"\\", \\"\\") 0 >>> find_pattern(\\"pattern\\", \\"\\") 0 >>> find_pattern(\\"\\", \\"pattern\\") -1 ``` *Expected Output*: The output should be an integer representing the starting index of the first occurrence of the pattern in the text. If the pattern is not found, the output should be -1. # Constraints - The length of the text and the pattern will not exceed 100,000 characters each. - Optimize for time and space complexity. - Ensure robust handling of various possible input scenarios. # Notes - Implement an efficient substring search algorithm. - Consider edge case scenarios and handle them appropriately. - Ensure your implementation is optimal for the given constraints.","solution":"def find_pattern(text: str, pattern: str) -> int: Finds the starting index of the first occurrence of the given pattern in the text. Parameters: text (str): The string in which to search for the pattern. pattern (str): The substring pattern to find. Returns: int: The starting index of the first occurrence of the pattern, or -1 if the pattern is not found. if not pattern: return 0 if not text or len(pattern) > len(text): return -1 # Build the KMP \\"partial match\\" table (also known as \\"failure function\\") partial_match_table = [0] * len(pattern) j = 0 # Preprocessing the pattern for i in range(1, len(pattern)): while j > 0 and pattern[j] != pattern[i]: j = partial_match_table[j-1] if pattern[j] == pattern[i]: j += 1 partial_match_table[i] = j # Searching in the text j = 0 for i in range(len(text)): while j > 0 and pattern[j] != text[i]: j = partial_match_table[j-1] if pattern[j] == text[i]: j += 1 if j == len(pattern): return i - j + 1 return -1"},{"question":"# Palindrome Check with Punctuation You are given a function `is_palindrome` that checks whether a given string is a palindrome, ignoring spaces, punctuation, and letter casing. Your task is to complete the function such that it correctly identifies if the input string is a palindrome with the specified conditions. Ensure the following considerations: - The input string `s` may contain letters, digits, spaces, and punctuation marks. - The function should ignore spaces and punctuation, and it should not be case-sensitive. For this problem, consider letters and digits only. **Function Signature**: ```python def is_palindrome(s: str) -> bool: pass ``` **Input**: - A single string `s`, which may contain letters, digits, spaces, and punctuation marks. **Output**: - A boolean value `True` if the processed string is a palindrome, `False` otherwise. **Examples**: ```python >>> is_palindrome(\\"A man, a plan, a canal, Panama!\\") True >>> is_palindrome(\\"No \'x\' in Nixon\\") True >>> is_palindrome(\\"Hello, world!\\") False >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"Was it a car or a cat I saw?\\") True >>> is_palindrome(\\"race a car\\") False ``` Please implement the function `is_palindrome` to pass the given examples and ensure its correctness for other similar inputs.","solution":"def is_palindrome(s: str) -> bool: Returns True if the input string is a palindrome, ignoring spaces, punctuation, and letter casing. # Filter only alphanumeric characters and convert to lowercase filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered characters form a palindrome return filtered_chars == filtered_chars[::-1]"},{"question":"# Coding Assessment Question Scenario A delivery company wants to optimize its operations by implementing a function that calculates the shortest route for delivering packages using the Dijkstra algorithm. You are tasked with writing a function that, given a map of delivery points and travel times, determines the shortest delivery route from a starting point to all other delivery points. Requirements * Write a function `shortest_delivery_route(start: str, edges: List[Tuple[str, str, int]]) -> Dict[str, int]` that calculates the shortest route using Dijkstra\'s algorithm. * Validate the inputs to ensure they meet the following constraints: - The start point must be a non-empty string. - The edges must be a list of tuples, where each tuple contains two non-empty strings (representing delivery points) and a positive integer (representing the travel time). * You must raise appropriate exceptions if the input values do not meet the constraints. Expected Input and Output * **Input**: - `start` (str): The starting delivery point. - `edges` (List[Tuple[str, str, int]]): A list of tuples representing the directed edges between delivery points and the travel time between them. * **Output**: - (Dict[str, int]): A dictionary where keys are delivery points and values are the shortest travel times from the start point. Examples 1. `shortest_delivery_route(\\"A\\", [(\\"A\\", \\"B\\", 1), (\\"B\\", \\"C\\", 2), (\\"A\\", \\"C\\", 4)])` should return `{\'A\': 0, \'B\': 1, \'C\': 3}` 2. `shortest_delivery_route(\\"X\\", [(\\"X\\", \\"Y\\", 5), (\\"Y\\", \\"Z\\", 10), (\\"X\\", \\"Z\\", 100)])` should return `{\'X\': 0, \'Y\': 5, \'Z\': 15}` 3. `shortest_delivery_route(\\"\\", [(\\"A\\", \\"B\\", 1)])` should raise an `Exception` with message \\"Start point must be a non-empty string\\" 4. `shortest_delivery_route(\\"A\\", [(\\"A\\", \\"B\\", -2)])` should raise an `Exception` with message \\"Travel time must be a positive integer\\" 5. `shortest_delivery_route(\\"A\\", [(\\"\\", \\"B\\", 1)])` should raise an `Exception` with message \\"Delivery points must be non-empty strings\\" Constraints * The graph is represented as an adjacency list. * All edge weights (travel times) are positive integers. ***Write your function below:*** ```python from typing import List, Tuple, Dict import heapq def shortest_delivery_route(start: str, edges: List[Tuple[str, str, int]]) -> Dict[str, int]: Calculate the shortest delivery route from the starting point to all other delivery points using Dijkstra\'s Algorithm. :param start: The starting delivery point :param edges: A list of tuples representing the directed edges and travel times :return: A dictionary where keys are delivery points and values are the shortest travel times from the start point # Validate input if not start: raise Exception(\\"Start point must be a non-empty string\\") for edge in edges: if not edge[0] or not edge[1]: raise Exception(\\"Delivery points must be non-empty strings\\") if edge[2] <= 0: raise Exception(\\"Travel time must be a positive integer\\") # Create adjacency list for the graph graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Initialize distances and priority queue distances = {node: float(\'inf\') for node in graph} distances[start] = 0 pq = [(0, start)] # Dijkstra\'s Algorithm while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances ```","solution":"from typing import List, Tuple, Dict import heapq def shortest_delivery_route(start: str, edges: List[Tuple[str, str, int]]) -> Dict[str, int]: Calculate the shortest delivery route from the starting point to all other delivery points using Dijkstra\'s Algorithm. :param start: The starting delivery point :param edges: A list of tuples representing the directed edges and travel times :return: A dictionary where keys are delivery points and values are the shortest travel times from the start point # Validate input if not start: raise Exception(\\"Start point must be a non-empty string\\") for edge in edges: if not edge[0] or not edge[1]: raise Exception(\\"Delivery points must be non-empty strings\\") if edge[2] <= 0: raise Exception(\\"Travel time must be a positive integer\\") # Create adjacency list for the graph graph = {} for u, v, w in edges: if u not in graph: graph[u] = [] graph[u].append((v, w)) # Initialize distances and priority queue distances = {} pq = [] # Add nodes from edges to distances for u, _, _ in edges: distances[u] = float(\'inf\') for _, v, _ in edges: distances[v] = float(\'inf\') # Initialize start point distance if start in distances: distances[start] = 0 pq.append((0, start)) # Dijkstra\'s Algorithm while pq: current_distance, current_vertex = heapq.heappop(pq) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph.get(current_vertex, []): distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances"},{"question":"# Coding Question: Maximal Product of Integer Splits Problem Statement: Given an integer `n`, consider breaking it into smaller integers such that their sum equals `n`, and the product of these integers is maximized. Write a function that determines the maximum product obtainable from any split of the given integer `n`. Write a function `maximal_product(n: int) -> int` where: - **Input**: - `n` (an integer) - the integer to be split. - **Output**: - Return the maximum product obtainable from any split of the given integer `n`. Function Signature: `def maximal_product(n: int) -> int` **Examples**: ```python assert maximal_product(10) == 36 # 2+2+3+3 -> 2*2*3*3 = 36 assert maximal_product(8) == 18 # 2+3+3 -> 2*3*3 = 18 assert maximal_product(5) == 6 # 2+3 -> 2*3 = 6 ``` Constraints: - The input integer `n` will be at least 2 and at most 58. Explanation: - One straightforward approach involves using dynamic programming to explore the splits. Alternatively, mathematical observations can lead to an optimized solution based on properties of integers and their products. Performance Requirements: - The solution should efficiently handle all values within the given constraints without significant increases in computational complexity.","solution":"def maximal_product(n: int) -> int: if n == 2: return 1 if n == 3: return 2 product = 1 while n > 4: n -= 3 product *= 3 product *= n return product"},{"question":"Maximal Histogram Rectangle Area Write a function `max_histogram_area(histogram: List[int]) -> int` that computes the area of the largest rectangle that can be formed within a given histogram. # Function Signature ```python def max_histogram_area(histogram: List[int]) -> int: pass ``` # Input - `histogram` (List[int]): A list of non-negative integers representing the heights of the histogram bars. # Output - An integer representing the area of the largest rectangle that can be formed within the given histogram. # Constraints - `1 <= len(histogram) <= 10^5` - `0 <= histogram[i] <= 10^4` # Example ```python print(max_histogram_area([2, 1, 5, 6, 2, 3])) # Output should be 10 print(max_histogram_area([6, 2, 5, 4, 5, 1, 6])) # Output should be 12 ``` # Hints 1. Use a stack to keep track of indices of histogram bars. 2. By iterating through the histogram and using the stack, you can efficiently calculate the maximum rectangular area. # Notes - This problem is usually associated with a function known as \\"Largest Rectangle in Histogram\\". - Ensure that the function handles both increasing and decreasing sequences in the histogram. - Optimize for both time and space complexity, considering the constraints.","solution":"from typing import List def max_histogram_area(histogram: List[int]) -> int: Computes the area of the largest rectangle that can be formed within a given histogram. stack = [] # Stack to store indices max_area = 0 # Initialize max area index = 0 while index < len(histogram): # If this bar is higher than the bar at stack top, push it to the stack if not stack or histogram[stack[-1]] <= histogram[index]: stack.append(index) index += 1 else: # Pop the top top_of_stack = stack.pop() # Calculate the area with histogram[top_of_stack] as the smallest (or minimum height) bar \'h\' area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) # Update max_area, if needed max_area = max(max_area, area) # Now, pop the remaining bars from stack and calculate area with each popped bar while stack: top_of_stack = stack.pop() area = (histogram[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"# Scenario You are tasked with building a simple version of a product recommendation system for an online store. The system should be able to suggest products based on a user\'s purchasing history. To achieve this, you will utilize the concept of collaborative filtering. # Task Implement a Recommendation System class that suggests products based on user similarities using the Jaccard similarity index. # Detailed Requirements 1. **Class**: `RecommendationSystem` 2. **Constructor**: `__init__(self, user_products: Dict[str, Set[str]])` - Input: A dictionary `user_products` where keys are user IDs (strings) and values are sets of product IDs (strings) representing the products purchased by each user. 3. **Method**: `recommend(self, user_id: str) -> List[str]` - Input: A string `user_id` representing the ID of the user for whom recommendations are to be made. - Output: A list of product IDs that are recommended for the given user. The products should be ranked in descending order of similarity scores and should exclude products already purchased by the user. - If the user ID is not present in the `user_products` dictionary, return an empty list. # Constraints 1. There can be up to `10^4` users. 2. Each user can have purchased between 1 and `10^3` products. 3. Each product ID and user ID are alphanumeric strings. 4. Aim to achieve efficient performance in terms of both time and space complexity. # Example Usage ```python # Example user products data user_products = { \\"user1\\": {\\"product1\\", \\"product2\\", \\"product3\\"}, \\"user2\\": {\\"product2\\", \\"product4\\", \\"product5\\"}, \\"user3\\": {\\"product1\\", \\"product3\\", \\"product6\\"} } recommendation_system = RecommendationSystem(user_products) # Recommendations for \\"user1\\" should exclude already purchased products and suggest based on similarities # Potential recommendations include products liked by most similar users, i.e., \\"user3\\" and \\"user2\\". # Expectation: Products like \\"product4\\", \\"product5\\", \\"product6\\" assert recommendation_system.recommend(\\"user1\\") == [\\"product6\\", \\"product4\\", \\"product5\\"] # Recommendations for a non-existing user should return an empty list assert recommendation_system.recommend(\\"user4\\") == [] ``` Provide the class implementation adhering to the above requirements and include sufficient unittests to validate the correctness of your implementation.","solution":"from typing import Dict, Set, List class RecommendationSystem: def __init__(self, user_products: Dict[str, Set[str]]): self.user_products = user_products def jaccard_similarity(self, set1: Set[str], set2: Set[str]) -> float: intersection = len(set1 & set2) union = len(set1 | set2) return intersection / union if union else 0 def recommend(self, user_id: str) -> List[str]: if user_id not in self.user_products: return [] target_products = self.user_products[user_id] similarity_scores = {} for other_user_id, products in self.user_products.items(): if other_user_id != user_id: similarity = self.jaccard_similarity(target_products, products) if similarity > 0: for product in products: if product not in target_products: if product not in similarity_scores: similarity_scores[product] = 0 similarity_scores[product] += similarity recommended_products = sorted(similarity_scores, key=lambda x: similarity_scores[x], reverse=True) return recommended_products"},{"question":"# Sum of Array Except Self You are required to implement a function that calculates the sum of an array except for each element in the original array. The function should return a new array where each element at index `i` of the new array is the sum of all the elements in the original array except the one at `i`. **Function Signature:** ```python def sum_except_self(nums: list[int]) -> list[int]: Given an array of integers, return a new array such that each element at index i of the new array is the sum of all the elements in the original array except the one at i. Args: - nums (list of int): A list of integers. Returns: - list of int: A list where each element is the sum of all the elements except itself. Example: result = sum_except_self([1,2,3,4]) pass ``` # Requirements 1. **sum_except_self** Method: Compute the resulting array such that each element is the sum of all elements in the given array except the current element at the index. # Constraints - The length of the input array `nums` will be between 1 and 10^5 inclusive. - The values of elements in the array `nums` will be in the range of -10^4 to 10^4 inclusive. - The solution should have a time complexity of O(n) where n is the length of the array. # Example ```python result = sum_except_self([1, 2, 3, 4]) assert result == [9, 8, 7, 6] result = sum_except_self([-1, 1, 0, -3, 3]) assert result == [1, -1, 0, 3, -3] ``` Implement the method ensuring an efficient solution and correctness of the output.","solution":"def sum_except_self(nums: list[int]) -> list[int]: Given an array of integers, return a new array such that each element at index i of the new array is the sum of all the elements in the original array except the one at i. Args: - nums (list of int): A list of integers. Returns: - list of int: A list where each element is the sum of all the elements except itself. total_sum = sum(nums) result = [total_sum - num for num in nums] return result"},{"question":"# Coding Assessment Question: **Scenario**: Dr. Y is trying to conduct a study on environmental data to help predict optimal planting times for crops in different regions. She wants to analyze the temperature fluctuations over a given period and needs to find the subarray with the maximum average temperature over this period for any given length of days. **Task**: Implement a function that finds the subarray of length `k` which has the maximum average temperature from a given list of temperatures. **Function Signature**: ```python def max_average_temperature_subarray( temps: List[float], k: int) -> float: Args: temps: A list of floats representing the temperature readings over a period. k: An integer representing the length of the subarray for which the average temperature is to be maximized. Returns: A float representing the maximum average temperature for any subarray of length k. pass ``` **Input**: 1. `temps`: A list of temperature readings (floats). 2. `k`: An integer representing the length of the subarray. **Output**: * A float representing the maximum average temperature for any subarray of length `k`. **Constraints**: * 1 ≤ `k` ≤ len(temps) * -1000.0 ≤ `temps[i]` ≤ 1000.0 * 1 ≤ len(temps) ≤ 10^5 **Example:** ``` temps = [1.0, 12.3, -5.6, 8.7, 13.2, 7.4, 6.1, 14.3] k = 3 ``` **Example Call:** ```python result = max_average_temperature_subarray([1.0, 12.3, -5.6, 8.7, 13.2, 7.4, 6.1, 14.3], 3) print(result) # Expected output: 9.766666666666667 ``` **Explanation**: For the given series of temperatures, the subarray `[8.7, 13.2, 7.4]` has the highest average temperature over any other subarray of length 3, with an average of 9.77 (rounded up for presentation). **Note**: Ensure your implementation handles the constraints efficiently. The solution should be optimized to avoid unnecessary computations, especially given the potential length of the temperature list.","solution":"from typing import List def max_average_temperature_subarray(temps: List[float], k: int) -> float: Returns the maximum average temperature for any subarray of length k. Args: temps: A list of floats representing the temperature readings over a period. k: An integer representing the length of the subarray for which the average temperature is to be maximized. Returns: A float representing the maximum average temperature for any subarray of length k. # Calculate the sum of the first subarray of length k current_sum = sum(temps[:k]) max_sum = current_sum # Use a sliding window to find the sum of all other subarrays of length k for i in range(k, len(temps)): current_sum += temps[i] - temps[i - k] if current_sum > max_sum: max_sum = current_sum # Return the maximum average return max_sum / k"},{"question":"# Permutation-Palindrome Check You are tasked with determining whether any permutation of a given string can form a palindrome. Write a function named `can_form_palindrome(s: str) -> bool`. Requirements: 1. The function should return `True` if any permutation of the given string can be rearranged to form a palindrome, otherwise return `False`. 2. A palindrome reads the same forward and backward. 3. Utilize efficient dictionary or set operations to check the character counts. Constraints: - `0 <= len(s) <= 10^6` Expected Input and Output: ```python >>> can_form_palindrome(\\"\\") True >>> can_form_palindrome(\\"a\\") True >>> can_form_palindrome(\\"ab\\") False >>> can_form_palindrome(\\"aab\\") True >>> can_form_palindrome(\\"carerac\\") True >>> can_form_palindrome(\\"code\\") False >>> can_form_palindrome(\\"aabbccdd\\") True >>> can_form_palindrome(\\"abcabcabc\\") False ```","solution":"def can_form_palindrome(s: str) -> bool: Returns True if any permutation of the given string can form a palindrome, otherwise returns False. # Dictionary to count the occurrences of each character. char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Checking the counts of characters to determine if a palindrome is possible. odd_count = 0 for count in char_count.values(): if count % 2 == 1: odd_count += 1 # More than one odd count means it can\'t form a palindrome. if odd_count > 1: return False return True"},{"question":"# Scenario A university is organizing a team-based project competition where students form teams to complete various projects. Each student has a list of preferred projects ranked by interest, while each project has a list of students ranked by their qualification for the project. The university wants to assign students to projects in a stable manner, ensuring no student-project pair would prefer each other over their current assignments. # Problem Given the details of students\' and projects\' preferences, implement the function `stable_assignment(student_pref: list[list[int]], project_pref: list[list[int]]) -> list[int]` to find a stable assignment where no two students and projects prefer each other over their current matched groups. Input * `student_pref`: A list of lists. Each sublist represents a student\'s ranked preferences over projects. * `project_pref`: A list of lists. Each sublist represents a project\'s ranked preferences over students. Output * A list of integers where the ith index represents the student, and the value is the corresponding project they are assigned to. Constraints * The lengths of `student_pref` and `project_pref` will be equal. * Each project’s and student’s preference list will contain unique integers within the valid range. # Example ```python def stable_assignment(student_pref: list[list[int]], project_pref: list[list[int]]) -> list[int]: # Function body here # Example data student_pref = [[0, 1, 2], [1, 0, 2], [0, 1, 2]] project_pref = [[1, 0, 2], [0, 2, 1], [0, 1, 2]] result = stable_assignment(student_pref, project_pref) print(result) # Should print a stable assignment list such as [1, 0, 2] ``` Performance Requirement * The solution must run in O(n^2) time complexity. # Note Ensure that the implemented function results in a stable assignment where no student and project pair exist that both prefer each other over their current assignments.","solution":"def stable_assignment(student_pref, project_pref): n = len(student_pref) # Create a list to keep track of the project to which each student is assigned (-1 = unassigned). student_assignment = [-1] * n # Create a list to keep track of the student to which each project is assigned (-1 = unassigned). project_assignment = [-1] * n # Track the number of free students. free_students = set(range(n)) # Track the proposals made by each student to each project. student_proposals = [0] * n # Create a ranking matrix for quick lookup of project preferences. project_rank = [[0] * n for _ in range(n)] for i, prefs in enumerate(project_pref): for rank, student in enumerate(prefs): project_rank[i][student] = rank while free_students: student = free_students.pop() preferred_project = student_pref[student][student_proposals[student]] student_proposals[student] += 1 if project_assignment[preferred_project] == -1: # If the project is unassigned, assign the project to the student. project_assignment[preferred_project] = student student_assignment[student] = preferred_project else: # If the project is already assigned, check if the project prefers the new student. current_student = project_assignment[preferred_project] if project_rank[preferred_project][student] < project_rank[preferred_project][current_student]: # The project prefers the new student, so reassign the project to the new student. project_assignment[preferred_project] = student student_assignment[student] = preferred_project # The previous student is now free. free_students.add(current_student) student_assignment[current_student] = -1 else: # The project prefers its current assignment, so the student remains free. free_students.add(student) return student_assignment"},{"question":"# Scenario You are working on a text processing tool that analyzes large documents to find frequently used phrases. You need a data structure to store and count occurrences of phrases efficiently. A Trie (prefix tree) is a suitable choice due to its ability to quickly insert and search strings. # Challenge Implement a custom Trie class to store phrases and count their occurrences. Implement the `Trie` class with methods to insert phrases, count their occurrences, and retrieve the most frequently used phrases in the document. # Task 1. Implement the `insert` method to add phrases to the Trie. 2. Implement the `count_occurrences` method to return the number of times a given phrase appears in the Trie. 3. Implement the `most_frequent_phrases` method to return a list of the top N most frequent phrases stored in the Trie. # Requirements - Implement the methods as specified. - Ensure efficient handling of phrase insertions and searches. - Handle edge cases such as phrases with common prefixes. - Optimize for both time and space complexity. # Input and Output - Input: A series of phrases to be inserted into the Trie. - Output: For each phrase insertion, maintain the count of that phrase. For retrieving the top N phrases, return a list of the most frequently occurring phrases. # Example Suppose you have the following sequence of operations: ```python trie = Trie() trie.insert(\\"hello world\\") print(trie.count_occurrences(\\"hello world\\")) # Output: 1 trie.insert(\\"hello world\\") print(trie.count_occurrences(\\"hello world\\")) # Output: 2 trie.insert(\\"hello\\") print(trie.most_frequent_phrases(2)) # Output: [\\"hello world\\", \\"hello\\"] trie.insert(\\"hello world\\") print(trie.most_frequent_phrases(1)) # Output: [\\"hello world\\"] ``` # Constraints - Phrases are strings consisting of words separated by spaces. - The number of phrases is up to 10^5. - The length of each phrase does not exceed 100 characters. - Ensure the Trie can handle uppercase and lowercase characters. Implement the `Trie` with the required methods and ensure it correctly manages phrase insertions, counts, and retrievals of top N phrases.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_phrase = False self.count = 0 class Trie: def __init__(self): self.root = TrieNode() self.phrase_count = {} def insert(self, phrase): node = self.root for char in phrase: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_phrase = True node.count += 1 if phrase in self.phrase_count: self.phrase_count[phrase] += 1 else: self.phrase_count[phrase] = 1 def count_occurrences(self, phrase): node = self.root for char in phrase: if char not in node.children: return 0 node = node.children[char] if node.is_end_of_phrase: return node.count return 0 def most_frequent_phrases(self, n): return sorted(self.phrase_count.keys(), key=lambda x: (-self.phrase_count[x], x))[:n]"},{"question":"# Coding Assessment Question Your task is to implement the following function: ```python def generate_ordered_power_set(input_set: set) -> list: Generate all possible subsets (the power set) of a given set. The subsets in the power set should be returned in a specific order: sort each subset in ascending order followed by sorting the entire list of subsets in increasing length. Args: input_set: A set of unique integers. Returns: list of lists: A list containing all subsets, each sorted in ascending order and the list itself sorted by the length of the subsets. # Your implementation here pass ``` # Detailed Specifications and Constraints: 1. **Inputs**: - `input_set` (set): A set of unique integers. 2. **Outputs**: - Returns a list containing all subsets of `input_set`. Each subset should be sorted in ascending order and the entire list should be sorted by the length of the subsets, each list stored as a list. 3. **Edge Cases**: - An empty set should return a list with one element: the empty list. - A set with one element should return two subsets: the empty set and the set containing the single element. 4. **Performance Requirements**: - The function should handle sets of varying sizes efficiently, but performance optimizations are secondary to correctness and clarity. # Testing: Use the following test cases to validate your implementation: ```python assert generate_ordered_power_set({1, 2, 3}) == [[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]] assert generate_ordered_power_set(set()) == [[]] assert generate_ordered_power_set({5}) == [[], [5]] assert generate_ordered_power_set({2, 1}) == [[], [1], [2], [1, 2]] assert generate_ordered_power_set({4, 3, 2, 1}) == [[], [1], [2], [3], [4], [1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]] ``` Feel free to add more test cases to thoroughly validate edge cases and ensure the accuracy of your implementation.","solution":"from itertools import combinations def generate_ordered_power_set(input_set: set) -> list: Generate all possible subsets (the power set) of a given set. The subsets in the power set should be returned in a specific order: sort each subset in ascending order followed by sorting the entire list of subsets in increasing length. Args: input_set: A set of unique integers. Returns: list of lists: A list containing all subsets, each sorted in ascending order and the list itself sorted by the length of the subsets. input_list = sorted(input_set) # Sort the input set power_set = [] # Generate all subsets for all possible lengths for subset_length in range(len(input_list) + 1): for subset in combinations(input_list, subset_length): power_set.append(list(subset)) return power_set"},{"question":"# Question: Surrounded Regions Context: You are given a 2D board containing `\'X\'` and `\'O\'`. The board captures the regions surrounded by `\'X\'`. A region is captured if the cells in the region are completely surrounded by `\'X\'`. All the cells on the border of the board can never be captured. Task: Implement a function `capture_regions(board: list[list[str]]) -> None` that: 1. Takes the 2D board as input. 2. Modifies the board in-place by capturing all the surrounded regions. A region surrounded by `\'X\'` should be replaced by `\'X\'`. For example, converting region of `\'O\'` cells that are completely surrounded by `\'X\'` cells to `\'X\'`. Input: 1. A 2D list `board` where each element is a character `\'X\'` or `\'O\'`. Output: Modify the input board in-place to capture surrounded regions. Constraints: - The board size will not exceed `200 x 200`. Example: ```python def capture_regions(board: list[list[str]]) -> None: # Your implementation # Example usage: # board = [ # [\'X\', \'X\', \'X\', \'X\'], # [\'X\', \'O\', \'O\', \'X\'], # [\'X\', \'X\', \'O\', \'X\'], # [\'X\', \'O\', \'X\', \'X\'] # ] # capture_regions(board) # assert board == [ # [\'X\', \'X\', \'X\', \'X\'], # [\'X\', \'X\', \'X\', \'X\'], # [\'X\', \'X\', \'X\', \'X\'], # [\'X\', \'O\', \'X\', \'X\'] # ] ``` Performance Requirement: Ensure that your solution can handle the maximum board size efficiently.","solution":"def capture_regions(board: list[list[str]]) -> None: Capture all surrounded regions in the board. if not board: return rows, cols = len(board), len(board[0]) def dfs(i, j): if i < 0 or j < 0 or i >= rows or j >= cols or board[i][j] != \'O\': return board[i][j] = \'E\' # Mark as escaped (not surrounded) # Perform DFS in all four directions dfs(i - 1, j) dfs(i + 1, j) dfs(i, j - 1) dfs(i, j + 1) # Start from the borders and mark the escapable \'O\'s for i in range(rows): if board[i][0] == \'O\': dfs(i, 0) if board[i][cols - 1] == \'O\': dfs(i, cols - 1) for j in range(cols): if board[0][j] == \'O\': dfs(0, j) if board[rows - 1][j] == \'O\': dfs(rows - 1, j) # Convert all \'O\'s to \'X\'s and all \'E\'s back to \'O\' for i in range(rows): for j in range(cols): if board[i][j] == \'O\': board[i][j] = \'X\' elif board[i][j] == \'E\': board[i][j] = \'O\'"},{"question":"# Problem Statement You are required to implement a function that determines the minimum number of coin flips required to make all coins in a row show the same face, either all heads (\'H\') or all tails (\'T\'). Each coin can be either \'H\' or \'T\'. # Function Signature ```python def min_flips(coins: str) -> int: pass ``` # Input - `coins`: A non-empty string consisting of characters \'H\' or \'T\', representing the initial state of the coins. # Output - An integer representing the minimum number of flips required to make all the coins show the same face. # Constraints - The length of `coins` will be between 1 and 10^5. # Examples 1. `min_flips(\\"HTHHHTT\\")` returns `3` 2. `min_flips(\\"HHTTHTH\\")` returns `4` 3. `min_flips(\\"HHHH\\")` returns `0` 4. `min_flips(\\"T\\")` returns `0` 5. `min_flips(\\"HTTTHTT\\")` returns `3` # Context This problem assesses your ability to perform basic string operations and make optimal decisions based on simple counting, which is fundamental in competitive programming and algorithm design. # Detailed Instructions 1. Count the number of \'H\' and \'T\' in the input string `coins`. 2. Determine the fewer number of characters to flip in order to make all coins the same (either all \'H\' or all \'T\'). 3. Return the minimum count between the two. ```python def min_flips(coins: str) -> int: count_H = coins.count(\'H\') count_T = len(coins) - count_H return min(count_H, count_T) ```","solution":"def min_flips(coins: str) -> int: Returns the minimum number of flips required to make all coins show the same face. Parameters: coins (str): A string consisting of characters \'H\' or \'T\', representing the initial state of the coins. Returns: int: The minimum number of flips required to make all the coins show the same face. count_H = coins.count(\'H\') count_T = len(coins) - count_H return min(count_H, count_T)"},{"question":"# Coding Assessment Question Scenario You are working on preparing a course curriculum plan for a new software engineering program. The program consists of multiple courses, each with specific prerequisites. To help students follow the correct sequence of courses, you need to determine the order in which they should take the courses given the prerequisites. Problem Statement Implement a function `calculate_course_order(num_courses: int, prerequisites: list[tuple[int, int]]) -> list[int] | None` that determines a valid order for a student to take courses based on given prerequisites. If it\'s not possible to complete all courses due to cyclic prerequisites, return `None`. # Input: * An integer `num_courses`, representing the number of courses (labeled from `0` to `num_courses - 1`). * A list of tuples `prerequisites`, where each tuple is of the form `(a, b)`, indicating that course `a` must be taken before course `b`. # Output: * A list of integers representing the order in which courses can be taken. * `None` if it is not possible to complete all courses due to cycle(s) in prerequisites. # Constraints: * (1 leq text{num_courses} leq 10^4) * (0 leq text{len(prerequisites)} leq 5 times 10^4) # Example: ```python num_courses_1 = 4 prerequisites_1 = [(1, 0), (2, 0), (3, 1), (3, 2)] assert calculate_course_order(num_courses_1, prerequisites_1) in [[0, 1, 2, 3], [0, 2, 1, 3]] num_courses_2 = 2 prerequisites_2 = [(1, 0), (0, 1)] assert calculate_course_order(num_courses_2, prerequisites_2) is None ``` Function Signature ```python def calculate_course_order(num_courses: int, prerequisites: list[tuple[int, int]]) -> list[int] | None: pass ``` # Notes: * The solution should efficiently handle the graph traversal and manage edge cases, including cycles. * Use a graph-based algorithm, such as Kahn\'s Algorithm or Depth-First Search (DFS), to implement the topological sorting and detect cycles.","solution":"from collections import deque, defaultdict def calculate_course_order(num_courses: int, prerequisites: list[tuple[int, int]]) -> list[int] | None: # Create an adjacency list and a list to count in-degrees adj_list = defaultdict(list) in_degree = [0] * num_courses # Populate the adjacency list and in-degree list from prerequisites for dest, src in prerequisites: adj_list[src].append(dest) in_degree[dest] += 1 # Initialize queue with courses that have no prerequisites queue = deque([course for course in range(num_courses) if in_degree[course] == 0]) course_order = [] while queue: course = queue.popleft() course_order.append(course) for neighbor in adj_list[course]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If the course order contains all courses, return it, otherwise return None return course_order if len(course_order) == num_courses else None"},{"question":"# Problem Statement Write a function `sum_of_top_k_largest_elements(arr: List[int], k: int) -> int` to return the sum of the `k` largest unique elements in a given array of integers `arr`. # Inputs - `arr`: A list of integers where (|arr| leq 10^5) and each integer is in the range (-10^6) to (10^6). - `k`: An integer ((1 leq k leq 100)). # Outputs - Returns the sum of the `k` largest unique elements. - If there are fewer than `k` unique elements, return the sum of all unique elements. # Constraints & Performance - Time Complexity: You should aim for a solution with (O(n log n)) time complexity. - Space Complexity: Your solution should use extra space linearly proportional to the input size, (O(n)). # Scenario for Context You are tasked with analyzing a list of numeric values. Your goal is to find and sum up the `k` largest unique numbers within that list. This is particularly useful in scenarios where prioritizing top results and avoiding duplicates is critical. # Sample Tests **Input**: ```python assert sum_of_top_k_largest_elements([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5], 3) == 20 assert sum_of_top_k_largest_elements([1, 2, 2, 3, 3], 2) == 5 assert sum_of_top_k_largest_elements([5, 5, 5, 5], 1) == 5 assert sum_of_top_k_largest_elements([10, 20, 30], 5) == 60 assert sum_of_top_k_largest_elements([], 3) == 0 ``` **Explanation**: - In the first test, the top 3 unique numbers are 9, 6, and 5. Their sum is 20. - In the second test, the top 2 unique numbers are 3 and 2. Their sum is 5. - In the third test, the only unique number is 5. - In the fourth test, there are only 3 unique numbers, so their sum is 60. - In the last test, the array is empty, so the sum is 0.","solution":"from typing import List def sum_of_top_k_largest_elements(arr: List[int], k: int) -> int: Returns the sum of the k largest unique elements in arr. If there are fewer than k unique elements, return the sum of all unique elements. if not arr: return 0 unique_elements = list(set(arr)) unique_elements.sort(reverse=True) return sum(unique_elements[:k])"},{"question":"Question: Maze Solver In this problem, you are required to solve a maze represented as a 2D grid. The objective is to determine if there\'s a path from the start point to the end point. You need to write a function `maze_solver` that accepts the maze grid as an input and returns `True` if there is a path from the start to the end, or `False` otherwise. # Details: 1. **Maze Representation**: - The maze is represented as a 2D list of characters. - Each character in the grid can be one of the following: - `\'S\'`: The start point of the maze. - `\'E\'`: The end point of the maze. - `\'.\'`: An open path that can be traversed. - `\'#\'`: A wall that cannot be traversed. - There is exactly one start point and one end point in the maze. 2. **Movement Rules**: - You can move up, down, left, or right from a cell to an adjacent cell. # Function Definition: ```python def maze_solver(maze: List[List[str]]) -> bool: ``` # Parameters: - `maze`: A list of lists of characters representing the maze. # Returns: - `bool`: Returns `True` if there is a path from the start point `\'S\'` to the end point `\'E\'`, otherwise returns `False`. # Constraints: - The size of the maze is at least 2x2 and can be up to 100x100. - There is exactly one `\'S\'` and one `\'E\'` in the maze. # Example: ```python maze = [ [\'S\', \'.\', \'#\', \'.\'], [\'#\', \'.\', \'#\', \'.\'], [\'#\', \'.\', \'.\', \'.\'], [\'#\', \'#\', \'.\', \'E\'] ] assert maze_solver(maze) == True maze = [ [\'S\', \'#\', \'#\'], [\'#\', \'.\', \'#\'], [\'#\', \'#\', \'E\'] ] assert maze_solver(maze) == False ``` # Task: Implement the `maze_solver` function as described. Ensure your solution passes the above example check scenarios. Use a suitable pathfinding algorithm to determine if a path exists from the start to the end.","solution":"from typing import List def maze_solver(maze: List[List[str]]) -> bool: def find_start_end(maze): start = end = None for i, row in enumerate(maze): for j, cell in enumerate(row): if cell == \'S\': start = (i, j) elif cell == \'E\': end = (i, j) return start, end def is_valid_move(maze, x, y, visited): rows, cols = len(maze), len(maze[0]) return 0 <= x < rows and 0 <= y < cols and maze[x][y] != \'#\' and not visited[x][y] def dfs(maze, x, y, end, visited): if (x, y) == end: return True visited[x][y] = True directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(maze, nx, ny, visited) and dfs(maze, nx, ny, end, visited): return True return False start, end = find_start_end(maze) if not start or not end: return False rows, cols = len(maze), len(maze[0]) visited = [[False] * cols for _ in range(rows)] return dfs(maze, start[0], start[1], end, visited)"},{"question":"# Question Title: Vehicle Path Prediction Based on GPS Coordinates # Question Description In this task, you are required to write a program that predicts the future trajectory of a vehicle based on its past GPS coordinates. You will receive sequences of GPS points with timestamps and will need to extrapolate future positions using linear regression. # Function Signature ```python def predict_future_path( past_points: list[tuple[float, float, int]], future_timesteps: list[int] ) -> list[tuple[float, float]]: pass ``` # Inputs - `past_points` (List of Tuple[float, float, int]): List containing tuples of past GPS coordinates (latitude, longitude, timestamp). The timestamp is an integer representing the time in seconds. - `future_timesteps` (List[int]): List of future timestamps (integers) at which the positions need to be predicted. # Output - Returns a list of tuples, each containing the predicted (latitude, longitude) positions of the vehicle at the given `future_timesteps`. # Instructions 1. **Data Preprocessing and Checking**: - Verify that at least two past GPS points are provided to perform linear regression. - Ensure timestamps are in ascending order. 2. **Trajectory Prediction**: - Utilize linear regression to estimate the trajectory based on the past GPS points. - Apply the linear regression model to predict the vehicle\'s position at each timestamp in `future_timesteps`. # Constraints 1. The past points are always provided in ascending order based on the timestamp. 2. There will be at least two past points to perform linear regression. 3. Timestamps will be positive integers. 4. Coordinates are given as floating-point numbers in decimal degrees. # Example Cases Example 1 ```python past_points = [ (37.7749, -122.4194, 1609459200), # (lat, lon, timestamp) (37.7750, -122.4195, 1609459260), # 60 seconds later ] future_timesteps = [1609459320, 1609459380] # 60, 120 seconds after the last past point predicted_path = predict_future_path(past_points, future_timesteps) ``` Example 2 ```python past_points = [ (34.0522, -118.2437, 1609455600), # (lat, lon, timestamp) (34.0523, -118.2438, 1609455660), # 60 seconds later (34.0524, -118.2439, 1609455720), # 60 seconds later ] future_timesteps = [1609455780, 1609455840] # 60, 120 seconds after the last past point predicted_path = predict_future_path(past_points, future_timesteps) ``` Notes - Ensure the predicted coordinates reflect plausible movements based on linear regression analysis. - Consider edge cases where past points depict minimal or erratic movement.","solution":"import numpy as np def linear_regression_fit(timestamps, coordinates): slope, intercept = np.polyfit(timestamps, coordinates, 1) return slope, intercept def predict_future_path(past_points, future_timesteps): if len(past_points) < 2: raise ValueError(\\"At least two past points are required for linear regression.\\") # Extract latitudes, longitudes, and timestamps from past_points latitudes = [point[0] for point in past_points] longitudes = [point[1] for point in past_points] timestamps = [point[2] for point in past_points] # Perform linear regression to get slope and intercept for latitude and longitude slope_lat, intercept_lat = linear_regression_fit(timestamps, latitudes) slope_lon, intercept_lon = linear_regression_fit(timestamps, longitudes) # Predict future coordinates using the slope and intercept future_positions = [] for t in future_timesteps: lat_pred = slope_lat * t + intercept_lat lon_pred = slope_lon * t + intercept_lon future_positions.append((lat_pred, lon_pred)) return future_positions"},{"question":"# Coding Assessment Question You need to create a function to manage the inventory of a bookstore. The function will allow adding new books, selling books, and checking the stock of a particular book. Each book is defined by its ISBN number, title, author, and the number of copies available. Task Implement a class `Bookstore` which has methods to add a new book, sell a book, and check the stock for a particular book. Class Signature ```python class Bookstore: def __init__(self): pass def add_book(self, isbn: str, title: str, author: str, quantity: int) -> None: pass def sell_book(self, isbn: str, quantity: int) -> None: pass def check_stock(self, isbn: str) -> int: pass ``` Methods Details - `__init__(self)`: Initializes the bookstore inventory as an empty dictionary. - `add_book(self, isbn: str, title: str, author: str, quantity: int) -> None`: - Adds a new book to the inventory with the given ISBN, title, author, and quantity. - If the book with the given ISBN already exists, increase its quantity by the given amount. - Raise a `ValueError` if `quantity` is not positive. - `sell_book(self, isbn: str, quantity: int) -> None`: - Reduces the quantity of the given book by the specified amount. - Raise a `KeyError` if the ISBN does not exist in the inventory. - Raise a `ValueError` if the quantity is not positive or if the available stock is insufficient. - `check_stock(self, isbn: str) -> int`: - Returns the current stock quantity of the book with the given ISBN. - Raise a `KeyError` if the ISBN does not exist in the inventory. Example ```python store = Bookstore() store.add_book(\\"1234567890\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5) store.add_book(\\"0987654321\\", \\"1984\\", \\"George Orwell\\", 3) print(store.check_stock(\\"1234567890\\")) # Output: 5 store.sell_book(\\"1234567890\\", 2) print(store.check_stock(\\"1234567890\\")) # Output: 3 store.add_book(\\"1234567890\\", \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 2) print(store.check_stock(\\"1234567890\\")) # Output: 5 try: store.sell_book(\\"1234567890\\", 10) except ValueError as e: print(e) # Output: Not enough stock available. try: store.check_stock(\\"1111111111\\") except KeyError as e: print(e) # Output: Book not found in inventory. ``` Notes: - Ensure that your implementation handles all error cases appropriately. - Use Python\'s exception handling features to tackle invalid operations. - Consider the edge cases where book quantities might reach zero or negative values, ensuring proper error management.","solution":"class Bookstore: def __init__(self): self.inventory = {} def add_book(self, isbn: str, title: str, author: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") if isbn in self.inventory: self.inventory[isbn][\'quantity\'] += quantity else: self.inventory[isbn] = { \'title\': title, \'author\': author, \'quantity\': quantity } def sell_book(self, isbn: str, quantity: int) -> None: if quantity <= 0: raise ValueError(\\"Quantity must be positive.\\") if isbn not in self.inventory: raise KeyError(f\\"Book with ISBN {isbn} not found.\\") if self.inventory[isbn][\'quantity\'] < quantity: raise ValueError(\\"Not enough stock available.\\") self.inventory[isbn][\'quantity\'] -= quantity def check_stock(self, isbn: str) -> int: if isbn not in self.inventory: raise KeyError(f\\"Book with ISBN {isbn} not found.\\") return self.inventory[isbn][\'quantity\']"},{"question":"# Analyzing Sales Data for Seasonal Trends In this task, your objective is to process a dataset of sales records and detect seasonal trends. This involves grouping sales data by month and computing relevant statistics such as the average sales for each product per month. Problem Description You are given a list of sales records. Each record is a tuple consisting of a timestamp (in the format \'YYYY-MM-DD\'), a product ID, and the sales amount. Your goal is to aggregate the sales data by month and by product, then compute the average sales amount for each product per month. Input * `sales_records`: a list of tuples where each tuple consists of: * a string representing the date in the format \'YYYY-MM-DD\', * an integer representing the product ID, * a float representing the sales amount. Output * A dictionary where the keys are tuples representing the month and year (in the format (YYYY, MM)), and each value is another dictionary. The inner dictionary\'s keys are product IDs, and the values are the average sales amounts for that product during that month. Constraints * `1 ≤ len(sales_records) ≤ 10^5` * The sales amount is a non-negative float. Example ```python sales_records = [ (\'2022-01-15\', 101, 150.0), (\'2022-01-20\', 102, 200.0), (\'2022-02-15\', 101, 300.0), (\'2022-02-15\', 102, 400.0), (\'2022-01-25\', 101, 250.0), (\'2022-02-25\', 101, 100.0) ] result = analyze_sales_trends(sales_records) print(result) ``` Expected Output: ``` { (2022, 1): { 101: 200.0, 102: 200.0 }, (2022, 2): { 101: 200.0, 102: 400.0 } } ``` Function Signature ```python def analyze_sales_trends(sales_records: list[tuple[str, int, float]]) -> dict[tuple[int, int], dict[int, float]]: pass ``` Notes * Ensure to parse the date and extract the year and month correctly. * You may assume that the input sales records are correctly formatted. * Handle any edge cases, such as when there are no sales for a particular month or product.","solution":"from collections import defaultdict from statistics import mean def analyze_sales_trends(sales_records): Analyzes sales data to find average sales per product per month. Parameters: sales_records (list): A list of tuples where each tuple consists of a date (str), a product ID (int), and a sales amount (float). Returns: dict: A dictionary where the keys are tuples representing the month and year (in the format (YYYY, MM)). Each value is another dictionary that maps product IDs to their average sales amount for that month. sales_data = defaultdict(lambda: defaultdict(list)) for record in sales_records: date, product_id, sales_amount = record year, month, _ = map(int, date.split(\'-\')) sales_data[(year, month)][product_id].append(sales_amount) # Calculate the average sales for each product per month result = {} for ym, products in sales_data.items(): result[ym] = {pid: mean(amounts) for pid, amounts in products.items()} return result"},{"question":"# String Compression Challenge You are asked to implement a function `compress_string` that compresses a given string by replacing sequences of the same character with that character followed by the number of times it appears consecutively. If the compressed string is not shorter than the original string, the function should return the original string. You are to ensure that the function performs efficiently. # Function Signature: ```python def compress_string(s: str) -> str: pass ``` # Input: - A string `s` containing only upper and lowercase letters (a-z, A-Z). # Output: - A compressed string, or the original string if the compressed version is not shorter. # Example: ```python print(compress_string(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compress_string(\\"abc\\")) # Output: \\"abc\\" ``` # Constraints: - The input string will only contain alphabetical characters (a-z, A-Z). - The function should handle strings efficiently with a reasonable time complexity. # Testing: 1. Test with strings of varying lengths, including very short (1-2 characters) and very large strings. 2. Test with strings that do not compress well (e.g., \\"abc\\", \\"abcd\\"). 3. Test with strings that compress significantly (e.g., \\"aabcccccaaa\\", \\"aabbccdd\\"). 4. Ensure edge cases such as empty strings and strings with single characters are handled properly.","solution":"def compress_string(s: str) -> str: Compresses a given string by replacing sequences of the same character with that character followed by the number of times it appears consecutively. If the compressed string is not shorter than the original string, returns the original string. if not s: return s compressed_parts = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: compressed_parts.append(current_char + str(count)) current_char = char count = 1 compressed_parts.append(current_char + str(count)) compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Coding Assessment Question: Restricted Factorial Calculation Background Factorial calculation is a basic yet important concept in mathematics. The factorial of a non-negative integer `n` is the product of all positive integers less than or equal to `n`. It is denoted by `n!`. However, for very large values of `n`, the factorial value can grow extremely large, which may cause computational overhead or memory issues. Task Implement a function to calculate the factorial of a non-negative integer `n` considering a given upper limit. If at any point during the calculation, the intermediate factorial result exceeds the upper limit, the function should return the upper limit instead. Input * An integer `n` (0 ≤ n ≤ 20). * An integer `limit` (1 ≤ limit ≤ 1,000,000). Output * An integer representing the factorial of `n` if it does not exceed the `limit`, otherwise the `limit`. Constraints * `n` is guaranteed to be within the provided range. * The upper limit is a positive integer where 1 ≤ limit ≤ 1,000,000. Performance Requirements The implementation should handle edge cases and unnecessary calculations should be avoided if the factorial exceeds the given limit early. Example ```python def restricted_factorial(n, limit): # Your implementation here # Test case n = 5 limit = 120 print(restricted_factorial(n, limit)) # Expected Output: 120 n = 5 limit = 100 print(restricted_factorial(n, limit)) # Expected Output: 100 ``` This question tests the ability to work with loops, conditional statements, and handling edge cases. The maximum input size ensures factorial calculations remain manageable in terms of computational resources.","solution":"def restricted_factorial(n, limit): Calculates the factorial of `n` considering an upper limit. If at any point the intermediate factorial result exceeds the `limit`, the function returns the `limit` instead. Parameters: n (int): a non-negative integer (0 ≤ n ≤ 20) limit (int): an integer (1 ≤ limit ≤ 1,000,000) Returns: int: the factorial of `n` if it does not exceed the `limit`, otherwise the `limit` result = 1 for i in range(1, n + 1): result *= i if result > limit: return limit return result"},{"question":"# Problem Statement You are building a library management system and need to handle customer book checkouts. Each customer has a membership level, and they can only borrow books with a total maximum value based on their level. If a customer tries to borrow books exceeding their allowance, you need to reject the transaction. # Task Write a function `check_borrow` that verifies whether a customer can borrow a given set of books without exceeding their membership allowance. # Function Signature ```python def check_borrow(membership_level: str, books: List[int]) -> bool: ``` # Inputs - `membership_level` (str): The membership level of the customer. Possible values are \\"Basic\\", \\"Premium\\", \\"Elite\\". - `books` (List[int]): List of integers where each integer represents the value of a book the customer wants to borrow. # Output - Returns `True` if the total value of the books does not exceed the customer\'s allowance based on their membership level, otherwise returns `False`. # Membership Allowances - \\"Basic\\": Maximum allowed value is 100. - \\"Premium\\": Maximum allowed value is 200. - \\"Elite\\": Maximum allowed value is 500. # Constraints - The length of the `books` list will be between 1 and 100. - The value of each book will be between 1 and 100. # Example ```python assert check_borrow(\\"Basic\\", [20, 30, 50]) == True assert check_borrow(\\"Basic\\", [50, 60, 10]) == False assert check_borrow(\\"Premium\\", [100, 50, 50]) == True assert check_borrow(\\"Premium\\", [150, 60]) == False assert check_borrow(\\"Elite\\", [250, 200, 50]) == True assert check_borrow(\\"Elite\\", [300, 250]) == False ``` # Explanation - **Basic Membership**: A customer can borrow books whose total value does not exceed 100. - **Premium Membership**: A customer can borrow books whose total value does not exceed 200. - **Elite Membership**: A customer can borrow books whose total value does not exceed 500. # Notes - Carefully evaluate the sum of the book values and compare it against the membership limits. - Ensure efficient computation given the constraints.","solution":"from typing import List def check_borrow(membership_level: str, books: List[int]) -> bool: Verifies whether a customer can borrow a given set of books without exceeding their membership allowance. Parameters: membership_level (str): The membership level of the customer (\\"Basic\\", \\"Premium\\", \\"Elite\\"). books (List[int]): List of integers representing the value of books the customer wants to borrow. Returns: bool: True if the total value of the books does not exceed the customer\'s allowance, otherwise False. membership_limits = { \\"Basic\\": 100, \\"Premium\\": 200, \\"Elite\\": 500 } total_value = sum(books) return total_value <= membership_limits.get(membership_level, 0)"},{"question":"# Problem Statement You are required to write a function `compute_statistics` that processes numerical data and computes a set of statistical values. The function should take a list of integers and return a dictionary with the following statistics: 1. Mean (average) of the data. 2. Median value of the data. 3. Mode(s) of the data (the value(s) that appear most frequently, if there are multiple, return all in a sorted list). 4. Range (difference between the maximum and minimum values). 5. Standard deviation of the data. # Function Signature ```python def compute_statistics(data: list[int]) -> dict: Compute various statistical values from a list of integers. Parameters: - data (list[int]): A list of integers. Returns: - dict: Dictionary containing the computed statistics. ``` # Input/Output Examples Input ```python compute_statistics([1, 2, 2, 3, 4, 5, 5, 5, 6]) ``` Output ```python { \\"mean\\": 3.67, \\"median\\": 4, \\"mode\\": [5], \\"range\\": 5, \\"standard_deviation\\": 1.67 } ``` # Constraints and Requirements 1. The input list `data` must contain at least one integer. 2. The function should handle negative and positive integers. 3. If the list contains a single integer, the mean, median, mode, and standard deviation are that integer itself, and the range is 0. 4. The mean and standard deviation should be rounded to two decimal places. 5. Use efficient algorithms to compute each statistical value, minimizing computational complexity. # Performance Requirements 1. Ensure the function can handle large datasets efficiently (up to 10^6 integers). 2. Avoid unnecessary computations and ensure the implementation adheres to good coding practices. # Context This function is useful for data analysis in various fields such as finance, research, and machine learning. It provides a set of fundamental statistical metrics that are commonly required for analyzing the distribution and spread of numerical data.","solution":"import math from collections import Counter def compute_statistics(data): Compute various statistical values from a list of integers. Parameters: - data (list[int]): A list of integers. Returns: - dict: Dictionary containing the computed statistics. if not data: return {} n = len(data) # Mean mean = round(sum(data) / n, 2) # Median sorted_data = sorted(data) mid = n // 2 if n % 2 == 0: median = (sorted_data[mid - 1] + sorted_data[mid]) / 2 else: median = sorted_data[mid] # Mode counter = Counter(data) max_freq = max(counter.values()) mode = sorted([k for k, v in counter.items() if v == max_freq]) # Range data_range = max(data) - min(data) # Standard Deviation variance = sum((x - mean) ** 2 for x in data) / n standard_deviation = round(math.sqrt(variance), 2) return { \\"mean\\": mean, \\"median\\": median, \\"mode\\": mode, \\"range\\": data_range, \\"standard_deviation\\": standard_deviation }"},{"question":"# Binary Tree Path Sum You are asked to implement a feature in a binary tree data structure that calculates the sum of all root-to-leaf paths. A path is defined as a sequence of nodes starting from the root node and ending at any leaf node. Your task is to find the sum of all such numbers formed by the paths. Your Task Enhance the `BinaryTree` class by implementing a method to calculate the sum of all the numbers formed by root-to-leaf paths. Each number is formed by concatenating the node values along the path. # Specifications * **Function to Implement**: `sum_of_paths(self) -> int` * **Input**: None (method within the `BinaryTree` class). * **Output**: Integer representing the sum of all root-to-leaf path numbers. * **Constraints**: - Assume the tree nodes contain only single-digit integers (0 through 9). - The method should run in O(N) time complexity, where N is the number of nodes in the tree. - There may be edge cases like an empty tree or a single-node tree. # Example ```python # Binary Tree: # 1 # / # 2 3 # Paths: 12, 13 # Sum: 12 + 13 = 25 bt = BinaryTree([1, 2, 3]) print(bt.sum_of_paths()) # Output: 25 # Binary Tree: # 4 # / # 9 0 # / # 5 1 # Paths: 495, 491, 40 # Sum: 495 + 491 + 40 = 1026 bt = BinaryTree([4, 9, 0, 5, 1]) print(bt.sum_of_paths()) # Output: 1026 ``` # Implementation Details - Perform a depth-first traversal to navigate each root-to-leaf path. - At each node, concatenate the current value to the path number formed so far. - When a leaf node is reached, add the formed number to the total sum. # Edge Case Considerations - An empty binary tree should return `0`. - A binary tree with only one node should return the value of that single node.","solution":"class TreeNode: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right class BinaryTree: def __init__(self, values): if not values: self.root = None else: self.root = self._create_tree(values, 0) def _create_tree(self, values, index): if index < len(values) and values[index] is not None: node = TreeNode(values[index]) node.left = self._create_tree(values, 2 * index + 1) node.right = self._create_tree(values, 2 * index + 2) return node return None def sum_of_paths(self): def dfs(node, current_sum): if node is None: return 0 current_sum = current_sum * 10 + node.value if node.left is None and node.right is None: return current_sum return dfs(node.left, current_sum) + dfs(node.right, current_sum) return dfs(self.root, 0)"},{"question":"# Coding Assessment Question Scenario You are working on a project that involves data processing for a series of numerical records. Your task is to transform a list of integers based on their properties. Specifically, you need to create a function that replaces all even numbers in the list with the string \\"EVEN\\" and all odd numbers with the string \\"ODD\\". This function should maintain the order of the elements and be efficient for large input sizes. Task Write a function `transform_numbers` that takes a list of integers as input and returns a new list where each even number is replaced with the string \\"EVEN\\" and each odd number is replaced with the string \\"ODD\\". Input * A single list of integers `nums` (1 ≤ |nums| ≤ 10^6) where |nums| represents the number of elements in the list. Output * A single list where each even number in `nums` has been replaced with \\"EVEN\\" and each odd number has been replaced with \\"ODD\\". Constraints * The function must handle lists up to 1,000,000 elements efficiently. * Elements in the input list can be positive or negative integers. Example ```python assert transform_numbers([1, 2, 3, 4, 5]) == [\\"ODD\\", \\"EVEN\\", \\"ODD\\", \\"EVEN\\", \\"ODD\\"] assert transform_numbers([-1, -2, 0, 7, 8]) == [\\"ODD\\", \\"EVEN\\", \\"EVEN\\", \\"ODD\\", \\"EVEN\\"] assert transform_numbers([10, 21, 32, 43]) == [\\"EVEN\\", \\"ODD\\", \\"EVEN\\", \\"ODD\\"] assert transform_numbers([]) == [] ```","solution":"def transform_numbers(nums): Replaces even numbers with \\"EVEN\\" and odd numbers with \\"ODD\\" in the given list of integers. Parameters: nums (list): A list of integers. Returns: list: A new list where even numbers are replaced with \\"EVEN\\" and odd numbers with \\"ODD\\". return [\\"EVEN\\" if num % 2 == 0 else \\"ODD\\" for num in nums]"},{"question":"# Image Pixel Flipping You are given a 2D binary matrix representing an image, where `0` represents a black pixel and `1` represents a white pixel. Your task is to write a function that flips the image horizontally (reverse each row) and then inverts it (replace all `0`s with `1`s and all `1`s with `0`s). Function Signature ```python def flip_and_invert_image(matrix: list[list[int]]) -> list[list[int]]: ``` Input Parameters * `matrix` (list[list[int]]): A 2D binary matrix representing an image. Output * A 2D binary matrix after flipping it horizontally and then inverting its colors. Constraints * The number of rows (m) and the number of columns (n) do not exceed 100. * Each element in the matrix is either 0 or 1. Example ```python >>> flip_and_invert_image([[1,1,0],[1,0,1],[0,0,0]]) [[1,0,0],[0,1,0],[1,1,1]] >>> flip_and_invert_image([[1,0,0],[1,1,1],[0,1,1]]) [[1,1,0],[0,0,0],[0,0,1]] >>> flip_and_invert_image([[1,0,1],[0,0,1],[1,1,0]]) [[0,1,0],[0,1,1],[1,0,0]] ``` Notes * The solution should be efficient in terms of time complexity. * Consider edge cases such as an empty matrix or the smallest possible matrix. * Ensure that the function works correctly for both odd and even dimensions of the input matrix.","solution":"def flip_and_invert_image(matrix: list[list[int]]) -> list[list[int]]: Flips the given binary matrix horizontally and inverts it. Args: matrix (list[list[int]]): A 2D binary matrix representing an image. Returns: list[list[int]]: The flipped and inverted 2D binary matrix. for row in matrix: # Flip horizontally (reverse each row) and invert (change 0 to 1 and 1 to 0) for i in range(len(row) // 2): # Swap the left and right elements row[i], row[~i] = row[~i], row[i] # Invert the entire row for j in range(len(row)): row[j] = 1 - row[j] return matrix"},{"question":"# Problem Statement You are given a string containing characters `a-z` and `*`. Your task is to generate all possible strings by replacing each `*` in the original string with either \'0\' or \'1\'. The output should be a list of all such possible strings, sorted in lexicographical order. # Function Signature ```python def generate_all_strings(s: str) -> list[str]: ``` # Input * `s` (string): A string containing characters `a-z` and `*`. The length of `s` will be in the range `[1, 15]`. # Output * Returns a list of all possible strings formed by replacing each `*` in `s` with \'0\' or \'1\', sorted in lexicographical order. # Constraints * The length of the string `s` will be in the range `[1, 15]` and `s` can contain any lowercase letters and `*`. # Example ```python s = \\"a*c\\" output = generate_all_strings(s) print(output) ``` Expected Output: ``` [\'a0c\', \'a1c\'] ``` # Example ```python s = \\"a*b*c\\" output = generate_all_strings(s) print(output) ``` Expected Output: ``` [\'a0b0c\', \'a0b1c\', \'a1b0c\', \'a1b1c\'] ``` # Additional Information: * You may assume the input string is valid and contains at least one `*` if `*` is mentioned in the problem statement. * The function should handle all combinations efficiently, even if there are multiple occurrences of `*`.","solution":"def generate_all_strings(s: str) -> list[str]: Generate all possible strings by replacing each `*` in the original string `s` with either \'0\' or \'1\', sorted in lexicographical order. :param s: Input string containing characters `a-z` and `*`. :return: List of all possible strings with `*` replaced by \'0\' or \'1\'. # Base condition: if no \'*\' in the string, return the string as a single-item list if \'*\' not in s: return [s] # Recursive approach to replace \'*\' in the string result = [] # Generate strings for all \'*\' in the string replacing it with \'0\' and \'1\' for character in \'01\': new_string = s.replace(\'*\', character, 1) result.extend(generate_all_strings(new_string)) # Ensure the result list is sorted return sorted(result)"},{"question":"# Problem Statement You are developing a financial application that requires calculating the rolling average of stock prices over a specified window. Given a list of daily stock prices and an integer representing the window size, your task is to implement a function that computes the rolling average for the specified window. If the window size is larger than the length of the price list, return an empty list. # Function Specification **Function Name**: `rolling_average` **Input**: - `prices`: A list of floats representing daily stock prices. - `window_size`: An integer representing the size of the window over which to compute the rolling average. **Output**: - A list of floats representing the rolling averages, rounded to two decimal places. # Constraints: - The `prices` list can have up to 1000 elements. - Each price in the list is between 0 and 10,000 inclusive. - The `window_size` is between 1 and the length of the prices list inclusive. # Requirements: - Your solution should have a time complexity of O(n). - Do not use any external libraries except `numpy`. - Ensure that the result list contains the rolling averages from the first valid window till the end of the list. # Examples 1. Example 1: ```python prices = [1, 2, 3, 4, 5] window_size = 3 rolling_average(prices, window_size) ``` Output: ```python [2.0, 3.0, 4.0] ``` 2. Example 2: ```python prices = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] window_size = 4 rolling_average(prices, window_size) ``` Output: ```python [25.0, 35.0, 45.0, 55.0, 65.0, 75.0, 85.0] ``` 3. Example 3: ```python prices = [5.5, 6.7, 8.2, 9.0, 7.3, 6.8] window_size = 2 rolling_average(prices, window_size) ``` Output: ```python [6.1, 7.45, 8.6, 8.15, 7.05] ``` *Note*: Students should ensure that the rolling average is correctly calculated by summing the elements of each window and dividing by the window size, updating as they progress through the list.","solution":"import numpy as np def rolling_average(prices, window_size): Returns the rolling averages of stock prices over the specified window size. :param prices: List of floats representing daily stock prices. :param window_size: Integer representing the window size. :return: List of floats representing the rolling averages. if window_size > len(prices): return [] rolling_averages = [] window_sum = sum(prices[:window_size]) rolling_averages.append(round(window_sum / window_size, 2)) for i in range(window_size, len(prices)): window_sum += prices[i] - prices[i - window_size] rolling_averages.append(round(window_sum / window_size, 2)) return rolling_averages"},{"question":"# Rectangle Intersection Area Calculation Problem You are tasked with creating a feature for a graphics application that calculates the intersection area of two rectangles. Each rectangle is defined by its bottom-left and top-right corners. This will help in various functionalities such as collision detection, drawing overlays, and clipping regions. **Task**: Write a function: 1. `rectangle_intersection_area(rect1: tuple, rect2: tuple) -> float` The function must: 1. Calculate the area of intersection between two rectangles. 2. Return `0.0` if the rectangles do not intersect. 3. Handle edge cases where the rectangles touch at the boundary but do not overlap. # Specifications - The `rect1` and `rect2` parameters are tuples of four floats each representing the coordinates of the bottom-left and top-right corners of the rectangles respectively, in the format (bottom_left_x, bottom_left_y, top_right_x, top_right_y). # Function Description and Examples 1. **rectangle_intersection_area** - **Input**: - `rect1` (tuple): Coordinates of the first rectangle\'s corners. - `rect2` (tuple): Coordinates of the second rectangle\'s corners. - **Output**: - Returns intersection area (float) in square units. - **Examples**: ```python assert rectangle_intersection_area((1.0, 1.0, 4.0, 4.0), (2.0, 2.0, 5.0, 5.0)) == 4.0 assert rectangle_intersection_area((1.0, 1.0, 2.0, 2.0), (3.0, 3.0, 4.0, 4.0)) == 0.0 assert rectangle_intersection_area((0.0, 0.0, 3.0, 3.0), (1.0, 1.0, 2.0, 2.0)) == 1.0 ``` # Implementation Example ```python def rectangle_intersection_area(rect1: tuple, rect2: tuple) -> float: # Calculate intersection boundaries inter_left_x = max(rect1[0], rect2[0]) inter_bottom_y = max(rect1[1], rect2[1]) inter_right_x = min(rect1[2], rect2[2]) inter_top_y = min(rect1[3], rect2[3]) # Check if there is no intersection if inter_left_x >= inter_right_x or inter_bottom_y >= inter_top_y: return 0.0 # Calculate the area of intersection inter_width = inter_right_x - inter_left_x inter_height = inter_top_y - inter_bottom_y inter_area = inter_width * inter_height return inter_area # Example usage: assert rectangle_intersection_area((1.0, 1.0, 4.0, 4.0), (2.0, 2.0, 5.0, 5.0)) == 4.0 assert rectangle_intersection_area((1.0, 1.0, 2.0, 2.0), (3.0, 3.0, 4.0, 4.0)) == 0.0 assert rectangle_intersection_area((0.0, 0.0, 3.0, 3.0), (1.0, 1.0, 2.0, 2.0)) == 1.0 ```","solution":"def rectangle_intersection_area(rect1: tuple, rect2: tuple) -> float: Calculate the area of intersection between two rectangles. Parameters: rect1, rect2: Tuples of four floats, representing the coordinates of the bottom-left and top-right corners of the rectangles respectively, in the format (bottom_left_x, bottom_left_y, top_right_x, top_right_y). Returns: float: The area of intersection in square units. Returns 0.0 if the rectangles do not intersect. # Calculate intersection boundaries inter_left_x = max(rect1[0], rect2[0]) inter_bottom_y = max(rect1[1], rect2[1]) inter_right_x = min(rect1[2], rect2[2]) inter_top_y = min(rect1[3], rect2[3]) # Check if there is no intersection if inter_left_x >= inter_right_x or inter_bottom_y >= inter_top_y: return 0.0 # Calculate the area of intersection inter_width = inter_right_x - inter_left_x inter_height = inter_top_y - inter_bottom_y inter_area = inter_width * inter_height return inter_area"},{"question":"# Scenario You are enhancing an e-commerce application and need to implement a function that calculates the total cost of items in a shopping cart. Each item in the cart has a `price` and a `quantity`, and the function must handle various edge cases, such as empty carts or invalid item attributes. Write comprehensive tests for the function `calculate_cart_total` to ensure it correctly computes the total cost under various scenarios. # Task Write a function `test_calculate_cart_total()` which performs the following: * Tests the cart with multiple items where each item has a non-negative `price` and `quantity`. * Tests the cart with an empty list. * Tests the cart containing items with `quantity` as zero. * Tests the cart with invalid item attributes (e.g., negative price or quantity). * Ensures the function raises appropriate exceptions for invalid item attributes. # Expected Input and Output * **Input**: A list of dictionaries where each dictionary represents an item with `price` and `quantity` keys. * **Output**: The function should contain assertions that test the expected output of `calculate_cart_total` under various scenarios and check for appropriate exceptions. # Constraints * Assume `calculate_cart_total` is correctly defined elsewhere in your codebase. * You should use the `pytest` library for writing the test cases. Example ```python def calculate_cart_total(cart): if not isinstance(cart, list): raise TypeError(\\"Cart must be a list of items.\\") total = 0 for item in cart: price = item.get(\'price\', 0) quantity = item.get(\'quantity\', 0) if not isinstance(price, (int, float)) or not isinstance(quantity, int): raise ValueError(\\"Item price must be a number and quantity must be an integer.\\") if price < 0 or quantity < 0: raise ValueError(\\"Item price and quantity must be non-negative.\\") total += price * quantity return total # Your task is to complete the test function `test_calculate_cart_total`. ``` Your solution should ensure that all assertions hold true for the provided scenarios.","solution":"def calculate_cart_total(cart): if not isinstance(cart, list): raise TypeError(\\"Cart must be a list of items.\\") total = 0 for item in cart: price = item.get(\'price\', 0) quantity = item.get(\'quantity\', 0) if not isinstance(price, (int, float)) or not isinstance(quantity, int): raise ValueError(\\"Item price must be a number and quantity must be an integer.\\") if price < 0 or quantity < 0: raise ValueError(\\"Item price and quantity must be non-negative.\\") total += price * quantity return total"},{"question":"# Problem Description You are tasked with optimizing a matrix traversal algorithm to efficiently find the shortest path from the top-left corner to the bottom-right corner of a grid. Each cell in the grid contains a non-negative integer representing the cost to traverse that cell. Your goal is to implement a solution that minimizes the total traversal cost. # Task Implement a function that calculates the minimum cost to traverse from the top-left corner to the bottom-right corner of a grid using the dynamic programming approach. You can only move right or down from any cell. # Function Signature ```python def min_traversal_cost(grid: list[list[int]]) -> int: pass ``` # Input - `grid` (list[list[int]]): A 2D list of non-negative integers representing the cost grid. # Output - Return the minimum cost to traverse the grid from the top-left corner to the bottom-right corner. # Constraints - The grid will have at least 1 row and 1 column. - The values within the grid will be non-negative integers. - The cost to traverse any cell will be a non-negative integer. # Examples ```python assert min_traversal_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7 assert min_traversal_cost([[1, 2, 3], [4, 5, 6]]) == 12 assert min_traversal_cost([[1, 2], [1, 1]]) == 3 ``` # Hints - Use a 2D array to store the minimum cost to reach each cell and iteratively update it as you traverse the grid. - Initialize the top-left corner with its own cost and build the solution up from there. - Handle edge cases such as single-row, single-column grids, and grid dimensions greater than 2x2. # Additional Notes - Optimize your solution to have a time complexity of O(m*n), where m is the number of rows and n is the number of columns in the grid. - Consider the space complexity if aiming for further optimizations.","solution":"def min_traversal_cost(grid: list[list[int]]) -> int: Calculate the minimum cost to traverse from the top-left to the bottom-right corner of a grid. if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) dp = [[0] * cols for _ in range(rows)] dp[0][0] = grid[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[-1][-1]"},{"question":"# Problem Statement Write a function to simulate the operation of a fictional machine that processes strings according to specified rules. The machine reads through a string and transforms it by applying operations in sequence. The function should take the initial string and a list of operations to perform. Each operation is represented by a tuple, where the first element is a string denoting the type of operation and the second element is the parameter for the operation. # Guidelines 1. **Function Signature**: ```python def string_processor(initial: str, operations: List[Tuple[str, Union[str, int]]]) -> str: ``` 2. **Parameters**: - `initial`: Initial string to be processed. - `operations`: List of operations. Each operation is a tuple where: - The first element is a string specifying the type of operation, which can be: - `\\"append\\"`: Concatenate the parameter string to the end. - `\\"prepend\\"`: Concatenate the parameter string to the start. - `\\"slice\\"`: Slice the string from the start index to the end index specified by the parameter, which is an integer tuple `(start, end)`. - `\\"replace\\"`: Replace all occurrences of the first parameter character with the second parameter character, provided in a tuple `(old_char, new_char)`. 3. **Returns**: - The resulting string after all operations have been applied in order. 4. **Constraints**: - The string can only contain printable ASCII characters. - The list of operations will contain at least one operation. - Indices provided in slicing operations are guaranteed to be valid for the current string length. - Characters for the replace operation will be valid single characters. - Avoid modifying the string in place directly; instead, build and return new strings as needed. # Example ```python >>> string_processor(\\"machine\\", [(\\"append\\", \\"s\\"), (\\"slice\\", (0, 7)), (\\"replace\\", (\'m\', \'M\')), (\\"prepend\\", \\"My \\")]) \'My Machine\' ``` # Notes - Ensure that the operations are applied sequentially and the intermediate state of the string is maintained accurately throughout. - Handle edge cases such as empty initial strings and varying lengths of result after each operation. - Consider performance implications of repeated string concatenations and slicing.","solution":"from typing import List, Tuple, Union def string_processor(initial: str, operations: List[Tuple[str, Union[str, int, Tuple[int, int], Tuple[str, str]]]]) -> str: result = initial for operation in operations: op_type = operation[0] param = operation[1] if op_type == \\"append\\": result += param elif op_type == \\"prepend\\": result = param + result elif op_type == \\"slice\\": start, end = param result = result[start:end] elif op_type == \\"replace\\": old_char, new_char = param result = result.replace(old_char, new_char) return result"},{"question":"# Coding Assessment Question Context Given a class `Node` representing a node in a binary tree, implement a function to calculate the maximum path sum. The path sum is the sum of the values of nodes on any path from any node to any leaf. A path does not necessarily need to go through the root or both ends of the path need not be leaf nodes. Task Write a function `max_path_sum(root: Node) -> int` that: 1. Traverses the binary tree from the root. 2. Calculates the maximum sum of values for any path from any node to any other node. Input - `root`: The root node of the binary tree. Output - An integer representing the maximum path sum. Constraints - The binary tree is non-empty and can have up to 10⁵ nodes. - Node values could be any integer (positive, zero, or negative). Performance Requirements - The function should handle large binary trees efficiently. Aim for a solution with O(n) time complexity, where n is the number of nodes. Example ```python class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right root = Node(1) root.left = Node(2) root.right = Node(3) root.left.left = Node(4) root.left.right = Node(5) root.right.right = Node(6) result = max_path_sum(root) print(result) # Expected output: 15 (from path 4 -> 2 -> 1 -> 3 -> 6) ``` This question tests the candidate\'s knowledge of binary tree traversals, recursion, and dynamic programming concepts to efficiently calculate the maximum path sum in a binary tree.","solution":"class Node: def __init__(self, value=0, left=None, right=None): self.value = value self.left = left self.right = right def max_path_sum(root: Node) -> int: def helper(node): nonlocal max_sum if not node: return 0 # Calculate the maximum path sum with the left and right subtrees left_max = max(helper(node.left), 0) right_max = max(helper(node.right), 0) # Update the maximum path sum including the current node current_sum = node.value + left_max + right_max max_sum = max(max_sum, current_sum) # Return the maximum path sum that can be extended to the parent node return node.value + max(left_max, right_max) max_sum = float(\'-inf\') helper(root) return max_sum"},{"question":"# Problem Statement You are tasked with creating algorithms to solve the \\"minimum coin change problem,\\" where you are given a set of coins of different denominations and a total amount of money. Your goal is to compute the minimum number of coins needed to make up the given amount. You should implement both a dynamic programming solution and a greedy solution and analyze their differences. # Requirements 1. **Dynamic Programming Solution**: - Function Name: `min_coin_change_dp` - Input: List of integers `coins` (denoting coin denominations) and an integer `amount` - Output: Integer representing the minimum number of coins needed to make up the `amount`, or -1 if it is not possible - Constraints: * If `amount` is 0, return 0. * If no combination can produce the amount, return -1. 2. **Greedy Solution**: - Function Name: `min_coin_change_greedy` - Input: List of integers `coins` (denoting coin denominations) and an integer `amount` - Output: Integer representing the minimum number of coins needed to make up the `amount`, or -1 if it is not possible - Constraints: * If `amount` is 0, return 0. * If no combination can produce the amount, return -1. * Assume that coins are sorted in descending order before the function call. # Example For example, the implementation should yield the following outputs: ```python assert min_coin_change_dp([1, 2, 5], 11) == 3 # Explanation: 11 = 5 + 5 + 1 assert min_coin_change_greedy([1, 2, 5], 11) == 3 # Explanation: 11 = 5 + 5 + 1 assert min_coin_change_dp([2], 3) == -1 # Not possible to sum up to 3 with coin 2 assert min_coin_change_greedy([2], 3) == -1 # Not possible to sum up to 3 with coin 2 assert min_coin_change_dp([1], 0) == 0 # No coins needed for amount 0 assert min_coin_change_greedy([1], 0) == 0 # No coins needed for amount 0 ``` # Function Definitions **Dynamic Programming Solution** ```python def min_coin_change_dp(coins: list, amount: int) -> int: # Initialize DP array with a large value greater than any possible coin count dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1 ``` **Greedy Solution** ```python def min_coin_change_greedy(coins: list, amount: int) -> int: coins.sort(reverse=True) count = 0 for coin in coins: if amount == 0: break num_coins = amount // coin amount -= num_coins * coin count += num_coins return count if amount == 0 else -1 ``` Implement these functions and ensure they pass the provided example cases.","solution":"def min_coin_change_dp(coins, amount): # Initialize DP array with a large value greater than any possible coin count dp = [amount + 1] * (amount + 1) dp[0] = 0 for i in range(1, amount + 1): for coin in coins: if i - coin >= 0: dp[i] = min(dp[i], dp[i - coin] + 1) return dp[amount] if dp[amount] != amount + 1 else -1 def min_coin_change_greedy(coins, amount): coins.sort(reverse=True) count = 0 for coin in coins: if amount == 0: break num_coins = amount // coin amount -= num_coins * coin count += num_coins return count if amount == 0 else -1"},{"question":"# **Question: Matrix Transposition and Element Product** You are given a 2D array (matrix) of integers. Your task is to implement two functionalities: 1. **Transpose the Matrix**: Implement a function `transpose_matrix(matrix)` that takes a 2D array (matrix) and returns a new matrix which is the transpose of the original. 2. **Element-wise Product**: Implement a function `elementwise_product(matrix1, matrix2)` that takes two matrices of the same dimensions and returns a new matrix where each element is the product of the corresponding elements of the input matrices. Constraints 1. The input matrices will be non-empty, containing integers. 2. All rows in the 2D arrays will have the same number of columns. 3. `matrix1` and `matrix2` will have the same dimensions for the element-wise product function. Input 1. For the transpose function: - `matrix`: A 2D array of integers. 2. For the element-wise product function: - `matrix1`: A 2D array of integers. - `matrix2`: A 2D array of integers. Output 1. For the transpose function: - A 2D array of integers representing the transpose of the input matrix. 2. For the element-wise product function: - A 2D array of integers representing the element-wise product of the two input matrices. # Example 1. **Transposing a Matrix:** ```python matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(transpose_matrix(matrix)) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` 2. **Element-wise Product of Two Matrices:** ```python matrix1 = [[1, 2, 3], [4, 5, 6]] matrix2 = [[7, 8, 9], [10, 11, 12]] print(elementwise_product(matrix1, matrix2)) # Output: [[7, 16, 27], [40, 55, 72]] ``` # Requirements * Implement the `transpose_matrix` function. * Implement the `elementwise_product` function. * Ensure both functions handle matrices of valid dimensions correctly. * Maintain efficient time and space complexity.","solution":"def transpose_matrix(matrix): Returns the transpose of the given matrix. return list(map(list, zip(*matrix))) def elementwise_product(matrix1, matrix2): Returns the element-wise product of two matrices. result = [] for row1, row2 in zip(matrix1, matrix2): result.append([a * b for a, b in zip(row1, row2)]) return result"},{"question":"# Task: You are required to implement a class `CustomLinkedHashMap` that provides efficient operations for adding, removing, and retrieving key-value pairs while maintaining the insertion order of elements. This class will use a combination of a doubly linked list and a hash map to achieve fast performance on all operations. # Requirements: - Implement the necessary methods that utilize the principles of hash maps and linked lists for optimal performance. - Ensure the data structure maintains insertion order. # Detailed Function Requirements: 1. **`put(key: any, value: any) -> None`**: Inserts the key-value pair into the map. If the key already exists, update the value. * **Input**: `key` - the key to be added, which can be of any type. `value` - the corresponding value to be associated with the key, which can also be of any type. * **Output**: None. 2. **`get(key: any) -> any`**: Retrieves the value associated with the given key. * **Input**: `key` - the key whose value needs to be retrieved. * **Output**: The value associated with the key, or `None` if the key does not exist. 3. **`remove(key: any) -> None`**: Removes the specified key and its associated value from the map. * **Input**: `key` - the key to be removed. * **Output**: None. 4. **`keys() -> list`**: Returns a list of all keys in the map, maintaining the order of their insertion. * **Input**: None. * **Output**: A list containing all keys in the order they were inserted. 5. **`values() -> list`**: Returns a list of all values in the map, maintaining the order of their corresponding keys\' insertion. * **Input**: None. * **Output**: A list containing all values in the order their keys were inserted. # Constraints: - The methods must efficiently handle all operations. - Consideration must be given to edge cases such as removing non-existent keys. # Example Usage: ```python custom_map = CustomLinkedHashMap() custom_map.put(\\"a\\", 1) custom_map.put(\\"b\\", 2) print(custom_map.get(\\"a\\")) # Output: 1 print(custom_map.keys()) # Output: [\\"a\\", \\"b\\"] custom_map.put(\\"a\\", 3) print(custom_map.get(\\"a\\")) # Output: 3 custom_map.remove(\\"b\\") print(custom_map.keys()) # Output: [\\"a\\"] print(custom_map.values()) # Output: [3] ``` # Note: Your implementation should use a doubly linked list to maintain insertion order and a hash map for fast lookups. Ensure that all operations are performed in an efficient manner.","solution":"class Node: def __init__(self, key=None, value=None): self.key = key self.value = value self.prev = None self.next = None class CustomLinkedHashMap: def __init__(self): self.head = Node() # Dummy head node self.tail = Node() # Dummy tail node self.head.next = self.tail self.tail.prev = self.head self.map = {} def _add_node(self, node): prev = self.tail.prev prev.next = node node.prev = prev node.next = self.tail self.tail.prev = node def _remove_node(self, node): prev = node.prev next = node.next prev.next = next next.prev = prev def put(self, key, value): if key in self.map: node = self.map[key] node.value = value else: new_node = Node(key, value) self.map[key] = new_node self._add_node(new_node) def get(self, key): node = self.map.get(key) if node is None: return None return node.value def remove(self, key): node = self.map.get(key) if node is not None: self._remove_node(node) del self.map[key] def keys(self): keys = [] current = self.head.next while current != self.tail: keys.append(current.key) current = current.next return keys def values(self): values = [] current = self.head.next while current != self.tail: values.append(current.value) current = current.next return values"},{"question":"# Unique Sequence Sum Count Context You are tasked with determining the number of ways to form a specified integer `k` as the sum of unique, consecutive positive integers. For example, the integer `15` can be represented as the sum of consecutive sequences in 4 different ways: `[1, 2, 3, 4, 5]`, `[4, 5, 6]`, `[7, 8]`, and `[15]`. Task Write a function `count_consecutive_sums(k: int) -> int` that takes an integer `k` and returns the count of unique ways to express `k` as the sum of consecutive positive integers. Input * An integer `k` where `1 ≤ k ≤ 1000`. Output * An integer representing the number of unique ways to express `k` as the sum of consecutive positive integers. Constraints * A sequence is considered unique if its start and end values are different from other sequences. Example For `k = 15`: ```plaintext count_consecutive_sums(15) => 4 ``` For `k = 10`: ```plaintext count_consecutive_sums(10) => 2 ``` Performance Requirements * Your solution should efficiently handle the upper limits of the input constraints, taking advantage of mathematical insights or efficient algorithms. Implementation Design this function to cover edge cases, ensure optimal performance, and consider mathematical properties that can enhance the efficiency of your solution. ```python def count_consecutive_sums(k: int) -> int: Return the number of ways to represent k as the sum of consecutive positive integers. count = 0 # We explore possible sequence lengths from 1 up to k for m in range(1, k + 1): # Check if there\'s a valid sequence of length m that sums to k # The sum of m consecutive numbers starting with n is: m*n + m*(m-1)/2 # Rearrange to solve for n: n = (k - m*(m-1)/2) / m sum_m_minus_1 = m * (m - 1) // 2 if sum_m_minus_1 >= k: break if (k - sum_m_minus_1) % m == 0: count += 1 return count # Testing the function print(count_consecutive_sums(15)) # Output should be 4 print(count_consecutive_sums(10)) # Output should be 2 ```","solution":"def count_consecutive_sums(k: int) -> int: Return the number of ways to represent k as the sum of consecutive positive integers. count = 0 # We explore possible sequence lengths from 1 up to k for m in range(1, k + 1): # Check if there\'s a valid sequence of length m that sums to k # The sum of m consecutive numbers starting with n is: m*n + m*(m-1)/2 # Rearrange to solve for n: n = (k - m*(m-1)/2) / m sum_m_minus_1 = m * (m - 1) // 2 if sum_m_minus_1 >= k: break if (k - sum_m_minus_1) % m == 0: count += 1 return count"},{"question":"# Question: Counting Distinct Subsequences Context You are given a string `s` and you need to count the number of distinct subsequences of `s` that equal a given target string `t`. A subsequence is created by deleting some or no characters in `s` without changing the order of the remaining characters. Function Signature ```python def count_distinct_subsequences(s: str, t: str) -> int: pass ``` Input * A string `s` of length `n` (1 ≤ n ≤ 1000) containing: - Lowercase English letters. * A string `t` of length `m` (1 ≤ m ≤ 1000) containing: - Lowercase English letters. Output * Return an integer: the number of distinct subsequences of `s` that are equal to `t`. Constraints * The input strings `s` and `t` will only contain lowercase English letters (\'a\' - \'z\'). * The lengths `n` and `m` will be in the range [1, 1000]. Examples Example 1: ```python s = \\"rabbbit\\" t = \\"rabbit\\" count_distinct_subsequences(s, t) # Output: 3 ``` Example 2: ```python s = \\"babgbag\\" t = \\"bag\\" count_distinct_subsequences(s, t) # Output: 5 ``` Example 3: ```python s = \\"abcdef\\" t = \\"z\\" count_distinct_subsequences(s, t) # Output: 0 ``` Example 4: ```python s = \\"bbab\\" t = \\"bab\\" count_distinct_subsequences(s, t) # Output: 2 ``` Guidelines Use dynamic programming to solve the problem. Define `dp[i][j]` as the number of distinct subsequences of the first `i` characters of `s` that equal the first `j` characters of `t`. **Notes**: - Carefully manage edge cases where the lengths of `s` and `t` are at their minimum and maximum values. - Remember that a subsequence does not disturb the order of characters in the original string. - Pay attention to the possibility of duplicate subsequences and ensure they are only counted once.","solution":"def count_distinct_subsequences(s: str, t: str) -> int: m, n = len(t), len(s) if m > n: return 0 dp = [[0] * (n + 1) for _ in range(m + 1)] for j in range(n + 1): dp[0][j] = 1 # An empty t has 1 subsequence in any prefix of s. for i in range(1, m + 1): for j in range(1, n + 1): if t[i - 1] == s[j - 1]: dp[i][j] = dp[i - 1][j - 1] + dp[i][j - 1] else: dp[i][j] = dp[i][j - 1] return dp[m][n]"},{"question":"# Problem: Implement a Stack using a Singly Linked List You are required to implement a stack data structure using a singly linked list. A stack is a linear data structure that follows the Last In First Out (LIFO) principle, where elements are added (pushed) and removed (popped) from the same end. Requirements: 1. **Initialization**: - Initialize the stack with no elements. 2. **Push Operation**: - Support pushing new elements onto the stack. 3. **Pop Operation**: - Support popping elements from the stack. If the stack is empty, raise an IndexError. 4. **Peek Operation**: - Provide a method to get the top element of the stack without removing it. If the stack is empty, raise an IndexError. 5. **Stack State**: - Provide methods to check if the stack is empty. Input: - A set of operations (push, pop, peek) along with their data when applicable. Output: - After each operation, return the state of the stack as a string representation in the format \\"top->mid->bottom\\", or \\"Stack is empty\\" if there are no elements. Constraints: 1. The stack size can grow as needed. 2. The operations will be within the available stack size. Performance Requirements: - Push and pop operations should be handled in O(1) time. - Stack state retrieval should be O(n) where n is the number of elements in the stack. Example Scenario ```python # Initialize a stack stack = Stack() # Push elements onto the stack stack.push(1) print(stack) # Expected Output: \\"1\\" stack.push(2) print(stack) # Expected Output: \\"2->1\\" stack.push(3) print(stack) # Expected Output: \\"3->2->1\\" # Peek at top element top_element = stack.peek() print(top_element) # Expected Output: 3 # Pop elements from the stack stack.pop() print(stack) # Expected Output: \\"2->1\\" stack.pop() print(stack) # Expected Output: \\"1\\" stack.pop() print(stack) # Expected Output: \\"Stack is empty\\" ``` **Note**: You can create a `Node` class for the singly linked list nodes and use it to implement the stack operations.","solution":"class Node: def __init__(self, value): self.value = value self.next = None class Stack: def __init__(self): self.top = None def is_empty(self): return self.top is None def push(self, value): new_node = Node(value) new_node.next = self.top self.top = new_node def pop(self): if self.is_empty(): raise IndexError(\\"pop from empty stack\\") value = self.top.value self.top = self.top.next return value def peek(self): if self.is_empty(): raise IndexError(\\"peek from empty stack\\") return self.top.value def __str__(self): if self.is_empty(): return \\"Stack is empty\\" current = self.top elements = [] while current: elements.append(str(current.value)) current = current.next return \\"->\\".join(elements)"},{"question":"# Linked List Operations In this programming task, you will work with a custom `LinkedList` class that supports various linked list operations. Your goal is to implement a specific method and verify its correctness. Problem Statement You are given the `LinkedList` class with its current functionalities as defined in the code snippet provided. Implement the following additional feature: # Method: `reverse()` Reverse the linked list in place and return the `LinkedList` instance with its elements rearranged in reverse order. # Expected Input and Output Formats * **Input**: The method will be called on a `LinkedList` instance. * **Output**: The `LinkedList` instance itself, with the elements reversed. # Constraints and Limitations: 1. The linked list can contain up to 10^4 nodes. 2. The method should run in O(n) time complexity and use O(1) space complexity. 3. Each node in the linked list contains an integer value. Example Scenario ```python >>> ll = LinkedList() >>> ll.append(1) >>> ll.append(2) >>> ll.append(3) >>> ll.append(4) >>> ll.reverse() >>> print(ll) [4, 3, 2, 1] ``` Use this function implementation to verify the correctness of your code. Ensure your implementation handles edge cases such as linked lists with zero, one, or two elements appropriately. # Implementation Complete the following method within the `LinkedList` class: ```python def reverse(self) -> LinkedList: # Your code here ``` Below is a basic structure of the `LinkedList` class for reference: ```python class Node: def __init__(self, value: int, next: Node = None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def __str__(self) -> str: result = [] current = self.head while current: result.append(current.value) current = current.next return str(result) # Implement the reverse method here ``` Evaluation Criteria * **Correctness**: The method should correctly reverse the linked list. * **Efficiency**: The solution should adhere to the given constraints. * **Readability**: The code should be clean, and well-documented.","solution":"class Node: def __init__(self, value: int, next: \'Node\' = None): self.value = value self.next = next class LinkedList: def __init__(self): self.head = None def append(self, value: int) -> None: new_node = Node(value) if not self.head: self.head = new_node else: current = self.head while current.next: current = current.next current.next = new_node def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev return self def __str__(self) -> str: result = [] current = self.head while current: result.append(current.value) current = current.next return str(result)"},{"question":"# Consecutive Sum Sequence Question You are given a task to determine if an integer `n` can be expressed as the sum of two or more consecutive positive integers. If it can, find the shortest sequence of such integers. If it cannot, return an empty list. Implement a function `find_consecutive_sum` that takes an integer `n` and returns the shortest sequence of consecutive positive integers that sum up to `n`. If no such sequence exists, return an empty list. Signature ```python def find_consecutive_sum(n: int) -> List[int]: ``` Input * **n**: (int) The number to be expressed as the sum of consecutive positive integers. (1 leq n leq 10^6) Output * Returns a list of integers representing the shortest sequence of consecutive positive integers that sum up to `n`. If no such sequence exists, return an empty list. Example ```python >>> find_consecutive_sum(15) [1, 2, 3, 4, 5] >>> find_consecutive_sum(3) [1, 2] >>> find_consecutive_sum(2) [] ``` Explanation: - For `n = 15`, the sequence `1, 2, 3, 4, 5` sums to 15 and is the shortest such sequence. - For `n = 3`, the sequence `1, 2` sums to 3. - For `n = 2`, no sequence of two or more consecutive positive integers sums to 2. Constraints 1. The function must be efficient and handle the problem within a reasonable time frame. 2. Consider edge cases such as very small integers. Implementation Notes 1. Utilize mathematical properties of consecutive sums and their series representation for efficiency. 2. Ensure the function can handle large values close to (10^6) within a reasonable time constraint.","solution":"from typing import List def find_consecutive_sum(n: int) -> List[int]: Returns the shortest sequence of consecutive positive integers that sum up to n. If no such sequence exists, returns an empty list. for start in range(1, n): sum_ = 0 sequence = [] for num in range(start, n): sum_ += num sequence.append(num) if sum_ == n: return sequence if sum_ > n: break return []"},{"question":"Question # Context: You are given an array of integers where each element appears twice except for one. Write a function to find that single one. Your algorithm should have a linear runtime complexity and be able to handle this in `O(1)` space complexity. # Task: Write a Python function `find_single_element(nums: List[int]) -> int:` that returns the single element that does not have a duplicate in the array. # Input: - `nums`: A list of integers where every element appears twice except for one. # Output: - An integer representing the single element that appears only once in the array. # Constraints: - The input list follows the constraint: 1 <= len(nums) <= 3 * 10^4 # Example: ```python def find_single_element(nums: List[int]) -> int: pass # Your implementation here # Example 1 nums = [2, 2, 1] print(find_single_element(nums)) # Expected output: 1 # Example 2 nums = [4, 1, 2, 1, 2] print(find_single_element(nums)) # Expected output: 4 # Example 3 nums = [1] print(find_single_element(nums)) # Expected output: 1 ``` # Requirements: - Implement the function using bitwise XOR to achieve the desired time and space complexity. - The solution should iterate through the list only once. # Performance: - Ensure the solution runs in linear time `O(n)`. - Use only `O(1)` extra space beyond the input list to keep the solution optimal.","solution":"from typing import List def find_single_element(nums: List[int]) -> int: Returns the single element that does not have a duplicate in the array. This function uses bitwise XOR to find the element in linear time and constant space. unique_element = 0 for num in nums: unique_element ^= num return unique_element"},{"question":"# Context You are designing a search feature for an application, and one requirement is to implement an autocomplete suggestion system. The efficiency and accuracy of your autocomplete function are crucial as it significantly impacts the user experience. # Objective Implement a function that takes a list of words (the dictionary) and a string prefix. The function should return a list of all dictionary words that start with the given prefix. # Function Signature ```python def autocomplete(dictionary: list[str], prefix: str) -> list[str]: Return a list of dictionary words that start with the given prefix. :param dictionary: List of words (strings) to search in :param prefix: Prefix string to match the start of the words :return: List of words starting with the given prefix Example: >>> autocomplete([\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"apply\\"], \\"app\\") [\\"apple\\", \\"apply\\"] >>> autocomplete([\\"dog\\", \\"deer\\", \\"deal\\"], \\"de\\") [\\"deer\\", \\"deal\\"] ``` # Constraints and Requirements 1. The input `dictionary` should be a list of strings, where each string is a non-empty word consisting of only lowercase letters. 2. The input `prefix` should be a non-empty string consisting of only lowercase letters. 3. If no words in the dictionary start with the given prefix, return an empty list. 4. Raise a `ValueError` if either `dictionary` or `prefix` is not appropriately formatted (e.g., contains uppercase letters or non-alphabetic characters). # Performance 1. Ensure the algorithm runs efficiently with a time complexity better than (O(n * m)), where `n` is the length of the dictionary and `m` is the length of the longest word. 2. The space complexity should be managed effectively, especially when dealing with large dictionaries. # Examples - Input: `[\\"apple\\", \\"banana\\", \\"apricot\\", \\"cherry\\", \\"apply\\"], \\"app\\"` Output: `[\\"apple\\", \\"apply\\"]` - Input: `[\\"dog\\", \\"deer\\", \\"deal\\"], \\"de\\"` Output: `[\\"deer\\", \\"deal\\"]` - Input: `[\\"cat\\", \\"caramel\\", \\"carrot\\"], \\"ca\\"` Output: `[\\"cat\\", \\"caramel\\", \\"carrot\\"]` - Input: `[\\"fish\\", \\"fishing\\", \\"fist\\"], \\"fi\\"` Output: `[\\"fish\\", \\"fishing\\", \\"fist\\"]` # Notes Ensure to properly handle invalid inputs and edge cases. Consider optimizing for large dictionaries to improve user experience with minimal latency. Validate your implementation with various test cases to ensure correctness and performance.","solution":"import re def autocomplete(dictionary: list[str], prefix: str) -> list[str]: Return a list of dictionary words that start with the given prefix. :param dictionary: List of words (strings) to search in :param prefix: Prefix string to match the start of the words :return: List of words starting with the given prefix :raises ValueError: If input dictionary or prefix has invalid format # Validate input dictionary if not all(isinstance(word, str) and re.match(\'^[a-z]+\', word) for word in dictionary): raise ValueError(\\"Dictionary must be a list of non-empty lowercase alphabetic strings.\\") # Validate input prefix if not isinstance(prefix, str) or not re.match(\'^[a-z]+\', prefix): raise ValueError(\\"Prefix must be a non-empty lowercase alphabetic string.\\") # Return list of words starting with the given prefix return [word for word in dictionary if word.startswith(prefix)]"},{"question":"# Distance Between Points **Objective**: Implement a function that calculates the Euclidean distance between two points in 2D space. **Function Signature**: `def calc_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float:` # Input: - `point1` (tuple of two float values): The coordinates (x1, y1) of the first point. - `point2` (tuple of two float values): The coordinates (x2, y2) of the second point. # Output: - Returns the Euclidean distance (float) between the two points, rounded to two decimal places. # Constraints: - The input tuples must each contain exactly two float values. - The function should raise a `ValueError` if any tuple contains a different number of elements. # Examples: 1. `calc_distance((0, 0), (3, 4))` should return `5.00`. 2. `calc_distance((1.5, 2.5), (4.5, 6.5))` should return `5.00`. 3. `calc_distance((-1, -1), (2, 3))` should return `5.00`. 4. `calc_distance((0, 0, 0), (3, 4))` should raise `ValueError: Points must be 2D coordinates`. # Notes: - The Euclidean distance between two points `(x1, y1)` and `(x2, y2)` can be found using the formula: `sqrt((x2 - x1)**2 + (y2 - y1)**2)`. - Ensure that the tuples represent 2D coordinates correctly by checking their lengths. - Use Python’s `math.sqrt` for computing the square root. - Be mindful of floating-point precision when calculating the distance. # Hints: - You can use Python’s built-in `math` module for square root calculation. - Consider using a try-except block or if-condition to handle tuples that do not contain exactly two elements.","solution":"import math def calc_distance(point1: tuple[float, float], point2: tuple[float, float]) -> float: Calculate the Euclidean distance between two points in 2D space. :param point1: Tuple containing the coordinates (x1, y1) of the first point :param point2: Tuple containing the coordinates (x2, y2) of the second point :return: The Euclidean distance between the two points rounded to two decimal places. :raises: ValueError if the input tuples do not contain exactly two elements. if len(point1) != 2 or len(point2) != 2: raise ValueError(\\"Points must be 2D coordinates\\") x1, y1 = point1 x2, y2 = point2 distance = math.sqrt((x2 - x1)**2 + (y2 - y1)**2) return round(distance, 2)"},{"question":"**Problem Statement:** You are tasked with finding the smallest number that is evenly divisible by all of the numbers from 1 to a given upper limit `m`. **Write a function:** ```python def find_smallest_multiple(m: int) -> int: Given an upper limit m, find the smallest positive number that is evenly divisible by all of the numbers from 1 to m. :param m: An integer representing the upper limit (m > 1) :return: An integer, representing the smallest number that is evenly divisible by all of the numbers from 1 to m. Example: >>> find_smallest_multiple(10) 2520 >>> find_smallest_multiple(15) 360360 >>> find_smallest_multiple(20) 232792560 pass ``` # Input - An integer `m` (2 <= m <= 50) # Output - An integer representing the smallest number that is evenly divisible by all of the numbers from 1 to `m`. # Constraints - The function must handle values up to 50 efficiently. - The function must return correct results for edge cases, including small and large values of `m`. # Scenario This problem is designed to test your understanding of the Least Common Multiple (LCM) in a practical context. Your job is to compute the smallest number that can be divided by every number from 1 to `m` without leaving a remainder. This function will help in learning about LCM and its computation using prime factorization or iterative methods. # Hints: - Use the Greatest Common Divisor (GCD) to help compute the LCM. - Consider using iterative computation of the LCM for each number in the range. **Testing:** Ensure that your solution passes the given examples and consider additional edge cases, for instance: - `find_smallest_multiple(5) -> 60` - `find_smallest_multiple(13) -> 360360`","solution":"import math def find_smallest_multiple(m: int) -> int: Given an upper limit m, find the smallest positive number that is evenly divisible by all of the numbers from 1 to m. def lcm(a, b): return a * b // math.gcd(a, b) multiple = 1 for i in range(1, m + 1): multiple = lcm(multiple, i) return multiple"},{"question":"# Coding Assessment Question Prerequisites: Understanding of recursion, memoization, and sequence generation. Problem Statement: Implement a function `fibonacci_sequence(n: int) -> int` that returns the `n`-th Fibonacci number. Use memoization to optimize the computation. Function Signature: ```python def fibonacci_sequence(n: int) -> int: pass ``` Input: - `n` (0 ≤ n ≤ 10^5): An integer specifying the position in the Fibonacci sequence. Output: - An integer representing the `n`-th Fibonacci number. Requirements: 1. **Efficiency**: Your implementation should have time complexity close to O(n). 2. **Space Optimization**: Use memory efficiently without compromising clarity. Constraints: - Handle invalid inputs by raising appropriate Python exceptions: - If `n` is not an integer, raise a `TypeError`. - If `n` is less than 0, raise a `ValueError`. Examples: ```python assert fibonacci_sequence(0) == 0 # The 0-th Fibonacci number is 0 assert fibonacci_sequence(1) == 1 # The 1st Fibonacci number is 1 assert fibonacci_sequence(10) == 55 # The 10th Fibonacci number is 55 assert fibonacci_sequence(20) == 6765 # The 20th Fibonacci number is 6765 assert fibonacci_sequence(50) == 12586269025 # The 50th Fibonacci number is 12586269025 ``` Note: - Ensure to include edge-case testing. - Optimize both for readability and performance. - Unit tests are highly recommended.","solution":"def fibonacci_sequence(n: int) -> int: Returns the n-th Fibonacci number. if not isinstance(n, int): raise TypeError(\\"Input must be an integer\\") if n < 0: raise ValueError(\\"Input must be a non-negative integer\\") if n == 0: return 0 elif n == 1: return 1 fib = [0, 1] + [0] * (n - 1) for i in range(2, n + 1): fib[i] = fib[i - 1] + fib[i - 2] return fib[n]"},{"question":"# Rotate Image by 90 Degrees Problem Statement Given an `n x n` 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You need to perform this rotation in-place, meaning you should directly modify the input matrix without using extra memory for another 2D matrix. Write a function `rotate_image(matrix: List[List[int]]) -> None` that takes in: - `matrix` (a list of lists of integers): The `n x n` 2D matrix representing the image to be rotated. The function should directly modify the `matrix` to reflect the rotated image. Example ```python >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate_image(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [ 5, 1, 9, 11], ... [ 2, 4, 8, 10], ... [13, 3, 6, 7], ... [15, 14, 12, 16] ... ] >>> rotate_image(matrix) >>> matrix [ [15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11] ] ``` Constraints - The matrix will have a length and width of `n`. Thus, it will always be a square matrix. - You may assume `n` is at most 1000. - The integers in the matrix will be between -1000 and 1000. Performance Requirements The solution should work efficiently in-place without using extra space for another 2D matrix. Additional Notes Ensure that you handle cases where: - The matrix has a single element. - The matrix is empty. Make sure your implementation does not use additional space for another matrix and properly reflects the rotated image within the original matrix structure.","solution":"def rotate_image(matrix): Rotates the input n x n 2D matrix by 90 degrees clockwise in place. Args: matrix (List[List[int]]): The input 2D matrix to be rotated. Returns: None n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"# Coding Assessment Question: Implement a Least Recently Used (LRU) cache system using data structures of your choice (e.g., a combination of a hashmap and a doubly linked list). The cache should provide efficient retrieval and update operations, maintaining the LRU property where the least recently accessed item is discarded when the cache exceeds its capacity. **Requirements**: - Your solution should support the following operations: `get`, `put`, and `display`. - The `get` operation should retrieve the value associated with a given key. - The `put` operation should insert or update a key-value pair in the cache. - The `display` operation should display the current state of the cache in the order from most recently used to least recently used. **Function Specifications**: - **get(key: int) -> int**: Return the value associated with `key` if present, otherwise return -1. - **put(key: int, value: int) -> None**: Insert or update the value associated with `key`. If the cache exceeds its capacity, the least recently used item should be removed. - **display() -> List[Tuple[int, int]]**: Return a list of key-value pairs representing the cache state from most recently used to least recently used. **Constraints**: - The cache has a fixed capacity provided at initialization. - All operations should function within O(1) time complexity. **Example**: ```python >>> lru = LRUCache(2) >>> lru.put(1, 1) >>> lru.put(2, 2) >>> lru.get(1) 1 >>> lru.put(3, 3) # Evicts key 2 >>> lru.get(2) -1 >>> lru.put(4, 4) # Evicts key 1 >>> lru.get(1) -1 >>> lru.get(3) 3 >>> lru.get(4) 4 >>> lru.display() [(4, 4), (3, 3)] ``` You are encouraged to explore the optimal data structures and algorithms necessary to achieve the specified performance guarantees.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} # Hashmap to store key-node pairs self.head = Node(0, 0) self.tail = Node(0, 0) self.head.next = self.tail self.tail.prev = self.head def _add_node(self, node: Node): Add a new node right after head. node.prev = self.head node.next = self.head.next self.head.next.prev = node self.head.next = node def _remove_node(self, node: Node): Remove an existing node from the linked list. prev = node.prev new = node.next prev.next = new new.prev = prev def _move_to_head(self, node: Node): Move certain node to the head. self._remove_node(node) self._add_node(node) def _pop_tail(self): Pop the current tail. res = self.tail.prev self._remove_node(res) return res def get(self, key: int) -> int: node = self.cache.get(key, None) if not node: return -1 # move the accessed node to the head; self._move_to_head(node) return node.value def put(self, key: int, value: int) -> None: node = self.cache.get(key) if not node: newNode = Node(key, value) self.cache[key] = newNode self._add_node(newNode) if len(self.cache) > self.capacity: # pop the tail tail = self._pop_tail() del self.cache[tail.key] else: node.value = value self._move_to_head(node) def display(self): Display the cache from most recently to least recently used. result = [] current = self.head.next while current != self.tail: result.append((current.key, current.value)) current = current.next return result"},{"question":"# Coding Assessment Question **Height-balanced Tree Verification** You are given a binary tree implementation where each node has an integer value, and each node can have left and right child nodes. Your task is to check whether a given binary tree is height-balanced or not. A binary tree is height-balanced if: 1. For every node, the difference in height between the left and right subtrees is at most 1. # Function Signature ```python def is_balanced_tree(tree: BinaryTree) -> bool: Determine if the given binary tree is height-balanced. :param tree: BinaryTree representing the binary tree. :return: True if the tree is height-balanced, False otherwise. class Node: def __init__(self, data: int, left: \'Node\' = None, right: \'Node\' = None): self.data = data self.left = left self.right = right class BinaryTree: def __init__(self, root: Node): self.root = root ``` # Input and Output - **Input**: A `BinaryTree` object, the root of which is a `Node`. - **Output**: A boolean, `True` if the tree is height-balanced, `False` otherwise. # Example ```python # Example 1 root = Node(1) root.left = Node(2, Node(4), Node(5)) root.right = Node(3, Node(6)) tree = BinaryTree(root) assert is_balanced_tree(tree) == True # Example 2 root = Node(1) root.left = Node(2, Node(4, Node(6))) root.right = Node(3, Node(5)) tree = BinaryTree(root) assert is_balanced_tree(tree) == False ``` # Constraints - The value at each node can be any valid integer. - The binary tree can be skewed (all left children or all right children). - The maximum height of the tree is 10⁴ nodes. # Guidelines - Think recursively about the height constraints imposed at each subtree. - Carefully handle edge cases including: - Single node trees. - Trees with negative values. - Trees where left or right children are missing. # Performance Requirements - Your solution should be optimized to run in linear time O(n).","solution":"class Node: def __init__(self, data: int, left: \'Node\' = None, right: \'Node\' = None): self.data = data self.left = left self.right = right class BinaryTree: def __init__(self, root: Node): self.root = root def is_balanced_tree(tree: BinaryTree) -> bool: Determine if the given binary tree is height-balanced. :param tree: BinaryTree representing the binary tree. :return: True if the tree is height-balanced, False otherwise. def check_balance(node: Node) -> (bool, int): if node is None: return True, 0 left_balanced, left_height = check_balance(node.left) right_balanced, right_height = check_balance(node.right) balanced = left_balanced and right_balanced and abs(left_height - right_height) <= 1 height = max(left_height, right_height) + 1 return balanced, height is_balanced, _ = check_balance(tree.root) return is_balanced"},{"question":"# CODING ASSESSMENT QUESTION Introduction You are a software developer working on a productivity tool that calculates the average reading time of articles based on their word count. The average reading speed of a person is approximately 200 words per minute. You need to implement two functions to compute the reading time in minutes and in a more readable format of minutes and seconds. Problem Description Write two functions `calculate_reading_time` and `format_reading_time` to compute the reading time of an article in minutes and to express it in minutes and seconds. 1. **Reading Time Calculation**: [ text{Reading Time (minutes)} = frac{text{word_count}}{200} ] - Inputs: - word_count (int): The total number of words in the article. - Output: (float) The reading time in minutes. - Constraints: The input should be a positive integer. 2. **Reading Time Formatting**: [ text{Reading Time (minutes and seconds)} = minutes + left(seconds , text{formatted as} , leftlfloor text{seconds} / 60 rightrfloor: text{seconds} , text{mod} , 60right) ] - Inputs: - word_count (int): The total number of words in the article. - Output: (str) The reading time formatted as a string in \'X minutes Y seconds\'. - Constraints: The input should be a positive integer. Function Signature ```python def calculate_reading_time(word_count: int) -> float: pass def format_reading_time(word_count: int) -> str: pass ``` Expected Input and Output ``` >>> calculate_reading_time(1000) 5.0 >>> calculate_reading_time(450) 2.25 >>> format_reading_time(1000) \'5 minutes 0 seconds\' >>> format_reading_time(450) \'2 minutes 15 seconds\' ``` Constraints 1. If the `word_count` is not a positive integer, the function should raise a `ValueError` with a message `Word count must be a positive integer`. 2. Use the function signatures provided and ensure the function behavior matches the examples given. Provide a robust solution that factors in edge cases and verify it using the provided examples.","solution":"def calculate_reading_time(word_count: int) -> float: if not isinstance(word_count, int) or word_count <= 0: raise ValueError(\\"Word count must be a positive integer\\") return word_count / 200 def format_reading_time(word_count: int) -> str: if not isinstance(word_count, int) or word_count <= 0: raise ValueError(\\"Word count must be a positive integer\\") reading_time_minutes = calculate_reading_time(word_count) minutes = int(reading_time_minutes) seconds = int((reading_time_minutes - minutes) * 60) return f\\"{minutes} minutes {seconds} seconds\\""},{"question":"# Longest Increasing Subsequence Implementation You are tasked with implementing a solution to find the longest increasing subsequence (LIS) within a given list of integers. The LIS problem is a classic example in dynamic programming and is essential for various applications in computer science. Problem Statement 1. Implement a function `find_lis(arr: List[int]) -> List[int]` that computes the longest increasing subsequence from a given list of integers. 2. Implement a function `lis_length(arr: List[int]) -> int` that returns the length of the longest increasing subsequence. Function Signatures ```python from typing import List def find_lis(arr: List[int]) -> List[int]: pass def lis_length(arr: List[int]) -> int: pass ``` Input and Output Formats 1. **Function `find_lis(arr: List[int]) -> List[int]`**: - **Input**: - `arr` (List[int]) - A list of integers. - **Output**: - A list of integers representing the longest increasing subsequence found in the input list. - If multiple LISs exist, any one of them can be returned. 2. **Function `lis_length(arr: List[int]) -> int`**: - **Input**: - `arr` (List[int]) – A list of integers. - **Output**: - The length of the longest increasing subsequence in the input list. Constraints - (On `find_lis` and `lis_length`): - `arr` must be a list of integers. - Raise `TypeError` with a suitable message if `arr` is not a list or if any element within `arr` is not an integer. - The list can be empty, in which case the function should return an empty list for `find_lis` and `0` for `lis_length`. Scenario and Context You are working on a complex data analysis project where finding subsequences is a recurring operation. The results are vital for trend analysis and predictive modeling. Your solutions must efficiently handle different edge cases, such as varying lengths of input lists and large datasets. Your implementation should ensure correctness, maintain optimal performance, and adhere to the required constraints.","solution":"from typing import List def find_lis(arr: List[int]) -> List[int]: # First, validate the input if not isinstance(arr, list): raise TypeError(\\"Input must be a list\\") for element in arr: if not isinstance(element, int): raise TypeError(\\"All elements in the list must be integers\\") n = len(arr) if n == 0: return [] # lis_length[i] will be the length of the LIS ending at index i lis_length = [1] * n # prev_index stores the index of the previous element in the LIS prev_index = [-1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis_length[i] < lis_length[j] + 1: lis_length[i] = lis_length[j] + 1 prev_index[i] = j # Find the index of the maximum length in lis_length max_len_index = 0 for i in range(1, n): if lis_length[i] > lis_length[max_len_index]: max_len_index = i lis = [] while max_len_index != -1: lis.append(arr[max_len_index]) max_len_index = prev_index[max_len_index] return lis[::-1] def lis_length(arr: List[int]) -> int: # First, validate the input if not isinstance(arr, list): raise TypeError(\\"Input must be a list\\") for element in arr: if not isinstance(element, int): raise TypeError(\\"All elements in the list must be integers\\") n = len(arr) if n == 0: return 0 # lis_length[i] will be the length of the LIS ending at index i lis_length = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j] and lis_length[i] < lis_length[j] + 1: lis_length[i] = lis_length[j] + 1 return max(lis_length)"},{"question":"# Question: Implementing a Cache for Fibonacci Sequence You are tasked with creating an efficient solution to compute Fibonacci numbers using a caching mechanism. This will help reduce the number of redundant computations, thus optimizing performance. # Scenario In many computational tasks, Fibonacci numbers often need to be computed repeatedly. By caching previously computed values, we can drastically reduce the time complexity of our solution. # Function Signature ```python class FibonacciCache: def __init__(self): # Initialize your cache pass def get_fibonacci(self, n: int) -> int: # Compute the nth Fibonacci number pass ``` # Input - `n` (int): The position in the Fibonacci sequence to compute. # Output - Returns the Fibonacci number at position `n`. # Constraints - `n` is a non-negative integer. - Use a dictionary to store and retrieve computed Fibonacci values. - Ensure the algorithm handles large values of `n` efficiently by utilizing the cache. # Example ```python fib_cache = FibonacciCache() assert fib_cache.get_fibonacci(0) == 0 # F(0) = 0 assert fib_cache.get_fibonacci(1) == 1 # F(1) = 1 assert fib_cache.get_fibonacci(2) == 1 # F(2) = 1 assert fib_cache.get_fibonacci(10) == 55 # F(10) = 55 assert fib_cache.get_fibonacci(50) == 12586269025 ``` # Requirements - Implement a caching mechanism to store previously computed Fibonacci numbers. - Ensure that the cache is used to retrieve already computed values to minimize computation time. - Handle the base cases where `n` is 0 or 1 directly within the method. - Implement the solution within a class-based structure with appropriate methods for initialization and computation.","solution":"class FibonacciCache: def __init__(self): self.cache = {} def get_fibonacci(self, n: int) -> int: if n in self.cache: return self.cache[n] if n < 2: return n self.cache[n] = self.get_fibonacci(n-1) + self.get_fibonacci(n-2) return self.cache[n]"},{"question":"# Problem Statement: You are tasked with developing a simple inventory management system for a small store. The system should be capable of storing data about items, including their name, quantity in stock, and price. The primary objective is to be able to update the stock levels, compute the total value of the inventory, and generate a report listing all items and their details. # Requirements: 1. **Class Name**: `Item` - **Attributes**: - `name` (string): Name of the item. - `quantity` (int): Quantity of the item in stock. - `price` (float): Price of the item. - **Methods**: - `__init__(self, name, quantity, price)`: Initializes an item with the given name, quantity, and price. - `update_quantity(self, amount)`: Updates the quantity of the item by adding the specified amount. 2. **Class Name**: `Inventory` - **Attributes**: - `items` (dictionary): Dictionary where the key is the item name (string) and the value is an `Item` object. - **Methods**: - `__init__(self)`: Initializes an inventory with an empty dictionary of items. - `add_item(self, item)`: Adds an `Item` object to the inventory. If the item already exists, it updates its price and quantity. - `remove_item(self, item_name)`: Removes the item with the specified name from the inventory. - `get_total_value(self)`: Returns the total value of all items in the inventory. - `generate_report(self)`: Generates and returns a string report listing all items and their details (name, quantity, and price). # Constraints: - All item names are unique. - Quantity and price are non-negative values. - The inventory initially contains no items. # Performance Requirements: - Ensure that adding, updating, and removing items are efficient operations. - The `generate_report` method should format the report neatly with headers sorted by item name. # Example Usage: ```python if __name__ == \\"__main__\\": inventory = Inventory() item1 = Item(\\"Apple\\", 50, 0.5) item2 = Item(\\"Banana\\", 30, 0.2) inventory.add_item(item1) inventory.add_item(item2) item1.update_quantity(20) inventory.remove_item(\\"Banana\\") print(inventory.get_total_value()) # Expected output: 35.0 print(inventory.generate_report()) # Expected output: # Item Name | Quantity | Price # Apple | 70 | 0.50 ```","solution":"class Item: def __init__(self, name, quantity, price): self.name = name self.quantity = quantity self.price = price def update_quantity(self, amount): self.quantity += amount class Inventory: def __init__(self): self.items = {} def add_item(self, item): if item.name in self.items: existing_item = self.items[item.name] existing_item.update_quantity(item.quantity) existing_item.price = item.price # Update the price to the new item price else: self.items[item.name] = item def remove_item(self, item_name): if item_name in self.items: del self.items[item_name] def get_total_value(self): total_value = sum(item.quantity * item.price for item in self.items.values()) return total_value def generate_report(self): report = \\"Item Name | Quantity | Pricen\\" report += \\"--------- | -------- | -----n\\" for item_name in sorted(self.items): item = self.items[item_name] report += f\\"{item.name.ljust(9)} | {str(item.quantity).ljust(8)} | {item.price:.2f}n\\" return report"},{"question":"# Rearrange Characters to Form a Palindrome Given a string, determine if the characters of the string can be rearranged to form a palindrome. If so, return one possible palindrome arrangement. If it is not possible to rearrange the characters to form a palindrome, return an empty string. # Input and Output Formats: - **Input:** * A single string `s` containing only lowercase alphabets. - **Output:** * If it is possible to rearrange the characters of the input string to form a palindrome, return one of such palindrome strings. * If it is not possible, return an empty string. # Constraints: - The input string will have a length between 1 and 1000. - The input string will contain only lowercase English letters (a-z). # Example: **Input:** ``` \\"sirii\\" ``` **Output:** ``` \\"iriir\\" (or any other valid palindrome variation) ``` **Input:** ``` \\"hello\\" ``` **Output:** ``` \\"\\" ``` # Explanation: - For the first example: - The input string \\"sirii\\" can be rearranged to form the palindrome \\"iriir\\". - For the second example: - The input string \\"hello\\" cannot be rearranged to form a palindrome, so the output is an empty string. # Hint: - A string can be rearranged to form a palindrome if at most one character has an odd count, and all other characters have even counts. ```python def can_form_palindrome(s: str) -> str: from collections import Counter count = Counter(s) odd_count = 0 middle_char = \\"\\" half_palindrome = [] for char, freq in count.items(): if freq % 2 != 0: odd_count += 1 middle_char = char half_palindrome.extend(char * (freq // 2)) if odd_count > 1: return \\"\\" half_palindrome = \\"\\".join(half_palindrome) return half_palindrome + middle_char + half_palindrome[::-1] # Tests assert can_form_palindrome(\\"sirii\\") in {\\"iriir\\", \\"ririr\\"} # expects a valid palindrome permutation assert can_form_palindrome(\\"hello\\") == \\"\\" # expects an empty string since palindrome cannot be formed ``` # Note: - Optimize the solution to handle the maximum constraint efficiently. - Use the `Counter` class from the `collections` module to count character frequencies conveniently.","solution":"from collections import Counter def can_form_palindrome(s: str) -> str: # Count the frequency of each character in the string count = Counter(s) # Track the number of characters with an odd count odd_count = 0 middle_char = \\"\\" half_palindrome = [] for char, freq in count.items(): if freq % 2 != 0: odd_count += 1 middle_char = char half_palindrome.extend(char * (freq // 2)) # A string can form a palindrome if at most one character has an odd count if odd_count > 1: return \\"\\" # Construct the palindrome half_palindrome = \\"\\".join(half_palindrome) return half_palindrome + middle_char + half_palindrome[::-1]"},{"question":"# Interpolation Methods In this task, you are required to implement different interpolation techniques to estimate values between known data points. Part 1: Linear Interpolation You are to implement a function `linear_interpolation` that takes three arguments: `x_values`, `y_values`, and `x`, and estimates the value of `y` for the given `x` using linear interpolation. Part 2: Polynomial Interpolation Implement a function `polynomial_interpolation` that takes three arguments: `x_values`, `y_values`, and `x`, and estimates the value of `y` for the given `x` using polynomial interpolation. Function Signatures ```python def linear_interpolation(x_values: List[float], y_values: List[float], x: float) -> float: Estimates the value of y using linear interpolation for the given x based on x_values and y_values data points. Parameters: x_values (List[float]): A list of x-coordinates of the data points. y_values (List[float]): A list of y-coordinates of the data points. x (float): The x-coordinate at which to estimate y. Returns: float: The estimated value of y at x. pass def polynomial_interpolation(x_values: List[float], y_values: List[float], x: float) -> float: Estimates the value of y using polynomial interpolation for the given x based on x_values and y_values data points. Parameters: x_values (List[float]): A list of x-coordinates of the data points. y_values (List[float]): A list of y-coordinates of the data points. x (float): The x-coordinate at which to estimate y. Returns: float: The estimated value of y at x. pass ``` # Constraints * `x_values` and `y_values` should be of the same length and contain at least 2 data points. * `x` should be within the range of `x_values`. # Example ```python x_vals = [1, 2, 3, 4, 5] y_vals = [1, 4, 9, 16, 25] print(linear_interpolation(x_vals, y_vals, 2.5)) # Output: Estimated value of y using linear interpolation for x=2.5 print(polynomial_interpolation(x_vals, y_vals, 2.5)) # Output: Estimated value of y using polynomial interpolation for x=2.5 ``` # Requirements 1. Ensure you handle cases where `x_values` are not sorted properly. 2. Include error handling for invalid inputs such as mismatched list lengths. 3. Optimize for performance to handle reasonably large datasets without excessive computational load.","solution":"from typing import List def linear_interpolation(x_values: List[float], y_values: List[float], x: float) -> float: if len(x_values) != len(y_values): raise ValueError(\\"x_values and y_values must have the same length\\") if len(x_values) < 2: raise ValueError(\\"x_values and y_values must contain at least two data points\\") sorted_indices = sorted(range(len(x_values)), key=lambda i: x_values[i]) x_values = [x_values[i] for i in sorted_indices] y_values = [y_values[i] for i in sorted_indices] if x < x_values[0] or x > x_values[-1]: raise ValueError(\\"x should be within the range of x_values\\") for i in range(len(x_values) - 1): if x_values[i] <= x <= x_values[i+1]: x0, x1 = x_values[i], x_values[i+1] y0, y1 = y_values[i], y_values[i+1] return y0 + (x - x0) * (y1 - y0) / (x1 - x0) raise ValueError(\\"Failed to interpolate\\") def polynomial_interpolation(x_values: List[float], y_values: List[float], x: float) -> float: if len(x_values) != len(y_values): raise ValueError(\\"x_values and y_values must have the same length\\") if len(x_values) < 2: raise ValueError(\\"x_values and y_values must contain at least two data points\\") def lagrange_poly(x, x_values, y_values): total = 0 n = len(x_values) for i in range(n): term = y_values[i] for j in range(n): if i != j: term *= (x - x_values[j]) / (x_values[i] - x_values[j]) total += term return total return lagrange_poly(x, x_values, y_values)"},{"question":"# Coding Assessment Question: Design and implement a data structure that functions as a priority queue but uses only basic stack operations: `push`, `pop`, and `peek`. Your implementation should provide the following functionalities: - **push(item: int, priority: int) -> None**: Adds an item to the priority queue with the specified priority. - **pop() -> int**: Removes and returns the highest priority item from the queue. If multiple items have the same highest priority, return the one inserted first (FIFO order). Raises an `IndexError` if the queue is empty. - **peek() -> int | None**: Returns the highest priority item without removing it. If multiple items have the same highest priority, return the one inserted first (FIFO order). Returns `None` if the queue is empty. # Constraints: - The maximum number of elements pushed into the priority queue won\'t exceed (10^5). - All operations should handle edge scenarios gracefully (e.g., popping or peeking from an empty queue). # Example: ```python >>> pq = PriorityQueueUsingStacks() >>> pq.push(1, 5) >>> pq.push(2, 1) >>> pq.push(3, 4) >>> pq.peek() 1 >>> pq.pop() 1 >>> pq.peek() 3 >>> pq.push(4, 5) >>> pq.pop() 4 >>> pq.peek() 3 >>> pq.pop() 3 >>> pq.pop() 2 >>> pq.pop() Traceback (most recent call last): ... IndexError: pop from an empty stack ``` Your task is to create the `PriorityQueueUsingStacks` class implementing this functionality. You are encouraged to think creatively about how to achieve this using the stack operations while maintaining correctness and efficiency.","solution":"class PriorityQueueUsingStacks: def __init__(self): self.stack = [] def push(self, item: int, priority: int) -> None: # Use a list to represent a stack; each element is a tuple (priority, item, index) # Append with a counter to maintain FIFO with same priority if len(self.stack) == 0: self.stack.append((priority, item, 0)) else: max_index = max(x[2] for x in self.stack) + 1 self.stack.append((priority, item, max_index)) def pop(self) -> int: if self.is_empty(): raise IndexError(\\"pop from an empty stack\\") highest_priority_item = self.peek() # Get item with highest priority to remove self.stack = [ (pri, itm, idx) for (pri, itm, idx) in self.stack if itm != highest_priority_item ] return highest_priority_item def peek(self) -> int: if self.is_empty(): return None # Find the item with the highest priority and minimal index max_priority = max(self.stack, key=lambda x: (x[0], -x[2])) return max_priority[1] def is_empty(self) -> bool: return len(self.stack) == 0"},{"question":"# Coding Assessment Question: Binary Tree Level Order Traversal You are given a binary tree. Your task is to implement a function that returns the level order traversal of its nodes\' values from left to right, level by level. # Input Format The input is the root node of the binary tree. # Output Format Return a list of lists, where each list represents a level in the tree. # Constraints * The number of nodes in the binary tree is in the range [0, 2000]. * `-1000 <= Node.val <= 1000` # Example Example 1: ```python >> root = TreeNode(3) >> root.left = TreeNode(9) >> root.right = TreeNode(20) >> root.right.left = TreeNode(15) >> root.right.right = TreeNode(7) >> solution(root) ``` **Output:** ```python [[3], [9, 20], [15, 7]] ``` Example 2: ```python >> root = TreeNode(1) >> root.left = TreeNode(2) >> root.right = TreeNode(3) >> root.left.left = TreeNode(4) >> root.left.right = TreeNode(5) >> root.right.right = TreeNode(6) >> solution(root) ``` **Output:** ```python [[1], [2, 3], [4, 5, 6]] ``` # Function Signature ```python from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def solution(root: Optional[TreeNode]) -> List[List[int]]: pass ``` # Explanation: For the given binary tree: * Perform a level order traversal using breadth-first search (BFS). * Use a queue to keep track of nodes in each level. * Record the value of each node and group values by level. Good luck!","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def solution(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) level = [] for _ in range(level_size): node = queue.popleft() level.append(node.val) if node.left: queue.append(node.left) if node.right: queue.append(node.right) result.append(level) return result"},{"question":"# Coding Challenge: Digit Sum and Query Context: You have been tasked with implementing a set of functions that deal with digit sums and their properties. These operations are useful in digital root calculations, checksum algorithms, and other numeric applications. Implement these functions efficiently to handle large ranges and edge cases gracefully. # Function 1: Efficient Digit Sum Calculation **Description**: Write a function, `digit_sum(n: int) -> int`, that takes a positive integer `n` and returns the sum of its digits. - **Input**: An integer `n` (1 ≤ n ≤ 10^9) - **Output**: An integer representing the sum of the digits of `n` - **Constraints**: - Ensure your implementation handles large numbers efficiently. - No restrictions on the number of digits in the input. # Function 2: Sum of Digit Sums in Range **Description**: Write a function, `range_digit_sum(start: int, end: int) -> int`, that takes two integers `start` and `end`, and returns the sum of the digit sums for all numbers in that range (inclusive). - **Input**: Two integers `start` and `end` (1 ≤ start ≤ end ≤ 10^6) - **Output**: An integer representing the sum of the digit sums of all numbers between `start` and `end` (inclusive). ```python def digit_sum(n: int) -> int: Returns the sum of the digits of the given number n. pass # Implement the function def range_digit_sum(start: int, end: int) -> int: Returns the sum of digit sums for all numbers in the range [start, end]. pass # Implement the function # Example Usage: # digit_sum(12345) -> 15 # range_digit_sum(10, 12) -> digit_sum(10) + digit_sum(11) + digit_sum(12) = 1 + 2 + 3 = 6 ``` Notes: 1. Optimize your solutions to run efficiently for the given constraints. 2. Include necessary input validation and handle edge cases properly.","solution":"def digit_sum(n: int) -> int: Returns the sum of the digits of the given number n. return sum(int(digit) for digit in str(n)) def range_digit_sum(start: int, end: int) -> int: Returns the sum of digit sums for all numbers in the range [start, end]. total_sum = 0 for num in range(start, end + 1): total_sum += digit_sum(num) return total_sum"},{"question":"# Scenario You have been hired to develop a feature for an online book store. Users often search for consecutive series of book titles within the bookstore\'s database, which are stored in an unsorted order. Your task is to implement a function that finds the longest sequence of consecutive book titles based on their ISBN numbers. # Task Implement a function `longest_consecutive_series` to find the longest sequence of consecutive integers in an unsorted list representing ISBN numbers. # Function Signature ```python def longest_consecutive_series(arr: list) -> int: Finds the longest sequence of consecutive ISBN numbers in the array. :param arr: List of integers representing ISBN numbers. :return: Length of the longest consecutive sequence of ISBN numbers. ``` # Input - `arr`: A list of integers `arr`, where 0 ≤ len(arr) ≤ 10^5. # Output The function should return an integer representing the length of the longest consecutive sequence of ISBN numbers. # Constraints - Elements of `arr` are integers within the range 0 to 10^9. - Your implementation should be efficient in terms of both time and space. # Performance Requirements - The algorithm should run in average O(n) time. # Example ```python arr = [100, 4, 200, 1, 3, 2] print(longest_consecutive_series(arr)) # Output: 4 # Explanation: The longest consecutive sequence is [1, 2, 3, 4]. arr = [7, 6, 2, 3, 4, 1, 5] print(longest_consecutive_series(arr)) # Output: 7 # Explanation: The longest consecutive sequence is [1, 2, 3, 4, 5, 6, 7]. arr = [] print(longest_consecutive_series(arr)) # Output: 0 # Explanation: The list is empty, hence there is no sequence. ``` # Notes - Consider the properties of sets to help identify consecutive sequences more effectively. - Handle edge cases such as empty inputs or lists with all elements being the same.","solution":"def longest_consecutive_series(arr: list) -> int: Finds the longest sequence of consecutive ISBN numbers in the array. :param arr: List of integers representing ISBN numbers. :return: Length of the longest consecutive sequence of ISBN numbers. if not arr: return 0 num_set = set(arr) longest_streak = 0 for num in arr: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# SQL Query Optimization You are responsible for enhancing the performance of a SQL query that retrieves data from a large database with millions of records. The database contains a table `orders` which stores information about customer orders. # Objective Write an optimized SQL query to fetch the top 5 products that have generated the highest total revenue, along with their total revenue. # Input The `orders` table has the following columns: * `order_id` (int): The unique identifier of the order. * `product_id` (int): The unique identifier of the product. * `quantity` (int): The number of units of the product ordered. * `price` (float): The price per unit of the product. * `order_date` (date): The date when the order was placed. # Output Your query should return a result set with the following columns: * `product_id` (int): The unique identifier of the product. * `total_revenue` (float): The total revenue generated by this product. # Constraints * Ensure that the query is optimized for performance on large datasets. * Use appropriate indexing if necessary to enhance query performance. * Remember to handle any potential edge cases, such as products with no orders. # Example ```sql SELECT product_id, SUM(quantity * price) AS total_revenue FROM orders GROUP BY product_id ORDER BY total_revenue DESC LIMIT 5; ``` Ensure your SQL query follows best practices for writing efficient queries, handles large volumes of data seamlessly, and returns accurate results.","solution":"def get_top_products_query(): Generates the optimized SQL query to fetch the top 5 products that have generated the highest total revenue, along with their total revenue. query = SELECT product_id, SUM(quantity * price) AS total_revenue FROM orders GROUP BY product_id ORDER BY total_revenue DESC LIMIT 5; return query"},{"question":"Graph Traversal Problem # Problem Statement You are required to implement the Breadth-First Search (BFS) algorithm to traverse a graph. Given an undirected graph represented as an adjacency list and a starting node, your task is to return the order of nodes visited using the BFS traversal method. # Function Signature ```python def bfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]: ``` # Input * `graph`: A `Dict[int, List[int]]` representing the adjacency list of the undirected graph. Each key is a node, and the corresponding value is a list of nodes connected to the key node. * `start`: An `int` representing the starting node for the BFS traversal. # Output * Returns a `List[int]` representing the order of nodes visited in the BFS traversal. # Constraints * The graph is guaranteed to have between `1` and `1000` nodes. * Each node value will be an integer, and all node values will be unique. * `1 <= start <= 1000` and the `start` node is guaranteed to exist in the graph. # Performance Requirements * The implementation should run efficiently for graphs with up to 1000 nodes and edges (time complexity of O(V + E) and space complexity of O(V)). # Example ```python # Example 1 graph = { 1: [2, 3], 2: [1, 4], 3: [1, 4, 5], 4: [2, 3, 5], 5: [3, 4] } start = 1 assert bfs_traversal(graph, start) == [1, 2, 3, 4, 5] # Example 2 graph = { 1: [2], 2: [1, 3, 4], 3: [2], 4: [2, 5], 5: [4] } start = 2 assert bfs_traversal(graph, start) == [2, 1, 3, 4, 5] ``` # Notes * Consider edge cases such as a graph with a single node or a graph that is disconnected. * Ensure the BFS implementation correctly handles cycles in the graph by tracking visited nodes. * You may use a queue data structure to facilitate the BFS traversal and ensure the correct order of node visits.","solution":"from collections import deque from typing import Dict, List def bfs_traversal(graph: Dict[int, List[int]], start: int) -> List[int]: Perform BFS traversal on the graph starting from the start node. Args: graph: Dict[int, List[int]] - adjacency list representing the undirected graph. start: int - the starting node for BFS traversal. Returns: List[int] - the order of nodes visited in BFS traversal. visited = set() queue = deque([start]) bfs_order = [] while queue: node = queue.popleft() if node not in visited: visited.add(node) bfs_order.append(node) # Add all unvisited neighbors to the queue for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return bfs_order"},{"question":"# Coding Challenge: Implementing Inorder Traversal on a Binary Search Tree with Iteration You are given a binary search tree (BST) and your task is to implement an iterative inorder traversal. Inorder traversal of a BST visits the nodes in ascending order: left subtree, root node, right subtree. # Task **Function to Implement:** ```python def inorder_traversal(root): Given the root of a Binary Search Tree (BST), perform an iterative inorder traversal and return the elements in a list. Parameters: root (TreeNode): The root node of the BST. Returns: List[int]: The list of elements in inorder sequence. pass ``` **Expected Input and Output:** - **Input**: - `root`: A `TreeNode` object representing the root of a Binary Search Tree. - **Output**: - A list of integers representing the elements of the tree in inorder sequence. # Constraints - The BST can have any number of nodes, from 0 to a large number. # Example ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example tree construction root = TreeNode(4) root.left = TreeNode(2) root.right = TreeNode(6) root.left.left = TreeNode(1) root.left.right = TreeNode(3) root.right.left = TreeNode(5) root.right.right = TreeNode(7) print(inorder_traversal(root)) # Output should be [1, 2, 3, 4, 5, 6, 7] ``` # Implementation Notes - You should use an iterative approach without using recursion. - Utilize a stack to help you traverse the tree iteratively. - Make sure to handle the case where the tree is empty (i.e., the root node is `None`).","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def inorder_traversal(root): Given the root of a Binary Search Tree (BST), perform an iterative inorder traversal and return the elements in a list. Parameters: root (TreeNode): The root node of the BST. Returns: List[int]: The list of elements in inorder sequence. stack, result = [], [] current = root while stack or current: # Traverse to the leftmost node while current: stack.append(current) current = current.left # Current is None at this point current = stack.pop() result.append(current.val) # Visit the right subtree current = current.right return result"},{"question":"# Problem Statement You are provided with an implementation of a queue. A queue is a data structure that supports First In, First Out (FIFO) operations, allowing you to add (`enqueue`) and remove (`dequeue`) elements from the front of the queue. The current implementation includes basic queue operations such as `enqueue`, `dequeue`, `peek`, `is_empty`, `is_full`, `size`, and `__contains__`. # Task Your task is to implement an additional method called `rotate_queue` in the `Queue` class. This method should rotate the elements in the queue by a given number of positions. A positive rotation will move elements from the front to the back, while a negative rotation will move elements from the back to the front. The operation should be carried out in place without using any additional data structures or collections, beyond the temporary variables required for the operations. # Method Signature ```python def rotate_queue(self, positions: int) -> None: Rotate the elements in the queue by the given number of positions. >>> Q = Queue() >>> Q.enqueue(1) >>> Q.enqueue(2) >>> Q.enqueue(3) >>> Q.enqueue(4) >>> Q.rotate_queue(2) >>> print(Q) [3, 4, 1, 2] >>> Q.rotate_queue(-1) >>> print(Q) [2, 3, 4, 1] ``` # Constraints * The queue may contain up to `limit` elements. * The available methods of the `Queue` class (i.e., `enqueue`, `dequeue`, `size`, etc.) are the only allowed interactions with the queue. * You must not use any other data structures (such as lists, stacks, or another queue) for this task. * If `positions` is greater than the size of the queue, continue rotating from the beginning. # Expectations * The `rotate_queue` method should handle both positive and negative rotations. * Ensure that the positions parameter is correctly accounted for (i.e., rotations greater than the size of the queue should wrap around). * The queue state should accurately reflect the rotation with no elements lost or duplicated. * The efficiency of the rotation should be reasonable given the constraints. # Example ```python Q = Queue() Q.enqueue(1) Q.enqueue(2) Q.enqueue(3) Q.enqueue(4) Q.rotate_queue(2) assert str(Q) == \\"[3, 4, 1, 2]\\" Q.rotate_queue(-1) assert str(Q) == \\"[2, 3, 4, 1]\\" ``` Implement the `rotate_queue` method below: ```python def rotate_queue(self, positions: int) -> None: # Your code goes here ```","solution":"class Queue: def __init__(self, limit=100): self.queue = [] self.limit = limit def enqueue(self, item): if len(self.queue) < self.limit: self.queue.append(item) def dequeue(self): if not self.is_empty(): return self.queue.pop(0) def peek(self): if not self.is_empty(): return self.queue[0] def is_empty(self): return len(self.queue) == 0 def is_full(self): return len(self.queue) == self.limit def size(self): return len(self.queue) def __contains__(self, item): return item in self.queue def __str__(self): return str(self.queue) def rotate_queue(self, positions: int) -> None: Rotate the elements in the queue by the given number of positions. if self.is_empty(): return n = self.size() positions = positions % n # Normalize positions if positions > 0: for _ in range(positions): self.enqueue(self.dequeue()) else: for _ in range(-positions): self.queue.insert(0, self.queue.pop()) # The queue class and rotate_queue method are now defined."},{"question":"# Task You need to implement a `MultiStack` class that can efficiently maintain and manage multiple stacks within a single array. The class should allow specifying the number of stacks and their maximum combined capacity at initialization. # Function Signature ```python class MultiStack: def __init__(self, num_stacks: int, capacity: int): pass def push(self, stack_num: int, value: int): pass def pop(self, stack_num: int) -> int: pass def peek(self, stack_num: int) -> int: pass def is_empty(self, stack_num: int) -> bool: pass def is_full(self, stack_num: int) -> bool: pass ``` # Requirements 1. **Initialization**: - The constructor should accept `num_stacks`, indicating the number of stacks. - The constructor should accept `capacity`, the maximum combined capacity for all the stacks. - Initialize the internal structures to support the given number of stacks and capacity. 2. **Push**: - Accepts a stack number (from `0` to `num_stacks - 1`) and a value to push onto the specified stack. - Should raise `ValueError` if an invalid stack number is provided. - Should raise `OverFlowError` if the specified stack is full or if the total capacity has been exceeded. 3. **Pop**: - Accepts a stack number (from `0` to `num_stacks - 1`) and removes and returns the top value from the specified stack. - Should raise `ValueError` if an invalid stack number is provided. - Should raise `UnderFlowError` if the specified stack is empty. 4. **Peek**: - Accepts a stack number (from `0` to `num_stacks - 1`) and returns the top value of the specified stack without removing it. - Should raise `ValueError` if an invalid stack number is provided. - Should raise `UnderFlowError` if the specified stack is empty. 5. **Is Empty**: - Accepts a stack number (from `0` to `num_stacks - 1`) and returns `True` if the specified stack is empty, otherwise `False`. 6. **Is Full**: - Accepts a stack number (from `0` to `num_stacks - 1`) and returns `True` if the specified stack is full, otherwise `False`. # Example Usage ```python multi_stack = MultiStack(3, 10) multi_stack.push(0, 5) multi_stack.push(0, 6) multi_stack.push(1, 7) multi_stack.push(1, 10) multi_stack.push(2, 12) print(multi_stack.peek(0)) # Output: 6 print(multi_stack.pop(1)) # Output: 10 print(multi_stack.is_empty(2)) # Output: False print(multi_stack.is_full(1)) # Output: False ``` # Constraints and Limits - Each stack can only expand within the bounds of the shared capacity. - The stack numbers range from 0 to `num_stacks - 1`. - Any invalid operations (e.g., invalid stack number, overflows, underflows) should appropriately raise custom exceptions (`ValueError`, `OverFlowError`, `UnderFlowError`).","solution":"class OverFlowError(Exception): pass class UnderFlowError(Exception): pass class MultiStack: def __init__(self, num_stacks: int, capacity: int): self.num_stacks = num_stacks self.capacity = capacity self.values = [None] * capacity self.sizes = [0] * num_stacks self.starts = [i * (capacity // num_stacks) for i in range(num_stacks)] self.ends = [(i + 1) * (capacity // num_stacks) for i in range(num_stacks)] def push(self, stack_num: int, value: int): if stack_num < 0 or stack_num >= self.num_stacks: raise ValueError(\\"Invalid stack number\\") if self.is_full(stack_num): raise OverFlowError(\\"Stack is full\\") idx = self.starts[stack_num] + self.sizes[stack_num] self.values[idx] = value self.sizes[stack_num] += 1 def pop(self, stack_num: int) -> int: if stack_num < 0 or stack_num >= self.num_stacks: raise ValueError(\\"Invalid stack number\\") if self.is_empty(stack_num): raise UnderFlowError(\\"Stack is empty\\") idx = self.starts[stack_num] + self.sizes[stack_num] - 1 value = self.values[idx] self.values[idx] = None self.sizes[stack_num] -= 1 return value def peek(self, stack_num: int) -> int: if stack_num < 0 or stack_num >= self.num_stacks: raise ValueError(\\"Invalid stack number\\") if self.is_empty(stack_num): raise UnderFlowError(\\"Stack is empty\\") idx = self.starts[stack_num] + self.sizes[stack_num] - 1 return self.values[idx] def is_empty(self, stack_num: int) -> bool: if stack_num < 0 or stack_num >= self.num_stacks: raise ValueError(\\"Invalid stack number\\") return self.sizes[stack_num] == 0 def is_full(self, stack_num: int) -> bool: if stack_num < 0 or stack_num >= self.num_stacks: raise ValueError(\\"Invalid stack number\\") return self.sizes[stack_num] >= (self.ends[stack_num] - self.starts[stack_num])"},{"question":"Binary Tree Zigzag Level Order Traversal Given a binary tree, you need to perform a zigzag level order traversal of its nodes\' values. (i.e., from left to right, then right to left for the next level, and alternate between). # Task 1. **Implement the `zigzagLevelOrder` function**: Develop a function that returns the zigzag level order traversal of a binary tree. 2. **Ensure Efficiency**: The function should handle large trees efficiently and perform the traversal in O(N) time complexity, where N is the number of nodes in the tree. 3. **Handle Edge Cases**: Consider cases where the tree is empty or has only one node. # Requirements: - You should use a queue (or deque) to facilitate the breadth-first traversal. - Ensure that you invert the traversal direction at every level. # Input: - A binary tree with `TreeNode` structure provided as follows: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` # Output: - A list of lists where each sublist contains the nodes\' values in zigzag order for each level. # Function Signature: ```python def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: pass ``` # Example: ```python # Provided TreeNode class for creating binary trees class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Example usage: # Constructing the following binary tree. # 3 # / # 9 20 # / # 15 7 root = TreeNode(3) root.left = TreeNode(9) root.right = TreeNode(20) root.right.left = TreeNode(15) root.right.right = TreeNode(7) >>> zigzagLevelOrder(root) [[3], [20, 9], [15, 7]] ``` **Note**: - Your solution should efficiently handle trees with varying structures. - Ensure proper edge case handling and robust implementation.","solution":"from collections import deque from typing import List, Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def zigzagLevelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] results = [] queue = deque([root]) left_to_right = True while queue: level_nodes = [] for _ in range(len(queue)): node = queue.popleft() if left_to_right: level_nodes.append(node.val) else: level_nodes.insert(0, node.val) # insert at beginning for reverse order if node.left: queue.append(node.left) if node.right: queue.append(node.right) results.append(level_nodes) left_to_right = not left_to_right return results"},{"question":"Scenario: You are developing an inventory management system for an e-commerce platform. One of the key components is an efficient sorting mechanism that ranks products based on their priority and price. Products are represented as tuples containing their name, priority, and price. The list should be sorted first by priority in descending order, and then by price in ascending order for products with the same priority. # Question: Implement a function that sorts a list of products based on the specified criteria. Ensure that the function outputs the sorted list correctly. # Function Signature: * **function name**: `sort_products` * **inputs**: - `products` (List[Tuple[str, int, float]]): A list of tuples where each tuple contains the product name (str), priority (int), and price (float). * **outputs**: - `sorted_products` (List[Tuple[str, int, float]]): A list of tuples sorted by the specified criteria. # Constraints: 1. The number of products (N) will be between 1 to 1000 (inclusive). 2. Priorities are integers ranging from 1 (lowest) to 10 (highest). 3. Prices are non-negative floats. # Example: ```python # Example usage: products = [ (\\"Product_A\\", 3, 19.99), (\\"Product_B\\", 1, 9.99), (\\"Product_C\\", 3, 17.49), (\\"Product_D\\", 2, 5.99) ] sorted_products = sort_products(products) print(sorted_products) # Expected Output: # [(\'Product_C\', 3, 17.49), (\'Product_A\', 3, 19.99), (\'Product_D\', 2, 5.99), (\'Product_B\', 1, 9.99)] ``` # Additional Notes: - Handle edge cases where there may be products with the same priority and price. - Ensure the implementation is efficient and can handle the upper limit of products within reasonable time constraints. - Validate inputs to ensure they follow the expected format and constraints.","solution":"from typing import List, Tuple def sort_products(products: List[Tuple[str, int, float]]) -> List[Tuple[str, int, float]]: Sort the products list first by priority in descending order, and then by price in ascending order for products with the same priority. :param products: List of tuples, where each tuple contains (product name, priority, price). :returns: Sorted list of products based on the specified criteria. return sorted(products, key=lambda x: (-x[1], x[2]))"},{"question":"You are asked to implement a function to search for a target value within a rotated sorted array of integers. The function should efficiently handle cases of large datasets and ensure optimal search performance under the given constraints. # Scenario You are part of a team developing a search feature for an application that processes rotated sorted lists. The lists are guaranteed to be initially sorted in ascending order but then rotated at some unknown pivot. Your task is to locate the target value within the array using the most efficient approach possible. # Function Signature ```python def search_in_rotated_array(array: List[int], target: int) -> int: pass ``` # Input * `array`: A list of integers that has been rotated at some pivot point. * `target`: The integer value to search for within the `array`. # Output * The function should return the index of the `target` value if found, otherwise, return -1 if the `target` is not present in `array`. # Constraints * The list will contain distinct integers. * Consider edge cases such as empty lists or the target value being at the rotation pivot. * Aim for a time complexity of O(log n). # Examples ```python search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 0) # Output: 4 search_in_rotated_array([4, 5, 6, 7, 0, 1, 2], 3) # Output: -1 search_in_rotated_array([1], 0) # Output: -1 ``` # Performance Requirements * The algorithm should achieve a logarithmic time complexity O(log n). # Notes * The array is rotated at some pivot such that the two subarrays are individually sorted. * Think about leveraging binary search and its properties to develop an efficient solution. * Consider handling the edge cases specifically and ensure to test with various datasets for robustness. Happy coding!","solution":"from typing import List def search_in_rotated_array(array: List[int], target: int) -> int: Returns the index of the target value in a rotated sorted array, using binary search for O(log n) time complexity. If the target is not found, return -1. if not array: return -1 left, right = 0, len(array) - 1 while left <= right: mid = (left + right) // 2 if array[mid] == target: return mid # the left half is sorted if array[left] <= array[mid]: if array[left] <= target < array[mid]: right = mid - 1 else: left = mid + 1 # the right half is sorted else: if array[mid] < target <= array[right]: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Rotate Image Clockwise Context: In a graphics editing program, one common operation is rotating an image by 90 degrees clockwise. You have been assigned to develop this feature for a new image manipulation tool. Task: Implement a function `rotate_image_clockwise(image: List[List[Tuple[int, int, int]]]) -> List[List[Tuple[int, int, int]]]` that rotates a given image 90 degrees clockwise. The function should take a 2D list of tuples representing the pixel values of the image and return the rotated image. The input image is represented as a 2D list of tuples where each tuple contains three integers representing the Red, Green, and Blue color channels of a pixel (R, G, B). Rotation Steps: To rotate the image by 90 degrees clockwise: 1. Transpose the matrix. 2. Reverse each row of the transposed matrix. Input: - `image`: A 2D list of tuples where each tuple contains three integers representing the Red, Green, and Blue color channels of a pixel. The dimensions of the list are `M x N`. Output: - Should return the rotated image as a 2D list of tuples with new pixel positions. Constraints: - The input image dimensions are `M x N` where `1 <= M, N <= 1000`. - Each pixel value is an integer in the range 0 to 255. Example: ```python image = [ [(0, 0, 0), (1, 1, 1), (2, 2, 2)], [(3, 3, 3), (4, 4, 4), (5, 5, 5)] ] rotate_image_clockwise(image) Output: [ [(3, 3, 3), (0, 0, 0)], [(4, 4, 4), (1, 1, 1)], [(5, 5, 5), (2, 2, 2)] ] ``` Notes: - Ensure the function handles both small and large images within the given constraints efficiently. - Consider edge cases where the image might have only one row or one column.","solution":"from typing import List, Tuple def rotate_image_clockwise(image: List[List[Tuple[int, int, int]]]) -> List[List[Tuple[int, int, int]]]: Rotates the given image (2D list of tuples) 90 degrees clockwise. Args: image: A 2D list of tuples where each tuple contains three integers representing the Red, Green, and Blue color channels of a pixel. Returns: rotated_image: The rotated image as a 2D list of tuples with new pixel positions. # Step 1: Transpose the matrix transposed_image = list(zip(*image)) # Step 2: Reverse each row of the transposed matrix rotated_image = [list(row[::-1]) for row in transposed_image] return rotated_image"},{"question":"# Problem Statement **Subsequence Sum Difference Finder** Given an array of positive integers, write a function that finds a subsequence where the difference between the maximum and minimum elements in the subsequence is maximized. The function should return the maximum difference found. A subsequence is a sequence derived from the array by deleting some or none of the elements without changing the order of the remaining elements. Implement the function `max_subsequence_diff(arr: List[int]) -> int` that encapsulates the above logic. # Input - `arr`: A list of positive integers (1 <= len(arr) <= 10^5, 1 <= arr[i] <= 10^9). # Output - Returns an integer that is the maximum difference between the maximum and minimum elements of any subsequence in the input list. # Constraints - 1 <= len(arr) <= 10^5 - 1 <= arr[i] <= 10^9 # Performance Requirements - The implementation should be optimized for performance with consideration for the given constraints. # Example ```python >>> max_subsequence_diff([1, 2, 3, 4]) 3 >>> max_subsequence_diff([10, 20, 30, 40]) 30 >>> max_subsequence_diff([100, 200, 300, 400, 500]) 400 ``` # Notes - The subsequence can be formed by picking any elements from the array without regard to their adjacency. - The function should handle large input sizes efficiently. - Make sure to test edge cases, such as arrays with all identical values or arrays with only two elements.","solution":"from typing import List def max_subsequence_diff(arr: List[int]) -> int: Returns the maximum difference between the maximum and minimum elements of any subsequence in the input list. if not arr: return 0 max_elem = max(arr) min_elem = min(arr) return max_elem - min_elem"},{"question":"K-Means Clustering for Customer Segmentation You are given a dataset of customer data with various attributes such as age, income, spending score, etc. Your task is to implement the K-Means clustering algorithm to segment the customers into `k` distinct groups based on their attributes. **Function Signature**: ```python def k_means_clustering(data: np.ndarray, k: int, max_iter: int = 300) -> Tuple[np.ndarray, np.ndarray]: ``` **Input**: - `data`: A 2D numpy array of shape `(n_samples, n_features)`, where `n_samples` is the number of customers and `n_features` is the number of attributes for each customer. - `k`: An integer representing the number of clusters. - `max_iter`: An optional integer representing the maximum number of iterations. Default is 300. **Output**: - A tuple containing: - `centroids`: A 2D numpy array of shape `(k, n_features)` containing the final centroids of the clusters. - `labels`: A 1D numpy array of shape `(n_samples,)` where each element is the cluster label (ranging from `0` to `k-1`) for the corresponding customer. **Constraints**: - Ensure `k` is a positive integer less than or equal to the number of samples. - All inputs must be provided in the correct formats and will always contain valid data. - Performance is crucial, optimize matrix operations as much as possible. **Details**: - Initialize the centroids by randomly selecting `k` unique samples from the dataset. - Iterate the assignment and update steps until convergence or the maximum number of iterations is reached. - The assignment step involves assigning each sample to the nearest centroid. - The update step involves recalculating the centroids as the mean of all samples assigned to each cluster. # Example ```python import numpy as np data = np.array([ [25, 50000], [34, 60000], [22, 52000], [27, 58000], [30, 61000], [26, 50000], [29, 69000], [35, 72000] ]) k = 3 centroids, labels = k_means_clustering(data, k) print(\\"Centroids:n\\", centroids) print(\\"Labels:n\\", labels) ``` Write your implementation for the `k_means_clustering` function below, ensuring adherence to the above specifications and requirements.","solution":"import numpy as np from typing import Tuple def k_means_clustering(data: np.ndarray, k: int, max_iter: int = 300) -> Tuple[np.ndarray, np.ndarray]: def initialize_centroids(data, k): indices = np.random.choice(data.shape[0], k, replace=False) return data[indices] def compute_distances(data, centroids): distances = np.zeros((data.shape[0], centroids.shape[0])) for i in range(centroids.shape[0]): distances[:, i] = np.linalg.norm(data - centroids[i], axis=1) return distances def assign_clusters(distances): return np.argmin(distances, axis=1) def compute_centroids(data, labels, k): centroids = np.zeros((k, data.shape[1])) for i in range(k): centroids[i] = data[labels == i].mean(axis=0) return centroids centroids = initialize_centroids(data, k) for i in range(max_iter): old_centroids = centroids distances = compute_distances(data, centroids) labels = assign_clusters(distances) centroids = compute_centroids(data, labels, k) if np.all(centroids == old_centroids): # If centroids do not change, break break return centroids, labels"},{"question":"# Coding Assessment Question You are given a string `s` consisting of lowercase English letters, and a list of words `words`, where each word is a string consisting of lowercase English letters. Your task is to implement a function that counts how many words from the list can be formed by deleting some characters of the string `s` without changing the order of the remaining characters. Function Signature ```python def count_matching_words(s: str, words: List[str]) -> int: ``` Input - `s` (str): A string consisting of lowercase English letters. - `words` (List[str]): A list of strings, each containing lowercase English letters. Output - int: The number of words from the list that can be formed by deleting some characters from `s` without changing the order of the remaining characters. Constraints 1. The string `s` will have a length of at most `1000`. 2. The list `words` will have at most `1000` words. 3. Each word in the list will have a length of at most `100`. Example ```python assert count_matching_words(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\", \\"plea\\"]) == 3 assert count_matching_words(\\"abpcplea\\", [\\"a\\", \\"b\\", \\"c\\", \\"d\\"]) == 3 assert count_matching_words(\\"abcdefgh\\", [\\"abc\\", \\"bcd\\", \\"cde\\", \\"def\\"]) == 4 assert count_matching_words(\\"abcdefgh\\", [\\"xyz\\", \\"ghijk\\", \\"mnop\\"]) == 0 ``` Explanation Given a string `s` and a list of words, the `count_matching_words` function checks for each word if it can be formed by deleting some characters of `s` without changing the order of the remaining characters: - \\"ale\\" can be formed from \\"abpcplea\\" by deleting \'b\', \'p\', \'c\', \'p\', and \'a\'. - \\"apple\\" can be formed from \\"abpcplea\\" by deleting \'b\' and \'c\'. - \\"monkey\\" cannot be formed from \\"abpcplea\\". - \\"plea\\" can be formed from \\"abpcplea\\". This problem is intended to test your ability to work with string manipulations and sequences, ensuring a consistent approach to solving substring and subsequence problems.","solution":"from typing import List def count_matching_words(s: str, words: List[str]) -> int: def is_subsequence(word: str, s: str) -> bool: it = iter(s) return all(char in it for char in word) return sum(1 for word in words if is_subsequence(word, s))"},{"question":"# Array Rotation Checker Problem Statement Write a function `is_rotation` that takes two lists, `list1` and `list2`, and returns `True` if `list2` is a rotation of `list1`. Otherwise, it returns `False`. If either input is not a list, the function should raise a `TypeError`. Constraints 1. Both `list1` and `list2` will contain non-negative integers. 2. The function must handle cases efficiently, especially for large lists. Input * Two lists of integers, `list1` and `list2`. Output * Returns `True` if `list2` is a rotation of `list1`. * Returns `False` otherwise. * Raises a `TypeError` if either input is not a list. Example ```python is_rotation([1, 2, 3, 4], [3, 4, 1, 2]) # Returns: True is_rotation([1, 2, 3], [1, 2, 3]) # Returns: True is_rotation([1, 2, 3], [2, 3, 4]) # Returns: False is_rotation([1, 2, 3, 4], [4, 3, 2, 1]) # Returns: False is_rotation([1, 2, 3], \'2, 3, 1\') # Raises: TypeError ``` Note * A rotation means that shifting the elements of `list1` some number of positions to the left or right results in `list2`. * Consider edge cases such as when one list is empty, or when both lists are significantly large. * Efficient handling of large lists will be crucial for the performance of your implementation.","solution":"def is_rotation(list1, list2): Returns True if list2 is a rotation of list1. Otherwise, returns False. Raises a TypeError if either input is not a list. if not isinstance(list1, list) or not isinstance(list2, list): raise TypeError(\\"Both inputs must be lists\\") if len(list1) != len(list2): return False if not list1: return True concatenated = list1 + list1 return \'\'.join(map(str, list2)) in \'\'.join(map(str, concatenated))"},{"question":"# Scenario A company wants to improve its online product recommendation system. The system currently recommends products based on the Jaccard Similarity between customer purchase sets. The Jaccard Similarity is a metric used to measure the similarity between two sets. It is defined as the size of the intersection divided by the size of the union of the sets. **Your Task**: Implement a function that calculates the Jaccard Similarity between two customers\' purchase histories. # Input Format You will be given: 1. A list of strings `customer_purchases1` representing the first customer\'s purchase history. 2. A list of strings `customer_purchases2` representing the second customer\'s purchase history. # Output Format Your program should return a float representing the Jaccard Similarity between the two customers\' purchase histories, rounded to 4 decimal places. # Constraints 1. 0 <= len(customer_purchases1), len(customer_purchases2) <= 1000 2. Each string in the lists represents a unique product ID. # Example ```python customer_purchases1 = [\\"apple\\", \\"banana\\", \\"cherry\\"] customer_purchases2 = [\\"banana\\", \\"cherry\\", \\"date\\", \\"fig\\"] ``` Expected output: ``` 0.4 ``` # Function Signature ```python def jaccard_similarity(customer_purchases1: List[str], customer_purchases2: List[str]) -> float: # your code here ``` # Notes * Ensure your code handles edge cases such as empty purchase histories for either or both customers. * Pay attention to the handling of large input sizes and ensure efficiency in computation.","solution":"from typing import List def jaccard_similarity(customer_purchases1: List[str], customer_purchases2: List[str]) -> float: Calculate the Jaccard Similarity between two customers\' purchase histories. Args: customer_purchases1 (List[str]): First customer\'s purchase history. customer_purchases2 (List[str]): Second customer\'s purchase history. Returns: float: Jaccard similarity coefficient rounded to 4 decimal places. set1 = set(customer_purchases1) set2 = set(customer_purchases2) intersection = set1.intersection(set2) union = set1.union(set2) if not union: return 0.0 similarity = len(intersection) / len(union) return round(similarity, 4)"},{"question":"**Objective**: Write a function that rearranges a linked list such that all even numbers appear before all odd numbers, while maintaining the original relative order of the elements within each group. **Scenario**: Suppose you are given a singly linked list where each node contains an integer. To optimize certain computations, you need to rearrange the list in such a way that all nodes containing even numbers come before all nodes containing odd numbers. The relative order of even and odd elements must remain the same as in the original list. **Function Signature**: ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_list(head: ListNode) -> ListNode: Rearranges the linked list such that all even numbers appear before all odd numbers. Parameters: head (ListNode): The head node of the linked list. Returns: ListNode: The head of the rearranged linked list. Examples: Example 1: Input: head = [1, 2, 3, 4, 5, 6] Output: [2, 4, 6, 1, 3, 5] Example 2: Input: head = [10, 9, 8, 7, 6, 5] Output: [10, 8, 6, 9, 7, 5] pass ``` **Constraints**: 1. The linked list can have any number of nodes. 2. The values in the linked list vary and may include negative or positive integers. **Requirements**: 1. The function should maintain the relative order of even and odd elements. 2. The function should exhibit an average time complexity of O(n). **Examples**: ```python # Example 1 head = ListNode(1, ListNode(2, ListNode(3, ListNode(4, ListNode(5, ListNode(6)))))) result = rearrange_list(head) # Expected Output: 2 -> 4 -> 6 -> 1 -> 3 -> 5 # Example 2 head = ListNode(10, ListNode(9, ListNode(8, ListNode(7, ListNode(6, ListNode(5)))))) result = rearrange_list(head) # Expected Output: 10 -> 8 -> 6 -> 9 -> 7 -> 5 ``` **Hint**: Consider iterating through the list once to partition the nodes into two separate lists: one for even values and one for odd values, and then merge them to get the desired arrangement.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def rearrange_list(head: ListNode) -> ListNode: Rearranges the linked list such that all even numbers appear before all odd numbers. Parameters: head (ListNode): The head node of the linked list. Returns: ListNode: The head of the rearranged linked list. if not head: return None even_head = even_tail = ListNode(0) odd_head = odd_tail = ListNode(0) current = head while current: if current.value % 2 == 0: even_tail.next = current even_tail = even_tail.next else: odd_tail.next = current odd_tail = odd_tail.next current = current.next even_tail.next = odd_head.next odd_tail.next = None return even_head.next"},{"question":"# Coding Assessment Question In data processing, an important task is merging two sorted lists into a single sorted list. This operation is foundational in algorithms such as Merge Sort and has applications in databases, file merging, and more. You are to create a function that efficiently merges two sorted lists while maintaining the sorted order. Write a function `merge_sorted_lists` that takes two sorted lists and returns a single sorted list containing all the elements from both input lists. Ensure the function operates efficiently, leveraging the fact that the input lists are already sorted. **Function Signature**: ```python def merge_sorted_lists(list1, list2): pass ``` # Input and Output - **Input**: - `list1` - A list of integers sorted in non-decreasing order. - `list2` - A list of integers sorted in non-decreasing order. - **Output**: - Returns a list containing all the integers from `list1` and `list2`, sorted in non-decreasing order. # Constraints - Both `list1` and `list2` will have lengths between 0 and 100,000. - The elements of both lists will be integers where -1,000,000 ≤ element ≤ 1,000,000. - You may not use built-in sorting functions. # Requirements & Performance - The function should have a time complexity of O(n + m), where n and m are the lengths of the input lists. - Ensure the function handles edge cases such as one or both lists being empty. # Example ```python # Example 1 list1 = [1, 3, 5] list2 = [2, 4, 6] print(merge_sorted_lists(list1, list2)) # Expected Output: [1, 2, 3, 4, 5, 6] # Example 2 list1 = [1, 2, 4] list2 = [1, 3, 5] print(merge_sorted_lists(list1, list2)) # Expected Output: [1, 1, 2, 3, 4, 5] # Example 3 list1 = [] list2 = [1, 2, 3] print(merge_sorted_lists(list1, list2)) # Expected Output: [1, 2, 3] # Example 4 list1 = [1, 2, 3] list2 = [] print(merge_sorted_lists(list1, list2)) # Expected Output: [1, 2, 3] ``` Implement the `merge_sorted_lists` function ensuring it is efficient and handles edge cases appropriately.","solution":"def merge_sorted_lists(list1, list2): Merges two sorted lists into a single sorted list. Parameters: list1 (list of int): A sorted list. list2 (list of int): Another sorted list. Returns: list of int: A merged and sorted list containing all elements from list1 and list2. merged_list = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] < list2[j]: merged_list.append(list1[i]) i += 1 else: merged_list.append(list2[j]) j += 1 # If there are remaining elements in list1 while i < len(list1): merged_list.append(list1[i]) i += 1 # If there are remaining elements in list2 while j < len(list2): merged_list.append(list2[j]) j += 1 return merged_list"},{"question":"# Question: Calculate Parabolic Motion Parameters Write a Python function to calculate the maximum height (H) and the horizontal range (R) of a projectile given its initial speed (v) and the angle of projection (θ) from the horizontal plane. The maximum height can be calculated using the formula: [ H = frac{v^2 sin^2(theta)}{2g} ] The horizontal range can be calculated using: [ R = frac{v^2 sin(2theta)}{g} ] Where ( g ) is the acceleration due to gravity, approximately ( 9.81 , text{m/s}^2 ). # Function Signature: ```python def calculate_parabolic_motion(initial_speed: float, angle: float) -> dict[str, float]: pass ``` # Input: - `initial_speed` (float): The initial speed (v) of the projectile in meters per second (m/s), must be greater than 0. - `angle` (float): The angle of projection (θ) in degrees, must be between 0 and 90. # Output: - A dictionary with two key-value pairs: - `\'maximum_height\'`: The maximum height (H) in meters (m). - `\'horizontal_range\'`: The horizontal range (R) in meters (m). # Constraints: - `initial_speed` should be positive. - `angle` should be between 0 and 90 degrees. # Example: ```python >>> calculate_parabolic_motion(20.0, 45.0) {\'maximum_height\': 10.19367816091954, \'horizontal_range\': 40.7754713824878} >>> calculate_parabolic_motion(30.0, 30.0) {\'maximum_height\': 11.49425287356322, \'horizontal_range\': 79.51662716352418} ``` # Notes: - Ensure to handle edge cases where the `initial_speed` is zero or negative, or the `angle` is out of range by raising a `ValueError` with an appropriate message. - Use the math module for trigonometric functions and conversions, as the angle is given in degrees. - The calculations should ensure precision floating-point arithmetic. ```python import math def calculate_parabolic_motion(initial_speed: float, angle: float) -> dict[str, float]: if initial_speed <= 0: raise ValueError(\\"Initial speed must be greater than 0\\") if not (0 <= angle <= 90): raise ValueError(\\"Angle must be between 0 and 90 degrees\\") g = 9.81 # Acceleration due to gravity in m/s^2 angle_rad = math.radians(angle) maximum_height = (initial_speed**2 * math.sin(angle_rad)**2) / (2 * g) horizontal_range = (initial_speed**2 * math.sin(2 * angle_rad)) / g return { \'maximum_height\': maximum_height, \'horizontal_range\': horizontal_range } ```","solution":"import math def calculate_parabolic_motion(initial_speed: float, angle: float) -> dict[str, float]: if initial_speed <= 0: raise ValueError(\\"Initial speed must be greater than 0\\") if not (0 <= angle <= 90): raise ValueError(\\"Angle must be between 0 and 90 degrees\\") g = 9.81 # Acceleration due to gravity in m/s^2 angle_rad = math.radians(angle) maximum_height = (initial_speed**2 * math.sin(angle_rad)**2) / (2 * g) horizontal_range = (initial_speed**2 * math.sin(2 * angle_rad)) / g return { \'maximum_height\': maximum_height, \'horizontal_range\': horizontal_range }"},{"question":"# Problem Statement Write a function `is_prime(num: int) -> bool` that determines if a given integer `num` is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. # Function Signature ```python def is_prime(num: int) -> bool: ``` # Input * An integer `num` (1 <= num <= 10^6). # Output * A boolean value: `True` if `num` is a prime number, `False` otherwise. # Constraints * The function should be efficient and optimized for large values up to `10^6`. # Example ```python print(is_prime(2)) # Output: True print(is_prime(4)) # Output: False print(is_prime(17)) # Output: True print(is_prime(1)) # Output: False print(is_prime(29)) # Output: True ``` # Guidelines * Use appropriate algorithms to determine primality efficiently. * Thoroughly test your implementation with a variety of inputs, including edge cases. * Avoid unnecessary computations to ensure optimal performance, especially for large input values.","solution":"def is_prime(num: int) -> bool: Determines if a given integer num is a prime number. Arguments: num -- An integer to be checked for primality. Returns: True if num is a prime number, False otherwise. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True"},{"question":"Scenario You are working on developing a file synchronization tool that ensures the latest version of files is available on multiple devices. One crucial feature of this tool is to compare the contents of two directories and identify any differences in their files, including files that are only present in one directory, files that differ in content, or files that are the same in both directories. Problem Statement Write a function `compare_directories` that compares the file contents of two directories and returns a summary of the differences. The summary should categorize files into three types: unique to the first directory, unique to the second directory, and common to both directories but with different contents. # Function Signature ```python def compare_directories(dir1: Dict[str, str], dir2: Dict[str, str]) -> Tuple[List[str], List[str], List[str]]: ``` # Input * Two dictionaries `dir1` and `dir2` where: * The keys are the filenames (case-sensitive strings). * The values are the file contents (strings). # Output * The function should return a tuple containing three lists: * The first list contains filenames unique to the first directory. * The second list contains filenames unique to the second directory. * The third list contains filenames common to both directories but with different contents. # Constraints * 1 <= number of files in each directory <= 1000 * 1 <= length of each filename, file content <= 1000 # Example ```python dir1 = { \\"file1.txt\\": \\"Hello World\\", \\"file2.txt\\": \\"Python Programming\\", \\"file3.txt\\": \\"Data Structures\\" } dir2 = { \\"file2.txt\\": \\"Python Programming\\", \\"file3.txt\\": \\"Data Science\\", \\"file4.txt\\": \\"Machine Learning\\" } result = compare_directories(dir1, dir2) # This should return the lists of filenames: # ([\'file1.txt\'], [\'file4.txt\'], [\'file3.txt\']) ``` # Additional Information * The filenames and file contents are case-sensitive. * Ensure the function handles directories with no files (empty dictionaries) correctly. * Consider edge cases such as directories with all unique files, no common files, or all common files but different contents.","solution":"from typing import Dict, List, Tuple def compare_directories(dir1: Dict[str, str], dir2: Dict[str, str]) -> Tuple[List[str], List[str], List[str]]: unique_to_dir1 = [] unique_to_dir2 = [] common_but_different = [] # Find files unique to dir1 for file in dir1: if file not in dir2: unique_to_dir1.append(file) elif dir1[file] != dir2[file]: common_but_different.append(file) # Find files unique to dir2 for file in dir2: if file not in dir1: unique_to_dir2.append(file) return unique_to_dir1, unique_to_dir2, common_but_different"},{"question":"# Context In several scenarios such as web scraping, text processing, and software engineering, it\'s often necessary to extract and manipulate URL data. # Problem Statement You have been provided with a `URLParser` class that can extract various components from a given URL string. Extend the functionality of this class to include methods that can fetch specific parts of the URL. # Task Enhance the given URL parser class to include the following additional methods: 1. **Fetch the Protocol**: * Implement a method `get_protocol()` that returns the protocol/scheme of the URL. 2. **Fetch the Domain**: * Implement a method `get_domain()` that returns the domain of the URL. 3. **Fetch the Path**: * Implement a method `get_path()` that returns the path of the URL. # Function Signature ```python class URLParser: def __init__(self, url: str): # Initialize your data structure here self.url = url def get_protocol(self) -> str: # Extract and return the protocol of the URL pass def get_domain(self) -> str: # Extract and return the domain of the URL pass def get_path(self) -> str: # Extract and return the path of the URL pass ``` # Input * A `URLParser` object initialized with a URL string. # Output * **get_protocol**: A string representing the protocol of the URL. * **get_domain**: A string representing the domain of the URL. * **get_path**: A string representing the path of the URL. # Example Usage ```python # Example Usage parser = URLParser(\\"https://www.example.com/path/to/resource\\") print(parser.get_protocol()) # Should output \\"https\\" print(parser.get_domain()) # Should output \\"www.example.com\\" print(parser.get_path()) # Should output \\"/path/to/resource\\" parser2 = URLParser(\\"ftp://fileserver.com/files\\") print(parser2.get_protocol()) # Should output \\"ftp\\" print(parser2.get_domain()) # Should output \\"fileserver.com\\" print(parser2.get_path()) # Should output \\"/files\\" ``` # Constraints 1. The URL provided will always be a valid and well-formed URL. 2. The protocol will always be present (e.g., `https`, `ftp`). 3. The domain will always be present (e.g., `example.com`, `fileserver.com`). 4. The path may be empty, but if present, it will start with a `/`. # Additional Notes Ensure that your solution handles edge cases such as URLs without a path or URLs with different protocols efficiently.","solution":"class URLParser: def __init__(self, url: str): self.url = url def get_protocol(self) -> str: Extract and return the protocol of the URL. protocol = self.url.split(\\"://\\")[0] return protocol def get_domain(self) -> str: Extract and return the domain of the URL. domain = self.url.split(\\"://\\")[1].split(\'/\')[0] return domain def get_path(self) -> str: Extract and return the path of the URL. parts = self.url.split(\\"://\\")[1].split(\'/\') path = \'/\' + \'/\'.join(parts[1:]) if len(parts) > 1 else \'/\' return path"},{"question":"# Problem Statement You need to find the maximum product of an array of integers, where the product can be formed by multiplying any subset of the array elements. Note that the subset can be any size including 1. Function Signature ```python def max_product_subset(arr: List[int]) -> int: Computes the maximum product of any subset of the given array. Parameters: arr (List[int]): A list of integers. Returns: int: The maximum product of any subset. ``` Input Constraints * The length of the array `arr` will be between 1 and 100 (1 ≤ len(arr) ≤ 100). * Each element in the array `arr` will be an integer within the range from -10 to 10. Output Requirements * A single integer representing the maximum product of any subset of the array. Performance Requirements * The solution should be efficient with an expected time complexity of O(n), where n is the length of the array. Examples ```python assert max_product_subset([1, -2, -3, 4, 6]) == 144 assert max_product_subset([-1, -2, -3, -4]) == 24 assert max_product_subset([0, 2, 3, -2]) == 6 assert max_product_subset([8]) == 8 assert max_product_subset([-1, 0, -2, -3]) == 6 ``` # Additional Context The problem involves understanding the behavior of products with negative and zero values. Consider all possible combinations regarding the presence of zero and negative numbers in the array to form the maximum product efficiently. This type of problem is common in interview settings to assess a candidate\'s ability to perform array manipulations and handle edge cases.","solution":"from typing import List def max_product_subset(arr: List[int]) -> int: Computes the maximum product of any subset of the given array. Parameters: arr (List[int]): A list of integers. Returns: int: The maximum product of any subset. if not arr: return 0 n = len(arr) if n == 1: return arr[0] max_neg = float(\'-inf\') count_neg = count_zero = product = 0 for num in arr: if num == 0: count_zero += 1 continue if num < 0: count_neg += 1 max_neg = max(max_neg, num) product = (product * num) if product != 0 else num # If all elements are zero if count_zero == n: return 0 # If there are odd number of negative numbers if count_neg % 2 != 0: if count_neg == 1 and count_zero + count_neg == n: return 0 product = product // max_neg return product"},{"question":"# Problem Statement You are tasked with creating a function that accurately calculates the total file size in a directory, including all nested subdirectories. Your function should traverse the directory tree and sum the sizes of all files, outputting the total in bytes. Function Signature ```python def calculate_total_size(directory: str) -> int: ``` Input * `directory` (str): The path to the directory whose total file size you wish to calculate. Output * Returns the total size of all files within the directory and its subdirectories in bytes. Constraints * Do not use the `os.system` or `subprocess` modules. * Ensure the function handles large directory trees efficiently. * Handle permissions errors gracefully and continue summing remaining accessible files. Requirements * Your function should effectively navigate through nested directories using the `os` and `os.path` modules. * Implement error handling for cases where access to certain files or directories is restricted. * The function should be efficient to handle large amounts of files and nested subdirectories. # Example ```python total_size = calculate_total_size(\\"/path/to/directory\\") print(f\\"Total size: {total_size} bytes\\") ``` # Testing * Test with directories of varying sizes, including deeply nested subdirectories. * Test with directories containing various types of files: regular files, symbolic links, and hidden files. * Ensure that the function handles edge cases such as empty directories, directories with restricted access, and directories with circular symbolic links.","solution":"import os def calculate_total_size(directory: str) -> int: total_size = 0 for root, dirs, files in os.walk(directory): for file in files: file_path = os.path.join(root, file) try: total_size += os.path.getsize(file_path) except (OSError, FileNotFoundError): # Skip the file if there\'s an error accessing its size continue return total_size"},{"question":"# Subarray Sum Equals k Problem Statement Given an array of integers `nums` and an integer `k`, you need to find the total number of continuous subarrays whose sum equals to `k`. Your task is to implement a function that efficiently counts all such subarrays. You are required to utilize a hashmap (dictionary in Python) to keep track of the cumulative sums and their frequencies to achieve the desired time complexity. Function Signature ```python def subarray_sum(nums: list[int], k: int) -> int: pass ``` Input * A list of integers `nums` (1 ≤ len(nums) ≤ 20,000, -1,000 ≤ nums[i] ≤ 1,000) * An integer `k` (-1,000,000 ≤ k ≤ 1,000,000) Output * An integer representing the total number of continuous subarrays whose sum equals `k`. Constraints * Only integer inputs will be provided for the array and `k`. Example ```python >>> subarray_sum([1, 1, 1], 2) 2 >>> subarray_sum([1, 2, 3], 3) 2 ``` You need to implement the `subarray_sum` function which makes use of an efficient approach to find all contiguous subarrays summing up to `k`.","solution":"def subarray_sum(nums: list[int], k: int) -> int: Returns the total number of continuous subarrays whose sum equals k. count = 0 cumulative_sum = 0 sum_frequencies = {0: 1} for num in nums: cumulative_sum += num if (cumulative_sum - k) in sum_frequencies: count += sum_frequencies[cumulative_sum - k] if cumulative_sum in sum_frequencies: sum_frequencies[cumulative_sum] += 1 else: sum_frequencies[cumulative_sum] = 1 return count"},{"question":"# Binary Search Tree Operations As a software developer, you are tasked with implementing various operations on a binary search tree (BST). Task: Implement the following functions for a binary search tree: 1. **Insert**: Insert a new node with a given value into the BST. 2. **Delete**: Delete a node with a given value from the BST. 3. **Find**: Search for a node with a given value in the BST. 4. **In-order Traversal**: Print all nodes in the BST in in-order traversal. 5. **Find Minimum**: Find and print the node with the minimum value in the BST. 6. **Find Maximum**: Find and print the node with the maximum value in the BST. Specifications: * **Input Format**: - Operations to be performed along with the values in case of insertions and deletions. - Each line contains an operation type (Insert/Delete/Find) followed by a value, if applicable. * **Output Format**: - **Find**: Return \\"Found\\" if the node exists and \\"Not Found\\" if it does not. - **In-order Traversal**: Print node values in in-order traversal. - **Find Minimum**: Print the minimum value node in the BST. - **Find Maximum**: Print the maximum value node in the BST. * **Constraints**: - The value of nodes in BST are integers. - The number of operations: 1 ≤ number of operations ≤ 1000 - Values: -10^4 ≤ value ≤ 10^4 - Ensure to handle edge cases such as deletion of non-existent nodes and empty trees. Additional Information: 1. Assume the BST is initially empty. 2. Ensure the BST properties are maintained during insertion and deletion. Example: ```python Input: Operations: Insert 10 Insert 5 Insert 15 Insert 3 Insert 7 Find 15 Find 8 Delete 5 Insert 12 In-order Traversal Find Minimum Find Maximum Output: Found Not Found In-order Traversal: 3 7 10 12 15 Minimum: 3 Maximum: 15 ```","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None class BST: def __init__(self): self.root = None def insert(self, value): def _insert(node, value): if node is None: return TreeNode(value) if value < node.value: node.left = _insert(node.left, value) else: node.right = _insert(node.right, value) return node self.root = _insert(self.root, value) def delete(self, value): def _delete(node, value): if node is None: return node if value < node.value: node.left = _delete(node.left, value) elif value > node.value: node.right = _delete(node.right, value) else: if node.left is None: return node.right elif node.right is None: return node.left temp_val = self.find_min(node.right).value node.value = temp_val node.right = _delete(node.right, temp_val) return node self.root = _delete(self.root, value) def find(self, value): def _find(node, value): if node is None: return \\"Not Found\\" if value == node.value: return \\"Found\\" elif value < node.value: return _find(node.left, value) else: return _find(node.right, value) return _find(self.root, value) def in_order_traversal(self): result = [] def _in_order_traverse(node): if node: _in_order_traverse(node.left) result.append(node.value) _in_order_traverse(node.right) _in_order_traverse(self.root) return result def find_min(self, node=None): current = node or self.root while current and current.left: current = current.left return current def find_max(self, node=None): current = node or self.root while current and current.right: current = current.right return current"},{"question":"# Merge k Sorted Lists You have been tasked to merge k sorted linked lists into one sorted linked list and return it as a single sorted list. **Function Signature:** ```python def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: ``` **Input:** * `lists` - A list of k linked lists, where each linked list is sorted in ascending order. **Output:** * A single linked list that results from merging all the k sorted linked lists in ascending order. **Constraints:** * You must ensure that the solution is efficient even for a large number of lists with large lengths. * Consider both time and space complexity in your approach. * Handle edge cases such as null, empty lists, or lists with duplicated values. **Scenario:** Imagine you are building an application for a system that needs to combine various sorted data streams. Efficiently merging these sorted lists is key to maintaining the performance of the system. **Example:** ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def print_list(node): result = [] while node: result.append(node.val) node = node.next return result list1 = ListNode(1, ListNode(4, ListNode(5))) list2 = ListNode(1, ListNode(3, ListNode(4))) list3 = ListNode(2, ListNode(6)) lists = [list1, list2, list3] >>> merged_head = merge_k_sorted_lists(lists) >>> print_list(merged_head) [1, 1, 2, 3, 4, 4, 5, 6] >>> print_list(merge_k_sorted_lists([])) [] >>> print_list(merge_k_sorted_lists([None, None])) [] ``` You can use the following partial code as a starting point for your solution: ```python from heapq import heappush, heappop from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: heap = [] for i, node in enumerate(lists): if node: heappush(heap, (node.val, i, node)) dummy = ListNode(0) current = dummy while heap: val, i, node = heappop(heap) current.next = ListNode(val) current = current.next node = node.next if node: heappush(heap, (node.val, i, node)) return dummy.next ``` **Note:** Thorough testing with various instances of k lists (including edge cases) is encouraged to ensure robustness and correctness of the merged sorted list.","solution":"from heapq import heappush, heappop from typing import List, Optional class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: if not lists: return None heap = [] # Push the head node of each list into the heap for i, node in enumerate(lists): if node: heappush(heap, (node.val, i, node)) # Dummy node to keep track of the head of merged list dummy = ListNode(0) current = dummy # Extract nodes from heap and build the final sorted linked list while heap: val, i, node = heappop(heap) current.next = ListNode(val) current = current.next node = node.next if node: heappush(heap, (node.val, i, node)) return dummy.next"},{"question":"# Scenario You have been asked to develop a simple caching mechanism for a web application to enhance performance. The caching system should store key-value pairs and manage the cache size using an eviction policy called Least Recently Used (LRU). This means when the cache reaches its maximum size, it will evict the least recently used item to accommodate a new one. # Task Implement an LRU (Least Recently Used) caching system. The cache should support the following operations: 1. `get(key)`: Return the value if the key exists in the cache, otherwise return -1. 2. `put(key, value)`: Insert or update the value of the key. If the cache exceeds its capacity, it should evict the least recently used item. # Function Signature Below are the methods that need to be implemented in the `LRUCache` class: ```python class LRUCache: def __init__(self, capacity: int): Initialize the LRU cache with a given capacity. def get(self, key: int) -> int: Get the value of the key if it exists in the cache, otherwise return -1. def put(self, key: int, value: int) -> None: Update the value of the key if it exists, or insert the key if it does not exist. When the cache reaches its capacity, evict the least recently used item. ``` # Input * `capacity`: A positive integer indicating the maximum size of the cache. # Output * The `get` method should return the value associated with the key or -1 if the key does not exist. * The `put` method does not return any value. # Constraints * 1 <= capacity <= 1000 * 0 <= key, value <= 10^4 * At most 10^5 calls to `get` and `put`. # Expected Complexity * Expected time complexity for each `get` and `put` operation is O(1). * Expected space complexity is O(capacity). # Example Usage ```python cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) print(cache.get(1)) # returns 1 cache.put(3, 3) # evicts key 2 print(cache.get(2)) # returns -1 (not found) cache.put(4, 4) # evicts key 1 print(cache.get(1)) # returns -1 (not found) print(cache.get(3)) # returns 3 print(cache.get(4)) # returns 4 ``` # Note Ensure your solution efficiently manages the order of usage to maintain O(1) time complexity for both `get` and `put` operations. This often involves using a combination of a dictionary and a doubly linked list.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.prev = None self.next = None class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.head = Node(0, 0) # Dummy head self.tail = Node(0, 0) # Dummy tail self.head.next = self.tail self.tail.prev = self.head def _remove(self, node: Node): prev, nxt = node.prev, node.next prev.next = nxt nxt.prev = prev def _add(self, node: Node): last = self.tail.prev last.next = node self.tail.prev = node node.prev = last node.next = self.tail def get(self, key: int) -> int: if key in self.cache: node = self.cache[key] self._remove(node) self._add(node) return node.value return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self._remove(self.cache[key]) node = Node(key, value) self._add(node) self.cache[key] = node if len(self.cache) > self.capacity: lru = self.head.next self._remove(lru) del self.cache[lru.key]"},{"question":"# Problem Statement: You are given an array of integers representing the height of buildings on a skyline. Each building has a width of 1. Your task is to implement a function to find two buildings such that the space between them can trap the maximum amount of water. The water level between the buildings is dictated by the shorter of the two building heights. # Function Signature: ```python def max_water_trap(heights: List[int]) -> int: Find the maximum amount of water that can be trapped between two buildings. Args: heights: List[int]: A list of integers representing the heights of buildings. Returns: max_water: int : The maximum amount of water that can be trapped between two buildings. ``` # Input: * `heights`: A list of integers, where each integer represents the height of a building. # Output: * `max_water`: An integer representing the maximum amount of water that can be trapped between two buildings. # Constraints: * 2 <= len(heights) <= 1000 * 0 <= heights[i] <= 10^4 # Example: ```python heights = [1, 8, 6, 2, 5, 4, 8, 3, 7] result = max_water_trap(heights) print(result) # should output 49 ``` # Notes: * The function should run in O(n) time and O(1) space, using a two-pointer technique to achieve optimal performance. * Ensure that the function handles edge cases where the building heights are either all the same or a combination of smallest and largest values.","solution":"from typing import List def max_water_trap(heights: List[int]) -> int: Find the maximum amount of water that can be trapped between two buildings. Args: heights: List[int]: A list of integers representing the heights of buildings. Returns: max_water: int : The maximum amount of water that can be trapped between two buildings. left = 0 right = len(heights) - 1 max_water = 0 while left < right: height = min(heights[left], heights[right]) width = right - left max_water = max(max_water, height * width) if heights[left] < heights[right]: left += 1 else: right -= 1 return max_water"},{"question":"# Implementing the K-Nearest Neighbors (KNN) Algorithm for Classification **Context**: You are provided with a dataset that includes different species of flowers characterized by features such as petal length, petal width, sepal length, and sepal width. Your task is to implement the K-Nearest Neighbors algorithm from scratch to classify the species of a flower based on given features. # Task: 1. **Data Loading and Preprocessing**: Write a function to load and split the dataset into training and testing sets. 2. **Distance Calculation**: Implement a function to calculate the Euclidean distance between two data points. 3. **KNN Implementation**: Write the KNN algorithm to classify a given data point based on the majority vote of its k nearest neighbors. 4. **Evaluation**: Implement a function to evaluate the accuracy of your model on the test set. # Inputs: - **dataset_url**: URL link to the dataset (in CSV format). - **k**: Number of nearest neighbors to consider. - **test_size**: Proportion of the dataset to be used for testing. # Expected Output: - Print the accuracy of the KNN classifier on the test data. - Print confusion matrix showing the performance of the classification. # Code Constraints: - Use numpy for efficient matrix operations. - Use pandas for data loading and preprocessing. - Ensure your code handles the dataset loading and preprocessing as needed. - Include meaningful comments and print statements for analysis and debug purposes. Here is the skeleton of the program you need to implement: ```python import numpy as np import pandas as pd from collections import Counter from sklearn.metrics import confusion_matrix def load_and_split_dataset(url, test_size): data = pd.read_csv(url) data = data.sample(frac=1).reset_index(drop=True) # shuffle the data train_size = int((1 - test_size) * len(data)) train_data = data[:train_size] test_data = data[train_size:] return train_data, test_data def euclidean_distance(row1, row2): return np.sqrt(np.sum((row1 - row2) ** 2)) def predict_classification(train_data, test_row, k): distances = [] for index, row in train_data.iterrows(): dist = euclidean_distance(test_row[:-1].to_numpy(), row[:-1].to_numpy()) distances.append((row, dist)) distances.sort(key=lambda x: x[1]) neighbors = distances[:k] output_values = [row[0][-1] for row, _ in neighbors] prediction = Counter(output_values).most_common(1)[0][0] return prediction def knn(train_data, test_data, k): predictions = [] for index, row in test_data.iterrows(): output = predict_classification(train_data, row, k) predictions.append(output) return predictions def calculate_accuracy(test_data, predictions): correct = sum(test_data.iloc[i, -1] == predictions[i] for i in range(len(test_data))) accuracy = correct / len(test_data) return accuracy def main(): url = \\"https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv\\" k = 5 test_size = 0.2 train_data, test_data = load_and_split_dataset(url, test_size) predictions = knn(train_data, test_data, k) accuracy = calculate_accuracy(test_data, predictions) print(f\\"Accuracy: {accuracy:.2f}\\") y_true = test_data.iloc[:, -1].to_numpy() y_pred = np.array(predictions) cm = confusion_matrix(y_true, y_pred) print(\\"Confusion Matrix:\\") print(cm) if __name__ == \\"__main__\\": main() ``` # Evaluation - You will be evaluated on correctly implementing the KNN algorithm and the distance calculation. - Effective use of test/train split and proper result evaluation. - Clear and concise code with appropriate function naming and comments.","solution":"import numpy as np import pandas as pd from collections import Counter from sklearn.metrics import confusion_matrix def load_and_split_dataset(url, test_size): Load dataset from the given URL and split into training and testing set. Parameters: url (str): URL of the CSV dataset test_size (float): Proportion of the dataset to include in the test split Returns: train_data (pd.DataFrame): Training data test_data (pd.DataFrame): Testing data data = pd.read_csv(url) data = data.sample(frac=1).reset_index(drop=True) # shuffle the data train_size = int((1 - test_size) * len(data)) train_data = data[:train_size] test_data = data[train_size:] return train_data, test_data def euclidean_distance(row1, row2): Calculate the Euclidean distance between two data points. Parameters: row1 (array-like): First data point row2 (array-like): Second data point Returns: float: Euclidean distance between row1 and row2 return np.sqrt(np.sum((row1 - row2) ** 2)) def predict_classification(train_data, test_row, k): Predict the class of a given data point using k-Nearest Neighbors. Parameters: train_data (pd.DataFrame): Training data test_row (pd.Series): Test data point k (int): Number of nearest neighbors to consider Returns: int/str: Predicted class distances = [] for _, row in train_data.iterrows(): dist = euclidean_distance(test_row[:-1].to_numpy(), row[:-1].to_numpy()) distances.append((row, dist)) distances.sort(key=lambda x: x[1]) neighbors = distances[:k] output_values = [row[-1] for row, _ in neighbors] prediction = Counter(output_values).most_common(1)[0][0] return prediction def knn(train_data, test_data, k): Classify test data points using k-Nearest Neighbors. Parameters: train_data (pd.DataFrame): Training data test_data (pd.DataFrame): Testing data k (int): Number of nearest neighbors to consider Returns: list: List of predictions for test data points predictions = [] for _, row in test_data.iterrows(): output = predict_classification(train_data, row, k) predictions.append(output) return predictions def calculate_accuracy(test_data, predictions): Calculate the accuracy of the classifier. Parameters: test_data (pd.DataFrame): Testing data predictions (list): List of predictions Returns: float: Accuracy of the classifier correct = sum(test_data.iloc[i, -1] == predictions[i] for i in range(len(test_data))) accuracy = correct / len(test_data) return accuracy def main(): url = \\"https://raw.githubusercontent.com/jbrownlee/Datasets/master/iris.csv\\" k = 5 test_size = 0.2 train_data, test_data = load_and_split_dataset(url, test_size) predictions = knn(train_data, test_data, k) accuracy = calculate_accuracy(test_data, predictions) print(f\\"Accuracy: {accuracy:.2f}\\") y_true = test_data.iloc[:, -1].to_numpy() y_pred = np.array(predictions) cm = confusion_matrix(y_true, y_pred) print(\\"Confusion Matrix:\\") print(cm) if __name__ == \\"__main__\\": main()"},{"question":"Problem Description You are asked to implement a function that simulates a simple transaction system for a vending machine. The vending machine offers several products, each with a specific price. Users can make purchases by inserting coins, and the machine should provide the correct change in the fewest number of coins possible. # Input - A list of transactions. Each transaction is represented by a dictionary with two keys: `\\"product\\"` (a string indicating the product name) and `\\"coins_inserted\\"` (an integer representing the total value of coins inserted). - A dictionary of products, where each key is a product name (string) and each value is the product price (integer). # Output - A list of dictionaries, where each dictionary represents the change for a transaction. Each dictionary has keys representing coin denominations (\\"25c\\", \\"10c\\", \\"5c\\", \\"1c\\") and values indicating the number of each coin denomination to return. # Function Signature ```python def calculate_change(transactions: list[dict], products: dict) -> list[dict]: pass ``` # Constraints - Coin denominations available are 25 cents, 10 cents, 5 cents, and 1 cent. - All prices and inserted values are valid integers. - The inserted amount is always greater than or equal to the product price. # Example ```python transactions = [ {\\"product\\": \\"soda\\", \\"coins_inserted\\": 100}, {\\"product\\": \\"chocolate\\", \\"coins_inserted\\": 200}, {\\"product\\": \\"chips\\", \\"coins_inserted\\": 50} ] products = { \\"soda\\": 75, \\"chocolate\\": 120, \\"chips\\": 50 } print(calculate_change(transactions, products)) # Output: # [ # {\\"25c\\": 1, \\"10c\\": 0, \\"5c\\": 0, \\"1c\\": 0}, # {\\"25c\\": 3, \\"10c\\": 0, \\"5c\\": 1, \\"1c\\": 0}, # {\\"25c\\": 0, \\"10c\\": 0, \\"5c\\": 0, \\"1c\\": 0} # ] ``` # Notes - Implement a greedy algorithm to ensure that the returned change is in the fewest number of coins possible. - Make sure to process each transaction independently and correctly compute the change based on the available coin denominations.","solution":"def calculate_change(transactions, products): coin_denominations = [25, 10, 5, 1] coin_labels = [\\"25c\\", \\"10c\\", \\"5c\\", \\"1c\\"] results = [] for transaction in transactions: product = transaction[\\"product\\"] coins_inserted = transaction[\\"coins_inserted\\"] product_price = products[product] change = coins_inserted - product_price change_dict = {\\"25c\\": 0, \\"10c\\": 0, \\"5c\\": 0, \\"1c\\": 0} for value, label in zip(coin_denominations, coin_labels): if change >= value: num_coins = change // value change_dict[label] = num_coins change -= num_coins * value results.append(change_dict) return results"},{"question":"# Question: Robot Grid Path Count A robot is situated at the top-left corner of an `m x n` grid (i.e., `grid[0][0]`) and it can move either down or right at any point in time. The goal of the robot is to reach the bottom-right corner of the grid (i.e., `grid[m-1][n-1]`). Write a function `robot_grid_paths` to compute the number of possible unique paths that the robot can take to reach the bottom-right corner. Note that the robot always starts at the top-left corner of the grid and not all paths may be traversable due to some obstacles in the grid. The grid is represented as a 2D list where `0` represents an empty cell and `1` represents an obstacle. Function Signature ```python def robot_grid_paths(grid: List[List[int]]) -> int: ``` Input - `grid`: A list of lists where each sublist represents a row in the grid. Each value in the sublists is `0` or `1`. Output - Returns the number of unique paths to reach `grid[m-1][n-1]` from `grid[0][0]`. Constraints - The grid dimensions `m` (number of rows) and `n` (number of columns) will be between 1 and 100. - There may be up to `10^4` cells in the grid. - There will always be at least one cell at the top-left corner (`grid[0][0]`). Example ```python assert robot_grid_paths([ [0, 0, 0], [0, 1, 0], [0, 0, 0] ]) == 2 assert robot_grid_paths([ [0, 1], [0, 0] ]) == 1 ``` Explanation - In the first example, the robot can take two different paths to reach the bottom-right: 1. Right -> Right -> Down -> Down 2. Down -> Down -> Right -> Right - In the second example, there is only one path available due to the obstacle: 1. Down -> Right You should consider edge cases such as grids with all cells empty or grids with paths completely blocked by obstacles.","solution":"from typing import List def robot_grid_paths(grid: List[List[int]]) -> int: Returns the number of unique paths from top-left to bottom-right in a grid with obstacles. m = len(grid) n = len(grid[0]) # If the start or end is an obstacle, no path is possible if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 # No path through an obstacle else: if i > 0: dp[i][j] += dp[i-1][j] # Path from above if j > 0: dp[i][j] += dp[i][j-1] # Path from the left return dp[m-1][n-1]"},{"question":"# Fibonacci Number Index Finder You are provided with a function `fib_index(num)` that finds the index of a given number in the Fibonacci sequence. # Problem Statement Given a positive integer `num`, your task is to implement the function `fib_index(num)` that returns the index of `num` in the Fibonacci sequence. The Fibonacci sequence is defined as: [ F₀ = 0, F₁ = 1, Fₙ = Fₙ₋₁ + Fₙ₋₂ ] where: - `Fₙ` is the nth Fibonacci number. - `n` is the position index in the sequence starting from 0. If the number does not exist in the Fibonacci sequence, the function should return -1. # Implementation Details * **Function Signature**: ```python def fib_index(num: int) -> int: ``` * **Input**: - `num` (int): A positive integer for which to find the index in the Fibonacci sequence. * **Output**: - An integer representing the index of the number in the Fibonacci sequence, or -1 if the number is not part of the sequence. * **Constraints**: - The input `num` will be a positive integer. # Example 1. **Input**: 21 **Output**: 8 2. **Input**: 5 **Output**: 5 3. **Input**: 22 **Output**: -1 # Additional Notes - Ensure your code follows the specified function signature. - Consider edge cases such as very large Fibonacci numbers and handle them efficiently.","solution":"def fib_index(num: int) -> int: # Base cases for 0 and 1 if num == 0: return 0 elif num == 1: return 1 # Initialize the first two Fibonacci numbers and index a, b = 0, 1 index = 1 # Generate Fibonacci sequence until we reach or exceed the number while b < num: a, b = b, a + b index += 1 # Check if the number matches the Fibonacci number at the current index if b == num: return index else: return -1"},{"question":"# Question You are a software engineer tasked with developing a file synchronization tool. The tool should be capable of identifying changes in a directory and synchronizing files between a source directory and a destination directory. # Requirements 1. **Function Name**: `sync_directories` 2. **Inputs**: - A string `source_dir` representing the path to the source directory. - A string `dest_dir` representing the path to the destination directory. 3. **Output**: - The function should not return anything but should perform the following actions: - Copy all files and directories from `source_dir` to `dest_dir`. - Replace files in `dest_dir` if they exist with a different content or timestamp compared to `source_dir`. - Remove any files or directories in `dest_dir` that are not present in `source_dir`. # Constraints - Only the file content and timestamps should be compared to determine if a file or directory needs synchronization. - You may use the `os` and `shutil` modules for handling file system operations. - Ensure that any subdirectories of `source_dir` are recursively synchronized to `dest_dir`. # Example ```python import os, shutil source_dir = \'path/to/source_dir\' dest_dir = \'path/to/dest_dir\' sync_directories(source_dir, dest_dir) # After calling the function, dest_dir should be an exact mirror of source_dir. ``` # Notes - Assume the paths provided are valid and that the source directory exists. - Ensure your code handles large numbers of files and potential subdirectory structures efficiently. - Handle file permissions and potential IO errors gracefully, ensuring partial syncing does not cause inconsistencies.","solution":"import os import shutil from filecmp import cmp def sync_directories(source_dir, dest_dir): Synchronize files and directories from source_dir to dest_dir. Args: - source_dir (str): Path to the source directory. - dest_dir (str): Path to the destination directory. Returns: - None # Ensure the destination directory exists if not os.path.exists(dest_dir): os.makedirs(dest_dir) # Track files and directories in the source directory source_items = set(os.listdir(source_dir)) dest_items = set(os.listdir(dest_dir)) # Handle items to be copied or replaced for item in source_items: source_path = os.path.join(source_dir, item) dest_path = os.path.join(dest_dir, item) if os.path.isdir(source_path): # If it\'s a directory sync_directories(source_path, dest_path) else: # If it\'s a file if not os.path.exists(dest_path) or not cmp(source_path, dest_path, shallow=False): shutil.copy2(source_path, dest_path) # Handle items to be removed for item in dest_items - source_items: dest_path = os.path.join(dest_dir, item) if os.path.isdir(dest_path): shutil.rmtree(dest_path) else: os.remove(dest_path)"},{"question":"# Flight Connection Finder You are implementing a flight reservation system. Your task is to create a function that, given a list of direct flights between cities and a start and end city, finds a path (if any) that connects these two cities through a series of direct flights. # Function Signature: ```python def find_flight_path(flights: List[Tuple[str, str]], start: str, end: str) -> List[str]: pass ``` # Input: - **flights**: A list of tuples where each tuple represents a direct flight between two cities (e.g., `(\\"New York\\", \\"Paris\\")`). - **start**: A string representing the starting city. - **end**: A string representing the destination city. # Output: - **List of strings**: A list of city names representing the path from the start city to the end city, inclusive. If no path is found, return an empty list. # Constraints: - Each city name is a string of maximum length 50. - The list of flights is non-empty and contains at most 10,000 flights. # Example: ```python flights = [(\\"New York\\", \\"Paris\\"), (\\"Paris\\", \\"Berlin\\"), (\\"Berlin\\", \\"Tokyo\\"), (\\"Tokyo\\", \\"Sydney\\")] start = \\"New York\\" end = \\"Sydney\\" print(find_flight_path(flights, start, end)) # Output: [\\"New York\\", \\"Paris\\", \\"Berlin\\", \\"Tokyo\\", \\"Sydney\\"] start = \\"New York\\" end = \\"Moscow\\" print(find_flight_path(flights, start, end)) # Output: [] ``` # Detailed Explanation: 1. **Input Flights Description**: Each tuple in the input list represents a direct flight between two cities. 2. **Path Finding**: The function should find and return the path from the start city to the end city. 3. **Path Validity**: A valid path is a series of direct flights connecting the start and end cities. 4. **Output Format**: The output should be a list of strings representing the sequence of cities in the path found. # Requirements: - Utilize efficient graph traversal techniques such as BFS or DFS to explore all possible paths. - Ensure to handle cases where no path exists between the start and end cities. - Keep the implementation optimized to handle the upper limit of input constraints.","solution":"from typing import List, Tuple from collections import defaultdict, deque def find_flight_path(flights: List[Tuple[str, str]], start: str, end: str) -> List[str]: # Create an adjacency list for the graph graph = defaultdict(list) for source, destination in flights: graph[source].append(destination) # BFS initialization queue = deque([(start, [start])]) visited = set() # Begin BFS while queue: current_city, path = queue.popleft() # Destination found if current_city == end: return path # Mark the current city as visited visited.add(current_city) # Add neighbors to the queue for neighbor in graph[current_city]: if neighbor not in visited: queue.append((neighbor, path + [neighbor])) # No path found return []"},{"question":"# Coding Question Problem Statement Given a positive integer `n`, implement a function `count_primes` that returns the number of prime numbers less than `n`. A prime number is defined as a natural number greater than 1 that has no positive divisors other than 1 and itself. Function Signature ```python def count_primes(n: int) -> int: pass ``` Input - `n` (int): A positive integer. Output - Returns an integer representing the number of prime numbers less than `n`. Constraints - 0 <= n <= 10^6 Example ```python count_primes(10) # Output: 4 (Prime numbers: 2, 3, 5, 7) count_primes(20) # Output: 8 (Prime numbers: 2, 3, 5, 7, 11, 13, 17, 19) count_primes(1) # Output: 0 count_primes(0) # Output: 0 count_primes(2) # Output: 0 ``` Performance Requirements - The function should efficiently handle the input constraints, ideally using the Sieve of Eratosthenes algorithm or another efficient method for prime number generation. # Edge Cases to Consider 1. When `n` is 0 or 1, the output should be 0 as there are no prime numbers less than 2. 2. When `n` is 2, the output should be 0 as there are no prime numbers less than 2. 3. Handle large values of `n` up to 10^6 efficiently. # Notes - Ensure the input is always a non-negative integer. - Focus on optimizing the function to handle larger values within the constraint efficiently. ```python def count_primes(n: int) -> int: if n <= 1: return 0 is_prime = [True] * n is_prime[0], is_prime[1] = False, False for i in range(2, int(n ** 0.5) + 1): if is_prime[i]: for j in range(i * i, n, i): is_prime[j] = False return sum(is_prime) ```","solution":"def count_primes(n: int) -> int: if n <= 1: return 0 is_prime = [True] * n is_prime[0], is_prime[1] = False, False for i in range(2, int(n ** 0.5) + 1): if is_prime[i]: for j in range(i * i, n, i): is_prime[j] = False return sum(is_prime)"},{"question":"# Intersecting Lists Context and Objective You are working on a data analysis tool that compares lists of integers to determine common elements. This tool should efficiently identify the intersection of two lists, enforcing the uniqueness of elements in the result. Problem Statement Given two lists of integers, write a function `intersecting_elements` that returns a sorted list of unique elements that are common to both input lists. The function should ensure that the comparison is case-sensitive and takes into account duplicates in the input lists, only returning distinct elements. Function Signature ```python def intersecting_elements(list1: list[int], list2: list[int]) -> list[int]: pass ``` Input Constraints - `list1`: A list of integers. - `list2`: Another list of integers. Assume: - Both lists can have lengths in the range [0, 10^5]. Output - Return a sorted list of unique integers that are found in both `list1` and `list2`. Example ```python # Example 1: list1 = [1, 2, 2, 1] list2 = [2, 2] # Intersection with unique elements: [2] assert intersecting_elements(list1, list2) == [2] # Example 2: list1 = [4, 9, 5] list2 = [9, 4, 9, 8, 4] # Intersection with unique elements: [4, 9] assert intersecting_elements(list1, list2) == [4, 9] # Example 3: list1 = [1, 2, 3] list2 = [4, 5, 6] # No common elements: [] assert intersecting_elements(list1, list2) == [] ``` Notes - The input lists may have duplicates, but the returned list should only include unique elements that are common across both lists. - The output list must be sorted in ascending order. - Aim for an efficient solution to handle large list sizes within the given constraints.","solution":"def intersecting_elements(list1, list2): Returns a sorted list of unique elements that are common to both input lists. # Convert lists to sets to remove duplicates and find common elements set1 = set(list1) set2 = set(list2) # Find the intersection of both sets intersection = set1.intersection(set2) # Convert the set to a sorted list and return return sorted(intersection)"},{"question":"# Question: Design a Rate Limiter Class with Fixed Window Algorithm Background Rate limiting is a technique used to control the number of requests a user can make to a service within a certain time period. This prevents abuse and ensures fair usage among users. In this task, you will implement a rate limiter using the fixed window algorithm, where the time window is divided into fixed intervals (e.g., seconds, minutes) and the number of requests is counted within each interval. Task Create a `RateLimiter` class that limits the number of requests a user can make within a fixed time window. The class should allow setting the maximum number of requests and the length of the time window in seconds. Function Signatures The class should have the following methods: ```python class RateLimiter: def __init__(self, max_requests: int, window_size: int): Initialize the rate limiter with a maximum number of requests and the size of the time window in seconds. :param max_requests: Maximum number of requests allowed in the time window :param window_size: Length of the time window in seconds def request(self, user_id: str) -> bool: Track a request from a user. Return True if the request is allowed, otherwise return False if the rate limit is exceeded. :param user_id: Unique identifier for the user making the request :return: Boolean indicating whether the request is allowed ``` Expected Input and Output 1. **Input**: * The number of requests allowed and the length of the time window in seconds. * Requests from users identified by unique user IDs. 2. **Output**: * Boolean for each request indicating whether it is allowed or rate-limited. Constraints * The maximum number of requests will be between 1 and 1000. * The time window size will be between 1 and 86400 seconds (1 day). Example 1. **Input**: ```python rate_limiter = RateLimiter(5, 60) requests = [\'user1\', \'user1\', \'user1\', \'user1\', \'user1\', \'user1\'] results = [rate_limiter.request(user) for user in requests] print(results) ``` **Output**: ```python [True, True, True, True, True, False] ``` Notes * Implement a method to efficiently track requests and reset the count at the start of each new time window. * Handle cases where there might be multiple users making requests concurrently. * Ensure that the class is thread-safe and efficient for high-throughput scenarios. Good luck!","solution":"import time from collections import defaultdict class RateLimiter: def __init__(self, max_requests: int, window_size: int): Initialize the rate limiter with a maximum number of requests and the size of the time window in seconds. :param max_requests: Maximum number of requests allowed in the time window :param window_size: Length of the time window in seconds self.max_requests = max_requests self.window_size = window_size self.requests = defaultdict(list) def request(self, user_id: str) -> bool: Track a request from a user. Return True if the request is allowed, otherwise return False if the rate limit is exceeded. :param user_id: Unique identifier for the user making the request :return: Boolean indicating whether the request is allowed current_time = int(time.time()) if user_id not in self.requests: self.requests[user_id] = [] user_requests = self.requests[user_id] # Remove requests that are outside the window while user_requests and user_requests[0] <= current_time - self.window_size: user_requests.pop(0) if len(user_requests) < self.max_requests: user_requests.append(current_time) return True return False"},{"question":"# Problem Description You are required to implement a function `intersection_of_dicts` that takes two dictionaries and returns a new dictionary representing their intersection. The intersection of two dictionaries (A) and (B) is defined as: [ text{Intersection}(A, B) = {k: A[k] mid k in A text{ and } k in B text{ and } A[k] == B[k]} ] In other words, the resultant dictionary should contain only the keys that are present in both input dictionaries and have the same corresponding values. # Function Signature ```python def intersection_of_dicts(dict_a: dict, dict_b: dict) -> dict: ``` # Input * `dict_a`: A dictionary where keys are strings and values are integers (1 ≤ |dict_a| ≤ 10^3) * `dict_b`: A dictionary where keys are strings and values are integers (1 ≤ |dict_b| ≤ 10^3) # Output * Return a dictionary containing the intersection of `dict_a` and `dict_b` as defined above. # Constraints 1. The function should raise an AssertionError with a message if either of the inputs is not a dictionary. 2. Both input dictionaries will contain keys that are non-empty strings and unique within each dictionary. 3. Both input dictionaries will have integer values. # Example ```python assert intersection_of_dicts({\\"a\\": 1, \\"b\\": 2, \\"c\\": 3}, {\\"b\\": 2, \\"c\\": 3, \\"d\\": 4}) == {\\"b\\": 2, \\"c\\": 3} assert intersection_of_dicts({\\"x\\": 5, \\"y\\": 6}, {\\"y\\": 7, \\"z\\": 8}) == {} assert intersection_of_dicts({\\"a\\": 10, \\"b\\": 15}, {\\"a\\": 10, \\"b\\": 15, \\"c\\": 20}) == {\\"a\\": 10, \\"b\\": 15} ``` # Notes * Ensure your function handles edge cases appropriately, such as when there are no common keys or when all common keys have different values. * Aim to keep the function clear and efficient within the provided constraints.","solution":"def intersection_of_dicts(dict_a, dict_b): Returns a dictionary that is the intersection of dict_a and dict_b. The resultant dictionary contains only those keys present in both dict_a and dict_b and with same values. assert isinstance(dict_a, dict), \\"First argument must be a dictionary.\\" assert isinstance(dict_b, dict), \\"Second argument must be a dictionary.\\" return {k: dict_a[k] for k in dict_a if k in dict_b and dict_a[k] == dict_b[k]}"},{"question":"# Scenario You are building a restaurant management system and need to implement a feature to help waitstaff manage table orders easily. As part of this, you need to develop a function that can take the list of orders from all tables and return the total number of each item ordered. # Task Given a list of dictionary objects, where each dictionary represents the orders from a single table, implement the `summarize_orders` function. This function should aggregate the orders across all tables and return a single dictionary that contains the total count of each item ordered. # Function Signature ```python def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: pass ``` # Input * `orders`: A list of dictionaries. Each dictionary represents the orders from one table, where the keys are strings representing item names and the values are integers representing the quantity of each item ordered. # Output * Returns a dictionary where the keys are item names and the values are the total quantities of each item ordered. # Constraints * The `orders` list will contain between 1 and 100 dictionaries. * Each dictionary will have between 1 and 20 items. * Item names will be non-empty strings of up to 50 characters. * Quantities will be positive integers between 1 and 100. # Example ```python orders = [ {\\"burger\\": 2, \\"fries\\": 1, \\"soda\\": 3}, {\\"pizza\\": 1, \\"burger\\": 1, \\"fries\\": 2}, {\\"soda\\": 2, \\"pizza\\": 3} ] result = summarize_orders(orders) # Expected output # { # \\"burger\\": 3, # \\"fries\\": 3, # \\"soda\\": 5, # \\"pizza\\": 4 # } ``` # Notes * Ensure the returned dictionary contains items sorted by their names alphabetically. * Your implementation should be efficient in terms of both time and space complexity. * You may assume that all item names within the input dictionaries are lowercase and unique per table. # Additional Test Cases ```python orders = [ {\\"steak\\": 1, \\"salad\\": 2}, {\\"salad\\": 1, \\"water\\": 3}, {\\"steak\\": 2, \\"water\\": 2, \\"burger\\": 1} ] result = summarize_orders(orders) # Expected output # { # \\"burger\\": 1, # \\"salad\\": 3, # \\"steak\\": 3, # \\"water\\": 5 # } orders = [ {\\"pasta\\": 1}, ] result = summarize_orders(orders) # Expected output # { # \\"pasta\\": 1 # } ```","solution":"from typing import List, Dict def summarize_orders(orders: List[Dict[str, int]]) -> Dict[str, int]: Aggregates orders from multiple tables into a single dictionary that contains the total count of each item ordered. summary = {} for table_order in orders: for item, count in table_order.items(): if item in summary: summary[item] += count else: summary[item] = count return dict(sorted(summary.items()))"},{"question":"# Coding Question: Database Connection Pool Manager **Scenario**: You are tasked with developing a simplified connection pool manager for a database. The purpose of this pool manager is to efficiently handle a limited number of database connections and provide them to multiple client threads upon request. The pool should be able to handle connection requests in a thread-safe manner and reuse connections instead of establishing new ones every time. **Requirements**: 1. Implement a `DatabaseConnectionPool` class with the following methods: - `__init__(self, max_connections: int) -> None`: Initialize the connection pool with a fixed number of connections. - `get_connection(self) -> object`: Return a connection object from the pool. If all connections are in use, block until a connection is returned to the pool. - `release_connection(self, connection: object) -> None`: Return a used connection back to the pool for reuse. 2. Connections can be represented by simple objects (e.g., instances of a dummy `DatabaseConnection` class). 3. Ensure thread-safety when accessing and modifying the pool. 4. Use Python\'s `threading` module to handle synchronization. **Input**: * `max_connections` - The maximum number of connections that can be managed by the pool (an integer greater than 0). **Output**: * The `get_connection` method should return a `DatabaseConnection` object. * The `release_connection` method should not return anything. **Constraints**: * The pool must handle thread synchronization properly to prevent race conditions. * The pool should reuse connections efficiently. **Example**: ```python import threading from queue import Queue class DatabaseConnection: def __init__(self, connection_id: int): self.connection_id = connection_id class DatabaseConnectionPool: def __init__(self, max_connections: int) -> None: self._max_connections = max_connections self._pool = Queue(maxsize=max_connections) for i in range(max_connections): self._pool.put(DatabaseConnection(i)) self._lock = threading.Lock() def get_connection(self) -> DatabaseConnection: return self._pool.get() def release_connection(self, connection: DatabaseConnection) -> None: self._pool.put(connection) # Example use case if __name__ == \\"__main__\\": pool = DatabaseConnectionPool(3) connection = pool.get_connection() print(f\\"Using connection: {connection.connection_id}\\") pool.release_connection(connection) ``` **Hints**: * Use the `Queue` class from Python\'s `queue` module to manage the pool. * Use locks or other synchronization mechanisms from the `threading` module to ensure thread safety.","solution":"import threading from queue import Queue class DatabaseConnection: def __init__(self, connection_id: int): self.connection_id = connection_id class DatabaseConnectionPool: def __init__(self, max_connections: int) -> None: self._max_connections = max_connections self._pool = Queue(maxsize=max_connections) for i in range(max_connections): self._pool.put(DatabaseConnection(i)) self._lock = threading.Lock() def get_connection(self) -> DatabaseConnection: with self._lock: return self._pool.get() def release_connection(self, connection: DatabaseConnection) -> None: with self._lock: self._pool.put(connection)"},{"question":"# Palindrome Substring Function Implementation # Scenario You are building a text editor with advanced string manipulation features. One of the features required is to identify if a given substring can be rearranged to form a palindrome. This is useful for special text effects and validations. # Task Write a function `can_form_palindrome(s: str) -> bool` that takes a single string input `s` and returns a boolean indicating if any permutation of the input string can form a palindrome. # Rules 1. An empty string is considered to be able to form a palindrome. 2. The input string can include uppercase and lowercase Latin letters and digits (A-Z, a-z, 0-9). 3. A string can be rearranged to form a palindrome if at most one character appears an odd number of times. # Constraints 1. The function should have a time complexity of O(n), where n is the length of the string. 2. Optimize the function to use O(1) additional space (ignore input size for counting character frequency). # Function Signature ```python def can_form_palindrome(s: str) -> bool: pass ``` # Example Test Cases ```python # Can form a palindrome assert can_form_palindrome(\\"civic\\") == True assert can_form_palindrome(\\"ivicc\\") == True assert can_form_palindrome(\\"aabbccdd\\") == True # Cannot form a palindrome assert can_form_palindrome(\\"civil\\") == False assert can_form_palindrome(\\"nict\\") == False ``` Implement the function `can_form_palindrome` based on the above criteria and ensure it passes the provided test cases.","solution":"def can_form_palindrome(s: str) -> bool: Determines if any permutation of the input string can form a palindrome. Args: s (str): The input string to check. Returns: bool: True if any permutation can form a palindrome, False otherwise. from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count the number of characters with odd frequencies odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count return odd_count <= 1"},{"question":"# Coding Assessment Question Scenario You are working with a database of personnel records. Each record contains a person\'s first name, last name, and their unique identification number. For some reporting purposes, it is necessary to format these names in a uniform way: the first character of both the first name and last name should be converted to uppercase, while the remaining characters should be converted to lowercase. Task Implement a function `format_name` that takes in a dictionary representing a person\'s record and returns a formatted string. The function should capitalize the first character of the first and last names and convert all other characters in these names to lowercase. Input - A dictionary with three keys: - `\'first_name\'`: A string representing the first name (length between 1 and 100). - `\'last_name\'`: A string representing the last name (length between 1 and 100). - `\'id\'`: An integer representing the unique identification number. Output - A string that combines the formatted first and last names separated by a space, followed by the ID number in parentheses. Constraints - The input names can contain uppercase and lowercase letters. - Both names will contain only alphabetic characters. Examples ```python >>> format_name({\'first_name\': \'john\', \'last_name\': \'DOE\', \'id\': 12345}) \'John Doe (12345)\' >>> format_name({\'first_name\': \'MARIA\', \'last_name\': \'smith\', \'id\': 67890}) \'Maria Smith (67890)\' >>> format_name({\'first_name\': \'ALICE\', \'last_name\': \'JOHNSON\', \'id\': 1}) \'Alice Johnson (1)\' >>> format_name({\'first_name\': \'bOb\', \'last_name\': \'bROwn\', \'id\': 99999}) \'Bob Brown (99999)\' ``` Implementation ```python def format_name(record: dict) -> str: Format the name in the given personnel record. first_name = record[\'first_name\'].capitalize() last_name = record[\'last_name\'].capitalize() id_number = record[\'id\'] return f\\"{first_name} {last_name} ({id_number})\\" # Sample test cases to validate your function assert format_name({\'first_name\': \'john\', \'last_name\': \'DOE\', \'id\': 12345}) == \'John Doe (12345)\' assert format_name({\'first_name\': \'MARIA\', \'last_name\': \'smith\', \'id\': 67890}) == \'Maria Smith (67890)\' assert format_name({\'first_name\': \'ALICE\', \'last_name\': \'JOHNSON\', \'id\': 1}) == \'Alice Johnson (1)\' assert format_name({\'first_name\': \'bOb\', \'last_name\': \'bROwn\', \'id\': 99999}) == \'Bob Brown (99999)\' print(\\"All tests passed!\\") ```","solution":"def format_name(record: dict) -> str: Format the name in the given personnel record. first_name = record[\'first_name\'].capitalize() last_name = record[\'last_name\'].capitalize() id_number = record[\'id\'] return f\\"{first_name} {last_name} ({id_number})\\""},{"question":"# Problem Description Given an array containing n distinct integers in the range [0, n] inclusive, with one number missing, write a function to find the missing number using the XOR bitwise operation. This solution should leverage the properties of the XOR operation to achieve optimal performance. # Function Signature ```python def find_missing_number(nums: list[int]) -> int: ``` # Input - **nums**: A list of n distinct integers within the range [0, n]. (e.g., [3, 0, 1]) # Output - The single missing number from the list. # Constraints - The input list is guaranteed to have a length of n, containing integers in the range from 0 to n, with exactly one integer missing. - 1 <= nums.length <= (10^4) - 0 <= nums[i] <= nums.length # Example ```python # Example 1 nums = [3, 0, 1] # Output: 2 # Example 2 nums = [0, 1] # Output: 2 # Example 3 nums = [9,6,4,2,3,5,7,0,1] # Output: 8 ``` # Requirements: - Implement the function to run in O(n) time complexity. - Utilize O(1) additional space, excluding input and output.","solution":"def find_missing_number(nums: list[int]) -> int: Returns the missing number in the array using XOR. Parameters: nums (list[int]): List of n distinct integers in the range [0, n]. Returns: int: The single missing number. n = len(nums) expected_xor = 0 actual_xor = 0 # XOR all numbers from 0 to n for i in range(n + 1): expected_xor ^= i # XOR all numbers in the given list for num in nums: actual_xor ^= num # XOR of expected_xor and actual_xor gives the missing number return expected_xor ^ actual_xor"},{"question":"# Task Description You are given a linked list represented by the `ListNode` class. Implement a function `swap_pairs(head: ListNode | None) -> ListNode | None` that swaps every two adjacent nodes and returns its head. You must solve the problem without modifying the values in the list\'s nodes (i.e., only nodes themselves may be changed). # Function Signature ```python def swap_pairs(head: ListNode | None) -> ListNode | None: ``` # Input - **head**: The head node of the linked list (ListNode | None). If the head is None, return None. # Output - The head node of the linked list after swapping every two adjacent nodes. # Constraints - You may assume the linked list has at most `10^4` nodes. # Example Given the linked list constructed as follows: ``` 1 -> 2 -> 3 -> 4 ``` The function should return a swapped linked list: ``` 2 -> 1 -> 4 -> 3 ``` Another example: ``` 1 -> 2 -> 3 ``` should return: ``` 2 -> 1 -> 3 ``` # Notes - Consider performance optimizations for handling large linked lists. - Ensure thorough testing for edge cases like linked lists with only one node, or an empty list. # Implementation Implement the function `swap_pairs` in Python. The function should be efficient and handle the discussed edge cases.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def swap_pairs(head: ListNode | None) -> ListNode | None: if not head or not head.next: return head dummy = ListNode(0) dummy.next = head prev = dummy current = head while current and current.next: next_pair = current.next.next second = current.next # swap second.next = current current.next = next_pair prev.next = second # Move forward prev = current current = next_pair return dummy.next"},{"question":"# Stock Price Analyzer You have been provided with a function that fetches historical stock prices for the company of your choice from a mock API. The task is to enhance the functionality to compute various stock metrics. Requirements 1. **Function Implementation**: - Implement a function `stock_analysis(api_url: str, ticker_symbol: str, start_date: str, end_date: str) -> dict`, which fetches stock prices for the given company over a specified date range and calculates: - Average Price - Maximum Price - Minimum Price - Volatility (standard deviation of closing prices) 2. **Input and Output Formats**: - **Input**: * `api_url` (string): The base URL of the API endpoint to fetch stock data from. * `ticker_symbol` (string): The ticker symbol of the stock. * `start_date` (string): The start date for fetching the stock data (format: \'YYYY-MM-DD\'). * `end_date` (string): The end date for fetching the stock data (format: \'YYYY-MM-DD\'). - **Output**: * A dictionary where keys are the metrics (e.g., \'Average Price\', \'Maximum Price\', etc.) and values are the corresponding calculated values. 3. **Constraints**: - Ensure your code handles: * API response errors and non-200 status codes. * Valid date range and date format validation. * Cases where no data is available for the provided date range. * Network latency by setting an appropriate timeout. 4. **Performance Requirements**: - Handle large ranges of data efficiently. - Ensure that the solution works within reasonable computational limits for time and space complexity. Mock API Data The mock API returns JSON data in the following format: ```json { \\"data\\": [ {\\"date\\": \\"YYYY-MM-DD\\", \\"open\\": float, \\"close\\": float, \\"high\\": float, \\"low\\": float}, ... ] } ``` Code Base to Extend ```python #!/usr/bin/env python3 import requests import statistics from datetime import datetime def fetch_stock_data(api_url: str, ticker_symbol: str, start_date: str, end_date: str) -> dict: Fetch stock data from the mock API params = { \'ticker\': ticker_symbol, \'start\': start_date, \'end\': end_date } response = requests.get(api_url, params=params, timeout=10) if response.status_code == 200: return response.json().get(\'data\', []) else: response.raise_for_status() # Add your implementation for stock_analysis here if __name__ == \\"__main__\\": api_url = \\"https://api.mockstockdata.com/historical\\" ticker = \\"AAPL\\" start = \\"2021-01-01\\" end = \\"2021-12-31\\" data = fetch_stock_data(api_url, ticker, start, end) print(f\\"Fetched {len(data)} records for {ticker} from {start} to {end}\\") # Uncomment the below line after implementing stock_analysis # metrics = stock_analysis(api_url, ticker, start, end) # print(\\"nStock Analysis Metrics:n\\", metrics) ``` # Implementation Note - Your implementation should be robust, handling various edge cases such as malformed data, network issues, and missing metrics. - Ensure valid input handling for ticker symbols and date ranges.","solution":"import requests import statistics from datetime import datetime def fetch_stock_data(api_url: str, ticker_symbol: str, start_date: str, end_date: str) -> list: Fetch stock data from the mock API. params = { \'ticker\': ticker_symbol, \'start\': start_date, \'end\': end_date } response = requests.get(api_url, params=params, timeout=10) if response.status_code == 200: return response.json().get(\'data\', []) else: response.raise_for_status() def stock_analysis(api_url: str, ticker_symbol: str, start_date: str, end_date: str) -> dict: Fetches stock prices and computes the metrics: - Average Price - Maximum Price - Minimum Price - Volatility (standard deviation of closing prices) # Fetch stock data data = fetch_stock_data(api_url, ticker_symbol, start_date, end_date) if not data: return { \'Average Price\': None, \'Maximum Price\': None, \'Minimum Price\': None, \'Volatility\': None } # Extract closing prices from data closing_prices = [entry[\'close\'] for entry in data] average_price = sum(closing_prices) / len(closing_prices) maximum_price = max(closing_prices) minimum_price = min(closing_prices) volatility = statistics.stdev(closing_prices) if len(closing_prices) > 1 else 0 metrics = { \'Average Price\': average_price, \'Maximum Price\': maximum_price, \'Minimum Price\': minimum_price, \'Volatility\': volatility } return metrics if __name__ == \\"__main__\\": api_url = \\"https://api.mockstockdata.com/historical\\" ticker = \\"AAPL\\" start = \\"2021-01-01\\" end = \\"2021-12-31\\" data = fetch_stock_data(api_url, ticker, start, end) print(f\\"Fetched {len(data)} records for {ticker} from {start} to {end}\\") metrics = stock_analysis(api_url, ticker, start, end) print(\\"nStock Analysis Metrics:n\\", metrics)"},{"question":"# Coding Assessment Question: Binary Search Tree Insertion Scenario You are required to implement a function to insert a new value into a Binary Search Tree (BST). The BST is represented by its root node, and each node contains a value, a left child, and a right child. The value must be inserted such that the properties of the BST are maintained. Function Signature ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: TreeNode, val: int) -> TreeNode: pass ``` Input - `root`: The root node of the current BST (or `None` if the tree is empty). - `val`: An integer value to be inserted into the BST. Output - Returns the root node of the BST after insertion. Constraints - The input BST will have at most 1000 nodes. - Node values are unique within the BST. - The BST properties must be maintained after insertion. Performance Requirements - The solution should achieve an average time complexity of O(log N) in a balanced BST. - Ensure the function handles large trees efficiently respecting the constraints. Example ```python # Initial BST: # 4 # / # 2 7 # / # 1 3 root = TreeNode(4) root.left = TreeNode(2, TreeNode(1), TreeNode(3)) root.right = TreeNode(7) # Insert value 5 # Resulting BST: # 4 # / # 2 7 # / / # 1 3 5 new_root = insert_into_bst(root, 5) ``` Detailed Steps 1. If the root is `None`, create a new node with the given value and return it as the new root. 2. Starting from the root, traverse the tree: - If the value to be inserted is less than the current node\'s value, move to the left child. - If the value to be inserted is greater than the current node\'s value, move to the right child. 3. If a null position is found (left or right child of a node is `None`), create a new node with the given value and assign it to that position. 4. Return the root of the tree after insertion. Edge Cases - Handle the case where the BST is initially empty. - Ensure that the value to be inserted does not already exist in the BST. # Implementation Notes The function is expected to properly insert the value into the BST while maintaining its properties. The insertion process involves tree traversal and finding the appropriate position for the new node. This can be implemented using recursion or iteration. Ensure that all nodes are compared correctly, and the BST structure is preserved.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def insert_into_bst(root: TreeNode, val: int) -> TreeNode: if root is None: return TreeNode(val) if val < root.val: if root.left is None: root.left = TreeNode(val) else: insert_into_bst(root.left, val) else: if root.right is None: root.right = TreeNode(val) else: insert_into_bst(root.right, val) return root"},{"question":"# Question Title: Fibonacci Sequence Checker Write a Python function `is_fibonacci_number(n: int) -> bool` that takes an integer as input and returns whether the number is a part of the Fibonacci sequence. The Fibonacci sequence is defined as: F(0) = 0, F(1) = 1, F(n) = F(n-1) + F(n-2). Function Signature: ```python def is_fibonacci_number(n: int) -> bool: ``` Input: - an integer `n` (0 ≤ n ≤ 10^18) Output: - A boolean indicating whether `n` is a part of the Fibonacci sequence. Constraints: 1. The function should handle inputs up to 10^18 efficiently. 2. Negative numbers are not considered part of the Fibonacci sequence. 3. Non-integer values should raise a `ValueError`. 4. Zero is considered part of the Fibonacci sequence. Example: ```python assert is_fibonacci_number(0) == True assert is_fibonacci_number(1) == True assert is_fibonacci_number(2) == True assert is_fibonacci_number(3) == True assert is_fibonacci_number(5) == True assert is_fibonacci_number(8) == True assert is_fibonacci_number(13) == True assert is_fibonacci_number(21) == True assert is_fibonacci_number(4) == False assert is_fibonacci_number(6) == False assert is_fibonacci_number(7) == False assert is_fibonacci_number(9) == False ``` Performance requirements: The function should be optimized to determine membership in the Fibonacci sequence efficiently for very large numbers up to the upper constraint. Scenario: Consider working on a bioinformatics project where identifying Fibonacci numbers among a sequence of biological data points is critical. Accurate and efficient identification of these numbers is essential for analyzing the structural patterns in the data. Ensure your function accurately identifies Fibonacci numbers while adhering to the constraints specified.","solution":"import math def is_fibonacci_number(n: int) -> bool: Returns whether the number \'n\' is a part of the Fibonacci sequence. Args: n (int): The number to check. Returns: bool: True if \'n\' is a Fibonacci number, False otherwise. if not isinstance(n, int): raise ValueError(\\"Input should be an integer.\\") if n < 0: return False # A number n is Fibonacci if and only if one or both of (5*n^2 + 4) or (5*n^2 - 4) # is a perfect square (source: mathematical property of Fibonacci numbers). def is_perfect_square(num): s = int(math.isqrt(num)) return s * s == num x1 = 5 * n * n + 4 x2 = 5 * n * n - 4 return is_perfect_square(x1) or is_perfect_square(x2)"},{"question":"# Coding Assessment Question In many applications, it is important to determine whether a given string of characters forms a valid expression, typically encompassing mathematical operations or other structural rules. One common task involves validating expressions with brackets. Write a function `validate_expression` that verifies whether a given string containing brackets is correctly balanced. The function should support the following types of brackets: parentheses `()`, square brackets `[]`, and curly braces `{}`. **Function Signature**: ```python def validate_expression(expression): pass ``` # Input and Output - **Input**: - `expression` - A string containing characters, including various types of brackets. - **Output**: - Returns a boolean - `True` if the brackets in the expression are balanced, otherwise `False`. # Constraints - The input string length will be between 0 and 10,000 characters. - The string may contain any printable ASCII characters. # Requirements & Performance - The function must correctly handle nested and mixed types of brackets. - It should efficiently process the input string, ideally in O(n) time complexity where n is the length of the input string. # Example ```python # Example 1 expression = \\"{[()]}\\" print(validate_expression(expression)) # Expected Output: True # Example 2 expression = \\"{[(])}\\" print(validate_expression(expression)) # Expected Output: False # Example 3 expression = \\"[({})](]\\" print(validate_expression(expression)) # Expected Output: False # Example 4 expression = \\"\\" print(validate_expression(expression)) # Expected Output: True # Example 5 expression = \\"a[b(c)d]{e}\\" print(validate_expression(expression)) # Expected Output: True ``` # Explanation - In Example 1, all types of brackets are properly nested and balanced. - In Example 2, the order of brackets is incorrect making it unbalanced. - In Example 3, there\'s an unmatched closing bracket that causes imbalance. - In Example 4, an empty string is trivially balanced. - In Example 5, the function should correctly ignore non-bracket characters and still confirm correct bracketing. Make sure your implementation handles edge cases such as an empty string or strings without any brackets effectively, and maintains a high performance for longer inputs.","solution":"def validate_expression(expression): Validate if the given expression has balanced brackets. Supports (), [], {} brackets. stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in expression: if char in bracket_map.values(): stack.append(char) elif char in bracket_map.keys(): if stack == [] or bracket_map[char] != stack.pop(): return False return stack == []"},{"question":"# Array Manipulation - Rotation Given an integer array `arr` of size `n` and an integer `k`, rotate the array to the right by `k` positions. Your task is to implement a function that performs the rotation in place (modifying the original array) and uses only constant extra space. Constraints * Your solution should have a time complexity of O(n). * You must not use any additional data structures; the operation must be done in place. * You should handle cases where `k` is greater than `n`. Function Signature ```python def rotate_array(arr: list, k: int) -> None: # Implement your function here ``` Example Usage ```python # Example usage arr1 = [1, 2, 3, 4, 5] rotate_array(arr1, 2) print(arr1) # Output: [4, 5, 1, 2, 3] arr2 = [1, 2, 3, 4, 5] rotate_array(arr2, 5) print(arr2) # Output: [1, 2, 3, 4, 5] arr3 = [1, 2, 3, 4, 5] rotate_array(arr3, 7) print(arr3) # Output: [4, 5, 1, 2, 3] (since 7 % 5 == 2) ``` Write the function `rotate_array` to rotate the elements of the given array to the right by `k` positions, ensuring the results match the expected output shown in the example usage.","solution":"def rotate_array(arr: list, k: int) -> None: Rotates the array \'arr\' to the right by \'k\' positions in-place. n = len(arr) k = k % n # Handle cases where k is greater than n # Reverse the entire array arr.reverse() # Reverse the first k elements arr[:k] = reversed(arr[:k]) # Reverse the remaining elements arr[k:] = reversed(arr[k:])"},{"question":"# Sum of All Digits Context: You are building a feature for a financial application that requires the calculation of the sum of all digits of a given integer. This feature is critical for validating numerical inputs as per certain business rules in banking and finance sectors. Problem Statement: Write a function `sum_of_digits(num: int) -> int` that computes the sum of all digits of the provided integer `num`. The function should handle both positive and negative integers gracefully. Input: - An integer `num` which can be positive, negative, or zero. Output: - An integer representing the sum of all individual digits of the absolute value of `num`. Constraints: - The function should execute in O(d) time complexity where d is the number of digits in the integer. - The solution should leverage arithmetic operations and avoid converting the number to a string. Examples: ``` >>> sum_of_digits(123) 6 >>> sum_of_digits(-456) 15 >>> sum_of_digits(0) 0 >>> sum_of_digits(78902) 26 >>> sum_of_digits(-9876) 30 ``` Performance Requirements: - Ensure the solution is optimized for readability and performance within the given constraints. Implementation Challenge: Implement the function `sum_of_digits` while taking into consideration the handling of negative numbers through their absolute values and ensuring the addition of each digit is performed efficiently. (Note: Utilize Python\'s built-in integer operations, focusing on arithmetic techniques to extract and sum the digits.)","solution":"def sum_of_digits(num: int) -> int: Computes the sum of all digits of the provided integer \'num\', considering the absolute value of the integer. Args: num (int): An integer which can be positive, negative, or zero. Returns: int: Sum of all individual digits of the absolute value of \'num\'. num = abs(num) total = 0 while num > 0: total += num % 10 num //= 10 return total"},{"question":"# Coding Question: Largest Prime Factor Problem Statement: Given a large number, your task is to find the largest prime factor. The prime factors of a number are the prime numbers that divide it exactly (without leaving a remainder). Write a function `solution(n: int) -> int` where: - **Input**: - `n` (an integer) - the number for which you must find the largest prime factor. - **Output**: Output the largest prime factor of `n`. Function Signature: `def solution(n: int) -> int` **Examples**: ```python assert solution(13195) == 29 assert solution(600851475143) == 6857 assert solution(29) == 29 assert solution(50) == 5 ``` Constraints: - `n` will be at least 2 and can be as large as 10^{12}. Performance Requirements: - The solution should be efficient enough to handle large values of `n` (up to 10^{12}) without a significant increase in time or space complexity. **Hint**: Use a combination of trial division and optimization techniques to reduce the problem space.","solution":"def solution(n: int) -> int: Returns the largest prime factor of the given number n. # Initialize the largest prime factor max_prime = -1 # Divide n by 2 to remove all even factors while n % 2 == 0: max_prime = 2 n //= 2 # n must be odd at this point so we can skip even numbers for i in range(3, int(n**0.5) + 1, 2): while n % i == 0: max_prime = i n //= i # If n becomes a prime number greater than 2 if n > 2: max_prime = n return max_prime"},{"question":"**Problem Statement**: You are required to implement a simple spell checker for an English language file using the Damerau-Levenshtein distance algorithm. This algorithm calculates the minimum number of operations (insertions, deletions, substitutions, and transpositions) needed to transform one string into another. Write a Python function `spell_check(file_path: str, dictionary_path: str) -> list[tuple[str, str]]` that accomplishes the following: 1. Reads the input text file and identifies all unique words. 2. Checks each word against a given dictionary file, and finds the closest matching words using the Damerau-Levenshtein distance. 3. Returns a list of tuples where the first element is the original word from the input text and the second element is the closest matching word from the dictionary. **Function Signature**: ```python def spell_check(file_path: str, dictionary_path: str) -> list[tuple[str, str]]: pass ``` **Input**: - `file_path` (str): The path to the input text file. - `dictionary_path` (str): The path to the dictionary text file, where each line contains a single valid word. **Output**: - Returns a list of tuples. Each tuple contains: - The original word from the input text file. - The closest matching word from the dictionary. **Example**: Suppose `input.txt` contains the text: \\"helo wrld\\", and `dictionary.txt` contains the following words: ``` hello world spell check ``` - `spell_check(\'input.txt\', \'dictionary.txt\')` might return: ```python [ (\'helo\', \'hello\'), (\'wrld\', \'world\') ] ``` **Constraints/Limitations**: - Each word in the input file and the dictionary file will only contain alphabetical characters. - Treat words as case-insensitive; i.e., \\"Hello\\" and \\"hello\\" should be considered the same. - The dictionary file and input file will not be empty. - Implement proper file I/O error handling. **Additional Notes**: - Aim for an efficient implementation; avoid unnecessary computations. - You can use existing libraries for calculating Damerau-Levenshtein distance, but the main logic for reading files and matching words should be implemented by you. **Hints**: - Consider preprocessing the input and dictionary files to normalize case. - Use a priority queue to keep track of the closest matches efficiently.","solution":"import numpy as np def damerau_levenshtein_distance(s1, s2): Calculate the Damerau-Levenshtein distance between two strings s1 and s2. d = np.zeros((len(s1) + 1, len(s2) + 1), dtype=int) d[0] = np.arange(len(s2) + 1) d[:, 0] = np.arange(len(s1) + 1) for i in range(1, len(s1) + 1): for j in range(1, len(s2) + 1): cost = 0 if s1[i - 1] == s2[j - 1] else 1 d[i, j] = min(d[i - 1, j] + 1, # Deletion d[i, j - 1] + 1, # Insertion d[i - 1, j - 1] + cost) # Substitution if (i > 1 and j > 1 and s1[i - 1] == s2[j - 2] and s1[i - 2] == s2[j - 1]): d[i, j] = min(d[i, j], d[i - 2, j - 2] + 1) # Transposition return d[len(s1), len(s2)] def spell_check(file_path: str, dictionary_path: str) -> list[tuple[str, str]]: Checks and corrects the spelling of words in the given file using the Damerau-Levenshtein distance algorithm. :param file_path: Path of the input text file :param dictionary_path: Path of the dictionary text file :return: List of tuples where each tuple contains the original word and the closest matching word from the dictionary try: with open(file_path, \'r\') as f: input_words = set(f.read().lower().split()) with open(dictionary_path, \'r\') as f: dictionary_words = [line.strip().lower() for line in f] except Exception as e: print(\\"Error reading files:\\", e) return [] corrections = [] for word in input_words: min_distance = float(\'inf\') closest_word = word for dict_word in dictionary_words: distance = damerau_levenshtein_distance(word, dict_word) if distance < min_distance: min_distance = distance closest_word = dict_word corrections.append((word, closest_word)) return corrections"},{"question":"# Coding Assessment Question: Triangle Area Calculator Context: You are given three sides of a triangle (a, b, and c), and you need to calculate the area of the triangle using Heron\'s formula. The formula for the area ( A ) is: [ s = frac{a + b + c}{2} ] [ A = sqrt{s(s - a)(s - b)(s - c)} ] Task: Write a Python function `triangle_area` that takes three floating-point numbers: `side_a`, `side_b`, and `side_c`, and returns the area of the triangle calculated using Heron\'s formula. Input: * Three positive floating-point numbers `side_a`, `side_b`, and `side_c` representing the lengths of the sides of the triangle. Output: * A floating-point number representing the area of the triangle. Constraints: * All sides (`side_a`, `side_b`, `side_c`) must be positive. * The sum of any two sides must be greater than the third side (triangle inequality). Raise a `ValueError` if the sides do not satisfy the triangle inequality or are not positive. Example: ```python >>> triangle_area(3.0, 4.0, 5.0) 6.0 >>> triangle_area(7.0, 10.0, 5.0) 16.24807680927192 >>> triangle_area(3.0, 4.0, -5.0) Traceback (most recent call last): ... ValueError: All side lengths must be positive >>> triangle_area(1.0, 1.0, 3.0) Traceback (most recent call last): ... ValueError: The sides do not satisfy the triangle inequality ``` Requirements: 1. Ensure your function validates that all side lengths are positive. 2. Check that the side lengths satisfy the triangle inequality. 3. Include error handling to raise a `ValueError` on invalid input. 4. Optimize your code for readability and efficiency. Performance: * The function should run in constant time ( O(1) ). * Memory usage must be constant as well ( O(1) ).","solution":"import math def triangle_area(side_a, side_b, side_c): Calculate the area of a triangle using Heron\'s formula. Parameters: side_a (float): Length of the first side of the triangle. side_b (float): Length of the second side of the triangle. side_c (float): Length of the third side of the triangle. Returns: float: The area of the triangle. Raises: ValueError: If the side lengths are not positive or do not meet the triangle inequality. # Validate the input if side_a <= 0 or side_b <= 0 or side_c <= 0: raise ValueError(\\"All side lengths must be positive\\") if side_a + side_b <= side_c or side_a + side_c <= side_b or side_b + side_c <= side_a: raise ValueError(\\"The sides do not satisfy the triangle inequality\\") # Calculate the semi-perimeter s = (side_a + side_b + side_c) / 2 # Calculate the area using Heron\'s formula area = math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c)) return area"},{"question":"# Problem Statement Given an integer array `nums`, write a function to determine if it is possible to rearrange the elements of `nums` such that the sum of the absolute differences between all adjacent elements is minimized. If possible, return the rearranged array. If multiple rearrangements provide the same sum, return the lexicographically smallest one. If it is not possible to rearrange the elements (for example, if the array has less than two elements), return an empty array. # Function Signature ```python def minimize_adjacent_sum(nums: List[int]) -> List[int]: pass ``` # Input * `nums` (List[int]): A list of integers containing the elements of the array. # Output * Returns a list of integers that represents the rearranged array where the sum of the absolute differences between all adjacent elements is minimized. If it\'s not possible to rearrange, return an empty list. # Constraints * `1 <= len(nums) <= 10^5` * `-10^6 <= nums[i] <= 10^6` # Error Handling * If the length of `nums` is less than 2, return an empty list. # Example ```python >>> minimize_adjacent_sum([4, 2, 1, 3]) # Output: [1, 2, 3, 4] >>> minimize_adjacent_sum([10, 1, 5, 2]) # Output: [1, 2, 5, 10] >>> minimize_adjacent_sum([7]) # Output: [] ``` # Implementation Notes * The goal is to sort the array to minimize the sum of absolute differences. * Sorting ensures that the differences between adjacent elements are minimized. * You may use the built-in sorting functions available in Python.","solution":"from typing import List def minimize_adjacent_sum(nums: List[int]) -> List[int]: if len(nums) < 2: return [] return sorted(nums)"},{"question":"# Question: You are given the task of enhancing the performance of an existing `dijkstra` function used in a navigation system. The aim is to optimize the implementation to achieve better runtime efficiency for larger datasets. Function Signature: ```python def dijkstra_optimized(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: ``` # Requirements: 1. Optimize the `dijkstra` function to reduce its time complexity. 2. Ensure the function correctly computes the shortest paths from the start node to all other nodes in the graph. 3. Handle edge cases such as: - A graph with no connections. - A graph with only one node. 4. Validate correctness using the provided sample test cases and create additional tests if necessary. # Expected input and output formats: - **Input**: A graph represented as a dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight), and an integer `start` representing the starting node. - **Output**: A dictionary where keys are node identifiers and values are the shortest distance from the start node to that node. # Performance requirements: - **Aim for O((V + E) log V)** time complexity using a min-heap or priority queue, where `V` is the number of vertices and `E` is the number of edges. # Sample Test Cases: ```python graph = { 0: [(1, 4), (2, 1)], 1: [(3, 1)], 2: [(1, 2), (3, 5)], 3: [] } assert dijkstra_optimized(graph, 0) == {0: 0, 1: 3, 2: 1, 3: 4} graph = { 0: [(1, 1)], 1: [(2, 2), (3, 1)], 2: [(3, 3)], 3: [] } assert dijkstra_optimized(graph, 0) == {0: 0, 1: 1, 2: 3, 3: 2} ``` # Additional Context: - Optimize using appropriate data structures like priority queues (heaps). - Avoid unnecessary recomputation and ensure the algorithm correctly maintains the shortest path estimates efficiently. - Use libraries such as `heapq` in Python to assist with the priority queue implementation if necessary.","solution":"import heapq from typing import List, Tuple, Dict def dijkstra_optimized(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: # Initialize the distance to all nodes as infinity and distance to start node as 0 distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Priority queue for tracking minimum distance nodes priority_queue = [(0, start)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip if the current distance is more than the recorded distance if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Assessment Question Problem Statement **Context**: Jacob is fascinated by number theory and has recently learned about prime numbers and their significance in various fields including cryptography. He is especially interested in learning about the distribution of twin primes - pairs of prime numbers that differ by exactly two. Jacob wants to write a function to find out how many twin prime pairs exist up to a given integer `M`. **Task**: Implement a function `count_twin_primes(M: int) -> int` that computes the number of twin prime pairs `(p1, p2)` such that `p1` and `p2` are primes and `p2 = p1 + 2`, with both `p1` and `p2` less than or equal to `M`. **Function Signature**: ```python def count_twin_primes(M: int) -> int: ``` **Parameters**: - `M` (int): The upper limit up to which the twin prime pairs are to be counted (1 <= M <= 10^5). **Returns**: - (int): The count of twin prime pairs (p1, p2), where both p1 and p2 are <= M and p2 = p1 + 2. **Examples**: ```python assert count_twin_primes(10) == 2 # (3, 5) and (5, 7) assert count_twin_primes(15) == 3 # (3, 5), (5, 7) and (11, 13) assert count_twin_primes(30) == 5 # Includes pairs (3, 5), (5, 7), (11, 13), (17, 19), and (29, 31) assert count_twin_primes(100000) == correct_answer # Full example computation ``` **Notes**: * Ensure your algorithm is efficient and can handle large inputs up to 100,000. * Make use of efficient prime-checking techniques or sieve algorithms to identify primes up to `M`. * Pay careful attention to edge cases where `M` might be very small or large. * Consider both time and space complexity in your implementation. **Constraints**: * `1 <= M <= 100000` **Scenario**: Jacob is working on a research paper on prime distributions and needs accurate data on twin primes. Help Jacob by writing this efficient function.","solution":"def count_twin_primes(M: int) -> int: def sieve(n): is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False # 0 and 1 are not prime numbers p = 2 while p * p <= n: if is_prime[p]: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return is_prime primes = sieve(M) count = 0 for i in range(2, M - 1): if primes[i] and primes[i + 2]: count += 1 return count"},{"question":"# Permutation Cycles in Array You are tasked with implementing a function to find and return the sizes of permutation cycles in a given array. A permutation cycle is formed when you repeatedly follow indices starting from any element in the array and eventually return to the starting point. Given an array `arr` where each element represents a permutation of indices (0-based), determine the sizes of all distinct cycles in the permutation. Function Signature ```python def permutation_cycles(arr: list[int]) -> list[int]: pass ``` Input and Output - **Input**: - `arr` (list[int]): An array of integers where `arr[i]` represents the next index to visit starting from index `i`. - **Output**: - Returns a list of integers representing the sizes of all distinct permutation cycles in no particular order. Constraints - `1 <= len(arr) <= 10^5` - The elements of `arr` are a permutation of indices from `0` to `len(arr) - 1`. Example ```python assert permutation_cycles([1, 2, 0]) == [3] assert permutation_cycles([1, 0, 3, 4, 5, 2]) == [2, 3] ``` In the first example, the cycle is `0 -> 1 -> 2 -> 0`, which has a size of 3. In the second example, the cycle `0 -> 1 -> 0` has a size of 2, and the cycle `2 -> 3 -> 4 -> 5 -> 2` has a size of 3. Additional Information - The function should efficiently handle large arrays, ensuring time complexity of O(n) and utilizing O(n) space. - The order of the cycle sizes in the returned list does not matter. Implement the `permutation_cycles` function to meet these criteria.","solution":"def permutation_cycles(arr): def find_cycle_length(start, visited): current = start length = 0 while not visited[current]: visited[current] = True current = arr[current] length += 1 return length n = len(arr) visited = [False] * n cycle_sizes = [] for i in range(n): if not visited[i]: cycle_size = find_cycle_length(i, visited) cycle_sizes.append(cycle_size) return cycle_sizes"},{"question":"# Problem: Unique Element Finder In a given list of integers, most numbers appear exactly twice, while one number appears exactly once. Your task is to find the single number that appears only once. # Task Write a function `find_unique_element(nums: list[int]) -> int` that accepts a list of integers and returns the integer that appears only once. # Input * `nums` (list of int): A list of integers where each integer appears exactly twice except for one integer that appears exactly once. # Output * (int): The integer that appears only once in the list. # Constraints * The length of the input list will be odd and not exceed 1000 elements. * Each integer in the list will be between `-1000` and `1000`. # Example ```python def find_unique_element(nums: list[int]) -> int: # Implement this function pass # Example Usage print(find_unique_element([2, 3, 2, 4, 4, 3, 5])) # Output: 5 print(find_unique_element([-1, -1, 2, 2, 3])) # Output: 3 print(find_unique_element([1, 3, 4, 4, 3, 5, 5])) # Output: 1 print(find_unique_element([1000, -1000, 1000])) # Output: -1000 print(find_unique_element([7])) # Output: 7 ``` # Additional Information 1. The list will always contain at least one integer that appears exactly once. 2. The function must be optimized for performance, avoiding unnecessary complexity. 3. The order of elements in the list can be arbitrary and should not be altered while processing.","solution":"def find_unique_element(nums: list[int]) -> int: Returns the integer that appears exactly once in the list. All other integers in the list appear exactly twice. unique_number = 0 # XOR all numbers, pairs of similar numbers will cancel out each other for num in nums: unique_number ^= num return unique_number"},{"question":"Problem Overview You are given a string containing a large and potentially arbitrary sequence of characters. Your task is to compute the frequency of each character in the string and return a dictionary with characters as keys and their respective counts as values. The function should be efficient to handle large strings and non-alphanumeric characters, ensuring an optimal count retrieval. Detailed Description # Function Specification You need to implement the following function: ```python def char_frequency(s: str) -> dict[str, int]: Computes the frequency of each character in a given string. Parameters: s (str): A string consisting of any printable ASCII characters. Returns: dict[str, int]: A dictionary with characters as keys and their counts as values. pass ``` # Input - A string `s`, where 0 ≤ len(s) ≤ 10^6 and it contains any printable ASCII characters. # Output - A dictionary with characters as keys and their frequencies as values. # Constraints - The solution should be optimal and handle very large strings efficiently. # Example: ```python >>> char_frequency(\\"hello world\\") {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \' \': 1, \'w\': 1, \'r\': 1, \'d\': 1} >>> char_frequency(\\"aaaAAA\\") {\'a\': 3, \'A\': 3} >>> char_frequency(\\"\\") {} >>> char_frequency(\\"12345!@#%\\") {\'1\': 1, \'2\': 1, \'3\': 1, \'4\': 1, \'5\': 1, \'!\': 1, \'@\': 1, \'#\': 1, \'\': 1, \'%\': 1} ``` # Implementation Notes - Utilize efficient data structures for counting, such as `collections.Counter` from the `collections` module in Python. - Make sure the function handles edge cases like empty strings correctly. - The characters should be counted with case sensitivity, i.e., \'A\' and \'a\' are considered different characters. By developing the function to compute character frequencies, you will showcase your understanding of string manipulation, dictionary usage, and algorithmic efficiency.","solution":"from collections import Counter def char_frequency(s: str) -> dict[str, int]: Computes the frequency of each character in a given string using Counter from collections. Parameters: s (str): A string consisting of any printable ASCII characters. Returns: dict[str, int]: A dictionary with characters as keys and their counts as values. return dict(Counter(s))"},{"question":"# Question You are given a list of integers that may contain duplicates, and your task is to implement a function `find_max_without_consecutive_duplicates` that finds the maximum sum of a subsequence such that no two chosen numbers are adjacent (consecutively located in the original list) and no two chosen numbers are duplicates. Your implementation should optimize for both time and space complexity. # Input * **nums**: A list of integers. The list will contain between 1 and 1000 integers. # Output * An integer representing the maximum sum of the chosen subsequence. # Constraints * The integers can be negative, zero, or positive. * The length of the input list will be at least 1 and at most 1000. # Example ```python def find_max_without_consecutive_duplicates(nums: [int]) -> int: # Your implementation here # Example 1 print(find_max_without_consecutive_duplicates([3, 2, 5, 10, 7])) # Output: 15 # Explanation: Choose numbers 3, 10 and 2 (not adjacent and non-duplicate), which sum up to 15. # Example 2 print(find_max_without_consecutive_duplicates([-1, -2, -3, -4, -5])) # Output: -1 # Explanation: The best result is -1 as it\'s the largest single negative number we can choose. # Example 3 print(find_max_without_consecutive_duplicates([5, 5, 10, 100, 10, 5])) # Output: 110 # Explanation: Choose numbers 5 (first), 100, and 5 (last), which sum up to 110. # Example 4 print(find_max_without_consecutive_duplicates([3, 3, 3, 3, 3, 3])) # Output: 3 # Explanation: Only one instance of 3 can be chosen, giving a maximum sum of 3. ```","solution":"def find_max_without_consecutive_duplicates(nums): Finds the maximum sum of a subsequence such that no two chosen numbers are adjacent and no two chosen numbers are duplicates. if not nums: return 0 n = len(nums) if n == 1: return nums[0] # Remove consecutive duplicates unique_nums = [nums[0]] for i in range(1, n): if nums[i] != nums[i-1]: unique_nums.append(nums[i]) if len(unique_nums) == 1: return unique_nums[0] # Create a dp array to store the maximum sums dp = [0] * len(unique_nums) dp[0] = unique_nums[0] dp[1] = max(unique_nums[0], unique_nums[1]) for i in range(2, len(unique_nums)): dp[i] = max(dp[i-1], dp[i-2] + unique_nums[i]) return dp[-1]"},{"question":"# [New Question] # One-Time Pad Enhanced: Coding Challenge **Context**: In this task, you will implement the One-Time Pad encryption and decryption algorithm, with enhancements to handle uppercase and lowercase letters, digits, and special characters. **Objective**: Write functions to generate a random pad, encrypt a message using the pad, and decrypt the cipher text back to the original message. **Function Specifications**: 1. **generate_pad(message: str) -> str** - Input: * `message`: The original message (may contain uppercase, lowercase, digits, and special characters). - Output: * A randomly generated pad of the same length as the message. 2. **encrypt_message(message: str, pad: str) -> str** - Input: * `message`: The original message. * `pad`: The random pad. - Output: * The encrypted message, character by character using the pad. 3. **decrypt_message(encrypted_message: str, pad: str) -> str** - Input: * `encrypted_message`: The encrypted message. * `pad`: The random pad. - Output: * The decrypted message, matching the original message. **Requirements**: - Each character in the message should be XORed with the corresponding character in the pad to create the encrypted message. - For decryption, XOR the encrypted message with the same pad to retrieve the original message. - Ensure characters from the message (including special characters) and pad are properly encoded/decoded during the XOR operation. **Example**: ```python message = \\"Encrypt This Message 2023!\\" pad = generate_pad(message) encrypted_message = encrypt_message(message, pad) print(f\\"Encrypted Message = {encrypted_message}\\") original_message = decrypt_message(encrypted_message, pad) print(f\\"Original Message = {original_message}\\") # Expected Output: # Encrypted Message = {some encrypted string with special characters} # Original Message = Encrypt This Message 2023! ```","solution":"import os def generate_pad(message: str) -> str: Generates a random pad of the same length as the message. return \'\'.join(chr(os.urandom(1)[0]) for _ in range(len(message))) def encrypt_message(message: str, pad: str) -> str: Encrypts the message using the pad via XOR operation. if len(message) != len(pad): raise ValueError(\\"Message and pad must be of the same length\\") encrypted_message = \'\'.join(chr(ord(m) ^ ord(p)) for m, p in zip(message, pad)) return encrypted_message def decrypt_message(encrypted_message: str, pad: str) -> str: Decrypts the encrypted message using the pad via XOR operation. if len(encrypted_message) != len(pad): raise ValueError(\\"Encrypted message and pad must be of the same length\\") decrypted_message = \'\'.join(chr(ord(e) ^ ord(p)) for e, p in zip(encrypted_message, pad)) return decrypted_message"},{"question":"# Coding Assessment Question **Objective**: Implement a function that finds the intersection of two lists, returning a new list containing elements that are common to both lists. The result should maintain the order they appear in the first list. **Function Signature**: ```python def list_intersection(list1: list, list2: list) -> list: pass ``` # Input & Output * **Input Format**: * `list1`: A list of elements. Elements may be of any type (integers, strings, etc.). * `list2`: Another list of elements. Elements may be of any type and possibly different from `list1`. * **Output Format**: * A single list containing elements that are common between `list1` and `list2`, maintaining their order from `list1`. # Constraints * The total number of elements in both lists combined does not exceed (10^6). # Performance Requirements * Your implementation should be able to handle the length efficiently within the given constraints. # Example 1. **Example 1**: * Input: `[1, 2, 3, 4, 5]`, `[4, 3, 2, 1]` * Output: `[1, 2, 3, 4]` 2. **Example 2**: * Input: `[\\"apple\\", \\"banana\\", \\"cherry\\"]`, `[\\"banana\\", \\"apple\\", \\"cherry\\", \\"date\\"]` * Output: `[\\"apple\\", \\"banana\\", \\"cherry\\"]` 3. **Example 3**: * Input: `[1, 2, 3, 4, 5]`, `[6, 7, 8, 9]` * Output: `[]` 4. **Example 4**: * Input: `[1, 3, 5, 7]`, `[2, 3, 4, 7]` * Output: `[3, 7]` # Instructions * Implement the `list_intersection` function according to the given requirements. * Ensure your function is efficient and handles edge cases effectively. * Do not print anything in the function; return the result directly.","solution":"def list_intersection(list1: list, list2: list) -> list: This function finds the intersection of two lists and returns a new list containing elements that are common to both lists, maintaining the order they appear in the first list. set_list2 = set(list2) return [element for element in list1 if element in set_list2]"},{"question":"# Coding Exercise: Analyze Log Files for IP Address Activity You are given a record of log entries from different servers, where each log entry records the IP address of the client and the timestamp of the request. Your task is to identify the IP addresses that made the most requests during a given time frame. Implement a function `top_active_ips(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]` that returns a list of IP addresses that made the most requests during the given time frame. Input * `logs`: A list of tuples where each tuple (ip_address, timestamp) represents a log entry. * `ip_address` (string): The IP address of the client, formatted as a string (e.g., \\"192.168.1.1\\"). * `timestamp` (string): The timestamp of the request in the format \\"YYYY-MM-DD hh:mm:ss\\". * `start_time` (string): The start time of the query window in the format \\"YYYY-MM-DD hh:mm:ss\\". * `end_time` (string): The end time of the query window in the format \\"YYYY-MM-DD hh:mm:ss\\". Output * A list of strings representing the IP addresses that made the most requests during the given time frame. If multiple IPs have the same activity level, return them in lexicographical order. Constraints * The number of log entries (len(logs)) does not exceed 10^6. * The IP address is always a valid IPv4 address. * The timestamps are guaranteed to be valid and in chronological order. # Example ```python def top_active_ips(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]: # Write your code here. # Example Usage logs = [ (\\"192.168.1.1\\", \\"2023-01-01 10:00:00\\"), (\\"192.168.1.2\\", \\"2023-01-01 10:05:00\\"), (\\"192.168.1.1\\", \\"2023-01-01 10:10:00\\"), (\\"192.168.1.3\\", \\"2023-01-01 10:15:00\\"), (\\"192.168.1.2\\", \\"2023-01-01 10:20:00\\"), (\\"192.168.1.3\\", \\"2023-01-01 10:25:00\\"), (\\"192.168.1.1\\", \\"2023-01-01 10:30:00\\") ] start_time = \\"2023-01-01 10:00:00\\" end_time = \\"2023-01-01 10:20:00\\" print(top_active_ips(logs, start_time, end_time)) # Expected Output: [\\"192.168.1.1\\", \\"192.168.1.2\\"] start_time = \\"2023-01-01 10:15:00\\" end_time = \\"2023-01-01 10:30:00\\" print(top_active_ips(logs, start_time, end_time)) # Expected Output: [\\"192.168.1.3\\", \\"192.168.1.1\\"] ``` # Hints 1. **Filtering Logs**: First filter the log entries to include only those within the specified time frame. 2. **Count Requests**: Count the number of requests made by each IP address during the filtered time frame. 3. **Sorting and Selection**: Identify the IP addresses with the highest request counts and sort them lexicographically to obtain the final result.","solution":"from typing import List, Tuple from collections import defaultdict def top_active_ips(logs: List[Tuple[str, str]], start_time: str, end_time: str) -> List[str]: counts = defaultdict(int) for ip, timestamp in logs: if start_time <= timestamp <= end_time: counts[ip] += 1 max_requests = max(counts.values(), default=0) result = [ip for ip, count in counts.items() if count == max_requests] return sorted(result)"},{"question":"# Coding Assessment Question: Context You\'re part of a start-up developing an advanced calendar application. The application must manage and organize numerous events efficiently. Users often need to find all upcoming events within a specific date range. Task Implement a function `filter_events(events: list[dict], start_date: str, end_date: str) -> list[dict]` that filters a list of events to include only those occurring within a given date range. Each event is represented by a dictionary with at least the keys `\\"id\\"` (an integer uniquely identifying the event) and `\\"date\\"` (a string representing the event\'s date in the format: \'YYYY-MM-DD\'). Constraints * The input list can be very large, containing up to (10^5) events. * The date range is given with `start_date` and `end_date` strings in the format \'YYYY-MM-DD\'. * The start and end dates are inclusive in the range. * Ensure the function is optimized to handle large datasets efficiently. Input & Output Format * Input: - `events` — a list of dictionaries where each dictionary contains at least the keys `\\"id\\"` (int) and `\\"date\\"` (str). - `start_date` — a string representing the starting date of the range in \'YYYY-MM-DD\' format. - `end_date` — a string representing the ending date of the range in \'YYYY-MM-DD\' format. * Output: A filtered list of dictionaries that fall within the specified date range, in the same format as they appear in the input list. Examples: * `filter_events([{\\"id\\": 1, \\"date\\": \\"2023-03-20\\"}, {\\"id\\": 2, \\"date\\": \\"2023-04-01\\"}, {\\"id\\": 3, \\"date\\": \\"2023-05-15\\"}], \\"2023-04-01\\", \\"2023-05-01\\")` should return `[{\\"id\\": 2, \\"date\\": \\"2023-04-01\\"}]` * `filter_events([{\\"id\\": 1, \\"date\\": \\"2022-12-15\\"}, {\\"id\\": 2, \\"date\\": \\"2023-01-10\\"}, {\\"id\\": 3, \\"date\\": \\"2023-07-04\\"}], \\"2023-01-01\\", \\"2023-06-01\\")` should return `[{\\"id\\": 2, \\"date\\": \\"2023-01-10\\"}]` Performance Requirements * The implementation should be competent in filtering large datasets efficiently. * Aim for linear performance in terms of time complexity where feasible.","solution":"from datetime import datetime def filter_events(events, start_date, end_date): Filters a list of events to include only those occurring within a given date range. Args: - events (list of dict): List of events where each event is a dictionary with at least \\"id\\" and \\"date\\" keys. - start_date (str): The start date in the format \'YYYY-MM-DD\'. - end_date (str): The end date in the format \'YYYY-MM-DD\'. Returns: - list of dict: Filtered list of events within the specified date range. start_date_dt = datetime.strptime(start_date, \'%Y-%m-%d\') end_date_dt = datetime.strptime(end_date, \'%Y-%m-%d\') filtered_events = [ event for event in events if start_date_dt <= datetime.strptime(event[\'date\'], \'%Y-%m-%d\') <= end_date_dt ] return filtered_events"},{"question":"# Coding Question: Find the Smallest Range Covering Elements from K Lists Background You are given `k` sorted linked lists of integers. Write a function `smallest_range(nums: list[list[int]]) -> list[int]` that finds the smallest range that includes at least one number from each of the `k` lists. The smallest range is defined as the interval `[min, max]` where `min` is the smallest number in the range and `max` is the largest. The range should be inclusive, containing at least one element from each list. Constraints * 2 <= k <= 3500 * The total number of elements among all the lists doesn\'t exceed 10^5. * Each list is sorted in non-decreasing order. * Elements of each list are integers. Input Format * `nums`: A list of `k` lists of integers, where each list is sorted in non-decreasing order. Output Format * Return a list of two integers, `[min, max]`, representing the smallest range. Example ```python nums = [ [4, 10, 15, 24, 26], [0, 9, 12, 20], [5, 18, 22, 30] ] smallest_range(nums) # Output: [20, 24] nums = [ [1, 2, 3], [1, 2, 3], [1, 2, 3] ] smallest_range(nums) # Output: [1, 1] ``` Explanation In the first example, the range `[20, 24]` includes elements `24` from the first list, `20` from the second list, and `22` from the third list. It is the smallest such range that includes at least one number from each list. In the second example, the smallest range covering at least one element from each list is `[1, 1]`. Hint Consider using a min-heap (priority queue) to efficiently track and compare the minimum and maximum elements from the current sublists being examined. This allows you to maintain and update the smallest range dynamically.","solution":"import heapq def smallest_range(nums): min_heap = [] current_max = float(\'-inf\') # Initialize the heap for i in range(len(nums)): heapq.heappush(min_heap, (nums[i][0], i, 0)) # (value, list index, element index) current_max = max(current_max, nums[i][0]) min_range = [float(\'-inf\'), float(\'inf\')] while True: min_val, list_idx, ele_idx = heapq.heappop(min_heap) if current_max - min_val < min_range[1] - min_range[0]: min_range = [min_val, current_max] if ele_idx + 1 == len(nums[list_idx]): break next_val = nums[list_idx][ele_idx + 1] current_max = max(current_max, next_val) heapq.heappush(min_heap, (next_val, list_idx, ele_idx + 1)) return min_range"},{"question":"# Coding Challenge: String Compression You are working on a text editor software that optimizes storage by employing a basic form of text compression. Your task is to implement a function that compresses a given string using the following rules: - Consecutive characters are replaced with the character followed by the count of its occurrences. - If the compressed string is not smaller than the original string, the function should return the original string. Function Specification **Function 1**: `compress_string(s: str) -> str` Your task is to complete the implementation of a function that compresses a string based on the rules mentioned above. - **Input**: - `s` (a string): The string to be compressed. - **Output**: - A string that is the compressed version of the input string if it is shorter; otherwise, the original string. - **Constraints**: - `s` will only contain uppercase and lowercase alphabetic characters (no spaces or special characters). - The length of `s` will be at most `10^5`. - **Performance**: - Your solution must operate within O(n) time complexity. Example: ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abc\\") == \\"abc\\" assert compress_string(\\"aa\\") == \\"aa\\" assert compress_string(\\"abbbccde\\") == \\"abbbccde\\" ``` Implementation Requirements: 1. Ensure that the function operates within O(n) time complexity by iterating through the string only once. 2. Consider edge cases such as an empty string or a string with no repetitive characters. Good luck! Your contribution to optimizing text storage will significantly enhance the performance and efficiency of the text editor.","solution":"def compress_string(s: str) -> str: Compresses the given string using the rules specified. Consecutive characters are replaced with the character followed by the count of its occurrences. If the compressed string is not smaller than the original string, returns the original string. if not s: return s # Handle empty string case compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) compressed.append(str(count)) count = 1 # Append the last group compressed.append(s[-1]) compressed.append(str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"# Query Processing with Trie Data Structure Problem Statement You are tasked with implementing a simple search suggestion system using a Trie data structure. The system should allow for adding words to a Trie and querying it to find all words that start with a given prefix. # Function Definitions 1. `class TrieNode` - **Attributes**: - `children`: A dictionary where the keys are characters and values are `TrieNode` objects. - `word_end`: A boolean indicating if the node marks the end of a valid word. 2. `class Trie` - **Methods**: - `insert(word: str) -> None` - Adds a word to the Trie. - **Input**: A string `word`. - **Output**: None. - `search_with_prefix(prefix: str) -> list[str]` - Searches for all words in the Trie that start with the specified prefix. - **Input**: A string `prefix`. - **Output**: A list of strings representing words that start with the given prefix. # Constraints - The words to be added to the Trie will consist only of lowercase alphabetical letters. - The prefix for queries will also consist only of lowercase alphabetical letters. - There won\'t be duplicate words in the words to be added. - The Trie should efficiently handle addition and search operations even with a large number of words. # Example ```python trie = Trie() trie.insert(\\"apple\\") trie.insert(\\"apples\\") trie.insert(\\"apricot\\") trie.insert(\\"banana\\") trie.search_with_prefix(\\"app\\") # Expected output: [\\"apple\\", \\"apples\\"] trie.search_with_prefix(\\"ban\\") # Expected output: [\\"banana\\"] ``` # Notes - Implement an efficient search and insert operation by utilizing the Trie structure. - Consider edge cases such as querying for prefixes that do not exist or searching in an empty Trie. - Ensure that the search results are complete and return the whole words that start with the given prefix.","solution":"class TrieNode: def __init__(self): self.children = {} self.word_end = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.word_end = True def _find_prefix_node(self, prefix: str) -> TrieNode: node = self.root for char in prefix: if char in node.children: node = node.children[char] else: return None return node def _collect_words(self, node: TrieNode, prefix: str, words: list) -> None: if node.word_end: words.append(prefix) for char, child_node in node.children.items(): self._collect_words(child_node, prefix + char, words) def search_with_prefix(self, prefix: str) -> list[str]: words = [] prefix_node = self._find_prefix_node(prefix) if prefix_node: self._collect_words(prefix_node, prefix, words) return words"},{"question":"# Counting Valleys in a Hike Context: You are given a string representing a sequence of steps taken during a hike. Each step is represented by a character – \'U\' for an uphill step and \'D\' for a downhill step. You start at sea level, and you need to determine the number of valleys encountered during the hike. A valley is a sequence of consecutive steps below sea level that starts with a step down (\'D\') from sea level and ends with a step up (\'U\') to sea level. Specifications: * Function Signature: `def count_valleys(steps: str) -> int` * Input: * A string `steps` consisting of characters \'U\' and \'D\' * Output: * An integer representing the number of valleys encountered during the hike. Constraints: 1. The input string can be empty or have up to 10,000 characters. 2. The string will consist only of the characters \'U\' and \'D\'. 3. The hike always starts at sea level. Example: ```python count_valleys(\\"UDDDUDUU\\") # Returns 1 count_valleys(\\"DDUUUUDD\\") # Returns 1 count_valleys(\\"UUU\\") # Returns 0 count_valleys(\\"DUDUDU\\") # Returns 3 count_valleys(\\"\\") # Returns 0 ``` Task: Implement `count_valleys()` that meets the above specifications. The function should correctly handle edge cases, such as an empty string or a string without any valleys.","solution":"def count_valleys(steps: str) -> int: Returns the number of valleys encountered during the hike. A valley is a sequence of consecutive steps below sea level that starts with a step down (\'D\') from sea level and ends with a step up (\'U\') to sea level. :param steps: A string consisting only of \'U\' and \'D\' :return: An integer representing the number of valleys sea_level = 0 current_level = 0 valleys = 0 for step in steps: if step == \'U\': current_level += 1 elif step == \'D\': current_level -= 1 if current_level == sea_level and step == \'U\': valleys += 1 return valleys"},{"question":"# Problem Statement You are tasked with implementing a function that can generate all unique permutations of a given list of integers. The function should handle lists that may contain duplicate elements and ensure that permutations are generated in a lexicographic order. # Requirements: 1. **Function to Generate Permutations**: - Name: `generate_unique_permutations` - Input: A list of integers `nums`. - Output: A list of lists, where each inner list is a unique permutation of the input list `nums`. - Constraints: - The input list may contain duplicate elements. - Return the permutations in lexicographic order (sorted order). # Example: ```python def generate_unique_permutations(nums: list[int]) -> list[list[int]]: # Your implementation here pass # Example usage input_list = [1, 1, 2] output = generate_unique_permutations(input_list) print(output) # Expected output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]] ``` # Notes: - You may use any standard library or module in Python to aid your implementation. - Ensure that the implementation handles edge cases, such as empty lists and lists with a single element. - Consider the efficiency of your solution, especially for larger input lists. # Additional Examples: ```python # Example 1 input_list = [1, 2, 3] output = generate_unique_permutations(input_list) # Expected output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] # Example 2 input_list = [3, 3, 0, 3] output = generate_unique_permutations(input_list) # Expected output: [[0, 3, 3, 3], [3, 0, 3, 3], [3, 3, 0, 3], [3, 3, 3, 0]] ``` # Constraints: - The length of the input list `nums` will not exceed 9. - Each element in the input list is an integer in the range [-10^9, 10^9].","solution":"from itertools import permutations def generate_unique_permutations(nums): Generate all unique permutations of the given list of integers. Args: nums (list): List of integers that may contain duplicates. Returns: list: A list of unique permutations, each permutation is represented as a list of integers. # Generate all permutations using itertools.permutations all_permutations = permutations(nums) # Use a set to filter out duplicates and then sort them unique_permutations = sorted(set(all_permutations)) # Convert each tuple in the set back to a list result = [list(permutation) for permutation in unique_permutations] return result"},{"question":"# Problem Statement You\'re tasked with designing a basic file system that supports the creation of directories and files, and querying the size of any directory. Each directory can contain sub-directories and files, and the size of a directory is the sum of the sizes of its files and all files in its sub-directories. # Function Signature ```python class FileSystem: def __init__(self): pass def mkdir(self, path: str) -> None: pass def addFile(self, path: str, size: int) -> None: pass def getSize(self, path: str) -> int: pass ``` # Input - `mkdir(path: str)` : Creates a directory at the specified path. The path is a string that represents the directory structure, e.g., \\"/a/b/c\\". - `addFile(path: str, size: int)`: Adds a file at the specified path with given `size`. The path includes the name of the file, e.g., \\"/a/b/c.txt\\". - `getSize(path: str)`: Returns the total size of files in the directory at the specified path, including files in any of its sub-directories. # Constraints 1. `path` will be a non-empty string containing only lowercase alphanumeric characters and forward slashes \'/\'. 2. Directory and file path lengths will not exceed 1000 characters. 3. The number of `mkdir`, `addFile`, and `getSize` operations will not exceed 10^4. 4. File sizes will be between 1 and 10^6. # Example ```python fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.addFile(\\"/a/b/file1.txt\\", 100) fs.addFile(\\"/a/file2.txt\\", 50) assert fs.getSize(\\"/a\\") == 150 assert fs.getSize(\\"/a/b\\") == 100 ``` # Explanation 1. The `mkdir(\\"/a\\")` and `mkdir(\\"/a/b\\")` commands create directories \\"/a\\" and \\"/a/b\\", respectively. 2. The `addFile(\\"/a/b/file1.txt\\", 100)` and `addFile(\\"/a/file2.txt\\", 50)` commands add files \\"file1.txt\\" of size 100 in directory \\"/a/b\\" and \\"file2.txt\\" of size 50 in directory \\"/a\\". 3. The `getSize(\\"/a\\")` command returns 150 because it is the total size of all files in \\"/a\\" and its sub-directory \\"/a/b\\". 4. The `getSize(\\"/a/b\\")` command returns 100 because it is the size of \\"file1.txt\\" in \\"/a/b\\". # Scenario You are implementing a file system for a cloud storage service that needs to efficiently manage directory and file structures, and calculate directory sizes for users querying their storage usage.","solution":"class FileSystem: def __init__(self): self.directories = {} self.files = {} def mkdir(self, path: str) -> None: if path not in self.directories: self.directories[path] = [] # Ensure parent directories exist parts = path.split(\'/\') for i in range(1, len(parts)): parent = \'/\'.join(parts[:i]) if parent and parent not in self.directories: self.directories[parent] = [] def addFile(self, path: str, size: int) -> None: dir_path, file_name = path.rsplit(\'/\', 1) self.mkdir(dir_path) # Ensure the directory exists self.files[path] = size def getSize(self, path: str) -> int: size = 0 for file_path, file_size in self.files.items(): if file_path.startswith(path + \'/\') or file_path == path: size += file_size return size"},{"question":"# Coding Assessment Question Scenario/Context In numerous algorithmic challenges, string manipulation and verification of specific properties within strings are common tasks. This problem will test your ability to assess palindromic properties of substrings, which is essential for understanding larger problems in fields like bioinformatics and data compression. Problem Statement Write a function `count_palindromic_substrings(s: str) -> int` that computes the number of palindromic substrings in a given string `s`. # Function Signature `def count_palindromic_substrings(s: str) -> int:` # Input * `s` (str): A string of lowercase English letters. # Output * Returns an integer, the total number of palindromic substrings present in the input string `s`. # Constraints * `1 <= len(s) <= 1000` # Example ```python >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"ababa\\") 9 ``` # Explanation 1. For the input `s = \\"abc\\"`, the palindromic substrings are \\"a\\", \\"b\\", and \\"c\\", totaling to 3. 2. For the input `s = \\"aaa\\"`, the palindromic substrings are \\"a\\" (3 times), \\"aa\\" (2 times) and \\"aaa\\", totaling to 6. 3. For the input `s = \\"ababa\\"`, the palindromic substrings are \\"a\\" (3 times), \\"b\\" (2 times), \\"aba\\" (2 times), and \\"ababa\\", totaling to 9. # Additional Points - A substring is defined as a contiguous sequence of characters within a string. - A palindromic string is a string that reads the same backward as forward. - Consider edge cases such as an empty string (should return 0), a single character string (should return 1), and strings with repeated characters.","solution":"def count_palindromic_substrings(s: str) -> int: Returns the total number of palindromic substrings in the given string `s`. n = len(s) count = 0 # Helper function to count palindromes centered at left and right def count_palindromes_around_center(left: int, right: int) -> int: num_palindromes = 0 while left >= 0 and right < n and s[left] == s[right]: num_palindromes += 1 left -= 1 right += 1 return num_palindromes for i in range(n): # Odd length palindromes centered at i count += count_palindromes_around_center(i, i) # Even length palindromes centered between i and i+1 count += count_palindromes_around_center(i, i + 1) return count"},{"question":"# Problem Statement Given a string `s` containing only lowercase English letters, you are required to implement a function that generates all possible distinct palindromic substrings of `s`. A palindromic substring is defined as a substring that reads the same forwards and backwards. # Function Signature ```python def find_palindromic_substrings(s: str) -> List[str]: pass ``` # Input * `s`: A string containing only lowercase English letters, where (0 leq text{len}(s) leq 20). # Output * A list of unique palindromic substrings in lexicographical order. # Constraints * The function should handle cases where the string is empty. * The function should not use additional libraries specifically for finding palindromic substrings. * Substrings should appear in lexicographical order in the resulting list. * The function\'s runtime should be optimized as much as possible given the constraints. # Example ```python >>> find_palindromic_substrings(\\"\\") [] >>> find_palindromic_substrings(\\"a\\") [\\"a\\"] >>> find_palindromic_substrings(\\"abc\\") [\\"a\\", \\"b\\", \\"c\\"] >>> find_palindromic_substrings(\\"aaa\\") [\\"a\\", \\"aa\\", \\"aaa\\"] >>> find_palindromic_substrings(\\"ababa\\") [\\"a\\", \\"aba\\", \\"ababa\\", \\"b\\", \\"bab\\"] ``` # Additional Information Make sure that the solution considers all possible substrings and correctly identifies and returns distinct palindromic substrings in the specified order. Using dynamic programming techniques or expanding around potential centers might be helpful to achieve optimal performance.","solution":"def is_palindrome(sub: str) -> bool: return sub == sub[::-1] def find_palindromic_substrings(s: str): palindromes = set() n = len(s) for i in range(n): for j in range(i, n): sub = s[i:j+1] if is_palindrome(sub): palindromes.add(sub) return sorted(palindromes)"},{"question":"# Coding Assessment Question # Context You are developing a management system for a railway station. One of the tasks is to manage the train schedules and detect any overlaps between the schedules. The primary goal is to determine if any two trains are scheduled to be on the same track at the same time, which could result in a collision. # Problem Statement Write a Python function `detect_schedule_overlap(trains)` that detects any overlapping schedules between the trains and raises an exception if any overlap is found. If no overlaps are found, the function should return True. # Function Signature ```python def detect_schedule_overlap(trains: list[dict]) -> bool: ``` # Input - `trains (list[dict])`: A list of dictionaries, where each dictionary represents a train\'s schedule. Each dictionary has the following keys: - `train_id` (int): The unique identifier of the train. - `track` (int): The track on which the train is scheduled to run. - `start_time` (int): The start time of the train\'s schedule in 24-hour format (e.g., 1300 for 1:00 PM). - `end_time` (int): The end time of the train\'s schedule in 24-hour format (e.g., 1500 for 3:00 PM). # Output - `result (bool)`: Returns True if no overlapping schedules are detected. Raises a `ValueError` if any overlapping schedules are found with the message \\"Overlap detected between train {train_id_1} and train {train_id_2} on track {track}\\". # Constraints - `train_id` is unique for each train. - `0 <= start_time < end_time <= 2359` - The time intervals for `start_time` and `end_time` are calculated in minutes for granularity. # Example Usage ```python trains = [ {\'train_id\': 1, \'track\': 1, \'start_time\': 1000, \'end_time\': 1200}, {\'train_id\': 2, \'track\': 1, \'start_time\': 1130, \'end_time\': 1300}, {\'train_id\': 3, \'track\': 2, \'start_time\': 1100, \'end_time\': 1230} ] result = detect_schedule_overlap(trains) # Raises ValueError: Overlap detected between train 1 and train 2 on track 1 ``` # Example Implementation ```python def detect_schedule_overlap(trains: list[dict]) -> bool: for i in range(len(trains)): for j in range(i + 1, len(trains)): if trains[i][\'track\'] == trains[j][\'track\']: if (trains[i][\'start_time\'] < trains[j][\'end_time\'] and trains[j][\'start_time\'] < trains[i][\'end_time\']): raise ValueError(f\\"Overlap detected between train {trains[i][\'train_id\']} and train {trains[j][\'train_id\']} on track {trains[i][\'track\']}\\") return True ``` Ensure your new question would integrate seamlessly into the existing set!","solution":"def detect_schedule_overlap(trains: list[dict]) -> bool: Detects overlapping schedules between trains. Args: trains (list[dict]): A list of dictionaries, where each dictionary represents a train\'s schedule. Returns: bool: True if no overlapping schedules are detected, otherwise raises ValueError. for i in range(len(trains)): for j in range(i + 1, len(trains)): if trains[i][\'track\'] == trains[j][\'track\']: if (trains[i][\'start_time\'] < trains[j][\'end_time\'] and trains[j][\'start_time\'] < trains[i][\'end_time\']): raise ValueError(f\\"Overlap detected between train {trains[i][\'train_id\']} and train {trains[j][\'train_id\']} on track {trains[i][\'track\']}\\") return True"},{"question":"# Ticket Price Calculation You are tasked with developing a system to calculate the total cost of movie tickets for a group. The system should take into account the different ticket prices for various age groups: children, adults, and seniors. Function Definition Implement a function `calculate_total_cost(ages: list[int], child_price: float, adult_price: float, senior_price: float) -> float` that takes a list of integers `ages` where each integer represents the age of a person in the group, along with the ticket prices for children, adults, and seniors, and returns the total cost as a float. Input Format * `ages` is a list of up to 100 integers, each representing the age of a person. * `child_price` is a float representing the price for a child\'s ticket (age 0-12). * `adult_price` is a float representing the price for an adult\'s ticket (age 13-64). * `senior_price` is a float representing the price for a senior\'s ticket (age 65 and above). Output Format * Return the total cost as a float rounded to two decimal places. Constraints * Each age is a non-negative integer. * Prices for child, adult, and senior tickets are non-negative floats. Performance Requirements * The function should efficiently calculate the total cost with linear complexity relative to the number of ages given. # Example ```python >>> calculate_total_cost([5, 10, 15, 30, 70], 5.00, 10.00, 8.00) 43.00 >>> calculate_total_cost([0, 12, 13, 25, 64, 65, 80], 7.50, 12.00, 9.00) 70.50 ``` # Notes 1. A child is defined as anyone aged 0 through 12. 2. An adult is defined as anyone aged 13 through 64. 3. A senior is defined as anyone aged 65 and older. 4. Consider edge cases such as empty lists or ages exactly at the boundary between two categories (e.g., 12/13 or 64/65).","solution":"def calculate_total_cost(ages: list[int], child_price: float, adult_price: float, senior_price: float) -> float: Calculates the total cost of movie tickets for a group based on their ages and ticket prices for different age categories. :param ages: List of ages of the people in the group. :param child_price: Price for a child\'s ticket. :param adult_price: Price for an adult\'s ticket. :param senior_price: Price for a senior\'s ticket. :return: Total cost of the movie tickets rounded to two decimal places. total_cost = 0.0 for age in ages: if 0 <= age <= 12: total_cost += child_price elif 13 <= age <= 64: total_cost += adult_price elif age >= 65: total_cost += senior_price return round(total_cost, 2)"},{"question":"# String Pattern Matching Challenge You are working on a text analysis tool that needs to detect patterns in strings. You have been tasked with implementing a function that locates all starting indices of a specified pattern within a given text. Task 1. Implement the following function: - `find_pattern_indices(text: str, pattern: str) -> list`: This function takes two strings: `text` and `pattern`. It returns a list of all starting indices where the pattern is found in the text. Input and Output Formats: * Input: Two strings `text` and `pattern`. - `text` represents the main string where the pattern search is conducted. - `pattern` represents the substring to search for within the text. * Output: A list of integers. Each integer is a zero-based index indicating the start position of the pattern in the text. Constraints: - Both `text` and `pattern` will contain only printable ASCII characters. - The length of `text` will not exceed (10^6). - The length of `pattern` will not exceed (10^5). - If `pattern` is an empty string, return an empty list. Examples: **Case 1:** ```python find_pattern_indices(\\"abracadabra\\", \\"abra\\") # Output: [0, 7] ``` **Case 2:** ```python find_pattern_indices(\\"aaaaaa\\", \\"aa\\") # Output: [0, 1, 2, 3, 4] ``` **Case 3:** ```python find_pattern_indices(\\"hello\\", \\"world\\") # Output: [] ``` **Case 4:** ```python find_pattern_indices(\\"hello\\", \\"\\") # Output: [] ``` Write your implementation of the function and ensure it handles edge cases efficiently. Consider performance implications, especially for large inputs.","solution":"def find_pattern_indices(text: str, pattern: str) -> list: if not pattern: return [] return [i for i in range(len(text) - len(pattern) + 1) if text[i:i+len(pattern)] == pattern]"},{"question":"# Problem Statement Implement a function `flatten_and_sort` that takes a list of lists of integers, flattens it into a single list, and returns it sorted in ascending order. # Requirements 1. **Function Signature**: ```python def flatten_and_sort(array: List[List[int]]) -> List[int]: ``` 2. **Inputs**: * `array` (List[List[int]]): A list containing multiple lists of integers. Each nested list contains integers that may range widely and can be of different lengths. 3. **Outputs**: * Returns a single list of integers, which is the result of flattening the input `array` and sorting the resultant list in ascending order. 4. **Constraints**: * The input list and its nested lists can be empty but the function should handle these as valid cases. # Example Usage ```python >>> flatten_and_sort([[3, 2, 1], [4, 6, 5], [], [9, 7, 8]]) [1, 2, 3, 4, 5, 6, 7, 8, 9] >>> flatten_and_sort([[], [], [], []]) [] >>> flatten_and_sort([[1, 3, 5], [2, 4, 6]]) [1, 2, 3, 4, 5, 6] >>> flatten_and_sort([[10, -1], [0], [3, 12, 5], [-4]]) [-4, -1, 0, 3, 5, 10, 12] ``` # Additional Notes - Make sure that the function handles edge cases such as empty nested lists or no integer input gracefully. - The function should be efficient and not use unnecessary additional space.","solution":"from typing import List def flatten_and_sort(array: List[List[int]]) -> List[int]: Flattens a list of lists and sorts the resulting single list in ascending order. Parameters: - array: List[List[int]] : A list of lists of integers. Returns: - List[int] : A sorted list of integers, flattened from the input list of lists. # Flatten the list of lists flattened = [item for sublist in array for item in sublist] # Sort the flattened list flattened.sort() return flattened"},{"question":"# Coding Assessment Question Scenario You are working on an algorithm that requires calculating the number of distinct ways to climb a staircase with `n` steps, where you can either take 1 step, 2 steps, or 3 steps at a time. This is a variation of the Fibonacci sequence but extended to three terms. Your task is to develop an efficient solution that can handle reasonably large values of `n`. Task Write a function `count_ways_to_climb(n)` that calculates the number of distinct ways to climb a staircase with `n` steps taking 1, 2, or 3 steps at a time. Implement this in Python. Function Signature ```python def count_ways_to_climb(n: int) -> int: ``` Input - `n` (int): The number of steps in the staircase. Must be a non-negative integer. Output - (int): The number of distinct ways to climb the staircase. Constraints - The function should raise a `ValueError` if `n` is not a non-negative integer. - The function should perform efficiently for values of `n` up to at least 1000. Example ```python >>> count_ways_to_climb(3) 4 >>> count_ways_to_climb(5) 13 >>> count_ways_to_climb(0) 1 >>> count_ways_to_climb(-1) Traceback (most recent call last): ... ValueError: n must be a non-negative integer >>> count_ways_to_climb(\\"a\\") Traceback (most recent call last): ... ValueError: n must be an integer ``` Note that your implementation should correctly handle invalid inputs and edge cases as demonstrated in the example.","solution":"def count_ways_to_climb(n): Returns the number of distinct ways to climb a staircase with `n` steps taking 1, 2, or 3 steps at a time. if not isinstance(n, int): raise ValueError(\\"n must be an integer\\") if n < 0: raise ValueError(\\"n must be a non-negative integer\\") if n == 0: return 1 elif n == 1: return 1 elif n == 2: return 2 # Using a bottom-up approach to store ways to climb up to the nth step ways = [0] * (n + 1) ways[0] = 1 ways[1] = 1 ways[2] = 2 for i in range(3, n + 1): ways[i] = ways[i-1] + ways[i-2] + ways[i-3] return ways[n]"},{"question":"# Problem Statement You are required to implement a `FileSystem` class that simulates a simplified hierarchical file system. Your task is to add the following features: 1. Create directories and files within the file system. 2. Navigate through the directory structure. 3. List the contents of a directory. 4. Maintain a current working directory and support changing it. # Requirements Directory and File Creation - Implement methods to create directories (`mkdir`) and files (`touch`). Navigation - Implement methods to change the current working directory (`cd`) and get the current working directory path (`pwd`). Listing Contents - Implement a method to list the contents of the current directory (`ls`). # Function Signatures You will need to implement the following methods in the `FileSystem` class. 1. `mkdir(self, path: str) -> None`: - Creates a directory at the specified `path`. If the path is relative, it is relative to the current working directory. 2. `touch(self, path: str) -> None`: - Creates a file at the specified `path`. If the path is relative, it is relative to the current working directory. 3. `cd(self, path: str) -> None`: - Changes the current working directory to the specified `path`. If the path is relative, it is relative to the current working directory. Supports the use of `..` to go up to the parent directory. 4. `pwd(self) -> str`: - Returns the absolute path of the current working directory. 5. `ls(self) -> List[str]`: - Lists the contents of the current directory, including both files and directories, sorted lexicographically. # Constraints - Paths are provided in Unix format (`/dir1/dir2/file` or `dir1/dir2/file`). - Assume all paths and names are valid strings. - Use common directory and file name characters (alphanumeric and `-_./`). # Example Usage ```python fs = FileSystem() fs.mkdir(\\"/a\\") fs.mkdir(\\"/a/b\\") fs.touch(\\"/a/b/file.txt\\") assert fs.pwd() == \\"/\\" fs.cd(\\"/a/b\\") assert fs.pwd() == \\"/a/b\\" # Add more commands as necessary for your unit tests. # ls should return a sorted list of directory contents assert fs.ls() == [\\"file.txt\\"] fs.cd(\\"..\\") assert fs.pwd() == \\"/a\\" assert fs.ls() == [\\"b\\"] # Implement the FileSystem class and its methods if __name__ == \\"__main__\\": unittest.main() ``` # Notes - Ensure your methods work seamlessly and handle edge cases, such as navigating beyond root, creating nested directories, etc. - Write unit tests to comprehensively cover the features and edge cases. - Focus on creating an intuitive and thorough implementation that aligns with typical file system behavior.","solution":"def path_to_dict(path): node = {} for part in path.split(\'/\'): if part: node = node.setdefault(part, {}) return node class FileSystem: def __init__(self): self.file_system = {} self.current_directory = [] def mkdir(self, path: str) -> None: node = self.file_system if not path.startswith(\'/\'): node = path_to_dict(\'/\'.join(self.current_directory)) for part in path.split(\'/\'): if part: node = node.setdefault(part, {}) def touch(self, path: str) -> None: node = self.file_system if not path.startswith(\'/\'): node = path_to_dict(\'/\'.join(self.current_directory)) parts = path.split(\'/\') for part in parts[:-1]: if part: node = node.setdefault(part, {}) node[parts[-1]] = None def cd(self, path: str) -> None: if path.startswith(\'/\'): self.current_directory = [part for part in path.split(\'/\') if part] else: for part in path.split(\'/\'): if part == \'..\': if self.current_directory: self.current_directory.pop() else: self.current_directory.append(part) def pwd(self) -> str: return \'/\' + \'/\'.join(self.current_directory) def ls(self) -> list: node = self.file_system for part in self.current_directory: node = node[part] return sorted(node.keys())"},{"question":"# Determine Path in a Tree Objective Write a function that determines if there is a path between two nodes in an undirected tree, represented as an adjacency list. Function Signature ```python def is_path_in_tree(adj_list: dict[int, list[int]], start: int, end: int) -> bool: ``` Input * `adj_list`: A dictionary where each key is an integer representing a node, and the value is a list of integers representing its neighboring nodes. * `start`: An integer representing the starting node. * `end`: An integer representing the ending node. Output * Returns a boolean value: - `True` if there is a path between the `start` node and the `end` node, - `False` otherwise. Constraints 1. The tree will contain between 1 and 1000 nodes. 2. All node values are within the range of 0 to 1000, inclusive. 3. The tree is connected and acyclic. 4. `start` and `end` will always be valid nodes in the tree. 5. The adjacency list will represent a valid tree structure without self-loops or multiple edges. Example ```python adj_list1 = { 0: [1, 2], 1: [0, 3, 4], 2: [0], 3: [1], 4: [1] } assert is_path_in_tree(adj_list1, 0, 3) == True assert is_path_in_tree(adj_list1, 2, 4) == True assert is_path_in_tree(adj_list1, 3, 2) == True assert is_path_in_tree(adj_list1, 5, 1) == False adj_list2 = { 0: [1, 2], 1: [0, 3], 2: [0], 3: [1, 4], 4: [3, 5], 5: [4] } assert is_path_in_tree(adj_list2, 0, 5) == True assert is_path_in_tree(adj_list2, 4, 0) == True assert is_path_in_tree(adj_list2, 5, 3) == True assert is_path_in_tree(adj_list2, 2, 5) == True assert is_path_in_tree(adj_list2, 1, 6) == False ``` Notes 1. Consider using depth-first search (DFS) or breadth-first search (BFS) to explore the tree. 2. Ensure to handle edge cases where the tree has only one node. 3. Your implementation should be efficient in both time and space complexity for large trees.","solution":"def is_path_in_tree(adj_list: dict[int, list[int]], start: int, end: int) -> bool: Returns True if there is a path between start and end nodes in an undirected tree, otherwise returns False. if start == end: return True visited = set() # Use Depth First Search (DFS) to find the path def dfs(node): if node in visited: return False visited.add(node) if node == end: return True for neighbor in adj_list.get(node, []): if dfs(neighbor): return True return False return dfs(start)"},{"question":"Question: Find Elements that Sum to Target in a Sorted Array You are given a sorted array of integers `arr` and a target integer `target`. Implement a function `find_pair(arr: list[int], target: int) -> tuple`: that finds two distinct elements in the array that sum up to the target value. # Function Signature: ```python def find_pair(arr: list[int], target: int) -> tuple[int, int] | None: ``` # Input: - `arr` (list[int]): A list of integers sorted in ascending order. - `target` (int): The target integer to find the sum. # Output: - A tuple containing two elements: - The pair of integers from the array that sum up to the target, or `None` if no such pair exists. # Constraints: - Each element in the array is unique. - The function should work in O(n) time complexity. # Example: ```python assert find_pair([1, 2, 3, 4, 5], 9) == (4, 5) assert find_pair([1, 2, 3, 4, 5], 3) == (1, 2) assert find_pair([1, 2, 3, 4, 5], 7) == (2, 5) assert find_pair([1, 2, 3, 4, 5], 10) == None ``` # Description: 1. Your function should efficiently find a pair of numbers that sum up to the given target. 2. Use a two-pointer technique starting from the beginning and end of the array to find the pair. 3. Return the pair of elements if found, otherwise return `None`. Good luck!","solution":"def find_pair(arr, target): Finds two numbers in the sorted array that sum up to the target value. Args: arr (list[int]): A sorted list of integers. target (int): The target sum. Returns: tuple[int, int] or None: A tuple of two integers that sum up to the target, or None if no such pair exists. left, right = 0, len(arr) - 1 while left < right: current_sum = arr[left] + arr[right] if current_sum == target: return (arr[left], arr[right]) elif current_sum < target: left += 1 else: right -= 1 return None"},{"question":"# Coding Question: Permutations with Duplicates **Objective**: Implement a function `permute_unique` that returns all unique permutations of a list of numbers that may contain duplicates. **Function Signature**: ```python def permute_unique(nums: list) -> list: pass ``` **Input**: - `nums`: A list of integers that may contain duplicates. **Output**: - A list of lists, where each inner list is a unique permutation of `nums`. **Constraints**: - `0 <= len(nums) <= 8` - The result should contain no duplicate permutations. - The permutations in the result can be in any order. **Example**: ```python >>> permute_unique([1, 1, 2]) [ [1, 1, 2], [1, 2, 1], [2, 1, 1] ] >>> permute_unique([1, 2, 3]) [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] >>> permute_unique([1, 1, 1]) [ [1, 1, 1] ] >>> permute_unique([]) [ [] ] ``` **Notes**: - Do not use Python\'s built-in `itertools.permutations` function directly, but feel free to emulate its behavior. - Ensure the solution handles edge cases appropriately, such as lists with all identical elements and empty lists. **Hint**: Consider using a backtracking approach to generate the permutations. Use a sorted list to avoid generating duplicates during the permutation process. Keep track of which elements have been used to form each permutation to ensure uniqueness.","solution":"def permute_unique(nums): Returns all unique permutations of a list of numbers that may contain duplicates. result = [] nums.sort() visited = [False] * len(nums) def backtrack(path): if len(path) == len(nums): result.append(path[:]) return for i in range(len(nums)): if visited[i] or (i > 0 and nums[i] == nums[i-1] and not visited[i-1]): continue visited[i] = True path.append(nums[i]) backtrack(path) path.pop() visited[i] = False backtrack([]) return result"},{"question":"Question: Priority Queue Management and Task Scheduling # Background You are a software engineer working on a project management tool that helps in organizing and scheduling tasks based on their priority. Users can add tasks with varying priorities, and the system will manage these tasks to ensure that higher priority tasks are handled before lower priority ones. You have been tasked with implementing this functionality using a priority queue. # Task Complete the implementation of the `TaskScheduler` class to: 1. **Manage Task Priorities**: - Use a min-heap or max-heap to maintain task order based on priorities. - Allow adding tasks with specified priorities. - Allow removing and retrieving the highest priority task. 2. **Task Scheduling**: - Implement a method to process tasks in the order of their priority, simulating a simple task scheduling system. # Specifications 1. **Task Management**: - Implement `add_task()`, `get_task()`, and `remove_task()` methods. - `add_task(task_name, priority)`: Adds a task with its priority. - `get_task()`: Retrieves the highest priority task without removing it. - `remove_task()`: Removes and returns the highest priority task. 2. **Task Scheduling**: - Implement `process_tasks(n)` method: - Processes and removes the top `n` highest priority tasks and returns them in order of processing. # Requirements - **Input**: - The `TaskScheduler` should be initialized as an empty priority queue. - The `add_task` method takes a string `task_name` and an integer `priority`. - The `get_task` and `remove_task` methods take no additional arguments. - The `process_tasks` method takes one integer `n`, indicating the number of tasks to be processed. - **Output**: - `get_task` should return the task name of the highest priority task as a string. - `remove_task` should return the task name of the highest priority task as a string and remove it from the queue. - `process_tasks` should return a list of task names processed in the order they were processed. - **Constraints**: - Ensure the priority queue efficiently manages tasks and maintains their order accurately. - Handle cases with tasks having the same priority appropriately. - Assume priorities are non-negative integers. # Example ```python # Example usage: scheduler = TaskScheduler() scheduler.add_task(\\"Task 1\\", 3) scheduler.add_task(\\"Task 2\\", 1) scheduler.add_task(\\"Task 3\\", 2) print(scheduler.get_task()) # Output: \\"Task 2\\" print(scheduler.remove_task()) # Output: \\"Task 2\\" print(scheduler.process_tasks(2)) # Output: [\\"Task 3\\", \\"Task 1\\"] ``` # Evaluation - Ensure your implementation accurately maintains and retrieves task priorities using an appropriate data structure. - Correctly adds, retrieves, and removes tasks based on their priorities. - Efficiently processes and returns tasks in the order of their priority.","solution":"import heapq class TaskScheduler: def __init__(self): self.task_queue = [] self.task_counter = 0 # to maintain insertion order for tasks with same priority def add_task(self, task_name, priority): heapq.heappush(self.task_queue, (priority, self.task_counter, task_name)) self.task_counter += 1 def get_task(self): if self.task_queue: return self.task_queue[0][2] return None def remove_task(self): if self.task_queue: return heapq.heappop(self.task_queue)[2] return None def process_tasks(self, n): processed_tasks = [] for _ in range(n): if self.task_queue: processed_tasks.append(self.remove_task()) else: break return processed_tasks"},{"question":"# Matrix Rotation by Specified Angle Context: Rotating a matrix is a common operations in many applications including graphics and image processing. The task involves rotating a 2D matrix by a given angle which can be 90, 180, or 270 degrees clockwise. Task: Implement a `rotate_matrix` function that rotates a given NxN matrix by 90, 180, or 270 degrees clockwise. Function Signature: ```python def rotate_matrix(matrix: list, angle: int) -> list: pass ``` Input and Output: - **Input**: - A list of lists, representing an NxN matrix (`matrix`). - An integer (`angle`), which will be one of {90, 180, 270}, representing the angle of clockwise rotation. - **Output**: - A list of lists, representing the rotated NxN matrix. Constraints: - The input matrix will always be square (NxN) where 1 ≤ N ≤ 100. - The angle will always be one of the specified values (90, 180, 270). Examples: 1. `rotate_matrix([[1, 2], [3, 4]], 90)` should return `[[3, 1], [4, 2]]`. 2. `rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 180)` should return `[[9, 8, 7], [6, 5, 4], [3, 2, 1]]`. 3. `rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 270)` should return `[[3, 6, 9], [2, 5, 8], [1, 4, 7]]`. Notes: - Assume the input matrix is always a valid square matrix. - Consider implementing helper functions for each specific angle rotation to keep the `rotate_matrix` function readable. - Ensure to handle edge cases, such as the smallest possible matrix (1x1).","solution":"def rotate_matrix_90(matrix): n = len(matrix) return [[matrix[n - j - 1][i] for j in range(n)] for i in range(n)] def rotate_matrix_180(matrix): n = len(matrix) return [[matrix[n - i - 1][n - j - 1] for j in range(n)] for i in range(n)] def rotate_matrix_270(matrix): n = len(matrix) return [[matrix[j][n - i - 1] for j in range(n)] for i in range(n)] def rotate_matrix(matrix, angle): if angle == 90: return rotate_matrix_90(matrix) elif angle == 180: return rotate_matrix_180(matrix) elif angle == 270: return rotate_matrix_270(matrix) else: raise ValueError(\\"Angle must be 90, 180, or 270 degrees\\")"},{"question":"# Coding Assessment Question **Context**: You are enhancing a library for handling various geometric problems, and you need to add functionality to determine the intersection area of two rectangles. **Problem Statement**: Implement a function to find the area of the intersection of two rectangles. Each rectangle is defined by its bottom-left corner and its top-right corner. # Function Signature: ```python def rectangle_intersection_area(rect1: tuple[int, int, int, int], rect2: tuple[int, int, int, int]) -> int: pass ``` # Input: 1. **rect1 (tuple[int, int, int, int])**: Four integers representing the coordinates of the first rectangle in the format (x1, y1, x2, y2) where (x1, y1) is the bottom-left corner and (x2, y2) is the top-right corner. 2. **rect2 (tuple[int, int, int, int])**: Four integers representing the coordinates of the second rectangle in the same format. # Output: Returns an integer representing the area of the intersection of the two rectangles. If the rectangles do not intersect, the function should return 0. # Constraints: 1. ( -10^9 leq x1, y1, x2, y2 leq 10^9 ) 2. The input coordinates ensure that ( x1 < x2 ) and ( y1 < y2 ) for both rectangles. # Example: ```python assert rectangle_intersection_area((1, 1, 4, 4), (2, 2, 5, 5)) == 4 assert rectangle_intersection_area((0, 0, 2, 2), (3, 3, 5, 5)) == 0 ``` # Explanation: The intersection area for the given inputs are: 1. The overlapping region of the two rectangles results in an area of 2x2 = 4. 2. The rectangles do not overlap, so the intersection area is 0. # Notes: - Calculate the overlapping region by determining the maximum of the bottom-left corners and the minimum of the top-right corners. - Ensure that if there is no intersection, the function correctly returns 0. # Hints: - Consider edge cases where rectangles touch but do not overlap.","solution":"def rectangle_intersection_area(rect1: tuple[int, int, int, int], rect2: tuple[int, int, int, int]) -> int: Calculates the area of the intersection of two rectangles. Each rectangle is defined by its bottom-left and top-right corners. If the rectangles do not intersect, returns 0. # Unpack the input tuples x1, y1, x2, y2 = rect1 x3, y3, x4, y4 = rect2 # Calculate the overlapping region overlap_x1 = max(x1, x3) overlap_y1 = max(y1, y3) overlap_x2 = min(x2, x4) overlap_y2 = min(y2, y4) # Check if there is an intersection if overlap_x1 < overlap_x2 and overlap_y1 < overlap_y2: # Calculate the area of the intersection return (overlap_x2 - overlap_x1) * (overlap_y2 - overlap_y1) else: return 0"},{"question":"# Scenario You are working on a logging system that categorizes log messages into different severity levels: \\"INFO\\", \\"WARNING\\", \\"ERROR\\". The system writes log messages into a log file. The goal is to refactor the current implementation to improve testability and then test the logging functionality using unit testing. # Task Refactor the `Logger` class implementation to: 1. Allow dependency injection of a file handler (for writing logs to a file). 2. Ensure the severity level can be passed as an input parameter when logging a message. Then write test code using the `unittest.mock` library to: 1. Mock the file handler used in the `Logger` class. 2. Verify that log messages are being written correctly based on the severity level. 3. Ensure that only the message with the correct severity level is written to the file handler. # Requirements 1. Implement the `Logger` class with the constructor allowing a file handler injection. 2. Implement methods to log messages with different severity levels (i.e., `log_info`, `log_warning`, `log_error`). 3. Implement a test class named `TestLogger` and a test method `test_logger_writes_correct_messages`. 4. Use appropriate assertions to check the behavior of logging different severity levels. # Input & Output - **Input**: A file handler to be used by the `Logger` class. - **Output**: Assert statements to validate the behavior. # Constraints - Log messages should be prefixed with their severity level (e.g., \\"[INFO] Message\\"). - Each method (log_info, log_warning, log_error) should take a single message string as an input. - The file handler is assumed to have a `write` method which appends a line to the log. # Example ```python import unittest from unittest.mock import Mock class Logger: def __init__(self, file_handler): self.file_handler = file_handler def log_info(self, message): self.file_handler.write(f\\"[INFO] {message}n\\") def log_warning(self, message): self.file_handler.write(f\\"[WARNING] {message}n\\") def log_error(self, message): self.file_handler.write(f\\"[ERROR] {message}n\\") class TestLogger(unittest.TestCase): def test_logger_writes_correct_messages(self): mock_file_handler = Mock() logger = Logger(mock_file_handler) logger.log_info(\\"This is an info message\\") logger.log_warning(\\"This is a warning message\\") logger.log_error(\\"This is an error message\\") mock_file_handler.write.assert_any_call(\\"[INFO] This is an info messagen\\") mock_file_handler.write.assert_any_call(\\"[WARNING] This is a warning messagen\\") mock_file_handler.write.assert_any_call(\\"[ERROR] This is an error messagen\\") if __name__ == \\"__main__\\": unittest.main() ```","solution":"class Logger: def __init__(self, file_handler): self.file_handler = file_handler def log_info(self, message): self.file_handler.write(f\\"[INFO] {message}n\\") def log_warning(self, message): self.file_handler.write(f\\"[WARNING] {message}n\\") def log_error(self, message): self.file_handler.write(f\\"[ERROR] {message}n\\")"},{"question":"# Question: Develop and Test a File Logging System for Data Processing Context: You are tasked with developing a logging system for a data processing application. The application reads data from various input files, processes it, and writes the output to new files. The logging system should keep a detailed log of the operations performed, including successful reads/writes and any errors encountered. Requirements: 1. **Logging Setup**: Implement a logging setup that records messages to a log file with timestamps. 2. **Operational Logging**: Log the start and completion of each file read and write operation. 3. **Error Logging**: Log any errors encountered during the file operations, including the type of error and the filename involved. 4. **Log Levels**: Use appropriate log levels (INFO, ERROR) to categorize the log messages. Main Function Specification: ```python def process_files(input_files: List[str], output_dir: str) -> None: Read data from input files, process it, and write the output to new files in the specified directory. Log all operations and errors. Parameters: input_files (List[str]): List of input file paths to read. output_dir (str): Directory path where output files will be saved. pass ``` * **Input**: A list of input file paths and an output directory path. * **Output**: None. The function performs file operations and logs the details. Constraints: - The function should handle any file I/O errors, such as file not found or permission denied. - Log a message at the start and end of processing for each file. - Ensure the logs are written to a file named `processing.log` in the current working directory. - The function should not terminate on errors; instead, log and continue processing the remaining files. * **Example**: ```python input_files = [\\"data/file1.txt\\", \\"data/file2.txt\\"] output_dir = \\"output\\" # Expected logs: # [INFO] Start reading file: data/file1.txt # [INFO] Successfully read file: data/file1.txt # [INFO] Start writing file: output/file1_processed.txt # [INFO] Successfully wrote file: output/file1_processed.txt # ... # [ERROR] Failed to read file: data/file2.txt (FileNotFoundError) ``` Performance Requirements: - Ensure that the function can handle multiple files efficiently. - Handle log writing asynchronously if necessary to avoid blocking file operations. Note: Provide a well-documented and tested solution demonstrating your understanding of file I/O, logging, and error handling in Python.","solution":"import logging import os from typing import List # Configure logging logging.basicConfig( filename=\'processing.log\', level=logging.INFO, format=\'%(asctime)s [%(levelname)s] %(message)s\', datefmt=\'%Y-%m-%d %H:%M:%S\' ) def process_files(input_files: List[str], output_dir: str) -> None: for input_file in input_files: try: # Log start of reading operation logging.info(f\'Start reading file: {input_file}\') # Read file content with open(input_file, \'r\') as f: content = f.read() # Log successful read logging.info(f\'Successfully read file: {input_file}\') except Exception as e: logging.error(f\'Failed to read file: {input_file} ({type(e).__name__}: {e})\') continue try: # Define output file path output_file = os.path.join(output_dir, f\'{os.path.splitext(os.path.basename(input_file))[0]}_processed.txt\') # Log start of writing operation logging.info(f\'Start writing file: {output_file}\') # Write to output file with open(output_file, \'w\') as f: f.write(content) # Log successful write logging.info(f\'Successfully wrote file: {output_file}\') except Exception as e: logging.error(f\'Failed to write file: {output_file} ({type(e).__name__}: {e})\')"},{"question":"# Coding Question - Real-Time Messaging System **Context**: You are tasked with developing a portion of a real-time messaging system, specifically the `MessageQueue` class. This system will support operations similar to those provided by typical queue data structures but with additional features tailored for a real-time environment. The messages are to be maintained in the order they are received, supporting First In, First Out (FIFO) processing. **Task**: You need to extend the `MessageQueue` implementation to include a method `get_latest_message` that fetches the most recent message (i.e., the one added last). Notably, the queue operates on a doubly-linked list to ensure efficient operations for both enqueue and dequeue, while allowing quick access to the latest message. **Requirements**: 1. Implement `get_latest_message` method: ```python def get_latest_message(self) -> str: # code to fetch the latest message ``` 2. Ensure that the method accesses the latest message in O(1) time. 3. Modify the `MessageQueue` class based on the provided structure to include the new functionality. **Function Signature**: ```python def get_latest_message(self) -> str: pass ``` **Example**: ```python queue = MessageQueue() queue.enqueue(\\"First message\\") queue.enqueue(\\"Second message\\") queue.enqueue(\\"Third message\\") latest_message = queue.get_latest_message() # Should return \\"Third message\\" ``` **Input/Output**: * Input: The current state of the MessageQueue instance. * Output: The string of the latest message added to the queue. * Example Execution: ```python queue = MessageQueue() queue.enqueue(\\"Message 1\\") queue.enqueue(\\"Message 2\\") queue.dequeue() # Queue now: [\\"Message 2\\"] queue.enqueue(\\"Message 3\\") # Queue now: [\\"Message 2\\", \\"Message 3\\"] latest_message = queue.get_latest_message() print(latest_message) # Output should be \\"Message 3\\" ``` **Constraints**: * Ensure that the `get_latest_message` operation maintains O(1) time complexity. * The implementation should efficiently handle multiple enqueue and dequeue operations while providing the latest message seamlessly. Implement your solution within the `MessageQueue` class, ensuring all existing functionalities like enqueue and dequeue are correctly preserved.","solution":"class Node: def __init__(self, message): self.message = message self.next = None self.prev = None class MessageQueue: def __init__(self): self.head = None self.tail = None def enqueue(self, message: str): new_node = Node(message) if self.tail is None: self.head = new_node self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def dequeue(self) -> str: if self.head is None: raise IndexError(\\"Dequeue from an empty queue\\") message = self.head.message self.head = self.head.next if self.head is None: self.tail = None else: self.head.prev = None return message def get_latest_message(self) -> str: if self.tail is None: raise IndexError(\\"No messages in the queue\\") return self.tail.message"},{"question":"**Problem Statement**: Write a function that simulates the handling of a heap data structure using an array. Implement the following operations on a min-heap: insertion, extraction of the minimum element, and finding the minimum element without extraction. The function should ensure that after each operation, the array remains a valid min-heap. **Function Signature**: ```python def min_heap_operations(operations: List[str], values: List[int]) -> List[Optional[int]]: pass ``` **Input**: - `operations` (List[str]): A list of strings where each string represents an operation. Each operation is one of the following: - \\"insert\\" for inserting an element. - \\"extract_min\\" for extracting the minimum element. - \\"get_min\\" for returning the minimum element without extraction. - `values` (List[int]): A list of integers where each integer represents the value associated with the corresponding operation. For example, if `operations[i]` is \\"insert\\", then `values[i]` is the value to be inserted into the heap; if `operations[i]` is \\"extract_min\\" or \\"get_min\\", then `values[i]` is ignored. **Output**: - Returns a list of results where each result corresponds to the result of the \\"extract_min\\" or \\"get_min\\" operations. For \\"insert\\" operations, there should be no output. **Constraints**: - The length of `operations` and `values` list is the same. - Each element of `operations` is one of the three specified strings. - Each element of `values` is an integer. **Examples**: ```python >>> min_heap_operations([\\"insert\\", \\"insert\\", \\"get_min\\", \\"extract_min\\", \\"get_min\\"], [5, 3, 0, 0, 0]) [3, 3, 5] >>> min_heap_operations([\\"insert\\", \\"insert\\", \\"insert\\", \\"extract_min\\", \\"extract_min\\", \\"get_min\\"], [8, 2, 10, 0, 0, 0]) [2, 8, 10] >>> min_heap_operations([\\"insert\\", \\"get_min\\", \\"extract_min\\"], [15, 0, 0]) [15, 15] ``` **Additional Context**: This problem tests your understanding of heaps, particularly min-heaps, and your ability to maintain the heap property during insertion and deletion operations while efficiently performing the required tasks. Implementing the heap operations using an array helps in practical understanding of indexed operations and maintenance of heap structure.","solution":"import heapq from typing import List, Optional def min_heap_operations(operations: List[str], values: List[int]) -> List[Optional[int]]: min_heap = [] result = [] for op, val in zip(operations, values): if op == \\"insert\\": heapq.heappush(min_heap, val) elif op == \\"extract_min\\": if min_heap: result.append(heapq.heappop(min_heap)) else: result.append(None) # to handle invalid extract_min operation elif op == \\"get_min\\": if min_heap: result.append(min_heap[0]) else: result.append(None) # to handle invalid get_min operation return result"},{"question":"# Coding Question: You are tasked with implementing a function to rotate a given binary matrix 90 degrees clockwise. The goal is to assess your ability to manipulate 2D arrays and handle matrix transformations. Function Signature: ```python def rotate_matrix_90_degrees_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates a given binary matrix 90 degrees clockwise. Parameters: - matrix (List[List[int]]): A 2D list representing the binary matrix. Returns: - List[List[int]]: The rotated matrix after a 90-degree clockwise transformation. Example: - Input: [[1, 0, 0], [0, 1, 0], [0, 0, 1]] - Output: [[0, 0, 1], [0, 1, 0], [1, 0, 0]] pass ``` Constraints: - The matrix will be a square matrix (n x n) with `n` within the range of `2 to 100`. - The matrix elements will be either `0` or `1`. Implementation Details: - Ensure your solution handles edge cases such as very small or very large matrices. - Aim for an in-place rotation if possible, or use additional space efficiently. Example: - Input: `[[1, 0, 0], [0, 1, 0], [0, 0, 1]]` - Output: `[[0, 0, 1], [0, 1, 0], [1, 0, 0]]` Tips: - You may use helper functions to make your code more modular. - Pay attention to managing indices correctly during the rotation process. Good luck!","solution":"def rotate_matrix_90_degrees_clockwise(matrix): Rotates a given binary matrix 90 degrees clockwise. Parameters: - matrix (List[List[int]]): A 2D list representing the binary matrix. Returns: - List[List[int]]: The rotated matrix after a 90-degree clockwise transformation. Example: - Input: [[1, 0, 0], [0, 1, 0], [0, 0, 1]] - Output: [[0, 0, 1], [0, 1, 0], [1, 0, 0]] n = len(matrix) # Create a new matrix to store the rotated result. rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n - 1 - i] = matrix[i][j] return rotated"},{"question":"# Problem Statement You have been tasked with developing a component of a text processing library that capitalizes the first letter of each word in a given string while leaving the rest of the characters unchanged. This function must handle words separated by spaces, tabs, or newline characters. Write a function `capitalize_words` that takes a single string `text` as input and returns a new string with the first letter of each word capitalized. Input: - `text`: str (a string of length 0 <= len(text) <= 10^5 containing ASCII characters including spaces, tabs, and newline characters) Output: - A string with the first letter of each word capitalized. Constraints: - The input string may contain leading, trailing, or multiple whitespace characters. - The function should handle multiple consecutive whitespace characters between words. - Minimum time complexity should be O(n), where n is the length of the input text. # Examples: 1. `capitalize_words(\\"hello world\\")` should return `\\"Hello World\\"`. 2. `capitalize_words(\\" multiple spaces\\")` should return `\\" Multiple Spaces\\"`. 3. `capitalize_words(\\"tabstandnnewlines\\")` should return `\\"TabstAndnNewlines\\"`. 4. `capitalize_words(\\"\\")` should return `\\"\\"`. 5. `capitalize_words(\\"a singleword\\")` should return `\\"A Singleword\\"`. # Notes: - Ensure that leading and trailing whitespace characters in the input are preserved in the output. - The function should correctly process and capitalize words separated by any mix of spaces, tabs, or newline characters. - Consider using Python\'s built-in capabilities for string manipulation to simplify the implementation.","solution":"def capitalize_words(text): Capitalizes the first letter of each word in the given text. Words are considered to be sequences of characters separated by spaces, tabs, or newline characters. Parameters: text (str): The input string. Returns: str: A new string with the first letter of each word capitalized. import re # Use a regular expression to find words and capitalize their first letters return re.sub(r\'(S)(S*)\', lambda m: m.group(1).upper() + m.group(2), text)"},{"question":"# Triangle Perimeter Checker You are provided with a function `is_valid_triangle(a, b, c)` that checks whether three given sides can form a valid triangle based on the triangle inequality theorem. # Problem Statement Given three positive integers `a`, `b`, and `c` representing the lengths of the sides of a triangle, your task is to implement the function `is_valid_triangle(a: int, b: int, c: int) -> bool` that determines if these sides can form a valid triangle. According to the triangle inequality theorem, for three sides to form a triangle: - The sum of any two sides must be greater than the third side. # Implementation Details * **Function Signature**: ```python def is_valid_triangle(a: int, b: int, c: int) -> bool: ``` * **Input**: - `a`, `b`, `c` (int): Positive integers representing the lengths of the sides of a triangle. * **Output**: - A boolean value, `True` if the sides can form a valid triangle, `False` otherwise. * **Constraints**: - The inputs `a`, `b`, and `c` will be positive integers. - You should raise a `ValueError` if any of `a`, `b`, or `c` is not a positive integer. # Example 1. **Input**: 3, 4, 5 **Output**: True 2. **Input**: 1, 2, 3 **Output**: False 3. **Input**: 7, 10, 12 **Output**: True # Additional Notes - Ensure your code follows the specified function signature. - Consider edge cases such as when the inputs do not satisfy the positive integer constraint and handle them appropriately by raising the specified error.","solution":"def is_valid_triangle(a: int, b: int, c: int) -> bool: Checks if three sides can form a valid triangle based on the triangle inequality theorem. if not all(isinstance(side, int) and side > 0 for side in [a, b, c]): raise ValueError(\\"All inputs must be positive integers.\\") return a + b > c and a + c > b and b + c > a"},{"question":"# Problem Statement You are working on data validation functions for a contact management system. The following tasks require your attention: 1. **Validate Email Addresses**: Write a function named `is_valid_email` that takes a string as input and returns a boolean indicating whether the email address is valid. A valid email address should adhere to the following criteria: - Contains exactly one \\"@\\" symbol. - The \\"@\\" symbol should not be the first or last character. - Contains at least one \\".\\" after the \\"@\\" symbol. - The last \\".\\" should not be immediately preceded by \\"@\\". - The last \\".\\" should not be followed by less than two characters. If the input is not a string or is an empty string, your function should raise a `ValueError`. 2. **Extract Domain from Email Address**: Write a function named `extract_domain` that takes a string representing an email address and returns a string representing the domain part of the email. The domain part is the substring after the \\"@\\" symbol. If the input is not a string, is an empty string, or if the email address is not valid according to the criteria defined in `is_valid_email`, your function should raise a `ValueError`. # Requirements * Implement the functions as per the provided function prototypes: ```python def is_valid_email(email: str) -> bool: # Your code here def extract_domain(email: str) -> str: # Your code here ``` * **Input Constraints**: * `email` is a string. * A valid email consists of at least one character before and after the \\"@\\" symbol and two or more characters after the last \\".\\". # Examples The `is_valid_email` function should work as follows: * `is_valid_email(\\"test@example.com\\")` should return `True`. * `is_valid_email(\\"user@domain.co\\")` should return `True`. * `is_valid_email(\\"invalid@com\\")` should return `False`. * `is_valid_email(\\"test@.com\\")` should return `False`. * `is_valid_email(\\"missingatsymbol.com\\")` should return `False`. * `is_valid_email(\\"\\")` should raise a `ValueError`. The `extract_domain` function should work as follows: * `extract_domain(\\"test@example.com\\")` should return `\\"example.com\\"`. * `extract_domain(\\"user@domain.co\\")` should return `\\"domain.co\\"`. * `extract_domain(\\"invalid-email.com\\")` should raise a `ValueError`. * `extract_domain(\\"\\")` should raise a `ValueError`. # Notes: * Ensure that your code handles different edge cases effectively, such as emails with subdomains or invalid characters. * Use appropriate error handling to manage invalid inputs. * Maintain readability and efficiency in your implementations.","solution":"import re def is_valid_email(email: str) -> bool: Validates if the input string is a valid email address. Args: email (str): email address to validate. Returns: bool: True if the email is valid, False otherwise. Raises: ValueError: If the input is not a string or is an empty string. if not isinstance(email, str) or not email: raise ValueError(\\"Input must be a non-empty string\\") # Regex for email validation regex = r\'^[^@]+@[^@]+.[^@]{2,}\' return bool(re.match(regex, email)) def extract_domain(email: str) -> str: Extracts the domain part from a valid email address. Args: email (str): email address to extract domain from. Returns: str: domain part of the email address. Raises: ValueError: If the input is not a string, is an empty string, or is not a valid email. if not is_valid_email(email): raise ValueError(\\"Invalid email address\\") return email.split(\'@\')[1]"},{"question":"# Problem Statement You need to implement a function `generate_fibonacci_series` that generates the first `n` numbers in the Fibonacci sequence and returns them in a list. The Fibonacci sequence is defined as follows: - The first number is 0. - The second number is 1. - Every subsequent number is the sum of the previous two numbers. Your function should return the Fibonacci sequence starting from 0 up to the nth number (exclusive). # Function Signature ```python def generate_fibonacci_series(n: int) -> list: ``` # Input - **n (int)**: The number of terms in the Fibonacci sequence to generate (0 ≤ n ≤ 30). # Output - **list**: A list containing the first n numbers of the Fibonacci sequence. # Constraints 1. The input n will always be a non-negative integer. 2. Optimize for clarity and simplicity. 3. Handle the edge case where n is 0 gracefully. # Example ```python >>> generate_fibonacci_series(0) [] >>> generate_fibonacci_series(1) [0] >>> generate_fibonacci_series(2) [0, 1] >>> generate_fibonacci_series(5) [0, 1, 1, 2, 3] >>> generate_fibonacci_series(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Explanation of Examples - For `n = 0`, the sequence is empty because no terms are requested. - For `n = 1`, the sequence contains only the first number: [0]. - For `n = 2`, the sequence contains the first two numbers: [0, 1]. - For `n = 5`, the sequence contains the first five numbers: [0, 1, 1, 2, 3]. - For `n = 10`, the sequence contains the first ten numbers: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]. # Edge Cases to Consider - The smallest number (0), which should return an empty list. - The smallest positive number (1), which should return a list containing only 0. - Typical use cases for generating small to medium-sized Fibonacci sequences.","solution":"def generate_fibonacci_series(n: int) -> list: Generates the first n numbers in the Fibonacci sequence. Parameters: - n (int): The number of terms in the Fibonacci sequence to generate. Returns: - list: A list containing the first n numbers of the Fibonacci sequence. if n <= 0: return [] fibonacci_series = [0] # Initializing the first number of the series if n == 1: return fibonacci_series fibonacci_series.append(1) # Adding the second number of the series for i in range(2, n): next_value = fibonacci_series[-1] + fibonacci_series[-2] fibonacci_series.append(next_value) return fibonacci_series"},{"question":"# Coding Assessment Question: Matrix Class Enhancement Context The matrix class you have been provided is robust, supporting several operations like addition, subtraction, and multiplication. However, it lacks some advanced linear algebra functionalities. One such missing feature is finding the matrix\'s inverse, which is particularly useful in solving systems of linear equations, among other applications. The inverse of a matrix ( A ) is a matrix ( A^{-1} ) such that ( A times A^{-1} ) is the identity matrix. Task Implement an `inverse` method within the provided `Matrix` class to find and return the inverse of the matrix, if it exists. Function Signature ```python def inverse(self) -> \'Matrix\': Computes the inverse of the matrix. Returns: Matrix: The inverse of the matrix. ``` Input - The matrix is already initialized using the provided `Matrix` class. - No additional inputs are required. Output - The function should return a new `Matrix` instance that is the inverse of the original matrix. - If the matrix is not invertible, the method should raise a custom exception called `MatrixNotInvertibleError`. Constraints - You must use the existing `Matrix` class and its methods where applicable. - Consider edge cases such as singular matrices (which do not have an inverse) and non-square matrices (which cannot have an inverse). - Efficient implementation using Gaussian elimination or any other suitable method is recommended. Example ```python # Example 1 matrix1 = Matrix([ [2, 1], [5, 3] ]) inverse1 = matrix1.inverse() print(inverse1) # Expected output: Matrix([[3, -1], [-5, 2]]) # Example 2 matrix2 = Matrix([ [1, 2, 3], [0, 1, 4], [5, 6, 0] ]) inverse2 = matrix2.inverse() print(inverse2) # Expected output: Matrix([[-24, 18, 5], [20, -15, -4], [-5, 4, 1]]) # Example 3 (should raise MatrixNotInvertibleError) matrix3 = Matrix([ [1, 2], [2, 4] ]) try: inverse3 = matrix3.inverse() except MatrixNotInvertibleError: print(\\"Matrix is not invertible.\\") ``` Additional Notes - Ensure that your method accounts for floating-point precision issues. - The custom `MatrixNotInvertibleError` should be defined within the same module or class. - Verify the implementation with a range of matrices, including edge cases like identity matrices and singular matrices.","solution":"class MatrixNotInvertibleError(Exception): pass class Matrix: def __init__(self, data): self.data = data self.rows = len(data) self.cols = len(data[0]) if data else 0 if any(len(row) != self.cols for row in data): raise ValueError(\\"All rows must have the same number of columns\\") def __str__(self): return \\"[\\" + \\"n \\".join([str(row) for row in self.data]) + \\"]\\" def inverse(self) -> \'Matrix\': if self.rows != self.cols: raise MatrixNotInvertibleError(\\"Only square matrices can be inverted.\\") n = self.rows # Create an augmented matrix with the identity matrix aug_matrix = [self.data[i] + [1 if i == j else 0 for j in range(n)] for i in range(n)] # Apply Gaussian Elimination for i in range(n): # Make the diagonal element 1 diag_elem = aug_matrix[i][i] if diag_elem == 0: raise MatrixNotInvertibleError(\\"The matrix is not invertible.\\") for j in range(2 * n): aug_matrix[i][j] /= diag_elem # Make the other elements in current column 0 for k in range(n): if i != k: factor = aug_matrix[k][i] for j in range(2 * n): aug_matrix[k][j] -= factor * aug_matrix[i][j] inverse_data = [row[n:] for row in aug_matrix] return Matrix(inverse_data)"},{"question":"Advanced Data Streams: Stock Price Monitor **Context**: You are a software engineer tasked with building a real-time monitoring system for stock prices. The system must efficiently handle large volumes of data and provide quick updates for stock queries. **Objective**: Your task is to design and implement a streamlined system to process and query stock prices. The system should handle a continuous stream of price updates and provide the current price of a stock or the highest price within a specific time window. **Function Signature**: ```python class StockPriceMonitor: def __init__(self) -> None: Initializes the stock price monitor. pass def add_update(self, timestamp: int, stock_symbol: str, price: float) -> None: Registers a price update for a given stock at a specific timestamp. pass def current_price(self, stock_symbol: str) -> float: Returns the latest price of the given stock symbol. pass def highest_price(self, stock_symbol: str, start_time: int, end_time: int) -> float: Returns the highest price of the given stock symbol within the specified time window. pass ``` **Expected Input/Output**: * `add_update(timestamp, stock_symbol, price)`: Adds a new price update for the given stock symbol at the specified timestamp. * `current_price(stock_symbol)`: Returns the latest price for the requested stock symbol. * `highest_price(stock_symbol, start_time, end_time)`: Retrieves the highest price of the requested stock symbol between the start and end timestamps. **Constraints**: 1. Timestamp values (`timestamp`, `start_time`, `end_time`) will be positive integers. 2. Stock symbols are strings consisting of uppercase English letters (e.g., \\"AAPL\\", \\"GOOG\\"). 3. Prices are floating-point numbers representing the stock price. 4. The number of updates (`add_update` calls) can be up to 10^6. 5. The queries (`current_price` and `highest_price`) can be up to 10^5. **Requirements**: - **Edge Cases**: Handle scenarios where there are no updates for a stock or no stock prices within a given time window. - **Performance**: Ensure the system can process a high volume of updates and queries efficiently. **Challenge**: Design the system to keep track of the latest and highest prices in a manner that minimizes memory usage while ensuring quick query responses. Leverage appropriate data structures to balance between update and query performance.","solution":"from collections import defaultdict import bisect class StockPriceMonitor: def __init__(self): self.stocks_latest = {} self.stock_prices = defaultdict(list) def add_update(self, timestamp: int, stock_symbol: str, price: float) -> None: # Update the latest price for the stock self.stocks_latest[stock_symbol] = (timestamp, price) # Insert the price update in the sorted list of prices for the stock # Using bisect to maintain sorted order by timestamp bisect.insort(self.stock_prices[stock_symbol], (timestamp, price)) def current_price(self, stock_symbol: str) -> float: # Return the latest price for the stock return self.stocks_latest[stock_symbol][1] if stock_symbol in self.stocks_latest else None def highest_price(self, stock_symbol: str, start_time: int, end_time: int) -> float: if stock_symbol not in self.stock_prices: return None prices = self.stock_prices[stock_symbol] # Use binary search to find the window of interest start_idx = bisect.bisect_left(prices, (start_time, float(\'-inf\'))) end_idx = bisect.bisect_right(prices, (end_time, float(\'inf\'))) if start_idx >= len(prices) or prices[start_idx][0] > end_time: return None # Find the maximum price within the specified time window max_price = float(\'-inf\') for i in range(start_idx, end_idx): if start_time <= prices[i][0] <= end_time: max_price = max(max_price, prices[i][1]) return max_price if max_price != float(\'-inf\') else None"},{"question":"**Matrix Diagonal Pattern Validation** In a two-dimensional matrix, a diagonal pattern consists of the diagonal elements being the same. You are required to ensure a given matrix follows this pattern, where all diagonals from the top-left to the bottom-right of the matrix must have the same value. # Scenario You are to implement a function that checks if the given matrix follows the diagonal pattern property. If at least one diagonal does not match this pattern, return `False`. # Task Write a function that: 1. Validates if each diagonal from top-left to bottom-right has the same element. 2. Returns `True` if all diagonals are consistent, otherwise returns `False`. # Function Signature ```python def is_diagonal_pattern(matrix: List[List[int]]) -> bool: pass ``` # Input - `matrix` (List[List[int]]): The input matrix to validate (1 <= len(matrix), len(matrix[0]) <= 200). # Output - Returns `True` if the matrix follows the diagonal pattern, `False` otherwise. # Constraints - The matrix can be of any size within the given constraints, including non-square matrices. - Handle empty matrix scenarios appropriately. # Example ```python >>> is_diagonal_pattern([ ... [1, 2, 3, 4], ... [5, 1, 2, 3], ... [9, 5, 1, 2] ... ]) True >>> is_diagonal_pattern([ ... [1, 2], ... [4, 5] ... ]) False >>> is_diagonal_pattern([ ... [1, 1, 1], ... [1, 1, 1] ... ]) True >>> is_diagonal_pattern([]) True ``` # Notes - Ensure that the function handles cases where the input matrix is empty by returning `True` since an empty matrix technically follows the diagonal pattern. - The function should work efficiently even for the maximum matrix size of 200x200.","solution":"from typing import List def is_diagonal_pattern(matrix: List[List[int]]) -> bool: if not matrix: return True rows, cols = len(matrix), len(matrix[0]) for i in range(rows): for j in range(cols): if i > 0 and j > 0 and matrix[i][j] != matrix[i-1][j-1]: return False return True"},{"question":"# Data Normalization Implementation Implement a function to normalize a numeric dataset to a specified range using Min-Max scaling. The dataset should be normalized for each feature independently. # Input and Output Input * `data`: A 2D numpy array where each row represents a data sample and each column represents a feature. * `norm_min`: A float representing the minimum value of the normalized range. * `norm_max`: A float representing the maximum value of the normalized range. Output * A 2D numpy array of the same shape as the input `data` with each feature normalized to the specified range. # Constraints * The dataset will have at least one row and one column. * All values in `norm_min` and `norm_max` will be such that `norm_min < norm_max`. ```python import numpy as np def normalize_data(data, norm_min=0.0, norm_max=1.0): # Check if the input array is valid if data.size == 0: return data # Calculate the minimum and maximum values for each feature data_min = np.min(data, axis=0) data_max = np.max(data, axis=0) # Avoid division by zero data_range = data_max - data_min data_range[data_range == 0] = 1 # Apply Min-Max scaling norm_data= (data - data_min) / data_range norm_data = norm_data * (norm_max - norm_min) + norm_min return norm_data # Sample Usage data = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) normalized_data = normalize_data(data, 0, 1) print(normalized_data) ```","solution":"import numpy as np def normalize_data(data, norm_min=0.0, norm_max=1.0): Normalize a dataset using Min-Max scaling to a specified range. Parameters: - data: 2D numpy array where each row is a sample and each column is a feature. - norm_min: Float representing the minimum value of the normalized range. - norm_max: Float representing the maximum value of the normalized range. Returns: - norm_data: 2D numpy array of the same shape as `data` with normalized values. # Check if the input array is valid if data.size == 0: return data # Calculate the minimum and maximum values for each feature data_min = np.min(data, axis=0) data_max = np.max(data, axis=0) # Avoid division by zero data_range = data_max - data_min data_range[data_range == 0] = 1 # Apply Min-Max scaling norm_data = (data - data_min) / data_range norm_data = norm_data * (norm_max - norm_min) + norm_min return norm_data"},{"question":"# Question: Minimum Number of Refueling Stops You are driving a car that can travel up to `startFuel` miles on a full tank. Along your route, there are `n` fuel stations, each with a certain amount of fuel available. Each fuel station is represented as `stations[i]` = [distance_i, fuel_i], indicating that the `i`-th station is `distance_i` miles from the starting point and has `fuel_i` liters of fuel available. Your goal is to reach a destination located `target` miles away from the starting point. You start with `startFuel` liters of fuel in your car. You can stop at any fuel station as many times as needed, and refuel any amount of fuel available at that station. Write a function `minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int` that returns the minimum number of refueling stops required to reach the destination. If it is not possible to reach the destination, return -1. Constraints - The input `target` and `startFuel` will both be positive integers (1 ≤ target, startFuel ≤ 10^9). - The input `stations` will be a list containing at most 500 elements, where each element is a list `[distance_i, fuel_i]` (0 ≤ distance_i < target and 1 ≤ fuel_i ≤ 10^9). Function Signature ```python def minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int: # Your implementation here ``` Example ```python assert minRefuelStops(100, 10, [[10, 60], [20, 30], [30, 30], [60, 40]]) == 2 assert minRefuelStops(100, 50, [[25, 50], [50, 25]]) == 1 assert minRefuelStops(1000, 100, [[100, 100], [200, 200], [300, 300], [400, 400], [500, 500], [600, 600], [700, 700], [800, 800], [900, 900]]) == 4 assert minRefuelStops(200, 100, [[50, 100], [100, 100], [150, 100]]) == 1 assert minRefuelStops(100, 1, [[10, 100]]) == -1 ``` Explanation For `target = 100`, `startFuel = 10`, and `stations = [[10, 60], [20, 30], [30, 30], [60, 40]]`: - You stop at the first station (10 miles) and refuel 60 liters. Current fuel: 60. - You can now travel to the distance of 70 miles and stop at the last station (60 miles), refueling 40 liters. Current fuel: 40. - You have enough fuel to reach the destination with a total of 2 stops. Thus, the result should be 2. Implement the function to effectively handle the provided examples and edge cases accordingly.","solution":"import heapq from typing import List def minRefuelStops(target: int, startFuel: int, stations: List[List[int]]) -> int: if startFuel >= target: return 0 max_heap = [] stations.append([target, 0]) fuel_at_last = startFuel refuel_stops = 0 prev = 0 for distance, fuel in stations: fuel_at_last -= distance - prev while max_heap and fuel_at_last < 0: fuel_at_last += -heapq.heappop(max_heap) refuel_stops += 1 if fuel_at_last < 0: return -1 heapq.heappush(max_heap, -fuel) prev = distance return refuel_stops"},{"question":"Implement Binary Tree with Level Order Traversal You need to implement a binary tree and provide a method for level order traversal (also known as breadth-first traversal). The binary tree should support insertion of elements. You will then validate your methods by showcasing the level order traversal of the tree after inserting a series of numbers. Function Signature ```python class TreeNode: def __init__(self, value: int) -> None: pass class BinaryTree: def __init__(self) -> None: pass def insert(self, value: int) -> None: pass def level_order_traversal(self) -> List[int]: pass ``` Requirements 1. **TreeNode class**: - Implement the `TreeNode` class which initializes with a value and has left and right child nodes set to `None`. 2. **BinaryTree class**: - Implement the `BinaryTree` class with a root initialized to `None`. - Implement the `insert` method to insert a value into the binary tree. - Implement the `level_order_traversal` method to return the values of the nodes in a level order traversal. 3. **Insertion Method**: - Ensure that new nodes are inserted following the binary search tree (BST) properties. 4. **Traversal Method**: - Implement level order traversal using a queue. 5. **Demonstration**: - Validate the classes and methods by constructing a binary tree with a specified set of input values, followed by the level order traversal of the tree. Example ```python # Example input values to form the binary tree input_values = [10, 5, 15, 3, 7, 12, 18] # Create an instance of the BinaryTree binary_tree = BinaryTree() # Insert the values into the binary tree for value in input_values: binary_tree.insert(value) # Output the level order traversal print(binary_tree.level_order_traversal()) # Expected output: [10, 5, 15, 3, 7, 12, 18] ```","solution":"from typing import List, Optional from collections import deque class TreeNode: def __init__(self, value: int) -> None: self.value = value self.left: Optional[TreeNode] = None self.right: Optional[TreeNode] = None class BinaryTree: def __init__(self) -> None: self.root: Optional[TreeNode] = None def insert(self, value: int) -> None: if self.root is None: self.root = TreeNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node: TreeNode, value: int) -> None: if value < node.value: if node.left is None: node.left = TreeNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = TreeNode(value) else: self._insert_recursive(node.right, value) def level_order_traversal(self) -> List[int]: result = [] if not self.root: return result queue = deque([self.root]) while queue: current_node = queue.popleft() result.append(current_node.value) if current_node.left is not None: queue.append(current_node.left) if current_node.right is not None: queue.append(current_node.right) return result"},{"question":"# Number of Digits in Factorial Context Factorials control the growth of numerical sequences and appear frequently in combinatorics and probability. Calculating the exact factorial of large numbers can quickly lead to astronomical values. Instead, we can focus on the number of digits in a factorial, which is a more manageable way to understand the scale. Task Write a function `digit_count_factorial(n: int) -> int` that returns the number of digits in the factorial of `n`. Use logarithmic properties to avoid dealing directly with large numbers. Example ``` Input: 5 Output: 3 Explanation: The factorial of 5 is 120, which has 3 digits. Input: 10 Output: 7 Explanation: The factorial of 10 is 3628800, which has 7 digits. ``` # Constraints - Input `n` is an integer such that 1 ≤ n ≤ 1000. - Consider the properties of logarithms to efficiently determine the number of digits. - You may use the mathematical properties of factorials and logarithms to derive the outcome instead of calculating the factorials directly. This composition aligns with the existing set in style, complexity, topic alignment, and uniqueness, making it a seamless addition to the original examination.","solution":"import math def digit_count_factorial(n: int) -> int: Returns the number of digits in the factorial of n. if n == 0 or n == 1: return 1 # Using logarithmic properties to determine number of digits digits = sum(math.log10(i) for i in range(1, n+1)) return math.floor(digits) + 1"},{"question":"Design a Python function that simulates a simple digital 2-bit binary adder. This adder takes two binary numbers, each of two bits, and returns their sum as a binary string. # Function Signature ```python def binary_adder(bit1: str, bit2: str) -> str: Implement a 2-bit binary adder. :param bit1: The first 2-bit binary string (e.g., \'00\', \'01\', \'10\', \'11\'). :param bit2: The second 2-bit binary string (e.g., \'00\', \'01\', \'10\', \'11\'). :return: The binary string representing the 2-bit sum of the input binary numbers. Examples: >>> binary_adder(\'00\', \'01\') \'01\' >>> binary_adder(\'01\', \'01\') \'10\' >>> binary_adder(\'10\', \'10\') \'100\' >>> binary_adder(\'11\', \'11\') \'110\' >>> binary_adder(\'11\', \'1\') Traceback (most recent call last): ... ValueError: Both inputs must be 2-bit binary strings >>> binary_adder(\'2\', \'01\') Traceback (most recent call last): ... ValueError: Both inputs must be 2-bit binary strings ``` # Constraints 1. Both `bit1` and `bit2` must be valid 2-bit binary strings consisting of \'0\' or \'1\'. 2. If either of the inputs is not a valid 2-bit binary string, a `ValueError` should be raised. # Task Implement the `binary_adder` function to correctly sum the two 2-bit binary numbers and return their sum as a binary string, with proper error handling for invalid inputs. --- This question evaluates the candidate\'s understanding of binary arithmetic, string manipulation, and error handling in Python.","solution":"def binary_adder(bit1: str, bit2: str) -> str: Implement a 2-bit binary adder. :param bit1: The first 2-bit binary string (e.g., \'00\', \'01\', \'10\', \'11\'). :param bit2: The second 2-bit binary string (e.g., \'00\', \'01\', \'10\', \'11\'). :return: The binary string representing the sum of the input binary numbers. Examples: >>> binary_adder(\'00\', \'01\') \'01\' >>> binary_adder(\'01\', \'01\') \'10\' >>> binary_adder(\'10\', \'10\') \'100\' >>> binary_adder(\'11\', \'11\') \'110\' >>> binary_adder(\'11\', \'1\') Traceback (most recent call last): ... ValueError: Both inputs must be 2-bit binary strings >>> binary_adder(\'2\', \'01\') Traceback (most recent call last): ... ValueError: Both inputs must be 2-bit binary strings if not (bit1 in {\'00\', \'01\', \'10\', \'11\'} and bit2 in {\'00\', \'01\', \'10\', \'11\'}): raise ValueError(\\"Both inputs must be 2-bit binary strings\\") decimal_sum = int(bit1, 2) + int(bit2, 2) return bin(decimal_sum)[2:]"},{"question":"# Intersection Point of Two Linked Lists # Background: In many practical applications, linked lists are often utilized to manage dynamic data sets. An interesting problem is identifying the intersection point of two singly linked lists, assuming that they may merge at some point. # Your Task: Implement the `get_intersection_node` function to find the node at which two singly linked lists intersect. If the two linked lists do not intersect, return `None`. # Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: ``` # Input: 1. **headA (ListNode)**: The head node of the first linked list. 2. **headB (ListNode)**: The head node of the second linked list. # Output: - **intersection_node (ListNode)**: The node at which the two linked lists intersect. If they do not intersect, return `None`. # Constraints: - The number of nodes in both linked lists is in the range `[0, 10^4]`. - Each linked list is non-cyclic. - The linked lists must retain their original structure after the function returns. # Requirements: 1. Ensure optimal time and space complexity. 2. Handle edge cases such as one or both linked lists being empty. 3. The ListNode must be traversed efficiently without modifying the list\'s structure. # Example: ```python # Assume ListNode class is defined as above # Creating two linked lists: # A: 4 -> 1 # 8 -> 4 -> 5 # B: 5 -> 6 -> 1 / # The intersection node\'s value is 8. list_common = ListNode(8, ListNode(4, ListNode(5))) headA = ListNode(4, ListNode(1, list_common)) headB = ListNode(5, ListNode(6, ListNode(1, list_common))) intersection = get_intersection_node(headA, headB) print(\\"Intersection Node Value:\\", intersection.val if intersection else None) ``` # Additional Task: Write automated tests to validate your `get_intersection_node` function by creating various test cases with different intersection scenarios and ensuring that the function returns the correct results.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def get_intersection_node(headA: ListNode, headB: ListNode) -> ListNode: if not headA or not headB: return None pointerA, pointerB = headA, headB while pointerA is not pointerB: pointerA = pointerA.next if pointerA else headB pointerB = pointerB.next if pointerB else headA return pointerA # If they intersect, else they meet at None"},{"question":"**Problem Statement**: You are tasked with creating a function that performs matrix multiplication and subsequently determines the determinant of the resulting matrix. The function will handle two-dimensional square matrices represented as lists of lists. Additionally, you need to implement a function to generate a formatted string representation of the matrix. **Function Specifications**: 1. **matrix_multiply**: - **Input**: `mat1: List[List[int]], mat2: List[List[int]]` - Two square matrices represented as lists of lists. - **Output**: `List[List[int]]` - The resulting matrix after multiplying `mat1` and `mat2`. 2. **matrix_determinant**: - **Input**: `matrix: List[List[int]]` - A square matrix. - **Output**: `int` - The determinant of the matrix. 3. **format_matrix**: - **Input**: `matrix: List[List[int]]` - A square matrix. - **Output**: `str` - A string representation of the matrix. When calling `matrix_multiply`, `mat1` and `mat2` must be multiplied using standard matrix multiplication rules. The function `matrix_determinant` should compute the determinant using the standard mathematical method for calculating determinants of square matrices. Finally, `format_matrix` should generate a string representation of the matrix. **Details**: The string representation of the matrix should be formatted as follows for a 3x3 matrix: ``` | 1 2 3 | | 4 5 6 | | 7 8 9 | ``` **Constraints**: - The input matrices for `matrix_multiply` and `matrix_determinant` will always be square matrices with integer elements. - The matrices for `matrix_multiply` will always have the same dimensions. # Implementation You need to implement the following functions: ```python def matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: # Implement the matrix multiplication pass def matrix_determinant(matrix: List[List[int]]) -> int: # Implement the matrix determinant calculation pass def format_matrix(matrix: List[List[int]]) -> str: # Implement the matrix formatting pass ``` **Example**: ```python # Example usage: mat1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat2 = [ [9, 8, 7], [6, 5, 4], [3, 2, 1] ] result_matrix = matrix_multiply(mat1, mat2) print(format_matrix(result_matrix)) # Expected Output: Printed formatted matrix result of mat1 * mat2 det = matrix_determinant(result_matrix) print(det) # Expected Output: Determinant of the result_matrix ``` **Expected Formatted Matrix Output**: ``` | 30 24 18 | | 84 69 54 | | 138 114 90 | ```","solution":"from typing import List def matrix_multiply(mat1: List[List[int]], mat2: List[List[int]]) -> List[List[int]]: n = len(mat1) result = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): for k in range(n): result[i][j] += mat1[i][k] * mat2[k][j] return result def matrix_determinant(matrix: List[List[int]]) -> int: if len(matrix) == 1: return matrix[0][0] if len(matrix) == 2: return matrix[0][0] * matrix[1][1] - matrix[0][1] * matrix[1][0] det = 0 for c in range(len(matrix)): sub_matrix = [row[:c] + row[c + 1:] for row in (matrix[:0] + matrix[1:])] det += ((-1) ** c) * matrix[0][c] * matrix_determinant(sub_matrix) return det def format_matrix(matrix: List[List[int]]) -> str: formatted_string = \\"\\" for row in matrix: formatted_string += \\"| \\" + \\" \\".join(f\\"{elem:>3}\\" for elem in row) + \\" |n\\" return formatted_string.strip()"},{"question":"# Coding Question Context You are developing a system that analyzes student performance based on their grades. Each student\'s grades are provided as an integer array. Your task is to identify students who have consistently improved. An improvement is defined as a sequence of grades where each grade is greater than the previous one. Objective Write a function `consistent_improvement` that takes a list of lists, where each inner list represents a student\'s grades. The function should return a list of boolean values indicating whether each student has shown consistent improvement. Function Signature ```python def consistent_improvement(grades: list[list[int]]) -> list[bool]: ``` Input * `grades`: a list of lists of integers representing the grades of students. Constraints: 1 <= len(grades) <= 100 and 1 <= len(grades[i]) <= 50, where 0 <= grades[i][j] <= 100. Output * A list of boolean values where each value corresponds to a student. The value should be `True` if the student has shown consistent improvement and `False` otherwise. Examples ```python >>> consistent_improvement([[70, 75, 80, 85], [95, 90, 85, 80], [50, 60, 70, 80, 90]]) [True, False, True] >>> consistent_improvement([[60, 60, 60], [55, 65, 75], [100, 99, 98, 97]]) [False, True, False] >>> consistent_improvement([[30], [45, 45], [50, 55, 60, 70]]) [True, False, True] >>> consistent_improvement([[40, 50, 60], [80], [70, 80, 85], [90, 91, 92]]) [True, True, True, True] ``` Constraints * The function should have an overall time complexity of O(n * m), where n is the number of students and m is the maximum length of a student\'s grades list. * Assume all grades are valid integers within the specified range. Notes 1. Handle edge cases such as a single grade in the list, or all grades being the same. 2. A student with only one grade is considered to have consistent improvement. ___","solution":"def consistent_improvement(grades: list[list[int]]) -> list[bool]: Returns a list of boolean values indicating whether each student has shown consistent improvement in their grades. :param grades: A list of lists, where each inner list represents a student\'s grades. :return: A list of boolean values. result = [] for student_grades in grades: if len(student_grades) == 1: result.append(True) continue for i in range(len(student_grades) - 1): if student_grades[i] >= student_grades[i + 1]: result.append(False) break else: result.append(True) return result"},{"question":"# Graph Traversal and Shortest Path Calculation Background Graph traversal algorithms are fundamental in computer science, often used for searching, finding paths, and various applications like network routing and social network analysis. Dijkstra\'s algorithm is a classic example used to find the shortest path between nodes in a graph with non-negative weights. Problem Statement You are tasked with implementing a Graph class that supports adding edges and nodes, and finding the shortest path between two nodes using Dijkstra\'s algorithm. Additionally, your implementation should allow for dynamic updates to the graph, including adding and removing nodes and edges. Requirements 1. **Function Signatures and Definitions**: - `class Graph()`: Constructor to initialize the Graph object. - `def add_edge(node1, node2, weight)`: Add an edge with a given weight between two nodes. - `def remove_edge(node1, node2)`: Remove the edge between two nodes. - `def add_node(node)`: Add a new node to the graph. - `def remove_node(node)`: Remove a node and all its associated edges from the graph. - `def shortest_path(start_node, end_node)`: Compute the shortest path between `start_node` and `end_node` using Dijkstra\'s algorithm. - `@property def nodes()`: Return a list of all nodes currently in the graph. - `@property def edges()`: Return a list of all edges currently in the graph as tuples (node1, node2, weight). 2. **Input/Output**: - Initialize an empty graph. - Add and remove nodes and edges dynamically. - Compute and return the shortest path between two specified nodes, and handle cases where no path exists. 3. **Constraints**: - The graph can have up to 1000 nodes and 5000 edges. - Edge weights are non-negative integers. - Nodes are unique and identified by integer values. - If a node is removed, all its associated edges should also be removed. Objectives - Understand and implement graph data structures. - Practice Dijkstra\'s algorithm for shortest path calculation. - Manage dynamic updates to the graph structure effectively. Implement the `Graph` class with the specified functionality to handle graph traversal and shortest path calculation dynamically.","solution":"import heapq class Graph: def __init__(self): self.adjacency_list = {} def add_node(self, node): if node not in self.adjacency_list: self.adjacency_list[node] = [] def remove_node(self, node): if node in self.adjacency_list: del self.adjacency_list[node] for n in self.adjacency_list: self.adjacency_list[n] = [edge for edge in self.adjacency_list[n] if edge[0] != node] def add_edge(self, node1, node2, weight): if node1 in self.adjacency_list and node2 in self.adjacency_list: self.adjacency_list[node1].append((node2, weight)) self.adjacency_list[node2].append((node1, weight)) def remove_edge(self, node1, node2): if node1 in self.adjacency_list: self.adjacency_list[node1] = [edge for edge in self.adjacency_list[node1] if edge[0] != node2] if node2 in self.adjacency_list: self.adjacency_list[node2] = [edge for edge in self.adjacency_list[node2] if edge[0] != node1] def shortest_path(self, start_node, end_node): if start_node not in self.adjacency_list or end_node not in self.adjacency_list: return float(\'inf\') distances = {node: float(\'inf\') for node in self.adjacency_list} distances[start_node] = 0 priority_queue = [(0, start_node)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in self.adjacency_list[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances[end_node] if distances[end_node] != float(\'inf\') else None @property def nodes(self): return list(self.adjacency_list.keys()) @property def edges(self): edges_list = [] for node in self.adjacency_list: for neighbor, weight in self.adjacency_list[node]: if (neighbor, node, weight) not in edges_list: edges_list.append((node, neighbor, weight)) return edges_list"},{"question":"# Problem Description You are required to implement a Word Counter class that can count the number of specific words in a list of strings, and provide the most common words encountered so far. The Word Counter should support the following operations: - `add_word(word: str)`: Adds a word to the counter. If the word already exists, increments its count. - `most_common(n: int) -> List[str]`: Returns the `n` most common words added so far, sorted by their frequency in descending order. If two words have the same frequency, they should be sorted lexicographically. - `count(word: str) -> int`: Returns the count of the specified word. If the word does not exist in the counter, returns 0. **Input Constraints** - Words are strings with length between 1 and 100. - `n` is an integer between 1 and 1000. - The operations `add_word`, `most_common`, and `count` should handle large inputs efficiently. **Output Description** - Implement the specified functions. - Ensure the operations conform to the following time complexities: - `add_word`: O(1) average case for adding a new word or updating an existing word\'s count. - `most_common`: O(k log k) where k is the number of unique words, considering sorting. - `count`: O(1) average case for retrieving the count of a word. **Example Input** ```python word_counter = WordCounter() word_counter.add_word(\\"apple\\") word_counter.add_word(\\"banana\\") word_counter.add_word(\\"apple\\") word_counter.add_word(\\"cherry\\") word_counter.add_word(\\"banana\\") word_counter.add_word(\\"banana\\") print(word_counter.count(\\"banana\\")) # Output: 3 print(word_counter.count(\\"apple\\")) # Output: 2 print(word_counter.count(\\"cherry\\")) # Output: 1 print(word_counter.count(\\"date\\")) # Output: 0 print(word_counter.most_common(2)) # Output: [\\"banana\\", \\"apple\\"] print(word_counter.most_common(1)) # Output: [\\"banana\\"] print(word_counter.most_common(3)) # Output: [\\"banana\\", \\"apple\\", \\"cherry\\"] ``` **Detailed Instructions** 1. Implement the `WordCounter` class with: - An `__init__` method to initialize the counter. - An `add_word` method to add or update words. - A `most_common` method to retrieve the most common words. - A `count` method to fetch the count of a specific word.","solution":"from collections import defaultdict class WordCounter: def __init__(self): self.word_count = defaultdict(int) def add_word(self, word: str): self.word_count[word] += 1 def most_common(self, n: int): sorted_words = sorted(self.word_count.items(), key=lambda item: (-item[1], item[0])) return [word for word, count in sorted_words[:n]] def count(self, word: str): return self.word_count[word]"},{"question":"# Problem: Implement a Function to Compute the Carmichael Function Given a positive integer `n`, write a function `carmichael_lambda(n: int) -> int` that computes the Carmichael function (also known as the reduced totient function). The function should return the smallest positive integer `m` such that `a^m ≡ 1 (mod n)` for every integer `a` coprime to `n`. **Input**: * A single integer `n` where `1 <= n <= 10^6`. **Output**: * The function should return the value of the Carmichael function for the given integer `n`. **Function Signature**: ```python def carmichael_lambda(n: int) -> int: pass ``` # Constraints: 1. If `n` is not a positive integer, the function should raise a `ValueError` with the message \\"Input must be a positive integer\\". 2. If `n` is not an integer type, the function should raise a `TypeError` with the message \\"Input value of [number=n] must be an integer\\". # Example: ```python >>> carmichael_lambda(8) 2 >>> carmichael_lambda(7) 6 >>> carmichael_lambda(9) 6 ``` # Notes: * The Carmichael function can be computationally intensive, so ensure an efficient implementation. * Factorization is a key part of computing the function and should be handled efficiently for values up to `10^6`. * Consider using properties of prime factorization and totient functions to optimize the solution. * Make sure to handle edge cases such as small values of `n` and invalid input types. # Hints: * For an integer `n`, if `n` is a product of prime powers, the Carmichael function `λ(n)` is computed using: * λ(p^k) = φ(p^k) when `p` is 2 and `k` > 2, * λ(p^k) = 2^(k-2) when `p` is 2 and `k` = 2, * λ(p^k) = (p-1)p^(k-1) otherwise. * Use the least common multiple (LCM) to combine the results of λ(p^k) for each prime power factor in `n`.","solution":"from math import gcd from functools import reduce def lcm(a, b): return abs(a * b) // gcd(a, b) def prime_factors(n): factors = {} d = 2 while d * d <= n: while (n % d) == 0: if d in factors: factors[d] += 1 else: factors[d] = 1 n //= d d += 1 if n > 1: factors[n] = 1 return factors def carmichael_lambda(n): if not isinstance(n, int): raise TypeError(f\\"Input value of [number={n}] must be an integer\\") if n <= 0: raise ValueError(\\"Input must be a positive integer\\") if n == 1: return 1 factors = prime_factors(n) lcm_values = [] for p, k in factors.items(): if p == 2 and k > 2: lcm_values.append(2**(k-2)) else: lcm_values.append((p-1) * (p**(k-1))) return reduce(lcm, lcm_values)"},{"question":"# Reverse Words in a Sentence Write a function that takes a sentence as input and returns the sentence with the words reversed. The function should handle multiple spaces between words and maintain the original spaces in the output. **Function Signature**: ```python def reverse_words(sentence: str) -> str: Reverse the words in a given sentence while preserving the original spaces. Args: sentence (str): A string representing the sentence to be processed. Returns: str: A new string with the words in the sentence reversed, with the original spaces preserved. ``` **Input**: - A string `sentence` representing the sentence to be reversed. The sentence may include multiple spaces between words. **Output**: - A string with the words in the sentence reversed but the spaces between the words preserved exactly as they were in the original sentence. **Constraints**: - The input string can be of length up to 10^5. - The sentence consists of printable ASCII characters and spaces. **Performance Requirements**: - The solution should efficiently handle large input strings within a reasonable time frame. **Example**: ```python sentence = \\"This is a sample sentence\\" reversed_sentence = reverse_words(sentence) # Expected output expected_output = \\"sentence sample a is This\\" assert reversed_sentence == expected_output ``` **Hint**: - Consider splitting the sentence into words while retaining the spaces, then reversing the list of words and reconstructing the sentence with spaces in their original positions. - The function should avoid using extra spaces wherever possible to be memory efficient. This question tests the understanding and application of string manipulation, handling various delimiters, and maintaining the original structure of input data while transforming it.","solution":"def reverse_words(sentence: str) -> str: Reverse the words in a given sentence while preserving the original spaces. Args: sentence (str): A string representing the sentence to be processed. Returns: str: A new string with the words in the sentence reversed, with the original spaces preserved. # Split the sentence into words and spaces using regular expressions import re parts = re.split(r\'(s+)\', sentence) # Extract the words by filtering out non-space parts words = [part for part in parts if not part.isspace()] # Reverse the list of words words.reverse() # Reconstruct the sentence reconstruct_sentence = [] word_index = 0 for part in parts: if part.isspace(): reconstruct_sentence.append(part) else: reconstruct_sentence.append(words[word_index]) word_index += 1 return \'\'.join(reconstruct_sentence)"},{"question":"# Coding Assessment Question Context: Understanding the manipulation of string-based data structures is crucial for data processing and text analytics applications. String transformations that involve recursive approaches can be particularly insightful for complex text processing tasks. Task: Write a function `reverse_nested_strings(data: list[str | list]) -> list[str | list]` that takes a potentially nested list of strings and reverses each string in place, maintaining the original nested structure. Your function should handle any level of nesting within the list. Input: * A list, `data`, which can contain strings or other lists that can be nested arbitrarily. Output: * A list with the same nested structure where each string is reversed. Constraints: * The input list can be deeply nested. * Strings in the list can be empty. * The nesting of lists can be deeply recursive. Performance Requirements: * Ensure the time complexity is O(n), where n is the total number of characters in all strings. * Aim for a space complexity that is mindful of the recursion depth. Example: ```python def reverse_nested_strings(data: list[str | list]) -> list[str | list]: # Your implementation here # Test cases print(reverse_nested_strings([\\"abc\\", [\\"def\\", [\\"ghi\\", \\"jkl\\"]]])) # Output: [\'cba\', [\'fed\', [\'ihg\', \'lkj\']]] print(reverse_nested_strings([[\\"hello\\", \\"world\\"], \\"example\\", [\\"nested\\", [\\"strings\\"]]])) # Output: [[\'olleh\', \'dlrow\'], \'elpmaxe\', [\'detsen\', [\'sgnirts\']]] print(reverse_nested_strings([\\"a\\", [\\"bb\\", [\\"ccc\\", [\\"dddd\\"]]]])) # Output: [\'a\', [\'bb\', [\'ccc\', [\'dddd\']]]] ``` Note: * Ensure the function handles varying levels of nested empty lists correctly. * The main focus should be on maintaining the original nested structure while reversing the strings.","solution":"def reverse_nested_strings(data): Reverses each string in a potentially nested list, maintaining the original nested structure. :param data: A list of strings or nested lists containing strings. :type data: list[str | list] :return: A list with the same nested structure where each string is reversed. :rtype: list[str | list] if isinstance(data, list): # Check if data is a list return [reverse_nested_strings(item) for item in data] # Recursively process each element elif isinstance(data, str): # If data is a string return data[::-1] # Reverse the string return data # In case of unexpected type, return as is"},{"question":"# Pair Sum Closest to Target You\'ve been hired as a software developer at a finance company, and one of the tasks assigned to you is to optimize a stock pattern analysis tool. To evaluate it, you need to write a function that, given an array of integers representing stock prices and a target integer, finds the two indices whose stock prices sum up closest to the given target. **Objective**: Implement a robust function `closest_pair_sum` to manage stock price evaluations efficiently, specifically to: - Find a pair of stocks whose prices sum up as close as possible to the target. **Requirements**: 1. **Function Signature**: * `closest_pair_sum(prices: List[int], target: int) -> Tuple[int, int]` 2. **Parameters**: - `prices`: A list of integers representing stock prices. - `target`: An integer representing the target sum. 3. **Output**: - Return a tuple of two indices `(i, j)` such that the sum of `prices[i]` and `prices[j]` is closest to the target. If there are multiple solutions, return any. **Constraints**: * `2 <= len(prices) <= 10^5` * `-10^9 <= prices[i] <= 10^9` * `-10^9 <= target <= 10^9` * Function methods must be optimized for: * Time complexity: O(n log n) **Example**: ```python # Example 1 prices = [1, 3, 4, 7, 10] target = 15 print(closest_pair_sum(prices, target)) # Expected: (2, 4) or (1, 4) or other pairs with sum close to 15 # Example 2 prices = [-1, 2, 1, -4] target = 1 print(closest_pair_sum(prices, target)) # Expected: (0, 2) or (1, 2) # Example 3 prices = [5, 10, 22, 13, 7] target = 19 print(closest_pair_sum(prices, target)) # Expected: (0, 3) or (1, 4) ``` __Note__: - The returned indices should be zero-based. - Handle edge cases and ensure that the solution works efficiently within the given constraints.","solution":"from typing import List, Tuple def closest_pair_sum(prices: List[int], target: int) -> Tuple[int, int]: # Create a list of tuples with prices and their indices indexed_prices = list(enumerate(prices)) # Sort the prices by their values indexed_prices.sort(key=lambda x: x[1]) # Initialize pointers left, right = 0, len(prices) - 1 closest_pair = (indexed_prices[left][0], indexed_prices[right][0]) closest_diff = abs(target - (indexed_prices[left][1] + indexed_prices[right][1])) # Use two-pointer technique to find the closest sum while left < right: current_sum = indexed_prices[left][1] + indexed_prices[right][1] current_diff = abs(target - current_sum) if current_diff < closest_diff: closest_pair = (indexed_prices[left][0], indexed_prices[right][0]) closest_diff = current_diff if current_sum < target: left += 1 else: right -= 1 return closest_pair"},{"question":"**[Question 2]: Prime Factorization Efficiently** Your task for this coding assessment is to implement an efficient algorithm to determine all the prime factors of a given positive integer. This task will evaluate your understanding of number theory, algorithm optimization, and handling large integer inputs. # Problem Statement: Write a function `prime_factors(n: int) -> list` that returns a list of all prime factors of a given integer ( n ). # Input: - An integer ( n ) where ( 2 leq n leq 10^{12} ). # Output: - A list of integers representing the prime factors of ( n ), sorted in ascending order. # Function Signature: ```python def prime_factors(n: int) -> list: ``` # Constraints: - The function should be capable of handling large inputs efficiently. - The prime factors should be unique and sorted in ascending order. - Aim for an average-case time complexity of ( O(sqrt{n}) ). - Avoid using additional space beyond what is necessary to store the results. # Example: ```python assert prime_factors(60) == [2, 3, 5] assert prime_factors(13195) == [5, 7, 13, 29] assert prime_factors(563) == [563] assert prime_factors(1_000_000_000_000) == [2, 5, 5, 5, 5] assert prime_factors(997) == [997] # 997 is a prime number. ``` # Implementation Details: 1. **Trial Division**: - Begin with the smallest prime 2 and check divisibility. - For odd numbers, continue checking for divisibility up to ( sqrt{n} ). 2. **Handling Large Numbers**: - Implement optimizations to avoid redundant calculations. 3. **Edge Cases**: - Ensure the function can handle both small and very large values of ( n ) efficiently, including prime numbers and highly composite numbers. # Note: Develop an algorithm which is carefully optimized to handle the constraints. Ensure to test your implementations on various edge cases and large inputs.","solution":"def prime_factors(n: int) -> list: Returns all prime factors of a given positive integer n. i = 2 factors = [] while i * i <= n: if n % i: i += 1 else: if i not in factors: factors.append(i) n //= i if n > 1 and n not in factors: factors.append(n) return factors"},{"question":"# Question: Financial Transactions Ledger Context You are required to design a class for managing a financial transactions ledger. This ledger should support adding transactions, calculating the current balance, and generating a summary of transactions. Requirements 1. **Ledger Class (`FinancialLedger`)**: - Should contain a list to hold transactions. - Must support addition of new transactions. - Must maintain a running balance. 2. **Transaction Recording**: - Implement a method `add_transaction` within the `FinancialLedger` class to add a transaction. - Each transaction should include an amount (positive for deposit, negative for withdrawal) and a description. 3. **Balance Calculation**: - Implement a method `current_balance` to return the current balance based on all transactions. 4. **Summary Report**: - Implement a method `generate_summary` to provide a summary of transactions including total deposits, total withdrawals, and the final balance. Implementation Details - **Input Format**: - Transactions in the form of amount and description. - **Output Format**: - Current balance as a single float value. - Summary in the form of a dictionary containing the number of transactions, total deposits, total withdrawals, and final balance. - **Constraints**: - Handle up to 1000 transactions. - Ensure robustness by validating transaction amounts (they must be non-zero). Function Signature ```python from typing import List, Dict class FinancialLedger: def __init__(self): self.transactions = [] def add_transaction(self, amount: float, description: str) -> None: pass # Add the transaction to the list and update the balance def current_balance(self) -> float: pass # Calculate and return the current balance def generate_summary(self) -> Dict[str, float]: pass # Generate and return the summary report # Example Usage: # ledger = FinancialLedger() # ledger.add_transaction(1500.0, \\"Salary\\") # ledger.add_transaction(-50.0, \\"Groceries\\") # balance = ledger.current_balance() # summary = ledger.generate_summary() ``` Performance Requirements - Ensure efficient handling of transactions to maintain real-time balance calculations.","solution":"from typing import List, Dict class FinancialLedger: def __init__(self): self.transactions = [] def add_transaction(self, amount: float, description: str) -> None: if amount == 0: raise ValueError(\\"Transaction amount cannot be zero\\") self.transactions.append((amount, description)) def current_balance(self) -> float: return sum(amount for amount, _ in self.transactions) def generate_summary(self) -> Dict[str, float]: total_deposits = sum(amount for amount, _ in self.transactions if amount > 0) total_withdrawals = sum(amount for amount, _ in self.transactions if amount < 0) final_balance = self.current_balance() return { \\"number_of_transactions\\": len(self.transactions), \\"total_deposits\\": total_deposits, \\"total_withdrawals\\": total_withdrawals, \\"final_balance\\": final_balance }"},{"question":"# Bank Account Management System **Objective**: Create a simple Bank Account management system. Implement a class `BankAccount` that allows for depositing, withdrawing, and checking the balance of an account. Class Definition ```python class BankAccount: def __init__(self, initial_balance: float = 0.0): pass def deposit(self, amount: float) -> None: pass def withdraw(self, amount: float) -> None: pass def get_balance(self) -> float: pass ``` Methods * `__init__(self, initial_balance: float = 0.0) -> None`: Initializes the bank account with an optional initial balance. * `deposit(self, amount: float) -> None`: Adds the specified amount to the account balance. * `withdraw(self, amount: float) -> None`: Deducts the specified amount from the account balance, if sufficient funds are available. * `get_balance(self) -> float`: Returns the current account balance. Constraints * Initial balance and any transaction amounts should be non-negative. * Withdrawals that exceed the current balance should raise an `InsufficientFundsError`. Custom Exception ```python class InsufficientFundsError(Exception): pass ``` Example Usage: ```python >>> account = BankAccount(100) >>> account.deposit(50) >>> account.get_balance() 150.0 >>> account.withdraw(20) >>> account.get_balance() 130.0 >>> account.withdraw(200) Traceback (most recent call last): ... InsufficientFundsError: Insufficient funds for this transaction ``` # Additional Requirements * Ensure methods validate that transaction amounts are non-negative. * Include appropriate docstrings for each method. * Handle edge cases, such as initializing with negative amounts or attempting to deposit/withdraw negative amounts, by raising a `ValueError`. # Context Managing financial transactions and maintaining accurate records are crucial in the world of finance. Implementing a bank account management system that ensures proper handling of deposits, withdrawals, and balance inquiry helps build a foundational understanding of financial software applications.","solution":"class InsufficientFundsError(Exception): Exception to be raised when withdrawal amount exceeds the balance. pass class BankAccount: def __init__(self, initial_balance: float = 0.0): if initial_balance < 0: raise ValueError(\\"Initial balance cannot be negative.\\") self.balance = initial_balance def deposit(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Deposit amount cannot be negative.\\") self.balance += amount def withdraw(self, amount: float) -> None: if amount < 0: raise ValueError(\\"Withdrawal amount cannot be negative.\\") if amount > self.balance: raise InsufficientFundsError(\\"Insufficient funds for this transaction.\\") self.balance -= amount def get_balance(self) -> float: return self.balance"},{"question":"# Array Rotation with Shifts Background You are developing a function to rotate the elements of an array (list) by a specified number of positions. The rotation should be to the right; that means elements shifted beyond the last position reappear at the beginning. Task Create a function `rotate_array` that takes in a list of integers and an integer `k`, representing the number of positions to rotate. The function should return a new list with the elements rotated to the right by `k` positions. Function Signature ```python def rotate_array(arr: List[int], k: int) -> List[int]: pass ``` Input * `arr`: A list of integers. * `k`: An integer indicating the number of positions to rotate the list. Output * A list of integers that represent the rotated array. Constraints * The array length will be between 1 and 10^5, inclusive. * The number of positions `k` will be between 0 and 10^5, inclusive. * The values in the array can be any integers. Performance Requirements * Your implementation should handle cases where `k` is greater than the length of the list efficiently by taking the modulo of `k` with the length of the list. Example ```python >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotate_array([1, 2, 3, 4, 5], 7) [4, 5, 1, 2, 3] ``` In the first example, rotating the list [1, 2, 3, 4, 5] by 2 positions to the right gives [4, 5, 1, 2, 3]. In the second example, rotating the list by 5 positions (which is the length of the list) results in the same list [1, 2, 3, 4, 5]. In the third example, rotating by 7 positions is the same as rotating by 2 positions (since 7 % 5 = 2), resulting in [4, 5, 1, 2, 3]. **Note**: Optimize your solution to handle large lists and rotations efficiently.","solution":"from typing import List def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the elements of the array `arr` to the right by `k` positions. n = len(arr) if n == 0: return arr k = k % n return arr[-k:] + arr[:-k]"},{"question":"# Question You have been tasked with writing a function for a system that monitors and logs user activity on a website. The function should analyze the log file containing user activity data and identify users who have exceeded a specified number of requests within a given time window. This is useful for detecting potential misuse or bot activity. Your task is to implement a function `find_overactive_users` that parses a log file and identifies users who exceed the request threshold within a given time window. **Function Signature:** ```python def find_overactive_users(log_file: str, threshold: int, time_window: int) -> set: pass ``` # Input: - `log_file`: A string representing the path to the log file. - `threshold`: An integer representing the maximum number of allowed requests within the `time_window`. - `time_window`: An integer representing the time window in seconds. # Output: - Returns a set of user IDs (as strings) who exceeded the request threshold within the specified time window. # Constraints: - The log file will be in the format where each line represents a log entry: `\\"timestamp,user_id\\"` (example: `\\"1615150968,user_123\\"`). - Timestamps are in Unix epoch format (seconds since January 1, 1970). - Assume the log file is sorted by timestamp in ascending order. - You may use any standard libraries to aid in file parsing and time handling. # Example: **Log File Content (log.txt)**: ``` 1615150968,user_123 1615151068,user_123 1615151168,user_123 1615151268,user_456 1615151368,user_123 1615151468,user_456 1615151568,user_456 ``` **Threshold**: 3 **Time Window**: 900 ```python # Example Usage: overactive_users = find_overactive_users(\\"log.txt\\", 3, 900) print(overactive_users) # Output: {\\"user_123\\"} ``` In this example, `user_123` has made 4 requests within a 900-second window, exceeding the threshold of 3. The function should detect this and return their user ID in the result set.","solution":"from collections import defaultdict, deque def find_overactive_users(log_file: str, threshold: int, time_window: int) -> set: overactive_users = set() user_logs = defaultdict(deque) with open(log_file, \'r\') as file: for line in file: timestamp, user_id = line.strip().split(\',\') timestamp = int(timestamp) user_logs[user_id].append(timestamp) while user_logs[user_id] and (timestamp - user_logs[user_id][0] > time_window): user_logs[user_id].popleft() if len(user_logs[user_id]) > threshold: overactive_users.add(user_id) return overactive_users"},{"question":"# Problem Statement You are given an encoded string where each character is represented by its ASCII value, followed by a special character that acts as a separator, repeated for all characters in the string. Your task is to decode this string and return the original message. * **Input**: An encoded string `encoded_str` where: * Each character is represented by its ASCII value followed by a special character (always the same for the entire string). For example, \'A\' might be represented as `65|`. * The special character is always the same and non-alphanumeric. * **Output**: The original decoded string. # Constraints * The encoded string is non-empty and properly formatted. * Each ASCII value can be between 32 (space) and 126 (tilde) inclusive. * The encoded string is well-formed, containing valid ASCII codes followed by the separator. # Example Given the encoded string, ``` \\"72|101|108|108|111|32|87|111|114|108|100|\\" ``` - The encoded string corresponds to ASCII values: 72, 101, 108, 108, 111, which translates to `Hello World`. The correct output would be `Hello World`. # Function Signature ```python def decode_string(encoded_str: str) -> str: pass ``` # Requirements * Must correctly identify the special separator character. * Must handle strings containing various ASCII values within the specified range. * The solution must be efficient in terms of both time and space constraints.","solution":"def decode_string(encoded_str: str) -> str: Decodes the given encoded string into the original message. Args: encoded_str (str): The encoded string where each character is represented by its ASCII value followed by a special character. Returns: str: The original decoded string. # Identify the special separator character from the string separator = \'\' for char in encoded_str: if not char.isdigit(): separator = char break # Split the encoded string by the separator encoded_values = encoded_str.split(separator) # Decode each ASCII value into the corresponding character decoded_chars = [chr(int(value)) for value in encoded_values if value] # Join the characters to form the original message return \'\'.join(decoded_chars)"},{"question":"# Problem Statement You are tasked with implementing a function that converts an infix expression (a regular arithmetic expression like `(a + b) * c`) into its corresponding postfix expression (Reverse Polish Notation, e.g., `a b + c *`). # Function Signature Implement the following function: ```python def infix_to_postfix(expression: str) -> str: pass ``` # Input - `expression`: A string representing a valid infix expression. The expression may contain the operators `+`, `-`, `*`, `/`, parentheses `(` and `)`, and alphanumeric variables/operands (single character variables). # Output - A string representing the equivalent postfix expression. # Constraints - The input expression will have balanced parentheses. - The expression will not contain any spaces. # Examples ```python expression = \\"(a+b)*c\\" result = infix_to_postfix(expression) print(result) ``` Output: ``` \\"ab+c*\\" ``` ```python expression = \\"a+b*c\\" result = infix_to_postfix(expression) print(result) ``` Output: ``` \\"abc*+\\" ``` ```python expression = \\"(a+b)*(c-d)\\" result = infix_to_postfix(expression) print(result) ``` Output: ``` \\"ab+cd-*\\" ``` # Hints 1. Use a stack for operators and parentheses to manage precedence and correct ordering. 2. Make use of the Shunting Yard algorithm by Edsger Dijkstra to handle the conversion. 3. Ensure you correctly handle the precedence and associativity of the operators.","solution":"def infix_to_postfix(expression: str) -> str: Convert an infix expression to a postfix expression (Reverse Polish Notation). # precedence of operators precedence = {\'+\': 1, \'-\': 1, \'*\': 2, \'/\': 2} postfix = [] stack = [] def has_higher_precedence(op1, op2): return precedence[op1] >= precedence[op2] for char in expression: if char.isalnum(): # Operand postfix.append(char) elif char == \'(\': stack.append(char) elif char == \')\': while stack and stack[-1] != \'(\': postfix.append(stack.pop()) stack.pop() # popping the \'(\' else: # Operator while stack and stack[-1] != \'(\' and has_higher_precedence(stack[-1], char): postfix.append(stack.pop()) stack.append(char) while stack: postfix.append(stack.pop()) return \'\'.join(postfix)"},{"question":"# Bitwise Manipulation to Find the Unique Number Scenario You are working on a telecommunication system where it is crucial to identify errors in transmission by ensuring that every number in a stream occurs exactly twice, except for one unique number that occurs only once. To resolve this, you need to find the unique number using an efficient bitwise manipulation technique. Objective Implement the `UniqueNumberFinder` class to identify the one unique number in a list where every other number appears exactly twice. Requirements 1. **Input**: - A list of integers `nums` where every integer appears twice except for one unique integer. 2. **Output**: - The unique integer that appears only once in the list. 3. **Constraints**: - The list will have a length `n`, where `1 <= n < 10^6`. - The input list is guaranteed to have one unique integer and all others appearing exactly twice. 4. **Performance**: - Your solution should run in linear time `O(n)` and use constant space `O(1)`. Function Signature ```python class UniqueNumberFinder: def __init__(self, nums: list[int]): # initialization code def find_unique_number(self) -> int: # code to find the unique number ``` Hints - Utilize bitwise XOR operation properties to identify the single unique number. - Recall that `x ^ x = 0` and `x ^ 0 = x` for any integer `x`. Example ```python nums = [4, 1, 2, 1, 2] unf = UniqueNumberFinder(nums) unique_num = unf.find_unique_number() print(unique_num) # Expected output: 4 ``` By adhering to the provided format, presentation style, and complexity, this new question aligns well with the given set and applies similar programming concepts in a slightly different context.","solution":"class UniqueNumberFinder: def __init__(self, nums: list[int]): self.nums = nums def find_unique_number(self) -> int: unique_number = 0 for num in self.nums: unique_number ^= num return unique_number"},{"question":"# Context: Real-time Analytics with Sliding Window Maximum You are tasked with developing a feature for an analytics dashboard that requires monitoring the maximum value among a stream of data points within a sliding window of fixed size. This problem often arises in scenarios such as tracking the highest temperature over the last 24 hours recorded every hour, or finding the maximum stock price over the last `n` minutes in a live trading application. Using the sliding window approach, implement a function to compute the maximum values in a sliding window for a given list of data points. # Task Requirements - Implement the `sliding_window_maximum` method: This should return a list of maximum values from each sliding window as it moves from the start to the end of the data points. Function Signature: ```python def sliding_window_maximum(nums: List[int], k: int) -> List[int]: pass ``` Input/Output Formats: - **Input**: - `nums`: A list of integers representing the stream of data points. - `k`: An integer indicating the size of the sliding window. - **Output**: A list of integers representing the maximum value in each sliding window position. Example: ```python >>> sliding_window_maximum([1,3,-1,-3,5,3,6,7], 3) [3, 3, 5, 5, 6, 7] >>> sliding_window_maximum([9,11,8,5,7,10], 2) [11, 11, 8, 7, 10] ``` Constraints: - 1 <= len(nums) <= 10^5 - -10^4 <= nums[i] <= 10^4 - 1 <= k <= len(nums) # Notes: - It is crucial to handle edge cases where `k` equals 1, `k` equals the length of `nums`, and the presence of negative numbers in `nums`. - Aim to have an efficient solution, ideally O(n) time complexity, to accommodate for potentially large input sizes.","solution":"from collections import deque from typing import List def sliding_window_maximum(nums: List[int], k: int) -> List[int]: Return a list of the maximum values in each sliding window of size k. dq = deque() max_values = [] for i in range(len(nums)): # Remove elements from the deque that are out of the current window if dq and dq[0] == i - k: dq.popleft() # Remove elements from the deque from the rear if they\'re smaller than the current element while dq and nums[dq[-1]] < nums[i]: dq.pop() # Add the current element\'s index to the deque dq.append(i) # Starting from the (k-1)th position, add the current max to the result list if i >= k - 1: max_values.append(nums[dq[0]]) return max_values"},{"question":"# Coding Assessment Question Your task is to write a function that removes duplicate elements from a singly linked list. The function should preserve the order of the first occurrence of each element. # Function Signature: ```python def remove_duplicates(head: Optional[ListNode]) -> Optional[ListNode]: ``` # Input: - `head` (Optional[ListNode]): The head of a singly linked list. # Output: - Returns the head of the modified linked list with duplicates removed. # List Node Definition: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` # Constraints: - The values in the linked list are integers. - The linked list length is between 0 and 10,000. # Examples: - Example 1: ```python head = ListNode(1, ListNode(2, ListNode(3, ListNode(2, ListNode(3, ListNode(1)))))) result = remove_duplicates(head) # Output: 1 -> 2 -> 3 ``` - Example 2: ```python head = ListNode(1, ListNode(1, ListNode(1))) result = remove_duplicates(head) # Output: 1 ``` - Example 3: ```python head = ListNode(5, ListNode(6, ListNode(7, ListNode(7, ListNode(6, ListNode(8)))))) result = remove_duplicates(head) # Output: 5 -> 6 -> 7 -> 8 ``` - Example 4: ```python head = None result = remove_duplicates(head) # Output: None ``` # Notes: - The input linked list might be empty, represented by `head = None`. - You may assume that the linked list does not contain cycles.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def remove_duplicates(head): if not head: return None seen = set() current = head prev = None while current: if current.val in seen: prev.next = current.next else: seen.add(current.val) prev = current current = current.next return head"},{"question":"**Context**: You are working on a security module for a web application that requires efficient encryption and decryption of messages. As part of this project, you need to implement the RSA encryption algorithm. **Problem**: Write a class `RSA` that can generate public and private keys, encrypt a message, and decrypt a message using the RSA algorithm. **Class Definition and Method Signatures**: ```python class RSA: def __init__(self, prime1: int, prime2: int): pass def encrypt(self, plaintext: str) -> list: pass def decrypt(self, ciphertext: list) -> str: pass ``` **Input**: * Two prime numbers `prime1` and `prime2` to be provided at the initialization of the `RSA` class. * A plaintext string `plaintext` to be encrypted. * A list of integers `ciphertext` representing the encrypted message to be decrypted. **Output**: * The `encrypt` method should return a list of integers representing the encrypted message. * The `decrypt` method should return the original plaintext string. **Constraints**: * `prime1` and `prime2` are distinct prime numbers, each having a bit length of up to 16 bits. * The plaintext string will contain ASCII characters only and will have a maximum length of 255 characters. * The encryption and decryption should handle messages block by block if necessary. **Example**: ```python rsa = RSA(61, 53) # Initialize with two prime numbers plaintext = \\"HELLO RSA\\" ciphertext = rsa.encrypt(plaintext) print(ciphertext) # Example: [2790, 3937, 2025, 2025, 1995, 1377, 1563, 837] decrypted_message = rsa.decrypt(ciphertext) print(decrypted_message) # Expected: \\"HELLO RSA\\" ``` **Additional Information**: 1. During the initialization, calculate `n` as the product of `prime1` and `prime2`. 2. Calculate the totient function `φ(n) = (prime1 - 1) * (prime2 - 1)`. 3. Choose an integer `e` such that 1 < e < φ(n) and `gcd(e, φ(n)) = 1`. 4. Compute `d` as the modular multiplicative inverse of `e` modulo `φ(n)`. 5. The public key is (e, n) and the private key is (d, n). The `encrypt` method will use the public key, and the `decrypt` method will use the private key for their respective operations. Both methods will convert characters to their ASCII values and operate on them as numerical data.","solution":"import sympy import math class RSA: def __init__(self, prime1: int, prime2: int): self.p = prime1 self.q = prime2 self.n = self.p * self.q self.phi = (self.p - 1) * (self.q - 1) # Find an integer e such that gcd(e, phi) = 1 and 1 < e < phi self.e = next(e for e in range(2, self.phi) if math.gcd(e, self.phi) == 1) # Compute d, the modular multiplicative inverse of e modulo phi self.d = sympy.mod_inverse(self.e, self.phi) def encrypt(self, plaintext: str) -> list: ciphertext = [(ord(char) ** self.e) % self.n for char in plaintext] return ciphertext def decrypt(self, ciphertext: list) -> str: plaintext = \'\'.join([chr((char ** self.d) % self.n) for char in ciphertext]) return plaintext"},{"question":"# Vowel Count in a Text File **Objective**: Implement a function to read the content of a text file and count the occurrences of each vowel (a, e, i, o, u) in both lowercase and uppercase forms. **Scenario**: You have a text file containing various sentences. You need to determine the number of times each vowel appears in the file for a textual analysis project. Ensure that your solution is efficient and handles large files without running into memory issues. **Requirements**: - Define a function `count_vowels_in_file(filename: str) -> dict` that: - Takes the name of a text file (string). - Returns a dictionary with the vowels as keys (both lowercase and uppercase), and their counts as values. - Handle file not found errors by returning an appropriate error message. - If the file is empty, return a dictionary with all counts set to zero. **Function Signature**: ```python def count_vowels_in_file(filename: str) -> dict: pass ``` **Constraints**: - The file name provided is valid. - The file might be large, use efficient reading methods. - Only English vowels (a, e, i, o, u) in both lowercase and uppercase should be counted. **Examples**: 1. If the contents of `example.txt` are `\\"Hello World\\"`, then: ```python { \\"a\\": 0, \\"e\\": 1, \\"i\\": 0, \\"o\\": 2, \\"u\\": 0, \\"A\\": 0, \\"E\\": 0, \\"I\\": 0, \\"O\\": 0, \\"U\\": 0 } ``` 2. If the contents of `example.txt` are `\\"\\"` (an empty file), then: ```python { \\"a\\": 0, \\"e\\": 0, \\"i\\": 0, \\"o\\": 0, \\"u\\": 0, \\"A\\": 0, \\"E\\": 0, \\"I\\": 0, \\"O\\": 0, \\"U\\": 0 } ``` 3. If the file `nonexistent.txt` does not exist: - Should return: ```python { \\"error\\": \\"File not found.\\" } ``` **Notes**: - Ensure that the function handles both lowercase and uppercase vowels separately. - The dictionary should include all vowels even if their count is zero.","solution":"def count_vowels_in_file(filename: str) -> dict: Reads the content of a file and counts occurrences of each vowel in both lowercase and uppercase forms. Parameters: filename: str - The name of the text file to read from. Returns: dict: A dictionary with vowels as keys and their counts as values. vowels = \'aeiouAEIOU\' counts = {vowel: 0 for vowel in vowels} try: with open(filename, \'r\') as file: text = file.read() for char in text: if char in counts: counts[char] += 1 except FileNotFoundError: return {\\"error\\": \\"File not found.\\"} return counts"},{"question":"# Question: Inventory Management System Implementation You are tasked to implement a class, `Inventory`, representing a basic inventory management system for a store. This system should support operations such as adding items, checking item availability, computing the total value of the inventory, and clearing the inventory. Your task: Implement the `Inventory` class with the following functionalities: 1. **Initialization**: - Initialize the inventory with an empty dictionary to store items where the key is the item name and the value is a tuple of (quantity, unit price). 2. **Add Item**: - `add_item(self, item_name: str, quantity: int, unit_price: float) -> None`: Add a specified quantity of an item at a given unit price to the inventory. If the item already exists, update its quantity and unit price. 3. **Check Availability**: - `check_availability(self, item_name: str) -> bool`: Check if a specified item is available in the inventory. 4. **Compute Total Value**: - `total_value(self) -> float`: Compute and return the total value of all items in the inventory, calculated as the sum of (quantity * unit price) for each item. 5. **Clear Inventory**: - `clear_inventory(self) -> None`: Clear the inventory by removing all items. Requirements: * Name of the class: `Inventory` * Each method should handle invalid input or operations gracefully. For example, adding an item with a non-positive quantity or unit price should raise a `ValueError`. * Provide detailed docstrings for each method. Example Scenarios & Edge Cases: 1. **Edge Cases**: * Adding an item with zero or negative quantity or unit price. * Checking availability for an item not in the inventory. * Calculating total value when the inventory is empty. 2. **Example Usage**: ```python inventory = Inventory() inventory.add_item(\\"Laptop\\", 10, 999.99) inventory.add_item(\\"Smartphone\\", 15, 499.50) print(inventory.check_availability(\\"Laptop\\")) # Expected: True print(inventory.check_availability(\\"Tablet\\")) # Expected: False print(inventory.total_value()) # Expected: 17498.35 (10*999.99 + 15*499.50) inventory.clear_inventory() print(inventory.total_value()) # Expected: 0.0 ``` Implement the class with all necessary methods and ensure that it passes testing for the edge cases and examples provided.","solution":"class Inventory: def __init__(self): Initialize an empty inventory. self.items = {} def add_item(self, item_name: str, quantity: int, unit_price: float) -> None: Add an item to the inventory with the specified quantity and unit price. If the item already exists, update its quantity and unit price. :param item_name: Name of the item to add. :param quantity: Quantity of the item. :param unit_price: Unit price of the item. :raises ValueError: If quantity or unit price is non-positive. if quantity <= 0 or unit_price <= 0: raise ValueError(\\"Quantity and unit price must be positive\\") if item_name in self.items: existing_quantity, _ = self.items[item_name] self.items[item_name] = (existing_quantity + quantity, unit_price) else: self.items[item_name] = (quantity, unit_price) def check_availability(self, item_name: str) -> bool: Check if a specified item is available in the inventory. :param item_name: Name of the item to check. :return: True if the item is available, False otherwise. return item_name in self.items def total_value(self) -> float: Compute and return the total value of all items in the inventory. :return: The total value of the inventory. return sum(quantity * unit_price for quantity, unit_price in self.items.values()) def clear_inventory(self) -> None: Clear the inventory by removing all items. self.items.clear()"},{"question":"# Reversing a Consecutive Subarray **Context**: Reversing a subarray is a common operation in various algorithms. There may be a situation where you need to reverse a specific consecutive part of an array while leaving the rest of the array unchanged. **Task**: Write a function `reverse_subarray(nums: list[int], start: int, end: int) -> list[int]` that reverses the subarray of `nums` starting from index `start` to index `end` (both inclusive). If `start` or `end` indices are out of range, raise an `IndexError`. **Input**: * `nums`: A list of integers. Example: `[1, 2, 3, 4, 5, 6, 7, 8]` * `start`: An integer indicating the starting index of the subarray to reverse. * `end`: An integer indicating the ending index of the subarray to reverse. **Output**: * Return a list of integers with the specified subarray reversed. **Constraints**: * You must not use any external libraries for reversing the subarray. Requirements: 1. Implement the subarray reversal from scratch. 2. The time complexity should not exceed O(n). ```python def reverse_subarray(nums: list[int], start: int, end: int) -> list[int]: Return a list with the specified subarray reversed. Wiki: https://en.wikipedia.org/wiki/In-place_algorithm >>> reverse_subarray([1, 2, 3, 4, 5, 6, 7, 8], 2, 5) [1, 2, 6, 5, 4, 3, 7, 8] >>> reverse_subarray([10, 20, 30, 40, 50], 1, 3) [10, 40, 30, 20, 50] >>> reverse_subarray([7], 0, 0) [7] >>> reverse_subarray([5, 10, 15], 2, 2) [5, 10, 15] >>> reverse_subarray([4, 8, 15, 16], 3, 3) [4, 8, 15, 16] >>> reverse_subarray([1, 2, 3, 4], 2, 1) Traceback (most recent call last): ... IndexError: Invalid start or end index >>> reverse_subarray([], 0, 0) Traceback (most recent call last): ... IndexError: Invalid start or end index # Your code here if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` **Explanation**: 1. If `start` or `end` indices are out of range, raise an `IndexError`. 2. Reverse the subarray of `nums` starting from index `start` to index `end`. **Edge Cases to Consider**: 1. The subarray to reverse is of length 0 or 1. 2. The list is empty. 3. `start` and `end` indices are the same. 4. `start` is greater than `end`.","solution":"def reverse_subarray(nums: list[int], start: int, end: int) -> list[int]: Returns a list with the specified subarray reversed. If start or end indices are out of range, raises an IndexError. if start < 0 or end >= len(nums) or start > end: raise IndexError(\\"Invalid start or end index\\") while start < end: nums[start], nums[end] = nums[end], nums[start] start += 1 end -= 1 return nums"},{"question":"# Coding Assessment Question: String Compression **Scenario**: In data transmission and storage, it\'s often necessary to compress strings to save space. You\'ll implement a function to compress strings using the following scheme: consecutive identical characters are replaced by the character followed by the number of repetitions. **Objective**: Write a function `compress_string` that takes a string input and returns a compressed version of the string according to the specifications provided. **Specifications**: 1. **Input**: - A string consisting of uppercase and lowercase English letters only. 2. **Output**: - A compressed string where sequences of the same character are replaced by the character followed by the number of times it appears consecutively in the original string. If the compressed string is not shorter than the original, return the original string. 3. **Constraints**: - The function should handle empty strings and single-character strings appropriately. - The function should be case-sensitive (treat \'a\' and \'A\' as different characters). **Function Signature**: ```python def compress_string(s: str) -> str: Compresses the input string using the specified compression algorithm. pass ``` **Performance Requirements**: - Ensure the function runs in linear time relative to the length of the string (O(n)). **Example Cases**: ```python assert compress_string(\\"aabcccccaaa\\") == \\"a2b1c5a3\\" assert compress_string(\\"abcd\\") == \\"abcd\\" # Compressed version \\"a1b1c1d1\\" is not shorter assert compress_string(\\"aaaaa\\") == \\"a5\\" assert compress_string(\\"\\") == \\"\\" # Edge case: Empty string assert compress_string(\\"aA\\") == \\"aA\\" # Case-sensitive check ``` **Implementation Steps**: 1. Initialize an empty result list to build the compressed string. 2. Traverse the input string, maintaining a count of consecutive identical characters. 3. For each sequence of consecutive characters, append the character and its count to the result list. 4. Convert the result list to a string. 5. Compare the lengths of the compressed and original strings and return the shorter one. --- Your task is to implement the `compress_string` function based on the outlined specifications. Make sure to handle various edge cases and meet the performance requirements.","solution":"def compress_string(s: str) -> str: if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 # Append the last set of characters compressed.append(s[-1] + str(count)) compressed_string = \\"\\".join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"**Fibonacci Matrix Transformation** **Context**: The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding numbers, usually starting with 0 and 1. This sequence can be extended to any size and is a common problem in programming exercises. In this problem, we will transform a matrix by replacing its elements with the corresponding Fibonacci numbers based on their positions. **Task**: Write a function `fibonacci_matrix_transformation` that takes a 2D numpy array (matrix) and returns a new matrix where each element is replaced by the Fibonacci number corresponding to its 1-based position index in row-major order (i.e., left to right, top to bottom). **Function Signature**: ```python def fibonacci_matrix_transformation(matrix: np.ndarray) -> np.ndarray: pass ``` **Input**: * `matrix` (np.ndarray): A 2D numpy array of shape (M, N) containing M rows and N columns. **Output**: * `np.ndarray`: A 2D numpy array of the same shape as the input matrix with elements replaced by their corresponding Fibonacci numbers. **Constraints**: * The matrix can contain any real number. * The returned matrix should be of the same shape as the input matrix. * The Fibonacci sequence should start with 0 and 1. **Example**: ```python >>> matrix = np.array([[2, 3], [5, 8]]) >>> fibonacci_matrix_transformation(matrix) array([[0, 1], [1, 2]]) ``` **Performance Requirements**: * The implementation should handle reasonably sized matrices efficiently. **Edge Cases**: * Matrix with a single element. * Matrix with multiple rows and columns where the position corresponds to higher Fibonacci sequence values. **Instructions**: * Implement the function `fibonacci_matrix_transformation`. * Ensure your implementation handles edge cases. * You should utilize numpy\'s operations as much as possible for efficiency. --- This question is crafted while maintaining consistency with previous questions in terms of style, length, difficulty, topic alignment, and uniqueness. The extension of the classic Fibonacci sequence problem to matrix transformation provides a novel and engaging programming challenge.","solution":"import numpy as np def fibonacci_matrix_transformation(matrix: np.ndarray) -> np.ndarray: # Find the size of the matrix M, N = matrix.shape size = M * N # Generating Fibonacci sequence of required length fib_seq = [0, 1] for i in range(2, size): fib_seq.append(fib_seq[-1] + fib_seq[-2]) # Creating the transformed matrix transformed_matrix = np.array(fib_seq[:size]).reshape(M, N) return transformed_matrix"},{"question":"# Dynamic HTML Table Generator Objective You are required to create a function that generates an HTML table based on input data and specified table properties. Input/Output Format * **Input**: * A 2D list \'data\' where each inner list represents a row in the table and each element in the inner list represents a cell. * A dictionary \'table_properties\' with optional keys \'header\', \'border\', and \'caption\'. - \'header\': A boolean flag indicating whether the first row of the data should be treated as the header row. Default is False. - \'border\': An integer representing the border width of the table. Default is 1. - \'caption\': A string to be used as the table caption. * **Output**: * A string containing the generated HTML code for the table. Constraints * The input data list must have at least one row and one column. * Assume all input data is valid and not empty. Code Requirements 1. The \'border\' property should be applied to the `<table>` tag. 2. If \'header\' is True, wrap the first row in `<thead>` and subsequent rows in `<tbody>`. 3. If \'caption\' is provided, use it as a `<caption>` for the table. 4. Ensure proper HTML formatting and escaping of special characters in the data. Template ```python def generate_html_table(data, table_properties={}): Generates an HTML table based on input data and table properties. \'data\' should be a 2D list where each inner list represents a row. \'table_properties\' is an optional dictionary with keys \'header\', \'border\', and \'caption\'. header = table_properties.get(\'header\', False) border = table_properties.get(\'border\', 1) caption = table_properties.get(\'caption\', \'\') html = f\'<table border=\\"{border}\\">n\' if caption: html += f\' <caption>{caption}</caption>n\' if header: html += \' <thead>n <tr>n\' for cell in data[0]: html += f\' <th>{cell}</th>n\' html += \' </tr>n </thead>n <tbody>n\' data = data[1:] # Exclude header row from body else: html += \' <tbody>n\' for row in data: html += \' <tr>n\' for cell in row: html += f\' <td>{cell}</td>n\' html += \' </tr>n\' html += \' </tbody>n</table>\' return html # Example usage data = [ [\\"Name\\", \\"Age\\", \\"City\\"], [\\"Alice\\", 30, \\"New York\\"], [\\"Bob\\", 25, \\"Los Angeles\\"], [\\"Charlie\\", 35, \\"Chicago\\"], ] table_properties = { \'header\': True, \'border\': 2, \'caption\': \'Employee Information\' } html_table = generate_html_table(data, table_properties) print(html_table) ```","solution":"def generate_html_table(data, table_properties={}): Generates an HTML table based on input data and table properties. \'data\' should be a 2D list where each inner list represents a row. \'table_properties\' is an optional dictionary with keys \'header\', \'border\', and \'caption\'. header = table_properties.get(\'header\', False) border = table_properties.get(\'border\', 1) caption = table_properties.get(\'caption\', \'\') html = f\'<table border=\\"{border}\\">n\' if caption: html += f\' <caption>{caption}</caption>n\' if header: html += \' <thead>n <tr>n\' for cell in data[0]: html += f\' <th>{cell}</th>n\' html += \' </tr>n </thead>n <tbody>n\' data = data[1:] # Exclude header row from body else: html += \' <tbody>n\' for row in data: html += \' <tr>n\' for cell in row: html += f\' <td>{cell}</td>n\' html += \' </tr>n\' html += \' </tbody>n</table>\' return html"},{"question":"# Coding Challenge Context/Scenario You are developing a software for a bookstore. One of the features involves calculating the number of possible unique combinations of books that a customer can buy given a total amount of money they are willing to spend. Each combination should sum up to the given amount. You will be provided with an array of integers representing the prices of different books in the store and a total amount. Function Signature Create a function `num_combinations`: ```python def num_combinations(prices: List[int], total_amount: int) -> int: Given a list of integers representing the prices of books and an integer representing the total amount of money, return the number of unique combinations of prices that sum up to the total amount. ``` Expected Input and Output Formats * **Input**: - `prices (List[int])`: The prices of books where each price is a positive integer [(1 <= price <= 10^4)]. - `total_amount (int)`: The total amount of money [(0 <= total_amount <= 10^4)]. * **Output**: - `int`: The number of unique combinations of book prices that sum up to the total amount. Constraints and Limitations - If no combination exists that adds up to the total amount, return 0. Performance Requirements - The function should efficiently handle cases where the length of `prices` is up to 100 and `total_amount` is up to 10^4. Example ```python >>> num_combinations([1, 2, 3], 4) 4 >>> num_combinations([2, 3, 6, 7], 7) 2 >>> num_combinations([2, 4, 6], 5) 0 >>> num_combinations([3, 5, 7], 8) 1 ```","solution":"from typing import List def num_combinations(prices: List[int], total_amount: int) -> int: Given a list of integers representing the prices of books and an integer representing the total amount of money, return the number of unique combinations of prices that sum up to the total amount. dp = [0] * (total_amount + 1) dp[0] = 1 # There\'s one way to make 0 total amount, by choosing no books for price in prices: for amount in range(price, total_amount + 1): dp[amount] += dp[amount - price] return dp[total_amount]"},{"question":"# Implementing a Custom Data Shuffling Algorithm Context You have been assigned the task of implementing a data shuffle operation to ensure randomness in a list of elements. This is especially useful in applications like gaming, data analysis, and load balancing where the order of elements needs to be randomized. The goal is to design an algorithm that performs this shuffling operation efficiently while maintaining equal probability for all possible permutations of the list. Problem Statement Implement a function `shuffle_list` which takes a list of elements and returns a new list with the elements shuffled uniformly at random. The algorithm should ensure that each possible permutation of the list is equally likely. Requirements 1. **Input and Output Formats**: - Input for `shuffle_list`: A list `data` containing `N` elements of any data type. - Output for `shuffle_list`: A new list with elements from the input list `data` shuffled in a random order. 2. **Constraints**: - `data` length: 1 ≤ len(data) ≤ 10^5. - `data` elements can be of any data type that can be compared using equality (e.g., integers, strings). 3. **Performance**: - The algorithm should perform the shuffling operation in O(N) time complexity. - Space complexity should be O(N), where N is the number of elements in the input list. Example ```python import random def shuffle_list(data: list) -> list: # Implement the Fisher-Yates shuffle algorithm shuffled_data = data[:] n = len(shuffled_data) for i in range(n-1, 0, -1): j = random.randint(0, i) shuffled_data[i], shuffled_data[j] = shuffled_data[j], shuffled_data[i] return shuffled_data # Example usage: original_list = [1, 2, 3, 4, 5] shuffled_list = shuffle_list(original_list) # Expected output: A permutation of the list [1, 2, 3, 4, 5], e.g., [3, 1, 4, 5, 2] # Each shuffle should produce a different random permutation. another_shuffled_list = shuffle_list(original_list) # Expected output: A different permutation of the list [1, 2, 3, 4, 5], e.g., [2, 4, 3, 1, 5] ``` Notes - Ensure that the function consistently returns new shuffled lists different from the original input list. - Utilize robust randomization techniques to avoid patterns or predictable output. - Test the function with various data types and edge cases such as empty lists, single-element lists, and lists with duplicate elements.","solution":"import random def shuffle_list(data: list) -> list: Shuffles the input list `data` using the Fisher-Yates shuffle algorithm. # Clone the list to avoid modifying the original list shuffled_data = data[:] n = len(shuffled_data) # Perform the Fisher-Yates shuffle for i in range(n-1, 0, -1): # Pick a random index from 0 to i j = random.randint(0, i) # Swap the elements at indices i and j shuffled_data[i], shuffled_data[j] = shuffled_data[j], shuffled_data[i] return shuffled_data"},{"question":"# Coding Assessment Question Context You are given a binary tree, where each node contains a positive integer value. Your task is to find the maximum sum of values from the root node to any leaf node. Remember that the sum must be obtained by summing the values of the nodes along the path from the root to a leaf. Task Write a function `max_root_to_leaf_sum(root) -> int` that calculates the maximum root-to-leaf path sum in the given binary tree. The binary tree node is represented by the following class: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Input Format * `root`: An instance of `TreeNode`, representing the root of the binary tree. Output Format * Return an integer representing the maximum sum of values from the root to any leaf node. Constraints * The binary tree contains at least one node. * The node values are positive integers. * The binary tree contains no more than 100,000 nodes. Example ```python root = TreeNode(10) root.left = TreeNode(5) root.right = TreeNode(20) root.left.left = TreeNode(4) root.left.right = TreeNode(8) root.right.right = TreeNode(25) print(max_root_to_leaf_sum(root)) # Output: 55 (10 -> 20 -> 25) ``` Performance Requirements * The solution should efficiently handle the provided constraints within linear time O(N), where N is the number of nodes in the binary tree. Edge Cases to Consider * Tree with only one node. * Tree where multiple paths have the same maximum sum. * Balanced and unbalanced trees.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_root_to_leaf_sum(root): if root is None: return 0 if root.left is None and root.right is None: return root.val left_sum = max_root_to_leaf_sum(root.left) right_sum = max_root_to_leaf_sum(root.right) return root.val + max(left_sum, right_sum)"},{"question":"# Coding Question: Calculate the Longest Consecutive Sequence of 1s in Binary Representation Context: Bob is analyzing binary data streams and needs to determine the longest sequence of consecutive 1s within the binary representation of non-negative integers. This metric helps in understanding data compression and error detection patterns. Your task is to implement a function to find this longest sequence for any given non-negative integer. Task: Write a function `longest_consecutive_ones(number: int) -> int` that returns the length of the longest consecutive sequence of 1s in the binary representation of a given non-negative integer. If the number is zero, the function should return 0. If the input is not an integer or is negative, the function should raise a `TypeError`. Input and Output Format: * **Input**: A single non-negative integer `number`. * Constraints: * `0 <= number <= 10^18` (Note: Ensure your function handles very large integers efficiently.) * **Output**: An integer representing the length of the longest consecutive sequence of 1s in the binary representation of the input number. If the number is zero, return 0. Example Cases: ```python >>> longest_consecutive_ones(29) 2 >>> longest_consecutive_ones(0) 0 >>> longest_consecutive_ones(15) 4 >>> longest_consecutive_ones(1) 1 >>> longest_consecutive_ones(-1) Traceback (most recent call last): ... TypeError: Input value must be a non-negative \'int\' type ``` Constraints: * You are not allowed to use any built-in functions like `bin()` for this task. * Handle edge cases, including zero and extremely large integers. Performance Requirements: * Your solution should run efficiently for input values up to (10^{18}). Good luck and ensure your code passes the provided example cases!","solution":"def longest_consecutive_ones(number): Return the length of the longest consecutive sequence of 1s in the binary representation of the given non-negative integer. if not isinstance(number, int) or number < 0: raise TypeError(\\"Input value must be a non-negative \'int\' type\\") max_ones = 0 current_ones = 0 while number > 0: if number & 1: current_ones += 1 max_ones = max(max_ones, current_ones) else: current_ones = 0 number >>= 1 return max_ones"},{"question":"Scenario You are responsible for designing a system that verifies data integrity in a messaging application. Part of this task involves checking if messages are being truncated inappropriately. You need to determine the length of the longest common prefix for pairs of given messages to ensure consistency. # Question Write a function `longest_common_prefix` that accepts a list of message tuples and performs the following tasks: 1. For each tuple, determine the longest common prefix of the two messages. 2. Return a list of integers representing the lengths of these longest common prefixes. # Input * A list of tuples, where each tuple contains two strings representing messages (e.g., `[(\\"hello\\", \\"helium\\"), (\\"test\\", \\"testing\\")]`). # Output * A list of integers indicating the length of the longest common prefix for each tuple of messages. # Constraints 1. The list will contain up to (10^5) tuples. 2. Each string will have a length of up to (10^6) characters. 3. Strings will have only lowercase English letters. 4. String tuples will be non-empty. # Example ```python longest_common_prefix([(\\"hello\\", \\"helium\\"), (\\"test\\", \\"testing\\"), (\\"code\\", \\"coder\\"), (\\"abc\\", \\"xyz\\")]) # Output: [3, 4, 4, 0] longest_common_prefix([(\\"match\\", \\"matching\\"), (\\"prefix\\", \\"prefixes\\"), (\\"example\\", \\"exam\\")]) # Output: [5, 6, 4] ``` # Notes * The function should efficiently handle the potential large input sizes. * Consider edge cases such as one message being a prefix of the other entirely. # Function Signature ```python def longest_common_prefix(message_pairs: list) -> list: pass ```","solution":"def longest_common_prefix(message_pairs): Returns a list of lengths of the longest common prefixes for the given list of message tuples. :param message_pairs: List of tuples, where each tuple contains two strings representing messages. :return: List of integers indicating the length of the longest common prefix for each tuple of messages. def common_prefix_length(s1, s2): # Find the length of the shortest string min_length = min(len(s1), len(s2)) # Compare characters up to the min_length for i in range(min_length): if s1[i] != s2[i]: return i return min_length # List to store the results result = [] for msg1, msg2 in message_pairs: result.append(common_prefix_length(msg1, msg2)) return result"},{"question":"**Partition Equal Subset Sum** You are given an array of non-negative integers. Your task is to determine if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal. Implement the function `can_partition(nums: List[int]) -> bool` that returns `True` if the array can be partitioned into two subsets with equal sum, and `False` otherwise. # Constraints: - 1 ≤ len(nums) ≤ 200 - 1 ≤ nums[i] ≤ 100 # Input: A list of non-negative integers `nums` representing the array. # Output: A boolean value indicating whether the array can be partitioned into two subsets with equal sum. # Example: ```python def can_partition(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets with equal sum. Args: nums (List[int]): The array of non-negative integers. Returns: bool: True if the array can be partitioned into two subsets with equal sum, False otherwise. # Your code here ``` # Test Cases: ```python assert can_partition([1, 5, 11, 5]) == True # The array can be partitioned into [1, 5, 5] and [11] both with sum 11. assert can_partition([1, 2, 3, 5]) == False # The array cannot be partitioned into two subsets with equal sum. assert can_partition([1, 2, 1, 2]) == True # The array can be partitioned into [1, 2] and [1, 2] both with sum 3. assert can_partition([1, 2, 3]) == True # The array can be partitioned into [1, 2] and [3] both with sum 3. assert can_partition([2, 2, 3, 5]) == False # The array cannot be partitioned into two subsets with equal sum. ``` # Explanation: - For `nums = [1, 5, 11, 5]`, the array can be partitioned into subsets with equal sums: `[1, 5, 5]` and `[11]`. - For `nums = [1, 2, 3, 5]`, no such partition exists. - For `nums = [1, 2, 1, 2]`, the array can be partitioned into subsets with equal sums: `[1, 2]` and `[1, 2]`. Analyze your solution for edge cases and performance.","solution":"from typing import List def can_partition(nums: List[int]) -> bool: Determines if the array can be partitioned into two subsets with equal sum. Args: nums (List[int]): The array of non-negative integers. Returns: bool: True if the array can be partitioned into two subsets with equal sum, False otherwise. total_sum = sum(nums) # If total_sum is odd, it\'s not possible to partition the array into two equal sum subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a dp array where dp[i] will be True if a subset with sum i can be made dp = [False] * (target + 1) dp[0] = True # Base case: a subset with sum 0 is always possible for num in nums: # Traverse the dp array from right to left to avoid using the same number twice for i in range(target, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target]"},{"question":"# Coding Challenge: List Flattening You are required to create a function that takes a nested list of arbitrary depth and flattens it into a single list of values. Your function should handle various types of input lists and ensure that the order of the elements is preserved during the flattening process. Function Signature ```python def flatten_list(nested_list: list) -> list: # Your implementation here ``` Input 1. `nested_list` (list): A list that may contain other lists, which in turn may also contain lists, and so on. Output - Returns a flat list containing all the values from the input list in depth-first order. Constraints - The elements of `nested_list` can be integers, floats, strings, or other lists. - Lists can be nested arbitrarily deep. - Input list is non-empty. Examples 1. `flatten_list([1, 2, [3, 4], [5, [6, 7]]])` should return `[1, 2, 3, 4, 5, 6, 7]`. 2. `flatten_list([[], [1, [2, [3, [4]]]], 5])` should return `[1, 2, 3, 4, 5]`. 3. `flatten_list([\'a\', [\'b\', [\'c\', [\'d\']]], \'e\'])` should return `[\'a\', \'b\', \'c\', \'d\', \'e\']`. 4. `flatten_list([[[\'nested\'], \'lists\'], \'are\', [[[[\'deep\']]]]])` should return `[\'nested\', \'lists\', \'are\', \'deep\']`. Error Handling 1. If `nested_list` is not a list, raise a `ValueError` with a message indicating the expected type. Example Usage ```python try: print(flatten_list([1, 2, [3, 4], [5, [6, 7]]])) # Should output: [1, 2, 3, 4, 5, 6, 7] print(flatten_list([[], [1, [2, [3, [4]]]], 5])) # Should output: [1, 2, 3, 4, 5] print(flatten_list([\'a\', [\'b\', [\'c\', [\'d\']]], \'e\'])) # Should output: [\'a\', \'b\', \'c\', \'d\', \'e\'] print(flatten_list([[[\'nested\'], \'lists\'], \'are\', [[[[\'deep\']]]]])) # Should output: [\'nested\', \'lists\', \'are\', \'deep\'] except ValueError as e: print(str(e)) ``` Implement the `flatten_list` function according to the given requirements.","solution":"def flatten_list(nested_list): if not isinstance(nested_list, list): raise ValueError(\\"Input should be a list\\") flat_list = [] def _flatten(sub_list): for item in sub_list: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_list) return flat_list"},{"question":"# Problem Statement Write a function that simulates an order management system for a restaurant. The system will manage orders by allowing new orders to be added, orders to be marked as completed, and the next pending order to be retrieved. Implement this system using a class structure in Python. # Class Definition ```python class OrderManager: def __init__(self): Initializes an empty order management system. def add_order(self, order_id: int) -> None: Adds a new order to the system. :param order_id: Integer representing the unique ID of the order. def complete_order(self) -> int: Marks the next pending order as completed and removes it from the system. :return: The ID of the completed order. If there are no pending orders, return -1. def next_order(self) -> int: Retrieves the ID of the next pending order without marking it as completed. :return: The ID of the next pending order. If there are no pending orders, return -1. ``` # Input * The `OrderManager` class will manage orders with unique integer IDs. * Orders are managed in the order they are added (FIFO). # Output * The `add_order` method will not return anything. * The `complete_order` method will return the ID of the completed order, or -1 if no orders are pending. * The `next_order` method will return the ID of the next pending order, or -1 if no orders are pending. # Constraints * There can be at most 10000 orders in the system at any given time. * Order IDs are guaranteed to be unique integers. # Example ```python order_manager = OrderManager() order_manager.add_order(101) order_manager.add_order(102) assert order_manager.next_order() == 101 # Next pending order is 101 assert order_manager.complete_order() == 101 # Complete and remove order 101 assert order_manager.next_order() == 102 # Next pending order is now 102 assert order_manager.complete_order() == 102 # Complete and remove order 102 assert order_manager.next_order() == -1 # No pending orders assert order_manager.complete_order() == -1 # No pending orders to complete ``` # Note - Use a queue-like data structure to manage the orders. - Ensure that the system handles adding, completing, and retrieving orders efficiently, even at the upper limit of 10000 orders. - Think about edge cases such as completing and retrieving orders from an empty system.","solution":"from collections import deque class OrderManager: def __init__(self): Initializes an empty order management system. self.orders = deque() def add_order(self, order_id: int) -> None: Adds a new order to the system. :param order_id: Integer representing the unique ID of the order. self.orders.append(order_id) def complete_order(self) -> int: Marks the next pending order as completed and removes it from the system. :return: The ID of the completed order. If there are no pending orders, return -1. if not self.orders: return -1 return self.orders.popleft() def next_order(self) -> int: Retrieves the ID of the next pending order without marking it as completed. :return: The ID of the next pending order. If there are no pending orders, return -1. if not self.orders: return -1 return self.orders[0]"},{"question":"# Scenario You are building a system that manages access levels in a secure environment. Each user has a unique identifier and a set of access levels represented as binary values. Your task is to create a function that determines the user\'s highest access level. # Objective Implement the function `max_access_level` that calculates the highest access level a user has. # Function Signature ```python def max_access_level(user_access: int) -> int: Determine the highest access level for a user. :param user_access: A non-negative integer representing access levels. :return: The highest access level (0-indexed, least significant bit as level 0). ``` # Input 1. `user_access`: A non-negative integer representing the access levels of a user, where each bit position (from least significant to most significant) indicates access to a corresponding level (0 indicates no access, 1 indicates access). # Output - An integer representing the highest access level the user has, based on the binary representation of `user_access`. # Constraints - The input integer user_access must be non-negative. # Examples ```python assert max_access_level(5) == 2 # binary: 101 -> highest level is 2 assert max_access_level(0) == -1 # binary: 0 -> no access, return -1 assert max_access_level(1) == 0 # binary: 1 -> highest level is 0 assert max_access_level(8) == 3 # binary: 1000 -> highest level is 3 assert max_access_level(15) == 3 # binary: 1111 -> highest level is 3 assert max_access_level(16) == 4 # binary: 10000 -> highest level is 4 ``` # Additional Notes - If the user_access integer is 0, it means the user has no access and the function should return -1. - The function should not raise any exceptions for non-negative integers and should handle them correctly as per the binary representation. This function should efficiently determine the highest set bit position in the binary representation of the given integer.","solution":"def max_access_level(user_access: int) -> int: Determine the highest access level for a user. :param user_access: A non-negative integer representing access levels. :return: The highest access level (0-indexed, least significant bit as level 0). if user_access == 0: return -1 level = 0 while user_access > 1: user_access >>= 1 level += 1 return level"},{"question":"# Airline Route Planner **Context**: You work as a software engineer for an airline company. Your task is to help create an automated scheduling program that can compute the shortest path between two cities in terms of flight time. Each flight has a specific duration, and layover times between connecting flights can be ignored. **Task**: Implement a function `shortest_flight_path` which, given a list of direct flights and their durations, finds the shortest path in terms of total flight time between two specified cities. **Function Signature**: ```python def shortest_flight_path(flights: list[tuple[str, str, int]], start: str, end: str) -> int: pass ``` **Input**: - `flights` (list of tuples): Each tuple contains three elements: `source` (str), `destination` (str), and `time` (int) which indicates the flight duration from the source to the destination. - `start` (str): The starting city. - `end` (str): The destination city. **Output**: - An integer representing the shortest flight time from the `start` city to the `end` city. If no such path exists, return `-1`. **Constraints**: - The number of flights can range from `1` to `10,000`. - Flight times are given in minutes and will be positive integers. - There may be multiple flights between two cities but with different durations. - Cities are denoted by uppercase alphabet characters (A to Z). **Example**: ```python flights = [ (\\"A\\", \\"B\\", 100), (\\"B\\", \\"C\\", 200), (\\"A\\", \\"C\\", 300), (\\"C\\", \\"D\\", 400), (\\"B\\", \\"D\\", 150) ] assert shortest_flight_path(flights, \\"A\\", \\"D\\") == 250 assert shortest_flight_path(flights, \\"A\\", \\"E\\") == -1 ``` **Notes**: - Use appropriate graph traversal or shortest path algorithms such as Dijkstra\'s or Bellman-Ford to determine the shortest path. - Make sure to handle cases where no valid path exists between the start and end cities by returning `-1`. This question evaluates your comprehension of graph theory, especially in implementing shortest path algorithms and applying them to real-world scenarios such as airline route planning.","solution":"import heapq def shortest_flight_path(flights: list, start: str, end: str) -> int: Finds the shortest path in terms of total flight time between two specified cities. # Step 1: Build the graph graph = {} for source, destination, time in flights: if source not in graph: graph[source] = [] graph[source].append((time, destination)) # Step 2: Implement Dijkstra\'s Algorithm # Priority queue to keep track of the minimum cost to reach each city pq = [(0, start)] # (current accumulated time, current city) # Dictionary to keep track of the shortest time to reach each city shortest_times = {start: 0} while pq: current_time, current_city = heapq.heappop(pq) # If we\'ve reached the destination city, return the current time if current_city == end: return current_time # If there is a shorter way to get to current city continue if current_time > shortest_times.get(current_city, float(\'inf\')): continue # Explore the neighbors for neighbor_time, neighbor in graph.get(current_city, []): time = current_time + neighbor_time if time < shortest_times.get(neighbor, float(\'inf\')): shortest_times[neighbor] = time heapq.heappush(pq, (time, neighbor)) # If we exhaust the priority queue without finding the destination city return -1"},{"question":"Fibonacci Sequence Generator Problem Statement You are required to implement a function `fibonacci(n)` that returns the `n-th` number in the Fibonacci sequence. The Fibonacci sequence is defined as follows: - `F(0) = 0` - `F(1) = 1` - `F(n) = F(n-1) + F(n-2)` for `n ≥ 2` Input - A single integer `n` (0 <= n <= 50) representing the position in the Fibonacci sequence. Output - Return the `n-th` number in the Fibonacci sequence. Constraints - The solution should have a time complexity of O(n) and space complexity of O(1). Example ```python fibonacci(0) # should return 0 fibonacci(5) # should return 5 fibonacci(10) # should return 55 fibonacci(20) # should return 6765 ``` Requirements 1. Implement the function `fibonacci(n)` with the expected input and output formats. 2. The function should be optimized for performance and handle base cases correctly. 3. Write additional unit tests to validate your implementation against different scenarios including edge cases. Implementation Tips - Consider using an iterative approach to minimize space usage. - Ensure your function handles the smallest inputs (especially `n = 0` and `n = 1`) correctly. - Pay attention to the constraint on the maximum value of `n` and ensure your solution can handle it efficiently.","solution":"def fibonacci(n): Returns the n-th number in the Fibonacci sequence. :param n: The position in the Fibonacci sequence (0 <= n <= 50) :type n: int :return: The n-th Fibonacci number :rtype: int if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Coding Assessment Question You are developing a module for processing and analyzing time series data collected from various IoT (Internet of Things) sensors. As part of the module, you are required to implement a function that can normalize the data points so that they fall within a specified range. **Task**: Implement a function `normalize_time_series` that takes in a list of numerical data points and scales them to fall within the range specified by `lower_bound` and `upper_bound`. Function Signature ```python def normalize_time_series(data: List[float], lower_bound: float, upper_bound: float) -> List[float]: pass ``` Input * `data` (List[float]): A list of numerical data points from the time series. * `lower_bound` (float): The lower bound of the desired range after normalization. * `upper_bound` (float): The upper bound of the desired range after normalization. Output * Returns a list of normalized data points within the specified range `[lower_bound, upper_bound]`. Constraints * The list `data` contains at least one element. * The values of `lower_bound` and `upper_bound` can be any float where `lower_bound < upper_bound`. * The values in `data` can be arbitrary floats, including negative and very large or small numbers. # Example Example Input ```python data = [10.0, 20.0, 30.0, 40.0, 50.0] lower_bound = 0.0 upper_bound = 1.0 ``` Example Output ```python [0.0, 0.25, 0.5, 0.75, 1.0] ``` **Explanation**: The given data points `[10.0, 20.0, 30.0, 40.0, 50.0]` are scaled such that the minimum value `10.0` maps to `0.0` and the maximum value `50.0` maps to `1.0`. Your task is to implement the function considering edge cases and ensuring the data points are correctly normalized within the specified range.","solution":"from typing import List def normalize_time_series(data: List[float], lower_bound: float, upper_bound: float) -> List[float]: min_val = min(data) max_val = max(data) range_val = max_val - min_val norm_range = upper_bound - lower_bound if range_val == 0: # If all values in data are the same, return a list with the mid-point return [lower_bound + norm_range / 2] * len(data) normalized_data = [ lower_bound + ((x - min_val) / range_val) * norm_range for x in data ] return normalized_data"},{"question":"# Building a Binary Search Tree from a Sorted List Your task is to construct a height-balanced binary search tree (BST) from a given sorted list and implement a function to perform in-order traversal on the tree. Scenario You are provided with a sorted list of integers `data` containing `n` unique elements. The task is to: 1. Create a height-balanced binary search tree (BST) from this sorted list. 2. Implement an in-order traversal function to retrieve elements from the BST in ascending order. You will need to: 1. Implement the `TreeNode` class to define the nodes of the BST. 2. Implement a function that builds a height-balanced BST from the sorted list. 3. Implement a function that performs in-order traversal on the BST and returns the elements in a list. Requirements 1. Implement a class `TreeNode` with properties `val`, `left`, and `right`. 2. Implement a function `sorted_list_to_bst(data: List[int]) -> TreeNode` that converts the sorted list to a height-balanced BST. 3. Implement a function `in_order_traversal(root: TreeNode) -> List[int]` that performs in-order traversal on the BST. Input * A sorted list of unique integers `data` with length `n` where ( n geq 1 ). Output * A list of integers representing the in-order traversal of the BST. Example Given the following sorted list: ```python data = [1, 2, 3, 4, 5, 6, 7] ``` Creating a height-balanced BST and performing in-order traversal should return: ```python [1, 2, 3, 4, 5, 6, 7] ``` Sample Function Definitions ```python class TreeNode: def __init__(self, val: int): self.val = val self.left = None self.right = None def sorted_list_to_bst(data: List[int]) -> TreeNode: if not data: return None mid = len(data) // 2 root = TreeNode(data[mid]) root.left = sorted_list_to_bst(data[:mid]) root.right = sorted_list_to_bst(data[mid+1:]) return root def in_order_traversal(root: TreeNode) -> List[int]: result = [] def _in_order(node: TreeNode): if node: _in_order(node.left) result.append(node.val) _in_order(node.right) _in_order(root) return result ``` Testing the implementation: ```python data = [1, 2, 3, 4, 5, 6, 7] root = sorted_list_to_bst(data) print(in_order_traversal(root)) # Output: [1, 2, 3, 4, 5, 6, 7] ```","solution":"from typing import List class TreeNode: def __init__(self, val: int): self.val = val self.left = None self.right = None def sorted_list_to_bst(data: List[int]) -> TreeNode: if not data: return None mid = len(data) // 2 root = TreeNode(data[mid]) root.left = sorted_list_to_bst(data[:mid]) root.right = sorted_list_to_bst(data[mid+1:]) return root def in_order_traversal(root: TreeNode) -> List[int]: result = [] def _in_order(node: TreeNode): if node: _in_order(node.left) result.append(node.val) _in_order(node.right) _in_order(root) return result"},{"question":"**Task: Implement a Word Frequency Counter** **Objective**: Write a Python function `word_count` that takes a string and returns a dictionary with the frequency of each word in the given string. # Function Signature ```python def word_count(sentence: str) -> dict: ``` # Input * A single string `sentence` containing multiple words. The string may contain punctuation, and words are separated by spaces. The function should be case-insensitive. # Output * A dictionary where the keys are words and the values are their respective frequencies in the input string. # Constraints * Words are defined as sequences of alphanumeric characters. * The function should convert all words to lowercase for case-insensitivity. * Punctuation marks should be ignored while counting the words. # Examples ```python >>> word_count(\'Hello world! Hello.\') {\'hello\': 2, \'world\': 1} >>> word_count(\'A man, a plan, a canal, Panama!\') {\'a\': 3, \'man\': 1, \'plan\': 1, \'canal\': 1, \'panama\': 1} >>> word_count(\'To be or not to be, that is the question.\') {\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1, \'that\': 1, \'is\': 1, \'the\': 1, \'question\': 1} >>> word_count(\'\') {} ``` # Instructions - You are required to implement the `word_count` function without using any external libraries for parsing. - Ensure the function handles special characters and punctuation properly by ignoring them for the word frequency count. - Optimize for readability and maintainability of the code.","solution":"import re from collections import defaultdict def word_count(sentence: str) -> dict: Takes a string and returns a dictionary with the frequency of each word in the given string. Parameters: - sentence: A string that may contain multiple words and punctuation. Returns: - A dictionary with words (lowercased) as keys and their frequency as values. # Convert to lowercase sentence = sentence.lower() # Remove punctuation using regex and split the string into words words = re.findall(r\'bw+b\', sentence) # Use defaultdict to count frequencies word_freq = defaultdict(int) for word in words: word_freq[word] += 1 return dict(word_freq)"},{"question":"# Coding Assessment Question Context You are to optimize a data processing pipeline that involves filtering and transforming a sequence of integers. The task is to filter out specific values and then apply a transformation function to the remaining integers. Requirements Create a function `process_integers` that performs the following steps: 1. Filter out all integers that are multiples of a given factor. 2. Apply a transformation function to the remaining integers. 3. Return the transformed and filtered list as well as the count of elements that were removed. Constraints * The input list (`numbers`) will have at most 10^6 elements. * The `factor` will be an integer greater than 1. * The transformation function `trans_fn` will be a callable that takes an integer and returns an integer. Input & Output # Input * `numbers`: List[int] — a list of integers. * `factor`: int — the factor used to filter out multiples. * `trans_fn`: Callable[[int], int] — a transformation function that is applied to filtered integers. # Output * Returns a tuple (List[int], int) — The first element is the transformed list, and the second element is the count of filtered-out integers. Example ```python >>> def square(x): >>> return x * x >>> result, removed_count = process_integers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, square) >>> print(result, removed_count) [1, 4, 16, 25, 49, 64, 100], 3 ``` Function Signature ```python from typing import List, Callable, Tuple def process_integers( numbers: List[int], factor: int, trans_fn: Callable[[int], int] ) -> Tuple[List[int], int]: pass ```","solution":"from typing import List, Callable, Tuple def process_integers( numbers: List[int], factor: int, trans_fn: Callable[[int], int] ) -> Tuple[List[int], int]: Filters integers from the list that are multiples of the given factor, applies a transformation function to the remaining integers, and returns the transformed list along with the count of removed elements. filtered_numbers = [num for num in numbers if num % factor != 0] transformed_numbers = [trans_fn(num) for num in filtered_numbers] removed_count = len(numbers) - len(filtered_numbers) return transformed_numbers, removed_count"},{"question":"# Array Equilibrium Index Finder Context In array manipulation, the equilibrium index of an array is an index such that the sum of elements at lower indices is equal to the sum of elements at higher indices. Finding such an index can be useful for various algorithmic applications. Task Write a function `find_equilibrium_index(arr: list[int]) -> int` that finds and returns the equilibrium index of the given array, if it exists. If no such index exists, the function should return `-1`. The function should conform to the following requirements: 1. The function should return the smallest equilibrium index if multiple indices satisfy the condition. 2. If the array is empty, raise a `ValueError` with the message \\"Array cannot be empty\\". 3. The function should handle both positive and negative integers within the array. Input - `arr`: A list of integers. Output - Return the smallest equilibrium index if it exists, otherwise return `-1`. Constraints - The array can contain both positive and negative integers. - The array will have a maximum length of `10^6`. Example ```python find_equilibrium_index([1, 3, 5, 2, 2]) # Output: 2 find_equilibrium_index([1, 2, 3]) # Output: -1 find_equilibrium_index([-7, 1, 5, 2, -4, 3, 0]) # Output: 3 ``` Hints - Consider calculating the total sum of the array first and then iterating through the array while maintaining the sum of elements on the left. - Ensure edge cases such as an empty array, arrays with all similar elements, or non-existent equilibrium indices are handled appropriately.","solution":"def find_equilibrium_index(arr): Finds and returns the first equilibrium index of the given array, if it exists. If no such index exists, the function returns -1. Raises a ValueError for empty arrays. if not arr: raise ValueError(\\"Array cannot be empty\\") total_sum = sum(arr) left_sum = 0 for i, num in enumerate(arr): total_sum -= num if left_sum == total_sum: return i left_sum += num return -1"},{"question":"# Task: List Manipulation and Aggregation You are given an implementation of a function that takes a nested list of integers. Your task is to implement an algorithm that flattens this nested list and then returns the sum of the flattened list. # Requirements 1. **Function**: `flatten_and_sum(nested_list: List[Union[int, List]]) -> int` 2. **Inputs**: - `nested_list` - A list which can contain integers and/or other lists of integers. These sublists can be nested to any depth. 3. **Output**: - An integer which is the sum of all integers in the flattened list. 4. **Constraints**: - The elements in the `nested_list` are either integers or lists. - The depth of nesting is not limited. # Examples ```python assert flatten_and_sum([1, 2, [3, 4, [5]], [6]]) == 21 assert flatten_and_sum([[1, [2]], [3, 4], [5, [6]], 7]) == 28 assert flatten_and_sum([1, [2, [3, [4, [5]]]]]) == 15 assert flatten_and_sum([]) == 0 ``` # Notes - You should handle edge cases such as when the list is empty or when certain sublists are empty. - You can assume that the input is always valid (contains either integers or lists). - Consider using recursion to solve this problem efficiently.","solution":"from typing import List, Union def flatten_and_sum(nested_list: List[Union[int, List]]) -> int: Flattens the nested list and returns the sum of the flattened list. :param nested_list: List which can contain integers and/or other lists of integers. :return: The sum of all integers in the flattened list. def flatten(nested): for element in nested: if isinstance(element, list): yield from flatten(element) else: yield element return sum(flatten(nested_list))"},{"question":"# Problem Statement You are given a list of integers, and you need to find the length of the longest subarray that contains only unique elements. Implement the function `longest_unique_subarray` that takes a list of integers as input and returns the length of the longest subarray with all unique elements. # Function Signature ```python def longest_unique_subarray(nums: list[int]) -> int: ``` # Input - A list of integers `nums` where (0 leq len(nums) leq 10^5) and (-10^6 leq nums[i] leq 10^6). # Output - An integer representing the length of the longest subarray that contains only unique elements. # Examples ```python assert longest_unique_subarray([1, 2, 3, 1, 2, 3]) == 3 assert longest_unique_subarray([5, 5, 5, 5]) == 1 assert longest_unique_subarray([2, 4, 6, 8, 10, 4, 6]) == 5 assert longest_unique_subarray([]) == 0 ``` # Constraints - Your implementation should have an average time complexity not exceeding (O(n)). - The function should handle both large positive and large negative integers within the specified range. # Notes - Ensure that the function efficiently tracks elements to check for uniqueness. - If the input list is empty, the function should return 0. # Edge Cases - The array can contain both positive and negative numbers. - The array can contain duplicate numbers. - An empty array should return 0. - Arrays with all elements the same should return 1 as the length of the longest unique subarray.","solution":"def longest_unique_subarray(nums): Finds the length of the longest subarray with all unique elements. Parameters: nums (list[int]): A list of integers. Returns: int: The length of the longest subarray with all unique elements. # Dictionary to store the last index of each element last_seen = {} max_length = 0 start_index = 0 for i, num in enumerate(nums): if num in last_seen: start_index = max(start_index, last_seen[num] + 1) last_seen[num] = i max_length = max(max_length, i - start_index + 1) return max_length"},{"question":"# Sorting an Array with a Custom Comparator You are tasked with developing software that performs various sorting operations. One of the key requirements is to sort arrays based on a custom set of rules dictated by a comparator function. Your task is to implement a function that sorts an array using a provided custom comparator. **Task**: Write a function: - `custom_sort(arr: List[int], comparator: Callable[[int, int], int]) -> List[int]` The function should: 1. Sort the array `arr` based on the comparison logic provided by `comparator`. 2. Return the sorted array. The `comparator` is a function that determines the order of two elements `a` and `b` as follows: - Returns a negative number if `a` should come before `b` - Returns zero if `a` and `b` are considered equal - Returns a positive number if `a` should come after `b` # Function Description and Example - **Input**: - `arr` (List[int]): An array of integers to be sorted. - `comparator` (Callable[[int, int], int]): A comparison function. - **Output**: - Returns the sorted array (List[int]). - **Example**: ```python from functools import cmp_to_key from typing import List, Callable def custom_sort(arr: List[int], comparator: Callable[[int, int], int]) -> List[int]: return sorted(arr, key=cmp_to_key(comparator)) # Example comparator functions: def ascending_comparator(a: int, b: int) -> int: return a - b # Ascending order def descending_comparator(a: int, b: int) -> int: return b - a # Descending order # Test cases: # Ascending order test print(custom_sort([4, 2, 8, 3, 1], ascending_comparator)) # Output: [1, 2, 3, 4, 8] # Descending order test print(custom_sort([4, 2, 8, 3, 1], descending_comparator)) # Output: [8, 4, 3, 2, 1] # Custom order test (e.g., even numbers first, then odd numbers) def even_first_comparator(a: int, b: int) -> int: if a % 2 == 0 and b % 2 != 0: return -1 elif a % 2 != 0 and b % 2 == 0: return 1 else: return a - b print(custom_sort([4, 2, 8, 3, 1], even_first_comparator)) # Output: [2, 4, 8, 1, 3] ``` Make sure to generalize the function for any valid comparator and handle edge cases where the input array may be empty.","solution":"from functools import cmp_to_key from typing import List, Callable def custom_sort(arr: List[int], comparator: Callable[[int, int], int]) -> List[int]: return sorted(arr, key=cmp_to_key(comparator)) # Example comparator functions: def ascending_comparator(a: int, b: int) -> int: return a - b # Ascending order def descending_comparator(a: int, b: int) -> int: return b - a # Descending order def even_first_comparator(a: int, b: int) -> int: if a % 2 == 0 and b % 2 != 0: return -1 elif a % 2 != 0 and b % 2 == 0: return 1 else: return a - b"},{"question":"# Coding Assessment Question Background & Context You are developing a feature extraction tool that processes large text documents. One of the functionalities of the tool is to extract all unique words from the document, count their occurrences, and store the results in a specific format for further analysis. Task Write a function `extract_words` that takes the path of a text document, extracts all unique words, counts their occurrences, and writes the results to a specified output file. The output file should contain each unique word along with its frequency, sorted by frequency in descending order. In case of ties, sort by the word in alphabetical order. Function Signature ```python def extract_words(document_path: str, output_path: str) -> None: Extracts unique words from a text document, counts their occurrences, and writes the results to an output file in the specified format. :param document_path: str, path of the text document to be processed :param output_path: str, path of the file where the results will be written ``` Input and Output Format * **Input**: - `document_path` (str): Path to the text document. - `output_path` (str): Path where the results should be written. * **Output**: - Writes the unique words and their frequencies to the specified output file. Constraints * A word is defined as a sequence of alphanumeric characters. * Ignore case differences (e.g., \\"Word\\" and \\"word\\" are the same). * Punctuation marks should be removed. * Assume the document fits in memory. Example Suppose the text document at `document_path` contains the following text: ``` Hello world! This is a simple text document. This document is intended for testing. Hello, world! Simple testing. ``` Your `extract_words` function should write the following content to `output_path`: ``` document: 2 hello: 2 is: 2 simple: 2 testing: 2 this: 2 world: 2 a: 1 for: 1 intended: 1 text: 1 ``` Notes * Use regular expressions for efficient word extraction and punctuation removal. * Ensure the output format is strictly followed, with one word-frequency pair per line, separated by a colon and a space.","solution":"import re from collections import Counter def extract_words(document_path: str, output_path: str) -> None: Extracts unique words from a text document, counts their occurrences, and writes the results to an output file in the specified format. :param document_path: str, path of the text document to be processed :param output_path: str, path of the file where the results will be written # Read the entire document with open(document_path, \'r\') as file: text = file.read() # Normalize the text to lowercase and remove punctuations normalized_text = re.sub(r\'[^a-zA-Z0-9s]\', \'\', text.lower()) # Split the text into words words = normalized_text.split() # Count the frequency of each word word_counts = Counter(words) # Sort words by frequency (descending) and alphabetically sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Write the results to the output file with open(output_path, \'w\') as file: for word, count in sorted_words: file.write(f\\"{word}: {count}n\\")"},{"question":"# Temperature Conversion and Classification **Objective**: Implement a function to convert a temperature from Fahrenheit to Celsius and classify the temperature into different categories. **Function Signature**: ```python def convert_and_classify_temperature(temp_f: float) -> Tuple[float, str]: ``` # Instructions: Write a function `convert_and_classify_temperature` that: 1. Takes one floating-point number as input: * `temp_f` (temperature in Fahrenheit). 2. Returns a tuple containing: * The temperature converted to Celsius (rounded to 2 decimal places). * A string representing the temperature classification based on the Celsius value. The temperature should be converted using the formula: [ C = frac{(F - 32) times 5}{9} ] Where `C` is the temperature in Celsius, and `F` is the temperature in Fahrenheit. # Temperature Classification: * \\"Freezing\\" for temperatures ( le 0 ) Celsius. * \\"Cold\\" for temperatures ( > 0 ) and ( le 15 ) Celsius. * \\"Warm\\" for temperatures ( > 15 ) and ( le 30 ) Celsius. * \\"Hot\\" for temperatures ( > 30 ) Celsius. # Input constraints: * ( -300 leq text{temp_f} leq 300 ) # Output: The function should return a tuple of: * A floating-point number (the temperature converted to Celsius, rounded to two decimal places). * A string (the temperature classification). # Examples: ```python >>> convert_and_classify_temperature(32) (0.0, \\"Freezing\\") >>> convert_and_classify_temperature(68) (20.0, \\"Warm\\") >>> convert_and_classify_temperature(-40) (-40.0, \\"Freezing\\") >>> convert_and_classify_temperature(100) (37.78, \\"Hot\\") >>> convert_and_classify_temperature(50) (10.0, \\"Cold\\") ``` # Performance requirements: The function should execute in constant time O(1) and use constant space O(1). # Additional Notes: * Ensure to handle invalid input gracefully by raising appropriate exceptions. * Consider edge cases such as extreme temperatures within the given range. * You can assume the function will not receive non-numeric input values.","solution":"from typing import Tuple def convert_and_classify_temperature(temp_f: float) -> Tuple[float, str]: Converts temperature from Fahrenheit to Celsius and classifies it into categories. Parameters: temp_f (float): Temperature in Fahrenheit. Returns: Tuple[float, str]: A tuple containing the temperature in Celsius (rounded to two decimal places) and its classification. # Convert Fahrenheit to Celsius temp_c = (temp_f - 32) * 5 / 9 # Round the Celsius temperature to two decimal places temp_c = round(temp_c, 2) # Classify the Celsius temperature if temp_c <= 0: classification = \\"Freezing\\" elif temp_c <= 15: classification = \\"Cold\\" elif temp_c <= 30: classification = \\"Warm\\" else: classification = \\"Hot\\" return temp_c, classification"},{"question":"# Problem Statement You are required to write a Python function that checks if a given string consists of all unique characters and another function that checks if two strings are permutations of each other. # Function Implementation 1. **Function 1**: `is_unique_chars(input_str: str) -> bool` - **Input**: A string of characters. - **Output**: A boolean value, `True` if all characters in the string are unique, `False` otherwise. - **Constraints**: The input string can be of any length including zero. 2. **Function 2**: `are_permutations(str1: str, str2: str) -> bool` - **Input**: Two strings. - **Output**: A boolean value, `True` if one string is a permutation of the other, `False` otherwise. - **Constraints**: The input strings can be of any length including zero. Both strings need to be compared in a case-sensitive manner. # Requirements * Your functions should handle edge cases efficiently. * The implementation of `is_unique_chars` should aim for a time complexity of O(n) and a space complexity of O(n) where n is the length of the input string. * The implementation of `are_permutations` should also handle the case of empty strings correctly. # Example ```python def is_unique_chars(input_str: str) -> bool: Check if the string has all unique characters. :param input_str: string to be checked :return: boolean indicating if all characters are unique >>> is_unique_chars(\\"abcdef\\") True >>> is_unique_chars(\\"aabcdef\\") False >>> is_unique_chars(\\"\\") True pass def are_permutations(str1: str, str2: str) -> bool: Check if one string is a permutation of the other. :param str1: first string for comparison :param str2: second string for comparison :return: boolean indicating if the strings are permutations of each other >>> are_permutations(\\"abc\\", \\"cba\\") True >>> are_permutations(\\"abc\\", \\"cbad\\") False >>> are_permutations(\\"\\", \\"\\") True pass ``` # Task Implement the `is_unique_chars` and `are_permutations` functions in Python to meet the above specifications. Ensure to handle edge cases and write efficient, clean code.","solution":"def is_unique_chars(input_str: str) -> bool: Check if the string has all unique characters. :param input_str: string to be checked :return: boolean indicating if all characters are unique seen_chars = set() for char in input_str: if char in seen_chars: return False seen_chars.add(char) return True def are_permutations(str1: str, str2: str) -> bool: Check if one string is a permutation of the other. :param str1: first string for comparison :param str2: second string for comparison :return: boolean indicating if the strings are permutations of each other if len(str1) != len(str2): return False return sorted(str1) == sorted(str2)"},{"question":"# Question You need to implement a function that determines if a directed graph contains a cycle. This is a common problem in graph theory with applications in dependency resolution, such as package managers. # Specifications Implement the function `has_cycle(graph: Dict[int, List[int]]) -> bool`. The function should take in a directed graph represented as an adjacency list and return `True` if the graph contains a cycle, otherwise `False`. # Constraints 1. The graph will be represented as a dictionary where the keys are node identifiers (integers) and the values are lists of integers indicating directed edges to other nodes. 2. There will be no duplicate edges, but there might be self-loops (an edge from a node to itself). 3. Node identifiers are guaranteed to be unique. 4. The graph can be disconnected. # Input and Output Formats Input * `graph`: Dict[int, List[int]] - The adjacency list representing the graph. Output * Returns `True` if the graph contains a cycle, otherwise `False`. # Sample Input and Output Example 1 **Input**: ```python graph = { 1: [2, 3], 2: [3], 3: [4], 4: [1] } ``` **Output**: ```python True ``` Example 2 **Input**: ```python graph = { 1: [2, 3], 2: [4], 3: [], 4: [] } ``` **Output**: ```python False ``` Example 3 **Input**: ```python graph = { 1: [1] } ``` **Output**: ```python True ``` # Implementation Notes - You should use Depth-First Search (DFS) to detect cycles in the graph. - Make use of three states to mark nodes: UNVISITED, VISITING, and VISITED. - Ensure the function handles all nodes, especially in disconnected graphs. # Skeleton Code ```python def has_cycle(graph: Dict[int, List[int]]) -> bool: Determine if the directed graph contains a cycle. Arguments: graph (Dict[int, List[int]]): Adjacency list representing the graph. Returns: bool: True if the graph contains a cycle, otherwise False. def dfs(node): Helper function for DFS traversal to detect cycles. if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph: if node not in visited: if dfs(node): return True return False # Test cases graph1 = { 1: [2, 3], 2: [3], 3: [4], 4: [1] } print(has_cycle(graph1)) # Should return True graph2 = { 1: [2, 3], 2: [4], 3: [], 4: [] } print(has_cycle(graph2)) # Should return False graph3 = { 1: [1] } print(has_cycle(graph3)) # Should return True ```","solution":"from typing import List, Dict def has_cycle(graph: Dict[int, List[int]]) -> bool: Determine if the directed graph contains a cycle. Arguments: graph (Dict[int, List[int]]): Adjacency list representing the graph. Returns: bool: True if the graph contains a cycle, otherwise False. def dfs(node): Helper function for DFS traversal to detect cycles. if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in graph.get(node, []): if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False visiting = set() visited = set() for node in graph: if node not in visited: if dfs(node): return True return False"},{"question":"# Sorting and Searching in a List of Dictionaries You are tasked with implementing sorting and searching functionalities for a list of dictionaries in Python. Each dictionary contains information about a product with the following keys: \'name\' (string), \'price\' (float), and \'rating\' (float). You need to: 1. Implement a function that sorts the list of products based on any of the three keys: \'name\', \'price\', or \'rating\'. The function should allow sorting in both ascending and descending order. 2. Implement a binary search function that searches for a product by name in the sorted list and returns the dictionary of the product if found, else returns `None`. # Input * A list of dictionaries, where each dictionary contains \'name\', \'price\', and \'rating\' keys. * Parameters specifying the key to sort by and the order of sorting (ascending or descending). * A string representing the product name to search for. # Output * A sorted list of dictionaries based on the specified key and order. * The dictionary of the product if found, else `None`. # Constraints * Assume that the list contains valid and non-empty dictionaries with the mentioned keys. * The search function will only search by the \'name\' key. # Example ```python def sort_products(products: List[Dict[str, Any]], sort_by: str, ascending: bool = True) -> List[Dict[str, Any]]: # Implement the sorting function def binary_search(products: List[Dict[str, Any]], product_name: str) -> Optional[Dict[str, Any]]: # Implement the binary search function # Example: products = [ {\\"name\\": \\"Laptop\\", \\"price\\": 999.99, \\"rating\\": 4.7}, {\\"name\\": \\"Smartphone\\", \\"price\\": 499.99, \\"rating\\": 4.5}, {\\"name\\": \\"Tablet\\", \\"price\\": 299.99, \\"rating\\": 4.2}, {\\"name\\": \\"Monitor\\", \\"price\\": 199.99, \\"rating\\": 4.3} ] sorted_products = sort_products(products, sort_by=\\"price\\", ascending=True) # sorted_products should be sorted by \'price\' in ascending order searched_product = binary_search(sorted_products, product_name=\\"Tablet\\") # searched_product should be the dictionary {\\"name\\": \\"Tablet\\", \\"price\\": 299.99, \\"rating\\": 4.2} assert sorted_products == [ {\\"name\\": \\"Monitor\\", \\"price\\": 199.99, \\"rating\\": 4.3}, {\\"name\\": \\"Tablet\\", \\"price\\": 299.99, \\"rating\\": 4.2}, {\\"name\\": \\"Smartphone\\", \\"price\\": 499.99, \\"rating\\": 4.5}, {\\"name\\": \\"Laptop\\", \\"price\\": 999.99, \\"rating\\": 4.7} ] assert searched_product == {\\"name\\": \\"Tablet\\", \\"price\\": 299.99, \\"rating\\": 4.2} ``` Implement the following functions: 1. **`sort_products`**: Sort the list of products based on the given key and order. 2. **`binary_search`**: Perform a binary search to find the product by name.","solution":"from typing import List, Dict, Any, Optional def sort_products(products: List[Dict[str, Any]], sort_by: str, ascending: bool = True) -> List[Dict[str, Any]]: Sorts the list of products based on the given key and order. :param products: List of dictionaries with product information. :param sort_by: Key to sort by (\'name\', \'price\', \'rating\'). :param ascending: If True, sort in ascending order; otherwise, sort in descending order. :return: Sorted list of products. return sorted(products, key=lambda x: x[sort_by], reverse=not ascending) def binary_search(products: List[Dict[str, Any]], product_name: str) -> Optional[Dict[str, Any]]: Perform a binary search to find the product by name. :param products: Sorted list of dictionaries with product information. :param product_name: Name of the product to search for. :return: The dictionary of the product if found, else None. left, right = 0, len(products) - 1 while left <= right: mid = (left + right) // 2 if products[mid][\'name\'] == product_name: return products[mid] elif products[mid][\'name\'] < product_name: left = mid + 1 else: right = mid - 1 return None"},{"question":"# Problem Statement: You are working on a project to manage a library system and need a function to track and manage book borrowings. Each book has a unique ID and can only be borrowed once before being returned. Your task is to implement a function that processes a sequence of borrowing and returning events and keeps track of which books are currently borrowed. # Function Signature: ```python def manage_library(events: List[Tuple[str, int]]) -> List[int]: Manage the library\'s book borrowing and returning events. Args: events: List of tuples, where each tuple contains: - action: str : Either \\"BORROW\\" or \\"RETURN\\" representing the borrowing or returning of a book. - book_id: int : A unique integer ID for the book. Returns: borrowed_books : List[int]: A list of book IDs that are currently borrowed, in ascending order. ``` # Input: * `events`: A list of tuples, each containing: * `action` (str): Either \\"BORROW\\" or \\"RETURN\\" representing the borrowing or returning of a book. * `book_id` (int): A unique integer ID for the book. # Output: * `borrowed_books`: A list of integers representing the IDs of books that are currently borrowed, sorted in ascending order. # Constraints: * 1 <= len(events) <= 10^4 * 1 <= book_id <= 10^6 * Book IDs are unique within the list of currently borrowed books, meaning no book can be borrowed twice before being returned. * It is guaranteed that a \\"RETURN\\" action will only be called for a book that is currently borrowed. # Example: ```python events = [(\\"BORROW\\", 102), (\\"BORROW\\", 205), (\\"RETURN\\", 102), (\\"BORROW\\", 314)] borrowed_books = manage_library(events) print(borrowed_books) # should output [205, 314] ``` # Notes: - Ensure the output list of borrowed books is always in ascending order. - The function should efficiently handle up to 10,000 events due to constraints.","solution":"def manage_library(events): borrowed_books = set() # To efficiently check if a book is borrowed for event in events: action, book_id = event if action == \\"BORROW\\": borrowed_books.add(book_id) elif action == \\"RETURN\\": borrowed_books.remove(book_id) return sorted(borrowed_books)"}]'),S={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:N,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},O={class:"search-container"},F={class:"card-container"},L={key:0,class:"empty-state"},R=["disabled"],z={key:0},P={key:1};function D(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",O,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",F,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",L,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",P,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const Y=h(S,[["render",D],["__scopeId","data-v-0204e457"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"quotes/50.md","filePath":"quotes/50.md"}'),j={name:"quotes/50.md"},U=Object.assign(j,{setup(r){return(e,l)=>(n(),i("div",null,[x(Y)]))}});export{B as __pageData,U as default};
