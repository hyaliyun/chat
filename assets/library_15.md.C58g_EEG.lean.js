import{_ as h,o as n,c as i,a as t,m as c,t as d,C as g,M as _,U as y,f as u,F as b,p as v,e as w,q as x}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},T={class:"poem-container"},q={class:"review"},E={class:"review-title"},I={class:"review-content"};function A(r,e,l,p,s,a){return n(),i("div",T,[t("div",q,[t("div",E,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),c(d(l.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",I,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),c(d(l.poem.solution),1)])])])}const C=h(k,[["render",A],["__scopeId","data-v-088068a3"]]),S=JSON.parse('[{"question":"# Context You are tasked with parsing and evaluating simple mathematical expressions. These expressions will only contain integer numbers, parentheses for grouping, and the binary operators `+` (addition) and `*` (multiplication). Operator precedence follows standard mathematical rules: multiplication has higher precedence than addition, and parentheses can be used to override this precedence. You need to write a function called `evaluate_expression` that takes a string representing the expression and returns the evaluated result as an integer. # Function Implementation You need to implement the function `evaluate_expression`: ```python def evaluate_expression(expression): Evaluate a mathematical expression containing integers, parentheses, and +, * operators. Args: expression (str): The mathematical expression to evaluate. Returns: int: The result of evaluating the expression. Example: >>> evaluate_expression(\\"(2+3)*(4+5)\\") 45 pass ``` * **Input Format**: - `expression`: A string containing the mathematical expression. The length of the expression will not exceed 100 characters. * **Output Format**: - An integer representing the result of the evaluated expression. * **Constraints**: - The expression will only contain digits `0-9`, parentheses `()`, and the operators `+` and `*`. - The expression will be well-formed (i.e., no unmatched parentheses and no syntax errors). # Example ```python # Given the expression \\"(2+3)*(4+5)\\" print(evaluate_expression(\\"(2+3)*(4+5)\\")) # Output: 45 # Given the expression \\"2+3*4\\" print(evaluate_expression(\\"2+3*4\\")) # Output: 14 # Given the expression \\"(1+2)*(3+4)+5\\" print(evaluate_expression(\\"(1+2)*(3+4)+5\\")) # Output: 26 ``` # Additional Notes * Implement a parser that respects operator precedence and correctly handles parentheses. * You can assume the expression is always valid and does not contain invalid characters. * Do not use `eval` or similar built-in functions directly for evaluation.","solution":"def evaluate_expression(expression): Evaluate a mathematical expression containing integers, parentheses, and +, * operators. Args: expression (str): The mathematical expression to evaluate. Returns: int: The result of evaluating the expression. def parse_expression(expression): tokens = list(expression.replace(\' \', \'\')) return parse_addition(tokens) def parse_addition(tokens): result = parse_multiplication(tokens) while tokens and tokens[0] == \'+\': tokens.pop(0) result += parse_multiplication(tokens) return result def parse_multiplication(tokens): result = parse_parentheses(tokens) while tokens and tokens[0] == \'*\': tokens.pop(0) result *= parse_parentheses(tokens) return result def parse_parentheses(tokens): if tokens[0] == \'(\': tokens.pop(0) result = parse_addition(tokens) tokens.pop(0) # this should be \')\' return result return parse_number(tokens) def parse_number(tokens): num = 0 while tokens and tokens[0].isdigit(): num = num * 10 + int(tokens.pop(0)) return num return parse_expression(expression)"},{"question":"# Problem Statement You are provided with an implementation of a matrix rotation function that rotates a given n x n matrix by 90 degrees clockwise. Your task is to extend this functionality to support both clockwise and counterclockwise rotations based on user input. # Requirements 1. **Rotation Direction**: Modify the function to accept an additional parameter that specifies the rotation direction (\'clockwise\' or \'counterclockwise\'). 2. **Matrix Rotation**: Implement the logic to rotate the matrix 90 degrees either clockwise or counterclockwise based on the input. # Input/Output - **Input**: A matrix represented as a list of lists, and a string indicating the direction of rotation (\'clockwise\' or \'counterclockwise\'). - **Output**: The rotated matrix. # Constraints 1. The matrix will always be a square matrix (n x n) where 1 <= n <= 100. 2. The matrix will contain integer values. # Function Signature ```python def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: pass ``` # Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] # Clockwise rotation result = rotate_matrix(matrix, \'clockwise\') # Output: [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] # Counterclockwise rotation result = rotate_matrix(matrix, \'counterclockwise\') # Output: [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] ``` # Implementation Details 1. For clockwise rotation: - Transpose the matrix. - Reverse each row in the transposed matrix. 2. For counterclockwise rotation: - Transpose the matrix. - Reverse each column in the transposed matrix. 3. Ensure the function handles both rotation directions based on the provided input.","solution":"def rotate_matrix(matrix: list[list[int]], direction: str) -> list[list[int]]: if direction == \'clockwise\': # Transpose the matrix transposed = list(map(list, zip(*matrix))) # Reverse each row in the transposed matrix rotated = [row[::-1] for row in transposed] elif direction == \'counterclockwise\': # Transpose the matrix transposed = list(map(list, zip(*matrix))) # Reverse each column in the transposed matrix rotated = transposed[::-1] else: raise ValueError(\\"Invalid direction. Use \'clockwise\' or \'counterclockwise\'.\\") return rotated"},{"question":"Array Rotation Utility In many computer science and engineering applications, rotating arrays is a common operation. Your task is to implement a class `ArrayRotator` that provides utility methods to rotate an array to the left or right by a specified number of positions. 1. **rotate_left(arr: List[int], k: int) -> List[int]**: Rotate the array `arr` to the left by `k` positions. 2. **rotate_right(arr: List[int], k: int) -> List[int]**: Rotate the array `arr` to the right by `k` positions. 3. **is_rotated_version(arr1: List[int], arr2: List[int]) -> bool**: Check if `arr2` is a rotated version of `arr1`. 4. **find_rotation_count(arr: List[int]) -> int**: Return the number of positions the array `arr` needs to be rotated to become sorted in ascending order. # Requirements: * The input `arr` will be a list of integers. * The input `k` will be a non-negative integer. * You may assume that `arr` contains at least one element. * Your implementation should handle edge cases such as an empty array gracefully. # Example: ```python class ArrayRotator: @staticmethod def rotate_left(arr: List[int], k: int) -> List[int]: # Implement this method pass @staticmethod def rotate_right(arr: List[int], k: int) -> List[int]: # Implement this method pass @staticmethod def is_rotated_version(arr1: List[int], arr2: List[int]) -> bool: # Implement this method pass @staticmethod def find_rotation_count(arr: List[int]) -> int: # Implement this method pass # Example Usage: assert ArrayRotator.rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] # Rotates left by 2 positions assert ArrayRotator.rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] # Rotates right by 2 positions assert ArrayRotator.is_rotated_version([1, 2, 3, 4, 5], [4, 5, 1, 2, 3]) == True # Checks if it\'s a rotated version assert ArrayRotator.find_rotation_count([4, 5, 1, 2, 3]) == 2 # Number of rotations to be sorted ``` Implement the class `ArrayRotator` with the specified methods using efficient algorithms for array manipulation and rotation.","solution":"from typing import List class ArrayRotator: @staticmethod def rotate_left(arr: List[int], k: int) -> List[int]: Rotate the array arr to the left by k positions. n = len(arr) k %= n # In case k is greater than n return arr[k:] + arr[:k] @staticmethod def rotate_right(arr: List[int], k: int) -> List[int]: Rotate the array arr to the right by k positions. n = len(arr) k %= n # In case k is greater than n return arr[-k:] + arr[:-k] @staticmethod def is_rotated_version(arr1: List[int], arr2: List[int]) -> bool: Check if arr2 is a rotated version of arr1. if len(arr1) != len(arr2): return False return any(arr1[i:] + arr1[:i] == arr2 for i in range(len(arr1))) @staticmethod def find_rotation_count(arr: List[int]) -> int: Return the number of positions the array arr needs to be rotated to become sorted in ascending order. n = len(arr) for i in range(n): if arr[i:] + arr[:i] == sorted(arr): return i return 0"},{"question":"# Problem Description You are given an integer array `nums` and an integer `target`. Your task is to implement a method named `find_closest_sum(self, target: int) -> int` in the `ClosestSum` class that finds three integers in `nums` such that the sum is closest to `target`. You should return the sum of the three integers. You may assume that each input would have exactly one solution. # Requirements - The function should return the closest possible sum of any three integers in the array to the given target. - Your solution should efficiently handle both small and large arrays. # Input - `target (int)`: An integer target sum. - `nums (List[int])`: A list of integers, where the length is between 3 and 10^5. # Output - An integer representing the sum of three integers in `nums` closest to the `target`. # Constraints - The length of `nums` is between 3 and 10^5. - `-10^4 <= nums[i] <= 10^4` - `-10^5 <= target <= 10^5` # Examples Example 1: ```python nums = [-1, 2, 1, -4] target = 1 closest_sum = ClosestSum(nums) print(closest_sum.find_closest_sum(target)) # Output: 2 # Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2) ``` Example 2: ```python nums = [1, 1, -1, -1, 3] target = -1 closest_sum = ClosestSum(nums) print(closest_sum.find_closest_sum(target)) # Output: -1 # Explanation: The sum that is closest to the target is -1. (1 + -1 + -1 = -1) ``` # Notes - Sort the array before processing it to leverage the sorted order in the algorithm. - You should use a combination of a loop and two-pointer technique to achieve the desired result efficiently. - Ensure your implementation handles all edge cases gracefully. ```python class ClosestSum: def __init__(self, nums: List[int]): self.nums = nums def find_closest_sum(self, target: int) -> int: nums = sorted(self.nums) closest_sum = sum(nums[:3]) for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum ``` This problem tests your ability to manipulate arrays, sort them, and apply a two-pointer technique efficiently to solve for the closest sum in a large list of integers.","solution":"from typing import List class ClosestSum: def __init__(self, nums: List[int]): self.nums = nums def find_closest_sum(self, target: int) -> int: # Sort the array first nums = sorted(self.nums) closest_sum = sum(nums[:3]) for i in range(len(nums) - 2): left, right = i + 1, len(nums) - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(target - current_sum) < abs(target - closest_sum): closest_sum = current_sum if current_sum < target: left += 1 elif current_sum > target: right -= 1 else: return current_sum return closest_sum"},{"question":"Memory-Efficient Longest Common Subsequence Implement a memory-efficient version of the Longest Common Subsequence (LCS) problem. The standard dynamic programming approach for solving LCS uses a two-dimensional array to store lengths of subsequences, which can be memory-intensive for large strings. Your task is to reduce the memory usage while still providing the correct result. Requirements: 1. **Input**: Two strings `a` and `b`. 2. **Output**: The length of the longest common subsequence between the given strings. 3. **Constraints**: * You cannot use a two-dimensional array of size `len(a) * len(b)`. * Handle edge cases where one or both strings might be empty. 4. **Performance**: * Aim to minimize memory usage as much as possible. * Ensure that the time complexity remains efficient. ```python def lcs_memory_efficient(a: str, b: str) -> int: Memory-efficient LCS implementation. :param a: First input string :param b: Second input string :return: Length of the longest common subsequence Examples: >>> lcs_memory_efficient(\\"abcde\\", \\"ace\\") 3 >>> lcs_memory_efficient(\\"abcdef\\", \\"ghijkl\\") 0 # Your code here if __name__ == \\"__main__\\": assert lcs_memory_efficient(\\"abcde\\", \\"ace\\") == 3 assert lcs_memory_efficient(\\"abcdef\\", \\"ghijkl\\") == 0 assert lcs_memory_efficient(\\"\\", \\"ghijkl\\") == 0 assert lcs_memory_efficient(\\"abcdef\\", \\"\\") == 0 assert lcs_memory_efficient(\\"abcdef\\", \\"abcdef\\") == 6 ``` Explanation: - **Memory Efficiency**: This problem requires you to implement an optimized approach for solving the LCS problem without using a large two-dimensional array, which is typically used in dynamic programming methods. - **Functionality**: The function should take in two strings and return the length of their longest common subsequence. - **Edge Cases**: It should handle cases where one or both strings are empty, efficiently returning `0` as the LCS length in such scenarios. By focusing on both memory and computational efficiency, this question tests the candidate\'s understanding of optimization techniques in dynamic programming and their ability to handle typical algorithmic challenges.","solution":"def lcs_memory_efficient(a: str, b: str) -> int: Memory-efficient LCS implementation. :param a: First input string :param b: Second input string :return: Length of the longest common subsequence if not a or not b: return 0 # Ensure the first string is the shorter one to minimize space if len(a) > len(b): a, b = b, a prev = [0] * (len(a) + 1) curr = [0] * (len(a) + 1) for i in range(1, len(b) + 1): for j in range(1, len(a) + 1): if b[i-1] == a[j-1]: curr[j] = prev[j-1] + 1 else: curr[j] = max(curr[j-1], prev[j]) prev, curr = curr, prev return prev[len(a)]"},{"question":"# Graph Traversal and Pathfinding with Dijkstra\'s Algorithm **Scenario**: Graph traversal and pathfinding are crucial in many computer science applications, such as routing, resource scheduling, and network analysis. Dijkstra\'s algorithm is one of the most popular algorithms used for finding the shortest path between nodes in a graph with non-negative edge weights. You are tasked with implementing this algorithm to solve typical shortest path problems. **Task**: 1. Implement the following function to find the shortest path between two nodes in a graph using Dijkstra\'s algorithm: ```python def dijkstra(graph: dict[str, dict[str, int]], start: str, end: str) -> list[str]: Find the shortest path between start and end nodes using Dijkstra\'s algorithm. Args: graph (dict[str, dict[str, int]]): A dictionary representing the graph where keys are node names and values are dictionaries of neighboring nodes and edge weights. start (str): The starting node for the path. end (str): The target node for the path. Returns: list[str]: A list of nodes representing the shortest path from start to end. ``` **Constraints**: - Assume all edge weights are non-negative integers. - The graph is represented as an adjacency list in the form of a dictionary. - Ensure the function handles graphs with cycles and varying connectivity patterns. - The function should efficiently handle graphs with up to 10^3 nodes and 10^4 edges. **Input Format**: - `graph` (dict[str, dict[str, int]]): The adjacency list of the graph. - `start` (str): The starting node of the path. - `end` (str): The target node of the path. **Output Format**: - Shortest path (list[str]): A list of node names representing the shortest path from the start node to the end node. If no path exists, return an empty list. **Examples**: ```python # Sample graph input graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'A\': 1, \'C\': 2, \'D\': 5}, \'C\': {\'A\': 4, \'B\': 2, \'D\': 1}, \'D\': {\'B\': 5, \'C\': 1} } shortest_path = dijkstra(graph, \'A\', \'D\') print(shortest_path) # Expected [\'A\', \'B\', \'C\', \'D\'] shortest_path = dijkstra(graph, \'A\', \'A\') print(shortest_path) # Expected [\'A\'] shortest_path = dijkstra(graph, \'A\', \'E\') print(shortest_path) # Expected [] ``` **Note**: Thoroughly test your implementation with various graph structures, ensuring correctness and performance within the given constraints.","solution":"import heapq def dijkstra(graph, start, end): Find the shortest path between start and end nodes using Dijkstra\'s algorithm. Args: graph (dict): A dictionary representing the graph where keys are node names and values are dictionaries of neighboring nodes and edge weights. start (str): The starting node for the path. end (str): The target node for the path. Returns: list: A list of nodes representing the shortest path from start to end. # Priority queue to store (cost, node, path) priority_queue = [(0, start, [])] visited = set() while priority_queue: (cost, current_node, path) = heapq.heappop(priority_queue) if current_node in visited: continue path = path + [current_node] visited.add(current_node) # Goal state if current_node == end: return path for neighbor, weight in graph.get(current_node, {}).items(): if neighbor not in visited: heapq.heappush(priority_queue, (cost + weight, neighbor, path)) return []"},{"question":"# Question **Context**: Recursion is a fundamental concept in computer science, allowing a function to call itself directly or indirectly to solve a problem. Understanding recursion is crucial for solving complex problems with elegance and simplicity. Task Write a recursive function `sum_of_digits(number: int) -> int` that returns the sum of the digits of the given integer `number`. Input - `number` (int): A non-negative integer whose digits\' sum needs to be calculated. Output - An integer representing the sum of the digits of the given number. - Return `0` if `number` is `0`. - Raise a `TypeError` if `number` is not a non-negative integer. Constraints - The `number` will fit within the standard range of a 32-bit signed integer. Examples ```python assert sum_of_digits(123) == 6 # 1 + 2 + 3 assert sum_of_digits(0) == 0 # sum of digits of 0 is 0 assert sum_of_digits(4567) == 22 # 4 + 5 + 6 + 7 assert sum_of_digits(1001) == 2 # 1 + 0 + 0 + 1 ``` Additional Notes - Implement the function using recursion only. - Avoid using loops or built-in functions that directly accomplish this task. - Consider edge cases and test the function with various valid inputs.","solution":"def sum_of_digits(number): Recursively returns the sum of the digits of the given integer number. :param number: A non-negative integer whose digits\' sum needs to be calculated. :type number: int :return: The sum of the digits of the given number. :rtype: int :raises TypeError: If the input is not a non-negative integer. if not isinstance(number, int) or number < 0: raise TypeError(\\"Input must be a non-negative integer\\") if number == 0: return 0 return number % 10 + sum_of_digits(number // 10)"},{"question":"# Problem: You are asked to develop a feature for a library management system to manage book rentals. Specifically, you need to implement a function that calculates the overdue fees for rented books based on their return dates and predefined rules. The library has the following rules for calculating overdue fees: - The daily fee for overdue books is 0.25. - There is a grace period of 5 days after the due date during which no fees are charged. - If the book is returned on or before the due date, the total fee is 0.00. - If the book is returned after the grace period, the fee applies to every day beyond the due date plus the grace period. # Function Signature: ```python def calculate_overdue_fee(return_date: str, due_date: str, daily_fee: float = 0.25, grace_period: int = 5) -> float: Calculate the overdue fees for a rented book based on the return date and due date. :param return_date: The date when the book was returned (str in \\"YYYY-MM-DD\\" format) :param due_date: The due date for returning the book (str in \\"YYYY-MM-DD\\" format) :param daily_fee: The daily fee for overdue books (float, default=0.25) :param grace_period: The number of days after the due date during which no fees are charged (int, default=5) :return: The total overdue fee (float) :raises ValueError: if either `return_date` or `due_date` is in an invalid format or if `return_date` is before `due_date`. ``` # Input: * `return_date`: A string representing the date the book was returned in the format `\\"YYYY-MM-DD\\"`. * `due_date`: A string representing the due date for returning the book in the format `\\"YYYY-MM-DD\\"`. * `daily_fee`: A float representing the daily fee for an overdue book (default is 0.25). * `grace_period`: An integer representing the number of grace period days where no fee is charged (default is 5 days). # Output: * A float representing the total overdue fee. # Constraints: * `return_date` and `due_date` will be in the correct format (`\\"YYYY-MM-DD\\"`). * `daily_fee` will be a positive float. * `grace_period` will be a non-negative integer. * The total overdue fee should be rounded to two decimal places. # Example Usage: ```python >>> calculate_overdue_fee(\\"2021-05-10\\", \\"2021-05-05\\") 1.25 >>> calculate_overdue_fee(\\"2021-05-07\\", \\"2021-05-05\\") 0.0 >>> calculate_overdue_fee(\\"2021-06-01\\", \\"2021-05-25\\", daily_fee=0.5) 1.50 >>> calculate_overdue_fee(\\"2021-05-10\\", \\"2021-05-05\\", daily_fee=0.75, grace_period=3) 1.50 >>> calculate_overdue_fee(\\"2021-06-01\\", \\"2021-05-20\\", daily_fee=1.0, grace_period=10) 10.0 ``` # Notes: * Include appropriate error handling for invalid date formats by raising a `ValueError` with a descriptive message. * Consider scenarios where the return date is on the due date or within the grace period (fees are 0.00). * Ensure to handle edge cases such as returns exactly on the due date and returns far beyond the due date.","solution":"from datetime import datetime def calculate_overdue_fee(return_date: str, due_date: str, daily_fee: float = 0.25, grace_period: int = 5) -> float: Calculate the overdue fees for a rented book based on the return date and due date. :param return_date: The date when the book was returned (str in \\"YYYY-MM-DD\\" format) :param due_date: The due date for returning the book (str in \\"YYYY-MM-DD\\" format) :param daily_fee: The daily fee for overdue books (float, default=0.25) :param grace_period: The number of days after the due date during which no fees are charged (int, default=5) :return: The total overdue fee (float) :raises ValueError: if either `return_date` or `due_date` is in an invalid format or if `return_date` is before `due_date`. try: return_date_obj = datetime.strptime(return_date, \\"%Y-%m-%d\\") due_date_obj = datetime.strptime(due_date, \\"%Y-%m-%d\\") except ValueError: raise ValueError(\\"Invalid date format. Use \'YYYY-MM-DD\'.\\") if return_date_obj < due_date_obj: raise ValueError(\\"Return date cannot be before the due date.\\") days_overdue = (return_date_obj - due_date_obj).days if days_overdue <= grace_period: return 0.0 days_to_charge = days_overdue - grace_period total_fee = days_to_charge * daily_fee return round(total_fee, 2)"},{"question":"# Question: Implement Rotational Matrix Transformation As a developer, you need to perform 2D rotational transformations on a set of points using a given angle. Your task includes creating a function that applies the rotation transformation on an array of points. Your Task 1. Implement a function `rotate_points` that computes the new positions of multiple 2D points after applying a rotational transformation by a given angle in degrees. Function Signature ```python def rotate_points(points: list[list[float]], angle_degrees: float) -> list[list[float]]: pass ``` # Parameters * **points (list[list[float]])**: A list of points where each point is represented as a list of two floats [x, y]. * **angle_degrees (float)**: Rotation angle in degrees. # Returns * A list of the transformed points, where each point is represented as a list of two floats [x\', y\']. # Examples ```python # Example 1 points = [[1.0, 0.0], [0.0, 1.0], [1.0, 1.0]] angle_degrees = 90 rotate_points(points, angle_degrees) # Expected: [[0.0, 1.0], [-1.0, 0.0], [-1.0, 1.0]] # Example 2 points = [[2.0, 2.0], [3.0, 4.0], [5.0, 7.0]] angle_degrees = 45 rotate_points(points, angle_degrees) # Expected: [[0.0, 2.828], [-0.707, 4.95], [-1.414, 8.485]] ``` # Constraints * The input angle can be positive or negative. * The input list of points will contain at least one point. * The function should handle floating-point precision up to three decimal places for the output coordinates. # Notes - To convert degrees to radians, use the relation: `radians = degrees * (π / 180)` - Use the rotation matrix: [ begin{bmatrix} cos(theta) & -sin(theta) sin(theta) & cos(theta) end{bmatrix} ] where θ is the rotation angle in radians. - Make sure to perform matrix multiplication correctly to find the new coordinates. # Implementation ```python import math def rotate_points(points: list[list[float]], angle_degrees: float) -> list[list[float]]: angle_radians = math.radians(angle_degrees) cos_theta = math.cos(angle_radians) sin_theta = math.sin(angle_radians) rotated_points = [] for x, y in points: new_x = cos_theta * x - sin_theta * y new_y = sin_theta * x + cos_theta * y rotated_points.append([round(new_x, 3), round(new_y, 3)]) return rotated_points ```","solution":"import math def rotate_points(points: list[list[float]], angle_degrees: float) -> list[list[float]]: Rotate a list of 2D points by a given angle in degrees. Parameters: points (list of list of floats): The original points to rotate, each point represented as [x, y]. angle_degrees (float): The angle by which to rotate the points, in degrees. Returns: list of list of floats: The rotated points, with each point rounded to 3 decimal places. angle_radians = math.radians(angle_degrees) cos_theta = math.cos(angle_radians) sin_theta = math.sin(angle_radians) rotated_points = [] for x, y in points: new_x = cos_theta * x - sin_theta * y new_y = sin_theta * x + cos_theta * y rotated_points.append([round(new_x, 3), round(new_y, 3)]) return rotated_points"},{"question":"# Question: Array Element Frequency Counter You\'re given an array of integers where some elements appear more than once and some appear only once. Your task is to write a function that counts the frequency of each element in the array and returns a dictionary where keys are the elements and the values are their corresponding frequencies. # Tasks: 1. Write a function `element_frequency(arr: List[int]) -> Dict[int, int]` that counts the frequency of each element in the array. 2. Ensure your function returns the frequency counts in a dictionary format. # Input: * An array `arr` (1 ≤ len(arr) ≤ 1000) where each element is an integer. # Output: * A dictionary with elements of the array as keys and their frequency as values. # Constraints: * The function should handle arrays of varying lengths efficiently. * Aim for O(n) time complexity where n is the length of the input array. # Examples: ```python >>> element_frequency([1, 2, 2, 3, 4, 4, 4]) {1: 1, 2: 2, 3: 1, 4: 3} >>> element_frequency([5, 5, 5, 5]) {5: 4} >>> element_frequency([1, 2, 3, 4, 5]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> element_frequency([]) {} >>> element_frequency([6, 7, 8, 7, 6, 5, 5, 5]) {5: 3, 6: 2, 7: 2, 8: 1} ``` # Notes: * Consider edge cases like an empty array and arrays with only one unique element. * Utilize Python\'s dictionary for keeping track of element counts efficiently.","solution":"from typing import List, Dict def element_frequency(arr: List[int]) -> Dict[int, int]: frequency = {} for elem in arr: if elem in frequency: frequency[elem] += 1 else: frequency[elem] = 1 return frequency"},{"question":"# Coding Assessment Question You are working on a system that processes orders for an e-commerce application. The system receives a log of orders placed, and your task is to implement a function that will summarize the total quantity ordered for each product. # Inputs * `orders`: A list of dictionaries where each dictionary represents an individual order. Each order contains two keys: \\"product_id\\" (an integer) and \\"quantity\\" (an integer). # Outputs * A dictionary where each key is a product_id and the corresponding value is the total quantity ordered for that product_id. # Constraints * `orders` list will contain at least one order. * All product_ids will be valid positive integers and quantities will be non-negative integers. # Example ```python orders = [ {\\"product_id\\": 1, \\"quantity\\": 5}, {\\"product_id\\": 2, \\"quantity\\": 3}, {\\"product_id\\": 1, \\"quantity\\": 7}, {\\"product_id\\": 3, \\"quantity\\": 2} ] # Summarized quantities might be: {1: 12, 2: 3, 3: 2} ``` # Implementation Complete the implementation of the `summarize_orders` function: ```python def summarize_orders(orders): summary = {} for order in orders: product_id = order[\'product_id\'] quantity = order[\'quantity\'] if product_id in summary: summary[product_id] += quantity else: summary[product_id] = quantity return summary ``` Test your implementation with multiple cases to ensure correctness.","solution":"def summarize_orders(orders): Summarizes the total quantity ordered for each product_id. Parameters: orders (list of dict): A list where each element is a dictionary representing an order with \'product_id\' and \'quantity\' keys. Returns: dict: A dictionary with product_id as keys and total quantity ordered as values. summary = {} for order in orders: product_id = order[\'product_id\'] quantity = order[\'quantity\'] if product_id in summary: summary[product_id] += quantity else: summary[product_id] = quantity return summary"},{"question":"Problem Statement You are developing a function to generate all unique permutations of a list of integers that may contain duplicates. This involves creating arrangements of the elements whereby each unique permutation appears once. # Function to Implement ```python def permute_unique(nums): Generate all unique permutations of the list of integers. @param nums: a list of integers which may contain duplicates. @return: a list of lists, where each list is a unique permutation of the nums list. # Your code here pass ``` # Input and Output Formats Input - `nums`: A list of integers, which can include duplicates. Output - A list of lists where each inner list is a unique permutation of the input list. # Constraints - The length of the list `nums` may vary from 1 to 10. - Integers in the list `nums` may range from `-10` to `10`. # Example ```python # Example Input: nums = [1, 1, 2] # Example Output: # permute_unique(nums) # Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]] ``` ```python # Example Input: nums = [2, 2, 1, 1] # Example Output: # permute_unique(nums) # Output: [[1, 1, 2, 2], [1, 2, 1, 2], [1, 2, 2, 1], # [2, 1, 1, 2], [2, 1, 2, 1], [2, 2, 1, 1]] ``` # Notes - Output does not need to be sorted. - Ensure that each permutation represented in the output list is unique. - Consider utilizing backtracking along with sorting the input list to manage duplicates effectively.","solution":"def permute_unique(nums): from collections import Counter def backtrack(combination, counter): if len(combination) == len(nums): result.append(list(combination)) return for num in counter: if counter[num] > 0: combination.append(num) counter[num] -= 1 backtrack(combination, counter) combination.pop() counter[num] += 1 result = [] counter = Counter(nums) backtrack([], counter) return result"},{"question":"# Coding Assessment Question Design a function `encode_decode` that uses a simple substitution cipher for encoding and decoding messages. Each character in a given string message will be substituted with a corresponding character from another string of unique characters (both strings having the same length). The function should be able to perform both operations - encoding and decoding based on an additional boolean parameter `encode`. Function Signature ```python def encode_decode(message: str, key1: str, key2: str, encode: bool) -> str: pass ``` Input - `message` (string): The original message to encode or decode. - `key1` (string): A string containing unique characters for substitution in encoding. - `key2` (string): A string containing unique characters for substitution in decoding. This string is correlated with `key1`. - `encode` (boolean): If `True`, encode the message. If `False`, decode the message. Output - (string): The encoded or decoded message. Constraints - `message` can contain up to `10^3` characters which include lower and upper-case letters, digits, and special characters. - `key1` and `key2` are of equal length and only contain unique characters. Example ```python message = \\"Hello World!\\" key1 = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" key2 = \\"nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM\\" encoded_message = encode_decode(message, key1, key2, True) print(encoded_message) # Output: \\"Uryyb Jbeyq!\\" decoded_message = encode_decode(encoded_message, key1, key2, False) print(decoded_message) # Output: \\"Hello World!\\" message = \\"Attack at dawn!\\" key1 = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" key2 = \\"ZYXWVUTSRQPONMLKJIHGFEDCBAzyxwvutsrqponmlkjihgfedcba\\" encoded_message = encode_decode(message, key1, key2, True) print(encoded_message) # Output: \\"Zggzxp zg wzdm!\\" decoded_message = encode_decode(encoded_message, key1, key2, False) print(decoded_message) # Output: \\"Attack at dawn!\\" ``` Scenarios to Validate - Encoding a message with only lowercase letters. - Decoding a message with mixed case letters. - Encoding a message with digits and special characters. - Decoding a message with digits and special characters. - Ensuring the function checks for the equality of lengths of `key1` and `key2` and that they only contain unique characters before proceeding with encoding/decoding.","solution":"def encode_decode(message: str, key1: str, key2: str, encode: bool) -> str: Encodes or decodes a message using a simple substitution cipher based on the provided keys. Parameters: - message (str): The message to encode or decode. - key1 (str): The substitution key for encoding. - key2 (str): The substitution key for decoding. - encode (bool): If True, encode the message; if False, decode the message. Returns: str: The encoded or decoded message. if len(key1) != len(key2): raise ValueError(\\"key1 and key2 must be of the same length.\\") if len(set(key1)) != len(key1) or len(set(key2)) != len(key2): raise ValueError(\\"key1 and key2 must contain unique characters.\\") translation_table = str.maketrans(key1, key2) if encode else str.maketrans(key2, key1) return message.translate(translation_table)"},{"question":"# Question: Implementing an Efficient Fibonacci Sequence Generator Given a positive integer `n`, write a function to generate the first `n` numbers in the Fibonacci sequence. Your implementation should be efficient in both time and space complexity, and it should handle the case where `n` can be up to (10^5). You must also ensure that the function handles the lower boundary conditions, such as `n` equal to 1 or 2, correctly. **Function Signature:** ```python def efficient_fibonacci(n: int) -> list[int]: pass ``` **Input:** * `n`: A positive integer representing the length of the Fibonacci sequence to be generated. The value of `n` can be as large as (10^5). **Output:** * Return a list containing the first `n` numbers of the Fibonacci sequence in order. **Constraints:** * The algorithm should be optimized for both time and space to handle up to (10^5) elements efficiently. * Ensure the function works correctly for minimal values of `n` like 1 and 2. **Examples:** ```python assert efficient_fibonacci(1) == [0] assert efficient_fibonacci(2) == [0, 1] assert efficient_fibonacci(5) == [0, 1, 1, 2, 3] assert efficient_fibonacci(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ```","solution":"def efficient_fibonacci(n: int) -> list[int]: if n == 1: return [0] if n == 2: return [0, 1] fib_seq = [0] * n fib_seq[0], fib_seq[1] = 0, 1 for i in range(2, n): fib_seq[i] = fib_seq[i - 1] + fib_seq[i - 2] return fib_seq"},{"question":"**Weather Simulation System** # Context: You are tasked with developing a Weather Simulation System that can model and predict weather conditions for a given region. Your system should generate a sequence of weather patterns based on a set of initial conditions and rules. # Objective: Implement a Python class `WeatherSimulator` that simulates weather conditions based on historical data and pattern rules. The simulation should: 1. Support initialization with historical weather data. 2. Allow obtaining weather predictions for future days based on simulation rules. 3. Introduce a feature to reset the simulation to initial conditions. # Constraints: - The initial historical weather data is provided as a list of strings representing days, e.g., `[\\"Sunny\\", \\"Rainy\\", \\"Cloudy\\"]`. - The system should support a rule-based engine where a weather pattern on a given day influences the prediction for the next day. - Each simulation should run for a maximum of 30 days. - Implementations should be efficient in memory usage and runtime performance. # Specifications: 1. Class Name: `WeatherSimulator` 2. Shall contain the methods: * `__init__(self, historical_data: List[str])`: Initializes with historical weather data. * `predict(self, days: int) -> List[str]`: Predicts the weather for the next `days` based on current simulation. * `reset(self) -> None`: Resets the simulation to the initial historical data. # Expected Input and Output Formats: - **Input formats**: * `historical_data`: A list of strings representing historical weather data. * `days`: An integer number of days to predict. - **Output formats**: * `predict(days)`: Returns a list of strings representing the predicted weather patterns for the next given number of days. # Example Usage: ```python # Initialize the simulator with historical data simulator = WeatherSimulator(historical_data=[\\"Sunny\\", \\"Rainy\\", \\"Cloudy\\", \\"Sunny\\"]) # Predict weather for the next 5 days predictions = simulator.predict(5) print(\\"Next 5 days predictions:\\", predictions) # Reset the simulation simulator.reset() ``` # Example Simulation Rules: You can assume example rules for prediction, such as: - \\"Sunny\\" is followed by \\"Cloudy\\" 50% of the time and \\"Rainy\\" 50% of the time. - \\"Rainy\\" is followed by \\"Sunny\\" 70% of the time and \\"Cloudy\\" 30% of the time. - \\"Cloudy\\" is followed by \\"Sunny\\" 40% of the time and \\"Rainy\\" 60% of the time. These rules can be embedded as part of the weather simulation logic or provided as a parameter during initialization. # Performance Requirements: - The simulation should handle the prediction for up to 30 days efficiently. - Ensure the reset functionality restores the weather simulation to its initial historical state without performance degradation.","solution":"import random from typing import List class WeatherSimulator: def __init__(self, historical_data: List[str]): self.historical_data = historical_data self.initial_data = list(historical_data) self.rules = { \\"Sunny\\": {\\"Cloudy\\": 0.5, \\"Rainy\\": 0.5}, \\"Rainy\\": {\\"Sunny\\": 0.7, \\"Cloudy\\": 0.3}, \\"Cloudy\\": {\\"Sunny\\": 0.4, \\"Rainy\\": 0.6}, } def predict(self, days: int) -> List[str]: if days <= 0: raise ValueError(\\"Number of days should be greater than 0\\") simulation_data = list(self.historical_data) for _ in range(days): last_day_weather = simulation_data[-1] transitions = self.rules[last_day_weather] next_day_weather = random.choices( population=list(transitions.keys()), weights=list(transitions.values()) )[0] simulation_data.append(next_day_weather) return simulation_data[-days:] def reset(self) -> None: self.historical_data = list(self.initial_data)"},{"question":"# Coding Challenge: Counting Set Bits in an Integer You are tasked with writing a function that counts the number of set bits (1s) in the binary representation of a given integer. This exercise will test your understanding of binary number representations and bitwise manipulation. Problem Description Implement a function named `count_set_bits` that takes an integer as input and returns the count of set bits (1s) in its binary representation. Function Signature: ```python def count_set_bits(number: int) -> int: ``` Input: * `number`: A single integer. The integer can be positive, negative, or zero. Output: * Returns an integer representing the count of set bits in the binary representation of the input number. Example: ```python assert count_set_bits(4) == 1 assert count_set_bits(7) == 3 assert count_set_bits(0) == 0 assert count_set_bits(15) == 4 assert count_set_bits(-1) == 32 # assuming a 32-bit integer representation assert count_set_bits(-8) == 29 # assuming a 32-bit integer representation ``` Constraints: * The solution must use bitwise operations to count the set bits. * Avoid using built-in functions such as `bin()` or similar for counting. * Execution should be efficient. Additional Considerations: Ensure to handle different types of integers (positive, negative, and zero) effectively and test any potential edge cases. Assume a 32-bit integer representation for negative numbers.","solution":"def count_set_bits(number: int) -> int: Count the number of set bits (1s) in the binary representation of the given integer. count = 0 if number < 0: # Assuming a 32-bit integer representation for negative numbers number = number & 0xFFFFFFFF while number: count += number & 1 number >>= 1 return count"},{"question":"# Problem Statement: You are given two strings `s1` and `s2`. Your task is to implement a function `min_distance(s1, s2)` that returns the minimum number of operations required to convert string `s1` into string `s2`. The only operations allowed are insertion, deletion, or substitution of a single character. # Function Signature ```python def min_distance(s1: str, s2: str) -> int: pass ``` # Input - **s1** (str): A non-empty string of length no more than 100. - **s2** (str): A non-empty string of length no more than 100. # Output - **int**: The minimum number of operations required to convert `s1` into `s2`. # Constraints - Ensure both input strings are non-empty and contain only lower-case English letters. If any input string is invalid, raise a `ValueError` with the message `\\"Invalid input\\"`. # Example ```python assert min_distance(\\"kitten\\", \\"sitting\\") == 3 # Replace \'k\' with \'s\', replace \'e\' with \'i\', insert \'g\' assert min_distance(\\"flaw\\", \\"lawn\\") == 2 # Replace \'f\' with \'l\', insert \'n\' assert min_distance(\\"intention\\", \\"execution\\") == 5 # Replace \'i\' with \'e\', replace \'n\' with \'x\', replace \'t\' with \'c\', replace \'n\' with \'u\', replace \'e\' with \'t\' assert min_distance(\\"hello\\", \\"hello\\") == 0 # Strings are already identical ``` # Additional Information - You may use dynamic programming to solve this problem efficiently. - Consider edge cases such as: - When both strings are already identical. - When one of the strings is empty. - Varying lengths and characters of the strings. # Tips - Use a 2D array to store the solution of subproblems. - The value at `dp[i][j]` will be the minimum number of operations required to convert `s1[0..i]` to `s2[0..j]`. - Ensure to handle edge cases appropriately and optimize for performance.","solution":"def min_distance(s1: str, s2: str) -> int: # Input validation if not s1.islower() or not s2.islower() or len(s1) > 100 or len(s2) > 100: raise ValueError(\\"Invalid input\\") m, n = len(s1), len(s2) # Create a DP table dp = [[0 for _ in range(n+1)] for _ in range(m+1)] # Initialize the table for i in range(m+1): for j in range(n+1): if i == 0: dp[i][j] = j # s1 is empty, insert all of s2\'s characters elif j == 0: dp[i][j] = i # s2 is empty, delete all of s1\'s characters elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # Characters are the same, no operation needed else: dp[i][j] = 1 + min(dp[i-1][j], # Insert dp[i][j-1], # Delete dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"# Problem Statement You are given an integer `n` that represents the number of stairs, and you are required to find the number of unique ways to climb to the top. You can either climb 1, 2, or 3 steps at a time. **Function Signature:** ```python def climb_stairs(n: int) -> int: Parameters: n (int): The number of stairs. Returns: int: The number of unique ways to climb to the top. ``` # Input - An integer `n` (1 ≤ n ≤ 40), representing the number of stairs. # Output - An integer, the number of unique ways to climb to the top of the stairs. # Constraints - Ensure the solution is efficient with respect to both time and space complexity. # Example ```python assert climb_stairs(1) == 1 assert climb_stairs(3) == 4 assert climb_stairs(5) == 13 ``` # Explanation For `n = 3`, the possible combinations are: 1. 1 step + 1 step + 1 step 2. 1 step + 2 steps 3. 2 steps + 1 step 4. 3 steps **Note**: * Consider using dynamic programming or memoization to optimize the solution. * Ensure that your solution properly handles the edge cases. By following these guidelines, the question should seamlessly integrate with the provided set, maintaining consistency in style, complexity, and topic alignment.","solution":"def climb_stairs(n: int) -> int: Returns the number of unique ways to climb to the top of `n` stairs. You can either climb 1, 2, or 3 steps at a time. if n == 1: return 1 elif n == 2: return 2 elif n == 3: return 4 dp = [0] * (n + 1) dp[1] = 1 dp[2] = 2 dp[3] = 4 for i in range(4, n + 1): dp[i] = dp[i-1] + dp[i-2] + dp[i-3] return dp[n]"},{"question":"# Maze Solver Challenge You are tasked with creating a function to solve a maze represented as a 2D grid. The goal is to determine if there is a path from a given start point to an end point, traversing only through open cells. Input - `maze`: A list of lists representing the maze grid (a 2D matrix of integers), where `0` represents an open cell and `1` represents a wall. - `start`: A tuple `(x, y)` representing the starting coordinates in the maze. - `end`: A tuple `(x, y)` representing the destination coordinates in the maze. Output - Return `True` if there is a path from `start` to `end`. Otherwise, return `False`. Example ```python def solve_maze(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> bool: # Your implementation here maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) print(solve_maze(maze, start, end)) # True maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 1] ] start = (0, 0) end = (4, 4) print(solve_maze(maze, start, end)) # False ``` # Constraints - The maze grid will contain at most 20x20 cells. - The start and end coordinates will always be within the maze grid boundaries. - There will be only one start and one end point. # Performance Requirement - The function should be optimized for time complexity, with a target of handling a 20x20 grid efficiently. # Detailed Requirements - Implement helper functions like `is_valid_move` to check the validity of the next move. - Use depth-first search (DFS) or breadth-first search (BFS) algorithm to find the path. - Ensure the function handles edge cases such as the start or end points being walls, and isolated open cells. - Focus on minimizing the number of visits to already checked cells to prevent redundant computations. Showcase your solution by demonstrating the ability to find a valid path from the start point to the end point, navigating around walls as necessary. Validate your solution with the provided example tests.","solution":"def solve_maze(maze, start, end): Determines if there is a path from start to end in the maze. :param maze: List of lists representing the maze (2D grid of integers) :param start: Tuple representing the start coordinates (x, y) :param end: Tuple representing the end coordinates (x, y) :return: True if there is a path from start to end, False otherwise if maze[start[0]][start[1]] == 1 or maze[end[0]][end[1]] == 1: return False rows, cols = len(maze), len(maze[0]) visited = [[False for _ in range(cols)] for _ in range(rows)] def is_valid_move(x, y): return 0 <= x < rows and 0 <= y < cols and maze[x][y] == 0 and not visited[x][y] def dfs(x, y): if (x, y) == end: return True visited[x][y] = True # Explore neighbors: right, down, left, up for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]: nx, ny = x + dx, y + dy if is_valid_move(nx, ny) and dfs(nx, ny): return True return False return dfs(start[0], start[1])"},{"question":"# Scenario Your task is to implement a function `max_subarray_with_target_sum` that determines the length of the longest contiguous subarray with a given target sum. This should be done using an approach that maintains O(n) time complexity. You are provided with an integer array and the target sum. # Function Specification ```python def max_subarray_with_target_sum(arr: List[int], target: int) -> int: pass ``` # Input * **arr**: A list of integers where 0 <= len(arr) <= 10^5. * **target**: An integer representing the target sum. # Output * Returns an integer that represents the length of the longest contiguous subarray whose sum is equal to the target. If no such subarray exists, return 0. # Constraints * Elements in the array lie within the range of [-10^5, 10^5]. * The target sum lies within the range of [-10^10, 10^10]. * The implementation should not use additional space beyond fixed-size or constant space variables. # Examples ```python >>> max_subarray_with_target_sum([1, -1, 5, -2, 3], 3) 4 >>> max_subarray_with_target_sum([-2, -1, 2, 1], 1) 2 >>> max_subarray_with_target_sum([], 0) 0 >>> max_subarray_with_target_sum([1, 2, 3, 4, 5], 15) 5 >>> max_subarray_with_target_sum([1, 2, 3], 7) 0 ``` **Note**: Make sure to consider both positive and negative numbers in the array and edge cases such as an empty array or the entire array summing to the target.","solution":"def max_subarray_with_target_sum(arr, target): Finds the length of the longest contiguous subarray with sum equal to the target. # Dictionary to store (sum up to index : index) sum_indices = {} sum_indices[0] = -1 # Handles the case where the subarray starts from index 0 current_sum = 0 max_length = 0 for i in range(len(arr)): current_sum += arr[i] if (current_sum - target) in sum_indices: max_length = max(max_length, i - sum_indices[current_sum - target]) if current_sum not in sum_indices: sum_indices[current_sum] = i return max_length"},{"question":"# Coding Question: Longest Subarray with Equal Number of 0s and 1s You are given a binary array `nums` that consists of only 0s and 1s. Your task is to write a function `find_max_length` that finds the maximum length of a contiguous subarray with an equal number of 0s and 1s. # Input - The input array `nums` which is a list of integers containing only 0 and 1. # Output - An integer representing the maximum length of the contiguous subarray with equal number of 0s and 1s. # Constraints - The length of `nums` will be in the range `[1, 10^5]`. # Example: ```python >>> find_max_length([0, 1]) 2 >>> find_max_length([0, 1, 0]) 2 >>> find_max_length([0, 0, 1, 0, 0, 1, 1]) 6 >>> find_max_length([0, 0, 1, 1, 0]) 4 ``` # Note: For the given input `nums = [0, 1]`, your function should return `2` since the entire array can be considered as the subarray with equal number of 0s and 1s. **Hint:** Use a hash map to keep track of the running sum and its first occurrence to optimize the solution. Transform the given array such that 0 becomes -1 and then find the largest subarray with a sum of zero.","solution":"def find_max_length(nums): Returns the maximum length of a contiguous subarray with an equal number of 0s and 1s. count_map = {0: -1} # hash map to store the earliest occurrence of each count max_length = 0 count = 0 for i, num in enumerate(nums): if num == 0: count -= 1 else: count += 1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"# Sum of Unique Elements You are tasked with implementing a function that calculates the sum of elements in a list that appear exactly once. Function Signature: ```python def sum_of_unique_elements(lst: list) -> int: ``` # Input: * A list of integers `lst`. # Output: * An integer representing the sum of elements that appear exactly once in the list. # Examples: ```python >>> sum_of_unique_elements([1, 2, 3, 2]) 4 >>> sum_of_unique_elements([4, 4, 4, 5]) 5 >>> sum_of_unique_elements([10, 20, 30, 40]) 100 >>> sum_of_unique_elements([1, 1, 1, 1]) 0 >>> sum_of_unique_elements([]) 0 ``` # Constraints: * The function must raise a `TypeError` if the input is not a list of integers. * The list may be empty, in which case the result should be `0`. * Achieve an optimized solution with a time complexity of O(n) and space complexity of O(n), where n is the number of elements in the list. # Additional Requirements: * Your solution should handle edge cases such as an empty list or lists with all elements the same. * Ensure that your function doesn\'t alter the original list. # Hints: * Use a dictionary or a counter to keep track of the frequency of each element in the list. * Sum only the elements with a frequency of one.","solution":"def sum_of_unique_elements(lst): Returns the sum of elements that appear exactly once in the list. Parameters: lst (list): A list of integers Returns: int: The sum of unique elements if not isinstance(lst, list): raise TypeError(\\"Input must be a list\\") if not all(isinstance(i, int) for i in lst): raise TypeError(\\"All elements in the list must be integers\\") from collections import Counter element_count = Counter(lst) unique_sum = sum(num for num, count in element_count.items() if count == 1) return unique_sum"},{"question":"# Coding Assessment Question Context In competitive programming and various algorithmic challenges, efficiently managing data and performing quick sum queries is crucial. One such popular data structure to handle these tasks is the Fenwick Tree (also known as Binary Indexed Tree, BIT). This question focuses on maintaining an array while supporting fast update and prefix sum operations. Problem Statement You are given a list of integers `arr` with `n` elements and you need to perform a series of updates and prefix sum queries on it. Implement a Fenwick Tree to efficiently handle these operations. 1. **Fenwick Tree Initialization**: * Implement the function to initialize the Fenwick Tree from the given list. 2. **Update Operation**: * Implement the function to update the value at a specific index in the original list and reflect this change in the Fenwick Tree. 3. **Prefix Sum Query**: * Implement the function to return the prefix sum (sum of elements from the start to a given index). Function Signatures ```python class FenwickTree: def __init__(self, arr: list[int]) -> None: Initializes the Fenwick Tree with the given list `arr`. pass def update(self, index: int, value: int) -> None: Adds `value` to the element at `index` in the Fenwick Tree. pass def prefix_sum(self, index: int) -> int: Returns the prefix sum from the start of the array to the given `index`. pass ``` Example ```python arr = [3, 2, -1, 6, 5, 4, -3, 3, 7, 2, 3] fenwick_tree = FenwickTree(arr) print(fenwick_tree.prefix_sum(5)) # Output: 19 (sum of [3, 2, -1, 6, 5, 4]) fenwick_tree.update(3, 2) # Increment value at index 3 by 2 print(fenwick_tree.prefix_sum(5)) # Output: 21 (sum of [3, 2, -1, 8, 5, 4]) fenwick_tree.update(5, -3) # Decrement value at index 5 by 3 print(fenwick_tree.prefix_sum(5)) # Output: 18 (sum of [3, 2, -1, 8, 2, 4]) ``` Constraints * Number of elements (`n`): 1 ≤ n ≤ 10^5 * Each element of `arr` is an integer between -10^9 and 10^9. * Updates and queries can be interleaved and may happen any number of times. * Indexes are zero-based. Your implementation must ensure efficient performance for both the update and prefix sum operations.","solution":"class FenwickTree: def __init__(self, arr: list[int]) -> None: Initializes the Fenwick Tree with the given list `arr`. self.n = len(arr) self.tree = [0] * (self.n + 1) for idx, val in enumerate(arr): self.update(idx, val) def update(self, index: int, value: int) -> None: Adds `value` to the element at `index` in the Fenwick Tree. index += 1 # Adjust to 1-based index while index <= self.n: self.tree[index] += value index += index & -index def prefix_sum(self, index: int) -> int: Returns the prefix sum from the start of the array to the given `index`. index += 1 # Adjust to 1-based index result = 0 while index > 0: result += self.tree[index] index -= index & -index return result"},{"question":"# Problem Statement: Given a non-empty list of strings, each representing a numeric value, your task is to sort these strings based on their numeric values. Keep in mind that the strings might represent very large integers which can exceed standard integer limits in programming. # Task: Implement the `numeric_string_sort` function which takes a list of strings `numbers` and returns a list of strings sorted in ascending order based on their numeric values. # Function Signature: ```python def numeric_string_sort(numbers: List[str]) -> List[str]: ``` # Input: - A list of strings `numbers` ((1 leq |numbers| leq 10^4)), where each string represents a non-negative integer ((0 leq int(numbers[i]) < 10^{100})). # Output: - A list of strings sorted in ascending order based on their numeric values. # Example: ```python assert numeric_string_sort([\\"123\\", \\"4\\", \\"45\\", \\"9\\", \\"56\\"]) == [\\"4\\", \\"9\\", \\"45\\", \\"56\\", \\"123\\"] assert numeric_string_sort([\\"1000\\", \\"200\\", \\"1500\\", \\"3\\"]) == [\\"3\\", \\"200\\", \\"1000\\", \\"1500\\"] assert numeric_string_sort([\\"1\\", \\"01\\", \\"001\\"]) == [\\"001\\", \\"01\\", \\"1\\"] ``` # Constraints: - Ensure the sorting algorithm can handle the large numeric values represented by the strings. - The algorithm should perform in a reasonable time frame, considering the constraints. # Implementation Note: - Do not convert the strings directly to integers for sorting; instead, handle the comparison operations to account for the numeric value directly with the strings.","solution":"from typing import List def numeric_string_sort(numbers: List[str]) -> List[str]: Sort a list of numeric strings by their integer values. # Sort based on their numeric value but maintain them as strings sorted_numbers = sorted(numbers, key=lambda x: (len(x), x)) return sorted_numbers"},{"question":"# Batch Process Simulation You are tasked with writing a simulation for a batch processing system that processes tasks in batches. Each batch has a specific capacity and processes tasks sequentially. **Function Signature** ```python def batch_process(tasks: list, batch_size: int) -> list: ``` # Input 1. `tasks` (list of int): A list of integers representing the tasks. Each integer represents the time required to complete the task. 2. `batch_size` (int): The maximum number of tasks that can be processed in a single batch. # Output A `list` of `list` where each inner list represents a batch of tasks processed sequentially. # Constraints * `1 <= len(tasks) <= 10^4` * `1 <= batch_size <= 100` * `1 <= task_time <= 10^3` for each task in tasks # Requirements * Ensure that the tasks are divided into batches of at most `batch_size` tasks. * Each task should appear in one and only one batch, in the order they appear in the input list. **Examples** ```python tasks = [5, 8, 3, 1, 6, 7, 2] batch_size = 3 result = batch_process(tasks, batch_size) print(result) # Output: [[5, 8, 3], [1, 6, 7], [2]] ``` ```python tasks = [12, 7, 10, 5, 4] batch_size = 2 result = batch_process(tasks, batch_size) print(result) # Output: [[12, 7], [10, 5], [4]] ``` # Hint Consider using a loop to iterate through the list of tasks and keep track of the current batch being formed. When the batch reaches the specified size, start forming a new batch.","solution":"def batch_process(tasks: list, batch_size: int) -> list: Divides given tasks into batches where each batch can contain at most batch_size tasks. Parameters: tasks (list of int): List of tasks where each task is represented by an integer. batch_size (int): Maximum number of tasks that can be processed in one batch. Returns: list of list of int: List containing batches of tasks. batches = [] for i in range(0, len(tasks), batch_size): batches.append(tasks[i:i+batch_size]) return batches"},{"question":"# Sudoku Solver You are tasked with implementing a Sudoku solver in Python that solves a given 9x9 Sudoku puzzle using a backtracking algorithm. Write a function that takes a partially completed Sudoku puzzle and returns the completed puzzle. # Requirements: 1. **Data Structure** - The puzzle is represented as a 2D list of integers, where empty cells are denoted by 0. - For example: ```python puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] ``` 2. **Solver Function** - Implement the function: ```python def solve_sudoku(puzzle: list[list[int]]) -> bool: ``` 3. **Helper Functions** - You may write helper functions as needed, such as: - `is_valid(puzzle: list[list[int]], row: int, col: int, num: int) -> bool` - `find_empty_location(puzzle: list[list[int]]) -> tuple[int, int] | None` # Constraints: - The given puzzle will always have a unique solution. - The function should modify the original puzzle in place and return `True` if the puzzle is successfully solved. - If the puzzle cannot be solved (which shouldn\'t be the case here), it should return `False`. # Example Usage: ```python if __name__ == \'__main__\': puzzle = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] if solve_sudoku(puzzle): for row in puzzle: print(row) else: print(\\"No solution exists.\\") ``` Implement the solver function and test it with various Sudoku puzzles to ensure it works correctly and efficiently.","solution":"def solve_sudoku(puzzle: list[list[int]]) -> bool: Solves the given Sudoku puzzle using backtracking algorithm. Modifies the puzzle in place and returns True if a solution is found. If the puzzle cannot be solved, returns False. empty_location = find_empty_location(puzzle) if not empty_location: return True # Puzzle is solved row, col = empty_location for num in range(1, 10): if is_valid(puzzle, row, col, num): puzzle[row][col] = num if solve_sudoku(puzzle): return True puzzle[row][col] = 0 # Backtrack return False def find_empty_location(puzzle: list[list[int]]) -> tuple[int, int] | None: Finds the next empty cell in the puzzle (denoted by 0). Returns a tuple (row, col) if an empty cell is found, or None if there are no empty cells. for i in range(9): for j in range(9): if puzzle[i][j] == 0: return (i, j) return None def is_valid(puzzle: list[list[int]], row: int, col: int, num: int) -> bool: Checks if placing the number `num` in the cell (row, col) is a valid move. Returns True if valid, else False. # Check row if any(puzzle[row][j] == num for j in range(9)): return False # Check column if any(puzzle[i][col] == num for i in range(9)): return False # Check 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) if any(puzzle[i][j] == num for i in range(start_row, start_row + 3) for j in range(start_col, start_col + 3)): return False return True"},{"question":"# Coding Assessment Question: Implement JSON Data Search and Export to CSV Objective Your task is to develop a feature that allows users to search through a local JSON file and export the search results to a CSV file. The JSON file contains a list of user data and their associated details. Requirements 1. **JSON Data**: The JSON file will contain an array of user objects with properties such as `id`, `name`, `email`, `age`, and `location`. 2. **Search Functionality**: Implement a search function that allows users to filter the data based on multiple fields (e.g., `name`, `email`, `age`, `location`). The search should support exact matches and partial matches. 3. **Export to CSV**: Once the data is filtered based on the search criteria, provide an option to export the results to a CSV file. 4. **Error Handling**: Ensure the function handles potential errors, such as an invalid search field or issues with reading/writing files. Input/Output Formats - **Input**: - JSON file path containing user data. - Search criteria as a dictionary (keys are field names, values are search terms). - **Output**: - A CSV file containing the search results. - A status message indicating success or failure of the operation. Performance Requirements - Efficiently handle large JSON files and ensure quick search operations. Implementation Steps 1. Load the JSON file into memory. 2. Implement the search function to filter users based on the given criteria. 3. Export the filtered results to a CSV file. 4. Include proper validation and error handling in the code. Scenario Consider a user management system where administrators need to find specific users based on certain criteria and export the found data for reporting or further analysis. For example, they might search for users located in a specific city who are within a certain age range and then need to export this list to a CSV file for additional processing. ```python import json import csv def search_users_and_export_to_csv(json_file_path, search_criteria, csv_file_path): try: # Load data from JSON file with open(json_file_path, \'r\') as file: data = json.load(file) # Filter data based on search criteria filtered_data = [] for user in data: match = True for key, value in search_criteria.items(): if key not in user or value.lower() not in str(user[key]).lower(): match = False break if match: filtered_data.append(user) if not filtered_data: return \\"No records found matching the search criteria.\\" # Export filtered data to CSV with open(csv_file_path, \'w\', newline=\'\') as csvfile: fieldnames = filtered_data[0].keys() writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for user in filtered_data: writer.writerow(user) return \\"Data successfully exported to CSV.\\" except FileNotFoundError: return \\"The specified JSON file could not be found.\\" except Exception as e: return f\\"An error occurred: {e}\\" # Example Usage: json_file_path = \'users.json\' search_criteria = { \'location\': \'New York\', \'age\': \'30\' } csv_file_path = \'filtered_users.csv\' status_message = search_users_and_export_to_csv(json_file_path, search_criteria, csv_file_path) print(status_message) ``` **Note**: Ensure that the specified JSON file exists and contains the required data structure. The search is case-insensitive and supports partial matches for string fields.","solution":"import json import csv def search_users_and_export_to_csv(json_file_path, search_criteria, csv_file_path): try: # Load data from JSON file with open(json_file_path, \'r\') as file: data = json.load(file) # Filter data based on search criteria filtered_data = [] for user in data: match = True for key, value in search_criteria.items(): if key not in user or value.lower() not in str(user[key]).lower(): match = False break if match: filtered_data.append(user) if not filtered_data: return \\"No records found matching the search criteria.\\" # Export filtered data to CSV with open(csv_file_path, \'w\', newline=\'\') as csvfile: fieldnames = filtered_data[0].keys() writer = csv.DictWriter(csvfile, fieldnames=fieldnames) writer.writeheader() for user in filtered_data: writer.writerow(user) return \\"Data successfully exported to CSV.\\" except FileNotFoundError: return \\"The specified JSON file could not be found.\\" except Exception as e: return f\\"An error occurred: {e}\\" # Example Usage: # json_file_path = \'users.json\' # search_criteria = { # \'location\': \'New York\', # \'age\': \'30\' # } # csv_file_path = \'filtered_users.csv\' # # status_message = search_users_and_export_to_csv(json_file_path, search_criteria, csv_file_path) # print(status_message)"},{"question":"# Spiral Matrix Traversal and Construction Scenario You are working at a company that specializes in image processing and transformations. One of your projects requires the capability to traverse and construct matrices in a spiral order. Your task is to write a function that constructs a matrix filled with integers from 1 to `n*m`, arranged in a spiral order. Problem Implement a function `spiral_matrix(n: int, m: int) -> List[List[int]]` that generates a 2D list (a matrix) of size `n` x `m`, filled with integers from 1 to `n*m` in a clockwise spiral order starting from the top-left cell moving to the right. Input - `n`: An integer representing the number of rows in the matrix. - `m`: An integer representing the number of columns in the matrix. Output - Return a 2D list (matrix) of size `n` x `m` filled with integers from 1 to `n*m` in a clockwise spiral order. Constraints - Both `n` and `m` are positive integers (1 ≤ n, m ≤ 100). Example ```python # A 3x3 spiral matrix: # [ # [1, 2, 3], # [8, 9, 4], # [7, 6, 5] # ] assert spiral_matrix(3, 3) == [ [1, 2, 3], [8, 9, 4], [7, 6, 5] ] # A 4x4 spiral matrix: # [ # [1, 2, 3, 4], # [12, 13, 14, 5], # [11, 16, 15, 6], # [10, 9, 8, 7] # ] assert spiral_matrix(4, 4) == [ [1, 2, 3, 4], [12, 13, 14, 5], [11, 16, 15, 6], [10, 9, 8, 7] ] # A 2x3 spiral matrix: # [ # [1, 2, 3], # [6, 5, 4] # ] assert spiral_matrix(2, 3) == [ [1, 2, 3], [6, 5, 4] ] # A 3x2 spiral matrix: # [ # [1, 2], # [6, 3], # [5, 4] # ] assert spiral_matrix(3, 2) == [ [1, 2], [6, 3], [5, 4] ] ``` Notes * Ensure your function builds the matrix in the specified spiral order. * Think about maintaining boundaries and changing directions when you reach the edge of the current boundary. Hint Use four boundaries (left, right, top, bottom) to keep track of the spiral\'s progression, and adjust these boundaries as you fill the matrix.","solution":"from typing import List def spiral_matrix(n: int, m: int) -> List[List[int]]: Generates a 2D list (matrix) of size n x m filled with integers from 1 to n*m in a clockwise spiral order. matrix = [[0] * m for _ in range(n)] num = 1 left, right, top, bottom = 0, m-1, 0, n-1 while left <= right and top <= bottom: # Traverse from left to right for i in range(left, right + 1): matrix[top][i] = num num += 1 top += 1 # Traverse from top to bottom for i in range(top, bottom + 1): matrix[i][right] = num num += 1 right -= 1 if top <= bottom: # Traverse from right to left for i in range(right, left - 1, -1): matrix[bottom][i] = num num += 1 bottom -= 1 if left <= right: # Traverse from bottom to top for i in range(bottom, top - 1, -1): matrix[i][left] = num num += 1 left += 1 return matrix"},{"question":"# Task Given a list of integers representing the profits from certain units sold, write a Python function `max_single_sell_profit(profits: List[int]) -> int` to determine the maximum profit that can be achieved by buying at one of the low points and selling at a later high point. # Function Signature ```python def max_single_sell_profit(profits: List[int]) -> int: pass ``` # Input * **profits**: A list of integers (p_1, p_2, ldots, p_n) (0 ≤ ( n leq 10,000)) where each integer represents the profit on that particular day. # Output * Returns the maximum possible profit that can be achieved by making a single buy-sell transaction. * If there\'s no profit possible, return 0. # Constraints * The function should efficiently handle the upper limit of the list size. * Implement the solution using a single traversal to achieve optimal time complexity. # Example Consider the list of profits: [7, 1, 5, 3, 6, 4]. The maximum profit can be achieved by buying at 1 and selling at 6. Therefore, the function should return 5. ```python >>> max_single_sell_profit([7, 1, 5, 3, 6, 4]) 5 ``` Consider another case where no profit is possible: [7, 6, 4, 3, 1]. Here, the function should return 0. ```python >>> max_single_sell_profit([7, 6, 4, 3, 1]) 0 ```","solution":"def max_single_sell_profit(profits): Returns the maximum possible profit that can be achieved by making a single buy-sell transaction. If no profit is possible, returns 0. if not profits: return 0 min_price = profits[0] max_profit = 0 for price in profits: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"# Coding Assessment Question Context Imagine you are building a feature for a social media platform where users can create and share posts. Each user\'s activity can be represented as a series of interactions (posts, comments, likes, etc.). The goal is to identify the top K users who have the highest level of activity on the platform. Objective Write a function to find the top K most active users based on a given activity log. Function Signature ```python def top_k_active_users(activity_log: list, k: int) -> list: Determines the top K most active users based on the activity log. Args: activity_log (list): A list of tuples representing user activity, where each tuple contains (username: str, activity_type: str). Example: [ (\\"user1\\", \\"post\\"), (\\"user2\\", \\"comment\\"), (\\"user1\\", \\"like\\"), ... ] k (int): The number of top active users to return. Returns: list: A list of the top K most active users sorted by their activity count in descending order. If two users have the same activity count, sort them alphabetically by username. If there are fewer than K distinct users, return all users sorted as described. pass ``` Input & Output * **Input**: The function takes a list representing the activity log and an integer representing the number of top active users to return. * `activity_log`: A list of tuples where each tuple consists of a user\'s username and the type of activity they performed. * `k`: An integer representing the number of top active users to return. * **Output**: The function should return a list of usernames representing the top K most active users sorted by their activity count in descending order. If there are fewer than K distinct users, return all users sorted as described. Constraints * The activity log may contain up to 100,000 entries. * Usernames are guaranteed to be alphanumeric and unique for each user. * The activity types are not constrained to a specific set of values. Example ```python activity_log = [ (\\"alice\\", \\"post\\"), (\\"bob\\", \\"comment\\"), (\\"alice\\", \\"like\\"), (\\"charlie\\", \\"post\\"), (\\"bob\\", \\"post\\"), (\\"charlie\\", \\"comment\\"), (\\"bob\\", \\"like\\"), (\\"alice\\", \\"comment\\") ] k = 2 assert top_k_active_users(activity_log, k) == [\\"alice\\", \\"bob\\"] ``` Performance Requirements * The implementation should efficiently handle an activity log with up to 100,000 entries.","solution":"from collections import Counter def top_k_active_users(activity_log: list, k: int) -> list: Determines the top K most active users based on the activity log. Args: activity_log (list): A list of tuples representing user activity, where each tuple contains (username: str, activity_type: str). Example: [ (\\"user1\\", \\"post\\"), (\\"user2\\", \\"comment\\"), (\\"user1\\", \\"like\\"), ... ] k (int): The number of top active users to return. Returns: list: A list of the top K most active users sorted by their activity count in descending order. If two users have the same activity count, sort them alphabetically by username. If there are fewer than K distinct users, return all users sorted as described. # Count the activities for each user user_activities = Counter(user for user, activity in activity_log) # Sort the users based on the count of activities and then alphabetically sorted_users = sorted(user_activities.items(), key=lambda x: (-x[1], x[0])) # Extract the top K users\' names top_users = [user for user, count in sorted_users[:k]] return top_users"},{"question":"**Scenario**: Strings are a fundamental data structure in many programming languages. In this problem, you are required to solve a variation of the classic palindrome problem—a palindrome is a string that reads the same forward and backward. The twist in this problem is that the input string can be modified by deleting some characters, and you need to determine the minimum number of deletions required to make it a palindrome. **Problem Statement**: Given a string `s`, write a function `min_deletions_to_palindrome` to determine the minimum number of deletions required to transform `s` into a palindrome. **Function Signature**: ```python def min_deletions_to_palindrome(s: str) -> int: pass ``` **Input**: - `s` (str): The input string. **Output**: - Return an integer representing the minimum number of deletions required to make `s` a palindrome. **Constraints**: 1. 1 <= len(s) <= 1000 2. `s` consists of lowercase English letters only. # Example: ```python # Example usage print(min_deletions_to_palindrome(\\"abca\\")) # Expected Output 1 print(min_deletions_to_palindrome(\\"racecar\\")) # Expected Output 0 print(min_deletions_to_palindrome(\\"google\\")) # Expected Output 2 ``` **Explanation**: 1. For the input \\"abca\\", deleting the character \'b\' will make it a palindrome (\\"aca\\"). Therefore, the minimum number of deletions required is 1. 2. For the input \\"racecar\\", it is already a palindrome, so no deletions are needed. 3. For the input \\"google\\", deleting the characters \'g\' and \'e\' will make it a palindrome (\\"goog\\"). Therefore, the minimum number of deletions required is 2.","solution":"def min_deletions_to_palindrome(s: str) -> int: Returns the minimum number of deletions required to transform s into a palindrome. def longest_palindromic_subsequence(s): n = len(s) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i + 1][j - 1] + 2 else: dp[i][j] = max(dp[i][j - 1], dp[i + 1][j]) return dp[0][n - 1] n = len(s) lps = longest_palindromic_subsequence(s) return n - lps"},{"question":"# Array Element Deletion based on Condition Context In this problem, you will implement a function that deletes elements from an array based on a set of conditions. This task is common in data preprocessing where certain data points must be filtered out before further analysis. Task Description You need to complete the function `delete_elements` which removes elements from an input array based on the conditions provided through a lambda function. The lambda function will be applied to each element of the array, and if it returns `True` for an element, that element will be removed from the array. Input - A numpy array `arr` of arbitrary shape containing real numbers. - A lambda function `condition` that takes a single argument and returns a boolean. Output - A numpy array containing the elements of the input array that do not meet the given condition. The shape of the resulting array may be different from the input array. Constraints - The function must utilize numpy for efficient element-wise operations. - The lambda function should be used directly without any alteration. - The function should work efficiently for large arrays. Examples ```python >>> import numpy as np >>> delete_elements(np.array([1, 2, 3, 4, 5]), lambda x: x > 3) array([1, 2, 3]) >>> delete_elements(np.array([10, -3, 4, 7, -5]), lambda x: x < 0) array([10, 4, 7]) >>> delete_elements(np.array([0.5, 2.3, -1.1, -0.8]), lambda x: x >= 0) array([-1.1, -0.8]) ```","solution":"import numpy as np def delete_elements(arr, condition): Removes elements from the numpy array `arr` based on the condition function. Parameters: - arr: numpy array of arbitrary shape containing real numbers. - condition: a lambda function that takes a single argument and returns a boolean. Returns: - A numpy array containing the elements of `arr` that do not meet the condition. return arr[~np.vectorize(condition)(arr)]"},{"question":"# Objective: To create a simple HTTP log parser that extracts and summarizes key information from server log entries. # Task: 1. Implement a `parse_log_entry` function that takes a log entry string and extracts the IP address, timestamp, HTTP method, URL, and HTTP status code. 2. Implement a `summarize_logs` function that processes a list of log entries, summarizes the total number of requests, the number of unique IPs, and the count of each HTTP status code. # Function Signatures: ```python def parse_log_entry(log_entry: str) -> dict: def summarize_logs(log_entries: list) -> dict: ``` # Input: For `parse_log_entry` function: * `log_entry` (str): a single line log entry in the format: `IP_address - - [timestamp] \\"HTTP_method URL HTTP_version\\" status_code bytes` For `summarize_logs` function: * `log_entries` (list): a list of log entry strings. # Output: For `parse_log_entry` function: * A dictionary with the following keys: `\\"ip\\"`, `\\"timestamp\\"`, `\\"method\\"`, `\\"url\\"`, and `\\"status_code\\"`. For `summarize_logs` function: * A dictionary with keys `\\"total_requests\\"`, `\\"unique_ips\\"`, and `\\"status_counts\\"`: * `\\"total_requests\\"`: Total number of log entries parsed. * `\\"unique_ips\\"`: Count of unique IP addresses found in the logs. * `\\"status_counts\\"`: A dictionary mapping each HTTP status code to the number of occurrences. # Requirements: 1. The `parse_log_entry` function should properly extract the IP address, timestamp, HTTP method, URL, and status code from a well-formatted log entry. 2. The `summarize_logs` function should correctly process the list of log entries and produce an accurate summary. # Constraints: * Log entries are assumed to be well-formed and valid. * Status codes are three-digit numbers. # Examples: ```python log_entry = \'127.0.0.1 - - [23/Mar/2023:23:59:59 +0000] \\"GET /index.html HTTP/1.1\\" 200 512\' parsed_entry = parse_log_entry(log_entry) # parsed_entry should be: # { # \\"ip\\": \\"127.0.0.1\\", # \\"timestamp\\": \\"23/Mar/2023:23:59:59 +0000\\", # \\"method\\": \\"GET\\", # \\"url\\": \\"/index.html\\", # \\"status_code\\": 200 # } log_entries = [ \'127.0.0.1 - - [23/Mar/2023:23:59:59 +0000] \\"GET /index.html HTTP/1.1\\" 200 512\', \'192.168.1.1 - - [24/Mar/2023:00:01:01 +0000] \\"POST /form.html HTTP/1.1\\" 404 256\' ] summary = summarize_logs(log_entries) # summary should be: # { # \\"total_requests\\": 2, # \\"unique_ips\\": 2, # \\"status_counts\\": { # 200: 1, # 404: 1 # } # } ``` # Additional Information: Implement a `main` function to: 1. Read a list of log entries from the user or from a predefined list. 2. Use the `summarize_logs` function to generate the summary. 3. Output the summary in a readable format.","solution":"import re from collections import defaultdict def parse_log_entry(log_entry): Parses a single log entry and returns a dictionary containing the IP address, timestamp, HTTP method, URL, and HTTP status code. pattern = r\'(?P<ip>d+.d+.d+.d+) - - [(?P<timestamp>[^]]+)] \\"(?P<method>S+) (?P<url>S+) HTTP/d+.d+\\" (?P<status_code>d+) d+\' match = re.match(pattern, log_entry) if match: return { \\"ip\\": match.group(\'ip\'), \\"timestamp\\": match.group(\'timestamp\'), \\"method\\": match.group(\'method\'), \\"url\\": match.group(\'url\'), \\"status_code\\": int(match.group(\'status_code\')) } return None def summarize_logs(log_entries): Summarizes a list of log entries and returns a dictionary with total requests, unique IPs, and status code counts. total_requests = len(log_entries) unique_ips = set() status_counts = defaultdict(int) for log_entry in log_entries: parsed_entry = parse_log_entry(log_entry) if parsed_entry: unique_ips.add(parsed_entry[\'ip\']) status_counts[parsed_entry[\'status_code\']] += 1 return { \\"total_requests\\": total_requests, \\"unique_ips\\": len(unique_ips), \\"status_counts\\": dict(status_counts) }"},{"question":"# Problem Statement In a fictional kingdom, the knights must complete a series of challenges to be promoted. One of these challenges involves solving a specific numerical problem: finding the number of unique ways to partition an integer `n` into a sum of distinct positive integers. Given an integer `n`, write a function `count_distinct_partitions(n)` that returns the number of unique ways to partition `n` into distinct positive integers. # Input and Output * **Input**: A single integer `n` (1 ≤ n ≤ 50) * **Output**: An integer representing the number of unique partitions of `n` into distinct positive integers. # Constraints * Each partition must consist of distinct (no repeated) positive integers. * The order of the integers in the partition does not matter (i.e., {1, 2, 3} is considered the same as {3, 2, 1}). # Example ```python count_distinct_partitions(5) ``` **Output**: ``` 3 ``` **Explanation**: There are three ways to partition 5 into distinct positive integers: 1. {1, 4} 2. {2, 3} 3. {5} # Task Write a function with the following signature: ```python def count_distinct_partitions(n: int) -> int: # Your code here pass ``` Implement this function to meet the requirements outlined above.","solution":"def count_distinct_partitions(n): Returns the count of distinct partitions of n :param n: integer :return: number of distinct partitions # We use dynamic programming to solve the problem partitions = [0] * (n + 1) partitions[0] = 1 # Base case: there is one way to partition zero # Generate all partitions sum for num in range(1, n + 1): # We move from n to num to add the last number `num` to the sums. for i in range(n, num - 1, -1): partitions[i] += partitions[i - num] return partitions[n]"},{"question":"# Reverse K Nodes in a Linked List Objective Your task is to implement a `reverse_k_nodes` function that reverses every k nodes in a given singly linked list. Requirements 1. Implement a function `reverse_k_nodes(head, k)` that takes the head of a singly linked list and an integer `k`. 2. The function should reverse every `k` nodes in the list. If the number of nodes is not a multiple of `k`, the remaining nodes at the end should remain in the original order. 3. The function should return the new head of the linked list after the reversal. Function Signature ```python class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_nodes(head: ListNode, k: int) -> ListNode: # Implement the function here ``` Example Let\'s define a linked list as follows: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8`. Calling `reverse_k_nodes(head, 3)` should reverse every 3 nodes: Before reversal: `1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8` After reversal: `3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8` Testing - Validate the functionality with various values of `k`. - Test edge cases such as: 1. `k` being 1 (no change to the list). 2. Small linked lists where `k` is greater than the length of the list. 3. A linked list with only one node. 4. Edge cases with `k` being equal to the length of the linked list. Example Code ```python # Utility function to print the linked list def print_list(head): while head: print(head.value, end=\\" -> \\") head = head.next print(\\"None\\") # Utility function to create a linked list from a list of values def create_linked_list(values): if not values: return None head = ListNode(values[0]) current = head for value in values[1:]: current.next = ListNode(value) current = current.next return head # Example usage: head = create_linked_list([1, 2, 3, 4, 5, 6, 7, 8]) print(\\"Original list:\\") print_list(head) head = reverse_k_nodes(head, 3) print(\\"Reversed list in groups of 3:\\") print_list(head) ``` Expected Output: ```shell Original list: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> None Reversed list in groups of 3: 3 -> 2 -> 1 -> 6 -> 5 -> 4 -> 7 -> 8 -> None ``` Ensure the function correctly reverses every k nodes and handles the specified edge cases.","solution":"class ListNode: def __init__(self, value=0, next=None): self.value = value self.next = next def reverse_k_nodes(head: ListNode, k: int) -> ListNode: if k <= 1 or not head: return head def reverse_list(start, end): prev, curr = None, start while curr != end: next_node = curr.next curr.next = prev prev = curr curr = next_node return prev dummy = ListNode(0) dummy.next = head prev_section_end = dummy while True: kth_node = prev_section_end for _ in range(k): kth_node = kth_node.next if not kth_node: return dummy.next section_start = prev_section_end.next section_end = kth_node.next kth_node.next = None prev_section_end.next = reverse_list(section_start, None) section_start.next = section_end prev_section_end = section_start"},{"question":"# Scenario: You are implementing a role-based access control system for a software application. Users are assigned roles, and each role has specific permissions. To ensure security and flexible permission assignment, you need to implement a method that verifies if a user has a required permission based on their role. # Task: Implement a function `has_permission` that checks if a user has a given permission based on their role and returns `True` or `False`. # Specifications: 1. The function signature is: ```python def has_permission( user_role: str, required_permission: str, role_permissions: dict ) -> bool: ``` 2. The function should: - Take `user_role` (a `str` indicating the user\'s role) and `required_permission` (a `str` indicating the permission to check). - `role_permissions` is a `dict` that maps each role (`str`) to a list of permissions (`list` of `str`). - Return `True` if the role has the required permission, otherwise return `False`. - Handle cases where the role or permission does not exist in the `role_permissions` dictionary. # Input: * `user_role`: A `str` representing the user\'s role. * `required_permission`: A `str` representing the permission to check. * `role_permissions`: A `dict` where keys are role names `str` and values are lists of permissions `list` of `str`. # Output: * A `bool` indicating whether the user role contains the required permission. # Constraints: * Role names and permissions are case-sensitive. # Examples: 1. `has_permission(\'admin\', \'delete_user\', {\'admin\': [\'create_user\', \'delete_user\'], \'user\': [\'view_profile\']})` should return `True`. 2. `has_permission(\'user\', \'delete_user\', {\'admin\': [\'create_user\', \'delete_user\'], \'user\': [\'view_profile\']})` should return `False`. 3. `has_permission(\'guest\', \'view_profile\', {\'admin\': [\'create_user\', \'delete_user\'], \'user\': [\'view_profile\']})` should return `False` because \'guest\' role does not exist. # Notes: * Ensure to handle cases where the user role or the required permission might not exist gracefully. Feel free to perform internal computations or define helper functions as needed to ensure the clarity and efficiency of your solution.","solution":"def has_permission( user_role: str, required_permission: str, role_permissions: dict ) -> bool: Checks if a user with a given role has the required permission. Parameters: user_role (str): The role of the user. required_permission (str): The permission to check. role_permissions (dict): A dictionary mapping roles to a list of their permissions. Returns: bool: True if the role has the required permission, False otherwise. if user_role in role_permissions: return required_permission in role_permissions[user_role] return False"},{"question":"# Coding Assessment Question Scenario A software company wants to enhance their inventory management system by adding a feature to track the quantity of items in warehouse storage. Your task is to write a function that computes the average quantity of items in storage over a given period. The function will take a list of integers representing the quantity of items in storage at the end of each month over a specific duration and will return the average quantity, rounded to 2 decimal places. Requirements * Write a function `average_inventory(quantities: List[int]) -> float` that performs the specified calculation. * Validate the input to ensure it meets the following constraints: - The list of quantities must not be empty. - All integers in the list must be non-negative. * You must raise appropriate exceptions if the input values do not meet the constraints. Expected Input and Output * **Input**: - `quantities` (List[int]): A list of integers representing the quantity of items at the end of each month. * **Output**: - (float): The average quantity of items in storage. Examples 1. `average_inventory([150, 200, 250, 300])` should return `225.00` 2. `average_inventory([100, 150, 200])` should return `150.00` 3. `average_inventory([])` should raise an `Exception` with the message \\"Quantities list must not be empty\\" 4. `average_inventory([100, -150, 200])` should raise an `Exception` with the message \\"Quantities must be non-negative\\" 5. `average_inventory([0, 0, 0, 0])` should return `0.00` Constraints * The function should return a floating-point number rounded to 2 decimal places. ***Write your function below:*** ```python from typing import List def average_inventory(quantities: List[int]) -> float: Calculate the average quantity of items in storage. :param quantities: List of integers representing the quantities at the end of each month. :return: The average quantity of items in storage. # Validate input if not quantities: raise Exception(\\"Quantities list must not be empty\\") if any(q < 0 for q in quantities): raise Exception(\\"Quantities must be non-negative\\") # Calculate average total_quantity = sum(quantities) num_months = len(quantities) average_quantity = total_quantity / num_months return round(average_quantity, 2) ```","solution":"from typing import List def average_inventory(quantities: List[int]) -> float: Calculate the average quantity of items in storage. :param quantities: List of integers representing the quantities at the end of each month. :return: The average quantity of items in storage, rounded to 2 decimal places. # Validate input if not quantities: raise Exception(\\"Quantities list must not be empty\\") if any(q < 0 for q in quantities): raise Exception(\\"Quantities must be non-negative\\") # Calculate average total_quantity = sum(quantities) num_months = len(quantities) average_quantity = total_quantity / num_months return round(average_quantity, 2)"},{"question":"# Coding Assessment Question You are developing a feature for a shopping cart application that calculates the total weight of items in the cart. Each item in the cart has a specified quantity and weight. Your task is to implement a function that calculates the total weight of the cart based on the quantities and weights provided. # Task Write a function `calculate_total_weight` that takes one parameter: - `items` (list of tuples): Each tuple contains two elements: - `quantity` (int): The number of units of the item. - `weight_per_unit` (float): The weight of one unit of the item in kilograms. The function should return the total weight of all items in the cart. Ensure that your function handles various edge cases such as zero or negative values for `quantity` and `weight_per_unit`. Function Signature ```python def calculate_total_weight(items: list) -> float: ``` Input/Output Formats * The input consists of: * `items`: A list of tuples, where each tuple contains two elements: * `quantity`: An integer representing the number of units of the item. * `weight_per_unit`: A float representing the weight of one unit of the item in kilograms. * The output is: * A float representing the total weight of the items in the cart. Constraints - 0 ≤ `quantity` ≤ 1000 - -100.0 ≤ `weight_per_unit` ≤ 1000.0 Performance Requirements - The calculation should be performed in linear time, O(n), where n is the number of items in the list. - The function should handle floating-point precision correctly. # Example ```python >>> calculate_total_weight([(2, 1.5), (3, 2.0), (5, 0.3)]) 10.5 >>> calculate_total_weight([(1, 0.5), (2, 1.75)]) 4.0 >>> calculate_total_weight([(0, 2.0), (3, 1.0)]) 3.0 >>> calculate_total_weight([(5, 0.0), (0, 1.0)]) 0.0 >>> calculate_total_weight([(2, -1.5), (3, -2.0)]) -9.0 ```","solution":"def calculate_total_weight(items: list) -> float: Given a list of (quantity, weight_per_unit) tuples, calculate the total weight of the items in the cart. total_weight = 0.0 for quantity, weight_per_unit in items: total_weight += quantity * weight_per_unit return total_weight"},{"question":"# Array Manipulation - Challenge You are tasked with implementing a series of array manipulation functions similar to the provided code snippets. Array manipulation allows you to perform operations directly on the elements of arrays, which can test your algorithmic skills and understanding of data structures. Functions to Implement: 1. `left_rotate(arr: list, d: int) -> list` - **Input**: - `arr` (list): A list of integers. - `d` (int): The number of positions to rotate the array to the left. - **Output**: A list of integers representing the array after being rotated `d` positions to the left. 2. `right_rotate(arr: list, d: int) -> list` - **Input**: - `arr` (list): A list of integers. - `d` (int): The number of positions to rotate the array to the right. - **Output**: A list of integers representing the array after being rotated `d` positions to the right. 3. `reverse_subarray(arr: list, start: int, end: int) -> list` - **Input**: - `arr` (list): A list of integers. - `start` (int): The starting index of the subarray to reverse. - `end` (int): The ending index of the subarray to reverse (inclusive). - **Output**: A list of integers representing the array after the specified subarray has been reversed. 4. `find_max(arr: list) -> int` - **Input**: - `arr` (list): A list of integers. - **Output**: An integer representing the maximum value in the array. 5. `find_min(arr: list) -> int` - **Input**: - `arr` (list): A list of integers. - **Output**: An integer representing the minimum value in the array. Additional Constraints: * You can assume that the `arr` will not be empty and will contain at least one element. * The `d` parameter for rotation will be a non-negative integer. * The `start` and `end` indices for reversing a subarray will be valid indices for the given `arr`. Performance Requirements: * Ensure the operations are efficient. Rotations should ideally be done in O(n) time complexity. * The `find_max` and `find_min` functions should have O(n) time complexity. Examples: ```python assert left_rotate([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert left_rotate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert right_rotate([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert right_rotate([1, 2, 3, 4, 5], 5) == [1, 2, 3, 4, 5] assert reverse_subarray([1, 2, 3, 4, 5], 1, 3) == [1, 4, 3, 2, 5] assert reverse_subarray([1, 2, 3, 4, 5], 0, 4) == [5, 4, 3, 2, 1] assert find_max([1, 2, 3, 4, 5]) == 5 assert find_max([-1, -2, -3, -4, -5]) == -1 assert find_min([1, 2, 3, 4, 5]) == 1 assert find_min([-1, -2, -3, -4, -5]) == -5 ``` Implement these functions correctly to handle the given constraints and requirements.","solution":"def left_rotate(arr, d): Rotates the array to the left by d positions. :param arr: List of integers :param d: Number of positions to rotate left :return: List of integers after rotation n = len(arr) d %= n # Handle cases where d >= n return arr[d:] + arr[:d] def right_rotate(arr, d): Rotates the array to the right by d positions. :param arr: List of integers :param d: Number of positions to rotate right :return: List of integers after rotation n = len(arr) d %= n # Handle cases where d >= n return arr[-d:] + arr[:-d] def reverse_subarray(arr, start, end): Reverses the subarray from index start to index end (inclusive). :param arr: List of integers :param start: Starting index of the subarray :param end: Ending index of the subarray :return: List of integers after the subarray is reversed return arr[:start] + arr[start:end+1][::-1] + arr[end+1:] def find_max(arr): Finds the maximum value in the array. :param arr: List of integers :return: Maximum value in the array return max(arr) def find_min(arr): Finds the minimum value in the array. :param arr: List of integers :return: Minimum value in the array return min(arr)"},{"question":"Scenario: You are part of a team responsible for building a recommendation engine for an online library. One critical feature is the ability to analyze user reading patterns effectively. You decide to implement this using a tree data structure to represent the hierarchy of book categories, where each node represents a category, and child nodes represent subcategories. **Task**: Implement a `CategoryTree` class with the following methods: 1. `add_category(self, parent_category: str, new_category: str) -> None`: This method should add a new subcategory under an existing parent category. 2. `find_path_to_category(self, start_category: str, target_category: str) -> list[str]`: This method should return a list representing the path from the `start_category` to the `target_category`, or an empty list if such a path doesn\'t exist. # Requirements: - **`add_category` Method:** - **Input**: `parent_category` and `new_category` (both strings) - **Output**: None - **`find_path_to_category` Method:** - **Input**: `start_category` and `target_category` (both strings) - **Output**: A list representing the sequence of categories from `start_category` to `target_category`, or an empty list if no such path exists. # Constraints: - The category tree might contain up to 100 nodes. - Categories are unique strings and case-insensitive. - The tree is represented as an acyclic connected graph (no cycles). **Function Signatures**: ```python class CategoryTree: def add_category(self, parent_category: str, new_category: str) -> None: pass def find_path_to_category(self, start_category: str, target_category: str) -> list[str]: pass ``` **Example**: ```python tree = CategoryTree() tree.add_category(\\"Books\\", \\"Fiction\\") tree.add_category(\\"Books\\", \\"Non-Fiction\\") tree.add_category(\\"Fiction\\", \\"Fantasy\\") tree.add_category(\\"Fiction\\", \\"Sci-Fi\\") tree.add_category(\\"Non-Fiction\\", \\"History\\") assert tree.find_path_to_category(\\"Books\\", \\"Sci-Fi\\") == [\\"Books\\", \\"Fiction\\", \\"Sci-Fi\\"] assert tree.find_path_to_category(\\"Non-Fiction\\", \\"Fantasy\\") == [] ``` # Notes: Ensure to handle edge cases, such as: - Adding a category to a non-existing parent. - Finding paths where either the start or target category doesn\'t exist. - The tree initially starts empty.","solution":"class CategoryTree: def __init__(self): self.tree = {} def add_category(self, parent_category: str, new_category: str) -> None: parent_category = parent_category.lower() new_category = new_category.lower() if parent_category not in self.tree: self.tree[parent_category] = [] self.tree[parent_category].append(new_category) if new_category not in self.tree: self.tree[new_category] = [] def find_path_to_category(self, start_category: str, target_category: str) -> list[str]: start_category = start_category.lower() target_category = target_category.lower() if start_category not in self.tree or target_category not in self.tree: return [] visited = set() path = [] def dfs(current, target): if current == target: path.append(current) return True visited.add(current) path.append(current) for neighbor in self.tree.get(current, []): if neighbor not in visited: if dfs(neighbor, target): return True path.pop() return False if dfs(start_category, target_category): return path else: return []"},{"question":"# Problem: Valid Parentheses with Stars Given a string containing only the characters `(`, `)`, and `*`, where a `*` can be treated as a single right parenthesis `)`, a single left parenthesis `(`, or an empty string, write an efficient algorithm to determine if the string can be made valid. # Task Implement the function `checkValidString(s: str) -> bool` which: - Takes a string `s` as input, consisting only of the characters `(`, `)`, and `*`. - Returns a boolean indicating whether the string can be made valid by replacing the `*` with characters `(`, `)`, or an empty string. # Input - `s` (1 ≤ len(s) ≤ 100): A string containing only characters `(`, `)`, and `*`. # Output - A boolean value. `True` if the string can be made valid, `False` otherwise. # Constraints - The algorithm should efficiently handle the upper limit of input size. # Examples - `checkValidString(\\"()\\")` should return `True`. - `checkValidString(\\"(*)\\")` should return `True`. - `checkValidString(\\"(*))\\")` should return `True`. - `checkValidString(\\"((*)\\")` should return `True`. - `checkValidString(\\"(\\")` should return `False`. # Explanation A valid string consists of balanced parenthesis pairs. The `*` characters can be used flexibly to balance any unmatched parentheses. # Hints - Think about maintaining the possible ranges of unmatched left parentheses through the sequence. - Try simulating the parsing with bounds to accommodate the flexibility provided by `*`. # Pseudocode Here\'s a conceptual outline to help understand the validation process: ``` def checkValidString(s: str) -> bool: low = 0 high = 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': low -= 1 high -= 1 else: # char == \'*\' low -= 1 high += 1 if high < 0: return False low = max(low, 0) return low == 0 ``` - Maintain two counters `low` and `high` to track the smallest and largest possible counts of unmatched left parentheses. - Adjust these counters based on the character encountered. - Ensure that all unmatched parentheses can potentially be matched by the replacements of `*`. Implement the logic in your function to ensure correctness for all edge cases.","solution":"def checkValidString(s: str) -> bool: Returns whether the string `s` can be made into a valid string by replacing \'*\' with \'(\', \')\' or an empty string. low = 0 high = 0 for char in s: if char == \'(\': low += 1 high += 1 elif char == \')\': low -= 1 high -= 1 elif char == \'*\': low -= 1 high += 1 if high < 0: return False low = max(low, 0) return low == 0"},{"question":"Problem Statement You are given a list of integers, and you are to implement a function that partitions this list into two non-empty sub-arrays such that the difference between the sum of the elements in the first sub-array and the sum of the elements in the second sub-array is minimized. # Function to Implement ```python def partition_array(arr): Partition the array into two non-empty sub-arrays with the minimum difference in their sums. @param arr: A list of integers to be partitioned. @return: A tuple of two lists representing the sub-arrays with the minimum difference in their sums. # Your code here pass ``` # Input and Output Formats Input - `arr`: A list of integers with at least 2 elements. Output - A tuple of two lists, each representing one of the sub-arrays. The order of elements in the sub-arrays does not matter. # Constraints - The length of the input list `arr` will be between 2 and 100 inclusive. - Each integer in the list will be between -1000 and 1000 inclusive. # Example ```python # Example Input: arr = [1, 2, 3, 4, 5] # Example Output: # (Note: The output can vary as long as the difference between the sums is minimized) ([1, 4, 5], [2, 3]) # Example Input: arr = [10, -10, 5, -5] # Example Output: # (Note: The output can vary as long as the difference between the sums is minimized) ([10, -10], [5, -5]) ``` # Notes - The goal is to find a partition that minimizes the absolute difference between the sums of the two sub-arrays. - There can be multiple valid solutions; any of them will be accepted as long as the difference in sums is minimal.","solution":"def partition_array(arr): Partition the array into two non-empty sub-arrays with the minimum difference in their sums. @param arr: A list of integers to be partitioned. @return: A tuple of two lists representing the sub-arrays with the minimum difference in their sums. import itertools total_sum = sum(arr) n = len(arr) min_diff = float(\'inf\') best_partition = ([], []) for i in range(1, n): for combo in itertools.combinations(arr, i): subset_sum = sum(combo) other_sum = total_sum - subset_sum diff = abs(subset_sum - other_sum) if diff < min_diff: min_diff = diff best_partition = (list(combo), list(set(arr) - set(combo))) return best_partition"},{"question":"# Question: Implement a Custom HashMap with Collision Handling using Separate Chaining Design and implement a simplified version of a HashMap (also known as a hash table) from scratch. Your implementation should handle hash collisions using the separate chaining technique, where each bucket in the hash table is a linked list. Requirements: 1. **Class**: `CustomHashMap` with the following methods: - `__init__(self, size: int)`: Initializes the hash table with a specified number of buckets. - `put(self, key: int, value: int)`: Inserts a key-value pair into the hash table. If the key already exists, update the value. - `get(self, key: int) -> int`: Retrieves the value associated with the key. Returns `None` if the key is not found. - `remove(self, key: int)`: Removes the key-value pair from the hash table if it exists. 2. **Constraints**: - The hash function should be a simple modulus operation (`key % size`). - Handle key collisions using the separate chaining technique with linked lists. - Handle scenarios where the hash table might be empty or have a small number of buckets effectively. 3. **Performance**: - Aim to ensure average-case time complexity remains efficient for `put`, `get`, and `remove` operations. - Avoid using additional data structures beyond linked lists for collision handling. ```python class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.next = None class CustomHashMap: def __init__(self, size: int): Initialize the hash table with a given number of buckets. :param size: The number of buckets in the hash table. self.size = size self.buckets = [None] * size def put(self, key: int, value: int): Insert a key-value pair into the hash table. :param key: The key to insert. :param value: The value to associate with the key. index = key % self.size if self.buckets[index] is None: self.buckets[index] = Node(key, value) else: current = self.buckets[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) def get(self, key: int) -> int: Retrieve the value associated with the key. :param key: The key to search for. :return: The value associated with the key, or None if the key is not found. index = key % self.size current = self.buckets[index] while current is not None: if current.key == key: return current.value current = current.next return None def remove(self, key: int): Remove the key-value pair from the hash table. :param key: The key to remove. index = key % self.size current = self.buckets[index] if current is None: return if current.key == key: self.buckets[index] = current.next return prev = None while current is not None: if current.key == key: prev.next = current.next return prev = current current = current.next if __name__ == \\"__main__\\": # Example usage hashmap = CustomHashMap(10) hashmap.put(1, 10) hashmap.put(2, 20) hashmap.put(11, 110) assert hashmap.get(1) == 10 assert hashmap.get(2) == 20 assert hashmap.get(11) == 110 hashmap.remove(1) assert hashmap.get(1) is None assert hashmap.get(2) == 20 ``` # Explanation: - This question asks the candidate to implement a custom HashMap using separate chaining for handling collisions. - The prompt ensures that the candidate has to create their own data structure, rather than relying on built-in libraries like `dict`. - There are constraints around which collision handling technique to use and how to implement basic operations such as insertions, lookups, and deletions. - The sample provided includes method signatures and an example usage to guide the implementer.","solution":"class Node: def __init__(self, key: int, value: int): self.key = key self.value = value self.next = None class CustomHashMap: def __init__(self, size: int): Initialize the hash table with a given number of buckets. :param size: The number of buckets in the hash table. self.size = size self.buckets = [None] * size def put(self, key: int, value: int): Insert a key-value pair into the hash table. :param key: The key to insert. :param value: The value to associate with the key. index = key % self.size if self.buckets[index] is None: self.buckets[index] = Node(key, value) else: current = self.buckets[index] while True: if current.key == key: current.value = value return if current.next is None: break current = current.next current.next = Node(key, value) def get(self, key: int) -> int: Retrieve the value associated with the key. :param key: The key to search for. :return: The value associated with the key, or None if the key is not found. index = key % self.size current = self.buckets[index] while current is not None: if current.key == key: return current.value current = current.next return None def remove(self, key: int): Remove the key-value pair from the hash table. :param key: The key to remove. index = key % self.size current = self.buckets[index] if current is None: return if current.key == key: self.buckets[index] = current.next return prev = None while current is not None: if current.key == key: prev.next = current.next return prev = current current = current.next"},{"question":"# Problem Statement You are working on a project for a logistics company that involves optimizing their delivery routes. One key feature of the application is to find the shortest path between two delivery points in a city represented as a grid, where some cells are impassable due to obstacles. Write a function `shortest_path(grid: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> int` that takes a 2D list of integers representing the grid, a starting point, and an ending point. The function should return the minimum number of steps required to reach the ending point from the starting point. If it is not possible to reach the endpoint, the function should return -1. # Input * `grid`: A 2D list of integers where `0` represents a passable cell and `1` represents an impassable cell. * `start`: A tuple `(x, y)` representing the starting point coordinates in the grid. * `end`: A tuple `(x, y)` representing the ending point coordinates in the grid. # Output * An integer representing the minimum number of steps required to reach the ending point from the starting point, or `-1` if it is not possible. # Constraints * The grid will have at least one cell and at most 10^4 cells in total. * Start and end points will always be within the bounds of the grid. * The grid may contain only `0`s and `1`s. * Start and end points will always be located at a `0`. # Example Usage ```python # Example 1 print(shortest_path([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 1, 0], [0, 0, 0, 0]], (0, 0), (3, 3))) # Output: 6 # Example 2 print(shortest_path([[0, 1], [1, 0]], (0, 0), (1, 1))) # Output: -1 # Example 3 print(shortest_path([[0]], (0, 0), (0, 0))) # Output: 0 # Example 4 print(shortest_path([[0, 0, 0], [0, 1, 0], [0, 1, 0], [0, 0, 0]], (0, 0), (3, 2))) # Output: 5 ``` # Performance Requirement * The solution should efficiently handle grids up to 10^4 cells in total. * The solution should use BFS (Breadth-First Search) or similar algorithms suitable for shortest path problems in unweighted grids, achieving a time complexity of O(n) where n is the number of cells in the grid.","solution":"from collections import deque def shortest_path(grid, start, end): Find the shortest path in a grid from start to end. Parameters: grid (list[list[int]]): The grid where 0 is passable and 1 is impassable. start (tuple[int, int]): The starting point coordinates. end (tuple[int, int]): The ending point coordinates. Returns: int: The minimum number of steps required to reach the ending point from the starting point, or -1 if not possible. if start == end: return 0 rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right # Initialize queue for BFS and set starting point queue = deque([(start[0], start[1], 0)]) # (x, y, step_count) visited = set() visited.add((start[0], start[1])) while queue: x, y, steps = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == end: return steps + 1 queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1"},{"question":"# Problem Statement Scenario Sarah is playing a game where she rolls a single 12-sided die and checks if the result is a prime number. She repeats this process `N` times, where `N` is an integer provided as input to the function. Your task is to write a function `prime_roll_probability(N)` that returns the probability, rounded to seven decimal places, that at least one of the `N` rolls results in a prime number. Function Signature ```python def prime_roll_probability(N: int) -> float: pass ``` Inputs and Outputs * The function takes a single integer `N` (1 ≤ N ≤ 10^6) as an input. * The function returns a float, representing the probability rounded to seven decimal places. Example ```python assert abs(prime_roll_probability(1) - 0.3333333) < 1e-7 assert abs(prime_roll_probability(2) - 0.5555556) < 1e-7 assert abs(prime_roll_probability(3) - 0.7037037) < 1e-7 ``` Constraints 1. The number of times Sarah rolls the 12-sided die (N) can be as large as 1,000,000. 2. Ensure the probability output is accurate to seven decimal places. Prime Numbers on a 12-sided Die - The prime numbers between 1 and 12 are 2, 3, 5, 7, and 11. - Therefore, the probability of rolling a prime number on a single roll is 5/12. # Performance Requirements * The function should execute efficiently even for large values of `N`.","solution":"def prime_roll_probability(N: int) -> float: Calculate the probability that at least one of the N rolls of a 12-sided die results in a prime number. The prime numbers between 1 and 12 are 2, 3, 5, 7, and 11. Therefore, the probability of rolling a prime number on a single roll is 5/12. We can use the complement rule to find the probability of at least one prime number in N rolls. # Probability of rolling a non-prime number in a single roll p_non_prime = 7 / 12 # Probability of not rolling a prime number in N rolls p_no_prime_in_N = p_non_prime ** N # Probability of at least one prime number in N rolls p_at_least_one_prime_in_N = 1 - p_no_prime_in_N # Return the result rounded to 7 decimal places return round(p_at_least_one_prime_in_N, 7)"},{"question":"# Secure Encoding and Decoding Problem Statement You are required to create a secure encoding and decoding mechanism for messages. The encoding should perform a series of character shifts within the ASCII printable characters range, followed by a reversible transformation to ensure message integrity. Your task is to implement two functions: ```python def encode_message(message: str, shift: int) -> str: pass def decode_message(encoded_message: str, shift: int) -> str: pass ``` - **Input**: - `message` (type: `str`): The original message to be encoded. - `encoded_message` (type: `str`): The encoded message to be decoded. - `shift` (type: `int`): An integer value that defines the number of positions each character in the message is shifted. The same shift value used for encoding should be used for decoding. - **Output**: - `encode_message` should return a string that represents the encoded message. - `decode_message` should return the original message after decoding the `encoded_message`. Constraints - The shift value will always be a positive integer. - The message will only contain printable ASCII characters (characters with ASCII values from 32 to 126 inclusive). - You must handle edge cases such as an empty string or a very large shift value. - Ensure that the reverse transformation in decoding properly retrieves the original message without data loss. Examples ```python # Example 1: message = \\"Hello, World!\\" shift = 5 encoded_message = encode_message(message, shift) assert encoded_message == \\"Mjqqt1%twqi&\\" decoded_message = decode_message(encoded_message, shift) assert decoded_message == message # Example 2: message = \\"Secure123!\\" shift = 10 encoded_message = encode_message(message, shift) assert encoded_message == \']}mqu~{?\\"#\' decoded_message = decode_message(encoded_message, shift) assert decoded_message == message # Example 3: message = \\"ASCII Test!\\" shift = 95 encoded_message = encode_message(message, shift) assert encoded_message == \\"ASCII Test!\\" decoded_message = decode_message(encoded_message, shift) assert decoded_message == message ``` Note - Printable ASCII characters range from 32 (space) to 126 (tilde \'~\'). - Use modular arithmetic to handle shifts that exceed the bounds of printable ASCII values. - It is guaranteed that the shift value will be within the bounds required for the encoding and decoding process.","solution":"def encode_message(message: str, shift: int) -> str: Encodes the given message by shifting each character within the ASCII printable range by the specified shift. encoded_chars = [] for char in message: new_char = chr(((ord(char) - 32 + shift) % 95) + 32) encoded_chars.append(new_char) return \'\'.join(encoded_chars) def decode_message(encoded_message: str, shift: int) -> str: Decodes the given encoded message by reversing the shift operation. decoded_chars = [] for char in encoded_message: new_char = chr(((ord(char) - 32 - shift) % 95) + 32) decoded_chars.append(new_char) return \'\'.join(decoded_chars)"},{"question":"# Question **Context**: String manipulation is a fundamental skill in programming, used extensively in data cleaning, text analysis, and user input processing. In this task, you will manipulate a string to remove all duplicate characters while preserving their first occurrence and the original character order. Task Write a function `remove_duplicates(s: str) -> str` which returns a new string with all duplicate characters removed from the input string `s`. The function should maintain the order of the characters as they first appear in the string. Input - `s` (str): A string of lowercase and uppercase English letters. Output - A new string with duplicates removed, preserving the order of their first appearance. - Raise a `TypeError` if `s` is not a string. Constraints - The input string `s` will contain at most 10^5 characters. Examples ```python assert remove_duplicates(\\"banana\\") == \\"ban\\" assert remove_duplicates(\\"hello\\") == \\"helo\\" assert remove_duplicates(\\"abcdabcd\\") == \\"abcd\\" assert remove_duplicates(\\"aAaAaA\\") == \\"aA\\" assert remove_duplicates(\\"\\") == \\"\\" ``` Additional Notes - Implement the function efficiently, taking into consideration the time and space complexity. - Consider edge cases such as an empty string and very large input.","solution":"def remove_duplicates(s: str) -> str: Returns a new string with all duplicate characters removed from the input string s. The function maintains the order of characters as they first appear in the input string. Parameters: s (str): A string of lowercase and uppercase English letters. Returns: str: A new string with duplicates removed. Raises: TypeError: If s is not a string. if not isinstance(s, str): raise TypeError(\\"Input must be a string\\") seen = set() result = [] for char in s: if char not in seen: seen.add(char) result.append(char) return \'\'.join(result)"},{"question":"# Matrix Decomposition using Cholesky **Context:** You are required to write a function to compute the Cholesky decomposition of a symmetric, positive-definite matrix. This operation is crucial in numerical analysis for efficient solving of linear systems, inversion of matrices, and simulation of multivariate Gaussian distributions. **Problem Statement:** Implement a function `cholesky_decomposition` that performs Cholesky decomposition on a given square matrix (X). The function should output a lower triangular matrix (L) such that (X = L times L^T). ```python def cholesky_decomposition(matrix: np.ndarray) -> np.ndarray: pass ``` **Function Definition:** * **Input**: * `matrix` (np.ndarray): Symmetric, positive-definite matrix to decompose. * **Output**: * Returns np.ndarray: The lower triangular matrix (L). **Constraints**: 1. The input matrix must be square (n x n). 2. The matrix must be symmetric and positive-definite. 3. Handle scenarios where the input matrix is not positive-definite by raising an appropriate error. **Edge Cases to Consider**: 1. Non-square matrix. 2. Matrix that is not positive-definite (e.g., containing negative eigenvalues). 3. Corner cases for very small matrices like 1x1 and exceptions where decomposition fails due to non-positive-definiteness. # Example: ```python import numpy as np matrix = np.array([[4, 2, 2], [2, 2, 1], [2, 1, 2]]) print(cholesky_decomposition(matrix)) # Output: array([[2. 0. 0.] # [1. 1. 0.] # [1. 0. 1.]]) ``` **Verification**: Create a unit test class `TestCholeskyDecomposition` with methods to thoroughly test the `cholesky_decomposition` function covering regular cases, non-square matrices, non-positive-definite matrices, and minimal valid scenarios. ```python import unittest class TestCholeskyDecomposition(unittest.TestCase): def test_cholesky_decomposition(self): matrix = np.array([[4, 2, 2], [2, 2, 1], [2, 1, 2]]) result = cholesky_decomposition(matrix) expected = np.array([[2., 0., 0.], [1., 1., 0.], [1., 0., 1.]]) np.testing.assert_array_equal(result, expected) def test_non_square_matrix(self): matrix = np.array([[4, 2, 2], [2, 2, 1]]) with self.assertRaises(ValueError): cholesky_decomposition(matrix) def test_non_positive_definite_matrix(self): matrix = np.array([[1, 2], [2, 1]]) with self.assertRaises(np.linalg.LinAlgError): cholesky_decomposition(matrix) def test_1x1_matrix(self): matrix = np.array([[4]]) result = cholesky_decomposition(matrix) expected = np.array([[2.]]) np.testing.assert_array_equal(result, expected) if __name__ == \'__main__\': unittest.main() ```","solution":"import numpy as np def cholesky_decomposition(matrix: np.ndarray) -> np.ndarray: Perform Cholesky decomposition on a symmetric, positive-definite matrix. Args: matrix (np.ndarray): Symmetric, positive-definite matrix to decompose. Returns: np.ndarray: The lower triangular matrix L such that X = L @ L.T Raises: ValueError: If the input matrix is not square. np.linalg.LinAlgError: If the matrix is not positive-definite. if matrix.shape[0] != matrix.shape[1]: raise ValueError(\\"The input matrix must be square (n x n).\\") try: # Perform Cholesky decomposition L = np.linalg.cholesky(matrix) except np.linalg.LinAlgError as e: raise np.linalg.LinAlgError(\\"The matrix is not positive-definite.\\") from e return L"},{"question":"# Question: Efficiently Manage File Metadata in a Cloud Storage System Context: You are developing a cloud storage system that needs to manage and query metadata for a vast number of files efficiently. Each file has associated metadata that includes the file name, size, creation date, and tags. The system should provide functionality to add, update, delete, and query this metadata. Additionally, you need to implement a search functionality that allows querying files by their tags and size. Requirements: 1. **Class Definition**: - Create a class `FileManager` that supports the following operations: - `add_file(filename: str, size: int, creation_date: str, tags: list[str]) -> None` - `update_file(filename: str, size: int = None, creation_date: str = None, tags: list[str] = None) -> None` - `delete_file(filename: str) -> None` - `search_by_tags(tags: list[str]) -> list[str]` - `search_by_size(min_size: int, max_size: int) -> list[str]` 2. **Input and Output Formats**: - Methods accept inputs as specified in the signatures. - `add_file`, `update_file`, and `delete_file` do not return any value. - `search_by_tags` and `search_by_size` return a list of filenames that match the search criteria. 3. **Constraints**: - Filenames are unique and case-sensitive. - The file size is always a positive integer. - The creation date is given as a string in the format \\"YYYY-MM-DD\\". - Tags are a list of strings, where each tag is case-sensitive. - Implement error handling for cases such as adding a file that already exists, updating or deleting a file that does not exist, and invalid data formats. 4. **Performance Requirements**: - Your solution should run efficiently with a time complexity of O(1) for add, update, and delete operations, and O(n) for search operations where n is the number of files. - Optimize for space by storing metadata in an efficient structure. Example Usage: ```python fm = FileManager() # Adding files fm.add_file(\\"file1.txt\\", 100, \\"2023-08-01\\", [\\"important\\", \\"work\\"]) fm.add_file(\\"file2.jpg\\", 2000, \\"2023-07-15\\", [\\"personal\\", \\"photos\\"]) fm.add_file(\\"file3.pdf\\", 500, \\"2023-06-20\\", [\\"work\\", \\"report\\"]) # Updating file metadata fm.update_file(\\"file1.txt\\", tags=[\\"important\\", \\"work\\", \\"urgent\\"]) # Searching for files assert fm.search_by_tags([\\"work\\"]) == [\\"file1.txt\\", \\"file3.pdf\\"] assert fm.search_by_size(100, 500) == [\\"file1.txt\\", \\"file3.pdf\\"] # Deleting a file fm.delete_file(\\"file2.jpg\\") # Example error handling try: fm.add_file(\\"file1.txt\\", 150, \\"2023-08-05\\", [\\"duplicate\\"]) except ValueError as e: print(e) # Output: File already exists try: fm.delete_file(\\"file_not_exists.txt\\") except ValueError as e: print(e) # Output: File does not exist ``` Instructions: 1. Create the `FileManager` class with the specified methods. 2. Implement the add, update, and delete functionalities ensuring unique filenames are handled correctly. 3. Implement the search functionalities to find files by tags and size range. 4. Ensure that your implementation is efficient and handles edge cases gracefully. 5. Test your code thoroughly with the provided assertions and additional test cases.","solution":"class FileManager: def __init__(self): self.files = {} def add_file(self, filename: str, size: int, creation_date: str, tags: list[str]) -> None: if filename in self.files: raise ValueError(\\"File already exists\\") self.files[filename] = {\\"size\\": size, \\"creation_date\\": creation_date, \\"tags\\": set(tags)} def update_file(self, filename: str, size: int = None, creation_date: str = None, tags: list[str] = None) -> None: if filename not in self.files: raise ValueError(\\"File does not exist\\") if size is not None: self.files[filename][\\"size\\"] = size if creation_date is not None: self.files[filename][\\"creation_date\\"] = creation_date if tags is not None: self.files[filename][\\"tags\\"] = set(tags) def delete_file(self, filename: str) -> None: if filename not in self.files: raise ValueError(\\"File does not exist\\") del self.files[filename] def search_by_tags(self, tags: list[str]) -> list[str]: matching_files = [] tags_set = set(tags) for filename, metadata in self.files.items(): if tags_set.issubset(metadata[\\"tags\\"]): matching_files.append(filename) return matching_files def search_by_size(self, min_size: int, max_size: int) -> list[str]: matching_files = [] for filename, metadata in self.files.items(): if min_size <= metadata[\\"size\\"] <= max_size: matching_files.append(filename) return matching_files"},{"question":"# Palindrome Permutation Check Scenario You are tasked with developing a feature for a text editor that checks whether any permutation of a given string can form a palindrome. This feature will help in identifying strings that have the potential to be rearranged into a palindromic sequence, which might be useful for certain operations like encoding or pattern recognition. Task Write a function `can_form_palindrome(s: str) -> bool` that takes a single string input `s` and returns a boolean indicating if any permutation of the string can form a palindrome. A string can be rearranged to form a palindrome if the frequency of each character either: 1. Occurs an even number of times, or 2. At most one character has an odd frequency (for the center position in palindromes of odd length). Constraints 1. The string will contain only printable ASCII characters and will be at most length (10^5). 2. The function should run efficiently with a time complexity of O(n), where n is the length of the string. Function Signature ```python def can_form_palindrome(s: str) -> bool: pass ``` Example Test Cases ```python # Valid palindrome permutations assert can_form_palindrome(\\"aabb\\") == True # \\"abba\\", \\"baab\\" assert can_form_palindrome(\\"racecar\\") == True # \\"racecar\\", \\"rcaecar\\" # Invalid palindrome permutations assert can_form_palindrome(\\"abcdef\\") == False assert can_form_palindrome(\\"aabc\\") == False ``` Implement the function `can_form_palindrome` based on the above criteria and ensure it passes the provided test cases.","solution":"from collections import Counter def can_form_palindrome(s: str) -> bool: Returns True if any permutation of the string s can form a palindrome. A string can be rearranged to form a palindrome if the frequency of each character either: 1. Occurs an even number of times, or 2. At most one character has an odd frequency (for the center position in palindromes of odd length). # Count the frequency of each character in the string char_count = Counter(s) # A variable to count the number of characters with odd frequencies odd_count = 0 # Check the frequency of each character for count in char_count.values(): if count % 2 == 1: odd_count += 1 # More than one character with an odd frequency means it cannot form a palindrome if odd_count > 1: return False # If we have at most one character with an odd frequency, it can form a palindrome return True"},{"question":"# Coding Assessment Question You are to implement a function that finds the first pair of numbers in a list that adds up to a specified target sum. The function should return the indices of these two numbers. Task Write a function `find_pair_with_sum(numbers: List[int], target: int) -> Optional[Tuple[int, int]]`. Given a list of integers and a target sum, the function should return a tuple containing the indices of the first pair of numbers that add up to the target sum. If no such pair exists, return `None`. Input * `numbers` is a list of integers. * `target` is an integer representing the target sum. Output * Returns a tuple of two integers representing the indices of the first two numbers that add up to the target sum. If no such numbers are found, return `None`. Example ```python numbers = [2, 7, 11, 15] target = 9 result = find_pair_with_sum(numbers, target) # Expected output: (0, 1) numbers = [3, 2, 4] target = 6 result = find_pair_with_sum(numbers, target) # Expected output: (1, 2) numbers = [3, 3] target = 6 result = find_pair_with_sum(numbers, target) # Expected output: (0, 1) numbers = [1, 2, 3, 4, 5] target = 10 result = find_pair_with_sum(numbers, target) # Expected output: None ``` Constraints * All input numbers are integers. * The size of the input list does not exceed 10^4. * Try to achieve an optimal time complexity. Notes * Consider using a hash table to keep track of the numbers and their indices for optimal performance.","solution":"from typing import List, Optional, Tuple def find_pair_with_sum(numbers: List[int], target: int) -> Optional[Tuple[int, int]]: Finds the first pair of numbers in a list that adds up to a specified target sum. Parameters: numbers (List[int]): The list of integers. target (int): The target sum. Returns: Optional[Tuple[int, int]]: A tuple containing the indices of the two numbers that add up to the target sum, or None if no such pair exists. num_to_index = {} for index, num in enumerate(numbers): complement = target - num if complement in num_to_index: return num_to_index[complement], index num_to_index[num] = index return None"},{"question":"# Question: Design a Parking Lot Management System Create a system to manage a parking lot with multiple levels and vehicles of different sizes. Vehicles can either be cars or motorcycles. The parking lot should be able to: 1. Track the occupancy on each level. 2. Support parking and retrieving vehicles. 3. Ensure vehicles are parked in appropriate spots based on their size. # Function Definitions: ```python class Vehicle: def __init__(self, license_plate: str, size: str) -> None: self.license_plate = license_plate self.size = size class ParkingSpot: def __init__(self, spot_id: int, size: str) -> None: self.spot_id = spot_id self.size = size self.is_free = True self.vehicle = None class Level: def __init__(self, level_id: int, num_spots: int, motorcycle_spots: int) -> None: self.level_id = level_id self.spots = [ParkingSpot(i, \\"motorcycle\\" if i < motorcycle_spots else \\"car\\") for i in range(num_spots)] def find_free_spot(self, vehicle_size: str) -> int: \'\'\' Find a free spot suitable for the vehicle size. Args: vehicle_size (str): \\"car\\" or \\"motorcycle\\". Returns: int: Spot ID of the free spot. Returns -1 if no suitable spot is found. \'\'\' pass def park_vehicle(self, vehicle: Vehicle) -> bool: \'\'\' Park a vehicle in an appropriate free spot. Args: vehicle (Vehicle): The vehicle to park. Returns: bool: True if the vehicle was successfully parked, False otherwise. \'\'\' pass def retrieve_vehicle(self, license_plate: str) -> bool: \'\'\' Retrieve a vehicle from its spot based on the license plate. Args: license_plate (str): License plate of the vehicle to retrieve. Returns: bool: True if the vehicle was successfully retrieved, False otherwise. \'\'\' pass class ParkingLot: def __init__(self, num_levels: int, spots_per_level: int, motorcycle_spots_per_level: int) -> None: self.levels = [Level(i, spots_per_level, motorcycle_spots_per_level) for i in range(num_levels)] def park_vehicle(self, vehicle: Vehicle) -> bool: \'\'\' Park a vehicle in the parking lot. Args: vehicle (Vehicle): The vehicle to park. Returns: bool: True if the vehicle was successfully parked, False otherwise. \'\'\' pass def retrieve_vehicle(self, license_plate: str) -> bool: \'\'\' Retrieve a vehicle from the parking lot. Args: license_plate (str): License plate of the vehicle to retrieve. Returns: bool: True if the vehicle was successfully retrieved, False otherwise. \'\'\' pass ``` Input Format: 1. For `park_vehicle`: `(vehicle)` where `vehicle` is an instance of the `Vehicle` class with attributes `license_plate` (string) and `size` (either \\"car\\" or \\"motorcycle\\"). 2. For `retrieve_vehicle`: `(license_plate)` where `license_plate` is the string identifier of the vehicle to be retrieved. Output Format: 1. For `park_vehicle`: Returns `True` if parking was successful, `False` otherwise. 2. For `retrieve_vehicle`: Returns `True` if retrieving was successful, `False` otherwise. Constraints: - The system should manage multiple levels and spots efficiently. - Cars should not be parked in motorcycle spots, but motorcycles can be parked in car spots if needed. - Ensure no two vehicles are parked in the same spot. - Handle edge cases such as full levels and unknown license plates. Example Usage: ```python # Create a parking lot with 2 levels, each having 10 spots, with the first 2 spots on each level for motorcycles parking_lot = ParkingLot(2, 10, 2) # Create vehicles car = Vehicle(\\"XYZ123\\", \\"car\\") motorcycle = Vehicle(\\"ABC789\\", \\"motorcycle\\") # Park vehicles print(parking_lot.park_vehicle(car)) # Output: True print(parking_lot.park_vehicle(motorcycle)) # Output: True # Retrieve vehicles print(parking_lot.retrieve_vehicle(\\"XYZ123\\")) # Output: True print(parking_lot.retrieve_vehicle(\\"XYZ999\\")) # Output: False (vehicle not found) ```","solution":"class Vehicle: def __init__(self, license_plate: str, size: str) -> None: self.license_plate = license_plate self.size = size class ParkingSpot: def __init__(self, spot_id: int, size: str) -> None: self.spot_id = spot_id self.size = size self.is_free = True self.vehicle = None class Level: def __init__(self, level_id: int, num_spots: int, motorcycle_spots: int) -> None: self.level_id = level_id self.spots = [ParkingSpot(i, \\"motorcycle\\" if i < motorcycle_spots else \\"car\\") for i in range(num_spots)] def find_free_spot(self, vehicle_size: str) -> int: for spot in self.spots: if spot.is_free and (spot.size == vehicle_size or (spot.size == \\"car\\" and vehicle_size == \\"motorcycle\\")): return spot.spot_id return -1 def park_vehicle(self, vehicle: Vehicle) -> bool: spot_id = self.find_free_spot(vehicle.size) if spot_id == -1: return False spot = self.spots[spot_id] spot.is_free = False spot.vehicle = vehicle return True def retrieve_vehicle(self, license_plate: str) -> bool: for spot in self.spots: if not spot.is_free and spot.vehicle and spot.vehicle.license_plate == license_plate: spot.is_free = True spot.vehicle = None return True return False class ParkingLot: def __init__(self, num_levels: int, spots_per_level: int, motorcycle_spots_per_level: int) -> None: self.levels = [Level(i, spots_per_level, motorcycle_spots_per_level) for i in range(num_levels)] def park_vehicle(self, vehicle: Vehicle) -> bool: for level in self.levels: if level.park_vehicle(vehicle): return True return False def retrieve_vehicle(self, license_plate: str) -> bool: for level in self.levels: if level.retrieve_vehicle(license_plate): return True return False"},{"question":"# Question: Matrix Chain Multiplication # Scenario You are working as a software engineer specializing in performance optimization. One of your projects involves optimizing a series of matrix multiplications. Given a sequence of matrices, the goal is to find the most efficient way to multiply these matrices together. The efficiency is measured by the minimum number of scalar multiplications required. # Task Write a function `matrix_chain_order(dims: List[int]) -> int` that calculates the minimum number of scalar multiplications needed to multiply a chain of matrices. Input: * `dims` - a list of integers where the (i)-th matrix has dimensions (dims[i-1] times dims[i]). Output: * An integer representing the minimum number of scalar multiplications needed to compute the product of the matrices. Constraints: * You can assume that the input list will contain at least two dimensions, i.e., `len(dims) >= 2`. * The dimensionality of matrices ensures that matrix (A_i) has dimensions (dims[i-1] times dims[i]). Example: ```python >>> matrix_chain_order([10, 30, 5, 60]) 4500 >>> matrix_chain_order([1, 2, 3, 4, 3]) 30 ``` Implementation Tips: 1. Use dynamic programming to solve the problem efficiently. 2. Create a 2D table `m` to store the minimum number of multiplications required to compute the product of matrices from (i) to (j). 3. Use nested loops to fill the table `m` and find the optimal solution. 4. The optimal solution can be found by considering different positions to split the chain and recursively solve the subproblems. # Performance Requirements The implementation using dynamic programming should have a time complexity of (O(n^3)), where (n) is the number of matrices in the chain.","solution":"from typing import List def matrix_chain_order(dims: List[int]) -> int: n = len(dims) - 1 # number of matrices m = [[0] * n for _ in range(n)] for length in range(2, n + 1): # length of the subsequence for i in range(n - length + 1): j = i + length - 1 m[i][j] = float(\'inf\') for k in range(i, j): q = m[i][k] + m[k + 1][j] + dims[i] * dims[k + 1] * dims[j + 1] if q < m[i][j]: m[i][j] = q return m[0][n - 1]"},{"question":"# Question: Finding Subarrays with Distinct Elements Context: Imagine you are given an array of integers. Your task is to identify subarrays where each element is distinct. The length of the largest such subarray should be returned. Task: Write a function `max_length_of_distinct_subarray(arr: List[int]) -> int` that receives a list of integers and returns the length of the longest subarray containing all distinct elements. Input: * `arr` - A list of integers (0 ≤ len(arr) ≤ 100,000). Output: An integer representing the length of the longest subarray with all distinct elements. Example: ```python from typing import List def max_length_of_distinct_subarray(arr: List[int]) -> int: pass # Example Usage print(max_length_of_distinct_subarray([5, 1, 3, 5, 2, 3, 4, 1])) # Output: 5 (subarray [5, 2, 3, 4, 1]) print(max_length_of_distinct_subarray([1, 2, 3, 1, 2, 3])) # Output: 3 (subarray [1, 2, 3]) ``` Constraints: 1. All elements in the array are non-negative integers. 2. Handle the edge case where the array is empty, the result should be 0. 3. Aim for an efficient solution with O(n) time complexity.","solution":"from typing import List def max_length_of_distinct_subarray(arr: List[int]) -> int: Return the length of the longest subarray with all distinct elements. n = len(arr) if n == 0: return 0 # To store the last index of every element. last_index = {} max_len = 0 start = 0 for end in range(n): if arr[end] in last_index: start = max(start, last_index[arr[end]] + 1) last_index[arr[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"# Objective You are required to implement a function that performs matrix factorization using the Singular Value Decomposition (SVD) method. The goal is to evaluate your understanding of matrix decompositions and matrix operations. # Problem Statement Write a Python function `svd_factorization(matrix: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]` that decomposes a given matrix `matrix` into three matrices U, Σ, and V such that `matrix = U * Σ * V.T`. Input: 1. `matrix` (np.ndarray): an `M x N` matrix. Output: Returns a tuple of three numpy arrays (U, Σ, V) which are the matrices resulting from the Singular Value Decomposition. Constraints: 1. Ensure the input is a valid `M x N` matrix. 2. The decomposition should conform to the mathematical properties of SVD. 3. Verify the dimensions of the output matrices: `U` should be `M x M`, `Σ` should be `M x N`, and `V` should be `N x N`. # Performance Requirements 1. Utilize efficient numerical libraries to achieve the decomposition. 2. Ensure the operation is numerically stable and handle potential errors in the decomposition process. # Example ```python import numpy as np matrix = np.array([ [1, 2, 3], [4, 5, 6] ]) U, S, V = svd_factorization(matrix) print(U) # Expected output array close to: # [[-0.3863177, -0.92236578], # [-0.92236578, 0.3863177 ]] print(S) # Expected output array close to: # [[ 9.508032, 0. , 0. ], # [ 0. , 0.77286964, 0. ]] print(V) # Expected output array close to: # [[-0.42866713, 0.80596391, 0.40824829], # [-0.56630692, 0.11238241, -0.81649658], # [-0.7039467, -0.58341668, 0.40824829]] ``` Write the function `svd_factorization` that implements the above problem statement.","solution":"import numpy as np from typing import Tuple def svd_factorization(matrix: np.ndarray) -> Tuple[np.ndarray, np.ndarray, np.ndarray]: Decomposes a given M x N matrix into U, Σ and V matrices using Singular Value Decomposition (SVD). Parameters: matrix (np.ndarray): Input M x N matrix. Returns: Tuple[np.ndarray, np.ndarray, np.ndarray]: U, Σ, V matrices such that matrix = U * Σ * V.T U, S, Vt = np.linalg.svd(matrix, full_matrices=True) # Create Σ matrix with correct dimensions (M x N) Σ = np.zeros_like(matrix, dtype=float) np.fill_diagonal(Σ, S) return U, Σ, Vt.T"},{"question":"# Node Depth in Binary Tree Problem Statement You are required to determine the depth of a given node in a binary tree. The depth of a node is defined as the number of edges from the tree\'s root node to the node. Task Write a function `node_depth(root: Optional[TreeNode], target: Any) -> int` that returns the depth of the target node if it exists, or `-1` if the target node does not exist in the binary tree. # Input ```plaintext The function takes: - `root`: the root node of the binary tree, which has `TreeNode` type. - `target`: the value of the node whose depth needs to be found. ``` # Output ```plaintext The function returns an integer: - Depth of the target node if it exists. - `-1` if the target node is not present in the tree. ``` # Constraints * The binary tree does not contain duplicate values. * n: Total number of nodes in the binary tree. (1 ≤ n ≤ 10<sup>4</sup>) # Example ```python class TreeNode: def __init__(self, data: Any) -> None: self.data: Any = data self.left: \'TreeNode\' = None self.right: \'TreeNode\' = None # Example 1 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.left.left = TreeNode(4) print(node_depth(root, 4)) # Output: 2 # Example 2 root = TreeNode(1) root.left = TreeNode(2) root.right = TreeNode(3) root.right.right = TreeNode(4) print(node_depth(root, 5)) # Output: -1 # Example 3 root = TreeNode(1) print(node_depth(root, 1)) # Output: 0 ``` # Function Signature ```python from typing import Optional, Any class TreeNode: def __init__(self, data) -> None: self.data = data self.left = None self.right = None def node_depth(root: Optional[TreeNode], target: Any) -> int: # Implement your solution here pass ``` # Notes: 1. Assume the tree is implemented using the `TreeNode` class as shown above. 2. Your solution should efficiently handle trees with up to 10,000 nodes. 3. Consider edge cases like when the tree is empty or the target node is the root node. 4. Do not alter the tree structure.","solution":"from typing import Optional, Any class TreeNode: def __init__(self, data) -> None: self.data = data self.left = None self.right = None def node_depth(root: Optional[TreeNode], target: Any) -> int: Determines the depth of the target node in the binary tree. def dfs(node: Optional[TreeNode], depth: int) -> int: if not node: return -1 if node.data == target: return depth left = dfs(node.left, depth + 1) if left != -1: return left right = dfs(node.right, depth + 1) return right return dfs(root, 0)"},{"question":"# Question Scenario You are working on a ticket reservation system for a theatre. The theatre has multiple shows, each with different sets of performances scheduled across several days. Each performance has a limited number of seats, and seat reservation requests come in randomly and need to be fulfilled if possible. Task Write a class `TheatreReservationSystem` that facilitates booking and checking seat availability for shows. The class should support the following operations: - `book_seat(show_id: int, performance_id: int, seat_number: int) -> bool`: Attempts to book a seat for a specific performance of a show. Returns `True` if the seat was successfully booked and `False` if the seat is already reserved or any of the identifiers do not exist. - `is_seat_available(show_id: int, performance_id: int, seat_number: int) -> bool`: Checks if a specific seat for a particular performance of a show is available. Returns `True` if the seat is available and `False` otherwise. Input and Output formats In addition to the class methods above, you will initialize the theatre reservation system with performance schedules using the following constructor: - `__init__(self, shows: Dict[int, Dict[int, int]])`: Initializes the theatre reservation system. The `shows` dictionary\'s keys are show IDs, and the values are dictionaries where the keys are performance IDs and the values are the number of seats for each performance. Constraints * The number of shows is at most 100. * Each show can have at most 50 performances. * Each performance can have up to 500 seats. * Seat numbers start from 0 and go up to (number of seats - 1) for each performance. Example ```python shows = { 1: {1: 10, 2: 15}, # Show 1 has 2 performances: Performance 1 with 10 seats, Performance 2 with 15 seats. 2: {1: 5} # Show 2 has 1 performance: Performance 1 with 5 seats. } system = TheatreReservationSystem(shows) # Book seat 5 for show 1, performance 1 print(system.book_seat(1, 1, 5)) # Output: True # Try to book seat 5 for show 1, performance 1 again print(system.book_seat(1, 1, 5)) # Output: False # Check if seat 5 for show 1, performance 1 is available print(system.is_seat_available(1, 1, 5)) # Output: False # Check if seat 6 for show 1, performance 1 is available print(system.is_seat_available(1, 1, 6)) # Output: True ``` Notes - Ensure your implementation accounts for edge cases such as invalid `show_id`, `performance_id`, and `seat_number`. - It is guaranteed that `show_id`, `performance_id`, and `seat_number` used in `book_seat` and `is_seat_available` methods are non-negative integers.","solution":"class TheatreReservationSystem: def __init__(self, shows): Initializes the theatre reservation system with given shows and their performances. :param shows: Dict[int, Dict[int, int]] - A dictionary representing shows, where keys are show IDs and values are dictionaries with performance IDs as keys and seat count as values. self.shows = shows self.reservations = { show_id: {performance_id: [False] * seat_count for performance_id, seat_count in performances.items()} for show_id, performances in shows.items() } def book_seat(self, show_id, performance_id, seat_number): Books a seat for a specific performance of a show. :param show_id: int - The ID of the show. :param performance_id: int - The ID of the performance. :param seat_number: int - The seat number to be booked. :return: bool - Returns True if the seat was successfully booked, False otherwise. if show_id in self.reservations and performance_id in self.reservations[show_id]: performance = self.reservations[show_id][performance_id] if 0 <= seat_number < len(performance) and not performance[seat_number]: performance[seat_number] = True return True return False def is_seat_available(self, show_id, performance_id, seat_number): Checks if a specific seat for a particular performance of a show is available. :param show_id: int - The ID of the show. :param performance_id: int - The ID of the performance. :param seat_number: int - The seat number to be checked. :return: bool - Returns True if the seat is available, False otherwise. if show_id in self.reservations and performance_id in self.reservations[show_id]: performance = self.reservations[show_id][performance_id] if 0 <= seat_number < len(performance): return not performance[seat_number] return False"},{"question":"# CSV Data Aggregation **Objective**: In this task, you will implement a function that reads a CSV file containing student data, processes it to compute average grades, and outputs summary statistics. # Problem Statement: You are given a CSV file with student records. Each row contains information about a student\'s grades in various subjects. The format of each row is: ``` Name,Math,Science,English ``` Where `Name` is a string representing the student\'s name, and `Math`, `Science`, and `English` are integers representing the student\'s grades in those subjects. # Your Task: 1. Implement a function `average_grade(math: int, science: int, english: int) -> float` that computes the average grade of the given subjects. 2. Implement a function `process_student_data(filename: str = \\"students.csv\\") -> dict` that reads the file `students.csv`, calculates the average grade for each student, and returns a dictionary with student names as keys and their average grades as values. # Input: - `filename` (str): The name of the file containing student records. # Output: - Returns (dict): A dictionary where keys are student names (str) and values are their average grades (float). # Constraints: - Grades will be in the range `0 ≤ grade ≤ 100`. - The file will contain at least one row of valid data. # Example: Given an example file \\"students.csv\\" with the following contents: ``` Alice,85,90,88 Bob,78,82,84 Charlie,92,91,89 ``` Running `process_student_data(\\"students.csv\\")` should return: ```python { \\"Alice\\": 87.67, \\"Bob\\": 81.33, \\"Charlie\\": 90.67 } ``` # Specification: ```python def average_grade(math: int, science: int, english: int) -> float: Calculate the average of the given grades for math, science, and English. def process_student_data(filename: str = \\"students.csv\\") -> dict: Process the student data in the given CSV file and return a dictionary with average grades. ``` # Notes: * Ensure your solution correctly handles varying numbers of students. * Be mindful of potential edge cases such as missing subjects or non-integer grades. # Testing: You should provide unit tests to validate the correctness of both functions.","solution":"import csv def average_grade(math: int, science: int, english: int) -> float: Calculate the average of the given grades for math, science, and English. return round((math + science + english) / 3, 2) def process_student_data(filename: str = \\"students.csv\\") -> dict: Process the student data in the given CSV file and return a dictionary with average grades. student_averages = {} with open(filename, mode=\'r\') as file: csv_reader = csv.reader(file) for row in csv_reader: name, math, science, english = row[0], int(row[1]), int(row[2]), int(row[3]) student_averages[name] = average_grade(math, science, english) return student_averages"},{"question":"# Task Overview: You are given a list of integers representing a binary search tree (BST) traversal in a level-order (breadth-first) sequence. Your task is to reconstruct the BST from this list and return the root node of the BST. # Function Signature: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reconstruct_bst(level_order: list[int]) -> TreeNode: Reconstruct the binary search tree based on the given level-order traversal. Parameters: level_order (list[int]): A list of integers representing the BST level-order traversal. Returns: TreeNode: The root node of the reconstructed binary search tree. ``` # Input: - `level_order`: A list of integers. Each integer represents a node value in the BST as traversed in level-order. # Output: - The root node of the reconstructed binary search tree (TreeNode). # Constraints: - All integers in the `level_order` list are unique. - 1 <= len(level_order) <= 1000 - The nodes\' values follow the constraints required to maintain the BST properties. # Examples: ```python >>> class TreeNode: >>> def __init__(self, val=0, left=None, right=None): >>> self.val = val >>> self.left = left >>> self.right = right >>> >>> def deserialize(data): >>> if not data: >>> return None >>> root = TreeNode(data[0]) >>> queue = [root] >>> index = 1 >>> while queue and index < len(data): >>> node = queue.pop(0) >>> if data[index] is not None: >>> node.left = TreeNode(data[index]) >>> queue.append(node.left) >>> index += 1 >>> if index < len(data) and data[index] is not None: >>> node.right = TreeNode(data[index]) >>> queue.append(node.right) >>> index += 1 >>> return root >>> >>> def serialize(root): >>> if not root: >>> return [] >>> result = [] >>> queue = [root] >>> while queue: >>> node = queue.pop(0) >>> if node: >>> result.append(node.val) >>> queue.append(node.left) >>> queue.append(node.right) >>> else: >>> result.append(None) >>> # Remove the trailing None values >>> while result and result[-1] is None: >>> result.pop() >>> return result >>> def reconstruct_bst(level_order): >>> if not level_order: >>> return None >>> root = TreeNode(level_order[0]) >>> i = 1 >>> queue = [root] >>> while i < len(level_order): >>> node = queue.pop(0) >>> if i < len(level_order) and level_order[i] < node.val: >>> node.left = TreeNode(level_order[i]) >>> queue.append(node.left) >>> i += 1 >>> if i < len(level_order) and level_order[i] > node.val: >>> node.right = TreeNode(level_order[i]) >>> queue.append(node.right) >>> i += 1 >>> return root >>> level_order = [7, 4, 12, 2, 6, 9, 19] >>> root1 = reconstruct_bst(level_order) >>> serialize(root1) [7, 4, 12, 2, 6, 9, 19] >>> level_order = [10, 5, 15, 3, 7, 12, 17] >>> root2 = reconstruct_bst(level_order) >>> serialize(root2) [10, 5, 15, 3, 7, 12, 17] ``` # Explanation: 1. **First Example:** The level-order traversal is [7, 4, 12, 2, 6, 9, 19]. Reconstructing the BST gives us: ``` 7 / 4 12 / / 2 6 9 19 ``` The serialized form of this BST is [7, 4, 12, 2, 6, 9, 19]. 2. **Second Example:** The level-order traversal is [10, 5, 15, 3, 7, 12, 17]. Reconstructing the BST gives us: ``` 10 / 5 15 / / 3 7 12 17 ``` The serialized form of this BST is [10, 5, 15, 3, 7, 12, 17].","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def reconstruct_bst(level_order): if not level_order: return None root = TreeNode(val=level_order[0]) queue = [(root, float(\'-inf\'), float(\'inf\'))] i = 1 while queue and i < len(level_order): node, min_val, max_val = queue.pop(0) if i < len(level_order) and min_val < level_order[i] < node.val: node.left = TreeNode(val=level_order[i]) queue.append((node.left, min_val, node.val)) i += 1 if i < len(level_order) and node.val < level_order[i] < max_val: node.right = TreeNode(val=level_order[i]) queue.append((node.right, node.val, max_val)) i += 1 return root"},{"question":"**Water Consumption Tracker Program** You are tasked with creating a program that tracks daily water consumption for a user and calculates the weekly average intake. # Objective Implement a class `WaterConsumptionTracker` that allows the user to record daily water intake (in liters) and compute the average water consumption over a week. # Class Definition ```python class WaterConsumptionTracker: def __init__(self): # Initialize your class variables here pass def record_daily_consumption(self, day: str, liters: float) -> bool: Records the water consumption for a given day. Parameters: - day (str): The name of the day (e.g., \\"Monday\\", \\"Tuesday\\"). - liters (float): The amount of water consumed in liters. Returns: - bool: True if the record is successful, False otherwise. pass def average_weekly_consumption(self) -> float: Calculates the average water consumption over the recorded days. Returns: - float: The average daily consumption in liters over the week. pass ``` # Methods 1. `record_daily_consumption(day: str, liters: float) -> bool`: - Input: - `day` (str): The name of the day. - `liters` (float): The amount of water consumed in liters. - Output: - Returns `True` if the consumption is successfully recorded; otherwise, `False`. 2. `average_weekly_consumption() -> float`: - Output: - Returns the average daily water consumption over the week as a float. If no data is recorded, return `0.0`. # Constraints - `day` must be a valid day of the week (\\"Monday\\", \\"Tuesday\\", etc.). - `liters` must be a non-negative float. - A maximum of one record per day is allowed. - Ensure proper data handling to avoid duplication of day records. # Example ```python tracker = WaterConsumptionTracker() tracker.record_daily_consumption(\\"Monday\\", 2.5) tracker.record_daily_consumption(\\"Tuesday\\", 3.0) tracker.record_daily_consumption(\\"Wednesday\\", 2.0) average = tracker.average_weekly_consumption() print(\\"Average weekly water consumption:\\", average) ``` # Expected Behavior The output should be the average of the recorded water consumptions for the week. If no data is recorded, it should return `0.0`. # Notes - Validate the inputs to ensure they meet constraints. - Handle any errors gracefully. - Ensure the class can handle an incomplete week of data appropriately.","solution":"class WaterConsumptionTracker: def __init__(self): self.consumptions = {} self.days_of_week = {\\"Monday\\", \\"Tuesday\\", \\"Wednesday\\", \\"Thursday\\", \\"Friday\\", \\"Saturday\\", \\"Sunday\\"} def record_daily_consumption(self, day: str, liters: float) -> bool: Records the water consumption for a given day. Parameters: - day (str): The name of the day (e.g., \\"Monday\\", \\"Tuesday\\"). - liters (float): The amount of water consumed in liters. Returns: - bool: True if the record is successful, False otherwise. if day not in self.days_of_week or liters < 0 or day in self.consumptions: return False self.consumptions[day] = liters return True def average_weekly_consumption(self) -> float: Calculates the average water consumption over the recorded days. Returns: - float: The average daily consumption in liters over the week. if not self.consumptions: return 0.0 return sum(self.consumptions.values()) / len(self.consumptions)"},{"question":"# Problem Statement You are tasked with implementing a function to efficiently search for an element in a 2D matrix. The matrix has the following properties: 1. Integers in each row are sorted in ascending order from left to right. 2. Integers in each column are sorted in ascending order from top to bottom. Given a 2D matrix and a target integer, your function should return a tuple (row, column) representing the position of the target in the matrix. If the target does not exist in the matrix, return (-1, -1). # Function Signature ```python def search_matrix(matrix: list[list[int]], target: int) -> tuple[int, int]: Searches for the target element in a 2D matrix with sorted rows and columns. :param matrix: The 2D matrix in which to search for the target. Each element is an integer. :param target: The integer value to search for in the matrix. :return: A tuple (row, column) representing the position of the target in the matrix. If the target is not found, return (-1, -1). ``` # Input * `matrix`: A list of lists of integers representing the 2D matrix. Each row and column is sorted in ascending order. * `target`: An integer value to search for in the matrix. # Output * A tuple (row, column) representing the position of the target in the matrix. If the target is not found, return (-1, -1). # Constraints * The matrix contains at least 0 and at most 300 rows and columns. * Each row and column is sorted in ascending order. * Matrix elements range from `-10^9` to `10^9`. # Example ```python matrix = [ [1, 4, 7, 11, 15], [2, 5, 8, 12, 19], [3, 6, 9, 16, 22], [10, 13, 14, 17, 24], [18, 21, 23, 26, 30] ] target = 5 # Output should be the position of the target 5 in the matrix expected_output = (1, 1) assert search_matrix(matrix, target) == expected_output ``` # Note - You should aim to achieve more efficient than O(n^2) time complexity. - Consider starting the search from the top-right or bottom-left corner of the matrix for an optimal approach.","solution":"def search_matrix(matrix, target): Searches for the target element in a 2D matrix with sorted rows and columns. :param matrix: The 2D matrix in which to search for the target. Each element is an integer. :param target: The integer value to search for in the matrix. :return: A tuple (row, column) representing the position of the target in the matrix. If the target is not found, return (-1, -1). if not matrix or not matrix[0]: return (-1, -1) rows = len(matrix) cols = len(matrix[0]) row = 0 col = cols - 1 while row < rows and col >= 0: if matrix[row][col] == target: return (row, col) elif matrix[row][col] > target: col -= 1 else: row += 1 return (-1, -1)"},{"question":"# Coding Assessment Question: Rotate Matrix To Match Background: You are given two n x n matrices, `mat1` and `mat2`. Your task is to determine if you can transform `mat1` to match `mat2` by rotating `mat1` in 90-degree increments. Specifically, check if `mat1` can match `mat2` after 0, 90, 180, or 270-degree rotations. # Function Signature ```python def can_rotate_to_match(mat1: List[List[int]], mat2: List[List[int]]) -> bool: pass ``` # Input - `mat1` (List[List[int]]): A square matrix of integers (n x n) where (1 leq n leq 10). - `mat2` (List[List[int]]): Another square matrix of integers (n x n). # Output - `bool`: A boolean value, where `True` indicates that `mat1` can be rotated to match `mat2`, and `False` otherwise. # Constraints - Both matrices will only contain integer values. # Example ```python def test_can_rotate_to_match(): mat1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] mat2 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert can_rotate_to_match(mat1, mat2) == True, \\"Test case 1 failed\\" mat1 = [ [1, 2], [3, 4] ] mat2 = [ [3, 1], [4, 2] ] assert can_rotate_to_match(mat1, mat2) == False, \\"Test case 2 failed\\" mat1 = [ [1] ] mat2 = [ [1] ] assert can_rotate_to_match(mat1, mat2) == True, \\"Test case 3 failed\\" print(\\"All test cases pass\\") test_can_rotate_to_match() ``` # Notes - Implement helper functions for rotating the matrix in 90-degree increments. - Compare the matrices after each rotation to see if they match. - Ensure the function handles edge cases, such as when the matrices are already matching without rotation or are of minimal size (1x1). ```python def rotate_90(matrix): return [list(row)[::-1] for row in zip(*matrix)] def can_rotate_to_match(mat1, mat2): for _ in range(4): if mat1 == mat2: return True mat1 = rotate_90(mat1) return False test_can_rotate_to_match() ```","solution":"from typing import List def rotate_90(matrix: List[List[int]]) -> List[List[int]]: Rotates a given n x n matrix by 90 degrees clockwise. return [list(row)[::-1] for row in zip(*matrix)] def can_rotate_to_match(mat1: List[List[int]], mat2: List[List[int]]) -> bool: Determines if mat1 can be rotated to match mat2 (by 0, 90, 180, or 270 degrees). for _ in range(4): if mat1 == mat2: return True mat1 = rotate_90(mat1) return False"},{"question":"# Run-Length Encoding Decompression You are provided with a file that has been compressed using Run-Length Encoding (RLE). Your task is to implement the RLE decompression algorithm to retrieve the original file content. Your implementation should include reading the compressed file, decompressing it, and saving the decompressed content to a new file. Input Format: 1. The input compressed file contains text with each character followed by a count indicating how many times the character is repeated in the original file. 2. You will be given two paths: one for the input compressed file, and another for the output decompressed file. Output Format: - The output should be a file created at the specified path containing the decompressed content. Constraints: - Ensure that your implementation correctly handles any character and count combinations. - Manage edge cases where the count might be more than a single digit. - The count associated with each character will be at least 1. Performance Requirements: - Your decompression function should handle files up to several megabytes in size efficiently. - Ensure that your solution does not exceed O(n) time complexity where n is the length of the decompressed data. Example Given a compressed file `compressed_file.rle` with the following content: ``` a1b3c2d4e1 ``` This means: - \'a\' appears 1 time - \'b\' appears 3 times - \'c\' appears 2 times - \'d\' appears 4 times - \'e\' appears 1 time The decompressed content would be: ``` abbbccdddde ``` You should implement the decompression such that invoking your function: ```python decompress(\\"compressed_file.rle\\", \\"decompressed_output.txt\\") ``` Produces the decompressed output in the specified `decompressed_output.txt`. **Function Signature:** ```python def decompress(src_path: str, dest_path: str) -> None: pass ```","solution":"def decompress(src_path: str, dest_path: str) -> None: Decompresses the content of the file specified by src_path using Run-Length Encoding (RLE) and writes the decompressed content to the file specified by dest_path. with open(src_path, \'r\') as f: compressed_content = f.read() decompressed_content = [] i = 0 while i < len(compressed_content): char = compressed_content[i] i += 1 count = \'\' while i < len(compressed_content) and compressed_content[i].isdigit(): count += compressed_content[i] i += 1 decompressed_content.append(char * int(count)) with open(dest_path, \'w\') as f: f.write(\'\'.join(decompressed_content))"},{"question":"# String Compression Algorithm You need to implement a function that takes a string consisting of lowercase alphabetical characters and compresses it using the counts of repeated characters. If the compressed string length is equal to or greater than the original string length, the function should return the original string. # Function Definition Implement the following function: ```python def compress_string(input_string: str) -> str: pass ``` # Input Parameters * **input_string** (str): A string consisting only of lowercase alphabetical characters (a-z). # Output * **str**: The compressed string or the original string if the compressed string is not shorter. # Constraints * The length of the `input_string` will be between 0 and 1000 inclusive. # Examples ```python # Example usage and output print(compress_string(\\"aabcccccaaa\\")) # Output: \\"a2b1c5a3\\" print(compress_string(\\"abcdef\\")) # Output: \\"abcdef\\" print(compress_string(\\"\\")) # Output: \\"\\" print(compress_string(\\"aaaaaa\\")) # Output: \\"a6\\" print(compress_string(\\"aab\\")) # Output: \\"aab\\" ``` # Notes * The function should traverse the string and count the occurrences of each character before switching to the next character. * If the compressed string is not shorter than the original string, return the original string. * Edge cases include empty strings and strings where all characters are unique.","solution":"def compress_string(input_string: str) -> str: if not input_string: return input_string compressed_parts = [] last_char = input_string[0] count = 1 for char in input_string[1:]: if char == last_char: count += 1 else: compressed_parts.append(last_char) compressed_parts.append(str(count)) last_char = char count = 1 compressed_parts.append(last_char) compressed_parts.append(str(count)) compressed_string = \'\'.join(compressed_parts) return compressed_string if len(compressed_string) < len(input_string) else input_string"},{"question":"# Scenario You are developing a data analysis tool that helps users find patterns in numerical data. One essential feature of this tool is identifying the subarray with the maximum sum within a given list of integers. This forms a core function in many data processing tasks. # Task Write a Python function `max_subarray_sum(nums: List[int]) -> int` that finds and returns the sum of the contiguous subarray with the largest sum within the given list of integers. # Input/Output Formats * **Input**: A list `nums` of integers with a length up to 10^5. * **Output**: An integer representing the largest sum possible for any contiguous subarray within the provided list. # Constraints * The list `nums` can contain both positive and negative integers. * The list may contain up to 10^5 elements. # Performance Requirements Your function should efficiently handle large lists within linear time complexity, ideally using Kadane\'s algorithm. # Examples ```python >>> max_subarray_sum([-2,1,-3,4,-1,2,1,-5,4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([5,4,-1,7,8]) 23 >>> max_subarray_sum([-1, -2, -3, -4]) -1 >>> max_subarray_sum([2, -1, 2, 3, 4, -5]) 10 ``` # Edge Cases * If the input list contains only negative numbers, the function should return the maximum single element. * The function should return the element itself if the list consists of a single number.","solution":"from typing import List def max_subarray_sum(nums: List[int]) -> int: Function to find the sum of the contiguous subarray with the largest sum. This implementation uses Kadane\'s Algorithm. if not nums: return 0 max_sum = current_sum = nums[0] for num in nums[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Query Range Sum in a Segment Tree In this task, you are required to implement a function that computes the sum of elements within a given range in an array using a Segment Tree. Given an array of integers and multiple query ranges, your function should efficiently build the Segment Tree and process the range sum queries. # Input * `arr`: A list of integers representing the array. * `queries`: A list of tuples, each containing two integers `(l, r)` representing the start and end indices of the query range (inclusive). # Output A list of integers, where each integer is the sum of the elements within the corresponding query range. # Constraints * The array may contain negative values. * The array length will be at most (10^5). * `0 <= l <= r < len(arr)` * At most (10^5) queries. # Performance Requirements * The function should be implemented to handle build and query operations efficiently. * Segment Tree operations (both build and query) should be (O(log N)) on average. # Example ```python arr = [1, 3, 5, 7, 9, 11] queries = [(1, 3), (0, 5), (2, 4)] query_results = query_range_sum(arr, queries) print(query_results) # Output: [15, 36, 21] ``` # Task Implement the `query_range_sum` function as described above. ```python from __future__ import annotations from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def range_sum(self, left: int, right: int) -> int: # Get sum of elements in the range [left, right) left += self.n right += self.n + 1 total = 0 while left < right: if left % 2 == 1: total += self.tree[left] left += 1 if right % 2 == 1: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def query_range_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: segment_tree = SegmentTree(arr) results = [] for l, r in queries: results.append(segment_tree.range_sum(l, r)) return results ```","solution":"from typing import List, Tuple class SegmentTree: def __init__(self, data: List[int]): self.n = len(data) self.tree = [0] * (2 * self.n) self.build(data) def build(self, data: List[int]): # Insert leaf nodes in the tree for i in range(self.n): self.tree[self.n + i] = data[i] # Build the tree by calculating parents for i in range(self.n - 1, 0, -1): self.tree[i] = self.tree[2 * i] + self.tree[2 * i + 1] def range_sum(self, left: int, right: int) -> int: # Get sum of elements in the range [left, right] left += self.n right += self.n + 1 total = 0 while left < right: if left % 2 == 1: total += self.tree[left] left += 1 if right % 2 == 1: right -= 1 total += self.tree[right] left //= 2 right //= 2 return total def query_range_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: segment_tree = SegmentTree(arr) results = [] for l, r in queries: results.append(segment_tree.range_sum(l, r)) return results"},{"question":"# Scenario You are developing a financial application that aides users in managing their expenses and budgets. One of the key features of this application is generating monthly summaries of expenses, categorized into different types like food, entertainment, utilities, etc. # Problem Statement You need to implement a function that takes a list of expense logs for a given month and categorizes them. Each expense log is a dictionary containing the expense amount, category, and date. Your function should aggregate the expenses by category and return the total expense amount for each category. # Requirements You need to implement the `categorize_expenses` function that takes one parameter: 1. `expense_logs` (list): A list of dictionaries, where each dictionary represents an expense log with the following keys: - `amount` (float): The amount spent. - `category` (str): The category of the expense (e.g., \\"food\\", \\"entertainment\\"). - `date` (str): The date of the expense in \\"YYYY-MM-DD\\" format (you may ignore this field for this problem). The function should return a dictionary where keys are expense categories and values are the total amounts spent in those categories for the given month. # Input - `expense_logs`: a list of dictionaries, each containing: - `amount` (float) - `category` (str) - `date` (str) # Output - Returns a dictionary with categories as keys and total expense amounts as values. # Constraints - `expense_logs` will contain at least one entry. - `amount` will be a non-negative float. - `category` will be a non-empty string. # Example ```python def categorize_expenses(expense_logs: list) -> dict: Given a list of expense logs, aggregates the expenses by category. Parameters: expense_logs (list): A list of expense logs, where each log is a dictionary containing \'amount\', \'category\', and \'date\'. Returns: dict: A dictionary with categories as keys and total amounts as values. categorized_expenses = {} for log in expense_logs: amount = log[\'amount\'] category = log[\'category\'] if category in categorized_expenses: categorized_expenses[category] += amount else: categorized_expenses[category] = amount return categorized_expenses # Example usage: expense_logs = [ {\'amount\': 20.5, \'category\': \'food\', \'date\': \'2023-01-01\'}, {\'amount\': 15.0, \'category\': \'food\', \'date\': \'2023-01-02\'}, {\'amount\': 5.0, \'category\': \'entertainment\', \'date\': \'2023-01-03\'}, {\'amount\': 100.0, \'category\': \'utilities\', \'date\': \'2023-01-04\'}, ] print(categorize_expenses(expense_logs)) # Should output: {\'food\': 35.5, \'entertainment\': 5.0, \'utilities\': 100.0} ```","solution":"def categorize_expenses(expense_logs: list) -> dict: Given a list of expense logs, aggregates the expenses by category. Parameters: expense_logs (list): A list of expense logs, where each log is a dictionary containing \'amount\', \'category\', and \'date\'. Returns: dict: A dictionary with categories as keys and total amounts as values. categorized_expenses = {} for log in expense_logs: amount = log[\'amount\'] category = log[\'category\'] if category in categorized_expenses: categorized_expenses[category] += amount else: categorized_expenses[category] = amount return categorized_expenses"},{"question":"# Coding Assessment Question: Data Filtering and Aggregation Context: In a data processing task, you are required to filter and aggregate information from a set of records, each represented as a dictionary. The goal is to extract meaningful insights while adhering to specified criteria and ensuring efficient data handling. Problem Statement: You are required to implement the following functions: 1. **filter_records**: - **Input**: A list of dictionaries `records` and a dictionary `criteria` containing key-value pairs to filter the records. - **Output**: A list of dictionaries containing only the records that match all the key-value pairs specified in the `criteria`. - **Constraints**: Each record is guaranteed to have all the keys specified in the `criteria`. 2. **aggregate_records**: - **Input**: A list of dictionaries `records`, a string `key` for the field to aggregate by, and a string `operation` specifying the aggregation operation (`sum`, `average`, `min`, `max`). - **Output**: A float value representing the result of the aggregation operation. - **Constraints**: The `key` exists in all records, and the `operation` is one of `\'sum\'`, `\'average\'`, `\'min\'`, or `\'max\'`. 3. **group_by_field**: - **Input**: A list of dictionaries `records` and a string `key` to group by. - **Output**: A dictionary where each key is a unique value from the specified `key`, and the corresponding value is a list of dictionaries (records) that contain that key value. - **Constraints**: The `key` exists in all records. 4. **sort_records**: - **Input**: A list of dictionaries `records`, a string `key` to sort by, and an optional boolean `reverse` (default is `False`) to specify sorting order. - **Output**: A list of dictionaries sorted by the specified `key` in ascending or descending order based on the `reverse` flag. - **Constraints**: The `key` exists in all records. Requirements: - Ensure appropriate handling of edge cases (e.g., empty lists, no matching criteria). - Optimize for readability, performance, and maintainability. - Provide clear and concise documentation within the code. Example Usage: ```python records = [ {\'id\': 1, \'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'id\': 2, \'name\': \'Bob\', \'age\': 25, \'salary\': 4500}, {\'id\': 3, \'name\': \'Charlie\', \'age\': 35, \'salary\': 5500}, {\'id\': 4, \'name\': \'David\', \'age\': 30, \'salary\': 6000}, ] criteria = {\'age\': 30} filtered = filter_records(records, criteria) print(filtered) # Output: [{\'id\': 1, \'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'id\': 4, \'name\': \'David\', \'age\': 30, \'salary\': 6000}] aggregate = aggregate_records(records, \'salary\', \'average\') print(aggregate) # Output: 5250.0 grouped = group_by_field(records, \'age\') print(grouped) # Output: {30: [{\'id\': 1, \'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'id\': 4, \'name\': \'David\', \'age\': 30, \'salary\': 6000}], 25: [{\'id\': 2, \'name\': \'Bob\', \'age\': 25, \'salary\': 4500}], 35: [{\'id\': 3, \'name\': \'Charlie\', \'age\': 35, \'salary\': 5500}]} sorted_records = sort_records(records, \'salary\', reverse=True) print(sorted_records) # Output: [{\'id\': 4, \'name\': \'David\', \'age\': 30, \'salary\': 6000}, {\'id\': 3, \'name\': \'Charlie\', \'age\': 35, \'salary\': 5500}, {\'id\': 1, \'name\': \'Alice\', \'age\': 30, \'salary\': 5000}, {\'id\': 2, \'name\': \'Bob\', \'age\': 25, \'salary\': 4500}] ```","solution":"def filter_records(records, criteria): Filters the records based on the specified criteria. Args: records (list of dict): List of records. criteria (dict): Dictionary with key-value pairs to filter the records. Returns: list of dict: Filtered list of records that match the criteria. return [record for record in records if all(record[k] == v for k, v in criteria.items())] def aggregate_records(records, key, operation): Aggregates the records based on the specified key and operation. Args: records (list of dict): List of records. key (str): The field to aggregate by. operation (str): Aggregation operation (\'sum\', \'average\', \'min\', \'max\'). Returns: float: Result of the aggregation operation. values = [record[key] for record in records] if operation == \'sum\': return sum(values) elif operation == \'average\': return sum(values) / len(values) if values else 0 elif operation == \'min\': return min(values) elif operation == \'max\': return max(values) else: raise ValueError(\\"Invalid operation specified.\\") def group_by_field(records, key): Groups the records by the specified key. Args: records (list of dict): List of records. key (str): The field to group by. Returns: dict: Dictionary where the keys are unique values from the specified key, and the values are lists of records that contain that key value. grouped = {} for record in records: k = record[key] if k not in grouped: grouped[k] = [] grouped[k].append(record) return grouped def sort_records(records, key, reverse=False): Sorts the records by the specified key in ascending or descending order. Args: records (list of dict): List of records. key (str): The field to sort by. reverse (bool, optional): Whether to sort in descending order. Default is False (ascending order). Returns: list of dict: Sorted list of records based on the specified key. return sorted(records, key=lambda x: x[key], reverse=reverse)"},{"question":"# Coding Assessment Question Problem Statement: Write a function that finds all the prime numbers less than or equal to a given integer `n`. Implement the Sieve of Eratosthenes algorithm to achieve this in an efficient manner. Input: - An integer `n` (2 <= n <= 10^6). Output: - A list of integers, representing all the prime numbers less than or equal to `n`. Constraints: - Input `n` will be a valid integer within the given range. - The solution must execute efficiently even for the largest possible input within the given constraints. Function Signature: ```python def find_primes(n: int) -> list: pass ``` Example: ```python print(find_primes(10)) # Output: [2, 3, 5, 7] print(find_primes(20)) # Output: [2, 3, 5, 7, 11, 13, 17, 19] ``` Context: In optimizing data encryption software, it is crucial to quickly identify prime numbers within a range. This function will be utilized frequently, thus requiring a highly efficient algorithm. # Requirements: - Implement the Sieve of Eratosthenes algorithm for prime number generation. - Ensure proper handling of edge cases; inputs will always be integers within constraints. Hint: The Sieve of Eratosthenes is an ancient algorithm used to find all primes up to a specified integer. The idea is to iteratively mark the multiples of each prime number starting from 2. ```python # Example steps for n = 10 # Start with a list of boolean values indicating potential primes. # numbers: 0 1 2 3 4 5 6 7 8 9 10 # is_prime: [F, F, T, T, T, T, T, T, T, T, T] # Mark multiples of 2 as False (not prime) # is_prime: [F, F, T, T, F, T, F, T, F, T, F] # Mark multiples of 3 as False (not prime) # is_prime: [F, F, T, T, F, T, F, T, F, F, F] # Continue for next primes... # The remaining True indices are primes. ```","solution":"def find_primes(n: int) -> list: Find all prime numbers less than or equal to n using the Sieve of Eratosthenes algorithm. if n < 2: return [] is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for start in range(2, int(n**0.5) + 1): if is_prime[start]: for multiple in range(start*start, n + 1, start): is_prime[multiple] = False return [num for num, prime in enumerate(is_prime) if prime]"},{"question":"# Context You are tasked with creating a custom cache mechanism that stores key-value pairs and provides efficient retrieval and eviction policies. The cache should have a fixed capacity and implement the Least Recently Used (LRU) eviction policy. # Task 1. Implement a class `LRUCache` that provides an efficient cache with LRU eviction policy. 2. Ensure that the `get`, `put`, and `remove` methods adhere to the expected performance constraints. # Expected Input and Output * **get(key: Any) -> Any**: If the key is present in the cache, return the value and mark the key as recently used. If the key is not present, return `None`. * **put(key: Any, value: Any) -> None**: Insert the key-value pair into the cache. If the cache reaches its capacity, evict the least recently used item first to make space for the new entry. * **remove(key: Any) -> None**: Remove the key-value pair from the cache if the key exists. # Constraints * The cache has a fixed capacity which is set at initialization. * All operations should handle edge cases gracefully (e.g., removal of non-existent keys should not cause errors). # Example ```python cache = LRUCache(2) cache.put(1, \'one\') cache.put(2, \'two\') print(cache.get(1)) # Output: \'one\' cache.put(3, \'three\') # Evicts key 2 print(cache.get(2)) # Output: None cache.put(4, \'four\') # Evicts key 1 print(cache.get(1)) # Output: None print(cache.get(3)) # Output: \'three\' print(cache.get(4)) # Output: \'four\' ``` # Performance Requirements * `get` and `put` should both operate in O(1) time complexity on average. * The implementation should leverage data structures such as `OrderedDict` from `collections` or similar for efficient LRU management.","solution":"from collections import OrderedDict class LRUCache: def __init__(self, capacity: int): self.cache = OrderedDict() self.capacity = capacity def get(self, key: any) -> any: if key not in self.cache: return None self.cache.move_to_end(key) # Mark as recently used return self.cache[key] def put(self, key: any, value: any) -> None: if key in self.cache: self.cache.move_to_end(key) # Update the position to mark as recently used self.cache[key] = value if len(self.cache) > self.capacity: self.cache.popitem(last=False) # Pop the least recently used item def remove(self, key: any) -> None: if key in self.cache: del self.cache[key]"},{"question":"# Binary Tree Level Order Traversal Implement the `level_order_traversal` method for a `BinaryTree` class that performs a breadth-first traversal (also known as level-order traversal) of a binary tree and returns a list of values encountered level-by-level. You will be working with the following `TreeNode` and `BinaryTree` classes: ```python from typing import List, Any from dataclasses import dataclass @dataclass class TreeNode: value: Any left: \'TreeNode\' | None = None right: \'TreeNode\' | None = None @dataclass class BinaryTree: root: \'TreeNode\' | None = None ``` Your task is to add a method `level_order_traversal` to the `BinaryTree` class, which should return a list containing the values of the nodes visited in level-order. # Function Signature ```python def level_order_traversal(self) -> List[Any]: pass ``` # Constraints - Assume the binary tree may contain any number of nodes (including zero nodes). - The function should handle edge cases such as empty trees and very small trees correctly. - The function should perform efficiently with respect to time and space complexity: * Time Complexity: O(n) where n is the number of nodes in the tree * Space Complexity: O(n) for the queue used during traversal # Examples ```python >>> binary_tree = BinaryTree() >>> binary_tree.root = TreeNode(1) >>> binary_tree.root.left = TreeNode(2) >>> binary_tree.root.right = TreeNode(3) >>> binary_tree.root.left.left = TreeNode(4) >>> binary_tree.root.left.right = TreeNode(5) >>> binary_tree.level_order_traversal() [1, 2, 3, 4, 5] >>> binary_tree2 = BinaryTree() >>> binary_tree2.root = TreeNode(7) >>> binary_tree2.root.left = TreeNode(2) >>> binary_tree2.root.right = TreeNode(9) >>> binary_tree2.root.left.right = TreeNode(5) >>> binary_tree2.level_order_traversal() [7, 2, 9, 5] >>> binary_tree3 = BinaryTree() >>> binary_tree3.level_order_traversal() [] ``` Add this function to the `BinaryTree` class and ensure its correctness with a variety of tree structures and sizes.","solution":"from typing import List, Any, Optional from dataclasses import dataclass from collections import deque @dataclass class TreeNode: value: Any left: Optional[\'TreeNode\'] = None right: Optional[\'TreeNode\'] = None @dataclass class BinaryTree: root: Optional[TreeNode] = None def level_order_traversal(self) -> List[Any]: if not self.root: return [] result = [] queue = deque([self.root]) while queue: current_node = queue.popleft() result.append(current_node.value) if current_node.left: queue.append(current_node.left) if current_node.right: queue.append(current_node.right) return result"},{"question":"# Problem Statement Implement a complex number addition function without using any built-in complex number libraries. The function should take two complex numbers represented as tuples and return their sum as another tuple. Each tuple will contain two elements: the real part and the imaginary part of the complex number. # Function Signature ```python def add_complex_numbers(a: tuple, b: tuple) -> tuple: pass ``` # Input * `a` (tuple): A tuple containing two floats representing the first complex number, (real_part_a, imaginary_part_a). * `b` (tuple): A tuple containing two floats representing the second complex number, (real_part_b, imaginary_part_b). # Output * Return a tuple containing two floats representing the sum of the complex numbers. # Constraints * The tuples will contain exactly two elements. * Each element within the tuples will be a float. * Your implementation should handle both positive and negative values. # Examples ```python assert add_complex_numbers((1, 2), (3, 4)) == (4.0, 6.0) assert add_complex_numbers((-1, -2), (3, 4)) == (2.0, 2.0) assert add_complex_numbers((0, 0), (0, 0)) == (0.0, 0.0) assert add_complex_numbers((1.5, -2.5), (-1.5, 2.5)) == (0.0, 0.0) ``` # Special Notes Consider testing your function thoroughly to handle edge cases such as: * Complex numbers with zero real or imaginary parts. * Mixed positive and negative values. * Extremely large or small float values. Provide appropriate documentation and comments within your code to ensure clarity and maintainability.","solution":"def add_complex_numbers(a: tuple, b: tuple) -> tuple: Adds two complex numbers represented as tuples (real_part, imaginary_part). Parameters: a (tuple): The first complex number. b (tuple): The second complex number. Returns: tuple: The sum of the two complex numbers. real_part = a[0] + b[0] imaginary_part = a[1] + b[1] return (real_part, imaginary_part)"},{"question":"# Problem Statement You are given a list of integers `nums` and a target integer `target`. Your task is to determine if there are two distinct indices `i` and `j` in the list such that `nums[i] + nums[j] == target`. # Function Signature ```python def two_sum(nums: list[int], target: int) -> bool: pass ``` # Input * `nums` (1 <= len(nums) <= 10000): A list of integers. * `target` (1 <= target <= 10^9): The target sum integer. # Output * Return `True` if there exist two distinct indices `i` and `j` in `nums` such that `nums[i] + nums[j] == target`, otherwise return `False`. # Example ```python assert two_sum([2, 7, 11, 15], 9) == True assert two_sum([3, 2, 4], 6) == True assert two_sum([3, 3], 6) == True assert two_sum([1, 2, 3, 4], 8) == False ``` # Constraints * `nums` will contain at least one integer. * The same element cannot be used twice in a solution. # Scenarios 1. For `nums = [2, 7, 11, 15]` and `target = 9`, the function returns `True` because `nums[0] + nums[1] = 2 + 7 = 9`. 2. For `nums = [3, 2, 4]` and `target = 6`, the function returns `True` because `nums[1] + nums[2] = 2 + 4 = 6`. 3. For `nums = [1, 2, 3, 4]` and `target = 8`, the function returns `False` because no such indices `i` and `j` exist that satisfy the condition. # Hints - Consider using a dictionary to keep track of the numbers you\'ve seen so far and their indices. - The dictionary can be used to efficiently check if the complement of the current number (i.e., `target - current_number`) exists in the list.","solution":"def two_sum(nums: list[int], target: int) -> bool: Determine if there are two distinct indices i and j in nums such that nums[i] + nums[j] == target. seen = {} for i, num in enumerate(nums): complement = target - num if complement in seen: return True seen[num] = i return False"},{"question":"# Problem Statement You are tasked with creating a function that generates all possible permutations of a given list of integers. Permutations are distinct arrangements of the elements in the list. # Function Signature ```python def generate_permutations(nums: list) -> list: ``` # Constraints * The list `nums` will contain a maximum of 10 elements. * The elements in `nums` will be distinct integers. * The return type should be a list of lists, where each inner list is a permutation of `nums`. # Example ```python # Example 1 print(generate_permutations([1, 2, 3])) # should return [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] # Example 2 print(generate_permutations([0, 1])) # should return [[0, 1], [1, 0]] ``` # Requirements 1. **Efficiency**: Ensure that the function runs efficiently even at the upper limit of constraints. 2. **Validation**: Validate the input to ensure it meets all given constraints. 3. **Output**: Order of permutations in the output does not matter.","solution":"from itertools import permutations def generate_permutations(nums: list) -> list: Generates all possible permutations of a list of integers. :param nums: List of distinct integers :return: List of all possible permutations of nums return [list(perm) for perm in permutations(nums)]"},{"question":"# Problem: You are given a `Node` class that represents the nodes of a singly linked list. Write a function `find_cycle_start` that detects if a cycle exists in the linked list and returns the node where the cycle begins. If there\'s no cycle, return `None`. # Requirements: 1. **Input**: The head node of the singly linked list. 2. **Output**: The node where the cycle starts or `None` if no cycle exists. 3. **Constraints**: - The linked list can contain up to (10^5) nodes. # Performance: - Maintain a time complexity of **O(N)** and space complexity of **O(1)**. # Sample Example: ```python class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def find_cycle_start(head: Node) -> Node: # Write your code here pass # Example Usage # Creating a linked list with a cycle: # 1 -> 2 -> 3 -> 4 -> 5 -> 2 (cycle starts again from 2) n1, n2, n3, n4, n5 = Node(1), Node(2), Node(3), Node(4), Node(5) n1.next, n2.next, n3.next, n4.next, n5.next = n2, n3, n4, n5, n2 print(find_cycle_start(n1)) # Output should be the node with value 2 # Creating a linked list without a cycle: # 1 -> 2 -> 3 -> 4 -> 5 n1, n2, n3, n4, n5 = Node(1), Node(2), Node(3), Node(4), Node(5) n1.next, n2.next, n3.next, n4.next, n5.next = n2, n3, n4, n5, None print(find_cycle_start(n1)) # Output should be None ``` # Explanation: - Use Floyd\'s Cycle-Finding Algorithm (also known as the Tortoise and Hare Algorithm) to detect the cycle. - Initialize two pointers, `slow` and `fast`, both starting from the head. Move `slow` by one step and `fast` by two steps. - If there\'s no cycle, `fast` will reach the end and return `None`. - If there\'s a cycle, `slow` and `fast` will eventually meet. - To find the start of the cycle, move one pointer to the head of the list and keep the other at the meeting point. Move both pointers one step at a time until they meet again. The meeting point is the start of the cycle.","solution":"class Node: def __init__(self, value=0, next=None): self.value = value self.next = next def find_cycle_start(head: Node) -> Node: if not head: return None # Initialize slow and fast pointers slow, fast = head, head # Detect cycle using Floyd\'s cycle detection algorithm while fast and fast.next: slow = slow.next fast = fast.next.next # If slow and fast meet, a cycle exists if slow == fast: break else: # If we exit the while without breaking, there is no cycle return None # Find the start of the cycle slow = head while slow != fast: slow = slow.next fast = fast.next return slow"},{"question":"# Online Library Book Search You have been tasked with creating a function to search for books in an online library. Each book is represented by a dictionary containing its title, author, and year of publication. The search function should allow users to search for books by title, author, or both. If both title and author are provided, the function should return books that match both criteria. **Constraints**: - The input is a list of dictionaries representing the books. - Each dictionary contains \'title\', \'author\', and \'year\' keys. - The search function accepts two optional string parameters: `title` and `author`. - If both are `None`, the function should return an empty list. - If one is `None`, the function should return books that match the specified criterion. - The search should be case-insensitive. **Expected Input and Output**: - The function should accept a list of dictionaries and two optional strings as input. - The function should return a list of dictionaries that match the search criteria. Implement the function with the following signature: ```python def search_books(library: list, title: str = None, author: str = None) -> list: pass ``` # Example Library: ```python library = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}, {\\"title\\": \\"Pride and Prejudice\\", \\"author\\": \\"Jane Austen\\", \\"year\\": 1813}, {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951}, ] ``` # Examples: ```python >>> search_books(library, title=\\"1984\\") [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}] >>> search_books(library, author=\\"Harper Lee\\") [{\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960}] >>> search_books(library, title=\\"the catcher in the rye\\", author=\\"J.D. Salinger\\") [{\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951}] >>> search_books(library, title=\\"Pride and Prejudice\\", author=\\"Jane Austen\\") [{\\"title\\": \\"Pride and Prejudice\\", \\"author\\": \\"Jane Austen\\", \\"year\\": 1813}] >>> search_books(library) [] >>> search_books(library, title=None, author=\\"George Orwell\\") [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949}] >>> search_books(library, title=\\"Moby Dick\\", author=\\"Herman Melville\\") [] ```","solution":"def search_books(library: list, title: str = None, author: str = None) -> list: Searches for books in the library based on the given title and/or author. Parameters: library (list): List of books, where each book is a dictionary containing \'title\', \'author\', and \'year\'. title (str, optional): The title to search for. Defaults to None. author (str, optional): The author to search for. Defaults to None. Returns: list: List of books matching the search criteria. if title is None and author is None: return [] title = title.lower() if title else None author = author.lower() if author else None result = [] for book in library: book_title = book[\'title\'].lower() book_author = book[\'author\'].lower() if title and author: if title in book_title and author in book_author: result.append(book) elif title: if title in book_title: result.append(book) elif author: if author in book_author: result.append(book) return result"},{"question":"# Problem Statement You are given a list of strings representing transactions in a bank. Each transaction is represented as a string in the format `\\"timestamp|sender|receiver|amount\\"`, where `timestamp` is an integer representing the time, `sender` and `receiver` are strings representing the account names, and `amount` is an integer representing the amount of money transferred. Your task is to write a function that processes the transactions and returns a dictionary where the keys are account names and the values are the net balances of the accounts after all transactions have been processed. # Function Signature ```python def calculate_balances(transactions: List[str]) -> Dict[str, int]: pass ``` # Input * `transactions`: A list of strings, each representing a transaction. # Output * A dictionary where keys are account names and values are the net balances of the accounts. # Constraints * Strings in the transaction list are always formatted correctly. * All timestamps are non-negative integers. * The amount in each transaction is a non-negative integer. # Example ```python transactions = [ \\"1599619200|Alice|Bob|50\\", \\"1599619205|Bob|Charlie|25\\", \\"1599619210|Alice|Charlie|30\\" ] print(calculate_balances(transactions)) # Expected Output: {\'Alice\': -80, \'Bob\': 25, \'Charlie\': 55} ``` # Notes * An account\'s balance starts at 0 if it is mentioned in a transaction. * Be sure to handle edge cases where transactions involve the same account multiple times. * Consider also cases where no transactions are given, returning an empty dictionary.","solution":"from typing import List, Dict def calculate_balances(transactions: List[str]) -> Dict[str, int]: Process the transactions and return a dictionary where keys are account names and values are the net balances of the accounts after all transactions have been processed. :param transactions: List of transaction strings in the format \\"timestamp|sender|receiver|amount\\" :return: Dictionary with account names as keys and their net balances as values balances = {} for transaction in transactions: timestamp, sender, receiver, amount = transaction.split(\'|\') amount = int(amount) if sender not in balances: balances[sender] = 0 if receiver not in balances: balances[receiver] = 0 balances[sender] -= amount balances[receiver] += amount return balances"},{"question":"# Coding Assessment Question **Problem Statement**: Given a list of integers, your task is to sort the array in such a way that the even numbers appear before the odd numbers, while maintaining the relative order of the even and odd numbers in the original array. This is also known as the ordered parity sort. **Function Signature**: ```python def parity_ordered_sort(arr: List[int]) -> List[int]: ``` **Input**: - `arr`: A list of integers where `0 <= len(arr) <= 10^6`. Each integer `arr[i]` falls within the range `-10^6 <= arr[i] <= 10^6`. **Output**: - Return a list of integers sorted by even numbers followed by odd numbers, with the relative order of even and odd numbers preserved from the original array. **Example**: ```python arr = [3, 1, 2, 4] Output: [2, 4, 3, 1] ``` ```python arr = [0, 1, 2] Output: [0, 2, 1] ``` **Constraints**: - The algorithm should maintain the relative order of even and odd integers from the input list. - The solution should have a time complexity of O(n) where n is the length of the array. **Hints**: 1. Utilize additional data structures to collect even and odd integers separately. 2. Traverse the array only once to partition the elements. 3. Concatenate the even and odd lists to obtain the final result. **Performance Requirements**: - The time complexity of the solution should be O(n). - The space complexity should be O(n) to accommodate the output list. Write the function `parity_ordered_sort` that accurately implements the above requirements while adhering to the performance constraints provided.","solution":"def parity_ordered_sort(arr): Sort the array such that even numbers come before odd numbers, while maintaining the relative order of even and odd numbers from the original array. even = [] odd = [] for num in arr: if num % 2 == 0: even.append(num) else: odd.append(num) return even + odd"},{"question":"# Objective Implement a function that performs image edge detection using the Sobel operator, followed by thresholding and edge-linking steps. # Description The function `detect_edges(rgb_image: np.ndarray, threshold: int) -> np.ndarray` should: 1. Convert the RGB image to a grayscale image. 2. Apply the Sobel operator to detect edges. 3. Apply a threshold to the edge magnitude to create a binary edge map. 4. Perform edge-linking on the binary edge map to ensure connectivity. # Input * `rgb_image`: A 3D NumPy array of shape (M, N, 3) representing an RGB image. * `threshold`: An integer value used for thresholding the edge magnitude. # Output * A 2D binary NumPy array of the same dimensions as the input image representing the final edge-detected result. # Constraints * The input image will always be a valid NumPy array with pixel values in the range [0, 255]. * The threshold value will be an integer in the range [0, 255]. # Requirements 1. Use the following conversion formula for RGB to Grayscale: [ text{Grayscale} = 0.2989 times R + 0.5870 times G + 0.1140 times B ] 2. Apply the Sobel operator to compute the gradient magnitudes. 3. Use the provided threshold value to convert gradient magnitudes to binary edges. 4. Implement edge-linking to ensure the connectivity of detected edges. # Example ```python import numpy as np def detect_edges(rgb_image: np.ndarray, threshold: int) -> np.ndarray: # Write your implementation here pass # Example usage: rgb_image = np.array([ [[127, 255, 0], [255, 0, 0]], [[0, 0, 255], [0, 255, 0]] ]) threshold = 100 output = detect_edges(rgb_image, threshold) print(output) ```","solution":"import numpy as np from scipy.ndimage import convolve def detect_edges(rgb_image: np.ndarray, threshold: int) -> np.ndarray: # Step 1: Convert RGB to Grayscale grayscale = 0.2989 * rgb_image[:, :, 0] + 0.5870 * rgb_image[:, :, 1] + 0.1140 * rgb_image[:, :, 2] # Define Sobel operators sobel_x = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]]) sobel_y = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]]) # Step 2: Apply Sobel operators to detect edges gradient_x = convolve(grayscale, sobel_x, mode=\'reflect\') gradient_y = convolve(grayscale, sobel_y, mode=\'reflect\') # Compute gradient magnitude gradient_magnitude = np.sqrt(gradient_x**2 + gradient_y**2) # Step 3: Apply threshold to create binary edge map binary_edge_map = (gradient_magnitude >= threshold).astype(np.uint8) # Step 4: Perform edge-linking (simple edge-linking by connecting 8 neighboring pixels) def edge_linking(binary_edge): # Create a copy of the binary edge map to store the linked edges linked_edges = binary_edge.copy() h, w = binary_edge.shape for i in range(1, h-1): for j in range(1, w-1): if binary_edge[i, j] == 1: continue # Check 8-connected neighbors if np.any(binary_edge[i-1:i+2, j-1:j+2] == 1): linked_edges[i, j] = 1 return linked_edges final_edges = edge_linking(binary_edge_map) return final_edges"},{"question":"# Majority Element: Array Analysis Function **Context**: You are working on a data analysis tool that involves finding the majority element in a list of integers. A majority element is an element that appears more than `n // 2` times in the list, where `n` is the length of the list. If no such element exists, you need to handle that scenario appropriately. **Task**: Implement a function `find_majority_element(arr: List[int]) -> int` that identifies the majority element in the given list. If no majority element exists, return `-1`. **Input Format**: - A single list of integers `arr`. - The list will contain at least 1 integer and can have up to 10^5 integers. **Output Format**: - An integer representing the majority element if it exists, otherwise `-1`. **Constraints**: - The elements of the list are within the range of a 32-bit signed integer. **Examples**: ```python assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) == -1 assert find_majority_element([3, 3, 4, 4, 4, 4]) == 4 assert find_majority_element([1, 2, 3, 4, 5]) == -1 ``` **Performance Requirements**: - Ensure the function runs efficiently for large input sizes, with an expected time complexity of O(n) and a space complexity of O(1).","solution":"from typing import List def find_majority_element(arr: List[int]) -> int: Finds the majority element in the list. The majority element is the one that appears more than n/2 times. If no majority element exists, return -1. :param arr: List of integers :return: The majority element or -1 if no majority element exists if not arr: return -1 # Boyer-Moore Voting Algorithm candidate = None count = 0 for num in arr: if count == 0: candidate = num count += (1 if num == candidate else -1) # Verify the candidate if candidate is not None and arr.count(candidate) > len(arr) // 2: return candidate return -1"},{"question":"# Coding Question Context In physics, Hooke\'s Law describes the behavior of springs under load. This principle states that the force exerted by a spring is proportional to the displacement of the spring from its equilibrium position. The formula for Hooke\'s Law is given by: [ F = -kx ] Where: - ( F ) is the force exerted by the spring (in Newtons) - ( k ) is the spring constant (in Newtons per meter) - ( x ) is the displacement of the spring from its equilibrium position (in meters) You are tasked with implementing a software that helps students understand Hooke\'s Law by calculating any one of these parameters given the other two. Tasks 1. Implement a function `compute_force` to calculate the force exerted by the spring given the spring constant and displacement. 2. Implement a function `compute_spring_constant` to calculate the spring constant given the force exerted and the displacement. 3. Implement a function `compute_displacement` to calculate the displacement of the spring given the force exerted and the spring constant. # Function Signatures ```python def compute_force(spring_constant: float, displacement: float) -> float: # your code here def compute_spring_constant(force: float, displacement: float) -> float: # your code here def compute_displacement(force: float, spring_constant: float) -> float: # your code here ``` # Requirements - If the spring constant or displacement is zero in the inputs for the force or spring constant calculation, raise a `ValueError` with the message: \\"Invalid inputs. Spring constant and displacement must be non-zero.\\" - The functions should adhere to the principles of Hooke\'s Law and handle negative values correctly according to physical conventions. # Constraints - Values provided can be positive or negative based on the direction of force and displacement. - Inputs must follow realistic physical constraints. # Example Usage ```python # Test cases for force computation compute_force(200, 0.5) # should return -100.0 # Test cases for spring constant computation compute_spring_constant(150, 0.75) # should return -200.0 # Test cases for displacement computation compute_displacement(-80, 40) # should return -2.0 ``` Ensure your functions handle edge cases such as zero values and provide correct exception handling as specified.","solution":"def compute_force(spring_constant: float, displacement: float) -> float: if spring_constant == 0 or displacement == 0: raise ValueError(\\"Invalid inputs. Spring constant and displacement must be non-zero.\\") return -spring_constant * displacement def compute_spring_constant(force: float, displacement: float) -> float: if displacement == 0: raise ValueError(\\"Invalid inputs. Spring constant and displacement must be non-zero.\\") return -force / displacement def compute_displacement(force: float, spring_constant: float) -> float: if spring_constant == 0: raise ValueError(\\"Invalid inputs. Spring constant and displacement must be non-zero.\\") return -force / spring_constant"},{"question":"# Merge Two Sorted Linked Lists Problem Statement You are required to implement a function to merge two sorted singly linked lists into one sorted linked list. The resulting linked list should contain all elements from both input lists, and it should be sorted. Task Write a function `merge_sorted_lists(head1: Optional[Node], head2: Optional[Node]) -> Optional[Node]` that merges two given sorted singly linked lists: # Input ```plaintext The function takes the head nodes of two singly linked lists `head1` and `head2`: - Node: where the linked list nodes have a `data` attribute storing the node\'s value, and a `next_node` attribute pointing to the next node in the list. ``` # Output ```plaintext The function returns the head node of a new singly linked list that contains all elements from `head1` and `head2` in sorted order. ``` # Constraints * n, m: The total number of nodes in the two linked lists. (1 ≤ n, m ≤ 10<sup>6</sup>) * The values in the linked list nodes are from the set of integers. # Example ```python class Node: def __init__(self, data: Any) -> None: self.data: Any = data self.next_node: \'Node\' = None # Example 1 # List 1: 1 -> 3 -> 5 # List 2: 2 -> 4 -> 6 head1 = Node(1) head1.next_node = Node(3) head1.next_node.next_node = Node(5) head2 = Node(2) head2.next_node = Node(4) head2.next_node.next_node = Node(6) merged_head = merge_sorted_lists(head1, head2) # Output: 1 -> 2 -> 3 -> 4 -> 5 -> 6 # Example 2 # List 1: 1 -> 3 # List 2: 2 -> 4 -> 5 head1 = Node(1) head1.next_node = Node(3) head2 = Node(2) head2.next_node = Node(4) head2.next_node.next_node = Node(5) merged_head = merge_sorted_lists(head1, head2) # Output: 1 -> 2 -> 3 -> 4 -> 5 # Example 3 # List 1: (empty list) # List 2: 1 -> 2 -> 3 head1 = None head2 = Node(1) head2.next_node = Node(2) head2.next_node.next_node = Node(3) merged_head = merge_sorted_lists(head1, head2) # Output: 1 -> 2 -> 3 ``` # Function Signature ```python from typing import Optional class Node: def __init__(self, data) -> None: self.data = data self.next_node = None def merge_sorted_lists(head1: Optional[Node], head2: Optional[Node]) -> Optional[Node]: # Implement your solution here pass ``` # Notes: 1. Ensure the function is optimized for large values of n and m. 2. Handle edge cases appropriately, including cases where one or both input lists are empty. 3. The input linked list structure is provided; do not alter it.","solution":"from typing import Optional class Node: def __init__(self, data): self.data = data self.next_node = None def merge_sorted_lists(head1: Optional[Node], head2: Optional[Node]) -> Optional[Node]: # Initialize a dummy node to act as the starting point of the merged list dummy = Node(0) current = dummy # Pointers for the two lists p1, p2 = head1, head2 # Traverse both lists and compare nodes while p1 and p2: if p1.data < p2.data: current.next_node = p1 p1 = p1.next_node else: current.next_node = p2 p2 = p2.next_node current = current.next_node # Attach the remaining nodes of either list to the merged list if p1: current.next_node = p1 if p2: current.next_node = p2 # The head of the merged list is the next node of the dummy return dummy.next_node"},{"question":"# Question: Validate and Convert Roman Numerals Background: Roman numerals are represented by combinations of the following seven symbols: `I`, `V`, `X`, `L`, `C`, `D`, and `M`. | Symbol | Value | |--------|--------| | I | 1 | | V | 5 | | X | 10 | | L | 50 | | C | 100 | | D | 500 | | M | 1000 | However, not all combinations of these symbols are valid. For example, `IIII` is not a valid representation of `4` (which should be represented as `IV`), and `VV` is not a valid representation of `10` (which should be represented as `X`). Problem Statement: Write a function `roman_to_integer(roman: str) -> int` that performs the following steps: 1. **Validation**: Check if the input string is a valid Roman numeral. 2. **Conversion**: Convert the validated Roman numeral to an integer. Valid Roman Numerals: Ensure that the input string adheres to the rules of Roman numeral formation, such as: - Symbols `I`, `X`, `C`, and `M` can be repeated up to 3 times in succession. - Symbols `V`, `L`, and `D` should not be repeated. - Certain combinations are used to denote subtraction, such as `IV` for `4`, `IX` for `9`, etc. Input: * `roman`: A string representing a Roman numeral (1 ≤ length ≤ 15). Output: * Return an integer representing the value of the Roman numeral if it is valid, otherwise return -1. Example: ```python Input: roman = \\"MCMXCIV\\" Output: 1994 ``` Explanation: The Roman numeral \\"MCMXCIV\\" corresponds to: - 1000 + 900 (CM) + 90 (XC) + 4 (IV) - Total: 1994 Constraints: - Ensure the input is correctly validated to be a valid Roman numeral. - Handle edge cases such as an empty string or invalid sequences that do not conform to the rules of Roman numeral formation. --- Implement the function `roman_to_integer(roman: str) -> int` in Python and provide an analysis of its complexity.","solution":"def roman_to_integer(roman: str) -> int: roman_to_int_map = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } # Rules for valid Roman Numeral valid_subtractive_combinations = [\'IV\', \'IX\', \'XL\', \'XC\', \'CD\', \'CM\'] # Validation for an empty string if not roman: return -1 # Step 1: Validate input string is a valid Roman numeral for char in roman: if char not in roman_to_int_map: return -1 # Check valid repetition of characters if \'IIII\' in roman or \'VV\' in roman or \'XXXX\' in roman or \'LL\' in roman or \'CCCC\' in roman or \'DD\' in roman or \'MMMM\' in roman: return -1 # Check valid subtractive combinations and non-valid combinations index = 0 while index < len(roman): if index + 1 < len(roman) and (roman[index] + roman[index + 1]) not in valid_subtractive_combinations: if roman[index + 1] in roman_to_int_map and roman_to_int_map[roman[index]] < roman_to_int_map[roman[index + 1]]: return -1 index += 1 # Step 2: Conversion result = 0 i = 0 while i < len(roman): # If this is a subtractive combination if i + 1 < len(roman) and (roman[i] + roman[i + 1]) in valid_subtractive_combinations: result += roman_to_int_map[roman[i + 1]] - roman_to_int_map[roman[i]] i += 2 # Otherwise, just add the value else: result += roman_to_int_map[roman[i]] i += 1 return result"},{"question":"# Question: Generate and Validate Sudoku Boards You are tasked with creating a program that generates a partially filled Sudoku board and validates whether it can be solved according to Sudoku rules. 1. **Generate a Sudokun board**: Create a function that generates a standard 9x9 Sudoku board with some pre-filled numbers. 2. **Validate the Sudoku board**: Create a function that checks if the given Sudoku board is valid. Functional Requirements: - **Function 1**: `generate_sudoku(difficulty: str) -> list` - `difficulty`: A string indicating the difficulty level (\'easy\', \'medium\', \'hard\') which determines how many cells are pre-filled. - Returns a 2D list representing a 9x9 Sudoku board with integers between 1 and 9, and empty cells represented by 0. - **Function 2**: `is_valid_sudoku(board: list) -> bool` - `board`: A 2D list representing a 9x9 Sudoku board. - Returns `True` if the board is a valid Sudoku configuration, `False` otherwise. Input and Output - **Input**: The `generate_sudoku` function takes a single string parameter indicating difficulty, while `is_valid_sudoku` takes a board represented as a list of lists. - **Output**: The functions must return the data structures as outlined above. Constraints: - The `generate_sudoku` function should ensure the generated board follows standard Sudoku rules. - The `is_valid_sudoku` function should verify: - Each row contains unique numbers from 1 to 9. - Each column contains unique numbers from 1 to 9. - Each 3x3 sub-grid contains unique numbers from 1 to 9. - `generate_sudoku` should handle invalid difficulty levels by raising a `ValueError`. - Use the python built-in random library for generating pre-filled numbers in the Sudoku board. Example ```python board = generate_sudoku(\'medium\') # Expected output: A 9x9 list of lists representing a medium difficulty Sudoku board with some cells filled. valid = is_valid_sudoku(board) # Expected output: True or False based on whether the generated board can be solved according to Sudoku rules. ``` Write the function implementations for `generate_sudoku(difficulty: str)` and `is_valid_sudoku(board: list)`.","solution":"import random def generate_sudoku(difficulty: str) -> list: def count_to_fill(difficulty: str) -> int: if difficulty == \\"easy\\": return 36 # ~40% filled cells elif difficulty == \\"medium\\": return 27 # ~30% filled cells elif difficulty == \\"hard\\": return 18 # ~20% filled cells else: raise ValueError(\\"Invalid difficulty level\\") def is_valid(board, row, col, num): for i in range(9): if board[row][i] == num or board[i][col] == num: return False startRow, startCol = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[i + startRow][j + startCol] == num: return False return True def fill_board(board): for row in range(9): for col in range(9): if board[row][col] == 0: for num in random.sample(range(1, 10), 9): if is_valid(board, row, col, num): board[row][col] = num if fill_board(board): return board board[row][col] = 0 return False return board board = [[0 for _ in range(9)] for _ in range(9)] filled_board = fill_board(board) squares = 81 removed_squares = squares - count_to_fill(difficulty) while removed_squares > 0: row, col = random.randint(0, 8), random.randint(0, 8) while board[row][col] == 0: row, col = random.randint(0, 8), random.randint(0, 8) board[row][col] = 0 removed_squares -= 1 return board def is_valid_sudoku(board: list) -> bool: def is_valid_line(line): line_numbers = [num for num in line if num != 0] return len(set(line_numbers)) == len(line_numbers) for row in board: if not is_valid_line(row): return False for col in zip(*board): if not is_valid_line(col): return False for row in range(0, 9, 3): for col in range(0, 9, 3): sub_grid = [board[row+i][col+j] for i in range(3) for j in range(3)] if not is_valid_line(sub_grid): return False return True"},{"question":"# Optimal Meeting Point in a Grid In a bustling city, you are tasked with developing a system to determine the most optimal meeting point for a group of people located at different positions within a grid. For simplicity, the city is modeled as a 2D grid where each cell represents a possible location, and travel can only occur along the grid lines (both horizontally and vertically). Your goal is to find the cell (location) that minimizes the total travel distance for all individuals to meet at that point. The total travel distance is defined as the sum of the Manhattan distances from each individual\'s starting position to the meeting point. **Function Signature**: ```python def optimal_meeting_point(positions: List[Tuple[int, int]]) -> Tuple[int, int]: ``` **Input**: - `positions`: (List of Tuples) Each tuple consists of two integers representing the coordinates (row, column) of an individual\'s position in the grid. **Output**: - A tuple representing the coordinates (row, column) of the optimal meeting point that minimizes the total travel distance. **Constraints**: - Positions will be given in a grid with bounds 1 ≤ row, column ≤ 10^4 - 1 ≤ number of positions ≤ 10^4 **Example**: ```python >>> positions = [(1, 2), (2, 3), (4, 6)] >>> optimal_meeting_point(positions) (2, 3) ``` **Explanation**: - Suppose your individuals are currently located in a grid as follows: ``` (1, 2), (2, 3), (4, 6) ``` - After calculating, you find that the point (2, 3) minimizes the total distance each individual has to travel to meet, in this particular case 3 + 0 + 4 = 7 units of distance. - Your function should return the coordinates (2, 3) as these minimize the overall travel distance. **Important Considerations**: - The optimal meeting point might not necessarily be one of the starting positions. - Ensure to handle large input efficiently, considering the constraints on coordinate values and the number of positions. - Use appropriate strategies such as sorting and careful selection of median points in relation to the Manhattan distance properties to achieve the optimal result efficiently. Good luck!","solution":"from typing import List, Tuple def optimal_meeting_point(positions: List[Tuple[int, int]]) -> Tuple[int, int]: Given a list of positions (row, column), finds the optimal meeting point that minimizes the total travel distance using Manhattan distance. if not positions: return (0, 0) # Extract the rows and columns rows = [pos[0] for pos in positions] columns = [pos[1] for pos in positions] # Sort the rows and columns separately rows.sort() columns.sort() # Find the median median_row = rows[len(rows) // 2] median_column = columns[len(columns) // 2] return (median_row, median_column)"},{"question":"# Array Splitter Problem You are given an array consisting of `N` integers. Your task is to determine if you can split this array into two non-empty subsets such that the sum of the elements in both subsets is equal. Return `True` if such a split is possible, otherwise, return `False`. # Function Signature ```python def can_split_array(nums: List[int]) -> bool: pass ``` # Input * `nums` (List[int]): A list of integers representing the array. * For example, `[1, 5, 11, 5]`. # Output * Returns (bool): A boolean value indicating whether the array can be partitioned into two subsets with equal sums. # Constraints * 1 <= len(nums) <= 100 * 1 <= nums[i] <= 100 # Example ```python assert can_split_array([1, 5, 11, 5]) == True assert can_split_array([1, 2, 3, 5]) == False ``` # Explanation For the first example, the array `[1, 5, 11, 5]` can be split into `[1, 5, 5]` and `[11]` which have equal sums of `11`. Therefore, the function should return `True`. For the second example, the array `[1, 2, 3, 5]` cannot be split into two subsets with equal sums, so the function should return `False`. # Notes * The problem should be solved using techniques such as dynamic programming or recursion with memoization to efficiently determine whether such a split is possible. * Pay attention to edge cases such as arrays with very few numbers, as they might require special consideration.","solution":"from typing import List def can_split_array(nums: List[int]) -> bool: total_sum = sum(nums) # If the total sum is odd, it is not possible to split into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Dynamic programming approach dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"# Coding Question: URL Shortener You need to implement a simple URL shortening service that shortens long URLs into short aliases. The service should be able to generate a unique short URL for a given long URL and retrieve the original long URL from the shortened version. Function Signatures ```python class URLShortener: def __init__(self): pass def shorten(self, long_url: str) -> str: pass def restore(self, short_url: str) -> str: pass ``` Methods 1. `__init__`: - Initializes the URL shortening service, setting up any necessary data structures. 2. `shorten`: - Takes a `long_url` (string) as input and returns a unique `short_url` (string). - The `short_url` should be a shortened alias. 3. `restore`: - Takes a `short_url` (string) as input and returns the original `long_url` (string). - If the `short_url` was not generated by this service, raise a `ValueError` with the message `\\"Short URL not found\\"`. Constraints * The long URL should be a valid URL. * The short URL should be unique for each long URL. * You can use any method to generate the short URL, such as a hash or a sequence of characters. Examples ```python >>> url_shortener = URLShortener() >>> short_url = url_shortener.shorten(\\"https://www.example.com/some/very/long/url\\") >>> short_url \'sht.ly/1a2b3c\' >>> original_url = url_shortener.restore(short_url) >>> original_url \'https://www.example.com/some/very/long/url\' >>> invalid_url = url_shortener.restore(\'sht.ly/invalid\') Traceback (most recent call last): ... ValueError: Short URL not found ``` Notes * Ensure the `shorten` method generates unique short URLs each time it\'s called with a unique long URL. * The `restore` method should accurately retrieve the long URL associated with the given short URL, and handle invalid short URLs appropriately. Validation To validate your implementation, write test cases to ensure: * The functionality of converting long URLs to short URLs. * The restoration of long URLs from short URLs. * Proper handling of invalid short URLs. * Edge cases such as very long and very short URLs.","solution":"import hashlib class URLShortener: def __init__(self): self.url_map = {} self.base_url = \\"sht.ly/\\" def shorten(self, long_url: str) -> str: # Create a hash of the long URL using md5 hash_object = hashlib.md5(long_url.encode()) short_hash = hash_object.hexdigest()[:6] short_url = self.base_url + short_hash self.url_map[short_url] = long_url return short_url def restore(self, short_url: str) -> str: if short_url not in self.url_map: raise ValueError(\\"Short URL not found\\") return self.url_map[short_url]"},{"question":"# Problem Statement Design a function that simulates a basic airport check-in system where passengers with different ticket classes are processed. The check-in system should ensure that passengers with higher priority are processed before those with lower priority, and within the same priority, they should maintain their order of arrival. # Objectives 1. **Implement a priority-based check-in system**. 2. **Maintain the order of arrival for passengers with the same priority**. 3. **Process passengers for check-in and update the system accordingly**. # Requirements 1. Implement the class `AirportCheckIn` with the following methods: * `add_passenger(name, ticket_class)`: Adds a passenger to the check-in system. - `name` (str): The name of the passenger. - `ticket_class` (str): The class of the ticket for the passenger, one of \'First\', \'Business\', \'Premium Economy\', \'Economy\'. * `process_next_passenger()`: Processes the next passenger in line and returns their name. - The order of processing should be: \'First\' > \'Business\' > \'Premium Economy\' > \'Economy\'. - Within the same class, passengers are processed in the order they were added. * `get_remaining_passengers()`: Returns a list of remaining passengers\' names in the order they will be processed. # Input Format * `name`: A string representing the name of the passenger. * `ticket_class`: A string denoting the class of the ticket; can be \'First\', \'Business\', \'Premium Economy\', or \'Economy\'. # Output Format - For `process_next_passenger()`: A string representing the name of the processed passenger. - For `get_remaining_passengers()`: A list of strings representing the names of remaining passengers in the order of processing. # Example ```python check_in_system = AirportCheckIn() check_in_system.add_passenger(\\"Alice\\", \\"Economy\\") check_in_system.add_passenger(\\"Bob\\", \\"Business\\") check_in_system.add_passenger(\\"Charlie\\", \\"First\\") check_in_system.add_passenger(\\"Dave\\", \\"Economy\\") check_in_system.process_next_passenger() # Output: \\"Charlie\\" print(check_in_system.get_remaining_passengers()) # Output: [\\"Bob\\", \\"Alice\\", \\"Dave\\"] check_in_system.add_passenger(\\"Eve\\", \\"Business\\") print(check_in_system.get_remaining_passengers()) # Output: [\\"Bob\\", \\"Eve\\", \\"Alice\\", \\"Dave\\"] check_in_system.process_next_passenger() # Output: \\"Bob\\" ``` # Constraints * You may assume a maximum of 1000 passengers at any given time. * Ensure that the check-in system maintains optimal performance with a time complexity of O(1) for `add_passenger` and `process_next_passenger` methods.","solution":"from collections import deque, defaultdict class AirportCheckIn: def __init__(self): self.passenger_queues = { \'First\': deque(), \'Business\': deque(), \'Premium Economy\': deque(), \'Economy\': deque() } def add_passenger(self, name, ticket_class): Adds a passenger to the check-in system. :param name (str): The name of the passenger. :param ticket_class (str): The class of the ticket for the passenger, one of \'First\', \'Business\', \'Premium Economy\', \'Economy\'. if ticket_class in self.passenger_queues: self.passenger_queues[ticket_class].append(name) def process_next_passenger(self): Processes the next passenger in line and returns their name. :return: str - The name of the processed passenger. for ticket_class in [\'First\', \'Business\', \'Premium Economy\', \'Economy\']: if self.passenger_queues[ticket_class]: return self.passenger_queues[ticket_class].popleft() return None def get_remaining_passengers(self): Returns a list of remaining passengers\' names in the order they will be processed. :return: list of str - The names of the remaining passengers. remaining_passengers = [] for ticket_class in [\'First\', \'Business\', \'Premium Economy\', \'Economy\']: remaining_passengers.extend(self.passenger_queues[ticket_class]) return remaining_passengers"},{"question":"# Matrix Multiplication Optimization In scientific computing and data analysis, matrix operations are fundamental. One such operation is matrix multiplication, which involves the product of two matrices. Optimizing this operation is crucial for handling large datasets efficiently. Description Implement a function `strassen_matrix_multiplication` that multiplies two given square matrices using the Strassen algorithm. The Strassen algorithm reduces the number of recursive multiplications when compared to the traditional algorithm, making it more efficient for larger matrices. Requirements - Use Strassen\'s approach to recursively divide and conquer the matrix multiplication task. - For matrices that are not powers of 2 in size, pad them with zeros to the next power of 2. - Ensure the final result does not include these padding zeros. Function Signature ```python def strassen_matrix_multiplication(A: List[List[int]], B: List[List[int]]) -> List[List[int]]: ``` Parameters: - `A (List[List[int]])`: The first matrix (n x n). - `B (List[List[int]])`: The second matrix (n x n). Returns: - `List[List[int]]`: The product matrix `C` (n x n). Example Use Case: ```python >>> A = [ ... [1, 2], ... [3, 4] ... ] >>> B = [ ... [5, 6], ... [7, 8] ... ] >>> strassen_matrix_multiplication(A, B) [[19, 22], [43, 50]] ``` Constraints: - Matrix `A` and `B` will have dimensions that are powers of 2, otherwise, they will be padded within the function. - Assume that the values in the matrices are integers and within a reasonable range to prevent overflow in intermediate steps. Notes: - The Strassen algorithm is not suitable for small matrices due to overheads; apply the traditional method for very small sizes (e.g., 2x2 or 4x4). - Use appropriate data structures and recursion to handle the sub-matrix calculations. Employ the recursive method to achieve the Strassen multiplication, leveraging the optimized approach to matrix splitting and combination. Ensure the solution is efficient for larger matrices, demonstrating an understanding of both traditional and Strassen methods of matrix multiplication.","solution":"def strassen_matrix_multiplication(A, B): Multiplies two matrices using Strassen\'s algorithm. Parameters: A, B: matrices (represented as lists of lists) to be multiplied. They should be square matrices (n x n). Returns: List of lists representing the resulting product matrix. # Traditional matrix multiplication for base case def traditional_mult(A, B): size = len(A) result = [[0]*size for _ in range(size)] for i in range(size): for j in range(size): for k in range(size): result[i][j] += A[i][k] * B[k][j] return result # Function to add two matrices def add_matrix(A, B): size = len(A) result = [[A[i][j] + B[i][j] for j in range(size)] for i in range(size)] return result # Function to subtract two matrices def sub_matrix(A, B): size = len(A) result = [[A[i][j] - B[i][j] for j in range(size)] for i in range(size)] return result # Function to divide matrix into quadrants def divide_matrix(M): n = len(M) mid = n // 2 M11 = [[M[i][j] for j in range(mid)] for i in range(mid)] M12 = [[M[i][j] for j in range(mid, n)] for i in range(mid)] M21 = [[M[i][j] for j in range(mid)] for i in range(mid, n)] M22 = [[M[i][j] for j in range(mid, n)] for i in range(mid, n)] return M11, M12, M21, M22 # Function to combine quadrants into a single matrix def combine_matrix(C11, C12, C21, C22): n = len(C11) * 2 C = [[0]*n for _ in range(n)] mid = n // 2 for i in range(mid): for j in range(mid): C[i][j] = C11[i][j] C[i][j + mid] = C12[i][j] C[i + mid][j] = C21[i][j] C[i + mid][j + mid] = C22[i][j] return C n = len(A) if n == 1: return [[A[0][0] * B[0][0]]] if n <= 2: return traditional_mult(A, B) # Dividing matrices A and B into 4 sub-matrices each A11, A12, A21, A22 = divide_matrix(A) B11, B12, B21, B22 = divide_matrix(B) # Calculating the 7 products, recursively P1 = strassen_matrix_multiplication(add_matrix(A11, A22), add_matrix(B11, B22)) P2 = strassen_matrix_multiplication(add_matrix(A21, A22), B11) P3 = strassen_matrix_multiplication(A11, sub_matrix(B12, B22)) P4 = strassen_matrix_multiplication(A22, sub_matrix(B21, B11)) P5 = strassen_matrix_multiplication(add_matrix(A11, A12), B22) P6 = strassen_matrix_multiplication(sub_matrix(A21, A11), add_matrix(B11, B12)) P7 = strassen_matrix_multiplication(sub_matrix(A12, A22), add_matrix(B21, B22)) # Combining the results C11 = add_matrix(sub_matrix(add_matrix(P1, P4), P5), P7) C12 = add_matrix(P3, P5) C21 = add_matrix(P2, P4) C22 = add_matrix(sub_matrix(add_matrix(P1, P3), P2), P6) # Combining the sub-matrices into the final result return combine_matrix(C11, C12, C21, C22) # Helper function to pad matrices to the next power of 2 def pad_matrix(matrix, size): padded = [[0]*size for _ in range(size)] current_size = len(matrix) for i in range(current_size): for j in range(current_size): padded[i][j] = matrix[i][j] return padded def prepare_for_strassen(A, B): Prepares matrices by padding them to the next power of 2 size, if needed, and then performs multiplication by Strassen algorithm. n = len(A) new_size = 1 while new_size < n: new_size *= 2 if new_size == n: C = strassen_matrix_multiplication(A, B) else: padded_A = pad_matrix(A, new_size) padded_B = pad_matrix(B, new_size) padded_C = strassen_matrix_multiplication(padded_A, padded_B) # Trimming the padding zeros C = [row[:n] for row in padded_C[:n]] return C"},{"question":"# Problem Statement Implement a function to calculate the area of a triangle given its base and height. The area of a triangle can be computed using the formula: [ text{Area} = frac{1}{2} times b times h ] Write a function `triangle_area(b: float, h: float) -> float` that takes two parameters: - `b`: A positive float representing the base of the triangle (in units). - `h`: A positive float representing the height of the triangle (in units). The function should return the area of the triangle in square units. If either `b` or `h` is zero or negative, the function should raise a `ValueError` with an appropriate message. # Input/Output * **Input**: - `b` (0 < b <= 10⁶) - `h` (0 < h <= 10⁶) * **Output**: - A single float representing the area of the triangle in square units. * **Constraints/Mentions**: - The output should be a float rounded to a reasonable precision. - Handling error inputs properly. # Examples 1. **Example 1**: ```python b = 5 h = 10 triangle_area(b, h) -> 25.0 ``` 2. **Example 2**: ```python b = 7.5 h = 3.2 triangle_area(b, h) -> 12.0 ``` 3. **Example 3**: ```python b = 0 h = 4 triangle_area(b, h) -> Raises a ValueError \\"Base cannot be 0 or negative\\" ``` Make sure to handle edge cases and write clean, efficient code. Validate your solution with the provided functional tests in your environment.","solution":"def triangle_area(b: float, h: float) -> float: Calculate the area of a triangle given its base and height. Parameters: b (float): base of the triangle. Must be a positive float. h (float): height of the triangle. Must be a positive float. Returns: float: area of the triangle. if b <= 0: raise ValueError(\\"Base cannot be 0 or negative\\") if h <= 0: raise ValueError(\\"Height cannot be 0 or negative\\") return 0.5 * b * h"},{"question":"# In-Place Heap Sort Implementation Heap sort is a comparison-based sorting technique based on a Binary Heap data structure. It is one of the most efficient sorting algorithms, particularly suitable for large datasets as it has an (O(n log n)) average time complexity. Task Implement the heap sort algorithm to sort an array of integers. The sorting must be done in-place to ensure space efficiency. Input * An array `arr` of integers with `n` elements, where `1 ≤ n ≤ 10^6`. Output * A sorted list of integers derived from `arr`. Heap Sort Characteristics * Utilizes a binary heap data structure to sort elements. * Heaps can be represented as arrays, where the root element is at index 0. * The algorithm involves building a max heap and then repeatedly swapping the root of the heap with the last element of the current heap and reducing the heap size until fully sorted. Function Signature ```python def heap_sort(arr: list[int]) -> list[int]: pass ``` Example ```python >>> heap_sort([5, 2, 7]) [2, 5, 7] >>> heap_sort([1, 1, 2, 2, 3]) [1, 1, 2, 2, 3] >>> heap_sort([10, 9, 8, 7, 6]) [6, 7, 8, 9, 10] >>> heap_sort([15, 10, 20, 5, 3, 8, 12, 25]) [3, 5, 8, 10, 12, 15, 20, 25] ``` Constraints * The implementation should handle edge cases such as an array of one element or being empty. * Time Complexity: (O(n log n)) due to heap operations. * Space Complexity: (O(1)) since sorting is done in-place. Tips * Build the max heap by rearranging the array. * Use the built-in methods to maintain the heap property (heapify). * Extract elements from the heap one by one, ensuring the largest element is placed at the end of the current heap segment.","solution":"def heapify(arr, n, i): To heapify a subtree rooted with node i which is an index in arr[]. n is the size of the heap largest = i left = 2 * i + 1 right = 2 * i + 2 if left < n and arr[left] > arr[largest]: largest = left if right < n and arr[right] > arr[largest]: largest = right if largest != i: arr[i], arr[largest] = arr[largest], arr[i] heapify(arr, n, largest) def heap_sort(arr): Perform heap sort on the given list of integers. n = len(arr) # Build a maxheap. for i in range(n // 2 - 1, -1, -1): heapify(arr, n, i) # One by one extract elements for i in range(n-1, 0, -1): arr[i], arr[0] = arr[0], arr[i] heapify(arr, i, 0) return arr"},{"question":"# Question: Implement a Basic Calculator You are tasked with implementing a basic calculator that can evaluate simple mathematical expressions. The expressions may include integer numbers, parentheses, and the operators `+`, `-`, `*`, and `/`. **Function Definition**: `calculator(expression: str) -> float` **Inputs**: - The function takes a single argument `expression`, which is a string representing a valid mathematical expression. The string will contain only integers, parentheses `()`, and the operators `+`, `-`, `*`, and `/`. **Outputs**: - The function returns a float representing the evaluated result of the expression. **Constraints**: - The input expression will not exceed 1000 characters. - Division by zero should be handled by raising a `ZeroDivisionError`. - The expression will always be a valid mathematical expression. # Example ```python print(calculator(\\"3+5\\")) # Output: 8.0 print(calculator(\\"(2+3)*4\\")) # Output: 20.0 print(calculator(\\"10 + 2 * 6\\")) # Output: 22.0 print(calculator(\\"100 * 2 + 12\\")) # Output: 212.0 print(calculator(\\"100 * ( 2 + 12 )\\")) # Output: 1400.0 print(calculator(\\"100 * ( 2 + 12 ) / 14\\")) # Output: 100.0 ``` # Performance Requirements: - Time complexity should be appropriate for expressions of length up to `1000`. Implement the `calculator` function ensuring it correctly processes the input expression and returns accurate results, handling edge cases appropriately.","solution":"import operator import re def calculator(expression: str) -> float: Evaluates a mathematical expression. def eval_inner(tokens): stack = [] num = \\"\\" sign = \\"+\\" while tokens or num: if tokens: ch = tokens.pop(0) else: ch = \\"\\" if ch.isdigit(): num += ch if ch == \'(\': num = str(eval_inner(tokens)) if (not ch.isdigit() and ch != \\" \\") or ch == \\"\\" or ch == \\")\\": if sign == \\"+\\": stack.append(float(num)) elif sign == \\"-\\": stack.append(-float(num)) elif sign == \\"*\\": stack.append(stack.pop() * float(num)) elif sign == \\"/\\": denominator = float(num) if denominator == 0: raise ZeroDivisionError(\\"division by zero\\") stack.append(stack.pop() / denominator) num = \\"\\" if ch == \\")\\": break sign = ch return sum(stack) tokens = list(expression) return eval_inner(tokens) # Example usage: #print(calculator(\\"3+5\\")) # Output: 8.0 #print(calculator(\\"(2+3)*4\\")) # Output: 20.0 #print(calculator(\\"10 + 2 * 6\\")) # Output: 22.0 #print(calculator(\\"100 * 2 + 12\\")) # Output: 212.0 #print(calculator(\\"100 * ( 2 + 12 )\\")) # Output: 1400.0 #print(calculator(\\"100 * ( 2 + 12 ) / 14\\")) # Output: 100.0"},{"question":"# Array Rotation Operations **Context**: Array rotation is a common operation where elements are shifted left or right by a given number of positions. Implement functions that perform both left and right rotations on a list of integers. Additionally, implement a function to rotate the list n number of times. **Tasks**: 1. `rotate_left(arr: list, k: int) -> list`: Rotates the array `arr` to the left by `k` positions. 2. `rotate_right(arr: list, k: int) -> list`: Rotates the array `arr` to the right by `k` positions. 3. `n_rotations(arr: list, n: int) -> list`: Rotates the array `arr` to the right by `n` times. **Input and Output**: - **Input**: Each function takes a list `arr` of integers and an integer `k` or `n`. - **Output**: Each function returns a new list of integers with the elements rotated. **Constraints**: - `0 <= len(arr) <= 10^5` - `0 <= k, n <= 10^5` - List `arr` contains integers where `-10^6 <= arr[i] <= 10^6` **Performance Requirements**: Operations should run in O(len(arr)) time, and use O(len(arr)) extra space. **Examples**: ```python assert rotate_left([1, 2, 3, 4, 5], 2) == [3, 4, 5, 1, 2] assert rotate_right([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] assert n_rotations([1, 2, 3, 4, 5], 3) == [3, 4, 5, 1, 2] ``` **Note**: Implement the following functions in a single file named `array_rotation.py`: ```python def rotate_left(arr: list, k: int) -> list: pass def rotate_right(arr: list, k: int) -> list: pass def n_rotations(arr: list, n: int) -> list: pass ```","solution":"def rotate_left(arr: list, k: int) -> list: Rotates the array `arr` to the left by `k` positions. if not arr: return arr k = k % len(arr) return arr[k:] + arr[:k] def rotate_right(arr: list, k: int) -> list: Rotates the array `arr` to the right by `k` positions. if not arr: return arr k = k % len(arr) return arr[-k:] + arr[:-k] def n_rotations(arr: list, n: int) -> list: Rotates the array `arr` to the right by `n` times. return rotate_right(arr, n)"},{"question":"# Image Processing - Gaussian Blur Implementation **Scenario**: In digital image processing, you frequently need to apply a Gaussian blur to an image to reduce noise and detail. Gaussian blur is a type of image-blurring filter that uses a Gaussian function. Implement a class that applies a Gaussian blur to a grayscale image using a specified kernel size and standard deviation. **Task**: Implement a `GaussianBlur` class in Python which performs the following tasks: 1. Generate a Gaussian kernel given the specified size and standard deviation. 2. Apply the Gaussian kernel to a given grayscale image to produce a blurred effect. **Function Signature**: ```python class GaussianBlur: def __init__(self, kernel_size: int, sigma: float) -> None: pass @staticmethod def _get_gaussian_kernel(kernel_size: int, sigma: float) -> np.ndarray: pass def apply_blur(self, image: np.ndarray) -> np.ndarray: pass ``` # Constraints: 1. **Inputs**: - `kernel_size`: Integer, the size of the Gaussian kernel (must be an odd positive number). - `sigma`: Float, the standard deviation of the Gaussian function. - `image`: 2-D numpy array of shape (H, W) representing the grayscale image. 2. **Outputs**: - Blurred image as a 2-D numpy array of the same shape as the input image. **Example**: ```python import numpy as np image = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=np.float32) gaussian_blur = GaussianBlur(kernel_size=3, sigma=1.0) blurred_image = gaussian_blur.apply_blur(image) print(blurred_image) ``` # Performance Requirements: 1. Ensure the implementation is capable of efficiently handling high-resolution images. 2. Optimize for both time and space complexity keeping in mind the large potential size of images. # Additional Requirements: 1. The Gaussian kernel must be normalized so that its sum is 1. 2. Raise appropriate errors for invalid inputs, such as non-odd kernel sizes or negative standard deviations. # Hint: 1. Utilize the separability property of the Gaussian kernel for optimized convolution. 2. Consider using convolution functions from libraries like `scipy.ndimage` for efficient computation. Sample Output: Given the example input, the output should be a blurred version of the provided image, effectively demonstrating the reduction of noise and details as per the Gaussian blur algorithm applied. The exact numerical values may vary based on the implementation details of the kernel generation and application process.","solution":"import numpy as np from scipy.ndimage import gaussian_filter class GaussianBlur: def __init__(self, kernel_size: int, sigma: float) -> None: if kernel_size % 2 == 0 or kernel_size <= 0: raise ValueError(\'Kernel size must be an odd positive number.\') if sigma <= 0: raise ValueError(\'Sigma must be a positive number.\') self.kernel_size = kernel_size self.sigma = sigma @staticmethod def _get_gaussian_kernel(kernel_size: int, sigma: float) -> np.ndarray: # Generate a 1D Gaussian kernel of specified size and sigma ax = np.linspace(-(kernel_size - 1) / 2., (kernel_size - 1) / 2., kernel_size) gauss = np.exp(-0.5 * np.square(ax) / np.square(sigma)) gauss = gauss / np.sum(gauss) # Normalize the kernel so the sum is 1 return gauss def apply_blur(self, image: np.ndarray) -> np.ndarray: # Apply Gaussian blur using scipy\'s gaussian_filter for efficiency return gaussian_filter(image, sigma=self.sigma)"},{"question":"Implement a Prefix Sum Array Function Your task is to implement a function that computes the prefix sums for a given list of integers. The prefix sum array is an array of the same length where each element is the sum of all the integers in the input array up to the corresponding index. # Function Signature ```python def prefix_sum_array(arr: List[int]) -> List[int]: Given a list of integers, returns a list containing the prefix sum for each element in the list. Args: arr: List[int] - A list of integers Returns: List[int] - A list containing the prefix sum of each element in arr. ``` # Input * A single list `arr` containing integers. # Output * A list where each element is the prefix sum of the elements from the input list up to the same index. # Constraints * 0 <= len(arr) <= 10^6 * -10^6 <= arr[i] <= 10^6 # Example ```python >>> prefix_sum_array([1, 2, -3, 4]) [1, 3, 0, 4] >>> prefix_sum_array([0, 0, 0, 0]) [0, 0, 0, 0] >>> prefix_sum_array([1, -1, 1, -1]) [1, 0, 1, 0] >>> prefix_sum_array([]) [] ``` # Performance Requirements * The solution should have a time complexity of O(n) and a space complexity of O(n). # Notes * Ensure to handle edge cases, such as empty lists. * Ensure to correctly handle lists with negative integers. # Additional Context Imagine you\'re working on an analytical tool that requires cumulative data processing. You need to compute running totals efficiently as part of a preprocessing step. Implement a function that can handle this computation even for large datasets.","solution":"from typing import List def prefix_sum_array(arr: List[int]) -> List[int]: Given a list of integers, returns a list containing the prefix sum for each element in the list. Args: arr: List[int] - A list of integers Returns: List[int] - A list containing the prefix sum of each element in arr. if not arr: return [] prefix_sums = [0] * len(arr) prefix_sums[0] = arr[0] for i in range(1, len(arr)): prefix_sums[i] = prefix_sums[i - 1] + arr[i] return prefix_sums"},{"question":"# Coding Assessment Question Objective Implement a Python function to locate the minimum spanning tree (MST) for a given graph using Prim\'s Algorithm. Analyze the graph representations and apply the correct approach to solve the problem. Problem Statement You are given an undirected graph represented using an adjacency matrix. You need to implement a function that computes the MST using Prim\'s Algorithm. 1. `prim_mst(graph: List[List[int]]) -> List[Tuple[int, int, int]]`: * Implements Prim\'s Algorithm to find the MST. * Returns a list of edges that form the MST. Each edge is represented as a tuple `(u, v, w)`, where `u` and `v` are nodes and `w` is the weight of the edge. Input * `graph`: A 2D list where `graph[i][j]` represents the weight of the edge between nodes `i` and `j`. A weight of `0` means there is no direct edge. Output * A list of tuples representing the edges in the MST, in the format [(u1, v1, w1), (u2, v2, w2), ...]. If the graph is not connected or invalid, return `None`. Constraints * `0 <= len(graph) <= 100` * `0 <= graph[i][j] <= 1000` * Elements on the diagonal of the matrix are always `0`, meaning no loops (`graph[i][i] == 0`). Requirements * Implement and compute the MST using Prim\'s Algorithm. * Ensure your implementation handles edge cases and provides the correct MST for connected graphs. Example Cases **Case 1: Simple Connected Graph** Input: ```python graph = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0] ] ``` Output using `prim_mst`: ```python [(0, 1, 2), (1, 2, 3), (1, 4, 5), (0, 3, 6)] ``` **Case 2: Disconnected Graph** Input: ```python graph = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] ``` Output using `prim_mst`: ```python None ``` Implementation Note Make sure to handle scenarios where the graph might be completely disconnected or contains isolated nodes. Your solution should be efficient and suitable for large inputs up to the constraints specified.","solution":"def prim_mst(graph): Implements Prim\'s Algorithm to find the MST of the given graph represented by an adjacency matrix. import heapq n = len(graph) if n == 0: return None # Define the MST and visited arrays mst_edges = [] visited = [False] * n min_heap = [] # Start from the first vertex start_vertex = 0 visited[start_vertex] = True # Add all the edges from the start vertex to the priority queue (min heap) for v in range(n): if graph[start_vertex][v] != 0: heapq.heappush(min_heap, (graph[start_vertex][v], start_vertex, v)) while min_heap: weight, u, v = heapq.heappop(min_heap) if not visited[v]: visited[v] = True mst_edges.append((u, v, weight)) for next_vertex in range(n): if graph[v][next_vertex] != 0 and not visited[next_vertex]: heapq.heappush(min_heap, (graph[v][next_vertex], v, next_vertex)) if len(mst_edges) != n - 1: return None # The graph is not connected return mst_edges"},{"question":"# Binary Search Tree (BST) Serialization and Deserialization You are tasked with implementing serialization and deserialization for a Binary Search Tree (BST). Serialization involves converting the BST into a string representation, while deserialization converts that string representation back into the original BST structure. Write two functions: 1. `serialize(root: Optional[TreeNode]) -> str`: that takes the root of a BST and returns a string representation of the tree. 2. `deserialize(data: str) -> Optional[TreeNode]`: that takes a string representation of a BST and reconstructs the original tree. Here is the definition for the `TreeNode` class: ``` python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` Constraints: 1. The values of the BST nodes are unique integers. 2. The BST values are in the range `-1000 <= val <= 1000`. 3. The number of nodes in the BST will not exceed `1000`. Expected Input/Output: - Input: ``` python root = TreeNode(2) root.left = TreeNode(1) root.right = TreeNode(3) serialized_data = serialize(root) ``` - Output: ``` python serialized_data = \\"2,1,3\\" ``` - Serialization Example: ``` python root = TreeNode(5) root.left = TreeNode(3) root.right = TreeNode(7) root.left.left = TreeNode(2) root.left.right = TreeNode(4) root.right.left = TreeNode(6) root.right.right = TreeNode(8) serialized_data = serialize(root) print(serialized_data) # Output: \\"5,3,7,2,4,6,8\\" ``` - Deserialization Example: ``` python serialized_data = \\"5,3,7,2,4,6,8\\" root = deserialize(serialized_data) print(serialize(root)) # Output: \\"5,3,7,2,4,6,8\\" ``` Notes: 1. Ensure your function handles edge cases, such as an empty tree (`root` is `None`). 2. Focus on maintaining the binary search tree properties during deserialization. 3. Your implementation should be efficient, given the constraints. Implement these functions ensuring they adhere to the specified requirements and properly cover edge cases.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def serialize(root): Encodes a BST to a single string. :param root: TreeNode :return: str def preorder(node): return [str(node.val)] + preorder(node.left) + preorder(node.right) if node else [] return \',\'.join(preorder(root)) def deserialize(data): Decodes the encoded data to reconstruct a BST. :param data: str :return: TreeNode if not data: return None data = list(map(int, data.split(\',\'))) def build_tree(data, min_val, max_val): if not data or data[0] < min_val or data[0] > max_val: return None val = data.pop(0) root = TreeNode(val) root.left = build_tree(data, min_val, val) root.right = build_tree(data, val, max_val) return root return build_tree(data, float(\'-inf\'), float(\'inf\'))"},{"question":"# Coding Assessment Question Context You are designing a function for a calendar application that needs to determine the number of days in a particular month of a given year. Problem Statement Implement a Python function named `days_in_month(year: int, month: int) -> int` that calculates the number of days in a specified month for a given year, considering leap years. Requirements 1. **Input Format**: - The function will receive two integers: `year` (a four-digit number representing the year) and `month` (an integer between 1 and 12, inclusive, representing the month). 2. **Output Format**: - The function should return an integer representing the number of days in the specified month of the given year. 3. **Constraints**: - The `year` will be a valid four-digit integer (e.g., 1900, 2021, 2024). - The `month` will be a valid integer between 1 and 12, inclusive. 4. **Performance**: - The function should run with a time complexity of O(1), ensuring it efficiently handles the input. 5. **Scenario**: - Test the function with typical, edge, and leap year cases to ensure accurate day calculations. Example Usage ```python >>> days_in_month(2023, 2) 28 >>> days_in_month(2020, 2) 29 >>> days_in_month(2021, 4) 30 >>> days_in_month(2000, 12) 31 ``` Implementation Guidelines To determine if a given year is a leap year, follow these rules: - A year that is divisible by 4 is a leap year, - unless it is also divisible by 100, in which case it is not a leap year, - unless it is also divisible by 400, in which case it is a leap year. Use this leap year logic to properly account for the number of days in February, and ensure that the function handles all edge cases correctly.","solution":"def days_in_month(year: int, month: int) -> int: Returns the number of days in a given month of a specified year, considering leap years. Parameters: year (int): The year (a four-digit number). month (int): The month (an integer between 1 and 12, inclusive). Returns: int: The number of days in the specified month and year. # Define the number of days for each month month_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # Check for leap year if month == 2: if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): return 29 else: return 28 # Return the days in the given month return month_days[month - 1]"},{"question":"# Question: Design and implement a function that takes a string consisting of digits and characters and finds the largest possible integer that can be formed from the substrings of digits present in the input string. A substring can be formed by sequentially traversing the input string and considering characters until a non-digit character is encountered. If no digits are found, return 0. # Input: - A single string `input_string` composed of digits (0-9) and/or lower and uppercase alphabetic characters (a-z, A-Z). # Output: - An integer representing the largest possible integer formed by the substrings of digits in the input string. # Constraints: - Input string length can be up to 10^6 characters. # Function Signature: ```python def largest_integer_from_substrings(input_string: str) -> int: pass ``` # Example: ```python >>> largest_integer_from_substrings(\'a123bc456d789e\') 789 >>> largest_integer_from_substrings(\'abc\') 0 >>> largest_integer_from_substrings(\'42a10b7\') 42 ``` **Note**: Your function should efficiently handle the input string to extract digit substrings and determine the largest integer formed among them.","solution":"def largest_integer_from_substrings(input_string: str) -> int: Takes a string consisting of digits and characters and returns the largest integer formed from substrings of digits. max_integer = 0 current_number = \\"\\" for char in input_string: if char.isdigit(): current_number += char else: if current_number: max_integer = max(max_integer, int(current_number)) current_number = \\"\\" if current_number: # In case the string ends with digits max_integer = max(max_integer, int(current_number)) return max_integer"},{"question":"# Advanced Diving Depth Calculator In this challenge, you have to develop a function that calculates the safe ascension time for a diver based on their maximum depth during the dive. The safe ascension time is the time it takes for a diver to safely ascend to the surface, preventing decompression sickness (also known as \\"the bends\\"). The ascension time depends on the depth and should follow the guidelines provided by dive tables. # Task Complete the function `safe_ascension_time` provided below. Your implementation should calculate the safe ascension time given the diving depth and follow standard safety regulations. # Requirements - Implement the function to compute the safe ascension time based on the depth using a linear rate of ascent. - The diver ascends at a rate of 9 meters per minute until reaching 6 meters below the surface. - Once the diver reaches 6 meters below the surface, they must take a safety stop for 3 minutes before ascending the remaining 6 meters at the same ascent rate. # Implementation Details *Function Signature*: ```python def safe_ascension_time(depth: float) -> float: pass ``` **Arguments**: - `depth` (float): The maximum depth of the dive in meters. **Returns**: - `float`: The total safe ascension time in minutes. # Constraints - Depth will be a positive number, and standard recreational diving depths will be considered (e.g., up to 40 meters). - Assume the diver always performs the safety stop, even for shallower dives. # Example Usage Example 1: ```python # Diving depth of 30 meters print(f\\"{safe_ascension_time(30):0.2f} minutes\\") # Output: \'6.33 minutes\' (expect approx) ``` Example 2: ```python # Diving depth of 15 meters print(f\\"{safe_ascension_time(15):0.2f} minutes\\") # Output: \'4.67 minutes\' (expect approx) ``` Example 3: ```python # Diving depth of 5 meters print(f\\"{safe_ascension_time(5):0.2f} minutes\\") # Output: \'3.67 minutes\' (expect approx) ``` Ensure your solution adheres to proper diving safety protocols and is tested against various scenarios to validate its accuracy and completeness.","solution":"def safe_ascension_time(depth: float) -> float: Calculate the safe ascension time for a diver based on their maximum depth during the dive. Args: depth (float): The maximum depth of the dive in meters. Returns: float: The total safe ascension time in minutes. ascent_rate = 9.0 # meters per minute safety_stop_depth = 6.0 # meters safety_stop_duration = 3.0 # minutes if depth <= safety_stop_depth: # If the depth is less than or equal to the safety stop depth, perform only safety stop and then ascend. return depth / ascent_rate + safety_stop_duration # Otherwise, calculate time to reach the safety stop depth time_to_safety_stop = (depth - safety_stop_depth) / ascent_rate # Add the safety stop duration and the time to ascend the last 6 meters total_ascension_time = time_to_safety_stop + safety_stop_duration + (safety_stop_depth / ascent_rate) return total_ascension_time"},{"question":"# Problem Statement Your task is to implement a function that finds the second smallest element in a given list of integers. The function should efficiently determine the second smallest value by inspecting the elements, and handle cases where the list might contain duplicates or have less than two distinct elements. # Function Signature ```python def second_smallest(nums: list[int]) -> int: pass ``` # Input - `nums` (list of int): A non-empty list of integers. The length of the list will not exceed (10^5). # Output - (int): The second smallest integer in the list. If there are fewer than two distinct integers, raise a `ValueError`. # Example ```python assert second_smallest([1, 2, 3, 4, 5]) == 2 assert second_smallest([4, 2, 3, 1]) == 2 assert second_smallest([1, 1, 1, 1]) == ValueError(\\"Not enough distinct elements\\") assert second_smallest([1, 2, 2, 3]) == 2 ``` # Constraints and Notes - The function should consider edge cases such as lists with a very small number of elements or lists where all elements are the same. - Ensure the function operates within a reasonable time limit given the input size constraint. - Utilize efficient parsing techniques to minimize the number of times the list is traversed. - Handle situations where the second smallest element does not exist gracefully by raising an appropriate exception. # Implementation Details - You should first filter the list to remove duplicate values and then find the second smallest element from the unique set. - Pay special attention to optimizing for time complexity, aiming for O(n) where possible. - Carefully handle and test edge cases to ensure robustness of your function.","solution":"def second_smallest(nums: list[int]) -> int: Returns the second smallest element in a list of integers. Raises ValueError if there are fewer than two distinct integers in the list. if len(nums) < 2: raise ValueError(\\"Not enough elements\\") first, second = float(\'inf\'), float(\'inf\') for num in nums: if num < first: first, second = num, first elif first < num < second: second = num if second == float(\'inf\'): raise ValueError(\\"Not enough distinct elements\\") return second"},{"question":"# Problem Description You are tasked with implementing a Min-Heap data structure with an additional feature to support the following operations efficiently: - `insert(key: int)`: Adds a new key to the heap. - `extract_min() -> int`: Removes and returns the smallest key from the heap. - `decrease_key(current_key: int, new_key: int)`: Decreases the value of a given key to a new lower value. It\'s guaranteed that the new value is smaller than the current value. - `get_min() -> int`: Returns the smallest key without removing it. **Input Constraints** - The heap will contain at most `10^5` keys. - All keys will be distinct integers. - Keys will fall within the range `-10^9` to `10^9`. **Output Description** - Implement the specified functions with time complexities: - `insert`: O(log n) to add a new key. - `extract_min`: O(log n) to remove and return the smallest key. - `decrease_key`: O(log n) to find and update the position of the decreased key while maintaining the heap property. - `get_min`: O(1) to return the smallest key. **Example Input** ```python heap = MinHeap() heap.insert(5) heap.insert(3) heap.insert(17) heap.insert(10) heap.insert(84) heap.insert(19) heap.insert(6) heap.insert(22) heap.insert(9) print(heap.get_min()) # Output: 3 print(heap.extract_min()) # Output: 3 print(heap.get_min()) # Output: 5 heap.decrease_key(19, 2) print(heap.get_min()) # Output: 2 ``` **Detailed Instructions** 1. Implement the `MinHeap` class with the following methods: - An `__init__` method to initialize an empty heap. - An `insert` method to add a new key to the heap. - An `extract_min` method to remove and return the smallest key. - A `decrease_key` method to decrease the value of an existing key. - A `get_min` method to return the smallest key without removing it.","solution":"import heapq class MinHeap: def __init__(self): self.heap = [] self.key_map = {} def insert(self, key: int): heapq.heappush(self.heap, key) self.key_map[key] = key def extract_min(self) -> int: min_key = heapq.heappop(self.heap) del self.key_map[min_key] return min_key def decrease_key(self, current_key: int, new_key: int): self.key_map[new_key] = new_key index = self.heap.index(current_key) self.heap[index] = new_key heapq.heapify(self.heap) del self.key_map[current_key] def get_min(self) -> int: return self.heap[0]"},{"question":"# Task Students in a university dormitory have access to a shared cafeteria. To optimize the food distribution, the cafeteria wants to predict which foods to prepare in larger quantities based on historical consumption data. # Context You are provided with a dataset where each row represents the daily consumption of different food items by each student. Implement a program to calculate the average daily consumption of each food item over a given period and determine which foods should be prioritized for preparation. # Requirements Create a `Cafeteria` class with the following methods: 1. `__init__(self, data: List[Dict[str, Union[str, int]]]) -> None`: Initialize with a list of dictionaries, each representing daily consumption data for a food item. 2. `average_consumption(self, start_date: str, end_date: str) -> Dict[str, float]`: Calculate the average daily consumption of each food item between the start and end dates (inclusive). 3. `priority_foods(self, threshold: float) -> List[str]`: Return a list of foods that have an average daily consumption higher than the specified threshold. The input data is a list of dictionaries with each dictionary in the format: ```python { \\"date\\": \\"YYYY-MM-DD\\", \\"student_id\\": int, \\"food_item\\": str, \\"quantity\\": int } ``` # Function Signatures ```python class Cafeteria: def __init__(self, data: List[Dict[str, Union[str, int]]]) -> None: pass def average_consumption(self, start_date: str, end_date: str) -> Dict[str, float]: pass def priority_foods(self, threshold: float) -> List[str]: pass ``` # Example Input ```python data = [ {\\"date\\": \\"2023-01-01\\", \\"student_id\\": 1, \\"food_item\\": \\"pizza\\", \\"quantity\\": 2}, {\\"date\\": \\"2023-01-01\\", \\"student_id\\": 2, \\"food_item\\": \\"burger\\", \\"quantity\\": 1}, {\\"date\\": \\"2023-01-02\\", \\"student_id\\": 1, \\"food_item\\": \\"pizza\\", \\"quantity\\": 1}, {\\"date\\": \\"2023-01-02\\", \\"student_id\\": 2, \\"food_item\\": \\"burger\\", \\"quantity\\": 2}, {\\"date\\": \\"2023-01-01\\", \\"student_id\\": 1, \\"food_item\\": \\"soda\\", \\"quantity\\": 1}, {\\"date\\": \\"2023-01-01\\", \\"student_id\\": 2, \\"food_item\\": \\"soda\\", \\"quantity\\": 2}, {\\"date\\": \\"2023-01-02\\", \\"student_id\\": 1, \\"food_item\\": \\"soda\\", \\"quantity\\": 1}, {\\"date\\": \\"2023-01-02\\", \\"student_id\\": 2, \\"food_item\\": \\"soda\\", \\"quantity\\": 2} ] ``` # Example Usage ```python cafeteria = Cafeteria(data) avg_consumption = cafeteria.average_consumption(\\"2023-01-01\\", \\"2023-01-02\\") print(avg_consumption) # Output: {\'pizza\': 1.5, \'burger\': 1.5, \'soda\': 1.5} priority = cafeteria.priority_foods(1.0) print(priority) # Output: [\'pizza\', \'burger\', \'soda\'] ``` # Notes - Ensure that the average calculation is accurate and handles edge cases (e.g., no data for a given date range). - Make sure your program can handle large datasets efficiently. - The date format is \'YYYY-MM-DD\'.","solution":"from typing import List, Dict, Union from collections import defaultdict from datetime import datetime class Cafeteria: def __init__(self, data: List[Dict[str, Union[str, int]]]) -> None: self.data = data def average_consumption(self, start_date: str, end_date: str) -> Dict[str, float]: start_date = datetime.strptime(start_date, \'%Y-%m-%d\') end_date = datetime.strptime(end_date, \'%Y-%m-%d\') # Initialize dictionaries to hold sums and counts consumption_totals = defaultdict(int) consumption_counts = defaultdict(int) for record in self.data: record_date = datetime.strptime(record[\'date\'], \'%Y-%m-%d\') if start_date <= record_date <= end_date: item = record[\'food_item\'] quantity = record[\'quantity\'] consumption_totals[item] += quantity consumption_counts[item] += 1 # Calculate average consumption average_consumption = { item: consumption_totals[item] / consumption_counts[item] for item in consumption_totals } return average_consumption def priority_foods(self, threshold: float) -> List[str]: # Calculate average for the entire dataset period since we need this for priority all_dates = [record[\'date\'] for record in self.data] min_date = min(all_dates) max_date = max(all_dates) average_consumption_total = self.average_consumption(min_date, max_date) # Filter items above the threshold priority_list = [ item for item, avg in average_consumption_total.items() if avg > threshold ] return priority_list"},{"question":"# Problem Statement: Given an integer array, `nums`, return the length of the longest consecutive elements sequence. The sequence must be strictly increasing, and the elements do not necessarily have to be adjacent in the array. You need to implement the following function prototype: ```python def longest_consecutive(nums: List[int]) -> int: ``` # Input: - `nums`: A list of integers, where 0 ≤ len(nums) ≤ 10^5. # Output: - Return the length of the longest strictly increasing consecutive elements sequence. # Constraints: - The elements in the nums array are not necessarily unique and can include negative integers. # Example: ```python nums = [100, 4, 200, 1, 3, 2] print(longest_consecutive(nums)) # Output should be 4 because the longest consecutive sequence is [1, 2, 3, 4] nums = [0, 3, 7, 2, 5, 8, 4, 6, 0, 1] print(longest_consecutive(nums)) # Output should be 9 because the longest consecutive sequence is [0, 1, 2, 3, 4, 5, 6, 7, 8] ``` # Function Signature ```python def longest_consecutive(nums: List[int]) -> int: ``` # Performance requirements: - The function should efficiently handle the given constraints, preferably in O(n) time complexity.","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: # Only check the start of a sequence if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Program Description In many software applications, generating permutations of a given string is a common task. Your task is to implement a function that generates all possible permutations of a given string, ensuring that you avoid duplicate permutations if the input string contains repeating characters. # Function Signature ```python def unique_permutations(s: str) -> List[str]: ``` # Input - **s**: A string for which all unique permutations need to be generated. The string may contain leading/trailing whitespaces, and may possibly be empty. # Output - A list of strings, where each string is a unique permutation of the input string. The order of permutations in the list is not important. # Constraints - The length of the input string does not exceed (10). - You may assume the input string consists only of printable ASCII characters. # Exceptions The function should raise a `ValueError` in the following cases: - The input string is `None`. # Example ```python >>> unique_permutations(\\"abc\\") [\'abc\', \'acb\', \'bac\', \'bca\', \'cab\', \'cba\'] >>> unique_permutations(\\"aab\\") [\'aab\', \'aba\', \'baa\'] >>> unique_permutations(\\" \\") [\' \'] >>> unique_permutations(\\"\\") [\'\'] >>> unique_permutations(None) Traceback (most recent call last): ... ValueError: None value was passed to the function ``` # Implementation Notes - Ensure proper handling of edge cases such as an empty string or a string with all identical characters. - Make sure the function is efficient and uses appropriate algorithms to generate permutations, avoiding duplicates naturally. - Consider using recursion or iterative methods to generate permutations.","solution":"from typing import List from itertools import permutations def unique_permutations(s: str) -> List[str]: Returns a list of all unique permutations of the input string `s`. Raises a ValueError if the input string is None. if s is None: raise ValueError(\\"None value was passed to the function\\") # Generate all permutations and remove duplicates by converting to a set perm_set = set(\'\'.join(p) for p in permutations(s)) return list(perm_set)"},{"question":"# Problem Context Sorting algorithms are fundamental in computer science for arranging data in a specific order. These algorithms can be optimized for performance depending on the type of data and the desired outcome. One such optimization is applied in the context of nearly sorted arrays. Given that nearly sorted arrays are mostly sorted with a few elements out of place, a sorting algorithm called \\"Insertion Sort\\" can be extremely efficient for this purpose. # Problem Statement Write a Python function `nearly_sorted_sort` that efficiently sorts a nearly sorted array. The function should use the Insertion Sort algorithm to take advantage of the nearly sorted nature of the array. # Function Signature ```python def nearly_sorted_sort(arr: list) -> list: Sort a nearly sorted array using insertion sort. ``` # Input - `arr` (list): A list of integers that is nearly sorted (most elements are already in order, with only a few out of place). # Output - A list: A list of integers sorted in ascending order. # Constraints 1. The input list may contain negative integers. 2. The input list will have a length between 1 and 1000. # Example ```python assert nearly_sorted_sort([2, 3, 5, 1, 6, 7, 8, 9]) == [1, 2, 3, 5, 6, 7, 8, 9] assert nearly_sorted_sort([10, 2, 3, 7]) == [2, 3, 7, 10] assert nearly_sorted_sort([-1, 0, -2, 2, 1]) == [-2, -1, 0, 1, 2] assert nearly_sorted_sort([5, 6, 3, 4, 8, 9, 7, 1]) == [1, 3, 4, 5, 6, 7, 8, 9] ``` # Notes Ensure that the function leverages the Insertion Sort algorithm to efficiently sort the array. The nature of nearly sorted arrays should make Insertion Sort more efficient compared to other sorting algorithms for this specific task.","solution":"def nearly_sorted_sort(arr: list) -> list: Sort a nearly sorted array using insertion sort. # Traverse from 1 to len(arr) for i in range(1, len(arr)): key = arr[i] j = i - 1 # Move elements of arr[0..i-1], that are greater than key, # to one position ahead of their current position while j >= 0 and key < arr[j]: arr[j + 1] = arr[j] j -= 1 arr[j + 1] = key return arr"},{"question":"# Coding Question: Smart Subarray Finder Your task is to implement a function that finds the smallest subarray with a given sum from an array of integers. This problem tests your ability to work with arrays and optimize search algorithms. You will write a function, `smallest_subarray_with_given_sum(s: int, nums: List[int]) -> int`, that returns the length of the smallest contiguous subarray whose sum is at least `s`. If no such subarray exists, return `0`. Input: * An integer `s` representing the target sum. * A list of integers `nums` which can be both positive and negative. Output: * The function should return an integer, the length of the smallest subarray whose sum is at least `s`. Constraints: * The length of `nums` can be up to (10^5). * Each element in `nums` can be between (-10^5) and (10^5). * The sum `s` is an integer between 1 and (10^9). # Example: ```python def smallest_subarray_with_given_sum(s: int, nums: List[int]) -> int: >>> smallest_subarray_with_given_sum(7, [2, 1, 5, 2, 3, 2]) 2 >>> smallest_subarray_with_given_sum(7, [-10, 20, -5, 15]) 1 >>> smallest_subarray_with_given_sum(20, [1, 2, 3, 4, 5]) 0 ``` # Notes: * Ensure your function handles arrays with negative numbers efficiently. * Consider edge cases where the array might be very large or contain only positive or only negative numbers. * Optimize for time complexity, as inefficient solutions will not perform well on larger input sizes.","solution":"from typing import List def smallest_subarray_with_given_sum(s: int, nums: List[int]) -> int: n = len(nums) min_length = float(\'inf\') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return min_length if min_length != float(\'inf\') else 0"},{"question":"# Recursive Binary Search **Scenario**: You have been assigned a task to search for an element in a sorted list, and it is crucial to minimize the search time due to performance-sensitive requirements in the application. **Task**: Implement a recursive version of the Binary Search algorithm. The algorithm should efficiently locate the position of a given target element within the list or indicate that the target is not present. **Function Signature**: ```python def recursive_binary_search(arr: list, target: int, left: int, right: int) -> int: ``` # Requirements: 1. **Input**: * `arr`: A sorted list of integers. * `target`: An integer value to search for in the list. * `left`: The starting index for the search, initially set to 0. * `right`: The ending index for the search, initially set to the length of the list minus one. 2. **Output**: * The index of the target element within the list if found. * `-1` if the target element is not present in the list. 3. **Constraints**: * The algorithm must be implemented recursively. * The function should handle lists with up to 10^5 elements. # Example: ```python >>> recursive_binary_search([1, 2, 3, 4, 5, 6, 7, 8, 9], 5, 0, 8) 4 >>> recursive_binary_search([10, 20, 30, 40, 50], 35, 0, 4) -1 >>> recursive_binary_search([1, 3, 5, 7, 9], 1, 0, 4) 0 >>> recursive_binary_search([2, 4, 6, 8, 10], 8, 0, 4) 3 ``` # Notes: * **Edge Cases**: Consider edge cases such as an empty list, a single-element list, and target elements that are not present within the list. * **Performance**: Ensure your solution runs efficiently within the constraints provided, leveraging the O(log n) time complexity of binary search. Implement your function below: ```python def recursive_binary_search(arr: list, target: int, left: int, right: int) -> int: if left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return recursive_binary_search(arr, target, mid + 1, right) else: return recursive_binary_search(arr, target, left, mid - 1) return -1 ```","solution":"def recursive_binary_search(arr: list, target: int, left: int, right: int) -> int: if left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: return recursive_binary_search(arr, target, mid + 1, right) else: return recursive_binary_search(arr, target, left, mid - 1) return -1"},{"question":"# Problem Statement You are responsible for developing a function to decompress a string encoded with a specific run-length encoding format. This encoding format denotes repetitions of sequences in the form of `number[string]`, where `number` is the number of times the `string` should be repeated. Implement a function `decode_string` that takes a single encoded string as input and returns the fully decompressed string. # Function Signature ```python def decode_string(encoded: str) -> str: pass ``` # Input - `encoded`: A string that follows the run-length encoding format (`number[string]`) with nested repetitions allowed. The input string will contain only digits (`0-9`), square brackets (`[]`), and lowercase English letters. # Output - A string that represents the fully decompressed version of the input. # Constraints - The number of times a string can be repeated (i.e., `number`) will be a positive integer (1 ≤ `number` < 300). - The input string will be valid according to the given format. - The length of the input string will not exceed 1000 characters. # Example ```python >>> decode_string(\\"3[a]2[bc]\\") \\"aaabcbc\\" >>> decode_string(\\"3[ab2[c]]\\") \\"abccabccabcc\\" >>> decode_string(\\"2[2[2[a]]]\\") \\"a\\" * 8 == \\"aaaaaaaa\\" >>> decode_string(\\"10[x10[y]]\\") \\"xyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyyxyyyyyyyyyy\\" ``` # Implementation Considerations - Consider a stack-based approach to handle nested decompressions efficiently. - Ensure the function handles various valid encoded strings appropriately. - Optimize for readability and maintainability while ensuring the correctness of the decompression logic.","solution":"def decode_string(encoded: str) -> str: stack = [] curr_num = 0 curr_str = \'\' for c in encoded: if c.isdigit(): curr_num = curr_num * 10 + int(c) elif c == \'[\': stack.append((curr_str, curr_num)) curr_str = \'\' curr_num = 0 elif c == \']\': last_str, num = stack.pop() curr_str = last_str + curr_str * num else: curr_str += c return curr_str"},{"question":"# Coding Question: Max Consecutive Ones Problem Statement: You are given a binary array `nums` (an array consisting of only 0s and 1s). Your task is to find the maximum number of consecutive 1s in the array. You must write a function `find_max_consecutive_ones(nums: list) -> int` that computes the longest sequence of consecutive 1s in the input list. Example: Input: `[1, 1, 0, 1, 1, 1]` Output: `3` Explanation: The longest sequence of consecutive 1s is three. Function Signature: ```python def find_max_consecutive_ones(nums: list) -> int: ``` Constraints: - The input list `nums` will contain only 0s and 1s. - The function needs to handle edge cases such as an empty list and lists without any 1s. - You should aim for an optimal solution with a linear time complexity of O(n) and a constant space complexity of O(1). Performance Requirement: Your solution should run in linear time and use constant extra space. Testing: The function will be tested with various test cases including, but not limited to: 1. A list with a mixture of 0s and 1s. 2. An empty list. 3. A list with all 1s. 4. A list with all 0s. 5. A list with single elements (either 0 or 1). Example Code: The following are some inputs and expected outputs for testing: ```python print(find_max_consecutive_ones([1, 1, 0, 1, 1, 1])) # Expected: 3 print(find_max_consecutive_ones([0, 0, 0, 0])) # Expected: 0 print(find_max_consecutive_ones([1, 1, 1, 1])) # Expected: 4 print(find_max_consecutive_ones([])) # Expected: 0 print(find_max_consecutive_ones([0])) # Expected: 0 print(find_max_consecutive_ones([1])) # Expected: 1 ``` Your task is to implement the `find_max_consecutive_ones` function.","solution":"def find_max_consecutive_ones(nums: list) -> int: Returns the maximum number of consecutive 1s in the binary array nums. max_consecutive_ones = 0 current_consecutive_ones = 0 for num in nums: if num == 1: current_consecutive_ones += 1 if current_consecutive_ones > max_consecutive_ones: max_consecutive_ones = current_consecutive_ones else: current_consecutive_ones = 0 return max_consecutive_ones"},{"question":"# Question: Implement a Multi-Threaded Word Counter Context: You are required to create a tool that processes a large text file and counts the frequency of each word. The tool should be optimized for performance by using multi-threading to split the file into manageable chunks and process each chunk concurrently. Requirements: 1. **Multi-threading**: Divide the text file into equal-sized chunks and count the words in each chunk concurrently using multiple threads. 2. **Thread Safety**: Ensure that the shared data structures used to store word counts are thread-safe. 3. **Performance Optimization**: Minimize the overhead caused by thread creation and synchronization. Main Function Specification: ```python def count_words_in_file(file_path: str, num_threads: int) -> Dict[str, int]: Read a text file and count the frequency of each word using multiple threads. Parameters: file_path (str): Path to the text file to be processed. num_threads (int): Number of threads to use for concurrent processing. Returns: Dict[str, int]: A dictionary mapping each word to its frequency in the file. pass ``` * **Input**: - `file_path`: Path to the text file. - `num_threads`: Number of threads to use (e.g., 4 or 8). * **Output**: A dictionary with words as keys and their corresponding frequencies as values. Constraints: - The function should handle large text files efficiently (e.g., files with millions of words). - Ensure the solution is robust and handles edge cases, such as empty files or files with non-alphanumeric characters. - Use lower case for all words to avoid case sensitivity issues. * **Example**: ```python input_file_path = \\"sample.txt\\" num_of_threads = 4 # Contents of \\"sample.txt\\": \\"Hello world! This is a test file. Hello again.\\" expected_output = { \\"hello\\": 2, \\"world\\": 1, \\"this\\": 1, \\"is\\": 1, \\"a\\": 1, \\"test\\": 1, \\"file\\": 1, \\"again\\": 1 } assert count_words_in_file(input_file_path, num_of_threads) == expected_output ``` Performance Requirements: - The function should process a text file with 1 million words in less than 10 seconds using an appropriate number of threads on a modern computer. Note: Provide a well-documented and tested solution showcasing your understanding of concurrent programming, file handling, and efficient counting algorithms in Python.","solution":"import threading import re from collections import defaultdict from typing import Dict def count_words_in_file(file_path: str, num_threads: int) -> Dict[str, int]: def process_chunk(text: str, counter: defaultdict) -> None: words = re.findall(r\'bw+b\', text.lower()) for word in words: with lock: counter[word] += 1 with open(file_path, \'r\') as file: content = file.read() file_size = len(content) chunk_size = file_size // num_threads threads = [] start = 0 counters = [defaultdict(int) for _ in range(num_threads)] lock = threading.Lock() for i in range(num_threads): end = file_size if i == num_threads - 1 else start + chunk_size # Adjust end to not split words if end != file_size: while end < file_size and content[end].isalnum(): end += 1 thread = threading.Thread(target=process_chunk, args=(content[start:end], counters[i])) threads.append(thread) start = end for thread in threads: thread.start() for thread in threads: thread.join() final_counter = defaultdict(int) for counter in counters: for word, count in counter.items(): final_counter[word] += count return final_counter"},{"question":"# Scenario You are building an application that deals with large datasets, and you need to implement a function to intelligently partition the dataset for parallel processing. # Task Write a Python function, `partition_dataset(data: list[int], parts: int) -> list[list[int]]`, that divides a given dataset into a specified number of roughly equal parts. Each part should have a nearly equal number of elements, with a difference of at most one element between the smallest and largest parts. # Requirements: 1. **Function Signature**: ```python def partition_dataset(data: list[int], parts: int) -> list[list[int]]: ``` 2. **Input**: * `data`: A list of integers representing the dataset to be partitioned. * `parts`: An integer specifying the number of parts to divide the dataset into. 3. **Output**: A list of lists, where each sublist represents a partition of the dataset. 4. **Constraints**: * The `data` list will have at least one element and at most `100000` elements. * `parts` will be a positive integer greater than or equal to 1 and less than or equal to the length of `data`. * Ensure that the difference in the number of elements between the smallest and largest parts does not exceed one. * The order of elements in the dataset should be preserved within each partition. # Example ```python # Example 1 data = [1, 2, 3, 4, 5, 6, 7, 8, 9] parts = 3 partition_dataset(data, parts) # Output: [[1, 2, 3], [4, 5, 6], [7, 8, 9]] # Example 2 data = [10, 20, 30, 40, 50, 60] parts = 4 partition_dataset(data, parts) # Output: [[10, 20], [30, 40], [50], [60]] ``` # Additional Guidelines * Ensure your function is efficient and handles edge cases, such as the number of elements in `data` being exactly divisible by `parts`, and situations where they are not. * Write a few test cases to validate your implementation, considering various cases like empty lists, different numbers of parts, and very large datasets.","solution":"def partition_dataset(data, parts): Partitions the dataset into the specified number of roughly equal parts. :param data: List of integers to be partitioned. :param parts: Integer specifying the number of parts. :return: List of lists, where each sublist represents a partition of the dataset. # Calculate the base size of each part base_size = len(data) // parts # Calculate the number of parts that need to be one element larger remainder = len(data) % parts result = [] start = 0 for i in range(parts): # Determine the size of the current part current_size = base_size + (1 if i < remainder else 0) # Slice the data list to get the current part result.append(data[start:start + current_size]) # Update the start index for the next part start += current_size return result"},{"question":"# Problem Statement As part of a system diagnosis, you need to identify and count unique sequences of commands executed across several servers. Each server logs a series of operations, and you want to determine how many of these sequences are unique across all servers. # Task Write a function `count_unique_sequences` that calculates the number of unique sequences of commands executed by the servers. # Function Signature ```python def count_unique_sequences(commands: List[List[str]]) -> int: ``` # Inputs - `commands` (List[List[str]]): A list where each element is a list of strings, representing a sequence of commands executed by a server. # Output - Returns an integer representing the count of unique command sequences. # Constraints - Each sequence of commands consists of between 1 and 1000 commands. - Total number of sequences across all servers is between 1 and 10000. - Each command is a string of length between 1 and 50. # Example ```python commands = [ [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], [\\"start\\", \\"load\\", \\"compute\\", \\"save\\"], [\\"start\\", \\"init\\", \\"compute\\", \\"log\\"], [\\"deploy\\", \\"start\\", \\"compute\\", \\"shutdown\\"] ] assert count_unique_sequences(commands) == 3 ``` # Explanation - The sequence `[\\"start\\", \\"load\\", \\"compute\\", \\"save\\"]` appears twice but is considered one unique sequence. - The sequences `[\\"start\\", \\"init\\", \\"compute\\", \\"log\\"]` and `[\\"deploy\\", \\"start\\", \\"compute\\", \\"shutdown\\"]` are distinct and contribute to the unique count. - Hence, there are 3 unique sequences of commands. # Notes - Consider using a set to take advantage of its properties for storing unique items. - Ensure that the solution efficiently handles the upper constraint limits in terms of both time and space.","solution":"from typing import List def count_unique_sequences(commands: List[List[str]]) -> int: Returns the number of unique command sequences. :param commands: List of command sequences :return: Number of unique sequences unique_sequences = set() for sequence in commands: # Convert each sequence to a tuple so it can be added to a set unique_sequences.add(tuple(sequence)) return len(unique_sequences)"},{"question":"# Coding Question: Implementing Kruskal\'s Algorithm with Union-Find Context: Kruskal\'s algorithm is a well-known method for finding the minimum spanning tree (MST) of a connected, undirected graph. It uses a greedy approach to select the edges with the least weight, while avoiding cycles. A common optimization associated with Kruskal\'s algorithm is the use of the Union-Find data structure to efficiently manage and merge disjoint sets. Task: Create a function that implements Kruskal\'s algorithm using a Union-Find data structure to find the Minimum Spanning Tree (MST) of a graph. Requirements: * **Function Signature**: `def kruskal(edges: List[Tuple[int, int, float]], vertices: int) -> List[Tuple[int, int, float]]` * **Input**: * `edges`: A list of tuples where each tuple `(u, v, w)` represents an edge between vertex `u` and vertex `v` with weight `w`. * `vertices`: An integer representing the number of vertices in the graph. * **Output**: * A list of edges that constitute the Minimum Spanning Tree (MST). Each edge in the MST should be represented as a tuple `(u, v, w)`. * **Constraints**: * The graph is connected and undirected. * The number of edges (E) in the graph is at most `10,000`. * The number of vertices (V) in the graph is at most `1000`. Here is the existing pseudocode for reference: ``` function kruskal(edges, vertices): mst = [] sort edges in ascending order of weight create a disjoint-set data structure for each vertex for each edge (u, v, w) in edges: if u and v belong to different components: add edge (u, v, w) to mst merge the sets containing u and v return mst ``` Challenge: Implement Kruskal\'s algorithm as outlined above, using Python and incorporating the Union-Find data structure to efficiently detect and merge disjoint sets. ```python class UnionFind: def __init__(self, size): self.parent = list(range(size)) self.rank = [1] * size def find(self, node): if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(edges, vertices): uf = UnionFind(vertices) mst = [] edges.sort(key=lambda x: x[2]) for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst.append((u, v, w)) return mst ```","solution":"from typing import List, Tuple class UnionFind: def __init__(self, size): # Initializes the union-find structure self.parent = list(range(size)) self.rank = [1] * size def find(self, node): # Finds the representative of the set that node is part of with path compression if self.parent[node] != node: self.parent[node] = self.find(self.parent[node]) return self.parent[node] def union(self, u, v): # Unites the sets that include u and v, using union by rank root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal(edges: List[Tuple[int, int, float]], vertices: int) -> List[Tuple[int, int, float]]: # Implements Kruskal\'s algorithm using the union-find structure uf = UnionFind(vertices) mst = [] edges.sort(key=lambda x: x[2]) for u, v, w in edges: if uf.find(u) != uf.find(v): uf.union(u, v) mst.append((u, v, w)) return mst"},{"question":"# Context Optimization of string manipulation is crucial in computational fields like natural language processing, data cleaning, and pattern recognition. Efficiently implementing and performing operations on strings can significantly improve program performance and resource utilization. # Problem Statement You are required to extend the provided `StringManipulator` class with the following capabilities: 1. **Longest Palindromic Substring**: Implement a method `longest_palindrome` to find the longest palindromic substring in the given string. 2. **String Compression**: Implement a method `compress_string` to compress the given string using the counts of repeated characters. For example, the string \\"aabcccccaaa\\" would become \\"a2b1c5a3\\". # Function Specifications: Longest Palindromic Substring: **Input**: - No input parameters. **Output**: - Returns the longest palindromic substring as a string. # String Compression: **Input**: - No input parameters. **Output**: - Returns the compressed string if the compressed string is shorter than the original, otherwise returns the original string. # Example: ```python s = StringManipulator(\\"babad\\") # Should print the longest palindromic substring of \'babad\' print(s.longest_palindrome()) # Output could be \\"bab\\" or \\"aba\\" s = StringManipulator(\\"aabcccccaaa\\") # Should print the compressed version of \'aabcccccaaa\' print(s.compress_string()) # Output: \\"a2b1c5a3\\" ``` # Constraints: - The input string for both methods will only contain lowercase alphabetical characters. - You may assume the length of input strings does not exceed 1000 characters. - Optimize for both time and space complexity where possible. # Additional Notes: - For the `longest_palindrome` method, consider edge cases like strings with no palindromes longer than one character. - For the `compress_string` method, handle scenarios where the compressed string would be longer than the original.","solution":"class StringManipulator: def __init__(self, string): self.string = string def longest_palindrome(self): s = self.string n = len(s) if n <= 1: return s start, max_len = 0, 1 def expand_around_center(left, right): while left >= 0 and right < n and s[left] == s[right]: left -= 1 right += 1 return right - left - 1 for i in range(n): len1 = expand_around_center(i, i) len2 = expand_around_center(i, i + 1) curr_max_len = max(len1, len2) if curr_max_len > max_len: max_len = curr_max_len start = i - (max_len - 1) // 2 if len1 > len2 else i - (max_len // 2) + 1 return s[start:start + max_len] def compress_string(self): s = self.string n = len(s) if n == 0: return \\"\\" compressed = [] count = 1 for i in range(1, n): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = \'\'.join(compressed) return compressed_string if len(compressed_string) < n else s"},{"question":"# Coding Question: Implementing a Custom Median Finder Context A company needs a quick way to find the median price of a list of products in their inventory. The inventory is dynamic, with prices of products being added or removed frequently. Implementing an efficient algorithm to determine the median price after every update is crucial for pricing strategy analysis. Problem Statement Implement the `MedianFinder` class that supports adding prices and finding the median price efficiently. This class should follow the given specifications: **Class Definition:** ```python class MedianFinder: def __init__(self): # Initialize your data structure here. def add_price(self, price: int) -> None: # Adds the price to the data structure. def find_median(self) -> float: # Returns the median of all prices added so far. ``` **Input:** - The `add_price` method receives an integer `price` representing the price to be added to the inventory. - The `find_median` method returns a float representing the median price of all prices added so far. **Output:** - The `add_price` method does not return anything. - The `find_median` method returns the median price. **Constraints:** - The methods should be optimized for performance with frequent add and find operations. - Prices added can be between -10^5 to 10^5. **Example Usage:** ```python >>> median_finder = MedianFinder() >>> median_finder.add_price(10) >>> median_finder.find_median() 10.0 >>> median_finder.add_price(20) >>> median_finder.find_median() 15.0 >>> median_finder.add_price(30) >>> median_finder.find_median() 20.0 >>> median_finder.add_price(-10) >>> median_finder.find_median() 15.0 ``` Additional Notes: 1. Make sure the algorithm handles both adding and finding the median in an efficient manner. 2. The median should be the middle element if the number of elements is odd, and the average of the two middle elements if the number of elements is even. 3. Consider using two heaps (a max-heap for the lower half and a min-heap for the upper half) to manage the median dynamically. This question tests the candidate\'s ability to implement efficient algorithms for dynamic data structures and focuses on understanding the median concept and advanced data structure manipulation.","solution":"import heapq class MedianFinder: def __init__(self): # Max heap for the lower half of numbers self.lower_half = [] # Min heap for the upper half of numbers self.upper_half = [] def add_price(self, price: int) -> None: # Add new price to the max heap (lower half), but negate it since Python has only min heap heapq.heappush(self.lower_half, -price) # Ensure every element of lower_half is <= every element of upper_half if (self.lower_half and self.upper_half and -self.lower_half[0] > self.upper_half[0]): val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) # Balance the sizes of the two heaps if len(self.lower_half) > len(self.upper_half) + 1: val = -heapq.heappop(self.lower_half) heapq.heappush(self.upper_half, val) if len(self.upper_half) > len(self.lower_half) + 1: val = heapq.heappop(self.upper_half) heapq.heappush(self.lower_half, -val) def find_median(self) -> float: if len(self.lower_half) > len(self.upper_half): return -self.lower_half[0] elif len(self.upper_half) > len(self.lower_half): return self.upper_half[0] else: return (-self.lower_half[0] + self.upper_half[0]) / 2.0"},{"question":"# Problem Statement Create a class `PriorityQueue` to represent a priority queue using a binary min-heap. The priority queue should support efficient insertion of an item with a priority and removal of the item with the highest priority (lowest numerical value). # Requirements 1. **Implementation Details**: - The priority queue should be implemented as a class `PriorityQueue` using an array-based binary min-heap. - Each element in the priority queue should be a tuple `(priority, item)`, where `priority` is an integer and `item` can be of any type. 2. **Functional Requirements**: Implement the following methods: - `insert(self, priority: int, item: T) -> None`: Adds an element with the given priority and item to the priority queue. - `pop(self) -> tuple[int, T]`: Removes and returns the element with the highest priority (lowest priority value). - `peek(self) -> tuple[int, T]`: Returns the element with the highest priority without removing it. - `is_empty(self) -> bool`: Returns `True` if the priority queue is empty, `False` otherwise. - `__len__(self) -> int`: Returns the number of elements in the priority queue. # Input/Output Formats - The `insert` method should accept an integer `priority` and an element `item` of any type `T`. - The `pop`, `peek` methods should return a tuple of `(priority, item)`. - The `is_empty()` method should return a boolean value. - The `__len__` method should return an integer representing the number of elements in the priority queue. # Constraints - Your implementation should ensure that all operations are efficient. - The insertion and removal operations should maintain the heap property of the binary min-heap. # Example Usage ```python pq = PriorityQueue() print(pq.is_empty()) # Output: True pq.insert(10, \\"task1\\") pq.insert(5, \\"task2\\") pq.insert(7, \\"task3\\") print(len(pq)) # Output: 3 print(pq.peek()) # Output: (5, \'task2\') print(pq.pop()) # Output: (5, \'task2\') print(len(pq)) # Output: 2 print(pq.is_empty()) # Output: False ``` # Additional Notes - You may assume any necessary imports and class definitions are provided. - The `__init__` method should initialize the priority queue as empty. - Consider edge cases such as operations on an empty priority queue. - Maintain the binary min-heap property through appropriate helper functions, such as `heapify_up` and `heapify_down`.","solution":"import heapq from typing import Any, Tuple, List class PriorityQueue: def __init__(self): self.heap: List[Tuple[int, Any]] = [] def insert(self, priority: int, item: Any) -> None: heapq.heappush(self.heap, (priority, item)) def pop(self) -> Tuple[int, Any]: if not self.is_empty(): return heapq.heappop(self.heap) raise IndexError(\\"pop from an empty priority queue\\") def peek(self) -> Tuple[int, Any]: if not self.is_empty(): return self.heap[0] raise IndexError(\\"peek from an empty priority queue\\") def is_empty(self) -> bool: return len(self.heap) == 0 def __len__(self) -> int: return len(self.heap)"},{"question":"# Magic Matrix **Scenario**: A **Magic Matrix** is a square matrix of distinct positive integers such that the sum of the integers in each row, each column, and both main diagonals are the same. This common sum is called the magic constant or magic sum. Your task is to create a function that verifies if a given 3x3 matrix is a magic matrix. **Task**: Implement the following function to determine if a given 3x3 matrix is a magic matrix: ```python def is_magic_matrix(matrix: list[list[int]]) -> bool: Determine if the given 3x3 matrix is a magic matrix. Args: matrix (list[list[int]]): 3x3 matrix of integers. Returns: bool: True if the matrix is a magic matrix, else False. ``` **Constraints**: - The matrix must be a 3x3 list of lists containing distinct positive integers. - Ensure your function checks the sum of integers in each row, column, and both main diagonals for equality. - The function should return `True` if the matrix is a magic matrix and `False` otherwise. **Input Format**: - `matrix` (list[list[int]]): A 3x3 list of lists containing integers. **Output Format**: - The function returns a boolean value (`True` if the matrix is a magic matrix, `False` otherwise). **Examples**: ```python # Example 1 matrix1 = [ [2, 7, 6], [9, 5, 1], [4, 3, 8] ] print(is_magic_matrix(matrix1)) # Expected: True # Example 2 matrix2 = [ [3, 5, 7], [8, 1, 6], [4, 9, 2] ] print(is_magic_matrix(matrix2)) # Expected: False # Example 3 matrix3 = [ [8, 1, 6], [3, 5, 7], [4, 9, 2] ] print(is_magic_matrix(matrix3)) # Expected: True ``` **Note**: Thoroughly test your implementation with various 3x3 matrices to ensure correctness.","solution":"def is_magic_matrix(matrix: list[list[int]]) -> bool: Determine if the given 3x3 matrix is a magic matrix. Args: matrix (list[list[int]]): 3x3 matrix of integers. Returns: bool: True if the matrix is a magic matrix, else False. if not all(len(row) == 3 for row in matrix): return False magic_sum = sum(matrix[0]) # Check rows and columns for i in range(3): if sum(matrix[i]) != magic_sum or sum(matrix[j][i] for j in range(3)) != magic_sum: return False # Check diagonals if sum(matrix[i][i] for i in range(3)) != magic_sum or sum(matrix[i][2 - i] for i in range(3)) != magic_sum: return False return True"},{"question":"# Course Enrollments - Detecting Cycles in Dependencies You are given a set of course dependencies in a university. Each course may have prerequisites which are other courses that must be completed before it can be taken. You need to detect if there are any cycles in these dependencies, as cycles would indicate that it\'s impossible to complete all courses. **Expected Input and Output Formats**: * **Input**: A list of tuples where each tuple represents a prerequisite relationship (course, prerequisite). * **Output**: A boolean value, True if there is a cycle in the dependencies, otherwise False. **Constraints/Limitations**: * The list can be empty; if so, return False. * There could be an arbitrary number of courses and prerequisites. * The courses and prerequisites are represented as strings. **Performance Requirements**: * The solution should be efficient and able to handle a large number of courses and dependencies. **Function Signature**: ```python def detect_cycle_in_courses(prerequisites: list[tuple[str, str]]) -> bool: ... ``` # Example: ```python # Example input and validation prerequisites1 = [ (\\"CourseA\\", \\"CourseB\\"), (\\"CourseB\\", \\"CourseC\\"), (\\"CourseC\\", \\"CourseA\\") ] prerequisites2 = [ (\\"CourseD\\", \\"CourseE\\"), (\\"CourseE\\", \\"CourseF\\"), (\\"CourseF\\", \\"CourseG\\") ] # Cycle detection in first example is_cycle1 = detect_cycle_in_courses(prerequisites1) print(is_cycle1) # Should output True # No cycle in second example is_cycle2 = detect_cycle_in_courses(prerequisites2) print(is_cycle2) # Should output False # Edge case: empty list of dependencies is_cycle_empty = detect_cycle_in_courses([]) print(is_cycle_empty) # Should output False ``` **Notes**: * Ensure to use an efficient graph traversal algorithm to detect cycles. * Handle cases where no direct cycles are present but complicated dependencies might lead to a cycle. * Consider both direct and indirect dependencies when determining cycles.","solution":"def detect_cycle_in_courses(prerequisites): from collections import defaultdict, deque # Create adjacency list graph = defaultdict(list) in_degree = defaultdict(int) # Build the graph and in-degree count for course, prereq in prerequisites: graph[prereq].append(course) in_degree[course] += 1 if prereq not in in_degree: in_degree[prereq] = 0 # Start with nodes that have no incoming edges queue = deque([node for node in in_degree if in_degree[node] == 0]) visited_count = 0 while queue: current = queue.popleft() visited_count += 1 for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If we visited all nodes, there\'s no cycle return visited_count != len(in_degree)"},{"question":"# Coding Assessment Question You are given a string representing an arithmetic expression containing integers and the operators `+` and `-`. Your task is to evaluate the expression and return the result as an integer. You are required to implement a function `evaluate_expression(expression: str) -> int` in Python, which calculates the value of the given arithmetic expression. Function Signature ```python def evaluate_expression(expression: str) -> int: ``` Input * `expression` (str): A string representing a valid arithmetic expression that contains integers and operators `+` and `-`. The length of the string is between 1 and 10^5. The expression does not contain any spaces. Output * Return the result of the arithmetic expression as an integer. Constraints * The input expression will contain only integers and the `+`, `-` operators. * The expression guarantee to be valid and correctly formatted (i.e., it will not start with an operator and will not have consecutive operators). Example ```python >>> evaluate_expression(\\"3+2-5\\") 0 # The expression evaluates to 3 + 2 - 5 = 0. >>> evaluate_expression(\\"10-20+30\\") 20 # The expression evaluates to 10 - 20 + 30 = 20. >>> evaluate_expression(\\"7+13-2+5-8\\") 15 # The expression evaluates to 7 + 13 - 2 + 5 - 8 = 15. >>> evaluate_expression(\\"50\\") 50 # A single number evaluates to itself. ``` Notes * You may assume that the input only contains valid characters representing numbers and arithmetic operations as described.","solution":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression containing integers and the operators + and -. Args: expression (str): A string representing a valid arithmetic expression Returns: int: The result of evaluating the expression # Initialize variables result = 0 current_number = 0 current_sign = 1 # Start with a positive sign # Traverse through the expression for ch in expression: if ch.isdigit(): current_number = current_number * 10 + int(ch) elif ch == \'+\': result += current_number * current_sign current_number = 0 current_sign = 1 elif ch == \'-\': result += current_number * current_sign current_number = 0 current_sign = -1 # Add the last number as there might be no operator following it result += current_number * current_sign return result"},{"question":"# Problem Statement You are required to write a function that receives a string of lowercase alphabetic characters and returns a list where each element represents a count of its consecutive occurrences in the given string. This task tests your ability to handle string traversal and generate correct count sequences. # Function Signature ```python def consecutive_character_count(s: str) -> list: ``` # Input - `s` (str): A string containing only lowercase alphabetic characters. The string will always have at least one character. # Output - A list of integers, where each integer represents the count of consecutive occurrences of each character in the input string. # Constraints - The input string will only contain lowercase alphabetic characters (\'a\' - \'z\'). - The input string will always have at least one character. # Example ```python >>> consecutive_character_count(\\"aaabbc\\") [3, 2, 1] >>> consecutive_character_count(\\"abcd\\") [1, 1, 1, 1] >>> consecutive_character_count(\\"a\\") [1] ``` # Performance Requirements - The function should run in O(n) time complexity, where n is the length of the input string. - The function should use at most O(n) additional space for the output list, where n is the length of the input string. # Guidelines 1. Traverse the input string from left to right. 2. Keep a count of consecutive characters and add these counts to the result list whenever a different character is encountered. 3. Return the list of counts once the entire string has been processed.","solution":"def consecutive_character_count(s: str) -> list: Returns a list where each element represents a count of its consecutive occurrences in the given string. if not s: return [] result = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: result.append(count) current_char = char count = 1 result.append(count) return result"},{"question":"# Task: Finding the Shortest Path in a Graph Objective Write a function `shortest_path` that takes an unweighted graph represented as an adjacency list and two vertices, and outputs the length of the shortest path between the two vertices. Scenario Imagine you have a map of cities connected by roads represented as an unweighted graph. Your task is to determine the minimum number of roads you need to travel to get from one city to another. Function Signature ```python def shortest_path(graph: dict, start: str, end: str) -> int: pass ``` Input 1. `graph` - A dictionary where keys are node labels (strings) and values are lists of neighboring node labels (strings). 2. `start` - A string representing the starting node. 3. `end` - A string representing the target node. Output - An integer representing the minimum number of edges required to travel from `start` to `end`. If no path is found, return `-1`. Constraints - The graph will have at most 1000 nodes. - Node labels are unique strings. - There will be no negative edges in the graph. - `start` and `end` are guaranteed to be in the graph. Examples ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\", \\"E\\"], \\"C\\": [\\"A\\", \\"F\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"B\\", \\"F\\"], \\"F\\": [\\"C\\", \\"E\\"] } assert shortest_path(graph, \\"A\\", \\"F\\") == 2 assert shortest_path(graph, \\"A\\", \\"E\\") == 2 assert shortest_path(graph, \\"D\\", \\"C\\") == 3 assert shortest_path(graph, \\"E\\", \\"A\\") == 2 assert shortest_path(graph, \\"A\\", \\"G\\") == -1 # \\"G\\" is not in the graph ``` # Requirements 1. Use an appropriate graph traversal algorithm, such as Breadth-First Search (BFS), to find the shortest path. 2. Ensure your solution efficiently handles the upper constraints of the graph size. 3. Implement proper handling for cases where no path exists between the given nodes. # Approach - Use a queue to explore each node level by level (BFS). - Maintain a set of visited nodes to avoid processing the same node multiple times. - Track the number of edges traversed to determine the path length. Return the length once the end node is reached. - If traversal completes without finding the end node, return `-1`.","solution":"from collections import deque def shortest_path(graph: dict, start: str, end: str) -> int: Finds the shortest path between start and end nodes in an unweighted graph. Parameters: - graph (dict): An adjacency list representing the graph. - start (str): The starting node. - end (str): The target node. Returns: - int: The length of the shortest path. Returns -1 if no path exists. if start == end: return 0 queue = deque([(start, 0)]) # queue to hold nodes along with current path length visited = set() # set to track visited nodes while queue: current_node, path_length = queue.popleft() if current_node == end: return path_length for neighbor in graph.get(current_node, []): if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path_length + 1)) return -1"},{"question":"# Context You are tasked with developing a function that tracks the inventory of a small retail business. An inventory system is essential for maintaining the stock levels and ensuring that products are available for sale when needed. The system must allow for adding new products, updating stock levels, and generating reports of current inventory levels. # Requirements Implement a class `Inventory` that will manage the inventory of products. Each product has a unique identifier, name, and quantity. The class should support methods to add new products, update the quantity of existing products, and generate a summary report of all products currently in the inventory. # Class Specification ```python class Inventory: def __init__(self): Initializes an empty inventory dictionary. pass def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. :param product_id: str, a unique identifier for the product. :param name: str, the name of the product. :param quantity: int, the quantity of the product to be added. :return: None pass def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of an existing product in the inventory. :param product_id: str, the unique identifier of the product. :param quantity: int, the new quantity of the product. :return: None pass def generate_report(self) -> str: Generates a report of all current products in the inventory, listing each product\'s id, name, and quantity. :return: str, formatted string report of current inventory. pass ``` # Input - `product_id` - String representing the unique identifier of a product. - `name` - String representing the name of a product. - `quantity` - Integer representing the quantity of a product. # Output - `add_product` and `update_quantity` methods do not return any value. - `generate_report` method returns a string formatted to list all product details in the inventory. # Example ```python # Example usage inventory = Inventory() inventory.add_product(\\"001\\", \\"Apple\\", 50) inventory.add_product(\\"002\\", \\"Banana\\", 30) inventory.update_quantity(\\"001\\", 20) report = inventory.generate_report() print(report) # Example Output: # Product ID: 001, Name: Apple, Quantity: 20 # Product ID: 002, Name: Banana, Quantity: 30 ``` # Constraints - Ensure that `quantity` is a non-negative integer. - Ensure that the `product_id` is unique for each product added to the inventory. - If an update is made to a non-existing product, it should be handled by adding the product as a new entry. - The report should be formatted properly with clear and concise information about each product. # Notes - Use appropriate data structures to manage the inventory efficiently. - Consider edge cases like updating the quantity to zero. - You may add helper methods if necessary to keep the class methods clean and concise.","solution":"class Inventory: def __init__(self): Initializes an empty inventory dictionary. self.inventory = {} def add_product(self, product_id: str, name: str, quantity: int) -> None: Adds a new product to the inventory. :param product_id: str, a unique identifier for the product. :param name: str, the name of the product. :param quantity: int, the quantity of the product to be added. :return: None if product_id in self.inventory: raise ValueError(\\"Product ID already exists\\") self.inventory[product_id] = {\'name\': name, \'quantity\': quantity} def update_quantity(self, product_id: str, quantity: int) -> None: Updates the quantity of an existing product in the inventory. :param product_id: str, the unique identifier of the product. :param quantity: int, the new quantity of the product. :return: None if product_id not in self.inventory: self.inventory[product_id] = {\'name\': \'Unknown\', \'quantity\': quantity} else: self.inventory[product_id][\'quantity\'] = quantity def generate_report(self) -> str: Generates a report of all current products in the inventory, listing each product\'s id, name, and quantity. :return: str, formatted string report of current inventory. report_lines = [] for product_id, details in self.inventory.items(): report_lines.append(f\\"Product ID: {product_id}, Name: {details[\'name\']}, Quantity: {details[\'quantity\']}\\") return \\"n\\".join(report_lines)"},{"question":"# Problem Description You are given a grid representing a city where each cell can either be a building (denoted by a 1) or an empty space (denoted by a 0). Your task is to find the minimum distance from an empty space to the nearest building. The distance is calculated as the number of cells traversed horizontally or vertically to reach the building. If it is impossible to reach any building from an empty space, return -1. # Function Signature ```python def min_distance_to_building(grid: List[List[int]]) -> int: ``` # Input * `grid`: A 2D list of size `n x m` (1 <= n, m <= 300), where each element is either 0 (empty space) or 1 (building). # Output * Returns an integer representing the minimum distance from an empty space to the nearest building. Returns `-1` if there are no buildings in the grid or if it is impossible to reach a building from any empty space. # Constraints * The grid will have at least one empty space (0). # Example Example 1 ```python grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 1] ] min_distance_to_building(grid) -> 1 ``` Explanation: The nearest building to the empty space at (1, 1) is at (0, 0), resulting in a distance of 1. Example 2 ```python grid = [ [1, 1, 1], [1, 0, 1], [1, 1, 1] ] min_distance_to_building(grid) -> 1 ``` Explanation: The only empty space is at (1, 1) and it is surrounded by buildings, resulting in a distance of 1. Example 3 ```python grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] min_distance_to_building(grid) -> -1 ``` Explanation: There are no buildings in the grid, so it is impossible for any empty space to reach a building. # Special Cases * If all cells in the grid are empty spaces, the function should return `-1`. * The function should handle edge cases such as grids with only one row or one column. # Notes * Ensure the implementation efficiently handles the grid, given the constraints. * Consider using a breadth-first search (BFS) approach to determine the minimum distance from each empty space to the nearest building.","solution":"from collections import deque from typing import List def min_distance_to_building(grid: List[List[int]]) -> int: rows, cols = len(grid), len(grid[0]) buildings = [(r, c) for r in range(rows) for c in range(cols) if grid[r][c] == 1] if not buildings: return -1 def bfs(buildings): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] dist = [[float(\'inf\')] * cols for _ in range(rows)] queue = deque(buildings) for r, c in buildings: dist[r][c] = 0 while queue: r, c = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols: if dist[nr][nc] > dist[r][c] + 1: dist[nr][nc] = dist[r][c] + 1 queue.append((nr, nc)) return dist distance_grid = bfs(buildings) min_dist = float(\'inf\') for r in range(rows): for c in range(cols): if grid[r][c] == 0: min_dist = min(min_dist, distance_grid[r][c]) return -1 if min_dist == float(\'inf\') else min_dist"},{"question":"# Problem Statement: You are tasked with implementing a small-scale file system that supports basic operations such as creating files, writing content to files, and reading content from files. The file system should be managed using a directory structure where each directory can contain files or other directories. # Objective: Write a class `FileSystem` that supports the following methods: 1. **`mkdir(path: str)`**: Creates a directory at the specified path. 2. **`addContentToFile(filePath: str, content: str)`**: Adds content to a file at the specified path. If the file does not exist, it should be created. 3. **`readContentFromFile(filePath: str) -> str`**: Reads the content of a file at the specified path. Constraints: 1. All paths are absolute paths which start with a `/` and do not end with a `/` (except `/` itself). 2. You may assume that all operations are valid and within the constraints. No need to manage permissions or complex error handling. 3. Duplicate directories along the same path are not allowed. 4. When reading from a file, if the file does not exist, return an empty string. # Example: ```python fs = FileSystem() # Create directories fs.mkdir(\\"/a/b/c\\") fs.mkdir(\\"/x/y/z\\") # Add content to a file fs.addContentToFile(\\"/a/b/c/d\\", \\"hello\\") fs.addContentToFile(\\"/a/b/c/e\\", \\"world\\") # Read content from files content1 = fs.readContentFromFile(\\"/a/b/c/d\\") content2 = fs.readContentFromFile(\\"/a/b/c/e\\") print(content1) # Expected output: \\"hello\\" print(content2) # Expected output: \\"world\\" ``` # Your Task: Implement the `FileSystem` class as specified above. Specifically: 1. Handle the directory and file paths properly. 2. Ensure the methods achieve their intended purpose.","solution":"class FileSystem: def __init__(self): self.filesystem = {} # Use a dictionary to manage the directory structure def mkdir(self, path: str): parts = path.strip(\'/\').split(\'/\') cur = self.filesystem for part in parts: if part not in cur: cur[part] = {} cur = cur[part] def addContentToFile(self, filePath: str, content: str): parts = filePath.strip(\'/\').split(\'/\') cur = self.filesystem for part in parts[:-1]: if part not in cur: cur[part] = {} cur = cur[part] if parts[-1] in cur: cur[parts[-1]] += content else: cur[parts[-1]] = content def readContentFromFile(self, filePath: str) -> str: parts = filePath.strip(\'/\').split(\'/\') cur = self.filesystem for part in parts: if part in cur: cur = cur[part] else: return \\"\\" return cur if isinstance(cur, str) else \\"\\""},{"question":"# Isomorphic Strings: Duplication Pattern Check **Context**: You are creating a text-processing utility, and you need to verify if two strings follows the same character pattern. Specifically, you want to check if the strings are isomorphic. Two strings (s) and (t) are isomorphic if the characters in (s) can be replaced to get (t). **Task**: Implement a function `is_isomorphic(s: str, t: str) -> bool` that returns whether the two given strings (s) and (t) are isomorphic. **Input Format**: - Two strings `s` and `t` which represent the strings to be compared. - Both strings will only contain alphabetical characters. - The lengths of the strings will vary but will be between 1 and (10^4) characters. **Output Format**: - A boolean value `True` if the strings are isomorphic, `False` otherwise. **Constraints**: - The function should handle the input strings efficiently given their possible length. **Examples**: ```python assert is_isomorphic(\\"egg\\", \\"add\\") == True assert is_isomorphic(\\"foo\\", \\"bar\\") == False assert is_isomorphic(\\"paper\\", \\"title\\") == True assert is_isomorphic(\\"ab\\", \\"aa\\") == False ``` **Performance Requirements**: - Ensure the function runs efficiently for input strings up to the maximum length with an expected time complexity of O(n).","solution":"def is_isomorphic(s: str, t: str) -> bool: Checks if two strings are isomorphic. if len(s) != len(t): return False s_to_t_mapping = {} t_to_s_mapping = {} for char_s, char_t in zip(s, t): if char_s in s_to_t_mapping: if s_to_t_mapping[char_s] != char_t: return False else: s_to_t_mapping[char_s] = char_t if char_t in t_to_s_mapping: if t_to_s_mapping[char_t] != char_s: return False else: t_to_s_mapping[char_t] = char_s return True"},{"question":"# Problem Statement Given an array of numbers representing scores achieved by a player in a game, you are to determine the highest score that can be achieved by performing a series of moves. In each move, you can pick any two distinct scores and replace them with their sum. The game continues until only one score remains in the array. Write a function `max_final_score` that takes in a list of integers and returns the highest possible final score that can be achieved by performing the moves as described. Function Signature ```python def max_final_score(scores: List[int]) -> int: pass ``` Input * `scores` (list of integers): A list of integers representing the scores achieved by a player. The length `n` of `scores` will satisfy `2 <= n <= 1000`, and each score will be between `1` and `1000`. Output * An integer: The highest possible final score after performing the moves. Example ```python assert max_final_score([4, 2, 1, 3]) == 10 assert max_final_score([5, 5, 5, 5]) == 20 ``` Constraints * You can assume that the input list always contains at least two elements. * The list may contain duplicate scores. # Additional Context You can refer to the previously provided code snippet for an example of the method used to solve this problem. Ensure to handle edge cases such as large inputs efficiently.","solution":"def max_final_score(scores): Returns the highest possible final score after performing the moves as described. Each move consists of picking any two distinct scores and replacing them with their sum until only one score remains. Args: scores (List[int]): A list of integers representing the scores achieved by a player. Returns: int: The highest possible final score. while len(scores) > 1: scores.sort(reverse=True) first = scores.pop(0) second = scores.pop(0) scores.append(first + second) return scores[0]"},{"question":"# Coding Question You are tasked to design a Python function that reads, processes, and analyzes a CSV file containing user transaction data. The function should calculate summary statistics and return data aggregated by user. Function Requirements: - **Function Name**: `process_transaction_data` - **Inputs**: - `file_path` (str): The file path to the CSV file. - `aggregation_field` (str): The field to aggregate transactions by (default = \\"user_id\\"). - **Outputs**: - A dictionary where keys are user IDs and values are dictionaries of summary statistics: - Total amount spent (sum of `amount` field). - Average amount per transaction. - Number of transactions. - **Constraints**: - The CSV file must contain at least the following fields: `user_id`, `transaction_id`, `amount`. - If the specified `aggregation_field` does not exist in the CSV, raise a `ValueError` with the message \\"Invalid aggregation field: {field}\\". - Ensure that the `amount` field is interpreted as a floating-point number. - **Edge Cases**: - Non-existing file paths. - Empty CSV files. # Example Usage ```python try: summary = process_transaction_data(\\"transactions.csv\\") for user_id, stats in summary.items(): print(f\\"User {user_id}:\\") for stat, value in stats.items(): print(f\\" {stat}: {value}\\") except ValueError as ve: print(ve) except IOError: print(\\"Error reading the file, please check the file path and try again.\\") ``` # Notes - You may use the `csv` module or any other library of your choice to parse the CSV file. - Ensure the solution handles large files efficiently. - Return empty dictionaries for users with no transactions recorded in the CSV. # Example Solution Signature ```python def process_transaction_data( file_path: str, aggregation_field: str = \\"user_id\\" ) -> dict: # Your code here pass ```","solution":"import csv def process_transaction_data(file_path: str, aggregation_field: str = \\"user_id\\") -> dict: transaction_data = {} try: with open(file_path, mode=\'r\') as csvfile: csv_reader = csv.DictReader(csvfile) if aggregation_field not in csv_reader.fieldnames: raise ValueError(f\\"Invalid aggregation field: {aggregation_field}\\") for row in csv_reader: user_id = row.get(aggregation_field) amount = float(row.get(\'amount\', 0)) if user_id not in transaction_data: transaction_data[user_id] = { \'total_amount\': 0.0, \'transaction_count\': 0 } transaction_data[user_id][\'total_amount\'] += amount transaction_data[user_id][\'transaction_count\'] += 1 for user_id, stats in transaction_data.items(): total_amount = stats[\'total_amount\'] transaction_count = stats[\'transaction_count\'] stats[\'average_amount\'] = total_amount / transaction_count if transaction_count > 0 else 0 return transaction_data except FileNotFoundError: raise IOError(f\\"Error reading the file, please check the file path and try again.\\")"},{"question":"Anagram Grouping with Preserved Word Order Problem Statement: In this task, the goal is to group a list of words into anagrams, maintaining the original order of their first occurrence. An anagram is a word formed by rearranging the letters of another, using all the original letters exactly once. Input: - A list of strings containing words. Output: - A list of lists, each containing words that are anagrams of each other, preserving the order of their first occurrence in the input. Constraints: - The length of the word list won\'t exceed 10,000 entries. - Each word will have a length of up to 100 characters. - All words will contain only lowercase English letters. Requirements: - Group words into lists of anagrams. - Maintain the original order of the first occurrence of the groups as they appeared in the input. Example: ```python Input: [\\"listen\\", \\"silent\\", \\"enlist\\", \\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"] Output: [[\\"listen\\", \\"silent\\", \\"enlist\\"], [\\"eat\\", \\"tea\\", \\"ate\\"], [\\"tan\\", \\"nat\\"], [\\"bat\\"]] ``` Hints: 1. Utilize a dictionary to map sorted character representation to corresponding word lists. 2. Ensure that you maintain the order of first occurrence for each anagram group in the input.","solution":"def group_anagrams(words): Groups a list of words into anagrams while maintaining the order of their first occurrence. :param words: List of strings where each string is a word. :return: List of lists, where each sublist contains words that are anagrams. anagrams_dict = {} result = [] for word in words: key = \'\'.join(sorted(word)) if key not in anagrams_dict: anagrams_dict[key] = [] anagrams_dict[key].append(word) for word in words: key = \'\'.join(sorted(word)) if key in anagrams_dict: result.append(anagrams_dict.pop(key)) return result"},{"question":"# Question: Implement Range Sum Query Optimized Create a class `RangeSumQuery` that efficiently calculates the sum of elements within a specific index range of an array. The class should support initializing with an array of integers and answering multiple range sum queries in an optimized manner. Class Definition ```python class RangeSumQuery: def __init__(self, nums: list[int]): Initialize the object with a list of integers. Preprocesses the data to support efficient range sum queries. :param nums: List of integers def sum_range(self, left: int, right: int) -> int: Returns the sum of elements between indices left and right inclusive. :param left: Start index of the range (inclusive) :param right: End index of the range (inclusive) :return: Sum of elements in the specified range :raises: IndexError if indices are out of bounds. ``` Input * Class initialization with a list of integers: `nums` (list of integers): The list of integers to initialize the object with. * Method `sum_range` parameters: - `left` (int): The starting index of the range (inclusive). - `right` (int): The ending index of the range (inclusive). Output * `sum_range` returns an integer: The sum of elements in the specified range. Constraints * All integer elements in the list and range indices must be within sensible bounds for typical integer values. * The list size (`nums`) can be up to (10^5). * The sum range queries may be called multiple times, up to (10^5) queries. * Index bounds: (0 leq texttt{left} leq texttt{right} < texttt{len(nums)}). Example ```python >>> nums = [1, 2, 3, 4, 5] >>> rsq = RangeSumQuery(nums) >>> rsq.sum_range(1, 3) 9 >>> rsq.sum_range(0, 4) 15 >>> rsq.sum_range(2, 2) 3 >>> rsq.sum_range(0, 0) 1 >>> rsq.sum_range(3, 4) 9 ``` # Requirements * Optimize range sum queries using pre-processing techniques such as prefix sums. * Ensure to handle edge cases, such as empty arrays, single-element ranges, and out-of-bound indices appropriately.","solution":"class RangeSumQuery: def __init__(self, nums: list[int]): Initialize the object with a list of integers. Preprocesses the data to support efficient range sum queries. # Precomputation of prefix sums self.prefix_sums = [0] * (len(nums) + 1) for i in range(len(nums)): self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i] def sum_range(self, left: int, right: int) -> int: Returns the sum of elements between indices left and right inclusive. if left < 0 or right >= len(self.prefix_sums) - 1 or left > right: raise IndexError(\\"Indices are out of bounds\\") return self.prefix_sums[right + 1] - self.prefix_sums[left]"},{"question":"# Longest Common Subsequence Challenge Subject: Dynamic Programming Background The Longest Common Subsequence (LCS) is a classic problem in computer science. Given two sequences, the task is to find the length of their longest subsequences that are common in both sequences. A subsequence is a sequence obtained by deleting zero or more elements from an array, without changing the order of the remaining elements. Function Signature Write a function with the following signature: ```python def longest_common_subsequence(text1: str, text2: str) -> int: pass ``` Input - **text1**: A string (1 ≤ |text1| ≤ 1000) representing the first sequence. - **text2**: A string (1 ≤ |text2| ≤ 1000) representing the second sequence. Output - **Return**: An integer representing the length of the longest common subsequence between the given two sequences. Constraints - Your solution should handle inputs efficiently given the constraints. - The lengths of text1 and text2 can vary and may include edge cases where there is no common subsequence. Examples 1. Input: `text1 = \\"abcde\\"`, `text2 = \\"ace\\"` Output: `3` Explanation: The longest common subsequence is \\"ace\\", which has length 3. 2. Input: `text1 = \\"abc\\"`, `text2 = \\"abc\\"` Output: `3` Explanation: The longest common subsequence is \\"abc\\", which has length 3. 3. Input: `text1 = \\"abc\\"`, `text2 = \\"def\\"` Output: `0` Explanation: There is no common subsequence, so the length is 0. Notes - Be mindful of the efficiency of your solution, particularly with larger input sizes. - Consider using dynamic programming to optimize your solution for better performance. Your implementation should correctly solve the problem, handle edge cases, and return results efficiently.","solution":"def longest_common_subsequence(text1: str, text2: str) -> int: Returns the length of the longest common subsequence between text1 and text2. m, n = len(text1), len(text2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if text1[i-1] == text2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"# Problem Statement Create a function that determines the smallest common multiple of a list of integers. The smallest common multiple is the smallest positive number that is a multiple of all numbers in the list. # Function Signature ```python def smallest_common_multiple(numbers: List[int]) -> int: ``` # Input - A list `numbers` of integers where: - Constraints: `2 <= len(numbers) <= 15` - Each integer in the list is between `1` and `100`. # Output - An integer representing the smallest common multiple of all integers in the provided list. # Example ```python assert smallest_common_multiple([4, 6, 8]) == 24 assert smallest_common_multiple([1, 2, 3, 4, 5]) == 60 assert smallest_common_multiple([2, 3, 5, 7]) == 210 ``` # Constraints - Ensure the solution is efficient and can handle the upper limits of the input constraints. # Notes - Utilize the mathematical relationship between the greatest common divisor (GCD) and least common multiple (LCM) to optimize the calculation. # Edge Cases - Consider the possibility of having `1` in the input list, which should not affect the LCM. - The function should handle cases with the smallest length and values at the extreme ends of the constraints.","solution":"from typing import List from math import gcd def lcm(a: int, b: int) -> int: Compute the Least Common Multiple (LCM) of two numbers a and b. return a * b // gcd(a, b) def smallest_common_multiple(numbers: List[int]) -> int: Compute the smallest common multiple of a list of integers. result = numbers[0] for num in numbers[1:]: result = lcm(result, num) return result"},{"question":"# Palindrome Password Generator Context You are developing a secure password generation system for a new application that ensures all generated passwords are palindromes (a palindrome is a word that reads the same backward as forward). The system should support custom alphabets and varying password lengths. Task Implement the following function: 1. `generate_palindrome_password(length: int, alphabet: str | None = None) -> str`: * Generates a palindrome password of the specified length using the provided alphabet. Input * `length`: An integer representing the length of the palindrome password to be generated. * `alphabet`: Optional. A string representing the custom alphabet to use. Defaults to the combined lowercase and uppercase English alphabet. Output * A string that is a palindrome of the specified length. Constraints * `1 <= length <= 10^4` * If `alphabet` is not provided, use `\\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\"` * Ensure the solution efficiently handles edge cases and minimizes unnecessary computations. Function Signature ```python def generate_palindrome_password(length: int, alphabet: str | None = None) -> str: pass ``` Example Scenarios 1. Generating a palindrome password with default alphabet: * Input: `(5)` * Output: `\\"ababa\\"` or `\\"aaaAa\\"` or any other valid 5-character palindrome. 2. Generating a palindrome password with custom alphabet: * Input: `(6, \\"01\\")` * Output: `\\"010101\\"` or `\\"101010\\"` or any other valid 6-character palindrome using the digits \\"0\\" and \\"1\\". Implement the function to ensure it follows robust error handling and efficient processing practices.","solution":"import random def generate_palindrome_password(length: int, alphabet: str | None = None) -> str: Generates a palindrome password of the specified length using the provided alphabet. :param length: The desired length of the palindrome password. :param alphabet: The custom alphabet to use. If None, defaults to combined lowercase and uppercase English alphabet. :return: A palindrome password of the specified length. if alphabet is None: alphabet = \\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" half_length = (length + 1) // 2 # Half length rounded up for odd lengths # Generate the first half of the palindrome password first_half = \'\'.join(random.choice(alphabet) for _ in range(half_length)) # Generate the second half based on the first half if length % 2 == 0: second_half = first_half[::-1] else: second_half = first_half[:-1][::-1] return first_half + second_half"},{"question":"# Scenario You are developing a task scheduler library for a project management application. One of the functionalities of this library is to determine the order of task execution given their dependencies. Each task is represented by a unique identifier, and a dependency list specifies which tasks must be completed before others. # Objective Write a Python function named `find_task_order` that accepts two inputs: a list of task identifiers and a list of tuples representing the dependent relationships between these tasks. The function should return the correct order of tasks to be executed such that all dependencies are satisfied. If no valid order exists due to cyclic dependencies, the function should return an empty list. # Function Signature ```python def find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: pass ``` # Input 1. `tasks` (List[int]): A list of integers representing unique task identifiers. 2. `dependencies` (List[Tuple[int, int]]): A list of tuples where the first element tuple[0] must be completed before tuple[1]. # Output * A list of integers representing the order in which tasks should be executed to satisfy all dependencies, or an empty list if no valid order exists. # Constraints * All task identifiers are unique. * The list of dependencies can be empty, indicating no dependencies. * Tasks and dependencies must be integers. # Requirements 1. The function should efficiently handle cyclic dependencies and return an empty list if they exist. 2. The function should properly validate the input for correctness. # Examples ```python >>> find_task_order([1, 2, 3, 4], [(1, 2), (2, 3), (3, 4)]) [1, 2, 3, 4] >>> find_task_order([1, 2, 3, 4], [(1, 2), (1, 3), (3, 2), (2, 4)]) [1, 3, 2, 4] >>> find_task_order([1, 2, 3, 4], [(1, 2), (2, 3), (3, 1)]) [] >>> find_task_order([1, 2, 3, 4], []) [1, 2, 3, 4] >>> find_task_order([3, 1, 4, 2], [(3, 1), (4, 2)]) [3, 1, 4, 2] ``` # Notes * You may assume that any task identifier not appearing in the dependencies list is independent and can be executed at any point. * The solution should be designed to handle relatively large input sizes efficiently. Provide well-documented code and include any assumptions made in your solution.","solution":"from typing import List, Tuple def find_task_order(tasks: List[int], dependencies: List[Tuple[int, int]]) -> List[int]: from collections import defaultdict, deque # Build the graph and the in-degree dictionary in_degree = {task: 0 for task in tasks} graph = defaultdict(list) for u, v in dependencies: graph[u].append(v) in_degree[v] += 1 # Queue for nodes with no incoming edges zero_degree_queue = deque([task for task in tasks if in_degree[task] == 0]) # List to store the task order task_order = [] while zero_degree_queue: node = zero_degree_queue.popleft() task_order.append(node) # Decrease the in-degree of the neighbors for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: zero_degree_queue.append(neighbor) # If task_order contains all tasks, we have a valid ordering if len(task_order) == len(tasks): return task_order else: # There exists a cycle, return an empty list return []"},{"question":"# Question You are developing a data processing script that performs data transformations on a set of CSV files. The files contain sales data, and each file is named according to the store it represents (e.g., `store_001.csv`, `store_002.csv`). Each CSV file has columns `date`, `product_id`, `quantity`, and `amount`. Your task is to implement a function `aggregate_sales_data` that: 1. Processes all CSV files in the specified directory. 2. Aggregates the total sales amount (`amount`) for each `product_id` across all stores. 3. Saves the aggregated data into a new CSV file named `aggregated_sales.csv` in the specified output directory. **Function Signature:** ```python def aggregate_sales_data(input_directory: pathlib.Path, output_directory: pathlib.Path) -> None: pass ``` # Input: - `input_directory`: A `pathlib.Path` object pointing to the directory containing the CSV files. - `output_directory`: A `pathlib.Path` object pointing to the directory where the output CSV file should be saved. # Output: - Saves the aggregated data to a file called `aggregated_sales.csv` in the specified output directory. # Aggregated CSV File: - Columns should be `product_id` and `total_amount`. - Each row represents a unique `product_id` and the sum of the `amount` for that product across all stores. # Constraints: - Each input CSV file has the same structure. - Assume that all files contain valid data and no missing values. - Handle any necessary imports within the function itself. # Example: Given the input CSV files in `sales_data/`: **store_001.csv**: ```csv date,product_id,quantity,amount 2023-01-01,101,2,30.0 2023-01-01,102,1,20.0 ``` **store_002.csv**: ```csv date,product_id,quantity,amount 2023-01-01,101,1,15.0 2023-01-01,103,3,45.0 ``` **aggregated_sales.csv**: ```csv product_id,total_amount 101,45.0 102,20.0 103,45.0 ``` ```python # Example Usage: from pathlib import Path aggregate_sales_data(Path(\\"sales_data\\"), Path(\\"output_data\\")) # The file \\"output_data/aggregated_sales.csv\\" should now contain the aggregated sales data ```","solution":"import pathlib import pandas as pd def aggregate_sales_data(input_directory: pathlib.Path, output_directory: pathlib.Path) -> None: Aggregates total sales amount for each product_id across all CSV files in the provided input directory and saves the output to a new CSV file in the output directory. Args: - input_directory (pathlib.Path): The path to the directory containing the input CSV files. - output_directory (pathlib.Path): The path to the directory where the output CSV file should be saved. Returns: - None consolidated_data = pd.DataFrame() # Iterate over all csv files in the input directory for csv_file in input_directory.glob(\\"*.csv\\"): df = pd.read_csv(csv_file) consolidated_data = pd.concat([consolidated_data, df]) # Group by product_id and sum the amount aggregated_data = consolidated_data.groupby(\'product_id\')[\'amount\'].sum().reset_index() aggregated_data.rename(columns={\'amount\': \'total_amount\'}, inplace=True) # Save to a new CSV file in the output directory output_filepath = output_directory / \'aggregated_sales.csv\' aggregated_data.to_csv(output_filepath, index=False)"},{"question":"# Problem Statement You are asked to generate all possible unique combinations of a given length from a list of distinct integers. Combinations are selections of items where their order does not matter. Write a Python function `unique_combinations(nums: list[int], length: int) -> list[list[int]]` that takes a list of distinct integers `nums` and an integer `length`, and returns a list of lists containing all unique combinations of `length` elements from `nums`. # Function Signature ```python def unique_combinations(nums: list[int], length: int) -> list[list[int]]: ``` # Input * `nums` (list[int]): A list of distinct integers. * `length` (int): The number of elements each combination should have. # Output * list of lists of ints: A list containing all unique combinations of `length` elements from `nums`. # Constraints * The integer `length` must be between 0 and the length of `nums` inclusive. * The input list `nums` will have at most 20 distinct integers. # Examples ```python >>> unique_combinations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 3]] >>> unique_combinations([1, 2, 3, 4], 3) [[1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]] >>> unique_combinations([], 0) [[]] >>> unique_combinations([1, 2, 3], 1) [[1], [2], [3]] >>> unique_combinations([1, 2, 3], 0) [[]] >>> unique_combinations([1], 2) [] ``` # Notes * If `length` is 0, the only combination is an empty list. * If `length` is greater than the length of `nums`, return an empty list. * Do not use any libraries to generate the combinations.","solution":"def unique_combinations(nums: list[int], length: int) -> list[list[int]]: def backtrack(start: int, current_combination: list[int]): if len(current_combination) == length: result.append(current_combination[:]) return for i in range(start, len(nums)): current_combination.append(nums[i]) backtrack(i + 1, current_combination) current_combination.pop() result = [] backtrack(0, []) return result"},{"question":"# Longest Subarray with Equal Number of 0s and 1s You need to implement an algorithm that finds the length of the longest subarray with an equal number of 0s and 1s. **Function Signature:** ```python def longest_subarray(arr: list[int]) -> int: Find the length of the longest subarray with equal number of 0s and 1s. Args: arr (list[int]): The input array of integers containing only 0s and 1s. Returns: int: The length of the longest subarray with equal number of 0s and 1s. Examples: >>> longest_subarray([0, 1, 0, 1]) 4 >>> longest_subarray([0, 0, 1, 0, 1, 1, 0]) 6 >>> longest_subarray([0, 0, 0, 1, 1, 1, 0]) 6 >>> longest_subarray([1, 1, 1, 1]) 0 ``` # Input: - A list of integers `arr` of size `n` where `1 <= n <= 10^6` and each element is either 0 or 1. # Output: - Return an integer that represents the length of the longest subarray with an equal number of 0s and 1s. If no such subarray exists, return 0. # Example: ```markdown Example 1: Input: arr = [0, 1, 0, 1] Output: 4 Example 2: Input: arr = [0, 0, 1, 0, 1, 1, 0] Output: 6 Example 3: Input: arr = [1, 1, 1, 1] Output: 0 ``` # Constraints: - The function must run in O(n) time complexity. - The function must use O(n) extra space for storage. # Explanation: 1. Convert all 0s in the array to -1s and keep 1s as they are. 2. Utilize a hash map to store the first occurrence of every cumulative sum. 3. Traverse the array, maintaining a cumulative sum and check if this sum has been seen before. 4. If the sum has been seen before, update the maximum length of the subarray. 5. If it has not been seen, store this sum along with the current index. 6. After the loop, return the maximum length found. Ensure your function handles the edge cases and performs efficiently up to the maximum constraints.","solution":"def longest_subarray(arr): Find the length of the longest subarray with equal number of 0s and 1s. Args: arr (list[int]): The input array of integers containing only 0s and 1s. Returns: int: The length of the longest subarray with equal number of 0s and 1s. # Change 0 to -1 arr = [-1 if x == 0 else 1 for x in arr] # Dictionary to store the first occurrence of each sum sum_index = {} curr_sum = 0 max_length = 0 for i in range(len(arr)): curr_sum += arr[i] # Check if this sum has been seen before if curr_sum == 0: max_length = i + 1 elif curr_sum in sum_index: max_length = max(max_length, i - sum_index[curr_sum]) else: sum_index[curr_sum] = i return max_length"},{"question":"# Coding Question: Efficient Interval Merging **Context**: Bob is working on a scheduling application that needs to handle overlapping intervals efficiently. Given a list of intervals where each interval is represented by a tuple of two integers (start, end) marking the start and end times, the goal is to merge all overlapping intervals. **Objective**: Your task is to implement the `IntervalMerger` class that merges all overlapping intervals and returns a list of the non-overlapping intervals. **Function to Implement**: You need to implement the `IntervalMerger` class with the following method: ```python class IntervalMerger: def __init__(self, intervals: list[tuple[int, int]]): # Initialize method with the list of intervals. self.intervals = intervals def merge_intervals(self) -> list[tuple[int, int]]: # Method to merge overlapping intervals and return the merged list. pass ``` **Input Format**: - The constructor `__init__` receives a list of intervals, where each interval is represented as a tuple of two integers `start` and `end`. - Example: `intervals = [(1, 3), (2, 5), (6, 8)]` - The `merge_intervals` method will not receive any parameters. **Output Format**: - The `merge_intervals` method should return a list of tuples representing the merged intervals. - Example: `[(1, 5), (6, 8)]` **Constraints**: - The list will contain at most 10,000 intervals. - The intervals are guaranteed to have integer start and end times, and `start <= end`. **Performance Requirements**: - The solution should be optimized to handle large input sizes efficiently. **Example**: Given the following intervals: ```python intervals = [(1, 3), (2, 5), (8, 10), (15, 18)] ``` Output: - The merged intervals should be: `[(1, 5), (8, 10), (15, 18)]` Another example: Given the following intervals: ```python intervals = [(1, 4), (4, 5)] ``` Output: - The merged intervals should be: `[(1, 5)]` Implement your solution in the class provided to correctly merge overlapping intervals. ```python class IntervalMerger: def __init__(self, intervals: list[tuple[int, int]]): self.intervals = intervals def merge_intervals(self) -> list[tuple[int, int]]: if not self.intervals: return [] # Sort intervals based on the start times self.intervals.sort(key=lambda x: x[0]) merged_intervals = [self.intervals[0]] for start, end in self.intervals[1:]: last_end = merged_intervals[-1][1] if start <= last_end: merged_intervals[-1] = (merged_intervals[-1][0], max(last_end, end)) else: merged_intervals.append((start, end)) return merged_intervals ```","solution":"class IntervalMerger: def __init__(self, intervals: list[tuple[int, int]]): self.intervals = intervals def merge_intervals(self) -> list[tuple[int, int]]: if not self.intervals: return [] # Sort intervals based on the start times self.intervals.sort(key=lambda x: x[0]) merged_intervals = [self.intervals[0]] for start, end in self.intervals[1:]: last_start, last_end = merged_intervals[-1] if start <= last_end: merged_intervals[-1] = (last_start, max(last_end, end)) else: merged_intervals.append((start, end)) return merged_intervals"},{"question":"# Problem: Generate Fibonacci Sequence Efficiently Develop an algorithm to generate the Fibonacci sequence up to the n-th term using both recursive and iterative techniques. Your task is to implement both methods and then refactor the recursive approach to optimize it using memoization. # Requirements 1. **Input**: - An integer `n` representing the number of terms to generate. Assume (0 leq n leq 40). 2. **Output**: - A list of the first `n` terms of the Fibonacci sequence. # Function Specification Implement three functions: 1. `fibonacci_recursive(n)` that accepts: - `n`: An integer representing the number of terms to generate. - Returns a list of the first `n` terms of the Fibonacci sequence, computed using a naive recursive approach. 2. `fibonacci_iterative(n)` that accepts: - `n`: An integer representing the number of terms to generate. - Returns a list of the first `n` terms of the Fibonacci sequence, computed using an iterative approach. 3. `fibonacci_memoized(n, memo=None)` that accepts: - `n`: An integer representing the number of terms to generate. - `memo`: A dictionary used for memoization to store previously computed terms. - Returns a list of the first `n` terms of the Fibonacci sequence, optimized using memoization. # Optimization Instructions 1. Compare the runtime of naive recursion versus the iterative method. 2. Refactor the naive recursive function to incorporate memoization, reducing redundant calculations. # Constraints 1. Ensure your solutions handle all edge cases gracefully. 2. The memoized version should demonstrate a significant performance improvement for higher values of `n`. # Example ```python print(fibonacci_recursive(10)) print(fibonacci_iterative(10)) print(fibonacci_memoized(10)) ``` Expected output for each method: ```python [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ``` # Notes 1. **Performance**: Measure and compare the execution times of each method for increasing values of `n`. 2. **Correctness**: Ensure each method produces the correct sequence elements for all test cases. 3. **Edge Cases**: Handle cases where ( n = 0 ) or ( n = 1 ) appropriately, returning [] or [0] respectively.","solution":"def fibonacci_recursive(n): Naive recursive approach to generate the first n terms of the Fibonacci sequence. if n == 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] return fibonacci_recursive(n-1) + [fibonacci_recursive(n-1)[-1] + fibonacci_recursive(n-1)[-2]] def fibonacci_iterative(n): Iterative approach to generate the first n terms of the Fibonacci sequence. if n == 0: return [] elif n == 1: return [0] sequence = [0, 1] while len(sequence) < n: sequence.append(sequence[-1] + sequence[-2]) return sequence def fibonacci_memoized(n, memo=None): Optimized recursive approach using memoization to generate the first n terms of the Fibonacci sequence. if memo is None: memo = {0: [], 1: [0], 2: [0, 1]} if n in memo: return memo[n] else: result = fibonacci_memoized(n-1, memo) + [fibonacci_memoized(n-1, memo)[-1] + fibonacci_memoized(n-1, memo)[-2]] memo[n] = result return result"},{"question":"# Problem Description You are required to implement a function `matrix_intersection` that takes two matrices and returns a new matrix representing their \\"Intersection Matrix\\". The Intersection Matrix of two matrices (A) and (B) is defined as: [ text{Intersection Matrix}(A, B) = { text{element} mid text{element} in A cap B } ] The function should ensure that the intersection is computed element-wise and the result is presented in the same dimension as the input matrices. If matrices have different dimensions, the function should raise an exception. # Function Signature ```python def matrix_intersection(matrix_a: list[list[int]], matrix_b: list[list[int]]) -> list[list[int]]: ``` # Input * `matrix_a`: A list of lists representing a matrix, where each list is a row of the matrix (1 ≤ len(matrix_a), len(matrix_a[0]) ≤ 50) * `matrix_b`: A list of lists representing a matrix of the same dimension as matrix_a # Output * Return a matrix (list of lists) containing the intersection of elements at corresponding positions from `matrix_a` and `matrix_b`, with specified value 0 in case of no intersection at that position. # Constraints 1. The function should raise a ValueError with a message if the input matrices do not have the same dimensions. 2. All elements in the matrices are integers. # Example ```python assert matrix_intersection( [[1, 2, 3], [4, 5, 6]], [[3, 2, 1], [6, 5, 4]]) == [[0, 2, 0], [0, 5, 0]] assert matrix_intersection( [[1, 2], [3, 4]], [[1, 3], [2, 4]]) == [[1, 0], [0, 4]] ``` # Notes * Ensure your function handles edge cases such as matrices with only one element or all elements being distinct appropriately. * The returned matrix should preserve the same dimensions as the input matrices. * Aim to keep the function clear and efficient within the provided constraints.","solution":"def matrix_intersection(matrix_a, matrix_b): Returns the intersection matrix of given two matrices A and B. The intersection matrix at each position (i, j) is the element if both are the same in A and B, otherwise 0. # Check if the dimensions match if not matrix_a or not matrix_b: raise ValueError(\\"Matrices should not be empty.\\") rows_a, cols_a = len(matrix_a), len(matrix_a[0]) rows_b, cols_b = len(matrix_b), len(matrix_b[0]) if rows_a != rows_b or cols_a != cols_b: raise ValueError(\\"Matrices dimensions do not match.\\") # Initialize the result matrix with zeros result_matrix = [[0] * cols_a for _ in range(rows_a)] # Compute the intersection matrix for i in range(rows_a): for j in range(cols_a): if matrix_a[i][j] == matrix_b[i][j]: result_matrix[i][j] = matrix_a[i][j] return result_matrix"},{"question":"# Coding Assessment Question Scenario You are developing a data processing application that includes various statistical functions. To evaluate students\' understanding of sorting algorithms and their ability to implement them effectively, you decide to include a task that involves sorting a list of points based on their distance from the origin in 2D space. Task Implement a function `sort_points_by_distance` that sorts a given list of points based on their Euclidean distance from the origin (0, 0). The function should use a sorting algorithm of your choice while demonstrating an understanding of distance computation and sorting principles. Function Signature ```python def sort_points_by_distance(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]: ``` Parameters - `points`: A list of tuples, where each tuple contains two floats representing the x and y coordinates of a point in 2D space. Requirements 1. Compute the Euclidean distance from the origin for each point. 2. Sort the points in ascending order of their distance from the origin. 3. Ensure the function handles lists with varied point densities and edge cases, such as points at the origin or identical points. Example Usage ```python points = [(3, 4), (1, 2), (0, 0), (2, 1)] sorted_points = sort_points_by_distance(points) print(f\\"Points sorted by distance from the origin: {sorted_points}\\") # Output: Points sorted by distance from the origin: [(0, 0), (1, 2), (2, 1), (3, 4)] points = [(10, 10), (-1, -1), (5, 5), (3, 3)] sorted_points = sort_points_by_distance(points) print(f\\"Points sorted by distance from the origin: {sorted_points}\\") # Output: Points sorted by distance from the origin: [(-1, -1), (3, 3), (5, 5), (10, 10)] ``` Constraints - The algorithm should have an average case time complexity of O(n log n). - Handle edge cases, including empty lists and lists with duplicate points. - Aim for clear and efficient code, leveraging Python\'s built-in sorting functionality appropriately where necessary. Performance Requirements - The sorted list should maintain stability for points with equal distances, i.e., the relative order of points with the same distance should be preserved as in the input list. - Ensure the solution is optimized for lists with high dimensional variance and large list sizes within typical computational limits. # Assessor\'s Notes - Ensure students understand the concept of Euclidean distance and sorting mechanisms. - Test for performance and edge cases, such as empty lists and points with zero distance. - Assess code efficiency, clarity, and adherence to the problem constraints.","solution":"from typing import List, Tuple import math def sort_points_by_distance(points: List[Tuple[float, float]]) -> List[Tuple[float, float]]: Sorts a list of points based on their Euclidean distance from the origin (0, 0). Args: points (List[Tuple[float, float]]): A list of tuples representing points in 2D space. Returns: List[Tuple[float, float]]: The list of points sorted by their distance from the origin. return sorted(points, key=lambda point: math.sqrt(point[0]**2 + point[1]**2))"},{"question":"# Sum of Prime Factors Design a function that calculates the sum of all unique prime factors of a given integer (n). # Function Signature `def sum_of_prime_factors(n: int) -> int:` # Input - An integer (n) where (n geq 2). # Output - Returns the sum of all unique prime factors of (n). # Constraints - (2 leq n leq 10^{12}) - Handle invalid input where (n < 2) by raising a `ValueError`. # Example ```python >>> sum_of_prime_factors(28) 10 >>> sum_of_prime_factors(100) 5 >>> sum_of_prime_factors(2) 2 ``` # Explanation - For (n = 28): - The prime factors of 28 are 2 and 7. - The sum of these unique prime factors (2 + 7 = 9). - For (n = 100): - The prime factors of 100 are 2 and 5. - The sum of these unique prime factors (2 + 5 = 7). - For (n = 2): - The only prime factor of 2 is 2 itself. - Therefore, the sum is (2). # Additional Notes - Consider edge cases, such as when (n) is itself a prime number. - Ensure the function is optimized to handle large values of (n).","solution":"from math import isqrt def sum_of_prime_factors(n: int) -> int: if n < 2: raise ValueError(\\"Input must be an integer greater than or equal to 2.\\") prime_factors = set() # check number of 2\'s that divide n while n % 2 == 0: prime_factors.add(2) n //= 2 # n must be odd at this point, so skip even numbers and iterate only for odd numbers for i in range(3, isqrt(n) + 1, 2): while n % i == 0: prime_factors.add(i) n //= i # This condition is to check if n is a prime number greater than 2 if n > 2: prime_factors.add(n) return sum(prime_factors)"},{"question":"# Breadth-First Search Algorithm & Graph Connectivity Context You\'re building a module for network connectivity analysis that needs to find the shortest path between nodes in an unweighted graph and determine if all nodes in the graph are connected. Task Write a function called `bfs_shortest_path_and_connectivity` that uses a Breadth-First Search (BFS) algorithm to find the shortest path between two nodes in a graph, and checks if the graph is fully connected. Function Signature ```python def bfs_shortest_path_and_connectivity(graph: dict, start: str, end: str) -> tuple[list[str], bool]: pass ``` Input * `graph` (dict): An undirected graph represented in the dictionary format where keys are node names (strings) and values are lists of adjacent nodes (strings). * `start` (str): Starting vertex for the BFS traversal. * `end` (str): Ending vertex for the BFS traversal. Output * `(shortest_path, is_connected)` (tuple[list, bool]): A tuple with two elements: * `shortest_path` (list): A list of nodes representing the shortest path from `start` to `end`. If no path exists, return an empty list. * `is_connected` (bool): A Boolean value `True` if all nodes in the graph are connected, i.e., there is a path between every pair of vertices, and `False` otherwise. Constraints * The graph can have up to (10^4) nodes. * Nodes names are non-empty strings of up to 50 characters. * The graph may have disconnected components. * The graph is undirected and unweighted. Example ```python def test_bfs_shortest_path_and_connectivity(): graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\", \\"E\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"C\\"], \\"F\\": [] } shortest_path, is_connected = bfs_shortest_path_and_connectivity(graph, \\"A\\", \\"E\\") assert shortest_path == [\\"A\\", \\"C\\", \\"E\\"] assert is_connected == False fully_connected_graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\", \\"E\\"], \\"D\\": [\\"B\\", \\"E\\"], \\"E\\": [\\"C\\", \\"D\\"] } shortest_path, is_connected = bfs_shortest_path_and_connectivity(fully_connected_graph, \\"A\\", \\"E\\") assert shortest_path == [\\"A\\", \\"C\\", \\"E\\"] assert is_connected == True disconnected_graph = { \\"A\\": [\\"B\\"], \\"B\\": [\\"A\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"C\\"] } shortest_path, is_connected = bfs_shortest_path_and_connectivity(disconnected_graph, \\"A\\", \\"D\\") assert shortest_path == [] assert is_connected == False print(\\"All tests passed!\\") test_bfs_shortest_path_and_connectivity() ``` You should also consider writing additional test cases to cover edge cases, such as graphs with isolated nodes or large graphs with many nodes and edges.","solution":"from collections import deque def bfs_shortest_path_and_connectivity(graph, start, end): def bfs_shortest_path(): visited = {node: False for node in graph} parent = {node: None for node in graph} queue = deque([start]) visited[start] = True while queue: current = queue.popleft() if current == end: break for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True parent[neighbor] = current queue.append(neighbor) path = [] if visited[end]: step = end while step: path.append(step) step = parent[step] path.reverse() return path def bfs_connectivity(): visited = {node: False for node in graph} queue = deque([list(graph.keys())[0]]) visited[queue[0]] = True while queue: current = queue.popleft() for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return all(visited.values()) shortest_path = bfs_shortest_path() is_connected = bfs_connectivity() return (shortest_path, is_connected)"},{"question":"# Problem Statement Given an unsorted list of integers, determine if it is possible to rearrange the numbers in the list such that no two adjacent numbers have the same value. If such a rearrangement is possible, return any valid rearrangement as a list of integers. If no such arrangement exists, return an empty list. # Task Write a function `rearrange_list` that takes in a list of integers, `nums`, and returns a list of integers that is a valid rearrangement or an empty list if no valid rearrangement exists. # Input * `nums`: A list of integers which may contain duplicates. # Output * A list of integers representing a valid rearrangement, or an empty list if no valid rearrangement exists. # Constraints * The length of `nums` will be at most 10,000 elements. # Example ```python def rearrange_list(nums: list[int]) -> list[int]: pass # Example Usage nums = [1, 1, 1, 2, 2, 3] print(rearrange_list(nums)) # Output: [1, 2, 1, 2, 1, 3] (or any valid output like [1, 3, 1, 2, 1, 2]) ``` # Notes Ensure the rearrangement function considers all edge cases such as empty lists and lists where all numbers are the same. Focus on achieving optimal performance for the given constraints.","solution":"from collections import Counter import heapq def rearrange_list(nums): Rearrange the list such that no two adjacent elements are the same. If this is not possible, return an empty list. if not nums: return [] # Count frequency of each number num_counts = Counter(nums) # Create a max heap based on negative counts (to simulate a max heap using min heap) max_heap = [(-count, num) for num, count in num_counts.items()] heapq.heapify(max_heap) prev_count, prev_num = 0, None result = [] while max_heap: count, num = heapq.heappop(max_heap) # Add the current number to the result list result.append(num) if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_num)) # Update the previous number and count prev_count, prev_num = count + 1, num # If no valid rearrangement is possible, return an empty list if not max_heap and prev_count < 0: return [] return result"},{"question":"# **MST Financial Network** You have been tasked with analyzing a financial network composed of various transactions. The goal is to identify the minimal spanning tree (MST) of this network to understand the least amount of transactions needed to keep the network connected optimally. You are provided with a list of transactions, where each transaction is represented as an edge with a weight denoting the transaction amount. You need to implement a function that constructs the MST using Kruskal\'s algorithm. **Function Signature**: ```python def kruskal_mst(transactions: List[Tuple[int, int, float]]) -> List[Tuple[int, int, float]]: pass ``` **Input**: * `transactions`: A list of transactions, where each transaction is represented as a tuple `(u, v, amount)`. Here, `u` and `v` are integers representing nodes (banks), and `amount` is the floating-point number representing the transaction amount. **Output**: * A list of tuples representing the edges of the MST. Each tuple should be in the form `(u, v, amount)` and should be part of the minimal spanning tree. **Constraints**: * Assume there are at most `10^3` transactions. * The nodes are represented as integers. * Each transaction amount is a positive number. **Example**: ```python transactions = [ (0, 1, 4.0), (0, 2, 3.0), (1, 2, 1.0), (1, 3, 2.0), (2, 3, 5.0), (3, 4, 7.0) ] result = kruskal_mst(transactions) assert result == [(1, 2, 1.0), (1, 3, 2.0), (0, 2, 3.0), (3, 4, 7.0)] ``` **Note**: - Use Kruskal\'s algorithm to find the MST which involves sorting the edges by weight and using a union-find data structure to detect and avoid cycles. - Ensure your implementation efficiently handles the provided constraints and edge cases such as disconnected graphs where an MST wouldn\'t exist. --- **Implementation Details:** To solve this problem efficiently, you\'ll follow these steps: 1. **Sort all edges by weight:** Begin by sorting the list of transactions based on the transaction amounts in ascending order. 2. **Union-Find Data Structure:** Utilize a union-find (disjoint-set) data structure to manage the connected components of the graph. 3. **Kruskal\'s Algorithm:** - Iterate through the sorted edges. - For each edge, use the union-find structure to determine if adding the edge would form a cycle. - If no cycle is formed, add the edge to the MST. - If adding the edge would form a cycle, ignore the edge. You can refer to existing data structure libraries or implement your own union-find with path compression and union-by-rank to ensure optimal performance.","solution":"from typing import List, Tuple class UnionFind: A union-find (disjoint set) data structure with path compression and union by rank. def __init__(self, size): self.parent = list(range(size)) self.rank = [0] * size def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def kruskal_mst(transactions: List[Tuple[int, int, float]]) -> List[Tuple[int, int, float]]: # Determine the number of nodes in the graph nodes = set() for u, v, amount in transactions: nodes.add(u) nodes.add(v) num_nodes = len(nodes) # Sort the transactions by amount (weight) sorted_transactions = sorted(transactions, key=lambda x: x[2]) # Initialize Union-Find data structure uf = UnionFind(num_nodes) # Kruskal\'s algorithm to find MST mst = [] for u, v, amount in sorted_transactions: if uf.find(u) != uf.find(v): uf.union(u, v) mst.append((u, v, amount)) return mst"},{"question":"# User Authentication System Question Context: You are developing a web application that requires a secure user authentication system. For this purpose, you need to implement a function that verifies if a username and password comply with the application’s security policies. Problem Statement: Implement a function `validate_credentials(username: str, password: str) -> dict` that checks if the provided username and password meet the following criteria: - The username must be at least 5 characters long and contain only alphanumeric characters. - The password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one digit, and one special character (e.g., !, @, #, , etc.). If both the username and password meet the specified criteria, the function should return a dictionary with a success message. Otherwise, it should return a dictionary with an appropriate error message indicating why the credentials are invalid. Function Signature: ```python def validate_credentials(username: str, password: str) -> dict: # Your code here ``` Expected Input and Output: * **Input**: Two strings representing the username and password, e.g., `\\"user123\\"` and `\\"Passw0rd!\\"`. * **Output**: A dictionary. For example: * On success: `{\'status\': \'success\', \'message\': \'Credentials are valid.\'}` * On error: `{\'status\': \'error\', \'message\': \'<error_message>\'}` Constraints: * The username must contain only alphanumeric characters. * The password must include at least one uppercase letter, one lowercase letter, one digit, and one special character. * Both the username and the password must meet their respective length requirements. Example: ```python # Example usage print(validate_credentials(\\"user123\\", \\"Passw0rd!\\")) print(validate_credentials(\\"User\\", \\"password\\")) # Expected Output { \'status\': \'success\', \'message\': \'Credentials are valid.\' } { \'status\': \'error\', \'message\': \'Username must be at least 5 characters long.\' } { \'status\': \'error\', \'message\': \'Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one digit, and one special character.\' } ``` Performance Requirements: Ensure your function efficiently validates the credentials without unnecessary delays, and handles input validation in a secure manner. Test Cases: Test your code with the following credentials: * Valid credentials: `\\"user123\\"`, `\\"Pasw0rd1!\\"` * Invalid username: `\\"usr\\"` (less than 5 characters) * Invalid password: `\\"password\\"` (lacks required complexity) * Invalid username and password: `\\"user!\\"`, `\\"pass\\"`","solution":"import re def validate_credentials(username: str, password: str) -> dict: if not (username.isalnum() and len(username) >= 5): return {\'status\': \'error\', \'message\': \'Username must be at least 5 characters long and contain only alphanumeric characters.\'} if len(password) < 8: return {\'status\': \'error\', \'message\': \'Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one digit, and one special character.\'} special_characters = re.compile(\'[!@#%^&*(),.?\\":{}|<>]\') if not (any(char.islower() for char in password) and any(char.isupper() for char in password) and any(char.isdigit() for char in password) and special_characters.search(password)): return {\'status\': \'error\', \'message\': \'Password must be at least 8 characters long and include at least one uppercase letter, one lowercase letter, one digit, and one special character.\'} return {\'status\': \'success\', \'message\': \'Credentials are valid.\'}"},{"question":"# Coding Task: Implement Dynamic Programming Solution for Fibonacci Sequence Background Given the problem of finding the N-th Fibonacci number, your task is to implement a dynamic programming solution to solve it efficiently. The Fibonacci sequence is defined as follows: ``` fib(0) = 0 fib(1) = 1 fib(n) = fib(n-1) + fib(n-2) for n >= 2 ``` Using dynamic programming ensures a significant reduction in the time complexity compared to the naive recursive approach by storing intermediate results and avoiding redundant calculations. Function Signature ```python def fibonacci(n): Function to calculate the N-th Fibonacci number using dynamic programming. n : int : non-negative integer indicating the position in Fibonacci sequence Returns an integer representing the N-th Fibonacci number. >>> fibonacci(0) 0 >>> fibonacci(1) 1 >>> fibonacci(2) 1 >>> fibonacci(10) 55 >>> fibonacci(20) 6765 >>> fibonacci(50) 12586269025 ``` Input 1. **n**: A non-negative integer representing the position in the Fibonacci sequence. Output * Returns an integer representing the N-th Fibonacci number. Constraints * `0 <= n <= 100` Example ```python print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(2)) # Output: 1 print(fibonacci(10)) # Output: 55 print(fibonacci(20)) # Output: 6765 ``` # Requirements: 1. Use dynamic programming to ensure the solution is efficient. 2. The implementation should have a time complexity of O(n) and a space complexity of O(1) if possible.","solution":"def fibonacci(n): Function to calculate the N-th Fibonacci number using dynamic programming. n : int : non-negative integer indicating the position in Fibonacci sequence Returns an integer representing the N-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n+1): a, b = b, a + b return b"},{"question":"# Polynomial Derivative Computation Given a polynomial represented as a list of its coefficients, implement a function to compute its derivative. The polynomial derivatives can be calculated using the power rule: if the polynomial is `a_nx^n + a_(n-1)x^(n-1) + ... + a_1x + a_0`, its derivative will be `n*a_nx^(n-1) + (n-1)*a_(n-1)x^(n-2) + ... + 1*a_1`. Objective Write a function `polynomial_derivative` that computes the derivative of a polynomial provided as a list of coefficients. Function Signature ```python def polynomial_derivative(coefficients: List[float]) -> List[float]: ``` # Input - A list of `n+1` real numbers (floating-point values) `coefficients` representing a polynomial of degree `n`. The i-th element is the coefficient of the x^i term. # Output - A list of `n` real numbers representing the coefficients of the derivative polynomial. # Constraints - `1 <= n <= 10^6` - `-10^9 <= coefficients[i] <= 10^9` for all `0 <= i <= n` # Examples ```python assert polynomial_derivative([3, 2, 1]) == [2, 2] assert polynomial_derivative([5, 0, 0, 3]) == [0, 0, 9] assert polynomial_derivative([2]) == [] assert polynomial_derivative([0, 0, 7]) == [0, 14] ``` **Explanation**: 1. For the polynomial `1x^2 + 2x + 3`, the derivative is `2x + 2`, so the output is `[2, 2]`. 2. For the polynomial `3x^3`, the derivative is `9x^2`, so the output is `[0, 0, 9]`. 3. For the constant polynomial `2`, the derivative is `0`, so the output is `[]`. 4. For the polynomial `7x^2`, the derivative is `14x`, so the output is `[0, 14]`. # Requirements - Ensure your implementation handles large inputs efficiently. - Consider and handle edge cases such as the function receiving a list where the polynomial is of degree 0.","solution":"from typing import List def polynomial_derivative(coefficients: List[float]) -> List[float]: Computes the derivative of a polynomial represented by its coefficients. Parameters: coefficients (List[float]): A list of coefficients where the i-th element represents the coefficient of the x^i term. Returns: List[float]: A list of coefficients representing the derivative of the polynomial. if len(coefficients) <= 1: return [] derivative = [i * coefficients[i] for i in range(1, len(coefficients))] return derivative"},{"question":"# Average Rainfall Calculation Scenario You have been tasked with analyzing weather data for a region. One of the key metrics you need to calculate is the average monthly rainfall over a given period. Your task is to write a function that processes rainfall data and computes the average monthly rainfall. Problem Statement Implement a function `average_rainfall(rainfall_data: List[float]) -> float` that calculates the average monthly rainfall from a list of monthly rainfall amounts. Input Format: * `rainfall_data` - a list of floats representing the rainfall amounts in millimeters for each month. Output Format: * A float representing the average monthly rainfall in millimeters. Constraints: * The input list `rainfall_data` may be empty. In such a case, the function should return `0.0`. * All float values in `rainfall_data` must be non-negative. Otherwise, raise a `ValueError`. * The function should handle typical float ranges and maintain accuracy up to at least 4 decimal places. Examples: ```python >>> average_rainfall([100.0, 200.0, 150.0, 120.0]) 142.5 >>> average_rainfall([]) 0.0 >>> average_rainfall([50.5, 60.1, 45.0, 55.5]) 52.775 ``` Notes: * Ensure the function handles an empty list by outputting `0.0`. * Verify the input values to ensure they are non-negative before processing. * Maintain precision in your calculations to at least 4 decimal places.","solution":"from typing import List def average_rainfall(rainfall_data: List[float]) -> float: Computes the average monthly rainfall from a list of monthly rainfall amounts. Args: rainfall_data (List[float]): A list of floats representing the rainfall amounts in millimeters for each month. Returns: float: The average monthly rainfall in millimeters. Raises: ValueError: If any value in the list is negative. if not rainfall_data: return 0.0 if any(r < 0 for r in rainfall_data): raise ValueError(\\"Rainfall amounts must be non-negative\\") total_rainfall = sum(rainfall_data) number_of_months = len(rainfall_data) average_rainfall = total_rainfall / number_of_months return round(average_rainfall, 4)"},{"question":"# Question: Calculate the Edit Distance **Scenario:** You are working on a text processing project and need to determine how similar two strings are by calculating their edit distance. The edit distance (or Levenshtein distance) between two strings is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to transform one string into the other. **Your Task:** Write a Python function `edit_distance(str1: str, str2: str) -> int` that computes the edit distance between two given strings `str1` and `str2` using a dynamic programming approach. Your implementation should handle strings of varying lengths and characters. **Function Signature:** ```python def edit_distance(str1: str, str2: str) -> int: pass ``` **Input and Output:** * **Input:** Two strings `str1` and `str2`. * **Output:** An integer representing the edit distance between `str1` and `str2`. **Constraints:** * The lengths of `str1` and `str2` are between 0 and 1000 inclusive. * The strings `str1` and `str2` consist of printable ASCII characters. **Requirements:** * Use a dynamic programming approach to compute the edit distance. * Ensure your solution efficiently handles the maximum string length constraints. **Examples:** ```python assert edit_distance(\\"kitten\\", \\"sitting\\") == 3 assert edit_distance(\\"flaw\\", \\"lawn\\") == 2 assert edit_distance(\\"gumbo\\", \\"gambol\\") == 2 assert edit_distance(\\"\\", \\"abc\\") == 3 assert edit_distance(\\"abc\\", \\"abc\\") == 0 ``` **Performance:** * Your solution should run in O(n * m) time complexity, where `n` and `m` are the lengths of `str1` and `str2` respectively. * The space complexity should be O(n * m). **Tips:** * Think about how you can use a 2D array to store the edit distances for substrings. * Remember to initialize your 2D array properly and fill it based on the recurrence relation: * If the characters are the same, the edit distance is the same as without these characters. * Otherwise, it is the minimum of replacing a character, inserting a character, or deleting a character. By following these guidelines, your solution will match the complexity, style, and scope of the existing questions, providing a robust assessment of your understanding of dynamic programming and string manipulation.","solution":"def edit_distance(str1: str, str2: str) -> int: n = len(str1) m = len(str2) # Create a 2D array to store the distance dp = [[0] * (m + 1) for _ in range(n + 1)] # Initialize the distances for converting empty string to a string for i in range(n + 1): dp[i][0] = i for j in range(m + 1): dp[0][j] = j # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if str1[i - 1] == str2[j - 1]: dp[i][j] = dp[i - 1][j - 1] # Characters match else: dp[i][j] = 1 + min(dp[i - 1][j], # Deletion dp[i][j - 1], # Insertion dp[i - 1][j - 1]) # Substitution return dp[n][m]"},{"question":"# Coding Assessment Question: Scenario: You are designing a system to help a bookstore manage their inventory. The bookstore wants to recommend books to customers based on specific criteria such as genre and author popularity. To facilitate this, you need to implement a function that filters the bookstore\'s full catalog and returns a list of recommended books. # Function Signature: ```python def recommend_books(catalog: List[Dict], genre: str, min_author_popularity: int, max_results: int) -> List[Dict]: pass ``` # Input: * `catalog` (List[Dict]): A list of dictionaries, where each dictionary represents a book with the following keys - \'title\' (str), \'author\' (str), \'genre\' (str), \'author_popularity\' (int). * `genre` (str): The genre to filter books by. * `min_author_popularity` (int): The minimum popularity score an author must have for their books to be recommended. * `max_results` (int): The maximum number of recommended books to return. # Output: * A list of dictionaries representing the recommended books, sorted by the \'author_popularity\' in descending order. Each dictionary should include the \'title\', \'author\', and \'genre\' of the book. # Example: ```python catalog = [ {\'title\': \'Book A\', \'author\': \'Author X\', \'genre\': \'Science Fiction\', \'author_popularity\': 95}, {\'title\': \'Book B\', \'author\': \'Author Y\', \'genre\': \'Fantasy\', \'author_popularity\': 85}, {\'title\': \'Book C\', \'author\': \'Author Z\', \'genre\': \'Science Fiction\', \'author_popularity\': 90}, {\'title\': \'Book D\', \'author\': \'Author X\', \'genre\': \'Fantasy\', \'author_popularity\': 95}, ] assert recommend_books(catalog, \'Science Fiction\', 80, 2) == [ {\'title\': \'Book A\', \'author\': \'Author X\', \'genre\': \'Science Fiction\'}, {\'title\': \'Book C\', \'author\': \'Author Z\', \'genre\': \'Science Fiction\'} ] ``` # Constraints: * The length of `catalog` will be between `1` and `1000`. * Each book entry\'s `author_popularity` will be between `0` and `100`. * `max_results` will be a positive integer not exceeding the number of books in the catalog. # Performance Requirements: * Ensure your solution can handle the maximum catalog size efficiently. Implementation: Write the function `recommend_books` that filters and sorts the book recommendations, and returns a list of dictionaries with only the necessary details (\'title\', \'author\', \'genre\').","solution":"from typing import List, Dict def recommend_books(catalog: List[Dict], genre: str, min_author_popularity: int, max_results: int) -> List[Dict]: Filters and returns a list of recommended books based on genre and author popularity. Parameters: catalog (List[Dict]): The full list of books in the catalog. genre (str): The genre to filter books by. min_author_popularity (int): The minimum popularity score an author must have for their books to be recommended. max_results (int): The maximum number of recommended books to return. Returns: List[Dict]: A list of recommended books, each dictionary contains \'title\', \'author\', and \'genre\'. # Filter books by genre and minimum author popularity filtered_books = [ book for book in catalog if book[\'genre\'] == genre and book[\'author_popularity\'] >= min_author_popularity ] # Sort books by author popularity in descending order sorted_books = sorted(filtered_books, key=lambda x: x[\'author_popularity\'], reverse=True) # Get top results up to max_results top_books = sorted_books[:max_results] # Prepare final output format recommended_books = [{\'title\': book[\'title\'], \'author\': book[\'author\'], \'genre\': book[\'genre\']} for book in top_books] return recommended_books"},{"question":"# Problem: Circular Queue Implementation You are required to implement a circular queue using an array. A circular queue is a linear data structure that follows the FIFO (First In, First Out) principle, but the last position of the queue is connected back to the first position to make a circle. It efficiently utilizes space and is suitable for scenarios like buffering data streams. Requirements: 1. **Implement a method `enqueue(data: int) -> bool`**: - This method should insert the specified data into the circular queue. - If the queue is full, return `False`. Otherwise, return `True`. 2. **Implement a method `dequeue() -> int | None`**: - This method should remove and return the data at the front of the queue. - If the queue is empty, return `None`. 3. **Implement a method `front() -> int | None`**: - This method should return the data at the front of the queue without removing it. - If the queue is empty, return `None`. 4. **Implement a method `is_empty() -> bool`**: - This method should return `True` if the queue is empty, otherwise return `False`. 5. **Implement a method `is_full() -> bool`**: - This method should return `True` if the queue is full, otherwise return `False`. Function Signatures: ```python class CircularQueue: def __init__(self, capacity: int) -> None: # Initialization with given capacity def enqueue(self, data: int) -> bool: # Code for enqueue def dequeue(self) -> int | None: # Code for dequeue def front(self) -> int | None: # Code for front def is_empty(self) -> bool: # Code for is_empty def is_full(self) -> bool: # Code for is_full ``` Input/Output Formats: - `__init__(capacity: int) -> None` - Input: Capacity (integer) - Output: None - `enqueue(data: int) -> bool` - Input: Data (integer) - Output: Boolean - `dequeue() -> int | None` - Input: None - Output: Front element\'s data (integer) or None - `front() -> int | None` - Input: None - Output: Front element\'s data (integer) or None - `is_empty() -> bool` - Input: None - Output: Boolean - `is_full() -> bool` - Input: None - Output: Boolean Constraints: - The circular queue should be implemented using an array. - `enqueue` should handle overflow situations gracefully. - `dequeue` should handle underflow situations gracefully. - `front` should not modify the queue. - `is_empty` and `is_full` should provide accurate status checks.","solution":"class CircularQueue: def __init__(self, capacity: int) -> None: Initialize the circular queue with the given capacity. self.capacity = capacity self.queue = [None] * capacity self.front_index = -1 self.rear_index = -1 def enqueue(self, data: int) -> bool: Inserts the specified data into the circular queue. If the queue is full, returns False. Otherwise, returns True. if self.is_full(): return False if self.is_empty(): self.front_index = 0 self.rear_index = (self.rear_index + 1) % self.capacity self.queue[self.rear_index] = data return True def dequeue(self) -> int | None: Removes and returns the data at the front of the queue. If the queue is empty, returns None. if self.is_empty(): return None data = self.queue[self.front_index] if self.front_index == self.rear_index: # Queue is now empty self.front_index, self.rear_index = -1, -1 else: self.front_index = (self.front_index + 1) % self.capacity return data def front(self) -> int | None: Returns the data at the front of the queue without removing it. If the queue is empty, returns None. if self.is_empty(): return None return self.queue[self.front_index] def is_empty(self) -> bool: Returns True if the queue is empty, otherwise returns False. return self.front_index == -1 def is_full(self) -> bool: Returns True if the queue is full, otherwise returns False. return (self.rear_index + 1) % self.capacity == self.front_index"},{"question":"Algorithm for Sorting a Linked List You are required to implement a function that sorts a singly linked list using merge sort. The objective is to design a function that efficiently sorts the linked list, maintaining the following structure and constraints: 1. **Node Definition** - Define a linked list node with a value and a reference to the next node. 2. **Sorting Algorithm** - Implement the merge sort algorithm to sort the linked list. # Implementation Details: 1. Create a `ListNode` class to represent a node in the singly linked list. 2. Implement a `sort_linked_list` function that should: - Take the head node of the linked list as the only parameter. - Return the head node of the sorted linked list. # Constraints: - The list nodes contain integer values. - The list can be of arbitrary length, potentially including thousands of elements. - Duplicate values are allowed. # Example Usage: ```python >>> nodes = [ListNode(4), ListNode(2), ListNode(1), ListNode(3)] >>> for i in range(len(nodes) - 1): ... nodes[i].next = nodes[i + 1] ... >>> sorted_head = sort_linked_list(nodes[0]) >>> sorted_values = [] >>> current = sorted_head >>> while current: ... sorted_values.append(current.value) ... current = current.next ... >>> sorted_values [1, 2, 3, 4] ``` # Submit your implementation with the following function and class signatures: ```python class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next def sort_linked_list(head: ListNode) -> ListNode: pass ``` # Steps to Implement Merge Sort on a Linked List: 1. Implement a `split` function to divide the list into two halves. 2. Implement a `merge` function to merge two sorted linked lists. 3. Implement the `sort_linked_list` function to use these helper functions for completing the merge sort. Your function should be efficient and capable of handling large linked lists within a reasonable time frame.","solution":"class ListNode: def __init__(self, value: int = 0, next: \'ListNode\' = None): self.value = value self.next = next def sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head def split(head): slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None return head, slow def merge(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.value < l2.value: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 or l2 return dummy.next first_half, second_half = split(head) left = sort_linked_list(first_half) right = sort_linked_list(second_half) return merge(left, right)"},{"question":"# Coding Challenge: Given the importance of efficient search algorithms, particularly in large datasets, implementing the Binary Search algorithm with optimizations is a valuable skill. This task is aimed at creating an enhanced version of Binary Search that can handle not only sorted arrays of integers but also sorted arrays containing floating-point numbers or strings. # Objective: Write a function `optimized_binary_search` that: 1. Takes a sorted list of elements that can include integers, floating-point numbers, or strings. 2. Implements a method to efficiently search for an element within this list. 3. Returns the index of the element if found, otherwise returns -1. Expected Input and Output: * **Input**: * A sorted list of elements (integers, floating-point numbers, or strings). * A target element to search for within the list. * **Output**: * The index of the target element if found; otherwise, -1. Performance Requirements: * The function should work with a time complexity of O(log n). Constraints and Considerations: * The list provided as input is guaranteed to be sorted. * Handle edge cases such as empty lists or lists containing very few elements. * Ensure robust handling of different data types without causing type errors. * Consider the use of recursion or iterative approaches in your implementation. # Example: ```python def optimized_binary_search(arr: list, target) -> int: pass print(optimized_binary_search([1, 3, 5, 7, 9], 7)) # Expected output: 3 print(optimized_binary_search([1.1, 2.2, 3.3, 4.4], 3.3)) # Expected output: 2 print(optimized_binary_search([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"], \\"banana\\")) # Expected output: 1 print(optimized_binary_search([10, 20, 30], 25)) # Expected output: -1 print(optimized_binary_search([], 5)) # Expected output: -1 ``` # Note: * Ensure your solution includes detailed documentation explaining your implementation choices and assumptions. * Consider the trade-offs between using a recursive or iterative version of the algorithm. By following these guidelines, the new question should align well with the existing set in terms of style, complexity, and scope.","solution":"def optimized_binary_search(arr, target): Perform binary search on the sorted list `arr` to find the `target`. Parameters: arr (list): A sorted list of elements (integers, floating-point numbers, or strings). target : The element to search for within the list. Returns: int: The index of the target element if found; otherwise, -1. left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 mid_value = arr[mid] if mid_value == target: return mid elif mid_value < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question As a part of an advanced data processing task, you need to implement a method to efficiently merge two sorted singly linked lists into a single sorted linked list without using any extra space. The primary goal is to ensure the merged list maintains the sorted order and that the solution operates within O(n) time complexity, where n is the total number of nodes in both lists. Function Signature ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: pass ``` Input/Output * **Input**: - `l1`: The head node of the first sorted singly linked list. - `l2`: The head node of the second sorted singly linked list. * **Output**: - Returns the head node of the merged sorted singly linked list. Constraints * The input lists are sorted in non-decreasing order. * The total number of nodes across both lists will not exceed 10^4. * The values of the nodes in the lists are within the range -10^5 to 10^5. * The `ListNode` class is predefined. Scenario Consider you are a software developer working on a healthcare data management system. Patient records are maintained in sorted linked lists based on their admission date. You need to merge two departments\' patient lists into a single, chronologically sorted list for generating comprehensive reports. The goal is to perform this operation efficiently without requiring extra memory for another list, ensuring the merged list preserves the sorted structure. Example ```python # Example usage # Helper function to create a linked list from a list def create_linked_list(arr): if not arr: return None head = ListNode(arr[0]) current = head for value in arr[1:]: current.next = ListNode(value) current = current.next return head # Helper function to print linked list def print_linked_list(head): result = [] while head: result.append(head.val) head = head.next print(result) # Creating linked lists from arrays l1 = create_linked_list([1, 3, 5]) l2 = create_linked_list([2, 4, 6]) # Merging the linked lists merged_head = merge_two_sorted_lists(l1, l2) print_linked_list(merged_head) # Output: [1, 2, 3, 4, 5, 6] ``` Note Ensure that you handle edge cases such as one of the lists being empty and test your solution for stability and efficiency with different lengths and values of lists.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_sorted_lists(l1: ListNode, l2: ListNode) -> ListNode: # Create a dummy node to help simplify the merge process dummy = ListNode() current = dummy # Traverse both lists and append the smallest node to the merged list while l1 and l2: if l1.val < l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next # If we\'ve reached the end of one list, append the other list if l1: current.next = l1 if l2: current.next = l2 return dummy.next"},{"question":"# Problem Statement: Write a function that takes a list of integers and returns a new list where each integer is replaced by the product of all other integers in the list except the integer at the current position. # Input: A list of integers `nums`. # Output: A list of integers where each element is the product of all other elements in the input list except for the element at the same position. # Constraints: * The function should handle empty input lists and lists with a single element appropriately. * The function should handle large lists efficiently. * The function should handle edge cases such as lists containing zero. # Function Signature: ```python def product_except_self(nums: List[int]) -> List[int]: # Your implementation goes here ``` # Examples: ```python assert product_except_self([1, 2, 3, 4]) == [24, 12, 8, 6] assert product_except_self([0, 1, 2, 3]) == [6, 0, 0, 0] assert product_except_self([0, 0, 3, 4]) == [0, 0, 0, 0] assert product_except_self([2, 3, 4, 5]) == [60, 40, 30, 24] assert product_except_self([1]) == [1] assert product_except_self([]) == [] ```","solution":"from typing import List def product_except_self(nums: List[int]) -> List[int]: n = len(nums) if n == 0: return [] elif n == 1: return [1] left_products = [1] * n right_products = [1] * n left_cumulative_product = 1 for i in range(n): left_products[i] = left_cumulative_product left_cumulative_product *= nums[i] right_cumulative_product = 1 for i in range(n-1, -1, -1): right_products[i] = right_cumulative_product right_cumulative_product *= nums[i] result = [] for i in range(n): result.append(left_products[i] * right_products[i]) return result"},{"question":"# Matrix Rotation and Reflection In this task, you need to implement two functions: one that rotates a matrix by 90 degrees clockwise, and another that reflects a matrix horizontally. The functions should handle any NxN matrix of integers. **Function Signatures**: - Implement the function `def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]:` - Implement the function `def reflect_matrix_horizontal(matrix: List[List[int]]) -> List[List[int]]:` # Requirements: 1. **rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]**: - Accepts a square matrix (NxN) of integers and returns a new matrix that is rotated 90 degrees clockwise. - Ensure that the function handles various matrix sizes, including edge cases like an empty matrix or a 1x1 matrix. 2. **reflect_matrix_horizontal(matrix: List[List[int]]) -> List[List[int]]**: - Accepts a square matrix (NxN) of integers and returns a new matrix that is reflected horizontally (mirrored along the horizontal axis). - Assure that the function correctly handles different dimensions of matrices as well as edge cases similar to those for the rotation function. # Constraints: - The input matrix will be a list of lists, where each inner list represents a row of the matrix. - Matrix dimensions (N times N) will be such that (1 leq N leq 1000). - The integers in the matrix will be such that (-10^6 leq matrix[i][j] leq 10^6). # Example: ```python # Example rotate_matrix_90_clockwise usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = rotate_matrix_90_clockwise(matrix) assert rotated_matrix == [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] # Example reflect_matrix_horizontal usage matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] reflected_matrix = reflect_matrix_horizontal(matrix) assert reflected_matrix == [ [7, 8, 9], [4, 5, 6], [1, 2, 3] ] ``` # Tests: Your implementation will be tested on a variety of cases, including: - Typical NxN matrices of different sizes. - Edge cases such as empty matrices and 1x1 matrices. - Matrices with both small and large integer values. Ensure your functions are correctly handling all these scenarios to validate their robustness.","solution":"from typing import List def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n-1-i] = matrix[i][j] return rotated_matrix def reflect_matrix_horizontal(matrix: List[List[int]]) -> List[List[int]]: if not matrix: return [] n = len(matrix) reflected_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): reflected_matrix[n-1-i][j] = matrix[i][j] return reflected_matrix"},{"question":"# Square Root Approximation As part of a mathematical software, you need to create a function that approximates the square root of a given non-negative number using the binary search algorithm. This approach should be efficient and work within a reasonable time for both small and large numbers. **Problem Statement**: Write a function `approximate_sqrt(n: float, precision: float) -> float` that takes two arguments: - `n`: The non-negative number whose square root needs to be approximated. - `precision`: The desired precision of the approximation. The function should return a float representing the approximated square root of `n` with the specified precision. **Input Constraints**: - `n` is a non-negative float. - `precision` is a positive float. **Requirements**: 1. If `n` is 0, the function should return 0. 2. The function should work efficiently for a wide range of numbers, from very small to very large. 3. The result should be accurate to within the specified precision. **Example**: ```python >>> print(approximate_sqrt(9, 0.001)) 3.0 >>> print(approximate_sqrt(0.25, 0.00001)) 0.5 >>> print(approximate_sqrt(2, 1e-7)) 1.4142136 >>> print(approximate_sqrt(123456789, 0.0001)) 11111.11106 ``` **Instructions**: - Use binary search to approximate the square root. - Ensure the function\'s performance is optimally efficient for a wide variety of inputs. - Test the function thoroughly with various numbers and precision requirements to confirm accuracy.","solution":"def approximate_sqrt(n: float, precision: float) -> float: Approximates the square root of a given non-negative number n with the specified precision using the binary search algorithm. if n == 0: return 0.0 low, high = 0.0, n if n < 1: high = 1.0 while high - low > precision: mid = (low + high) / 2 if mid * mid < n: low = mid else: high = mid return (low + high) / 2"},{"question":"# Python Dictionary Merging Function In this task, you are required to implement a function to merge two dictionaries. When there are conflicting keys between the dictionaries, the function should concatenate the values associated with these keys into a list. # Function Signature ```python def merge_dicts(dict1: dict, dict2: dict) -> dict: ``` # Inputs: - `dict1`: A dictionary containing key-value pairs. - `dict2`: Another dictionary containing key-value pairs. # Output: - A merged dictionary with concatenated values in case of key conflicts. # Constraints: - **Values in the dictionaries are either strings or integers.** - **In case of a conflict, if values are not of the same type, convert all values to strings and then concatenate them in a list.** # Example Scenarios Example 1 ```python merge_dicts({\'a\': 1, \'b\': 2}, {\'b\': 3, \'c\': 4}) Output: {\'a\': 1, \'b\': [2, 3], \'c\': 4} ``` Example 2 ```python merge_dicts({\'x\': \'apple\', \'y\': \'banana\'}, {\'y\': \'cherry\', \'z\': \'orange\'}) Output: {\'x\': \'apple\', \'y\': [\'banana\', \'cherry\'], \'z\': \'orange\'} ``` Example 3 ```python merge_dicts({\'key1\': 100, \'key2\': 200}, {\'key1\': \'new_value\', \'key3\': 300}) Output: {\'key1\': [100, \'new_value\'], \'key2\': 200, \'key3\': 300} ``` Example 4 ```python merge_dicts({}, {\'a\': 1, \'b\': 2}) Output: {\'a\': 1, \'b\': 2} ``` # Additional Requirements: 1. Ensure that the resultant dictionary maintains the order of the keys as they appear in the input dictionaries. 2. Handle cases where one or both input dictionaries are empty. 3. Provide thorough testing to validate correctness for diverse inputs and edge cases. Write your implementation to fulfill the requirements and test your function with a variety of inputs to ensure robustness.","solution":"def merge_dicts(dict1: dict, dict2: dict) -> dict: result = dict1.copy() # Start with a copy of the first dictionary for key, value in dict2.items(): if key in result: if isinstance(result[key], list): result[key].append(value) else: if isinstance(result[key], type(value)): result[key] = [result[key], value] else: result[key] = [str(result[key]), str(value)] else: result[key] = value return result"},{"question":"# Problem Statement You are given two non-empty binary trees. Each node in the trees contains an integer value. Your task is to implement a function that merges the two binary trees into one. The merge rule is that if two nodes overlap, then sum the values from both nodes and store the result in the merged node. Otherwise, the non-null node will be used as the node of the new tree. # Function Signature: ```python def merge_trees(tree1: TreeNode, tree2: TreeNode) -> TreeNode: ``` # Input: - `tree1`: The root of the first binary tree. - `tree2`: The root of the second binary tree. # Output: - Returns the root of the merged binary tree. # Constraints: - Each tree node contains a single integer. - The number of nodes in both trees is between 1 and 2000. - The integer values are in the range of `[-1000, 1000]`. # Example: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right # Creating first tree tree1 = TreeNode(1) tree1.left = TreeNode(3) tree1.right = TreeNode(2) tree1.left.left = TreeNode(5) # Creating second tree tree2 = TreeNode(2) tree2.left = TreeNode(1) tree2.right = TreeNode(3) tree2.left.right = TreeNode(4) tree2.right.right = TreeNode(7) result_tree = merge_trees(tree1, tree2) # Expected Output: The merged tree would be represented as: # 3 # / # 4 5 # / # 5 4 7 def inorder_traversal(root: TreeNode): if not root: return [] return inorder_traversal(root.left) + [root.val] + inorder_traversal(root.right) print(inorder_traversal(result_tree)) # Example expected output: [5, 4, 4, 3, 5, 7] ``` # Notes: - You should not use any extra space for data structures other than the provided trees and should work in-place. - Consider edge cases where one tree might be significantly larger than the other or one tree is completely empty.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def merge_trees(tree1: TreeNode, tree2: TreeNode) -> TreeNode: if not tree1 and not tree2: return None # If one of the trees is empty, return the other tree. if not tree1: return tree2 if not tree2: return tree1 # Merge the values of tree1 and tree2 merged_root = TreeNode(tree1.val + tree2.val) # Recursively merge the left and right children merged_root.left = merge_trees(tree1.left, tree2.left) merged_root.right = merge_trees(tree1.right, tree2.right) return merged_root"},{"question":"# Question: Two-Sum Problem You are tasked with writing a function in Python that finds two numbers in an array that add up to a specific target. If such a pair exists, the function should return their indices as a tuple. If no such pair exists, the function should return `None`. Function Signature ```python def two_sum(nums: list, target: int) -> Optional[Tuple[int, int]]: ... ``` # Input * A list `nums` of integers (where 0 leq |nums| leq 10^4). * An integer `target` representing the sum we are looking for. # Output * A tuple of two integers representing the indices of the two numbers that add up to the `target`. If no such pair exists, return `None`. # Constraints * The input list can contain duplicate elements. * The solution should have a time complexity of O(n). # Examples 1. `two_sum([2, 7, 11, 15], 9)` ➞ `(0, 1)` because 2 + 7 = 9. 2. `two_sum([3, 2, 4], 6)` ➞ `(1, 2)` because 2 + 4 = 6. 3. `two_sum([3, 3], 6)` ➞ `(0, 1)` because 3 + 3 = 6. 4. `two_sum([1, 2, 3], 7)` ➞ `None` because no two numbers add up to 7. # Things to Consider * Ensure your solution works efficiently with both small and large lists. * Consider edge cases such as an empty list, no solution, or multiple possible pairs. * Make sure the function returns the first occurrence pair of indices when multiple pairs sum up to the target. # Implementation Write your function, ensuring to follow the constraints and handle the edge cases appropriately.","solution":"from typing import Optional, Tuple, List def two_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Finds two numbers in the list that add up to the target and returns their indices. Arguments: nums: A list of integers. target: An integer representing the target sum. Returns: A tuple of two integers representing the indices of the two numbers that add up to the target. Returns None if no such pair exists. num_to_index = {} for index, num in enumerate(nums): complement = target - num if complement in num_to_index: return (num_to_index[complement], index) num_to_index[num] = index return None"},{"question":"# Dijkstra\'s Algorithm: Shortest Path in a Weighted Graph # Scenario You have been tasked with developing a function that calculates the shortest path in a weighted, directed graph using Dijkstra\'s algorithm. # Task Write a Python function `dijkstra_shortest_path` that finds the shortest path from a given start node to all other nodes in the graph and returns the distances. # Function Signature ```python def dijkstra_shortest_path(graph: Dict[Any, Dict[Any, float]], start_node: Any) -> Dict[Any, float]: ``` # Input 1. `graph` (Dict[Any, Dict[Any, float]]): A dictionary representing a weighted, directed graph, where the keys are nodes and the values are dictionaries of neighboring nodes and their respective edge weights. 2. `start_node` (Any): The node from which to start the shortest path calculation. # Output * Returns a dictionary where keys are nodes and values are the shortest distance from the `start_node` to that node. If a node is not reachable from `start_node`, its distance should be `float(\'inf\')`. # Constraints 1. The graph contains at least the `start_node` and is connected. 2. Edge weights are non-negative. 3. The number of nodes in the graph is reasonable to be computed within given time limits. # Performance Requirement * The implemented solution should have a time complexity of (O(|E| log |V|)) where (|E|) is the number of edges and (|V|) is the number of vertices. # Example ```python graph_example = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } # Calculate shortest path from node \'A\' result = dijkstra_shortest_path(graph_example, \'A\') print(result) # Expected output: {\'A\': 0, \'B\': 1, \'C\': 3, \'D\': 4} ``` # Notes * Use a priority queue (heap) to select the next node with the smallest tentative distance. * Initialize all distances as `float(\'inf\')` except the `start_node` which should have a distance of 0. * Update the distances as you explore each node\'s neighbors using the Dijkstra\'s algorithm rules.","solution":"import heapq from typing import Dict, Any def dijkstra_shortest_path(graph: Dict[Any, Dict[Any, float]], start_node: Any) -> Dict[Any, float]: Implements Dijkstra\'s Algorithm to find the shortest paths from a start node to all other nodes in a directed, weighted graph. Parameters: graph (Dict[Any, Dict[Any, float]]): A dictionary where keys are nodes and values are dictionaries of neighboring nodes and edge weights. start_node (Any): The node from which to start the shortest path calculation. Returns: Dict[Any, float]: A dictionary where keys are nodes and values are the shortest distance from the start_node to that node. # Initialize distances of all nodes to infinity distances = {node: float(\'inf\') for node in graph} # Distance to the start node is 0 distances[start_node] = 0 # Priority queue to keep track of the next node to process priority_queue = [(0, start_node)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip if we\'ve found a longer path to the current node if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph[current_node].items(): distance = current_distance + weight # Only consider this new path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Question Context You are developing a simple command-line tool to manage a collection of books. The tool should allow users to add new books, search for existing ones, and remove books from the collection. Each book has a title, author, and a unique identifier (ID). Task Write a class `BookManager` that manages the collection of books. This class should provide methods for adding, searching, and removing books. Ensure error handling is in place for scenarios such as adding a book with an existing ID or removing a book that does not exist. Class and Method Signatures ```python class BookManager: def __init__(self): pass def add_book(self, book_id: int, title: str, author: str) -> None: pass def search_book(self, book_id: int) -> dict: pass def remove_book(self, book_id: int) -> None: pass ``` Requirements 1. **Attributes**: * `books` (dict): A dictionary to store book details where the key is the book ID and the value is another dictionary containing `title` and `author`. 2. **Methods**: * `__init__`: Initializes the BookManager with an empty book collection (i.e., an empty dictionary). * `add_book`: Adds a new book to the collection. * Input: `book_id` (int), `title` (str), `author` (str) * Output: None * Raises: `ValueError` if a book with the same `book_id` already exists. * `search_book`: Searches for a book by its `book_id`. * Input: `book_id` (int) * Output: A dictionary with the `title` and `author` of the book, or an empty dictionary if the book is not found. * `remove_book`: Removes a book from the collection by its `book_id`. * Input: `book_id` (int) * Output: None * Raises: `KeyError` if the book with the given `book_id` does not exist. Example: ```python if __name__ == \\"__main__\\": manager = BookManager() # Add some books manager.add_book(1, \\"1984\\", \\"George Orwell\\") manager.add_book(2, \\"To Kill a Mockingbird\\", \\"Harper Lee\\") # Search for a book print(manager.search_book(1)) # Output: {\'title\': \'1984\', \'author\': \'George Orwell\'} # Remove a book manager.remove_book(2) # Try to search for the removed book print(manager.search_book(2)) # Output: {} ``` Notes: * Ensure that the `BookManager` class is efficient and handles the stated requirements gracefully. * Write clean and maintainable code with appropriate comments and error messages.","solution":"class BookManager: def __init__(self): self.books = {} def add_book(self, book_id: int, title: str, author: str) -> None: Adds a new book to the collection. Raises ValueError if book_id already exists. if book_id in self.books: raise ValueError(\\"A book with this ID already exists.\\") self.books[book_id] = {\\"title\\": title, \\"author\\": author} def search_book(self, book_id: int) -> dict: Searches for a book by its ID. Returns a dictionary with title and author if found, else an empty dictionary. return self.books.get(book_id, {}) def remove_book(self, book_id: int) -> None: Removes a book from the collection by its ID. Raises KeyError if book_id does not exist. if book_id not in self.books: raise KeyError(\\"No book found with the given ID.\\") del self.books[book_id]"},{"question":"# Question You are tasked with implementing a function that flattens a deeply nested list of integers. The function should traverse the nested lists, extract all integers, and return them as a single flat list in the order they appear. # Function Signature ```python def flatten_list(nested_list: list) -> list: ``` # Input * `nested_list: list` - A list that may contain integers or other lists, which can be further nested arbitrarily deep. # Output * `list` - A flat list containing all integers extracted from the nested lists, in the order they appear. # Constraints * The nested list may contain arbitrarily deep levels of nesting. * The nested list is guaranteed to contain only integers and other lists. * The length of the nested list and its sublists combined will not exceed (10^4) elements. # Examples ```python assert flatten_list([1, [2, [3, 4], 5], 6]) == [1, 2, 3, 4, 5, 6] assert flatten_list([1, [2, [3]], [[4, 5], 6], 7]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_list([[[1, 2], 3], 4, [5, [6, [7]]]]) == [1, 2, 3, 4, 5, 6, 7] assert flatten_list([[1, [2, [3]]], [4, [5, [6]]], [7, [8, [9]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9] ``` # Implementation Guide 1. **Initialize a Results List**: Create an empty list to store the flattened integers. 2. **Recursive Traversal Function**: - Define a helper function that takes a single element (which could be an integer or a list). - If the element is an integer, append it to the results list. - If the element is a list, recursively call the helper function on each item within the list. 3. **Iterate Through Nested List**: Start by passing the top-level nested list to the helper function. 4. **Return the Flat List**: After traversal, return the results list containing all integers. # Note - You should manage arbitrarily deep nesting effectively, ensuring that no integers are missed or duplicated in the resulting flat list.","solution":"def flatten_list(nested_list): Flattens a deeply nested list of integers. Parameters: nested_list (list): A list that contains integers or other lists, which can be nested further. Returns: list: A flat list containing all integers from nested_list, in the order they appear. def flatten_helper(sub_list, result): for item in sub_list: if isinstance(item, list): flatten_helper(item, result) else: result.append(item) result = [] flatten_helper(nested_list, result) return result"},{"question":"# Noise Reduction Using Moving Average Filter You are tasked with implementing a method to reduce noise in a 1-dimensional numerical signal using a simple moving average filter within the `SignalProcessing` class. Specifically, implement the `moving_average_filter` method. **Task**: Add the following method to the `SignalProcessing` class: ```python def moving_average_filter(self, window_size): Reduces noise in the signal using a simple moving average filter. :param window_size: Size of the moving window (must be an odd positive integer) :return: Smoothed signal as a numpy array return np.convolve(self.signal, np.ones(window_size)/window_size, mode=\'valid\') ``` **Objective**: You need to define this method such that it operates on the class\'s internal attribute `signal`. Ensure your implementation correctly applies the moving average filter using the specified window size. **Input/Output**: * **Input**: The method will use an existing attribute (`self.signal`) which is a numpy array containing the original signal values, and `window_size`, an odd positive integer. * **Output**: A numpy array representing the smoothed signal with reduced noise. **Constraints**: * `signal` is a 1-dimensional numpy array. * `window_size` is an odd positive integer that dictates the size of the moving window for the filter. **Performance**: Ensure your implementation handles long signals efficiently. **Scenario**: You are processing a noisy signal obtained from an IoT sensor to smooth out abrupt variations and retain the general trend. This is particularly useful in preparing the data for further analysis or visualization. Example: ```python # Given input signal signal = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9]) # Expected Output # Moving average filter with window_size=3 np.array([2., 3., 4., 5., 6., 7., 8.]) ``` Add your method definition to the `SignalProcessing` class and verify its correctness based on the provided example.","solution":"import numpy as np class SignalProcessing: def __init__(self, signal): Initializes the SignalProcessing object with the given signal. :param signal: A 1-dimensional numpy array representing the signal. self.signal = signal def moving_average_filter(self, window_size): Reduces noise in the signal using a simple moving average filter. :param window_size: Size of the moving window (must be an odd positive integer) :return: Smoothed signal as a numpy array if window_size % 2 == 0 or window_size < 1: raise ValueError(\\"window_size must be an odd positive integer\\") return np.convolve(self.signal, np.ones(window_size)/window_size, mode=\'valid\')"},{"question":"# Scenario You are developing a task management system that keeps track of task dependencies. Each task must be completed before any tasks that depend on it can be started. Tasks are represented as nodes in a directed acyclic graph (DAG), where an edge from node A to node B signifies that task A must be completed before task B can start. # Task Implement a function called `task_ordering` that takes a list of tasks and their dependencies, and returns a feasible order of task completion that satisfies all given dependencies. Function Signature ```python def task_ordering(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: ``` Parameters - `tasks`: A list of strings representing the unique task identifiers. - `dependencies`: A list of tuples, where each tuple (a, b) indicates that task `a` must be completed before task `b`. Constraints - Task identifiers are non-empty strings. - There are no cyclic dependencies in the input. - The graph can contain up to `10^4` tasks and `10^5` dependencies. Implementation Notes - If there are multiple valid task orders, any one of them is acceptable. - You can assume that a valid order always exists. Example ```python tasks = [\\"task1\\", \\"task2\\", \\"task3\\", \\"task4\\"] dependencies = [ (\\"task1\\", \\"task2\\"), (\\"task2\\", \\"task3\\"), (\\"task1\\", \\"task3\\"), (\\"task3\\", \\"task4\\"), ] result = task_ordering(tasks, dependencies) print(result) # Possible output: [\'task1\', \'task2\', \'task3\', \'task4\'] ``` Implement the function `task_ordering` with the required functionality ensuring the optimal ordering of tasks based on the dependencies provided. Your solution should handle edge cases efficiently, and maintain readability.","solution":"from typing import List, Tuple from collections import defaultdict, deque def task_ordering(tasks: List[str], dependencies: List[Tuple[str, str]]) -> List[str]: # Initialize graph and in-degree count graph = defaultdict(list) in_degree = {task: 0 for task in tasks} # Build the graph and in-degree dictionary for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Initialize the queue with tasks having zero in-degree queue = deque([task for task in tasks if in_degree[task] == 0]) ordered_tasks = [] while queue: task = queue.popleft() ordered_tasks.append(task) for neighbor in graph[task]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # Return the ordered tasks return ordered_tasks"},{"question":"# Scenario A company wants to maintain a list of their top k highest-paid employees and frequently update this list when there is a change in employee salaries. Each employee has a unique identifier and a salary associated with them. # Task Write a class `TopKEmployees` that manages the top k highest-paid employees. The class should support adding or updating an employee\'s salary and retrieving the current list of top k highest-paid employees sorted by their salaries in descending order. Class Definition ```python class TopKEmployees: def __init__(self, k: int): Initializes the TopKEmployees object with a given k. Args: k (int): The number of top-paid employees to maintain. pass def add_or_update_employee(self, emp_id: int, salary: int) -> None: Adds a new employee or updates the salary of an existing employee. Args: emp_id (int): The unique identifier of the employee. salary (int): The salary of the employee. pass def get_top_k_employees(self) -> List[Tuple[int, int]]: Returns the current list of top k highest-paid employees sorted by salary in descending order. Returns: List[Tuple[int, int]]: A list of tuples where each tuple contains two elements - (emp_id, salary) representing employee id and salary, respectively. pass ``` # Input - `k`: An integer representing the number of top-paid employees to maintain. - `emp_id`: An integer representing the unique identifier of an employee. - `salary`: An integer representing the salary of an employee. # Output - `add_or_update_employee()`: No output. - `get_top_k_employees()`: Returns a list of tuples, where each tuple contains the employee id and salary of the top k highest-paid employees sorted by salary in descending order. # Constraints - k will be a positive integer less than or equal to 1000. - `emp_id` will be a positive integer less than or equal to 100000. - `salary` will be a non-negative integer less than or equal to 1000000. - The total number of distinct employee updates will not exceed 10000. # Example ```python # Instantiate the TopKEmployees with k = 3 top_k = TopKEmployees(3) # Add employees with their salaries top_k.add_or_update_employee(1, 50000) top_k.add_or_update_employee(2, 100000) top_k.add_or_update_employee(3, 75000) top_k.add_or_update_employee(4, 200000) # Retrieve the current top 3 highest-paid employees assert top_k.get_top_k_employees() == [(4, 200000), (2, 100000), (3, 75000)] # Update the salary of an existing employee top_k.add_or_update_employee(2, 300000) # Retrieve the updated top 3 highest-paid employees assert top_k.get_top_k_employees() == [(2, 300000), (4, 200000), (3, 75000)] ``` # Implementation Details - Use a suitable data structure (e.g., heap, sorted list, or dictionary) to efficiently manage and update the top k highest-paid employees. - Ensure that the operations are optimized for both time and space complexity. - Assume valid input within the provided constraints.","solution":"from typing import List, Tuple import heapq class TopKEmployees: def __init__(self, k: int): self.k = k self.salary_map = {} # Dictionary to store employee id and salary self.min_heap = [] # Min-heap to keep track of the top k salaries def add_or_update_employee(self, emp_id: int, salary: int) -> None: # If the employee exists and needs to be updated if emp_id in self.salary_map: self.salary_map[emp_id] = salary else: # If they are new to the system, add them. self.salary_map[emp_id] = salary # Reset the heap to account for changes and keep only top k highest paid employees self.min_heap = [(salary, emp_id) for emp_id, salary in self.salary_map.items()] heapq.heapify(self.min_heap) while len(self.min_heap) > self.k: heapq.heappop(self.min_heap) def get_top_k_employees(self) -> List[Tuple[int, int]]: # Get the sorted list of the top k employees from the heap in descending order by salary sorted_employees = sorted(self.min_heap, key=lambda x: (-x[0], x[1])) return [(emp_id, salary) for salary, emp_id in sorted_employees]"},{"question":"Scenario You are working on a text processing application, and one of the tasks is to normalize a dataset of sentences for further analysis. This involves removing punctuation, converting all text to lowercase, and removing stopwords like \\"and\\", \\"the\\", \\"in\\", etc. The goal is to process the sentences so that they can be used for various natural language processing (NLP) tasks such as text classification or sentiment analysis. # Question Write a function `normalize_sentences` that accepts a list of sentences (strings) and a list of stopwords. The function should perform the following tasks: 1. Convert all alphabetic characters in the sentences to lowercase. 2. Remove all punctuation from the sentences. 3. Remove all stopwords from the sentences. # Input * A list of sentences (e.g., `[\\"The quick brown fox jumps over the lazy dog.\\", \\"And then they rested.\\"]`) * A list of stopwords (e.g., `[\\"the\\", \\"and\\", \\"in\\", \\"over\\", \\"then\\"]`) # Output * A list of strings where each string is a normalized sentence. # Constraints 1. The list of sentences will contain up to (10^4) sentences. 2. Each sentence will contain up to (10^3) characters. 3. All input strings will only contain printable ASCII characters. # Example ```python normalize_sentences([\\"The quick brown fox jumps over the lazy dog.\\", \\"And then they rested.\\"], [\\"the\\", \\"and\\", \\"in\\", \\"over\\", \\"then\\"]) # Output: [\\"quick brown fox jumps lazy dog\\", \\"they rested\\"] normalize_sentences([\\"Hello, World! This is an example.\\"], [\\"this\\", \\"is\\", \\"an\\"]) # Output: [\\"hello world example\\"] normalize_sentences([\\"Normalization is important.\\", \\"It simplifies analysis.\\"], [\\"is\\"]) # Output: [\\"normalization important\\", \\"it simplifies analysis\\"] ``` # Notes * The function should not raise errors for empty input lists, but return an empty list instead. * Consider using string methods and regular expressions for efficient processing. # Function Signature ```python def normalize_sentences(sentences: list, stopwords: list) -> list: pass ```","solution":"import re def normalize_sentences(sentences: list, stopwords: list) -> list: Normalize a list of sentences by converting to lowercase, removing punctuation, and removing stopwords. normalized_sentences = [] stopwords_set = set(stopwords) for sentence in sentences: # Convert to lowercase sentence = sentence.lower() # Remove punctuation using regex sentence = re.sub(r\'[^ws]\', \'\', sentence) # Remove stopwords words = sentence.split() filtered_words = [word for word in words if word not in stopwords_set] normalized_sentence = \' \'.join(filtered_words) normalized_sentences.append(normalized_sentence) return normalized_sentences # Example use print(normalize_sentences([\\"The quick brown fox jumps over the lazy dog.\\", \\"And then they rested.\\"], [\\"the\\", \\"and\\", \\"in\\", \\"over\\", \\"then\\"])) # Output: [\\"quick brown fox jumps lazy dog\\", \\"they rested\\"]"},{"question":"# Merge K Sorted Lists - Optimized Solution Given `k` sorted linked lists, merge them into a single sorted linked list. Your Task 1. **Optimize Merging Algorithm**: Enhance the given approach to merge multiple sorted linked lists. 2. **Function Implementation**: Implement the function using an efficient algorithm. Requirements - Implement the function `merge_k_sorted_lists(lists: List[ListNode]) -> ListNode` that merges `k` sorted linked lists into a single sorted linked list with improved performance. - Utilize appropriate data structures to achieve optimal merging time complexity. Input - A list of `k` sorted linked lists. Each `ListNode` is defined as follows: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next ``` Output - A single `ListNode` representing the merged sorted linked lists. Constraints - The number of linked lists `k` will be ≤ 100. - The total number of nodes across all linked lists will be ≤ 10^5. Performance - Aim for an optimal time complexity, at least O(N log k) where N is the total number of nodes and k is the number of linked lists. Example ```python # Given the following linked lists: # 1 -> 4 -> 5 # 1 -> 3 -> 4 # 2 -> 6 >>> lists = [ListNode(1, ListNode(4, ListNode(5))), ListNode(1, ListNode(3, ListNode(4))), ListNode(2, ListNode(6))] >>> merged = merge_k_sorted_lists(lists) # The merged linked list should be: # 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> 5 -> 6 ``` Your implementation should ensure optimal performance while maintaining the correct order for all values in the merged linked list.","solution":"from typing import List, Optional import heapq class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def __lt__(self, other): # This is needed to compare the ListNode objects inside the heap return self.val < other.val def merge_k_sorted_lists(lists: List[Optional[ListNode]]) -> Optional[ListNode]: min_heap = [] for l in lists: if l: heapq.heappush(min_heap, (l.val, l)) dummy = ListNode() current = dummy while min_heap: _, node = heapq.heappop(min_heap) current.next = node current = current.next if node.next: heapq.heappush(min_heap, (node.next.val, node.next)) return dummy.next"},{"question":"# Coding Assessment Question **Scenario**: You have been asked to build a functionality that processes customer orders for an online retail store. The store receives numerous orders with various quantities and item prices that need to be processed to determine the final amount charged after applying applicable discounts. Your task is to write a function that calculates the total amount for each order. **Objective**: Develop a function `calculate_order_total` to: 1. Accept order details including items, quantities, and prices. 2. Apply a discount based on the total order amount according to the given discount rules. 3. Return the final amount after applying the discount. **Function Signature**: ```python def calculate_order_total(order: dict[str, tuple[int, float]]) -> float: Calculate the total amount for an order after applying discounts. Args: - order (dict[str, tuple[int, float]]): A dictionary where keys are item names, and values are tuples containing quantity (int) and price per unit (float). Returns: - float: The final amount after applying the discount. ``` **Discount Rules**: - No discount if the total is less than 50. - 5% discount if the total is between 50 and 100. - 10% discount if the total is between 100 and 200. - 15% discount if the total is higher than 200. **Constraints**: - **Input**: - `order`: A dictionary with item names as keys. Each key maps to a tuple where the first element is an integer (quantity) and the second element is a float (price per unit). - At least one item will be in the order. - **Output**: - A float representing the total order amount after applying the discount. Round the final amount to two decimal places. **Example**: ```python order = { \\"book\\": (2, 15.0), \\"pen\\": (5, 2.0), \\"laptop\\": (1, 250.0) } result = calculate_order_total(order) Expected Output (example): 234.00 ``` **Guidelines for Implementation**: 1. **Calculate Subtotals**: Sum the product of quantity and price per unit for each item to get the subtotal before discount. 2. **Apply Discounts**: Determine the applicable discount based on the subtotal and apply it. 3. **Edge Cases**: Handle edge cases where quantities or prices are particularly large or small (e.g., very high-item quantities or prices).","solution":"def calculate_order_total(order): Calculate the total amount for an order after applying discounts. Args: - order (dict): A dictionary where keys are item names, and values are tuples containing quantity (int) and price per unit (float). Returns: - float: The final amount after applying the discount. # Calculate the subtotal subtotal = sum(quantity * price for quantity, price in order.values()) # Apply discount based on subtotal if subtotal < 50: discount = 0 elif 50 <= subtotal < 100: discount = 0.05 elif 100 <= subtotal < 200: discount = 0.10 else: discount = 0.15 # Calculate final total after discount total = subtotal * (1 - discount) # Round the final total to 2 decimal places return round(total, 2)"},{"question":"# Average Pixel Intensity Calculator You are tasked with implementing a function to calculate the average pixel intensity of an image. The function should operate within the `ImageAnalyzer` class and compute the average intensity for each color channel separately. **Task**: Add the following method to the `ImageAnalyzer` class: ```python def average_intensity(self): Calculate the average intensity for each color channel in an image. :return: A dictionary with the average intensity of \'red\', \'green\', and \'blue\' channels. avg_red = np.mean(self.image[:, :, 0]) avg_green = np.mean(self.image[:, :, 1]) avg_blue = np.mean(self.image[:, :, 2]) return {\'red\': avg_red, \'green\': avg_green, \'blue\': avg_blue} ``` **Objective**: You need to define this method such that it operates on the class\'s internal attribute (`image`). Ensure your implementation correctly computes the averages for each color channel separately and returns the result in the specified dictionary format. **Input/Output**: * **Input**: The method will use an existing attribute (`self.image`), which is a 3D numpy array representing an RGB image. * **Output**: A dictionary containing the average intensity values for \'red\', \'green\', and \'blue\' channels. **Constraints**: * `image` is a numpy array with shape (height, width, 3) where each pixel has three values corresponding to the red, green, and blue color intensities. * The values within `image` are integers ranging from 0 to 255. **Performance**: Ensure your implementation can handle large images efficiently. **Scenario**: You are analyzing the average color intensity of an image to determine the general color balance. This can be useful in applications such as image enhancement, color correction, or for statistical analysis in image processing tasks. Example: ```python # Given input image image = np.array([[[125, 200, 75], [100, 150, 200]], [[200, 100, 150], [50, 50, 50]]], dtype=np.uint8) # Expected Output { \'red\': 118.75, \'green\': 125.0, \'blue\': 118.75 } ``` Add your method definition to the `ImageAnalyzer` class and verify its correctness based on the provided example.","solution":"import numpy as np class ImageAnalyzer: def __init__(self, image): self.image = image def average_intensity(self): Calculate the average intensity for each color channel in an image. :return: A dictionary with the average intensity of \'red\', \'green\', and \'blue\' channels. avg_red = np.mean(self.image[:, :, 0]) avg_green = np.mean(self.image[:, :, 1]) avg_blue = np.mean(self.image[:, :, 2]) return {\'red\': avg_red, \'green\': avg_green, \'blue\': avg_blue}"},{"question":"# Implement Isolated Subgraphs Detection You are given a connected undirected graph represented as a list of edges. Your task is to detect isolated subgraphs where each node in an isolated subgraph cannot reach any node outside that subgraph. # Function Signature: ```python def detect_isolated_subgraphs(edges: List[Tuple[int, int]]) -> List[List[int]]: ``` # Input: * `edges` (List[Tuple[int, int]]): A list of tuples where each tuple represents an edge between two nodes in the graph. The graph contains `n` nodes where `1 <= n <= 1000` and is not necessarily connected. Each node is represented by an integer. # Output: * Returns a list where each element is a list of integers representing the nodes in one of the isolated subgraphs. Each isolated subgraph should be sorted in an increasing order and the list of subgraphs should also be sorted by the smallest node in each subgraph. # Constraints: * Nodes are represented by positive integers. * No duplicate edges exist in the input. * An edge between x and y implies an edge between y and x. * There are no self-loops. * The graph can be disconnected. * Each subgraph should appear only once in the result. # Example: ```python >>> detect_isolated_subgraphs([(1, 2), (2, 3), (3, 1), (4, 5), (6, 7)]) [[1, 2, 3], [4, 5], [6, 7]] >>> detect_isolated_subgraphs([(10, 11), (11, 12), (12, 10), (3, 14)]) [[3, 14], [10, 11, 12]] >>> detect_isolated_subgraphs([(1, 3), (2, 4), (3, 5), (10, 11), (6, 7), (8, 9)]) [[1, 3, 5], [2, 4], [6, 7], [8, 9], [10, 11]] >>> detect_isolated_subgraphs([]) [] ``` # Note: 1. If the input is an empty list, the result should be an empty list. 2. Ensure that the function is well-optimized to handle the upper limits of the constraints.","solution":"from typing import List, Tuple, Dict def detect_isolated_subgraphs(edges: List[Tuple[int, int]]) -> List[List[int]]: def dfs(node: int, graph: Dict[int, List[int]], visited: set, component: List[int]): visited.add(node) component.append(node) for neighbor in graph[node]: if neighbor not in visited: dfs(neighbor, graph, visited, component) if not edges: return [] # Generate the graph from the edges graph = {} for u, v in edges: if u not in graph: graph[u] = [] if v not in graph: graph[v] = [] graph[u].append(v) graph[v].append(u) visited = set() isolated_subgraphs = [] # Find all the connected components (subgraphs) for node in graph: if node not in visited: component = [] dfs(node, graph, visited, component) isolated_subgraphs.append(sorted(component)) return sorted(isolated_subgraphs, key=lambda x: x[0])"},{"question":"# Problem: Sum of Nested Lists You have a function `sum_nested_lists` that takes a nested list of integers and returns the sum of all the integers present in it. The input list can be arbitrarily nested, meaning that it can contain integers, as well as other lists of potentially arbitrary depth. # Function Signature ```python def sum_nested_lists(nested_list: list) -> int: Sums all integers in a nested list. Args: nested_list (list): The nested list of integers. Returns: int: The sum of all integers in the nested list. Example: >>> sum_nested_lists([1, [2, 3], [4, [5, 6]], 7]) 28 >>> sum_nested_lists([1, [2, [3, [4, [5]]]], 6]) 21 >>> sum_nested_lists([[], [[[[[5]]]]]]) 5 ``` # Constraints * Each element of the input list is either an integer or another list. * The list can be deeply nested but will not contain cycles or references to itself. # Implementation Requirements Implement the `sum_nested_lists` function: * Traverse through each element of the list and sum up integers encountered. * Recursively handle nested lists to ensure all integer values at any depth are included in the sum. * Ensure the function works efficiently for varying levels of nested structures. # Edge Cases to Consider: * Lists that are empty or contain empty sublists. * Large nested structures with varying depths. * Ensure correct handling of input that contains only integers and nested lists. # Example Test ```python print(sum_nested_lists([1, [2, 3], [4, [5, 6]], 7])) # Output: 28 print(sum_nested_lists([1, [2, [3, [4, [5]]]], 6])) # Output: 21 print(sum_nested_lists([[], [[[[[5]]]]]])) # Output: 5 ``` **Write your implementation of the `sum_nested_lists` function below:**","solution":"def sum_nested_lists(nested_list): Sums all integers in a nested list. Args: nested_list (list): The nested list of integers. Returns: int: The sum of all integers in the nested list. total = 0 for element in nested_list: if isinstance(element, list): total += sum_nested_lists(element) else: total += element return total"},{"question":"You are assigned to write a Python function that implements a simple 2-bit binary adder. The function should take two 2-bit binary numbers (each represented as a tuple of two integers, which can be 0 or 1) and return a tuple representing the 2-bit sum and a carry-out bit. The inputs should be validated to ensure only binary digits (0 or 1) are allowed, otherwise a `ValueError` should be raised. # Function Signature ```python def binary_adder(a: Tuple[int, int], b: Tuple[int, int]) -> Tuple[int, int, int]: Implement a 2-bit binary adder. :param a: The first 2-bit binary number (each bit 0 or 1). :param b: The second 2-bit binary number (each bit 0 or 1). :return: A tuple representing the sum (2-bit binary number) and the carry-out bit. Examples: >>> binary_adder((0, 0), (0, 0)) (0, 0, 0) >>> binary_adder((0, 1), (0, 1)) (1, 0, 0) >>> binary_adder((1, 1), (1, 1)) (1, 1, 1) >>> binary_adder((1, 0), (0, 1)) (1, 1, 0) >>> binary_adder((1, 0), (1, -1)) Traceback (most recent call last): ... ValueError: Each bit in the binary numbers must be 0 or 1 ``` # Constraints 1. The elements of `a` and `b` must be tuples of two integers, and each integer must be either 0 or 1. 2. If any element of `a` or `b` is not 0 or 1, raise a `ValueError`. # Task Implement the `binary_adder` function to correctly add two 2-bit binary numbers, handling the carry and ensuring to raise appropriate errors for invalid inputs.","solution":"from typing import Tuple def binary_adder(a: Tuple[int, int], b: Tuple[int, int]) -> Tuple[int, int, int]: Implement a 2-bit binary adder. :param a: The first 2-bit binary number (each bit 0 or 1). :param b: The second 2-bit binary number (each bit 0 or 1). :return: A tuple representing the sum (2-bit binary number) and the carry-out bit. # Validate the inputs for bit in a + b: if bit not in {0, 1}: raise ValueError(\\"Each bit in the binary numbers must be 0 or 1\\") # Bitwise addition # Extract bits a1, a0 = a b1, b0 = b # First bit addition s0 = a0 ^ b0 carry0 = a0 & b0 # Second bit addition s1 = a1 ^ b1 carry1 = a1 & b1 # Consider the carry from the lower bit addition carry_low_high = s1 & carry0 sum1 = s1 ^ carry0 # Final carry out carry_out = carry1 | carry_low_high return (sum1, s0, carry_out)"},{"question":"**Parallel Matrix Multiplication** # Context: You\'ve been provided with an implementation of a basic Matrix class capable of performing standard operations like addition and multiplication. Your task is to enhance this implementation to support parallel matrix multiplication, which will significantly increase computation speed for large matrices. # Objective: Write a new class `ParallelMatrix` that extends the functionality of the provided Matrix class to: 1. Support multi-threaded matrix multiplication. 2. Ensure thread safety and manage workload distribution efficiently. 3. Allow for configurable thread usage up to a certain maximum. # Constraints: - Matrix dimensions must be compatible for multiplication. Specifically, if Matrix `A` is of dimension `m x n`, then Matrix `B` should be `n x p`. - Ensure no more than 8 threads are used concurrently. - Efficiently divide the matrix multiplication task across the available threads. - Be mindful of memory usage and avoid unnecessary data duplication. # Specifications: 1. Class Name: `ParallelMatrix` 2. Shall contain the methods: * `__init__(self, data: List[List[int]])`: Initializes a matrix with the provided 2-dimensional list. * `multiply(self, other: \'ParallelMatrix\', thread_count: int = 4) -> \'ParallelMatrix\'`: Multiplies the current matrix with another matrix using the specified number of threads and returns the resulting matrix. * `__str__(self) -> str`: Returns a string representation of the matrix for easy printing. 3. Ensure thread safety during matrix multiplication by using synchronizing mechanisms from the `threading` module. # Expected input and output formats: - **Input formats**: * `__init__(self, data: List[List[int]])`: A 2D list representing the matrix. * `multiply(self, other: \'ParallelMatrix\', thread_count: int = 4) -> \'ParallelMatrix\'`: Another matrix object and the number of threads to use for the multiplication. - **Output formats**: * `multiply(self, other: \'ParallelMatrix\', thread_count: int = 4) -> \'ParallelMatrix\'`: Returns a new `ParallelMatrix` object resulting from the multiplication. * `__str__(self)`: Returns a string representation of the matrix. # Performance Requirements: - Distribute the multiplication task evenly among the threads. - Minimize overhead from thread management. - Ensure proper thread synchronization to avoid data races and ensure accuracy of results. # Example Usage: ```python from threading import Thread # Initialize matrices matrix_a = ParallelMatrix([[1, 2, 3], [4, 5, 6]]) matrix_b = ParallelMatrix([[7, 8], [9, 10], [11, 12]]) # Multiply matrices using 4 threads result = matrix_a.multiply(matrix_b, thread_count=4) # Output the result print(result) ``` In this example, the result of multiplying `matrix_a` by `matrix_b` should produce a `ParallelMatrix` object containing the resulting matrix, which will be printed. The multiplication task is distributed across 4 threads for enhanced performance.","solution":"import threading class ParallelMatrix: def __init__(self, data): self.data = data self.rows = len(data) self.cols = len(data[0]) if self.rows > 0 else 0 def multiply(self, other, thread_count=4): if self.cols != other.rows: raise ValueError(\\"Matrix dimensions are incompatible for multiplication.\\") if thread_count < 1: raise ValueError(\\"Thread count must be at least 1.\\") max_threads = min(thread_count, 8) result = [[0 for _ in range(other.cols)] for _ in range(self.rows)] thread_workload = (self.rows + max_threads - 1) // max_threads threads = [] for i in range(max_threads): start_row = i * thread_workload end_row = min((i + 1) * thread_workload, self.rows) if start_row >= self.rows: break thread = threading.Thread(target=self._multiply_partial, args=(other, result, start_row, end_row)) threads.append(thread) thread.start() for thread in threads: thread.join() return ParallelMatrix(result) def _multiply_partial(self, other, result, start_row, end_row): for i in range(start_row, end_row): for j in range(other.cols): result[i][j] = sum(self.data[i][k] * other.data[k][j] for k in range(self.cols)) def __str__(self): return \\"n\\".join([\\" \\".join(map(str, row)) for row in self.data])"},{"question":"# Problem Statement You are tasked with implementing a function that simulates a simple in-memory key-value store with basic commands for setting, getting, and deleting values. The key-value store should support string keys and string values. Implement the class `KeyValueStore` in Python which supports the following operations: - `set(key: str, value: str) -> None`: Sets the given key to the provided value. If the key already exists, update its value. - `get(key: str) -> Optional[str]`: Retrieves the value associated with the given key. If the key does not exist, return `None`. - `delete(key: str) -> bool`: Deletes the key-value pair associated with the given key. Returns `True` if the key was found and deleted, `False` otherwise. # Class Definition ```python class KeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value: str) -> None: self.store[key] = value def get(self, key: str) -> Optional[str]: return self.store.get(key) def delete(self, key: str) -> bool: if key in self.store: del self.store[key] return True return False ``` # Input - For `set`, `key` and `value` are strings. - For `get`, `key` is a string. - For `delete`, `key` is a string. # Output - For `set`, return `None`. - For `get`, return the value associated with the key as a string, or `None` if the key does not exist. - For `delete`, return `True` if the key was found and deleted, `False` otherwise. # Examples ```python # Initialize the key-value store store = KeyValueStore() # Set some values store.set(\\"name\\", \\"Alice\\") store.set(\\"age\\", \\"25\\") # Retrieve values >>> store.get(\\"name\\") \'Alice\' >>> store.get(\\"age\\") \'25\' >>> store.get(\\"nonexistent\\") None # Delete a key >>> store.delete(\\"name\\") True >>> store.get(\\"name\\") None >>> store.delete(\\"name\\") False # Setting and updating a value store.set(\\"country\\", \\"Canada\\") >>> store.get(\\"country\\") \'Canada\' store.set(\\"country\\", \\"USA\\") >>> store.get(\\"country\\") \'USA\' ``` # Notes 1. The keys and values are always strings. 2. The implementation should be efficient with respect to insertion, retrieval, and deletion operations. 3. Attempt to handle edge cases where operations are performed on keys that do not exist appropriately.","solution":"class KeyValueStore: def __init__(self): self.store = {} def set(self, key: str, value: str) -> None: Sets the given key to the provided value. If the key already exists, its value is updated. self.store[key] = value def get(self, key: str): Retrieves the value associated with the given key. If the key does not exist, returns None. return self.store.get(key) def delete(self, key: str) -> bool: Deletes the key-value pair associated with the given key. Returns True if the key was found and deleted, False otherwise. if key in self.store: del self.store[key] return True return False"},{"question":"# Context You are tasked with developing a scheduler for a sports tournament where multiple matches need to be scheduled based on certain constraints. # Description Implement a function that schedules matches for a given set of teams ensuring that no team plays more than one match at the same time. The scheduler is flexible to maximize parallel matches but adheres strictly to the constraint mentioned. # Function Signature ```python def schedule_matches(teams: List[str]) -> List[List[Tuple[str, str]]]: pass ``` # Input * `teams` (List[str]): A list of strings representing the names of the participating teams. The number of teams will always be even and between 2 and 20 (inclusive). # Output * Return a list of lists where each sublist corresponds to one time slot, containing tuples of two team names representing the matches. # Constraints * Each team can only play one match at a time. * Each team must play exactly once in the tournament. * There must be no duplicate matches (e.g., team A vs team B should only appear once). # Example ```python teams = [\\"Team A\\", \\"Team B\\", \\"Team C\\", \\"Team D\\", \\"Team E\\", \\"Team F\\"] result = schedule_matches(teams) # `result` might be something like [[\'Team A\', \'Team B\'], [\'Team C\', \'Team D\'], [\'Team E\', \'Team F\']] ``` # Notes * To maximize utilization of available slots, always aim to schedule as many matches in parallel as the constraints allow. * If 6 teams are passed, the function should ensure that all are scheduled within the minimal number of time slots needed without any two teams playing at the same time. This question is designed to test the candidate\'s ability to handle scheduling problems, ensuring they grasp the concepts of pairs and list manipulation in Python, while respecting constraints such as ensuring no team overlaps and maximizing parallel scheduling where possible.","solution":"from typing import List, Tuple def schedule_matches(teams: List[str]) -> List[List[Tuple[str, str]]]: Schedules matches for the given teams. :param teams: List of team names. :return: List of match schedules. num_teams = len(teams) match_schedule = [] for i in range(0, num_teams, 2): match_schedule.append((teams[i], teams[i + 1])) return [match_schedule]"},{"question":"**String Reorganization** You are required to write a function that reorganizes a given string such that no two adjacent characters are the same. If it is not possible to reorganize the string in this way, the function should return an empty string. # Function Signature ```python def reorganize_string(s: str) -> str: pass ``` # Input - `s`: A string consisting of lowercase English letters. # Output - A string reorganized so that no two adjacent characters are the same, or an empty string if it is impossible to achieve this. # Constraints - `s` will only contain lowercase English letters. - The length of `s` will be in the range [1, 1000]. # Requirements - Optimize the function for performance to handle larger strings efficiently. - Ensure the output string maintains the original set of characters, just reorganized. - Handle edge cases, such as strings with only one unique character, gracefully. # Example Usage ```python print(reorganize_string(\\"aab\\")) # Output could be \\"aba\\" print(reorganize_string(\\"aaab\\")) # Output should be \\"\\" ``` # Notes - Consider using a heap or priority queue to organize the characters by frequency and efficiently arrange them to avoid adjacent duplicates. - Pay attention to edge cases where the frequency of any character is greater than half the length of the string plus one, which will make reorganization impossible. - Provide comments explaining the logic behind the implemented solution and any optimizations performed. # Explanation The function `reorganize_string` should ensure that each character in the returned string appears in a position where it is not adjacent to the same character. Use an algorithm that takes into account the frequency of each character and places the most frequent characters in a strategic manner to avoid conflicts. If any character appears too frequently to rearrange without duplicates, return an empty string.","solution":"import heapq from collections import Counter def reorganize_string(s: str) -> str: Reorganizes the string so that no two adjacent characters are the same. Returns an empty string if it\'s not possible to organize the string in such a way. # Count the frequency of each character freq_dict = Counter(s) # Max heap to store characters by their frequencies max_heap = [(-freq, char) for char, freq in freq_dict.items()] heapq.heapify(max_heap) # Previous character and frequency prev_freq, prev_char = 0, \'\' result = [] while max_heap: # Get the most frequent character curr_freq, curr_char = heapq.heappop(max_heap) # Append current char to the result result.append(curr_char) # If there was a previous character with remaining frequency, push it back to the max_heap if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) # Decrease the frequency and set this as the previous character prev_freq, prev_char = curr_freq + 1, curr_char result_str = \'\'.join(result) # If reorganized string\'s length is not equal to the input string\'s length, return \\"\\" if len(result_str) != len(s): return \\"\\" return result_str"},{"question":"# Number Frequency Counter **Problem Statement**: You are required to implement a function that reads a list of integers and returns a dictionary with the frequency count of each unique number. **Requirements**: 1. Implement a function `number_frequency(int_list)` with the following: - The function takes a single parameter, `int_list`, which is a list of integers. - The function returns a dictionary where the keys are unique integers from the list, and the values are the number of times each integer appears in the list. **Input Format**: - A list of integers, where each integer could be positive, negative, or zero. **Output Format**: - A dictionary with keys as unique integers from the input list and values as their frequency count. **Constraints**: - The length of the list will be between 1 and 1000 inclusive. - Each integer in the list will be between -1000 and 1000 inclusive. **Example**: ```python >>> number_frequency([1, 2, 2, 3, 4, 4, 4]) {1: 1, 2: 2, 3: 1, 4: 3} >>> number_frequency([5, -1, -1, 2, 2, 0]) {5: 1, -1: 2, 2: 2, 0: 1} ``` **Notes**: - The dictionary should be created using the most efficient method possible for counting elements. - Consider using Python\'s `collections.Counter` for optimizing the process. - Test the function with multiple lists to ensure accuracy and efficiency.","solution":"from collections import Counter def number_frequency(int_list): Returns a dictionary with the frequency count of each unique number in the list. return dict(Counter(int_list)) # Example usage: # print(number_frequency([1, 2, 2, 3, 4, 4, 4])) # Output: {1: 1, 2: 2, 3: 1, 4: 3}"},{"question":"# Question Objective Write a function `most_frequent_char` to identify and return the most frequently occurring character in a given string. If there are multiple characters with the same highest frequency, return the one which appears first in the string. Algorithm Explanation The algorithm should: 1. Traverse the string and count the frequency of each character. 2. Identify the character with the highest frequency. 3. In case of a tie, select the character that appears first in the string. Input and Output * **Input**: A string `text`. * **Output**: A single character that is the most frequently occurring in the string. Constraints * The input string will only contain lowercase alphabetical characters `a-z`. * The input string will have a length between 1 and 1000 characters. Scenario This function can be useful for text analysis, where identifying frequently used characters can help in various encoding or compression algorithms. Example ```python >>> text = \\"hello\\" >>> most_frequent_char(text) \'l\' # \'l\' appears twice, more frequently than any other character. >>> text = \\"test\\" >>> most_frequent_char(text) \'t\' # \'t\' and \'e\' both appear twice, but \'t\' appears first. >>> text = \\"aabbcc\\" >>> most_frequent_char(text) \'a\' # \'a\', \'b\', and \'c\' all appear twice, but \'a\' appears first. >>> text = \\"xyz\\" >>> most_frequent_char(text) \'x\' # \'x\', \'y\', and \'z\' each appear once, but \'x\' appears first. >>> text = \\"single\\" >>> most_frequent_char(text) \'s\' # All characters appear once, but \'s\' appears first. ``` Develop the `most_frequent_char` function to correctly determine the most frequently occurring character in the given string.","solution":"def most_frequent_char(text): from collections import Counter frequency = Counter(text) # Find the character with the highest frequency max_count = max(frequency.values()) for char in text: if frequency[char] == max_count: return char"},{"question":"# Problem Statement A Fibonacci sequence is a series of numbers in which each number (Fibonacci number) is the sum of the two preceding ones, usually starting with 0 and 1. For example, the sequence goes as follows: 0, 1, 1, 2, 3, 5, 8, 13, ... Write a function `nth_fibonacci` that takes an integer `n` as input and returns the `n`-th Fibonacci number. The function should handle edge cases, such as when `n` is zero or negative gracefully by returning `None` in such cases. If `n` is not an integer, raise a `TypeError` with an appropriate message. Input Format - An integer `n` which represents the position in the Fibonacci sequence. Output Format - An integer representing the `n`-th Fibonacci number. Constraints - The function should be efficient and handle up to large values of `n` within practical limits. Example ```python assert nth_fibonacci(1) == 0 assert nth_fibonacci(2) == 1 assert nth_fibonacci(6) == 5 assert nth_fibonacci(-1) == None # Edge case for negative input assert nth_fibonacci(8) == 13 ```","solution":"def nth_fibonacci(n): Returns the n-th Fibonacci number. If n is zero or negative, returns None. If n is not an integer, raises a TypeError. if not isinstance(n, int): raise TypeError(\\"Input n must be an integer\\") if n <= 0: return None if n == 1: return 0 elif n == 2: return 1 a, b = 0, 1 for _ in range(2, n): a, b = b, a + b return b"},{"question":"You are given a list of points in a 2-dimensional coordinate plane where each point is represented as a tuple `(x, y)`. Implement a function `find_convex_hull` to compute the convex hull of the set of points using Andrew\'s monotone chain algorithm. # Constraints 1. There must be at least three points in the input list. 2. Points may not be distinct; duplicate points should be treated as a single point. # Function Signature ```python def find_convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: ... ``` # Input Format - `points`: A list of tuples where each tuple contains two integers representing the x and y coordinates of a point. The list may contain duplicates. # Output Format - A list of tuples representing the vertices of the convex hull in counter-clockwise order starting from the vertex with the smallest x-coordinate. # Example ```python points = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0), (1, 1), (3, 3)] output = find_convex_hull(points) print(output) # Expected: # [(0, 0), (2, 0), (3, 3), (0, 2)] ``` # Additional Requirements: 1. Raise a `ValueError` if fewer than three unique points are provided. 2. Ensure the output vertices are ordered in a counter-clockwise direction. # Explanation: The convex hull is the smallest convex boundary that can enclose all the points from the input list. Andrew\'s monotone chain algorithm is one of the efficient ways to find the convex hull in O(n log n) time complexity by sorting the points and then constructing the upper and lower hulls separately.","solution":"from typing import List, Tuple def find_convex_hull(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Computes the convex hull of a set of 2D points using Andrew\'s monotone chain algorithm. # Remove duplicates points = sorted(set(points)) # There must be at least 3 unique points if len(points) < 3: raise ValueError(\\"At least three unique points are required to form a convex hull\\") # Helper function to determine orientation def cross_product(o, a, b): return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]) # Building the lower hull lower = [] for p in points: while len(lower) >= 2 and cross_product(lower[-2], lower[-1], p) <= 0: lower.pop() lower.append(p) # Building the upper hull upper = [] for p in reversed(points): while len(upper) >= 2 and cross_product(upper[-2], upper[-1], p) <= 0: upper.pop() upper.append(p) # Concatenate lower and upper hull to make full hull, # excluding the last point of each half because it\'s repeated at the beginning of the other half return lower[:-1] + upper[:-1]"},{"question":"# Scenario You are developing a new feature for an e-commerce website to help users find similar products based on their browsing history. You need to implement a recommendation engine that uses the cosine similarity measure to find products similar to the ones the user has viewed. # Task Write a Python class `RecommendationEngine` that generates product recommendations based on the cosine similarity between product feature vectors. Your class should be able to take a user\'s browsing history as input and return a set of recommended products. # Class Structure ```python class RecommendationEngine: def __init__(self, product_features: np.ndarray[float]) -> None: Initialize the RecommendationEngine with product feature vectors. pass def recommend(self, viewed_products: list[int], num_recommendations: int = 5) -> list[int]: Recommend a set of products based on the viewed products. pass ``` # Constraints and Requirements * Use cosine similarity to measure the similarity between product feature vectors. * Expected input format: * `product_features` is a 2D numpy array of float values where each row represents the features of a product. * `viewed_products` is a list of integers representing the indices of the products the user has viewed. * `num_recommendations` is an integer representing the number of products to recommend. * Expected output: * A list of integers representing the indices of the recommended products. * Recommendations should be sorted by similarity in descending order. # Example ```python # Example usage product_features = np.array([ [0.1, 0.3, 0.5], [0.2, 0.1, 0.8], [0.7, 0.8, 0.6], [0.9, 0.2, 0.3], [0.4, 0.5, 0.7] ]) engine = RecommendationEngine(product_features) viewed = [0, 2] print(engine.recommend(viewed, num_recommendations=3)) # Expected Output: [4, 3, 1] ``` # Important Note Ensure that there are no duplicates in the recommendation output and that the recommended products are not part of the initial `viewed_products` list. Consider edge cases such as all products being equally similar or the number of products being fewer than the requested number of recommendations.","solution":"import numpy as np from sklearn.metrics.pairwise import cosine_similarity class RecommendationEngine: def __init__(self, product_features: np.ndarray) -> None: Initialize the RecommendationEngine with product feature vectors. self.product_features = product_features self.similarity_matrix = cosine_similarity(product_features) def recommend(self, viewed_products: list[int], num_recommendations: int = 5) -> list[int]: Recommend a set of products based on the viewed products. viewed_products_set = set(viewed_products) similarity_scores = np.mean(self.similarity_matrix[viewed_products], axis=0) recommended_indices = np.argsort(similarity_scores)[::-1] recommendations = [] for index in recommended_indices: if index not in viewed_products_set: recommendations.append(index) if len(recommendations) == num_recommendations: break return recommendations"},{"question":"# **Question: Transpose and Find Maximum in Each Row** You are given a 2D array (a list of lists). Your task is to create two functionalities: 1. **Transpose the 2D array**: Write a function `transpose_2d_array(matrix)` that transposes the input 2D array. 2. **Find row-wise maximums**: Write a function `find_row_maximums(matrix)` that returns a list containing the maximum element in each row of the 2D array. Constraints 1. The input 2D array will be non-empty, containing integers. 2. All rows in the 2D array will have the same number of columns. Input 1. For the transpose function: - `matrix`: A 2D array of integers. 2. For the find maximums function: - `matrix`: A 2D array of integers. Output 1. For the transpose function: - Returns the transposed 2D array. 2. For the find maximums function: - Returns a list of integers, each representing the maximum value from the corresponding row of the 2D array. # Example 1. **Using the transpose function:** ```python matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(transpose_2d_array(matrix)) # Output: [[1, 4, 7], [2, 5, 8], [3, 6, 9]] ``` 2. **Using the find maximums function:** ```python matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] print(find_row_maximums(matrix)) # Output: [3, 6, 9] matrix = [[5, 2, 7], [1, 0, 4], [3, 9, 8]] print(find_row_maximums(matrix)) # Output: [7, 4, 9] ``` # Requirements * Implement the `transpose_2d_array` function. * Implement the `find_row_maximums` function. * Ensure the functions handle edge cases properly. * Aim for efficient time and space complexity.","solution":"def transpose_2d_array(matrix): Returns the transpose of the input 2D array \'matrix\'. The transpose of a matrix is obtained by swapping rows with columns. Args: matrix (list of list of int): The 2D array to be transposed. Returns: list of list of int: The transposed 2D array. return [list(row) for row in zip(*matrix)] def find_row_maximums(matrix): Returns a list containing the maximum element in each row of the input 2D array \'matrix\'. Args: matrix (list of list of int): The 2D array whose row wise maximums need to be found. Returns: list of int: A list containing maximum values from each row. return [max(row) for row in matrix]"},{"question":"# Matrix Diagonal Sum **Context**: Working with 2D arrays (matrices) is a common task in programming, especially in fields like data science, graphics, and simulations. Efficient operations on matrices are essential for performance-critical applications. **Task**: Implement a function `diagonal_sum(matrix: List[List[int]]) -> int` that calculates the sum of the matrix\'s two diagonals. **Details**: 1. The matrix is a square (i.e., the number of rows is equal to the number of columns). 2. The function should sum both primary and secondary diagonal elements. 3. If an element is shared by both diagonals, it should be added only once. **Input and Output**: - **Input**: A 2D list of integers `matrix` where `len(matrix) == len(matrix[0])`. - **Output**: An integer representing the sum of the two diagonals. **Constraints**: - `1 <= len(matrix) <= 100` - `-10^5 <= matrix[i][j] <= 10^5` **Performance Requirements**: The solution should run in O(n) time, where n is the number of rows or columns in the matrix. **Examples**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert diagonal_sum(matrix) == 25 # 1+5+9 (primary diagonal) + 3+5+7 (secondary diagonal, 5 is counted only once) matrix = [ [1, 2], [4, 5] ] assert diagonal_sum(matrix) == 12 # 1+5 (primary diagonal) + 2+4 (secondary diagonal) matrix = [ [1] ] assert diagonal_sum(matrix) == 1 # Only one element which is on both diagonals ``` **Note**: Implement the following function in a single file named `matrix_diagonal_sum.py`. ```python from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Primary diagonal if i != n - i - 1: total_sum += matrix[i][n - i - 1] # Secondary diagonal return total_sum ``` Make sure to write test cases to validate your function.","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: n = len(matrix) total_sum = 0 for i in range(n): total_sum += matrix[i][i] # Primary diagonal if i != n - i - 1: total_sum += matrix[i][n - i - 1] # Secondary diagonal return total_sum"},{"question":"Context You are implementing a feature for a 2D game where you need to manipulate the position of various game entities on the screen. One common operation is translating the position of an entity, which involves moving it by a certain offset in both the x and y directions. This can be used for moving characters, objects, and even UI elements dynamically during gameplay. Task Implement the `translate` function, which applies a translation transformation to a point in 2D space. # Specification: 1. **Function Name**: `translate` 2. **Parameters**: * `x` (float): The initial x-coordinate of the point. * `y` (float): The initial y-coordinate of the point. * `dx` (float): The offset to move the point in the x direction. * `dy` (float): The offset to move the point in the y direction. 3. **Returns**: A tuple (x\', y\') representing the new coordinates of the point after the translation. 4. **Constraints**: * The coordinates and the offsets can be any real numbers, including negative values and zero. 5. **Input/Output**: * Example: ```python translate(2, 3, 4, -1) ``` Should return: ```python (6, 2) ``` # Performance Requirements: The function should perform the translation in constant time O(1), directly calculating the new coordinates from the input values without any loops or recursion. # Edge Cases: Consider cases where offsets are zero, very large or very small, and negative values. Ensure the function handles floating-point precision appropriately. # Example Usage: ```python def translate(x: float, y: float, dx: float, dy: float) -> tuple[float, float]: >>> translate(2, 3, 4, -1) (6, 2) >>> translate(0, 0, 0, 0) (0, 0) >>> translate(-1, -1, 2, 2) (1, 1) >>> translate(1.5, -2.5, -3, 4.5) (-1.5, 2.0) return (x + dx, y + dy) # Write your code here and test thoroughly. ```","solution":"def translate(x, y, dx, dy): Applies a translation transformation to a point in 2D space. Parameters: x (float): The initial x-coordinate of the point. y (float): The initial y-coordinate of the point. dx (float): The offset to move the point in the x direction. dy (float): The offset to move the point in the y direction. Returns: (float, float): The new coordinates of the point after the translation. return (x + dx, y + dy)"},{"question":"**Scenario**: You are managing an online store where customers can place orders for various items. Each item has a certain stock availability and price. Customers submit their orders containing the item IDs and the desired quantities. You need to process these orders to verify if they can be fulfilled based on available stock and calculate the total cost of the valid orders. **Problem Statement**: Write a function `process_orders(stock: dict[int, int], prices: dict[int, float], orders: list[tuple[int, int]]) -> tuple[bool, float]` that verifies if the orders can be fulfilled given the stock availability and calculates the total cost of all the valid orders. # Input: 1. `stock`: A dictionary where keys are item IDs (integers) and values are the available stock quantities (non-negative integers). 2. `prices`: A dictionary where keys are item IDs (integers) and values are the prices of the items (positive floats). 3. `orders`: A list of tuples where each tuple contains two integers, the first being the item ID and the second being the quantity ordered. # Output: A tuple containing: 1. A boolean value indicating if all orders can be fulfilled (True) or not (False). 2. A float representing the total cost of all valid orders. This value is only relevant if all orders can be fulfilled; otherwise, it should be zero. # Constraints: - Every item ID in `orders` exists in both `stock` and `prices`. - Stock quantities and order quantities are non-negative integers. - Prices are positive floats. # Examples: ```python assert process_orders({1: 10, 2: 5, 3: 2}, {1: 100.0, 2: 50.0, 3: 75.0}, [(1, 5), (2, 3)]) == (True, 650.0) assert process_orders({1: 3, 2: 2, 3: 1}, {1: 10.0, 2: 20.0, 3: 30.0}, [(1, 4), (2, 1)]) == (False, 0.0) assert process_orders({1: 5}, {1: 25.0}, [(1, 5)]) == (True, 125.0) assert process_orders({1: 0}, {1: 15.0}, [(1, 1)]) == (False, 0.0) assert process_orders({1: 5, 2: 5}, {1: 50.0, 2: 75.0}, []) == (True, 0.0) ``` # Additional Notes: - Ensure the function handles edge cases, such as empty order lists, appropriately. - Consider efficiency especially for larger inputs, although you may assume reasonable limits on input sizes. - Handle cases where stock is insufficient clearly and return the appropriate values.","solution":"def process_orders(stock, prices, orders): Verifies if the orders can be fulfilled given the stock availability and calculates the total cost of all the valid orders. Parameters: - stock (dict[int, int]): Dictionary with item IDs as keys and stock quantities as values. - prices (dict[int, float]): Dictionary with item IDs as keys and prices as values. - orders (list[tuple[int, int]]): List of tuples where each tuple contains an item ID and quantity ordered. Returns: - tuple: A tuple containing a boolean and a float. The boolean indicates if all orders can be fulfilled. The float represents the total cost of all valid orders, and it is zero if not all orders can be fulfilled. total_cost = 0.0 for item_id, quantity in orders: if stock[item_id] < quantity: return False, 0.0 total_cost += prices[item_id] * quantity return True, total_cost"},{"question":"# Implement a Function to Check for Circular Linked List Write a function called `is_circular_linked_list` that determines if a given singly linked list is circular. A circular linked list is one where a node\'s next pointer points to one of the previous nodes in the sequence, forming a loop. Return `True` if the linked list is circular, otherwise return `False`. # Function Signature ```python def is_circular_linked_list(head: ListNode) -> bool: ``` # Parameters and Constraints - `head` is an instance of `ListNode` which is the head of the singly linked list. - You cannot use any additional data structures such as sets or lists to store nodes. - The function should run in O(n) time where n is the number of nodes in the linked list. # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next # Example 1: Circular linked list # 1 -> 2 -> 3 -> 4 -+ # ^-----------| node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) node4.next = node2 # Creating the loop assert is_circular_linked_list(node1) == True # Example 2: Non-circular linked list # 1 -> 2 -> 3 -> 4 -> None node4 = ListNode(4) node3 = ListNode(3, node4) node2 = ListNode(2, node3) node1 = ListNode(1, node2) assert is_circular_linked_list(node1) == False ``` # Additional Notes - Use Floyd’s Cycle-Finding Algorithm (also known as the tortoise and hare algorithm) to solve this problem. - Ensure to handle cases where the linked list is empty (head is `None`).","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def is_circular_linked_list(head: ListNode) -> bool: Determines if a singly linked list is circular. if head is None: return False slow = head fast = head while fast is not None and fast.next is not None: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Sorting Students by Marks Problem Context: In a classroom, students are often assessed and given marks. For various administrative tasks, it\'s necessary to sort students by their marks and, in case of a tie, by their names. This helps in organizing records better and presenting data in a clear and structured manner. You need to implement a sorting system that orders students first by their marks (from highest to lowest) and then, in case of a tie, alphabetically by their names. Tasks: 1. Implement a function `sort_students_by_marks(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]` that takes a list of students along with their marks and sorts them accordingly. Input: - The function will receive a list of tuples `students`, where each tuple contains a student\'s name (string) and their respective mark (integer). Output: - A list of tuples, sorted first by marks in descending order and then by names in ascending order if there is a tie. Constraints: - The number of students `n` can be up to 10^5. - Each student\'s name will be a string of alphabets with a maximum length of 100 characters. - Marks are integers and can range from 0 to 100. Example: ```python def sort_students_by_marks(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: # Implement student sorting here # Example Usage: students = [(\\"Alice\\", 85), (\\"Bob\\", 75), (\\"Charlie\\", 85), (\\"David\\", 60)] print(sort_students_by_marks(students)) # Output: [(\'Alice\', 85), (\'Charlie\', 85), (\'Bob\', 75), (\'David\', 60)] ``` Your task is to provide an implementation for the function `sort_students_by_marks`, which should perform the described sorting.","solution":"from typing import List, Tuple def sort_students_by_marks(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the students first by their marks in descending order, and in case of a tie, by their names in ascending order. # Sorting using the key: (-marks, name) where -marks for descending sorting return sorted(students, key=lambda x: (-x[1], x[0]))"},{"question":"# Question: Checking Balanced Brackets in Code Snippets Given a list of code snippets as strings, write a function to check if each snippet has balanced brackets. For this question, you need to consider the following types of brackets: (), {}, and []. The function should return a list of boolean values indicating whether each code snippet has balanced brackets. # Function Signature ```python def check_balanced_brackets(snippets: List[str]) -> List[bool]: Check if the brackets in each given code snippet are balanced. :param snippets: List[str] - A list of code snippets where each snippet is a string. :return: List[bool] - A list of boolean values where each value corresponds to whether the brackets in the code snippet are balanced. >>> check_balanced_brackets([\\"{[()()]}\\", \\"{[(])}\\", \\"{{[[(())]]}}\\"]) [True, False, True] >>> check_balanced_brackets([\\"()\\", \\"([])\\", \\"([)]\\"]) [True, True, False] ``` # Input - `snippets`: A list of strings, where each string is a code snippet that may contain various brackets. # Output - A list of boolean values, where each value indicates whether the corresponding code snippet in the input list has balanced brackets. # Constraints - The input list will contain at most 1,000 snippets. - Each snippet will have at most 1,000 characters. - You need to consider only the brackets and ignore other characters in the code snippets. # Example ```python snippets = [\\"{[()()]}\\", \\"{[(])}\\", \\"{{[[(())]]}}\\"] output = check_balanced_brackets(snippets) # Expected output: [True, False, True] ``` # Notes: - A set of brackets is considered balanced if each opening bracket has a corresponding closing bracket of the same type and the opening brackets are closed in the correct order. - You can use a stack to ensure that the brackets are balanced correctly. ```python from typing import List def check_balanced_brackets(snippets: List[str]) -> List[bool]: def is_balanced(snippet: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in snippet: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return False return not stack return [is_balanced(snippet) for snippet in snippets] ```","solution":"from typing import List def check_balanced_brackets(snippets: List[str]) -> List[bool]: def is_balanced(snippet: str) -> bool: stack = [] bracket_map = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in snippet: if char in bracket_map.values(): stack.append(char) elif char in bracket_map: if not stack or stack.pop() != bracket_map[char]: return False return not stack return [is_balanced(snippet) for snippet in snippets]"},{"question":"# Question You are a software developer working on a data analysis library. Your task is to write a function that calculates the median of a list of integers after removing the smallest and largest k elements. # Function Description Implement the function `median_after_trimming` which takes in a list of integers and an integer k, and returns the median of the list after removing the smallest and largest k elements. # Input * A list of integers `data` of length n (1 ≤ n ≤ 10^5). * An integer `k` (0 ≤ k ≤ n//2), which is the number of smallest and largest elements to remove. # Output * An integer or float representing the median of the trimmed list. # Constraints * The list contains integers in the range [-10^9, 10^9]. * If the trimmed list has an even length, the median is the average of the two middle elements. * If `k = 0`, the median is calculated on the entire list. # Example ```python def median_after_trimming(data, k): data = sorted(data) trimmed_data = data[k:-k] n = len(trimmed_data) if n % 2 == 1: return trimmed_data[n // 2] else: return (trimmed_data[n // 2 - 1] + trimmed_data[n // 2]) / 2 # Example usage: data = [7, 1, 3, 5, 9, 8, 2] k = 1 result = median_after_trimming(data, k) print(result) # Output: 5 data = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100] k = 2 result = median_after_trimming(data, k) print(result) # Output: 55 ``` In the above example, the `median_after_trimming` function will calculate and return the median after removing the smallest and largest `k` elements from the list.","solution":"def median_after_trimming(data, k): Returns the median of the list after removing the smallest and largest k elements. Parameters: data (list): List of integers. k (int): Number of smallest and largest elements to remove. Returns: int or float: Median of the trimmed list. data = sorted(data) trimmed_data = data[k:len(data)-k] n = len(trimmed_data) if n == 0: raise ValueError(\\"The trimmed list is empty.\\") if n % 2 == 1: return trimmed_data[n // 2] else: return (trimmed_data[n // 2 - 1] + trimmed_data[n // 2]) / 2"},{"question":"# Problem Statement **Task Scheduling with Job Prioritization** Develop a scheduling algorithm that determines the optimal order for executing a set of tasks, taking into account their dependencies and priority levels. Each task has a priority, and some tasks cannot start until other prerequisite tasks have been completed. # Requirements: 1. You are given a list of tasks where each task is represented by a unique task ID. 2. Each task has an associated priority level; higher numbers indicate higher priority. 3. Each task can have a list of prerequisite tasks that must be completed before it can start. # Implementation Details: - Implement a function `schedule_tasks(tasks: List[Tuple[int, int]], prerequisites: List[Tuple[int, int]]) -> List[int]` where: - `tasks` is a list of tuples `(task_id, priority)`. - `prerequisites` is a list of tuples `(pre_task_id, post_task_id)` indicating that `post_task_id` depends on `pre_task_id`. - The function should return a list of task IDs in the order they should be executed to ensure all dependencies are met and priority is maximized. # Expected Input and Output - **Input**: - A list of tasks, each represented by a tuple `(task_id, priority)` - A list of prerequisites, each represented by a tuple `(pre_task_id, post_task_id)` - **Output**: - A list of task IDs in the order they should be executed. Constraints: - Tasks are uniquely identified by their ID. - There are no cyclic dependencies. - All tasks and dependencies are valid. - In case of multiple valid orders, the one that respects the highest priorities should be chosen. # Sample Input: ```python tasks = [(1, 5), (2, 3), (3, 2), (4, 1)] prerequisites = [(1, 2), (1, 3), (3, 4)] ``` # Sample Output: ```python [1, 3, 2, 4] ``` # Explanation: - Task 1 must come before tasks 2 and 3 due to its dependency. - Task 3 must come before task 4. - Task 2 can be executed after task 1. - Task 4 can only be executed after tasks 1 and 3. # Note: This problem requires understanding of graph traversal algorithms, particularly topological sorting enhanced by handling task priorities. Be mindful of edge cases such as multiple tasks having the same priority or having no prerequisites. Good luck!","solution":"from typing import List, Tuple from collections import defaultdict, deque def schedule_tasks(tasks: List[Tuple[int, int]], prerequisites: List[Tuple[int, int]]) -> List[int]: # Create a map of task_id to priority priority_map = {task_id: priority for task_id, priority in tasks} # Build the graph and in-degree count graph = defaultdict(list) in_degrees = defaultdict(int) for pre, post in prerequisites: graph[pre].append(post) in_degrees[post] += 1 topo_sort = [] zero_in_degree_queue = deque() # Initialize the queue with tasks that have zero in-degrees for task_id, _ in tasks: if in_degrees[task_id] == 0: zero_in_degree_queue.append(task_id) while zero_in_degree_queue: # Sorting zero degree nodes based on priority (highest first) zero_in_degree_queue = deque(sorted(zero_in_degree_queue, key=lambda x: -priority_map[x])) current = zero_in_degree_queue.popleft() topo_sort.append(current) # Decrease in-degree of neighbors for neighbor in graph[current]: in_degrees[neighbor] -= 1 if in_degrees[neighbor] == 0: zero_in_degree_queue.append(neighbor) return topo_sort"},{"question":"# Problem Statement You are developing a system log analysis tool that helps in monitoring and understanding the behavior of server logs. One of the key functionalities needed is to extract specific log messages based on their severity level. The log messages are categorized into three severity levels: \\"Info\\", \\"Warning\\", and \\"Error\\". Write a function `filter_log_by_severity` that filters log messages based on the given severity level. The function should take a list of log messages and a severity level, and return a list of messages that match the given severity level. Each log message is a string that starts with the severity level followed by a colon and the actual message. For example: ``` \\"Info:Successfully connected to the database\\" \\"Warning:Disk space is running low\\" \\"Error:Failed to open socket\\" ``` # Function Signature ```python def filter_log_by_severity(logs: list, severity: str) -> list: ``` # Input * `logs` (list): A list of log messages where each message is a string that begins with \\"Info:\\", \\"Warning:\\", or \\"Error:\\". * `severity` (str): A string representing the severity level that needs to be filtered. It can be one of \\"Info\\", \\"Warning\\", or \\"Error\\". # Output * Returns a list of log messages that match the specified severity level. # Constraints * If the severity level is not one of \\"Info\\", \\"Warning\\", or \\"Error\\", the function must raise a `ValueError` with the message \\"Invalid severity level\\". # Examples ```python >>> filter_log_by_severity( ... [\\"Info:Successfully connected to the database\\", ... \\"Warning:Disk space is running low\\", ... \\"Error:Failed to open socket\\", ... \\"Info:User logged out\\"], ... \\"Info\\") [\'Info:Successfully connected to the database\', \'Info:User logged out\'] >>> filter_log_by_severity( ... [\\"Info:Successfully connected to the database\\", ... \\"Warning:Disk space is running low\\", ... \\"Error:Failed to open socket\\", ... \\"Info:User logged out\\"], ... \\"Warning\\") [\'Warning:Disk space is running low\'] >>> filter_log_by_severity( ... [\\"Info:Successfully connected to the database\\", ... \\"Warning:Disk space is running low\\", ... \\"Error:Failed to open socket\\", ... \\"Info:User logged out\\"], ... \\"Error\\") [\'Error:Failed to open socket\'] >>> filter_log_by_severity( ... [\\"Info:Successfully connected to the database\\", ... \\"Warning:Disk space is running low\\", ... \\"Error:Failed to open socket\\", ... \\"Info:User logged out\\"], ... \\"Debug\\") Traceback (most recent call last): ... ValueError: Invalid severity level ``` # Hints * You can use Python\'s list comprehension to filter messages based on the given severity level. * Ensure to handle the case sensitivity correctly while checking for severity levels and matching them in logs.","solution":"def filter_log_by_severity(logs: list, severity: str) -> list: Filters log messages based on the given severity level. :param logs: List of log messages where each message is a string that begins with \\"Info:\\", \\"Warning:\\", or \\"Error:\\". :param severity: A string representing the severity level that needs to be filtered. It can be one of \\"Info\\", \\"Warning\\", or \\"Error\\". :return: A list of log messages that match the specified severity level. :raises ValueError: If the severity level is not one of \\"Info\\", \\"Warning\\", or \\"Error\\". valid_severities = {\\"Info\\", \\"Warning\\", \\"Error\\"} if severity not in valid_severities: raise ValueError(\\"Invalid severity level\\") return [log for log in logs if log.startswith(severity + \\":\\")]"},{"question":"String Segmentation Utility Working with strings, especially long ones, can be cumbersome when each segment or chunk of the string needs to meet specific criteria. For instance, dividing up a string into segments that have an equal number of occurrences of a given set of characters. Such segmentation is often required in text processing or data parsing tasks. Your task is to implement a class `StringSegmenter` with the following methods to manage string segmentation efficiently: 1. **segment_into_equal_counts(input_string: str, chars: str) -> List[str]**: Split the input string into minimal segments where each segment contains the same number of occurrences of every character in the `chars` string. - If it is not possible to split the string into such segments, return an empty list. 2. **segment_by_length(input_string: str, length: int) -> List[str]**: Split the input string into segments, each of a given `length`. If the last segment is shorter than the specified length, include it as is. 3. **segment_by_delimiter(input_string: str, delimiter: str) -> List[str]**: Split the input string by a specified `delimiter` string. 4. **is_segmentable(input_string: str, chars: str) -> bool**: Check if the input string can be segmented such that each segment contains the same number of occurrences of each character in the `chars` string. # Requirements: * The `input_string` will be a non-empty string. * The `chars` string will contain unique characters. * For `segment_by_length`, the length will be a positive integer. * For `segment_by_delimiter`, the `delimiter` will be a non-empty string. # Example: ```python class StringSegmenter: @staticmethod def segment_into_equal_counts(input_string: str, chars: str) -> List[str]: # Implement this method pass @staticmethod def segment_by_length(input_string: str, length: int) -> List[str]: # Implement this method pass @staticmethod def segment_by_delimiter(input_string: str, delimiter: str) -> List[str]: # Implement this method pass @staticmethod def is_segmentable(input_string: str, chars: str) -> bool: # Implement this method pass # Example usage: assert StringSegmenter.segment_into_equal_counts(\\"aabbcc\\", \\"abc\\") == [\\"aabbcc\\"] assert StringSegmenter.segment_into_equal_counts(\\"abcabc\\", \\"abc\\") == [\\"abc\\", \\"abc\\"] assert StringSegmenter.segment_into_equal_counts(\\"abbcc\\", \\"abc\\") == [] assert StringSegmenter.segment_by_length(\\"abcdefghijkl\\", 3) == [\\"abc\\", \\"def\\", \\"ghi\\", \\"jkl\\"] assert StringSegmenter.segment_by_length(\\"abcdefghij\\", 3) == [\\"abc\\", \\"def\\", \\"ghi\\", \\"j\\"] assert StringSegmenter.segment_by_delimiter(\\"one-tow-three\\", \\"-\\") == [\\"one\\", \\"two\\", \\"three\\"] assert StringSegmenter.is_segmentable(\\"abcabc\\", \\"abc\\") == True assert StringSegmenter.is_segmentable(\\"abcab\\", \\"abc\\") == False ``` Implement the class `StringSegmenter` with these methods to handle various string segmentation requirements efficiently.","solution":"from typing import List class StringSegmenter: @staticmethod def segment_into_equal_counts(input_string: str, chars: str) -> List[str]: count = {char: 0 for char in chars} segment = [] result = [] for char in input_string: if char in count: count[char] += 1 segment.append(char) if all(count[c] == count[chars[0]] for c in count): result.append(\'\'.join(segment)) segment = [] count = {char: 0 for char in chars} else: segment.append(char) if any(count[c] != 0 for c in count): # Check if any leftover counts return [] return result @staticmethod def segment_by_length(input_string: str, length: int) -> List[str]: return [input_string[i:i + length] for i in range(0, len(input_string), length)] @staticmethod def segment_by_delimiter(input_string: str, delimiter: str) -> List[str]: return input_string.split(delimiter) @staticmethod def is_segmentable(input_string: str, chars: str) -> bool: count = {char: 0 for char in chars} for char in input_string: if char in count: count[char] += 1 # All counts must be equal and greater than zero return len(set(count.values())) == 1 and next(iter(count.values())) > 0"},{"question":"# Context You are tasked with implementing a function that checks for the presence of a specific pattern in a matrix. The pattern is a contiguous subsequence of numbers that forms a straight line horizontally, vertically, or diagonally. # Description Implement a function that checks if a given pattern exists within an N x M matrix. The pattern should be a contiguous subsequence of integers either in a single row, a single column, or diagonally (both major and minor diagonals). # Function Signature ```python def check_pattern(matrix: List[List[int]], pattern: List[int]) -> bool: pass ``` # Input * `matrix` (List[List[int]]): A 2D list of integers representing the matrix. * `pattern` (List[int]): A list of integers representing the sequence to look for. # Output * Return `True` if the pattern is found in the matrix, `False` otherwise. # Constraints * The size of the matrix (`N x M`) is such that (1 leq N, M leq 100). * The length of the pattern is at most the size of the larger dimension of the matrix. * All integers in the matrix and the pattern are between (-10^6) and (10^6). # Example ```python matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] pattern = [6, 7, 8] result = check_pattern(matrix, pattern) # `result` should be True, as the pattern [6, 7, 8] is found in the second row. pattern = [10, 6, 2] result = check_pattern(matrix, pattern) # `result` should be False, as the pattern [10, 6, 2] is not found anywhere in a contiguous line. pattern = [13, 9, 5] result = check_pattern(matrix, pattern) # `result` should be True, as the pattern [13, 9, 5] is found in a diagonal. ``` # Notes * You need to consider all possible lines in the matrix where the pattern might appear (rows, columns, and diagonals). * Make sure to handle the boundaries of the matrix properly to avoid indexing errors. * Optimize the solution to handle the worst-case scenario where the pattern length is close to the matrix size limits.","solution":"def check_pattern(matrix, pattern): def check_horizontal(x, y): if y + len(pattern) > len(matrix[0]): return False return matrix[x][y:y+len(pattern)] == pattern def check_vertical(x, y): if x + len(pattern) > len(matrix): return False for i in range(len(pattern)): if matrix[x + i][y] != pattern[i]: return False return True def check_major_diagonal(x, y): if x + len(pattern) > len(matrix) or y + len(pattern) > len(matrix[0]): return False for i in range(len(pattern)): if matrix[x + i][y + i] != pattern[i]: return False return True def check_minor_diagonal(x, y): if x + len(pattern) > len(matrix) or y - len(pattern) + 1 < 0: return False for i in range(len(pattern)): if matrix[x + i][y - i] != pattern[i]: return False return True for i in range(len(matrix)): for j in range(len(matrix[0])): if (check_horizontal(i, j) or check_vertical(i, j) or check_major_diagonal(i, j) or check_minor_diagonal(i, j)): return True return False"},{"question":"# Problem Statement: You are to implement a function to perform integer division of two numbers without using the division, multiplication, or modulus operators. The function should return the quotient after dividing the dividend by the divisor. Ensure that the function handles edge cases, such as division by zero. # Function Signature: ```python def integer_divide(dividend: int, divisor: int) -> int: pass ``` # Input: - `dividend` (int): The number to be divided, which can be positive, negative, or zero. - `divisor` (int): The number by which to divide, which can be positive or negative (non-zero). # Output: - (int): The quotient after dividing the `dividend` by the `divisor`. # Constraints: - Division by zero should raise a `ZeroDivisionError`. - The result should be truncated towards zero (i.e., `-1.9` returns `-1` and `3.5` returns `3`). - The function should handle large integers efficiently. # Performance Requirements: - Your solution should ideally have a time complexity of ( O(log n) ), where ( n ) is the absolute value of the dividend. - Space complexity should be ( O(1) ). # Examples: ```python assert integer_divide(10, 3) == 3 assert integer_divide(7, -3) == -2 assert integer_divide(-10, 2) == -5 assert integer_divide(-7, -3) == 2 assert integer_divide(0, 1) == 0 try: integer_divide(1, 0) except ZeroDivisionError: pass ``` # Explanation of the Example: - ( 10 // 3 = 3 ) because `3.333...` truncated towards zero is `3`. - ( 7 // -3 = -2 ) because `-2.333...` truncated towards zero is `-2`. - ( -10 // 2 = -5 ) because `-5` is already an integer. - ( -7 // -3 = 2 ) because `2.333...` truncated towards zero is `2`. - ( 0 // 1 = 0 ) because any number divided by `1` is the number itself, and `0` divided by any non-zero number is `0`. # Additional Notes: - Utilize bit manipulation to optimize the performance. - Be mindful of handling negative values and edge cases correctly. - Ensure that your implementation has robust error handling, especially for division by zero.","solution":"def integer_divide(dividend: int, divisor: int) -> int: if divisor == 0: raise ZeroDivisionError(\\"division by zero\\") # Determine the sign of the result negative = (dividend < 0) != (divisor < 0) # Use absolute values for division dividend, divisor = abs(dividend), abs(divisor) quotient = 0 # We will use bit manipulation to perform the division while dividend >= divisor: temp_divisor, num_divisors = divisor, 1 while dividend >= (temp_divisor << 1): temp_divisor <<= 1 num_divisors <<= 1 dividend -= temp_divisor quotient += num_divisors if negative: quotient = -quotient return quotient"},{"question":"# Graph Traversal and Shortest Path Finding Objective You are tasked with writing a function to find the shortest path in an undirected, weighted graph using Dijkstra\'s algorithm. This is a common problem in graph theory and has applications in network routing, geographical mapping, etc. Problem Statement You need to implement a function `shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]` that: 1. Finds the shortest path between two nodes in a given graph using Dijkstra\'s algorithm. 2. Returns the sequence of nodes from the start node to the end node. Input * A dictionary representing the graph where keys are node identifiers (integers) and values are lists of tuples. Each tuple contains a neighboring node and the weight of the edge connecting them. * Two integers `start` and `end` representing the start and end nodes. Output * A list of integers representing the sequence of nodes from `start` to `end`. If no path exists, return an empty list. Constraints * The graph is undirected, and weights are non-negative integers. * The graph may have multiple components. * The start and end nodes are always valid nodes in the graph. Example ```python >>> graph = { ... 0: [(1, 4), (2, 1)], ... 1: [(0, 4), (2, 2), (3, 1)], ... 2: [(0, 1), (1, 2), (3, 5)], ... 3: [(1, 1), (2, 5)] ... } >>> shortest_path(graph, 0, 3) [0, 2, 1, 3] >>> shortest_path(graph, 0, 1) [0, 2, 1] >>> shortest_path(graph, 3, 0) [3, 1, 2, 0] >>> shortest_path(graph, 0, 4) [] ``` Requirements * Do not use any external libraries for graph traversal or shortest path finding. * Make use of comments for clarity. * Ensure edge cases such as isolated nodes or nodes not connected to the end node are handled effectively.","solution":"import heapq from typing import Dict, List, Tuple def shortest_path(graph: Dict[int, List[Tuple[int, int]]], start: int, end: int) -> List[int]: Finds the shortest path between two nodes in a graph using Dijkstra\'s algorithm. :param graph: A dictionary where keys are node identifiers and values are lists of tuples (neighbor, weight). :param start: The starting node identifier. :param end: The ending node identifier. :return: A list of node identifiers representing the shortest path from start to end. # Priority queue to store (current_distance, current_node) queue = [(0, start)] # Dictionary to store the minimum distance to reach each node distances = {node: float(\'infinity\') for node in graph} distances[start] = 0 # Dictionary to store the previous node in the optimal path previous_nodes = {node: None for node in graph} visited = set() while queue: current_distance, current_node = heapq.heappop(queue) visited.add(current_node) if current_node == end: # Reconstruct the path if the end node is reached path = [] while current_node is not None: path.append(current_node) current_node = previous_nodes[current_node] return path[::-1] if current_distance > distances[current_node]: continue # Explore neighbors for neighbor, weight in graph.get(current_node, []): if neighbor in visited: continue distance = current_distance + weight # If a shorter path to neighbor is found if distance < distances[neighbor]: distances[neighbor] = distance previous_nodes[neighbor] = current_node heapq.heappush(queue, (distance, neighbor)) # If the end node is not reachable return []"},{"question":"# Temperature Conversion You are required to write a function that converts temperature measurements between different scales. The given function `temperature_conversion` converts a value given in one temperature scale to another using predefined conversion formulas. Your task is to add support for two additional scales: **Rankine** and **Reaumur**. You also have to ensure that the function gracefully handles invalid inputs and prints a user-friendly error message. # Requirements: 1. **Scale Conversions to Add**: - **Rankine (R)**: - Conversion to Celsius: ( C = frac{R - 491.67}{1.8} ) - Conversion from Celsius: ( R = C times 1.8 + 491.67 ) - **Reaumur (Re)**: - Conversion to Celsius: ( C = Re times 1.25 ) - Conversion from Celsius: ( Re = C times 0.8 ) 2. **Error Handling**: - Modify the error message for invalid scales to be more user-friendly. 3. **Function Signature**: - `def temperature_conversion(value: float, from_scale: str, to_scale: str) -> float:` 4. **Example**: ```python >>> temperature_conversion(100, \\"Celsius\\", \\"Rankine\\") 671.67 >>> temperature_conversion(491.67, \\"Rankine\\", \\"Celsius\\") 0.0 >>> temperature_conversion(80, \\"Reaumur\\", \\"Celsius\\") 100.0 >>> temperature_conversion(25, \\"Celsius\\", \\"Reaumur\\") 20.0 >>> temperature_conversion(5, \\"Kelvin\\", \\"Celsius\\") Traceback (most recent call last): ... ValueError: Invalid \'from_scale\' value: \'Kelvin\'.nAvailable scales are: Celsius, Fahrenheit, Kelvin, Rankine, Reaumur ``` # Constraints: 1. If input scales are not valid, raise a `ValueError` with a message listing available scales. 2. The function should work with input values up to a precision of `1e-15` for floating-point calculations.","solution":"def temperature_conversion(value: float, from_scale: str, to_scale: str) -> float: Converts a temperature from one scale to another. Supported scales: Celsius, Fahrenheit, Kelvin, Rankine, Reaumur available_scales = [\\"Celsius\\", \\"Fahrenheit\\", \\"Kelvin\\", \\"Rankine\\", \\"Reaumur\\"] def to_celsius(value, from_scale): if from_scale == \\"Celsius\\": return value elif from_scale == \\"Fahrenheit\\": return (value - 32) * 5/9 elif from_scale == \\"Kelvin\\": return value - 273.15 elif from_scale == \\"Rankine\\": return (value - 491.67) / 1.8 elif from_scale == \\"Reaumur\\": return value * 1.25 else: raise ValueError(f\\"Invalid \'from_scale\' value: \'{from_scale}\'.nAvailable scales are: {\', \'.join(available_scales)}\\") def from_celsius(value, to_scale): if to_scale == \\"Celsius\\": return value elif to_scale == \\"Fahrenheit\\": return value * 9/5 + 32 elif to_scale == \\"Kelvin\\": return value + 273.15 elif to_scale == \\"Rankine\\": return value * 1.8 + 491.67 elif to_scale == \\"Reaumur\\": return value * 0.8 else: raise ValueError(f\\"Invalid \'to_scale\' value: \'{to_scale}\'.nAvailable scales are: {\', \'.join(available_scales)}\\") if from_scale not in available_scales: raise ValueError(f\\"Invalid \'from_scale\' value: \'{from_scale}\'.nAvailable scales are: {\', \'.join(available_scales)}\\") if to_scale not in available_scales: raise ValueError(f\\"Invalid \'to_scale\' value: \'{to_scale}\'.nAvailable scales are: {\', \'.join(available_scales)}\\") value_in_celsius = to_celsius(value, from_scale) result = from_celsius(value_in_celsius, to_scale) return result"},{"question":"# Anagram Grouping Enhancement You have implemented a basic algorithm to group a list of strings into anagrams. Your task is to enhance this implementation to handle a large dataset of strings efficiently and improve its performance. Task 1. Modify the `group_anagrams` function to ensure it can handle large datasets of up to 1 million strings efficiently. 2. Implement a sorting mechanism for each group of anagrams in a consistent order to ensure deterministic output. Specifications: * **Function to Implement**: You need to modify the provided `group_anagrams` function. * Use an efficient approach for grouping anagrams, considering both time and space complexity. * Make sure each group of anagrams is sorted in lexicographical order. * **Input and Output**: * The `words` parameter is a list of strings containing up to 1 million elements. * Return a list of lists, where each sublist contains grouped anagrams sorted in lexicographical order. * **Performance Requirement**: Ensure the function operates within a reasonable time for large inputs and avoids excessive memory usage. * **Constraints**: * Assume each string length is between 1 and 100 characters. * The input list contains at most 1 million strings. Below is the initial implementation: ```python from collections import defaultdict def group_anagrams(words): Group list of strings into anagrams and sort each group. Args: words (list): List of strings to be grouped. Returns: list: List of lists with grouped anagrams sorted lexicographically. Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'ate\', \'eat\', \'tea\'], [\'bat\'], [\'nat\', \'tan\']] anagrams = defaultdict(list) # for storing groups of anagram for word in words: # The sorted tuple of the word will be our grouping key key = tuple(sorted(word)) anagrams[key].append(word) # Sort the individual groups and return as a list result = [sorted(group) for group in anagrams.values()] return result if __name__ == \\"__main__\\": import doctest doctest.testmod() words = input(\\"Enter words separated by space: \\").split() grouped_anagrams = group_anagrams(words) for group in grouped_anagrams: print(\\"Group: \\", group) ``` This question prompts you to enhance your understanding of hash maps (dictionaries) and sorting algorithms while considering large-scale data handling and optimization.","solution":"from collections import defaultdict def group_anagrams(words): Group list of strings into anagrams and sort each group. Args: words (list): List of strings to be grouped. Returns: list: List of lists with grouped anagrams sorted lexicographically. Example: >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [[\'ate\', \'eat\', \'tea\'], [\'bat\'], [\'nat\', \'tan\']] anagrams = defaultdict(list) # for storing groups of anagram for word in words: # The sorted tuple of the word will be our grouping key key = tuple(sorted(word)) anagrams[key].append(word) # Sort the individual groups and return as a list result = [sorted(group) for group in anagrams.values()] # Sort the overall list of groups by the first word in each group for deterministic output result.sort(key=lambda x: x[0]) return result if __name__ == \\"__main__\\": import doctest doctest.testmod()"},{"question":"# Problem Statement You are given an array of integers `numbers`. Your task is to rearrange the elements in such a way that all negative numbers appear at the beginning of the array, followed by all positive numbers, while maintaining the relative order of the negative and positive numbers. # Input - An array of integers `numbers` of length `n` where `0 ≤ n ≤ 10^6` and each element can be between `-10^9` and `10^9`. # Output - Return a new list of integers where all negative numbers are at the beginning, followed by all positive numbers, preserving their relative order from the original array. # Constraints - You must preserve the relative order of the negative and positive numbers from the original array. - The function should handle large input sizes efficiently. # Example ```python assert reorder_negatives_first([1, -2, -3, 4, 5, -6]) == [-2, -3, -6, 1, 4, 5] assert reorder_negatives_first([-1, -2, -3, -4, -5]) == [-1, -2, -3, -4, -5] assert reorder_negatives_first([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] assert reorder_negatives_first([0, -1, 2, -3, 4]) == [-1, -3, 0, 2, 4] assert reorder_negatives_first([]) == [] ``` # Function Signature ```python def reorder_negatives_first(numbers: list[int]) -> list[int]: # implement here ``` # Notes - Ensure to raise ValueError if `numbers` is not an iterable of integers.","solution":"def reorder_negatives_first(numbers): Reorder the list such that all negative numbers appear first, followed by all non-negative numbers, while maintaining their relative order. Args: numbers (list of int): List of integers to reorder Returns: list of int: Reordered list with negatives first, followed by non-negatives if not all(isinstance(num, int) for num in numbers): raise ValueError(\\"All elements in the input must be integers\\") negatives = [num for num in numbers if num < 0] non_negatives = [num for num in numbers if num >= 0] return negatives + non_negatives"},{"question":"```markdown # Problem Statement: You are tasked with implementing a `BalancedParentheses` class that can validate if a given string containing \'(\', \')\', \'{\', \'}\', \'[\' and \']\' is balanced. A string is considered balanced if every opening bracket has a corresponding closing bracket in the correct order. # Requirements: * Implement the class `BalancedParentheses` with a method `is_balanced` that takes a string as input and returns a boolean indicating whether the string is balanced. * Use a stack data structure to keep track of the opening brackets. * Ensure the method handles all possible edge cases. # Function Signature: ```python class BalancedParentheses: def is_balanced(self, string: str) -> bool: ``` # Expected Input: * A string containing the characters \'(\', \')\', \'{\', \'}\', \'[\' and \']\', e.g., \\"({[()]})\\". # Expected Output: * A boolean value, e.g., True or False. # Constraints: * 1 <= len(string) <= 1000 # Implementation Details: 1. Use a stack to keep track of opening brackets as they appear. 2. For each closing bracket encountered, check if it corresponds to the last unmatched opening bracket on the stack. If it does, pop the stack. 3. If all brackets are matched by the end of the string, return True. Otherwise, return False. # Example: ```python >>> validator = BalancedParentheses() >>> validator.is_balanced(\\"({[()]})\\") True >>> validator.is_balanced(\\"({[([)])\\") False ``` # Notes: * Consider edge cases like an empty string, or a string with only closing brackets. * The matching of brackets must take into account the order and type of parentheses. ```","solution":"class BalancedParentheses: def is_balanced(self, string: str) -> bool: stack = [] pairs = {\')\': \'(\', \'}\': \'{\', \']\': \'[\'} for char in string: if char in pairs.values(): # opening brackets stack.append(char) elif char in pairs.keys(): # closing brackets if stack == [] or stack.pop() != pairs[char]: return False return stack == [] # Example usage: # validator = BalancedParentheses() # print(validator.is_balanced(\\"({[()]})\\")) # Should return True # print(validator.is_balanced(\\"({[([)])\\")) # Should return False"},{"question":"# Binary Search Tree Height Calculation You are tasked with computing the height of a Binary Search Tree (BST). The height of a BST is defined as the number of edges on the longest path from the root node to a leaf node. # Your Task: Write a function `calculate_bst_height(values)` that: 1. Creates a Binary Search Tree (BST) from the given list of values. 2. Calculates and returns the height of the BST. ```python class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def calculate_bst_height(values: list[int]) -> int: # Your implementation here pass ``` # Input: - `values`: List of integers representing the node values to be inserted into the BST. # Output: - An integer representing the height of the BST. # Constraints: - 1 <= len(values) <= 1000 - -1000 <= values[i] <= 1000 - All values are distinct. # Example: ```python values = [10, 5, 15, 3, 7, 12, 18] height = calculate_bst_height(values) print(height) ``` Output: ``` 2 ``` # Notes: - Ensure the BST properties are maintained during the insertion of nodes. - Optimize the BST insertion for efficiency. - You may assume that the input list will not be empty.","solution":"class TreeNode: def __init__(self, key): self.left = None self.right = None self.val = key def insert_into_bst(root, key): if root is None: return TreeNode(key) else: if key < root.val: root.left = insert_into_bst(root.left, key) else: root.right = insert_into_bst(root.right, key) return root def calculate_bst_height(values): if not values: return -1 root = None for val in values: root = insert_into_bst(root, val) def height(node): if node is None: return -1 else: left_height = height(node.left) right_height = height(node.right) return 1 + max(left_height, right_height) return height(root)"},{"question":"# Question You are given two strings, `str_a` and `str_b`. Your task is to implement the function `smallest_supersequence` that finds the length of the smallest supersequence of the given two strings. A supersequence of a group of sequences is a sequence that contains all those sequences as subsequences. # Constraints 1. 1 ≤ len(str_a), len(str_b) ≤ 1000 2. Both strings consist of only lowercase English letters. # Function Signature ```python def smallest_supersequence(str_a: str, str_b: str) -> int: ... ``` # Input Format - `str_a`: A string. - `str_b`: A string. # Output Format - An integer representing the length of the smallest supersequence. # Example ```python print(smallest_supersequence(\\"geek\\", \\"eke\\")) # Expected: 5 # Explanation: The smallest supersequence is \\"geeke\\" which has length 5. print(smallest_supersequence(\\"AGGTAB\\", \\"GXTXAYB\\")) # Expected: 9 # Explanation: The smallest supersequence is \\"AGXGTXAYB\\" which has length 9. ``` # Additional Requirements: 1. Efficiently handle the maximum input size within reasonable time and space complexity. 2. You may assume that the function will always receive valid input as specified.","solution":"def smallest_supersequence(str_a: str, str_b: str) -> int: Returns the length of the smallest supersequence of two given strings. m, n = len(str_a), len(str_b) # Create a 2D table to store lengths of longest common subsequence dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the table in bottom-up manner for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif str_a[i-1] == str_b[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) # Length of the smallest supersequence lcs_length = dp[m][n] return m + n - lcs_length"},{"question":"# Question In a forest, each tree emits a unique frequency of sound to attract birds. You have a list of `n` trees, where each tree has a specific frequency of sound emission. You want to determine the tree with the highest frequency, but if there are multiple trees with the same highest frequency, you want to find the tree that appears last in the list. Write a Python function `highest_frequency_tree` that takes a list `frequencies` representing the frequencies emitted by the trees and returns the index of the tree with the highest frequency. If the list is empty, return `-1`. Here are the details: * The index returned should be 0-based. * If there are multiple trees with the same highest frequency, return the index of the tree that appears last in the list. * If the list is empty, return `-1`. **Function Signature:** ```python def highest_frequency_tree(frequencies: list) -> int: ``` **Input:** - `frequencies`: A list of integers where each integer represents the frequency emitted by a tree. **Output:** - Returns an integer representing the index of the tree with the highest frequency. If the list is empty, return `-1`. **Examples:** ```python >>> highest_frequency_tree([1, 3, 7, 3, 7]) 4 >>> highest_frequency_tree([5, 5, 5]) 2 >>> highest_frequency_tree([10, 20, 30, 10, 20]) 2 >>> highest_frequency_tree([]) -1 >>> highest_frequency_tree([9]) 0 ``` Please ensure your implementation correctly handles edge cases and provides accurate results for all valid inputs, as specified.","solution":"def highest_frequency_tree(frequencies: list) -> int: Returns the index of the tree with the highest frequency. If there are multiple trees with the same highest frequency, returns the index of the tree that appears last in the list. If the list is empty, returns -1. if not frequencies: return -1 max_freq = max(frequencies) max_index = len(frequencies) - 1 - frequencies[::-1].index(max_freq) return max_index"},{"question":"# SQL Query Optimization Challenge You are provided with two tables: `sales` and `products`. The `sales` table records each sale transaction, and the `products` table contains information about each product available in the inventory. Your task is to write an optimized SQL query that retrieves the top 5 products with the highest sales revenue within a specified date range. # Objective Write a query to fetch the top 5 products based on the total sales revenue (price * quantity) for a given date range from the `sales` table. Tables Description # `sales` table: - **Columns**: - `sale_id` (INTEGER): Unique identifier for each sale transaction. - `product_id` (INTEGER): Identifier for the product sold. - `quantity` (INTEGER): Quantity of the product sold. - `price` (NUMERIC): Price per unit of the product sold. - `sale_date` (DATE): Date when the sale was made. # `products` table: - **Columns**: - `product_id` (INTEGER): Unique identifier for each product. - `product_name` (VARCHAR): Name of the product. - There are indexes on the `sale_date` and `product_id` columns to optimize query performance. # Task Breakdown 1. Calculate each product\'s total revenue (price * quantity) for the specified date range. 2. Retrieve product names along with the calculated revenue. 3. Sort the results by total revenue in descending order. 4. Limit the results to the top 5 products. # Input/Output - **Input**: - `start_date` (DATE): Starting date of the period. - `end_date` (DATE): Ending date of the period. - **Output**: - A list of tuples containing the top 5 product names and their total sales revenue in the specified date range. # Example Given tables populated with sample data: **sales**: | sale_id | product_id | quantity | price | sale_date | |---------|------------|----------|-------|-----------| | 1 | 101 | 2 | 20 | 2023-05-01| | 2 | 102 | 1 | 50 | 2023-05-02| | 3 | 101 | 1 | 20 | 2023-05-03| | 4 | 103 | 5 | 10 | 2023-05-04| **products**: | product_id | product_name | |------------|--------------| | 101 | Product A | | 102 | Product B | | 103 | Product C | **Input Values**: ```sql start_date = \'2023-05-01\' end_date = \'2023-05-05\' ``` **Expected Result**: The query should produce: ```sql (\\"Product A\\", 60), (\\"Product C\\", 50), (\\"Product B\\", 50) ``` # Note Focus on query optimization techniques considering the use of indexes and aggregation functions. # SQL Query template ```sql SELECT p.product_name, SUM(s.price * s.quantity) AS total_revenue FROM sales s JOIN products p ON s.product_id = p.product_id WHERE s.sale_date BETWEEN \'start_date\' AND \'end_date\' GROUP BY p.product_name ORDER BY total_revenue DESC LIMIT 5; ```","solution":"def get_top_products_sales_revenue(start_date, end_date): Returns a SQL query that retrieves the top 5 products based on the total sales revenue within a specified date range. Parameters: start_date (str): The starting date of the period (inclusive). end_date (str): The ending date of the period (inclusive). Returns: str: The SQL query string. query = f SELECT p.product_name, SUM(s.price * s.quantity) AS total_revenue FROM sales s JOIN products p ON s.product_id = p.product_id WHERE s.sale_date BETWEEN \'{start_date}\' AND \'{end_date}\' GROUP BY p.product_name ORDER BY total_revenue DESC LIMIT 5; return query"},{"question":"# Coding Assessment Question Scenario You are working on a system that processes large streams of numeric data. You need a way to quickly insert elements into a data structure and retrieve the current median of the elements at any point in time. To allow these operations, you choose to implement a median finding data structure using two heaps (binary heaps). Task Implement the `MedianFinder` class which supports the following functionalities: 1. Inserting a number into the data structure. 2. Finding the median of all inserted numbers. Class Definitions 1. **MedianFinder**: * **Methods**: - `__init__(self)`: Initializes the data structure, preparing two heaps (one max-heap for the lower half and one min-heap for the upper half). - `addNum(self, num: int)`: Adds a number to the data structure. - `findMedian(self) -> float`: Returns the median of all numbers (an integer if the number of elements is odd, or a float otherwise). Example Usage ```python mf = MedianFinder() mf.addNum(1) mf.addNum(2) assert mf.findMedian() == 1.5 mf.addNum(3) assert mf.findMedian() == 2 mf_2 = MedianFinder() mf_2.addNum(-1) mf_2.addNum(-2) mf_2.addNum(-3) assert mf_2.findMedian() == -2 mf_2.addNum(-4) mf_2.addNum(1) assert mf_2.findMedian() == -2 ``` # Requirements * Ensure the `addNum` operation runs in (O(log n)) time. * Ensure the `findMedian` operation runs in (O(1)) time. * Validate edge cases, such as adding a single element or handling an empty data structure correctly. Constraints * All elements added are integers in the range of ([-10^5, 10^5]). * A maximum of (10^5) elements will be added to the data structure. Implementing the core functionality efficiently is crucial to handle both small and large data streams effectively.","solution":"import heapq class MedianFinder: def __init__(self): Initialize the MedianFinder with two heaps: - A max-heap to store the lower half of numbers - A min-heap to store the upper half of numbers self.lower_half = [] # Max heap self.upper_half = [] # Min heap def addNum(self, num: int): Add a number into the data structure. if not self.lower_half or num <= -self.lower_half[0]: heapq.heappush(self.lower_half, -num) else: heapq.heappush(self.upper_half, num) # Balance the heaps if len(self.lower_half) > len(self.upper_half) + 1: heapq.heappush(self.upper_half, -heapq.heappop(self.lower_half)) elif len(self.upper_half) > len(self.lower_half): heapq.heappush(self.lower_half, -heapq.heappop(self.upper_half)) def findMedian(self) -> float: Retrieve the median of all numbers. if len(self.lower_half) == len(self.upper_half): return (-self.lower_half[0] + self.upper_half[0]) / 2.0 else: return float(-self.lower_half[0])"},{"question":"# Problem Scenario You are working on a project to help a local grocery store with its inventory management. The store wants to keep track of items\' stock levels automatically. Your task is to write a function that updates the inventory based on a list of transactions. Each transaction either adds more of the item to the stock or removes some of the item from the stock. Write a function `update_inventory` to calculate the final inventory for each item based on the following parameters: - `initial_inventory`: A dictionary where the keys are item names (strings) and the values are the initial stock levels (integers). - `transactions`: A list of tuples representing transactions. Each tuple contains three elements: - `item` (string): The name of the item. - `change` (int): The change in stock level (a positive number represents an addition to the stock, and a negative number represents a removal from the stock). The function should return the final inventory as a dictionary with the item names as keys and the updated stock levels as values. Function Signature ```python def update_inventory(initial_inventory: dict, transactions: list) -> dict: ``` Input - `initial_inventory` (dict): The initial inventory with item names as keys and stock levels as values. - `transactions` (list): A list of tuples representing the transactions, where each tuple contains: - `item` (str): The name of the item involved in the transaction. - `change` (int): The change in stock level (positive or negative integer). Output - Returns the final inventory (dict) with item names as keys and updated stock levels as values. Constraints - Items mentioned in transactions will always be present in the initial inventory. - The resulting stock levels should not be negative. If a transaction would result in a negative stock level, set the stock level to zero instead. - The inventory and transactions may contain up to 10^4 items and transactions, respectively. Examples ```python >>> update_inventory({\'apple\': 10, \'banana\': 5, \'orange\': 8}, [(\'apple\', -3), (\'banana\', 2), (\'orange\', -10)]) {\'apple\': 7, \'banana\': 7, \'orange\': 0} >>> update_inventory({\'milk\': 20, \'bread\': 15}, [(\'milk\', 5), (\'bread\', -3), (\'milk\', -25)]) {\'milk\': 0, \'bread\': 12} >>> update_inventory({\'eggs\': 50, \'cheese\': 30}, [(\'eggs\', -50), (\'cheese\', -30)]) {\'eggs\': 0, \'cheese\': 0} ``` In this problem, the inventory update involves simple arithmetic operations while ensuring that the stock levels do not drop below zero.","solution":"def update_inventory(initial_inventory: dict, transactions: list) -> dict: Update the inventory based on a list of transactions. Parameters: initial_inventory (dict): The initial inventory with item names as keys and stock levels as values. transactions (list): A list of tuples representing the transactions, where each tuple contains: - `item` (str): The name of the item involved in the transaction. - `change` (int): The change in stock level (positive or negative integer). Returns: dict: The final inventory with updated stock levels. # Iterate over the transactions and apply the changes to the inventory for item, change in transactions: if item in initial_inventory: initial_inventory[item] += change # Ensure the stock level does not drop below zero if initial_inventory[item] < 0: initial_inventory[item] = 0 return initial_inventory"},{"question":"# Coding Assessment Question A depth-first traversal (DFT) of a binary tree is a core technique in tree-based algorithms, commonly applied in various domains such as artificial intelligence, computational biology, and database indexing. **Objective**: Implement a function to perform a depth-first traversal of a binary tree and verify your implementation by printing nodes in the order they are visited. Requirements: 1. **Tree Node Class**: * Construct a `TreeNode` class representing individual nodes of a binary tree. Each node should contain a value and pointers to its left and right children. 2. **Depth-First Traversal Function**: * Implement a depth-first traversal (`dft`) function that performs an in-order traversal of the binary tree and returns the values of the nodes in an in-order manner. 3. **Traversal Verification**: * Ensure your implementation accurately traverses the tree and handles edge cases such as an empty tree or a tree with a single node. Class Definition ```python class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right ``` Function Definition ```python def dft(root: TreeNode) -> list: Perform an in-order depth-first traversal of the binary tree. :param root: TreeNode - The root node of the binary tree :return: list - A list of values from the tree in in-order # Your implementation here pass ``` Example Usage: ```python # Create a simple binary tree root = TreeNode(1, left=TreeNode(2, right=TreeNode(4)), right=TreeNode(3)) # Perform depth-first traversal and print the result print(dft(root)) # Expected Output: [2, 4, 1, 3] ``` Constraints: 1. The values of the tree nodes should be integers. 2. The tree can have an arbitrary number of levels. 3. Ensure the `dft` function handles null values and empty trees gracefully. 4. Handle cases with various tree structures, such as balanced, unbalanced, and skewed trees. Context: Depth-first traversal is a fundamental algorithm in computer science used to explore tree structures. By implementing this traversal, you demonstrate your understanding of recursive algorithms and efficient tree manipulation techniques.","solution":"class TreeNode: def __init__(self, value: int, left: \'TreeNode\' = None, right: \'TreeNode\' = None): self.value = value self.left = left self.right = right def dft(root: TreeNode) -> list: Perform an in-order depth-first traversal of the binary tree. :param root: TreeNode - The root node of the binary tree :return: list - A list of values from the tree in in-order if root is None: return [] # Traverse left subtree, root, and then right subtree return dft(root.left) + [root.value] + dft(root.right)"},{"question":"# Coding Assessment Question Objective Implement a function to find all prime numbers up to a given number using the Sieve of Eratosthenes algorithm. Problem Statement A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers. For this task, you need to implement the function `find_primes_up_to` that finds all prime numbers less than or equal to the given number `n`. Function Specification ```python def find_primes_up_to(n: int) -> List[int]: Find all prime numbers up to a specified number using the Sieve of Eratosthenes algorithm. Args: - n (int): The upper limit to find primes, inclusive. Returns: - List[int]: A list of all prime numbers up to n. ``` Input * `n` (2 ≤ n ≤ 10^6): The upper limit to find primes, inclusive. Output * Returns a list of integers representing all prime numbers up to `n`. Constraints 1. The function should use the Sieve of Eratosthenes algorithm for optimal performance. Performance Requirements - Must consider efficient handling with an upper constraint of (10^6). Example ```python print(find_primes_up_to(10)) # Expected output: [2, 3, 5, 7] print(find_primes_up_to(30)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] print(find_primes_up_to(50)) # Expected output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] ``` Additional Notes - Ensure the implementation is efficient and correctly follows the Sieve of Eratosthenes algorithm. - Handle edge cases where `n` is the smallest prime number (2).","solution":"from typing import List def find_primes_up_to(n: int) -> List[int]: Find all prime numbers up to a specified number using the Sieve of Eratosthenes algorithm. Args: - n (int): The upper limit to find primes, inclusive. Returns: - List[int]: A list of all prime numbers up to n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0], sieve[1] = False, False # 0 and 1 are not prime numbers p = 2 while p * p <= n: if sieve[p]: for i in range(p * p, n + 1, p): sieve[i] = False p += 1 return [p for p in range(n + 1) if sieve[p]]"},{"question":"# Pascal\'s Triangle Row Generation You are required to implement a function `generate_pascals_triangle_row` in Python that generates a specific row of Pascal\'s Triangle. Your task is to write a function that takes an integer `n` and returns the `n`-th row of Pascal\'s Triangle. **Requirements**: * Your function should be capable of handling large values of `n`. * You are not allowed to generate the entire triangle but only the specific row requested. **Function Specifications**: ```python def generate_pascals_triangle_row(n: int) -> list: Generate the n-th row of Pascal\'s Triangle. pass ``` **Constraints**: * The input `n` should be a non-negative integer. **Example**: ```python print(generate_pascals_triangle_row(0)) # Expected output: [1] print(generate_pascals_triangle_row(3)) # Expected output: [1, 3, 3, 1] print(generate_pascals_triangle_row(5)) # Expected output: [1, 5, 10, 10, 5, 1] ``` **Edge Cases** to Consider: * What happens when `n` is `0`? * Verify the function\'s correctness with large values of `n`. * Confirm that the function handles values of `n` where integer overflow might be a concern.","solution":"def generate_pascals_triangle_row(n: int) -> list: Generate the n-th row of Pascal\'s Triangle. if n == 0: return [1] row = [1] for i in range(1, n + 1): row.append(row[i - 1] * (n - i + 1) // i) return row"},{"question":"# Maximum Subarray Sum using Divide and Conquer Your task is to implement the algorithm to find the maximum sum of a contiguous subarray using the divide and conquer approach. This problem is a classic example known as \\"Maximum Subarray Problem\\" or \\"Kadane\'s Algorithm using Divide and Conquer.\\" **Function Signature:** ```python def max_subarray_sum(nums: List[int]) -> int: pass ``` **Input:** * `nums` (list of integers): The list `nums` contains `n` integers. **Output:** * Returns an integer, which is the maximum sum of the contiguous subarray. **Constraints:** * 1 <= len(nums) <= 10^5 * -10^4 <= nums[i] <= 10^4 **Example:** ```python nums = [-2,1,-3,4,-1,2,1,-5,4] print(max_subarray_sum(nums)) # Output: 6 (subarray [4,-1,2,1] has the maximum sum) ``` **Performance Requirements:** Your implementation should strive for an optimal time complexity of O(n*log(n)). **Additional Context:** The divide and conquer approach splits the array into two halves, recursively finds the maximum subarray sum in each half, and also considers the maximum subarray sum that crosses the midpoint of the array. Combining these results, it determines the overall maximum subarray sum.","solution":"from typing import List def max_crossing_sum(nums: List[int], low: int, mid: int, high: int) -> int: left_sum = float(\'-inf\') total = 0 for i in range(mid, low - 1, -1): total += nums[i] if total > left_sum: left_sum = total right_sum = float(\'-inf\') total = 0 for i in range(mid + 1, high + 1): total += nums[i] if total > right_sum: right_sum = total return left_sum + right_sum def max_subarray_sum_divide_and_conquer(nums: List[int], low: int, high: int) -> int: if low == high: return nums[low] mid = (low + high) // 2 left_sum = max_subarray_sum_divide_and_conquer(nums, low, mid) right_sum = max_subarray_sum_divide_and_conquer(nums, mid + 1, high) cross_sum = max_crossing_sum(nums, low, mid, high) return max(left_sum, right_sum, cross_sum) def max_subarray_sum(nums: List[int]) -> int: if not nums: return 0 return max_subarray_sum_divide_and_conquer(nums, 0, len(nums) - 1)"},{"question":"# Coding Challenge: Sum of Unique Elements **Objective**: Write a function that computes the sum of all unique elements in a list of integers. Function Signature ```python def sum_unique_elements(numbers: List[int]) -> int: pass ``` Input - `numbers` (list): A list of integers. Output - `int`: The sum of all unique integers in the given list. Constraints - The length of the list does not exceed 1000. - Each element in the list is an integer between -10^6 and 10^6. Examples ```python assert sum_unique_elements([1, 2, 2, 3, 4, 5]) == 1 + 3 + 4 + 5 # 13 assert sum_unique_elements([4, 5, 6, 7, 4, 7, 8]) == 5 + 6 + 8 # 19 assert sum_unique_elements([10, 20, 20, 10, 30, 40, 50]) == 30 + 40 + 50 # 120 assert sum_unique_elements([1, 1, 1, 1]) == 0 # No unique elements assert sum_unique_elements([7, 8, 9, 10]) == 7 + 8 + 9 + 10 # 34 ``` # Implementation Notes 1. Initialize an empty dictionary to track the count of each element. 2. Traverse the list and populate the count dictionary. 3. Loop through the dictionary, adding the elements with a count of 1 to the sum. 4. Return the computed sum. Good luck!","solution":"from typing import List def sum_unique_elements(numbers: List[int]) -> int: Returns the sum of all unique elements in a list of integers. # Create a dictionary to store the count of each element count_dict = {} for num in numbers: if num in count_dict: count_dict[num] += 1 else: count_dict[num] = 1 # Calculate the sum of unique elements unique_sum = 0 for num, count in count_dict.items(): if count == 1: unique_sum += num return unique_sum"},{"question":"# Text Summarization using Extractive Methods You are given a collection of documents. Your task is to implement an extractive text summarizer using a simple but effective technique. Specifically, use term frequency-inverse document frequency (TF-IDF) to identify the most significant sentences in each document and assemble a summary. **Function Signature**: ```python def summarize_documents(documents: List[str], summary_length: int) -> List[str]: ``` **Input**: - `documents`: A list of strings, where each string is a document containing multiple sentences. - `summary_length`: An integer representing the number of sentences to be included in the summary for each document. **Output**: - A list of strings, where each string is the summary of the corresponding document, consisting of the `summary_length` most significant sentences. **Constraints**: - Ensure `summary_length` is less than or equal to the number of sentences in each document. - All inputs must be provided in the correct formats and will always contain valid data. - Focus on performance while calculating TF-IDF scores, as documents might be large. Your implementation should: 1. Tokenize each document into sentences. 2. Compute the TF-IDF score for each sentence. 3. Select the top `summary_length` sentences with the highest TF-IDF scores to form the summary. # Example ```python documents = [ \\"The cat in the hat. It sat on the mat. The mat was flat. The cat wore a hat.\\", \\"Dogs are very loyal animals. They bark when they see strangers. Dogs can be trained to perform various tasks.\\" ] summary_length = 2 summaries = summarize_documents(documents, summary_length) print(summaries) ``` Write your implementation for the `summarize_documents` function below, ensuring adherence to the above specifications and requirements.","solution":"from typing import List from sklearn.feature_extraction.text import TfidfVectorizer import numpy as np def summarize_documents(documents: List[str], summary_length: int) -> List[str]: Summarizes each document to the top `summary_length` sentences based on TF-IDF scores. Parameters: - documents: List of strings, each containing a document with multiple sentences. - summary_length: Integer representing the number of sentences to include in the summary. Returns: - A list of strings where each string is a summary of the corresponding document. summaries = [] for doc in documents: sentences = doc.split(\'. \') vectorizer = TfidfVectorizer(stop_words=\'english\') tfidf_matrix = vectorizer.fit_transform(sentences) tfidf_scores = tfidf_matrix.sum(axis=1).A1 # Sum of TF-IDF scores for each sentence # Get indices of the top `summary_length` sentences top_sentence_indices = np.argsort(tfidf_scores)[-summary_length:] top_sentence_indices.sort() # Form the summary by joining the selected sentences summary = \'. \'.join([sentences[i] for i in top_sentence_indices]) if summary and not summary.endswith(\'.\'): summary += \'.\' summaries.append(summary) return summaries"},{"question":"# Coding Assessment Question **Problem Statement:** You are provided with two classes, `Customer` and `Order`, representing a simple order management system. The `Customer` class contains customer details, while the `Order` class contains order details. Your task is to populate an in-memory database of `Customer` and `Order` instances and return a summary of orders for a given list of customers, sorted by the total amount spent in descending order. **Classes Provided:** ```python class Customer: def __init__(self, customer_id: int, name: str): self.customer_id = customer_id self.name = name class Order: def __init__(self, order_id: int, customer_id: int, amount: float): self.order_id = order_id self.customer_id = customer_id self.amount = amount ``` **Objective:** Write a function `customer_order_summary` that takes a list of `Customer` objects and a list of `Order` objects, and returns a list of tuples where each tuple contains a customer\'s name and the total amount spent by that customer, sorted by the total amount spent in descending order. **Function Signature:** ```python def customer_order_summary(customers: List[Customer], orders: List[Order]) -> List[Tuple[str, float]]: ``` **Input:** * `customers`: A list of `Customer` objects. * `orders`: A list of `Order` objects. **Output:** * A list of tuples sorted by the total amount spent in descending order. Each tuple contains: - A string representing the customer\'s name. - A float representing the total amount spent by that customer. **Constraints:** * Each customer has a unique `customer_id`. * Each order has a unique `order_id`. * No customers will have the same name. * It\'s possible that some customers have no orders. * Customers and orders lists may contain zero or more elements. **Example:** ```python customers = [Customer(1, \\"Alice\\"), Customer(2, \\"Bob\\"), Customer(3, \\"Charlie\\")] orders = [Order(101, 1, 29.99), Order(102, 2, 19.99), Order(103, 1, 39.99), Order(104, 3, 9.99)] result = customer_order_summary(customers, orders) print(result) # Output: [(\'Alice\', 69.98), (\'Bob\', 19.99), (\'Charlie\', 9.99)] ``` **Requirements:** 1. Implement the function `customer_order_summary` by iterating through the lists of customers and orders to calculate the total amount spent by each customer. 2. Ensure the results are sorted by the total amount in descending order. 3. Handle edge cases such as customers with no orders and empty input lists. 4. Thoroughly test the function with various inputs, including edge cases.","solution":"from typing import List, Tuple class Customer: def __init__(self, customer_id: int, name: str): self.customer_id = customer_id self.name = name class Order: def __init__(self, order_id: int, customer_id: int, amount: float): self.order_id = order_id self.customer_id = customer_id self.amount = amount def customer_order_summary(customers: List[Customer], orders: List[Order]) -> List[Tuple[str, float]]: # Create a dictionary to map customer_id to total amount spent amount_spent = {customer.customer_id: 0 for customer in customers} # Sum the amounts for each order for order in orders: if order.customer_id in amount_spent: amount_spent[order.customer_id] += order.amount # Create the summary list with customer names and total amount spent summary = [(customer.name, amount_spent[customer.customer_id]) for customer in customers] # Sort the summary list by total amount spent in descending order summary.sort(key=lambda x: x[1], reverse=True) return summary"},{"question":"# Coding Assessment Question: Roman Numeral Converter Context: A Roman numeral is a numeral system originating in ancient Rome. The symbols are: * I = 1 * V = 5 * X = 10 * L = 50 * C = 100 * D = 500 * M = 1000 Given a string representing a Roman numeral, convert it to its integer form. Task: Write a Python function `roman_to_integer` that takes a Roman numeral string and returns its integer value. Input: * A string `roman` representing the Roman numeral (case-insensitive). Output: * An integer representing the numerical value of the Roman numeral. Constraints: * The input string is guaranteed to be a valid Roman numeral. * The Roman numeral string will be between 1 and 15 characters in length. Example: ```python >>> roman_to_integer(\\"III\\") 3 >>> roman_to_integer(\\"IX\\") 9 >>> roman_to_integer(\\"LVIII\\") 58 >>> roman_to_integer(\\"MCMXCIV\\") 1994 >>> roman_to_integer(\\"cd\\") 400 ``` Note: * Roman numerals are usually written largest to smallest from left to right. * The numeral for four is not IIII. Instead, the number four is written as IV. * The numeral for nine is written as IX. * These patterns work for larger numbers as well; for example, forty is written as XL and ninety as XC. Requirements: 1. Ensure your function handles both lowercase and uppercase input by converting the input to uppercase at the beginning. 2. Include logic to handle subtraction cases (e.g., IV, IX, XL, XC, CD, CM). Performance: * The function should run in linear time ( O(n) ) with respect to the length of the Roman numeral string. * Memory usage must be linear as well ( O(n) ). This newly added question should fit seamlessly with the original set, including constraints, clear expectations, and consistent formatting.","solution":"def roman_to_integer(roman): Converts a Roman numeral to an integer. Parameters: roman (str): The Roman numeral to convert. Returns: int: The integer value of the Roman numeral. roman = roman.upper() # Convert input to uppercase to handle case insensitivity roman_dict = { \'I\': 1, \'V\': 5, \'X\': 10, \'L\': 50, \'C\': 100, \'D\': 500, \'M\': 1000 } total = 0 prev_value = 0 for char in roman[::-1]: value = roman_dict[char] if value < prev_value: total -= value else: total += value prev_value = value return total"},{"question":"# Problem Statement You are the lead developer at a logistics company that manages a large fleet of delivery trucks. To improve delivery efficiency, you need to analyze the travel patterns of these trucks. Each travel pattern is represented as a list of integers, with each integer indicating the distance traveled in a straight line between delivery points on a specific day. Your task is to write a function `max_non_adjacent_sum()` that determines the maximum sum of distances that can be achieved by selecting non-adjacent distances from the list, ensuring no two selected distances are next to each other in the list. # Input and Output * **Input**: A list of integers representing travel distances: `distances: List[int]` * **Output**: An integer representing the maximum sum of non-adjacent distances. # Constraints * The list can have up to `10^5` integers. * Each integer in the list is between `0` and `1000`. # Requirements * You cannot select two adjacent distances. * The function should efficiently work with the given constraints. # Example ```python distances = [6, 7, 1, 30, 8, 2, 4] print(max_non_adjacent_sum(distances)) # Output: 41 (7 + 30 + 4) distances = [3, 2, 5, 10, 7] print(max_non_adjacent_sum(distances)) # Output: 15 (3 + 10 + 2) ``` # Task Write a function with the following signature: ```python def max_non_adjacent_sum(distances: List[int]) -> int: # Your code here pass ``` Implement this function to meet the requirements outlined above.","solution":"def max_non_adjacent_sum(distances): Determines the maximum sum of non-adjacent distances from the list. :param distances: List[int] - A list of integers representing travel distances. :return: int - Maximum sum of non-adjacent distances. if not distances: return 0 if len(distances) == 1: return distances[0] incl = distances[0] excl = 0 for i in range(1, len(distances)): new_excl = max(incl, excl) incl = excl + distances[i] excl = new_excl return max(incl, excl)"},{"question":"# Question: Intersection of Two Sorted Arrays You are given two sorted arrays `nums1` and `nums2` in non-decreasing order. Your task is to compute an array that contains only the elements common to both arrays, without duplicates. The result should also be sorted in non-decreasing order. # Function Signature ```python def intersection(nums1: list[int], nums2: list[int]) -> list[int]: ``` # Input - `nums1` (list of int): A list of integers sorted in non-decreasing order. (0 <= len(nums1) <= 1000) - `nums2` (list of int): A list of integers sorted in non-decreasing order. (0 <= len(nums2) <= 1000) # Output - Returns a list of integers representing the intersection of `nums1` and `nums2`, sorted in non-decreasing order. # Constraints 1. `nums1` and `nums2` are both sorted in non-decreasing order. 2. All elements in each array are unique. 3. The resulting array should only contain unique elements. 4. The algorithm should run with minimal time complexity. # Example ```python >>> intersection([1, 2, 2, 3], [2, 2, 3, 4]) [2, 3] >>> intersection([1, 1, 2, 3], [4, 5, 6]) [] >>> intersection([1, 2, 3, 4, 5], [2, 4, 6]) [2, 4] ``` # Explanation - For the first example, the common elements between [1, 2, 2, 3] and [2, 2, 3, 4] are 2 and 3. Since both arrays are sorted and elements are unique within themselves, the result is simply [2, 3]. - For the second example, there are no common elements between [1, 1, 2, 3] and [4, 5, 6], resulting in an empty list. - For the third example, the common elements between [1, 2, 3, 4, 5] and [2, 4, 6] are 2 and 4, resulting in [2, 4].","solution":"def intersection(nums1: list[int], nums2: list[int]) -> list[int]: Returns the intersection of two sorted arrays, with unique elements and sorted in non-decreasing order. # Converting the lists to sets to remove any duplicates and perform set intersection set1 = set(nums1) set2 = set(nums2) # Compute the intersection of two sets intersection_set = set1 & set2 # Convert the result to a sorted list return sorted(list(intersection_set))"},{"question":"# Question: Rotate List You are given a list of integers and an integer k. Your task is to write a function `rotate_list` that rotates the list to the right by k steps. Function Signature ```python def rotate_list(nums: List[int], k: int) -> List[int]: ``` # Input * A list of integers `nums` containing n elements (0 <= n <= 10^5). * An integer `k` (0 <= k <= 10^5), which indicates the number of steps to rotate the list. # Output * A list of integers representing the rotated list. # Constraints * The input list can be empty. * Ensure the function handles edge cases, such as large values of k where k can be much greater than the length of the list. * The function should be efficient with respect to time and space complexity. # Example ```python print(rotate_list([1, 2, 3, 4, 5], 2)) # Output: [4, 5, 1, 2, 3] print(rotate_list([0, 1, 2], 4)) # Output: [2, 0, 1] print(rotate_list([], 3)) # Output: [] ``` # Explanation For `[1, 2, 3, 4, 5]` rotated 2 steps to the right: * List after 1 step: `[5, 1, 2, 3, 4]` * List after 2 steps: `[4, 5, 1, 2, 3]` For `[0, 1, 2]` rotated 4 steps to the right: * Since rotating the list 4 times is equivalent to rotating it 1 time (because 4 % 3 = 1), the list becomes `[2, 0, 1]`. For an empty list, any number of rotations will still be an empty list.","solution":"def rotate_list(nums, k): Rotates the elements of list \'nums\' to the right by \'k\' steps. if not nums: return [] n = len(nums) k = k % n # In case k is greater than n return nums[-k:] + nums[:-k]"},{"question":"# Problem Statement You are tasked with implementing a function `collect_common` that takes two lists of integers and returns a set containing all unique elements that are present in both lists. # Requirements * Your function should validate that both inputs are indeed lists. * The result should be a set containing all unique common elements from both input lists. # Function Signature ```python def collect_common(list_a: list, list_b: list) -> set: ``` # Input * `list_a` (list): A list of integers. (0 <= len(list_a) <= 10^3) * `list_b` (list): A list of integers. (0 <= len(list_b) <= 10^3) # Output * (set): A set of integers containing all unique common elements from `list_a` and `list_b`. # Constraints * If either list is empty, the function should return an empty set. * Both inputs must be lists. The function should assert this as part of its validation process. * Ensure your implementation handles edge cases and optimizes performance where feasible. # Examples ```python >>> collect_common([1, 2, 3, 4], [3, 4, 5, 6]) {3, 4} >>> collect_common([1, 2, 2, 3], [2, 3, 3, 4]) {2, 3} >>> collect_common([1, 2, 3], []) set() ``` # Notes * Ensure the function raises an error if either input is not a list: * Example: `collect_common([1, 2, 3], {1, 2, 3})` should raise an assertion error.","solution":"def collect_common(list_a, list_b): Takes two lists of integers and returns a set containing all unique elements that are present in both lists. assert isinstance(list_a, list), \\"First argument must be a list\\" assert isinstance(list_b, list), \\"Second argument must be a list\\" set_a = set(list_a) set_b = set(list_b) return set_a & set_b"},{"question":"# Problem Statement You are tasked with implementing a function `flatten_dictionary` that recursively flattens a nested dictionary. The nested dictionary can have keys that map to dictionaries, which themselves can have keys that map to dictionaries, and so on. The goal is to flatten this nested dictionary such that each key in the final dictionary corresponds to a path in the original dictionary. # Function Signature ```python def flatten_dictionary(d: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: ``` # Input 1. `d` (dict): A dictionary where each key maps to either another dictionary or a value. 2. `parent_key` (str): A string used to track the current path of keys, default is an empty string (used during the recursion). 3. `sep` (str): A string to separate keys in the path, default is a dot `.`. # Output - Returns a dictionary where each key represents the path to an element in the original nested dictionary. # Constraints - The input dictionary can have any level of nesting. - The keys in the dictionary are strings. - The values in the dictionary can be strings, numbers, or other dictionaries. # Example ```python # Example 1 d = { \'a\': { \'b\': { \'c\': 42 } } } print(flatten_dictionary(d)) # Output: {\'a.b.c\': 42} # Example 2 d = { \'a\': 1, \'b\': { \'c\': 2, \'d\': { \'e\': 3 } } } print(flatten_dictionary(d)) # Output: {\'a\': 1, \'b.c\': 2, \'b.d.e\': 3} ``` # Notes - Make sure to handle the case where the input dictionary is empty. - Ensure your implementation handles deeply nested structures efficiently. - Keys in the flattened dictionary should not end with the separator. # Edge Cases to Consider - An empty dictionary. - A dictionary with varying levels of nested dictionaries. - A dictionary where some values are dictionaries and others are not. # Testing - Include tests to cover typical use cases and edge cases. - Utilize the `doctest` library to verify your solution.","solution":"def flatten_dictionary(d: dict, parent_key: str = \'\', sep: str = \'.\') -> dict: Flattens a nested dictionary. Parameters: d (dict): The dictionary to flatten. parent_key (str): The base key to use for recursion. sep (str): The separator to use between keys. Returns: dict: The flattened dictionary. items = [] for k, v in d.items(): new_key = f\\"{parent_key}{sep}{k}\\" if parent_key else k if isinstance(v, dict): items.extend(flatten_dictionary(v, new_key, sep=sep).items()) else: items.append((new_key, v)) return dict(items)"},{"question":"# Coding Assessment Question Scenario You have been asked to develop a utility for an event management software that assists in distributing invitations evenly across multiple days. The goal is to ensure that each day gets a uniform distribution of events as much as possible. Specifically, you need to create a function that divides a given number of total events into a specified number of days in the fairest way possible. Objectives Implement a function that evenly distributes a number of events across a given number of days and returns the distribution as a list where each element represents the number of events assigned to a respective day. Function Signature ```python def distribute_events(total_events: int, num_days: int) -> list[int]: pass ``` Input * An integer `total_events` representing the total number of events to be distributed. * An integer `num_days` representing the number of days across which the events should be distributed. Output * A list of integers, where each element represents the number of events assigned to each respective day. Constraints * `total_events` will be a non-negative integer (0 ≤ total_events ≤ 10^6). * `num_days` will be a positive integer (1 ≤ num_days ≤ 365). Performance Requirements * The function should run efficiently, with a focus on linear time complexity, O(n), relative to the number of days `num_days`. Examples ```python >>> distribute_events(10, 3) [4, 3, 3] >>> distribute_events(7, 7) [1, 1, 1, 1, 1, 1, 1] >>> distribute_events(0, 5) [0, 0, 0, 0, 0] >>> distribute_events(13, 5) [3, 3, 3, 2, 2] ``` Instructions 1. Design the function to ensure the most uniform distribution of events across the given days. 2. Handle edge cases such as zero events or one day correctly. 3. Ensure the list returned has exactly `num_days` elements, with total events summing up to `total_events`. 4. Do not use any external libraries; rely solely on standard Python functionalities.","solution":"def distribute_events(total_events: int, num_days: int) -> list[int]: Distributes total_events across num_days as evenly as possible. Args: total_events (int): The total number of events to distribute. num_days (int): The number of days to distribute events across. Returns: list[int]: A list of integers where each element represents the number of events assigned to each respective day. # Initialize the base number of events per day base_events = total_events // num_days # Calculate the number of days that will have one extra event extra_events_days = total_events % num_days # Generate the list with base events distribution = [base_events] * num_days # Distribute the extra events across the first \'extra_events_days\' days for i in range(extra_events_days): distribution[i] += 1 return distribution"},{"question":"**Context:** You need to determine the number of ways to climb a staircase with `n` steps where you can take either 1 step, 2 steps, or 3 steps at a time. This is similar to the classic \\"staircase problem,\\" but with an extra constraint: you cannot take the same number of steps consecutively more than twice. **Task:** Implement a function `unique_staircase_climb(n: int) -> int` that calculates the number of distinct ways to climb a staircase with `n` steps, ensuring that no step size is taken more than twice in a row. **Input:** - `n`: An integer representing the number of steps in the staircase. **Output:** - Returns an integer representing the number of unique ways to climb the staircase under the given constraints. **Constraints:** - `0 <= n <= 35` **Examples:** ```python >>> unique_staircase_climb(3) 4 >>> unique_staircase_climb(5) 13 >>> unique_staircase_climb(0) 1 ``` **Instructions:** 1. Implement the `unique_staircase_climb` function in Python. 2. Use dynamic programming or memoization techniques to efficiently solve the problem. 3. Ensure that your implementation handles edge cases and large values of `n` appropriately.","solution":"def unique_staircase_climb(n): Returns the number of unique ways to climb a staircase with \'n\' steps where no step size is taken more than twice consecutively. if n == 0: return 1 if n == 1: return 1 if n == 2: return 2 dp = [0] * (n + 1) dp[0], dp[1], dp[2] = 1, 1, 2 for i in range(3, n + 1): dp[i] = dp[i - 1] + dp[i - 2] + dp[i - 3] return dp[n]"},{"question":"# Question In this task, you will be working on creating various string manipulation and pattern matching functions. These functions are commonly used in text processing and can be essential in many areas including natural language processing, data cleaning, and analysis. Below are the descriptions of the functions you need to implement: 1. **Longest Substring Without Repeating Characters**: Write a function `longest_unique_substring(s: str) -> int` that finds the length of the longest substring without repeating characters. 2. **Word Frequency**: Write a function `word_frequency(text: str) -> Dict[str, int]` that counts the frequency of each word in a given text and returns a dictionary with words as keys and their frequencies as values. Assume words are separated by spaces and are case-insensitive. 3. **Palindromic Substrings**: Write a function `count_palindromic_substrings(s: str) -> int` that returns the number of palindromic substrings in the input string. 4. **Anagram Checker**: Write a function `are_anagrams(s1: str, s2: str) -> bool` that checks whether two strings are anagrams of each other. Anagrams are strings that can be formed by rearranging the characters of another string. 5. **Pattern Matching**: Write a function `pattern_match(text: str, pattern: str) -> bool` that verifies if the entire `text` matches the given `pattern`. The `pattern` may include the wildcard character `*`, which can match any sequence of characters (including an empty sequence). Ensure your functions handle edge cases and optimize for performance where possible. Below are the constraints and expected inputs/outputs for each function: 1. **Longest Substring Without Repeating Characters**: - **Input**: `s` (a non-empty string). - **Output**: An integer representing the length of the longest substring without repeating characters. 2. **Word Frequency**: - **Input**: `text` (a string). - **Output**: A dictionary where keys are words and values are their respective frequencies. 3. **Palindromic Substrings**: - **Input**: `s` (a string). - **Output**: An integer representing the number of palindromic substrings. 4. **Anagram Checker**: - **Input**: `s1` and `s2` (two strings). - **Output**: A boolean indicating whether the two strings are anagrams. 5. **Pattern Matching**: - **Input**: `text` (a string), `pattern` (a string containing wildcards `*`). - **Output**: A boolean indicating whether the text matches the pattern. Provide complete implementations of these functions with proper error handling, taking care of edge cases, performance optimizations, and ensuring correct results for different input scenarios.","solution":"def longest_unique_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i longest = max(longest, i - start + 1) return longest from collections import defaultdict def word_frequency(text: str) -> dict: Counts the frequency of each word in a given text and returns a dictionary with words as keys and their frequencies as values. words = text.lower().split() frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency) def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the input string. def is_palindrome(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return (right - left) // 2 count = 0 for i in range(len(s)): count += is_palindrome(i, i) count += is_palindrome(i, i + 1) return count def are_anagrams(s1: str, s2: str) -> bool: Checks whether two strings are anagrams of each other. return sorted(s1) == sorted(s2) def pattern_match(text: str, pattern: str) -> bool: Verifies if the entire text matches the given pattern. The pattern may include the wildcard character \'*\'. m, n = len(text), len(pattern) dp = [[False] * (n + 1) for _ in range(m + 1)] dp[0][0] = True for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[0][j] = dp[0][j - 1] for i in range(1, m + 1): for j in range(1, n + 1): if pattern[j - 1] == \'*\': dp[i][j] = dp[i][j - 1] or dp[i - 1][j] else: dp[i][j] = dp[i - 1][j - 1] and pattern[j - 1] == text[i - 1] return dp[m][n]"},{"question":"**Context**: You are enhancing the security of a web application by implementing a feature that generates password reset tokens. Each token must be a unique alphanumeric string of a specified length. Additionally, you need to ensure that the tokens are cryptographically secure. **Coding Task**: Write a function named `generate_token` that takes a single parameter: * `length` (an integer, the desired length of the token). Your function should return a string composed of random alphanumeric characters (`0-9`, `a-z`, `A-Z`). Ensure that the random generation is done in a cryptographically secure manner. # Input * The function will be called as: `generate_token(length: int) -> str` * `length` (an integer): The length of the generated token (1 ≤ length ≤ 128) # Output * Return a string, indicating the generated token of the specified length. # Constraints * Use Python\'s `secrets` module to ensure cryptographic security in the token generation process. * Ensure all characters in the generated token are chosen randomly and uniformly. # Example ```python import secrets import string def generate_token(length: int) -> str: # Your implementation here # Example usage print(generate_token(8)) # Output: Some random 8-character string, e.g., \'aB3dE8Fg\' print(generate_token(16)) # Output: Some random 16-character string, e.g., \'4bR7hH1kL8M2pQ9r\' ``` # Explanation * The first example generates an 8-character long token using cryptographically secure methods. * The second example does the same for a 16-character long token. Each token is unique and consists of random alphanumeric characters.","solution":"import secrets import string def generate_token(length: int) -> str: Generates a cryptographically secure random alphanumeric token of the specified length. Parameters: length (int): The desired length of the generated token (1 ≤ length ≤ 128) Returns: str: A randomly generated alphanumeric token of the specified length. if not (1 <= length <= 128): raise ValueError(\\"Length must be between 1 and 128\\") characters = string.ascii_letters + string.digits token = \'\'.join(secrets.choice(characters) for _ in range(length)) return token"},{"question":"# Advanced Coding Assessment Question Context You are developing a dynamic booking system for an event venue that accepts group reservations. The system must efficiently handle booking requests, cancellations, and provide up-to-date occupancy information. Problem Statement Implement a class `EventVenue` that manages bookings for an event venue. The class should efficiently handle three main operations: booking, cancellation, and current occupancy check. 1. Implement the class `EventVenue` with the following functionalities: - `__init__(capacity: int)`: Initializes the venue with a specified total capacity. - `book_reservation(group_size: int)`: Adds a booking for a group of the specified size. If the booking exceeds the available capacity, raise a `ValueError` with the message \\"Not enough capacity\\". - `cancel_reservation(group_size: int)`: Cancels a booking for a group of the specified size. If the cancellation results in negative occupancy, raise a `ValueError` with the message \\"Cannot cancel more than booked\\". - `current_occupancy()`: Returns the current number of booked seats. 2. Ensure proper handling of edge cases: - Handle bookings and cancellations efficiently. - Ensure capacity constraints are respected. - Provide meaningful error messages for invalid operations. Constraints * The maximum capacity of the venue will be 10^6 seats. Function Signatures * `class EventVenue` - `__init__(self, capacity: int) -> None` - `book_reservation(self, group_size: int) -> None` - `cancel_reservation(self, group_size: int) -> None` - `current_occupancy(self) -> int` Input and Output * `EventVenue.__init__(capacity: int)` - **Input**: An integer `capacity` representing the total capacity of the venue. - **Initialization**: Sets the total capacity and initializes current occupancy to 0. * `EventVenue.book_reservation(group_size: int)` - **Input**: An integer `group_size` representing the number of seats to book. - **Output**: None - **Raises**: `ValueError` if booking exceeds available capacity. * `EventVenue.cancel_reservation(group_size: int)` - **Input**: An integer `group_size` representing the number of seats to cancel. - **Output**: None - **Raises**: `ValueError` if cancelling more seats than currently booked. * `EventVenue.current_occupancy()` - **Output**: An integer representing the current number of booked seats. Example Usage ```python # Initialize the venue with a capacity of 100 venue = EventVenue(100) # Book reservations venue.book_reservation(25) venue.book_reservation(30) print(venue.current_occupancy()) # Outputs: 55 # Cancel a reservation venue.cancel_reservation(10) print(venue.current_occupancy()) # Outputs: 45 # Handling edge cases try: venue.book_reservation(60) except ValueError as e: print(e) # Outputs: Not enough capacity try: venue.cancel_reservation(50) except ValueError as e: print(e) # Outputs: Cannot cancel more than booked ``` Please ensure your implementation follows the structure and constraints outlined above.","solution":"class EventVenue: def __init__(self, capacity: int): Initialize the venue with a specified total capacity and sets current occupancy to 0. self.capacity = capacity self.current_booked = 0 def book_reservation(self, group_size: int) -> None: Adds a booking for a group of the specified size. Raises a ValueError if the booking exceeds the available capacity. if self.current_booked + group_size > self.capacity: raise ValueError(\\"Not enough capacity\\") self.current_booked += group_size def cancel_reservation(self, group_size: int) -> None: Cancels a booking for a group of the specified size. Raises a ValueError if the cancellation results in negative occupancy. if self.current_booked - group_size < 0: raise ValueError(\\"Cannot cancel more than booked\\") self.current_booked -= group_size def current_occupancy(self) -> int: Returns the current number of booked seats. return self.current_booked"},{"question":"# Given Context You are working on a software for an e-commerce application that maintains inventory and product catalog. The current implementation of the product catalog supports the addition, update, and deletion of products. You need to extend this functionality to include a search feature that can search for products based on various attributes like name, category, price range, and availability. # Task 1. Implement the `search_product` function to search the product catalog based on multiple search criteria. 2. Use appropriate data structures to ensure that search operations are efficient. # Input and Output Formats * **Function to implement**: * `search_product` - Searches products based on the criteria provided. * **Constraints**: * The catalog will store a significant number of products (up to 10,000). * Products have attributes - \'name\', \'category\', \'price\', and \'available\' (boolean). * The search criteria can include any combination of the attributes. * Ensure that the search can handle partial matches for \'name\' and \'category\'. * Aim to optimize the search time. # Example Scenario Given a product catalog with the following products: ```python products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 999.99, \\"available\\": True}, {\\"name\\": \\"Coffee Maker\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 49.99, \\"available\\": True}, {\\"name\\": \\"LED TV\\", \\"category\\": \\"Electronics\\", \\"price\\": 499.99, \\"available\\": False}, {\\"name\\": \\"Vacuum Cleaner\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 149.99, \\"available\\": True} ] ``` - Calling `search_product(products, name=\\"Lap\\", category=\\"Elect\\", available=True)` should return: ```python [{\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 999.99, \\"available\\": True}] ``` - Calling `search_product(products, price<(100, 200))` should return: ```python [{\\"name\\": \\"Coffee Maker\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 49.99, \\"available\\": True}, {\\"name\\": \\"Vacuum Cleaner\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 149.99, \\"available\\": True}] ``` # Starter Code ```python def search_product(products, **criteria): # Implement multiple search criteria # attributes include - \'name\', \'category\', \'price\', \'available\' results = products for key, value in criteria.items(): if key == \\"price\\": results = [ product for product in results if value[0] <= product[key] <= value[1] ] elif key == \\"name\\" or key == \\"category\\": results = [ product for product in results if value.lower() in product[key].lower() ] elif key == \\"available\\": results = [ product for product in results if product[key] == value ] return results # Example usage products = [ {\\"name\\": \\"Laptop\\", \\"category\\": \\"Electronics\\", \\"price\\": 999.99, \\"available\\": True}, {\\"name\\": \\"Coffee Maker\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 49.99, \\"available\\": True}, {\\"name\\": \\"LED TV\\", \\"category\\": \\"Electronics\\", \\"price\\": 499.99, \\"available\\": False}, {\\"name\\": \\"Vacuum Cleaner\\", \\"category\\": \\"Home Appliances\\", \\"price\\": 149.99, \\"available\\": True} ] print(search_product(products, name=\\"Lap\\", category=\\"Elect\\", available=True)) print(search_product(products, price=(100, 200))) ```","solution":"def search_product(products, **criteria): Searches for products based on the given search criteria. Args: products (list of dict): The product catalog. criteria (dict): The search criteria which may include \'name\', \'category\', \'price\' (as a tuple of (min_price, max_price)), and \'available\'. Returns: list of dict: The list of products that match the search criteria. results = products for key, value in criteria.items(): if key == \\"price\\": results = [ product for product in results if value[0] <= product[\'price\'] <= value[1] ] elif key == \\"name\\" or key == \\"category\\": results = [ product for product in results if value.lower() in product[key].lower() ] elif key == \\"available\\": results = [ product for product in results if product[key] == value ] return results"},{"question":"# Question: Creating a Stack Implementation with Min-Max Tracking Context You are tasked with designing a stack data structure that, in addition to typical stack operations, provides the functionality to retrieve the current minimum and maximum values efficiently. Requirements 1. **Stack Class (`CustomStack`)**: - Should implement standard stack operations: push, pop, and peek. - Should provide a method to retrieve the current minimum value in the stack. - Should provide a method to retrieve the current maximum value in the stack. - Implement the stack using a single list to store elements. 2. **Efficiency Consideration**: - Ensure that the operations to retrieve minimum and maximum values are optimized to run in constant time. Implementation Details - **Input Format**: - Elements to be added: integers. - **Output Format**: - Output of `peek`: the top element of the stack. - Output of `get_min`: the current minimum value in the stack. - Output of `get_max`: the current maximum value in the stack. - **Constraints**: - All elements in the stack are integers. - The stack operations should handle up to 10,000 elements efficiently. Function Signature ```python class CustomStack: def __init__(self): self.stack = [] self.min_stack = [] self.max_stack = [] def push(self, x: int) -> None: pass # Push the element onto the stack def pop(self) -> int: pass # Pop the top element off the stack def peek(self) -> int: pass # Peek the top element without removing it def get_min(self) -> int: pass # Retrieve the current minimum value def get_max(self) -> int: pass # Retrieve the current maximum value # Example Usage: # my_stack = CustomStack() # my_stack.push(3) # my_stack.push(5) # print(my_stack.get_min()) # Output: 3 # print(my_stack.get_max()) # Output: 5 # my_stack.push(2) # my_stack.push(1) # print(my_stack.get_min()) # Output: 1 # print(my_stack.get_max()) # Output: 5 # my_stack.pop() # print(my_stack.peek()) # Output: 2 # print(my_stack.get_min()) # Output: 2 # print(my_stack.get_max()) # Output: 5 ``` Performance Requirements - Ensure the `get_min` and `get_max` methods operate in constant O(1) time complexity.","solution":"class CustomStack: def __init__(self): self.stack = [] self.min_stack = [] self.max_stack = [] def push(self, x: int) -> None: self.stack.append(x) # Maintain the min_stack if not self.min_stack or x <= self.min_stack[-1]: self.min_stack.append(x) # Maintain the max_stack if not self.max_stack or x >= self.max_stack[-1]: self.max_stack.append(x) def pop(self) -> int: if not self.stack: raise IndexError(\\"pop from empty stack\\") top = self.stack.pop() if top == self.min_stack[-1]: self.min_stack.pop() if top == self.max_stack[-1]: self.max_stack.pop() return top def peek(self) -> int: if not self.stack: raise IndexError(\\"peek from empty stack\\") return self.stack[-1] def get_min(self) -> int: if not self.min_stack: raise IndexError(\\"min from empty stack\\") return self.min_stack[-1] def get_max(self) -> int: if not self.max_stack: raise IndexError(\\"max from empty stack\\") return self.max_stack[-1]"},{"question":"# Coding Question: Implement Dijkstra\'s Shortest Path Algorithm You are given a weighted, directed graph represented as an adjacency matrix. Implement the Dijkstra\'s algorithm to find the shortest path from a given source vertex to all other vertices in the graph. Implement the `dijkstra` function. Function Signature ```python def dijkstra(graph: List[List[int]], start_vertex: int) -> List[int]: pass ``` Inputs - `graph (List[List[int]])`: A 2D list representing the adjacency matrix of the graph where `graph[i][j]` is the weight of the edge from vertex `i` to vertex `j`. A value of `0` indicates no edge. - `start_vertex (int)`: An integer representing the starting vertex for Dijkstra\'s algorithm. Outputs - Returns a list of integers where the `i`-th element represents the shortest distance from the `start_vertex` to vertex `i`. Constraints - The number of vertices in the graph is guaranteed to be between `1` and `100`, inclusive. - The weights of the edges are non-negative integers. - There are no negative weight cycles in the graph. Implementation Details 1. Initialize the distance to all vertices as infinity (`float(\'inf\')`), except for the start vertex which should be `0`. 2. Use a priority queue (min-heap) to keep track of the vertices to be processed based on the shortest discovered distance. 3. Extract the vertex with the minimum distance from the priority queue, and update the distances of its adjacent vertices if a shorter path is found. 4. Repeat the process until the priority queue is empty. Example ```python def dijkstra(graph: List[List[int]], start_vertex: int) -> List[int]: import heapq n = len(graph) distances = [float(\'inf\')] * n distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in enumerate(graph[current_vertex]): if weight > 0: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances # Example Test Case graph = [ [0, 1, 4, 0, 0, 0], [1, 0, 4, 2, 7, 0], [4, 4, 0, 3, 5, 0], [0, 2, 3, 0, 4, 6], [0, 7, 5, 4, 0, 7], [0, 0, 0, 6, 7, 0] ] start_vertex = 0 print(dijkstra(graph, start_vertex)) # Output: [0, 1, 4, 3, 7, 9] (example) ``` Hints 1. Use a min-heap to efficiently retrieve the vertex with the smallest distance. 2. Keep track of the vertices whose shortest distance has been finalized to avoid re-processing them. 3. Make sure to update the priority queue correctly when a shorter path to an adjacent vertex is found.","solution":"from typing import List import heapq def dijkstra(graph: List[List[int]], start_vertex: int) -> List[int]: Implements Dijkstra\'s algorithm to find the shortest path from the start_vertex to all other vertices in the graph. :param graph: A 2D list representing the adjacency matrix of the graph. :param start_vertex: The starting vertex for Dijkstra\'s algorithm. :return: A list of distances where the ith element is the shortest distance from the start_vertex to vertex i. n = len(graph) distances = [float(\'inf\')] * n distances[start_vertex] = 0 priority_queue = [(0, start_vertex)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in enumerate(graph[current_vertex]): if weight > 0: # there is an edge distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"# Coding Challenge Implement a function that converts an integer to its Roman numeral representation. Roman numerals are a numeral system originating in ancient Rome. Standard Roman numerals are as follows: - `I` = 1 - `V` = 5 - `X` = 10 - `L` = 50 - `C` = 100 - `D` = 500 - `M` = 1000 Objective Your task is to write a function that converts an integer between 1 and 3999 to a Roman numeral. Requirements - Implement the function `int_to_roman` that takes an integer as input and returns its Roman numeral representation as a string. - The integer input will always be in the range from 1 to 3999, inclusive. Function Signature ```python def int_to_roman(num: int) -> str: pass ``` Input - `num`: An integer in the range [1, 3999]. - Example: 58 Output - A string representing the Roman numeral equivalent of the integer. - Example: \\"LVIII\\" Constraints - The input integer will always lie within the specified range. Example Here is an example of how your function should work: ```python >>> int_to_roman(58) \'LVIII\' >>> int_to_roman(1994) \'MCMXCIV\' ``` Code Template Use the following template to start your implementation: ```python def int_to_roman(num: int) -> str: lookup = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\'), ] roman_numeral = [] for value, symbol in lookup: while num >= value: roman_numeral.append(symbol) num -= value return \'\'.join(roman_numeral) if __name__ == \\"__main__\\": import doctest doctest.testmod() ```","solution":"def int_to_roman(num: int) -> str: lookup = [ (1000, \'M\'), (900, \'CM\'), (500, \'D\'), (400, \'CD\'), (100, \'C\'), (90, \'XC\'), (50, \'L\'), (40, \'XL\'), (10, \'X\'), (9, \'IX\'), (5, \'V\'), (4, \'IV\'), (1, \'I\'), ] roman_numeral = [] for value, symbol in lookup: while num >= value: roman_numeral.append(symbol) num -= value return \'\'.join(roman_numeral)"},{"question":"# Question: Determining the Maximum Path Sum in a Triangle of Numbers **Context**: Given a triangle of numbers, find the maximum total from top to bottom. In every step, one moves to adjacent numbers on the row below. **Task**: Write a function `maximum_path_sum` that takes a list of lists (representing the triangle) and returns the maximum path sum from the top to the bottom. **Function Signature**: ```python def maximum_path_sum(triangle: List[List[int]]) -> int: ``` **Input**: - `triangle` (list of lists of integers): a list where each sublist contains integers representing a row in the triangle. Constraints: The height of the triangle is `1 <= height <= 100`, and each number is `-10^4 <= num <= 10^4`. **Output**: - Returns an integer representing the maximum path sum from the top to the bottom of the triangle. **Example**: ```python assert maximum_path_sum([[2], [4, 5], [1, 2, 6]]) == 11 assert maximum_path_sum([[7], [3, 8], [8, 1, 0], [2, 7, 4, 4], [4, 5, 2, 6, 5]]) == 30 ``` **Explanation**: - For the first example, the path 2 -> 5 -> 6 produces the maximum sum, which is 13. - For the second example, the path 7 -> 3 -> 8 -> 7 -> 5 has the maximum sum of 30. **Detailed Explanation**: To solve this problem, start from the bottom of the triangle and move upwards, updating each element to be the sum of itself and the maximum of the two elements directly below it. Continue this process until you reach the top of the triangle. The value at the top will then be the maximum path sum.","solution":"from typing import List def maximum_path_sum(triangle: List[List[int]]) -> int: Returns the maximum path sum from top to bottom of the given triangle. # Work on a copy to avoid modifying the original triangle dp = [row[:] for row in triangle] # Start from the second last row and move upwards for row in range(len(dp) - 2, -1, -1): for col in range(len(dp[row])): dp[row][col] += max(dp[row + 1][col], dp[row + 1][col + 1]) # The top element now contains the maximum path sum return dp[0][0]"},{"question":"# Fibonacci Search Optimization Problem Statement: In this assessment, you are required to implement an optimized version of the Fibonacci search algorithm. This algorithm is particularly useful for searching in sorted arrays and can be more efficient than binary search for certain types of data. Input: * A sorted list of integers. * An integer value to search for within the list. Output: * The index of the integer value if it exists within the list, otherwise -1. Constraints: * The length of the list won\'t exceed 100,000 entries. * The integer values within the list and the search value will be within the range of -10^6 to 10^6. Requirements: * Implement the Fibonacci search algorithm which utilizes Fibonacci numbers to foster an efficient search logic. * Optimize to ensure that the search performs in O(log n) time complexity in the average and worst cases. Example: ```python Input: List: [-10, -3, 0, 1, 4, 8, 12, 19, 24, 32, 45], Search Value: 19 Output: 7 Input: List: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21], Search Value: 4 Output: -1 ``` Hints: 1. Understand how Fibonacci numbers can be used to split the list into subdivisions. 2. Pay attention to edge cases such as an empty list or when the search value is not present in the list. --- The question demands both understanding of a non-trivial search algorithm and its efficient implementation, aligning both with the complexity and the algorithmic nature of the sample questions.","solution":"def fibonacci_search(arr, x): Performs Fibonacci search for x in array arr :param arr: List[int] - sorted list of integers :param x: int - integer value to search for :return: int - index of x if found, else -1 n = len(arr) # Initialize the fibonacci numbers fib_m2 = 0 # (m-2)\'th Fibonacci No. fib_m1 = 1 # (m-1)\'th Fibonacci No. fib_m = fib_m1 + fib_m2 # mth Fibonacci # fib_m is the smallest Fibonacci number greater than or equal to n while fib_m < n: fib_m2 = fib_m1 fib_m1 = fib_m fib_m = fib_m1 + fib_m2 # Marks the eliminated range from the front offset = -1 while fib_m > 1: # Check if fib_m2 is a valid location i = min(offset + fib_m2, n-1) # If x is greater than the value at index fib_m2, cut the subarray array from offset to i if arr[i] < x: fib_m = fib_m1 fib_m1 = fib_m2 fib_m2 = fib_m - fib_m1 offset = i # If x is less than the value at index fib_m2, cut the subarray after i+1 elif arr[i] > x: fib_m = fib_m2 fib_m1 = fib_m1 - fib_m2 fib_m2 = fib_m - fib_m1 # element found. return index else: return i # comparing the last element with x if fib_m1 and offset + 1 < n and arr[offset + 1] == x: return offset + 1 # element not found. return -1 return -1"},{"question":"# Palace Lighting Scheduling **Context:** You are employed as the manager for lighting systems in a historical palace. Each room in the palace must have its lighting scheduled and turned on in a specific order depending on preparation tasks. The dependency orders are represented by a directed graph where an edge from A to B implies A must have its lighting prepared before B. Your goal is to determine a valid ordering for lighting preparations of the rooms. **Problem Statement:** Implement a function `lighting_schedule(graph, rooms)` that receives: 1. A directed acyclic graph `graph` representing the dependencies between the lighting preparations of the rooms. 2. A dictionary `rooms` mapping room indices to room names. Your function should output the order in which the lighting preparations should be done according to the dependencies. **Function Signature:** ```python def lighting_schedule(graph: List[List[int]], rooms: Dict[int, str]) -> List[str]: pass ``` **Input:** - `graph`: A list of lists representing the adjacency list of the directed acyclic graph. - `rooms`: A dictionary mapping indices to room names. **Output:** - A list of room names in the order their lighting preparations should be done. **Constraints:** - The graph is guaranteed to be acyclic. - The number of rooms (vertices) is at most 15. **Example:** ```python # Example input graph = [[1, 2], [3], [3], [], [0, 1], [4, 6], [7], [5, 3], []] rooms = { 0: \\"Entrance Hall\\", 1: \\"Throne Room\\", 2: \\"Gallery\\", 3: \\"Grand Ballroom\\", 4: \\"Library\\", 5: \\"Kitchen\\", 6: \\"Garden\\", 7: \\"Chapel\\", 8: \\"Dungeon\\", } # Example output [\\"Dungeon\\", \\"Entrance Hall\\", \\"Gallery\\", \\"Throne Room\\", \\"Grand Ballroom\\", \\"Library\\", \\"Kitchen\\", \\"Garden\\", \\"Chapel\\"] ``` **Notes:** - Your function must ensure that the lighting preparation list respects the dependency order given in the `graph`. - Handle edge cases, such as nodes without dependencies correctly.","solution":"from typing import List, Dict def lighting_schedule(graph: List[List[int]], rooms: Dict[int, str]) -> List[str]: def topological_sort(node, visited, stack): visited[node] = True for neighbor in graph[node]: if not visited[neighbor]: topological_sort(neighbor, visited, stack) stack.append(node) num_rooms = len(rooms) visited = [False] * num_rooms stack = [] for i in range(num_rooms): if not visited[i]: topological_sort(i, visited, stack) ordered_indices = stack[::-1] result = [rooms[idx] for idx in ordered_indices] return result"},{"question":"Challenge: Balanced String Splits You are required to implement a function, `balanced_string_splits`, that calculates the number of balanced substrings that can be obtained from a given string. A string is considered balanced if it contains an equal number of \'R\' and \'L\' characters. # Function Signature ```python def balanced_string_splits(s: str) -> int: ``` # Input - `s` (str): A non-empty string consisting only of the characters \'R\' and \'L\'. # Output - (int): The number of balanced substrings that can be obtained from the given string. # Constraints - The length of `s` will not exceed 100,000. # Error Handling - Raise a `ValueError` if `s` is not a string or if it contains characters other than \'R\' and \'L\'. # Examples ```python assert balanced_string_splits(\\"RLRRLLRLRL\\") == 4 assert balanced_string_splits(\\"RLLLLRRRLR\\") == 3 assert balanced_string_splits(\\"LLLLRRRR\\") == 1 assert balanced_string_splits(\\"RLRRLLR\\") == 2 ``` # Explanation - `balanced_string_splits(\\"RLRRLLRLRL\\")` returns `4` because: - The balanced substrings are \\"RL\\", \\"RRLL\\", \\"RL\\", and \\"RL\\". - `balanced_string_splits(\\"RLLLLRRRLR\\")` returns `3` because: - The balanced substrings are \\"RL\\", \\"LLLRRR\\", and \\"LR\\". # Additional Notes - Ensure to handle edge cases where the string may consist entirely of \'R\'s or \'L\'s before becoming balanced. - Aim for an efficient solution that iterates through the string in a single pass.","solution":"def balanced_string_splits(s: str) -> int: Calculates the number of balanced substrings that can be obtained from the given string. A string is considered balanced if it contains an equal number of \'R\' and \'L\' characters. Parameters: s (str): A non-empty string consisting only of the characters \'R\' and \'L\'. Returns: int: The number of balanced substrings that can be obtained from the given string. if not isinstance(s, str): raise ValueError(\\"Input must be a string\\") if any(c not in \'RL\' for c in s): raise ValueError(\\"String can only contain \'R\' and \'L\'\\") count = 0 balance = 0 for char in s: if char == \'R\': balance += 1 elif char == \'L\': balance -= 1 if balance == 0: count += 1 return count"},{"question":"# Question: Efficient Fibonacci Sequence Calculation Background: Fibonacci numbers form a sequence where each number is the sum of the two preceding ones, starting from 0 and 1. The sequence goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on. Efficient calculation of Fibonacci numbers is important in various computational problems involving algorithms, number theory, and dynamic programming. Requirements: 1. Implement a function `efficient_fibonacci(n: int) -> int` that returns the nth Fibonacci number. 2. The function should be optimized to handle large values of `n`. Input: - An integer `n` where `0 <= n <= 10^7`. Output: - Return the nth Fibonacci number. Constraints: - The function should raise a `ValueError` if the input is not a non-negative integer. Examples: ```python assert efficient_fibonacci(0) == 0 assert efficient_fibonacci(1) == 1 assert efficient_fibonacci(2) == 1 assert efficient_fibonacci(3) == 2 assert efficient_fibonacci(4) == 3 assert efficient_fibonacci(7) == 13 assert efficient_fibonacci(10) == 55 assert efficient_fibonacci(20) == 6765 assert efficient_fibonacci(50) == 12586269025 ``` Hints: - Utilize dynamic programming or matrix exponentiation techniques to optimize the calculation. - Avoid purely recursive solutions as they may not perform efficiently for large `n`. - Consider using memoization to store previously computed Fibonacci numbers and avoid redundant calculations.","solution":"def efficient_fibonacci(n: int) -> int: if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return 0 elif n == 1: return 1 def matrix_mult(A, B): return [ [A[0][0] * B[0][0] + A[0][1] * B[1][0], A[0][0] * B[0][1] + A[0][1] * B[1][1]], [A[1][0] * B[0][0] + A[1][1] * B[1][0], A[1][0] * B[0][1] + A[1][1] * B[1][1]] ] def matrix_pow(matrix, power): result = [[1, 0], [0, 1]] # Identity matrix base = matrix while power: if power % 2 == 1: result = matrix_mult(result, base) base = matrix_mult(base, base) power //= 2 return result F = [[1, 1], [1, 0]] result_matrix = matrix_pow(F, n - 1) return result_matrix[0][0]"},{"question":"# Coding Assessment Question Objective Implement a function to find the k most frequent words in a text file. Your solution should efficiently handle large texts while maintaining correct word frequency counts. Task Write a function `top_k_frequent_words(file_path: str, k: int) -> List[str]` which reads a text file and returns a list of the k most frequent words. Input and Output Format **Input**: - `file_path`: A string representing the path to the text file. - `k`: An integer representing the number of most frequent words to return. **Output**: - The function should return a list of strings, each being one of the k most frequent words in the text file. Words must be in descending order of frequency. If two words have the same frequency, they should appear in lexicographical order. Constraints - Words are defined as sequences of alphabetic characters. - The function should ignore punctuation and be case insensitive. - The function should handle large text files efficiently. Performance Requirements - The function should run efficiently with a time complexity of O(n log k), where n is the number of words in the file. Example ```python from typing import List from collections import Counter import re def top_k_frequent_words(file_path: str, k: int) -> List[str]: Function to find the k most frequent words in a text file. with open(file_path, \'r\') as file: text = file.read().lower() words = re.findall(r\'b[a-z]+b\', text) counter = Counter(words) # Retrieve the k most common words, sorted by frequency and then alphabetically most_common = sorted(counter.items(), key=lambda x: (-x[1], x[0]))[:k] return [word for word, freq in most_common] # Example usage: # Assuming \\"text.txt\\" contains \\"Hello world. Hello everyone. It\'s a wonderful world.\\" # top_k_frequent_words(\\"text.txt\\", 2) should return [\'hello\', \'world\'] ``` Scenario Imagine you are working on a text analytics tool where users need to know the most frequently used words in large documents for better insight into the content\'s trends. Your task is to implement the core functionality that identifies the most frequent words from a given text. Use the provided `top_k_frequent_words` function template to complete this task.","solution":"from typing import List from collections import Counter import re def top_k_frequent_words(file_path: str, k: int) -> List[str]: Function to find the k most frequent words in a text file. # Read the file content and convert it to lowercase with open(file_path, \'r\', encoding=\'utf-8\') as file: text = file.read().lower() # Find all words (sequences of alphabetic characters) words = re.findall(r\'b[a-z]+b\', text) # Count the frequency of each word counter = Counter(words) # Retrieve the k most common words, sorted by frequency and then alphabetically most_common = sorted(counter.items(), key=lambda x: (-x[1], x[0]))[:k] return [word for word, _ in most_common]"},{"question":"**Problem Description**: You are asked to implement a function that determines if a given string is a valid representation of a hexadecimal number. A hexadecimal number can include the digits `0-9` and letters `a-f` or `A-F`, without any prefixes like `0x`. **Function Signature**: ```python def is_valid_hexadecimal(s: str) -> bool: Returns True if the string is a valid hexadecimal number, False otherwise. :param s: String, the input string to be checked :return: Boolean, True if the string is a valid hexadecimal number, False otherwise ``` **Input and Output**: - **Input**: A string `s` (1 ≤ len(s) ≤ 10^6), representing the potential hexadecimal number. - **Output**: A boolean value indicating whether the string is a valid hexadecimal number. **Constraints**: - The function should efficiently handle strings up to a length of 1,000,000 characters. **Example**: ```python assert is_valid_hexadecimal(\\"1A3F\\") == True assert is_valid_hexadecimal(\\"GHIJ\\") == False assert is_valid_hexadecimal(\\"123abc\\") == True assert is_valid_hexadecimal(\\"\\") == False assert is_valid_hexadecimal(\\"0\\") == True assert is_valid_hexadecimal(\\"abcdefABCDEF0123456789\\") == True ``` **Requirements**: - You should handle both uppercase and lowercase hexadecimal digits. - Focus on performance: ensure your function can handle the upper limit efficiently. **Scenario**: You are developing a feature for a data processing system where users can input strings that represent hexadecimal numbers. Validating these hexadecimal inputs is crucial before any further processing is performed. **Note**: Ensure your implementation is efficient and can handle the upper limits as described.","solution":"def is_valid_hexadecimal(s: str) -> bool: Returns True if the string is a valid hexadecimal number, False otherwise. :param s: String, the input string to be checked :return: Boolean, True if the string is a valid hexadecimal number, False otherwise if len(s) == 0: return False for char in s: if not ((\'0\' <= char <= \'9\') or (\'a\' <= char <= \'f\') or (\'A\' <= char <= \'F\')): return False return True"},{"question":"# Implementing a Trie for Word Search In this task, you are to implement a Trie (prefix tree) and use it to perform word search operations efficiently. Tries are useful for quickly finding and storing words by their prefixes. Task 1: Trie Construction Write a class `Trie` that supports the following methods: - `insert(word: str) -> None`: Inserts a word into the Trie. - `search(word: str) -> bool`: Returns True if the word exists in the Trie, otherwise returns False. - `starts_with(prefix: str) -> bool`: Returns True if there is any word in the Trie that starts with the given prefix, otherwise returns False. Task 2: Word Search in a 2D Board Additionally, implement a function `exist(board: list[list[str]], word: str) -> bool` that takes a 2D board of characters and a word, and returns True if the word exists in the grid. You can search for the word in the board by starting from any cell and moving in four possible directions (up, down, left, right). The same letter cell may not be used more than once in a word. Input: 1. A 2D board of characters, `board: list[list[str]]`. 2. A word, `word: str`. Output: 1. Returns True if the word exists in the board, otherwise returns False. Example: ```python # Given board board = [ [\'A\', \'B\', \'C\', \'E\'], [\'S\', \'F\', \'C\', \'S\'], [\'A\', \'D\', \'E\', \'E\'] ] # Target word to search for word = \\"ABCCED\\" # Expected output output = exist(board, word) # Output: True ``` Constraints: - The dimensions of the board `m` and `n` will be such that `1 ≤ m, n ≤ 200`. - The length of the word `word` will be such that `1 ≤ len(word) ≤ 1000`. Performance Requirements: - Aim for efficient Trie operations (`insert`, `search`, `starts_with`) with time complexity O(W) where W is the length of the word. - The word search in the grid should be performed using backtracking with time complexity O(m*n*4^L) where L is the length of the word.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): self.root = TrieNode() def insert(self, word: str) -> None: node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: node = self.root for char in word: if char not in node.children: return False node = node.children[char] return node.is_end_of_word def starts_with(self, prefix: str) -> bool: node = self.root for char in prefix: if char not in node.children: return False node = node.children[char] return True def exist(board: list[list[str]], word: str) -> bool: rows, cols = len(board), len(board[0]) def backtrack(r, c, idx): if idx == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[idx]: return False temp, board[r][c] = board[r][c], \'#\' found = (backtrack(r+1, c, idx+1) or backtrack(r-1, c, idx+1) or backtrack(r, c+1, idx+1) or backtrack(r, c-1, idx+1)) board[r][c] = temp return found for row in range(rows): for col in range(cols): if backtrack(row, col, 0): return True return False"},{"question":"# Longest Common Subsequence Challenge You are required to implement a function to find the longest common subsequence (LCS) of two given strings. The LCS problem is a classic computer science problem that requires dynamic programming to solve efficiently. Description: Implement a function `longest_common_subsequence(str1, str2)` which returns the length of the longest common subsequence between `str1` and `str2`. Input: - `str1`: A string containing alphanumeric characters. - `str2`: A string containing alphanumeric characters. Output: - Returns an integer representing the length of the longest common subsequence. Constraints: - 1 <= len(str1), len(str2) <= 1000 Requirements: - Your implementation must use dynamic programming to efficiently compute the LCS. - Handle edge cases where either of the strings might be empty. - Ensure optimal performance for the maximum input size. Additional Details: 1. The LCS of two strings is the longest sequence that can be derived from both strings by deleting some or no characters. 2. Consider using a 2D array to store the lengths of LCS up to each index of the strings. You are provided with a sample input and expected output below for reference: Sample Input: ```python str1 = \\"ABCBDAB\\" str2 = \\"BDCAB\\" ``` Sample Output: ```python 4 ``` Explanation: The LCS is \\"BCAB\\" or \\"BDAB\\", both of length 4. Implement the `longest_common_subsequence` function accordingly. Starter Code: ```python def longest_common_subsequence(str1, str2): # Your code here pass ```","solution":"def longest_common_subsequence(str1, str2): Returns the length of the longest common subsequence between str1 and str2. m, n = len(str1), len(str2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Filling the dp array for i in range(1, m + 1): for j in range(1, n + 1): if str1[i-1] == str2[j-1]: dp[i][j] = dp[i-1][j-1] + 1 else: dp[i][j] = max(dp[i-1][j], dp[i][j-1]) return dp[m][n]"},{"question":"# Question Context You are tasked with implementing a function that merges two sorted lists into one sorted list. The function should handle edge cases such as empty input lists and lists with different lengths. # Problem Statement Implement a function called `merge_sorted_lists` in Python that takes two sorted lists and merges them into a single sorted list. You must ensure the function is correct by writing thorough unit tests using Python’s `unittest` framework. # Requirements 1. **Function Definition**: ```python def merge_sorted_lists(list1: list, list2: list) -> list: pass ``` 2. **Behavior**: - The function should merge the two input lists, `list1` and `list2`, which are already sorted in non-decreasing order. - The output should be a single sorted list that contains all elements from `list1` and `list2`. 3. **Testing Requirements**: - Create unit tests using Python’s `unittest` framework. - Test scenarios should include: - Normal cases with varying sizes of `list1` and `list2`. - Edge cases where one or both input lists are empty. - Cases where input lists contain duplicate elements. - Cases where the lists are of different lengths. # Expected Input and Output Formats - **Input**: - `list1`: A list of integers, sorted in non-decreasing order. - `list2`: A list of integers, sorted in non-decreasing order. - **Output**: A new list containing all elements from `list1` and `list2`, sorted in non-decreasing order. # Constraints - The function should be efficient with a time complexity of O(n + m), where n is the length of `list1` and m is the length of `list2`. # Performance Requirements - The function should handle merging operations within reasonable time constraints, ensuring scalability with increased input sizes. # Implementation You are required to implement the `merge_sorted_lists` function and write comprehensive unit tests based on the outlined specifications.","solution":"def merge_sorted_lists(list1: list, list2: list) -> list: Merges two sorted lists into a single sorted list. result = [] i, j = 0, 0 while i < len(list1) and j < len(list2): if list1[i] <= list2[j]: result.append(list1[i]) i += 1 else: result.append(list2[j]) j += 1 # Add remaining elements result.extend(list1[i:]) result.extend(list2[j:]) return result"},{"question":"# Question: Rotate Matrix Clockwise by 90 Degrees Scenario You are working with 2D matrices and have encountered a situation in which you need to rotate a given matrix by 90 degrees clockwise. Efficient matrix manipulation is essential in many computational problems, including image processing and game development. Task Implement a function `rotate_matrix(matrix: list) -> list` that rotates a given `n x n` matrix by 90 degrees in a clockwise direction. Input * `matrix`: A 2D list representing an `n x n` matrix of integers, where `0 <= n <= 10`. Output * A 2D list representing the rotated `n x n` matrix. Constraints * The input matrix will always be square (same number of rows and columns). * Your implementation should perform the rotation in-place if possible to minimize space complexity. Performance Requirements * Your solution should aim to operate within O(n^2) time complexity and O(1) extra space complexity. Example 1. Input: `[[1]]` Output: `[[1]]` 2. Input: `[[1, 2], [3, 4]]` Output: `[[3, 1], [4, 2]]` 3. Input: `[[1, 2, 3], [4, 5, 6], [7, 8, 9]]` Output: `[[7, 4, 1], [8, 5, 2], [9, 6, 3]]` Edge Cases to Consider * Empty matrix * Single-element matrix * Matrix with negative numbers or zeros (e.g., `[[0, -1], [-2, 3]]`) Additional Challenge Modify the function to support rotating the matrix by 180 and 270 degrees as well, based on an additional parameter. Example Code Template: ```python def rotate_matrix(matrix: list) -> list: pass # Example usage: # result = rotate_matrix([[1, 2], [3, 4]]) # print(result) # Output should be [[3, 1], [4, 2]] ```","solution":"def rotate_matrix(matrix: list) -> list: Rotates a given n x n matrix by 90 degrees clockwise. n = len(matrix) if n == 0: return matrix # Perform the rotation in-place for i in range(n // 2): for j in range(i, n - i - 1): # Store the value of one element temporarily temp = matrix[i][j] # Move values from left to top matrix[i][j] = matrix[n - j - 1][i] # Move values from bottom to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # Move values from right to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # Assign temp to right matrix[j][n - i - 1] = temp return matrix"},{"question":"# Scenario: You are designing a simple simulation for a turn-based strategy game where various characters with different abilities take turns to attack. Each character has an associated health value, and the game should track the health dynamically as characters take damage until only one character remains. # Task: Build a simulation system for the turn-based game with characters having health parameters and attack actions. Your implementation should allow initializing the game with characters, simulating turns where characters take damage, and determining when the game ends (i.e., only one character is left standing). # Requirements: 1. **Initialization**: Initialize the game with a list of characters, each having a unique ID and an initial health value. 2. **Methods**: * `attack(attacker_id, target_id, damage)`: Simulate an attack where the target character\'s health is reduced by the specified damage value. * `is_game_over()`: Check and return a boolean indicating whether only one character remains with health above zero. * `get_remaining_characters()`: Return a list of character IDs that are still in the game (health > 0). 3. **Constraints**: * Assume character IDs are integers. * Health values are positive integers. * If a character\'s health drops to zero or below, they are considered out of the game. * Ensure no attacks are made on already defeated characters. # Input Format: - Initialization parameters: * A list of tuples, each containing a character ID and health value: `[(id1, health1), (id2, health2), ...]` - For `attack` method: * `attacker_id`: Integer ID of the attacking character. * `target_id`: Integer ID of the target character. * `damage`: Integer value of the damage inflicted. # Output Format: - `attack`: No return value. - `is_game_over`: Boolean indicating if the game has ended. - `get_remaining_characters`: List of integer IDs representing remaining characters. # Example: ```python # Initializing the game with characters game = GameSimulation([(1, 100), (2, 80), (3, 120)]) # Characters taking turns to attack game.attack(1, 2, 30) # Character 1 attacks character 2 with 30 damage game.attack(3, 1, 50) # Character 3 attacks character 1 with 50 damage game.attack(2, 3, 40) # Character 2 attacks character 3 with 40 damage # Check remaining characters print(game.get_remaining_characters()) # Expected output: [1, 2, 3] # Determine if the game is over print(game.is_game_over()) # Expected output: False (since there are still multiple characters with positive health) # More attacks game.attack(1, 3, 100) # This attack can eliminate character 3 if health drops to 0 or below # Final check print(game.get_remaining_characters()) # Expected output: [1, 2] or similar, depending on remaining health print(game.is_game_over()) # Expected output: False or True if only one character remains ``` Implement the `GameSimulation` class in Python with the given specifications.","solution":"class GameSimulation: def __init__(self, characters): Initialize the game with a list of tuples. Each tuple contains a character ID and initial health value. self.characters = {char_id: health for char_id, health in characters} def attack(self, attacker_id, target_id, damage): Simulate an attack where the target character\'s health is reduced by the specified damage value. if target_id in self.characters and self.characters[target_id] > 0: self.characters[target_id] -= damage if self.characters[target_id] <= 0: self.characters[target_id] = 0 # Character is considered out def is_game_over(self): Check and return whether only one character remains with health above zero. remaining_characters = [health for health in self.characters.values() if health > 0] return len(remaining_characters) <= 1 def get_remaining_characters(self): Return a list of character IDs that are still in the game (health > 0). return [char_id for char_id, health in self.characters.items() if health > 0]"},{"question":"# Question: Finding First Duplicated Element in an Array Context: You are given an array of integers. Your task is to find the first element that appears more than once in the array. If no such element exists, return `None`. Instead of using a nested loop (brute force approach), you are required to implement an efficient algorithm that leverages auxiliary data structures to reduce time complexity. Requirements: 1. Implement a function `first_duplicate(array: list[int]) -> int | None` that returns the first duplicated element in the array or `None` if there are no duplicates. 2. The function should efficiently identify the first duplicate by leveraging appropriate data structures. Input: - `array`: A list of integers. Example: `[2, 1, 3, 5, 3, 2]` Output: - An integer representing the first duplicated element or `None` if no duplicates exist. Constraints: - The length of the array will not exceed `1000`. - The elements of the array are within the range of valid integer values in Python. - The solution should avoid using nested iteration to achieve better performance. Performance Requirements: - Time complexity should be O(n). - Space complexity should be O(n). Example: ```python arr = [2, 1, 3, 5, 3, 2] first_duplicate(arr) # Output should be 3 arr = [2, 1, 5, 3] first_duplicate(arr) # Output should be None ``` Scenario: Imagine you are analyzing log files to identify repeated IP addresses. The first repeated entry might indicate an anomaly or repeated access by a particular user. Using this function can help you quickly pinpoint such entries without needing to manually check each pair of IP addresses. Write your implementation in Python and make sure to handle edge cases as outlined.","solution":"def first_duplicate(array): Returns the first duplicate element in the array. If no duplicates are found, returns None. seen = set() for element in array: if element in seen: return element seen.add(element) return None"},{"question":"# Integer Array Cyclic Rotation **Objective:** Implement the `cyclic_rotate` function that performs a cyclic rotation on an array of integers. This function should move each element of the array one position to the right, with the last element wrapping around to the start of the array. **Function Signature:** ```python def cyclic_rotate(arr: list[int]) -> list[int]: ``` **Parameters:** - `arr` (list of int): The list of integers to be rotated. **Returns:** - A list of integers representing the rotated array. **Constraints:** 1. The elements in the list `arr` can be negative, zero, or positive integers. 2. The function should handle empty arrays gracefully by returning an empty list. 3. Aim for an in-place solution if possible. **Example Usage:** ```python >>> cyclic_rotate([]) [] >>> cyclic_rotate([1]) [1] >>> cyclic_rotate([1, 2, 3]) [3, 1, 2] >>> cyclic_rotate([0, -1, 2, -3, 4]) [4, 0, -1, 2, -3] >>> cyclic_rotate([7, 14, 28, 35]) [35, 7, 14, 28] ``` **Performance Requirements:** - The implementation should efficiently handle large arrays. - Ensure minimal additional space usage by attempting an in-place modification. **Instructions:** 1. If the array is empty, return an empty list. 2. For a non-empty array, perform the cyclic rotation by shifting elements. 3. Ensure the last element wraps around to the start of the array. **Additional Information:** - Do not use any built-in functions that specifically perform rotations. - You may use temporary variables where necessary to facilitate the rotation. - Consider edge cases such as arrays with a single element or arrays with all identical elements.","solution":"def cyclic_rotate(arr: list[int]) -> list[int]: Performs a cyclic rotation on the array of integers. Each element of the array is moved one position to the right, with the last element wrapping around to the start of the array. Parameters: arr (list of int): The list of integers to be rotated. Returns: list[int]: The rotated list of integers. n = len(arr) if n <= 1: return arr last_element = arr[-1] for i in range(n-1, 0, -1): arr[i] = arr[i-1] arr[0] = last_element return arr"},{"question":"# Problem Statement You are given a binary matrix `mat` containing only 0s and 1s, where each row and column are sorted in ascending order. Write a function `binary_matrix_search` that searches for a target value in this matrix using an efficient algorithm. Function Signature ```python def binary_matrix_search(mat: list[list[int]], target: int) -> bool: pass ``` Input * `mat` (list of list of int): A binary matrix (0 ≤ len(mat) ≤ 10^3, 0 ≤ len(mat[i]) ≤ 10^3, mat[i] is sorted in ascending order). * `target` (int): The value to search for in the matrix. Output * `bool`: Returns `True` if the target value exists in the matrix and `False` otherwise. Constraints * The rows and columns of the matrix are sorted in ascending order. * Aim for a solution with an average or worst-case time complexity of O(m + n), where m is the number of rows and n is the number of columns. Performance Requirements * Ensure the solution is efficient for larger matrix sizes. Example ```python # Example 1 mat = [[0, 0, 1, 2, 3], [0, 1, 1, 3, 4], [1, 1, 2, 4, 5], [2, 3, 4, 5, 6]] target = 4 # Explanation: The target 4 exists in the matrix. assert binary_matrix_search(mat, target) == True # Example 2 mat = [[0, 0, 1, 2, 3], [0, 1, 1, 3, 4], [1, 1, 2, 4, 5], [2, 3, 4, 5, 6]] target = 7 # Explanation: The target 7 does not exist in the matrix. assert binary_matrix_search(mat, target) == False ``` Notes * The matrix is guaranteed to have rows and columns sorted in ascending order. * A potential approach to solve this problem would be to start from the top-right corner and move in either row or column directions based on the comparison between the current element and the target value.","solution":"def binary_matrix_search(mat, target): Searches for a target value in a given binary matrix where each row and column are sorted in ascending order. :param mat: list of list of int representing the binary matrix :param target: int, the value to search for in the matrix :return: bool, True if the target exists in the matrix, False otherwise if not mat or not mat[0]: return False rows, cols = len(mat), len(mat[0]) row, col = 0, cols - 1 while row < rows and col >= 0: if mat[row][col] == target: return True elif mat[row][col] > target: col -= 1 else: row += 1 return False"},{"question":"# Scenario: You are working as a software engineer for a company that specializes in developing educational software. Your current task is to help build a function that converts a given integer to its corresponding column title as it appears in an Excel sheet. This functionality will be used in one of the company\'s spreadsheet-related applications. # Task: Implement a function `convert_to_title(column_number: int) -> str` that converts a given integer to a corresponding Excel column title. # Requirements: * **Input**: * `column_number`: An integer representing the column number (starting from 1). * **Output**: * The function should return a string that represents the Excel column title. # Constraints: * The function should handle values where `1 <= column_number <= 2^31 - 1`. # Function Signature: ```python def convert_to_title(column_number: int) -> str: ``` # Examples: ```python >>> convert_to_title(1) \'A\' >>> convert_to_title(28) \'AB\' >>> convert_to_title(701) \'ZY\' >>> convert_to_title(702) \'ZZ\' >>> convert_to_title(703) \'AAA\' ``` # Explanation: In Excel, column titles are labeled as follows: - 1 -> \\"A\\" - 2 -> \\"B\\" - ... - 26 -> \\"Z\\" - 27 -> \\"AA\\" - 28 -> \\"AB\\" - ... The logic can be compared to a base-26 number system, where the letters A to Z represent the digits 1 to 26. # Additional Challenge: To ensure your implementation is thorough, consider testing it with larger column numbers and verify the results match the expected Excel column titles.","solution":"def convert_to_title(column_number: int) -> str: Converts a given integer to its corresponding column title as it appears in an Excel sheet. Args: column_number (int): The column number to be converted. Returns: str: The corresponding column title. result = [] while column_number > 0: column_number -= 1 result.append(chr(column_number % 26 + ord(\'A\'))) column_number //= 26 return \'\'.join(result[::-1])"},{"question":"# Longest Consecutive Subsequence Objective Implement a function `findLongestConseqSubseq` that takes an array of integers and returns the length of the longest subsequence such that elements in the subsequence are consecutive integers. Expected Input and Output Formats * **Input**: * A list of integers. * **Output**: * An integer representing the length of the longest consecutive subsequence. Constraints and Limitations * Ensure the input list contains at least one element and doesn\'t exceed a length of 10^5. * The values in the array can range between -10^6 and 10^6. * Consider both positive and negative numbers as part of the sequence. Performance Requirements * The implementation should operate in O(n) time complexity to be efficient with large input sizes. Scenario You are given an unsorted array of integers. Your task is to find the length of the longest subsequence where the elements are consecutive integers, even if they appear out of order in the array. Implement the `findLongestConseqSubseq` function to determine this length efficiently. # Function Requirements The function should implement the following: * **Input validation**: Ensure the list is not empty and elements fall within the specified range. * **Method**: 1. `findLongestConseqSubseq` - Determines the length of the longest consecutive subsequence. Implement the `findLongestConseqSubseq` function considering the above requirements. Ensure to handle edge cases and constraints validation. ```python from typing import List def findLongestConseqSubseq(arr: List[int]) -> int: if not arr: return 0 numbers_set = set(arr) longest_streak = 0 for number in arr: if number - 1 not in numbers_set: current_number = number current_streak = 1 while current_number + 1 in numbers_set: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak # Example usage: if __name__ == \\"__main__\\": arr = [100, 4, 200, 1, 3, 2] print(findLongestConseqSubseq(arr)) # Output: 4, because the longest consecutive subsequence is [1, 2, 3, 4] ```","solution":"from typing import List def findLongestConseqSubseq(arr: List[int]) -> int: if not arr: return 0 numbers_set = set(arr) longest_streak = 0 for number in arr: if number - 1 not in numbers_set: current_number = number current_streak = 1 while current_number + 1 in numbers_set: current_number += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"# Problem Context You are developing a scheduling tool for project management that allows users to automate task dependencies. The tool must create a schedule where each task is executed after its dependencies are resolved. # Task Implement the TaskScheduler class with methods to accurately manage tasks and resolve dependencies. # Function Signature ```python class TaskScheduler: def __init__(self): ... def add_task(self, task_id: int, dependencies: list[int]): ... def can_schedule(self) -> bool: ... def get_schedule(self) -> list[int]: ... ``` # Requirements 1. **Initialization (`__init__` method)**: - Initializes an empty list or dictionary to track tasks and their dependencies. 2. **Add Task (`add_task` method)**: - Accepts a task ID and a list of task IDs it depends on. - Adds the task to the scheduler along with its dependencies. - Task IDs are unique integers. 3. **Can Schedule (`can_schedule` method)**: - Returns `True` if tasks can be scheduled without dependency conflicts (i.e., there are no cyclic dependencies), otherwise `False`. 4. **Get Schedule (`get_schedule` method)**: - Returns a list of task IDs in an order that respects the dependencies. - If tasks cannot be scheduled (cyclic dependency), return an empty list. # Input and Output Format * **Input**: - List of tasks and their dependencies. ```plaintext add_task(1, []) add_task(2, [1]) add_task(3, [1]) add_task(4, [2, 3]) ``` * **Output**: - Method signature implementations. - Use `can_schedule` to verify the possibility of scheduling, and `get_schedule` to fetch the valid sequence. # Constraints 1. Task IDs are positive integers. 2. Dependencies are also positive integers and must reference existing tasks. # Example Usage ```python if __name__ == \\"__main__\\": scheduler = TaskScheduler() scheduler.add_task(1, []) scheduler.add_task(2, [1]) scheduler.add_task(3, [1]) scheduler.add_task(4, [2, 3]) if scheduler.can_schedule(): print(scheduler.get_schedule()) else: print(\\"Tasks cannot be scheduled due to cyclic dependencies.\\") ``` Expected Output: ```plaintext [1, 2, 3, 4] ``` # Additional Guidelines 1. **Edge Cases**: - Handle input where tasks have no dependencies. - Ensure cyclic dependencies are detected. 2. **Performance**: - Use efficient algorithms to check for cyclic dependencies and to determine the correct order of tasks. - Optimize for scenarios with large numbers of tasks and dependencies.","solution":"from collections import defaultdict, deque class TaskScheduler: def __init__(self): # Initialize the graph and in-degrees self.graph = defaultdict(list) self.in_degree = defaultdict(int) self.tasks = set() def add_task(self, task_id: int, dependencies: list[int]): # Update the graph and in-degrees if task_id not in self.tasks: self.tasks.add(task_id) self.in_degree[task_id] = 0 for dep in dependencies: self.graph[dep].append(task_id) self.in_degree[task_id] += 1 if dep not in self.tasks: self.tasks.add(dep) self.in_degree[dep] = 0 def can_schedule(self) -> bool: # Check if a valid schedule exists using Kahn\'s algorithm for topological sorting in_degree_copy = self.in_degree.copy() zero_in_degree_queue = deque([task for task in self.tasks if in_degree_copy[task] == 0]) visited_count = 0 while zero_in_degree_queue: current = zero_in_degree_queue.popleft() visited_count += 1 for neighbor in self.graph[current]: in_degree_copy[neighbor] -= 1 if in_degree_copy[neighbor] == 0: zero_in_degree_queue.append(neighbor) return visited_count == len(self.tasks) def get_schedule(self) -> list[int]: if not self.can_schedule(): return [] # Generate the order using Kahn\'s algorithm in_degree_copy = self.in_degree.copy() zero_in_degree_queue = deque([task for task in self.tasks if in_degree_copy[task] == 0]) result = [] while zero_in_degree_queue: current = zero_in_degree_queue.popleft() result.append(current) for neighbor in self.graph[current]: in_degree_copy[neighbor] -= 1 if in_degree_copy[neighbor] == 0: zero_in_degree_queue.append(neighbor) return result"},{"question":"# Binary Search Tree Balance Context You are given the implementation of a binary search tree (BST) that supports typical operations like insertion, deletion, and search. However, the current execution of these operations does not ensure that the tree remains balanced, which can lead to degraded performance as the tree becomes skewed, approaching O(n) complexity for these operations. A balanced tree maintains a more optimal O(log n) complexity by keeping the height of the tree as small as possible. Task Your task is to enhance the `BinarySearchTree` class by implementing the following advanced features: 1. **Balancing:** Introduce a method to balance the tree at any point, ensuring that the height of the tree is kept minimal. 2. **AVL Tree Balancing (Self-Balancing):** Modify the insert and delete operations to maintain the AVL property (difference in heights of left and right subtrees of any node is no more than one). 3. **Height Calculation:** Add a method to calculate the height of the tree, which can be useful for debugging and performance analysis. Function Signature ```python class BinarySearchTree: def __init__(self): self.root = None class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 # New attribute for height def insert(self, key): insert: @param key: an integer value to insert into the BST Inserts the key into the BST and ensures the AVL balancing property is maintained. def delete(self, key): delete: @param key: an integer value to remove from the BST Deletes the key from the BST and ensures the AVL balancing property is maintained. def search(self, key): search: @param key: an integer value to search for in the BST Returns the node with the given key if found, else returns None. def balance(self): balance: Balances the entire BST to maintain a minimal height. def get_height(self, node): get_height: @param node: the node for which to calculate the height Returns the height of the tree from the given node. def _rotate_left(self, z): # Helper method for left rotation def _rotate_right(self, y): # Helper method for right rotation ``` Input - `key` for insert, delete, and search: An integer value to insert, delete, or search in the BST. Output - For search: Returns the node with the given key if found, else None. - For height calculation: Returns an integer representing the height of the tree from the specified node. Constraints - Ensure AVL property is maintained after each insertion and deletion to keep the tree balanced. - Efficiently balance the tree to avoid significant performance degradation. - The `balance` method should optimize the tree\'s height without losing the BST property. Performance Requirements - Insert, delete, and search operations should maintain complexity close to O(log n). - Balance method should optimize the tree efficiently without redundant operations. # Example Usage ```python # Example usage after enhancements bst = BinarySearchTree() keys = [20, 4, 15, 70, 50, 100, 10] for key in keys: bst.insert(key) print(bst.search(15).key) # Output: 15 bst.delete(4) bst.balance() height = bst.get_height(bst.root) print(f\\"Height of balanced BST: {height}\\") ```","solution":"class BinarySearchTree: def __init__(self): self.root = None class Node: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 # New attribute for height def insert(self, key): self.root = self._insert(self.root, key) def _insert(self, node, key): if not node: return self.Node(key) if key < node.key: node.left = self._insert(node.left, key) else: node.right = self._insert(node.right, key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) return self._balance_node(node) def delete(self, key): self.root = self._delete(self.root, key) def _delete(self, node, key): if not node: return node if key < node.key: node.left = self._delete(node.left, key) elif key > node.key: node.right = self._delete(node.right, key) else: if not node.left: return node.right elif not node.right: return node.left temp = self._get_min_value_node(node.right) node.key = temp.key node.right = self._delete(node.right, temp.key) node.height = 1 + max(self.get_height(node.left), self.get_height(node.right)) return self._balance_node(node) def search(self, key): return self._search(self.root, key) def _search(self, node, key): if not node or node.key == key: return node elif key < node.key: return self._search(node.left, key) else: return self._search(node.right, key) def balance(self): nodes = [] self._in_order_traversal(self.root, nodes) self.root = self._build_balanced_tree(nodes, 0, len(nodes) - 1) def _in_order_traversal(self, node, nodes): if node: self._in_order_traversal(node.left, nodes) nodes.append(node.key) self._in_order_traversal(node.right, nodes) def _build_balanced_tree(self, nodes, start, end): if start > end: return None mid = (start + end) // 2 root = self.Node(nodes[mid]) root.left = self._build_balanced_tree(nodes, start, mid - 1) root.right = self._build_balanced_tree(nodes, mid + 1, end) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) return root def get_height(self, node): if not node: return 0 return node.height def _rotate_left(self, z): y = z.right z.right = y.left y.left = z z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def _rotate_right(self, y): x = y.left y.left = x.right x.right = y y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) x.height = 1 + max(self.get_height(x.left), self.get_height(x.right)) return x def _balance_node(self, node): balance = self.get_balance(node) if balance > 1: if self.get_balance(node.left) < 0: node.left = self._rotate_left(node.left) return self._rotate_right(node) if balance < -1: if self.get_balance(node.right) > 0: node.right = self._rotate_right(node.right) return self._rotate_left(node) return node def get_balance(self, node): if not node: return 0 return self.get_height(node.left) - self.get_height(node.right) def _get_min_value_node(self, node): current = node while current.left is not None: current = current.left return current"},{"question":"# Coding Assessment Question Task Develop a function that generates an MxN grid where each cell contains a single alphabetical character according to the following rules: 1. The grid should start with the character \'A\' in the top-left corner. 2. Characters should increment sequentially in each row (left to right) and wrap around from \'Z\' back to \'A\'. 3. After reaching the end of a row, the next character should start on the subsequent row. Write a function that constructs and returns such a grid. Function Signature ```python def generate_grid(m: int, n: int) -> List[List[str]]: ``` # Input - `m` (int): Number of rows in the grid. - `n` (int): Number of columns in the grid. # Output - (List[List[str]]): A 2D list representing the MxN grid filled with characters as described. # Constraints - 1 ≤ `m`, `n` ≤ 26 # Requirements * Ensure that characters wrap around from \'Z\' to \'A\'. * The function should handle cases where `m` or `n` is 1. # Example Here is an example of how your function might be called and what the expected output would be: ```python assert generate_grid(3, 4) == [ [\'A\', \'B\', \'C\', \'D\'], [\'E\', \'F\', \'G\', \'H\'], [\'I\', \'J\', \'K\', \'L\'] ] assert generate_grid(5, 6) == [ [\'A\', \'B\', \'C\', \'D\', \'E\', \'F\'], [\'G\', \'H\', \'I\', \'J\', \'K\', \'L\'], [\'M\', \'N\', \'O\', \'P\', \'Q\', \'R\'], [\'S\', \'T\', \'U\', \'V\', \'W\', \'X\'], [\'Y\', \'Z\', \'A\', \'B\', \'C\', \'D\'] ] ``` # Notes * Consider edge case handling such as when `m` or `n` equals 1. * Implement efficient character wrapping logic to ensure correct character flow. Use Python\'s `ord()` and `chr()` functions to manage character increment.","solution":"from typing import List def generate_grid(m: int, n: int) -> List[List[str]]: grid = [] current_char = ord(\'A\') for i in range(m): row = [] for j in range(n): row.append(chr(current_char)) current_char += 1 if current_char > ord(\'Z\'): current_char = ord(\'A\') grid.append(row) return grid"},{"question":"# Coding Assessment Question **Title**: Circular Buffer Implementation Background A circular buffer, also known as a ring buffer, is a data structure that uses a single, fixed-size buffer as if it were connected end-to-end. This structure is useful for buffering data streams in situations where the producer and consumer operate at different rates. Task Implement a circular buffer class in Python which supports the following operations: - `enqueue`: Add an element to the buffer. - `dequeue`: Remove and return the oldest element from the buffer. - `peek`: Return the oldest element without removing it. - `is_empty`: Check if the buffer is empty. - `is_full`: Check if the buffer is full. Class Signature ```python class CircularBuffer: def __init__(self, capacity: int): Initialize the circular buffer with a given capacity. Args: capacity (int): The maximum number of elements the buffer can hold. pass def enqueue(self, value: int) -> None: Add an element to the buffer. Args: value (int): The value to add to the buffer. Raises: OverflowError: If the buffer is full. pass def dequeue(self) -> int: Remove and return the oldest element from the buffer. Raises: IndexError: If the buffer is empty. Returns: int: The oldest element in the buffer. pass def peek(self) -> int: Return the oldest element without removing it. Raises: IndexError: If the buffer is empty. Returns: int: The oldest element in the buffer. pass def is_empty(self) -> bool: Check if the buffer is empty. Returns: bool: True if the buffer is empty, False otherwise. pass def is_full(self) -> bool: Check if the buffer is full. Returns: bool: True if the buffer is full, False otherwise. pass ``` Example Usage ```python buffer = CircularBuffer(3) buffer.enqueue(1) buffer.enqueue(2) print(buffer.dequeue()) # Output: 1 buffer.enqueue(3) buffer.enqueue(4) print(buffer.peek()) # Output: 2 print(buffer.is_full()) # Output: True print(buffer.is_empty()) # Output: False ``` Constraints - The capacity is a positive integer no greater than 1000. - The `enqueue` method should raise an `OverflowError` if the buffer is full. - The `dequeue` and `peek` methods should raise an `IndexError` if the buffer is empty. - All elements of the buffer will be non-negative integers. ***Notes:*** - Ensure efficient operations for enqueueing and dequeueing in terms of time complexity. - Handle edge cases such as buffer wrap-around correctly.","solution":"class CircularBuffer: def __init__(self, capacity: int): self.capacity = capacity self.buffer = [None] * capacity self.head = 0 self.tail = 0 self.size = 0 def enqueue(self, value: int) -> None: if self.is_full(): raise OverflowError(\\"Buffer is full\\") self.buffer[self.tail] = value self.tail = (self.tail + 1) % self.capacity self.size += 1 def dequeue(self) -> int: if self.is_empty(): raise IndexError(\\"Buffer is empty\\") value = self.buffer[self.head] self.buffer[self.head] = None self.head = (self.head + 1) % self.capacity self.size -= 1 return value def peek(self) -> int: if self.is_empty(): raise IndexError(\\"Buffer is empty\\") return self.buffer[self.head] def is_empty(self) -> bool: return self.size == 0 def is_full(self) -> bool: return self.size == self.capacity"},{"question":"# Coding Assessment Question Scenario: You are developing a system that tracks temperature changes throughout the day and provides an analysis of these changes. To assist in this, you need to implement a function that calculates the maximum temperature difference between any two given times in a list of recorded temperature readings. Task: Write a Python function `max_temperature_diff(temps: List[int]) -> int` that: * Takes a list `temps` of integers representing temperature readings at different times. * Returns an integer representing the maximum difference between any two temperatures in the list. # Specifications: * **Input**: A list of integers `temps` where each integer represents a temperature reading. * **Output**: An integer representing the maximum difference between any two temperatures in the input list. # Constraints: * The input list `temps` will have at least 2 temperature readings and at most 10^4 readings. * The temperature readings are integer values and can range from -10^5 to 10^5. * If the input is not a list of integers, your function should raise a `TypeError` with an appropriate error message. * If the input list contains less than 2 readings, your function should raise a `ValueError` with an appropriate error message. Example Inputs and Outputs: 1. `max_temperature_diff([30, 10, 20, 40, 50])` should return `40` (difference between 50 and 10). 2. `max_temperature_diff([-10, -5, -1, 0, 5, 10])` should return `20` (difference between 10 and -10). 3. `max_temperature_diff([100])` should raise a `ValueError`. 4. `max_temperature_diff([-50, -20, -10, 0, 10])` should return `60` (difference between 10 and -50). # Edge Cases: 1. If the input list is `[\\"a\\", 10, 20]`, raise `TypeError` with the message \\"All elements must be integers\\". 2. If the input list has only one element, raise `ValueError` with the message \\"The list must contain at least two temperature readings\\". 3. If the input is `20`, raise `TypeError` with the message \\"Input value must be a \'list\' type\\". # Example Error Handling: 1. `max_temperature_diff([\\"a\\", 10, 20])` should raise a `TypeError` with the message \\"All elements must be integers\\". 2. `max_temperature_diff([100])` should raise a `ValueError` with the message \\"The list must contain at least two temperature readings\\". 3. `max_temperature_diff(20)` should raise a `TypeError` with the message \\"Input value must be a \'list\' type\\". # Note: Remember to handle all edge cases as specified to ensure the robustness of your function.","solution":"from typing import List def max_temperature_diff(temps: List[int]) -> int: Given a list of temperature readings, returns the maximum difference between any two readings. :param temps: A list of integers representing temperature readings. :return: An integer representing the maximum difference between any two temperatures. :raises TypeError: If the input is not a list or elements in the list are not all integers. :raises ValueError: If the input list contains less than 2 readings. if not isinstance(temps, list): raise TypeError(\\"Input value must be a \'list\' type\\") if len(temps) < 2: raise ValueError(\\"The list must contain at least two temperature readings\\") if not all(isinstance(temp, int) for temp in temps): raise TypeError(\\"All elements must be integers\\") return max(temps) - min(temps)"},{"question":"# Question: Optimized Kth Smallest Element in a Matrix Given an `n x n` matrix where each of the rows and columns are sorted in ascending order, design and implement an efficient algorithm to find the k-th smallest element in the matrix. Requirements: 1. **Input**: An `n x n` matrix `matrix`, and an integer `k`. 2. **Output**: The k-th smallest element in the given matrix. 3. **Constraints**: * The matrix dimensions will be between 1 and 300. * 1 ≤ k ≤ n^2. * You cannot use built-in functions for sorting the entire matrix directly. 4. **Performance**: * Aim to achieve a time complexity better than O(n² log n²). * Efficiently manage space and avoid unnecessary overhead. ```python import heapq def kth_smallest(matrix: list, k: int) -> int: Find the kth smallest element in a sorted n x n matrix. :param matrix: 2D list where each row and column are sorted in ascending order :param k: Integer representing the kth position smallest element to find :return: The kth smallest element in the matrix Examples: >>> kth_smallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 8) 13 >>> kth_smallest([ ... [1, 5, 9], ... [10, 11, 13], ... [12, 13, 15] ... ], 1) 1 # Your code here if __name__ == \\"__main__\\": assert kth_smallest([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 5) == 5 assert kth_smallest([ [1, 1, 3], [1, 4, 6], [3, 6, 9] ], 4) == 3 ```","solution":"import heapq def kth_smallest(matrix: list, k: int) -> int: Find the kth smallest element in a sorted n x n matrix. :param matrix: 2D list where each row and column are sorted in ascending order :param k: Integer representing the kth position smallest element to find :return: The kth smallest element in the matrix n = len(matrix) min_heap = [] for r in range(min(n, k)): # We use at most k rows to fill our heap heapq.heappush(min_heap, (matrix[r][0], r, 0)) number_count, number = 0, 0 while min_heap: number, r, c = heapq.heappop(min_heap) number_count += 1 if number_count == k: break if c + 1 < n: heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return number"},{"question":"# Problem Statement: You are given a function that counts the occurrences of each character in a string. Your task is to implement a new function named `majority_characters(s: str) -> List[str]` that returns a sorted list of characters that appear more than `n/2` times in the given string, where `n` is the length of the string. # Requirements: 1. If no character appears more than `n/2` times, return an empty list. 2. Ensure the function handles edge cases, such as an empty string or strings with no majority characters. 3. The function should have optimal time complexity, ideally O(n). # Function Signature: ```python def majority_characters(s: str) -> List[str]: pass ``` # Input Format: * `s`: A string of lowercase English letters. # Output Format: * A list of characters that appear more than `n/2` times in the string, sorted in alphabetical order. # Example: ```python # Example 1 s = \\"ababab\\" # Majority characters: [] print(majority_characters(s)) # Example 2 s = \\"aaaaa\\" # Majority characters: [\'a\'] print(majority_characters(s)) # Example 3 s = \\"abcccc\\" # Majority characters: [\'c\'] print(majority_characters(s)) ``` # Constraints: * `s` is a string of lowercase English letters with a length between 0 and 10^6.","solution":"from typing import List def majority_characters(s: str) -> List[str]: Returns a sorted list of characters that appear more than n/2 times in the string. Parameters: s (str): A string of lowercase English letters. Returns: List[str]: A sorted list of majority characters. from collections import Counter n = len(s) if n == 0: return [] freq = Counter(s) majority_threshold = n // 2 majority_chars = [char for char, count in freq.items() if count > majority_threshold] return sorted(majority_chars)"},{"question":"# Coding Assessment Question Problem Statement Your task is to implement a function that processes a list of transactions for multiple bank accounts and calculates the final balance of each account. Each transaction includes an account ID and the amount (which can be positive or negative). The function should handle different edge cases, such as multiple transactions for the same account and no transactions at all. Function to Implement ```python def calculate_final_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: Calculate the final balances for each account given a list of transactions. Parameters: - transactions (List[Dict[str, Union[str, float]]]): A list of transactions where each transaction is represented as a dictionary with \'account_id\' (str) and \'amount\' (float) keys. Returns: - Dict[str, float]: A dictionary where the keys are account IDs and the values are the final balances of those accounts. pass ``` Expectations 1. **Functionality**: - The function should correctly sum up the transactions for each account. - It should handle transactions for multiple accounts and make sure each account has its correct final balance. 2. **Input/Output**: - The input is a list of transactions, where each transaction is a dictionary with \'account_id\' and \'amount\' keys. - It returns a dictionary mapping account IDs (str) to their final balances (float). 3. **Constraints**: - Each account ID is unique. - Be mindful of cases where no transactions are present. - Consider the efficiency of your solution for a large number of transactions. Example Usage ```python transactions = [ {\'account_id\': \'A123\', \'amount\': 100.0}, {\'account_id\': \'B456\', \'amount\': 150.0}, {\'account_id\': \'A123\', \'amount\': -50.0}, {\'account_id\': \'C789\', \'amount\': 200.0}, {\'account_id\': \'B456\', \'amount\': -75.0}, ] final_balances = calculate_final_balances(transactions) print(final_balances) # Output: {\'A123\': 50.0, \'B456\': 75.0, \'C789\': 200.0} ```","solution":"from typing import List, Dict, Union def calculate_final_balances(transactions: List[Dict[str, Union[str, float]]]) -> Dict[str, float]: final_balances = {} for transaction in transactions: account_id = transaction[\'account_id\'] amount = transaction[\'amount\'] if account_id in final_balances: final_balances[account_id] += amount else: final_balances[account_id] = amount return final_balances"},{"question":"# Problem Statement You are required to implement a function to evaluate the postfix expression (also known as Reverse Polish Notation, RPN). Your function should take a list of tokens representing the postfix expression and return the calculated result as an integer. The given expression is guaranteed to be valid. # Function Specifications **Function Name:** `evaluate_postfix_expression` **Input:** A list of strings `tokens` representing the postfix expression. **Output:** An integer representing the result of evaluating the postfix expression. # Constraints - The length of `tokens` will be between 1 and 100. - Each token in `tokens` will be either an integer or one of the operators: `+, -, *, /`. For the division operator `/`, perform integer division. - All given integers are valid and within the range of [-10000, 10000]. # Performance Requirements - The expected time complexity is O(n), where `n` is the length of the `tokens` list. # Examples ```python >>> evaluate_postfix_expression([\\"2\\", \\"1\\", \\"+\\", \\"3\\", \\"*\\"]) 9 >>> evaluate_postfix_expression([\\"4\\", \\"13\\", \\"5\\", \\"/\\", \\"+\\"]) 6 >>> evaluate_postfix_expression([\\"10\\", \\"6\\", \\"9\\", \\"3\\", \\"+\\", \\"-11\\", \\"*\\", \\"/\\", \\"*\\", \\"17\\", \\"+\\", \\"5\\", \\"+\\"]) 22 ``` # Notes - Assume all the given expressions are valid postfix expressions. - Division should handle truncation towards 0 (e.g., `7 / 2` should be `3` and `-7 / 2` should be `-3`). - Focus on implementing the algorithm using a stack to evaluate the postfix expression as per the standard approach.","solution":"def evaluate_postfix_expression(tokens): Evaluate the given postfix expression and return the result. stack = [] for token in tokens: if token in \\"+-*/\\": # Pop the two topmost values from stack for the operation b = stack.pop() a = stack.pop() if token == \\"+\\": stack.append(a + b) elif token == \\"-\\": stack.append(a - b) elif token == \\"*\\": stack.append(a * b) elif token == \\"/\\": # Implement integer division where truncation goes towards zero stack.append(int(a / b)) else: # Token is a number, push to stack stack.append(int(token)) # The last remaining item in the stack is the result return stack[-1]"},{"question":"Question Efficient data compression is vital to optimize storage and network transfer speeds. Implement a function using the Run-Length Encoding (RLE) technique. This function will take a string (`text`) as input and return its compressed form. Each run of consecutive identical characters is replaced by a single instance of the character followed by the count of characters in that run. # Function Signature ```python def run_length_encode(text: str) -> str: pass ``` # Input * A single string `text` (0 ≤ len(text) ≤ 10^6), consisting of lowercase English letters. # Output * A compressed string using Run-Length Encoding format. For example, the string \\"aaabbc\\" compresses to \\"a3b2c1\\". # Constraints * Handle edge cases such as empty strings and strings with no consecutive identical characters effectively. # Examples ```python >>> run_length_encode(\'aaabbc\') \'a3b2c1\' >>> run_length_encode(\'aaaaaa\') \'a6\' >>> run_length_encode(\'abcde\') \'a1b1c1d1e1\' >>> run_length_encode(\'\') \'\' ``` # Scenario Run-Length Encoding is a simple form of data compression that is very effective in scenarios where a string contains many consecutive repeating characters. Your task is to implement this technique to prepare data for efficient storage or transmission, particularly when data is likely to exhibit high redundancy. # Notes Implement the Run-Length Encoding function with efficient time complexity to handle the upper constraint limits effectively. Ensure your function correctly handles all possible edge cases, particularly when the input string is empty or when there are no repeating characters. The function will be tested against various input sizes and patterns to verify its correctness and performance.","solution":"def run_length_encode(text: str) -> str: Compresses the provided text using Run-Length Encoding (RLE) technique. Each run of consecutive identical characters is replaced by a single instance of the character followed by the count of characters in that run. :param text: str - a string consisting of lowercase English letters. :return: str - the Run-Length Encoded string. if not text: return \\"\\" encoded = [] current_char = text[0] count = 1 for char in text[1:]: if char == current_char: count += 1 else: encoded.append(current_char + str(count)) current_char = char count = 1 # Don\'t forget to add the last run encoded.append(current_char + str(count)) return \\"\\".join(encoded)"},{"question":"# Problem Description Your task is to implement a system for tracking a user\'s tasks with priorities using a Binary Heap data structure. The system should support adding new tasks, retrieving the task with the highest priority, and removing completed tasks efficiently. # Objectives 1. Implement the `add_task` method to insert a new task into the binary heap. 2. Implement the `get_highest_priority` method to retrieve and return the task with the highest priority without removing it. 3. Implement the `remove_highest_priority` method to remove and return the task with the highest priority from the binary heap. # Requirements Part 1: `add_task` * **Function Signature**: `def add_task(self, task: str, priority: int) -> None` * **Inputs**: A string `task` representing the task description and an integer `priority` representing the task\'s priority. * **Outputs**: None * **Constraints**: - Tasks are represented as strings with a maximum length of 100 characters. - Priority values are non-negative integers. Part 2: `get_highest_priority` * **Function Signature**: `def get_highest_priority(self) -> str` * **Inputs**: None * **Outputs**: The task description with the highest priority. * **Constraints**: - If the heap is empty, return an empty string. Part 3: `remove_highest_priority` * **Function Signature**: `def remove_highest_priority(self) -> str` * **Inputs**: None * **Outputs**: The task description with the highest priority. * **Constraints**: - If the heap is empty, return an empty string. # Input and Output Format ```python # Example for Part 1, 2, and 3 scheduler = TaskScheduler() scheduler.add_task(\\"Complete assignment\\", 3) scheduler.add_task(\\"Prepare for meeting\\", 2) scheduler.add_task(\\"Book flight tickets\\", 4) print(scheduler.get_highest_priority()) # Output should be \\"Book flight tickets\\" print(scheduler.remove_highest_priority()) # Output should be \\"Book flight tickets\\" print(scheduler.get_highest_priority()) # Output should be \\"Complete assignment\\" ``` # Performance and Constraints - Ensure time complexity remains efficient for all operations. - Handle edge cases such as operations on an empty heap. # Function Details 1. `add_task(self, task: str, priority: int) -> None` 2. `get_highest_priority(self) -> str` 3. `remove_highest_priority(self) -> str` # Scenario Imagine you are managing a task scheduling system where tasks need to be completed based on their priorities. To ensure that the system retrieves and handles the most important tasks first, you need a priority queue implemented as a binary heap. This structure allows efficient addition of new tasks, getting the highest priority task without removing it, and removing tasks as they are completed, all while maintaining optimal performance for high-frequency operations.","solution":"import heapq class TaskScheduler: def __init__(self): self.heap = [] def add_task(self, task: str, priority: int) -> None: Insert a new task into the binary heap. Parameters: - task (str): The task description. - priority (int): The priority of the task, a non-negative integer. Returns: None heapq.heappush(self.heap, (-priority, task)) def get_highest_priority(self) -> str: Retrieve and return the task with the highest priority without removing it. Returns: str: The task with the highest priority. Empty string if heap is empty. if not self.heap: return \\"\\" return self.heap[0][1] def remove_highest_priority(self) -> str: Remove and return the task with the highest priority from the binary heap. Returns: str: The task with the highest priority. Empty string if heap is empty. if not self.heap: return \\"\\" return heapq.heappop(self.heap)[1]"},{"question":"**Problem Statement**: Design and implement a class that simulates a stack data structure with an additional operation to retrieve the median of all elements in the stack in constant time ( O(1) ). The class should support the following operations: - `push(val: int)`: Pushes an integer value onto the stack. - `pop() -> int`: Removes the top element from the stack and returns it. If the stack is empty, raise an `IndexError` with the message `pop from empty stack`. - `peek() -> int`: Returns the top element of the stack without removing it. If the stack is empty, raise an `IndexError` with the message `peek from empty stack`. - `get_median() -> float`: Returns the median value of all elements currently in the stack. If the stack is empty, raise an `IndexError` with the message `get_median from empty stack`. # Class Definition: ```python class MedianStack: def __init__(self): pass def push(self, val: int): pass def pop(self) -> int: pass def peek(self) -> int: pass def get_median(self) -> float: pass ``` # Constraints: - The median of a list of numbers is the middle number when all the numbers are sorted in ascending order. If the list has an even number of elements, the median is the average of the two middle numbers. - All operations (`push`, `pop`, `peek`, `get_median`) must be implemented to handle possible edge cases, such as empty stack conditions. - `get_median` operation should execute in constant time ( O(1) ). # Examples: ```python ms = MedianStack() ms.push(1) ms.push(2) ms.push(3) print(ms.get_median()) # Expected output: 2 print(ms.pop()) # Expected output: 3 print(ms.get_median()) # Expected output: 1.5 ms.push(7) ms.push(5) print(ms.get_median()) # Expected output: 2 print(ms.peek()) # Expected output: 5 print(ms.pop()) # Expected output: 5 print(ms.get_median()) # Expected output: 2 ``` # Requirements: - Ensure that the `MedianStack` class operates efficiently within the constraints. - The `MedianStack` class should maintain the median calculation optimally to guarantee the ( O(1) ) complexity for the `get_median` method. - Implement robust error handling for edge cases and invalid stack operations.","solution":"import bisect class MedianStack: def __init__(self): self.stack = [] self.sorted_stack = [] def push(self, val: int): self.stack.append(val) bisect.insort(self.sorted_stack, val) def pop(self) -> int: if not self.stack: raise IndexError(\'pop from empty stack\') val = self.stack.pop() self.sorted_stack.remove(val) return val def peek(self) -> int: if not self.stack: raise IndexError(\'peek from empty stack\') return self.stack[-1] def get_median(self) -> float: if not self.stack: raise IndexError(\'get_median from empty stack\') n = len(self.sorted_stack) if n % 2 == 1: return float(self.sorted_stack[n // 2]) else: return (self.sorted_stack[n // 2 - 1] + self.sorted_stack[n // 2]) / 2.0"},{"question":"# Scenario: You are working on an application that processes purchase transactions. Your task is to create a function that calculates the total cost of all items that have been purchased given a list of transactions. Each transaction includes the item price as well as the quantity purchased. # Task: Implement a Python function `calculate_total_cost(transactions: List[Dict[str, Union[float, int]]]) -> float` that: 1. Accepts a list of transaction dictionaries. 2. Each transaction dictionary contains: - A key `\\"price\\"` with a float value representing the price of a single item. - A key `\\"quantity\\"` with an integer value representing the number of items purchased. 3. Returns the total cost (a float) of all items purchased. The total cost is the sum of the product of the price and quantity for each transaction. # Input: - `transactions` (List[Dict[str, Union[float, int]]]): A list of transaction dictionaries. # Output: - (float): The total cost of all items purchased. # Constraints: - Each transaction dictionary will have valid `\\"price\\"` and `\\"quantity\\"` keys. - The price will be a non-negative float. - The quantity will be a non-negative integer. # Example: ```python transactions = [ {\\"price\\": 19.99, \\"quantity\\": 2}, {\\"price\\": 5.49, \\"quantity\\": 5}, {\\"price\\": 3.50, \\"quantity\\": 10} ] result = calculate_total_cost(transactions) # Expected result: # 78.93 ``` # Notes: - Ensure that the function handles an empty list of transactions gracefully, returning 0.0. - Test your implementation with varying prices and quantities to ensure accuracy.","solution":"from typing import List, Dict, Union def calculate_total_cost(transactions: List[Dict[str, Union[float, int]]]) -> float: Calculate the total cost of all items purchased. Args: transactions (List[Dict[str, Union[float, int]]]): A list of transaction dictionaries. Returns: float: The total cost of all items purchased. total_cost = 0.0 for transaction in transactions: total_cost += transaction[\'price\'] * transaction[\'quantity\'] return total_cost"},{"question":"# String Manipulation: Word Ladder Transformation A word ladder is a sequence of words formed by changing only one letter at a time, where each transformed word must be a valid dictionary word and must differ by exactly one letter from the word immediately before it. The challenge is to transform a starting word into an ending word using the minimal number of transformations. Task: Implement the word ladder transformation with added constraints: 1. You have the standard requirement to change only one letter at a time. 2. Introduce a restriction whereby the transformation distance at each step must be exactly 1 letter apart. 3. Optimize for performance to find the shortest transformation sequence. You will need to implement three functions: 1. `is_valid_word(word: str, dictionary: set[str]) -> bool`: Checks if a given word is in the dictionary. 2. `find_neighbors(word: str, dictionary: set[str]) -> list[str]`: Finds all valid neighbor words that are one letter different from the given word. 3. `find_shortest_transformation(start: str, end: str, dictionary: set[str]) -> list[str]`: Finds the shortest transformation sequence from the start word to the end word using the set of dictionary words. Input: * A string `start` representing the starting word. * A string `end` representing the ending word. * A set of strings `dictionary` representing the list of valid dictionary words. Output: * A list of strings representing the shortest transformation sequence from `start` to `end`. Example Usage: ```python dictionary = {\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"} start = \\"hit\\" end = \\"cog\\" transformation_sequence = find_shortest_transformation(start, end, dictionary) ``` Here, an example output might be: ```python [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\"] ``` Constraints: * The length of `start` and `end` are the same and within the range `[1, 10]`. * `start` and `end` are guaranteed to be valid words in the dictionary. * The dictionary contains at most 10,000 words. Performance: Optimize your implementation to find the shortest path efficiently, even with large dictionary sizes. Additional Notes: * Ensure your program handles cases where no valid transformation sequence exists gracefully. * Test and validate your implementation with various dictionary sizes and word pairs. * Consider edge cases such as non-transformable combinations where `start` and `end` have no valid connection through the dictionary words. Implement an efficient breadth-first search (BFS) approach or another optimal strategy for the solution.","solution":"from collections import deque def is_valid_word(word, dictionary): Checks if a given word is in the dictionary. return word in dictionary def find_neighbors(word, dictionary): Finds all valid neighbor words that are one letter different from the given word. neighbors = [] word_length = len(word) for i in range(word_length): for c in \'abcdefghijklmnopqrstuvwxyz\': if c != word[i]: neighbor = word[:i] + c + word[i+1:] if neighbor in dictionary: neighbors.append(neighbor) return neighbors def find_shortest_transformation(start, end, dictionary): Finds the shortest transformation sequence from the start word to the end word using the set of dictionary words. if start == end: return [start] queue = deque([(start, [start])]) visited = set([start]) while queue: current_word, path = queue.popleft() for neighbor in find_neighbors(current_word, dictionary): if neighbor == end: return path + [neighbor] if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] # Return an empty list if no transformation sequence exists"},{"question":"# Problem Statement: Large Window Subarray Sum You are given an array of integers and a window size ( k ). Your task is to implement a function that finds the maximum sum of any subarray of size ( k ). # Function Specifications max_window_subarray_sum **Parameters**: - `arr`: A list of integers representing the array. - `k`: An integer representing the size of the window. **Returns**: - An integer representing the maximum sum of any subarray of size ( k ). Example ```python def max_window_subarray_sum(arr: list[int], k: int) -> int: # Your implementation here ``` Input: ```python arr = [1, 2, 3, 4, 5, 6, 7, 8, 9] k = 3 ``` Output: ```python 24 ``` Constraints - ( 1 leq k leq |arr| leq 100 ) - All elements in the array are integers and may range from (-10^3) to (10^3) # Notes - Ensure your function handles edge cases such as small arrays and small window sizes. - Optimize for efficiency, aiming for an O(n) solution by leveraging a sliding window approach. - Thoroughly test your function with varied input to guarantee robustness.","solution":"def max_window_subarray_sum(arr, k): Find the maximum sum of any subarray of size k. Parameters: arr (list of int): The input array. k (int): The window size. Returns: int: The maximum sum of any subarray of size k. if not arr or k == 0 or k > len(arr): return 0 max_sum = float(\'-inf\') current_sum = sum(arr[:k]) max_sum = max(max_sum, current_sum) for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"# Problem Statement You are required to implement a function `lowercase_count` that counts the number of lowercase alphabetic characters in a given string. Additionally, you must implement a function `uppercase_count` that counts the number of uppercase alphabetic characters in the same string. **Function 1: `lowercase_count`** - **Input**: A `str` object `input_string`. - **Output**: An `int` representing the number of lowercase alphabetic characters in the input string. - **Constraints**: - The input `input_string` can be an empty string. **Function 2: `uppercase_count`** - **Input**: A `str` object `input_string`. - **Output**: An `int` representing the number of uppercase alphabetic characters in the input string. - **Constraints**: - The input `input_string` can be an empty string. # Example ```python def lowercase_count(input_string: str) -> int: \'\'\' This function counts the number of lowercase alphabetic characters in the input string. \'\'\' pass # TODO: Write the implementation here def uppercase_count(input_string: str) -> int: \'\'\' This function counts the number of uppercase alphabetic characters in the input string. \'\'\' pass # TODO: Write the implementation here # Test Cases assert lowercase_count(\'Hello World!\') == 8 assert lowercase_count(\'HELLO WORLD!\') == 0 assert lowercase_count(\'\') == 0 assert lowercase_count(\'abcdefghijklmnopqrstuvwxyz\') == 26 assert lowercase_count(\'1234567890!@#%^&*()\') == 0 assert uppercase_count(\'Hello World!\') == 2 assert uppercase_count(\'HELLO WORLD!\') == 10 assert uppercase_count(\'\') == 0 assert uppercase_count(\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\') == 26 assert uppercase_count(\'1234567890!@#%^&*()\') == 0 ``` **Additional Note**: - Ensure your code handles edge cases properly, such as an empty string or strings with no alphabetic characters. - The implementation should efficiently process very large input strings within the constraints.","solution":"def lowercase_count(input_string: str) -> int: This function counts the number of lowercase alphabetic characters in the input string. return sum(1 for char in input_string if char.islower()) def uppercase_count(input_string: str) -> int: This function counts the number of uppercase alphabetic characters in the input string. return sum(1 for char in input_string if char.isupper())"},{"question":"# Question: Function to Implement: `minimize_ticket_cost` Context: You are planning a holiday trip and need to minimize the total cost of your airline tickets. There are several cities you want to visit, but there are no direct flights between every pair of cities you want to travel. However, you can use neighboring cities as layovers to connect to your destination on the trip. Task: You need to implement the function `minimize_ticket_cost`: ```python def minimize_ticket_cost(cost: dict[tuple[str, str], float], start: str, end: str) -> float: Input Parameters ---------------- cost : Dictionary where keys are tuples representing a pair of cities (start_city, end_city) and the values represent the cost of airline tickets between those cities. start : Starting city for the trip. end : Ending city for the trip. Returns ------- result : float The minimum cost to travel from \'start\' city to \'end\' city. If there is no possible way to connect from \'start\' city to \'end\' city, return -1. ``` Examples: 1. Given the costs: ```python cost = { (\'A\', \'B\'): 100, (\'B\', \'C\'): 150, (\'A\', \'D\'): 200, (\'D\', \'C\'): 50 } ``` `minimize_ticket_cost(cost, \'A\', \'C\')` should return `250` (A -> B -> C). 2. Given the costs: ```python cost = { (\'A\', \'B\'): 100, (\'B\', \'C\'): 150, } ``` `minimize_ticket_cost(cost, \'A\', \'C\')` should return `250` (A -> B -> C). 3. Given the costs: ```python cost = { (\'A\', \'B\'): 100, (\'B\', \'C\'): 150, } ``` `minimize_ticket_cost(cost, \'A\', \'D\')` should return `-1` (No connection from A to D). Constraints: * The dictionary `cost` will contain at most 100,000 entries. * City names are strings consisting of uppercase English letters with a maximum length of 100 characters. * Ticket costs will be non-negative floats. * If there is no possible way to connect from the `start` city to the `end` city, the function should return -1. Edge Cases: * Direct flights are available (e.g., from \'A\' to \'B\'). * Indirect flights with one or multiple layovers. * No flights available from the `start` city to the `end` city. * Cost dictionary is empty.","solution":"from heapq import heappop, heappush from collections import defaultdict import math def minimize_ticket_cost(cost: dict[tuple[str, str], float], start: str, end: str) -> float: # Dictionary to represent the graph graph = defaultdict(list) for (u, v), price in cost.items(): graph[u].append((v, price)) # Priority queue (min-heap) for Dijkstra\'s algorithm pq = [(0, start)] # (current cost, current city) min_cost = {start: 0} while pq: curr_cost, u = heappop(pq) if u == end: return curr_cost for v, price in graph[u]: next_cost = curr_cost + price if next_cost < min_cost.get(v, math.inf): min_cost[v] = next_cost heappush(pq, (next_cost, v)) return -1 # If there\'s no path from start to end"},{"question":"# Image Encryption: Matrix Rotation **Context**: In this task, you will implement functions to rotate an image represented by an NxN matrix by 90 degrees clockwise and counterclockwise. **Objective**: Write functions to rotate the given matrix (image) by 90 degrees clockwise and 90 degrees counterclockwise. **Function Specifications**: 1. **rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]** - Input: * `matrix`: An NxN matrix representing the image. - Output: * The matrix rotated by 90 degrees clockwise. 2. **rotate_matrix_counterclockwise(matrix: List[List[int]]) -> List[List[int]]** - Input: * `matrix`: An NxN matrix representing the image. - Output: * The matrix rotated by 90 degrees counterclockwise. **Requirements**: - Do not use any built-in functions that directly perform matrix rotation. - Ensure your solution is efficient and handles edge cases like empty matrices. - The transformed matrix should maintain the original dimensions but with elements rotated as specified. **Example**: ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_clockwise = rotate_matrix_clockwise(matrix) print(f\\"Rotated Clockwise = {rotated_clockwise}\\") # Expected Output: # Rotated Clockwise = # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] rotated_counterclockwise = rotate_matrix_counterclockwise(matrix) print(f\\"Rotated Counterclockwise = {rotated_counterclockwise}\\") # Expected Output: # Rotated Counterclockwise = # [ # [3, 6, 9], # [2, 5, 8], # [1, 4, 7] # ] ``` **Solution**: Here are the two required functions implemented in Python: ```python from typing import List def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Create a new matrix of the same size to hold the rotated matrix. rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix def rotate_matrix_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: n = len(matrix) # Create a new matrix of the same size to hold the rotated matrix. rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[n - 1 - j][i] = matrix[i][j] return rotated_matrix ``` Make sure to test the functions with different matrix sizes and edge cases to ensure correctness.","solution":"from typing import List def rotate_matrix_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees clockwise. Args: matrix (List[List[int]]): The input NxN matrix. Returns: List[List[int]]: The rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[j][n - 1 - i] = matrix[i][j] return rotated_matrix def rotate_matrix_counterclockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates an NxN matrix 90 degrees counterclockwise. Args: matrix (List[List[int]]): The input NxN matrix. Returns: List[List[int]]: The rotated matrix. n = len(matrix) rotated_matrix = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated_matrix[n - 1 - j][i] = matrix[i][j] return rotated_matrix"},{"question":"# CODING ASSESSMENT QUESTION Introduction You are working as an analyst in a logistics company and need to develop a software tool to assist in calculating the optimal loading of boxes into a truck. The truck has a maximum weight capacity, and there are multiple boxes, each with a specific weight. Your goal is to maximize the number of boxes loaded into the truck without exceeding the weight capacity. Problem Description Write a function `max_boxes_loaded` to compute the maximum number of boxes that can be loaded into the truck without exceeding the given weight capacity. - Inputs: - `max_capacity` (int): The maximum weight capacity of the truck in kilograms. - `box_weights` (List[int]): A list of integers representing the weights of the boxes in kilograms. - Output: (int) The maximum number of boxes that can be loaded. - Constraints: - `1 <= max_capacity <= 10^6` - `1 <= len(box_weights) <= 10^3` - `1 <= box_weights[i] <= 10^3` for each i Function Signature ```python def max_boxes_loaded(max_capacity: int, box_weights: List[int]) -> int: pass ``` Expected Input and Output ``` >>> max_boxes_loaded(50, [10, 20, 30, 40]) 2 >>> max_boxes_loaded(100, [50, 50, 50, 50, 50]) 2 >>> max_boxes_loaded(500, [100, 200, 300, 150, 120, 130, 110]) 4 >>> max_boxes_loaded(1000, [100, 100, 100, 100, 100, 100, 100, 100, 100, 100]) 10 ``` Constraints 1. If the `max_capacity` is less than the smallest box weight, the function should return `0`. 2. Use the function signature provided and ensure the function behavior matches the examples given. Provide an efficient solution that considers the problem constraints and optimally loads the truck. Verify edge cases and validate results with the provided examples.","solution":"def max_boxes_loaded(max_capacity: int, box_weights: list) -> int: Returns the maximum number of boxes that can be loaded into the truck without exceeding the maximum weight capacity. # Sort the list of box weights in ascending order box_weights.sort() # Initialize the total weight and the count of boxes total_weight = 0 count = 0 # Iterate through the sorted list and add boxes until the max capacity is reached or exceeded for weight in box_weights: if total_weight + weight <= max_capacity: total_weight += weight count += 1 else: break return count"},{"question":"# Problem Statement You are tasked with implementing a function `reverse_words_in_place` that reverses the words in a given string in place. The function should not use any additional space for another string or array, ensuring that the reversal is done in place. This problem is useful in understanding in-place algorithms and manipulation of character arrays. # Function Signature ```python def reverse_words_in_place(s: str) -> str: ``` # Input 1. `s` (str): A string containing words separated by spaces. # Output - Returns the input string with the words reversed in place. # Constraints - The input string will only contain printable ASCII characters and spaces. - Words are separated by a single space. - The length of the input string will be between 1 and 10^4. # Example ```python # Example 1 s = \\"the quick brown fox\\" print(reverse_words_in_place(s)) # Output: \\"fox brown quick the\\" # Example 2 s = \\"hello world\\" print(reverse_words_in_place(s)) # Output: \\"world hello\\" ``` # Notes - Ensure your implementation handles potential leading and trailing spaces gracefully. - You cannot use additional data structures such as lists or arrays to achieve the result. - Words must retain their order, but the entire string of words must be reversed. - Properly handle edge cases such as strings with a single word or strings consisting of only spaces. # Edge Cases to Consider - A string with only one word. - A string consisting of only spaces. - A string with extremely long words. # Testing - Include tests to cover typical use cases and edge cases. - Utilize the `doctest` library to verify your solution. ```python def reverse_words_in_place(s: str) -> str: Given a string of words separated by spaces, return a new string with the words in reversed order. Examples: >>> reverse_words_in_place(\\"the quick brown fox\\") \'fox brown quick the\' >>> reverse_words_in_place(\\"hello world\\") \'world hello\' >>> reverse_words_in_place(\\" \\") \'\' >>> reverse_words_in_place(\\"word\\") \'word\' words = s.split() return \' \'.join(reversed(words)) ```","solution":"def reverse_words_in_place(s: str) -> str: Given a string of words separated by spaces, return a new string with the words in reversed order. Args: s (str): Input string Returns: str: String with words reversed in place Examples: >>> reverse_words_in_place(\\"the quick brown fox\\") \'fox brown quick the\' >>> reverse_words_in_place(\\"hello world\\") \'world hello\' >>> reverse_words_in_place(\\" \\") \'\' >>> reverse_words_in_place(\\"word\\") \'word\' words = s.split() return \' \'.join(reversed(words))"},{"question":"# Evaluating Expression Trees **Objective**: Write a Python function to evaluate an expression tree and return the computed result. The expression tree contains basic arithmetic operations. **Function Signature**: ```python def evaluate_expression_tree(root: Node | None) -> int: ``` Input: 1. **`root`** (Node | None): The root node of the expression tree. Output: An integer representing the result of the evaluated expression. Constraints: 1. The tree can contain any number of nodes, including zero (an empty tree). 2. Each node contains a value that can either be an integer or one of the operators \'+\', \'-\', \'*\', or \'/\'. 3. Division should assume integer division where the result of \'7 / 2\' would be \'3\'. 4. All operations are performed using left-to-right traversal. Example Scenarios: Here are some example scenarios to illustrate the expected outputs: 1. **Example 1:** * Input: ``` \'+\' / 3 \'*\' / 2 4 ``` * Output: `11` (because 3 + (2 * 4) = 3 + 8 = 11) 2. **Example 2:** * Input: ``` \'-\' / 6 \'/\' / 12 4 ``` * Output: `3` (because 6 - (12 / 4) = 6 - 3 = 3) 3. **Example 3:** * Input: `None` * Output: `0` (Empty tree represents 0) 4. **Example 4:** * Input: ``` \'-\' / 10 \'+\' / 5 3 ``` * Output: `2` (because 10 - (5 + 3) = 10 - 8 = 2) Additional Requirements: 1. Your implementation must be efficient with respect to both time and space. 2. Please include sufficient tests to validate your implementation, covering both typical and edge cases. Use the given structure for the TreeNode class: ```python @dataclass class Node: value: str left: Node | None = None right: Node | None = None ``` Implement the function considering the structure of the given TreeNode class and ensure to cover various edge cases for robustness.","solution":"from dataclasses import dataclass from typing import Union, Optional @dataclass class Node: value: str left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def evaluate_expression_tree(root: Optional[Node]) -> int: if root is None: return 0 # If the node is a leaf (i.e., it\'s an integer) if root.left is None and root.right is None: return int(root.value) # Recursively evaluate the left and right subtrees left_val = evaluate_expression_tree(root.left) right_val = evaluate_expression_tree(root.right) # Perform the operation specified by the current node if root.value == \'+\': return left_val + right_val elif root.value == \'-\': return left_val - right_val elif root.value == \'*\': return left_val * right_val elif root.value == \'/\': return left_val // right_val # Integer division else: raise ValueError(f\\"Unknown operator: {root.value}\\")"},{"question":"# Coding Assessment Question Context Arrays often require manipulation to conform to specific criteria, such as having all elements in non-decreasing order. One common operation to achieve this is deciding the minimum number of changes needed to transform an array into a non-decreasing array. Task Write a function `min_changes_to_non_decreasing` that takes a list of integers and returns the minimum number of changes needed to make the array non-decreasing. A change is defined as either increasing or decreasing an element to match the adjacent values. * **Input**: * A list of integers `arr` (0 ≤ len(arr) ≤ 10^5, -10^9 ≤ arr[i] ≤ 10^9) which denotes the array to be transformed. * **Output**: * An integer representing the minimum number of changes needed. For example: ```python >>> min_changes_to_non_decreasing([3, 5, 3, 7]) 1 >>> min_changes_to_non_decreasing([4, 2, 3]) 1 ``` Constraints * The input list `arr` could be very large, so your solution should be efficient in terms of both time and space complexity. Requirements * Ensure your function handles edge cases, such as empty arrays or arrays that are already non-decreasing. * Your solution should handle large arrays efficiently and avoid unnecessary computations. Performance Your solution should ideally aim for linear time complexity, `O(n)`, where `n` is the number of elements in the array. Edge Cases * Handle cases where the input array is empty. * Handle cases where the input array is already in non-decreasing order. # Example The following illustrates the expected result: ```python >>> min_changes_to_non_decreasing([10, 5, 1, 2, 3]) 3 >>> min_changes_to_non_decreasing([5, 4, 3, 2, 1]) 4 ``` # Implement the function below: ```python def min_changes_to_non_decreasing(arr): # Your code here pass ```","solution":"def min_changes_to_non_decreasing(arr): Returns the minimum number of changes needed to make the array non-decreasing. A change is defined as either increasing or decreasing an element. if len(arr) <= 1: return 0 changes = 0 for i in range(1, len(arr)): if arr[i] < arr[i - 1]: changes += 1 arr[i] = arr[i - 1] # Adjust the current element to maintain non-decreasing order. return changes"},{"question":"You are given an incomplete 9x9 Sudoku grid represented by a 2D list, where empty cells are denoted by 0. Your task is to implement a backtracking algorithm to solve the Sudoku puzzle and fill in the missing numbers. # Function Signature ```python def solve_sudoku(board: list[list[int]]) -> bool: pass ``` # Input - `board`: A 2D list of integers representing a 9x9 Sudoku grid (length of `board` and `board[i]` is always 9 for all `i`; elements in `board` are integers between 0 and 9). # Output - Return `True` if the Sudoku can be solved and modify the input `board` in-place to contain the solved puzzle. - Return `False` if the Sudoku is unsolvable. # Constraints 1. The given Sudoku puzzle will always have a unique solution. 2. The board will be partially filled with valid numbers, and there will always be at least one empty cell. 3. The function should modify the board in-place without using additional 2D lists. # Examples ```python board = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] assert solve_sudoku(board) == True assert board == [ [5, 3, 4, 6, 7, 8, 9, 1, 2], [6, 7, 2, 1, 9, 5, 3, 4, 8], [1, 9, 8, 3, 4, 2, 5, 6, 7], [8, 5, 9, 7, 6, 1, 4, 2, 3], [4, 2, 6, 8, 5, 3, 7, 9, 1], [7, 1, 3, 9, 2, 4, 8, 5, 6], [9, 6, 1, 5, 3, 7, 2, 8, 4], [2, 8, 7, 4, 1, 9, 6, 3, 5], [3, 4, 5, 2, 8, 6, 1, 7, 9] ] ``` # Additional Notes 1. Ensure your function correctly modifies the input `board` in-place to contain the solved Sudoku puzzle. 2. The Sudoku board will always start out valid according to Sudoku rules (numbers 1 to 9 appear at most once in each row, column, and 3x3 sub-grid).","solution":"def solve_sudoku(board: list[list[int]]) -> bool: def is_valid(board, row, col, num): # Check if num is in the current row for x in range(9): if board[row][x] == num: return False # Check if num is in the current column for x in range(9): if board[x][col] == num: return False # Check if num is in the current 3x3 sub-grid start_row, start_col = 3 * (row // 3), 3 * (col // 3) for i in range(3): for j in range(3): if board[i + start_row][j + start_col] == num: return False return True def solve(): for row in range(9): for col in range(9): if board[row][col] == 0: for num in range(1, 10): if is_valid(board, row, col, num): board[row][col] = num if solve(): return True board[row][col] = 0 return False return True return solve()"},{"question":"Word Subset Finder # Scenario You are developing a function to identify subsets of words from a list that can be formed using a specific set of characters. This function will help in applications that involve word games, puzzles, and linguistic pattern analysis. # Function to Implement You need to write a function, `find_word_subsets`, which will accept a string of allowed characters and a list of words, and return a list of words that can be fully formed from the allowed characters. Each character in the allowed string can be used multiple times. # Function Signature ```python def find_word_subsets(allowed: str, words: list) -> list: pass ``` # Input - A string of allowed characters. (1 ≤ len(allowed) ≤ 100) - A list of words. (1 ≤ len(words) ≤ 1000, 1 ≤ len(word) ≤ 100) # Output - A list of words that can be fully formed from the allowed characters. # Constraints - The allowed characters may include any printable ASCII characters. - Handle the case sensitively: \'A\' and \'a\' are considered different characters. # Example ```python find_word_subsets(\\"abcdef\\", [\\"fade\\", \\"bed\\", \\"cab\\", \\"ace\\", \\"fed\\", \\"face\\", \\"deaf\\", \\"bad\\", \\"feed\\"]) ``` Output: ```python [\'fade\', \'bed\', \'cab\', \'ace\', \'fed\', \'face\', \'deaf\', \'bad\'] ``` # Notes - If no words can be formed from the allowed characters, return an empty list. - Consider edge cases such as empty input strings or lists, and ensure graceful error handling where appropriate. - Ensure the function handles performance efficiently for larger inputs. Both the \\"Word Pattern Matcher\\" and \\"Word Subset Finder\\" questions aim to assess the candidate’s ability to manipulate strings and lists, utilize appropriate data structures, and implement effective algorithms to solve problems involving character patterns and subsets. The additional challenge in understanding and matching character arrangements adds a layer of complexity similar to the original question.","solution":"def find_word_subsets(allowed: str, words: list) -> list: Returns a list of words that can be fully formed from the allowed characters. from collections import Counter allowed_count = Counter(allowed) def can_be_formed(word): word_count = Counter(word) for char, cnt in word_count.items(): if allowed_count[char] < cnt: return False return True return [word for word in words if can_be_formed(word)]"},{"question":"# Coding Assessment Question 2 Scenario: You need to develop a program for scheduling tasks based on their dependencies. Each task is identified by a unique label, and the dependencies form a Directed Acyclic Graph (DAG). Implement a function to detect any potential cycles in this DAG to ensure all tasks can be completed without any circular dependencies. Task: Write a function `detect_cycle(nodes: List[str], dependencies: Dict[str, List[str]]) -> bool` that checks if the given graph contains any cycles. If a cycle is detected, the function should return `True`, indicating a circular dependency. Otherwise, it should return `False`. Input: 1. `nodes`: A list of strings representing the task labels. 2. `dependencies`: A dictionary where keys are task labels and values are lists of dependencies (also labels). Output: - A boolean value indicating whether there is a cyclic dependency (True for cycle, False for no cycle). Constraints: - All input tasks form a Directed Acyclic Graph (DAG) by definition, but it\'s possible to receive input that isn\'t a DAG. - Task labels are unique. - The graph may have disconnected components. Example: ```python nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\", \\"Task4\\"] dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [\\"Task4\\"], \\"Task4\\": [\\"Task1\\"] # This creates a cycle } print(detect_cycle(nodes, dependencies)) # Output: True nodes = [\\"Task1\\", \\"Task2\\", \\"Task3\\"] dependencies = { \\"Task1\\": [\\"Task2\\"], \\"Task2\\": [\\"Task3\\"], \\"Task3\\": [] } print(detect_cycle(nodes, dependencies)) # Output: False ``` # Performance Requirements: - The time complexity should be O(V + E). - The algorithm should handle up to 10,000 tasks efficiently. Note: - Ensure to test for graphs with multiple disconnected components. - Also, handle edge cases where tasks have no dependencies or all tasks are disconnected. # Explanation: - Use depth-first search (DFS) or Kahn’s algorithm to detect cycles in the graph. - Carefully consider the possibility of multi-component graphs and handle accordingly.","solution":"from typing import List, Dict def detect_cycle(nodes: List[str], dependencies: Dict[str, List[str]]) -> bool: Detect if there is a cycle in the task graph. Returns True if there is a cycle, otherwise False. def dfs(node, visited, rec_stack): if visited[node] == False: visited[node] = True rec_stack[node] = True for neighbor in dependencies.get(node, []): if visited[neighbor] == False: if dfs(neighbor, visited, rec_stack) == True: return True elif rec_stack[neighbor] == True: return True rec_stack[node] = False return False visited = {node: False for node in nodes} rec_stack = {node: False for node in nodes} for node in nodes: if visited[node] == False: if dfs(node, visited, rec_stack) == True: return True return False"},{"question":"# String Segmentation to Form Dictionary Words You are given a string `s` and a list of words `wordDict`. You need to segment the string `s` into a space-separated sequence of one or more dictionary words from `wordDict`. Determine if the segmentation is possible such that each word in the sequence is found in `wordDict`. # Problem Statement **Input:** - A string `s`. - A list of strings `wordDict` where each string is a word. **Output:** - A boolean value indicating whether string `s` can be segmented into a space-separated sequence of one or more dictionary words. # Function Signature ```python def word_break(s: str, wordDict: List[str]) -> bool: ``` # Constraints: - 1 <= len(s) <= 300 - 1 <= len(wordDict) <= 1000 - 1 <= len(wordDict[i]) <= 20 - All characters in `s` and `wordDict[i]` are lowercase English letters # Example: ```python >>> word_break(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True ``` # Explanation: - \\"leetcode\\" can be segmented as \\"leet code\\" which are both words from `wordDict`. # Example: ```python >>> word_break(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True ``` # Explanation: - \\"applepenapple\\" can be segmented as \\"apple pen apple\\" which are all words from `wordDict`. # Example: ```python >>> word_break(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False ``` # Explanation: - The string \\"catsandog\\" cannot be fully segmented using the given dictionary words. # Additional Notes: - Ensure your implementation handles edge cases such as when `s` is empty or when `wordDict` contains overlapping words or words that can form new valid sequences. - Think about the optimal way to check subsequences to ensure the program runs efficiently given the constraints.","solution":"from typing import List def word_break(s: str, wordDict: List[str]) -> bool: word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True # base case: an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)]"},{"question":"# Coding Assessment Question: Implement a Circular Linked List Check Context Expanding on the linked list structure, your task is to write a function within the `LinkedList` class to check if the linked list is circular. A linked list is considered circular if it has no end (i.e., if a node\'s `next` pointer eventually points back to some previous node in the list). Input & Output *Input*: None. The function operates on the linked list instance. *Output*: The function should return `True` if the list is circular, and `False` otherwise. Constraints 1. The function should handle empty lists. 2. The function should work efficiently, checking for circularity in O(n) time complexity and O(1) additional space complexity. Function Signature ```python class LinkedList: # Assume all other methods are defined as in the given snippet def is_circular(self) -> bool: Checks if the linked list is circular. Returns: True if the list is circular, False otherwise. ``` Scenario Consider the following scenario to further illustrate: ```python link = LinkedList() link.push(1) link.push(2) link.push(3) # Creating a loop for testing link.head.next.next.next = link.head # Circular print(link.is_circular()) # Expected output: True ``` In the example above, the linked list `3 -> 2 -> 1 -> 3 -> ...` is circular. Hence, the function should return `True`. Complete the `is_circular()` function to determine the circularity of the linked list.","solution":"class Node: def __init__(self, data): self.data = data self.next = None class LinkedList: def __init__(self): self.head = None def push(self, new_data): new_node = Node(new_data) new_node.next = self.head self.head = new_node def is_circular(self) -> bool: Checks if the linked list is circular. Returns: True if the list is circular, False otherwise. if not self.head: return False slow = self.head fast = self.head while fast and fast.next: slow = slow.next fast = fast.next.next if slow == fast: return True return False"},{"question":"# Coding Assessment Question: Scenario: You are working as a software developer in a company that creates bookkeeping software. As part of the software development, you need to implement a module that checks for balanced parentheses in mathematical expressions. This is to ensure the expressions input by users are syntactically correct before further processing. Task: Write the function `is_balanced(expression)` to check if the parentheses in a mathematical expression are balanced. Function Specifications: - **Function**: is_balanced - **Input**: - `expression` (str): A string containing a mathematical expression. - **Output**: - (bool): `True` if the parentheses are balanced, `False` otherwise. Constraints: - `1 <= len(expression) <= 10^5` - The expression will only contain parentheses `(`, `)`, and non-parentheses characters (mathematical operators, digits, spaces, etc.). # Example: ```python expression = \\"(3 + (2 * 5))\\" print(is_balanced(expression)) # Output: True expression = \\"(3 + 2 * 5)\\" print(is_balanced(expression)) # Output: True expression = \\"(3 + (2 * 5)\\" print(is_balanced(expression)) # Output: False expression = \\"3 + 2) * 5(\\" print(is_balanced(expression)) # Output: False ``` **Note**: Ensure your function accounts for various edge cases such as empty expressions, expressions with no parentheses, and expressions with mismatched or nested parentheses.","solution":"def is_balanced(expression): Checks if the parentheses in the given expression are balanced. Args: - expression: str, a string containing a mathematical expression. Returns: - bool: True if the parentheses are balanced, False otherwise. stack = [] for char in expression: if char == \'(\': stack.append(char) elif char == \')\': if not stack: return False stack.pop() return not stack"},{"question":"# Question: Job Scheduling with Deadlines and Profits You are given `n` jobs where each job has a deadline and a profit associated with it. The task is to find the maximum profit that can be earned by scheduling the jobs using a single processor. Each job takes a single unit of time to complete, and a job can only be completed if it is finished by its deadline. # Function Signature ```python def job_scheduling(jobs: List[Tuple[int, int]], max_deadline: int) -> int: pass ``` # Input * `jobs`: A list of tuples where each tuple contains two integers `(profit, deadline)` indicating the profit and deadline of a job. * `max_deadline`: An integer representing the maximum deadline of any job. # Output * An integer representing the maximum profit that can be earned by scheduling the jobs appropriately. # Example Consider the following jobs and deadlines: ```python jobs = [(20, 2), (15, 2), (10, 1), (5, 3), (1, 3)] max_deadline = 3 ``` When calling the function: ```python result = job_scheduling(jobs, max_deadline) ``` The result should be `40`. # Constraints & Notes 1. The job profits and deadlines are all positive integers. 2. You should consider optimizing the schedule to maximize the profit. 3. If multiple jobs have the same deadline, you can choose the order in which they are processed to maximize the profit. 4. The maximum deadline corresponds to the number of maximum time slots available. # Performance * Your solution should aim to be efficient in terms of both time and space complexity. * Sorting the jobs based on profit and arranging them within available slots can be a viable approach. Write your implementation of the `job_scheduling` function:","solution":"from typing import List, Tuple def job_scheduling(jobs: List[Tuple[int, int]], max_deadline: int) -> int: # Sort the jobs by their profit in descending order jobs.sort(key=lambda x: -x[0]) # Initialize time slots to track which time slots are occupied time_slots = [False] * max_deadline total_profit = 0 for profit, deadline in jobs: # Find a time slot from deadline to 1 (0-indexed) for t in range(min(deadline, max_deadline) - 1, -1, -1): if not time_slots[t]: time_slots[t] = True total_profit += profit break return total_profit"},{"question":"# Minimum Element in Sliding Window You are required to implement a function that finds the minimum element in every sliding window of size `k` across a given list of integers. **Function Signature:** ```python def min_in_sliding_window(nums, k): :param nums: List[int] - list of integers. :param k: int - size of the sliding window. :return: List[int] - list of minimum elements for each sliding window. pass ``` **Specifications:** 1. **Input Format**: - `nums`: List of `n` integers. - `k`: An integer representing the size of the sliding window. 2. **Constraints**: - 1 <= n <= 10^5 - 1 <= k <= n - -10^4 <= nums[i] <= 10^4 for 0 <= i < n 3. **Output**: - A list of integers representing the minimum element in each sliding window of size `k` across the `nums` list. **Performance Requirements**: Solution must be optimized to run in O(n) time complexity. **Example**: ```python nums = [1, 3, -1, -3, 5, 3, 6, 7] k = 3 print(min_in_sliding_window(nums, k)) # Expected Output: [-1, -3, -3, -3, 3, 3] ``` **Description**: You should implement an efficient algorithm to determine the minimum element in each sliding window of size `k` in the array `nums`. Use a deque or a similar data structure to maintain the indices of elements and ensure the time complexity remains linear.","solution":"from collections import deque def min_in_sliding_window(nums, k): Finds the minimum element in every sliding window of size k across nums. :param nums: List[int] - list of integers. :param k: int - size of the sliding window. :return: List[int] - list of minimum elements for each sliding window. if not nums or k == 0: return [] n = len(nums) if k == 1: return nums result = [] dq = deque() # store indices of nums, elements are in non-decreasing order for i in range(n): # Remove indices that are out of the current window if dq and dq[0] == i - k: dq.popleft() # Remove elements from the deque that are greater than the current element while dq and nums[dq[-1]] > nums[i]: dq.pop() dq.append(i) # The first index in deque is the minimum element index in the current window if i >= k - 1: result.append(nums[dq[0]]) return result"},{"question":"# Flatten Nested List **Context**: Working with nested structures is a common task in programming. A nested list can have multiple levels of lists within lists, which makes operations like flattening a bit more complex. The goal is to flatten such nested lists into a single list with all the elements at the same level. **Objective**: Implement the `flatten` function to transform a nested list of arbitrary depth into a flat list. Ensure your implementation handles multiple levels of nested lists correctly. **Function Signature**: ```python def flatten(nested_list: list) -> list: pass ``` **Expected Input and Output**: * Input: A single list, which may contain other lists nested arbitrarily deep. * Output: A single list containing all the elements of the input list, but no nested lists. **Performance Requirements**: * The function should handle deeply nested structures efficiently. * Ensure the function manages memory appropriately without excessive overhead. **Constraints**: * The input list can contain any data type (integers, strings, etc.), but will be nested. * The function should preserve the order of elements. **Example Cases**: * Single Level Nested List: * Input: `[1, [2, 3], [4, 5]]` * Output: `[1, 2, 3, 4, 5]` * Multiple Levels Nested List: * Input: `[1, [2, [3, [4]]], 5]` * Output: `[1, 2, 3, 4, 5]` * Deeply Nested List: * Input: `[[[[1]]], 2, [[[3, 4]]], [5, [6]]]` * Output: `[1, 2, 3, 4, 5, 6]` **Test Cases**: Provide a comprehensive set of tests ensuring that the function handles all typical and edge cases, including: * Empty list. * Single element lists. * Deeply nested structures. * Mixed data types within the nested lists. **Implementation Example**: ```python def flatten(nested_list: list) -> list: flat_list = [] def _flatten(sub_list): for item in sub_list: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_list) return flat_list def test_flatten() -> None: assert flatten([1, [2, 3], [4, 5]]) == [1, 2, 3, 4, 5] assert flatten([1, [2, [3, [4]]], 5]) == [1, 2, 3, 4, 5] assert flatten([[[[1]]], 2, [[[3, 4]]], [5, [6]]]) == [1, 2, 3, 4, 5, 6] assert flatten([[], [[]], [[[[[[]]]]]]]) == [] assert flatten([[1, 2], [3, 4, [5, [6, 7]]], [8, [9, [10]]]]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] if __name__ == \\"__main__\\": print(flatten([1, [2, 3], [4, 5]])) # Expected output: [1, 2, 3, 4, 5] print(flatten([1, [2, [3, [4]]], 5])) # Expected output: [1, 2, 3, 4, 5] print(flatten([[[[1]]], 2, [[[3, 4]]], [5, [6]]])) # Expected output: [1, 2, 3, 4, 5, 6] ```","solution":"def flatten(nested_list: list) -> list: Flatten a nested list of arbitrary depth into a single list. flat_list = [] def _flatten(sub_list): for item in sub_list: if isinstance(item, list): _flatten(item) else: flat_list.append(item) _flatten(nested_list) return flat_list"},{"question":"# Coding Question Problem Statement You are given a string `s` and a string `subs`. Your task is to write a Python function called `count_overlapping_occurrences` that counts how many times the substring `subs` appears in the string `s`, allowing for overlapping occurrences. You must handle invalid inputs gracefully by throwing a `ValueError` with the message \\"Input must be a valid non-empty string\\". Requirements - Function Signature: `def count_overlapping_occurrences(s: str, subs: str) -> int:` - **Input**: Two strings, `s` and `subs`. - **Output**: An integer representing the number of overlapping occurrences of `subs` in `s`. - **Constraints**: Both `s` and `subs` should be non-empty. Example ```python >>> count_overlapping_occurrences(\\"abababa\\", \\"aba\\") 3 >>> count_overlapping_occurrences(\\"aaaa\\", \\"aa\\") 3 >>> count_overlapping_occurrences(\\"abcdef\\", \\"gh\\") 0 >>> count_overlapping_occurrences(\\"abababa\\", \\"\\") Traceback (most recent call last): ... ValueError: Input must be a valid non-empty string >>> count_overlapping_occurrences(\\"\\", \\"abc\\") Traceback (most recent call last): ... ValueError: Input must be a valid non-empty string >>> count_overlapping_occurrences(123, \\"ab\\") Traceback (most recent call last): ... ValueError: Input must be a valid non-empty string >>> count_overlapping_occurrences(None, \\"abc\\") Traceback (most recent call last): ... ValueError: Input must be a valid non-empty string ``` Constraints - The function should handle input errors by raising `ValueError` with the message \\"Input must be a valid non-empty string\\". - The function should efficiently handle the string operations to account for larger strings as input. Additional Notes - Consider using string searching algorithms for finding overlapping patterns. - Make sure your implementation is robust and thorough in handling edge cases and constraints.","solution":"def count_overlapping_occurrences(s: str, subs: str) -> int: if not isinstance(s, str) or not isinstance(subs, str) or not s or not subs: raise ValueError(\\"Input must be a valid non-empty string\\") count = start = 0 while True: start = s.find(subs, start) if start == -1: break count += 1 start += 1 # Move to the next character to allow overlapping return count"},{"question":"Problem Description You need to implement a system for managing user access to various resources in a software application. The access is managed based on user roles and permissions. Users can be assigned multiple roles, and each role can have multiple permissions. Your task is to implement the following functionalities: 1. **Adding and Removing Roles**: * Implement functions to add and remove roles to/from users. 2. **Assigning and Revoking Permissions**: * Implement functions to assign and revoke permissions from roles. 3. **Checking Access**: * Implement a function to check if a user has a specific permission. # Details Role and Permission Management * Roles are represented as strings (e.g., \\"admin\\", \\"editor\\", \\"viewer\\"). * Permissions are also represented as strings (e.g., \\"read\\", \\"write\\", \\"delete\\"). Functions 1. **Function 1: `add_role_to_user`** * **Input**: * `user_roles` (dict): Dictionary mapping user names to a set of roles. * `user` (string): The user to which the role should be added. * `role` (string): The role to be added to the user. * **Output**: * The `user_roles` dictionary after the role has been added. 2. **Function 2: `remove_role_from_user`** * **Input**: * `user_roles` (dict): Dictionary mapping user names to a set of roles. * `user` (string): The user from which the role should be removed. * `role` (string): The role to be removed from the user. * **Output**: * The `user_roles` dictionary after the role has been removed. 3. **Function 3: `assign_permission_to_role`** * **Input**: * `role_permissions` (dict): Dictionary mapping roles to a set of permissions. * `role` (string): The role to which the permission should be assigned. * `permission` (string): The permission to be assigned to the role. * **Output**: * The `role_permissions` dictionary after the permission has been assigned. 4. **Function 4: `revoke_permission_from_role`** * **Input**: * `role_permissions` (dict): Dictionary mapping roles to a set of permissions. * `role` (string): The role from which the permission should be revoked. * `permission` (string): The permission to be revoked from the role. * **Output**: * The `role_permissions` dictionary after the permission has been revoked. 5. **Function 5: `check_permission`** * **Input**: * `user_roles` (dict): Dictionary mapping user names to a set of roles. * `role_permissions` (dict): Dictionary mapping roles to a set of permissions. * `user` (string): The user to check. * `permission` (string): The permission to check. * **Output**: * `True` if the user has the specified permission, `False` otherwise. # Example ```python user_roles = { \\"alice\\": {\\"admin\\"}, \\"bob\\": {\\"editor\\", \\"viewer\\"} } role_permissions = { \\"admin\\": {\\"read\\", \\"write\\", \\"delete\\"}, \\"editor\\": {\\"read\\", \\"write\\"}, \\"viewer\\": {\\"read\\"} } # Add a new role to a user user_roles = add_role_to_user(user_roles, \\"charlie\\", \\"editor\\") # Remove a role from a user user_roles = remove_role_from_user(user_roles, \\"bob\\", \\"viewer\\") # Assign a new permission to a role role_permissions = assign_permission_to_role(role_permissions, \\"editor\\", \\"publish\\") # Revoke a permission from a role role_permissions = revoke_permission_from_role(role_permissions, \\"editor\\", \\"write\\") # Check if a user has a specific permission print(check_permission(user_roles, role_permissions, \\"alice\\", \\"delete\\")) # True print(check_permission(user_roles, role_permissions, \\"bob\\", \\"read\\")) # True print(check_permission(user_roles, role_permissions, \\"bob\\", \\"write\\")) # False ``` # Assumptions - The `user_roles` dictionary contains valid user names and set of roles. - The `role_permissions` dictionary contains valid roles and set of permissions. - The operations of adding and removing roles or permissions should handle the situation where the role or permission does not exist gracefully. # Constraints - User and role names are strings and are case-sensitive. - Permissions are strings and are case-sensitive.","solution":"def add_role_to_user(user_roles, user, role): Adds a role to a user in the user_roles dictionary. if user not in user_roles: user_roles[user] = set() user_roles[user].add(role) return user_roles def remove_role_from_user(user_roles, user, role): Removes a role from a user in the user_roles dictionary. if user in user_roles and role in user_roles[user]: user_roles[user].remove(role) return user_roles def assign_permission_to_role(role_permissions, role, permission): Assigns a permission to a role in the role_permissions dictionary. if role not in role_permissions: role_permissions[role] = set() role_permissions[role].add(permission) return role_permissions def revoke_permission_from_role(role_permissions, role, permission): Revokes a permission from a role in the role_permissions dictionary. if role in role_permissions and permission in role_permissions[role]: role_permissions[role].remove(permission) return role_permissions def check_permission(user_roles, role_permissions, user, permission): Checks if a user has a specific permission. if user not in user_roles: return False for role in user_roles[user]: if role in role_permissions and permission in role_permissions[role]: return True return False"},{"question":"# Context You are given an array of integers where each integer represents the height of a building. Your task is to determine the maximum amount of water that can be trapped between the buildings after raining. The width of each building is 1 unit. # Function Signature Write a function called `max_trapped_water` that takes in an array of integers and returns a single integer. # Input * An array of integers ( heights ), where each element represents the height of a building. - ( 0 leq |heights| leq 10^5 ) - ( 0 leq heights[i] leq 10^4 ) # Output * Returns an integer representing the maximum amount of water that can be trapped between the buildings. # Constraints 1. The implementation should be efficient with a time complexity of ( O(n) ). # Examples * `max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1])` should return `6`. * `max_trapped_water([4, 2, 0, 3, 2, 5])` should return `9`. * `max_trapped_water([1, 1, 1, 1, 1, 1])` should return `0`. * `max_trapped_water([5, 4, 1, 2])` should return `1`. # Implementation Make sure to consider edge cases such as arrays with less than three elements or arrays with heights of zero.","solution":"def max_trapped_water(heights): Returns the maximum amount of water that can be trapped between the buildings. :param heights: List[int] - an array where each element represents the height of a building. :return: int - the maximum amount of water that can be trapped. if not heights or len(heights) < 3: return 0 left, right = 0, len(heights) - 1 left_max, right_max = heights[left], heights[right] total_water = 0 while left < right: if left_max < right_max: left += 1 left_max = max(left_max, heights[left]) total_water += max(0, left_max - heights[left]) else: right -= 1 right_max = max(right_max, heights[right]) total_water += max(0, right_max - heights[right]) return total_water"},{"question":"# Coding Assessment Question: Create a function that simulates a shopping cart where users can add items, remove items, and calculate the total price. Each item has a name, price, and quantity. Ensure your implementation handles negative quantities and prices gracefully. Function Signature ```python class ShoppingCart: def __init__(self): pass def add_item(self, name: str, price: float, quantity: int): pass def remove_item(self, name: str): pass def get_total_price(self) -> float: pass ``` Input and Output - **Methods**: - `add_item(name: str, price: float, quantity: int)`: Adds the specified quantity of the item to the cart. If the item already exists, update its quantity. - `remove_item(name: str)`: Removes the item from the cart if it exists; otherwise, do nothing. - `get_total_price()`: Computes and returns the total price of all items in the cart. Constraints - `add_item` method: - `name` is a string with 1 ≤ len(name) ≤ 100. - `price` is a non-negative float with a permitted range of 0 ≤ price ≤ 10^7. - `quantity` is a non-negative integer with a permitted range of 0 ≤ quantity ≤ 10^5. - If `quantity` is 0, the item should not be added to the cart. - `remove_item` method should gracefully handle the case where the item does not exist in the cart. - `get_total_price` method should return the total price rounded to two decimal places. Example ```python >>> cart = ShoppingCart() >>> cart.add_item(\\"apple\\", 0.99, 3) >>> cart.add_item(\\"banana\\", 0.49, 2) >>> cart.get_total_price() 3.95 >>> cart.remove_item(\\"apple\\") >>> cart.get_total_price() 0.98 ```","solution":"class ShoppingCart: def __init__(self): self.items = {} def add_item(self, name: str, price: float, quantity: int): if quantity <= 0 or price < 0 or len(name) == 0: return if name in self.items: self.items[name][\'quantity\'] += quantity else: self.items[name] = {\'price\': price, \'quantity\': quantity} def remove_item(self, name: str): if name in self.items: del self.items[name] def get_total_price(self) -> float: total = sum(item[\'price\'] * item[\'quantity\'] for item in self.items.values()) return round(total, 2)"},{"question":"# Scenario You\'ve been approached by a logistics company to help optimize their package delivery routes. They need a functionality to calculate the shortest path to deliver packages from one location to another within a city grid that includes both open paths and obstacles. # Objective Write a function `shortest_path` that determines the shortest path from a starting point to a destination point in a city grid. The grid consists of open paths (denoted by `0`) and obstacles (denoted by `1`). You may move in four possible directions: up, down, left, right. # Specification **Function Signature**: ```python def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: pass ``` **Inputs**: * `grid` (List[List[int]]): A 2D list representing the city grid where `0` indicates an open path and `1` indicates an obstacle. * `start` (Tuple[int, int]): A tuple `(x, y)` representing the starting coordinates within the grid. * `destination` (Tuple[int, int]): A tuple `(x, y)` representing the destination coordinates within the grid. **Output**: * Returns an integer, the minimum number of steps required to reach the destination from the start. If there is no possible path, return `-1`. # Constraints: * The grid dimensions will not exceed `100 x 100`. * The values in the grid will be either `0` or `1`. * The starting point and destination point will be within the grid and valid (i.e., not an obstacle). # Example Usage: ```python grid = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 0, 0, 0], [0, 0, 0, 1, 0] ] start = (0, 0) destination = (4, 4) print(shortest_path(grid, start, destination)) # Expected Output: 8 grid2 = [ [0, 1], [1, 0] ] start2 = (0, 0) destination2 = (1, 1) print(shortest_path(grid2, start2, destination2)) # Expected Output: -1 ``` # Notes: - Consider edge cases where paths are completely blocked by obstacles. - Ensure your function can handle grids of varying sizes efficiently. - Utilize appropriate pathfinding algorithms such as BFS (Breadth-First Search) for optimal pathfinding in grid-based problems.","solution":"from typing import List, Tuple from collections import deque def shortest_path(grid: List[List[int]], start: Tuple[int, int], destination: Tuple[int, int]) -> int: if not grid or not grid[0] or start == destination: return 0 directions = [(0, 1), (0, -1), (1, 0), (-1, 0)] rows, cols = len(grid), len(grid[0]) queue = deque([(start[0], start[1], 0)]) visited = set() visited.add(start) while queue: x, y, step = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0 and (nx, ny) not in visited: if (nx, ny) == destination: return step + 1 queue.append((nx, ny, step + 1)) visited.add((nx, ny)) return -1"},{"question":"# Coding Assessment Question Context In many programming scenarios, converting between units of measurement is a common task. For this exercise, we will consider a simple problem related to time conversion. We need to convert a given number of seconds into a format representing hours, minutes, and seconds. Problem Statement You need to write a Python function `convert_seconds(seconds: int) -> str` that takes an integer number of seconds and returns a string representing the time in hours, minutes, and seconds in the format \\"HH:MM:SS\\". The function should handle invalid inputs appropriately. # Constraints * The input `seconds` will be a non-negative integer (0 ≤ seconds ≤ 10^9). # Expected Function Signature ```python def convert_seconds(seconds: int) -> str: ``` # Input * An integer `seconds` representing the number of seconds to be converted. # Output * A string in the format \\"HH:MM:SS\\" representing the converted time. # Example ```python print(convert_seconds(3661)) # Output: \\"01:01:01\\" print(convert_seconds(0)) # Output: \\"00:00:00\\" print(convert_seconds(86399)) # Output: \\"23:59:59\\" print(convert_seconds(-1)) # Output: ValueError: Seconds must be a non-negative integer. ``` # Constraints 1. The function should raise a `ValueError` with the message \\"Seconds must be a non-negative integer.\\" if the input is a negative value. 2. The function should format each component (hours, minutes, seconds) with two digits, padding with leading zeros if necessary. Additional Notes * Validate the input to ensure it is a non-negative integer. * Use arithmetic operations to divide the total seconds into hours, minutes, and seconds effectively.","solution":"def convert_seconds(seconds: int) -> str: Converts a given number of seconds into a formatted string representing hours, minutes, and seconds as \'HH:MM:SS\'. Args: seconds (int): The number of seconds to convert. Returns: str: The formatted time string in \'HH:MM:SS\' format. Raises: ValueError: If the input seconds is a negative integer. if seconds < 0: raise ValueError(\\"Seconds must be a non-negative integer.\\") hours = seconds // 3600 seconds %= 3600 minutes = seconds // 60 seconds %= 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\""},{"question":"# Problem Statement You are provided with a string that contains digits and characters. Your task is to reformat the string such that all the digits come before all the characters, while preserving their initial relative order. # Input: 1. A string `input_string` containing both digits and letters (1 ≤ len(input_string) ≤ 1000). # Output: A string where all digits are moved to the front and all letters are moved to the back, both in their original relative order as they appeared in `input_string`. # Constraints: - The input string will only contain digits and lowercase English letters. - There will be at least one digit and one letter in the input string. # Example: ```python # Sample input input_string = \\"a1b2c3d4\\" # Expected output \\"1234abcd\\" ``` # Function Signature ```python def reformat_string(input_string: str) -> str: pass ``` # Instructions: 1. Implement the reformatting logic based on the given code snippet. 2. Your function should handle input of varying lengths efficiently. 3. Maintain the relative order of digits and letters as they originally appear in the input string. # Additional Examples ```python # Sample input input_string = \\"a1b2c3\\" # Expected output \\"123abc\\" # Sample input input_string = \\"hello123\\" # Expected output \\"123hello\\" ```","solution":"def reformat_string(input_string: str) -> str: Returns a string where all digits come before all characters, maintaining their initial relative order. digits = [] letters = [] for char in input_string: if char.isdigit(): digits.append(char) elif char.isalpha(): letters.append(char) return \'\'.join(digits + letters)"},{"question":"# Problem Statement: You are tasked with writing a function to validate a given pattern within a list of integers, where the pattern represents an \\"increasing hill\\" - a sequence that strictly increases to a peak and then strictly decreases. The hill must have at least three elements and must form a unique peak. # Background: An \\"increasing hill\\" pattern requires a sequence of numbers that first strictly increases to a single maximum value and then strictly decreases. The sequence must have a minimum length of three elements, and there should be exactly one peak (highest point) in the transition. # Function Requirements: Implement the following function: ```python def is_increasing_hill(arr: list) -> bool: Checks if the given list of integers forms a valid increasing hill pattern. :param arr: list of integers :return: True if valid, False otherwise Example: >>> is_increasing_hill([1, 2, 3, 2, 1]) True # Your implementation here ``` # Constraints: * The list will have length within the range (3 leq len(arr) leq 10^6). * Elements in the list are within the range (-10^6 leq text{arr[i]} leq 10^6). # Expected Input and Output: * **Input**: A list of integers (text{arr}) * **Output**: A boolean value representing whether the list forms an increasing hill pattern. # Examples: ```python # Example 1 assert is_increasing_hill([1, 2, 3, 2, 1]) == True # Example 2 assert is_increasing_hill([1, 3, 2]) == True # Example 3 assert is_increasing_hill([1, 2, 2, 1]) == False # Example 4 assert is_increasing_hill([1, 1, 1, 1]) == False # Example 5 assert is_increasing_hill([1]) == False ``` # Performance Requirements: * Your solution should efficiently handle the expected length of the list up to (10^6). # Notes: - To solve the problem, you will need to iterate through the provided list and validate the increasing and then decreasing sequence with the unique peak condition. - Consider edge cases, such as lists with no elements, lists with only increasing or only decreasing sequences, and lists that contain equal consecutive elements.","solution":"def is_increasing_hill(arr: list) -> bool: Checks if the given list of integers forms a valid increasing hill pattern. :param arr: list of integers :return: True if valid, False otherwise n = len(arr) if n < 3: return False i = 0 # Traverse uphill while i + 1 < n and arr[i] < arr[i + 1]: i += 1 # Peak can\'t be first or last element if i == 0 or i == n - 1: return False # Traverse downhill while i + 1 < n and arr[i] > arr[i + 1]: i += 1 # If we reached the end, it\'s a valid hill return i == n - 1"},{"question":"# Coding Challenge You are developing an inventory management system for an online bookstore. The system needs to predict the future sales of books based on historical sales data using ensemble modeling and perform quality checks for stock replenishment decisions. Requirements: 1. **Implement** two predictive algorithms: - **Random Forest Prediction** (`random_forest_predictor`). - **Gradient Boosting Prediction** (`gradient_boosting_predictor`). 2. **Implement** a stock quality assessment system: - **Z-Score Checker** (`z_score_checker`). - **Stock Quality Checker** (`stock_quality_checker`). 3. **Process** provided historical sales data and predict the book sales for the next day. Determine if the book stock is of acceptable quality for replenishment based on predicted values and actual sales data. # Input: - Historical sales data is provided in three lists: dates, total sales, and stock levels. - Actual sales for the next day as a float. # Output: - A boolean value indicating whether the predicted next day\'s sales justify the quality of stock replenishment (`true` for acceptable quality, `false` for low quality). # Constraints: - Lists will have a minimum size of 10. - All values in lists will be positive integers. - Predictions should handle edge cases like insufficient data length gracefully. # Implementation Details: - Implement the predictive functions `random_forest_predictor` and `gradient_boosting_predictor`. - Implement quality assessment functions `z_score_checker` and `stock_quality_checker`. # Example: ```python data_dates = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] total_sales = [20, 25, 30, 35, 40, 45, 30, 50, 55, 60] stock_levels = [100, 85, 70, 65, 75, 80, 90, 60, 65, 70] actual_next_day_sales = 65 # You need to process the data # Implement predictive models # Implement stock quality assessment system # Expected output: # True or False (indicating if the book stock is of acceptable quality) ```","solution":"import numpy as np from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor from scipy.stats import zscore def random_forest_predictor(dates, total_sales): model = RandomForestRegressor() dates = np.array(dates).reshape(-1, 1) model.fit(dates, total_sales) next_day = [[dates[-1, 0] + 1]] prediction = model.predict(next_day) return prediction[0] def gradient_boosting_predictor(dates, total_sales): model = GradientBoostingRegressor() dates = np.array(dates).reshape(-1, 1) model.fit(dates, total_sales) next_day = [[dates[-1, 0] + 1]] prediction = model.predict(next_day) return prediction[0] def z_score_checker(total_sales, threshold=1.96): sales_z_scores = zscore(total_sales) return all(abs(score) < threshold for score in sales_z_scores) def stock_quality_checker(dates, total_sales, stock_levels, actual_next_day_sales): rf_prediction = random_forest_predictor(dates, total_sales) gb_prediction = gradient_boosting_predictor(dates, total_sales) average_prediction = (rf_prediction + gb_prediction) / 2 print(f\\"RF Prediction: {rf_prediction}, GB Prediction: {gb_prediction}, Average Prediction: {average_prediction}\\") if z_score_checker(total_sales): return True if average_prediction > actual_next_day_sales else False return False"},{"question":"# Question: Determine the Matching Habitat You need to write a function `find_matching_habitat(animal_habitats)` that receives a dictionary where the keys are strings representing animal names and the values are lists of strings representing their respective habitats. The function should return a dictionary that maps each habitat to a list of animals that live in that habitat. If multiple animals share the same habitat, the animals should be listed in alphabetical order. Function Signature ```python def find_matching_habitat(animal_habitats: Dict[str, List[str]]) -> Dict[str, List[str]]: ``` Input * `animal_habitats` (Dict[str, List[str]]): A dictionary where keys are animal names (strings) and values are lists of habitats (strings) they live in. Output * A dictionary where keys are habitats and values are lists of animals that live in each habitat, sorted in alphabetical order. Constraints * Animal names and habitat names will be non-empty strings composed of alphabetical characters. * An animal may have multiple habitats, but each habitat will appear at least once in the input. * The total number of animals will not exceed 1000. Example ```python find_matching_habitat({ \\"Lion\\": [\\"Savannah\\", \\"Grassland\\"], \\"Shark\\": [\\"Ocean\\", \\"Reef\\"], \\"Elephant\\": [\\"Savannah\\", \\"Forest\\"], \\"Dolphin\\": [\\"Ocean\\", \\"Reef\\"], \\"Tiger\\": [\\"Forest\\", \\"Grassland\\"] }) # Should return { # \\"Savannah\\": [\\"Elephant\\", \\"Lion\\"], # \\"Grassland\\": [\\"Lion\\", \\"Tiger\\"], # \\"Ocean\\": [\\"Dolphin\\", \\"Shark\\"], # \\"Reef\\": [\\"Dolphin\\", \\"Shark\\"], # \\"Forest\\": [\\"Elephant\\", \\"Tiger\\"] # } find_matching_habitat({ \\"Panda\\": [\\"Forest\\"], \\"Whale\\": [\\"Ocean\\"], \\"Eagle\\": [\\"Mountain\\"], \\"Wolf\\": [\\"Forest\\", \\"Mountain\\"], }) # Should return { # \\"Forest\\": [\\"Panda\\", \\"Wolf\\"], # \\"Ocean\\": [\\"Whale\\"], # \\"Mountain\\": [\\"Eagle\\", \\"Wolf\\"] # } ``` Notes 1. Ensure that the animals within each habitat list are sorted alphabetically. 2. Handle edge cases where some habitats might exclusively belong to a single animal. 3. **Performance requirements**: The function should handle up to 1000 animals efficiently.","solution":"from typing import Dict, List def find_matching_habitat(animal_habitats: Dict[str, List[str]]) -> Dict[str, List[str]]: habitat_animals = {} for animal, habitats in animal_habitats.items(): for habitat in habitats: if habitat not in habitat_animals: habitat_animals[habitat] = [] habitat_animals[habitat].append(animal) for habitat in habitat_animals: habitat_animals[habitat].sort() return habitat_animals"},{"question":"# Problem Statement: You are asked to implement a scheduling algorithm for a single CPU that executes a series of tasks with specific priorities. Your goal is to determine the order of task execution based on their priorities and return the sequence in which the tasks will be executed. **Objective:** Write a function `schedule_tasks(tasks: List[Tuple[int, int]]) -> List[int]` that returns a list of task IDs in the order they should be executed. **Input:** * A list of tuples `tasks`, where each tuple represents a task and contains two integers: * `task_id` (a unique identifier for the task). * `priority` (an integer representing the priority of the task, with a lower number indicating higher priority). **Output:** * A list of task IDs sorted in the order they should be executed, from highest priority (lowest number) to lowest priority (highest number). If two tasks have the same priority, the task with the smaller `task_id` should be executed first. **Constraints:** * The list `tasks` will not be empty. * `1 <= len(tasks) <= 10^5` * `0 <= task_id <= 10^5` * `0 <= priority <= 10^3` **Example:** ```python assert schedule_tasks([(1, 3), (2, 1), (3, 2), (4, 1)]) == [2, 4, 3, 1] assert schedule_tasks([(10, 5), (5, 2), (8, 5), (2, 2)]) == [2, 5, 8, 10] assert schedule_tasks([(42, 0), (23, 2), (86, 1)]) == [42, 86, 23] ``` **Scenario:** Imagine you are managing a system that needs to execute tasks received from different users where each task has a certain priority. It is crucial for the system\'s efficiency to correctly determine and execute tasks based on their specified priorities while respecting the order of incoming tasks in cases of ties in priority.","solution":"from typing import List, Tuple def schedule_tasks(tasks: List[Tuple[int, int]]) -> List[int]: Schedules tasks based on their priorities and returns the order of task execution. Args: tasks (List[Tuple[int, int]]): A list of tuples where each tuple contains a task id and its priority. Returns: List[int]: A list of task ids in the order they should be executed. # Sort tasks primarily by priority (ascending) and secondarily by task_id (ascending) tasks_sorted = sorted(tasks, key=lambda x: (x[1], x[0])) # Extract the task ids from the sorted tasks ordered_task_ids = [task[0] for task in tasks_sorted] return ordered_task_ids"},{"question":"# Coding Question: Merge and Filter Lists Based on Criteria Given two lists of integers, your task is to implement three functions that merge these lists and filter the resulting list based on specific criteria. The criteria involve removing all duplicates, sorting the list, and keeping only numbers that adhere to a given condition. 1. **Function 1: `merge_and_remove_duplicates(list1: list[int], list2: list[int]) -> list[int]`**: * **Input**: Two lists of integers `list1` and `list2`. * **Output**: A sorted list where all duplicates are removed. * **Constraints**: Both lists have at least one element. 2. **Function 2: `filter_even_numbers(lst: list[int]) -> list[int]`**: * **Input**: A list of integers `lst`. * **Output**: A list containing only the even numbers from `lst`. * **Constraints**: The input list has at least one element. 3. **Function 3: `merge_and_filter(list1: list[int], list2: list[int], condition: callable) -> list[int]`**: * **Input**: Two lists of integers `list1` and `list2`, and a callable condition. * **Output**: A sorted list where all duplicates are removed and only elements that satisfy the condition are kept. * **Constraints**: Both lists have at least one element, and the condition is a function that takes an integer as input and returns a boolean. # Example ```python # Test case 1 list1 = [1, 3, 5, 7] list2 = [2, 3, 5, 6] assert merge_and_remove_duplicates(list1, list2) == [1, 2, 3, 5, 6, 7] assert filter_even_numbers([1, 2, 3, 4, 5, 6]) == [2, 4, 6] assert merge_and_filter(list1, list2, lambda x: x % 2 == 0) == [2, 6] # Test case 2 list1 = [4, 1, 6, 4] list2 = [4, 7, 1, 2] assert merge_and_remove_duplicates(list1, list2) == [1, 2, 4, 6, 7] assert filter_even_numbers([8, 1, 5, -2, 0]) == [8, -2, 0] assert merge_and_filter(list1, list2, lambda x: x > 3) == [4, 6, 7] # Test case 3 list1 = [10, 12] list2 = [10, 14] assert merge_and_remove_duplicates(list1, list2) == [10, 12, 14] assert filter_even_numbers([10, 11, 18]) == [10, 18] assert merge_and_filter(list1, list2, lambda x: x % 5 == 0) == [10] ``` # Your implementation should pass all given edge cases: * List with all even or all odd numbers. * Lists with multiple repeating elements. * Condition that none of the elements satisfy. # Notes: 1. Ensure that all functions handle edge cases appropriately and provide accurate results. 2. Implement the functions and test them with the provided examples and additional test cases you come up with.","solution":"def merge_and_remove_duplicates(list1, list2): Takes two lists and returns a sorted list with all duplicates removed. combined_list = list(set(list1 + list2)) combined_list.sort() return combined_list def filter_even_numbers(lst): Takes a list and returns a list containing only the even numbers. return [x for x in lst if x % 2 == 0] def merge_and_filter(list1, list2, condition): Takes two lists and a condition function, returns a sorted list with all duplicates removed and only elements that satisfy the condition. combined_list = merge_and_remove_duplicates(list1, list2) filtered_list = [x for x in combined_list if condition(x)] return filtered_list"},{"question":"# Context You are developing an application to efficiently process a list of unique employee records, each represented by a dictionary containing \'id\', \'name\', and \'salary\'. To support features such as searching and sorting, one critical function involves sorting this list based on employee salaries. # Task Implement a function in Python to sort a list of employee records (dictionaries) by the \'salary\' key. Your function should handle the basic sort, maintaining both efficiency and correctness, and must work to modify the list directly. # Requirements - Function Name: `sort_by_salary` - **Input**: A list of dictionaries, where each dictionary has the keys \'id\', \'name\', and \'salary\' (an integer). - **Output**: The same list, modified to be sorted in ascending order by \'salary\'. - **Constraints**: - The maximum length of the list will be 10^4. - The \'id\' values are unique for each dictionary. - Each \'salary\' will be a non-negative integer and will not exceed 10^6. - The \'name\' value is a non-empty string. # Example ```python # Example usage employees = [ {\'id\': 1, \'name\': \'Alice\', \'salary\': 70000}, {\'id\': 2, \'name\': \'Bob\', \'salary\': 80000}, {\'id\': 3, \'name\': \'Charlie\', \'salary\': 55000} ] sort_by_salary(employees) print(employees) # Output: [{\'id\': 3, \'name\': \'Charlie\', \'salary\': 55000}, {\'id\': 1, \'name\': \'Alice\', \'salary\': 70000}, {\'id\': 2, \'name\': \'Bob\', \'salary\': 80000}] employees = [{\'id\': 1, \'name\': \'Danny\', \'salary\': 90000}] sort_by_salary(employees) print(employees) # Output: [{\'id\': 1, \'name\': \'Danny\', \'salary\': 90000}] ``` # Notes: - Ensure to handle edge cases such as an empty list or a list with just one employee. - Pay attention to the efficiency of the sorting algorithm, considering the constraints provided. **Implement the Function Below:** ```python def sort_by_salary(employees): # your code here ```","solution":"def sort_by_salary(employees): Sorts the list of employee records in ascending order by the \'salary\' key. Parameters: employees (list): A list of dictionaries with keys \'id\', \'name\', and \'salary\'. Returns: None: The function modifies the list in-place. employees.sort(key=lambda x: x[\'salary\'])"},{"question":"# Coding Question: Matrix Diagonal Summation **Background**: Matrix operations are fundamental in various fields such as mathematics, computer science, and engineering. One common task is calculating the sum of elements along the main and secondary diagonals of a square matrix. The main diagonal of a matrix (A) consists of elements (A[i][i]), and the secondary diagonal consists of elements (A[i][n-i-1]). **Task**: Implement a function to compute the sum of the elements along both the main diagonal and the secondary diagonal of a given square matrix. **Function Signature**: ```python def diagonal_sums(matrix: list[list[int]]) -> tuple: Computes the sums of the main and secondary diagonals of a square matrix. :param matrix: A 2D list of integers representing a square matrix. :return: A tuple (main_diagonal_sum, secondary_diagonal_sum). Example: >>> diagonal_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 15) pass ``` **Instructions**: 1. Implement the function `diagonal_sums(matrix)` which takes a 2D list `matrix` representing a square matrix as an input. 2. Calculate the sum of elements on the main diagonal and the secondary diagonal. 3. Ensure the function handles edge cases appropriately: - Single-element matrix 4. The function should return a tuple `(main_diagonal_sum, secondary_diagonal_sum)`. **Constraints**: - `matrix` will be a square matrix with dimensions (n times n) where (n) can be up to 10^3. - Each element in `matrix` will be an integer within the range of [-10^6, 10^6]. - `matrix` is guaranteed to be non-empty and square. **Example**: ```python >>> diagonal_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 15) >>> diagonal_sums([[5]]) (5, 5) >>> diagonal_sums([[2, -1], [-3, 4]]) (6, -4) >>> diagonal_sums([[0, 1], [1, 0]]) (0, 2) ``` **Note**: Ensure the function is efficient and avoids unnecessary computations for large matrices.","solution":"def diagonal_sums(matrix: list[list[int]]) -> tuple: Computes the sums of the main and secondary diagonals of a square matrix. :param matrix: A 2D list of integers representing a square matrix. :return: A tuple (main_diagonal_sum, secondary_diagonal_sum). Example: >>> diagonal_sums([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) (15, 15) n = len(matrix) main_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): main_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n-i-1] return (main_diagonal_sum, secondary_diagonal_sum)"},{"question":"# Problem Statement Implement a Simple Text Editor class that supports the following operations: 1. **Append**: Adds a string to the end of the current text. 2. **Delete**: Removes the last k characters from the current text. 3. **Retrieve Last k**: Returns the last k characters from the current text without deleting them. The class should maintain the ability to undo the last operation performed (either `append` or `delete`). Input Format - You will be provided a series of operations with relevant inputs where needed. Output Format - For every `retrieve_last_k` operation, return the corresponding result. - For every `undo` operation, return the state of the text after the undo. Constraints - The initial text is empty. - Operations will be given as a tuple of a string and an optional integer/string. - Each string can be at most 1000 characters long. - You can assume the total number of operations will not exceed 10^5. - Each `retrieve_last_k` operation\'s k will be less than or equal to the current length of the text. Functions to Implement ```python class SimpleTextEditor: def __init__(self): pass def append(self, text: str) -> None: pass def delete(self, k: int) -> None: pass def retrieve_last_k(self, k: int) -> str: pass def undo(self) -> None: pass ``` Example ```python editor = SimpleTextEditor() # Append operation editor.append(\\"hello\\") print(editor.retrieve_last_k(4)) # Output: \\"ello\\" # Append operation editor.append(\\" world\\") print(editor.retrieve_last_k(6)) # Output: \\" world\\" # Delete operation editor.delete(3) print(editor.retrieve_last_k(9)) # Output: \\"hello wo\\" # Undo operation editor.undo() print(editor.retrieve_last_k(11)) # Output: \\"hello world\\" # Undo operation editor.undo() print(editor.retrieve_last_k(5)) # Output: \\"hello\\" ```","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, text: str) -> None: self.history.append(self.text) self.text += text def delete(self, k: int) -> None: self.history.append(self.text) self.text = self.text[:-k] def retrieve_last_k(self, k: int) -> str: return self.text[-k:] def undo(self) -> None: if self.history: self.text = self.history.pop()"},{"question":"# Coding Question: Implement a Simple Lexical Analyzer Given a grammar for a simple programming language, complete the lexical analyzer function that takes a string of source code and returns a list of tokens. Each token should be a tuple containing the type of token and the value. Implement the `lexical_analyzer` function. Function Signature ```python def lexical_analyzer(code: str) -> list: pass ``` Inputs - `code (str)`: A string representing the source code. Outputs - Returns a list of tuples `(token_type, value)`, where `token_type` is a string representing the type of token (e.g., \'IDENTIFIER\', \'NUMBER\', \'OPERATOR\', etc.) and `value` is the actual value of the token from the source code. Constraints - Tokens include identifiers, keywords (like \'if\', \'else\', \'while\'), numbers, operators (like \'+\', \'-\', \'*\', \'/\'), and delimiters (like \'(\', \')\', \'{\', \'}\'). - Identifiers are strings that start with a letter and may contain letters and digits. - Numbers are non-negative integers. - Operators include \'+\', \'-\', \'*\', \'/\'. - Delimiters include \'(\', \')\', \'{\', \'}\'. - Keywords are limited to a predefined set. Example ```python def lexical_analyzer(code: str) -> list: # Implement the lexical analyzer logic pass # Example Test Case code = \\"if (x > 0) { y = x + 1; }\\" print(lexical_analyzer(code)) # Expected Output: # [ # (\'KEYWORD\', \'if\'), # (\'DELIMITER\', \'(\'), # (\'IDENTIFIER\', \'x\'), # (\'OPERATOR\', \'>\'), # (\'NUMBER\', \'0\'), # (\'DELIMITER\', \')\'), # (\'DELIMITER\', \'{\'), # (\'IDENTIFIER\', \'y\'), # (\'OPERATOR\', \'=\'), # (\'IDENTIFIER\', \'x\'), # (\'OPERATOR\', \'+\'), # (\'NUMBER\', \'1\'), # (\'DELIMITER\', \';\'), # (\'DELIMITER\', \'}\') # ] ``` Hints 1. Use regular expressions to identify the different types of tokens. 2. Define the tokens\' patterns for keywords, identifiers, numbers, operators, and delimiters. 3. Process the input string character by character or in chunks matching the patterns to extract the tokens in sequence. 4. Maintain the order of tokens as they appear in the input string.","solution":"import re def lexical_analyzer(code: str) -> list: tokens = [] token_specification = [ (\'NUMBER\', r\'d+\'), # Integer (\'IDENTIFIER\', r\'[a-zA-Z_]w*\'), # Identifiers (\'OPERATOR\', r\'[+-*/=<>!]\'), # Arithmetic operators (\'DELIMITER\', r\'[(){};,]\'), # Delimiters (\'WHITESPACE\', r\'s+\'), # Whitespace (\'MISMATCH\', r\'.\'), # Any other character ] keywords = {\'if\', \'else\', \'while\', \'for\', \'do\', \'return\'} tok_regex = \'|\'.join(\'(?P<%s>%s)\' % pair for pair in token_specification) get_token = re.compile(tok_regex).match pos = 0 while pos < len(code): match = get_token(code, pos) if match is not None: token_type = match.lastgroup value = match.group(token_type) if token_type == \'WHITESPACE\': pos = match.end() continue elif token_type == \'IDENTIFIER\' and value in keywords: token_type = \'KEYWORD\' elif token_type == \'MISMATCH\': raise RuntimeError(f\'{value!r} unexpected on line {line_num}\') tokens.append((token_type, value)) pos = match.end() else: raise RuntimeError(f\'Illegal character {code[pos]} at position {pos}\') return tokens"},{"question":"# Implementing a Secure Password Validator Scenario You are working on a password management system and need to implement a secure password validator. The validator must ensure that passwords meet specific security criteria to be considered strong. Your task is to create a function that validates whether a given password is secure based on predefined rules. Function Signature ```python def is_secure_password(password: str) -> bool: Given a string representing a password, returns whether the password is considered secure. Parameters: password (str): The password string to validate. Returns: bool: True if the password is secure, False otherwise. Example: >>> is_secure_password(\\"SecureP@ssw0rd\\") True >>> is_secure_password(\\"password123\\") False Constraints: * The password string must be at least 8 characters long. * The password must include at least one uppercase letter. * The password must include at least one lowercase letter. * The password must include at least one digit. * The password must include at least one special character from the set {!@#%^&*()}. ``` Requirements 1. The function should ensure the password is at least 8 characters long. 2. The function should check for at least one uppercase letter. 3. The function should check for at least one lowercase letter. 4. The function should check for at least one digit. 5. The function should check for at least one special character from the set {!@#%^&*()}. 6. Return `True` if all criteria are met; otherwise, return `False`. Constraints * Assume that input is always a non-empty string. * No external libraries should be used for validation. * The input string can be of arbitrary length, though passwords longer than 64 characters are unlikely to be practical. # Example Usage ```python assert is_secure_password(\\"SecureP@ssw0rd\\") == True assert is_secure_password(\\"password123\\") == False assert is_secure_password(\\"Sh0rt!\\") == False assert is_secure_password(\\"LongPassword1!\\") == True ```","solution":"def is_secure_password(password: str) -> bool: Given a string representing a password, returns whether the password is considered secure. Parameters: password (str): The password string to validate. Returns: bool: True if the password is secure, False otherwise. if len(password) < 8: return False has_upper = False has_lower = False has_digit = False has_special = False special_characters = set(\\"!@#%^&*()\\") for char in password: if char.isupper(): has_upper = True elif char.islower(): has_lower = True elif char.isdigit(): has_digit = True elif char in special_characters: has_special = True return has_upper and has_lower and has_digit and has_special"},{"question":"# Problem: Implement a Simplified Job Scheduling Algorithm **Context**: You are tasked with developing a simplified job scheduling algorithm. The focus here is on determining the maximum number of non-overlapping jobs that can be scheduled given their start and end times. **Problem Statement**: Implement a function `max_non_overlapping_jobs` that, given a list of jobs (each represented as a tuple with a start and end time), returns the maximum number of non-overlapping jobs that can be scheduled. # Requirements * **Function Implementation**: * `max_non_overlapping_jobs(jobs: list[tuple[int, int]]) -> int` * Inputs: - `jobs`: A list of tuples, where each tuple contains two integers - the start time and the end time of a job. * Outputs: - An integer representing the maximum number of non-overlapping jobs that can be scheduled. # Example ```python jobs = [(1, 3), (2, 4), (3, 5), (1, 2)] result = max_non_overlapping_jobs(jobs) # result is expected to be 3, since the jobs [(1, 2), (2, 4), (1, 3)] can overlap to form 3 non-overlapping jobs ``` # Constraints * The start and end times of the jobs will be positive integers. * The start time will always be less than the end time within each job tuple. * Handle edge cases where the list of jobs might be empty. * Optimize for time complexity, ideally O(n log n). **Strategy**: 1. Sort the jobs based on their end times (earliest end time first). 2. Use a greedy algorithm approach to select the maximum number of non-overlapping jobs. **Hint**: You may find it useful to always pick the job that finishes the earliest and then recursively find the next job that starts after the current one ends.","solution":"def max_non_overlapping_jobs(jobs): Returns the maximum number of non-overlapping jobs that can be scheduled. :param jobs: List of tuples, each tuple contains two integers - the start time and the end time of a job. :return: An integer representing the maximum number of non-overlapping jobs. if not jobs: return 0 # Sort the jobs based on their end times jobs.sort(key=lambda x: x[1]) count = 0 last_end_time = 0 for job in jobs: start_time, end_time = job if start_time >= last_end_time: count += 1 last_end_time = end_time return count"},{"question":"# Scenario You are working on a machine learning algorithm that involves the normalization of feature vectors. Normalizing vectors is a crucial task in many statistical and machine learning applications to ensure consistency and improve model performance. Your task is to implement a function that normalizes an input list of numbers to unit length. # Function to Implement Write a function `normalize_vector`: Input - `vector` (list[float]): A list containing the elements of the vector to be normalized. Output - list[float]: The normalized vector such that the Euclidean norm (L2 norm) is equal to 1. Constraints 1. The `vector` list must contain at least one element. 2. If the Euclidean norm of the vector is zero, return a vector of the same length with all elements as zero, since normalization is not possible in this case. # Requirements 1. Raise a `ValueError` if the input vector is empty. 2. Use list comprehensions and built-in functions to enhance code efficiency and readability. 3. Do not use any external libraries for normalization (e.g., NumPy). # Example ```python >>> normalize_vector([3.0, 4.0]) [0.6, 0.8] >>> normalize_vector([0.0, 0.0, 0.0]) [0.0, 0.0, 0.0] >>> normalize_vector([1.0, 2.0, 2.0]) [0.3333333333333333, 0.6666666666666666, 0.6666666666666666] >>> normalize_vector([5.0]) [1.0] >>> normalize_vector([]) Traceback (most recent call last): ... ValueError: Input vector should not be empty. ``` Ensure your code is efficient, clearly structured, and thoroughly tested for different edge cases, including vectors with zero length, large numbers, small numbers, and negative values.","solution":"def normalize_vector(vector): Normalizes a vector to unit length (L2 norm = 1). Parameters: vector (list of float): The vector to be normalized Returns: list of float: The normalized vector if not vector: raise ValueError(\\"Input vector should not be empty.\\") norm = sum(x ** 2 for x in vector) ** 0.5 if norm == 0: return [0.0] * len(vector) return [x / norm for x in vector]"},{"question":"# Sorting an Array of Contact Names You are tasked with writing a program that reads a list of contact names and sorts them alphabetically by their last names. If two contacts have the same last name, they should be sorted by their first names. Implement the following function: 1. **sort_contacts**: This function should take a list of contact names and return a new list where the names are sorted alphabetically by their last names, and by first names in case of ties. * **Input**: A list of strings, where each string represents a contact name in the format \\"First Last\\". * **Output**: A new list of strings sorted as specified. * **Constraints**: - Each name will have exactly one first name and one last name. - The list will have at least one contact name and at most 1000 names. # Example ```python contacts = [ \\"John Smith\\", \\"Alice Johnson\\", \\"Bob Johnson\\", \\"Charlie Brown\\", \\"John Brown\\" ] sorted_contacts = sort_contacts(contacts) print(sorted_contacts) # Output: [\'Charlie Brown\', \'John Brown\', \'Alice Johnson\', \'Bob Johnson\', \'John Smith\'] ``` # Notes - Consider using Python\'s built-in sorting capabilities to handle the sorting logic. - Ensure the function performs efficiently, especially for the upper constraint of 1000 names. - The function should be robust and handle any reasonably expected edge cases, such as names with similar first or last names.","solution":"def sort_contacts(contacts): Takes a list of contact names and returns a new list where the names are sorted alphabetically by their last names and by first names in case of ties. :param contacts: A list of strings, each representing a contact name in the format \\"First Last\\". :return: A new list of strings sorted as specified. return sorted(contacts, key=lambda name: (name.split()[1], name.split()[0]))"},{"question":"# Minimum Spanning Tree Using Kruskal\'s Algorithm Your task as a software engineer is to implement a function that finds the Minimum Spanning Tree (MST) of an undirected weighted graph using Kruskal\'s algorithm. The graph is represented as a list of edges, each defined by two nodes and their corresponding edge weight. Function Signature ```python def minimum_spanning_tree(edges: List[Tuple[str, str, int]], num_nodes: int) -> int: This function computes the total weight of the Minimum Spanning Tree using Kruskal\'s algorithm. :param edges: List of tuples where each tuple represents an edge in the form (node1, node2, weight). :param num_nodes: The total number of nodes in the graph. :return: Integer value representing the total weight of the Minimum Spanning Tree, or -1 if the graph is disconnected and no MST exists. ``` Input 1. **edges**: A list of tuples where each tuple represents an edge in the form (node1, node2, weight). Each node is a string, and weight is a non-negative integer. 2. **num_nodes**: An integer representing the total number of nodes in the graph. Output * An integer representing the total weight of the Minimum Spanning Tree. If no MST exists (i.e., the graph is disconnected), return -1. Constraints * All edge weights are non-negative integers. * The nodes are labeled as strings. * The graph may include multiple components, but the MST should only span the connected component that includes the majority of the nodes. Example ```python # Example edge list representation graph_edges = [ (\\"A\\", \\"B\\", 4), (\\"B\\", \\"C\\", 8), (\\"C\\", \\"D\\", 7), (\\"D\\", \\"E\\", 9), (\\"E\\", \\"F\\", 10), (\\"F\\", \\"G\\", 2), (\\"G\\", \\"H\\", 1), (\\"H\\", \\"A\\", 8), (\\"B\\", \\"H\\", 11), (\\"H\\", \\"I\\", 7), (\\"I\\", \\"C\\", 2), (\\"I\\", \\"G\\", 6), (\\"C\\", \\"F\\", 4), (\\"D\\", \\"F\\", 14) ] assert minimum_spanning_tree(graph_edges, 9) == 37 assert minimum_spanning_tree([(\\"A\\", \\"B\\", 4), (\\"B\\", \\"C\\", 6)], 4) == -1 # Disconnected graph, no MST exists ``` Notes * Consider using a disjoint-set (union-find) data structure to efficiently manage connectivity between nodes. * Ensure the algorithm returns -1 for graphs that are not fully connected. * Optimize for both time and space efficiency, especially considering larger graphs. * Handle edge cases, such as graphs with no edges.","solution":"from typing import List, Tuple def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 def minimum_spanning_tree(edges: List[Tuple[str, str, int]], num_nodes: int) -> int: if num_nodes == 0 or len(edges) == 0: return -1 # No MST possible if no nodes or edges edges = sorted(edges, key=lambda item: item[2]) parent = {} rank = {} for edge in edges: u, v, w = edge if u not in parent: parent[u] = u rank[u] = 0 if v not in parent: parent[v] = v rank[v] = 0 mst_weight = 0 mst_edges = 0 for edge in edges: u, v, w = edge if find(parent, u) != find(parent, v): union(parent, rank, u, v) mst_weight += w mst_edges += 1 if mst_edges == num_nodes - 1: return mst_weight # If we exit the loop without using num_nodes-1 edges, graph is disconnected return -1"},{"question":"# Coding Assessment Question You are asked to implement a function that takes a text file with multiple sentences and transforms it into a system where each sentence is represented as a node in a graph. This tests your understanding of file I/O, string manipulation, and basic graph data structures. # Question **Problem Statement:** Write a function `create_sentence_graph(file_path: str) -> dict` that reads a text file, extracts sentences, and creates a graph where each sentence is a node. Each node should have edges connecting it to the next sentence in the file. **Input:** - `file_path` (str): Path to the text file containing multiple sentences. **Output:** - A dictionary representing the graph where each key is a sentence and its value is the next sentence in the file. The last sentence should have an empty string as its value. **Constraints:** - Sentences are assumed to end with a period (.), exclamation mark (!), or question mark (?). - Punctuation marks should be considered part of the sentence. - If the file is empty or contains no valid sentences, return an empty dictionary. # Example Given a text file `sentences.txt` with content: ``` Hello World. How are you? This is a sample text file. It contains multiple sentences. ``` The function call: ```python graph = create_sentence_graph(\'sentences.txt\') ``` Should return: ```python { \\"Hello World.\\": \\"How are you?\\", \\"How are you?\\": \\"This is a sample text file.\\", \\"This is a sample text file.\\": \\"It contains multiple sentences.\\", \\"It contains multiple sentences.\\": \\"\\" } ``` # Implementation Notes: - Properly handle file reading with error checks. - Ensure sentences are correctly parsed and considered in their entirety. - Use libraries and data structures effectively to achieve a clean solution. ```python def create_sentence_graph(file_path: str) -> dict: pass # Your implementation here # Example usage: graph = create_sentence_graph(\'sentences.txt\') print(graph) ``` Make sure your code is efficient, handles edge cases like empty files or no valid sentences, and is well-documented. Use any libraries necessary to accomplish the task.","solution":"import re def create_sentence_graph(file_path: str) -> dict: Reads a text file, extracts sentences, and creates a graph where each sentence is a node connected to the next sentence. Args: file_path (str): Path to the text file containing multiple sentences. Returns: dict: A dictionary representing the graph where each key is a sentence and its value is the next sentence in the file. with open(file_path, \'r\') as file: content = file.read() # Use regular expressions to split the text into sentences sentence_pattern = r\'([^.!?]+[.!?])\' sentences = re.findall(sentence_pattern, content) # Create the graph graph = {} for i in range(len(sentences) - 1): graph[sentences[i].strip()] = sentences[i + 1].strip() if sentences: graph[sentences[-1].strip()] = \\"\\" return graph"},{"question":"# Scenario: You are developing a system to manage a library\'s book inventory. Each book has a unique identifier (ISBN), title, author, and year of publication. The library frequently needs to add new books, remove old books, search for existing books, and list all books within a specific range of publication years. # Task: Design and implement a library inventory management system using a class-based approach. The system should support the following operations: # Requirements: 1. **Initialization**: Create a class `Library` with no initial books. 2. **Methods**: * `add_book(isbn, title, author, year)`: Add a new book with the given attributes. * `remove_book(isbn)`: Remove a book by its ISBN. * `search_book(isbn)`: Search for a book by its ISBN and return its details: (title, author, year). If the book is not found, return `None`. * `list_books(start_year, end_year)`: List all books published within the specified year range, inclusive. Return a list of tuples (isbn, title, author, year). # Constraints: * ISBN is a unique positive integer. * The year is a four-digit integer. * Title and author are strings. * If an attempt is made to add a book with an existing ISBN, the old entry should be replaced with the new one. # Input Format: - For `add_book` method: * `isbn`: Integer unique identifier of the book. * `title`: String title of the book. * `author`: String author of the book. * `year`: Integer year of publication. - For `remove_book` method: * `isbn`: Integer unique identifier of the book. - For `search_book` method: * `isbn`: Integer unique identifier of the book. - For `list_books` method: * `start_year`: Integer starting year of the range. * `end_year`: Integer ending year of the range. # Output Format: - `add_book`: No return value. - `remove_book`: No return value. - `search_book`: Tuple of (title, author, year) or `None`. - `list_books`: List of tuples (isbn, title, author, year). # Example: ```python # Creating the library library = Library() # Adding books library.add_book(123456, \'Book Title 1\', \'Author A\', 1999) library.add_book(234567, \'Book Title 2\', \'Author B\', 2005) library.add_book(345678, \'Book Title 3\', \'Author C\', 2010) library.add_book(123456, \'New Book Title 1\', \'Author A\', 2020) # Replacing old entry # Searching for a book print(library.search_book(123456)) # Expected output: (\'New Book Title 1\', \'Author A\', 2020) # Listing books published between 2000 and 2015 print(library.list_books(2000, 2015)) # Expected output: [(234567, \'Book Title 2\', \'Author B\', 2005), (345678, \'Book Title 3\', \'Author C\', 2010)] # Removing a book library.remove_book(234567) print(library.search_book(234567)) # Expected output: None ``` Implement the `Library` class in Python with the above specifications.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, isbn, title, author, year): self.books[isbn] = {\'title\': title, \'author\': author, \'year\': year} def remove_book(self, isbn): if isbn in self.books: del self.books[isbn] def search_book(self, isbn): if isbn in self.books: book = self.books[isbn] return (book[\'title\'], book[\'author\'], book[\'year\']) return None def list_books(self, start_year, end_year): result = [] for isbn, book in self.books.items(): if start_year <= book[\'year\'] <= end_year: result.append((isbn, book[\'title\'], book[\'author\'], book[\'year\'])) return result"},{"question":"# Coding Assessment Question In database management, query optimization is crucial for efficient data retrieval, especially when dealing with large datasets. You are tasked with creating a function that simulates a simplified in-memory SQL-like query executor which can handle SELECT, FILTER, and SORT operations. Write a function `simple_query_executor` that takes a list of dictionaries representing rows of data, a list of columns to select, optional filtering criteria, and an optional sorting key. **Function Signature**: ```python def simple_query_executor(rows, select_columns, filter_criteria=None, sort_by=None): pass ``` # Input and Output - **Input**: - `rows` - A list of dictionaries where each dictionary represents a row of data, with keys as column names and values as column data. - `select_columns` - A list of column names to be selected. - `filter_criteria` - An optional list of tuples for filtering. Each tuple contains a column name, a comparison operator as a string (\'==\', \'!=\', \'<\', \'<=\', \'>\', \'>=\') and a value. (`None` if no filtering is needed) - `sort_by` - An optional column name to sort the result by. (`None` if no sorting is needed.) - **Output**: - Returns a list of dictionaries representing the rows of the processed data. # Constraints - The input `rows` will always have at least one row and at least one column. - All column names in `select_columns` and `sort_by` will be valid columns present in the `rows`. - The `filter_criteria` list, if provided, will be non-empty and contain valid filtering comparisons. - When sorting, if `sort_by` column values are of different types, sort them as strings. # Requirements & Performance - **Selection**: - Select only the specified columns from each row. - **Filtering**: - Apply the specified filter criteria to include only rows that satisfy all conditions. - **Sorting**: - Sort the resultant rows based on the specified column. # Example ```python rows = [ {\\"id\\": 1, \\"name\\": \\"Alice\\", \\"age\\": 30, \\"salary\\": 70000}, {\\"id\\": 2, \\"name\\": \\"Bob\\", \\"age\\": 25, \\"salary\\": 55000}, {\\"id\\": 3, \\"name\\": \\"Charlie\\", \\"age\\": 35, \\"salary\\": 100000}, {\\"id\\": 4, \\"name\\": \\"David\\", \\"age\\": 30, \\"salary\\": 80000} ] select_columns = [\\"name\\", \\"age\\"] filter_criteria = [(\\"age\\", \\">\\", 25), (\\"salary\\", \\"<\\", 90000)] sort_by = \\"age\\" result = simple_query_executor(rows, select_columns, filter_criteria, sort_by) print(result) # Expected Output: # [ # {\\"name\\": \\"Alice\\", \\"age\\": 30}, # {\\"name\\": \\"David\\", \\"age\\": 30} # ] ``` Handle edge cases such as no filtering criteria, no sorting column, and ensure efficient data manipulation to simulate query execution.","solution":"from operator import itemgetter def simple_query_executor(rows, select_columns, filter_criteria=None, sort_by=None): def apply_filter(row, filters): for column, operator_, value in filters: if operator_ == \'==\': if not row[column] == value: return False elif operator_ == \'!=\': if not row[column] != value: return False elif operator_ == \'<\': if not row[column] < value: return False elif operator_ == \'<=\': if not row[column] <= value: return False elif operator_ == \'>\': if not row[column] > value: return False elif operator_ == \'>=\': if not row[column] >= value: return False return True # Apply filtering if filter_criteria: rows = [row for row in rows if apply_filter(row, filter_criteria)] # Sort if required if sort_by: rows = sorted(rows, key=itemgetter(sort_by), reverse=False) # Select specific columns result = [{col: row[col] for col in select_columns} for row in rows] return result"},{"question":"# Coding Challenge # Problem Statement You are given a matrix where each cell contains an integer. Your task is to find the minimum cost path from the top-left corner to the bottom-right corner of the matrix. You can move in only two directions: right or down. # Input - A string representation of the matrix structure where each level of the matrix is a line of space-separated integers. - Guarantee: The matrix will contain between 1 and 100 rows and columns. # Output - An integer representing the minimum cost from the top-left to the bottom-right corner of the matrix. # Example Input ``` 1 3 1 1 5 1 4 2 1 ``` Output ``` 7 ``` # Explanation For the given example, the minimum cost path is 1 -> 3 -> 1 -> 1 -> 1 = 7. # Function Signature ```python def minimum_cost_path(matrix_str: str) -> int: pass ``` # Constraints - 1 ≤ number of rows, columns ≤ 100 - All matrix values are integers between -10^4 and 10^4. # Scenario This task is an extension of your previous work around efficient pathfinding in grid-based structures. The problem combines dynamic programming and graph traversal techniques to ensure optimal performance within given constraints.","solution":"def minimum_cost_path(matrix_str: str) -> int: Given a string representation of a matrix, finds the minimum cost path from the top-left corner to the bottom-right corner. You can move only right or down. # Parse the input string into a 2D list (matrix) matrix = [list(map(int, row.split())) for row in matrix_str.strip().split(\'n\')] # Get the number of rows and columns rows = len(matrix) cols = len(matrix[0]) # Initialize a dp array with the same dimensions as the matrix dp = [[0] * cols for _ in range(rows)] # Initialize the starting point dp[0][0] = matrix[0][0] # Fill the first row (can only come from the left) for j in range(1, cols): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column (can only come from above) for i in range(1, rows): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp array for i in range(1, rows): for j in range(1, cols): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] # The answer is in the bottom-right corner of the dp array return dp[rows-1][cols-1]"},{"question":"# String Reversal & Palindrome Checker Scenario You have been hired by a software company to help with text processing tasks. One fundamental task is to determine if a given string is a palindrome, which is a string that reads the same backward as forward. Additionally, they want the functionality to reverse a given string. Task 1. Write a function `reverse_string(string: str) -> str` that takes a string as input and returns the reversed string. 2. Write a function `is_palindrome(string: str) -> bool` that takes a string as input and returns a boolean indicating whether the string is a palindrome. This function should use the `reverse_string` function to determine if the string is a palindrome. 3. Both functions should only accept alphabetic characters. If the string contains any non-alphabetic characters, they should raise a `ValueError`. 4. Both functions should be case-insensitive. Input and Output Formats * **Input**: A string containing only alphabetic characters. * **Output**: - For `reverse_string`: A string which is the reverse of the input string. - For `is_palindrome`: A boolean value `True` if the string is a palindrome, otherwise `False`. Constraints & Limitations * The input string will have a length of `1 <= len(string) <= 100`. * Both functions should raise a `ValueError` for strings containing non-alphabetic characters. * Both functions should handle both uppercase and lowercase letters. Example ```python >>> reverse_string(\'Level\') \'leveL\' >>> is_palindrome(\'Level\') True >>> is_palindrome(\'hello\') False >>> reverse_string(\'hello1\') Traceback (most recent call last): ... ValueError: String must only contain alphabetic characters. ``` Performance Requirements * Aim for a solution with optimized time complexity, ideally around O(n). Additional Notes Consider edge cases such as empty strings and single-character strings.","solution":"def reverse_string(string: str) -> str: Reverses the given string and returns the result. Only alphabetic characters are allowed; raises ValueError otherwise. Case-insensitive. if not string.isalpha(): raise ValueError(\\"String must only contain alphabetic characters.\\") return string[::-1] def is_palindrome(string: str) -> bool: Checks if the given string is a palindrome. Only alphabetic characters are allowed; raises ValueError otherwise. Case-insensitive. if not string.isalpha(): raise ValueError(\\"String must only contain alphabetic characters.\\") reversed_string = reverse_string(string) return string.lower() == reversed_string.lower()"},{"question":"New Question: Advanced String Manipulation with Palindrome Filtering # Context You have been provided a function that identifies whether a given string is a palindrome. However, as an accomplished coder, you need to enhance this function to process a list of strings and filter out non-palindrome entries. # Objective * Refactor the provided `is_palindrome` function to handle a list of strings and return only those that are palindromes. * Enhance error handling to manage invalid data types within the list. # Function Signature ```python def filter_palindromes(strings: List[Union[str, Any]]) -> Dict[str, List]: Filter a list of strings, returning only palindrome strings. Parameters: strings (List[Union[str, Any]]): A list that may contain strings and other data types. Returns: Dict[str, List]: A dictionary with two keys \\"palindromes\\" and \\"errors\\". \\"palindromes\\" is a list of strings that are palindromes. \\"errors\\" is a list of elements that are not strings. Example: >>> filter_palindromes([\\"radar\\", 12321, \\"hello\\", \\"level\\", 42]) {\'palindromes\': [\'radar\', \'level\'], \'errors\': [12321, 42]} ``` # Constraints and Requirements * **Input Constraints**: - The input list can contain strings and other data types (e.g., integers, floats). * **Output**: - The function must return a dictionary containing valid palindromic strings and any non-string elements that caused errors. * **Error Handling**: - If an element is not a string, it should be logged to the \\"errors\\" list. * **Performance**: Ensure the function operates efficiently with a complexity of O(n) for n input elements. ```python # Original Function Reference def is_palindrome(s: str) -> bool: Check whether a given string is a palindrome >>> is_palindrome(\\"radar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"level\\") True return s == s[::-1] ``` You are tasked to write and thoroughly test your solution, ensuring to cover normal, edge cases, and error handling. # Hints - Use list comprehensions and/or the filter function to process the list efficiently. - Consider how string slicing can be utilized for palindrome checking. - Implement proper exception handling for type-related errors and robustness.","solution":"from typing import List, Union, Dict, Any def is_palindrome(s: str) -> bool: Check whether a given string is a palindrome >>> is_palindrome(\\"radar\\") True >>> is_palindrome(\\"hello\\") False >>> is_palindrome(\\"level\\") True return s == s[::-1] def filter_palindromes(strings: List[Union[str, Any]]) -> Dict[str, List]: Filter a list of strings, returning only palindrome strings. Parameters: strings (List[Union[str, Any]]): A list that may contain strings and other data types. Returns: Dict[str, List]: A dictionary with two keys \\"palindromes\\" and \\"errors\\". \\"palindromes\\" is a list of strings that are palindromes. \\"errors\\" is a list of elements that are not strings. result = {\'palindromes\': [], \'errors\': []} for element in strings: if isinstance(element, str): if is_palindrome(element): result[\'palindromes\'].append(element) else: result[\'errors\'].append(element) return result"},{"question":"# Coding Question: Binary Search Tree Operations for Student Records Background: A university is developing a system to manage student records using a Binary Search Tree (BST). Each student record comprises a unique integer student ID and a grade, which is a float. The system must support dynamic operations such as adding a new student record, finding a student’s grade by their ID, and removing a student record. Additionally, the system should allow listing all student IDs in sorted order. Task: Implement the following operations in your BST class: 1. **Insert Student Record**: Add a new student record with a given ID and grade. 2. **Find Grade**: Find and return the grade of a student by their ID. 3. **Delete Student Record**: Remove the student record with the given ID. 4. **Sorted Student IDs**: Return a list of student IDs in ascending order. Your BST class must have the following methods implementing the required operations: ```python class StudentRecordBST: class Node: def __init__(self, student_id: int, grade: float): self.student_id = student_id self.grade = grade self.left = None self.right = None def __init__(self): Initialize an empty BST. self.root = None def insert(self, student_id: int, grade: float) -> None: Insert a new student record with the given student ID and grade. :param student_id: Integer student ID. :param grade: Float grade of the student. pass def find_grade(self, student_id: int) -> float: Find and return the grade of the student with the given ID. :param student_id: Integer student ID. :return: Float grade of the student. pass def delete(self, student_id: int) -> None: Remove the student record with the given ID. :param student_id: Integer student ID. pass def sorted_ids(self) -> list[int]: Return a list of student IDs in ascending order. :return: List of student IDs in ascending order. pass ``` Input/Output Format: * `insert(student_id: int, grade: float)` - Adds a new student record with the specified ID and grade. * `find_grade(student_id: int)` - Returns the grade of the student with the specified ID. * `delete(student_id: int)` - Removes the student record with the specified ID. * `sorted_ids()` - Returns a list of student IDs in ascending order. Constraints: * All student IDs are unique integers. * Grades are floats. * The number of student records will not exceed 10^6. Example Usage: ```python # Example initialization and operations bst = StudentRecordBST() bst.insert(101, 3.5) bst.insert(102, 3.8) bst.insert(103, 3.7) print(bst.find_grade(102)) # Output: 3.8 bst.delete(101) sorted_ids = bst.sorted_ids() print(sorted_ids) # Output: [102, 103] ``` Ensure that your implementation efficiently handles the operations and maintains the BST properties through all manipulations.","solution":"class StudentRecordBST: class Node: def __init__(self, student_id: int, grade: float): self.student_id = student_id self.grade = grade self.left = None self.right = None def __init__(self): Initialize an empty BST. self.root = None def insert(self, student_id: int, grade: float) -> None: Insert a new student record with the given student ID and grade. :param student_id: Integer student ID. :param grade: Float grade of the student. new_node = self.Node(student_id, grade) if self.root is None: self.root = new_node else: self._insert_recursive(self.root, new_node) def _insert_recursive(self, current_node, new_node): if new_node.student_id < current_node.student_id: if current_node.left is None: current_node.left = new_node else: self._insert_recursive(current_node.left, new_node) else: if current_node.right is None: current_node.right = new_node else: self._insert_recursive(current_node.right, new_node) def find_grade(self, student_id: int) -> float: Find and return the grade of the student with the given ID. :param student_id: Integer student ID. :return: Float grade of the student. node = self._find_student_node(self.root, student_id) return node.grade if node else None def _find_student_node(self, current_node, student_id): if current_node is None: return None if student_id == current_node.student_id: return current_node elif student_id < current_node.student_id: return self._find_student_node(current_node.left, student_id) else: return self._find_student_node(current_node.right, student_id) def delete(self, student_id: int) -> None: Remove the student record with the given ID. :param student_id: Integer student ID. self.root = self._delete_recursive(self.root, student_id) def _delete_recursive(self, current_node, student_id): if current_node is None: return None if student_id < current_node.student_id: current_node.left = self._delete_recursive(current_node.left, student_id) elif student_id > current_node.student_id: current_node.right = self._delete_recursive(current_node.right, student_id) else: if current_node.left is None: return current_node.right elif current_node.right is None: return current_node.left temp_val = self._find_min_value_node(current_node.right) current_node.student_id, current_node.grade = temp_val.student_id, temp_val.grade current_node.right = self._delete_recursive(current_node.right, temp_val.student_id) return current_node def _find_min_value_node(self, node): current = node while current.left is not None: current = current.left return current def sorted_ids(self) -> list[int]: Return a list of student IDs in ascending order. :return: List of student IDs in ascending order. ids = [] self._inorder_traversal(self.root, ids) return ids def _inorder_traversal(self, node, ids): if node is not None: self._inorder_traversal(node.left, ids) ids.append(node.student_id) self._inorder_traversal(node.right, ids)"},{"question":"# Context: You have been tasked with developing a financial digital solution that works with various currency manipulations. One critical functionality is converting amounts from one currency to another based on dynamically provided exchange rates, which are updated periodically. # Task: Implement the `currency_converter` function to facilitate conversion between different currencies using provided exchange rates. # Specification: 1. **Function Name**: `currency_converter` 2. **Parameters**: * `amount` (float): The amount of money to be converted. * `src_currency` (str): The source currency code (e.g., \\"USD\\", \\"EUR\\"). * `dst_currency` (str): The destination currency code (e.g., \\"USD\\", \\"EUR\\"). * `exchange_rates` (dict): A dictionary where the keys are currency codes and values are the exchange rates against a base currency (e.g., `{\'USD\': 1.0, \'EUR\': 0.85, \'JPY\': 110.0}`). 3. **Returns**: The converted amount as a float. 4. **Constraints**: * The exchange rates dictionary will always include both source and destination currencies. * The amount is a positive float. * The function should handle floating point arithmetic precision appropriately. 5. **Input/Output**: * Example: ```python currency_converter(100, \'USD\', \'EUR\', {\'USD\': 1.0, \'EUR\': 0.85, \'JPY\': 110.0}) ``` Should return: ```python 85.0 ``` # Performance Requirements: The function should perform the conversion using basic arithmetic operations, ensuring it operates in constant time O(1). # Edge Cases: Consider very small and very large amounts, as well as high precision exchange rates to ensure proper functionality without floating point errors. # Example Usage: ```python def currency_converter(amount: float, src_currency: str, dst_currency: str, exchange_rates: dict) -> float: >>> currency_converter(100, \'USD\', \'EUR\', {\'USD\': 1.0, \'EUR\': 0.85, \'JPY\': 110.0}) # doctest: +NORMALIZE_WHITESPACE 85.0 # Your implementation here pass # Write your code here. ```","solution":"def currency_converter(amount: float, src_currency: str, dst_currency: str, exchange_rates: dict) -> float: Converts the given amount from source currency to destination currency using the provided exchange rates. :param amount: The amount of money to be converted. :param src_currency: The source currency code. :param dst_currency: The destination currency code. :param exchange_rates: A dictionary where keys are currency codes and values are the exchange rates against a base currency. :return: The converted amount as a float. if src_currency == dst_currency: return amount base_amount = amount / exchange_rates[src_currency] converted_amount = base_amount * exchange_rates[dst_currency] return converted_amount"},{"question":"# Problem Statement Write a function to compute the nth Fibonacci number in a sequence where the sequence is defined as follows: - ( F(0) = 0 ) - ( F(1) = 1 ) - ( F(n) = F(n-1) + F(n-2) ) for ( n geq 2 ) Your function should be efficient and handle larger values of n without significant performance degradation. # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Expected Input and Output Formats - **Input**: - `n`: An integer representing the position in the Fibonacci sequence. - **Output**: - An integer representing the nth Fibonacci number. # Constraints and Limitations 1. ( 0 leq n leq 10^6 ) 2. Your solution should handle the largest cases within a reasonable time (under 2 seconds for ( n = 10^6 )). # Example ```python assert fibonacci(0) == 0, \\"Test case 0 failed\\" assert fibonacci(1) == 1, \\"Test case 1 failed\\" assert fibonacci(10) == 55, \\"Test case 10 failed\\" assert fibonacci(50) == 12586269025, \\"Test case 50 failed\\" ``` # Performance Requirements - The time complexity should be optimized to handle the upper limits efficiently. - Consider employing iterative methods or matrix exponentiation for efficient computation. # Scenario In various computational biology and algorithm analysis tasks, computing Fibonacci numbers efficiently is crucial. For instance, the Fibonacci sequence is used in dynamic programming problems, growth modeling, and analysis of recursive algorithms. Your implementation should support rapid computation for use in these scientific and engineering applications.","solution":"def fibonacci(n: int) -> int: Computes the nth Fibonacci number using an iterative approach which allows for efficient computation even for large values of n. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"# Problem Statement You are tasked with creating a function to compute the \\"Median of Two Sorted Arrays\\". Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). # Function Signature ```python def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: ``` # Input - A list of integers `nums1` of size m representing the first sorted array. - A list of integers `nums2` of size n representing the second sorted array. # Output - A float representing the median of the two sorted arrays combined. # Constraints 1. nums1 and nums2 cannot both be empty simultaneously. 2. The elements of nums1 and nums2 are always integers. 3. The overall total number of elements (m + n) will be between 1 and 2000. # Performance Requirements - The function should run in logarithmic time complexity O(log (m+n)), where m is the length of nums1 and n is the length of nums2. - The space complexity should be constant O(1). # Scenario Implement a solution to find the median of two sorted arrays efficiently using a binary search approach. # Example ```python # Input: nums1 = [1, 3], nums2 = [2] # Output: 2.0 # Input: nums1 = [1, 2], nums2 = [3, 4] # Output: 2.5 # Input: nums1 = [0, 0], nums2 = [0, 0] # Output: 0.0 # Input: nums1 = [], nums2 = [1] # Output: 1.0 # Input: nums1 = [2], nums2 = [] # Output: 2.0 ``` # Implementation Guidelines 1. Determine which array is shorter for the purpose of applying binary search. 2. Utilize binary search to partition both arrays to ensure the combined left half length equals the combined right half length. 3. Check and adjust partitions to maintain the median properties based on the values around the partition. 4. Compute and return the median based on the values around the partition. You may use helper functions or comments to clarify your approach and ensure accuracy for all specified edge cases.","solution":"from typing import List def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float: if len(nums1) > len(nums2): nums1, nums2 = nums2, nums1 m, n = len(nums1), len(nums2) imin, imax, half_len = 0, m, (m + n + 1) // 2 while imin <= imax: i = (imin + imax) // 2 j = half_len - i if i < m and nums1[i] < nums2[j - 1]: imin = i + 1 elif i > 0 and nums1[i - 1] > nums2[j]: imax = i - 1 else: if i == 0: left_max = nums2[j - 1] elif j == 0: left_max = nums1[i - 1] else: left_max = max(nums1[i - 1], nums2[j - 1]) if (m + n) % 2 == 1: return float(left_max) if i == m: right_min = nums2[j] elif j == n: right_min = nums1[i] else: right_min = min(nums1[i], nums2[j]) return (left_max + right_min) / 2.0"},{"question":"# Assessing Employee Performance Based on Sales Data You are tasked with implementing a set of functions that evaluate employee performance based on their sales data. The provided functions must accurately compute the total sales, average sales, and identify the top performer from a given list of sales records. Ensure the functions handle various input scenarios and edge cases correctly. Requirements 1. **Total Sales Calculation**: - Implement the `total_sales` function, which calculates the total sales for a given list of sales figures. - Ensure error handling for invalid inputs (e.g., negative values). 2. **Average Sales Calculation**: - Implement the `average_sales` function, which calculates the average sales from the provided list of sales figures. - Handle cases where the input list is empty appropriately. 3. **Top Performer Identification**: - Implement the `top_performer` function, which identifies the top performer based on the highest sales figure from a dictionary mapping employee names to their sales figures. - Ensure to validate the inputs appropriately and handle scenarios where the sales data contains ties for the top performer. Function Signatures ```python def total_sales(sales: List[float]) -> float: pass def average_sales(sales: List[float]) -> float: pass def top_performer(sales_data: Dict[str, float]) -> str: pass ``` Input and Output Formats - **Total Sales**: - **Input**: `sales` (List[float]), a list of sales figures for an employee - **Output**: `float` representing the total sales - **Average Sales**: - **Input**: `sales` (List[float]), a list of sales figures for an employee - **Output**: `float` representing the average sales, or `None` if the list is empty - **Top Performer**: - **Input**: `sales_data` (Dict[str, float]), a dictionary mapping employee names to their sales figures - **Output**: `str` representing the name of the top performer Constraints - Sales figures must be non-negative. If not, raise a ValueError with a relevant message. - The dictionary in `top_performer` must contain at least one entry. If not, raise a ValueError with a relevant message. - Handle ties in sales figures by returning any one of the top performers. Performance Requirements All operations should be performed efficiently, aiming for linear time complexity O(n), where n is the length of the input list or the number of items in the dictionary, as applicable. Example Usage ```python print(total_sales([1000.0, 2000.0, 1500.0])) # Output: 4500.0 print(average_sales([1000.0, 2000.0, 1500.0])) # Output: 1500.0 print(top_performer({\\"Alice\\": 3200.0, \\"Bob\\": 2500.0, \\"Charlie\\": 3700.0})) # Output: \\"Charlie\\" ``` Implement the given functions based on these details while adhering to the input-output formats, constraints, and performance requirements.","solution":"from typing import List, Dict def total_sales(sales: List[float]) -> float: Returns the total sales for a given list of sales figures. if not all(sale >= 0 for sale in sales): raise ValueError(\\"Sales figures must be non-negative.\\") return sum(sales) def average_sales(sales: List[float]) -> float: Returns the average sales for a given list of sales figures. if not sales: return None if not all(sale >= 0 for sale in sales): raise ValueError(\\"Sales figures must be non-negative.\\") return sum(sales) / len(sales) def top_performer(sales_data: Dict[str, float]) -> str: Identifies the top performer based on the highest sales figure from a dictionary mapping employee names to their sales figures. if not sales_data: raise ValueError(\\"Sales data must contain at least one entry.\\") if not all(sale >= 0 for sale in sales_data.values()): raise ValueError(\\"Sales figures must be non-negative.\\") return max(sales_data, key=sales_data.get)"},{"question":"# Problem Statement Write a function `convert_to_title_case(sentence: str) -> str` that converts a given sentence to title case, capitalizing the first letter of each word while converting the rest of the letters to lowercase. The function should handle edge cases gracefully, such as multiple spaces between words and leading or trailing spaces. # Constraints 1. The input sentence can contain lowercase and uppercase alphabetic characters, spaces, and may be empty. # Input - A string `sentence` representing the sentence to be converted. **Examples:** ```python convert_to_title_case(\\"hello world\\") # Output: \\"Hello World\\" convert_to_title_case(\\" multiple spaces \\") # Output: \\"Multiple Spaces\\" convert_to_title_case(\\"cAPITALIZE eVEN wHEN cAseS aRe mIXEd\\") # Output: \\"Capitalize Even When Cases Are Mixed\\" convert_to_title_case(\\"\\") # Output: \\"\\" ``` # Implementation Details - Use the `strip` method to handle leading or trailing spaces. - Split the sentence into words, process each word to follow title casing, and then join them back together. - Handle different cases and ensure robustness with various input formats.","solution":"def convert_to_title_case(sentence: str) -> str: Converts a given sentence to title case, capitalizing the first letter of each word and converting the rest of the letters to lowercase. words = sentence.strip().split() title_cased_words = [word.capitalize() for word in words] title_cased_sentence = \' \'.join(title_cased_words) return title_cased_sentence"},{"question":"# Problem Statement Create a function `sum_of_multiples` that calculates the sum of all the multiples of 3 or 5 below a given non-negative integer. Your task is to implement this function in such a way that it efficiently handles large input values. # Function Signature ```python def sum_of_multiples(limit: int) -> int: pass ``` # Input * A single parameter `limit`, which is a non-negative integer (0 ≤ limit ≤ 10^7). # Output * An integer representing the sum of all the multiples of 3 or 5 below the input value. # Constraints * The input limit will be within the range 0 ≤ limit ≤ 10^7. # Requirements * The function must identify multiples of 3 or 5 and sum them efficiently. * The function should handle invalid inputs by raising a `ValueError` with the message \\"Input must be a non-negative integer\\". # Example ```python >>> sum_of_multiples(10) 23 >>> sum_of_multiples(20) 78 >>> sum_of_multiples(15) 45 >>> sum_of_multiples(0) 0 >>> sum_of_multiples(1) 0 >>> sum_of_multiples(-5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> sum_of_multiples(5.5) Traceback (most recent call last): ... ValueError: Input must be a non-negative integer >>> sum_of_multiples(\\"10\\") Traceback (most recent call last): ... ValueError: Input must be a non-negative integer ``` # Hints * Consider using arithmetic progressions to achieve efficient sums when dealing with large inputs. * Ensure type checking and handle edge cases carefully before performing the sum calculation.","solution":"def sum_of_multiples(limit: int) -> int: Calculates the sum of all the multiples of 3 or 5 below the given limit. :param limit: A non-negative integer. :return: Sum of all multiples of 3 or 5 below the given limit. :raises ValueError: If the limit is not a non-negative integer. if not isinstance(limit, int) or limit < 0: raise ValueError(\\"Input must be a non-negative integer\\") def sum_of_multiples_divisible_by(n, max_limit): Helper function to calculate the sum of multiples of `n` below `max_limit`. p = (max_limit - 1) // n return n * p * (p + 1) // 2 sum_3 = sum_of_multiples_divisible_by(3, limit) sum_5 = sum_of_multiples_divisible_by(5, limit) sum_15 = sum_of_multiples_divisible_by(15, limit) return sum_3 + sum_5 - sum_15"},{"question":"Implementing a Custom Linked List with Advanced Operations You are given a class `Node` to represent a singly linked list node, and a class `LinkedList` to represent a linked list. Your task is to extend the functionality of the `LinkedList` class to support the following advanced operations efficiently: 1. Reverse the linked list 2. Find the nth node from the end 3. Rotate the linked list by k places # Problem Statement Implement the methods `reverse`, `find_nth_from_end`, and `rotate` in the `LinkedList` class. # Constraints 1. The list is guaranteed to have at least one node. 2. (1 leq text{length of the linked list} leq 10^4) 3. (0 leq k leq 10^4) 4. (1 leq n leq text{length of the linked list}) # Input Format - For `reverse`: No input required. - For `find_nth_from_end`: An integer n representing the nth position from the end of the list. - For `rotate`: An integer k representing the number of places to rotate the list. # Output Format - For `reverse`: Return the head of the reversed linked list. - For `find_nth_from_end`: Return the value of the nth node from the end of the list. - For `rotate`: Return the head of the rotated linked list. # Example ```python # Initialization linked_list = LinkedList() linked_list.append(1) linked_list.append(2) linked_list.append(3) linked_list.append(4) linked_list.append(5) # Reverse the list linked_list.reverse() # [5, 4, 3, 2, 1] # Find 2nd node from end value = linked_list.find_nth_from_end(2) # Output should be 2 # Rotate the list by 2 places linked_list.rotate(2) # [2, 1, 5, 4, 3] ``` # Implementation Extend the `LinkedList` class with the `reverse`, `find_nth_from_end`, and `rotate` methods. Complete each method as follows: 1. `reverse`: Reverse the linked list. 2. `find_nth_from_end`: Find the nth node from the end of the list and return its value. 3. `rotate`: Rotate the linked list by k places. ```python class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self) -> Node: prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def find_nth_from_end(self, n: int) -> int: main_pointer = self.head ref_pointer = self.head count = 0 if self.head is not None: while count < n: if ref_pointer is None: raise ValueError(\\"n is greater than the number of nodes in list\\") ref_pointer = ref_pointer.next count += 1 while ref_pointer is not None: main_pointer = main_pointer.next ref_pointer = ref_pointer.next return main_pointer.value def rotate(self, k: int) -> Node: if k == 0: return current = self.head count = 1 while (count < k and current is not None): current = current.next count += 1 if current is None: return kthNode = current while current.next is not None: current = current.next current.next = self.head self.head = kthNode.next kthNode.next = None ```","solution":"class Node: def __init__(self, value): self.value = value self.next = None class LinkedList: def __init__(self): self.head = None def append(self, value): if not self.head: self.head = Node(value) else: current = self.head while current.next: current = current.next current.next = Node(value) def reverse(self): prev = None current = self.head while current: next_node = current.next current.next = prev prev = current current = next_node self.head = prev def find_nth_from_end(self, n: int) -> int: main_pointer = self.head ref_pointer = self.head count = 0 if self.head is not None: while count < n: if ref_pointer is None: raise ValueError(\\"n is greater than the number of nodes in list\\") ref_pointer = ref_pointer.next count += 1 while ref_pointer is not None: main_pointer = main_pointer.next ref_pointer = ref_pointer.next return main_pointer.value def rotate(self, k: int): if k == 0 or self.head is None: return self.head # Find the length of the list current = self.head length = 1 while current.next: current = current.next length += 1 # Connect the last node to the head to make it a circular list current.next = self.head # Find the new head after rotation k = k % length steps_to_new_head = length - k new_tail = self.head for _ in range(steps_to_new_head - 1): new_tail = new_tail.next self.head = new_tail.next new_tail.next = None return self.head"},{"question":"# Merge Sort With Linked List Implementation Overview: You are provided with a singly linked list containing a sequence of integers. Your task is to implement the Merge Sort algorithm to sort this linked list in ascending order. Merge Sort is particularly well-suited for linked lists due to its ability to handle large data sets and avoid extra space overhead unlike array-based sorting algorithms. Function Signature: ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: ``` Input: - `head`: The head node of a singly linked list containing integers. Output: - The head node of the singly linked list sorted in ascending order. Constraints: - The given linked list may contain zero or more nodes. - You need to preserve the ListNode structure as defined. Example: ```python input: head = [4, 2, 1, 3] output: sorted_head = [1, 2, 3, 4] input: head = [-1, 5, 3, 4, 0] output: sorted_head = [-1, 0, 3, 4, 5] ``` Requirements: 1. Create a function to find the middle of the linked list. 2. Implement a function to merge two sorted linked lists. 3. Use the Merge Sort algorithm to recursively divide and conquer the linked list. 4. Ensure the newly returned head node points to the beginning of the sorted linked list. Scenario: As part of a legacy migration project, an old system processes transaction records using a custom linked list structure. You need to implement an efficient Merge Sort algorithm to sort these linked lists in ascending order. The solution must handle edge cases such as empty lists gracefully and should work seamlessly with the provided ListNode class structure.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sort_linked_list(head: ListNode) -> ListNode: if not head or not head.next: return head # Function to find the middle of the linked list def find_middle(head): slow = head fast = head prev = None while fast and fast.next: prev = slow slow = slow.next fast = fast.next.next if prev: prev.next = None return slow # Function to merge two sorted linked lists def merge(l1, l2): dummy = ListNode() tail = dummy while l1 and l2: if l1.val < l2.val: tail.next = l1 l1 = l1.next else: tail.next = l2 l2 = l2.next tail = tail.next tail.next = l1 if l1 else l2 return dummy.next # Divide the linked list into two halves middle = find_middle(head) left = head right = middle # Recursively split and merge left = merge_sort_linked_list(left) right = merge_sort_linked_list(right) # Merge the sorted halves return merge(left, right)"},{"question":"# Problem Statement You are to implement a condensed version of the famous board game Scrabble. This simplified version will focus only on the calculation of word scores based on given letter values and ensuring that words formed using a list of given letters are valid per a provided dictionary. Requirements: 1. **Function Name**: `calculate_scrabble_score` 2. **Input**: - `word`: A string consisting of the word to evaluate. - `letter_values`: A dictionary where keys are characters and values are the points specific to each character. - `available_letters`: A list of characters representing the letters available to form the word. - `dictionary`: A set or list of valid words. 3. **Output**: - An integer which is the total score of the word if it can be formed with the available letters and is present in the dictionary. - Return `-1` if the word cannot be formed with the available letters or is not present in the dictionary. 4. **Constraints**: - The `word` can only contain alphabetic characters (both uppercase and lowercase). - The function should be case insensitive, treating \'A\' the same as \'a\'. - Words not in the dictionary should be considered invalid. - The length of `available_letters` and the size of the dictionary should be such that a solution exists within a reasonable time frame (consider solutions that can handle up to 10,000 words in the dictionary). Implement the function with the signature: ```python def calculate_scrabble_score( word: str, letter_values: dict[str, int], available_letters: list[str], dictionary: set[str] ) -> int: pass ``` Example ```python letter_values = { \'a\': 1, \'b\': 3, \'c\': 3, \'d\': 2, \'e\': 1, \'f\': 4, \'g\': 2, \'h\': 4, \'i\': 1, \'j\': 8, \'k\': 5, \'l\': 1, \'m\': 3, \'n\': 1, \'o\': 1, \'p\': 3, \'q\': 10, \'r\': 1, \'s\': 1, \'t\': 1, \'u\': 1, \'v\': 4, \'w\': 4, \'x\': 8, \'y\': 4, \'z\': 10 } available_letters = [\'a\', \'p\', \'p\', \'l\', \'e\'] dictionary = {\'apple\', \'pear\', \'grape\'} print(calculate_scrabble_score(\'apple\', letter_values, available_letters, dictionary)) # Output: 9 print(calculate_scrabble_score(\'orange\', letter_values, available_letters, dictionary)) # Output: -1 print(calculate_scrabble_score(\'Pear\', letter_values, available_letters, dictionary)) # Output: -1 ``` # Explanation 1. For the word \'apple\', it can be formed using the available letters `[\'a\', \'p\', \'p\', \'l\', \'e\']`, and it exists in the dictionary, so the score is calculated as `1 (a) + 3 (p) + 3 (p) + 1 (l) + 1 (e) = 9`. 2. The word \'orange\' cannot be formed using the available letters, so the output is `-1`. 3. The word \'Pear\' (case insensitive) cannot be formed using the available letters `[\'a\', \'p\', \'p\', \'l\', \'e\']` and `pear` exists in the dictionary, but since it\'s not case insensitive conversion considered, hence the output is `-1`.","solution":"def calculate_scrabble_score( word: str, letter_values: dict[str, int], available_letters: list[str], dictionary: set[str] ) -> int: from collections import Counter word = word.lower() available_letters = [letter.lower() for letter in available_letters] if word not in dictionary: return -1 word_count = Counter(word) available_count = Counter(available_letters) for letter, count in word_count.items(): if available_count[letter] < count: return -1 total_score = sum(letter_values[letter] for letter in word) return total_score"},{"question":"# Minimum Spanning Tree using Prim’s Algorithm Sara is a network administrator tasked with optimizing the wiring layout for a new corporate office. She needs to connect all the rooms with cables such that the total length of the cables used is minimized and every room is reachable from any other room. To achieve this, she decides to use Prim\'s Algorithm to find the minimum spanning tree (MST) for the given weighted graph. Your task is to implement Prim’s Algorithm to compute the total weight of the minimum spanning tree in the given graph. Function Signature: ```python def prim_mst(graph: List[List[int]]) -> int: pass ``` # Input * `graph`: A 2D list (adjacency matrix) containing non-negative integers, where `graph[i][j]` represents the weight of the edge between vertex `i` and vertex `j`. A value of `0` indicates that there is no direct edge between the vertices. # Output * An integer representing the total weight of the minimum spanning tree of the given graph. # Constraints * `1 <= len(graph) <= 100` * The graph is undirected and connected. * `0 <= graph[i][j] <= 1000` # Example ```python graph = [ [0, 2, 0, 6, 0], [2, 0, 3, 8, 5], [0, 3, 0, 0, 7], [6, 8, 0, 0, 9], [0, 5, 7, 9, 0], ] assert prim_mst(graph) == 16 ``` # Additional Requirements 1. Ensure the function handles graphs with up to 100 vertices efficiently. 2. Consider edge cases such as graphs with multiple edges having the same weight. 3. Provide a clear explanation of your approach and mention any potential performance bottlenecks. Implement the `prim_mst` function to achieve the above requirements.","solution":"from typing import List import heapq def prim_mst(graph: List[List[int]]) -> int: Returns the total weight of the minimum spanning tree (MST) using Prim\'s Algorithm. # Number of vertices in the graph n = len(graph) # A boolean array to track the vertices included in the MST in_mst = [False] * n # Min-Heap to store the edges in the form of (weight, vertex) min_heap = [(0, 0)] # Total cost of the minimum spanning tree total_weight = 0 while min_heap: weight, u = heapq.heappop(min_heap) # If the vertex u is already included in MST, skip it if in_mst[u]: continue # Include vertex u in MST in_mst[u] = True total_weight += weight # Iterate through all the vertices adjacent to u for v in range(n): if graph[u][v] != 0 and not in_mst[v]: # If there is an edge and vertex v is not in MST, add it to the heap heapq.heappush(min_heap, (graph[u][v], v)) return total_weight"},{"question":"# Objective You are to implement a function to determine if a given string is a valid palindrome after removing all non-alphanumeric characters and ignoring case differences. This task assesses your understanding of string manipulation, character filtering, and basic checks for symmetric properties in strings. # Problem Statement Write a Python function `is_valid_palindrome(s: str) -> bool` that takes a single string ( s ) and returns `True` if the string is a valid palindrome, and `False` otherwise. # Input and Output: * **Input**: A string ( s ) containing printable ASCII characters. * **Output**: A boolean indicating whether the string is a palindrome. # Constraints: 1. The input string can be empty. 2. Only consider alphanumeric characters in the string. 3. Ignore case differences when determining if the string is a palindrome. # Function Signature: ```python def is_valid_palindrome(s: str) -> bool: ``` # Example Input and Output * Input: `s = \\"A man, a plan, a canal: Panama\\"` * Output: `True` * Input: `s = \\"race a car\\"` * Output: `False` * Input: `s = \\" \\"` * Output: `True` * Input: `s = \\"No lemon, no melon\\"` * Output: `True` # Constraints and Considerations: 1. **Edge Cases**: * Input string is empty. * Input string contains only non-alphanumeric characters. 2. **Performance**: * Efficient string processing and filtering to handle large strings. * Minimize redundant checks and leverage string properties. # Approach: 1. Remove all non-alphanumeric characters from the input string. 2. Convert the filtered string to lower case. 3. Check if the processed string reads the same forward and backward. 4. Return the result of the check.","solution":"def is_valid_palindrome(s: str) -> bool: Determines if the given string is a valid palindrome after removing all non-alphanumeric characters and ignoring case differences. # Filter the string to keep only alphanumeric characters and convert to lowercase filtered_str = \'\'.join(char.lower() for char in s if char.isalnum()) # Check if the filtered string is the same forwards and backwards return filtered_str == filtered_str[::-1]"},{"question":"# Validate Prime Number and Generate its Next You are provided a number, and you need to determine if it is a prime number. If the number is prime, you should return a message indicating that it is prime. If the number is not prime, you should return the next prime number greater than the provided number. # Problem Description Write a Python function `prime_or_next` that takes an integer as input and performs the following steps: 1. Checks if the number is a prime. 2. If it is a prime, returns the message: \\"The number {number} is a prime\\". 3. If it is not a prime, finds and returns the next prime number greater than the input number along with the message: \\"The number {number} is not a prime, the next prime is {next_prime}\\". # Function Signature ```python def prime_or_next(number: int) -> str: ``` # Input * `number` (int): A positive integer greater than 1. # Output * Returns a string indicating whether the number is prime and, if not, the next prime number. # Constraints 1. The input number should be a positive integer greater than 1. 2. If the input number does not meet the constraint, the function should raise a `ValueError` with the message: \\"Input must be a positive integer greater than 1\\". # Example ```python def prime_or_next(number: int) -> str: >>> prime_or_next(7) \'The number 7 is a prime\' >>> prime_or_next(10) \'The number 10 is not a prime, the next prime is 11\' >>> prime_or_next(-5) Traceback (most recent call last): ... ValueError: Input must be a positive integer greater than 1 >>> prime_or_next(1) Traceback (most recent call last): ... ValueError: Input must be a positive integer greater than 1 if number <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") def is_prime(n): if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True if is_prime(number): return f\\"The number {number} is a prime\\" else: next_prime = number + 1 while not is_prime(next_prime): next_prime += 1 return f\\"The number {number} is not a prime, the next prime is {next_prime}\\" ```","solution":"def prime_or_next(number: int) -> str: Check if the number is a prime or find the next prime number. Args: number (int): A positive integer greater than 1. Returns: str: A message indicating if the number is a prime or the next prime number. Raises: ValueError: If the input number is not a positive integer greater than 1. if number <= 1: raise ValueError(\\"Input must be a positive integer greater than 1\\") def is_prime(n): if n <= 1: return False for i in range(2, int(n**0.5) + 1): if n % i == 0: return False return True if is_prime(number): return f\\"The number {number} is a prime\\" else: next_prime = number + 1 while not is_prime(next_prime): next_prime += 1 return f\\"The number {number} is not a prime, the next prime is {next_prime}\\""},{"question":"Assessment Question: # Context: You are assigned the task of developing an inventory system for a small store. The system needs to keep track of product quantities, update inventories with incoming shipments, and process customer purchases. # Challenge: Write a class `Inventory` with the following methods: 1. `add_product(product_name: str, quantity: int) -> None`: Adds a new product to the inventory or updates the quantity of an existing product. 2. `purchase(product_name: str, quantity: int) -> bool`: Decreases the quantity of the specified product by the specified amount if there is sufficient stock. Returns True if the purchase is successful and False otherwise. 3. `get_stock(product_name: str) -> int`: Returns the current stock level of the specified product. If the product does not exist in the inventory, returns 0. # Input: - `product_name`: A string representing the name of the product. - `quantity`: An integer representing the number of units for adding or purchasing. # Output: - For `add_product`: No return value. - For `purchase`: True if the purchase is successful, otherwise False. - For `get_stock`: An integer representing the current stock level of the product. # Constraints: - Product names are case-sensitive. - Ensure that the inventory handles multiple products efficiently. - The number of distinct products can be up to 10^5. # Example: ```python class Inventory: def __init__(self): self.products = {} def add_product(self, product_name: str, quantity: int) -> None: if product_name in self.products: self.products[product_name] += quantity else: self.products[product_name] = quantity def purchase(self, product_name: str, quantity: int) -> bool: if product_name in self.products and self.products[product_name] >= quantity: self.products[product_name] -= quantity return True return False def get_stock(self, product_name: str) -> int: return self.products.get(product_name, 0) # Example Usage: inventory = Inventory() inventory.add_product(\\"apple\\", 100) inventory.add_product(\\"banana\\", 50) assert inventory.purchase(\\"apple\\", 20) == True # Enough stock assert inventory.purchase(\\"banana\\", 60) == False # Insufficient stock assert inventory.get_stock(\\"apple\\") == 80 # 100 - 20 = 80 assert inventory.get_stock(\\"banana\\") == 50 # Stock remains the same since purchase was unsuccessful ``` # Implementation Hints: - Use a dictionary to manage the product inventory for efficient lookup, addition, and update operations. - Handle edge cases like purchasing more than available stock or querying a non-existent product\'s stock level appropriately.","solution":"class Inventory: def __init__(self): self.products = {} def add_product(self, product_name: str, quantity: int) -> None: if product_name in self.products: self.products[product_name] += quantity else: self.products[product_name] = quantity def purchase(self, product_name: str, quantity: int) -> bool: if product_name in self.products and self.products[product_name] >= quantity: self.products[product_name] -= quantity return True return False def get_stock(self, product_name: str) -> int: return self.products.get(product_name, 0)"},{"question":"# Question: Minimum Steps to Reach a Target Sum You need to implement a function that calculates the minimum number of steps required to reach a target sum starting from 0. In each step, you can either add or subtract the step number from your current sum. __Requirements:__ * Your function should efficiently compute the minimum steps required to reach the target sum. * The implementation should handle both positive and negative target values. __Function Signature:__ ```python def min_steps_to_target(target: int) -> int: pass ``` __Input:__ * An integer `target`, which can be any value within the range `-10^9` to `10^9`. __Output:__ * Return the minimum number of steps required to reach the target sum from 0. __Constraints:__ * The input `target` will be an integer. * The function should handle edge cases where `target` is zero. __Example:__ ```python assert min_steps_to_target(3) == 2 assert min_steps_to_target(2) == 3 assert min_steps_to_target(-5) == 5 assert min_steps_to_target(0) == 0 ``` __Explanation:__ * For `target=3`, the steps are 1 (+1), 2 (+2), thus only 2 steps are needed. * For `target=2`, the steps are 1 (+1), 2 (+2), 3 (-3), thus 3 steps are needed. * For `target=-5`, the steps are 1 (-1), 2 (-3), 3 (0), 4 (0), 5 (-5), thus 5 steps are needed.","solution":"def min_steps_to_target(target: int) -> int: target = abs(target) step = 0 total_sum = 0 while total_sum < target or (total_sum - target) % 2 != 0: step += 1 total_sum += step return step"},{"question":"# Question: Frequency of Most Frequent Element Given an integer array `nums`, write a function that returns the maximum frequency of any element in the array. The maximum frequency is the highest number of times any single element appears in the array. Task: Write a function `max_frequency(nums: List[int]) -> int` that computes this frequency. Input: - `nums` (List[int]): A list of integers where `1 <= len(nums) <= 10^5` and each integer in the list can be between `-10^9` and `10^9`. Output: - Returns: An integer representing the maximum frequency of any element in the array. Constraints: - The list can contain negative, zero, and positive integers. - The frequency calculation must be performed efficiently to handle large inputs. Example: ```python >>> max_frequency([1, 2, 2, 3, 3, 3, 4]) 3 >>> max_frequency([5, 5, 5, 1]) 3 >>> max_frequency([-1, -1, 2, 2, -1]) 3 ``` Write a function `max_frequency` that meets the requirements and passes the given examples. Ensure to consider edge cases and strive for an efficient solution.","solution":"def max_frequency(nums): Returns the maximum frequency of any element in the nums array. from collections import Counter count = Counter(nums) return max(count.values())"},{"question":"# Problem Statement Consider a directed graph represented by an adjacency list. Each node in the graph has a unique string identifier. Write a function `shortest_path` that takes the graph and two nodes `start` and `end` and returns the shortest path from `start` to `end` as a list of node identifiers. If there is no path between the nodes, return an empty list. # Function Signature ```python def shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: ``` # Input - `graph`: A dictionary where keys are node identifiers (strings) and values are lists of adjacent node identifiers (strings). - `start`: A string representing the starting node. - `end`: A string representing the ending node. # Output - A list of string identifiers representing the shortest path from `start` to `end`. If no path exists, return an empty list. # Constraints - The graph does not contain any cycles. - The maximum number of nodes in the graph is 1000. - Node identifiers are unique strings of length between 1 and 10. - Nodes might not be connected directly but through intermediate nodes. # Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"C\\", \\"D\\"], \\"C\\": [\\"D\\"], \\"D\\": [\\"E\\"], \\"E\\": [] } print(shortest_path(graph, \\"A\\", \\"E\\")) # Output should be [\'A\', \'B\', \'D\', \'E\'] print(shortest_path(graph, \\"A\\", \\"F\\")) # Output should be [] ``` # Notes - Consider the properties of directed graphs and the implications for pathfinding. - Implement an appropriate graph traversal algorithm such as BFS (Breadth-First Search) to find the shortest path. - Ensure your solution handles cases where there is no possible path from the start node to the end node efficiently. - You may assume the graph is well-formed and does not contain invalid data. # Additional Context This problem assesses your understanding of graph data structures, traversal algorithms, and handling edge cases in graph-based problems. It requires you to implement an efficient search mechanism to find the shortest path in a directed graph.","solution":"from collections import deque from typing import List, Dict def shortest_path(graph: Dict[str, List[str]], start: str, end: str) -> List[str]: Finds the shortest path in a directed graph from start node to end node. Parameters: graph (Dict[str, List[str]]): The adjacency list of the graph. start (str): The starting node. end (str): The ending node. Returns: List[str]: The list of node identifiers representing the shortest path, or an empty list if no path exists. if start == end: return [start] # Queue to store (current path, current node) queue = deque([[start]]) # Set to store visited nodes visited = set() visited.add(start) while queue: # Get the first path from the queue path = queue.popleft() node = path[-1] # Traverse all the neighbors of the current node for neighbor in graph.get(node, []): # Create a new path including the neighbor new_path = list(path) new_path.append(neighbor) # Check if the neighbor is the end node if neighbor == end: return new_path # If neighbor hasn\'t been visited yet, add it to the visited set and queue if neighbor not in visited: visited.add(neighbor) queue.append(new_path) return []"},{"question":"# Problem Description You\'re working on a software system to analyze and predict the behavior of mechanical springs in engineering applications. Your goal is to create a tool that computes the potential energy stored in a spring and the force exerted by the spring based on Hooke\'s Law. Objective Write two functions `spring_potential_energy` and `spring_force` that calculate the potential energy stored in the spring and the force exerted by the spring, respectively. Function Signatures * `spring_potential_energy(spring_constant: float, displacement: float) -> float` * `spring_force(spring_constant: float, displacement: float) -> float` # Function Definitions 1. **spring_potential_energy** This function calculates the potential energy stored in the spring using the formula: [ E = frac{1}{2} k x^2 ] where ( E ) is the potential energy, ( k ) is the spring constant, and ( x ) is the displacement from equilibrium. 2. **spring_force** This function calculates the force exerted by the spring using Hooke\'s Law: [ F = k times x ] where ( F ) is the force, ( k ) is the spring constant, and ( x ) is the displacement from equilibrium. # Input * `spring_constant` (float): The spring constant (stiffness of the spring), greater than 0. * `displacement` (float): The displacement from the spring\'s equilibrium position (can be positive or negative, including zero). # Output * Returns the respective computed energy or force as a float. # Constraints * If the `spring_constant` is less than or equal to 0, raise a `ValueError` with the message: `\\"spring_constant must be a positive float.\\"` # Examples ```python # Example for spring_potential_energy print(spring_potential_energy(10, 2)) # Expected Output: 20.0 print(spring_potential_energy(5, 0)) # Expected Output: 0.0 print(spring_potential_energy(8, -1.5)) # Expected Output: 9.0 # Example for spring_force print(spring_force(10, 2)) # Expected Output: 20.0 print(spring_force(5, 0)) # Expected Output: 0.0 print(spring_force(8, -1.5)) # Expected Output: -12.0 ``` # Instructions 1. Ensure efficient and correct handling of edge cases. 2. Raise appropriate errors for invalid inputs. 3. Make sure to test your code thoroughly using the provided examples and additional test cases if necessary.","solution":"def spring_potential_energy(spring_constant: float, displacement: float) -> float: Calculate the potential energy stored in the spring. Parameters: spring_constant (float): The spring constant (stiffness) of the spring. Must be positive. displacement (float): The displacement from the spring\'s equilibrium position. Returns: float: The potential energy stored in the spring. Raises: ValueError: If spring_constant is not greater than 0. if spring_constant <= 0: raise ValueError(\\"spring_constant must be a positive float.\\") return 0.5 * spring_constant * displacement ** 2 def spring_force(spring_constant: float, displacement: float) -> float: Calculate the force exerted by the spring. Parameters: spring_constant (float): The spring constant (stiffness) of the spring. Must be positive. displacement (float): The displacement from the spring\'s equilibrium position. Returns: float: The force exerted by the spring. Raises: ValueError: If spring_constant is not greater than 0. if spring_constant <= 0: raise ValueError(\\"spring_constant must be a positive float.\\") return spring_constant * displacement"},{"question":"# Problem Statement For a coding exercise, you are required to calculate the longest consecutive subsequence of the same number within a list of integers. Your task is to implement a function that identifies the value of the number with the longest consecutive run and the length of that run. # Requirements & Constraints 1. **Function Name**: `longest_consecutive_subsequence` 2. **Input**: A list of integers `nums` (1 <= len(nums) <= 1,000,000) 3. **Output**: A tuple containing the value of the integer with the longest consecutive run and the length of that run. 4. **Performance**: Your function must run efficiently even for maximum input sizes. 5. **Error Handling**: - Return `None` if the input list is empty. - Raise `TypeError` if `nums` is not a list of integers. # Additional Information You are allowed to use helper functions or classes to maintain readability and performance of your solution. Make sure your solution handles edge cases appropriately, such as lists with all elements the same or lists with no repeating elements. # Example Usage ```python def longest_consecutive_subsequence(nums): # Your implementation goes here # Example inputs and outputs print(longest_consecutive_subsequence([1, 1, 2, 2, 2, 3, 3])) # Output: (2, 3) print(longest_consecutive_subsequence([4, 4, 4, 4])) # Output: (4, 4) print(longest_consecutive_subsequence([])) # Output: None print(longest_consecutive_subsequence([1, 2, 3, 4, 5])) # Output: (1, 1) ``` # Hints - Consider how you can efficiently traverse the list to keep track of current and maximum counts. - Ensure your solution is prepared to handle very large lists within reasonable time limits. - Think about edge cases such as lists containing only one unique number or all unique numbers.","solution":"def longest_consecutive_subsequence(nums): Returns the value of the integer with the longest consecutive run and the length of that run. Returns None if the input list is empty. Raises TypeError if nums is not a list of integers. if not isinstance(nums, list): raise TypeError(\\"Input must be a list.\\") if not nums: return None max_val = None max_length = 0 current_val = nums[0] current_length = 1 for i in range(1, len(nums)): if nums[i] == current_val: current_length += 1 else: if current_length > max_length: max_length = current_length max_val = current_val current_val = nums[i] current_length = 1 # Final check for the last run if current_length > max_length: max_length = current_length max_val = current_val return (max_val, max_length)"},{"question":"# Question **Context**: You are tasked with developing a module for an e-commerce web application. One of the requirements is to calculate the most frequently occurring product IDs from a list of transactions in an efficient manner. **Goal**: Write a function that returns the `k` most frequently occurring product IDs from a given list of transactions. **Function to Implement**: ```python def top_k_frequent_products(transactions: list[int], k: int) -> list[int]: Returns the k most frequently occurring product IDs in the transactions. :param transactions: list of product IDs from transactions :param k: number of top-most frequent product IDs to return :return: a list of k most frequent product IDs ``` **Input**: - `transactions`: A list of integers representing product IDs, where 1 <= len(transactions) <= 10^5 and 1 <= transactions[i] <= 10^9. - `k`: An integer representing the number of top frequent product IDs to return, where 1 <= k <= len(transactions). **Output**: - A list of the `k` most frequent product IDs, sorted in descending order of frequency. If there is a tie in frequencies, the product IDs should be returned in ascending numerical order. **Constraints**: - The solution should aim for a time complexity of O(n log n) or better. - You should not use any inbuilt sorting functions, but you may use helper functions and data structures like dictionaries, heaps, etc. **Example**: ```python >>> top_k_frequent_products([1, 1, 2, 2, 3, 3, 3, 4, 4, 4, 4], 2) [4, 3] >>> top_k_frequent_products([5, 5, 5, 2, 2, 8, 8, 8, 8, 7, 7, 1, 1, 1, 1], 3) [1, 8, 5] ``` **Hint**: - Use a dictionary to count the frequency of each product ID and then leverage a heap to determine the top `k` frequent product IDs efficiently.","solution":"from collections import defaultdict import heapq def top_k_frequent_products(transactions: list[int], k: int) -> list[int]: Returns the k most frequently occurring product IDs in the transactions. :param transactions: list of product IDs from transactions :param k: number of top-most frequent product IDs to return :return: a list of k most frequent product IDs # Step 1: Count frequency of each product ID freq_map = defaultdict(int) for product_id in transactions: freq_map[product_id] += 1 # Step 2: Use a heap to find the top k frequent product IDs heap = [] for product_id, frequency in freq_map.items(): heapq.heappush(heap, (-frequency, product_id)) # invert frequency for max-heap simulation # Step 3: Extract the top k elements from the heap top_k = [] for _ in range(k): top_k.append(heapq.heappop(heap)[1]) return top_k"},{"question":"# Coding Assessment Question You are given a string consisting of lowercase letters and an integer array. Each integer in the array represents the cost associated with removing a character at the corresponding index in the string. Write a function `min_cost_to_remove_duplicates` that returns the minimum cost to remove all duplicate letters such that each letter appears only once. **Function Signature**: ```python def min_cost_to_remove_duplicates(s: str, cost: list[int]) -> int: ``` **Input**: * A string `s` containing only lowercase English letters. * Example: \\"abccbd\\" * A list of integers `cost` where each integer corresponds to the cost of removing the character at the same index in `s`. * Example: [0, 1, 2, 3, 4, 5] **Output**: * An integer representing the minimum total cost to remove the duplicate characters. * Example: 2 **Constraints**: * The string `s` length can be up to 100,000 characters. * The list `cost` will have the same length as `s`. * Each element of `cost` is a non-negative integer, not exceeding 10^5. # Performance Requirements * The solution should aim for O(n) time complexity where n is the length of the string, ensuring efficiency given the constraint limits. # Examples ```python assert min_cost_to_remove_duplicates(\\"abccbd\\", [0, 1, 2, 3, 4, 5]) == 2 assert min_cost_to_remove_duplicates(\\"aabbcc\\", [1, 2, 1, 2, 1, 2]) == 3 assert min_cost_to_remove_duplicates(\\"aaaa\\", [1, 2, 3, 4]) == 6 assert min_cost_to_remove_duplicates(\\"abc\\", [1, 2, 3]) == 0 ``` In solving this problem, consider efficiently tracking and comparing costs, ensuring minimal removals, and validate the handling of various input scenarios, particularly focusing on maintaining performance under large input sizes.","solution":"def min_cost_to_remove_duplicates(s: str, cost: list[int]) -> int: total_cost = 0 i = 0 while i < len(s): current_char = s[i] max_cost = cost[i] sum_cost = cost[i] j = i + 1 # Traverse the sequence of duplicate characters while j < len(s) and s[j] == current_char: sum_cost += cost[j] if cost[j] > max_cost: max_cost = cost[j] j += 1 # We need to remove all but one character in this sequence total_cost += (sum_cost - max_cost) # Move to the next character i = j return total_cost"},{"question":"[Question]: Implement a method in the given `BinarySearchTree` code that finds the lowest common ancestor (LCA) of two given nodes in the binary search tree. The objective of this method is to determine the deepest node that is an ancestor of both specified nodes. # Task Implement a method `find_lca(self, node1: int, node2: int) -> Optional[Node]` in the `BinarySearchTree` class which finds the lowest common ancestor of `node1` and `node2`. If either of the nodes does not exist in the tree, the method should return `None`. # Input - Two integers, `node1` and `node2`, which represent the data values of the nodes for which the LCA is to be found. # Output - A `Node` object representing the lowest common ancestor of the given nodes, or `None` if either node does not exist. # Constraints * The nodes being searched for will always be different. * Assume all values in the binary search tree are unique. # Example Consider the following sequence of events: ```python t = BinarySearchTree() t.put(20) t.put(8) t.put(22) t.put(4) t.put(12) t.put(10) t.put(14) lca = t.find_lca(10, 14) print(lca.label) # Output: 12 lca = t.find_lca(14, 8) print(lca.label) # Output: 8 lca = t.find_lca(10, 22) print(lca.label) # Output: 20 lca = t.find_lca(10, 30) print(lca) # Output: None (since 30 does not exist in the tree) ``` # Tips 1. The LCA of two nodes in a BST is the node that is the lowest (i.e., deepest) node that has both nodes as descendants. 2. Follow the properties of the BST to efficiently locate the LCA by comparing the node values with the current node during traversal. 3. If you reach a node where one of the values becomes the root, then that node is the LCA. If they diverge around the root, then the current node is the LCA. Implement your solution inside the `BinarySearchTree` class below.","solution":"class Node: def __init__(self, label): self.label = label self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def put(self, label): if self.root is None: self.root = Node(label) else: self._put(self.root, label) def _put(self, current, label): if label < current.label: if current.left is None: current.left = Node(label) else: self._put(current.left, label) else: if current.right is None: current.right = Node(label) else: self._put(current.right, label) def find_lca(self, node1, node2): return self._find_lca(self.root, node1, node2) def _find_lca(self, node, node1, node2): if node is None: return None if node.label > node1 and node.label > node2: return self._find_lca(node.left, node1, node2) if node.label < node1 and node.label < node2: return self._find_lca(node.right, node1, node2) if self._find(self.root, node1) and self._find(self.root, node2): return node else: return None def _find(self, node, target): if node is None: return False if node.label == target: return True elif target < node.label: return self._find(node.left, target) else: return self._find(node.right, target)"},{"question":"# Longest Increasing Subsequence with Constraints **Context**: You are working on a data analysis project where you need to identify trends in sequences of data. Specifically, you need to find the longest increasing subsequence (LIS) within an array of numbers. To add complexity, the subsequence should adhere to specific constraints. **Objective**: Implement the function `longest_increasing_subsequence` which takes as input an array of numbers and an integer `max_value` representing the maximum allowed value in the subsequence. # Requirements 1. **Input**: - An array `arr` of `n` integers where `1 ≤ n ≤ 10^4`. - An integer `max_value` where `1 ≤ max_value ≤ 10^6`. 2. **Output**: - An integer representing the length of the longest increasing subsequence (LIS) that only includes numbers less than or equal to `max_value`. 3. **Constraints**: - If the array is empty, the LIS length should be 0. - The numbers in the subsequence must be strictly increasing and must not exceed `max_value`. # Function Signature ```python from typing import List def longest_increasing_subsequence(arr: List[int], max_value: int) -> int: pass ``` # Example ```python assert longest_increasing_subsequence([10, 20, 10, 30, 20, 50], 25) == 2 assert longest_increasing_subsequence([3, 10, 2, 1, 20], 20) == 3 assert longest_increasing_subsequence([10, 9, 2, 5, 3, 7, 101, 18], 50) == 4 assert longest_increasing_subsequence([], 10) == 0 assert longest_increasing_subsequence([1, 2, 1], 1) == 1 ``` # Implementation Notes - Utilize dynamic programming to achieve an efficient solution. - Ensure the algorithm runs in O(n log n) time complexity. - Pay attention to edge cases such as empty arrays and arrays where no elements meet the `max_value` constraint.","solution":"from typing import List import bisect def longest_increasing_subsequence(arr: List[int], max_value: int) -> int: Returns the length of the longest increasing subsequence where all elements are less than or equal to max_value. if not arr: return 0 lis = [] for num in arr: if num <= max_value: pos = bisect.bisect_left(lis, num) if pos < len(lis): lis[pos] = num else: lis.append(num) return len(lis)"},{"question":"# Question: Implement Depth First Search to Count Connected Components in a Graph You are given an undirected graph represented as a dictionary where keys are node labels, and values are lists of adjacent nodes. Write a class `Graph` with the following methods: 1. **Constructor `__init__(self, graph: dict[str, list[str]])`**: - Initializes the graph. 2. **Method `dfs(self, vertex: str, visited: set)`**: - A recursive method to perform Depth First Search (DFS) starting from the given vertex and mark all reachable nodes as visited. 3. **Method `count_connected_components(self) -> int`**: - Returns the number of connected components in the graph. # Example ```python graph = { \\"A\\": [\\"B\\", \\"C\\"], \\"B\\": [\\"A\\", \\"D\\"], \\"C\\": [\\"A\\"], \\"D\\": [\\"B\\"], \\"E\\": [\\"F\\"], \\"F\\": [\\"E\\"], \\"G\\": [] } g = Graph(graph) # Counting connected components print(g.count_connected_components()) # Output: 3 ``` # Constraints - The graph is undirected. - All vertex names are unique and consist of uppercase English letters. - The graph can have isolated nodes with no edges. - The method `count_connected_components` should return `1` for a fully connected graph, and higher values for graphs with multiple disjoint subgraphs. Use these constraints and aspects to guide your implementation process.","solution":"class Graph: def __init__(self, graph: dict[str, list[str]]): self.graph = graph def dfs(self, vertex: str, visited: set): visited.add(vertex) for neighbor in self.graph[vertex]: if neighbor not in visited: self.dfs(neighbor, visited) def count_connected_components(self) -> int: visited = set() count = 0 for vertex in self.graph: if vertex not in visited: self.dfs(vertex, visited) count += 1 return count"},{"question":"# Question: Longest Harmonious Subsequence # Scenario As a software developer at a financial firm, you\'re tasked with analyzing customer transaction data. One particular analysis requires identifying the longest harmonious subsequence within a set of transactions. A harmonious subsequence is defined as a subsequence where the difference between the maximum and minimum elements is exactly 1. # Task Write a function `longest_harmonious_subsequence(nums: List[int]) -> int` that finds the length of the longest harmonious subsequence within a given list of integers. Input: * `nums` - a list of integers representing transaction values. Output: * An integer representing the length of the longest harmonious subsequence. If no such subsequence exists, return 0. Constraints: * You can assume that the input list will contain only integer values. * The length of the list (`n`) varies from 1 to 10^4. Example: ```python >>> longest_harmonious_subsequence([1, 3, 2, 2, 5, 2, 3, 7]) 5 >>> longest_harmonious_subsequence([1, 1, 1, 1]) 0 ``` Implementation Tips: 1. Use a hash map to count the frequency of each integer. 2. Iterate through the keys and for each key, check if key+1 exists in the hash map. 3. If key+1 exists, calculate the length of the subsequence formed by key and key+1. 4. Track and return the maximum length found. # Performance Requirements The solution should aim for a time complexity of (O(n)).","solution":"from typing import List from collections import Counter def longest_harmonious_subsequence(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence in a list of integers. num_counts = Counter(nums) max_length = 0 for num in num_counts: if num + 1 in num_counts: max_length = max(max_length, num_counts[num] + num_counts[num + 1]) return max_length"},{"question":"Dijkstra\'s Algorithm for Shortest Path Implement Dijkstra\'s algorithm to find the shortest path from a source node to all other nodes in a given directed weighted graph. The graph is represented using an adjacency matrix. # Function Signature ```python def dijkstra(adj_matrix: List[List[int]], start: int) -> List[int]: ``` # Input * `adj_matrix`: A list of lists where each inner list represents a row in the adjacency matrix. The value at `adj_matrix[i][j]` represents the weight of the edge from node `i` to node `j`. If there\'s no edge, the value will be `float(\'inf\')`. * `start`: An integer representing the starting node for Dijkstra\'s algorithm. # Output * Returns a list of integers where the `i`-th element represents the shortest distance from the start node to the `i`-th node in the graph. # Constraints * Number of nodes (n): `2 <= n <= 1000` * Edge weights: Non-negative integers or `float(\'inf\')` for no direct path. # Example ```python adj_matrix = [ [0, 2, float(\'inf\'), 4], [2, 0, 1, float(\'inf\')], [float(\'inf\'), 1, 0, 3], [4, float(\'inf\'), 3, 0] ] start = 0 shortest_distances = dijkstra(adj_matrix, start) print(shortest_distances) ``` # Expected Output ``` [0, 2, 3, 4] ``` # Performance Requirements * The algorithm should efficiently handle graphs with up to 1000 nodes. * Ensure that the implementation is optimized to handle dense graphs within a reasonable time frame. # Additional Notes * You can use standard libraries and data structures (e.g., heap) to optimize the performance of your implementation. * The function should correctly handle graphs with nodes that are not connected to any other nodes. * Ensure that the implementation handles graphs with multiple shortest paths by always returning the first encountered shortest path.","solution":"import heapq from typing import List def dijkstra(adj_matrix: List[List[int]], start: int) -> List[int]: n = len(adj_matrix) distances = [float(\'inf\')] * n distances[start] = 0 visited = [False] * n min_heap = [(0, start)] # (distance, node) while min_heap: current_distance, current_node = heapq.heappop(min_heap) if visited[current_node]: continue visited[current_node] = True for neighbor in range(n): weight = adj_matrix[current_node][neighbor] if weight != float(\'inf\') and not visited[neighbor]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances"},{"question":"# List Processing and Manipulation Problem Statement You are given a list of `n` integers and a separate list of `m` operations. Each operation is one of the following: - `add x` - Add `x` to each element in the list. - `mul x` - Multiply each element in the list by `x`. - `delete d` - Delete the element at index `d`. If `d` is out of bounds, leave the list unchanged. - `insert x d` - Insert `x` at index `d`. If `d` is out of bounds, append `x` to the list. Your task is to write a function: ```python def process_operations(values: List[int], operations: List[str]) -> List[int]: ``` - **Input**: - `values` (type: `List[int]`): A list of integers. - `operations` (type: `List[str]`): A list of operations to perform on the values list. - **Output**: - A list of integers after all operations have been performed. Constraints - `1 <= n <= 10^5`, where `n` is the number of elements in `values`. - `1 <= m <= 10^5`, where `m` is the number of operations. - Each element in `values` is an integer between `-10^6` and `10^6`. - `x` in operations is an integer between `-10^6` and `10^6`. - `d` in `delete` and `insert` operations is a non-negative integer. Examples ```python assert process_operations([1, 2, 3], [\\"add 2\\", \\"mul 3\\"]) == [9, 12, 15] assert process_operations([4, 5, 6], [\\"delete 1\\", \\"insert 10 1\\"]) == [4, 10, 6] assert process_operations([], [\\"add 2\\", \\"insert 5 0\\"]) == [5] assert process_operations([10, 20, 30], [\\"delete -1\\"]) == [10, 20, 30] assert process_operations([10, 20, 30], [\\"insert 5 100\\"]) == [10, 20, 30, 5] ``` Note Make sure that edge cases such as empty lists and out-of-bounds indices are handled gracefully. Focus on efficient implementation to handle the upper constraint limits.","solution":"def process_operations(values, operations): Process a list of operations on the given list of integers. for operation in operations: op = operation.split() command = op[0] if command == \\"add\\": x = int(op[1]) values = [v + x for v in values] elif command == \\"mul\\": x = int(op[1]) values = [v * x for v in values] elif command == \\"delete\\": d = int(op[1]) if 0 <= d < len(values): values.pop(d) elif command == \\"insert\\": x = int(op[1]) d = int(op[2]) if 0 <= d <= len(values): values.insert(d, x) else: values.append(x) return values"},{"question":"# Context You are given two strings, `s1` and `s2`. Your task is to determine if these two strings are one edit distance apart. A string can be considered one edit distance apart from another string if you can: - Insert exactly one character into one string to make the two strings equal. - Delete exactly one character from one string to make the two strings equal. - Substitute exactly one character from one string to make the two strings equal. # Task 1. Implement the function `is_one_edit_distance(s1: str, s2: str) -> bool` that checks whether two strings are one edit distance apart. 2. Ensure that the function does not allow more than one operation to be performed. # Expected Input and Output * **is_one_edit_distance(s1: str, s2: str) -> bool**: Return `True` if the strings are one edit distance apart, otherwise return `False`. # Constraints * The lengths of `s1` and `s2` will be between 0 and 10,000 inclusive. * The strings `s1` and `s2` will consist of lowercase English letters. # Example ```python print(is_one_edit_distance(\\"abc\\", \\"ab\\")) # Output: True print(is_one_edit_distance(\\"abc\\", \\"abz\\")) # Output: True print(is_one_edit_distance(\\"abc\\", \\"abcd\\")) # Output: True print(is_one_edit_distance(\\"abc\\", \\"abcde\\")) # Output: False print(is_one_edit_distance(\\"example\\", \\"samples\\")) # Output: False print(is_one_edit_distance(\\"\\", \\"a\\")) # Output: True ``` # Performance Requirements * The function should run in O(n) time complexity where n is the length of the longer string.","solution":"def is_one_edit_distance(s1: str, s2: str) -> bool: Determines if two strings are one edit distance apart. len1, len2 = len(s1), len(s2) # If the length difference between the two strings is more than 1, they cannot be one edit apart. if abs(len1 - len2) > 1: return False # Make sure s1 is the shorter string, if not swap. if len1 > len2: s1, s2 = s2, s1 len1, len2 = len2, len1 i, j = 0, 0 found_difference = False while i < len1 and j < len2: if s1[i] != s2[j]: if found_difference: return False found_difference = True if len1 == len2: # If lengths are the same, move both pointers i += 1 else: i += 1 j += 1 return found_difference or len1 < len2"},{"question":"# Problem Statement **The Skyline Problem** Given the locations and heights of multiple buildings in a cityscape, your objective is to compute the skyline formed by these buildings when viewed from a distance. The skyline is a series of \\"key points\\" that visually represent the outer contour of the buildings. Each building is represented by a triplet: `[left, right, height]`, where `left` and `right` are the x-coordinates of the building\'s left and right edges, and `height` is the building\'s height. # Requirements: 1. **Function Definition**: ```python def get_skyline(buildings: list[list[int]]) -> list[list[int]]: Computes the skyline formed by a list of buildings. Parameters: buildings (list): A list of lists, where each sublist contains three integers [left, right, height]. Returns: list: A list of key points that form the skyline, where each key point is represented as [x, height]. ``` 2. **Input Specifications**: * A list of buildings where each building is represented as a triplet [left, right, height]. * The number of buildings, `n`, is between 1 and 1000. * Each coordinate or height is an integer within the range [-10^4, 10^4]. 3. **Output Specifications**: * A list of key points that represent the skyline in the format [x, height]. * The key points should be sorted by their x-coordinate. * Each key point represents a horizontal or vertical transition in the skyline. 4. **Constraints**: * Buildings may overlap. * There can be buildings with zero height. # Example: **Input**: ```python buildings = [ [2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8] ] ``` **Output**: ```python [ [2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0] ] ``` # Evaluation Criteria: * **Correctness**: Ensure the function returns the correct skyline for the given buildings. * **Efficiency**: The solution should handle the upper limit efficiently. * **Robustness**: Handle edge cases such as overlapping buildings, buildings with zero height, and buildings with equal start or end points. # Notes: * Focus on an efficient approach, possibly using a heap or divide-and-conquer technique to manage overlapping buildings. * The skyline should visually represent the contour formed by the buildings. * Pay attention to performance, specifically for high overlap and dense cityscapes.","solution":"def get_skyline(buildings): import heapq from collections import defaultdict # Create a list of all start and end points events = [] for left, right, height in buildings: events.append((left, -height, right)) events.append((right, 0, 0)) # Sort the events by position, break ties by height events.sort() # Max-Heap to keep track of building heights live_buildings_heap = [(0, float(\\"inf\\"))] skyline = [] prev_max_height = 0 for x, neg_height, end in events: while live_buildings_heap[0][1] <= x: heapq.heappop(live_buildings_heap) if neg_height != 0: heapq.heappush(live_buildings_heap, (neg_height, end)) current_max_height = -live_buildings_heap[0][0] if current_max_height != prev_max_height: skyline.append([x, current_max_height]) prev_max_height = current_max_height return skyline"},{"question":"# Question: Implementing a Cache with Eviction Policy You are tasked with implementing an extended Least Recently Used (LRU) cache with a special eviction policy. Besides the typical LRU behavior, your cache should also support eviction based on expiration times, with expired entries being removed first if they exist. 1. `class CacheItem`: - **Attributes**: - `key` (string): The key associated with the cache item. - `value` (any): The value associated with the cache item. - `expiration` (int): Unix timestamp indicating the expiration time for the cache item. 2. `class LRUCache`: - **Methods**: - `def __init__(self, capacity: int) -> None`: - **Description**: Initializes the LRUCache with a given capacity. - **Input**: An integer `capacity` indicating the maximum number of items the cache can hold. - `def get(self, key: str) -> any`: - **Description**: Retrieves the value associated with the given key if present, otherwise returns `None`. - **Input**: A string `key` which is the key to look for in the cache. - **Output**: The value associated with the key, or `None` if the key is not in the cache or if the entry has expired. - `def put(self, key: str, value: any, expiration: int) -> None`: - **Description**: Adds a key-value pair to the cache with a specified expiration time. Evicts the least recently used item or expired items if the cache exceeds its capacity. - **Input**: A string `key`, the value `value` to be stored, and an integer `expiration` representing the expiration timestamp. # Example ```python import time # Time simulation function def get_time_offset(seconds): return int(time.time()) + seconds cache = LRUCache(2) cache.put(\\"a\\", 1, get_time_offset(5)) # Expires in 5 seconds cache.put(\\"b\\", 2, get_time_offset(10)) # Expires in 10 seconds assert cache.get(\\"a\\") == 1 time.sleep(6) assert cache.get(\\"a\\") == None # Expired assert cache.get(\\"b\\") == 2 cache.put(\\"c\\", 3, get_time_offset(5)) # Should evict \\"a\\" even though it is expired assert cache.get(\\"a\\") == None assert cache.get(\\"b\\") == 2 assert cache.get(\\"c\\") == 3 ``` # Constraints - The cache should be able to hold both string and integer types as values. - All input keys are unique. - The `expiration` times are provided as Unix timestamps and always in the future relative to the insertion time. - Assume that the `put` and `get` methods are called in a thread-safe manner and no further thread synchronization is needed. # Performance Requirements - The `get` and `put` methods should have an average time complexity of O(1).","solution":"import time import collections class CacheItem: def __init__(self, key, value, expiration): self.key = key self.value = value self.expiration = expiration class LRUCache: def __init__(self, capacity: int) -> None: self.capacity = capacity self.cache = collections.OrderedDict() def _evict_expired(self): current_time = int(time.time()) expired_keys = [key for key, item in self.cache.items() if item.expiration < current_time] for key in expired_keys: del self.cache[key] def get(self, key: str): self._evict_expired() if key not in self.cache: return None item = self.cache.pop(key) self.cache[key] = item # Move key to end to show it was recently used return item.value def put(self, key: str, value: any, expiration: int) -> None: self._evict_expired() if key in self.cache: self.cache.pop(key) elif len(self.cache) >= self.capacity: self.cache.popitem(last=False) self.cache[key] = CacheItem(key, value, expiration)"},{"question":"# Question: Implementing a Priority Queue with Custom Comparison You need to implement a custom Priority Queue class that operates on sequences of items while respecting a provided comparator function. This priority queue should support insertion, deletion of the highest-priority item, and retrieval of the highest-priority item without deletion. Requirements: 1. `insert(self, item: Any) -> None`: Inserts an item into the priority queue. 2. `peek(self) -> Any`: Returns the highest-priority item without removing it. 3. `delete_max(self) -> Any`: Deletes and returns the highest-priority item. You should also implement the `__init__` method to accept a custom comparator function that determines the priority of the items. The comparator function takes two items as arguments and returns: - A negative number if the first item has lower priority. - Zero if both items have equal priority. - A positive number if the first item has higher priority. The priority queue should be implemented using a max-heap for efficiency. # Example Usage: ```python from typing import Any, Callable class PriorityQueue: def __init__(self, comparator: Callable[[Any, Any], int]): self.comparator = comparator self.heap = [] def insert(self, item: Any) -> None: # Add your implementation here pass def peek(self) -> Any: # Add your implementation here pass def delete_max(self) -> Any: # Add your implementation here pass # Custom comparator function def custom_comparator(a, b): return a - b pq = PriorityQueue(comparator=custom_comparator) # Insert items into the priority queue pq.insert(5) pq.insert(9) pq.insert(2) pq.insert(16) # Peek at the highest-priority item print(pq.peek()) # Expected output: 16 # Delete and return the highest-priority item print(pq.delete_max()) # Expected output: 16 # Verify the highest-priority item after deletion print(pq.peek()) # Expected output: 9 ``` # Constraints: - The priority queue should operate in (O(log n)) time complexity for insertions and deletions. - The items in the priority queue must be comparable using the provided comparator function. - The priority queue should handle any comparable data type (integers, strings, etc.). # Additional Details: The internal representation of the max-heap can leverage a list, and you need to ensure that the comparator function is correctly used to maintain the max-heap property.","solution":"from typing import Any, Callable, List class PriorityQueue: def __init__(self, comparator: Callable[[Any, Any], int]): self.comparator = comparator self.heap: List[Any] = [] def _sift_up(self, index: int) -> None: parent = (index - 1) // 2 if index > 0 and self.comparator(self.heap[index], self.heap[parent]) > 0: self.heap[index], self.heap[parent] = self.heap[parent], self.heap[index] self._sift_up(parent) def _sift_down(self, index: int) -> None: largest = index left_child = 2 * index + 1 right_child = 2 * index + 2 if left_child < len(self.heap) and self.comparator(self.heap[left_child], self.heap[largest]) > 0: largest = left_child if right_child < len(self.heap) and self.comparator(self.heap[right_child], self.heap[largest]) > 0: largest = right_child if largest != index: self.heap[index], self.heap[largest] = self.heap[largest], self.heap[index] self._sift_down(largest) def insert(self, item: Any) -> None: self.heap.append(item) self._sift_up(len(self.heap) - 1) def peek(self) -> Any: if not self.heap: raise IndexError(\\"Peek from an empty priority queue\\") return self.heap[0] def delete_max(self) -> Any: if not self.heap: raise IndexError(\\"Delete from an empty priority queue\\") if len(self.heap) == 1: return self.heap.pop() max_item = self.heap[0] self.heap[0] = self.heap.pop() self._sift_down(0) return max_item"},{"question":"# Coding Assessment Question: **Problem Description**: Design and implement a P2P (peer-to-peer) messaging network simulator. The purpose of this exercise is to verify your understanding of distributed systems, message passing mechanisms, and handling network communication in a simulated environment. **Requirements**: Create a `P2PMessagingNetwork` class with the ability to add nodes, connect nodes, and facilitate message passing between them. The implementation must include the following methods: 1. **Constructor `__init__(self)`** - Initialize the network with attributes for storing nodes and connections. 2. **Method `add_node(self, node: str) -> None`** - Add a new node to the network. 3. **Method `connect_nodes(self, node1: str, node2: str) -> None`** - Establish a bidirectional connection between two nodes. 4. **Method `send_message(self, from_node: str, to_node: str, message: str) -> List[str]`** - Simulate sending a message from one node to another through the shortest path available in the network. - Return the list of nodes traversed by the message. **Input/Output**: 1. **Constructor Parameters**: - None 2. **Method Parameters for `add_node`**: - `node` (str): The identifier of the node to be added to the network. 3. **Method Parameters for `connect_nodes`**: - `node1` (str): The identifier of the first node to be connected. - `node2` (str): The identifier of the second node to be connected. 4. **Method Parameters for `send_message`**: - `from_node` (str): The identifier of the node sending the message. - `to_node` (str): The identifier of the node receiving the message. - `message` (str): The content of the message to be sent. 5. **Method Output for `send_message`**: - Return (List[str]): A list of node identifiers representing the path traversed by the message. **Constraints**: - There will be at most 100 nodes in the network. - All node identifiers are unique strings without spaces. - Nodes are connected in a way that there is always a path between any two nodes. - Messages must be routed through the shortest available path. **Example**: ```python class P2PMessagingNetwork: def __init__(self): self.nodes = set() self.edges = {} def add_node(self, node): self.nodes.add(node) self.edges[node] = set() def connect_nodes(self, node1, node2): if node1 in self.nodes and node2 in self.nodes: self.edges[node1].add(node2) self.edges[node2].add(node1) def send_message(self, from_node, to_node, message): # Implement BFS to find the shortest path between from_node and to_node from collections import deque queue = deque([(from_node, [from_node])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == to_node: print(f\\"Message: {message}\\") return path for neighbor in self.edges[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return [] if __name__ == \\"__main__\\": network = P2PMessagingNetwork() # Add nodes for node in [\'A\', \'B\', \'C\', \'D\', \'E\']: network.add_node(node) # Connect nodes network.connect_nodes(\'A\', \'B\') network.connect_nodes(\'B\', \'C\') network.connect_nodes(\'C\', \'D\') network.connect_nodes(\'D\', \'E\') network.connect_nodes(\'A\', \'E\') # Send message path = network.send_message(\'A\', \'D\', \'Hello, World!\') print(f\\"Path traversed: {path}\\") ``` **Objective**: Ensure you understand the fundamentals of networking, efficient pathfinding algorithms, and are capable of simulating a realistic distributed system for message passing.","solution":"from collections import deque from typing import List class P2PMessagingNetwork: def __init__(self): self.nodes = set() self.edges = {} def add_node(self, node: str) -> None: self.nodes.add(node) self.edges[node] = set() def connect_nodes(self, node1: str, node2: str) -> None: if node1 in self.nodes and node2 in self.nodes: self.edges[node1].add(node2) self.edges[node2].add(node1) def send_message(self, from_node: str, to_node: str, message: str) -> List[str]: queue = deque([(from_node, [from_node])]) visited = set() while queue: current_node, path = queue.popleft() if current_node == to_node: print(f\\"Message: {message}\\") return path for neighbor in self.edges[current_node]: if neighbor not in visited: visited.add(neighbor) queue.append((neighbor, path + [neighbor])) return []"},{"question":"# Find Missing Number in Arithmetic Progression Problem Statement You are required to implement a function that takes in a list representing an arithmetic progression with one missing element and returns the missing number. An arithmetic progression is a sequence of numbers in which the difference between any two consecutive terms is constant. Assume the input list contains at least three elements and exactly one number is missing. Function Signature ```python def find_missing_number(arr: list) -> int: ``` Input - `arr` (list) : a list of integers where one element is missing, 3 <= len(arr) <= 10^3 and all elements are within the range of -10^6 to 10^6. Output - An integer representing the missing number in the arithmetic progression. Constraints - The input list will contain at least 3 elements and at most 10^3 elements. - The common difference of the arithmetic progression will be constant and not equal to zero. - The elements in the list are distinct. - The list is unsorted. Examples ```python >>> find_missing_number([5, 15, 10, 25]) 20 >>> find_missing_number([9, 18, 27, 36, 54]) 45 >>> find_missing_number([2, 8, 20]) 14 >>> find_missing_number([10, 20, 40, 50]) 30 >>> find_missing_number([-1, -3, -7, -9]) -5 ``` Additional Notes To solve this problem, consider sorting the list and calculating the common difference based on the first and last elements. Use the common difference to find the expected value at each position in the sequence, and detect the missing number based on the discrepancy between the expected values and the list elements.","solution":"def find_missing_number(arr: list) -> int: # Step 1: Sort the array arr.sort() # Step 2: Find the common difference (we can take any adjacent pair in the sorted list) n = len(arr) common_diff = (arr[-1] - arr[0]) // n # Step 3: Iterate over the sorted array and find the missing number for i in range(1, n): expected = arr[0] + i * common_diff if arr[i] != expected: return expected # Fallback return, though the problem guarantees there\'s a missing number return None"},{"question":"Iterative Binary Search **Problem Statement**: You are required to implement the Binary Search algorithm iteratively. Your task is to create a function that takes a sorted list of integers and a target integer and returns the index of the target if found; otherwise, returns -1. The implementation should be done without using recursion. **Function Signature**: ```python def binary_search_iterative(arr: List[int], target: int) -> int: Approach: - Uses a while loop to repeatedly divide the search interval in half. - Compares the target to the middle element of the interval. - Adjusts the interval based on whether the target is less than or greater than the middle element. Params: - arr (List[int]): A sorted list of integers. - target (int): The integer value to search for in the list. Returns: - int: The index of the target if found, otherwise -1. pass ``` **Input**: * `arr` - A list of integers sorted in ascending order. * `target` - An integer representing the target value to search for. **Output**: * An integer representing the index of the target if found; otherwise, -1. **Constraints**: * `1 <= len(arr) <= 10^4` * `-10^4 <= arr[i], target <= 10^4` **Example**: ```python # Example use-case arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 5 print(binary_search_iterative(arr, target)) # Output: 4 arr = [-10, -5, 0, 5, 10] target = 0 print(binary_search_iterative(arr, target)) # Output: 2 arr = [1, 2, 3, 4, 5] target = 6 print(binary_search_iterative(arr, target)) # Output: -1 ``` **Note**: - Ensure that your implementation avoids infinite loops and handles the case where the target is not present in the list. - Test your function with various sorted lists and target values to ensure its correctness.","solution":"from typing import List def binary_search_iterative(arr: List[int], target: int) -> int: left, right = 0, len(arr) - 1 while left <= right: mid = (left + right) // 2 if arr[mid] == target: return mid elif arr[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Scenario A social media platform is trying to analyze its traffic by categorizing user sessions into different types based on their activity patterns. You are tasked with implementing a function to classify sessions as \\"Active\\", \\"Passive\\", or \\"Ghost\\" based on interaction metrics such as posts, likes, and comments. The classification criteria are as follows: - \\"Active\\" if a user makes at least 10 posts or at least 30 interactions in total. - \\"Passive\\" if a user makes between 1 and 9 posts and has fewer than 30 interactions in total. - \\"Ghost\\" if a user makes 0 posts or has no interactions at all. # Task Implement the function `classify_sessions` that takes a DataFrame of user sessions and returns a list of strings representing the classification for each session. # Function Signature ```python def classify_sessions(sessions: pd.DataFrame) -> List[str]: ``` # Input - `sessions`: A pandas DataFrame with three columns: - `posts` (number of posts made by the user). - `likes` (number of likes given by the user). - `comments` (number of comments made by the user). # Output - Returns a list of strings where each string is \\"Active\\", \\"Passive\\", or \\"Ghost\\" based on the criteria. # Constraints - The DataFrame provided will contain at least 5 sessions. # Performance - The solution should efficiently handle data up to 5000 sessions. # Example ```python import pandas as pd sessions = pd.DataFrame({ \'posts\': [0, 5, 2, 15, 1], \'likes\': [0, 10, 5, 50, 20], \'comments\': [0, 10, 3, 20, 5] }) print(classify_sessions(sessions)) # Output: [\\"Ghost\\", \\"Passive\\", \\"Passive\\", \\"Active\\", \\"Passive\\"] ``` Use the provided method signature and implement the logic within the `classify_sessions` function to achieve the described functionality.","solution":"import pandas as pd from typing import List def classify_sessions(sessions: pd.DataFrame) -> List[str]: classifications = [] for index, row in sessions.iterrows(): total_interactions = row[\'posts\'] + row[\'likes\'] + row[\'comments\'] if row[\'posts\'] == 0 and total_interactions == 0: classifications.append(\\"Ghost\\") elif row[\'posts\'] >= 10 or total_interactions >= 30: classifications.append(\\"Active\\") elif 1 <= row[\'posts\'] <= 9 and total_interactions < 30: classifications.append(\\"Passive\\") else: classifications.append(\\"Ghost\\") return classifications"},{"question":"# Frequency Counter for Characters You are tasked with implementing a function that counts the frequency of each character in a given string and returns the frequencies in a dictionary. Function Signature ```python def char_frequency(s: str) -> dict: ``` Input - A single string `s` where ( 1 leq text{len}(s) leq 10^5 ). Output - A dictionary where the keys are characters, and the values are the counts of each character in the input string. Constraints - The input string can contain any printable ASCII characters. Examples 1. `char_frequency(\\"hello\\")` should return `{\'h\': 1, \'e\': 1, \'l\': 2, \'o\': 1}`. 2. `char_frequency(\\"test123\\")` should return `{\'t\': 2, \'e\': 1, \'s\': 1, \'1\': 1, \'2\': 1, \'3\': 1}`. 3. `char_frequency(\\"aabbbcccc\\")` should return `{\'a\': 2, \'b\': 3, \'c\': 4}`. 4. `char_frequency(\\"!@#%^&*()\\")` should return `{\'!\': 1, \'@\': 1, \'#\': 1, \'\': 1, \'%\': 1, \'^\': 1, \'&\': 1, \'*\': 1, \'(\': 1, \')\': 1}`. Edge cases to consider: - Strings with only one character (e.g., \\"a\\" should return `{\'a\': 1}`). - Strings containing special characters and spaces. - Very long strings should be efficiently handled. Implement your solution with careful consideration of performance, ensuring it runs efficiently for large input sizes. Provide appropriate tests to validate your implementation.","solution":"def char_frequency(s: str) -> dict: Returns a dictionary with the frequency of each character in the input string. freq = {} for char in s: if char in freq: freq[char] += 1 else: freq[char] = 1 return freq"},{"question":"# Coding Assessment Question Scenario An online marketplace allows vendors to list their products with detailed descriptions. They want to enhance their search functionality by implementing an auto-suggestion feature. This feature suggests the most relevant keywords as the user types in a search query. Your task is to write a function to generate these keyword suggestions based on the available product descriptions. Task Write a function `get_suggestions(products: list[str], query: str, max_suggestions: int) -> list[str]` that returns a list of keyword suggestions based on the partial query provided. Input * `products`: A list of strings, where each string represents a product description. * `query`: A string representing the partial query the user has typed in. * `max_suggestions`: An integer representing the maximum number of suggestions to return. Output * A list of strings representing the most relevant keyword suggestions. Constraints * Each product description in the `products` list is a non-empty string containing lowercase letters and spaces. * The `query` string will only contain lowercase letters and have a length of at least one character. * The `max_suggestions` will be a positive integer. * If fewer than `max_suggestions` keywords match the query, return all matching keywords. Example ```python def get_suggestions(products: list[str], query: str, max_suggestions: int) -> list[str]: # function implementation # Example Calls products1 = [ \\"wireless earphones with noise cancellation\\", \\"smartphone with the best camera\\", \\"smartwatch with various health features\\", \\"noise-canceling wireless headphones\\", \\"wireless mouse for gaming\\", \\"smart light bulbs\\" ] query1 = \\"wire\\" max_suggestions1 = 3 print(get_suggestions(products1, query1, max_suggestions1)) # Output: [\\"wireless earphones with noise cancellation\\", \\"wireless mouse for gaming\\", \\"noise-canceling wireless headphones\\"] query2 = \\"smart\\" max_suggestions2 = 2 print(get_suggestions(products1, query2, max_suggestions2)) # Output: [\\"smartphone with the best camera\\", \\"smartwatch with various health features\\"] ``` Additional Notes * Suggestions should be in the order in which they appear in the original `products` list. * Only full words in the product descriptions that match the query should be included. * Consider performance for larger lists of product descriptions.","solution":"def get_suggestions(products: list[str], query: str, max_suggestions: int) -> list[str]: Returns a list of keyword suggestions based on the query. :param products: List of product descriptions :param query: Partial query string :param max_suggestions: Maximum number of suggestions to return :return: List of keyword suggestions suggestions = [] for product in products: if query in product: suggestions.append(product) if len(suggestions) == max_suggestions: break return suggestions"},{"question":"# Problem You are tasked with developing a module to analyze palindrome properties in strings. A palindrome is a sequence of characters that reads the same backwards as forwards. Your task is to write a function `is_palindrome`, and another function `longest_palindromic_substring`. # Requirements 1. `is_palindrome` should determine if the provided string is a palindrome. 2. `longest_palindromic_substring` should find and return the longest palindromic substring within the input string. 3. The functions should be efficient and handle both upper and lower case letters. # Constraints * Strings will contain only ASCII characters. * The length of the string will range from 1 to 1000. # Input and Output Format - `is_palindrome(s: str) -> bool` - `longest_palindromic_substring(s: str) -> str` Here\'s an example of how these functions should work: ```python s = \'babad\' assert is_palindrome(\'Aibohphobia\') == True assert is_palindrome(\'Palindrome\') == False assert longest_palindromic_substring(s) == \'bab\' or longest_palindromic_substring(s) == \'aba\' ``` # Additional Information - The solutions should be case insensitive. - Consider edge cases like strings with a single character or the entire string being a palindrome. # Solution Template ```python def is_palindrome(s: str) -> bool: Determine if the provided string is a palindrome. s = s.lower() return s == s[::-1] def longest_palindromic_substring(s: str) -> str: Find and return the longest palindromic substring. def expand_from_center(string, left, right): while left >= 0 and right < len(string) and string[left] == string[right]: left -= 1 right += 1 return string[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_from_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_from_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest ```","solution":"def is_palindrome(s: str) -> bool: Determine if the provided string is a palindrome. s = s.lower() return s == s[::-1] def longest_palindromic_substring(s: str) -> str: Find and return the longest palindromic substring. def expand_from_center(string, left, right): while left >= 0 and right < len(string) and string[left] == string[right]: left -= 1 right += 1 return string[left + 1:right] longest = \\"\\" for i in range(len(s)): # Odd length palindromes odd_palindrome = expand_from_center(s, i, i) if len(odd_palindrome) > len(longest): longest = odd_palindrome # Even length palindromes even_palindrome = expand_from_center(s, i, i + 1) if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"# Course Enrollment System You are tasked with building a course enrollment system for students at a university. Each student can enroll in multiple courses, and each course can have multiple students. To efficiently manage enrollments, you need to track which students are enrolled in which courses and make it easy to check enrollments and lists of students per course. **Objective**: Implement a `CourseEnrollment` class that allows the following operations: - Enroll students in courses. - Check if a student is enrolled in a course. - List all students enrolled in a course. **Requirements**: 1. **Initialization**: * Initialize the class without any arguments. 2. **Methods**: - `enroll(student_id: int, course_name: str) -> None`: * Enroll the student identified by `student_id` in the course identified by `course_name`. - `is_enrolled(student_id: int, course_name: str) -> bool`: * Return `True` if the student is enrolled in the course, otherwise `False`. - `list_students(course_name: str) -> List[int]`: * Return a list of student IDs enrolled in the specified course in ascending order. **Constraints**: * `1 <= student_id <= 10^6` * `course_name` will be a non-empty string with a maximum length of 100. * A student_id will be a positive integer and unique for each student. **Example**: ```python # Create an instance of the CourseEnrollment class course_system = CourseEnrollment() # Enroll students in courses course_system.enroll(1, \\"Math101\\") course_system.enroll(2, \\"Math101\\") course_system.enroll(1, \\"CS101\\") course_system.enroll(3, \\"Math101\\") # Check if students are enrolled in courses assert course_system.is_enrolled(1, \\"Math101\\") == True assert course_system.is_enrolled(2, \\"CS101\\") == False # List students enrolled in a specific course print(course_system.list_students(\\"Math101\\")) # Expected: [1, 2, 3] print(course_system.list_students(\\"CS101\\")) # Expected: [1] ```","solution":"class CourseEnrollment: def __init__(self): self.course_enrollments = {} def enroll(self, student_id: int, course_name: str) -> None: if course_name not in self.course_enrollments: self.course_enrollments[course_name] = set() self.course_enrollments[course_name].add(student_id) def is_enrolled(self, student_id: int, course_name: str) -> bool: return student_id in self.course_enrollments.get(course_name, set()) def list_students(self, course_name: str) -> list: return sorted(self.course_enrollments.get(course_name, set())) # Example usage: # course_system = CourseEnrollment() # course_system.enroll(1, \\"Math101\\") # course_system.enroll(2, \\"Math101\\") # course_system.enroll(1, \\"CS101\\") # course_system.enroll(3, \\"Math101\\") # print(course_system.is_enrolled(1, \\"Math101\\")) # Expected: True # print(course_system.is_enrolled(2, \\"CS101\\")) # Expected: False # print(course_system.list_students(\\"Math101\\")) # Expected: [1, 2, 3] # print(course_system.list_students(\\"CS101\\")) # Expected: [1]"},{"question":"# Coding Assessment Question Objective To evaluate the understanding and implementation of Depth First Search (DFS) in finding connected components in a grid. Question You are provided with a grid (matrix) representing a city map, where certain cells are marked as parks (\'P\') and others as buildings (\'B\'). Your task is to write a function to calculate the number of disconnected parks within the city. A park is considered connected if it is adjacent vertically or horizontally to another park. Function Signature ```python def count_disconnected_parks(city_map: list[list[str]]) -> int: Returns the number of disconnected parks in the city map. :param city_map: A 2D list of strings where each element is either \'P\' (park) or \'B\' (building) :return: The number of disconnected parks (integer) ``` Inputs 1. `city_map`: A 2D list of strings where each string is either \'P\' or \'B\'. (1 ≤ len(city_map) ≤ 1000, 1 ≤ len(city_map[0]) ≤ 1000) Outputs - An integer representing the number of disconnected parks in the city map. Constraints - Ensure the grid contains only the characters \'P\' and \'B\'. - Optimize the function to handle large grids efficiently. Example ```python >>> city_map = [ [\'P\', \'B\', \'P\', \'P\'], [\'B\', \'P\', \'B\', \'B\'], [\'P\', \'P\', \'B\', \'P\'], [\'B\', \'B\', \'B\', \'B\'] ] >>> count_disconnected_parks(city_map) 4 >>> city_map = [ [\'P\', \'P\', \'B\'], [\'P\', \'B\', \'B\'], [\'B\', \'B\', \'P\'] ] >>> count_disconnected_parks(city_map) 2 >>> city_map = [ [\'B\', \'B\', \'B\'], [\'B\', \'P\', \'B\'], [\'B\', \'B\', \'B\'] ] >>> count_disconnected_parks(city_map) 1 ``` Notes * Consider edge cases where the input constraints are minimal or maximal. * Ensure to handle invalid inputs by raising appropriate errors or returning specific values. * Justify the usage of the Depth First Search (DFS) technique over other methods. * Ensure the function runs efficiently for large input sizes.","solution":"def count_disconnected_parks(city_map): def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() if 0 <= row < len(city_map) and 0 <= col < len(city_map[0]) and city_map[row][col] == \'P\': city_map[row][col] = \'B\' # mark the park as visited by setting it as \'B\' stack.extend([(row+1, col), (row-1, col), (row, col+1), (row, col-1)]) count = 0 for r in range(len(city_map)): for c in range(len(city_map[0])): if city_map[r][c] == \'P\': dfs(r, c) count += 1 return count"},{"question":"# Find the Middle Node of a Singly Linked List Objective You are required to implement a function that finds the middle node of a singly linked list. If the list has an even number of nodes, return the second of the two middle nodes. Problem Description Implement the function `find_middle_node` that takes a `SinglyLinkedList` instance and returns the middle `Node` of the linked list. Function Signature ```python def find_middle_node(sll: SinglyLinkedList) -> Node: pass ``` # Input - `sll`: A singly linked list as an instance of `SinglyLinkedList` class. # Output - Returns a `Node` instance representing the middle node of the linked list. # Constraints - The input linked list will contain at least one node and at most (10^4) nodes. - Nodes of the linked list contain integers between -10000 and 10000 inclusive. # Example ```python # Example test cases test_data_odd = (3, 1, 4, 1, 5, 9, 2) test_data_even = (2, 4, 6, 8, 10, 12) # Assume Node and SinglyLinkedList classes are defined as below class Node: def __init__(self, value: int): self.value = value self.next = None class SinglyLinkedList: def __init__(self, values: list): self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next middle_odd = find_middle_node(SinglyLinkedList(test_data_odd)) middle_even = find_middle_node(SinglyLinkedList(test_data_even)) print(middle_odd.value) # 1 print(middle_even.value) # 8 ``` # Notes 1. Use the `Node` and `SinglyLinkedList` class definitions as provided in the snippet above without modification. 2. The middle node should be determined such that for an odd-length list, it is the exact middle, while for an even-length list, it is the second of the two middle nodes. 3. Do not use additional data structures such as arrays or lists to store node references; the solution should only traverse the list.","solution":"class Node: def __init__(self, value: int): self.value = value self.next = None class SinglyLinkedList: def __init__(self, values: list): self.head = Node(values[0]) current = self.head for value in values[1:]: current.next = Node(value) current = current.next def find_middle_node(sll: SinglyLinkedList) -> Node: slow = sll.head fast = sll.head while fast and fast.next: slow = slow.next fast = fast.next.next return slow"},{"question":"# Data Processing and Transformation Coding Challenge **Context**: You are provided with a list of book review data containing reviewer names, book titles, and review scores. Your task is to process this data to identify the top N reviewers based on their average review score. The average review score is calculated as the total score of all reviews by a reviewer divided by the number of reviews they have given. # Function Implementation Implement a function named `top_n_reviewers` that accepts two parameters: 1. `reviews` (list of tuples): A list of tuples where each tuple contains: * `reviewer_name` (str): The name of the reviewer. * `book_title` (str): The title of the book reviewed. * `score` (int): The review score given for the book (range 0 to 10). 2. `n` (int): The number of top reviewers to return based on their average score. The function should: 1. Validate the inputs to ensure: * `reviews` is a non-empty list. * Each tuple in the list has the required format and types. * `n` is a positive integer. 2. Calculate the average review score for each reviewer. 3. Return a list of dictionaries for the top N reviewers sorted by their average review score in descending order. Each dictionary should contain: * `reviewer_name`: The name of the reviewer. * `average_score`: The average score of the reviewer rounded to two decimal places. **Specifications**: - If the `reviews` list is empty or any validation fails, return an empty list. - If there are fewer than `n` unique reviewers, return information for all reviewers. - Use Python built-in functions and libraries for data processing and validations. **Constraints**: - The `score` is always an integer between 0 and 10. - Each reviewer can have multiple reviews for different books. # Example ```python def top_n_reviewers(reviews: list, n: int) -> list: # Your implementation here ``` **Test Cases**: 1. `top_n_reviewers([], 3)` should return `[]` 2. `top_n_reviewers([(\\"Alice\\", \\"Book A\\", 8), (\\"Bob\\", \\"Book B\\", 6), (\\"Alice\\", \\"Book B\\", 9)], 1)` should return `[{ \\"reviewer_name\\": \\"Alice\\", \\"average_score\\": 8.50 }]` 3. `top_n_reviewers([(\\"Alice\\", \\"Book A\\", 8), (\\"Bob\\", \\"Book B\\", 6)], 2)` should return `[{ \\"reviewer_name\\": \\"Alice\\", \\"average_score\\": 8.00 }, { \\"reviewer_name\\": \\"Bob\\", \\"average_score\\": 6.00 }]` 4. `top_n_reviewers([(\\"Alice\\", \\"Book A\\", 8), (\\"Alice\\", \\"Book B\\", 9), (\\"Bob\\", \\"Book C\\", 10), (\\"Bob\\", \\"Book D\\", 10), (\\"Charlie\\", \\"Book E\\", 4)], 2)` should return `[{ \\"reviewer_name\\": \\"Bob\\", \\"average_score\\": 10.00 }, { \\"reviewer_name\\": \\"Alice\\", \\"average_score\\": 8.50 }]` **Notes**: - Ensure to validate input correctly as specified. - Handle edge cases such as empty or malformed input gracefully. - Use Python\'s built-in facilities to maintain performance and readability.","solution":"def top_n_reviewers(reviews, n): if not isinstance(reviews, list) or not all(isinstance(review, tuple) and len(review) == 3 and isinstance(review[0], str) and isinstance(review[1], str) and isinstance(review[2], int) for review in reviews) or not isinstance(n, int) or n <= 0: return [] from collections import defaultdict review_scores = defaultdict(list) for reviewer, book, score in reviews: review_scores[reviewer].append(score) average_scores = [{ \'reviewer_name\': reviewer, \'average_score\': round(sum(scores) / len(scores), 2) } for reviewer, scores in review_scores.items()] sorted_reviewers = sorted(average_scores, key=lambda x: x[\'average_score\'], reverse=True) return sorted_reviewers[:n]"},{"question":"# Frequency of Characters You are required to implement functions that will count the frequency of each character in a given string, ignoring spaces and case sensitivity. Your tasks are as follows: 1. **`calculate_frequency(string: str) -> dict`**: - Takes a string as input and returns a dictionary. - The dictionary keys are the characters from the string (ignoring spaces and case sensitivity), and the values are the counts of those characters. 2. **`most_frequent_characters(frequency_dict: dict) -> list`**: - Takes a dictionary of character frequencies and returns a list of characters. - The list should contain the characters with the highest frequency, sorted alphabetically. # Function Signatures ```python def calculate_frequency(string: str) -> dict: Calculates the frequency of each character in the given string. :param string: str, the input string. :return: dict, a dictionary where keys are characters and values are their frequencies. pass def most_frequent_characters(frequency_dict: dict) -> list: Returns a list of the most frequent characters from the frequency dictionary. :param frequency_dict: dict, a dictionary with character frequencies. :return: list, a list of characters with the highest frequency, sorted alphabetically. pass ``` # Constraints - Ignore spaces and case sensitivity when counting character frequencies. - The string will only contain alphabetical characters and spaces. - The input string can be empty. # Performance Requirements Your solution should be efficient in terms of both time and space complexity. Consider edge cases and optimize for large strings. # Example ```python if __name__ == \\"__main__\\": sample_text = \\"Example string for character frequency calculation\\" freq_dict = calculate_frequency(sample_text) print(freq_dict) # Example output: {\'e\': 4, \'x\': 1, \'a\': 4, \'m\': 2, \'p\': 1, \'l\': 2, \'s\': 1, \'t\': 3, \'r\': 3, \'i\': 2, # \'n\': 3, \'g\': 2, \'f\': 1, \'o\': 1, \'c\': 2, \'u\': 1} most_frequent = most_frequent_characters(freq_dict) print(most_frequent) # Example output: [\'a\', \'e\'] ``` Write your code to implement the `calculate_frequency` and `most_frequent_characters` functions.","solution":"def calculate_frequency(string: str) -> dict: Calculates the frequency of each character in the given string. :param string: str, the input string. :return: dict, a dictionary where keys are characters and values are their frequencies. frequency = {} for char in string.lower(): if char.isalpha(): if char in frequency: frequency[char] += 1 else: frequency[char] = 1 return frequency def most_frequent_characters(frequency_dict: dict) -> list: Returns a list of the most frequent characters from the frequency dictionary. :param frequency_dict: dict, a dictionary with character frequencies. :return: list, a list of characters with the highest frequency, sorted alphabetically. if not frequency_dict: return [] # Find the maximum frequency max_freq = max(frequency_dict.values()) # Gather all characters with the maximum frequency most_frequent_chars = [char for char, freq in frequency_dict.items() if freq == max_freq] # Return the sorted list of most frequent characters return sorted(most_frequent_chars)"},{"question":"# Coding Question on Efficient String Manipulation Context String manipulation is a common task in programming that often involves operations like searching, replacing, splitting, or recombining strings. One such interesting problem involves reordering a given sentence while preserving the relative order of words but reversing only the words themselves. Problem Develop a function `reverse_words_preserve_order(sentence)` that takes a string `sentence` containing multiple words separated by spaces and returns a new string where every word is reversed in place, but the order of the words remains unchanged. Requirements To achieve this: 1. Split the input string by spaces to identify individual words. 2. Reverse each word. 3. Reconstruct the string with the reversed words in the original order. Input and Output * **Input**: - A string `sentence` consisting of words separated by spaces (e.g., \\"The quick brown fox\\"). * **Output**: - A string where each word is reversed, but the words remain in the original order (e.g., \\"ehT kciuq nworb xof\\"). Implementation Constraints * Ensure the solution is efficient for potentially large sentences. * Handle edge cases such as multiple spaces between words and leading/trailing spaces gracefully. Example ```python def reverse_words_preserve_order(sentence): # Your code here # Example: print(reverse_words_preserve_order(\\"The quick brown fox\\")) # Expected output: \\"ehT kciuq nworb xof\\" print(reverse_words_preserve_order(\\" Hello World \\")) # Expected output: \\" olleH dlroW \\" ``` You are required to provide a function definition for `reverse_words_preserve_order(sentence)` and ensure it accurately produces the expected output for the given examples. Maintain readability and efficiency in your string operations.","solution":"def reverse_words_preserve_order(sentence): Reverses each word in the sentence while preserving the order of words. Args: sentence (str): The input sentence consisting of words separated by spaces. Returns: str: The sentence with each word reversed but in the original order. words = sentence.split(\' \') reversed_words = [word[::-1] for word in words] return \' \'.join(reversed_words)"},{"question":"# Image Pixel Manipulation Your task is to manipulate an image represented as a 2D grid of pixels by applying a given transformation function to each pixel. # Objective Implement the `transform_image` function, which will apply a transformation function to each pixel of the provided image grid. # Implementation Details 1. The `transform_image` function should take an image grid (a 2D list of integers) and a transformation function as input. 2. The transformation function will be applied to each pixel in the grid, and the image grid should be updated in place. 3. Ensure the solution works efficiently on grids up to 1000x1000 in reasonable time. # Function Signature ```python def transform_image(image: list[list[int]], transform_function: Callable[[int], int]) -> None: ... ``` # Input - **image**: a 2D list of integers representing pixel values of an image (0-255). - **transform_function**: a function that takes an integer (pixel value) as input and returns an integer (transformed pixel value). # Expected Output An updated image grid where the transformation function has been applied to each pixel. # Constraints - Grid dimensions (h, w) will not exceed 1000. - Pixel values are integers between 0 and 255. - The transformation function is a valid, deterministic function that maps an integer to an integer. # Example Given a 3x3 image grid and a transformation function: ```python image = [ [255, 128, 64], [0, 64, 128], [64, 32, 16] ] def invert(pixel): return 255 - pixel transform_image(image, invert) ``` The transformed image grid should be: ```python [ [0, 127, 191], [255, 191, 127], [191, 223, 239] ] ``` Ensure the transformation correctly applies to all pixels and the function is optimized for large grids.","solution":"from typing import Callable def transform_image(image: list[list[int]], transform_function: Callable[[int], int]) -> None: Apply transformation function to each pixel in the image grid in place. :param image: 2D list of integers representing pixel values of an image (0-255) :param transform_function: Function that takes an integer (pixel value) and returns a transformed integer for i in range(len(image)): for j in range(len(image[i])): image[i][j] = transform_function(image[i][j])"},{"question":"# Question You need to implement a function that finds the maximum product of two distinct numbers from a given list of non-negative integers. # Problem Statement: Write a Python function `max_product_of_two(nums: List[int]) -> int` that returns the maximum product of any two distinct numbers in the given list. # Input and Output: **Input**: - A list `nums` of length `n` (2 ≤ `n` ≤ 100000), where each element is a non-negative integer (0 ≤ `nums[i]` ≤ 10^4). **Output**: - An integer representing the maximum product of any two distinct numbers from the list. # Constraints: - The function should handle the input list efficiently and aim for a time complexity better than O(n^2). # Example: ```python Example 1: Input: [1, 2, 3, 4, 5] Output: 20 Explanation: The maximum product is achieved by multiplying 4 and 5. Example 2: Input: [10, 10, 5, 2] Output: 100 Explanation: The maximum product is achieved by multiplying any of the 10s together. Example 3: Input: [0, 0, 1, 2] Output: 2 Explanation: The maximum product is achieved by multiplying 1 and 2. ``` # Note: - Ensure your solution works within an acceptable time complexity, ideally O(n) by making a single pass through the list or using relevant Python built-ins for more efficient processing. ```python def max_product_of_two(nums: List[int]) -> int: # Your code here # Example usage and testing print(max_product_of_two([1, 2, 3, 4, 5])) # Output: 20 print(max_product_of_two([10, 10, 5, 2])) # Output: 100 print(max_product_of_two([0, 0, 1, 2])) # Output: 2 ``` Implement the `max_product_of_two` function according to the problem description. Ensure it passes all edge cases and performs within the specified constraints.","solution":"from typing import List def max_product_of_two(nums: List[int]) -> int: # Initialize the two largest numbers first_max = second_max = 0 for num in nums: if num > first_max: second_max = first_max first_max = num elif num > second_max: second_max = num return first_max * second_max"},{"question":"# Question: Implementing a Custom Sorting Algorithm Context: You have been asked to implement a custom sorting algorithm for a specific requirement in a library system. Books need to be sorted not by their titles, but by their authors\' last names. The sorting algorithm should use a modified merge sort to sort the books while considering only the last names of the authors. Task: Implement the `Book` class and the `library_sort` function that performs sorting. Here are the required functionalities: 1. **The `Book` class**: - Constructor that initializes `title` and `author` attributes. - A `__repr__` method that returns a string representation of the book in the format `\\"Title by Author\\"`. 2. **The `library_sort` function**: - Accepts a list of `Book` objects and sorts them by the author\'s last name using a modified merge sort. - Considers only the last name of the author for sorting. Requirements: * **Input Format**: - The `Book` class constructor takes two string arguments: `title` and `author`. - The `library_sort` function takes a list of `Book` objects. * **Output Format**: - `library_sort` returns a list of `Book` objects sorted by the authors\' last names. * **Constraints**: - Both the `title` and `author` fields are non-empty strings. - The author names consist only of English letters and may include a single space separating first and last names. - The length of the list of books does not exceed 1000. Example: ```python books = [ Book(\\"The Fellowship of the Ring\\", \\"J.R.R. Tolkien\\"), Book(\\"1984\\", \\"George Orwell\\"), Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\"), Book(\\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\"), Book(\\"Moby-Dick\\", \\"Herman Melville\\") ] sorted_books = library_sort(books) for book in sorted_books: print(book) # Output: # 1984 by George Orwell # The Great Gatsby by F. Scott Fitzgerald # To Kill a Mockingbird by Harper Lee # Moby-Dick by Herman Melville # The Fellowship of the Ring by J.R.R. Tolkien ``` **Note**: You must implement the `Book` class and `library_sort` function with the provided method signatures. ```python class Book: def __init__(self, title: str, author: str) -> None: self.title = title self.author = author def __repr__(self) -> str: # Implementation here def library_sort(books: list[Book]) -> list[Book]: # Implementation here ``` Testing: Ensure your implementation passes the following doctests: ```python >>> books = [ ... Book(\\"Jane Eyre\\", \\"Charlotte Bronte\\"), ... Book(\\"Pride and Prejudice\\", \\"Jane Austen\\"), ... Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\"), ... Book(\\"Don Quixote\\", \\"Miguel de Cervantes\\") ... ] >>> sorted_books = library_sort(books) >>> [b.author for b in sorted_books] [\'Jane Austen\', \'Charlotte Bronte\', \'Miguel de Cervantes\', \'J.D. Salinger\'] >>> [b.title for b in sorted_books] [\'Pride and Prejudice\', \'Jane Eyre\', \'Don Quixote\', \'The Catcher in the Rye\'] ```","solution":"class Book: def __init__(self, title: str, author: str) -> None: self.title = title self.author = author def __repr__(self) -> str: return f\'\\"{self.title}\\" by {self.author}\' def library_sort(books: list[Book]) -> list[Book]: def merge_sort(books): if len(books) > 1: mid = len(books) // 2 left_half = books[:mid] right_half = books[mid:] merge_sort(left_half) merge_sort(right_half) i = j = k = 0 while i < len(left_half) and j < len(right_half): if left_half[i].author.split()[-1] < right_half[j].author.split()[-1]: books[k] = left_half[i] i += 1 else: books[k] = right_half[j] j += 1 k += 1 while i < len(left_half): books[k] = left_half[i] i += 1 k += 1 while j < len(right_half): books[k] = right_half[j] j += 1 k += 1 merge_sort(books) return books"},{"question":"# Coding Assessment Question Scenario Data compression algorithms aim to reduce the size of data representations, making storage and transmission more efficient. One classic compression algorithm is Run-Length Encoding (RLE), which replaces sequences of repeated characters with a single character followed by the count of repetitions. Task Implement a Run-Length Encoding (RLE) algorithm in Python. Your implementation should be able to encode a given string and decode an RLE-encoded string back to its original form. Ensure that the algorithm can handle edge cases such as empty strings and strings with no repeated characters. Requirements 1. Implement two functions: - `encode_rle(input_str: str) -> str`: - This function should compress the input string using RLE. - `decode_rle(encoded_str: str) -> str`: - This function should decompress the RLE-encoded string back to the original string. 2. Ensure your implementation handles the following: - Properly handles inputs with various repetitions. - Correctly decodes strings encoded in RLE format. 3. Demonstrate your implementation with the following cases: - Encode and decode the string `\\"aaabbcccc\\"` to verify consistency. - Encode and decode the string `\\"abc\\"` to verify behavior with no repeated characters. - Handle the empty string case. Function Signature ```python def encode_rle(input_str: str) -> str: # Implement the RLE encoding logic def decode_rle(encoded_str: str) -> str: # Implement the RLE decoding logic # Example usage encoded = encode_rle(\\"aaabbcccc\\") print(encoded) # Expected output: \\"a3b2c4\\" decoded = decode_rle(encoded) print(decoded) # Expected output: \\"aaabbcccc\\" # Testing with no repetitions encoded = encode_rle(\\"abc\\") print(encoded) # Expected output: \\"a1b1c1\\" decoded = decode_rle(encoded) print(decoded) # Expected output: \\"abc\\" # Testing with empty string encoded = encode_rle(\\"\\") print(encoded) # Expected output: \\"\\" decoded = decode_rle(encoded) print(decoded) # Expected output: \\"\\" ``` Input Format - `encode_rle`: A string containing the original data to be compressed. - `decode_rle`: A string containing the RLE-encoded data. Output Format - `encode_rle`: A string representing the RLE-encoded data. - `decode_rle`: A string representing the decompressed original data. Constraints - You may assume all characters in the input strings are ASCII characters. - The input string length does not exceed `10000` characters. Performance Requirements - The implementation should efficiently handle inputs up to the maximum length constraint.","solution":"def encode_rle(input_str: str) -> str: if not input_str: return \\"\\" result = [] count = 1 prev_char = input_str[0] for char in input_str[1:]: if char == prev_char: count += 1 else: result.append(prev_char + str(count)) prev_char = char count = 1 result.append(prev_char + str(count)) return \'\'.join(result) def decode_rle(encoded_str: str) -> str: if not encoded_str: return \\"\\" decoded_str = [] i = 0 length = len(encoded_str) while i < length: char = encoded_str[i] count_str = [] i += 1 while i < length and encoded_str[i].isdigit(): count_str.append(encoded_str[i]) i += 1 count = int(\'\'.join(count_str)) decoded_str.append(char * count) return \'\'.join(decoded_str) # Example usage encoded = encode_rle(\\"aaabbcccc\\") print(encoded) # Expected output: \\"a3b2c4\\" decoded = decode_rle(encoded) print(decoded) # Expected output: \\"aaabbcccc\\" # Testing with no repetitions encoded = encode_rle(\\"abc\\") print(encoded) # Expected output: \\"a1b1c1\\" decoded = decode_rle(encoded) print(decoded) # Expected output: \\"abc\\" # Testing with empty string encoded = encode_rle(\\"\\") print(encoded) # Expected output: \\"\\" decoded = decode_rle(encoded) print(decoded) # Expected output: \\"\\""},{"question":"# Coding Assessment Question Objective Implement a Python function to evaluate the performance of a student\'s answers on a multiple-choice assessment by comparing it with the provided answer key. Problem Statement Given two lists, one representing the student\'s answers and the other representing the correct answers (answer key), your objective is to calculate the total score based on the following scoring policy: - Each correct answer awards the student +4 points. - Each incorrect answer deducts 1 point. - No points are awarded or deducted for unanswered questions (denoted by an empty string `\\"\\"`). Function Specifications 1. **Function Name**: `calculate_score` 2. **Input Parameters**: - `student_answers`: list of strings; Each element represents the student\'s answer to a question. It can be either a letter (e.g., \\"A\\", \\"B\\", \\"C\\") or an empty string for unanswered questions. - `answer_key`: list of strings; Each element represents the correct answer to a question. 3. **Output**: - An integer representing the total score based on the scoring policy. - If the provided input lists are invalid (e.g., different lengths or contain invalid entries), raise a `ValueError` with a descriptive message. 4. **Constraints**: - Both lists should be of the same length. - Each entry in the lists should be either one of the letters \\"A\\", \\"B\\", \\"C\\", \\"D\\" or an empty string `\\"\\"`. ```python def calculate_score(student_answers: list[str], answer_key: list[str]) -> int | ValueError: Input Parameters: ----------------- student_answers: A list of strings where each string represents the student\'s answer to a question or an empty string for unanswered questions. answer_key: A list of strings where each string represents correct answer to a question. Returns: -------- The function returns an integer representing the student\'s total score based on the defined scoring policy. If the inputs are invalid, raises a ValueError with an appropriate error message. Examples: --------- >>> calculate_score([\\"A\\", \\"C\\", \\"\\", \\"B\\"], [\\"A\\", \\"C\\", \\"B\\", \\"B\\"]) 7 >>> calculate_score([\\"A\\", \\"C\\", \\"D\\", \\"B\\"], [\\"A\\", \\"C\\", \\"B\\", \\"B\\"]) 6 >>> calculate_score([\\"A\\", \\"C\\"], [\\"A\\", \\"C\\", \\"B\\"]) ValueError(\'Input Error: Both lists must be of the same length.\') pass # Your code here ``` Notes: 1. Validate the inputs to ensure both lists are of the same length and contain only valid entries. 2. Ensure to include informative error messages for input validation issues. 3. Your code will be assessed for efficiency, readability, and correctness of handling various input scenarios.","solution":"def calculate_score(student_answers, answer_key): Evaluates the performance of a student\'s answers on a multiple-choice assessment. Parameters: student_answers (list of str): List of student\'s answers. answer_key (list of str): List of correct answers. Returns: int: Total score based on the scoring policy. Raises: ValueError: if input lists have different lengths or contain invalid entries. if len(student_answers) != len(answer_key): raise ValueError(\'Input Error: Both lists must be of the same length.\') valid_answers = {\\"A\\", \\"B\\", \\"C\\", \\"D\\", \\"\\"} for ans in student_answers + answer_key: if ans not in valid_answers: raise ValueError(\'Input Error: Lists contain invalid entries. Must be \\"A\\", \\"B\\", \\"C\\", \\"D\\" or \\"\\".\') total_score = 0 for student_answer, correct_answer in zip(student_answers, answer_key): if student_answer == \\"\\": continue elif student_answer == correct_answer: total_score += 4 else: total_score -= 1 return total_score"},{"question":"# Problem Statement You are given a list of `n` integers. Your task is to determine the number of unique pairs `(i, j)` such that `i < j` and the sum of the integers at indices `i` and `j` is equal to a given target sum `k`. # Function Signature ```python def count_unique_pairs(nums: list[int], k: int) -> int: pass ``` # Input - `nums`: A list of `n` integers. - `k`: An integer representing the target sum. # Output - Returns an integer representing the number of unique pairs `(i, j)` where `i < j` and `nums[i] + nums[j] == k`. # Constraints - (1 leq n leq 10^4) - (-10^4 leq nums[i] leq 10^4) - (-10^4 leq k leq 10^4) # Example ```python nums = [1, 5, 7, -1, 5] k = 6 print(count_unique_pairs(nums, k)) # Output: 3 ``` # Explanation The unique pairs are (0, 3), (1, 4), and (2, 3), summing to the target value 6. Therefore, the function returns 3. # Notes - The pairs `(i, j)` should be counted only once, i.e., (1,2) is the same as (2,1) for counting purposes. - Consider edge cases, such as an empty list or when no pairs are found.","solution":"def count_unique_pairs(nums: list[int], k: int) -> int: Determines the number of unique pairs (i, j) such that i < j and nums[i] + nums[j] equals the target sum k. count = 0 seen = {} # Dictionary to store each number and its indices for i, num in enumerate(nums): if k - num in seen: count += len(seen[k - num]) if num in seen: seen[num].append(i) else: seen[num] = [i] return count"},{"question":"# Linked List Operations and Reversal You are required to implement a singly linked list and provide a set of fundamental operations for managing the list, including an in-place reversal of the linked list. Your class should support appending elements, deleting elements, finding elements, and reversing the linked list. # Specifications: * **Class Name**: `LinkedList` * **Node Class**: Define a nested `Node` class to represent each element in the linked list. * **Methods**: - `append(value)`: Adds a new node with the specified value to the end of the list. - `delete(value)`: Deletes the first node that contains the specified value. - `find(value)`: Returns a boolean indicating whether the value is present in the list. - `reverse()`: Reverses the linked list in place. - `to_list()`: Converts the linked list to a regular Python list for verification purposes. # Constraints: * Values in the linked list will be integers. * Methods should raise appropriate Python exceptions for invalid inputs: - `TypeError` if inputs are not integers. - `ValueError` if attempting to delete a value not present in the list. # Example Usage: ```python ll = LinkedList() ll.append(1) ll.append(2) ll.append(3) # Find value print(ll.find(2)) # Output: True print(ll.find(4)) # Output: False # Delete value ll.delete(2) print(ll.to_list()) # Output: [1, 3] # Reverse the list ll.reverse() print(ll.to_list()) # Output: [3, 1] ``` # Performance Requirements: * Operations should handle linked lists with up to 10^4 nodes efficiently. * Ensure the reverse operation performs in linear time with constant space complexity. # Implementation: Implement the `LinkedList` class with this functionality. Pay careful attention to edge cases such as attempting to delete a value from an empty list or from a list without the value. Ensure proper management of head and tail pointers during list operations and reversal. # New Question: Compose one additional question that seamlessly integrates with the existing set, adhering to all the above guidelines.","solution":"class LinkedList: class Node: def __init__(self, value): if not isinstance(value, int): raise TypeError(\\"Value must be an integer\\") self.value = value self.next = None def __init__(self): self.head = None def append(self, value): new_node = self.Node(value) if self.head is None: self.head = new_node return last = self.head while last.next: last = last.next last.next = new_node def delete(self, value): if not isinstance(value, int): raise TypeError(\\"Value must be an integer\\") if self.head is None: raise ValueError(\\"List is empty\\") if self.head.value == value: self.head = self.head.next return current = self.head while current.next and current.next.value != value: current = current.next if current.next is None: raise ValueError(\\"Value not found in the list\\") current.next = current.next.next def find(self, value): if not isinstance(value, int): raise TypeError(\\"Value must be an integer\\") current = self.head while current: if current.value == value: return True current = current.next return False def reverse(self): prev = None current = self.head while current: next = current.next current.next = prev prev = current current = next self.head = prev def to_list(self): result = [] current = self.head while current: result.append(current.value) current = current.next return result"},{"question":"# Question: Problem Statement: You are required to implement a basic digital circuit using NAND gates to simulate an AND gate. The AND gate outputs True (1) only when both inputs are True (1), and False (0) otherwise. Your task is to write a function that computes the AND operation using only NAND gates. Function Signature: ```python def and_using_nand(input_1: int, input_2: int) -> int: Compute the AND operation using only NAND gates :param input_1: First boolean input (0 or 1) :param input_2: Second boolean input (0 or 1) :return: Result of AND operation (0 or 1) ``` Input: - `input_1`: An integer, either 0 or 1. - `input_2`: An integer, either 0 or 1. Output: - An integer (0 or 1), representing the AND of the input values. Example: ```python >>> and_using_nand(0, 0) 0 >>> and_using_nand(0, 1) 0 >>> and_using_nand(1, 0) 0 >>> and_using_nand(1, 1) 1 ``` Constraints: - Input values will always be either 0 or 1. - The function must use only NAND gates as defined in the provided `nand_gate` function. Performance Requirements: The function should operate in constant time O(1) due to fixed operations versus input size. Hint: You may use the provided `nand_gate` function to build the AND logic. Recall that the AND operation can be represented in terms of NAND gates using the following logic: - The AND operation `A AND B` is equivalent to applying the NAND operation twice. # Note: Ensure you handle all boolean combinations as per the truth table of AND. ```python def nand_gate(input_1: int, input_2: int) -> int: return int(not (input_1 and input_2)) ``` Good luck!","solution":"def nand_gate(input_1: int, input_2: int) -> int: This function implements a NAND gate. A NAND gate returns True (1) if at least one of the inputs is False (0). return int(not (input_1 and input_2)) def and_using_nand(input_1: int, input_2: int) -> int: This function simulates an AND gate using only NAND gates. # First, apply the NAND gate to the inputs nand_result = nand_gate(input_1, input_2) # Then, apply the NAND gate to the result of the first NAND gate with itself and_result = nand_gate(nand_result, nand_result) return and_result"},{"question":"# Problem Statement You are tasked with implementing a library system that can manage a collection of books. Each book in the collection is represented as a dictionary with the attributes `title`, `author`, `year`, and `genre`. The library should support basic query operations to find books that match certain criteria. # Function Signature ```python def library_query(books: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Finds books in a collection that match the given criteria. :param books: List of dictionaries, where each dictionary represents a book\'s attributes. :param criteria: A dictionary containing the search criteria. :return: A list of dictionaries representing books that match the criteria. ``` # Input - `books`: A list of dictionaries, where each dictionary contains the attributes `title` (str), `author` (str), `year` (int), and `genre` (str). - `criteria`: A dictionary where keys are attribute names and values are the required values for those attributes. The criteria dictionary may contain one or more of the following keys: `title`, `author`, `year`, `genre`. # Output - Returns a list of dictionaries representing the books that match all given criteria. # Constraints - The list `books` can contain up to 10^5 dictionaries. - The value types in the `criteria` dictionary will always match the corresponding attribute types in the books\' dictionaries. - Matching should be exact for all attributes. # Example ```python from typing import List, Dict, Any def library_query(books: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: # To be implemented pass # Example usage books = [ {\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Novel\\"}, {\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}, {\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Novel\\"}, {\\"title\\": \\"The Catcher in the Rye\\", \\"author\\": \\"J.D. Salinger\\", \\"year\\": 1951, \\"genre\\": \\"Novel\\"}, ] # Find books by author \\"George Orwell\\" print(library_query(books, {\\"author\\": \\"George Orwell\\"})) # Output: [{\\"title\\": \\"1984\\", \\"author\\": \\"George Orwell\\", \\"year\\": 1949, \\"genre\\": \\"Dystopian\\"}] # Find books published in 1925 print(library_query(books, {\\"year\\": 1925})) # Output: [{\\"title\\": \\"The Great Gatsby\\", \\"author\\": \\"F. Scott Fitzgerald\\", \\"year\\": 1925, \\"genre\\": \\"Novel\\"}] # Find books by genre \\"Novel\\" and author \\"Harper Lee\\" print(library_query(books, {\\"genre\\": \\"Novel\\", \\"author\\": \\"Harper Lee\\"})) # Output: [{\\"title\\": \\"To Kill a Mockingbird\\", \\"author\\": \\"Harper Lee\\", \\"year\\": 1960, \\"genre\\": \\"Novel\\"}] ``` # Implementation Tips - Iterate through the list of books and filter them based on the provided criteria. - Ensure that the comparison is case-sensitive and matches the specified values exactly. - Consider edge cases where criteria may have overlapping attributes with many books.","solution":"from typing import List, Dict, Any def library_query(books: List[Dict[str, Any]], criteria: Dict[str, Any]) -> List[Dict[str, Any]]: Finds books in a collection that match the given criteria. :param books: List of dictionaries, where each dictionary represents a book\'s attributes. :param criteria: A dictionary containing the search criteria. :return: A list of dictionaries representing books that match the criteria. def matches(book: Dict[str, Any], criteria: Dict[str, Any]) -> bool: for key, value in criteria.items(): if book.get(key) != value: return False return True return [book for book in books if matches(book, criteria)]"},{"question":"# Binary Search Tree (BST) Enhancements As a programming task, you need to enhance the existing Binary Search Tree class with additional functionalities and policies. 1. **Self-Balancing**: Enhance the BST to self-balance itself upon insertion and deletion using the AVL tree rotation techniques. Implement the necessary methods to perform the rotations and maintain the AVL property (height balance). 2. **Range Queries**: Add support for range queries which return all keys within a given range [low, high]. Implement a function `range_search(low: int, high: int) -> List[int]` to perform this task. 3. **In-order Successor**: Implement a method to find the in-order successor of a given node in the BST. The in-order successor of a node is the next node in in-order traversal of the BST. # Input and Output Format * Implement these distinct functions in the BST class: * `insert(key: int) -> None`: Insert a new key while maintaining the AVL property. * `delete(key: int) -> None`: Delete an existing key and maintain the AVL property. * `range_search(low: int, high: int) -> List[int]`: Return a list of keys within the specified range. * `inorder_successor(key: int) -> int`: Return the key of the in-order successor. # Constraints * Key types will be integers. * Ensure the AVL property (balance factor of each node is in the set {-1, 0, 1}) is maintained after every insertion and deletion. * The BST will initially be empty. # Examples ```python # Example usage: bst = BST() # Insert elements bst.insert(10) bst.insert(20) bst.insert(5) bst.insert(25) bst.insert(15) # Range queries print(bst.range_search(10, 20)) # Should return [10, 15, 20] # In-order successor print(bst.inorder_successor(15)) # Should return 20 # Delete elements bst.delete(10) print(bst.range_search(5, 25)) # Should return [5, 15, 20, 25] # AVL Property Check bst.insert(30) print(bst.is_balanced()) # Should return True, indicating the tree is balanced ``` Implement the enhanced BST class based on the above requirements and guidelines.","solution":"class TreeNode: def __init__(self, key): self.key = key self.left = None self.right = None self.height = 1 class AVLTree: def insert(self, root, key): if not root: return TreeNode(key) if key < root.key: root.left = self.insert(root.left, key) else: root.right = self.insert(root.right, key) root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and key < root.left.key: return self.right_rotate(root) if balance < -1 and key > root.right.key: return self.left_rotate(root) if balance > 1 and key > root.left.key: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and key < root.right.key: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def delete(self, root, key): if not root: return root if key < root.key: root.left = self.delete(root.left, key) elif key > root.key: root.right = self.delete(root.right, key) else: if root.left is None: return root.right elif root.right is None: return root.left temp = self.get_min_value_node(root.right) root.key = temp.key root.right = self.delete(root.right, temp.key) if root is None: return root root.height = 1 + max(self.get_height(root.left), self.get_height(root.right)) balance = self.get_balance(root) if balance > 1 and self.get_balance(root.left) >= 0: return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) <= 0: return self.left_rotate(root) if balance > 1 and self.get_balance(root.left) < 0: root.left = self.left_rotate(root.left) return self.right_rotate(root) if balance < -1 and self.get_balance(root.right) > 0: root.right = self.right_rotate(root.right) return self.left_rotate(root) return root def range_search(self, root, low, high): result = [] self._range_search_helper(root, low, high, result) return result def _range_search_helper(self, root, low, high, result): if root is None: return if low < root.key: self._range_search_helper(root.left, low, high, result) if low <= root.key <= high: result.append(root.key) if high > root.key: self._range_search_helper(root.right, low, high, result) def inorder_successor(self, root, key): successor = None while root is not None: if key < root.key: successor = root root = root.left elif key > root.key: root = root.right else: if root.right: successor = self.get_min_value_node(root.right) break return successor.key if successor else None def get_min_value_node(self, node): while node.left is not None: node = node.left return node def get_height(self, root): return root.height if root else 0 def get_balance(self, root): return self.get_height(root.left) - self.get_height(root.right) if root else 0 def right_rotate(self, z): y = z.left T3 = y.right y.right = z z.left = T3 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def left_rotate(self, z): y = z.right T2 = y.left y.left = z z.right = T2 z.height = 1 + max(self.get_height(z.left), self.get_height(z.right)) y.height = 1 + max(self.get_height(y.left), self.get_height(y.right)) return y def __init__(self): self.root = None def insert_value(self, key): self.root = self.insert(self.root, key) def delete_value(self, key): self.root = self.delete(self.root, key) def range_search_values(self, low, high): return self.range_search(self.root, low, high) def inorder_successor_value(self, key): return self.inorder_successor(self.root, key) def is_balanced(self): def _is_balanced(node): if node is None: return True lh = self.get_height(node.left) rh = self.get_height(node.right) if abs(lh - rh) > 1: return False return _is_balanced(node.left) and _is_balanced(node.right) return _is_balanced(self.root)"},{"question":"# Question: Minimum Depth of Binary Tree # Problem Statement: You are given the root of a binary tree. Implement a function to find the minimum depth of the binary tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. # Function Signature: ```python def min_depth(root: Node) -> int: pass ``` # Input: - The function takes a single argument `root` which is the root node of a binary tree. - `root`: `(Node | None)` - The root node of the binary tree or `None` if the tree is empty. # Output: - The function returns an integer representing the minimum depth of the binary tree. - `int` - The minimum depth of the binary tree. If the tree is empty, it should return `0`. # Constraints: - The number of nodes in the tree is in the range `[0, 10^4]`. - The values of the nodes are in the range `[-10^6, 10^6]`. # Example: ```python # Example 1: # Input: root = Node(3) root.left = Node(9) root.right = Node(20) root.right.left = Node(15) root.right.right = Node(7) # Tree structure: # 3 # / # 9 20 # / # 15 7 min_depth_value = min_depth(root) # Expected Output: 2 # Example 2: # Input: root = None # Tree structure: Empty tree min_depth_value = min_depth(root) # Expected Output: 0 # Example 3: # Input: root = Node(1) root.left = Node(2) # Tree structure: # 1 # / # 2 min_depth_value = min_depth(root) # Expected Output: 2 ``` # Additional Notes: - Assume that the Node class and binary tree structure is already defined and available for use. - A leaf node is a node that does not have any children. - Your solution should handle edge cases like an empty tree, trees with only root, and highly unbalanced trees. # Node Class Definition: ```python @dataclass class Node: value: int left: Node | None = None right: Node | None = None ```","solution":"from typing import Optional from dataclasses import dataclass @dataclass class Node: value: int left: Optional[\'Node\'] = None right: Optional[\'Node\'] = None def min_depth(root: Optional[Node]) -> int: if not root: return 0 # Initialize the queue for BFS queue = [(root, 1)] # The node and its depth while queue: current, depth = queue.pop(0) # Check if we reach a leaf node if not current.left and not current.right: return depth # Add children to the queue with their respective depths if current.left: queue.append((current.left, depth + 1)) if current.right: queue.append((current.right, depth + 1))"},{"question":"# Question: Implement Dynamic Programming for Fibonacci Sequence You need to write a program that computes the `n`-th Fibonacci number using dynamic programming to ensure an O(n) time complexity and O(1) space complexity. The Fibonacci sequence is defined as follows: - F(0) = 0 - F(1) = 1 - F(n) = F(n-1) + F(n-2) (for n > 1) # Function Signature ```python def fibonacci(n: int) -> int: pass ``` # Input Format - An integer n (0 <= n <= 10^5) # Output Format - Return an integer representing the `n`-th Fibonacci number. # Constraints - You must use dynamic programming to achieve the time complexity of O(n) and space complexity of O(1). - Ensure that the solution handles large values of `n` efficiently. # Example ```python print(fibonacci(0)) # Output: 0 print(fibonacci(1)) # Output: 1 print(fibonacci(10)) # Output: 55 print(fibonacci(50)) # Output: 12586269025 ``` **Hint**: Use variables to store the last two Fibonacci numbers and update them iteratively.","solution":"def fibonacci(n: int) -> int: if n == 0: return 0 elif n == 1: return 1 prev2, prev1 = 0, 1 for _ in range(2, n+1): current = prev1 + prev2 prev2, prev1 = prev1, current return prev1"},{"question":"# Coding Assessment Question You are given a list of integers `nums` representing the amount of money of each house arranged in a circle. Write a function `max_robbery_in_circle(nums: List[int]) -> int` to maximize your robbery amount without alerting the police. You cannot rob two adjacent houses, and since the houses are arranged in a circle, the first house is adjacent to the last house. # Input - `nums` (List[int]): A list of integers where each integer represents the amount of money in each house. (1 ≤ len(nums) ≤ 1000, 0 ≤ nums[i] ≤ 1000) # Output - Return an integer representing the maximum amount of money you can rob without alerting the police. # Constraints: - You must come up with an efficient solution that can handle the upper limits of the input size. - You cannot rob two adjacent houses, and since the houses are arranged in a circle, the first house is adjacent to the last house. # Example: ```python def max_robbery_in_circle(nums: List[int]) -> int: pass # Implement the function here print(max_robbery_in_circle([2, 3, 2])) # Output: 3 print(max_robbery_in_circle([1, 2, 3, 1])) # Output: 4 print(max_robbery_in_circle([0, 0, 0, 0])) # Output: 0 print(max_robbery_in_circle([5, 6, 1, 3, 7])) # Output: 13 ``` - Utilize a dynamic programming approach to solve the problem efficiently. - Consider breaking the problem into two subproblems where you can either include the first house or the last house in the solution but not both to maintain the circular constraint.","solution":"from typing import List def rob(nums: List[int]) -> int: prev, curr = 0, 0 for num in nums: prev, curr = curr, max(curr, prev + num) return curr def max_robbery_in_circle(nums: List[int]) -> int: n = len(nums) if n == 1: return nums[0] # Solve the problem twice: (1) excluding the first house, (2) excluding the last house. return max(rob(nums[1:]), rob(nums[:-1]))"},{"question":"# Trie Implementation with Specific Rules Tries, also known as prefix trees, are a type of ordered tree data structure commonly used to store associative arrays where the keys are usually strings. A trie allows for efficient insertion, deletion, and lookup operations. Task Your task is to implement a basic trie with the following operations: 1. **insert**: Adds a word to the trie. 2. **search**: Checks if a word is present in the trie. 3. **startsWith**: Checks if there is any word in the trie that starts with a given prefix. Additionally, you need to implement a function `longest_common_prefix()` which returns the longest common prefix string amongst all words stored in the trie. # Input 1. A list of operations to be performed on the trie. Each operation is a tuple where the first element is the operation name (one of \\"insert\\", \\"search\\", \\"startsWith\\", or \\"longest_common_prefix\\"), and the second element is the required parameter for the operation if applicable. # Output * For \\"insert\\" operations, return `None`. * For \\"search\\" and \\"startsWith\\" operations, return `True` or `False`. * For \\"longest_common_prefix\\" operations, return the longest common prefix string. # Constraints * The list of operations will contain at least one \\"insert\\" operation. * The length of each word given is between 1 and 100 characters. * The list of operations will contain between 1 and 1000 operations. * Words consist of lowercase English letters (\'a\' to \'z\'). # Example ```python operations = [ (\\"insert\\", \\"flower\\"), (\\"insert\\", \\"flow\\"), (\\"insert\\", \\"flight\\"), (\\"search\\", \\"flow\\"), # Output: True (\\"search\\", \\"flame\\"), # Output: False (\\"startsWith\\", \\"fl\\"), # Output: True (\\"startsWith\\", \\"fle\\"), # Output: False (\\"longest_common_prefix\\",) # Output: \\"fl\\" ] trie = Trie() for op in operations: if op[0] == \\"insert\\": trie.insert(op[1]) elif op[0] == \\"search\\": print(trie.search(op[1])) elif op[0] == \\"startsWith\\": print(trie.startsWith(op[1])) elif op[0] == \\"longest_common_prefix\\": print(trie.longest_common_prefix()) ``` # Function Signature ```python class Trie: def __init__(self): # Your implementation here def insert(self, word: str) -> None: # Your implementation here def search(self, word: str) -> bool: # Your implementation here def startsWith(self, prefix: str) -> bool: # Your implementation here def longest_common_prefix(self) -> str: # Your implementation here ``` # Notes * You are required to define the `TrieNode` and `Trie` classes, and to implement the above-mentioned methods. * Ensure the implementation is efficient to handle the operations within the provided constraints. * Consider edge cases and verify results using the example provided.","solution":"class TrieNode: def __init__(self): self.children = {} self.is_end_of_word = False class Trie: def __init__(self): Initialize the Trie self.root = TrieNode() def insert(self, word: str) -> None: Insert a word into the trie node = self.root for char in word: if char not in node.children: node.children[char] = TrieNode() node = node.children[char] node.is_end_of_word = True def search(self, word: str) -> bool: Search for a word in the trie node = self._find_node(word) return node is not None and node.is_end_of_word def startsWith(self, prefix: str) -> bool: Check if there is any word in the trie that starts with the given prefix return self._find_node(prefix) is not None def _find_node(self, word: str) -> TrieNode: Helper function to traverse the trie and find the node of the last character of the word node = self.root for char in word: if char not in node.children: return None node = node.children[char] return node def longest_common_prefix(self) -> str: Find and return the longest common prefix among all words in the trie node = self.root prefix = [] while node and not node.is_end_of_word and len(node.children) == 1: char = next(iter(node.children)) prefix.append(char) node = node.children[char] return \'\'.join(prefix)"},{"question":"# Problem Statement You are given an integer array `nums` and an integer `k`. Your task is to implement a function that returns the number of unique k-sum combinations from the array. A k-sum combination is a unique subset of `k` elements from the array that add up to a given target sum `S`. Each element in the array may only be used once in each subset. The array may contain duplicate numbers, but the combinations themselves must be unique. **Function Signature** ```python def count_k_sum_combinations(nums: list, k: int, S: int) -> int: Given an array of integers `nums`, an integer `k` and an integer `S`, returns the number of unique k-sum combinations from the array that add up to `S`. Args: nums (list): List of integers. k (int): Number of elements in the subset. S (int): Target sum of the subset. Returns: int: The number of unique k-sum combinations that sum up to `S`. Raises: ValueError: If `k` is larger than the size of the array or if inputs are invalid. ``` # Input * **nums**: A list of integers (0 ≤ `len(nums)` ≤ 100) * **k**: A positive integer (1 ≤ `k` ≤ `len(nums)`) * **S**: An integer (-10^4 ≤ `S` ≤ 10^4) # Output * An integer, which is the number of unique k-sum combinations that sum up to `S`. # Constraints - The same number may appear in multiple unique combinations if the array contains duplicates, but the exact combination should be counted once. - Consider edge cases where `k` is relatively small or large compared to `nums`. - Ensure that the solution handles various combinations without redundancy and efficiently navigates through possible subsets. # Example ```python print(count_k_sum_combinations([1, 2, 3, 4, 5], 3, 6)) # Output: 1 print(count_k_sum_combinations([1, 2, 2, 3, 3], 3, 7)) # Output: 2 ``` # Notes - The function should efficiently find all unique combinations potentially utilizing combinatorial techniques or dynamic programming. - It is guaranteed that the input parameters will be within the given bounds and valid.","solution":"from itertools import combinations def count_k_sum_combinations(nums: list, k: int, S: int) -> int: Given an array of integers `nums`, an integer `k` and an integer `S`, returns the number of unique k-sum combinations from the array that add up to `S`. Args: nums (list): List of integers. k (int): Number of elements in the subset. S (int): Target sum of the subset. Returns: int: The number of unique k-sum combinations that sum up to `S`. if k > len(nums): raise ValueError(\\"k can\'t be larger than the size of the array\\") # Generate all possible combinations of size k all_combinations = combinations(nums, k) # Use a set to ensure the combinations are unique unique_combinations = set() # Check each combination if it sums to the target S for combo in all_combinations: if sum(combo) == S: unique_combinations.add(tuple(sorted(combo))) return len(unique_combinations)"},{"question":"# Sorting and Searching Optimization Challenge You are tasked with optimizing the given implementation of a search operation on a sorted list. The current implementation uses linear search which is inefficient for large datasets. Your goal is to use binary search to improve the search time complexity. # Task Implement a binary search algorithm to find the index of a given target element in a sorted list. If the target element is not present, return `-1`. # Input - An integer `N` representing the number of elements in the list. - `N` integers in a single line representing a sorted list of integers. - An integer `target` representing the element to search for. # Output - Print the index of the target element if it is present in the list. Otherwise, print `-1`. # Constraints - `1 <= N <= 10^6` - `-10^9 <= list[i] <= 10^9` - `-10^9 <= target <= 10^9` # Example Input ``` 10 -10 -5 -2 0 3 5 7 9 12 15 5 ``` Output ``` 5 ``` # Notes Use binary search to efficiently handle the given constraints and provide the correct index of the target element, or `-1` if the element is not found.","solution":"def binary_search(sorted_list, target): Performs binary search on a sorted list to find the index of the target. Returns the index if the target is found, otherwise returns -1. left, right = 0, len(sorted_list) - 1 while left <= right: mid = (left + right) // 2 if sorted_list[mid] == target: return mid elif sorted_list[mid] < target: left = mid + 1 else: right = mid - 1 return -1"},{"question":"# Coding Assessment Question Context This task involves manipulating arrays to identify and segment elements based on specific criteria. Such operations are essential in data preprocessing, which is a common step in fields like data analysis and machine learning. Efficient handling of array elements based on conditions is crucial for the performance of subsequent analytical tasks. Task Write a function `segment_array(arr: List[int], threshold: int) -> Tuple[List[int], List[int]]` that segments the array into two lists based on a given threshold. One list should contain elements greater than or equal to the threshold, and the other list should contain elements less than the threshold. Input and Output Formats * **Input**: * `arr (List[int])`: A list of integers. * `threshold (int)`: An integer that serves as the threshold for segmentation. * **Output**: * A tuple of two lists: the first list with elements greater than or equal to the threshold, and the second list with elements less than the threshold. Constraints and Performance Requirements * The input list `arr` can have up to 10^5 elements. * Ensure that the function operates efficiently with respect to both time and space complexity. Special Notes 1. Maintain the original order of elements in both output lists. 2. The threshold will be within the range of the integers in the input list. Example ```python from typing import List, Tuple def segment_array(arr: List[int], threshold: int) -> Tuple[List[int], List[int]]: pass ``` **Example Usage:** ```python >>> segment_array([1, 2, 3, 4, 5], 3) ([3, 4, 5], [1, 2]) >>> segment_array([10, 20, 30, 40, 50], 25) ([30, 40, 50], [10, 20]) >>> segment_array([3, 7, 8, 1, 5], 5) ([7, 8, 5], [3, 1]) >>> segment_array([9, 7, 5, 3, 1], 4) ([9, 7, 5], [3, 1]) ```","solution":"from typing import List, Tuple def segment_array(arr: List[int], threshold: int) -> Tuple[List[int], List[int]]: Segments the array into two lists: one with elements >= threshold and one with elements < threshold. greater_equal = [x for x in arr if x >= threshold] less_than = [x for x in arr if x < threshold] return (greater_equal, less_than)"},{"question":"# Context Graph traversal is a key concept in computer science, utilized in various applications like social network analysis, pathfinding algorithms, and network propagation models. Implementing efficient graph traversal algorithms is crucial for understanding the structure and behavior of complex networks. # Problem Statement You are required to extend the provided `Graph` class with the following capabilities: 1. **Depth-First Search (DFS)**: Implement a method `depth_first_search` to perform a DFS traversal of the graph. 2. **Breadth-First Search (BFS)**: Implement a method `breadth_first_search` to perform a BFS traversal of the graph. # Function Specifications: Depth-First Search (DFS): **Input**: - `start_node`: an integer representing the starting node for the traversal. **Output**: - Returns a list of nodes representing the order in which they were visited during the DFS traversal. Breadth-First Search (BFS): **Input**: - `start_node`: an integer representing the starting node for the traversal. **Output**: - Returns a list of nodes representing the order in which they were visited during the BFS traversal. # Example: ```python graph = Graph() graph.add_edge(0, 1) graph.add_edge(0, 2) graph.add_edge(1, 2) graph.add_edge(2, 0) graph.add_edge(2, 3) graph.add_edge(3, 3) # Should print DFS traversal starting from node 2 print(graph.depth_first_search(2)) # Output: [2, 0, 1, 3] # Should print BFS traversal starting from node 2 print(graph.breadth_first_search(2)) # Output: [2, 0, 3, 1] ``` # Constraints: - You may assume that the graph is represented using an adjacency list internally. - The graph may be directed or undirected. - There should be no duplicate edges or self-loops. - If a node has no edges, it should still be included in the traversal result if it is reached from other nodes. # Additional Notes: - Use any standard DFS and BFS techniques/concepts you are familiar with, but ensure the methods follow the specified constraints and return types. - Implement input validation to ensure `start_node` exists in the graph before performing the traversal. - Consider typical graph traversal edge cases, such as handling disconnected components.","solution":"class Graph: def __init__(self): self.graph = {} def add_edge(self, u, v): if u not in self.graph: self.graph[u] = [] self.graph[u].append(v) def depth_first_search(self, start_node): visited = [] stack = [start_node] while stack: node = stack.pop() if node not in visited: visited.append(node) if node in self.graph: stack.extend([n for n in self.graph[node] if n not in visited]) return visited def breadth_first_search(self, start_node): visited = [] queue = [start_node] while queue: node = queue.pop(0) if node not in visited: visited.append(node) if node in self.graph: queue.extend([n for n in self.graph[node] if n not in visited]) return visited"},{"question":"# Problem Statement You are tasked with developing a function for a grocery store\'s inventory system. The system needs to calculate the total cost of items in a customer\'s shopping cart, apply any applicable discounts, and generate a receipt. The receipt should include a list of items, their prices, any discounts applied, and the final amount payable. # Requirements You are to implement a function `generate_receipt(cart: List[Tuple[str, float]], discounts: Dict[str, float]) -> dict` which handles the inventory and discount application logic. # Input and Output 1. **Input** - `generate_receipt(cart: List[Tuple[str, float]], discounts: Dict[str, float]) -> dict` - `cart`: List of tuples where each tuple contains: - `item`: str (name of the item) - `price`: float (price of the item, must be non-negative) - `discounts`: Dictionary where keys are item names and values are discount percentages (between 0-100 inclusive) 2. **Output** - Return a dictionary containing: - `\'items\'`: list of dictionaries, each containing: - `\'item\'`: str (name of the item) - `\'original_price\'`: float (original price of the item) - `\'discount\'`: float (discount applied on the item) - `\'final_price\'`: float (price after applying the discount) - `\'total_amount\'`: float (total amount payable after discounts) # Constraints - `0 <= price` - `0 <= discount <= 100` # Example ```python generate_receipt([(\\"apple\\", 1.5), (\\"banana\\", 1.0), (\\"milk\\", 2.5)], {\\"apple\\": 10, \\"milk\\": 20}) # Output: # { # \'items\': [ # {\'item\': \'apple\', \'original_price\': 1.5, \'discount\': 0.15, \'final_price\': 1.35}, # {\'item\': \'banana\', \'original_price\': 1.0, \'discount\': 0.0, \'final_price\': 1.0}, # {\'item\': \'milk\', \'original_price\': 2.5, \'discount\': 0.5, \'final_price\': 2.0} # ], # \'total_amount\': 4.35 # } generate_receipt([(\\"bread\\", 3.0), (\\"butter\\", 4.0)], {\\"bread\\": 15, \\"butter\\": 0}) # Output: # { # \'items\': [ # {\'item\': \'bread\', \'original_price\': 3.0, \'discount\': 0.45, \'final_price\': 2.55}, # {\'item\': \'butter\', \'original_price\': 4.0, \'discount\': 0.0, \'final_price\': 4.0} # ], # \'total_amount\': 6.55 # } ``` # Notes - Ensure that discount calculations are accurate to two decimal points. - Handle cases where an item in the cart does not have a discount listed in the dictionary by applying a 0% discount for those items. - Raise appropriate exceptions for invalid inputs, such as negative prices or discounts outside the 0-100 range.","solution":"def generate_receipt(cart, discounts): Generates a receipt for a given cart of items and applicable discounts. Parameters: - cart: List[Tuple[str, float]] - List of tuples where each tuple contains: `item`: str (name of the item) and `price`: float (price of the item, must be non-negative) - discounts: Dict[str, float] - Dictionary where keys are item names and values are discount percentages (between 0-100 inclusive) Returns: - dict: Dictionary containing: - \'items\': list of dictionaries, each containing: \'item\': str (name of the item) \'original_price\': float (original price of the item) \'discount\': float (discount applied on the item) \'final_price\': float (price after applying the discount) - \'total_amount\': float (total amount payable after discounts) receipt_items = [] total_amount = 0.0 for item, price in cart: if price < 0: raise ValueError(\\"Price cannot be negative\\") discount_percentage = discounts.get(item, 0) if not (0 <= discount_percentage <= 100): raise ValueError(\\"Discount percentage must be between 0 and 100 inclusive\\") discount_amount = (price * discount_percentage) / 100 final_price = price - discount_amount receipt_items.append({ \'item\': item, \'original_price\': round(price, 2), \'discount\': round(discount_amount, 2), \'final_price\': round(final_price, 2) }) total_amount += final_price return { \'items\': receipt_items, \'total_amount\': round(total_amount, 2) }"},{"question":"# Matrix Rotation in a 2D Array Objective Implement a function `rotate_matrix` that rotates a given N x N 2D matrix by 90 degrees in the clockwise direction. Background Matrix rotation is a common operation in image processing, computer graphics, and various computational simulations. The task requires manipulating the given 2D matrix to achieve the desired orientation. This operation can be tricky due to the constraints and the in-place requirement. Task 1. Write the function `rotate_matrix(matrix: List[List[int]]) -> None` that rotates the matrix in place. 2. The size of the matrix will always be N x N, where N is a positive integer. 3. You must not use any extra space for another matrix. You can only use a constant amount of extra memory. Implementation Requirements 1. **Function Definition**: - `def rotate_matrix(matrix: List[List[int]]) -> None:` 2. Implement the function to rotate the matrix in place by 90 degrees clockwise. Example ```python from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] matrix[first][i] = matrix[last - offset][first] matrix[last - offset][first] = matrix[last][last - offset] matrix[last][last - offset] = matrix[i][last] matrix[i][last] = top # Example usage: matrix_3x3 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotate_matrix(matrix_3x3) print(matrix_3x3) # Output: # [ # [7, 4, 1], # [8, 5, 2], # [9, 6, 3] # ] ``` Constraints 1. The matrix will always be a square matrix (N x N). 2. Do not use any extra storage that scales with the input size (only use O(1) additional storage). 3. The elements of the matrix are integers. Notes - Ensure that your solution runs in-place and does not depend on any additional matrix for rotation. - Think carefully about the layers and how you can effectively swap the elements in a single loop. This problem requires understanding the fundamental concepts of matrix manipulation and in-place transformation. Ensure your solution adheres to the constraints and performs optimally.","solution":"from typing import List def rotate_matrix(matrix: List[List[int]]) -> None: Rotates the given N x N matrix by 90 degrees clockwise in place. n = len(matrix) for layer in range(n // 2): first = layer last = n - layer - 1 for i in range(first, last): offset = i - first top = matrix[first][i] matrix[first][i] = matrix[last - offset][first] matrix[last - offset][first] = matrix[last][last - offset] matrix[last][last - offset] = matrix[i][last] matrix[i][last] = top"},{"question":"# Coding Challenge: File System Path Validation **Context**: In a simplified file system structure, a path is used to navigate through various directories and files. A valid path must adhere to certain rules and constraints. Your task is to write a function that validates file system paths. # Task Implement a function `is_valid_path` that determines if a given path string is valid according to the following criteria: 1. A valid path must start with a `/` and contain only alphanumeric characters, slashes `/`, underscores `_`, and hyphens `-`. 2. Consecutive slashes `//` are not allowed. 3. The path must not end with a slash `/` except for the root path `/`. 4. Empty segments between slashes or at the beginning or end (excluding the root) are invalid. 5. No segment should be longer than 255 characters. # Inputs and Outputs - **Path Validation**: - Method: `is_valid_path(path: str) -> bool` - Input: A string representing the file system path. - Output: A boolean indicating whether the path is valid. # Constraints 1. The input string length is between 1 and 104. 2. Only specific characters (alphanumeric, slashes, underscores, hyphens) are allowed. # Examples ```python assert is_valid_path(\'/home/user/docs\') == True assert is_valid_path(\'/home//user\') == False assert is_valid_path(\'/home/user/\') == False assert is_valid_path(\'/home/user/documents/assignments\') == True assert is_valid_path(\'/\') == True assert is_valid_path(\'home/user/docs\') == False assert is_valid_path(\'/this/is/a/very/long/directory/that/exceeds/the/maximum/length/for/a/single/segment/\'*5) == False ``` # Scenario You need to validate various paths provided by a user or systems to ensure they follow the specified file system rules. ```python def is_valid_path(path: str) -> bool: if not path.startswith(\'/\'): return False segments = path.split(\'/\') if not all(segment.isalnum() or (\'_\' in segment or \'-\' in segment) for segment in segments): return False if path != \'/\' and path.endswith(\'/\'): return False for segment in segments: if not segment or len(segment) > 255: return False if \'//\' in path: return False return True if __name__ == \\"__main__\\": # Example test cases test_paths = [ \\"/home/user/docs\\", \\"/home//user\\", \\"/home/user/\\", \\"/home/user/documents/assignments\\", \\"/\\", \\"home/user/docs\\", \\"/this/is/a/very/long/directory/that/exceeds/the/maximum/length/for/a/single/segment/\\"*5 ] expected_results = [ True, False, False, True, True, False, False ] for path, expected in zip(test_paths, expected_results): result = is_valid_path(path) print(f\\"Path: {path} | Valid: {result} | Expected: {expected}\\") ``` Ensure to test edge cases such as paths with invalid characters, overly long segments, and paths starting without a leading slash.","solution":"def is_valid_path(path: str) -> bool: Validate whether the provided file system path is valid. Parameters: path (str): The file system path to validate. Returns: bool: True if the path is valid, False otherwise. # Rule 1: Path must start with a `/` if not path.startswith(\'/\'): return False # Rule 2: Path must not contain consecutive slashes (`//`) if \'//\' in path: return False # Segments are the parts of the path split by `/` segments = path.split(\'/\') # Rule 3: Path must not end with a slash `/` (excluding the root path `/`) if len(path) > 1 and path.endswith(\'/\'): return False for segment in segments: # Rule 5: No segment should be longer than 255 characters if len(segment) > 255: return False # Skip the root segment as it is a single `/` if segment == \'\': continue # Remove empty segments due to leading, trailing, or consecutive slashes if not segment.isalnum() and not all(c.isalnum() or c in \'-_\' for c in segment): return False return True"},{"question":"# Scenario You are developing a command-line tool that fetches the current weather information for a specified city using the OpenWeatherMap API. To ensure that your tool remains functional even when network issues arise, you decide to implement caching of the weather data. The cache should store the most recent successful weather data fetch per city for a duration of 1 hour. # Task 1. Implement a function `get_weather_info` that takes the name of the city and an optional parameter for the cache, fetches the weather information using the OpenWeatherMap API, and returns the weather data as a dictionary. If the data for the city is available in the cache and is less than 1 hour old, it should return the cached data instead of making an API request. 2. The cache should be a dictionary where the key is the city name and the value is a tuple of the timestamp and the weather data. # Requirements **Function Signatures**: ```python import time from typing import Optional def get_weather_info(city: str, cache: Optional[dict] = None) -> dict: # Your implementation here def fetch_from_api(city: str) -> dict: # Simulates an API call to fetch weather information ``` # Example ```python # API response simulation def fetch_from_api(city: str) -> dict: return {\\"city\\": city, \\"temperature\\": 20, \\"weather\\": \\"clear\\"} # Example usage cache = {} info = get_weather_info(\\"London\\", cache) # Subsequent call within 1 hour should return cached data info_cached = get_weather_info(\\"London\\", cache) print(info == info_cached) # Expected output: True ``` # Constraints - Assume `API_ENDPOINT = \\"https://api.openweathermap.org/data/2.5/weather\\"` - The function should raise an exception if no city is specified. - The caching mechanism should keep data for one hour and refresh it after expiration. # Testing - Test the function `get_weather_info` to ensure it correctly uses and updates the cache. - Simulate API responses by defining a `fetch_from_api` function. - Verify that the function returns cached data when available and fresh data when the cache is expired or empty. # Additional Information - You can use the `time` module to handle timestamps. - Ensure that the function properly handles edge cases such as invalid city names or network failures when the cache is empty.","solution":"import time from typing import Optional API_ENDPOINT = \\"https://api.openweathermap.org/data/2.5/weather\\" CACHE_EXPIRY_TIME = 3600 # 1 hour in seconds def fetch_from_api(city: str) -> dict: # Simulate an API call to fetch weather information # This is just a mock function for demonstration purposes return {\\"city\\": city, \\"temperature\\": 20, \\"weather\\": \\"clear\\"} def get_weather_info(city: str, cache: Optional[dict] = None) -> dict: if cache is None: cache = {} if not city: raise ValueError(\\"City name must be specified\\") current_time = time.time() if city in cache: cached_time, cached_data = cache[city] if current_time - cached_time < CACHE_EXPIRY_TIME: return cached_data # Fetch fresh data from API weather_data = fetch_from_api(city) cache[city] = (current_time, weather_data) return weather_data"},{"question":"# Problem Statement Context: You are developing a calendar display utility and need to implement two functions: one that generates the correct abbreviation for the days of the week, and another that computes the number of days in a specified month for both regular and leap years. Instructions: 1. **Create a function `day_abbreviation`**: - This function should take an integer representing a day of the week (0-6) and return the corresponding three-letter abbreviation (e.g., 0 for \\"Sun\\", 1 for \\"Mon\\", etc.) - Raise a `ValueError` if the input integer is not within the range 0-6. 2. **Implement a function `days_in_month`**: - This function should accept two parameters: a month (integer 1-12) and a year (four-digit integer). - Return the number of days in the specified month of that year, correctly accounting for leap years. - A leap year occurs every 4 years, but years divisible by 100 are not unless they are also divisible by 400. Specifications: - **Function Signatures**: ```python def day_abbreviation(day: int) -> str: ... def days_in_month(month: int, year: int) -> int: ... ``` - **Input/Output Examples**: ```python >>> day_abbreviation(0) \'Sun\' >>> day_abbreviation(4) \'Thu\' >>> day_abbreviation(7) Traceback (most recent call last): ... ValueError: Invalid input: day must be within 0-6. >>> days_in_month(2, 2020) 29 >>> days_in_month(2, 2021) 28 >>> days_in_month(11, 2023) 30 >>> days_in_month(4, 1900) 30 >>> days_in_month(2, 2000) 29 ``` - **Constraints**: - `day` must be an integer between 0 and 6. - `month` must be an integer between 1 and 12. - `year` must be a four-digit integer. - **Performance Requirements**: - Ensure the functions handle incorrect inputs gracefully by raising appropriate exceptions. - Both functions should have a worst-case time complexity of O(1).","solution":"def day_abbreviation(day: int) -> str: Given an integer (0-6) representing a day of the week, return the corresponding three-letter abbreviation. Raise a ValueError if the day is not within the valid range. days = [\\"Sun\\", \\"Mon\\", \\"Tue\\", \\"Wed\\", \\"Thu\\", \\"Fri\\", \\"Sat\\"] if 0 <= day <= 6: return days[day] else: raise ValueError(\\"Invalid input: day must be within 0-6.\\") def days_in_month(month: int, year: int) -> int: Given a month (1-12) and a year (four-digit integer), return the number of days in that month, considering leap years. if not (1 <= month <= 12): raise ValueError(\\"Invalid month: month must be within 1-12.\\") if year < 1: raise ValueError(\\"Invalid year: year must be a positive integer.\\") # Days in each month in a common year common_year_days = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] # Check for leap year if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0): common_year_days[1] = 29 # February has 29 days in a leap year return common_year_days[month - 1]"},{"question":"# Problem Statement: Given a list of strings `words`, find the length of the longest word that can be constructed using only the letters from the string `letters`. Each letter in `letters` can only be used as many times as it appears in `letters`. Implement a function `longest_word(words: List[str], letters: str) -> int` to solve this problem. # Input: - `words`: A list of strings representing the words. - `letters`: A string representing the letters available for constructing words. # Output: - The length of the longest word that can be constructed using the provided letters. # Constraints: 1. `words` contains at least one word and at most 100 words. 2. Each word in `words` has a length between 1 and 20 characters. 3. The string `letters` has a length between 1 and 100 characters. 4. All inputs contain only lowercase English letters. # Performance Requirements: - The solution should handle the given constraints efficiently. # Example: Consider the following inputs: ```python words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] letters = \\"aappleb\\" ``` From this input, the longest word we can construct is \\"apple\\", which has a length of 5. # Function Signature: ```python def longest_word(words: List[str], letters: str) -> int: pass ``` Write the code that correctly finds the length of the longest word that can be constructed. # Notes: - Consider edge cases where none of the words can be constructed with the available letters. - Think about how to efficiently check if each word can be made from the given letters. # Example Test Case: ```python def test_longest_word(): words = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"] letters = \\"aappleb\\" assert longest_word(words, letters) == 5 words = [\\"cat\\", \\"dog\\", \\"rabbit\\"] letters = \\"catdogribbt\\" assert longest_word(words, letters) == 6 words = [\\"flower\\", \\"flow\\", \\"flight\\"] letters = \\"floweflight\\" assert longest_word(words, letters) == 6 # Additional tests needed for complete verification ```","solution":"from typing import List from collections import Counter def can_construct(word: str, letters: str) -> bool: word_count = Counter(word) letter_count = Counter(letters) for char in word_count: if word_count[char] > letter_count[char]: return False return True def longest_word(words: List[str], letters: str) -> int: max_length = 0 for word in words: if can_construct(word, letters): max_length = max(max_length, len(word)) return max_length"},{"question":"# Context: You are developing a library for handling and manipulating text data in applications such as chatbots and natural language processing (NLP) systems. A common task is to perform text normalization, which includes converting text to lowercase, removing punctuation, and eliminating extra whitespace. You have been tasked with implementing a function to perform these operations efficiently. # Problem Statement: Implement the function `normalize_text` using the given skeleton code. The function should take as input a string and return a normalized version of the string. # Function Signature: ```python def normalize_text(text: str) -> str: ``` # Input: * **text**: A string containing the input text which may include uppercase letters, punctuation, and whitespace. # Output: * **normalized_text**: A string with the following properties: * All characters are lowercase. * Punctuation characters are removed. * Multiple consecutive spaces are replaced with a single space. * Leading and trailing whitespace is removed. # Constraints: * The function should be efficient and handle reasonably large text inputs (up to several megabytes). * Use standard libraries (such as `re` for regular expressions) where appropriate for tokenization and text processing. # Example: ```python # Sample text with mixed case, punctuation, and extra spaces sample_text = \\" Hello, World! This is a test... \\" # Applying the text normalization normalized_text = normalize_text(sample_text) # The output `normalized_text` should be: # \\"hello world this is a test\\" print(normalized_text) ``` # Notes: 1. Ensure the function handles edge cases such as empty strings, strings with no punctuation, and strings with only punctuation. 2. Pay attention to performance considerations and avoid unnecessary complexity. 3. You may use Python\'s standard library functions and regular expressions (regex) to simplify the implementation. # Evaluation Criteria: * **Correctness**: The function should correctly normalize the text as specified. * **Efficiency**: The implementation should be efficient and handle large text inputs appropriately. * **Edge Handling**: The function should correctly handle various edge cases. * **Code Quality**: The solution should be clean, readable, and properly commented. # Hints: 1. You might find the `re` library in Python useful for removing punctuation and handling whitespace. 2. Convert the text to lowercase before performing other operations to simplify the process. 3. Consider using a sequence of transformations to gradually normalize the text.","solution":"import re def normalize_text(text: str) -> str: Normalize the input text by converting to lowercase, removing punctuation, and eliminating extra whitespace. # Convert text to lowercase text = text.lower() # Remove punctuation using regex text = re.sub(r\'[^ws]\', \'\', text) # Replace multiple consecutive spaces with a single space text = re.sub(r\'s+\', \' \', text) # Strip leading and trailing whitespace text = text.strip() return text"},{"question":"# Problem: Prefix Sum Array A prefix sum array is a useful data structure that allows querying the sum of elements in a subarray efficiently. Given an integer array, you need to implement functions that calculate the prefix sum array and find the sum of any subarray specified by its start and end indices. Instructions: 1. **Function Names**: `compute_prefix_sum` and `subarray_sum` 2. **Input for `compute_prefix_sum`**: * **arr** (List[int]): A list of integers. 3. **Output for `compute_prefix_sum`**: * A list of integers representing the prefix sum array. 4. **Input for `subarray_sum`**: * **prefix_sum** (List[int]): A list of integers representing the prefix sum array. * **start** (int): The starting index (inclusive) of the subarray. * **end** (int): The ending index (inclusive) of the subarray. 5. **Output for `subarray_sum`**: * An integer representing the sum of the specified subarray. 6. **Constraints**: * The input array `arr` can have up to 10^6 elements. * 0 ≤ start ≤ end < len(arr) Example: ```python arr = [1, 2, 3, 4, 5] prefix_sum = compute_prefix_sum(arr) print(prefix_sum) # Output: [1, 3, 6, 10, 15] sum_subarray = subarray_sum(prefix_sum, 1, 3) print(sum_subarray) # Output: 9 ``` **Explanation**: 1. The `compute_prefix_sum` function takes the input array `[1, 2, 3, 4, 5]` and produces the prefix sum array `[1, 3, 6, 10, 15]`. 2. The `subarray_sum` function uses the prefix sum array to quickly compute the sum of the subarray from index 1 to 3, which is `2 + 3 + 4 = 9`. **Deliverable**: Provide the complete implementations of `compute_prefix_sum` and `subarray_sum`. Ensure your solutions are optimized for the constraints provided. Here is the initial setup for your implementation: ```python def compute_prefix_sum(arr): # Write the code to compute and return the prefix sum array pass def subarray_sum(prefix_sum, start, end): # Write the code to compute and return the sum of the subarray pass # Example usage if __name__ == \\"__main__\\": arr = [1, 2, 3, 4, 5] prefix_sum = compute_prefix_sum(arr) print(prefix_sum) # Should output [1, 3, 6, 10, 15] sum_subarray = subarray_sum(prefix_sum, 1, 3) print(sum_subarray) # Should output 9 ```","solution":"def compute_prefix_sum(arr): Computes the prefix sum array for the input list of integers. Args: arr (list of int): The input list of integers. Returns: list of int: The prefix sum array. if not arr: return [] prefix_sum = [arr[0]] for i in range(1, len(arr)): prefix_sum.append(prefix_sum[-1] + arr[i]) return prefix_sum def subarray_sum(prefix_sum, start, end): Computes the sum of a subarray using the prefix sum array. Args: prefix_sum (list of int): The prefix sum array. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: int: The sum of the subarray. if start == 0: return prefix_sum[end] return prefix_sum[end] - prefix_sum[start - 1]"},{"question":"# Problem Statement You are developing a small utility for analyzing text documents. One of the tasks involves counting the frequency of words in a document. Additionally, you need to find the word with the highest frequency and sort all the unique words alphabetically. # Function Specifications Function 1: `word_frequencies(text)` - **Input**: A string `text` representing the document. - **Output**: A dictionary where keys are unique words and values are their respective frequencies. - **Constraints**: The input text may contain punctuation. Words are case-insensitive, meaning \'Word\' and \'word\' should be considered the same. Function 2: `most_frequent_word(text)` - **Input**: A string `text` representing the document. - **Output**: A string representing the word with the highest frequency. If there is a tie, return the lexicographically smallest word. - **Constraints**: The input text may contain punctuation. Words are case-insensitive. Function 3: `sorted_unique_words(text)` - **Input**: A string `text` representing the document. - **Output**: A list of unique words sorted in alphabetical order. - **Constraints**: The input text may contain punctuation. Words are case-insensitive. # Examples Example 1: Word Frequencies ```python >>> word_frequencies(\\"Hello, world! Hello world.\\") {\'hello\': 2, \'world\': 2} >>> word_frequencies(\\"Python is great. Python is fun!\\") {\'python\': 2, \'is\': 2, \'great\': 1, \'fun\': 1} >>> word_frequencies(\\"\\") {} ``` Example 2: Most Frequent Word ```python >>> most_frequent_word(\\"apple banana apple apple orange banana\\") \'apple\' >>> most_frequent_word(\\"Python is great! Python is fun! Python, Python!\\") \'python\' >>> most_frequent_word(\\"to be or not to be\\") \'be\' ``` Example 3: Sorted Unique Words ```python >>> sorted_unique_words(\\"Hello, world! Hello again, world!\\") [\'again\', \'hello\', \'world\'] >>> sorted_unique_words(\\"This is a test. This test is simple.\\") [\'a\', \'is\', \'simple\', \'test\', \'this\'] >>> sorted_unique_words(\\"\\") [] ``` # Detailed Instructions 1. **Implement `word_frequencies` function**: - Convert the input text to lowercase and remove punctuation. - Split the text into words and count the frequency of each word. - Return a dictionary of word frequencies. 2. **Implement `most_frequent_word` function**: - Use the `word_frequencies` function to get the frequency of each word. - Identify the word with the highest frequency. In case of a tie, return the lexicographically smallest word. 3. **Implement `sorted_unique_words` function**: - Use the `word_frequencies` function to get the unique words. - Sort the unique words alphabetically and return the sorted list. # Additional Notes - Define helper functions if needed to keep the main functions clean and concise. - Ensure your code handles edge cases effectively, such as empty input strings. - Optimize your implementation to handle large texts efficiently within the constraints. Good luck and ensure to test your functions thoroughly!","solution":"import string def remove_punctuation(text): return text.translate(str.maketrans(\'\', \'\', string.punctuation)) def word_frequencies(text): text = text.lower() text = remove_punctuation(text) words = text.split() freq = {} for word in words: if word in freq: freq[word] += 1 else: freq[word] = 1 return freq def most_frequent_word(text): frequencies = word_frequencies(text) max_frequency = max(frequencies.values(), default=0) most_frequent_words = [word for word, freq in frequencies.items() if freq == max_frequency] return min(most_frequent_words) if most_frequent_words else \'\' def sorted_unique_words(text): frequencies = word_frequencies(text) unique_words = list(frequencies.keys()) unique_words.sort() return unique_words"},{"question":"# Problem Statement You are tasked with creating a function that validates a string based on the following rules: 1. The string must be exactly 6 characters long. 2. It must contain only alphanumeric characters. 3. It should contain at least one uppercase letter. 4. It should contain at least one lowercase letter. 5. It should contain at least one digit. Implement the function ensuring that it efficiently checks the validity of the string according to the above rules. # Function Signature ```python def validate_string(s: str) -> bool: pass ``` # Input - **s** (string): A string whose length and composition need to be validated. # Output - **bool**: Returns `True` if the string meets all the criteria, otherwise returns `False`. # Examples ```python assert validate_string(\\"A1b2C3\\") == True assert validate_string(\\"123456\\") == False assert validate_string(\\"abcdef\\") == False assert validate_string(\\"ABCDEF\\") == False assert validate_string(\\"aA1bB2\\") == True assert validate_string(\\"aA1!\\") == False assert validate_string(\\"aA1b2c\\") == True ``` # Performance Requirements - The function should have a time complexity of O(n), where n is the length of the string. - Intermediate checks should avoid unnecessary computations once a condition is met. # Hints - Consider using flag variables to keep track of the different requirements. - Ensure to validate the string length as an initial step to quickly determine invalid cases.","solution":"def validate_string(s: str) -> bool: if len(s) != 6: return False has_upper = False has_lower = False has_digit = False for char in s: if not char.isalnum(): return False if char.isupper(): has_upper = True if char.islower(): has_lower = True if char.isdigit(): has_digit = True return has_upper and has_lower and has_digit"},{"question":"# Coding Assessment Question Context: A permutation of an array is a reordering of its elements. For example, `[1, 2, 3]` can be reordered to `[3, 1, 2]`, `[2, 3, 1]`, etc. A k-permutation of an array is any permutation containing exactly k elements of the original array. Problem: Write a function that generates all possible k-permutations of a given list of integers. The function should return a list of lists, where each inner list is a k-permutation of the original list. Function Signature: ```python def k_permutations(arr: list[int], k: int) -> list[list[int]]: ``` Input: - `arr`: a list of integers. - `k`: an integer representing the length of each permutation. Output: - Returns a list of lists where each inner list is a k-permutation of the given list. Requirements: 1. The function must handle edge cases such as an empty list or a list with fewer elements than k. 2. Ensure that all permutations are unique and no duplicates are present in the output. 3. Optimize for performance and handle reasonably large input sizes efficiently. Constraints: - The input list can contain between 0 and 10 elements. - The value of k will be between 0 and the length of the array. Example: ```python >>> k_permutations([1, 2, 3], 2) [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]] >>> k_permutations([1, 2, 3], 3) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> k_permutations([1, 2], 1) [[1], [2]] >>> k_permutations([], 0) [[]] ``` Note: Ensure that your implementation handles cases where k is greater than the length of the array by returning an empty list for such cases. Use efficient permutation generation techniques to achieve the desired results.","solution":"from itertools import permutations def k_permutations(arr, k): Generates all possible k-permutations of a given list of integers. Parameters: arr (list[int]): The input list of integers. k (int): The length of each permutation. Returns: list[list[int]]: A list of lists where each inner list is a k-permutation of the given list. # Edge case: if k is 0, we return a list with an empty permutation if k == 0: return [[]] # If k is greater than the length of the list, return an empty list if k > len(arr): return [] # Generate and return all k-permutations return list(map(list, permutations(arr, k)))"},{"question":"# Coding Assessment Question Scenario When processing large datasets, efficient retrieval of information based on given conditions is essential. This includes operations such as filtering data, aggregating results, and finding specific elements that meet certain criteria. Problem Statement Implement a function called `filter_and_aggregate_data` that processes a dataset of numerical values and performs two main tasks: 1. Filter out values that do not meet a specified threshold. 2. Aggregate the remaining data based on a provided aggregation function. Function Signature ```python def filter_and_aggregate_data(data: list[float], threshold: float, aggregation: str) -> float: Filters data based on a threshold and then aggregates the filtered data using the specified aggregation function. :param data: List of floats representing the dataset. :param threshold: Float value that serves as the threshold for filtering the data. :param aggregation: String indicating the type of aggregation to perform (\'sum\', \'mean\', \'max\', or \'min\'). :return: The aggregated result of the filtered data. Example Usage: >>> data = [1.2, 5.3, 7.4, 3.2, 9.8] >>> filter_and_aggregate_data(data, 5.0, \'sum\') 22.5 >>> data = [1.2, 5.3, 7.4, 3.2, 9.8] >>> filter_and_aggregate_data(data, 5.0, \'mean\') 7.5 >>> data = [1.2, 5.3, 7.4, 3.2, 9.8] >>> filter_and_aggregate_data(data, 5.0, \'max\') 9.8 >>> data = [1.2, 5.3, 7.4, 3.2, 9.8] >>> filter_and_aggregate_data(data, 10.0, \'min\') inf # Since no value is above 10.0, return a representation of infinity. ``` Requirements 1. **Filtering**: Remove all values from `data` that are less than the `threshold`. 2. **Aggregation Options**: Implement the following aggregation functions: - **\'sum\'**: Return the sum of the filtered values. - **\'mean\'**: Return the mean of the filtered values. - **\'max\'**: Return the maximum of the filtered values. - **\'min\'**: Return the minimum of the filtered values. 3. **Edge Case Handling**: Handle cases such as empty lists after filtering or unsupported aggregation functions. 4. **Errors**: Return `float(\'inf\')` if the filtered list is empty and the aggregation function is \'min\' or \'max\'; raise a `ValueError` for unsupported aggregation functions. Constraints * The input list `data` will contain between 0 and 10^6 floating point numbers. * Ensure your implementation can handle these constraints efficiently in terms of both time and space. Performance Requirement * Aim to maintain efficient performance regarding both time and space complexity while handling large datasets and specified operations.","solution":"def filter_and_aggregate_data(data, threshold, aggregation): Filters data based on a threshold and then aggregates the filtered data using the specified aggregation function. :param data: List of floats representing the dataset. :param threshold: Float value that serves as the threshold for filtering the data. :param aggregation: String indicating the type of aggregation to perform (\'sum\', \'mean\', \'max\', \'min\'). :return: The aggregated result of the filtered data. if not isinstance(data, list) or not all(isinstance(i, float) for i in data): raise ValueError(\\"Data should be a list of floats.\\") filtered_data = [d for d in data if d >= threshold] if aggregation == \'sum\': return sum(filtered_data) if aggregation == \'mean\': return sum(filtered_data) / len(filtered_data) if filtered_data else 0.0 if aggregation == \'max\': return max(filtered_data, default=float(\'inf\')) if aggregation == \'min\': return min(filtered_data, default=float(\'inf\')) raise ValueError(\\"Unsupported aggregation function.\\")"},{"question":"Movie Ticket System You are tasked with designing a simple booking system for a movie theater. The system should allow users to view seat availability for different shows and book seats for a particular show. Context Consider the following classes structure: 1. **Seat**: Represents a single seat and contains the seat number and status (`\'available\'` or `\'booked\'`). 2. **Show**: Represents a single show, containing the show ID, a list of `Seat` objects, and a method to view and book seats. You need to create classes `Seat` and `Show` with the following functionality: - **Seat**: - Has a constructor that initializes `seat_number` (as an integer) and `status` (as `\'available\'` or `\'booked\'`). - A method `__str__` that returns the string representation of the seat in the format `Seat {seat_number}: {status}`. - A method `book_seat` that changes the status of the seat to `\'booked\'` if it\'s currently `\'available\'`. - **Show**: - Has a constructor that initializes `show_id` (as a string) and `seats` (a list of `Seat` objects, all seats start as `\'available\'`). - A method `view_seats` that returns a list of `Seat` objects with their status. - A method `book_seat` that takes a seat number and attempts to book that seat, returning a message indicating success or failure. Example Implementation 1. **Seat Class**: ```python class Seat: def __init__(self, seat_number: int, status: str = \'available\'): self.seat_number = seat_number self.status = status def __str__(self): return f\\"Seat {self.seat_number}: {self.status}\\" def book_seat(self): if self.status == \'available\': self.status = \'booked\' return True return False ``` 2. **Show Class**: ```python class Show: def __init__(self, show_id: str, total_seats: int): self.show_id = show_id self.seats = [Seat(seat_number) for seat_number in range(1, total_seats + 1)] def view_seats(self): return [str(seat) for seat in self.seats] def book_seat(self, seat_number: int): if 1 <= seat_number <= len(self.seats): seat = self.seats[seat_number - 1] if seat.book_seat(): return f\\"Seat {seat_number} booked successfully.\\" return f\\"Seat {seat_number} is already booked.\\" return f\\"Invalid seat number {seat_number}.\\" ``` Input - `show_id` (str): A unique identifier for the show. - `total_seats` (int): The total number of seats for the show. - `seat_number` (int): The number of the seat to book. Output - For `view_seats`: A list of strings representing the status of each seat. - For `book_seat`: A string message indicating whether the booking was successful or not. Example Function Calls ```python show = Show(\'s1\', 5) print(show.view_seats()) # Output: [\\"Seat 1: available\\", \\"Seat 2: available\\", \\"Seat 3: available\\", \\"Seat 4: available\\", \\"Seat 5: available\\"] print(show.book_seat(3)) # Output: \\"Seat 3 booked successfully.\\" print(show.view_seats()) # Output: [\\"Seat 1: available\\", \\"Seat 2: available\\", \\"Seat 3: booked\\", \\"Seat 4: available\\", \\"Seat 5: available\\"] print(show.book_seat(3)) # Output: \\"Seat 3 is already booked.\\" ``` Implement the `Seat` and `Show` classes following the specified input and output formats.","solution":"class Seat: def __init__(self, seat_number: int, status: str = \'available\'): self.seat_number = seat_number self.status = status def __str__(self): return f\\"Seat {self.seat_number}: {self.status}\\" def book_seat(self): if self.status == \'available\': self.status = \'booked\' return True return False class Show: def __init__(self, show_id: str, total_seats: int): self.show_id = show_id self.seats = [Seat(seat_number) for seat_number in range(1, total_seats + 1)] def view_seats(self): return [str(seat) for seat in self.seats] def book_seat(self, seat_number: int): if 1 <= seat_number <= len(self.seats): seat = self.seats[seat_number - 1] if seat.book_seat(): return f\\"Seat {seat_number} booked successfully.\\" return f\\"Seat {seat_number} is already booked.\\" return f\\"Invalid seat number {seat_number}.\\""},{"question":"Question Efficient text processing is a common task in various applications like word processors and compilers. Implement a function that identifies and returns all unique words along with their frequency count from a given text. A word is defined as a sequence of alphabetical characters. # Function Signature ```python def word_frequencies(text: str) -> dict: pass ``` # Input * A single string `text` (0 ≤ len(text) ≤ 10^6), consisting of spaces, alphabetical characters, and punctuation marks. # Output * A dictionary where the keys are unique words (in lowercase) from the input text and the values are their respective frequency counts. # Examples ```python >>> word_frequencies(\'Hello world! Hello Universe.\') {\'hello\': 2, \'world\': 1, \'universe\': 1} >>> word_frequencies(\'To be or not to be\') {\'to\': 2, \'be\': 2, \'or\': 1, \'not\': 1} >>> word_frequencies(\'\') {} ``` # Scenario In applications like text analysis software, it is crucial to process and count the frequency of words efficiently. This function will aid in analyzing large text datasets for various purposes, such as understanding word usage trends or detecting the most common words in a dataset. # Notes Implement the function to ensure it handles various input sizes efficiently, from empty strings to very large texts. The function should convert words to lowercase to maintain consistency and avoid counting different cases of the same word separately. Ensure that non-alphabetical characters are excluded from words.","solution":"import re from collections import defaultdict def word_frequencies(text: str) -> dict: Returns a dictionary where the keys are unique words from the input text (in lowercase) and the values are their respective frequency counts. # Use regex to find all words consisting of alphabetical characters words = re.findall(r\'b[a-zA-Z]+b\', text.lower()) # Use a defaultdict to count word frequencies freq_dict = defaultdict(int) for word in words: freq_dict[word] += 1 return dict(freq_dict)"},{"question":"# Fibonacci Subsequence Check Context The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. That is, (F(0) = 0, F(1) = 1), and (F(n) = F(n-1) + F(n-2)) for (n geq 2). The sequence typically goes: 0, 1, 1, 2, 3, 5, 8, 13, 21, etc. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Task Given a list of integers, implement a function `is_fibonacci_subsequence(seq)` that determines whether the given list is a subsequence of the Fibonacci sequence (starting from 0). Return `True` if it is, otherwise return `False`. ```python def is_fibonacci_subsequence(seq: list) -> bool: Given a list of integers `seq`, return `True` if it is a subsequence of the Fibonacci sequence, otherwise return `False`. :param seq: The list of integers to check :type seq: list :return: A boolean indicating if `seq` is a subsequence of the Fibonacci sequence :rtype: bool Examples: >>> is_fibonacci_subsequence([1, 1, 2, 3]) True >>> is_fibonacci_subsequence([1, 3, 4, 7]) False >>> is_fibonacci_subsequence([0, 1, 8]) True >>> is_fibonacci_subsequence([]) True # Empty list is trivially a subsequence of any sequence. pass ``` Constraints - The length of the input list `seq` can be up to (10^4) - Each integer in `seq` will be non-negative and within the range [0, (10^9)] Requirements - Ensure the function handles both small and large input sizes efficiently. - Consider edge cases, such as an empty list or very large numbers.","solution":"def is_fibonacci_subsequence(seq: list) -> bool: Given a list of integers `seq`, return `True` if it is a subsequence of the Fibonacci sequence, otherwise return `False`. :param seq: The list of integers to check :type seq: list :return: A boolean indicating if `seq` is a subsequence of the Fibonacci sequence :rtype: bool Examples: >>> is_fibonacci_subsequence([1, 1, 2, 3]) True >>> is_fibonacci_subsequence([1, 3, 4, 7]) False >>> is_fibonacci_subsequence([0, 1, 8]) True >>> is_fibonacci_subsequence([]) True # Empty list is trivially a subsequence of any sequence. if not seq: return True # Generate Fibonacci numbers up to the maximum element in seq or a reasonably high limit fib = [0, 1] while fib[-1] < 2 * (10**9): fib.append(fib[-1] + fib[-2]) # Convert generated Fibonacci sequence to a set for O(1) look-up times fib_set = set(fib) # Check if each element of the given sequence is a Fibonacci number for number in seq: if number not in fib_set: return False return True"},{"question":"# Sum of Unique Elements in a List Problem Statement You need to implement a function that calculates the sum of unique elements in a list. The function should return an integer representing the sum of unique elements. Function Specification ```python def sum_of_unique_elements(nums: list) -> int: Calculate the sum of unique elements in a list. Parameters: nums (list): A list of integers. Returns: int: The sum of unique integers in the list. ``` Input & Output Format * **Input**: * A list of integers `nums` (0 <= len(nums) <= 1000, -1000 <= nums[i] <= 1000) representing the list of numbers. * **Output**: * An integer representing the sum of unique elements in the list. Constraints: * The function should handle cases where the list is empty. * Ensure the function works efficiently with lists up to the maximum length (1000 elements). Example ```python >>> sum_of_unique_elements([1, 2, 3, 2, 1]) 3 >>> sum_of_unique_elements([5, 5, 5, 5, 5]) 5 >>> sum_of_unique_elements([1, 2, 3, 4, 5]) 15 >>> sum_of_unique_elements([]) 0 ``` Additional Notes * Unique elements are defined as elements that appear exactly once in the list. * Pay attention to edge cases such as empty lists or lists where all elements are the same. * Your solution should aim for optimal space and time complexity within the given constraints.","solution":"def sum_of_unique_elements(nums: list) -> int: Calculate the sum of unique elements in a list. Parameters: nums (list): A list of integers. Returns: int: The sum of unique integers in the list. from collections import Counter # Count the occurrences of each element in the list counts = Counter(nums) # Sum the elements that appear exactly once unique_sum = sum(key for key, value in counts.items() if value == 1) return unique_sum"},{"question":"# Problem Scenario You are developing a text-based game where a player can collect items, perform tasks, and navigate through a series of rooms. Each room is represented as a node in a graph, and paths between rooms as the edges. To ensure the player can always get from any room to any other room, you decide to first check whether the graph is fully connected. To achieve this, you will write a function to determine if the graph of rooms is fully connected using Depth First Search (DFS). # Task Write a function `are_rooms_fully_connected(n: int, connections: list) -> bool`. Your function should: 1. Take as input the number of rooms, `n`, and a list of tuples `connections` representing the paths between rooms. 2. Return `True` if there is a path between any pair of rooms, indicating the graph is fully connected; otherwise, return `False`. # Expected Input and Output Input: - An integer `n` representing the number of rooms. * Example: `5` - A list of tuples, `connections`, where each tuple `(a, b)` represents a bidirectional path between rooms `a` and `b`. * Example: `[(0, 1), (1, 2), (2, 3), (3, 4)]` Output: - A boolean value indicating if the graph is fully connected. * Example: `True` # Constraints: * `1 <= n <= 1000` * The length of the `connections` list will be at most `n*(n-1)/2`. * `0 <= a, b < n` # Example ```python def are_rooms_fully_connected(n: int, connections: list) -> bool: # Implement Depth First Search (DFS) to check graph connectivity pass # Example usage: print(are_rooms_fully_connected(5, [(0, 1), (1, 2), (2, 3), (3, 4)])) # Output: True print(are_rooms_fully_connected(5, [(0, 1), (2, 3)])) # Output: False ``` Provide your implementation of the `are_rooms_fully_connected()` function using DFS as discussed.","solution":"def are_rooms_fully_connected(n: int, connections: list) -> bool: from collections import defaultdict, deque # Create adjacency list for the graph adjacency_list = defaultdict(list) for a, b in connections: adjacency_list[a].append(b) adjacency_list[b].append(a) # Function to perform DFS traversal def dfs(node, visited): stack = [node] while stack: current = stack.pop() for neighbor in adjacency_list[current]: if neighbor not in visited: visited.add(neighbor) stack.append(neighbor) # Initialize visited set and start DFS from node 0 visited = set() visited.add(0) dfs(0, visited) # Check if all nodes are visited return len(visited) == n"},{"question":"# Coding Assessment Question A robotic arm is designed to pick and place items in a 2D grid. The grid is represented as a matrix where each cell can either be empty (0) or contain an obstacle (1). The robotic arm starts at the top-left corner of the grid (0, 0) and needs to reach the bottom-right corner (n-1, m-1). The robot can move right, down, left, or up, but it cannot move diagonally or pass through obstacles. Write a function that returns the length of the shortest path for the robotic arm to reach the bottom-right corner of the grid from the top-left corner. If there is no such path, return -1. # Function Signature ```python def shortest_path(grid: List[List[int]]) -> int: pass ``` # Input * `grid` (List[List[int]]): A 2D list representing the grid, containing only 0s and 1s. # Output * Returns an integer representing the length of the shortest path from the top-left corner to the bottom-right corner, or -1 if no such path exists. # Constraints * 1 ≤ len(grid), len(grid[0]) ≤ 100 * grid[0][0] == 0 and grid[n-1][m-1] == 0, where n is the number of rows and m is the number of columns in `grid`. # Examples ```python # Example 1: # For the grid: # [ # [0, 1, 0], # [0, 0, 0], # [0, 1, 0] # ] # The shortest path length is 4 assert shortest_path([[0, 1, 0], [0, 0, 0], [0, 1, 0]]) == 4 # Example 2: # For the grid: # [ # [0, 1], # [1, 0] # ] # There is no possible path, so the output is -1 assert shortest_path([[0, 1], [1, 0]]) == -1 # Example 3: # For the grid: # [ # [0, 0, 0], # [1, 0, 1], # [0, 0, 0] # ] # The shortest path length is 4 assert shortest_path([[0, 0, 0], [1, 0, 1], [0, 0, 0]]) == 4 ``` # Explanation 1. The function should implement a shortest path search algorithm such as Breadth-First Search (BFS) to find the shortest path in an unweighted grid. 2. The robot can move in four possible directions: right, down, left, or up, but not through cells with obstacles. 3. Handle the edge cases where no path exists by checking for paths that hit obstacles or exceed grid boundaries. # Notes - Think carefully about edge cases with isolated 1 cells or fully blocked paths. - Consider performance implications and ensure efficiency within the given constraints.","solution":"from collections import deque from typing import List def shortest_path(grid: List[List[int]]) -> int: if not grid or not grid[0]: return -1 n, m = len(grid), len(grid[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) # (row, col, path_length) visited = set((0, 0)) while queue: row, col, path_length = queue.popleft() # Check if we have reached the destination if row == n - 1 and col == m - 1: return path_length # Explore all possible movements for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < n and 0 <= new_col < m and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited: queue.append((new_row, new_col, path_length + 1)) visited.add((new_row, new_col)) return -1"},{"question":"# Image Rotation by an Arbitrary Angle Context In computer graphics and image processing, rotating an image by a certain angle is a common operation. It involves translating the pixel positions based on trigonometric transformations while maintaining the image\'s quality. However, the rotation may create black borders if not managed properly. Task Implement the function `rotate_image` that rotates a given grayscale image by a specified angle. Ensure that the rotation preserves the image\'s size by cropping the unnecessary border areas while maintaining the core structure of the image. Function Signature ```python def rotate_image(image, angle): Function to rotate a grayscale image by a specific angle. :param image: 2D numpy array representing the grayscale image. :param angle: A float representing the angle by which the image should be rotated, in degrees. :return: 2D numpy array representing the rotated image. pass ``` Parameters - **image** (`numpy.ndarray`): A 2D numpy array representing the grayscale image. - **angle** (`float`): The angle in degrees to rotate the image. Positive values mean counter-clockwise rotation. Constraints - The `image` should be a 2D array with shape (n, m), where n and m are positive integers. - The `angle` can be any real number, including negatives and fractional degrees. - Ensure minimal loss of quality during the rotation process. - Crop the black borders created by the rotation to maintain the content of the image. Expected Output - Return a 2D numpy array representing the rotated image, cropped to the original size. Example ```python import numpy as np # Example image with simple structure image = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=np.float32) # Example angle angle = 45.0 # Calling the function rotated_image = rotate_image(image, angle) # `rotated_image` is expected to be the result after rotating the input image # by 45 degrees and cropping the borders to maintain the original size. ``` Notes - Use appropriate image rotation algorithms to ensure accuracy and efficiency. - Handle all edge cases, including non-square images and rotations greater than 360 degrees. - Optimize the function for performance, especially for larger images. - You may use interpolation techniques to maintain the quality of the rotated image.","solution":"import numpy as np import scipy.ndimage def rotate_image(image, angle): Function to rotate a grayscale image by a specific angle while cropping unnecessary border areas. :param image: 2D numpy array representing the grayscale image. :param angle: A float representing the angle by which the image should be rotated, in degrees. :return: 2D numpy array representing the rotated image. # Rotate the image using scipy\'s rotate function rotated = scipy.ndimage.rotate(image, angle, reshape=False) return rotated"},{"question":"# Coding Question: Implement Custom Sorting Algorithm You are provided with an implementation of the Merge Sort algorithm in Python for sorting a list of numbers. Your task is to extend the existing sorting functionality by implementing a custom comparison-based sorting algorithm: the \\"Odd-Even Sort\\". This sorting algorithm ensures that all odd numbers appear before all even numbers in the list while maintaining the relative order among odd and even numbers. # Task 1. **Implement the Odd-Even Sort**: - Add a new function named `odd_even_sort` to the existing codebase. - Ensure that this function sorts the numbers such that all odd numbers come before even numbers, preserving their initial relative order. 2. **Integrate and Test**: - Ensure that the new sort function works seamlessly with the existing list of numbers. - Test the new sorting function on various lists to ensure correctness. 3. **Required Code Implementation**: - Implement the `odd_even_sort` function. - Provide test functions to demonstrate the use of the `odd_even_sort` function. # Function Signatures ```python def odd_even_sort(arr): Sort the array such that all odd numbers appear before all even numbers, while maintaining the relative order among odd and even numbers. :param arr: list of integers :return: sorted list of integers # Implement odd-even sort here def test_odd_even_sort(): Test function for the odd-even sort. # Test cases to validate the function ``` # Constraints: 1. Do not use additional data structures that result in a space complexity greater than O(n). 2. The time complexity of your solution should be O(n). # Sample Input: ```python test_case_1 = [8, 13, 17, 2, 7, 4, 1] test_case_2 = [2, 4, 6, 8, 10, 11, 1] test_case_3 = [1, 3, 5, 7, 9, 2, 4] ``` # Sample Output: ```python # After sorting using odd-even sort sorted_case_1 = [13, 17, 7, 1, 8, 2, 4] sorted_case_2 = [11, 1, 2, 4, 6, 8, 10] sorted_case_3 = [1, 3, 5, 7, 9, 2, 4] ``` # Explanation: - In `test_case_1`, all odd numbers [13, 17, 7, 1] are moved before all even numbers [8, 2, 4] while preserving their original relative order. - Similarly, for `test_case_2` and `test_case_3`, the sorting is done in the same fashion. Implement the `odd_even_sort` function and validate it using the provided test function to ensure it meets all the requirements.","solution":"def odd_even_sort(arr): Sort the array such that all odd numbers appear before all even numbers, while maintaining the relative order among odd and even numbers. :param arr: list of integers :return: sorted list of integers # Separate the odd and even numbers while maintaining the relative order odd_numbers = [x for x in arr if x % 2 != 0] even_numbers = [x for x in arr if x % 2 == 0] # Concatenate odd and even numbers sorted_arr = odd_numbers + even_numbers return sorted_arr"},{"question":"# Context You are working on a library system that maintains a record of books available for borrowing. Each book has a unique title, an author, and a number of copies available. Patrons can borrow and return books. The system should be able to track the number of copies and ensure that books can only be borrowed if they are available. # Task Implement a class `Library` that manages the books using an internal dictionary structure. The system should support the following operations: 1. **Add a book**: Add a new book or update the number of copies of an existing book. 2. **Borrow a book**: Reduce the number of available copies of the specified book by one, if available. 3. **Return a book**: Increase the number of available copies of the specified book by one. 4. **Get available copies**: Retrieve the number of available copies for a specified book. Books are represented as dictionaries with keys \'title\', \'author\', and \'copies\'. Implement methods with the following signatures: ```python class Library: def add_book(self, title: str, author: str, copies: int) -> None: pass def borrow_book(self, title: str) -> bool: pass def return_book(self, title: str) -> bool: pass def get_available_copies(self, title: str) -> int: pass ``` # Requirements 1. Ensure that borrowing an unavailable book returns `False` and does not alter the state. 2. Returning a book that was not previously borrowed should still increase the available copies count. 3. Handle edge cases such as attempting to borrow or return books that do not exist in the system. # Constraints * Titles and authors are strings with maximum lengths of 100 characters. * The number of copies is between [0, 1000]. # Example ```python library = Library() library.add_book(\\"1984\\", \\"George Orwell\\", 3) library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) print(library.get_available_copies(\\"1984\\")) # Output: 3 print(library.borrow_book(\\"1984\\")) # Output: True print(library.get_available_copies(\\"1984\\")) # Output: 2 print(library.borrow_book(\\"1984\\")) # Output: True print(library.get_available_copies(\\"1984\\")) # Output: 1 print(library.borrow_book(\\"1984\\")) # Output: True print(library.get_available_copies(\\"1984\\")) # Output: 0 print(library.borrow_book(\\"1984\\")) # Output: False print(library.return_book(\\"1984\\")) # Output: True print(library.get_available_copies(\\"1984\\")) # Output: 1 ``` # Submission Submit a class `Library` implemented in Python, with the specified methods ensuring efficient management of the book records.","solution":"class Library: def __init__(self): self.books = {} def add_book(self, title: str, author: str, copies: int) -> None: if title in self.books: self.books[title][\'copies\'] += copies else: self.books[title] = {\'author\': author, \'copies\': copies} def borrow_book(self, title: str) -> bool: if title in self.books and self.books[title][\'copies\'] > 0: self.books[title][\'copies\'] -= 1 return True return False def return_book(self, title: str) -> bool: if title in self.books: self.books[title][\'copies\'] += 1 return True return False def get_available_copies(self, title: str) -> int: if title in self.books: return self.books[title][\'copies\'] return 0"},{"question":"# Question: Cleaning and Transforming CSV Data for Analysis You are tasked with developing a Python function that reads a CSV file containing user data, removes invalid rows, and transforms specific columns for further analysis. Function Signature ```python def clean_and_transform_csv(file_path: str) -> list[dict[str, Any]]: pass ``` Input: - `file_path` (str): The path to the CSV file to be read and processed. Output: - A list of dictionaries where: - Each dictionary represents a valid row from the CSV. - The keys of the dictionary are the column headers from the CSV. - Specific transformations are applied: - The `\'age\'` field is converted to an integer. - The `\'signup_date\'` field is converted to a datetime object. - Rows with invalid data (non-numeric \'age\', or malformed \'signup_date\') are removed. Constraints: - The CSV file is expected to have at least the following columns: `[\'name\', \'email\', \'age\', \'signup_date\']`. - The function should handle incorrect file paths gracefully by returning an empty list on failure. - Ensure that the date format used in the CSV is \'YYYY-MM-DDTHH:MM:SS\' (ISO 8601). Sample Execution: ```python # Prepare a sample CSV content csv_content = name,email,age,signup_date John Doe,john.doe@example.com,30,2022-01-15T13:45:30 Jane Smith,jane.smith@example.com,29,invalid_date Foo Bar,foo.bar@example.com,invalid_age,2022-03-10T09:30:00 Alice Johnson,alice.johnson@example.com,25,2022-05-20T11:20:15 # Write the sample content to a temporary CSV file import tempfile with tempfile.NamedTemporaryFile(delete=False, mode=\'w\') as tmp_file: tmp_file.write(csv_content) tmp_file_path = tmp_file.name # Clean and transform CSV data cleaned_data = clean_and_transform_csv(tmp_file_path) print(cleaned_data) # Expected: List of dictionaries with clean and transformed data ``` # Background: This exercise is meant to test your understanding of: - Reading and processing CSV files using Python. - Data cleaning techniques such as handling and removing invalid rows. - Data transformation methods including type conversion and handling dates. - Handling exceptions related to file operations and data parsing. **Example CSV Structure**: ```csv name,email,age,signup_date John Doe,john.doe@example.com,30,2022-01-15T13:45:30 Jane Smith,jane.smith@example.com,29,invalid_date Foo Bar,foo.bar@example.com,invalid_age,2022-03-10T09:30:00 Alice Johnson,alice.johnson@example.com,25,2022-05-20T11:20:15 ``` Refer to the [Python CSV module documentation](https://docs.python.org/3/library/csv.html) and the [datetime module documentation](https://docs.python.org/3/library/datetime.html) for more details.","solution":"import csv from datetime import datetime from typing import Any, List, Dict def clean_and_transform_csv(file_path: str) -> List[Dict[str, Any]]: result = [] try: with open(file_path, mode=\'r\', encoding=\'utf-8\') as file: reader = csv.DictReader(file) for row in reader: try: # Attempt to convert the age to integer row[\'age\'] = int(row[\'age\']) # Attempt to parse the signup_date to datetime object row[\'signup_date\'] = datetime.fromisoformat(row[\'signup_date\']) result.append(row) except (ValueError, TypeError): # Skip rows with invalid age or signup_date continue except FileNotFoundError: # If file not found, return an empty list return [] return result"},{"question":"# Scenario: You are building a library management system where users can borrow and return books. The system needs to keep track of the availability of each book and prevent duplicate borrowings. Additionally, you need to provide a summary feature that displays all currently borrowed books. # Task: Write a class `Library` that manages the borrowing and returning of books. The class should include methods to borrow a book, return a book, and display a summary of currently borrowed books. # Requirements: 1. Implement a method `borrow_book(self, book_title: str) -> None`: - This method should add the book to the list of borrowed books if it is not already borrowed. - If the book is already borrowed, it should raise an exception with a message \\"Book already borrowed\\". 2. Implement a method `return_book(self, book_title: str) -> None`: - This method should remove the book from the list of borrowed books if it is currently borrowed. - If the book is not borrowed, it should raise an exception with a message \\"Book not borrowed\\". 3. Implement a method `summary(self) -> None`: - This method should print the titles of all currently borrowed books, one per line. # Example: ```python class Library: def __init__(self): self.borrowed_books = set() def borrow_book(self, book_title: str) -> None: if book_title in self.borrowed_books: raise Exception(\\"Book already borrowed\\") self.borrowed_books.add(book_title) def return_book(self, book_title: str) -> None: if book_title not in self.borrowed_books: raise Exception(\\"Book not borrowed\\") self.borrowed_books.remove(book_title) def summary(self) -> None: for book in self.borrowed_books: print(book) # Example usage: library = Library() library.borrow_book(\\"1984\\") library.borrow_book(\\"To Kill a Mockingbird\\") library.summary() library.return_book(\\"1984\\") library.summary() ``` Input/Output: - `borrow_book(book_title: str) -> None`: Adds the book title to the list of borrowed books, or raises an exception if the book is already borrowed. - `return_book(book_title: str) -> None`: Removes the book title from the list of borrowed books, or raises an exception if the book is not borrowed. - `summary() -> None`: Prints the titles of all borrowed books, one per line. Constraints: - The maximum number of books that can be borrowed at any time is 100.","solution":"class Library: def __init__(self): self.borrowed_books = set() def borrow_book(self, book_title: str) -> None: if len(self.borrowed_books) >= 100: raise Exception(\\"Maximum number of books borrowed\\") if book_title in self.borrowed_books: raise Exception(\\"Book already borrowed\\") self.borrowed_books.add(book_title) def return_book(self, book_title: str) -> None: if book_title not in self.borrowed_books: raise Exception(\\"Book not borrowed\\") self.borrowed_books.remove(book_title) def summary(self) -> None: for book in self.borrowed_books: print(book)"},{"question":"User Activity Log Analysis You are developing a web application that analyzes the activity log of users on the platform. Your task is to process the log data to determine the most active user within a specified time window. Task 1. Implement a function `most_active_user(logs: List[Tuple[str, str]]) -> str` that takes a list of tuples where each tuple consists of a `timestamp` and a `userID`. It returns the userID of the most active user within the given time window. Input * **logs**: A list of tuples, where each tuple contains: - `timestamp`: a string in the form `\\"YYYY-MM-DD HH:MM:SS\\"` - `userID`: a string representing the user ID. Output * **str**: The `userID` of the most active user within the specified time window. Constraints * The list `logs` is guaranteed to be sorted by `timestamp` in ascending order. * If there are multiple users with the same highest activity, return any one of them. * The `timestamp` format ensures natural sorting by date and time. Example Usage ```python logs = [ (\\"2023-09-19 12:14:05\\", \\"user1\\"), (\\"2023-09-19 12:15:42\\", \\"user2\\"), (\\"2023-09-19 12:15:45\\", \\"user1\\"), (\\"2023-09-19 12:16:01\\", \\"user3\\"), (\\"2023-09-19 12:17:03\\", \\"user1\\"), (\\"2023-09-19 12:17:55\\", \\"user2\\"), (\\"2023-09-19 12:18:33\\", \\"user1\\") ] most_active = most_active_user(logs) print(most_active) # Expected output: \\"user1\\" ``` Note - Utilize standard Python libraries to handle date and time format if necessary. - Keep track of user activities efficiently to ensure scalability.","solution":"from typing import List, Tuple from collections import defaultdict def most_active_user(logs: List[Tuple[str, str]]) -> str: activity_count = defaultdict(int) for timestamp, user in logs: activity_count[user] += 1 max_activity = 0 most_active_user = None for user, count in activity_count.items(): if count > max_activity: max_activity = count most_active_user = user return most_active_user"},{"question":"# Question: Matrix Diagonal Sum and Transpose You are provided with two individual tasks involving matrix operations. Write two functions to achieve the following: Task 1: Sum of Diagonal Elements Write a function `diagonal_sum(matrix: List[List[int]]) -> int` that computes the sum of the diagonal elements of a square matrix. The matrix is represented as a list of lists. **Input** - A list of lists `matrix` where each sublist represents a row of the square matrix. **Output** - Return an integer representing the sum of the diagonal elements. **Examples** ```python >>> diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 15 # (1 + 5 + 9) >>> diagonal_sum([[2, 0, 1], [0, 3, 0], [1, 0, 4]]) 9 # (2 + 3 + 4) ``` Task 2: Transpose of a Matrix Write a function `transpose_matrix(matrix: List[List[int]]) -> List[List[int]]` that returns the transpose of a square matrix. The transpose of a matrix is obtained by swapping rows with columns. **Input** - A list of lists `matrix` where each sublist represents a row of the square matrix. **Output** - Return a new list of lists representing the transpose of the input matrix. **Examples** ```python >>> transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[1, 4, 7], [2, 5, 8], [3, 6, 9]] >>> transpose_matrix([[2, 0, 1], [0, 3, 0], [1, 0, 4]]) [[2, 0, 1], [0, 3, 0], [1, 0, 4]] ``` **Constraints**: - Both functions should raise a `ValueError` if the input matrix is empty, not a list of lists, or not a square matrix (i.e., all rows must have the same number of columns equal to the number of rows). ```python def diagonal_sum(matrix: List[List[int]]) -> int: # your code here pass def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: # your code here pass ``` Use the following assertions to verify the correctness of your code: ```python assert diagonal_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 15 assert diagonal_sum([[2, 0, 1], [0, 3, 0], [1, 0, 4]]) == 9 assert transpose_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [[1, 4, 7], [2, 5, 8], [3, 6, 9]] assert transpose_matrix([[2, 0, 1], [0, 3, 0], [1, 0, 4]]) == [[2, 0, 1], [0, 3, 0], [1, 0, 4]] ```","solution":"from typing import List def diagonal_sum(matrix: List[List[int]]) -> int: Computes the sum of the diagonal elements of a square matrix. if not matrix or not all(isinstance(row, list) for row in matrix) or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input must be a non-empty square matrix.\\") return sum(matrix[i][i] for i in range(len(matrix))) def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Returns the transpose of a square matrix. if not matrix or not all(isinstance(row, list) for row in matrix) or not all(len(row) == len(matrix) for row in matrix): raise ValueError(\\"The input must be a non-empty square matrix.\\") n = len(matrix) return [[matrix[j][i] for j in range(n)] for i in range(n)]"},{"question":"# Coding Assessment Question Context In the following task, you are required to implement a function that performs data compression using a simplified version of the Run-Length Encoding (RLE) algorithm. RLE is a basic form of lossless data compression where sequences of the same data value (runs) are stored as a single data value and a count. Task You are required to implement the functions `rle_encode` and `rle_decode` as specified below: 1. **Function Name**: `rle_encode` - **Input**: A `str` object (`data`) containing the uncompressed string to be encoded. - **Output**: A `str` object containing the Run-Length Encoded string of the input data. 2. **Function Name**: `rle_decode` - **Input**: A `str` object (`data`) containing the Run-Length Encoded representation to be decoded. - **Output**: A `str` object containing the original uncompressed string. - **Constraints**: - The input string must be a valid run-length encoded string. - The count of characters in the encoded string should be a positive integer. If it contains invalid values or formatting, raise a `ValueError` with an appropriate message. Constraints * Your implementations must validate the input for `rle_decode`. * If the input for `rle_decode` is invalid, raise a `ValueError` with an appropriate message. * The encoding must encode sequences of one or more identical characters. * You are not allowed to use any external libraries for encoding or decoding. Examples ```python # Example for rle_encode assert rle_encode(\'AAABBBCC\') == \'3A3B2C\' assert rle_encode(\'AABCC\') == \'2A1B2C\' assert rle_encode(\'\') == \'\' # Example for rle_decode assert rle_decode(\'3A3B2C\') == \'AAABBBCC\' assert rle_decode(\'2A1B2C\') == \'AABCC\' assert rle_decode(\'\') == \'\' # Invalid cases for rle_decode try: rle_decode(\'3A3B2C1\') except ValueError as e: assert str(e) == \\"RLE encoded data is invalid: count for character missing or not an integer.\\" try: rle_decode(\'3A3BXYZ\') except ValueError as e: assert str(e) == \\"RLE encoded data is invalid: count for character missing or not an integer.\\" try: rle_decode(\'This is invalid RLE.\') except ValueError as e: assert str(e) == \\"RLE encoded data is invalid: count for character missing or not an integer.\\" ``` Be sure to handle edge cases and validate the input appropriately.","solution":"def rle_encode(data): if not data: return \'\' encoded = [] count = 1 previous = data[0] for char in data[1:]: if char == previous: count += 1 else: encoded.append(f\'{count}{previous}\') previous = char count = 1 encoded.append(f\'{count}{previous}\') return \'\'.join(encoded) def rle_decode(data): if not data: return \'\' decoded = [] count = \'\' for char in data: if char.isdigit(): count += char else: if count == \'\': raise ValueError(\\"RLE encoded data is invalid: count for character missing or not an integer.\\") decoded.append(char * int(count)) count = \'\' if count != \'\': raise ValueError(\\"RLE encoded data is invalid: count for character missing or not an integer.\\") return \'\'.join(decoded)"},{"question":"Question: In this task, you are required to implement the merge sort algorithm to sort an array of integers in ascending order. This exercise is intended to evaluate your comprehension and ability to handle sorting an array using the merge sort method. # Requirements: 1. **Function**: `def merge_sort(collection: list[int]) -> list[int]:` 2. **Input**: * A list of integers `collection`, e.g., `[4, 3, 2, 1]`. 3. **Output**: * The sorted list in ascending order. 4. **Constraints**: * Do not use built-in sorting methods. * The input list can be empty or contain up to `1000` integers. 5. **Performance**: * Target O(n log n) time complexity. * O(n) additional space. # Scenario: A new acquaintance, who just started their journey into data science, seeks your help to sort a list of integers they\'ve gathered for their studies. They are interested in understanding the merge sort technique and asked you to provide a clear, automated solution to sort their data. # Example: Input: `[4, 2, 7, 1, 3]` Output: `[1, 2, 3, 4, 7]` # Edge Cases to Consider: * The algorithm should handle empty lists gracefully by returning an empty list. * It should accurately sort lists that are already sorted or nearly sorted. * Consider cases where all elements in the list are identical. # Additional Tests: Make sure your implementation passes the expected outputs for the following scenarios: 1. Input: `[5, 4, 3, 2, 1]` Output: `[1, 2, 3, 4, 5]` 2. Input: `[1, 2, 3, 4, 5]` Output: `[1, 2, 3, 4, 5]` 3. Input: `[10, -1, 2, 5, 0, 3, 7, 8, -5]` Output: `[-5, -1, 0, 2, 3, 5, 7, 8, 10]` # Instructions: * Implement your solution in Python. * Ensure your code is well-structured and includes necessary comments for clarity. * Test your solution against multiple test cases to verify correctness.","solution":"def merge_sort(collection: list[int]) -> list[int]: if len(collection) <= 1: return collection def merge(left: list[int], right: list[int]) -> list[int]: sorted_list = [] left_index, right_index = 0, 0 while left_index < len(left) and right_index < len(right): if left[left_index] <= right[right_index]: sorted_list.append(left[left_index]) left_index += 1 else: sorted_list.append(right[right_index]) right_index += 1 sorted_list.extend(left[left_index:]) sorted_list.extend(right[right_index:]) return sorted_list mid = len(collection) // 2 left_half = merge_sort(collection[:mid]) right_half = merge_sort(collection[mid:]) return merge(left_half, right_half)"},{"question":"# Sum of Dict Values Performing operations on data structures like dictionaries is a common task in many programming challenges. This problem will assess your ability to sum the values contained in a nested dictionary structure. Task Objective: Write a function `sum_dict_values(d: dict) -> int` that computes the sum of all integer values present in a dictionary. The dictionary may have nested dictionaries as values. Function Specifications: * **Input**: * `d` (dict): a dictionary where the values can be integers or other dictionaries. * **Output**: * (int): the sum of all integer values from the dictionary, including those in any nested dictionaries. Constraints: * The dictionary will not contain lists or other data types other than integers and nested dictionaries. * The input dictionary may be empty. What You Should Implement: Implement a function named `sum_dict_values` with the specified behavior and constraints. Example usages: ```python >>> sum_dict_values({\\"a\\": 1, \\"b\\": {\\"c\\": 2, \\"d\\": 3}, \\"e\\": 4}) 10 >>> sum_dict_values({\\"key1\\": {\\"subkey1\\": 10, \\"subkey2\\": 20}, \\"key2\\": 30}) 60 >>> sum_dict_values({}) 0 >>> sum_dict_values({\\"x\\": {\\"y\\": {\\"z\\": 5}}, \\"a\\": 1}) 6 >>> sum_dict_values({\\"a\\": 1, \\"b\\": 2, \\"c\\": {\\"d\\": 3, \\"e\\": {\\"f\\": 4, \\"g\\": 5}}}) 15 ``` This problem examines your ability to navigate and manipulate nested data structures while performing aggregate operations. Your function should be both efficient and handle any edge cases involving deeply nested dictionaries.","solution":"def sum_dict_values(d): Computes the sum of all integer values present in a dictionary, including nested dictionaries. Parameters: d (dict): The dictionary to sum the values of. Returns: int: The sum of all integer values in the dictionary. total = 0 for value in d.values(): if isinstance(value, dict): total += sum_dict_values(value) elif isinstance(value, int): total += value return total"},{"question":"# Coding Assessment Question **Context**: You are given a large array containing integers. Your goal is to determine the smallest positive integer that is missing from this array. The array may contain both positive and negative integers, and it is guaranteed that the size of the array does not exceed 100,000 elements. **Task**: Write a function `find_smallest_missing_positive(nums: List[int]) -> int` that: 1. Receives a list of integers `nums` with size `n` (1 ≤ n ≤ 100,000). 2. Returns the smallest positive integer that is missing from the array. **Input**: - A list of integers `nums` specifying the array elements. **Output**: - An integer representing the smallest positive integer that is missing from the array. **Constraints**: - The solution must run in O(n) time complexity and use O(1) additional space complexity. **Example**: ```python print(find_smallest_missing_positive([3, 4, -1, 1])) # Output: 2 print(find_smallest_missing_positive([1, 2, 0])) # Output: 3 print(find_smallest_missing_positive([-2, -3, -1, 1, 2, 3])) # Output: 4 ``` **Function Signature**: ```python from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: pass ``` Ensure your solution effectively leverages in-place manipulation of the array elements to minimize additional space usage.","solution":"from typing import List def find_smallest_missing_positive(nums: List[int]) -> int: n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"# Task: Implement a Circular Linked List Problem Statement You are provided with a partially implemented Circular Linked List class. Your task is to complete the implementation with specific methods to ensure the Circular Linked List operates correctly. This data structure should allow elements to be added, removed, and accessed in a circular manner, such that the last element points back to the first element. Class Signature ```python class Node: def __init__(self, data: int): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def append(self, data: int): pass def remove(self, data: int): pass def display(self) -> list[int]: pass ``` Input - `append` method should take an integer `data` to be added to the list. - `remove` method should take an integer `data` to be removed from the list. - `display` method should return the list of elements in the Circular Linked List as a list of integers. Output - `append` method should modify the list by adding the new element. - `remove` method should modify the list by removing the specified element. - `display` method should return the elements in the list in order. Constraints 1. All input values for `data` should be non-negative integers. 2. Attempting to remove a non-existent element should raise a `ValueError`. 3. Displaying an empty list should return an empty list. 4. Elements should be maintained in the order they are added. Example ```python >>> cll = CircularLinkedList() >>> cll.append(1) >>> cll.append(2) >>> cll.append(3) >>> cll.display() [1, 2, 3] >>> cll.remove(2) >>> cll.display() [1, 3] >>> cll.remove(4) Traceback (most recent call last): ... ValueError: Element not found in the Circular Linked List >>> cll.append(4) >>> cll.append(5) >>> cll.display() [1, 3, 4, 5] ``` Requirements - Complete the implementation of the `append`, `remove`, and `display` methods. - Ensure the Circular Linked List maintains its properties with the last element pointing back to the first. - Handle edge cases such as removing from an empty list or removing a non-existent element appropriately.","solution":"class Node: def __init__(self, data: int): self.data = data self.next = None class CircularLinkedList: def __init__(self): self.head = None def append(self, data: int): new_node = Node(data) if not self.head: self.head = new_node new_node.next = self.head else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = new_node new_node.next = self.head def remove(self, data: int): if not self.head: raise ValueError(\\"Element not found in the Circular Linked List\\") if self.head.data == data: if self.head.next == self.head: self.head = None return else: temp = self.head while temp.next != self.head: temp = temp.next temp.next = self.head.next self.head = self.head.next return prev = None curr = self.head while curr.next != self.head: if curr.data == data: prev.next = curr.next return prev = curr curr = curr.next if curr.data == data: prev.next = curr.next else: raise ValueError(\\"Element not found in the Circular Linked List\\") def display(self) -> list: elements = [] if not self.head: return elements temp = self.head while True: elements.append(temp.data) temp = temp.next if temp == self.head: break return elements"},{"question":"# Problem Statement Design a simplified compiler that can parse and evaluate mathematical expressions containing addition and multiplication operators. The input expressions will be given in standard infix notation with integer operands. No parentheses are allowed. # Requirements 1. **Input**: - `expression` : A string containing a mathematical expression with operands (positive integers) and operators (`+`, `*`) separated by spaces. 2. **Output**: - An integer representing the result of evaluating the expression. # Constraints - The length of the expression string will be at least 3 (i.e., \\"1 + 1\\") and less than or equal to 1,000. - The expression will be valid and evaluated strictly from left to right (no operator precedence other than as encountered). - Only non-negative integers and the two operators (`+`, `*`) are allowed in the expression. # Example ```python # Sample inputs expression1 = \\"3 + 5 * 2\\" expression2 = \\"7 * 2 + 3 + 4\\" # Evaluated results result1 = evaluate_expression(expression1) print(f\\"Result of \'{expression1}\': {result1}\\") # Output: 16 result2 = evaluate_expression(expression2) print(f\\"Result of \'{expression2}\': {result2}\\") # Output: 21 ``` # Instructions: 1. Create a function `evaluate_expression(expression: str) -> int`: - Parse the input string. - Evaluate the mathematical expression from left to right. - Return the result as an integer. 2. **Note**: Do not handle operator precedence; consider each operator as encountered. 3. You may assume all inputs are formatted correctly and no error handling is needed for invalid expressions. ```python def evaluate_expression(expression: str) -> int: tokens = expression.split() result = int(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] operand = int(tokens[i+1]) if operator == \'+\': result += operand elif operator == \'*\': result *= operand i += 2 return result # Test cases expression1 = \\"3 + 5 * 2\\" expression2 = \\"7 * 2 + 3 + 4\\" result1 = evaluate_expression(expression1) print(f\\"Result of \'{expression1}\': {result1}\\") # Output: 16 result2 = evaluate_expression(expression2) print(f\\"Result of \'{expression2}\': {result2}\\") # Output: 21 ```","solution":"def evaluate_expression(expression: str) -> int: tokens = expression.split() result = int(tokens[0]) i = 1 while i < len(tokens): operator = tokens[i] operand = int(tokens[i+1]) if operator == \'+\': result += operand elif operator == \'*\': result *= operand i += 2 return result"},{"question":"# Problem Statement: You are developing a feature for a data processing tool that requires summarizing information about a sequence of numbers. Specifically, you need to create a function that finds the length and starting position of the longest contiguous subsequence with the same value within a given list of integers. If there are multiple such subsequences of the same maximum length, return the one that appears first. # Function Definition: ```python def longest_contiguous_subsequence(arr: list[int]) -> tuple[int, int, int]: Find the length and starting position of the longest contiguous subsequence with the same value. Parameters: - arr: A list of integers containing the sequence to process. Returns: - A tuple containing three integers: the value of the longest subsequence, the length of the subsequence, and the starting index. ``` # Input and Output: - **Input**: - `arr`: A list of integers, where the length of the list will not exceed 10^4 integers. - **Output**: A tuple containing three integers: the value of the longest contiguous subsequence, the length of the subsequence, and the starting index of the subsequence. # Constraints: - The input list can contain both positive and negative integers. - If the input list is empty, return a tuple `(0, 0, -1)`. # Examples: ```python longest_contiguous_subsequence([1, 1, 2, 2, 2, 1, 1]) # Output: (2, 3, 2) longest_contiguous_subsequence([4, 4, 4, 4, 4]) # Output: (4, 5, 0) longest_contiguous_subsequence([1, 3, 3, 1, 2, 2, 2, 2, 3, 3]) # Output: (2, 4, 4) longest_contiguous_subsequence([7]) # Output: (7, 1, 0) longest_contiguous_subsequence([]) # Output: (0, 0, -1) ``` # Notes: - The function should iterate through the list efficiently. - Handle edge cases such as empty lists or lists with only one element appropriately. - Ensure the function returns the correct starting position for tied subsequences. Happy coding!","solution":"def longest_contiguous_subsequence(arr: list[int]) -> tuple[int, int, int]: if not arr: return (0, 0, -1) max_value = arr[0] max_length = 1 max_start_index = 0 current_value = arr[0] current_length = 1 current_start_index = 0 for i in range(1, len(arr)): if arr[i] == current_value: current_length += 1 else: if current_length > max_length: max_value = current_value max_length = current_length max_start_index = current_start_index current_value = arr[i] current_length = 1 current_start_index = i if current_length > max_length: max_value = current_value max_length = current_length max_start_index = current_start_index return (max_value, max_length, max_start_index)"},{"question":"# Shortest Path in a Weighted Graph using Dijkstra\'s Algorithm You need to write a program to find the shortest path from a given source node to all other nodes in a weighted graph using Dijkstra\'s Algorithm. # Specifications 1. **Function**: `dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]` * **Inputs**: * `graph`: A dictionary where keys are node identifiers and values are lists of tuples representing the connected nodes and the associated edge weights. For example, `graph[u] = [(v1, w1), (v2, w2)]` means there are edges from node `u` to node `v1` with weight `w1` and to node `v2` with weight `w2`. * `start`: An integer representing the starting node identifier. * **Output**: * A dictionary where keys are node identifiers and values are the shortest distances from the starting node to that node. For example, if the starting node is `s`, then the output would be `{v1: d1, v2: d2, ...}` where `d1` is the shortest distance from `s` to `v1`. # Constraints * The number of nodes `n` can be up to `10^4`. * The total number of edges `m` can be up to `5 * 10^4`. * Edge weights are positive integers. * Ensure your implementation is efficient and can handle large graphs within a reasonable time frame. # Performance Requirements * The implementation must be efficient, preferably with a time complexity of O((n + m) log n). # Example ```python graph = { 0: [(1, 2), (2, 4)], 1: [(2, 1), (3, 7)], 2: [(3, 3)], 3: [] } start = 0 shortest_paths = dijkstra(graph, start) print(shortest_paths) # Expected Output: {0: 0, 1: 2, 2: 3, 3: 6} ``` **Note**: You may design and use additional helper functions or classes as required to complete the implementation.","solution":"import heapq from typing import Dict, List, Tuple def dijkstra(graph: Dict[int, List[Tuple[int, int]]], start: int) -> Dict[int, int]: Implements Dijkstra\'s algorithm to find the shortest paths from the start node to all other nodes in a weighted graph. :param graph: A dictionary where keys are node identifiers and values are lists of tuples representing the connected nodes and the associated edge weights. :param start: An integer representing the starting node identifier. :return: A dictionary where keys are node identifiers and values are the shortest distances from the starting node to that node. # Initialize distances from start node to infinity distances = {node: float(\'inf\') for node in graph} distances[start] = 0 # Priority queue to keep track of (distance, node) pairs priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) # Skip if we have found a better way if current_distance > distances[current_node]: continue # Check neighbors for neighbor, weight in graph[current_node]: distance = current_distance + weight # Only consider this path if it\'s better if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances"},{"question":"**Question: Robot Path Planning on a Grid with Obstacles** You are given a grid that represents a factory floor where an autonomous robot needs to navigate from a starting position to a target position. The grid contains obstacles that the robot cannot pass through. The robot can move up, down, left, or right at each step. Implement an efficient algorithm that calculates the shortest path from the start to the target, avoiding obstacles. If no path exists, the algorithm should return -1. # Task 1. **Implement the `find_shortest_path` function**: Develop an optimal pathfinding algorithm to compute the shortest path on the grid. 2. Consider edge cases such as the start or target positions being obstacles and handle them appropriately. 3. Reduce the time complexity by avoiding unnecessary traversals and keeping track of visited positions. # Requirements: - Use an appropriate search algorithm (e.g., BFS for unweighted grids). - Ensure the algorithm operates within O(N) time complexity where N is the number of cells in the grid. - Provide graceful handling of scenarios with no possible paths. # Input: - `grid` (list[list[int]]): A 2D list where 0 represents a walkable space and 1 represents an obstacle. - `start` (tuple[int, int]): The starting position (row, col) of the robot. - `target` (tuple[int, int]): The target position (row, col) the robot needs to reach. # Output: - An integer representing the shortest distance from start to target. Return -1 if no path is possible. # Function Signature: ```python def find_shortest_path(grid: list[list[int]], start: tuple[int, int], target: tuple[int, int]) -> int: pass ``` # Example: ```python >>> grid = [ ... [0, 0, 1, 0], ... [0, 0, 0, 0], ... [0, 1, 0, 0], ... [0, 0, 0, 0] ... ] >>> start = (0, 0) >>> target = (3, 3) >>> find_shortest_path(grid, start, target) 6 ``` **Note**: - Ensure the robot does not step into obstacle cells. - Confirm that the robot only makes valid moves within the grid boundaries. **Example Explained**: In the given grid, the robot starts at (0, 0) and finds a path through (1, 0) → (1, 1) → (1, 2) → (2, 2) → (3, 2) → (3, 3), totaling 6 steps.","solution":"from collections import deque def find_shortest_path(grid, start, target): Computes the shortest path from start to target in a grid with obstacles. Args: grid (list[list[int]]): A 2D list where 0 represents walkable space and 1 represents obstacle. start (tuple[int, int]): Starting position (row, col). target (tuple[int, int]): Target position (row, col). Returns: int: The shortest distance from start to target or -1 if no path exists. if start == target: return 0 if grid[start[0]][start[1]] == 1 or grid[target[0]][target[1]] == 1: return -1 rows, cols = len(grid), len(grid[0]) directions = [(1, 0), (0, 1), (0, -1), (-1, 0)] visited = set() queue = deque([(start[0], start[1], 0)]) # (current_row, current_col, current_distance) while queue: row, col, dist = queue.popleft() if (row, col) == target: return dist for dr, dc in directions: new_row, new_col = row + dr, col + dc if (0 <= new_row < rows and 0 <= new_col < cols and grid[new_row][new_col] == 0 and (new_row, new_col) not in visited): visited.add((new_row, new_col)) queue.append((new_row, new_col, dist + 1)) return -1"},{"question":"Question: In this task, you are required to implement a function to compute the Fibonacci sequence up to the n-th term. This exercise is intended to evaluate your comprehension and ability to handle the recursive and iterative approaches commonly used in dynamic programming. # Requirements: 1. **Function**: `def fibonacci(n: int) -> list[int]:` 2. **Input**: * An integer `n`, representing the number of terms of the Fibonacci sequence to compute, e.g., `5`. 3. **Output**: * A list of the first `n` terms of the Fibonacci sequence. 4. **Constraints**: * The input `n` is a non-negative integer. * For `n == 0`, the output should be an empty list. * The function should handle inputs up to `n = 30`. 5. **Performance**: * Target O(n) time complexity using an iterative approach. * O(n) additional space to store the output list. # Scenario: You are developing a module for a numerical library, and your task is to provide an efficient way to compute and return the first `n` terms of the Fibonacci sequence. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. # Example: Input: `5` Output: `[0, 1, 1, 2, 3]` # Edge Cases to Consider: * When `n = 1`, the output should be `[0]`. * When `n = 0`, the output should be `[]`. * Ensure the function correctly handles larger values of `n` up to `30`. # Additional Tests: Make sure your implementation passes the expected outputs for the following scenarios: 1. Input: `0` Output: `[]` 2. Input: `1` Output: `[0]` 3. Input: `10` Output: `[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]` # Instructions: * Implement your solution in Python. * Ensure your code is well-structured and includes necessary comments for clarity. * Test your solution against multiple test cases to verify correctness. ```python def fibonacci(n: int) -> list[int]: if n == 0: return [] elif n == 1: return [0] fib_list = [0, 1] for i in range(2, n): next_fib = fib_list[-1] + fib_list[-2] fib_list.append(next_fib) return fib_list # Test Cases print(fibonacci(5)) # [0, 1, 1, 2, 3] print(fibonacci(0)) # [] print(fibonacci(1)) # [0] print(fibonacci(10)) # [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] ```","solution":"def fibonacci(n: int) -> list[int]: Compute the first n terms of the Fibonacci sequence. Args: n : int : the number of terms to compute in the Fibonacci sequence Returns: list[int] : list containing the first n terms of the Fibonacci sequence if n == 0: return [] elif n == 1: return [0] fib_list = [0, 1] for i in range(2, n): next_fib = fib_list[-1] + fib_list[-2] fib_list.append(next_fib) return fib_list"},{"question":"# Coding Assessment Question **Balancing the Rotational String** You are given a string ( s ) composed of lowercase English letters. Two strings ( s1 ) and ( s2 ) derived from ( s ) are considered rotationally balanced if one string can be rotated some number of positions to the right (or left) to become equal to the other. Implement the function `is_rotationally_balanced(s1: str, s2: str) -> bool` that takes two strings ( s1 ) and ( s2 ), and checks if they are rotationally balanced. Input * Two strings ( s1 ) and ( s2 ), both of length ( n ) such that ( (1 leq n leq 100) ). Output * A boolean value `True` if the strings are rotationally balanced, otherwise `False`. Examples 1. **Input**: `is_rotationally_balanced(\\"abcde\\", \\"cdeab\\")` **Output**: `True` 2. **Input**: `is_rotationally_balanced(\\"abc\\", \\"cab\\")` **Output**: `True` 3. **Input**: `is_rotationally_balanced(\\"abc\\", \\"bac\\")` **Output**: `False` Ensure your implementation efficiently checks for rotational balance and handles edge cases.","solution":"def is_rotationally_balanced(s1, s2): Returns True if s1 and s2 are rotationally balanced, False otherwise. if len(s1) != len(s2): return False return s2 in s1 + s1"},{"question":"# Context You are developing a software system for a customer service center to analyze call durations and identify peak usage times. The calls are logged as start and end times throughout the day, and you need to determine the maximum number of concurrent calls that occurred at any given point in time. # Task Write a Python function that takes as input a list of call start and end times and calculates the maximum number of concurrent calls. # Function Signature ```python def max_concurrent_calls(calls: list[tuple[int, int]]) -> int: pass ``` # Input - `calls` (list of tuples): Each tuple contains two integers representing the start and end times of a call (in minutes from the beginning of the day). # Output - (int): The maximum number of concurrent calls at any time. # Constraints - The length of `calls` will be at least 1 and at most 1000. - Each tuple in `calls` will have the form `(start, end)` where `0 <= start < end <= 1440` (since there are 1440 minutes in a day). - Calls do not overlap at the exact start and end times. # Example ```python calls = [(30, 150), (120, 270), (240, 360), (300, 420)] expected_output = 2 assert max_concurrent_calls(calls) == expected_output calls = [(0, 60), (30, 90), (60, 120)] expected_output = 2 assert max_concurrent_calls(calls) == expected_output ``` # Explanation In the first example, the maximum number of concurrent calls occurs between the times 120 and 150, and there are 2 calls active during that period. In the second example, the maximum number of concurrent calls occurs between the times 30 and 60, and there are 2 calls active during that period.","solution":"def max_concurrent_calls(calls: list[tuple[int, int]]) -> int: events = [] for start, end in calls: events.append((start, \'start\')) events.append((end, \'end\')) events.sort() max_concurrent = 0 current_concurrent = 0 for time, event_type in events: if event_type == \'start\': current_concurrent += 1 max_concurrent = max(max_concurrent, current_concurrent) elif event_type == \'end\': current_concurrent -= 1 return max_concurrent"},{"question":"# Scenario You are a software engineer tasked with designing a feature for an e-commerce application that recommends relevant products to users based on their purchase history. The purchase history is represented as a list of transactions, where each transaction is a list of product IDs purchased together. Your task is to implement a function that finds the product that is most frequently purchased with a given product. # Task Write a function `most_frequent_pair(transactions: List[List[int]], product_id: int) -> int` that returns the product ID that appears most frequently in the same transaction as the given `product_id`. If there are multiple products with the same highest frequency, return the smallest product ID among them. If the `product_id` does not appear in any transaction, return -1. # Input Format * `transactions`: A list of lists, where each inner list contains integers representing product IDs purchased together in a single transaction. * `product_id`: An integer representing the product ID of interest. # Output Format * Return an integer representing the product ID that is most frequently purchased with the given `product_id`. If the `product_id` does not appear in any transaction, return -1. # Constraints * The transactions list contains at most (10^4) transactions. * Each inner list contains at most (10^2) product IDs. * Each product ID is a positive integer that does not exceed (10^5). # Example ```python transactions = [ [1, 2, 3], [2, 3, 4], [1, 2], [1, 3, 4, 2], [2, 4] ] product_id = 2 print(most_frequent_pair(transactions, product_id)) # Output: 1 ```","solution":"from collections import defaultdict from typing import List def most_frequent_pair(transactions: List[List[int]], product_id: int) -> int: Returns the product ID that appears most frequently in the same transaction as the given product_id. If there are multiple products with the same highest frequency, returns the smallest product ID among them. If the product_id does not appear in any transaction, returns -1. if not transactions: return -1 freq = defaultdict(int) for transaction in transactions: if product_id in transaction: for pid in transaction: if pid != product_id: freq[pid] += 1 if not freq: return -1 max_freq = max(freq.values()) candidates = [pid for pid, count in freq.items() if count == max_freq] return min(candidates)"},{"question":"# Problem Statement: You are given a list of integers `nums`, your task is to write a function that returns the number of unique pairs `(i, j)` such that `nums[i] + nums[j]` is equal to a given target `k`. # Function Signature: ```python def count_pairs_with_sum(nums: List[int], target: int) -> int: ``` # Input * `nums`: A list of integers `nums` where `1 <= len(nums) <= 1000` and `-1000 <= nums[i] <= 1000`. * `target`: An integer `k` where `-2000 <= k <= 2000`. # Output * Return an integer representing the number of unique pairs `(i, j)` such that `nums[i] + nums[j] == target`. # Constraints - Each pair `(i, j)` should be unique based on their positions in the list. - `i` should not be equal to `j`. # Example ```python assert count_pairs_with_sum([1, 1, 1, 1], 2) == 6 assert count_pairs_with_sum([1, 2, 3, 4], 5) == 2 assert count_pairs_with_sum([1, -1, 2, -2, 3, -3], 0) == 3 assert count_pairs_with_sum([0, 0, 0, 0], 0) == 6 assert count_pairs_with_sum([1, 2, 3], 7) == 0 ``` # Explanation of Examples - In the first case, the pairs that sum up to 2 are: `(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)`, hence the count is 6. - In the second case, the pairs that sum up to 5 are: `(0, 3), (1, 2)`, hence the count is 2. - In the third case, the pairs that sum up to 0 are: `(0, 1), (2, 3), (4, 5)`, hence the count is 3. - In the fourth case, the pairs that sum up to 0 are: `(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3)`, hence the count is 6. - In the fifth case, there are no pairs that sum up to 7, hence the count is 0. # Performance Requirements * The solution should efficiently find and count the pairs within the given constraints.","solution":"from typing import List def count_pairs_with_sum(nums: List[int], target: int) -> int: Returns the number of unique pairs (i, j) such that nums[i] + nums[j] == target. count = 0 seen = {} for i in range(len(nums)): diff = target - nums[i] if diff in seen: count += seen[diff] if nums[i] in seen: seen[nums[i]] += 1 else: seen[nums[i]] = 1 return count"},{"question":"# Coding Question: Implement a Custom Infix to Postfix Expression Converter In this task, you will implement a function to convert an infix mathematical expression to a postfix expression. This process involves understanding the precedence of operators and using a stack to ensure the operators are placed in the correct order in the resulting postfix expression. Function Signature: ```python def infix_to_postfix(expression: str) -> str: pass ``` # Input: - **expression**: A string representing an infix mathematical expression. The expression will only contain single-digit operands (0-9) and operators (+, -, *, /, ^), parentheses are also included. # Output: - A string representing the equivalent postfix expression. # Constraints: - The input string will have a length `n` (1 <= n <= 100). - The expression will be properly balanced and valid, containing no whitespace. # Examples: 1. **Input**: ```python expression = \\"3+5*2/(7-2)\\" ``` **Output**: ```python \\"352*72-/+\\" ``` 2. **Input**: ```python expression = \\"8+(2*5)/(1+3)-7\\" ``` **Output**: ```python \\"825*13+/+7-\\" ``` # Explanation: In the first example, the postfix expression is obtained by adhering to the operator precedence: 1. `3` followed by `5` and `2` due to multiplication. 2. Dividing the result of the multiplication by `7-2` which is computed first due to parentheses. 3. Finally, adding `3` after the division result. In the second example, `8` is added to the result of the division of `2*5` by `1+3` first due to parentheses and operator precedence. Lastly, subtracting `7`. # Notes: Ensure that your implementation correctly: - Accounts for operator precedence and associativity. - Uses parentheses to reflect the intended order of operations. - Handles expressions with all combinations of the supported operators. - Manages edge cases where expression length is minimal (e.g., a single operand). Return the resulting postfix expression as a string.","solution":"def infix_to_postfix(expression: str) -> str: Converts an infix expression to a postfix expression. prec = {\'^\': 4, \'*\': 3, \'/\': 3, \'+\': 2, \'-\': 2, \'(\': 1} # Operator precedence op_stack = [] # Stack to hold operators postfix_list = [] # List for the final postfix expression tokens = list(expression) # Tokenize the input expression for token in tokens: if token.isnumeric(): # If the token is an operand, add it to the output list postfix_list.append(token) elif token == \'(\': # If the token is \'(\', push it to the stack op_stack.append(token) elif token == \')\': # If the token is \')\', pop and output from the stack until \'(\' is found top_token = op_stack.pop() while top_token != \'(\': postfix_list.append(top_token) top_token = op_stack.pop() else: # The token is an operator while (op_stack) and (prec[op_stack[-1]] >= prec[token]): postfix_list.append(op_stack.pop()) op_stack.append(token) # Pop all the remaining operators in the stack while op_stack: postfix_list.append(op_stack.pop()) return \'\'.join(postfix_list)"},{"question":"# Matrix Transposition Objective Implement a function to transpose a given square matrix, testing your understanding of matrix operations and your ability to manipulate 2D arrays in Python. Function Signature ```python def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: pass ``` Inputs - `matrix` (List[List[int]]): A 2D list representing a square matrix of integers. The matrix dimensions will be `n x n`, where `1 ≤ n ≤ 100`. Outputs - A 2D list representing the transposed matrix. Constraints - The input matrix will always be a valid, non-empty square matrix (meaning the number of rows will be equal to the number of columns). Example ```python matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(transpose_matrix(matrix)) # Output: # [ # [1, 4, 7], # [2, 5, 8], # [3, 6, 9] # ] matrix = [ [1, 2], [3, 4] ] print(transpose_matrix(matrix)) # Output: # [ # [1, 3], # [2, 4] # ] ``` Scenario You are developing a spreadsheet application that involves multiple matrix operations, one of which is transposing matrices to change their orientation. Implement the `transpose_matrix` function to accomplish this task accurately.","solution":"from typing import List def transpose_matrix(matrix: List[List[int]]) -> List[List[int]]: Transposes the given square matrix. Parameters: matrix (List[List[int]]): A 2D list representing a square matrix of integers. Returns: List[List[int]]: A 2D list representing the transposed matrix. n = len(matrix) transposed = [[None] * n for _ in range(n)] for i in range(n): for j in range(n): transposed[j][i] = matrix[i][j] return transposed"},{"question":"# Problem Description Write a function that computes the longest common subsequence (LCS) for two sequences. The LCS of two sequences is the longest sequence that can be derived from both input sequences by deleting some elements (while maintaining the order). Function: Longest Common Subsequence Implement `longest_common_subsequence(seq1: Sequence[Any], seq2: Sequence[Any]) -> Sequence[Any]`: * **Input**: - `seq1`: The first sequence of elements. It can contain any hashable type. - `seq2`: The second sequence of elements. It can contain any hashable type. * **Output**: A sequence representing the longest common subsequence of `seq1` and `seq2`. # Constraints 1. The length of `seq1` and `seq2` will be between 1 and 1000. 2. The elements of `seq1` and `seq2` will be hashable types. # Performance Requirements The function should run efficiently with a time complexity of O(n * m), where n is the length of `seq1` and m is the length of `seq2`. # Example ```python seq1 = [\'A\', \'B\', \'C\', \'D\', \'G\', \'H\'] seq2 = [\'A\', \'E\', \'D\', \'F\', \'H\', \'R\'] assert longest_common_subsequence(seq1, seq2) == [\'A\', \'D\', \'H\'] seq1 = [1, 3, 4, 1, 2, 1, 5] seq2 = [3, 4, 1, 2, 1, 5] assert longest_common_subsequence(seq1, seq2) == [3, 4, 1, 2, 1, 5] seq1 = [\'X\', \'Y\', \'Z\'] seq2 = [\'A\', \'X\', \'B\', \'Y\', \'C\', \'Z\'] assert longest_common_subsequence(seq1, seq2) == [\'X\', \'Y\', \'Z\'] ``` Your task is to implement the function that returns the longest common subsequence for the given input sequences.","solution":"def longest_common_subsequence(seq1, seq2): Computes the longest common subsequence of two sequences. Args: seq1: The first sequence. seq2: The second sequence. Returns: A sequence representing the longest common subsequence of seq1 and seq2. n = len(seq1) m = len(seq2) # Initialize the dp table dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp table for i in range(1, n + 1): for j in range(1, m + 1): if seq1[i - 1] == seq2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence lcs = [] i, j = n, m while i > 0 and j > 0: if seq1[i - 1] == seq2[j - 1]: lcs.append(seq1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 # Reverse the lcs since we constructed it backwards lcs.reverse() return lcs"},{"question":"Question: Binary Search Tree Traversal Implement different traversal methods for a Binary Search Tree (BST). This question will test your understanding of tree data structures, recursion, and depth-first searching techniques. # Task Write a class `BSTNode` to represent a node in the BST and a class `BinarySearchTree` to represent the BST itself. Implement the following traversal methods in the `BinarySearchTree` class: 1. **In-order Traversal**: Traverse the left subtree, visit the node, and then traverse the right subtree. ```python def inorder_traversal(self) -> List[int]: pass ``` 2. **Pre-order Traversal**: Visit the node, traverse the left subtree, and then traverse the right subtree. ```python def preorder_traversal(self) -> List[int]: pass ``` 3. **Post-order Traversal**: Traverse the left subtree, traverse the right subtree, and then visit the node. ```python def postorder_traversal(self) -> List[int]: pass ``` # Input & Output Specifications: - Implement the `BSTNode` and `BinarySearchTree` classes to allow insertion of nodes and performing the required traversals. - The `BSTNode` class will only contain an integer value. - Traverse methods will return a list of integers representing the node values in traversal order. # Detailed Requirements BSTNode Class: ```python class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None ``` BinarySearchTree Class: ```python class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): pass def inorder_traversal(self) -> List[int]: pass def preorder_traversal(self) -> List[int]: pass def postorder_traversal(self) -> List[int]: pass ``` # Example Usage: ```python bst = BinarySearchTree() bst.insert(5) bst.insert(3) bst.insert(7) bst.insert(2) bst.insert(4) bst.insert(6) bst.insert(8) print(bst.inorder_traversal()) # Output: [2, 3, 4, 5, 6, 7, 8] print(bst.preorder_traversal()) # Output: [5, 3, 2, 4, 7, 6, 8] print(bst.postorder_traversal()) # Output: [2, 4, 3, 6, 8, 7, 5] ``` # Constraints: - All values inserted into the BST will be distinct integers. - The BST may contain at most 1000 nodes. # Performance Requirements: Ensure the implementation is efficient and handles up to 1000 nodes with traversal operations running in O(n) time complexity where n is the number of nodes in the tree.","solution":"class BSTNode: def __init__(self, value: int): self.value = value self.left = None self.right = None class BinarySearchTree: def __init__(self): self.root = None def insert(self, value: int): if self.root is None: self.root = BSTNode(value) else: self._insert_recursive(self.root, value) def _insert_recursive(self, node, value): if value < node.value: if node.left is None: node.left = BSTNode(value) else: self._insert_recursive(node.left, value) else: if node.right is None: node.right = BSTNode(value) else: self._insert_recursive(node.right, value) def inorder_traversal(self): result = [] self._inorder_traverse(self.root, result) return result def _inorder_traverse(self, node, result): if node: self._inorder_traverse(node.left, result) result.append(node.value) self._inorder_traverse(node.right, result) def preorder_traversal(self): result = [] self._preorder_traverse(self.root, result) return result def _preorder_traverse(self, node, result): if node: result.append(node.value) self._preorder_traverse(node.left, result) self._preorder_traverse(node.right, result) def postorder_traversal(self): result = [] self._postorder_traverse(self.root, result) return result def _postorder_traverse(self, node, result): if node: self._postorder_traverse(node.left, result) self._postorder_traverse(node.right, result) result.append(node.value)"},{"question":"# Graph Traversal and Shortest Path Coding Challenge **Context**: You are working as a software developer at a logistics company. One of your tasks is to improve the efficiency of the delivery routing system to ensure packages are delivered in the shortest time possible. To achieve this, you need to implement a function that calculates the shortest path between two nodes in a weighted graph using Dijkstra\'s algorithm. **Requirements**: 1. Implement the `dijkstra_shortest_path` function. 2. The function should compute the shortest path from a starting node to a target node in a given weighted graph. 3. Ensure the implementation handles edge cases efficiently (e.g., non-existent nodes, graphs with negative weights). **Function Signature**: ```python def dijkstra_shortest_path(graph: dict, start: str, target: str) -> (list, int): pass ``` **Input**: - `graph`: A dictionary representing the weighted graph, where keys are node labels and values are dictionaries of neighboring node labels and their associated weights. - `start`: A string representing the starting node. - `target`: A string representing the target node. **Output**: - Returns a tuple containing two elements: 1. A list of nodes representing the shortest path from the start node to the target node. 2. An integer representing the total weight of the shortest path. **Constraints**: - The graph is directed and weighted. - Node labels are strings. - Weights are non-negative integers. **Examples**: ```python # Example 1 graph = { \'A\': {\'B\': 1, \'C\': 4}, \'B\': {\'C\': 2, \'D\': 5}, \'C\': {\'D\': 1}, \'D\': {} } assert dijkstra_shortest_path(graph, \'A\', \'D\') == ([\'A\', \'B\', \'C\', \'D\'], 4) # Example 2 graph = { \'A\': {\'B\': 2}, \'B\': {\'C\': 1}, \'C\': {\'A\': 10} } assert dijkstra_shortest_path(graph, \'A\', \'C\') == ([\'A\', \'B\', \'C\'], 3) # Example 3 graph = { \'A\': {}, \'B\': {\'A\': 1} } assert dijkstra_shortest_path(graph, \'B\', \'A\') == ([\'B\', \'A\'], 1) # Example 4 graph = { \'A\': {\'B\': 6}, \'B\': {\'C\': 5}, \'C\': {\'A\': 4} } assert dijkstra_shortest_path(graph, \'A\', \'C\') == ([\'A\', \'B\', \'C\'], 11) ``` **Performance Note**: Your function should maintain an efficient time complexity suitable for large graphs. **Hints**: 1. Consider using a priority queue to manage the exploration of nodes. 2. Ensure you keep track of the shortest path to each node to avoid unnecessary computations. Good luck with your implementation and optimization!","solution":"import heapq def dijkstra_shortest_path(graph, start, target): Implements Dijkstra\'s algorithm to find the shortest path from start to target in a weighted graph. Parameters: - graph: A dictionary representing the weighted graph, where keys are node labels and values are dictionaries of neighboring node labels and their associated weights. - start: A string representing the starting node. - target: A string representing the target node. Returns: - A tuple containing two elements: 1. A list of nodes representing the shortest path from the start node to the target node. 2. An integer representing the total weight of the shortest path. # Priority queue to manage exploration of nodes pq = [(0, start, [])] visited = set() while pq: (current_distance, current_node, path) = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) path = path + [current_node] if current_node == target: return (path, current_distance) for neighbor, weight in graph.get(current_node, {}).items(): if neighbor not in visited: heapq.heappush(pq, (current_distance + weight, neighbor, path)) return ([], float(\'inf\'))"},{"question":"# Dynamic Array Rotation Problem You are given an array of integers and a number of positions to rotate the array. The task is to implement the function `rotate_array` that rotates the elements of the array to the right by the given number of positions and returns the rotated array. Function Signature ```python def rotate_array(arr: List[int], positions: int) -> List[int]: ``` Input - `arr` (List[int]): An array of integers. (0 ≤ length of arr ≤ 10^5) - `positions` (int): The number of positions to rotate the array. (0 ≤ positions ≤ 10^5) Output - Returns a new list of integers that represents the rotated array. Constraints - If `positions` value is negative, raise a `ValueError` with the message \\"The number of positions to rotate cannot be negative\\". - If the array `arr` is empty or `positions` is zero, return the original array. Examples ```python # Example 1 assert rotate_array([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3] # Example 2 assert rotate_array([10, 20, 30, 40, 50], 3) == [30, 40, 50, 10, 20] # Example 3 assert rotate_array([7, 8, 9], 1) == [9, 7, 8] # Example 4 assert rotate_array([1, 2, 3], 0) == [1, 2, 3] # Example 5 assert rotate_array([], 3) == [] try: rotate_array([1, 2, 3], -1) except ValueError as e: assert str(e) == \\"The number of positions to rotate cannot be negative\\" ``` Detailed Explanation 1. **Validation**: - Check whether `positions` is non-negative. - If the `positions` is negative, raise a `ValueError`. 2. **Edge Cases**: - If the array is empty or `positions` value is zero, return the original array. 3. **Rotation Calculation**: - Compute the actual number of positions by taking `positions % len(arr)` which handles rotation greater than array length. - Slice the array to get the rotated result. 4. **Return**: - Return the rotated array. Provide a robust implementation of the function `rotate_array` following these guidelines and ensuring that all edge cases are handled properly.","solution":"from typing import List def rotate_array(arr: List[int], positions: int) -> List[int]: Rotates the elements of the array to the right by the given number of positions. if positions < 0: raise ValueError(\\"The number of positions to rotate cannot be negative\\") if not arr or positions == 0: return arr n = len(arr) positions = positions % n # Normalize positions if greater than array length return arr[-positions:] + arr[:-positions]"},{"question":"# Question Prompt Create a function called `analyze_review_scores` that processes a list of product reviews to evaluate the overall sentiment score for each product. Reviews are scored between 0 (very negative) and 5 (very positive), and each product can have multiple reviews. The function should return a dictionary with products as keys and their average review scores as values. Expected Input and Output - **Input**: `reviews` - A dictionary where keys are product names (strings) and values are lists of review scores (integers between 0 and 5). - **Output**: A dictionary with product names as keys and their average review score (float, rounded to 2 decimal places) as values. Example ```python input_reviews = { \\"ProductA\\": [4, 5, 3, 4], \\"ProductB\\": [2, 2, 3], \\"ProductC\\": [5, 4, 4, 5, 5] } # Expected output { \\"ProductA\\": 4.00, \\"ProductB\\": 2.33, \\"ProductC\\": 4.60 } ``` Constraints and Limitations - All review scores are within the valid range (0-5). - Each product will have at least one review. - The number of products should not exceed 1000. - The total number of reviews across all products should not exceed 10,000. ```python def analyze_review_scores(reviews: dict) -> dict: This function takes a dictionary of product reviews and returns a dictionary containing the average sentiment score for each product. average_scores = {} for product, scores in reviews.items(): if not scores: continue average_score = sum(scores) / len(scores) average_scores[product] = round(average_score, 2) return average_scores # Example usage: input_reviews = { \\"ProductA\\": [4, 5, 3, 4], \\"ProductB\\": [2, 2, 3], \\"ProductC\\": [5, 4, 4, 5, 5] } print(analyze_review_scores(input_reviews)) # Output: {\'ProductA\': 4.0, \'ProductB\': 2.33, \'ProductC\': 4.6} ``` # Objectives: 1. Correctly compute the average review score for each product. 2. Ensure the result is accurate and rounded to 2 decimal places. 3. Efficiently handle a large list of reviews while meeting the constraints.","solution":"def analyze_review_scores(reviews: dict) -> dict: This function takes a dictionary of product reviews and returns a dictionary containing the average sentiment score for each product. average_scores = {} for product, scores in reviews.items(): if not scores: continue average_score = sum(scores) / len(scores) average_scores[product] = round(average_score, 2) return average_scores"},{"question":"# Problem Description You are tasked with implementing a function to determine if a given string is a cyclic permutation of another string. Two strings are cyclic permutations of each other if one can be obtained by rotating the other. For example, \\"abcd\\" and \\"dabc\\" are cyclic permutations. # Function Specifications Function Name ```python def are_cyclic_permutations(str1: str, str2: str) -> bool ``` Input - `str1` (str): The first string to check. Constraints: 1 ≤ len(str1) ≤ 10^5. - `str2` (str): The second string to check. Constraints: 1 ≤ len(str2) ≤ 10^5. Output - Returns a boolean value: `True` if `str1` and `str2` are cyclic permutations of each other, otherwise `False`. Error Handling - If either `str1` or `str2` is an empty string, the function should return `False`. # Constraints 1. The function should be efficient given the constraint size. 2. Handle edge cases such as different lengths of strings or empty strings. # Example ```python # Examples of calling are_cyclic_permutations(str1, str2) assert are_cyclic_permutations(\\"abcd\\", \\"dabc\\") == True assert are_cyclic_permutations(\\"abc\\", \\"cab\\") == True assert are_cyclic_permutations(\\"abc\\", \\"acb\\") == False assert are_cyclic_permutations(\\"abc\\", \\"\\") == False assert are_cyclic_permutations(\\"\\", \\"abc\\") == False assert are_cyclic_permutations(\\"abc\\", \\"abcd\\") == False ``` # Notes 1. Ensure the function is optimized for both time and space requirements. 2. Check that the function can handle strings of up to length 100,000 efficiently. 3. Test the function thoroughly with edge cases like empty strings and different string lengths.","solution":"def are_cyclic_permutations(str1: str, str2: str) -> bool: Determines if one string is a cyclic permutation of another. Parameters: - str1: The first string. - str2: The second string. Returns: - True if str1 and str2 are cyclic permutations of each other, otherwise False. # Check if lengths are different if len(str1) != len(str2): return False # Check for empty strings if not str1 or not str2: return False # Concatenate str1 with itself and check if str2 is a substring double_str1 = str1 + str1 return str2 in double_str1"},{"question":"# Question You are given an array of integers representing the output of a discrete signal processing system. Your task is to implement a function `find_longest_constant_segment` which finds the longest subarray where all elements are the same. If there are multiple subarrays with the same longest length, return the starting index of the first one. Function Signature ```python def find_longest_constant_segment(arr: list[int]) -> tuple[int, int]: pass ``` Input * `arr` (list[int]): A list of integers where `1 ≤ len(arr) ≤ 10^6` and `-10^9 ≤ arr[i] ≤ 10^9` for 0 ≤ i < len(arr). Output * `tuple[int, int]`: A tuple containing two integers: - The starting index of the longest subarray where all elements are the same. - The length of this subarray. Constraints - The input array is non-empty and contains at least one element. - If the array contains multiple longest constant segments, return the first one. Examples 1. `find_longest_constant_segment([1, 2, 2, 2, 3, 3, 3, 3, 1, 1])` should return `(4, 4)`, because the longest subarray with all identical elements is `[3, 3, 3, 3]` starting at index 4. 2. `find_longest_constant_segment([7, 7, 7, 6, 6, 6, 6, 5, 5])` should return `(3, 4)`, since `[6, 6, 6, 6]` is the longest segment starting at index 3. 3. `find_longest_constant_segment([1, 2, 3, 4, 5])` should return `(0, 1)`, since all elements are unique and the longest constant segment is any single element. Requirements - You should implement the function in an efficient manner that handles the input size constraints within reasonable limits. - Avoid unnecessary computations and ensure the solution covers edge cases such as single element arrays and arrays with uniform values.","solution":"def find_longest_constant_segment(arr: list[int]) -> tuple[int, int]: if not arr: return (0, 0) max_len = 1 max_start_index = 0 current_len = 1 current_start_index = 0 for i in range(1, len(arr)): if arr[i] == arr[i-1]: current_len += 1 else: if current_len > max_len: max_len = current_len max_start_index = current_start_index current_len = 1 current_start_index = i # Check the last segment if current_len > max_len: max_len = current_len max_start_index = current_start_index return (max_start_index, max_len)"},{"question":"# Problem Statement You have been recruited to build a simple text-processing utility for a word game application. One of the requirements is to implement a function that finds the longest palindrome substring within any given string. Objective Write a `Longest Palindromic Substring Finder` function `longest_palindrome_substring(s: str) -> str` that returns the longest palindromic substring within the input string `s`. Input * `s`: A string consisting of lowercase and uppercase English letters. Output * A string representing the longest palindromic substring found within the input string. Constraints * The length of `s` is between 1 and 10^3 inclusive. * The solution should handle the upper limit constraints efficiently. Requirements 1. Implement `longest_palindrome_substring` to find the longest palindromic substring within the given string. 2. Ensure the solution has a polynomial time complexity but optimized to handle up to the maximum constraint efficiently. # Example ```python longest_palindrome_substring(\\"babad\\") # Output: \\"bab\\" or \\"aba\\" (since both are valid palindromic substrings of the same length) longest_palindrome_substring(\\"cbbd\\") # Output: \\"bb\\" longest_palindrome_substring(\\"a\\") # Output: \\"a\\" longest_palindrome_substring(\\"ac\\") # Output: \\"a\\" or \\"c\\" (either single character is valid as there are no longer palindromes) ```","solution":"def longest_palindrome_substring(s: str) -> str: Finds the longest palindromic substring in the provided string. if len(s) == 0: return \\"\\" start, max_len = 0, 1 def expand_around_center(left: int, right: int): nonlocal start, max_len while left >= 0 and right < len(s) and s[left] == s[right]: current_len = right - left + 1 if current_len > max_len: start = left max_len = current_len left -= 1 right += 1 for i in range(len(s)): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return s[start:start + max_len]"},{"question":"# Coding Question You have been assigned to simulate a basic library management system. The system maintains records of books and allows users to lend and return books. You need to implement functionalities to add books to the library, lend books to users, and return books back to the library. Objective Implement a class `Library` with the following functionalities: 1. **Initialization and Book Management**: - The `Library` class should be initialized with an empty dictionary to store books. - Implement a method `add_book(title: str, author: str, quantity: int) -> None` to add books to the library. If the book already exists, increment its quantity. 2. **Lend and Return Books**: - Implement a method `lend_book(title: str, user: str) -> str`: - If the book is available, lend it to the user and return a success message. - If the book is not available or does not exist, return an appropriate error message. - Implement a method `return_book(title: str, user: str) -> str`: - If the user has borrowed the book, return it to the library and return a success message. - If the user has not borrowed the book or the book does not exist, return an appropriate error message. 3. **Track Book Lending**: - Maintain a dictionary to track which user has borrowed which book. - Ensure that users cannot borrow the same book multiple times without returning it first. Class Implementation - **Library** - `add_book(title: str, author: str, quantity: int) -> None`: - Add books to the library or increase the quantity of existing books. - `lend_book(title: str, user: str) -> str`: - Lend the specified book to the user. - `return_book(title: str, user: str) -> str`: - Return the specified book from the user. Example ```python >>> library = Library() >>> library.add_book(\\"1984\\", \\"George Orwell\\", 3) >>> library.add_book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", 2) >>> print(library.lend_book(\\"1984\\", \\"Alice\\")) \'Book \\"1984\\" has been lent to Alice.\' >>> print(library.lend_book(\\"1984\\", \\"Bob\\")) \'Book \\"1984\\" has been lent to Bob.\' >>> print(library.return_book(\\"1984\\", \\"Alice\\")) \'Book \\"1984\\" has been returned by Alice.\' >>> print(library.lend_book(\\"1984\\", \\"Alice\\")) \'Book \\"1984\\" has been lent to Alice.\' >>> print(library.lend_book(\\"1984\\", \\"Charlie\\")) \'Book \\"1984\\" is currently not available.\' >>> print(library.return_book(\\"1984\\", \\"Charlie\\")) \'User Charlie has not borrowed book \\"1984\\".\' >>> print(library.lend_book(\\"The Great Gatsby\\", \\"Alice\\")) \'Book \\"The Great Gatsby\\" does not exist in the library.\' ``` Implement the `Library` class and its methods according to the specifications.","solution":"class Library: def __init__(self): self.books = {} self.lent_books = {} def add_book(self, title: str, author: str, quantity: int) -> None: if title in self.books: self.books[title][\'quantity\'] += quantity else: self.books[title] = { \'author\': author, \'quantity\': quantity } def lend_book(self, title: str, user: str) -> str: if title not in self.books: return f\'Book \\"{title}\\" does not exist in the library.\' if self.books[title][\'quantity\'] == 0: return f\'Book \\"{title}\\" is currently not available.\' if title in self.lent_books and user in self.lent_books[title]: return f\'User {user} already borrowed book \\"{title}\\".\' self.books[title][\'quantity\'] -= 1 if title not in self.lent_books: self.lent_books[title] = [] self.lent_books[title].append(user) return f\'Book \\"{title}\\" has been lent to {user}.\' def return_book(self, title: str, user: str) -> str: if title not in self.lent_books or user not in self.lent_books[title]: return f\'User {user} has not borrowed book \\"{title}\\".\' self.lent_books[title].remove(user) if len(self.lent_books[title]) == 0: del self.lent_books[title] self.books[title][\'quantity\'] += 1 return f\'Book \\"{title}\\" has been returned by {user}.\'"},{"question":"# Bank Account System **Scenario**: You have been contracted by a bank to develop a system to manage customer accounts and process transactions. Your task is to create the foundational elements of this system, including account creation and transaction handling. **Requirements**: 1. Write a class `BankAccount` that allows for basic account operations. - The constructor `__init__(self, account_id: str, initial_balance: float = 0)` should initialize the account with a unique ID and an optional initial balance. - Implement a method `deposit(self, amount: float) -> float` that adds funds to the account and returns the new balance. - Implement a method `withdraw(self, amount: float) -> float` that subtracts funds from the account and returns the new balance. This method should raise an `InsufficientFundsException` if the withdrawal amount exceeds the current balance. - Implement a method `get_balance(self) -> float` that returns the current balance. 2. Write a custom exception class `InsufficientFundsException` that will be raised when attempting to withdraw more than the available balance. **Function Signatures**: ```python class InsufficientFundsException(Exception): pass class BankAccount: def __init__(self, account_id: str, initial_balance: float = 0): pass def deposit(self, amount: float) -> float: pass def withdraw(self, amount: float) -> float: pass def get_balance(self) -> float: pass ``` **Input/Output**: * `BankAccount` * **Constructor**: * **Input**: * A string `account_id` representing the unique ID of the bank account. * An optional float `initial_balance` representing the starting balance (defaults to 0). * **Output**: * Initializes the `BankAccount` object. * `deposit`: * **Input**: * A float `amount` representing the amount to be deposited. * **Output**: * Returns a float representing the new balance after the deposit. * `withdraw`: * **Input**: * A float `amount` representing the amount to be withdrawn. * **Output**: * Returns a float representing the new balance after the withdrawal. * **Exceptions**: * Raises `InsufficientFundsException` if the withdrawal amount exceeds the current balance. * `get_balance`: * **Input**: * No parameters. * **Output**: * Returns a float representing the current balance. **Constraints**: * The `account_id` is a unique identifier consisting of alphanumeric characters. * The `initial_balance` and `amount` are non-negative floats. * Ensure the methods handle edge cases, such as zero or negative amounts for transactions. **Example**: ```python >>> account = BankAccount(\'123ABC\', 100) >>> account.get_balance() 100.0 >>> account.deposit(50) 150.0 >>> account.withdraw(20) 130.0 >>> account.withdraw(200) # Raises InsufficientFundsException >>> account.get_balance() 130.0 ``` # Additional Notes: Your solution will be evaluated on correctness, design, efficiency, and adherence to best coding practices. Ensure to write clean and readable code with appropriate comments to explain your logic.","solution":"class InsufficientFundsException(Exception): pass class BankAccount: def __init__(self, account_id: str, initial_balance: float = 0): self.account_id = account_id self.balance = initial_balance def deposit(self, amount: float) -> float: if amount < 0: raise ValueError(\\"Amount to deposit should be non-negative\\") self.balance += amount return self.balance def withdraw(self, amount: float) -> float: if amount < 0: raise ValueError(\\"Amount to withdraw should be non-negative\\") if amount > self.balance: raise InsufficientFundsException(\\"Insufficient funds for withdrawal\\") self.balance -= amount return self.balance def get_balance(self) -> float: return self.balance"},{"question":"# Fibonacci Heap Implementation Implement a Fibonacci Heap and utilize it to perform specified operations efficiently. Fibonacci Heap is a data structure that combines the advantages of both binary heaps and binomial heaps. It allows for faster amortized time complexity for several operations compared to binary heaps. Class Signature: ```python class FibonacciHeap: def __init__(self): pass def insert(self, key: int) -> None: pass def extract_min(self) -> int: pass def decrease_key(self, node, new_key: int) -> None: pass def find_min(self) -> int: pass ``` # Requirements: 1. **Class Methods**: - `__init__()`: Initializes an empty Fibonacci Heap. - `insert(key: int) -> None`: Inserts a node with the given key into the heap. - `extract_min() -> int`: Removes and returns the minimum key from the heap. - `decrease_key(node, new_key: int) -> None`: Decreases the key of the given node to `new_key`. - `find_min() -> int`: Returns the minimum key in the heap without removing it. 2. **Constraints**: - When `insert(key: int)` is called, `key` must be an integer. - `decrease_key(node, new_key: int)` should not be called with a `new_key` that is greater than the current key of `node`. - Handle invalid inputs appropriately by raising exceptions. # Example: ```python heap = FibonacciHeap() heap.insert(5) heap.insert(2) heap.insert(8) print(heap.find_min()) # Output: 2 heap.insert(3) print(heap.find_min()) # Output: 2 min_key = heap.extract_min() print(min_key) # Output: 2 print(heap.find_min()) # Output: 3 ``` # Implementation Details: - Create a node structure to represent the elements in the Fibonacci Heap. - Implement the Fibonacci Heap properties, making sure to maintain the tree structure on insertion, extracting the minimum, and decreasing keys. - Aggregate trees of equal rank upon extracting the minimum to maintain the heap properties. Ensure all Fibonacci Heap operations follow their respective amortized time complexities: - Insertion: ( O(1) ) amortized. - Finding the minimum: ( O(1) ) worst-case. - Extracting the minimum: ( O(log n) ) amortized. - Decreasing key: ( O(1) ) amortized.","solution":"class Node: def __init__(self, key): self.key = key self.parent = None self.child = None self.left = self self.right = self self.degree = 0 self.marked = False class FibonacciHeap: def __init__(self): self.min_node = None self.total_nodes = 0 def insert(self, key: int) -> Node: node = Node(key) if self.min_node is None: self.min_node = node else: self._merge_into_root_list(node) if key < self.min_node.key: self.min_node = node self.total_nodes += 1 return node def extract_min(self) -> int: z = self.min_node if z is not None: if z.child is not None: children = [x for x in self._iterate(z.child)] for x in children: self._merge_into_root_list(x) x.parent = None self._remove_from_root_list(z) if z == z.right: self.min_node = None else: self.min_node = z.right self._consolidate() self.total_nodes -= 1 return z.key if z else None def decrease_key(self, node, new_key: int) -> None: if new_key > node.key: raise ValueError(\\"New key is greater than current key\\") node.key = new_key y = node.parent if y is not None and node.key < y.key: self._cut(node, y) self._cascading_cut(y) if node.key < self.min_node.key: self.min_node = node def find_min(self) -> int: return self.min_node.key if self.min_node else None def _merge_into_root_list(self, node: Node): if self.min_node is None: self.min_node = node else: node.left = self.min_node node.right = self.min_node.right self.min_node.right = node node.right.left = node def _remove_from_root_list(self, node: Node): if node.right == node: node.right = None node.left = None else: node.right.left = node.left node.left.right = node.right def _iterate(self, node: Node): current = node if current is not None: while True: yield current current = current.right if current == node: break def _consolidate(self): A = [None] * (self.total_nodes + 1) nodes = [w for w in self._iterate(self.min_node)] for w in nodes: x = w d = x.degree while A[d] is not None: y = A[d] if x.key > y.key: x, y = y, x self._link(y, x) A[d] = None d += 1 A[d] = x self.min_node = None for i in range(len(A)): if A[i] is not None: if self.min_node is None: self.min_node = A[i] else: self._merge_into_root_list(A[i]) if A[i].key < self.min_node.key: self.min_node = A[i] def _link(self, y: Node, x: Node): self._remove_from_root_list(y) y.left = y.right = y if x.child is None: x.child = y else: self._merge_into_child_list(x.child, y) y.parent = x x.degree += 1 y.marked = False def _merge_into_child_list(self, child: Node, node: Node): node.left = child node.right = child.right child.right = node node.right.left = node def _cut(self, x: Node, y: Node): self._remove_from_child_list(y, x) y.degree -= 1 self._merge_into_root_list(x) x.parent = None x.marked = False def _remove_from_child_list(self, parent: Node, node: Node): if node.right == node: parent.child = None else: node.right.left = node.left node.left.right = node.right if parent.child == node: parent.child = node.right def _cascading_cut(self, y: Node): z = y.parent if z is not None: if not y.marked: y.marked = True else: self._cut(y, z) self._cascading_cut(z)"},{"question":"# Coding Assessment Question **Context**: In a text processing system, you are building a feature to generate unique acronyms from phrases. An acronym is formed by taking the first letter of each word in a phrase and converting them to uppercase. **Objective**: Write a function `generate_acronym` that creates an acronym from a given phrase. **Function signature**: ```python def generate_acronym(phrase: str) -> str: pass ``` **Input**: * A single string `phrase` consisting of words separated by spaces. **Output**: * Return a string representing the acronym, formed by the first letter of each word in uppercase. **Constraints**: 1. The phrase will only contain alphabetic characters and spaces. 2. Words in the phrase are separated by single spaces. 3. The function should handle both lowercase and uppercase characters in the input phrase. **Example**: ```python >>> generate_acronym(\'Random Access Memory\') \'RAM\' >>> generate_acronym(\'as soon as possible\') \'ASAP\' >>> generate_acronym(\'you only live once\') \'YOLO\' ``` **Performance Requirements**: * Aim to iterate through the phrase only once (O(n) time complexity). * Minimize additional memory usage, ensuring space complexity is O(k), where k is the number of words. **Additional Information**: * Consider splitting the phrase by spaces to directly access each word. * Remember to convert each first letter to uppercase before forming the final acronym.","solution":"def generate_acronym(phrase: str) -> str: Generate an acronym from the given phrase by taking the first letter of each word and converting them to uppercase. Parameters: - phrase: str: A string consisting of words separated by spaces. Returns: - str: The acronym formed by the first letter of each word in uppercase. return \'\'.join(word[0].upper() for word in phrase.split())"},{"question":"# Problem Statement You have been given an array representing the heights of buildings in a city skyline, where each height is a positive integer. Each building is viewed from the left side, and your task is to calculate the \\"visibility score\\" for each building. The visibility score is defined as the number of buildings to the left of the current building (including itself) that are shorter than or equal to the height of the current building. Write a function `calculate_visibility(heights: List[int]) -> List[int]` that takes a list of integers representing building heights and returns a list of integers representing the visibility score of each building. Input * A list `heights` of `n` integers, where `height[i]` is the height of the building on the `i-th` position. (1 ≤ n ≤ 10^5, 1 ≤ height[i] ≤ 10^5) Output * A list `visibility` of `n` integers, where `visibility[i]` is the visibility score of the building in the `i-th` position. Example ``` Input: heights = [3, 1, 2, 5, 4] Output: [1, 1, 2, 4, 1] ``` In this example: - For the first building with height 3, there is no building to the left, so visibility = 1. - For the second building with height 1, it alone is visible, so visibility = 1. - For the third building with height 2, buildings with heights 1 (second) and 2 (itself) are visible, so visibility = 2. - For the fourth building with height 5, all previous buildings are shorter or equal, so visibility = 4. - For the fifth building with height 4, only the fourth building is taller, so visibility = 1. Constraints * You must achieve an `O(n)` time complexity. * Use of additional space is allowed, but focus on optimal usage. Implement the function `calculate_visibility(heights: List[int]) -> List[int]` that adheres to these requirements.","solution":"def calculate_visibility(heights): Calculate the visibility score for each building in the city skyline. The visibility score for each building is the count of buildings to the left (including itself) that are shorter than or equal to the height of the current building. :param List[int] heights: A list of integers representing building heights. :return List[int]: A list of integers representing the visibility score of each building. # Initialize an empty result list to store visibility scores visibility = [] # Stack to keep track of visible buildings\' heights and their counts stack = [] for height in heights: # Initialize visibility count for the current building current_visibility = 1 # Stack elements are (building height, visibility count of the height) while stack and stack[-1][0] <= height: current_visibility += stack.pop()[1] # Push the current building and its visibility count to the stack stack.append((height, current_visibility)) # Add the current visibility count to the result list visibility.append(current_visibility) return visibility"},{"question":"Problem: Implementing an Efficient Sieve of Eratosthenes # Scenario You are optimizing a software application for scientific computations involving prime numbers. One of the essential tasks is to efficiently generate a list of prime numbers. To achieve this, you need to implement an enhanced version of the Sieve of Eratosthenes algorithm with additional optimizations. # Task Write a function `optimized_sieve` that generates all prime numbers up to a given number ( n ) using the Sieve of Eratosthenes algorithm. Implement optimizations to reduce computational complexity and memory usage. # Function Signature ```python def optimized_sieve(n: int) -> list[int]: pass ``` # Input * `n` (int): The upper limit (inclusive) up to which prime numbers are to be generated. # Output * A list of prime numbers up to and including ( n ). # Constraints 1. ( 1 leq n leq 10^6 ). 2. The function should be optimized for both time and space complexity. # Example ```python n = 30 print(optimized_sieve(n)) # Output: [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Notes * Use efficient data structures to manage the sieve. * Implement techniques like skipping even numbers (except 2) to enhance performance. * Consider edge cases, such as very small values of ( n ). * Ensure your solution scales efficiently for large inputs.","solution":"def optimized_sieve(n: int) -> list[int]: Generates all prime numbers up to and including n using an optimized Sieve of Eratosthenes. Arguments: n -- The upper limit (inclusive) up to which prime numbers are to be generated. Returns: A list of prime numbers up to and including n. if n < 2: return [] sieve = [True] * (n + 1) sieve[0] = sieve[1] = False for start in range(4, n + 1, 2): sieve[start] = False for start in range(3, int(n**0.5) + 1, 2): if sieve[start]: for multiple in range(start * start, n + 1, start * 2): sieve[multiple] = False return [num for num in range(n + 1) if sieve[num]]"},{"question":"# Question You are required to implement a Decision Tree Classifier to predict whether a banknote is authentic based on its features. Dataset Preparation 1. Download the dataset from the link: [Banknote Authentication Dataset](https://archive.ics.uci.edu/ml/datasets/banknote+authentication). 2. Load the dataset into your working environment. This dataset contains 5 columns: - **Variance** of Wavelet Transformed image (continuous) - **Skewness** of Wavelet Transformed image (continuous) - **Curtosis** of Wavelet Transformed image (continuous) - **Entropy** of image (continuous) - **Class** (0 for authentic, 1 for inauthentic) Decision Tree Implementation 1. Preprocess the data by splitting it into training and testing sets. 2. Initialize and configure a Decision Tree Classifier from a machine learning library (e.g., Scikit-learn). 3. Fit the model using the training data. 4. Evaluate the model\'s performance using the test data and appropriate metrics (e.g., accuracy, precision, recall). Prediction 1. Write a function that takes as input the four feature values (variance, skewness, curtosis, entropy) and outputs whether the banknote is authentic or not. Requirements - **Input:** A list containing the four feature values. - **Output:** \\"Authentic\\" if the banknote is predicted as authentic, \\"Inauthentic\\" otherwise. # Constraints - Use 80% of the dataset for training and 20% for testing. - Ensure preprocessing is handled appropriately (e.g., handling missing values, if any). # Performance - Aim for at least 90% accuracy on the test set. - Optimize your decision tree to prevent overfitting (consider using techniques like pruning). # Example: ```python from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score # Load and preprocess data data = pd.read_csv(\'data_banknote_authentication.txt\', header=None) X = data.iloc[:, :-1].values y = data.iloc[:, -1].values X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42) # Initialize and train Decision Tree Classifier classifier = DecisionTreeClassifier() classifier.fit(X_train, y_train) # Evaluate the model y_pred = classifier.predict(X_test) print(\\"Accuracy:\\", accuracy_score(y_test, y_pred)) # Prediction function def predict_authenticity(classifier, features): prediction = classifier.predict([features]) return \\"Authentic\\" if prediction[0] == 0 else \\"Inauthentic\\" # Usage sample_features = [2.3, 6.5, -1.3, -0.4] print(predict_authenticity(classifier, sample_features)) # Output: \\"Authentic\\" or \\"Inauthentic\\" ``` # Additional Notes - Consider visualizing the decision tree using appropriate tools for a better understanding. - Experiment with different hyperparameters to improve model performance.","solution":"import pandas as pd from sklearn.model_selection import train_test_split from sklearn.tree import DecisionTreeClassifier from sklearn.metrics import accuracy_score, precision_score, recall_score # Load and preprocess data def load_data(): url = \'https://archive.ics.uci.edu/ml/machine-learning-databases/00267/data_banknote_authentication.txt\' column_names = [\'variance\', \'skewness\', \'curtosis\', \'entropy\', \'class\'] data = pd.read_csv(url, header=None, names=column_names) return data def preprocess_data(data): X = data.iloc[:, :-1].values y = data.iloc[:, -1].values return train_test_split(X, y, test_size=0.2, random_state=42) def train_model(X_train, y_train): classifier = DecisionTreeClassifier(random_state=42) classifier.fit(X_train, y_train) return classifier def evaluate_model(classifier, X_test, y_test): y_pred = classifier.predict(X_test) accuracy = accuracy_score(y_test, y_pred) precision = precision_score(y_test, y_pred) recall = recall_score(y_test, y_pred) return accuracy, precision, recall def predict_authenticity(classifier, features): prediction = classifier.predict([features]) return \\"Authentic\\" if prediction[0] == 0 else \\"Inauthentic\\" # Main execution data = load_data() X_train, X_test, y_train, y_test = preprocess_data(data) classifier = train_model(X_train, y_train) accuracy, precision, recall = evaluate_model(classifier, X_test, y_test) print(f\\"Accuracy: {accuracy:.2f}\\") print(f\\"Precision: {precision:.2f}\\") print(f\\"Recall: {recall:.2f}\\") # Example prediction sample_features = [2.3, 6.5, -1.3, -0.4] print(predict_authenticity(classifier, sample_features)) # Output: \\"Authentic\\" or \\"Inauthentic\\""},{"question":"# Merge Intervals with Conditions # Problem Statement: You are to implement a function that merges overlapping intervals, but with an added twist. Each interval will contain a \\"type\\" label. Two intervals should only be merged if they both have the same type label. The intervals are provided as a list of tuples, where each tuple represents `(start, end, type)` indicating the start, end, and type label of the interval respectively. # Rules: 1. If two intervals overlap and have the same type, they should be merged into a single interval. 2. The merging of two intervals `a` and `b` is performed if the intervals overlap. The result of merging will be one interval from the minimum start of interval `a` and `b` to the maximum end of interval `a` and `b`. 3. Non-overlapping intervals, even if they have the same type, remain unchanged in the output. # Function Signature: ```python def merge_intervals_with_types(intervals: list[tuple[int, int, str]]) -> list[tuple[int, int, str]]: Merges overlapping intervals with the same type label. :param intervals: List of tuples where each tuple contains (start, end, type). :return: List of merged intervals sorted by their start value and type label. ``` # Constraints: * The input list can have up to `10^4` intervals. * Each interval tuple contains two integers (start and end) and a string (type label). * The type label is a string consisting only of lowercase English letters and can have a length of up to 10 characters. * `0 <= start < end <= 10^9`. # Input/Output Examples: Example 1: ```python intervals = [(1, 3, \'a\'), (2, 4, \'a\'), (5, 7, \'a\'), (6, 8, \'b\')] print(merge_intervals_with_types(intervals)) # Expected Output: [(1, 4, \'a\'), (5, 7, \'a\'), (6, 8, \'b\')] ``` Example 2: ```python intervals = [(1, 3, \'x\'), (4, 6, \'y\'), (2, 5, \'x\'), (7, 8, \'x\')] print(merge_intervals_with_types(intervals)) # Expected Output: [(1, 5, \'x\'), (4, 6, \'y\'), (7, 8, \'x\')] ``` # Explanation: 1. In the first example, intervals `(1, 3, \'a\')` and `(2, 4, \'a\')` overlap and have the same type, so they are merged into `(1, 4, \'a\')`. The interval `(5, 7, \'a\')` does not overlap with any other interval and remains as it is. The interval `(6, 8, \'b\')` does not overlap with any interval having the same type `\'b\'`. 2. In the second example, intervals `(1, 3, \'x\')` and `(2, 5, \'x\')` overlap and have the same type, so they are merged into `(1, 5, \'x\')`. The interval `(4, 6, \'y\')` does not overlap with any other interval having the same type `\'y\'`, hence remains unchanged. The interval `(7, 8, \'x\')` has a different range and does not overlap with any other `\'x\'` interval. Implement the function `merge_intervals_with_types` that merges the intervals based on the given conditions.","solution":"from typing import List, Tuple def merge_intervals_with_types(intervals: List[Tuple[int, int, str]]) -> List[Tuple[int, int, str]]: Merges overlapping intervals with the same type label. :param intervals: List of tuples where each tuple contains (start, end, type). :return: List of merged intervals sorted by their start value and type label. if not intervals: return [] # Group intervals by type intervals_by_type = {} for start, end, _type in intervals: if _type not in intervals_by_type: intervals_by_type[_type] = [] intervals_by_type[_type].append((start, end)) merged_intervals = [] # Process each group of intervals by type for _type, interval_list in intervals_by_type.items(): # Sort intervals by start time interval_list.sort() # Merge intervals merged = [] for start, end in interval_list: if not merged or merged[-1][1] < start: merged.append((start, end)) else: merged[-1] = (merged[-1][0], max(merged[-1][1], end)) # Add the merged intervals with their type back to results for start, end in merged: merged_intervals.append((start, end, _type)) # Sort final result by start time merged_intervals.sort() return merged_intervals"},{"question":"# Problem: Maximum Sum Subarray of Size K You are developing a feature for analyzing historical sales data. One common analysis task is identifying the highest revenue generated in any contiguous period of a fixed length. Given an array of daily revenues and a specified period length, your task is to find the maximum sum of any contiguous subarray of revenues that is exactly of the given length. Problem Statement Given an array of integers representing daily revenues and an integer `k`, write a function to find the maximum sum of any contiguous subarray of size `k`. Implement the function `max_sum_subarray_of_size_k(revenues: list[int], k: int) -> int`: * **Input**: Two parameters: - A list of integers `revenues` where (1 leq text{len(revenues)} leq 10^5) and each element is in the range ([-10^4, 10^4]) - An integer `k` where (1 leq k leq text{len(revenues)}) * **Output**: An integer representing the maximum sum of any contiguous subarray of size `k`. Constraints * The sum of elements fits within the signed 32-bit integer range. Example ```python >>> max_sum_subarray_of_size_k([1, 2, 3, 4, 5, 6, 7, 8, 9], 3) 24 >>> max_sum_subarray_of_size_k([-1, 2, 3, -6, 10, -3, 8, 9], 2) 17 >>> max_sum_subarray_of_size_k([1], 1) 1 ``` Guidelines * Use a sliding window approach to keep the solution efficient with a time complexity of O(n). * Consider edge cases where the array might contain negative values or where all values are negative. * Verify the correctness by testing various scenarios, particularly at the length edges (minimum and maximum k). This question tests the candidate\'s understanding of efficient algorithms to handle subarray problems and their ability to use sliding window techniques for optimal performance.","solution":"def max_sum_subarray_of_size_k(revenues, k): Given a list of integers representing daily revenues and an integer k, find the maximum sum of any contiguous subarray of size k. max_sum = float(\'-inf\') current_window_sum = sum(revenues[:k]) max_sum = max(max_sum, current_window_sum) for i in range(k, len(revenues)): current_window_sum += revenues[i] - revenues[i-k] max_sum = max(max_sum, current_window_sum) return max_sum"},{"question":"# Question: Sum of K Largest Elements in a List Context: You are tasked with creating a function that can efficiently compute the sum of the K largest numbers in a list. This operation is useful in scenarios such as statistical data analysis, game scoring systems, and various optimization problems. Task: Write a function `sum_k_largest_elements(lst: List[int], k: int) -> int` that takes a list of integers and an integer `k` as input and returns the sum of the K largest numbers in the list. Input: - A list of integers `lst` where `1 <= len(lst) <= 10^5` and `-10^9 <= lst[i] <= 10^9`. - An integer `k` where `1 <= k <= len(lst)`. Output: - An integer representing the sum of the K largest numbers in the list `lst`. Constraints: - The input list is guaranteed to have at least one element. - The value of `k` is always valid and lies within the number of elements in the list. - Only integers are valid inputs. If `lst` or `k` are not valid, the function should raise a `TypeError` with the message `\\"invalid input\\"`. Examples: ```python sum_k_largest_elements([10, 15, 7, 3, 8, 11], 3) # Returns: 36 sum_k_largest_elements([5, 5, 5, 5, 5], 2) # Returns: 10 sum_k_largest_elements([-10, -5, 0, 5, 10], 4) # Returns: 10 sum_k_largest_elements([4, 3, 2, 1], 2) # Returns: 7 sum_k_largest_elements([20], 1) # Returns: 20 ``` Notes: - Consider edge cases such as lists with negative numbers, single-element lists, and lists with repeated elements. - Ensure the function handles large lists efficiently. Would you like to provide the implementation for the function or need further assistance?","solution":"from typing import List def sum_k_largest_elements(lst: List[int], k: int) -> int: Returns the sum of the K largest numbers in the list `lst`. Raises TypeError if inputs are not valid. if not isinstance(lst, list) or not all(isinstance(x, int) for x in lst) or not isinstance(k, int): raise TypeError(\\"invalid input\\") if not (1 <= len(lst) <= 10**5) or not (1 <= k <= len(lst)): raise TypeError(\\"invalid input\\") # Sort the list in descending order and sum up the first `k` elements return sum(sorted(lst, reverse=True)[:k])"},{"question":"# Question: Implement a Bellman-Ford Algorithm for Single Source Shortest Path Problem Statement: You are required to implement the Bellman-Ford algorithm to find the shortest path from a single source node to all other nodes in a weighted graph. This algorithm should be able to handle graphs that may have negative weight edges but no negative weight cycles. Requirements: 1. Write a function `bellman_ford(graph: List[Tuple[int, int, int]], V: int, src: int) -> List[int]` that performs the Bellman-Ford algorithm to find the shortest path from the source node to every other node. 2. The function should return a list of shortest distances from the source node to each node. Input Format: * `graph`: A list of tuples `(u, v, w)` where `u` and `v` are the nodes of the edge and `w` is the weight of the edge. * `V`: An integer representing the number of vertices in the graph. * `src`: An integer representing the source node. Output Format: * A list of shortest distances from node `src` to every other node. * If the distance to a node is still considered infinite, display `float(\'inf\')` for that node. Constraints: * (1 leq V leq 10^3) * (0 leq w leq 10^3) * The graph may contain negative weights, but no negative weight cycles. Example: Input: ``` graph = [(0, 1, -1), (0, 2, 4), (1, 2, 3), (1, 3, 2), (1, 4, 2), (3, 2, 5), (3, 1, 1), (4, 3, -3)] V = 5 src = 0 ``` Output: ``` Distances from source 0: [0, -1, 2, -2, 1] ``` Implementation: ```python def bellman_ford(graph, V, src): # Initialize distances from src to all other vertices as INFINITE dist = [float(\'inf\')] * V dist[src] = 0 # Relax all edges |V| - 1 times for _ in range(V - 1): for u, v, w in graph: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: dist[v] = dist[u] + w # Check for negative-weight cycles. for u, v, w in graph: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: print(\\"Graph contains negative weight cycle\\") return None return dist if __name__ == \\"__main__\\": graph = [(0, 1, -1), (0, 2, 4), (1, 2, 3), (1, 3, 2), (1, 4, 2), (3, 2, 5), (3, 1, 1), (4, 3, -3)] V = 5 src = 0 distances = bellman_ford(graph, V, src) if distances: print(f\\"Distances from source {src}: {distances}\\") ```","solution":"from typing import List, Tuple def bellman_ford(graph: List[Tuple[int, int, int]], V: int, src: int) -> List[int]: # Initialize distances from src to all other vertices as INFINITE dist = [float(\'inf\')] * V dist[src] = 0 # Relax all edges |V| - 1 times for _ in range(V - 1): for u, v, w in graph: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: dist[v] = dist[u] + w # Check for negative-weight cycles. for u, v, w in graph: if dist[u] != float(\'inf\') and dist[u] + w < dist[v]: print(\\"Graph contains negative weight cycle\\") return None return dist"},{"question":"# Coding Assessment Question **Scenario**: You are working on a task involving data compression. One of the classic algorithms for compressing data is the Run-Length Encoding (RLE) algorithm. It is particularly effective for sequences where the same data value occurs consecutively multiple times. **Task**: Implement the Run-Length Encoding algorithm to compress a given string input. Your implementation should be efficient and handle edge cases gracefully, such as strings with no repetitions or completely repetitive strings. **Function Signature**: ```python def run_length_encoding(s: str) -> str: Compute the Run-Length Encoding for the given input string. :param s: str - Input string. :return: str - The Run-Length Encoded string. ``` **Input**: - A single string `s` containing alphanumeric characters (0 <= length of s <= 10^6). **Output**: - A string representing the Run-Length Encoded version of the input string. **Constraints**: - The function should correctly handle an empty string. - Ensure the function executes efficiently even for very large strings. - The encoded string should be constructed such that each character is followed by its count of consecutive occurrences. **Example**: ```python assert run_length_encoding(\'aabcccccaaa\') == \'a2b1c5a3\' assert run_length_encoding(\'ab\') == \'a1b1\' assert run_length_encoding(\'\') == \'\' assert run_length_encoding(\'xxxyyyzzzz\') == \'x3y3z4\' ```","solution":"def run_length_encoding(s: str) -> str: Compute the Run-Length Encoding for the given input string. :param s: str - Input string. :return: str - The Run-Length Encoded string. if not s: return \\"\\" encoded_str = [] current_char = s[0] count = 1 for char in s[1:]: if char == current_char: count += 1 else: encoded_str.append(current_char + str(count)) current_char = char count = 1 # Add the last set of characters encoded_str.append(current_char + str(count)) return \'\'.join(encoded_str)"},{"question":"# Longest Increasing Subsequence with Step Constraint Context Finding the longest increasing subsequence (LIS) in an array is a classic problem. However, sometimes additional constraints are necessary, such as a maximum allowed step between consecutive elements of the subsequence. Task You are to write a function `longest_increasing_subsequence_with_step(arr: List[int], max_step: int) -> List[int]`, which computes the longest increasing subsequence (LIS) of an array where the difference between any two consecutive elements in the subsequence does not exceed `max_step`. Function Signature ```python def longest_increasing_subsequence_with_step(arr: List[int], max_step: int) -> List[int]: ... ``` Input 1. `arr` (List[int]): The input array of integers. 2. `max_step` (int): The maximum allowed step between consecutive elements in the subsequence. Output A list containing the elements of the longest increasing subsequence found where the difference between any two consecutive elements does not exceed `max_step`. If there are multiple solutions with the same length, return any of them. Constraints 1. The input array may contain only integers. 2. `0 <= len(arr) <= 1000` 3. `-10^9 <= arr[i] <= 10^9` for each element in `arr` 4. `0 <= max_step <= 10^9` Examples ```python # Maximally allowed step filters out larger differences print(longest_increasing_subsequence_with_step([10, 22, 5, 75, 65, 80], 15)) # [10, 22] or [5, 20] # Normal case with a valid increasing subsequence print(longest_increasing_subsequence_with_step([1, 2, 3, 4, 5, 6], 1)) # [1, 2, 3, 4, 5, 6] # No valid increasing subsequence due to max_step constraint print(longest_increasing_subsequence_with_step([10, 9, 4, 3, 2, 1], 1)) # [10] (single element subsequence) # Multiple valid increasing subsequences print(longest_increasing_subsequence_with_step([1, 2, 3, 2, 3, 4, 5], 1)) # [1, 2, 3, 4, 5] # Sequence with large numbers print(longest_increasing_subsequence_with_step([1000000000, 999999999, 1000000001], 2)) # [999999999, 1000000001] ``` This question should integrate seamlessly with the existing set of coding assessment questions, providing a comparable level of complexity and requiring similar analytical skills.","solution":"from typing import List def longest_increasing_subsequence_with_step(arr: List[int], max_step: int) -> List[int]: if not arr: return [] n = len(arr) dp = [] for _ in range(n): dp.append([]) dp[0] = [arr[0]] for i in range(1, n): for j in range(i): if arr[i] > arr[j] and (arr[i] - arr[j]) <= max_step and len(dp[j]) + 1 > len(dp[i]): dp[i] = dp[j][:] dp[i].append(arr[i]) longest_seq = max(dp, key=len) return longest_seq"},{"question":"# Coding Assessment Question Objective: Implement a function that generates and validates ISBN-13 numbers. The check digit mechanism to be used is ISBN-13 calculation. Problem Statement: You are required to create a function `generate_isbn_check_digit(isbn: str) -> str` that receives a 12-digit ISBN and returns the full 13-digit ISBN with the computed check digit, and another function `validate_isbn_list(isbns: List[str]) -> List[bool]` that receives a list of ISBN-13 numbers as strings and validates each using the appropriate check digit mechanism. Input: 1. `generate_isbn_check_digit(isbn: str) -> str`: - A string representing the ISBN without the check digit (12 digits). 2. `validate_isbn_list(isbns: List[str]) -> List[bool]`: - A list of strings, each representing a ISBN-13 number. Output: 1. `generate_isbn_check_digit(isbn: str) -> str`: - A string representing the full 13-digit ISBN with the computed check digit. 2. `validate_isbn_list(isbns: List[str]) -> List[bool]`: - A list of boolean values. Each boolean value indicates whether the corresponding ISBN is valid (True) or not (False). Constraints: - ISBN should be exactly 12 digits for `generate_isbn_check_digit`. - ISBN should be exactly 13 digits for `validate_isbn_list`. - If there are any invalid characters or ISBN lengths, a ValueError should be raised. Example: ```python >>> generate_isbn_check_digit(\\"978316148410\\") \\"9783161484100\\" >>> validate_isbn_list([\\"9783161484100\\", \\"9783161484101\\", \\"9783161484102\\"]) [True, False, False] ``` Requirements: - Use the appropriate ISBN-13 check digit calculation mechanism. - Ensure that inputs are properly validated before processing. - Handle any invalid or unexpected inputs gracefully. Note: The check digit calculation for ISBN-13 is as follows: 1. Take the digits of the ISBN and multiply them by 1 or 3 alternately. 2. Sum these results. 3. Compute the check digit as `(10 - (sum % 10)) % 10`. For example, for ISBN \\"978316148410\\": - Multiplied sequence: 9, 7*3, 8, 3*3, 1, 6*3, 1, 4*3, 8, 4*3, 1, 0*3 - Sum = 9 + 21 + 8 + 9 + 1 + 18 + 1 + 12 + 8 + 12 + 1 + 0 = 100 - Check digit = (10 - (100 % 10)) % 10 = (10 - 0) % 10 = 0 - ISBN-13 = \\"9783161484100\\" Make sure to implement this logic in the functions.","solution":"def generate_isbn_check_digit(isbn: str) -> str: if len(isbn) != 12 or not isbn.isdigit(): raise ValueError(\\"ISBN must be a 12-digit string\\") total = sum(int(digit) * (1 if index % 2 == 0 else 3) for index, digit in enumerate(isbn)) check_digit = (10 - (total % 10)) % 10 return isbn + str(check_digit) def validate_isbn_list(isbns: list[str]) -> list[bool]: results = [] for isbn in isbns: if len(isbn) != 13 or not isbn.isdigit(): raise ValueError(\\"Each ISBN must be a 13-digit string\\") check_digit_calculated = generate_isbn_check_digit(isbn[:12])[-1] results.append(isbn[-1] == check_digit_calculated) return results"},{"question":"# Word Frequency Counter Scenario You are tasked with developing a program that reads a text file and counts the frequency of each word in the file. This program will be useful in various scenarios such as textual analysis and data preprocessing for natural language processing tasks. The provided code snippet includes a starting point for reading a file and processing its contents. Your goal is to complete and ensure the correctness of the word count functionality. Task Implement the function `word_frequency` to read a text file and return a dictionary where keys are words and values are their frequencies. Function Details 1. `word_frequency(file_path)` - **Parameters:** - `file_path`: The path to the text file that needs to be processed. - **Functionality:** Read the file, split its content into words, count the frequency of each word, and return a dictionary with word-frequency pairs. Input and Output - **Input Format**: A string `file_path` representing the path to a text file. - **Output Format**: A dictionary with words as keys and their respective frequencies as values. Constraints - The words should be treated case-insensitively (e.g., \\"Word\\" and \\"word\\" should be considered the same word). - Punctuation should be ignored during the word counting (e.g., \\"word,\\" and \\"word.\\" should both be counted as \\"word\\"). - Focus on correct reading from the file, proper splitting of words, and accurate frequency counting. Example Usage Assume the contents of \\"example.txt\\" are: ``` Hello, world! Hello earth. Welcome to the world of coding. ``` ```python assert word_frequency(\\"example.txt\\") == { \\"hello\\": 2, \\"world\\": 2, \\"earth\\": 1, \\"welcome\\": 1, \\"to\\": 1, \\"the\\": 1, \\"of\\": 1, \\"coding\\": 1 } ``` Ensure your implementation efficiently reads the file, processes the text, and handles edge cases such as empty files and files with only punctuation.","solution":"import re from collections import defaultdict def word_frequency(file_path): Reads a text file and counts the frequency of each word. Punctuation is ignored and words are case-insensitive. word_count = defaultdict(int) with open(file_path, \'r\') as file: content = file.read().lower() words = re.findall(r\'bw+b\', content) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"# Question: Find Minimum and Maximum in a List Context: Your task is to implement a function that finds both the minimum and maximum elements in a list. The function should return a tuple where the first element is the minimum value and the second element is the maximum value. If the list is empty, the function should return `(None, None)`. Function Signature: ```python def find_min_max(lst: list) -> (int, int): ``` Parameters: - `lst`: a list of integers from which we need to find the minimum and maximum values. Returns: - The function returns a tuple `(min_value, max_value)`: - `min_value`: the smallest integer in the list. - `max_value`: the largest integer in the list. - If the list is empty, return `(None, None)`. Constraints: - Consider edge cases like a list with only one element, an empty list, and lists with duplicated maximum or minimum values. Examples: ```python # Example 1 print(find_min_max([3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5])) # Output: (1, 9) # Example 2 print(find_min_max([10])) # Output: (10, 10) # Example 3 print(find_min_max([])) # Output: (None, None) # Example 4 print(find_min_max([7, 7, 7, 7])) # Output: (7, 7) # Example 5 print(find_min_max([-3, -1, -4, -2, -5])) # Output: (-5, -1) ``` Note: Implement the function without using any built-in min, max functions or libraries. The function should be able to handle various inputs efficiently, ensuring correctness in all edge cases.","solution":"def find_min_max(lst): Finds the minimum and maximum values in a list. Returns a tuple (min_value, max_value). If the list is empty, returns (None, None). if not lst: return (None, None) min_value = float(\'inf\') max_value = float(\'-inf\') for num in lst: if num < min_value: min_value = num if num > max_value: max_value = num return (min_value, max_value)"},{"question":"# Problem Statement Given a list of integers, write a function `count_distinct_subsets(arr: List[int], k: int) -> int` that returns the number of distinct subsets of size `k` that can be formed from the list `arr`. # Function Signature ```python def count_distinct_subsets(arr: List[int], k: int) -> int: pass ``` # Input - `arr`: A list of integers. It may contain duplicates and can be of any size from 0 to 10. - `k`: A non-negative integer representing the subset size. # Output - Return an integer representing the number of distinct subsets of size `k`. # Constraints - The length of the list `arr` is 0 ≤ len(arr) ≤ 10. - The value of `k` is 0 ≤ k ≤ len(arr). # Requirements - Use appropriate combinations and set operations to ensure subsets are counted distinctly. - Do not use any built-in library functions to generate combinations. # Example ```python assert count_distinct_subsets([1, 2, 2], 2) == 2 # Subsets: [1, 2], [2, 2] assert count_distinct_subsets([1, 1, 1, 2], 1) == 2 # Subsets: [1], [2] assert count_distinct_subsets([], 0) == 1 # Only the empty subset assert count_distinct_subsets([1, 2, 3, 4], 5) == 0 # Impossible to form assert count_distinct_subsets([1, 2, 3], 3) == 1 # Subset: [1, 2, 3] assert count_distinct_subsets([1, 1, 1, 1, 1], 3) == 1 # Subset: [1, 1, 1] ``` # Notes - Ensure that the function handles edge cases like an empty list or `k` greater than the length of the list. - Think about how to avoid counting duplicate subsets. - Efficiently manage the generation and storage of subsets, especially with lists containing repeated elements.","solution":"from typing import List def count_distinct_subsets(arr: List[int], k: int) -> int: def generate_subsets(curr, start): if len(curr) == k: result.add(tuple(sorted(curr))) return for i in range(start, len(arr)): generate_subsets(curr + [arr[i]], i + 1) if k > len(arr): return 0 if k == 0: return 1 # Only the empty subset. result = set() generate_subsets([], 0) return len(result)"},{"question":"# Problem Description You are tasked with writing a function to validate and parse a URL, extracting specific components from it. The components of interest are the scheme (protocol), domain name, path, and query parameters. Your function should return these components in a structured format. # Function Specification Write a function `parse_url(url: str) -> dict` which takes in a URL string and returns a dictionary with the extracted components. Input - `url` (str): A string representing the URL to be parsed. Output - A dictionary with the keys \\"scheme\\", \\"domain\\", \\"path\\", and \\"query\\" corresponding to the respective parts of the URL. If a component is missing, its value should be an empty string. Constraints - The URL will always be valid and well-formed. - Query parameters, if present, should be returned as a dictionary of key-value pairs. # Example ```python def parse_url(url: str) -> dict: # implement here url = \\"https://www.example.com/path/to/resource?user=admin&password=1234\\" print(parse_url(url)) # Output: { # \\"scheme\\": \\"https\\", # \\"domain\\": \\"www.example.com\\", # \\"path\\": \\"/path/to/resource\\", # \\"query\\": {\\"user\\": \\"admin\\", \\"password\\": \\"1234\\"} # } ``` # Requirements - Handle URLs with or without query parameters. - Ensure the function correctly handles various URL structures, including those without a path or with multiple query parameters. - Ensure robustness against minor malformations that still qualify as valid URLs.","solution":"from urllib.parse import urlparse, parse_qs def parse_url(url: str) -> dict: Parses the given URL and returns its scheme, domain, path, and query components. result = urlparse(url) scheme = result.scheme domain = result.netloc path = result.path query = {k: v[0] for k, v in parse_qs(result.query).items()} return { \\"scheme\\": scheme, \\"domain\\": domain, \\"path\\": path, \\"query\\": query }"},{"question":"# **Coding Challenge: Interval Insert and Query** Context You are given a list of intervals and you need to perform operations on these intervals. Specifically, you need to insert new intervals and query the merged state of the intervals list after each insertion. Task Implement a solution that can handle interval insertions efficiently and return the merged intervals after each insertion. Input and Output Formats **Input**: 1. A list of initial intervals, where each interval is represented as a pair of integers `[start, end]`. 2. A list of insert operations. Each operation is represented as a new interval to be inserted, in the form of `[start, end]`. ``` Example: initial_intervals = [[1, 3], [6, 9]] operations = [[2, 5], [8, 10], [15, 18]] ``` **Output**: 1. Return a list of merged intervals after each insert operation. Requirements 1. **Function Signature**: ```python def insert_interval(intervals: List[List[int]], new_interval: List[int]) -> List[List[int]]: # insert new_interval into intervals and return the merged list of intervals pass def perform_operations(initial_intervals: List[List[int]], operations: List[List[int]]) -> List[List[List[int]]]: # initialize with initial_intervals and perform insertion operations pass ``` 2. **Constraints**: * The input list `intervals` will have a length `n` where `0 <= n <= 10^4`. * Each interval contains two integers `[start, end]` where `0 <= start <= end <= 10^5`. * The number of operations `q` will be such that `1 <= q <= 10^4`. Example ```python # Input initial_intervals = [[1, 3], [6, 9]] operations = [[2, 5], [8, 10], [15, 18]] # Output [ [[1, 5], [6, 9]], # After inserting [2, 5] [[1, 5], [6, 10]], # After inserting [8, 10] [[1, 5], [6, 10], [15, 18]] # After inserting [15, 18] ] ``` **Note:** You should merge intervals such that overlapping intervals are combined into one. For example, given the intervals `[1, 3]` and `[2, 6]`, merging these intervals results in a single interval `[1, 6]`.","solution":"def insert_interval(intervals, new_interval): Insert new_interval into intervals and return the merged list of intervals. merged = [] i = 0 n = len(intervals) # Add all intervals that end before new_interval starts while i < n and intervals[i][1] < new_interval[0]: merged.append(intervals[i]) i += 1 # Merge overlapping intervals while i < n and intervals[i][0] <= new_interval[1]: new_interval[0] = min(new_interval[0], intervals[i][0]) new_interval[1] = max(new_interval[1], intervals[i][1]) i += 1 merged.append(new_interval) # Add the remaining intervals while i < n: merged.append(intervals[i]) i += 1 return merged def perform_operations(initial_intervals, operations): Initialize with initial_intervals and perform insertion operations. result = [] intervals = initial_intervals for op in operations: intervals = insert_interval(intervals, op) result.append(intervals) return result"},{"question":"# Context Bob is developing a piece of software that entails the management of strings and their unique transformations. He is particularly interested in understanding how he can manipulate strings using cyclic rotations. A cyclic rotation of a string is obtained by moving characters from the beginning of the string to the end, while keeping their relative order the same. For instance, cyclic rotation of the string \\"abc\\" can yield \\"bca\\", \\"cab\\", and back to \\"abc\\". # Task Write a function `find_min_cyclic_rotation` that accepts a string and returns its lexicographically smallest cyclic rotation. The function should be efficient and handle strings with lengths up to 2000 characters. # Input - A single string `s` with a length between 1 and 2000 characters, consisting of lowercase English letters. # Output - A string representing the lexicographically smallest cyclic rotation of the input string. # Example ```python s = \\"bca\\" find_min_cyclic_rotation(s) ``` Expected Output: ``` \\"abc\\" ``` # Constraints - The length of the input string `s` is between 1 and 2000 characters. - The string consists only of lowercase English letters. # Performance Requirements - Optimize the function to run efficiently even for the maximum constraints provided. Avoid unnecessary computations and optimize memory usage.","solution":"def find_min_cyclic_rotation(s): Returns the lexicographically smallest cyclic rotation of the string s. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: The lexicographically smallest cyclic rotation of s. s = s + s # Concatenate the string with itself to handle rotations easily n = len(s) // 2 min_rotation = s[:n] for i in range(1, n): candidate = s[i:i+n] if candidate < min_rotation: min_rotation = candidate return min_rotation"},{"question":"# Scenario A bank\'s backend system stores account transactions in a detailed log file. Each transaction entry consists of a timestamp and an amount. The bank needs a way to query the total amount of money transacted within a given time range. The goal is to implement a function that queries the log efficiently and computes this total. # Task Write a function `transaction_sum(logs: list[tuple[str, float]], start: str, end: str) -> float` that computes the sum of the transaction amounts within the specified time range. # Function Signature ```python def transaction_sum(logs: list[tuple[str, float]], start: str, end: str) -> float ``` # Input - `logs`: A list of tuples where each tuple contains: - `timestamp` (str): A string representing the timestamp in the format \\"YYYY-MM-DD HH:MM:SS\\". - `amount` (float): A float representing the transaction amount. - `start`: A string representing the start of the time range in the format \\"YYYY-MM-DD HH:MM:SS\\". - `end`: A string representing the end of the time range in the format \\"YYYY-MM-DD HH:MM:SS\\". # Output - A float representing the total transaction amount within the specified time range. # Constraints - The input list `logs` can have up to 10,000 transaction entries. - The timestamps are sorted in ascending order. - The `start` and `end` strings are guaranteed to be valid timestamps. # Example 1. For an input `logs = [(\\"2023-01-01 09:00:00\\", 100.0), (\\"2023-01-01 10:00:00\\", 150.0), (\\"2023-01-01 11:00:00\\", 200.0)]`, `start = \\"2023-01-01 09:30:00\\"`, `end = \\"2023-01-01 10:30:00\\"` - The function should return `150.0`. 2. For an input `logs = [(\\"2023-01-01 09:00:00\\", 100.0), (\\"2023-01-01 10:00:00\\", 150.0), (\\"2023-01-01 11:00:00\\", 200.0)]`, `start = \\"2023-01-01 08:00:00\\"`, `end = \\"2023-01-01 12:00:00\\"` - The function should return `450.0`. # Additional Requirements - The function should efficiently handle the time range queries. - Ensure that the function returns zero if no transactions fall within the specified range. - You may assume the logs are sorted in ascending order by timestamp and that the provided timestamps for the start and end range are formatted correctly.","solution":"from datetime import datetime def transaction_sum(logs: list[tuple[str, float]], start: str, end: str) -> float: Computes the sum of transaction amounts within the specified time range. Parameters: logs (list[tuple[str, float]]): A list of tuples where each tuple contains a timestamp and a transaction amount. start (str): The start of the time range in the format \\"YYYY-MM-DD HH:MM:SS\\". end (str): The end of the time range in the format \\"YYYY-MM-DD HH:MM:SS\\". Returns: float: The total transaction amount within the specified time range. start_dt = datetime.strptime(start, \\"%Y-%m-%d %H:%M:%S\\") end_dt = datetime.strptime(end, \\"%Y-%m-%d %H:%M:%S\\") total_sum = 0.0 for log in logs: log_dt = datetime.strptime(log[0], \\"%Y-%m-%d %H:%M:%S\\") if start_dt <= log_dt <= end_dt: total_sum += log[1] return total_sum"},{"question":"# Problem Statement You are required to write a function that generates a list of prime numbers up to a given limit. The prime numbers should be discovered using the Sieve of Eratosthenes algorithm, which is an efficient way to find all primes smaller than a given number. # Requirements 1. Implement a function `sieve_of_eratosthenes(limit: int) -> list` that: - Takes an integer `limit` as its parameter, representing the upper bound (inclusive) up to which prime numbers need to be found. - Uses the Sieve of Eratosthenes algorithm to generate all prime numbers up to the provided limit. - Returns a list of prime numbers in ascending order. # Input - `limit`: An integer representing the upper bound for finding prime numbers (0 <= limit <= 10^6). # Output - Returns a list containing all prime numbers up to the given limit (inclusive). # Constraints - The function should handle edge cases such as non-positive limits appropriately. - The algorithm should be optimized for performance to handle upper bounds as large as 10^6 efficiently. - The function must use the Sieve of Eratosthenes algorithm to ensure optimal performance. # Example ```python result = sieve_of_eratosthenes(10) print(result) # Expected Output # [2, 3, 5, 7] result = sieve_of_eratosthenes(30) print(result) # Expected Output # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] ``` # Function Signature ```python def sieve_of_eratosthenes(limit: int) -> list: # Your implementation here pass ```","solution":"def sieve_of_eratosthenes(limit: int) -> list: if limit < 2: return [] is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if is_prime[p]] return prime_numbers"},{"question":"# **Coding Assessment Question: Shortest Path in Maze Using A* Algorithm** As a software engineer for a game development company, your task is to implement a navigation system for a character to find the shortest path from the starting point to the destination within a maze. The maze is represented as a grid where cells can either be open or blocked. Your goal is to implement an efficient pathfinding algorithm using the A* search algorithm to find the shortest path. **Task**: Design and implement a function `a_star_maze_solver(maze: list[list[int]], start: tuple[int, int], end: tuple[int, int]) -> list[tuple[int, int]]` that finds the shortest path in the maze using the A* search algorithm. **Input and Notes**: 1. The input parameter, `maze`, is a 2D list where `maze[i][j]`: - `0` represents an open cell. - `1` represents a blocked cell. 2. The `start` parameter is a tuple (x, y) representing the starting cell in the maze. 3. The `end` parameter is a tuple (x, y) representing the destination cell in the maze. 4. For simplicity, assume the maze is non-empty and both start and end points are open cells. 5. Movements are allowed in the four cardinal directions (up, down, left, right). **Output**: 1. A list of tuples where each tuple (x, y) represents a cell in the shortest path from `start` to `end`, inclusive. If no path exists, return an empty list. **Constraints**: * **Performance**: The solution should be efficient in both time and space complexity, capable of handling mazes up to 1000x1000 cells. **Example**: ```python maze = [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [1, 1, 0, 1, 0], [0, 0, 0, 0, 0] ] start = (0, 0) end = (4, 4) path = a_star_maze_solver(maze, start, end) assert path == [(0, 0), (1, 0), (2, 0), (2, 1), (2, 2), (3, 2), (4, 2), (4, 3), (4, 4)] ``` Implement the `a_star_maze_solver` function and ensure it provides correct and efficient results.","solution":"from heapq import heappop, heappush def a_star_maze_solver(maze, start, end): def heuristic(a, b): return abs(a[0] - b[0]) + abs(a[1] - b[1]) def neighbors(node): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] result = [] for direction in directions: neighbor = (node[0] + direction[0], node[1] + direction[1]) if 0 <= neighbor[0] < len(maze) and 0 <= neighbor[1] < len(maze[0]) and maze[neighbor[0]][neighbor[1]] == 0: result.append(neighbor) return result open_set = [] came_from = {} g_score = {start: 0} f_score = {start: heuristic(start, end)} heappush(open_set, (f_score[start], start)) while open_set: _, current = heappop(open_set) if current == end: path = [] while current in came_from: path.append(current) current = came_from[current] path.append(start) return path[::-1] for neighbor in neighbors(current): tentative_g_score = g_score[current] + 1 if tentative_g_score < g_score.get(neighbor, float(\'inf\')): came_from[neighbor] = current g_score[neighbor] = tentative_g_score f_score[neighbor] = tentative_g_score + heuristic(neighbor, end) heappush(open_set, (f_score[neighbor], neighbor)) return []"},{"question":"# Matrix Rotation Validator You need to check if one given matrix can be obtained by rotating another matrix 90 degrees any number of times (0, 1, 2, or 3 times). Write a function to determine if this is the case. Task Implement the `is_rotated_version` function to check if one matrix is a rotated version of another. Function Signature ```python def is_rotated_version(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: pass ``` Input - `matrix1`: A two-dimensional list of integers representing the first matrix (dimensions NxN, with (1 leq N leq 100)). - `matrix2`: A two-dimensional list of integers representing the second matrix (same dimensions N x N as `matrix1`). Output - `True` if `matrix2` can be obtained by rotating `matrix1` 0, 90, 180, or 270 degrees; otherwise, `False`. Constraints - Only standard Python libraries should be used. - The matrices will always be square (NxN). Example ```python >>> is_rotated_version([[1, 2], [3, 4]], [[3, 1], [4, 2]]) True >>> is_rotated_version([[1, 2], [3, 4]], [[4, 3], [2, 1]]) True >>> is_rotated_version([[1, 2], [3, 4]], [[2, 1], [3, 4]]) False >>> is_rotated_version([[1, 2], [3, 4]], [[1, 2], [3, 4]]) True ``` Steps 1. **Identity Check**: If `matrix1` is the same as `matrix2`, return `True`. 2. **Generate Rotations**: Create three additional matrices by rotating `matrix1` by 90, 180, and 270 degrees. 3. **Comparison**: Compare each rotation with `matrix2`. If any matches, return `True`; otherwise, return `False`.","solution":"from typing import List def rotate_90_degrees(matrix: List[List[int]]) -> List[List[int]]: Rotates a square matrix 90 degrees clockwise. n = len(matrix) rotated = [[0] * n for _ in range(n)] for i in range(n): for j in range(n): rotated[j][n-1-i] = matrix[i][j] return rotated def is_rotated_version(matrix1: List[List[int]], matrix2: List[List[int]]) -> bool: Checks if one matrix can be obtained by rotating another matrix if matrix1 == matrix2: return True rotated_90 = rotate_90_degrees(matrix1) if rotated_90 == matrix2: return True rotated_180 = rotate_90_degrees(rotated_90) if rotated_180 == matrix2: return True rotated_270 = rotate_90_degrees(rotated_180) if rotated_270 == matrix2: return True return False"},{"question":"# Problem Statement You are given a string representing an arithmetic expression that includes non-negative integers and the operators `+` and `*` (representing addition and multiplication, respectively). Your task is to evaluate the result of the expression following the usual precedence rules (multiplication takes precedence over addition). # Input - A string `expr` representing an arithmetic expression containing non-negative integers and the operators `+` and `*`. # Output - A single integer value representing the result of the evaluated expression. # Constraints - The string will contain only non-negative integers and the operators `+` and `*`. - The string will be non-empty and will not contain any spaces. - The order of operations must be respected (multiplication before addition). # Function Signature ```python def evaluate_expression(expr: str) -> int: ``` # Examples ```python >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\"3*2+2\\") 8 >>> evaluate_expression(\\"2*3+4*5\\") 26 >>> evaluate_expression(\\"2*3*4+1\\") 25 >>> evaluate_expression(\\"10+20*30\\") 610 ``` # Implementation Guidance 1. Parse the input string and use a stack to handle the operations. 2. Process the string from left to right, respecting the precedence of `*` over `+`. 3. As you encounter numbers and operators, use the stack to store intermediate results and operators. 4. Compute the final result once the entire string has been processed.","solution":"def evaluate_expression(expr: str) -> int: Evaluate an arithmetic expression that includes non-negative integers and the operators + and *, following the usual precedence rules. :param expr: A string representing the arithmetic expression :return: The evaluated result as an integer # Initialize a stack to keep track of numbers and operators stack = [] num = 0 sign = \'+\' length = len(expr) for i in range(length): char = expr[i] # If char is a digit, construct the number if char.isdigit(): num = num * 10 + int(char) # If char is an operator or it\'s the end of the string if char in \'+*\' or i == length - 1: if sign == \'+\': stack.append(num) elif sign == \'*\': stack.append(stack.pop() * num) sign = char num = 0 # Sum up the values in the stack for the final result return sum(stack)"},{"question":"# Question Problem Statement You are given a list of integers and you are tasked with creating a function `check_sorted_rotated(arr)` that checks if the given list was originally sorted (either in ascending or descending order) and then possibly rotated. A rotation means taking a section of the array from the end and moving it to the beginning. # Function Signature ```python def check_sorted_rotated(arr: list) -> bool: pass ``` # Input - `arr`: A list of integers (1 ≤ len(arr) ≤ 10000) where each integer is in the range ([-10^5, 10^5]). # Output - Return `True` if the array was originally sorted in ascending or descending order and then rotated. Otherwise, return `False`. # Constraints - The function should handle both ascending and descending order scenarios. - You are guaranteed to have no duplicate elements in the array. # Examples Example 1 ```python arr = [3, 4, 5, 1, 2] result = check_sorted_rotated(arr) print(result) # Output: True ``` Example 2 ```python arr = [4, 5, 1, 2, 3] result = check_sorted_rotated(arr) print(result) # Output: True ``` Example 3 ```python arr = [4, 5, 6, 7, 2, 3, 1] result = check_sorted_rotated(arr) print(result) # Output: False ``` # Explanation - In Example 1, the sequence `[3, 4, 5, 1, 2]` can be seen as being in ascending order before being rotated. - In Example 2, the sequence `[4, 5, 1, 2, 3]` was also in ascending order before being rotated. - In Example 3, the sequence `[4, 5, 6, 7, 2, 3, 1]` cannot be reduced to a sorted sequence through any single rotation. Thus, the output is `False`. # Notes - Testing for rotation requires identifying pivot points where the rotation might have occurred and checking if the segments before and after the pivot point are in the desired order. - Ensure to handle edge cases where the array might be already sorted and no rotation was performed.","solution":"def check_sorted_rotated(arr): def is_sorted(lst): return all(lst[i] <= lst[i+1] for i in range(len(lst)-1)) or all(lst[i] >= lst[i+1] for i in range(len(lst)-1)) n = len(arr) if is_sorted(arr): return True for i in range(1, n): if arr[i] < arr[i - 1]: if is_sorted(arr[i:] + arr[:i]): return True break return False"},{"question":"# Coding Assessment Question **Scenario**: You have been tasked with developing a simple recommendation system for an online book store. The system should recommend books to users based on their historical purchase data using collaborative filtering. Your task is to implement a function that takes user purchase history and returns a list of recommended books for a given user. **Objective**: Create a function `recommend_books` that: 1. Takes a dictionary representing user purchase history. 2. Recommends a list of books to a specific user based on the most similar users\' purchase history. **Function Signature**: ```python def recommend_books(user_history: dict[str, list[str]], target_user: str, top_n: int) -> list[str]: Recommend books to a user based on similar users\' purchase history. Args: - user_history (dict[str, list[str]]): A dictionary where keys are user IDs and values are lists of book titles they\'ve purchased. - target_user (str): The user ID for whom to recommend books. - top_n (int): The number of recommendations to return. Returns: - list[str]: A list of recommended book titles for the given user. ``` **Constraints**: - **Input**: - `user_history`: A dictionary with user IDs as keys and lists of purchased book titles as values. There can be between 1 and 1000 users, and each user can have purchased between 1 and 100 books. - `target_user`: A valid user ID that exists in the `user_history` dictionary. - `top_n`: A positive integer representing the number of recommendations to return. - **Output**: - A list of book titles (strings) recommended for the `target_user`. The list should have at most `top_n` items. **Example**: ```python user_history = { \\"user1\\": [\\"BookA\\", \\"BookB\\", \\"BookC\\"], \\"user2\\": [\\"BookB\\", \\"BookD\\", \\"BookE\\"], \\"user3\\": [\\"BookA\\", \\"BookE\\", \\"BookF\\"], \\"user4\\": [\\"BookC\\", \\"BookD\\", \\"BookG\\"] } target_user = \\"user1\\" top_n = 3 result = recommend_books(user_history, target_user, top_n) Expected Output (example): [\\"BookE\\", \\"BookD\\"] ``` **Guidelines for Implementation**: 1. **Similarity Measure**: Use Jaccard Similarity to find the most similar users based on their purchase history. 2. **Recommendation Logic**: Aggregate book titles from the most similar users that the target user has not yet purchased. 3. **Handling Edge Cases**: Consider scenarios where: - The target user has purchased all the books that similar users have. - The function should not recommend any books below the `top_n` threshold unless fewer than `top_n` books are available. 4. **Efficiency**: Ensure the function performs efficiently given the constraint sizes.","solution":"def recommend_books(user_history, target_user, top_n): from collections import Counter from itertools import chain def jaccard_similarity(set1, set2): intersection = len(set1.intersection(set2)) union = len(set1.union(set2)) return intersection / union target_books = set(user_history[target_user]) similarities = {} for user, books in user_history.items(): if user == target_user: continue similarity = jaccard_similarity(target_books, set(books)) similarities[user] = similarity similar_users = sorted(similarities, key=similarities.get, reverse=True) potential_books = [] for user in similar_users: potential_books.extend(book for book in user_history[user] if book not in target_books) recommended_books = [book for book, _ in Counter(chain.from_iterable( [[book] * potential_books.count(book) for book in potential_books] )).most_common(top_n)] return recommended_books[:top_n]"},{"question":"# Remove Duplicate Lines from a Multiline String Context: You are tasked with cleaning up the lines in a text document by removing any duplicate lines. The goal is to keep only the first occurrence of each line and to maintain the order in which they appear. Objective: Implement a function that takes a multiline string and returns a new multiline string with only unique lines, preserving their original order. Function Signature: ```python def remove_duplicate_lines(multiline_string: str) -> str: pass ``` Input: 1. **multiline_string** (str): The multiline string from which duplicate lines should be removed. Output: - **str**: The multiline string with duplicate lines removed. Constraints: - Each line in `multiline_string` will have a length between 0 and 500. - The number of lines in `multiline_string` will be between 0 and 10^4. Example: ```python input_string = hello world hello python world output_string = hello world python assert remove_duplicate_lines(input_string) == output_string input_string = a b c a b d e output_string = a b c d e assert remove_duplicate_lines(input_string) == output_string input_string = row1 row2 row1 row2 row1 row2 output_string = row1 row2 assert remove_duplicate_lines(input_string) == output_string ``` Note: - Ensure that your implementation handles edge cases such as empty input strings and strings where no duplicate lines exist. - You can assume that input to this function will always be valid and adhere to the constraints.","solution":"def remove_duplicate_lines(multiline_string: str) -> str: seen = set() unique_lines = [] for line in multiline_string.splitlines(): if line not in seen: seen.add(line) unique_lines.append(line) return \\"n\\".join(unique_lines)"},{"question":"New Question [Question 2]: # Scenario You\'re tasked with developing a system for a library that automatically categorizes incoming books based on their International Standard Book Number (ISBN). The categorization is determined by whether the provided ISBN is valid or not. # Task Write a function `validate_isbn` that checks if the given ISBN-10 or ISBN-13 number is valid. Your implementation needs to support both formats and correctly identify the validity. # Expected Function Signature ```python def validate_isbn(isbn: str) -> bool: pass ``` # Input - `isbn`: A string representing the ISBN-10 or ISBN-13 number (e.g., \'0-306-40615-2\' or \'978-3-16-148410-0\'). # Output - Returns a boolean—`True` if the ISBN is valid, `False` otherwise. # Constraints - The ISBN should either be 10 or 13 characters long, not including hyphens. - Hyphens may appear in the input, but they should be ignored during validation. - Must handle both ISBN-10 and ISBN-13 validation checks correctly. # Performance Requirements - The function should run in linear time O(n), where n is the length of the ISBN. - The function should use constant space O(1). # Example ```python assert validate_isbn(\'0-306-40615-2\') == True assert validate_isbn(\'978-3-16-148410-0\') == True assert validate_isbn(\'0-306-40615-1\') == False assert validate_isbn(\'978-3-16-148410-5\') == False assert validate_isbn(\'123-4-567-89012-8\') == False ``` # Notes 1. For ISBN-10, the validation algorithm involves calculating a weighted sum of 10 digits. 2. For ISBN-13, use the EAN-13 algorithm to check the validity. 3. Remove any non-numeric characters such as hyphens before processing. 4. Return `False` if the input does not match the required length for ISBN-10 or ISBN-13 after removing hyphens. # Detailed Validation **ISBN-10:** - Consists of 9 digits followed by an optional checksum digit which can be a digit or \'X\'. - Validation uses a weighted sum: (10*d1 + 9*d2 + 8*d3 + ... + 2*d9 + 1*d10) where d10 can be \'X\' (interpreted as 10). **ISBN-13:** - Comprised of 13 digits. - Uses a weighted sum: (1*d1 + 3*d2 + 1*d3 + 3*d4 + ... + 1*d13). - Resulting sum must be divisible by 10.","solution":"def validate_isbn(isbn: str) -> bool: Validates if the given ISBN-10 or ISBN-13 number is valid. isbn = isbn.replace(\'-\', \'\').replace(\' \', \'\') if len(isbn) == 10: return validate_isbn_10(isbn) elif len(isbn) == 13: return validate_isbn_13(isbn) return False def validate_isbn_10(isbn: str) -> bool: if len(isbn) != 10 or not isbn[:-1].isdigit() or (isbn[-1] != \'X\' and not isbn[-1].isdigit()): return False total = 0 for i in range(9): total += int(isbn[i]) * (10 - i) if isbn[-1] == \'X\': total += 10 else: total += int(isbn[-1]) return total % 11 == 0 def validate_isbn_13(isbn: str) -> bool: if len(isbn) != 13 or not isbn.isdigit(): return False total = 0 for i in range(13): if i % 2 == 0: total += int(isbn[i]) else: total += int(isbn[i]) * 3 return total % 10 == 0"},{"question":"# Rotate Square Matrix You are given a 2D square matrix of integers `matrix` where each sub-array represents a row. Write a function `rotate_matrix` that rotates the matrix 90 degrees clockwise and returns the rotated matrix. Input * `matrix`: A list of lists of integers (2D square matrix), where `1 <= len(matrix) <= 100` and each row and column have the same length. * Each element in the matrix `matrix[i][j]` is an integer where `-1000 <= matrix[i][j] <= 1000` Output * A list of lists of integers representing the rotated matrix. Constraints * You must perform the rotation in-place, meaning you should not use any additional lists or arrays to achieve the rotated state. Example ```python >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 0], [0, 1]]) [[0, 1], [1, 0]] >>> rotate_matrix([[1]]) [[1]] ``` Implementation Note Ensure that your solution efficiently handles the in-place transformation of the matrix while adhering to the constraints.","solution":"def rotate_matrix(matrix): Rotates the given n x n 2D matrix 90 degrees clockwise in place. :param matrix: List[List[int]] - a list of lists of integers representing the matrix :return: List[List[int]] - the rotated matrix n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element temp = matrix[i][j] # Move elements from left to top matrix[i][j] = matrix[n - j - 1][i] # Move elements from bottom to left matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1] # Move elements from right to bottom matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1] # Assign temp to right matrix[j][n - i - 1] = temp return matrix"},{"question":"# Football Team Manager You are working on a football team management application where you need to maintain the list of players in different teams. Your task is to implement a function `manage_team` that processes a series of operations on a team and returns the responses for each \\"show\\" operation. **Function Signature**: ```python def manage_team(team: List[str], operations: List[str]) -> List[str]: ``` **Input**: - `team`: a list of strings representing the initial players in the team. - `operations`: a list of strings representing operations to be performed on the team. Each string can be one of the following: - `\\"add <player_name>\\"`: adds the player_name to the team. - `\\"remove <player_name>\\"`: removes the player_name from the team if they exist. - `\\"show\\"`: shows the current list of players in the team, each player separated by a comma and a space. - `\\"size\\"`: returns the current count of players in the team. **Output**: - List of strings representing the output of \\"show\\" and \\"size\\" operations in the order they were executed. **Constraints**: - You can assume that no invalid operations will be provided in the input. - Player names can contain spaces and special characters. - Operations are case sensitive. **Example**: ```python team = [\\"John Doe\\", \\"Jane Smith\\"] operations = [ \\"add Mike Tyson\\", \\"show\\", \\"remove John Doe\\", \\"remove Alice Doe\\", \\"show\\", \\"size\\", \\"add Alice Johnson\\", \\"show\\" ] assert manage_team(team, operations) == [ \\"John Doe, Jane Smith, Mike Tyson\\", \\"Jane Smith, Mike Tyson\\", \\"2\\", \\"Jane Smith, Mike Tyson, Alice Johnson\\" ] ``` **Notes**: 1. Ensure the efficient handling of team list operations. 2. Maintain the order of players as they are added or removed from the team.","solution":"def manage_team(team, operations): Processes a series of operations on a football team and returns the responses for each \'show\' and \'size\' operation in order. Parameters: team (list of str): Initial list of players in the team. operations (list of str): List of operations to be performed on the team. Returns: list of str: Responses for each \'show\' and \'size\' operation. results = [] for operation in operations: if operation.startswith(\\"add \\"): player = operation[4:] team.append(player) elif operation.startswith(\\"remove \\"): player = operation[7:] if player in team: team.remove(player) elif operation == \\"show\\": results.append(\\", \\".join(team)) elif operation == \\"size\\": results.append(str(len(team))) return results"},{"question":"# Polynomial Regression Implementation You are required to implement a polynomial regression model from scratch. Using Python, you will write functions to fit a polynomial of arbitrary degree to a set of data points and predict new values. # Requirements: 1. **Data Preparation Functions** - Write a function to generate a Vandermonde matrix for a given degree. - `generate_vandermonde_matrix(x: list[float], degree: int) -> list[list[float]]` 2. **Model Fitting Function** - Implement a function to fit the polynomial regression model using the normal equation. - `fit_polynomial_regression(x: list[float], y: list[float], degree: int) -> list[float]` 3. **Prediction Function** - Develop a function to make predictions using the polynomial regression model. - `predict_polynomial_regression(x: list[float], coefficients: list[float]) -> list[float]` # Constraints: - You should use basic linear algebra operations without relying on high-level libraries such as numpy or scikit-learn. - Implement the functions such that they can accommodate polynomials of any reasonable degree. - Assume that the input data has no missing values and is correctly formatted. # Example Usage: ```python def main() -> None: # Example data points x = [1, 2, 3, 4, 5] y = [2, 3, 5, 7, 11] degree = 2 # Generate the Vandermonde matrix for the given degree vandermonde_matrix = generate_vandermonde_matrix(x, degree) print(\\"Vandermonde Matrix:\\") for row in vandermonde_matrix: print(row) # Fit the polynomial regression model coefficients = fit_polynomial_regression(x, y, degree) print(\\"Coefficients:\\", coefficients) # Make predictions predictions = predict_polynomial_regression(x, coefficients) print(\\"Predictions:\\", predictions) if __name__ == \'__main__\': main() ``` Implement these functions and test with appropriate datasets to ensure correctness and performance.","solution":"def generate_vandermonde_matrix(x, degree): Generates a Vandermonde matrix for the given values and degree. Args: x (list of float): The input x values. degree (int): The degree of the polynomial. Returns: list of list of float: The Vandermonde matrix. return [[xi ** d for d in range(degree + 1)] for xi in x] def fit_polynomial_regression(x, y, degree): Fits a polynomial regression model using the normal equation. Args: x (list of float): The input x values. y (list of float): The input y values. degree (int): The degree of the polynomial. Returns: list of float: The coefficients of the polynomial. # Generate Vandermonde matrix X = generate_vandermonde_matrix(x, degree) # Transpose of X X_T = list(zip(*X)) # Matrices for the normal equation # X_T * X XT_X = [[sum(a * b for a, b in zip(row, col)) for col in zip(*X)] for row in X_T] # X_T * y XT_y = [sum(a * b for a, b in zip(row, y)) for row in X_T] # Solve linear system XT_X * coefficients = XT_y using Gaussian elimination coefficients = gaussian_elimination(XT_X, XT_y) return coefficients def gaussian_elimination(A, b): Solves linear equations system Ax = b using Gaussian Elimination. Args: A (list of list of float): The coefficient matrix. b (list of float): The right-hand side vector. Returns: list of float: The solution vector. n = len(A) # Forward elimination for i in range(n): # Make A[i][i] = 1 factor = A[i][i] for j in range(i, n): A[i][j] /= factor b[i] /= factor # Make A[j][i] = 0 for all j != i for j in range(i + 1, n): factor = A[j][i] for k in range(i, n): A[j][k] -= factor * A[i][k] b[j] -= factor * b[i] # Back substitution x = [0] * n for i in range(n - 1, -1, -1): x[i] = b[i] - sum(A[i][j] * x[j] for j in range(i + 1, n)) return x def predict_polynomial_regression(x, coefficients): Predicts values using the polynomial regression model. Args: x (list of float): The input x values. coefficients (list of float): The polynomial coefficients. Returns: list of float: The predicted y values. def polynomial(xi): return sum(c * (xi ** i) for i, c in enumerate(coefficients)) return [polynomial(xi) for xi in x]"},{"question":"# Question You are tasked with implementing a function that calculates the Fibonacci sequence up to a given number using both recursive and iterative methods. The function should take an integer `n` as input and return a list of integers representing the Fibonacci sequence up to the `n`-th term. Requirements 1. Create two separate functions, one for the recursive method and one for the iterative method. 2. Each function should validate the input to ensure it is a non-negative integer. 3. If the input is not a non-negative integer, raise a `ValueError`. 4. The iterative function should handle large inputs efficiently by avoiding excessive recursion depth. Function Signatures ```python def fibonacci_recursive(n: int) -> list[int]: Generate Fibonacci sequence up to the n-th term using recursion. :param n: The number of terms in the Fibonacci sequence to generate. :return: A list of integers representing the Fibonacci sequence up to the n-th term. :raises ValueError: If the input is not a non-negative integer. pass def fibonacci_iterative(n: int) -> list[int]: Generate Fibonacci sequence up to the n-th term using iteration. :param n: The number of terms in the Fibonacci sequence to generate. :return: A list of integers representing the Fibonacci sequence up to the n-th term. :raises ValueError: If the input is not a non-negative integer. pass ``` Input - `n`: An integer representing the number of terms in the Fibonacci sequence to generate (0 <= n <= 50). Output - Returns a list of integers representing the Fibonacci sequence up to the `n`-th term. Constraints - Ensure efficient computation for both small and moderately large values of `n`. Examples ```python n = 5 fibonacci_recursive(n) # Output: [0, 1, 1, 2, 3] fibonacci_iterative(n) # Output: [0, 1, 1, 2, 3] n = 10 fibonacci_recursive(n) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] fibonacci_iterative(n) # Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] n = -1 # fibonacci_recursive(n) raises ValueError # fibonacci_iterative(n) raises ValueError ``` Hints - The recursive approach should include a base case for `n` equal to 0 or 1. - The iterative approach can involve a loop to accumulate the sequence in a list. By implementing both methods, you will gain insight into their performance differences and efficiency.","solution":"def fibonacci_recursive(n: int) -> list[int]: Generate Fibonacci sequence up to the n-th term using recursion. :param n: The number of terms in the Fibonacci sequence to generate. :return: A list of integers representing the Fibonacci sequence up to the n-th term. :raises ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") def fib_recursive(n): if n == 0: return [0] elif n == 1: return [0, 1] else: seq = fib_recursive(n - 1) seq.append(seq[-1] + seq[-2]) return seq return fib_recursive(n)[:n] def fibonacci_iterative(n: int) -> list[int]: Generate Fibonacci sequence up to the n-th term using iteration. :param n: The number of terms in the Fibonacci sequence to generate. :return: A list of integers representing the Fibonacci sequence up to the n-th term. :raises ValueError: If the input is not a non-negative integer. if not isinstance(n, int) or n < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if n == 0: return [] elif n == 1: return [0] seq = [0, 1] for _ in range(2, n): seq.append(seq[-1] + seq[-2]) return seq"},{"question":"# Context Bob is tasked with processing textual data for a natural language processing project. One of the tasks involves compressing strings by counting consecutive repeating characters. This is a common approach used in run-length encoding (RLE). Bob needs a function to perform this compression efficiently. # Task Write a function `compress_string` that takes a string as input and returns its run-length encoded version. The function should minimize the length of the encoded string by representing consecutive repeating characters with the character followed by the count of repetitions. If a character does not repeat consecutively, it should not be followed by a count. # Input - The input will be a string `s` consisting of lowercase letters. # Output - A string representing the run-length encoded version of the input. # Example ```python s = \\"aaabbccccdaa\\" compress_string(s) ``` Expected Output: ``` \\"a3b2c4da2\\" ``` # Constraints - The length of the string `s` is between 1 and 10,000 inclusive. # Notes - If a character appears only once consecutively, it should not be followed by the number 1. # Performance Requirements - The solution should handle large strings efficiently without unnecessary memory usage. # Additional Information This task helps ensure that learners understand string manipulation, specifically the ability to encode data using a straightforward form of compression.","solution":"def compress_string(s): Compresses the input string by counting consecutive repeating characters. Parameters: s (str): The input string consisting of lowercase letters. Returns: str: The run-length encoded version of the string. if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 # add the last group compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return \'\'.join(compressed)"},{"question":"# Phone Number Validation Function Context: In various applications, it\'s essential to validate phone numbers to ensure correct formatting. Proper formatting helps prevent errors and ensures consistent data storage. Task: Write a function `is_valid_phone_number(number: str) -> bool` that checks if a given phone number is valid according to a specific set of rules. Specifications: 1. The phone number must start with a `+` followed by the country code, which is a sequence of 1 to 3 digits. 2. The country code must be followed by a space. 3. The space-separated groups after the country code must meet the following criteria: - Each group may contain only digits (0-9). - Each group can be 1 to 4 digits long. - Groups must be separated by exactly one space. Input: - A single string `number`, representing the phone number to be validated. Output: - Return `True` if the phone number is valid according to the above rules, otherwise return `False`. Constraints: - Input phone number length should not exceed 20 characters. - Assume the given phone number does not contain any other characters except those mentioned in the rules. Example: ```python assert is_valid_phone_number(\\"+1 123 456 789\\") == True assert is_valid_phone_number(\\"+123 45\\") == True assert is_valid_phone_number(\\"+12 34 5678 9012\\") == True assert is_valid_phone_number(\\"+1234 567 89\\") == False assert is_valid_phone_number(\\"+12/34 5678\\") == False assert is_valid_phone_number(\\"123 456 789\\") == False ``` Notes: - Ensure your implementation strictly follows the given criteria. - Handle edge cases and invalid formats appropriately. ```python def is_valid_phone_number(number: str) -> bool: Returns True if the given phone number is valid according to the defined criteria. # Implement function here ```","solution":"def is_valid_phone_number(number: str) -> bool: Returns True if the given phone number is valid according to the defined criteria. if not number.startswith(\'+\'): return False parts = number.split(\' \') # The country code part should be the first part and must follow after the \'+\' if len(parts) < 2 or not parts[0][1:].isdigit() or not (1 <= len(parts[0][1:]) <= 3): return False # Check each group of digits after the country code for part in parts[1:]: if not part.isdigit() or not (1 <= len(part) <= 4): return False return True"},{"question":"# Problem Scenario You are building a utility to manage a collection of books in a library. One of the features of this utility is to enable users to search for books by keywords present in the book titles. The search should be case-insensitive and match any part of the book title. # Task Implement the `search_books_by_keyword` function in Python that returns a list of book titles containing a given keyword. # Function Signature ```python def search_books_by_keyword(books: List[str], keyword: str) -> List[str]: ... ``` # Constraints * `books` (List[str]): A list of strings representing book titles. * `keyword` (str): A string representing the keyword to search for. # Input * `books`: a list of book titles, where each title is a non-empty string. * `keyword`: a non-empty string representing the keyword for searching. # Output * A list of strings, each representing a book title that contains the keyword. The returned list should be sorted in the same order as the books appear in the input list. # Example ```python books = [ \\"The Great Gatsby\\", \\"To Kill a Mockingbird\\", \\"The Catcher in the Rye\\", \\"Great Expectations\\" ] print(search_books_by_keyword(books, \\"great\\")) # Output: [\'The Great Gatsby\', \'Great Expectations\'] print(search_books_by_keyword(books, \\"THE\\")) # Output: [\'The Great Gatsby\', \'The Catcher in the Rye\'] ``` # Note * The search should be case-insensitive, meaning that the keyword \\"great\\" should match both \\"Great\\" and \\"great\\". * Ensure input validation is performed to handle edge cases, such as an empty list of books or an empty keyword string. * The order of the output list should follow the order of the input list. Implement the `search_books_by_keyword` function as specified, ensuring it meets all the constraints and requirements outlined above.","solution":"from typing import List def search_books_by_keyword(books: List[str], keyword: str) -> List[str]: Returns a list of book titles that contain the given keyword. The search is case-insensitive and matches any part of the book title. Parameters: - books: List of book titles (each title is a string) - keyword: Keyword to search for (a string) Returns: - A list of book titles that contain the keyword, in the same order as they appear in the input list. keyword_lower = keyword.lower() return [book for book in books if keyword_lower in book.lower()]"},{"question":"# Array Rotation and Query Problem Statement: You are required to write a program that performs a series of operations on an array. The operations are of two types: rotations and queries. A rotation shifts all elements of the array to the right by one position, and a query returns the element at a specified index. Requirements: 1. Implement a function `perform_operations(arr: List[int], operations: List[Tuple[str, int]]) -> List[int]` where each operation is either a rotation (\\"rotate\\") or a query (\\"query\\"), followed by an integer which denotes the index in case of a query operation. 2. For a \\"rotate\\" operation, shift all elements of the array to the right by one position. 3. For a \\"query\\" operation, return the element present at the given index at the current state of the array. Function Signature: ```python from typing import List, Tuple def perform_operations(arr: List[int], operations: List[Tuple[str, int]]) -> List[int]: pass ``` Constraints: * The initial array `arr` will have a length in the range 1 ≤ len(arr) ≤ 10^5. * The number of operations will be in the range 1 ≤ len(operations) ≤ 10^5. * Valid indices for \\"query\\" operations will be within the bounds of the array. Example: ```python arr = [1, 2, 3, 4, 5] operations = [(\\"rotate\\", 0), (\\"rotate\\", 0), (\\"query\\", 0), (\\"query\\", 1)] assert perform_operations(arr, operations) == [4, 5] arr = [3, 8, 9, 7, 6] operations = [(\\"rotate\\", 0), (\\"query\\", 1), (\\"rotate\\", 0), (\\"query\\", 3)] assert perform_operations(arr, operations) == [9, 8] ``` Performance Requirements: * The function should complete within 1 second for any valid input within the constraints. * Aim to optimize both rotation and query operations to ensure efficiency. Notes: * Consider that multiple rotations may be condensed to a single effective rotation step for optimization. * Ensure the solution doesn\'t exceed time complexity constraints even with large inputs.","solution":"from typing import List, Tuple def perform_operations(arr: List[int], operations: List[Tuple[str, int]]) -> List[int]: n = len(arr) effective_rotations = 0 results = [] for op, idx in operations: if op == \\"rotate\\": effective_rotations = (effective_rotations + 1) % n elif op == \\"query\\": adjusted_index = (idx - effective_rotations) % n results.append(arr[adjusted_index]) return results"},{"question":"# Problem Statement Implement a function that takes a list of integers and an integer `n`, and returns the first `n` unique elements from the list in the given order. If the list contains fewer than `n` unique elements, return all the unique elements present in the list. # Function Signature ```python def first_n_unique_elements(arr: list, n: int) -> list: ``` # Input * A list `arr` of integers. * An integer `n` representing the number of unique elements to return. # Output * A list containing the first `n` unique integers from the input list, in the order they appear. # Constraints * The length of the input list will be between 0 and 10^5. * The elements of the list will be integers, which can be positive, negative, or zero. * The integer `n` will be a non-negative integer. * If the input list is empty or `n` is 0, return an empty list. * If `n` is greater than the number of unique elements in the list, return all unique elements. # Examples ```python first_n_unique_elements([4, 5, 1, 2, 4, 3, 1, 2, 3], 3) => [4, 5, 1] first_n_unique_elements([7, 7, 7, 7], 2) => [7] first_n_unique_elements([], 5) => [] first_n_unique_elements([-1, -2, -3, -4, -1, -2, -3], 5) => [-1, -2, -3, -4] first_n_unique_elements([1, 2, 3, 4, 5], 8) => [1, 2, 3, 4, 5] first_n_unique_elements([10, 20, 20, 10, 30], 1) => [10] ``` # Additional Information * Ensure your solution handles edge cases like an empty list or `n` being zero correctly. * Consider performance implications, especially when the list is large. * Explain in your comments or documentation how the approach guarantees the order and uniqueness constraints.","solution":"def first_n_unique_elements(arr: list, n: int) -> list: Returns the first n unique elements from the list in the order they appear. Parameters: arr (list): A list of integers. n (int): The number of unique elements to return. Returns: list: A list containing the first n unique integers from the input list. if n == 0 or len(arr) == 0: return [] seen = set() unique_elements = [] for val in arr: if val not in seen: unique_elements.append(val) seen.add(val) if len(unique_elements) == n: break return unique_elements"},{"question":"# Problem Statement **Optimization of Warehouse Storage Allocation** You have been hired to optimize the storage allocation in a warehouse. The warehouse is represented as a 2D grid, where each cell can store a certain number of items. The objective is to maximize the total number of items stored in the warehouse given a set of storage constraints. # Requirements: 1. You are given a grid represented as a 2D list where each cell contains an integer that represents the storage capacity of that cell. 2. You need to implement the `WarehouseOptimizer` class to find the optimal allocation of items to cells, complying with the constraints. # Implementation Details: - Implement the following methods: 1. `__init__(self, grid: list[list[int]], constraints: list[int])` - Initializes the WarehouseOptimizer with the given grid and a list of storage constraints. The constraints list contains the number of items to be allocated to the corresponding rows. 2. `allocate_storage(self) -> list[list[int]]` - Allocates items efficiently into the warehouse cells and returns the grid after allocation. Each cell should contain the number of items stored, not exceeding its capacity. # Expected Input and Output - **Input**: - A grid (a 2D list of integers representing storage capacities) - A list of constraints (integers representing the number of items that must be stored in each corresponding row) - **Output**: - A 2D list of integers representing the warehouse grid after storage allocation. Constraints: - The grid dimensions and capacity values are non-negative integers. - Each row in the grid should comply with the corresponding constraint. - Each cell\'s number of stored items must not exceed its storage capacity. # Sample Usage: ```python # Define the warehouse layout and constraints grid = [ [3, 1, 4], [2, 0, 3], [1, 5, 2] ] constraints = [5, 3, 6] # Total items to store in each row respectively. # Instantiating and optimizing with WarehouseOptimizer optimizer = WarehouseOptimizer(grid, constraints) allocation = optimizer.allocate_storage() print(allocation) # Expected output might be: # [ # [3, 1, 1], # 3 items in the first cell, 1 in the second cell, 1 in the third cell (total 5) # [2, 0, 1], # 2 items in the first cell, 0 in the second cell, 1 in the third cell (total 3) # [1, 5, 0], # 1 item in the first cell, 5 in the second cell, 0 in the third cell (total 6) # ] ``` --- # Note: This problem requires understanding of dynamic programming or greedy algorithms to efficiently distribute the items matching the constraints. Consider edge cases where some cells might have zero capacity or constraints might exceed the total row capacity. Optimize your solution for various grid sizes. Good luck!","solution":"class WarehouseOptimizer: def __init__(self, grid, constraints): self.grid = grid self.constraints = constraints def allocate_storage(self): allocation = [[0] * len(row) for row in self.grid] for row_index, (row, constraint) in enumerate(zip(self.grid, self.constraints)): for col_index in range(len(row)): if constraint <= 0: break allocation[row_index][col_index] = min(row[col_index], constraint) constraint -= allocation[row_index][col_index] return allocation"},{"question":"# Problem Statement Given a sorted array of unique integers and a target integer, write a function to find the starting and ending position of a given target value. If the target is not found in the array, return [-1, -1]. # Function to Implement **Function**: `find_range(nums: List[int], target: int) -> List[int]` You need to implement the above function. This function should return a list containing two integers, the starting index and ending index of the target value in the array. If the target is not present, return [-1, -1]. # Input and Output Formats * **Input**: * `nums` (List[int]): A sorted list of unique integers. * `target` (int): The target value to find in the list. * **Output**: * **List[int]**: A list with two integers indicating the starting and ending index of `target` in `nums`. If `target` is not found, return [-1, -1]. # Constraints * The input list `nums` will have at most `10^5` elements. * Each element of `nums` and the `target` will be in the range `[-10^9, 10^9]`. * The array is sorted in ascending order and contains unique integers. # Examples ```python assert find_range([1, 2, 3, 4, 5, 6, 7], 3) == [2, 2] assert find_range([1, 3, 5, 7, 9], 4) == [-1, -1] assert find_range([5, 10, 15, 20, 25], 15) == [2, 2] assert find_range([10, 20, 30, 40, 50], 40) == [3, 3] assert find_range([], 5) == [-1, -1] ``` # Implementation Details * Ensure the function handles edge cases such as an empty array or single element array correctly. * Optimize the function to find the starting and ending position using binary search to achieve `O(log n)` time complexity.","solution":"from typing import List def find_range(nums: List[int], target: int) -> List[int]: def binary_search_left(arr, x): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] < x: low = mid + 1 else: high = mid - 1 return low def binary_search_right(arr, x): low, high = 0, len(arr) - 1 while low <= high: mid = (low + high) // 2 if arr[mid] <= x: low = mid + 1 else: high = mid - 1 return high left_idx = binary_search_left(nums, target) right_idx = binary_search_right(nums, target) if left_idx <= right_idx < len(nums) and nums[left_idx] == target: return [left_idx, right_idx] else: return [-1, -1]"},{"question":"# Problem Scenario/Context You are working on a warehouse management system where shelves are used to store various items. The items are arranged in stacks, and each stack can hold a maximum number of items before they need to be moved to a new stack. Given the height of stacks and the dimensions of the warehouse, you need to determine the optimal arrangement of stacks to minimize the number of required stacks and the overall height utilization. # Task You are to write a function `optimize_shelf_stacks` that takes in three integer parameters `n_shelves` (number of shelves), `max_height` (maximum height of each shelf in terms of number of items), and `n_items` (total number of items to be stored). The function should return the minimum number of stacks needed to store all the items optimally without exceeding the maximum height for any shelf. Function Signature ```python def optimize_shelf_stacks(n_shelves: int, max_height: int, n_items: int) -> int: pass ``` Input * `n_shelves` (int): number of shelves, 1 ≤ n_shelves ≤ 10,000. * `max_height` (int): maximum height of each shelf in terms of items, 1 ≤ max_height ≤ 1,000. * `n_items` (int): total number of items to store, 1 ≤ n_items ≤ 1,000,000. Output * `int`: minimum number of stacks needed to store all items. # Constraints * The function should efficiently handle large inputs up to the given limits. * Ensure that no shelf exceeds the maximum height constraint. # Example ```python >>> optimize_shelf_stacks(20, 50, 1200) 24 >>> optimize_shelf_stacks(10, 100, 500) 5 ``` # Requirements * Consider various arrangement possibilities to achieve the optimal stacking. * Ensure the function runs efficiently within the provided constraints. # Notes * For a given item count and maximum stack height, determine how items can be distributed across the shelves without violating the height restriction. * Utilize algorithms that efficiently distribute items to minimize stack usage and maximize storage efficiency.","solution":"def optimize_shelf_stacks(n_shelves: int, max_height: int, n_items: int) -> int: Calculate the minimum number of stacks needed to store all items without exceeding the maximum height for any shelf. Parameters: n_shelves (int): Number of shelves. max_height (int): Maximum height of each shelf in terms of items. n_items (int): Total number of items to store. Returns: int: Minimum number of stacks needed. if n_items == 0: return 0 max_total_height = n_shelves * max_height # If we have fewer items than the combined height of all shelves, we can fit them accordingly if n_items <= max_total_height: return (n_items + max_height - 1) // max_height # This is equivalent to math.ceil(n_items / max_height) # Otherwise, simply stack all items without considering the number of shelves return (n_items + max_height - 1) // max_height # This is equivalent to math.ceil(n_items / max_height)"},{"question":"# Implement a Stream Data Aggregator You are tasked with creating a `StreamAggregator` class for a real-time analytics system. The system processes an incoming stream of numerical data and provides the ability to retrieve aggregated information like sum, average, maximum, and minimum values at any given time. Your task is to implement the `StreamAggregator` class that efficiently manages these aggregations as new data is continuously appended. You need to: 1. **Initialize** the `StreamAggregator` with no initial data. 2. **Implement** methods to: - Add new data points. - Retrieve the current sum of all streamed data points. - Retrieve the current average of all streamed data points. - Retrieve the current maximum and minimum values from all streamed data points. # Input and Output Format - The `StreamAggregator` class should support: - `add(self, value: float) -> None`: Add a new data point to the stream. - `get_sum(self) -> float`: Return the sum of all recorded data points. - `get_average(self) -> float`: Return the average of all recorded data points. - `get_max(self) -> float`: Return the maximum value from the recorded data points. - `get_min(self) -> float`: Return the minimum value from the recorded data points. - Assume input methods are called directly on the `StreamAggregator` instance. - For edge cases, return appropriate values or raise errors as necessary, such as division by zero for average calculation before any data points are added. Example ```python class StreamAggregator: def __init__(self) -> None: self.data = [] self.sum = 0.0 self.max = float(\'-inf\') self.min = float(\'inf\') def add(self, value: float) -> None: self.data.append(value) self.sum += value if value > self.max: self.max = value if value < self.min: self.min = value def get_sum(self) -> float: return self.sum def get_average(self) -> float: if not self.data: raise ValueError(\\"No data points added.\\") return self.sum / len(self.data) def get_max(self) -> float: if not self.data: raise ValueError(\\"No data points added.\\") return self.max def get_min(self) -> float: if not self.data: raise ValueError(\\"No data points added.\\") return self.min # Test Cases stream = StreamAggregator() stream.add(4.0) stream.add(7.0) stream.add(1.0) assert stream.get_sum() == 12.0 assert stream.get_average() == 4.0 assert stream.get_max() == 7.0 assert stream.get_min() == 1.0 stream.add(10.0) assert stream.get_sum() == 22.0 assert stream.get_average() == 5.5 assert stream.get_max() == 10.0 assert stream.get_min() == 1.0 ``` Provide the complete implementation of the `StreamAggregator` class.","solution":"class StreamAggregator: def __init__(self) -> None: self.data = [] self.sum = 0.0 self.max = float(\'-inf\') self.min = float(\'inf\') def add(self, value: float) -> None: self.data.append(value) self.sum += value if value > self.max: self.max = value if value < self.min: self.min = value def get_sum(self) -> float: return self.sum def get_average(self) -> float: if not self.data: raise ValueError(\\"No data points added.\\") return self.sum / len(self.data) def get_max(self) -> float: if not self.data: raise ValueError(\\"No data points added.\\") return self.max def get_min(self) -> float: if not self.data: raise ValueError(\\"No data points added.\\") return self.min"},{"question":"# Detecting Cycles in a Directed Graph Context You are working as a software engineer tasked with developing an application that processes various data flows represented by graphs. To ensure the integrity of the process flows, it\'s important to detect and prevent cyclic dependencies. You need an algorithm that efficiently detects cycles in a directed graph. Task Write a function `has_cycle` that determines if a given directed graph has a cycle. If the graph contains any cycle, the function should return `True`, otherwise `False`. **Function Signature**: ```python def has_cycle(num_nodes: int, edges: List[Tuple[int, int]]) -> bool: pass ``` Input - `num_nodes` (int): The number of nodes in the graph, where 0 ≤ num_nodes ≤ 100,000. - `edges` (List[Tuple[int, int]]): A list of tuples representing directed edges between nodes. Each tuple (u, v) indicates a directed edge from node u to node v. Output - (bool): Returns `True` if the graph contains at least one cycle, otherwise `False`. Constraints - Ensure the function runs efficiently for large values of `num_nodes`. - Utilize a depth-first search (DFS) or other suitable algorithms to detect cycles in the graph. - Maintain a time complexity of O(num_nodes + len(edges)). Examples 1. **Input**: `num_nodes = 4`, `edges = [(0, 1), (1, 2), (2, 3), (3, 1)]` **Output**: `True` (there is a cycle 1 -> 2 -> 3 -> 1) 2. **Input**: `num_nodes = 3`, `edges = [(0, 1), (1, 2)]` **Output**: `False` (no cycles in the graph) 3. **Input**: `num_nodes = 2`, `edges = [(0, 1), (1, 0)]` **Output**: `True` (there is a cycle 0 -> 1 -> 0) Leverage the given algorithm structure to implement the `has_cycle` function and ensure it handles all test cases and edge scenarios effectively.","solution":"from typing import List, Tuple def has_cycle(num_nodes: int, edges: List[Tuple[int, int]]) -> bool: def dfs(node): if node in visiting: return True if node in visited: return False visiting.add(node) for neighbor in adjacency_list[node]: if dfs(neighbor): return True visiting.remove(node) visited.add(node) return False adjacency_list = {i: [] for i in range(num_nodes)} for u, v in edges: adjacency_list[u].append(v) visited = set() visiting = set() for node in range(num_nodes): if dfs(node): return True return False"},{"question":"# Problem Statement You are working as a software engineer at a networking company. Your team needs to create a function to compress a string using the Run-Length Encoding (RLE) algorithm, which is a basic form of data compression. RLE works by replacing consecutive repeating characters with the character followed by the number of repetitions. Your task is to implement this function. # Function Signature ```python def rle_compress(input_str: str) -> str: pass ``` # Input - `input_str` (str): A non-empty string consisting of uppercase and lowercase English letters. # Output - A compressed string using the RLE algorithm. # Examples ```python >>> rle_compress(\\"aaabbcddd\\") \'a3b2c1d3\' >>> rle_compress(\\"aabcccccaaa\\") \'a2b1c5a3\' >>> rle_compress(\\"abcd\\") \'a1b1c1d1\' ``` # Constraints - The input string will have at least one character and at most (10^6) characters. - The compressed string should be returned in the format where each character is followed by the number of its repetitions. # Instructions Implement the `rle_compress` function following the guidelines and constraints stated above.","solution":"def rle_compress(input_str: str) -> str: if not input_str: return \\"\\" compressed_str = [] current_char = input_str[0] count = 1 for char in input_str[1:]: if char == current_char: count += 1 else: compressed_str.append(f\\"{current_char}{count}\\") current_char = char count = 1 # Don\'t forget to append the last set of characters compressed_str.append(f\\"{current_char}{count}\\") return \\"\\".join(compressed_str)"},{"question":"Given a directed graph, design an algorithm to detect if there is a cycle present in the graph. Use Depth-First Search (DFS) for the implementation. **Requirements**: 1. Implement a function `is_cyclic` that determines if the directed graph contains a cycle. 2. Expected Time Complexity: O(V + E), where V is the number of vertices and E is the number of edges in the graph. 3. Expected Space Complexity: O(V) due to recursion stack and additional space for marking visited nodes. **Function Signature**: ```python def is_cyclic(n: int, edges: List[Tuple[int, int]]) -> bool: # Your implementation here pass ``` **Input/Output**: - Input: - `n`: an integer `n`, representing the number of vertices. - `edges`: a list of tuples, where each tuple `(u, v)` represents a directed edge from vertex `u` to vertex `v`. - Output: A boolean value `True` if the graph contains a cycle, otherwise `False`. **Constraints**: - 1 <= n <= 10^5 - 0 <= len(edges) <= 10^5 - The graph may be disconnected. **Examples**: ```python # Example 1: A graph with a cycle n1 = 4 edges1 = [(0, 1), (1, 2), (2, 0), (3, 2)] assert is_cyclic(n1, edges1) == True # Example 2: A graph without a cycle n2 = 3 edges2 = [(0, 1), (1, 2)] assert is_cyclic(n2, edges2) == False # Example 3: A disconnected graph with a cycle in one component n3 = 5 edges3 = [(0, 1), (1, 2), (2, 0), (3, 4)] assert is_cyclic(n3, edges3) == True # Example 4: A disconnected graph without any cycles n4 = 3 edges4 = [(0, 1), (1, 2)] assert is_cyclic(n4, edges4) == False ``` **Hint**: Utilize recursion and maintain a record of the recursion stack to detect back edges which indicate a cycle.","solution":"def is_cyclic(n, edges): from collections import defaultdict def dfs(v): visited[v] = True rec_stack[v] = True for neighbour in adj_list[v]: if not visited[neighbour]: if dfs(neighbour): return True elif rec_stack[neighbour]: return True rec_stack[v] = False return False adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) visited = [False] * n rec_stack = [False] * n for node in range(n): if not visited[node]: if dfs(node): return True return False"},{"question":"# Coding Assessment Question: You are tasked with implementing a function that checks if a given positive integer number `n` is a \\"Twisted Prime\\". A number is considered a \\"Twisted Prime\\" if it is a prime number and its digits reversed also form a prime number. Function Signature: ```python def is_twisted_prime(n: int) -> bool: Given an integer n, determine if it is a Twisted Prime. A Twisted Prime is a number that remains prime even when its digits are reversed. Parameters: n (int): The positive integer number to check. Returns: bool: True if n is a Twisted Prime, False otherwise. pass ``` Parameters: - `n` (int): A positive integer to check for the Twisted Prime property. Must be greater than 1. Output: - Returns `True` if `n` is a Twisted Prime, `False` otherwise. Constraints: - (2 leq n leq 10^9) Examples: ```python assert is_twisted_prime(13) == True # 13 and 31 are both primes assert is_twisted_prime(17) == False # 71 is prime but 17 is not assert is_twisted_prime(31) == True # 31 and 13 are both primes assert is_twisted_prime(23) == False # 32 is not a prime assert is_twisted_prime(29) == True # 29 and 92 are both primes ``` Guideline for Implementation: 1. Implement a helper function to check if a given number is prime. 2. Implement another helper function to reverse the digits of an integer. 3. Use the helper functions to check if both the original number and its reversed number are prime. 4. Ensure efficient prime-checking algorithm, suitable for handling large numbers within the constraint limits. 5. Optimize for performance to handle (10^9) efficiently. Note: - Prime checking can be optimized using techniques such as the Sieve of Eratosthenes for a range of numbers or probabilistic tests for larger numbers. - Use careful integer manipulation to reverse the digits of the number without converting to a string if possible for efficiency.","solution":"def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def reverse_number(num): reversed_num = 0 while num > 0: reversed_num = reversed_num * 10 + num % 10 num //= 10 return reversed_num def is_twisted_prime(n: int) -> bool: if not is_prime(n): return False reversed_n = reverse_number(n) return is_prime(reversed_n)"},{"question":"# Coding Question on Data Structures and Graph Algorithms Context Graph traversal algorithms are fundamental in computer science, often used in networking, pathfinding, and many other applications. You\'re tasked with implementing a graph traversal function that ensures all nodes in a graph are visited. Problem Design a function `bfs_traversal(graph, start_node)` that performs a Breadth-First Search (BFS) on a given graph. The graph is represented as an adjacency list, with each node pointing to a list of its neighboring nodes. The BFS must start from the specified start node and return the order in which nodes are visited. Requirements To achieve this: 1. Implement the BFS algorithm using a queue. 2. Ensure all reachable nodes from the start node are visited. 3. Return a list of nodes in the order they are visited. Input and Output * **Input**: - A dictionary `graph` representing the adjacency list of the graph (e.g., `{0: [1, 2], 1: [0, 3], 2: [0], 3: [1]}`) - An integer `start_node` indicating the starting node for BFS (e.g., `0`). * **Output**: - A list of integers representing the nodes in the order they are visited. Example ```python def bfs_traversal(graph, start_node): # Your code here # Example: graph = {0: [1, 2], 1: [0, 3], 2: [0], 3: [1]} start_node = 0 print(bfs_traversal(graph, start_node)) # Expected output: [0, 1, 2, 3] ``` You are required to provide a function definition for `bfs_traversal(graph, start_node)` and ensure it accurately returns the nodes in the expected BFS visitation order for the given example case. Use appropriate data structures and algorithms to maintain efficiency.","solution":"from collections import deque def bfs_traversal(graph, start_node): Performs BFS on the given graph starting from the start_node. :param graph: Dictionary representing the adjacency list of the graph :param start_node: The node from which BFS starts :return: List of nodes in the order they are visited visited = set() queue = deque([start_node]) bfs_order = [] while queue: current_node = queue.popleft() if current_node not in visited: visited.add(current_node) bfs_order.append(current_node) for neighbor in graph.get(current_node, []): if neighbor not in visited: queue.append(neighbor) return bfs_order"},{"question":"# Organizing an Event You are tasked with creating a program that helps event planners organize attendees into groups based on their preferences. The planner needs a way to allocate attendees into different groups of a fixed size, without exceeding it. # Requirements 1. **Function Implementation**: Implement a function `group_attendees` that accepts a list of preferences and an integer group size. Each preference indicates the attendee\'s preferred group. 2. **Grouping Logic**: The function should allocate attendees to groups in such a way that: - Each group does not exceed the specified group size. - Attendees with similar preferences are grouped together as much as possible. - If an attendee cannot be placed in a group due to size constraints, they should be allocated to the next available group. 3. **Result Structure**: The function should return a list of lists, where each sublist represents a group of attendees. # Input/Output Format - **Input**: - `group_attendees(preferences: List[str], group_size: int) -> List[List[str]]`: Organizes the input list of preferences into groups based on the specified group size. - **Output**: - A list of lists representing the grouped attendees. # Performance Requirements - Ensure the solution maintains a time complexity of `O(n)` where `n` is the length of the preferences list. - Space complexity should be considered `O(n)` due to the need to store grouped results. # Constraints - Each preference in the list is a string representing the attendee\'s preferred group. - `group_size` must be a positive integer. # Example Workflow ```python preferences = [\\"GroupA\\", \\"GroupB\\", \\"GroupA\\", \\"GroupC\\", \\"GroupB\\", \\"GroupA\\"] group_size = 2 groups = group_attendees(preferences, group_size) print(groups) # OUTPUT: [[\\"GroupA\\", \\"GroupA\\"], [\\"GroupB\\", \\"GroupB\\"], [\\"GroupA\\", \\"GroupC\\"]] ``` # Hints for Consideration - Utilize a dictionary to keep track of preferences and their counts. - Consider how you can efficiently fill groups without exceeding the specified group size. - Ensure any remaining attendees are grouped appropriately if they do not fit into a completely filled group slot.","solution":"from collections import defaultdict from typing import List def group_attendees(preferences: List[str], group_size: int) -> List[List[str]]: Distribute attendees into groups based on their preferences and specified group size. :param preferences: List of attendee preferences. :param group_size: The maximum size of each group. :return: A list of grouped attendees. # Dictionary to store preferences and their counts preference_counts = defaultdict(list) # Store attendees in their respective preference lists for attendee in preferences: preference_counts[attendee].append(attendee) groups = [] # Create groups based on preferences for attendees in preference_counts.values(): while len(attendees) > 0: groups.append(attendees[:group_size]) attendees = attendees[group_size:] return groups"},{"question":"# Coding Question Scenario You are developing a tool for financial analysis and need to process a large dataset of stock prices. A common task is to calculate moving averages, which helps in identifying trends over a specified period. In this context, you are required to implement a function to compute the simple moving average (SMA) for given stock prices over a specified window size. Problem Statement Write a function `moving_average` that calculates the simple moving average of a list of stock prices over a specified window size. The function should handle edge cases appropriately and ensure the computation is efficient even for large datasets. Implementation - You are given a list of stock prices `prices`, where each price is a float. - The function `moving_average` should accept: - A list of floats `prices` - An integer `window_size` indicating the size of the moving average window - The function should return a list of floats representing the simple moving average for each window of prices. Input - `prices`: A list of floats representing stock prices. - `window_size`: An integer indicating the size of the moving average window. Output - A list of floats representing the simple moving average for the given window size. Constraints - `prices` will have at least one element and at most 100,000 elements. - Each element in `prices` will be within the range `0.0` to `10,000.0`. - `window_size` will be a positive integer between 1 and the length of `prices`. Example ```python def moving_average(prices, window_size): # implementation here # Example usage prices = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] window_size = 4 print(moving_average(prices, window_size)) # Output should be [2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5] ``` Ensure that your implementation handles cases where the window size is equal to the length of the prices list and provides accurate results for the boundaries. Use efficient algorithms to maintain performance with large datasets.","solution":"def moving_average(prices, window_size): Calculate the simple moving average of stock prices over a specified window size. :param prices: List of floats representing stock prices. :param window_size: An integer representing the size of the moving average window. :return: List of floats representing the simple moving average for each window of prices. if window_size <= 0 or window_size > len(prices): raise ValueError(\\"window_size must be a positive integer within the range of the prices list length\\") moving_averages = [] window_sum = sum(prices[:window_size]) for i in range(len(prices) - window_size + 1): if i > 0: window_sum = window_sum - prices[i - 1] + prices[i + window_size - 1] moving_averages.append(window_sum / window_size) return moving_averages # Example usage prices = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0] window_size = 4 print(moving_average(prices, window_size)) # Expected output: [2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5]"},{"question":"# Assignment: Minimum Steps to One Context In algorithmic problem solving, transforming a number to another following specific rules is a classic challenge. One such problem is reducing a number to one with the minimum number of steps. This type of problem has applications in optimization, dynamic programming, and various real-world scenarios where reducing complexity in iterative processes is crucial. Problem Statement Write a function `min_steps_to_one(n: int) -> int` that calculates and returns the minimum number of steps required to reduce the given integer `n` to one. You can perform the following operations: 1. Subtract 1 from the number. 2. If the number is divisible by 2, divide it by 2. 3. If the number is divisible by 3, divide it by 3. Input * An integer `n`, where 1 ≤ n ≤ 10,000. Output * An integer representing the minimum number of steps to reduce `n` to one. Constraints * The input number will be a positive integer between 1 and 10,000 inclusive. Example ```python >>> min_steps_to_one(10) 3 >>> min_steps_to_one(15) 4 >>> min_steps_to_one(1) 0 ``` Requirements * The function should efficiently handle the maximum constraint (n = 10,000). * Use dynamic programming or memoization to optimize the solution. Implementation Notes * Initialize an array `dp` where `dp[i]` represents the fewest steps to reach 1 from `i`. * Use a bottom-up approach to fill the `dp` array, starting from `dp[1]` which is zero. * For each number, consider all possible operations and choose the one that requires fewer steps. * Ensure to handle edge cases explicitly, such as when `n` is already 1.","solution":"def min_steps_to_one(n): Returns the minimum number of steps required to reduce n to 1. if n == 1: return 0 dp = [0] * (n + 1) for i in range(2, n + 1): # Subtract 1 step dp[i] = dp[i - 1] + 1 # If divisible by 2, choose to divide by 2 step if it\'s better if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) # If divisible by 3, choose to divide by 3 step if it\'s better if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"**Prime Number Checker and Sieve of Eratosthenes** # Problem Statement You are required to write two functions: one to check if a given number is prime and another to generate all prime numbers up to a given limit using the Sieve of Eratosthenes algorithm. Both functions should be efficient in terms of time complexity. # Function Signatures ```python def is_prime(n: int) -> bool: Determines if a given number is a prime number. Parameters: - n (int): The number to check for primality. Returns: - bool: True if the number is prime, otherwise False. pass def sieve_of_eratosthenes(limit: int) -> List[int]: Generates all prime numbers up to a given limit using the Sieve of Eratosthenes. Parameters: - limit (int): The upper limit (inclusive) up to which primes are to be generated. Returns: - List[int]: A list of prime numbers up to the given limit. pass ``` # Input - For `is_prime(n)`, `n` is an integer where `2 <= n <= 10^6`. - For `sieve_of_eratosthenes(limit)`, `limit` is an integer where `2 <= limit <= 10^6`. # Output - For `is_prime(n)`, return `True` if `n` is a prime number, otherwise return `False`. - For `sieve_of_eratosthenes(limit)`, return a list of prime numbers up to the given `limit` (inclusive). # Examples ```python # Example usage of is_prime print(is_prime(5)) # Expected: True print(is_prime(4)) # Expected: False # Example usage of sieve_of_eratosthenes print(sieve_of_eratosthenes(10)) # Expected: [2, 3, 5, 7] print(sieve_of_eratosthenes(20)) # Expected: [2, 3, 5, 7, 11, 13, 17, 19] ``` # Requirements - The `is_prime` function should have a time complexity of O(√N). - The `sieve_of_eratosthenes` function should have a time complexity of O(N log log N). - Ensure proper handling of all edge cases, such as the smallest and largest possible values for the inputs. - Provide necessary error handling and validation. # Testing Ensure extensive testing with: - Small and large numbers for primality checks. - Limits that include multiple ranges for the sieve algorithm. - Edge cases and performance-related cases with upper constraint values.","solution":"from typing import List def is_prime(n: int) -> bool: Determines if a given number is a prime number. Parameters: - n (int): The number to check for primality. Returns: - bool: True if the number is prime, otherwise False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def sieve_of_eratosthenes(limit: int) -> List[int]: Generates all prime numbers up to a given limit using the Sieve of Eratosthenes. Parameters: - limit (int): The upper limit (inclusive) up to which primes are to be generated. Returns: - List[int]: A list of prime numbers up to the given limit. sieve = [True] * (limit + 1) sieve[0] = sieve[1] = False p = 2 while p * p <= limit: if sieve[p]: for i in range(p * p, limit + 1, p): sieve[i] = False p += 1 return [p for p in range(limit + 1) if sieve[p]]"},{"question":"# Scenario: In a storage system for digital documents, it\'s often necessary to manage access based on user permissions and roles. Imagine a system where documents can be tagged for different access levels, and users are granted permissions based on their roles and individual settings. Access control mechanisms are vital to ensure that only authorized users can view or manipulate the documents. # Task: Design and implement an access control system using classes that handle user roles, permissions, and document access. Your system should include the following major components: 1. **Classes and Methods**: - `User`: Represents a user in the system with attributes like `username`, `role`, and individual `permissions`. - `Role`: Represents a role with a set of default `permissions`. - `Document`: Represents a document with attributes including `title`, `content`, and an access `tag`. - `AccessControl`: Manages roles, users, and documents to enforce access rules. 2. **Primary Functionalities**: - Add and manage users, roles, and documents. - Assign roles to users and adjust individual permissions. - Check if a user has access to a document based on their role and permissions. # Implementation Requirements: 1. **Function Definitions**: - `add_user(username: str, user_role: str) -> User`: Adds a new user with a specified role. - `add_role(role_name: str, permissions: list[str]) -> Role`: Adds a new role with specified permissions. - `add_document(title: str, content: str, tag: str) -> Document`: Adds a new document with a specific access tag. - `assign_role_to_user(user: User, role: Role) -> None`: Assigns a role to a user. - `grant_permission(user: User, permission: str) -> None`: Grants an additional permission to a user. - `has_access(user: User, document: Document) -> bool`: Checks if the user has access to the document based on their role and permissions. 2. **Input**: - Usernames, role names, permissions, document titles, content, and tags. - Users, roles, and documents are added and managed through class methods with specified parameters. 3. **Output**: - Methods return appropriate objects or boolean values based on the operations (e.g., user objects, role objects, document objects, or access checks). 4. **Constraints**: - Usernames, role names, and document tags are unique strings. - Permissions are represented as strings and can be arbitrarily assigned to roles or users. - Access tags are used to categorize documents and enforce access rules. # Example: ```python class User: def __init__(self, username, role): self.username = username self.role = role self.permissions = set() class Role: def __init__(self, role_name, permissions): self.role_name = role_name self.permissions = set(permissions) class Document: def __init__(self, title, content, tag): self.title = title self.content = content self.tag = tag class AccessControl: def __init__(self): self.users = {} self.roles = {} self.documents = {} def add_user(self, username: str, user_role: str) -> User: if user_role not in self.roles: raise ValueError(\\"Role not found\\") user = User(username, self.roles[user_role]) self.users[username] = user return user def add_role(self, role_name: str, permissions: list[str]) -> Role: role = Role(role_name, permissions) self.roles[role_name] = role return role def add_document(self, title: str, content: str, tag: str) -> Document: document = Document(title, content, tag) self.documents[title] = document return document def assign_role_to_user(self, user: User, role: Role) -> None: user.role = role # Assigns a new role, replacing the existing one def grant_permission(self, user: User, permission: str) -> None: user.permissions.add(permission) def has_access(self, user: User, document: Document) -> bool: return document.tag in user.permissions or document.tag in user.role.permissions # Example usage ac = AccessControl() viewer_role = ac.add_role(\\"viewer\\", [\\"read_public\\"]) editor_role = ac.add_role(\\"editor\\", [\\"read_public\\", \\"write_content\\"]) user1 = ac.add_user(\\"alice\\", \\"viewer\\") user2 = ac.add_user(\\"bob\\", \\"editor\\") doc1 = ac.add_document(\\"Doc1\\", \\"Content of Doc 1\\", \\"read_public\\") doc2 = ac.add_document(\\"Doc2\\", \\"Content of Doc 2\\", \\"write_content\\") print(ac.has_access(user1, doc1)) # Output: True print(ac.has_access(user1, doc2)) # Output: False ac.grant_permission(user1, \\"write_content\\") print(ac.has_access(user1, doc2)) # Output: True ``` Implement the above classes and methods carefully considering edge cases and scalability for managing a growing number of users, roles, and documents.","solution":"class User: def __init__(self, username, role): self.username = username self.role = role self.permissions = set() class Role: def __init__(self, role_name, permissions): self.role_name = role_name self.permissions = set(permissions) class Document: def __init__(self, title, content, tag): self.title = title self.content = content self.tag = tag class AccessControl: def __init__(self): self.users = {} self.roles = {} self.documents = {} def add_user(self, username: str, user_role: str) -> User: if user_role not in self.roles: raise ValueError(\\"Role not found\\") user = User(username, self.roles[user_role]) self.users[username] = user return user def add_role(self, role_name: str, permissions: list[str]) -> Role: role = Role(role_name, permissions) self.roles[role_name] = role return role def add_document(self, title: str, content: str, tag: str) -> Document: document = Document(title, content, tag) self.documents[title] = document return document def assign_role_to_user(self, user: User, role: Role) -> None: user.role = role # Assigns a new role, replacing the existing one def grant_permission(self, user: User, permission: str) -> None: user.permissions.add(permission) def has_access(self, user: User, document: Document) -> bool: return document.tag in user.permissions or document.tag in user.role.permissions # Example usage ac = AccessControl() viewer_role = ac.add_role(\\"viewer\\", [\\"read_public\\"]) editor_role = ac.add_role(\\"editor\\", [\\"read_public\\", \\"write_content\\"]) user1 = ac.add_user(\\"alice\\", \\"viewer\\") user2 = ac.add_user(\\"bob\\", \\"editor\\") doc1 = ac.add_document(\\"Doc1\\", \\"Content of Doc 1\\", \\"read_public\\") doc2 = ac.add_document(\\"Doc2\\", \\"Content of Doc 2\\", \\"write_content\\") print(ac.has_access(user1, doc1)) # Output: True print(ac.has_access(user1, doc2)) # Output: False ac.grant_permission(user1, \\"write_content\\") print(ac.has_access(user1, doc2)) # Output: True"},{"question":"# Merge Two Sorted Arrays As a software developer, you are tasked with creating a functionality to merge two sorted arrays into one sorted array. This is a common problem in sorting algorithms and data manipulation. Given two sorted arrays, write a function `merge_sorted_arrays` that merges them into a single sorted array. The function should work efficiently in terms of time and space complexity. # Function Signature ```python def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: pass ``` # Constraints 1. The input arrays are already sorted in non-decreasing order. 2. The function should merge the arrays using the least possible time complexity. 3. The function should handle arrays of different lengths. 4. Both arrays can be empty, but the output should be the combined sorted list of their elements. # Input * Two lists of integers in non-decreasing order. # Output * A single list of integers in non-decreasing order. # Example ```python assert merge_sorted_arrays([1, 3, 5], [2, 4, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_arrays([1, 2, 3], [4, 5, 6]) == [1, 2, 3, 4, 5, 6] assert merge_sorted_arrays([5, 6, 7], [1, 2, 3]) == [1, 2, 3, 5, 6, 7] assert merge_sorted_arrays([], [1, 2, 3]) == [1, 2, 3] assert merge_sorted_arrays([1, 2, 3], []) == [1, 2, 3] assert merge_sorted_arrays([], []) == [] # Invalid cases (should raise a TypeError) try: merge_sorted_arrays([1, \'a\'], [2, 3]) except TypeError: pass try: merge_sorted_arrays(1, [2, 3]) except TypeError: pass ``` # Description Implement the function `merge_sorted_arrays` that: 1. Takes in two integer lists. 2. Merges them into a single list while maintaining the non-decreasing order. 3. Validates inputs and raises appropriate exceptions for invalid cases. # Hints 1. Use two pointers to traverse each array. 2. Compare elements and append the smaller element to the result list. 3. Ensure to handle the remaining elements in either array once one array is exhausted.","solution":"def merge_sorted_arrays(arr1: list[int], arr2: list[int]) -> list[int]: Merges two sorted arrays into one sorted array. # Validate inputs if not all(isinstance(x, int) for x in arr1 + arr2): raise TypeError(\\"All elements must be integers.\\") merged_array = [] i, j = 0, 0 # Traverse both arrays and append the smaller element to the merged_array while i < len(arr1) and j < len(arr2): if arr1[i] <= arr2[j]: merged_array.append(arr1[i]) i += 1 else: merged_array.append(arr2[j]) j += 1 # Append remaining elements, if any while i < len(arr1): merged_array.append(arr1[i]) i += 1 while j < len(arr2): merged_array.append(arr2[j]) j += 1 return merged_array"},{"question":"# Question: Implement and Extend BFS-GraphExplorer for Shortest Path in Directional Cyclic Graphs. Context: You are given an algorithm `BFS-GraphExplorer`, which performs a Breadth-First Search (BFS) to explore nodes in an undirected acyclic graph. A graph is represented as an adjacency list where each node contains a list of its neighbors. Task: Extend `BFS-GraphExplorer` to handle **directional cyclic** graphs and calculate the shortest path from a start node to an end node. Modify relevant functions to: 1. Ensure BFS traversal correctly handles directed edges. 2. Detect cycles and appropriately process nodes. 3. Calculate the shortest path taking into account the direction of edges. Specifications: 1. **Input**: - `adjacency_list` : A dictionary where the keys are node identifiers and the values are lists of tuples. Each tuple contains a node identifier representing a directed edge and the weight of that edge. - `start_node` : The starting node identifier. - `end_node` : The destination node identifier. 2. **Output**: - `shortest_path` : A list of node identifiers representing the shortest path from `start_node` to `end_node`, or an empty list if no path exists. 3. **Constraints**: - Edge weights are non-negative integers. - The algorithm should handle large graphs efficiently, considering time complexity appropriate for BFS. Example Input: ```python adjacency_list = { \'A\': [(\'B\', 2), (\'C\', 3)], \'B\': [(\'C\', 2), (\'D\', 4)], \'C\': [(\'D\', 1)], \'D\': [(\'A\', 1)] } start_node = \'A\' end_node = \'D\' ``` Example Output: ```python [\'A\', \'C\', \'D\'] ``` This output indicates that the shortest path from node `A` to node `D` is through nodes `C` and `D`. Instructions: 1. **Update BFS Traversal**: Modify the BFS function to correctly handle directed edges and cycles. 2. **Cycle Detection and Processing**: Implement logic to detect and appropriately process cycles within the graph. 3. **Shortest Path Calculation**: Adjust the BFS algorithm to calculate the shortest path based on the direction and weight of edges. 4. **Testing**: Write at least 3 test cases to verify your extended implementation, ensuring edge cases such as no path or cycles are covered.","solution":"from collections import deque, defaultdict def bfs_shortest_path(adjacency_list, start_node, end_node): Returns the shortest path from start_node to end_node using BFS in a directed cyclic graph. # Parent map to keep track of the path parent = {start_node: None} # Distance map to keep track of shortest paths distance = {start_node: 0} queue = deque([start_node]) while queue: current_node = queue.popleft() for neighbor, weight in adjacency_list.get(current_node, []): new_distance = distance[current_node] + weight if neighbor not in distance or new_distance < distance[neighbor]: distance[neighbor] = new_distance parent[neighbor] = current_node queue.append(neighbor) if end_node not in parent: return [] # No path found # Reconstruct path from end_node to start_node using parent map path = [] while end_node is not None: path.append(end_node) end_node = parent[end_node] return list(reversed(path))"},{"question":"# Longest Increasing Subsequence Objective Given an array of integers, implement an algorithm to find the length of the longest increasing subsequence (LIS). Function Signature ```python def longest_increasing_subsequence(nums: List[int]) -> int: pass ``` Input 1. `nums` (List[int]): A list of integers representing the sequence of numbers. Output An integer representing the length of the longest increasing subsequence in the input array. Constraints - `1 <= len(nums) <= 2500` - `-10^4 <= nums[i] <= 10^4` Performance Requirements - The implementation should aim for a time complexity of O(N log N) and space complexity of O(N). Scenario Consider a scenario where a researcher is analyzing a dataset of numerical values representing some form of measurement over time. They need to determine the longest sequence of increasing measurements to understand the trend better. Your algorithm will help in finding this sequence efficiently. Example ```python nums = [10, 9, 2, 5, 3, 7, 101, 18] result = longest_increasing_subsequence(nums) # Expected output: # 4 # The longest increasing subsequence is [2, 3, 7, 101], and its length is 4. ```","solution":"from typing import List import bisect def longest_increasing_subsequence(nums: List[int]) -> int: Finds the length of the longest increasing subsequence in a given list of integers. if not nums: return 0 lis = [] # This will store the current longest increasing subsequence we\'ve found. for num in nums: pos = bisect.bisect_left(lis, num) # Find the position where \'num\' should go in \'lis\' to keep it sorted. if pos == len(lis): lis.append(num) # If \'num\' is greater than any element in \'lis\', it will create a new LIS else: lis[pos] = num # Replace the element at the found position with \'num\' to potentially start a new LIS return len(lis) # Length of lis is the length of the Longest Increasing Subsequence"},{"question":"# Coding Challenge Context In competitive games, a leaderboard keeps track of players and their scores. When a player\'s score changes, the leaderboard updates and re-ranks all players. In this challenge, your task is to simulate such a leaderboard update and return the updated rankings. Task Write a Python function to update the leaderboard rankings when a player\'s new score is added. Function Signature ```python def update_leaderboard(leaderboard: List[Tuple[str, int]], player: str, new_score: int) -> List[Tuple[str, int]]: pass ``` Input * `leaderboard` (List[Tuple[str, int]]): A list of tuples where each tuple contains a player\'s name (str) and their score (int). * `player` (str): The name of the player whose score is being updated. * `new_score` (int): The new score to be added for the specified player. Output * (List[Tuple[str, int]]): The updated leaderboard list sorted in descending order of scores. If two players have the same score, they are sorted lexicographically by their names. Constraints * The leaderboard will have at most 10^4 entries. * Player names are unique and consist of only alphabetical characters. * All scores are non-negative integers. * The provided player\'s name will always be present in the leaderboard. Examples ```python >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1800), (\\"Charlie\\", 1700)], \\"Alice\\", 1900) [(\'Alice\', 1900), (\'Bob\', 1800), (\'Charlie\', 1700)] >>> update_leaderboard([(\\"Alice\\", 1500), (\\"Bob\\", 1500), (\\"Charlie\\", 1500)], \\"Charlie\\", 1600) [(\'Charlie\', 1600), (\'Alice\', 1500), (\'Bob\', 1500)] ``` Notes * After updating the score for the specified `player`, the leaderboard needs to be re-sorted accordingly. * If the player\'s new score is the highest, they should top the leaderboard. * Ensure to handle the sorting criteria properly: primary by score in descending order and secondary by player name in ascending order lexicographically. Edge Cases * The leaderboard might have players with equal scores, and the sorting must handle this by the player\'s name. * If the leaderboard contains only one player, the function should return that single player with the updated score.","solution":"from typing import List, Tuple def update_leaderboard(leaderboard: List[Tuple[str, int]], player: str, new_score: int) -> List[Tuple[str, int]]: updated_leaderboard = [(name, new_score if name == player else score) for name, score in leaderboard] updated_leaderboard.sort(key=lambda x: (-x[1], x[0])) return updated_leaderboard"},{"question":"# Problem Description You are tasked with writing a function that simulates a library checkout system. The function will track books being checked out and returned by different users, and validate the availability of the books before checkout. If a book is not available, the function should raise a `BookNotAvailableError`. # Function Signature ```python def library_checkout_system( books: List[str], checkout: List[Tuple[str, str]], returns: List[Tuple[str, str]] ) -> Dict[str, List[str]]: pass ``` # Input * **books** (List[str]): A list of strings representing the unique titles of books available in the library. * **checkout** (List[Tuple[str, str]]): A list of tuples, where each tuple contains: - **user_id** (str): A string representing the unique ID of a user. - **book_title** (str): A string representing the title of the book the user wants to check out. * **returns** (List[Tuple[str, str]]): A list of tuples, where each tuple contains: - **user_id** (str): A string representing the unique ID of a user. - **book_title** (str): A string representing the title of the book the user wants to return. # Output * **status** (Dict[str, List[str]]): A dictionary where the keys are user IDs, and the values are lists of book titles currently checked out by the corresponding user. # Constraints * Each book title in the `checkout` and `returns` lists is guaranteed to be in the `books` list. * The books dictionary should reflect the real-time status after all checkout and return operations are processed. * Multiple users can have checked out different books at the same time, but no user can check out a book that is already checked out. * If an attempt is made to check out a book that is not available, the function should raise a `BookNotAvailableError` with an appropriate message. # Custom Exception ```python class BookNotAvailableError(Exception): pass ``` # Examples ```python >>> books = [\\"Book A\\", \\"Book B\\", \\"Book C\\"] >>> checkout = [(\\"user1\\", \\"Book A\\"), (\\"user2\\", \\"Book B\\")] >>> returns = [(\\"user1\\", \\"Book A\\")] >>> library_checkout_system(books, checkout, returns) {\\"user2\\": [\\"Book B\\"]} >>> checkout = [(\\"user1\\", \\"Book A\\"), (\\"user2\\", \\"Book A\\")] >>> library_checkout_system(books, checkout, []) Traceback (most recent call last): ... BookNotAvailableError: Book \'Book A\' is not available. >>> checkout = [(\\"user1\\", \\"Book A\\")] >>> returns = [(\\"user1\\", \\"Book A\\"), (\\"user2\\", \\"Book A\\")] >>> library_checkout_system(books, checkout, returns) {} ``` # Note - Make sure to run and pass the provided examples and handle possible edge cases. - Ensure multiple users managing different books are correctly accounted for.","solution":"from typing import List, Tuple, Dict class BookNotAvailableError(Exception): pass def library_checkout_system( books: List[str], checkout: List[Tuple[str, str]], returns: List[Tuple[str, str]] ) -> Dict[str, List[str]]: available_books = set(books) user_books = {} # Process checkouts for user_id, book_title in checkout: if book_title not in available_books: raise BookNotAvailableError(f\\"Book \'{book_title}\' is not available.\\") if user_id not in user_books: user_books[user_id] = [] user_books[user_id].append(book_title) available_books.remove(book_title) # Process returns for user_id, book_title in returns: if user_id in user_books and book_title in user_books[user_id]: user_books[user_id].remove(book_title) available_books.add(book_title) if not user_books[user_id]: # clean up if the user has no more books del user_books[user_id] return user_books"},{"question":"Matrix Diagonal Sum Problem Given a square matrix `matrix` of integers, implement a function `diagonal_sum` that calculates the sum of the elements on both the primary diagonal and the secondary diagonal. Ensure that each element that belongs to both diagonals is not double-counted. # Function Signature ```python def diagonal_sum(matrix: list) -> int: pass ``` # Input * `matrix`: A list of lists of integers, representing an n x n matrix where 1 ≤ n ≤ 500 and -10^5 ≤ matrix[i][j] ≤ 10^5. # Output * An integer representing the sum of the primary and secondary diagonal elements. # Example ```python >>> diagonal_sum([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 25 >>> diagonal_sum([ ... [5, 2], ... [3, 8] ... ]) 18 ``` # Constraints * The function must operate within O(n) time complexity. * Handle edge cases, such as the smallest possible matrix, correctly. # Explanation In the first example, the primary diagonal elements are 1, 5, 9 and the secondary diagonal elements are 3, 5, 7. Since 5 is common to both diagonals, it is added only once, leading to a sum of 1 + 5 + 9 + 3 + 7 = 25. In the second example, the primary diagonal elements are 5, 8 and the secondary diagonal elements are 2, 3, again leading to a sum of 5 + 8 + 2 + 3 = 18.","solution":"def diagonal_sum(matrix: list) -> int: Calculate the sum of the primary and secondary diagonal elements of a given square matrix. Ensures that elements appearing in both diagonals are not double-counted. :param matrix: List of lists of integers, representing an n x n matrix. :return: Integer sum of the elements on both diagonals. n = len(matrix) total_sum = 0 for i in range(n): primary_diagonal_element = matrix[i][i] secondary_diagonal_element = matrix[i][n - 1 - i] total_sum += primary_diagonal_element if i != n - 1 - i: total_sum += secondary_diagonal_element return total_sum"},{"question":"# Question: Implement Sierpinski Triangle Fractal Implement a function to generate an image of the Sierpinski triangle using recursion. The Sierpinski triangle, also known as the Sierpinski gasket or Sierpinski sieve, is a fractal described by repeatedly subdividing an equilateral triangle into smaller equilateral triangles. # The Sierpinski Triangle Function Implement the function `sierpinski_image` with the following signature: ```python def sierpinski_image( image_size: int, max_depth: int, background_color: Tuple[int, int, int] = (255, 255, 255), triangle_color: Tuple[int, int, int] = (0, 0, 0), ) -> Image.Image: Generates an image of the Sierpinski triangle with the given parameters. Parameters: - image_size (int): Size of the image in pixels (width and height). - max_depth (int): Maximum depth of recursion. - background_color (Tuple[int, int, int]): RGB color for the background. - triangle_color (Tuple[int, int, int]): RGB color for the Sierpinski triangle. Returns: - Image.Image: The generated image of the Sierpinski triangle. pass ``` # Requirements 1. **Initialization**: Create an image with the given size and background color. 2. **Base Triangle Drawing**: For depth 0, draw an equilateral triangle covering the entire image. 3. **Recursive Subdivision**: For each subsequent depth, recursively draw three smaller Sierpinski triangles within the current triangle. 4. **Drawing Function**: Implement a helper function that draws an equilateral triangle given its vertex coordinates and specified color. 5. **Color Coding**: Ensure the triangles are drawn using the specified triangle color. # Example Usage Generate and display a Sierpinski triangle with image size 512 and recursion depth 5: ```python if __name__ == \\"__main__\\": img = sierpinski_image(512, 5) img.show() ``` # Constraints * Image size is a positive integer, typically in the range of [128, 2048]. * Maximum depth is a positive integer, typically in the range of [1, 10]. # Performance Considerations Efficiency is important, especially for higher recursion depths. Ensure the implementation is optimized for generating the fractal image without excessive computation or memory usage.","solution":"from typing import Tuple from PIL import Image, ImageDraw def draw_triangle(draw: ImageDraw.Draw, vertices: Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]], color: Tuple[int, int, int]): Draws a filled equilateral triangle using the provided vertices and color. draw.polygon(vertices, fill=color) def sierpinski(draw: ImageDraw.Draw, vertices: Tuple[Tuple[int, int], Tuple[int, int], Tuple[int, int]], depth: int, color: Tuple[int, int, int]): Recursively draws Sierpinski triangles. if depth == 0: draw_triangle(draw, vertices, color) else: # Calculate the midpoints of each side of the triangle mid1 = ((vertices[0][0] + vertices[1][0]) // 2, (vertices[0][1] + vertices[1][1]) // 2) mid2 = ((vertices[1][0] + vertices[2][0]) // 2, (vertices[1][1] + vertices[2][1]) // 2) mid3 = ((vertices[2][0] + vertices[0][0]) // 2, (vertices[2][1] + vertices[0][1]) // 2) # Recursively draw the smaller triangles sierpinski(draw, (vertices[0], mid1, mid3), depth - 1, color) sierpinski(draw, (mid1, vertices[1], mid2), depth - 1, color) sierpinski(draw, (mid3, mid2, vertices[2]), depth - 1, color) def sierpinski_image( image_size: int, max_depth: int, background_color: Tuple[int, int, int] = (255, 255, 255), triangle_color: Tuple[int, int, int] = (0, 0, 0), ) -> Image.Image: Generates an image of the Sierpinski triangle with the given parameters. Parameters: - image_size (int): Size of the image in pixels (width and height). - max_depth (int): Maximum depth of recursion. - background_color (Tuple[int, int, int]): RGB color for the background. - triangle_color (Tuple[int, int, int]): RGB color for the Sierpinski triangle. Returns: - Image.Image: The generated image of the Sierpinski triangle. # Create an image with the specified background color image = Image.new(\\"RGB\\", (image_size, image_size), background_color) draw = ImageDraw.Draw(image) # Define the initial large equilateral triangle vertices height = int((3**0.5 / 2) * image_size) # height of the equilateral triangle vertices = [(image_size // 2, 0), (0, height), (image_size, height)] # Draw the Sierpinski triangle using recursion sierpinski(draw, vertices, max_depth, triangle_color) return image"},{"question":"# Anagram Checking You are given two strings, `str1` and `str2`. Your task is to determine if `str1` and `str2` are anagrams of each other. # Input * `str1` - A string where 1 ≤ length of `str1` ≤ 1000. * `str2` - A string where 1 ≤ length of `str2` ≤ 1000. # Output * Return `True` if `str1` and `str2` are anagrams of each other. * Return `False` otherwise. # Constraints * The strings will only contain lowercase alphabetical characters. # Example ```python def are_anagrams(str1: str, str2: str) -> bool: >>> are_anagrams(\\"listen\\", \\"silent\\") True >>> are_anagrams(\\"hello\\", \\"world\\") False >>> are_anagrams(\\"aabbcc\\", \\"ccbbaa\\") True >>> are_anagrams(\\"abc\\", \\"def\\") False >>> are_anagrams(\\"anagram\\", \\"nagaram\\") True from collections import Counter return Counter(str1) == Counter(str2) if __name__ == \\"__main__\\": import doctest doctest.testmod() ``` # Implementation Notes: * Consider edge cases, such as when the strings are of different lengths. * Use efficient methods to compare the character counts in the strings. * Ensure your implementation is performant for strings at the upper limit of length.","solution":"def are_anagrams(str1: str, str2: str) -> bool: Determines if str1 and str2 are anagrams of each other. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 and str2 are anagrams, False otherwise. from collections import Counter return Counter(str1) == Counter(str2)"},{"question":"**Shopping Cart Optimal Discount Calculation** You are required to implement a function that calculates the optimal discount for a shopping cart in an e-commerce system. The system offers two types of discounts: a bulk discount that applies if the total price of items exceeds a certain threshold and a percentage discount that applies to each item individually. # Input Format: * A list of tuples representing the items in the shopping cart, each tuple contains: 1. Item name (a string) 2. Item price (a floating-point number) 3. Desired quantity (an integer) * A floating-point number representing the bulk discount threshold. * A floating-point number representing the bulk discount amount. * A floating-point number representing the percentage discount. ``` optimal_discount(cart, bulk_threshold, bulk_discount, percent_discount) ``` # Output Format: * A floating-point number representing the total price of the shopping cart after applying the optimal discount strategy. # Constraints: * Item prices are non-negative. * Desired quantities are non-negative integers. * The bulk discount threshold is a non-negative number. * The bulk discount amount is a non-negative number and should be applied once if the total price before discounts exceeds the threshold. * The percentage discount is a value between 0 and 100 inclusive and should be applied to each item individually. * If both discount types can be applied, the function should choose the one which yields the lower total price. # Example: ```python cart = [ (\\"Laptop\\", 999.99, 1), (\\"Headphones\\", 79.99, 2), (\\"Mouse\\", 29.99, 1) ] bulk_threshold = 1000.0 bulk_discount = 100.0 percent_discount = 10.0 print(f\\"{optimal_discount(cart, bulk_threshold, bulk_discount, percent_discount):.2f}\\") # Output: 1,036.07 ``` # Scenario Imagine you are developing a feature for an e-commerce platform where users can avail special discounts based on their total purchase amount. This function needs to intelligently determine the most cost-effective discount for the user to maximize their savings and thereby improve customer satisfaction. The function `optimal_discount` needs to be implemented to meet these requirements and should be able to handle various cart configurations efficiently. Make sure to carefully calculate and compare the different discount strategies to provide the optimal total price for the shopping cart.","solution":"def optimal_discount(cart, bulk_threshold, bulk_discount, percent_discount): Calculate the optimal total price of the cart after applying the optimal discount strategy. Args: cart (list of tuples): Each tuple contains (item_name, item_price, item_quantity). bulk_threshold (float): The price threshold to qualify for the bulk discount. bulk_discount (float): The discount amount applied if the bulk threshold is met. percent_discount (float): The percentage discount applied to each individual item. Returns: float: The total price of the cart after applying the optimal discount. # Calculate the initial total price without any discounts initial_total = sum(item_price * item_quantity for _, item_price, item_quantity in cart) # Calculate the total price after applying the bulk discount if initial_total > bulk_threshold: bulk_discounted_total = initial_total - bulk_discount else: bulk_discounted_total = initial_total # Calculate the total price after applying the percentage discount percent_discounted_total = sum(item_price * item_quantity * (1 - percent_discount / 100) for _, item_price, item_quantity in cart) # Return the minimum of the two discounted totals return min(bulk_discounted_total, percent_discounted_total)"},{"question":"# Context You have been learning about sorting algorithms and have come across various efficient methods like Merge Sort, Quick Sort, and Heap Sort. You are now tasked with implementing a hybrid sorting algorithm that combines the strengths of two or more traditional methods to optimize performance, especially for larger datasets. # Problem Design and implement a hybrid sorting algorithm that initially uses Quick Sort for overall efficiency, but switches to Insertion Sort for small subarrays to boost performance on smaller segments. # Task 1. Implement the function `hybrid_sort(arr: List[int]) -> List[int]` which sorts the array using Quick Sort, switching to Insertion Sort for subarrays smaller than a given threshold. 2. Define a suitable threshold value within your implementation for switching to Insertion Sort. # Requirements 1. **Function**: `hybrid_sort` - **Input**: A list of integers `arr` where (1 ≤ len(arr) ≤ (10^5)) - **Output**: Returns a sorted list of integers. - **Constraints**: - Implement an efficient hybrid sorting algorithm. - Ensure the sorting algorithm performs well on arrays of varying sizes. # Example ```python from typing import List def hybrid_sort(arr: List[int]) -> List[int]: def insertion_sort(subarray): for i in range(1, len(subarray)): key = subarray[i] j = i - 1 while j >= 0 and key < subarray[j]: subarray[j + 1] = subarray[j] j -= 1 subarray[j + 1] = key def quick_sort_helper(arr, low, high): if low < high: if high - low <= threshold: insertion_sort(arr[low:high+1]) else: pi = partition(arr, low, high) quick_sort_helper(arr, low, pi - 1) quick_sort_helper(arr, pi + 1, high) def partition(arr, low, high): pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 threshold = 10 quick_sort_helper(arr, 0, len(arr) - 1) return arr # Tests assert hybrid_sort([10, 7, 8, 9, 1, 5]) == [1, 5, 7, 8, 9, 10] assert hybrid_sort([4, 3, 2, 1]) == [1, 2, 3, 4] assert hybrid_sort([5]) == [5] assert hybrid_sort([0, -1, 5, -10, 8]) == [-10, -1, 0, 5, 8] assert hybrid_sort([1, 1, 1, 1]) == [1, 1, 1, 1] assert hybrid_sort([2, 3, 5, 3, 5, 0]) == [0, 2, 3, 3, 5, 5] ```","solution":"from typing import List def hybrid_sort(arr: List[int]) -> List[int]: def insertion_sort(subarray: List[int], start: int, end: int): for i in range(start + 1, end + 1): key = subarray[i] j = i - 1 while j >= start and key < subarray[j]: subarray[j + 1] = subarray[j] j -= 1 subarray[j + 1] = key def quick_sort_helper(arr: List[int], low: int, high: int): if low < high: if high - low <= threshold: insertion_sort(arr, low, high) else: pi = partition(arr, low, high) quick_sort_helper(arr, low, pi - 1) quick_sort_helper(arr, pi + 1, high) def partition(arr: List[int], low: int, high: int) -> int: pivot = arr[high] i = low - 1 for j in range(low, high): if arr[j] < pivot: i += 1 arr[i], arr[j] = arr[j], arr[i] arr[i + 1], arr[high] = arr[high], arr[i + 1] return i + 1 threshold = 10 quick_sort_helper(arr, 0, len(arr) - 1) return arr"},{"question":"# Problem Statement You are tasked with implementing a function that determines if a given string contains a valid and balanced combination of parentheses, brackets, and curly braces. The three types of braces must appear in pairs and in the correct order. # Functional Requirements - **Function Name**: `is_valid_braces` - **Input**: - A string (`s`) containing characters, which may include parentheses `\'()\'`, square brackets `\'[]\'`, and curly braces `\'{}\'`. - **Output**: - A boolean value: `True` if the string has balanced braces, and `False` otherwise. - **Constraints**: - The string can be of arbitrary length, including an empty string. - The function should ignore non-brace characters and only evaluate the brace characters. # Non-Functional Requirements - **Error Handling**: Gracefully handle empty, null, and non-string inputs by returning `False`. - **Performance**: The solution should efficiently handle strings with large lengths without significant time or memory overhead. # Example Input/Output ```python >>> is_valid_braces(\\"(){}[]\\") True >>> is_valid_braces(\\"([{}])\\") True >>> is_valid_braces(\\"(]\\") False >>> is_valid_braces(\\"([)]\\") False >>> is_valid_braces(\\"a(b)c[d]e{f}\\") True >>> is_valid_braces(\\"\\") True >>> is_valid_braces(\\"just a normal string\\") True >>> is_valid_braces(None) False >>> is_valid_braces(234) False ``` # Implementation Implement the function `is_valid_braces` based on the requirements specified above.","solution":"def is_valid_braces(s): Checks if the string s contains valid and balanced parentheses, brackets, and curly braces. if not isinstance(s, str): return False stack = [] opening_braces = {\'(\': \')\', \'[\': \']\', \'{\': \'}\'} closing_braces = {\')\': \'(\', \']\': \'[\', \'}\': \'{\'} for char in s: if char in opening_braces: stack.append(char) elif char in closing_braces: if stack and stack[-1] == closing_braces[char]: stack.pop() else: return False return len(stack) == 0"},{"question":"# Problem Statement: Develop a function that simulates the action of distributing a specified number of balls into a series of bins. The distribution should be random, but each bin must contain at least one ball. This function can be particularly useful in tasks such as load balancing, resource allocation, and randomized testing scenarios. # Function Signature: ```python def distribute_balls(num_balls: int, num_bins: int) -> List[int]: pass ``` # Input: * `num_balls` (int): The total number of balls to distribute, a positive integer. * `num_bins` (int): The number of bins to fill with balls, a positive integer. # Output: * Returns a `List[int]` of length `num_bins` where each element represents the number of balls in the corresponding bin. The list must satisfy the condition that each bin contains at least one ball. # Constraints: * `num_balls` should be greater than or equal to `num_bins`. * Performance should handle at least `10^5` balls efficiently. # Example: ```python def distribute_balls(num_balls: int, num_bins: int) -> List[int]: if num_balls < num_bins: raise ValueError(\\"Number of balls must be greater than or equal to number of bins\\") # Start by putting one ball in each bin bins = [1] * num_bins remaining_balls = num_balls - num_bins for _ in range(remaining_balls): bins[random.randint(0, num_bins - 1)] += 1 return bins # Example Usage print(distribute_balls(10, 3)) # Possible output: [4, 3, 3] ``` # Requirements: 1. Implement the function `distribute_balls` that achieves the described functionality. 2. Ensure the function handles potential edge cases, such as when `num_balls` equals `num_bins`. 3. Test the function with various `num_balls` and `num_bins` values to verify correct distribution. # Hints: 1. Utilize randomization techniques to ensure each bin gets at least one ball. 2. Consider edge cases explicitly to manage distributions where the number of balls is equal to the number of bins.","solution":"import random from typing import List def distribute_balls(num_balls: int, num_bins: int) -> List[int]: if num_balls < num_bins: raise ValueError(\\"Number of balls must be greater than or equal to number of bins\\") # Start by putting one ball in each bin bins = [1] * num_bins remaining_balls = num_balls - num_bins for _ in range(remaining_balls): bins[random.randint(0, num_bins - 1)] += 1 return bins"},{"question":"# Integer Partition Sums Objective: Implement a function that determines the number of ways to partition a given integer `n` as the sum of positive integers. # Background: An integer partition of `n` is a way of writing `n` as the sum of positive integers, where order does not matter. For example, the partitions of `4` are: - 4 - 3 + 1 - 2 + 2 - 2 + 1 + 1 - 1 + 1 + 1 + 1 Function Signature: ```python def partition_count(n: int) -> int: pass ``` Expected Input and Output: * **Input**: A single integer `n`. * **Output**: An integer representing the number of ways to partition `n`. Constraints and Assumptions: * `n` will be in the range from 1 to 100. * You must handle invalid inputs by raising a ValueError. * The function should be efficient to handle large values of `n` within the given range. Guiding Points: 1. **Edge Handling**: Ensure your function correctly handles non-integer and non-positive inputs by throwing appropriate errors. 2. **Dynamic Programming Approach**: Use a bottom-up dynamic programming approach to build up the number of partitions. 3. **Array Representation**: Utilize an array to store the number of ways to partition each number up to `n`. Implementation Example ```python def partition_count(n: int) -> int: if n <= 0 or not isinstance(n, int): raise ValueError(f\\"n must be a positive integer\\") dp = [0] * (n + 1) dp[0] = 1 # Base case: there is one way to partition 0 for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n] # Example Usage: # partition_count(4) should return 5 # partition_count(5) should return 7 # partition_count(1) should return 1 ``` Submit your solution with test cases to confirm the implementation is correct.","solution":"def partition_count(n: int) -> int: if n <= 0 or not isinstance(n, int): raise ValueError(f\\"n must be a positive integer\\") dp = [0] * (n + 1) dp[0] = 1 # Base case: there is one way to partition 0 for i in range(1, n + 1): for j in range(i, n + 1): dp[j] += dp[j - i] return dp[n] # Example Usage: # partition_count(4) should return 5 # partition_count(5) should return 7 # partition_count(1) should return 1"},{"question":"# Evaluate Knights\' Tour on a Chessboard Context The Knight\'s tour problem involves moving a knight on an ( n times n ) chessboard so that the knight visits every square exactly once. A knight in chess moves in an L-shape: two squares in one direction and then one square perpendicular, or one square in one direction and then two squares perpendicular. Problem Statement Write a function `knights_tour(n: int) -> bool` that determines if there is a sequence of knight moves that covers every square on an ( n times n ) chessboard exactly once starting from the top-left corner (0, 0). If the input is not a positive integer, raise a `ValueError` stating \\"Invalid board size\\". Function Signature ```python def knights_tour(n: int) -> bool: pass ``` # Input * An integer `n` representing the size of the chessboard. # Output * A boolean value `True` if there is a valid sequence of knight moves that covers the entire chessboard, otherwise `False`. # Constraints * ( 1 leq n leq 20 ) # Example ```python # Example 1 >>> n = 1 >>> knights_tour(n) True # Example 2 >>> n = 5 >>> knights_tour(n) True # Example 3 >>> n = 2 >>> knights_tour(n) False # Example 4 >>> n = \'3\' >>> knights_tour(n) ValueError: Invalid board size ``` # Notes * This problem usually requires a backtracking approach. Ensure that your solution is designed to explore multiple paths efficiently. * Consider edge cases such as the smallest and largest possible board sizes within the given constraints. * Aim for clarity and efficiency in your solution while matching the complexity and scope demonstrated in the sample question provided.","solution":"def knights_tour(n: int) -> bool: if not isinstance(n, int) or n <= 0: raise ValueError(\\"Invalid board size\\") # Movement in x and y direction for the Knight x_moves = [2, 1, -1, -2, -2, -1, 1, 2] y_moves = [1, 2, 2, 1, -1, -2, -2, -1] def is_valid_move(x, y): return 0 <= x < n and 0 <= y < n and board[x][y] == -1 def solve(x, y, move_count): if move_count == n * n: return True for i in range(8): next_x = x + x_moves[i] next_y = y + y_moves[i] if is_valid_move(next_x, next_y): board[next_x][next_y] = move_count if solve(next_x, next_y, move_count + 1): return True board[next_x][next_y] = -1 return False # Initialize the chessboard with -1 board = [[-1 for _ in range(n)] for _ in range(n)] # Starting position board[0][0] = 0 if solve(0, 0, 1): return True return False"},{"question":"# Context You are working for a company that specializes in providing secure encryption solutions. They have asked you to implement an encryption-based doubly linked list that encrypts each node\'s value using a simple Caesar cipher before storing it. # Task Implement a class called `CaesarDoublyLinkedList` that simulates a doubly linked list with the added functionality of encrypting and decrypting each node\'s value using a Caesar cipher. The class must support the following operations: 1. `append(value)`: Adds a node with the encrypted `value` to the end of the list. 2. `prepend(value)`: Adds a node with the encrypted `value` to the beginning of the list. 3. `delete(value)`: Deletes the first node with the decrypted `value` from the list. 4. `display()`: Returns a list of all decrypted node values from the start to the end of the list. The Caesar cipher should use a shift of 3 for encryption and decryption. # Specifications * **Classes and Methods**: - `class CaesarDoublyLinkedList`: - `__init__(self)`: Initializes an empty doubly linked list. - `append(self, value)`: Adds a new node with the encrypted value to the end of the list. - `prepend(self, value)`: Adds a new node with the encrypted value to the beginning of the list. - `delete(self, value)`: Deletes the first occurrence of a node with the decrypted value from the list. - `display(self)`: Returns a list of all decrypted node values in the order they appear in the list. * **Caesar Cipher**: - **Encrypt**: Shift each character in the string by 3 places to the right in the alphabet. For example, \\"a\\" becomes \\"d\\". - **Decrypt**: Shift each character in the string by 3 places to the left in the alphabet. For example, \\"d\\" becomes \\"a\\". * **Input Handling**: - The `value` provided to `append`, `prepend`, and `delete` methods will be a string containing only lowercase alphabetical characters. * **Output**: - The `display` method returns a list of strings representing the decrypted values in the list. # Example ```python # Creating the doubly linked list dll = CaesarDoublyLinkedList() # Appending and prepending values dll.append(\'hello\') dll.prepend(\'world\') dll.append(\'python\') # Displaying the list print(dll.display()) # Output: [\'world\', \'hello\', \'python\'] # Deleting a value dll.delete(\'hello\') # Displaying the list again print(dll.display()) # Output: [\'world\', \'python\'] ``` # Notes * You must handle the encryption and decryption within the respective methods of the `CaesarDoublyLinkedList` class. * Ensure the linked list maintains its integrity after each operation. * Consider edge cases like an empty list, deleting a non-existent value, or multiple occurrences of the same value when implementing the methods.","solution":"class CaesarDoublyLinkedList: class Node: def __init__(self, value): self.value = value self.next = None self.prev = None def __init__(self): self.head = None self.tail = None def _encrypt(self, value): encrypted = \'\'.join( chr((ord(char) - 97 + 3) % 26 + 97) for char in value ) return encrypted def _decrypt(self, encrypted_value): decrypted = \'\'.join( chr((ord(char) - 97 - 3) % 26 + 97) for char in encrypted_value ) return decrypted def append(self, value): encrypted_value = self._encrypt(value) new_node = self.Node(encrypted_value) if not self.head: self.head = self.tail = new_node else: self.tail.next = new_node new_node.prev = self.tail self.tail = new_node def prepend(self, value): encrypted_value = self._encrypt(value) new_node = self.Node(encrypted_value) if not self.head: self.head = self.tail = new_node else: new_node.next = self.head self.head.prev = new_node self.head = new_node def delete(self, value): decrypted_value = self._encrypt(value) current = self.head while current: if current.value == decrypted_value: if current.prev: current.prev.next = current.next if current.next: current.next.prev = current.prev if current == self.head: self.head = current.next if current == self.tail: self.tail = current.prev return current = current.next def display(self): values = [] current = self.head while current: values.append(self._decrypt(current.value)) current = current.next return values"},{"question":"Scenario Sorting student scores can be a repetitive yet challenging task when dealing with large datasets. Implement a solution that not only sorts scores but also handles the complexities of sorting based on multiple criteria such as scores and names. This question tests your understanding of sorting algorithms, data structures, and handling nested sorting criteria effectively. Problem Statement Given a list of tuples `students`, where each tuple contains a student\'s name and their score, implement the function `sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]` that sorts the students first by their scores in descending order and then by their names in ascending order if scores are equal, returning the sorted list of students. Input - `students` (list of tuples): A list containing tuples, where each tuple consists of a string (student\'s name) and an integer (student\'s score). Output - Returns a list of tuples sorted as per the criteria discussed. Function Signature ```python def sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: pass ``` Example ```python >>> sort_students([(\\"Alice\\", 88), (\\"Bob\\", 95), (\\"Charlie\\", 88), (\\"David\\", 92)]) [(\\"Bob\\", 95), (\\"David\\", 92), (\\"Alice\\", 88), (\\"Charlie\\", 88)] >>> sort_students([(\\"Eve\\", 70), (\\"Alice\\", 60), (\\"Eve\\", 60), (\\"Alice\\", 70)]) [(\\"Alice\\", 70), (\\"Eve\\", 70), (\\"Alice\\", 60), (\\"Eve\\", 60)] >>> sort_students([(\\"Alice\\", 100), (\\"Bob\\", 90), (\\"Charlie\\", 95)]) [(\\"Alice\\", 100), (\\"Charlie\\", 95), (\\"Bob\\", 90)] ``` Constraints - Each student tuple contains a string (name) and an integer (score). - Names are non-empty strings consisting of uppercase and lowercase alphabets, and scores are non-negative integers. - The list can contain up to 10,000 student tuples. - Optimize the sorting to handle the upper constraints efficiently. Note - Sorting should be stable i.e., students with the same scores should retain their relative order based on names. - Use efficient algorithms and data structures to ensure the solution remains performant with large datasets.","solution":"from typing import List, Tuple def sort_students(students: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Sorts the list of students first by score in descending order, and by name in ascending order in case of ties. return sorted(students, key=lambda x: (-x[1], x[0]))"},{"question":"# Hypotenuse Length Calculator **Objective**: Implement a function that calculates the length of the hypotenuse of a right triangle given the lengths of the other two sides. Context In a right triangle, the length of the hypotenuse can be calculated using the Pythagorean theorem: [ text{hypotenuse} = sqrt{a^2 + b^2} ] where, - ( a ) is the length of one side of the right triangle, - ( b ) is the length of the other side of the right triangle. Function Signature ```python def hypotenuse_length(a: float, b: float) -> float: Calculates the length of the hypotenuse of a right triangle. Parameters: a (float): length of one side of the triangle. Must be non-negative. b (float): length of the other side of the triangle. Must be non-negative. Returns: float: Length of the hypotenuse. Raises: ValueError: If either a or b is less than 0. pass ``` Expected Input and Output 1. **Input**: - A float `a` (length of one side in units). - A float `b` (length of the other side in units). 2. **Output**: - A float representing the length of the hypotenuse in the same units. Constraints - ( 0 leq a leq 10000 ) - ( 0 leq b leq 10000 ) Performance Requirements - **Time Complexity**: O(1) - **Space Complexity**: O(1) Example * **Example 1**: ```python >>> hypotenuse_length(3, 4) 5.0 ``` * **Example 2**: ```python >>> hypotenuse_length(5, 12) 13.0 ``` * **Example 3**: ```python >>> hypotenuse_length(8, 15) 17.0 ``` * **Edge Case**: ```python >>> hypotenuse_length(0, 0) 0.0 ``` **Note**: You must handle invalid inputs by raising an appropriate exception.","solution":"import math def hypotenuse_length(a: float, b: float) -> float: Calculates the length of the hypotenuse of a right triangle. Parameters: a (float): length of one side of the triangle. Must be non-negative. b (float): length of the other side of the triangle. Must be non-negative. Returns: float: Length of the hypotenuse. Raises: ValueError: If either a or b is less than 0. if a < 0 or b < 0: raise ValueError(\\"Both side lengths must be non-negative.\\") return math.sqrt(a**2 + b**2)"},{"question":"# Coding Assessment Question: Scenario: You are developing a file management system, and you need to create a feature that checks if a given filename is valid or not based on specific rules. Filenames must be alphanumeric strings with underscores allowed, and they must start with either a letter or an underscore. Task: Write a function `is_valid_filename(filename: str) -> bool` that takes in a string and returns `True` if the filename is valid according to the rules, and `False` otherwise. Input: - A string `filename` representing the filename to be validated. Output: - A boolean `True` if the filename is valid, `False` otherwise. Constraints: - The filename will contain only printable ASCII characters. - The filename length will be between 1 and 255 characters, inclusive. - The filename must start with a letter (`a-z` or `A-Z`) or an underscore (`_`). - The filename can only contain letters (`a-z`, `A-Z`), digits (`0-9`), and underscores (`_`). Examples: ```python is_valid_filename(\\"file1\\") # Returns: True is_valid_filename(\\"_file2\\") # Returns: True is_valid_filename(\\"123file\\") # Returns: False is_valid_filename(\\"file@name\\") # Returns: False is_valid_filename(\\"file name\\") # Returns: False is_valid_filename(\\"filename_123\\") # Returns: True is_valid_filename(\\"_123filename\\") # Returns: True ```","solution":"import re def is_valid_filename(filename: str) -> bool: Checks if the given filename is valid based on the following rules: 1. The filename must start with a letter (a-z, A-Z) or an underscore (_). 2. The filename can only contain alphanumeric characters (a-z, A-Z, 0-9) and underscores (_). Args: filename (str): The filename to be validated Returns: bool: True if the filename is valid, False otherwise if not filename or len(filename) > 255: return False return bool(re.match(r\'^[a-zA-Z_][a-zA-Z0-9_]*\', filename))"},{"question":"Question You are tasked with implementing a function that computes the sum of all root-to-leaf numbers in a binary tree. Each root-to-leaf path in the tree represents a number formed by concatenating the values of the nodes along the path. Your function should return the sum of these numbers. # Function Signature ```python def sum_root_to_leaf_numbers(root: Optional[TreeNode]) -> int: pass ``` # Input - `root` (TreeNode): The root node of a binary tree, where each node has an integer value. # Output - Returns an integer: the sum of all root-to-leaf numbers in the binary tree. # Constraints 1. The tree will have at least one node. 2. The tree node values will be non-negative integers. # Examples ```python # Example 1 # Input: [1,2,3] # Tree structure: # 1 # / # 2 3 # The root-to-leaf paths are 12 and 13. # Output: 25 result = sum_root_to_leaf_numbers(TreeNode(1, TreeNode(2), TreeNode(3))) print(result) # Example output: 25 # Example 2: # Input: [4,9,0,5,1] # Tree structure: # 4 # / # 9 0 # / # 5 1 # The root-to-leaf paths are 495, 491, and 40. # Output: 1026 result = sum_root_to_leaf_numbers(TreeNode(4, TreeNode(9, TreeNode(5), TreeNode(1)), TreeNode(0))) print(result) # Example output: 1026 ``` # Note - You may need to implement the TreeNode class for testing purposes, typically defined as: ```python class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right ``` - Ensure to handle edge cases where the tree consists of a single node, or has complex structures.","solution":"from typing import Optional class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sum_root_to_leaf_numbers(root: Optional[TreeNode]) -> int: def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val # If it\'s a leaf if not node.left and not node.right: return current_number # Continue DFS on left and right left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"# Scenario: As a software developer, you have been tasked with building a web application that allows users to upload a text document and extract the most frequent words from it. The application should be able to process the text, compute the frequency of each word, and display the top N most frequent words along with their counts. # Task: Implement a function to process the uploaded text document, compute word frequencies, and return the top N most frequent words along with their counts. # Instructions: 1. **File Handling**: * Write a function to read the contents of a text file. * Ensure the function can handle large files efficiently. 2. **Text Processing**: * Convert the text to lowercase. * Remove punctuation and special characters. * Split the text into individual words. 3. **Frequency Calculation**: * Compute the frequency of each word in the document. * Use a dictionary or similar data structure to store word counts. 4. **Top N Words**: * Sort the word counts and extract the top N most frequent words. # Constraints: * Assume N is a positive integer and is given as input. * Ignore case (i.e., treat \\"Word\\" and \\"word\\" as the same word). * Remove common English stop words like \'the\', \'is\', \'in\', \'and\', etc. * Handle large files efficiently without loading the entire file into memory if possible. # Expected Functions: You need to implement the function `extract_top_words()` which: - Reads and processes the text document. - Computes word frequencies. - Returns the top N most frequent words with their counts. # Example: ```python def extract_top_words(file_path, N): # Your code to read the file, process the text, and calculate frequencies # Return a list of tuples with (word, count) for the top N words return top_words ``` # Additional Requirements: * Optimize your function for performance on large text files. * Ensure proper handling of edge cases such as empty files, files with no valid words, and invalid input values for N. * Consider using libraries like `collections.Counter` for frequency calculation and `string` for punctuation removal.","solution":"import string from collections import Counter import heapq def preprocess_text(text): Preprocesses the input text: - Converts to lowercase - Removes punctuation - Splits into words text = text.lower() text = text.translate(str.maketrans(\'\', \'\', string.punctuation)) words = text.split() stop_words = set([ \'the\', \'is\', \'in\', \'and\', \'a\', \'an\', \'of\', \'to\', \'it\', \'that\', \'with\', \'as\', \'for\', \'on\', \'was\', \'at\', \'by\', \'which\', \'be\', \'or\', \'from\', \'but\', \'this\', \'are\', \'were\', \'not\', \'can\', \'will\', \'would\', \'if\', \'has\', \'have\', \'had\', \'i\', \'you\', \'he\', \'she\', \'they\', \'we\', \'us\', \'them\', \'his\', \'her\', \'its\', \'our\' ]) filtered_words = [word for word in words if word not in stop_words] return filtered_words def extract_top_words(file_path, N): Extracts the top N most frequent words from the given text file. :param file_path: Path to the text file. :param N: Number of top frequent words to return. :return: List of tuples with (word, count) for the top N words. word_counter = Counter() with open(file_path, \'r\', encoding=\'utf-8\') as file: for line in file: words = preprocess_text(line) word_counter.update(words) top_words = heapq.nlargest(N, word_counter.items(), key=lambda item: item[1]) return top_words"},{"question":"# Problem Description Your task is to write a function that removes all duplicate elements from an unsorted list while maintaining the order of first occurrences. # Function Signature ```python def remove_duplicates(collection: list[int]) -> list[int]: Removes duplicate elements from a list while maintaining the order of first occurrences, and returns the list of unique elements. :param collection: A list of integers which may contain duplicates. :return: A list of unique integers, preserving their original order. Examples: >>> remove_duplicates([1, 2, 2, 3, 4, 5, 5, 6]) [1, 2, 3, 4, 5, 6] >>> remove_duplicates([]) [] >>> remove_duplicates([5, 5, 5, 5]) [5] ``` # Input - A list of integers `collection`. # Output - A list containing unique integers, preserving the original order of their first occurrences in the input list. # Constraints - The input list can have a length ranging from 0 to 10**6. - Each integer in the list can range from -10**6 to 10**6. # Performance Requirements - Ensure that the solution effectively handles large lists and runs within feasible time limits. # Example ```python assert remove_duplicates([1, 2, 2, 3, 4, 5, 5, 6]) == [1, 2, 3, 4, 5, 6] assert remove_duplicates([]) == [] assert remove_duplicates([5, 5, 5, 5]) == [5] ```","solution":"def remove_duplicates(collection: list[int]) -> list[int]: Removes duplicate elements from a list while maintaining the order of first occurrences, and returns the list of unique elements. :param collection: A list of integers which may contain duplicates. :return: A list of unique integers, preserving their original order. seen = set() unique_list = [] for item in collection: if item not in seen: unique_list.append(item) seen.add(item) return unique_list"},{"question":"# Given Task You need to implement a function that parses a list of strings containing mathematical expressions and evaluates them. The expressions will only contain integers, the four basic operators (`+`, `-`, `*`, `/`), and will not include any parentheses. # Function Signature ```python def evaluate_expressions(expressions: list[str]) -> list[float]: pass ``` # Input * `expressions`: A list of strings, each string representing a mathematical expression. # Output * A list of floats where each float is the result of evaluating the corresponding expression in `expressions`. # Example ```python >>> evaluate_expressions([\\"3 + 2\\", \\"10 - 5\\", \\"4 * 5\\", \\"100 / 2\\"]) [5.0, 5.0, 20.0, 50.0] >>> evaluate_expressions([\\"2 + 3 * 4\\", \\"10 / 2 - 1\\", \\"6 + 5 * 2 / 10\\"]) [14.0, 4.0, 7.0] >>> evaluate_expressions([\\"7 - 3 * 0 + 2\\", \\"20 / 4 + 1\\"]) [9.0, 6.0] ``` # Edge Cases * An empty list should return an empty list. * Ensure that division by zero is handled gracefully, either by raising an appropriate error or by returning `float(\'inf\')` and logging an error message. * Handle whitespace appropriately in the input expressions. * Invalid input expressions should raise a suitable error. Implement the function `evaluate_expressions` ensuring it handles all specified conditions and edge cases correctly.","solution":"def evaluate_expressions(expressions: list[str]) -> list[float]: Evaluates a list of mathematical expressions and returns a list of their results. Each expression in the input list must be a valid mathematical expression containing integers and the operators +, -, *, /. def eval_expr(expr: str) -> float: # Use eval with caution try: result = eval(expr) return float(result) except ZeroDivisionError: return float(\'inf\') # Handle division by zero except Exception as e: raise ValueError(f\\"Invalid expression: {expr}\\") from e return [eval_expr(expr) for expr in expressions]"},{"question":"# Coding Challenge Question: Valid Balanced Parentheses with Custom Symbols **Context**: In programming languages, checking for balanced parentheses is a common task. This assignment requires developing a function that can validate custom pairs of symbols for balance in a string. Problem Statement Implement a function `is_balanced(expression: str, pairs: dict[str, str]) -> bool` that takes a string `expression` consisting of different characters and a dictionary `pairs` representing matching pairs of opening and closing symbols. The function should return `True` if the symbols in the expression are balanced according to the given pairs, otherwise return `False`. Input * A string `expression` that contains symbols and other characters. Example: `{a+[b*(c+d)]}`. * A dictionary `pairs` where each key is an opening symbol and the corresponding value is a closing symbol. Example: `{\'(\': \')\', \'[\': \']\', \'{\': \'}\'}`. Output * A boolean value: `True` if the symbols in the expression are balanced according to the given pairs, otherwise `False`. Constraints * The length of the expression `n` can be 0 <= n <= 10^5. * The dictionary will contain valid pairs of characters. Expectations 1. Efficient handling of the input string. 2. Proper validation of balance according to the provided symbol pairs. 3. Handling of edge cases and invalid inputs robustly. Example ```python >>> is_balanced(\\"{a+[b*(c+d)]}\\", {\'(\': \')\', \'[\': \']\', \'{\': \'}\'}) True >>> is_balanced(\\"{a+[(b*c+d)}]\\", {\'(\': \')\', \'[\': \']\', \'{\': \'}\'}) False >>> is_balanced(\\"[a * (b + c)\\", {\'(\': \')\', \'[\': \']\', \'{\': \'}\'}) False >>> is_balanced(\\"a + b + c\\", {\'(\': \')\', \'[\': \']\', \'{\': \'}\'}) True >>> is_balanced(\\"\\", {\'(\': \')\', \'[\': \']\', \'{\': \'}\'}) True ``` Implementation Challenge * Consider edge cases where expression might contain characters not in the pairs dictionary. * Ensure performance is optimal for large strings. * Handle erroneous inputs gracefully. Feel free to define helper functions if needed.","solution":"def is_balanced(expression: str, pairs: dict[str, str]) -> bool: stack = [] opening_symbols = set(pairs.keys()) closing_symbols = set(pairs.values()) matching_symbol = {v: k for k, v in pairs.items()} for char in expression: if char in opening_symbols: stack.append(char) elif char in closing_symbols: if not stack or stack[-1] != matching_symbol[char]: return False stack.pop() return not stack"},{"question":"# Question: Implement a Custom Priority Queue for Complex Data Types Overview: You are tasked with implementing a custom priority queue that can handle elements of a complex data type. The queue should support usual operations such as insertion, extraction of the maximum (or minimum) element based on a specific attribute of the complex data type, and checking if the queue is empty. Function Signature: ```python class CustomPriorityQueue: def __init__(self, attribute: str, max_heap: bool = True): \'\'\' Initializes the priority queue. Parameters: attribute (str): The attribute of the elements to base the priority on. max_heap (bool): Whether to implement the priority queue as a max-heap or min-heap (default is max-heap). \'\'\' self.queue = [] self.attribute = attribute self.max_heap = max_heap def insert(self, item: object): \'\'\' Inserts a new item into the priority queue. Parameters: item (object): The item to be inserted. \'\'\' # implementation follows def extract(self) -> object: \'\'\' Extracts the item with the highest priority from the queue. Returns: object: The item with the highest priority based on the specified attribute. \'\'\' # implementation follows def is_empty(self) -> bool: \'\'\' Checks if the priority queue is empty. Returns: bool: True if the queue is empty, False otherwise. \'\'\' return len(self.queue) == 0 ``` Input: - `attribute` - The attribute of the elements by which their priority will be determined. - `max_heap` - A boolean flag indicating whether the queue is a max-heap or min-heap. - `item` - An object to be inserted into the queue which contains the specified `attribute`. Output: - `insert`: Inserts an item into the priority queue without returning any value. - `extract`: Returns the object with the highest priority from the queue. - `is_empty`: Returns a boolean indicating whether the queue is empty. Example: ```python class Employee: def __init__(self, name, age, salary): self.name = name self.age = age self.salary = salary pqueue = CustomPriorityQueue(attribute=\'salary\') emp1 = Employee(\'Alice\', 30, 50000) emp2 = Employee(\'Bob\', 24, 55000) emp3 = Employee(\'Charlie\', 28, 49000) pqueue.insert(emp1) pqueue.insert(emp2) pqueue.insert(emp3) assert pqueue.extract().name == \'Bob\' assert pqueue.extract().name == \'Alice\' assert pqueue.is_empty() == False assert pqueue.extract().name == \'Charlie\' assert pqueue.is_empty() == True ``` Notes: - Handle edge cases such as extracting from an empty queue, ensure the `attribute` exists in the items, and manage max-heap or min-heap property as per the `max_heap` flag. - Make use of Python\'s `heapq` module for efficient heap operations, and customize the comparison based on the provided `attribute` and `max_heap` flag. - You may assume all objects inserted into the queue have the same structure and the specified attribute.","solution":"import heapq class CustomPriorityQueue: def __init__(self, attribute: str, max_heap: bool = True): self.queue = [] self.attribute = attribute self.max_heap = max_heap def _get_priority(self, item: object) -> float: # Retrieve the value of the specified attribute value = getattr(item, self.attribute) # If it\'s a max-heap, we store negative values to simulate max-heap behavior using min-heap return -value if self.max_heap else value def insert(self, item: object): # Create tuple of priority and item and push to the heap heapq.heappush(self.queue, (self._get_priority(item), item)) def extract(self) -> object: if self.is_empty(): raise IndexError(\\"extract from an empty priority queue\\") # Pop from the heap and return the item return heapq.heappop(self.queue)[1] def is_empty(self) -> bool: return len(self.queue) == 0"},{"question":"# Coding Challenge: Array Product Except Self **Problem Statement**: You are given an array `nums` of `n` integers where `n > 1`. Your task is to construct a new array `output` such that `output[i]` is equal to the product of all the elements of `nums` except `nums[i]`. **Function Specification**: Implement the function `array_product_except_self(nums: list) -> list` to achieve the desired output. # Input - A list of integers `nums` with the condition that `2 <= len(nums) <= 10^5` where the elements may include both positive and negative integers as well as zero. # Output - Return a list of integers where each element at index `i` is the product of all integers in the input list except `nums[i]`. # Constraints - You must solve the problem without using division and in O(n) time complexity. # Example 1. Given input: [1, 2, 3, 4] Expected output: [24, 12, 8, 6] 2. Given input: [-1, 1, 0, -3, 3] Expected output: [0, 0, 9, 0, 0] 3. Given input: [2, 3, 4, 5] Expected output: [60, 40, 30, 24] # Edge Cases 1. The list contains only positive numbers. 2. The list contains both positive and negative numbers. 3. The list contains one or more zeros. # Hints - Consider using two arrays to keep track of the products from the left and right side of each element. - Combine the products from both arrays to get the final output. **Note**: The examples provided in the problem statement are not exhaustive. Make sure to thoroughly test your code against various edge cases. ```python def array_product_except_self(nums: list) -> list: Construct an array \'output\' such that output[i] is the product of all the elements of nums except nums[i]. Args: nums (list): input list of integers Returns: list: list of products except self n = len(nums) output = [1] * n # Calculate left products left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate right products and multiply with left products right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output ```","solution":"def array_product_except_self(nums: list) -> list: Construct an array \'output\' such that output[i] is the product of all the elements of nums except nums[i]. Args: nums (list): input list of integers Returns: list: list of products except self n = len(nums) output = [1] * n # Calculate left products left_product = 1 for i in range(n): output[i] = left_product left_product *= nums[i] # Calculate right products and multiply with left products right_product = 1 for i in range(n - 1, -1, -1): output[i] *= right_product right_product *= nums[i] return output"},{"question":"Implementing and Analyzing Data Structures for Frequency Analysis Background Frequency analysis is a powerful technique used in cryptography to break ciphers by studying the frequency of letters or patterns in the ciphertext. In this task, you are required to implement and analyze data structures that can efficiently handle frequency analysis for a given text input. # Task 1. **Frequency Dictionary**: - Implement a function `frequency_dict` that takes a string input and returns a dictionary with characters as keys and their respective frequency counts as values. - Ensure that the function is case-insensitive and ignores non-alphabetic characters (e.g., punctuation, numbers). 2. **Most Frequent Characters**: - Implement a function `most_frequent_chars` that takes a frequency dictionary and an integer `n`, and returns a list of the `n` most frequent characters in descending order of frequency. - Handle ties by returning characters in alphabetical order. # Function Signatures * `def frequency_dict(input_string: str) -> dict[str, int]` * `def most_frequent_chars(freq_dict: dict[str, int], n: int) -> list[str]` # Constraints * The `input_string` will consist of printable ASCII characters. * The `n` will be a positive integer. # Examples ```python print(frequency_dict(\\"Hello, World!\\")) # Expected Output: {\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1} print(most_frequent_chars({\'h\': 1, \'e\': 1, \'l\': 3, \'o\': 2, \'w\': 1, \'r\': 1, \'d\': 1}, 2)) # Expected Output: [\'l\', \'o\'] ``` # Notes * Ensure the `frequency_dict` function is efficient and handles large inputs gracefully. * The `most_frequent_chars` function should handle the case where `n` is greater than the number of unique characters in the text by returning all characters sorted by their frequency. * Include appropriate docstrings and comments to explain your code logic.","solution":"import re from collections import Counter def frequency_dict(input_string: str) -> dict[str, int]: Given a string, returns a dictionary with characters as keys and their respective frequency counts as values. The function is case-insensitive and ignores non-alphabetic characters. input_string = input_string.lower() filtered_string = re.sub(\'[^a-z]\', \'\', input_string) return dict(Counter(filtered_string)) def most_frequent_chars(freq_dict: dict[str, int], n: int) -> list[str]: Given a frequency dictionary and an integer n, returns a list of the n most frequent characters in descending order of frequency. Ties are resolved by returning characters in alphabetical order. sorted_chars = sorted(freq_dict.items(), key=lambda item: (-item[1], item[0])) return [char for char, freq in sorted_chars[:n]]"},{"question":"# Meeting Room Scheduler In this task, you will implement a function to determine if a new meeting can be scheduled without conflicting with existing meetings. The scheduling system should check for overlapping time intervals and ensure each meeting room can only host one meeting at a time. Function Specifications 1. `can_schedule_meeting(existing_meetings: List[Tuple[str, str]], new_meeting: Tuple[str, str]) -> bool` This function should determine if a new meeting can be scheduled without overlapping any of the existing meetings. Each meeting is represented by a tuple with the start time and end time in the format of \\"HH:MM\\". The start and end times are in 24-hour format. - **Input**: - `existing_meetings (List[Tuple[str, str]])`: A list of tuples where each tuple represents a meeting with a start time and an end time. - `new_meeting (Tuple[str, str])`: A tuple representing the new meeting\'s start and end times. - **Output**: - `bool`: `True` if the new meeting can be scheduled without overlap, `False` otherwise. - **Constraints**: - Return `False` if the new meeting starts at the same time another meeting ends. - The start time of a meeting must be before its end time. - Assume all times are valid time strings in \\"HH:MM\\" format. Example ```python >>> can_schedule_meeting([(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"13:00\\", \\"14:00\\")], (\\"10:15\\", \\"10:45\\")) False >>> can_schedule_meeting([(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"13:00\\", \\"14:00\\")], (\\"11:30\\", \\"12:00\\")) True >>> can_schedule_meeting([(\\"09:00\\", \\"10:00\\"), (\\"10:30\\", \\"11:30\\"), (\\"13:00\\", \\"14:00\\")], (\\"10:30\\", \\"11:00\\")) False >>> can_schedule_meeting([], (\\"12:00\\", \\"13:00\\")) True >>> can_schedule_meeting([(\\"09:00\\", \\"12:00\\")], (\\"11:00\\", \\"11:30\\")) False ``` Notes - Ensure your function efficiently checks for meeting overlaps. - Handle edge cases where meeting times are exactly at the boundary of another meeting. - Make use of time comparison to validate the scheduling appropriately.","solution":"from typing import List, Tuple def can_schedule_meeting(existing_meetings: List[Tuple[str, str]], new_meeting: Tuple[str, str]) -> bool: def time_to_minutes(t: str) -> int: # Convert time string in \\"HH:MM\\" format to minutes since 00:00 hours, minutes = map(int, t.split(\\":\\")) return hours * 60 + minutes new_start = time_to_minutes(new_meeting[0]) new_end = time_to_minutes(new_meeting[1]) # Check if the new meeting\'s start time is before its end time if new_start >= new_end: return False for start, end in existing_meetings: start_time = time_to_minutes(start) end_time = time_to_minutes(end) # Check for overlapping if (new_start < end_time and new_end > start_time): return False return True"},{"question":"# Context Working with strings and mathematical functions is a common task in programming, which often requires an understanding of nested loops and control structures to manipulate data effectively. # Problem Statement Write a function `generate_pascal_triangle` that generates the first `n` rows of Pascal\'s Triangle. Pascal\'s Triangle is a triangular array of the binomial coefficients. # Requirements 1. **generate_pascal_triangle(n: int) -> List[List[int]]**: Returns the first `n` rows of Pascal\'s Triangle. - Each row is an array of integers, representing the binomial coefficients. # Input and Output Formats * **Input**: An integer `n` representing the number of rows. * **Output**: A list of lists of integers where each inner list represents a row in Pascal\'s Triangle. # Constraints * `0 <= n <= 30` # Example ```python # Example usage: assert generate_pascal_triangle(5) == [ [1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1] ] assert generate_pascal_triangle(0) == [] assert generate_pascal_triangle(1) == [[1]] ``` # Edge Cases to Consider * Generating Pascal\'s Triangle with `n = 0`. * Generating Pascal\'s Triangle with `n = 1`. * Ensuring that the rows have the correct length and content for any value of `n`. Implement the function: ```python from typing import List def generate_pascal_triangle(n: int) -> List[List[int]]: if n == 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle ```","solution":"from typing import List def generate_pascal_triangle(n: int) -> List[List[int]]: if n == 0: return [] triangle = [[1]] for i in range(1, n): row = [1] for j in range(1, i): row.append(triangle[i-1][j-1] + triangle[i-1][j]) row.append(1) triangle.append(row) return triangle"},{"question":"# Problem Statement You are tasked with creating a helper function for a web scraping tool. This function will process nested HTML lists represented as Python dictionaries. Your goal is to extract and flatten the links contained in a nested structure of lists and dictionaries. Each list or dictionary may contain other lists, dictionaries, or link strings. # Requirements 1. Implement the function `flatten_links(nested_structure: Union[list, dict]) -> list`. 2. The function should recursively traverse the nested structure and collect all link strings into a flat list. 3. Ensure the function can handle any combination of nested lists and dictionaries. # Input Format * A nested structure that is either a list or a dictionary. * The structure can be arbitrarily nested with lists, dictionaries, and strings representing URLs. # Output Format * A list of strings representing flattened URLs. # Constraints * The input nested structure will not exceed a depth of 20. * The total number of link strings in the nested structure will not exceed 10,000. * Link strings will be in a standard URL format (e.g., \\"http://example.com\\"). # Example ```python # Input nested_structure = { \\"section1\\": [ \\"http://example1.com\\", {\\"subsection\\": \\"http://example2.com\\"}, [\\"http://example3.com\\", \\"http://example4.com\\"] ], \\"section2\\": \\"http://example5.com\\", \\"section3\\": { \\"subsection1\\": \\"http://example6.com\\", \\"subsection2\\": [\\"http://example7.com\\", {\\"subsection3\\": \\"http://example8.com\\"}] } } # Output output_links = [ \\"http://example1.com\\", \\"http://example2.com\\", \\"http://example3.com\\", \\"http://example4.com\\", \\"http://example5.com\\", \\"http://example6.com\\", \\"http://example7.com\\", \\"http://example8.com\\" ] ``` Implement the function `flatten_links` that meets the above requirements.","solution":"from typing import Union, List def flatten_links(nested_structure: Union[List, dict]) -> List[str]: Recursively extracts and flattens link strings from arbitrarily nested lists and dictionaries. Parameters: nested_structure (Union[List, dict]): The nested structure containing lists, dictionaries, and link strings. Returns: List[str]: A flat list of link strings. flattened = [] if isinstance(nested_structure, dict): for value in nested_structure.values(): flattened.extend(flatten_links(value)) elif isinstance(nested_structure, list): for item in nested_structure: flattened.extend(flatten_links(item)) elif isinstance(nested_structure, str): flattened.append(nested_structure) return flattened"},{"question":"# Problem: Collatz Sequence Length You are participating in a coding apprenticeship at a software firm, and one of the tasks you are given is based on the Collatz conjecture. Your objective is to write a Python function that calculates the length of the Collatz sequence for a given positive integer n. The function should be optimized to handle large inputs efficiently. Instructions: 1. **Function Name**: `collatz_sequence_length` 2. **Input**: * **n** (int): A positive integer greater than or equal to 1. 3. **Output**: * An integer representing the total number of steps required for the sequence to reach 1. 4. **Constraints**: * `1 ≤ n ≤ 100,000` 5. **Performance Requirement**: * The function should compute the sequence length in a time-efficient manner, even for the upper limit of the input range. You are required to complete the following code, filling in the logic for the `collatz_sequence_length` function: ```python def collatz_sequence_length(n: int) -> int: steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps if __name__ == \\"__main__\\": n = 27 print(f\\"Collatz sequence length for {n}: {collatz_sequence_length(n)}\\") ``` Scenario: As a programmer in a computational research setting, you are required to calculate the Collatz sequence length for large numbers repeatedly. Your function needs to be optimized to handle potentially large values of n efficiently to support high-performance computations. **Deliverable**: Provide your complete implementation of the `collatz_sequence_length` function. Ensure your function is optimized and thoroughly tested to handle input values up to the constraint limit efficiently.","solution":"def collatz_sequence_length(n: int) -> int: steps = 0 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 steps += 1 return steps"},{"question":"# CSV to JSON Conversion Context: You are asked to implement a function that converts comma-separated values (CSV) formatted data into a JSON object. Each CSV row represents a separate object, with the first row providing the keys (column names) and subsequent rows providing the values for these keys. # Function: CSV to JSON Write a function `csv_to_json(csv_data: str) -> str` that takes a string containing CSV formatted data and returns a JSON formatted string. The function should raise a `ValueError` if the input CSV data is not properly formatted, specifically if all rows do not have the same number of columns. Example: ```python >>> csv_to_json(\'name,age,citynAlice,30,New YorknBob,25,Boston\') \'[{\\"name\\": \\"Alice\\", \\"age\\": \\"30\\", \\"city\\": \\"New York\\"}, {\\"name\\": \\"Bob\\", \\"age\\": \\"25\\", \\"city\\": \\"Boston\\"}]\' >>> csv_to_json(\'id,product,pricen1,T-shirt,20.5n2,Jeans,40.0n3,Shoes,60.75\') \'[{\\"id\\": \\"1\\", \\"product\\": \\"T-shirt\\", \\"price\\": \\"20.5\\"}, {\\"id\\": \\"2\\", \\"product\\": \\"Jeans\\", \\"price\\": \\"40.0\\"}, {\\"id\\": \\"3\\", \\"product\\": \\"Shoes\\", \\"price\\": \\"60.75\\"}]\' >>> csv_to_json(\'name,age,citynCharlie,35,ChicagonDavid,40,Miami\') \'[{\\"name\\": \\"Charlie\\", \\"age\\": \\"35\\", \\"city\\": \\"Chicago\\"}, {\\"name\\": \\"David\\", \\"age\\": \\"40\\", \\"city\\": \\"Miami\\"}]\' >>> csv_to_json(\'name,age,citynEmily,29,Seattle\') \'[{\\"name\\": \\"Emily\\", \\"age\\": \\"29\\", \\"city\\": \\"Seattle\\"}]\' >>> csv_to_json(\'name,age,citynFrank,32\') Traceback (most recent call last): ... ValueError: CSV data is invalid: Rows have inconsistent number of columns. ``` # Constraints: 1. Properly handle and strip any leading or trailing whitespace from keys and values. 2. Ensure that the JSON output keys and values are strings. 3. Raise a `ValueError` with a descriptive message if the CSV rows do not have the same number of columns. 4. Assume the input CSV data does not contain any quoted fields or escaped characters. This new question provides a task that involves string manipulation, error handling, and JSON formatting, which aligns well with the complexity, style, and scope of the provided Base16 encoding/decoding question.","solution":"import json def csv_to_json(csv_data: str) -> str: Convert CSV formatted data into a JSON formatted string. Args: csv_data (str): A string containing CSV formatted data. Returns: str: A JSON formatted string representing the CSV data. Raises: ValueError: If the input CSV data is not properly formatted. # Split the input into lines lines = csv_data.strip().split(\'n\') if len(lines) <= 1: return \\"[]\\" # Get the keys from the first line keys = [key.strip() for key in lines[0].split(\',\')] # Initialize list to hold the dictionary representation of each row json_list = [] # Process each row for row in lines[1:]: values = [value.strip() for value in row.split(\',\')] if len(values) != len(keys): raise ValueError(\\"CSV data is invalid: Rows have inconsistent number of columns.\\") # Create a dictionary for the current row row_dict = dict(zip(keys, values)) json_list.append(row_dict) return json.dumps(json_list)"},{"question":"# Problem: Invert Binary Tree Context: Inverting a binary tree means swapping every left node with its corresponding right node. Given the root of a binary tree, implement a function that inverts the tree and returns the root of the inverted tree. Function Signature: ```python def invert_tree(root: TreeNode | None) -> TreeNode | None: pass ``` Input: - `root` (TreeNode | None): The root node of the binary tree (or None for an empty tree). Output: - `TreeNode | None`: The root node of the inverted binary tree. Constraints: - The number of nodes in the tree can be up to 10^4. - Node values are integers within the range of -100 <= node.value <= 100. Requirements: 1. Utilize Depth-First Search (DFS) to traverse the tree. 2. Your solution should handle large trees efficiently. 3. Consider edge cases like empty trees, single-node trees, and imbalanced trees. Example: ```python # Example 1: # Input: # 4 # / # 2 7 # / / # 1 3 6 9 # Output: # 4 # / # 7 2 # / / # 9 6 3 1 # # Example 2: # Input: # 2 # / # 1 3 # Output: # 2 # / # 3 1 # Example Usage: root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) inverted_root = invert_tree(root) assert inverted_root.left.val == 7 assert inverted_root.right.val == 2 assert inverted_root.left.left.val == 9 assert inverted_root.left.right.val == 6 assert inverted_root.right.left.val == 3 assert inverted_root.right.right.val == 1 ``` Notes: - **Performance Consideration**: Aim for an O(n) time complexity solution and use stack space for recursion which would be O(h) where h is the height of the tree. - **Implementation Tip**: You can leverage recursion or iteration to traverse and swap nodes. Choose an approach that you find more intuitive.","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invert_tree(root: TreeNode | None) -> TreeNode | None: if not root: return None # Invert the subtree root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invert_tree(root.left) invert_tree(root.right) return root"},{"question":"# Question: Implement a Basic Calculator Supporting Multiple Operations You are tasked with implementing a basic calculator that supports four fundamental arithmetic operations: addition, subtraction, multiplication, and division. The calculator should be able to process a sequence of operations along with appropriate numerical inputs and apply the sequence of operations in order. Functions to Implement: 1. **Addition** - Computes the sum of two numbers. - **Input**: `num_1: float, num_2: float` - **Output**: `float` 2. **Subtraction** - Computes the difference between two numbers. - **Input**: `num_1: float, num_2: float` - **Output**: `float` 3. **Multiplication** - Computes the product of two numbers. - **Input**: `num_1: float, num_2: float` - **Output**: `float` 4. **Division** - Computes the quotient of two numbers. If divided by zero, return `float(\'inf\')`. - **Input**: `num_1: float, num_2: float` - **Output**: `float` 5. **Calculator Evaluator** - Evaluates a given sequence of arithmetic operations and applies them to inputs sequentially. - **Input**: `operations: List[Tuple[str, List[float]]]`, where each tuple contains: * The name of the operation (`\\"add\\"`, `\\"subtract\\"`, `\\"multiply\\"`, `\\"divide\\"`). * A list of two numerical inputs for the operation. - **Output**: `float` final result of the operations. **Constraints**: - The operations list will contain valid operation names and appropriate number of inputs for each operation. - Inputs to operations will always be numerical values (including both integers and floats). **Example:** Input: ```python operations = [ (\\"add\\", [1.5, 2.5]), (\\"multiply\\", [3, 4]), (\\"subtract\\", [10, 5]), (\\"divide\\", [20, 4]) ] ``` Output: ```python 5.0 # Result after applying all operations sequentially ``` Implement the following functions: ```python def add(num_1: float, num_2: float) -> float: pass def subtract(num_1: float, num_2: float) -> float: pass def multiply(num_1: float, num_2: float) -> float: pass def divide(num_1: float, num_2: float) -> float: pass def calculator_evaluator(operations: List[Tuple[str, List[float]]]) -> float: pass ```","solution":"from typing import List, Tuple def add(num_1: float, num_2: float) -> float: Computes the sum of two numbers. return num_1 + num_2 def subtract(num_1: float, num_2: float) -> float: Computes the difference between two numbers. return num_1 - num_2 def multiply(num_1: float, num_2: float) -> float: Computes the product of two numbers. return num_1 * num_2 def divide(num_1: float, num_2: float) -> float: Computes the quotient of two numbers. If divided by zero, return float(\'inf\'). if num_2 == 0: return float(\'inf\') return num_1 / num_2 def calculator_evaluator(operations: List[Tuple[str, List[float]]]) -> float: Evaluates a given sequence of arithmetic operations and applies them to inputs sequentially. result = 0 for operation, numbers in operations: if operation == \\"add\\": result = add(numbers[0], numbers[1]) elif operation == \\"subtract\\": result = subtract(numbers[0], numbers[1]) elif operation == \\"multiply\\": result = multiply(numbers[0], numbers[1]) elif operation == \\"divide\\": result = divide(numbers[0], numbers[1]) return result"},{"question":"# Context As an aspiring data engineer, you are given the task of implementing a basic recommendation system using collaborative filtering based on user-item interactions. This project is designed to help you understand the basics of collaborative filtering and matrix factorization. # Problem Statement Write a Python function to implement matrix factorization using Singular Value Decomposition (SVD) for a user-item interaction matrix with the following requirements: 1. **Matrix Factorization**: Decompose the user-item interaction matrix into user and item feature matrices. 2. **Reconstruction**: Reconstruct the original interaction matrix using the decomposed matrices. 3. **Prediction**: Predict missing values in the user-item interaction matrix. # Function Signature ```python def svd_recommendation(ratings: np.ndarray, k: int) -> np.ndarray: Parameters: ratings: np.ndarray -> User-item interaction matrix (users x items) k: int -> Number of singular values to consider for the decomposition Returns: np.ndarray -> Predicted/reconstructed user-item interaction matrix ``` # Input and Output - **Input**: - `ratings`: A `numpy` array of shape `(u, i)` where `u` is the number of users and `i` is the number of items, containing user-item interaction scores (e.g., ratings or likes). - `k`: An integer specifying the number of singular values to use for the decomposition. - **Output**: - A `numpy` array of shape `(u, i)`, representing the reconstructed user-item interaction matrix with predicted values for missing entries. # Constraints - You must use the SVD method to decompose the matrix. - Use only the top `k` singular values/vectors for the reconstruction. - Handle potential missing values represented by `NaN` in the input matrix by treating them as zero during SVD. # Example ```python import numpy as np ratings = np.array([[5, 3, np.nan, 1], [4, np.nan, np.nan, 1], [1, 1, np.nan, 5], [1, np.nan, np.nan, 4], [np.nan, 1, 5, 4]]) k = 2 predicted_ratings = svd_recommendation(ratings, k) print(predicted_ratings) # Example output: [[4.75, 3.15, 2.95, 1.1], [4.35, 2.8, 2.65, 1.15], ...]] ``` # Test Case Validate your solution by: 1. Testing with a small toy dataset. 2. Comparing your results with known outputs or using a library like `scikit-learn` for verification. 3. Ensuring edge cases are handled, such as matrices with all interactions filled, and proper handling of matrices with many missing values.","solution":"import numpy as np def svd_recommendation(ratings: np.ndarray, k: int) -> np.ndarray: Decompose the user-item interaction matrix using SVD and reconstruct it to make predictions. Parameters: ratings (np.ndarray): User-item interaction matrix (users x items) k (int): Number of singular values to consider for the decomposition Returns: np.ndarray: Predicted/reconstructed user-item interaction matrix # 1. Handle missing values by treating them as zero ratings = np.nan_to_num(ratings) # 2. Perform SVD decomposition U, sigma, Vt = np.linalg.svd(ratings, full_matrices=False) # 3. Keep only the top k singular values sigma = np.diag(sigma[:k]) U = U[:, :k] Vt = Vt[:k, :] # 4. Reconstruct the matrix reconstructed_matrix = np.dot(U, np.dot(sigma, Vt)) return reconstructed_matrix"},{"question":"**Implement a Thread-Safe Singleton Logger** Your task is to implement a thread-safe singleton Logger class that ensures only one instance of the Logger is created, even when accessed from multiple threads. The Logger should provide the following functionalities: 1. **Class Definition & Initialization**: - Define a `Logger` class with a private constructor and a static method to get the singleton instance. - Use appropriate synchronization mechanisms to ensure thread-safety. 2. **Logging Functionality**: - Include a method `log(message)` that writes the log messages to a file. - Ensure that log messages from different threads are not interleaved in the output file. 3. **Singleton Pattern**: - Implement the Singleton design pattern to restrict instantiation of the Logger class to a single object. - Use double-checked locking to enhance performance. 4. **Input and Output Formats**: - **get_instance()**: Should return the singleton instance of the Logger. - **log(message)**: Should append the provided message to a log file. 5. **Constraints**: - Log file path must be provided during the Logger initialization. - All log messages will be strings. - The Logger should be capable of handling logging from multiple threads efficiently. # Example ```python import threading class Logger: _instance = None _lock = threading.Lock() def __init__(self, file_path): if Logger._instance is not None: raise Exception(\\"This class is a singleton!\\") self.file_path = file_path Logger._instance = self @staticmethod def get_instance(file_path=None): if Logger._instance is None: with Logger._lock: if Logger._instance is None: Logger(file_path) return Logger._instance def log(self, message): with Logger._lock: with open(self.file_path, \'a\') as log_file: log_file.write(message + \'n\') # Example usage logger = Logger.get_instance(\'logfile.txt\') logger.log(\'This is a log message.\') # Simulating logging from multiple threads def log_from_thread(id): logger = Logger.get_instance(\'logfile.txt\') logger.log(f\'Thread {id} logging.\') threads = [] for i in range(5): t = threading.Thread(target=log_from_thread, args=(i,)) threads.append(t) t.start() for t in threads: t.join() # Output file `logfile.txt` should contain: # This is a log message. # Thread 0 logging. # Thread 1 logging. # Thread 2 logging. # Thread 3 logging. # Thread 4 logging. ``` Note: Ensure the implementation is as efficient as possible, handling multiple simultaneous access to the logging mechanism correctly and maintaining thread safety throughout.","solution":"import threading class Logger: _instance = None _lock = threading.Lock() def __init__(self, file_path): if Logger._instance is not None: raise Exception(\\"This class is a singleton!\\") self.file_path = file_path Logger._instance = self @staticmethod def get_instance(file_path=None): if Logger._instance is None: with Logger._lock: if Logger._instance is None: Logger(file_path) return Logger._instance def log(self, message): with Logger._lock: with open(self.file_path, \'a\') as log_file: log_file.write(message + \'n\')"},{"question":"# Scenario A text-based game needs to keep track of player scores over several rounds, and it must rank the players based on their cumulative scores. Your task is to implement the ranking logic. The system should take player names and their scores as input and return the players ranked from the highest to lowest cumulative scores. If two players have the same score, they should be ranked in alphabetical order by their names. # Task Description Implement a function `rank_players` that takes a list of tuples `scores` where each tuple contains a player\'s name (a string) and their score (an integer). The function should return a list of player names sorted by their cumulative scores in descending order. If two players have the same score, they should be sorted alphabetically by their names. # Function Signature ```python def rank_players(scores: List[Tuple[str, int]]) -> List[str]: pass ``` # Input * A list of tuples `scores` where each tuple contains: - A string representing the player\'s name (1 <= length of name <= 50). - An integer representing a score (1 <= score <= 100). # Output * A list of player names sorted by cumulative scores in descending order. * If two players have the same score, they should be sorted alphabetically by their names. # Constraints * The list `scores` contains at most 1000 tuples. # Example Example 1 ```python scores = [(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Alice\\", 25), (\\"Bob\\", 75), (\\"Cathy\\", 50)] print(rank_players(scores)) # Output: [\\"Bob\\", \\"Alice\\", \\"Cathy\\"] ``` Example 2 ```python scores = [(\\"Dave\\", 40), (\\"Eve\\", 40), (\\"Frank\\", 40)] print(rank_players(scores)) # Output: [\\"Dave\\", \\"Eve\\", \\"Frank\\"] ``` Example 3 ```python scores = [(\\"Zara\\", 99), (\\"Bass\\", 99), (\\"Omar\\", 99), (\\"Liam\\", 101)] print(rank_players(scores)) # Output: [\\"Liam\\", \\"Bass\\", \\"Omar\\", \\"Zara\\"] ``` # Notes * Ensure to account for players being listed multiple times in the input with additional scores each time. * Only use the Python standard library to solve this problem.","solution":"from typing import List, Tuple from collections import defaultdict def rank_players(scores: List[Tuple[str, int]]) -> List[str]: # Initialize a default dictionary to keep track of cumulative scores for each player. cumulative_scores = defaultdict(int) # Compute the cumulative scores for each player. for name, score in scores: cumulative_scores[name] += score # Create a list of players with their cumulative scores. player_score_list = [(name, cumulative_scores[name]) for name in cumulative_scores] # Sort the players: first by descending score, then by name alphabetically. player_score_list.sort(key=lambda x: (-x[1], x[0])) # Extract the sorted player names. ranked_players = [name for name, _ in player_score_list] return ranked_players"},{"question":"# Question Overview You are given a matrix containing integers where each cell represents the elevation at that point. You need to determine if there is a path from the top-left corner to the bottom-right corner. You can only move up, down, left, or right, and you can only move to adjacent cells with the same or lower elevation. # Problem Statement **Function Signature**: ```python def has_path(matrix: List[List[int]]) -> bool: pass ``` **Input**: - A 2D list `matrix` of size `m x n` where `0 ≤ m, n ≤ 100` and each element in the matrix is an integer value representing the elevation. **Output**: - Return `True` if there is a path from the top-left corner to the bottom-right corner, otherwise return `False`. # Constraints - You can only move up, down, left, or right to adjacent cells. - You may only move to a cell if its elevation is less than or equal to the current cell\'s elevation. # Hints - Consider using Breadth-First Search (BFS) or Depth-First Search (DFS) for traversal. - Use a queue or stack to keep track of the cells to be visited next. # Additional Requirements - Include meaningful comments in your code explaining each step. - Ensure your solution passes the following test cases: ```python assert has_path([[1]]) == True assert has_path([[1, 2], [3, 4]]) == False assert has_path([[4, 3, 2], [2, 1, 0], [1, 1, 1]]) == True assert has_path([[3, 3, 3], [2, 2, 2], [1, 1, 1]]) == True assert has_path([[5, 3], [6, 1]]) == True assert has_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == False ``` # Performance Testing - Your solution should handle matrices up to size `100 x 100` efficiently.","solution":"from collections import deque from typing import List def has_path(matrix: List[List[int]]) -> bool: if not matrix or not matrix[0]: return False rows, cols = len(matrix), len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() # If we\'ve reached the bottom-right corner, return True if x == rows - 1 and y == cols - 1: return True # Explore neighbors for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited: if matrix[nx][ny] <= matrix[x][y]: # Check elevation condition visited.add((nx, ny)) queue.append((nx, ny)) # If we\'ve exhausted all possibilities without reaching the bottom-right corner return False"},{"question":"# 2D Geometric Transformations You are tasked with implementing functionality for 2D geometric transformations. Specifically, you need to create a function that rotates a 2D point around the origin and another function that translates the rotated points by a given offset. Requirements 1. **`rotate_point` function**: * **Input**: A 2D point represented by coordinates `(x, y)` and an angle `theta` in degrees by which the point should be rotated around the origin. * **Output**: The rotated 2D point `(rotated_x, rotated_y)`. * **Function Signature**: ```python def rotate_point(x: float, y: float, theta: float) -> tuple[float, float]: ``` 2. **`translate_rotated_point` function**: * **Input**: A 2D point `(x, y)`, a rotation angle `theta`, and two parameters `dx` and `dy` for the translation offset. * **Output**: The translated 2D coordinates `(translated_x, translated_y)`. * **Function Signature**: ```python def translate_rotated_point( x: float, y: float, theta: float, dx: float, dy: float ) -> tuple[float, float]: ``` Constraints * Input values must be numeric (either `float` or `int`). * Angles are provided in degrees and must be converted to radians for calculations. Example ```python # Example usage of rotate_point rotated = rotate_point(1.0, 0.0, 90.0) print(rotated) # Output: (0.0, 1.0) # Example usage of translate_rotated_point translated = translate_rotated_point(1.0, 0.0, 90.0, 2.0, 3.0) print(translated) # Output: (2.0, 4.0) ``` Notes * Ensure that your implementation handles non-numeric inputs gracefully by raising appropriate exceptions. * Use the provided `convert_to_radians` function as a helper for the `rotate_point` and `translate_rotated_point` functions. * The rotation of the point should be performed using the standard rotation matrix: [ begin{pmatrix} cos(theta) & -sin(theta) sin(theta) & cos(theta) end{pmatrix} ] Good luck, and happy coding!","solution":"import math def rotate_point(x: float, y: float, theta: float) -> tuple[float, float]: Rotates a point (x, y) by theta degrees around the origin. Returns the rotated point coordinates (rotated_x, rotated_y). radians = math.radians(theta) cos_theta = math.cos(radians) sin_theta = math.sin(radians) rotated_x = x * cos_theta - y * sin_theta rotated_y = x * sin_theta + y * cos_theta return rotated_x, rotated_y def translate_rotated_point(x: float, y: float, theta: float, dx: float, dy: float) -> tuple[float, float]: Rotates a point (x, y) by theta degrees around the origin, then translates it by (dx, dy). Returns the translated point coordinates (translated_x, translated_y). rotated_x, rotated_y = rotate_point(x, y, theta) translated_x = rotated_x + dx translated_y = rotated_y + dy return translated_x, translated_y"},{"question":"# Coding Assessment Question Context: You are developing a system to manage employee records for a large organization. One of the functionalities needed is to efficiently search for employees based on their attributes. Task: Write a Python class `EmployeeDirectory` that manages a collection of employee records and allows for efficient attribute-based searches. Implementation Steps: 1. Implement an `Employee` class with the following attributes: - `id` (int): Unique identifier for the employee. - `name` (str): Full name of the employee. - `department` (str): Department to which the employee belongs. - `salary` (int): Annual salary of the employee. 2. Implement the `EmployeeDirectory` class that should: - Store a list of `Employee` objects. - Allow adding new `Employee` objects. - Allow searching for employees based on their name, department, or salary range. 3. The `EmployeeDirectory` class should include the following methods: - `add_employee(employee: Employee) -> None`: Adds a new employee to the directory. - `find_by_name(name: str) -> List[Employee]`: Returns a list of employees whose name matches the given name. - `find_by_department(department: str) -> List[Employee]`: Returns a list of employees who belong to the given department. - `find_by_salary_range(min_salary: int, max_salary: int) -> List[Employee]`: Returns a list of employees whose salary is within the specified range. Input Format: - `Employee` and `EmployeeDirectory` classes with specified attributes and methods. Output Format: - Methods of the `EmployeeDirectory` class should return lists of `Employee` instances based on the search criteria. Constraints: - Assume there are no duplicate employee IDs. - The `name` and `department` are case-sensitive. - The salary range search should include the boundaries. Performance Requirements: - The solution should have a reasonable time complexity to handle up to 10,000 employee records efficiently. Example: Suppose the following employee records are added to the `EmployeeDirectory`: ```python e1 = Employee(1, \\"Alice Smith\\", \\"Engineering\\", 85000) e2 = Employee(2, \\"Bob Jones\\", \\"HR\\", 50000) e3 = Employee(3, \\"Alice Johnson\\", \\"Engineering\\", 95000) e4 = Employee(4, \\"Charlie Brown\\", \\"Marketing\\", 60000) directory = EmployeeDirectory() directory.add_employee(e1) directory.add_employee(e2) directory.add_employee(e3) directory.add_employee(e4) ``` Calling `directory.find_by_name(\\"Alice\\")` should yield: ```python [Employee(id=1, name=\\"Alice Smith\\", department=\\"Engineering\\", salary=85000), Employee(id=3, name=\\"Alice Johnson\\", department=\\"Engineering\\", salary=95000)] ``` Calling `directory.find_by_department(\\"Engineering\\")` should yield: ```python [Employee(id=1, name=\\"Alice Smith\\", department=\\"Engineering\\", salary=85000), Employee(id=3, name=\\"Alice Johnson\\", department=\\"Engineering\\", salary=95000)] ``` Calling `directory.find_by_salary_range(80000, 90000)` should yield: ```python [Employee(id=1, name=\\"Alice Smith\\", department=\\"Engineering\\", salary=85000)] ```","solution":"from typing import List class Employee: def __init__(self, id: int, name: str, department: str, salary: int): self.id = id self.name = name self.department = department self.salary = salary class EmployeeDirectory: def __init__(self): self.employees = [] def add_employee(self, employee: Employee) -> None: self.employees.append(employee) def find_by_name(self, name: str) -> List[Employee]: return [emp for emp in self.employees if emp.name == name] def find_by_department(self, department: str) -> List[Employee]: return [emp for emp in self.employees if emp.department == department] def find_by_salary_range(self, min_salary: int, max_salary: int) -> List[Employee]: return [emp for emp in self.employees if min_salary <= emp.salary <= max_salary]"},{"question":"**Context**: Linked lists are a classic data structure in computer science, providing a flexible way to manage sequences of elements. Merging sorted linked lists is a common task, particularly useful in algorithms involving divided sequences. # Problem Statement Implement a function that merges two sorted, singly linked lists into one sorted linked list. The function should return the head of the new linked list. # Requirements * **Function Name**: `merge_sorted_linked_lists` * **Input**: Two linked lists, `l1` and `l2`, both sorted in non-decreasing order * **Output**: A single linked list sorted in non-decreasing order # Constraints - Each linked list node must be represented using a class `ListNode` with attributes `val` (integer) and `next` (pointer to the next node). - The length of the two linked lists combined will not exceed 1000. - The result should maintain the property of being sorted in non-decreasing order. # Performance - Aim for time complexity O(n+m) where n and m are the lengths of the two linked lists. - Ensure the space complexity remains O(1) for the merging process itself (excluding the space required for the input and output lists). # Example ```python class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: # Your code here # Example usage: # Input: l1 = 1 -> 2 -> 4, l2 = 1 -> 3 -> 4 # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 # Constructing example linked lists: l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) merged_head = merge_sorted_linked_lists(l1, l2) while merged_head: print(merged_head.val, end=\\" -> \\") merged_head = merged_head.next # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> # Edge cases: # Input: l1 = None, l2 = 0 -> 1 -> 2 # Output: 0 -> 1 -> 2 # Input: l1 = 0 -> 1 -> 2, l2 = None # Output: 0 -> 1 -> 2 # Input: l1 = None, l2 = None # Output: None ``` # Special Considerations - Handle edge cases where one or both linked lists may be empty. - Ensure that duplicate values appear in the merged list in their proper order. # Testing Create a series of unit tests to validate your function under different scenarios, including edge cases, average random input, and worst-case scenarios.","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_sorted_linked_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy while l1 and l2: if l1.val <= l2.val: current.next = l1 l1 = l1.next else: current.next = l2 l2 = l2.next current = current.next if l1: current.next = l1 else: current.next = l2 return dummy.next"},{"question":"# Task You are required to implement a function that generates a sequence of numbers based on the Collatz conjecture, also known as the \\"3n + 1\\" problem, and then calculates the length of the sequence. # Function Signature ```python def collatz_sequence_length(n: int) -> int: pass ``` # Input * `n (int)`: A positive integer representing the starting value of the sequence. # Output * An integer representing the length of the Collatz sequence starting from `n` and ending at `1`. # Constraints * The input `n` will be a positive integer. * You should handle potential large numbers, ensuring the function terminates for reasonable values of `n`. # Example ```python # Starting number n = 6 # Calculating the sequence length length = collatz_sequence_length(n) print(length) # Output should be 9 since the sequence is [6, 3, 10, 5, 16, 8, 4, 2, 1] and its length is 9. ``` # Notes You should implement the `collatz_sequence_length` function such that it calculates the Collatz sequence length efficiently. The sequence is generated as follows: - Start with the integer `n`. - If `n` is even, the next number is `n / 2`. - If `n` is odd, the next number is `3 * n + 1`. - Repeat the above steps until `n` becomes 1.","solution":"def collatz_sequence_length(n: int) -> int: Generates a sequence of numbers based on the Collatz conjecture and returns its length. Parameters: n (int): A positive integer representing the starting value of the sequence. Returns: int: The length of the Collatz sequence starting from `n` and ending at `1`. length = 1 while n != 1: if n % 2 == 0: n = n // 2 else: n = 3 * n + 1 length += 1 return length"},{"question":"# Morse Code Translator Implement a class `MorseCodeTranslator` that can encode and decode strings using Morse code. Explanation: - The `encode` method should take a string and return a string representing its Morse code equivalent. Each letter is separated by a space and each word by a \' / \'. - The `decode` method should take a string in Morse code and return the original message. Function Signature: ```python class MorseCodeTranslator: ... def encode(self, text: str) -> str: ... def decode(self, morse: str) -> str: ... ``` Morse Code Mapping Table: - A: .- N: -. 0: ----- - B: -... O: --- 1: .---- - C: -.-. P: .--. 2: ..--- - D: -.. Q: --.- 3: ...-- - E: . R: .-. 4: ....- - F: ..-. S: ... 5: ..... - G: --. T: - 6: -.... - H: .... U: ..- 7: --... - I: .. V: ...- 8: ---.. - J: .--- W: .-- 9: ----. - K: -.- X: -..- - L: .-.. Y: -.-- - M: -- Z: --.. Expected Inputs and Outputs: * **Input**: * text: A string of alphanumeric characters and spaces. * morse: A string in Morse code. * **Output**: * A string representing the encoded Morse code. * A string representing the decoded message. Example: ```python translator = MorseCodeTranslator() # Encoding Example encoded_message = translator.encode(\'HELLO WORLD\') assert encoded_message == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" # Decoding Example decoded_message = translator.decode(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") assert decoded_message == \'HELLO WORLD\' ``` # Notes: 1. Input strings for `encode` will only contain uppercase letters, digits, and spaces. 2. Input strings for `decode` will only contain \'.\', \'-\', and \' / \'. # Constraints: 1. Each string (both input and output) will have a length between 1 and 10000 characters.","solution":"class MorseCodeTranslator: morse_code_dict = { \'A\': \'.-\', \'B\': \'-...\', \'C\': \'-.-.\', \'D\': \'-..\', \'E\': \'.\', \'F\': \'..-.\', \'G\': \'--.\', \'H\': \'....\', \'I\': \'..\', \'J\': \'.---\', \'K\': \'-.-\', \'L\': \'.-..\', \'M\': \'--\', \'N\': \'-.\', \'O\': \'---\', \'P\': \'.--.\', \'Q\': \'--.-\', \'R\': \'.-.\', \'S\': \'...\', \'T\': \'-\', \'U\': \'..-\', \'V\': \'...-\', \'W\': \'.--\', \'X\': \'-..-\', \'Y\': \'-.--\', \'Z\': \'--..\', \'0\': \'-----\', \'1\': \'.----\', \'2\': \'..---\', \'3\': \'...--\', \'4\': \'....-\', \'5\': \'.....\', \'6\': \'-....\', \'7\': \'--...\', \'8\': \'---..\', \'9\': \'----.\' } @classmethod def encode(cls, text: str) -> str: encoded_text = [] for word in text.split(\\" \\"): encoded_word = \\" \\".join([cls.morse_code_dict[char] for char in word]) encoded_text.append(encoded_word) return \\" / \\".join(encoded_text) @classmethod def decode(cls, morse: str) -> str: morse_words = morse.split(\\" / \\") decoded_text = [] reverse_morse_code_dict = {v: k for k, v in cls.morse_code_dict.items()} for morse_word in morse_words: decoded_word = \\"\\".join([reverse_morse_code_dict[char] for char in morse_word.split()]) decoded_text.append(decoded_word) return \\" \\".join(decoded_text)"},{"question":"# Merge Sorted Lists and Handle Duplicate Removal In a data processing project, you need to merge multiple sorted lists into a single sorted list, removing any duplicate elements. Your task is to implement a function `merge_sorted_lists` that merges the lists and eliminates duplicates, while preserving the sorted order. # Task 1. **merge_sorted_lists(lists: List[List[int]]) -> List[int]** - Input: A list of `List[int]` where each `List[int]` is pre-sorted in ascending order. - Output: A single merged `List[int]` containing all unique elements from the input lists, sorted in ascending order. # Constraints - Each input list can contain integers, both positive and negative. - The input lists vary in length, with a minimum length of 0 and no specified maximum length. - You cannot use Python\'s built-in sorting functions to directly sort the final merged list. # Example Usage ```python >>> merge_sorted_lists([[1, 3, 5], [2, 4, 6], [0, 3, 3, 7, 8]]) [0, 1, 2, 3, 4, 5, 6, 7, 8] >>> merge_sorted_lists([[10, 20], [5, 25], [], [5, 15]]) [5, 10, 15, 20, 25] >>> merge_sorted_lists([[-3, -1, 0], [-2, 2, 3], [1, 1, 4]]) [-3, -2, -1, 0, 1, 2, 3, 4] >>> merge_sorted_lists([[], [], []]) [] ``` # Additional Requirements 1. **Efficiency**: - Given that each input list is already sorted, design your algorithm to take advantage of this property for an efficient merge. 2. **Edge Cases**: - Ensure the function handles the merging of multiple empty lists correctly. - Ensure that the function can handle lists with negative numbers properly. - Ensure the function correctly removes duplicate elements from the merged list while maintaining the sorted order. Implement the `merge_sorted_lists` function with the described requirements and constraints.","solution":"import heapq from typing import List def merge_sorted_lists(lists: List[List[int]]) -> List[int]: Merges multiple sorted lists into a single sorted list, removing duplicates. :param lists: List of sorted lists to be merged. :return: A merged sorted list with unique elements. min_heap = [] for l in lists: if l: for num in l: heapq.heappush(min_heap, num) merged_and_unique = [] prev = None while min_heap: current = heapq.heappop(min_heap) if current != prev: merged_and_unique.append(current) prev = current return merged_and_unique"},{"question":"# Question: Prime Factorization Given an integer, write a function to return its prime factors along with their respective counts. Prime factorization is presenting an integer as a product of prime numbers raised to their respective powers. **Problem Statement**: Implement a Python function that takes an integer and returns its prime factors as a dictionary with prime factors as keys and their counts as values. **Function Signature**: ```python def prime_factorization(n: int) -> dict[int, int]: pass ``` **Parameters**: - `n` (int): The integer to be factorized. **Returns**: - A dictionary where keys are prime factors, and values are their respective counts. **Examples**: ```python >>> prime_factorization(18) {2: 1, 3: 2} >>> prime_factorization(100) {2: 2, 5: 2} >>> prime_factorization(37) {37: 1} >>> prime_factorization(1) {} >>> prime_factorization(0) {} ``` **Constraints**: - The function should handle positive integers, zero, and one. Zero and one do not have prime factors, so they should return an empty dictionary. - Assume `n` will be a non-negative integer within the range of `0 <= n <= 10^9`. Your task is to write an efficient function that calculates the prime factors of the given integer. Consider edge cases and ensure optimal performance for large numbers.","solution":"def prime_factorization(n: int) -> dict[int, int]: Returns the prime factorization of the integer n as a dictionary where keys are prime factors and values are their respective counts. if n <= 1: return {} result = {} factor = 2 while factor * factor <= n: while (n % factor) == 0: if factor in result: result[factor] += 1 else: result[factor] = 1 n //= factor factor += 1 if n > 1: result[n] = 1 return result"}]'),F={name:"App",components:{PoemCard:C},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const r=this.searchQuery.trim().toLowerCase();return r?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(r)||e.solution&&e.solution.toLowerCase().includes(r)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(r=>setTimeout(r,1e3)),this.visibleCount+=4,this.isLoading=!1}}},N={class:"search-container"},L={class:"card-container"},O={key:0,class:"empty-state"},R=["disabled"],z={key:0},D={key:1};function P(r,e,l,p,s,a){const m=g("PoemCard");return n(),i("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",N,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),_(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>s.searchQuery=o),placeholder:"Search..."},null,512),[[y,s.searchQuery]]),s.searchQuery?(n(),i("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>s.searchQuery="")}," ✕ ")):u("",!0)]),t("div",L,[(n(!0),i(b,null,v(a.displayedPoems,(o,f)=>(n(),w(m,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(n(),i("div",O,' No results found for "'+d(s.searchQuery)+'". ',1)):u("",!0)]),a.hasMorePoems?(n(),i("button",{key:0,class:"load-more-button",disabled:s.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[s.isLoading?(n(),i("span",D,"Loading...")):(n(),i("span",z,"See more"))],8,R)):u("",!0)])}const j=h(F,[["render",P],["__scopeId","data-v-e446cb7f"]]),M=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"library/15.md","filePath":"library/15.md"}'),Y={name:"library/15.md"},V=Object.assign(Y,{setup(r){return(e,l)=>(n(),i("div",null,[x(j)]))}});export{M as __pageData,V as default};
