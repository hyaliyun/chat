import{_ as m,o as s,c as n,a as t,m as d,t as c,C as h,M as g,U as b,f as l,F as x,p as y,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const k={name:"PoemCard",props:{poem:{type:Object,required:!0}}},q={class:"poem-container"},T={class:"review"},L={class:"review-title"},N={class:"review-content"};function A(i,e,u,_,r,a){return s(),n("div",q,[t("div",T,[t("div",L,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),d(c(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),d(c(u.poem.solution),1)])])])}const S=m(k,[["render",A],["__scopeId","data-v-1e1bf1aa"]]),R=JSON.parse(`[{"question":"def longest_sequence_of_minute_intervals(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases T and a list of test cases, each containing a number of events and their corresponding timestamps, returns a list of integers representing the length of the longest sequence of events where each event occurs exactly one minute after the previous one. >>> longest_sequence_of_minute_intervals(2, [(5, [1, 2, 3, 5, 6]), (4, [10, 12, 13, 14])]) [3, 3] >>> longest_sequence_of_minute_intervals(1, [(3, [0, 1, 2])]) [3] >>> longest_sequence_of_minute_intervals(1, [(5, [5, 7, 8, 9, 10])]) [4] >>> longest_sequence_of_minute_intervals(3, [(4, [2, 3, 4, 5]), (3, [7, 9, 10]), (2, [15, 16])]) [4, 2, 2]","solution":"def longest_sequence_of_minute_intervals(T, test_cases): results = [] for case in test_cases: n, timestamps = case if n <= 1: results.append(n) continue longest_length = 1 current_length = 1 for i in range(1, n): if timestamps[i] == timestamps[i-1] + 1: current_length += 1 longest_length = max(longest_length, current_length) else: current_length = 1 results.append(longest_length) return results"},{"question":"def single_number(nums): Returns the single number in the list which appears only once, while other numbers appear exactly twice. >>> single_number([1, 2, 3, 2, 1]) == 3 >>> single_number([4, 1, 2, 1, 2, 4, 5]) == 5 >>> single_number([2, 2, 3, 5, 3]) == 5 >>> single_number([7, 3, 5, 3, 5]) == 7 >>> single_number([10]) == 10 >>> single_number([0, 0, 1, 1, -1, -1, 99]) == 99 >>> single_number([17, 23, 17, 19, 19]) == 23 >>> single_number([1000000, 1, 1, 2, 2, 1000000, 99]) == 99 >>> single_number([-2, -2, -3]) == -3 >>> large_input = list(range(1, 500001)) + list(range(1, 500000)) >>> single_number(large_input) == 500000","solution":"def single_number(nums): Returns the single number in the list which appears only once, while other numbers appear exactly twice. single = 0 for num in nums: single ^= num return single"},{"question":"def find_smallest_missing_positive(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an integer t representing the number of test cases and a list of tuples where each tuple contains an integer N and a list of N integers, find the smallest positive integer that is not present in the array for each test case. >>> find_smallest_missing_positive(2, [(3, [1, 2, 0]), (4, [3, 4, -1, 1])]) [3, 2] >>> find_smallest_missing_positive(1, [(5, [2, 3, 7, 6, 8, -1, -10, 15])]) [1] >>> find_smallest_missing_positive(1, [(4, [-1, -2, -3, -4])]) [1] >>> find_smallest_missing_positive(1, [(6, [1, 2, 3, 4, 5, 6])]) [7] >>> find_smallest_missing_positive(2, [(3, [1, 1, 0]), (3, [1, 2, 3])]) [2, 4]","solution":"def find_smallest_missing_positive(t, test_cases): results = [] for i in range(t): n, array = test_cases[i][0], test_cases[i][1] present = [False] * (n + 1) for num in array: if 1 <= num <= n: present[num] = True smallest_missing_positive = n + 1 for j in range(1, n + 1): if not present[j]: smallest_missing_positive = j break results.append(smallest_missing_positive) return results"},{"question":"def countDistinctIslands(grid: List[List[int]]) -> int: Returns the number of distinct islands in the given grid. >>> countDistinctIslands([[1, 1, 0, 0, 0], [1, 1, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 1, 1]]) 2 >>> countDistinctIslands([[1, 1, 0, 0, 0], [1, 0, 0, 0, 1], [0, 0, 0, 1, 1], [0, 0, 0, 0, 0], [0, 1, 1, 0, 0]]) 3 >>> countDistinctIslands([[1, 0], [0, 0]]) 1 >>> countDistinctIslands([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> countDistinctIslands([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 1 pass","solution":"def countDistinctIslands(grid): Returns the number of distinct islands in the given grid. grid: List of List of integers (1's and 0's) if not grid or not grid[0]: return 0 def dfs(x, y): if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]) or grid[x][y] == 0: return grid[x][y] = 0 dfs(x + 1, y) dfs(x - 1, y) dfs(x, y + 1) dfs(x, y - 1) def find_islands(): count = 0 for i in range(len(grid)): for j in range(len(grid[0])): if grid[i][j] == 1: dfs(i, j) count += 1 return count return find_islands()"},{"question":"def rank_students(test_cases): Rank the students based on their scores. Given a list of students with their corresponding scores in a test, rank the students based on their scores. In case of a tie (i.e., multiple students having the same score), assign the same rank to those students and leave a gap in the ranking for subsequent students. Args: test_cases (List[List[Tuple[str, int]]]): List of test cases, each containing a list of tuples with student name and score. Returns: List[List[Tuple[str, int]]]: List of results for each test case, where each result is a list of tuples containing student name and their rank. pass def process_input(input_string): Process the input string and convert it to a list of test cases. Args: input_string (str): String containing the input data. Returns: List[List[Tuple[str, int]]]: List of test cases, each containing a list of tuples with student name and score. pass def format_output(results): Format the output results into a string for displaying. Args: results (List[List[Tuple[str, int]]]): List of results for each test case, where each result is a list of tuples containing student name and their rank. Returns: str: Formatted string output. pass # Unit tests def test_single_test_case(): input_data = \\"1n5nAlice 90nBob 85nCharlie 85nDavid 80nEva 70\\" expected_output = \\"Alice 1nBob 2nCharlie 2nDavid 4nEva 5\\" test_cases = process_input(input_data) results = rank_students(test_cases) output = format_output(results) assert output == expected_output def test_multiple_test_cases(): input_data = \\"2n5nAlice 90nBob 85nCharlie 85nDavid 80nEva 70n3nJohn 95nJane 95nJake 90\\" expected_output = \\"Alice 1nBob 2nCharlie 2nDavid 4nEva 5nJohn 1nJane 1nJake 3\\" test_cases = process_input(input_data) results = rank_students(test_cases) output = format_output(results) assert output == expected_output def test_all_same_scores(): input_data = \\"1n4nEthan 80nSophia 80nJames 80nIsabella 80\\" expected_output = \\"Ethan 1nSophia 1nJames 1nIsabella 1\\" test_cases = process_input(input_data) results = rank_students(test_cases) output = format_output(results) assert output == expected_output def test_single_student(): input_data = \\"1n1nMichael 90\\" expected_output = \\"Michael 1\\" test_cases = process_input(input_data) results = rank_students(test_cases) output = format_output(results) assert output == expected_output","solution":"def rank_students(test_cases): results = [] for students in test_cases: sorted_students = sorted(students, key=lambda x: -x[1]) ranks = [] current_rank = 1 count = 1 for i in range(len(sorted_students)): if i > 0 and sorted_students[i][1] != sorted_students[i - 1][1]: current_rank = count ranks.append((sorted_students[i][0], current_rank)) count += 1 results.append(ranks) return results def process_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) students = [] for j in range(1, N+1): name, score = lines[index + j].rsplit(\\" \\", 1) score = int(score) students.append((name, score)) test_cases.append(students) index += (N + 1) return test_cases def format_output(results): output = [] for result in results: for student in result: output.append(f\\"{student[0]} {student[1]}\\") return \\"n\\".join(output)"},{"question":"def kth_largest_distinct_character(s: str, k: int) -> str: Write a function that takes a string s consisting of lowercase English letters and an integer k. The function should find the k-th largest distinct character (alphabetically, with 'a' being the smallest and 'z' being the largest) in the string. If there are fewer than k distinct characters, return the character '?'. >>> kth_largest_distinct_character(\\"abracadabra\\", 2) 'd' >>> kth_largest_distinct_character(\\"xyz\\", 4) '?'","solution":"def kth_largest_distinct_character(s, k): Returns the k-th largest distinct character in string s. If there are fewer than k distinct characters, returns '?'. distinct_chars = sorted(set(s)) if len(distinct_chars) < k: return '?' return distinct_chars[-k]"},{"question":"def distinct_areas(n: int, rectangles: List[Tuple[int, int]]) -> int: Returns the number of distinct areas among the given rectangles. Parameters: n (int): The number of rectangles. rectangles (list of tuple): List of tuples where each tuple contains two integers (l, w) representing length and width of a rectangle. Returns: int: The number of distinct areas. >>> distinct_areas(3, [(4, 5), (2, 3), (4, 5)]) 2 >>> distinct_areas(5, [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) 5 pass","solution":"def distinct_areas(n, rectangles): Returns the number of distinct areas among the given rectangles. Parameters: n (int): The number of rectangles. rectangles (list of tuple): List of tuples where each tuple contains two integers (l, w) representing length and width of a rectangle. Returns: int: The number of distinct areas. areas = set() for l, w in rectangles: areas.add(l * w) return len(areas)"},{"question":"def max_subarray_product(arr: List[int]) -> int: Given an array of integers, find the contiguous subarray within an array (containing at least one number) which has the largest product. The subarray can contain both positive and negative numbers. >>> max_subarray_product([2, 3, -2, 4, -1]) 48 >>> max_subarray_product([-2, 0, -1]) 0 >>> max_subarray_product([6]) 6 >>> max_subarray_product([-6]) -6 >>> max_subarray_product([1, 2, 3, 4, 5]) 120 >>> max_subarray_product([-1, -2, -3, -4]) 24 >>> max_subarray_product([0, 2, -2, 3, 0, 4, -1]) 4 >>> max_subarray_product([2] * 100000) 2**100000","solution":"def max_subarray_product(arr): Returns the maximum product of a contiguous subarray within an array. if not arr: return 0 max_product = min_product = result = arr[0] for number in arr[1:]: if number < 0: max_product, min_product = min_product, max_product max_product = max(number, max_product * number) min_product = min(number, min_product * number) result = max(result, max_product) return result"},{"question":"def interesting_sequence(n): Returns an interesting sequence of n positive integers, or \\"impossible\\" if not possible. >>> interesting_sequence(1) \\"1\\" >>> interesting_sequence(4) \\"1 2 4 8\\" >>> interesting_sequence(5) \\"1 2 4 8 16\\" >>> interesting_sequence(0) \\"impossible\\" >>> interesting_sequence(10) \\"1 2 4 8 16 32 64 128 256 512\\"","solution":"def interesting_sequence(n): Returns an interesting sequence of n positive integers. if n < 1: return \\"impossible\\" sequence = [2**i for i in range(n)] return ' '.join(map(str, sequence))"},{"question":"def guess_integer(y): Guesses the integer y held by a friend using a binary search strategy. low, high = 0, 2**30 - 1 while low < high: mid = (low + high) // 2 if is_greater(y, mid): low = mid + 1 else: high = mid return low def is_greater(y, k): Mock response function to simulate the friend's answer. For test purposes, it returns whether y is greater than k. return y > k # Example Interaction if __name__ == \\"__main__\\": y = 20 # This would be interactively determined in a real scenario result = guess_integer(y) print(\\"Your integer is\\", result)","solution":"def guess_integer(y): Guesses the integer y held by a friend using a binary search strategy. low, high = 0, 2**30 - 1 while low < high: mid = (low + high) // 2 if is_greater(y, mid): low = mid + 1 else: high = mid return low def is_greater(y, k): Mock response function to simulate the friend's answer. For test purposes, it returns whether y is greater than k. return y > k"},{"question":"def max_equal_subsequence_length(S: str) -> int: Returns the maximum size of a contiguous subsequence which has an equal number of '0's and '1's. Args: S (str): A binary string. Returns: int: The maximum size of the subsequence. Example: >>> max_equal_subsequence_length(\\"1100011\\") 6 >>> max_equal_subsequence_length(\\"10101\\") 4 def main(input_lines: List[str]) -> List[int]: Processes multiple test cases to find the maximum size of contiguous subsequences with an equal number of '0's and '1's. Args: input_lines (List[str]): List of input lines where the first line is the number of test cases and the subsequent lines are the binary strings. Returns: List[int]: List of results for each test case. Example: >>> main([\\"2\\", \\"1100011\\", \\"10101\\"]) [6, 4]","solution":"def max_equal_subsequence_length(S): Returns the maximum size of a contiguous subsequence which has an equal number of '0's and '1's. n = len(S) max_len = 0 count = 0 count_map = {0: -1} for i in range(n): count += 1 if S[i] == '1' else -1 if count in count_map: max_len = max(max_len, i - count_map[count]) else: count_map[count] = i return max_len def main(input_lines): T = int(input_lines[0]) results = [] for i in range(1, T + 1): S = input_lines[i] results.append(max_equal_subsequence_length(S)) return results"},{"question":"def uniqueElements(arr): Returns a list of unique elements from the input list, in the order they first appeared. :param arr: List of integers :return: List of unique integers or null if the input is invalid","solution":"def uniqueElements(arr): Returns a list of unique elements from the input list, in the order they first appeared. :param arr: List of integers :return: List of unique integers or null if the input is invalid if not isinstance(arr, list) or not all(isinstance(i, int) for i in arr): return None seen = set() unique = [] for num in arr: if num not in seen: seen.add(num) unique.append(num) return unique"},{"question":"def cutRod(L: int, price: List[int]) -> int: Returns the maximum value obtainable by cutting up the rod of length L and selling the pieces based on the given price array. >>> cutRod(8, [1, 5, 8, 9, 10, 17, 17, 20]) 22 >>> cutRod(8, [3, 5, 8, 9, 10, 17, 17, 20]) 24","solution":"def cutRod(L, price): Returns the maximum value obtainable by cutting up the rod of length L and selling the pieces based on the given price array. # Create a table to store results of subproblems dp = [0] * (L + 1) # Build the table dp[] in bottom up manner for i in range(1, L + 1): max_val = -1 for j in range(i): max_val = max(max_val, price[j] + dp[i - j - 1]) dp[i] = max_val return dp[L]"},{"question":"from typing import List def count_paths(grid: List[List[int]]) -> int: Determine the total number of distinct paths from the top-left corner to the bottom-right corner, avoiding obstacles. Args: grid: A list of lists where 0 represents an empty space and 1 represents an obstacle. Returns: An integer representing the total number of distinct paths. If there is no valid path, return 0. >>> count_paths([ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> count_paths([ ... [0, 1, 0], ... [1, 0, 0], ... [0, 0, 0] ... ]) 0","solution":"def count_paths(grid): M = len(grid) N = len(grid[0]) if grid[0][0] == 1 or grid[M-1][N-1] == 1: return 0 dp = [[0 for _ in range(N)] for _ in range(M)] dp[0][0] = 1 for i in range(M): for j in range(N): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[M-1][N-1]"},{"question":"def max_simultaneous_participants(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the maximum number of participants running simultaneously at any point during the event. Args: T: int : The number of test cases test_cases: List[Tuple[int, List[int]]] : List of tuples where each tuple contains the number of participants and list of their start and finish times respectively. Returns: List[int] : List containing the maximum number of participants running simultaneously for each test case. >>> max_simultaneous_participants(1, [(3, [1, 4, 2, 5, 3, 6])]) [3] >>> max_simultaneous_participants(1, [(1, [0, 1])]) [1] >>> max_simultaneous_participants(1, [(3, [1, 2, 3, 4, 5, 6])]) [1] >>> max_simultaneous_participants(1, [(3, [1, 4, 2, 5, 3, 6])]) [3] >>> max_simultaneous_participants(2, [(2, [1, 5, 2, 6]), (3, [2, 5, 4, 8, 1, 9])]) [2, 3] >>> max_simultaneous_participants(1, [(2, [0, 1000000000, 1, 999999999])]) [2]","solution":"def max_simultaneous_participants(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] times = test_cases[i][1] events = [] for j in range(0, 2 * N, 2): start_time = times[j] end_time = times[j + 1] events.append((start_time, 'start')) events.append((end_time, 'end')) # Sort events: in case of ties, 'end' should come before 'start' events.sort(key=lambda x: (x[0], x[1] == 'start')) current_running = 0 max_running = 0 for event in events: if event[1] == 'start': current_running += 1 if current_running > max_running: max_running = current_running else: current_running -= 1 results.append(max_running) return results"},{"question":"def count_watering_times(schedule: str) -> int: Returns the number of times Lisa will water her plants in the year 2024 based on the given schedule. The \`schedule\` can be either in the format \\"every n days\\" or \\"x of month\\". >>> count_watering_times(\\"every 1 days\\") 366 >>> count_watering_times(\\"every 3 days\\") 122 >>> count_watering_times(\\"every 10 days\\") 36 >>> count_watering_times(\\"1 of month\\") 12 >>> count_watering_times(\\"15 of month\\") 12","solution":"def count_watering_times(schedule): Returns the number of times Lisa will water her plants in the year 2024 based on the given schedule. The \`schedule\` can be either in the format \\"every n days\\" or \\"x of month\\". if schedule.startswith(\\"every\\"): n = int(schedule.split()[1]) return 366 // n elif schedule.endswith(\\"of month\\"): x = int(schedule.split()[0]) return 12 # Example usage: # print(count_watering_times(\\"every 3 days\\")) # Output: 122 # print(count_watering_times(\\"15 of month\\")) # Output: 12"},{"question":"def is_palindrome(s: str) -> bool: Check if a given string is a palindrome, ignoring spaces, punctuation, and capitalization differences. Parameters: s (str): the string to check Returns: bool: True if the given string is a palindrome, False otherwise pass # Example test cases assert is_palindrome(\\"madam\\") assert is_palindrome(\\"racecar\\") assert is_palindrome(\\"A man a plan a canal Panama\\") assert is_palindrome(\\"No lemon no melon\\")","solution":"def is_palindrome(s): Check if a given string is a palindrome, ignoring spaces, punctuation, and capitalization differences. Parameters: s (str): the string to check Returns: bool: True if the given string is a palindrome, False otherwise # Remove spaces and make lowercase cleaned_s = ''.join(char.lower() for char in s if char.isalnum()) # Check palindrome return cleaned_s == cleaned_s[::-1]"},{"question":"def three_sum(nums): Function to find all unique triplets in the array which give the sum of zero. >>> three_sum([-1, 0, 1, 2, -1, -4]) == [[-1, -1, 2], [-1, 0, 1]] >>> three_sum([1, 2, -2, -1]) == [] >>> three_sum([0, 1, 2]) == [] >>> three_sum([0, -1, 2, -3, 1, -2, 3]) == [[-3, 0, 3], [-3, 1, 2], [-2, -1, 3], [-2, 0, 2], [-1, 0, 1]] >>> three_sum([0, 0, 0, 0]) == [[0, 0, 0]] >>> three_sum([-2, -1, 1, 0, 2]) == [[-2, 0, 2], [-1, 0, 1]]","solution":"def three_sum(nums): Function to find all unique triplets in the array which give the sum of zero. nums.sort() n = len(nums) res = [] for i in range(n): if i > 0 and nums[i] == nums[i-1]: continue l, r = i + 1, n - 1 while l < r: s = nums[i] + nums[l] + nums[r] if s < 0: l += 1 elif s > 0: r -= 1 else: res.append([nums[i], nums[l], nums[r]]) while l < r and nums[l] == nums[l+1]: l += 1 while l < r and nums[r] == nums[r-1]: r -= 1 l += 1 r -= 1 return res"},{"question":"from typing import List, Tuple def maximum_delay_times(T: int, cases: List[Tuple[int, int, List[Tuple[int, int]], int]]) -> List[int]: Determines maximum delay time that a virus takes to reach any computer in the network. Args: T: int : Number of test cases cases : List[Tuple[int, int, List[Tuple[int, int]], int]] : List containing tuples for each test case with: - Number of computers (N) - Number of edges (M) - List of edges (u, v) - Source computer (S) Returns: List[int] : Maximum delay times for each test case. Returns -1 for computers not reached by virus. >>> maximum_delay_times(2, [(5, 5, [(1, 2), (1, 3), (3, 4), (4, 5), (2, 5)], 1), (3, 2, [(1, 2), (2, 3)], 1)]) [3, 2] >>> maximum_delay_times(1, [(4, 3, [(1, 2), (1, 3), (2, 4)], 1)]) [2]","solution":"from collections import defaultdict, deque def maximum_delay_times(T, cases): results = [] for case in cases: N, M, edges, source = case # Create a graph as an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) # Perform BFS to find the longest path in terms of time units visited = {i: -1 for i in range(1, N+1)} queue = deque([(source, 0)]) visited[source] = 0 while queue: node, time = queue.popleft() for neighbor in graph[node]: if visited[neighbor] < time + 1: visited[neighbor] = time + 1 queue.append((neighbor, time + 1)) max_delay = max(visited.values()) results.append(max_delay if max_delay > 0 else -1) return results # Example usage: T = 2 cases = [ (5, 5, [(1, 2), (1, 3), (3, 4), (4, 5), (2, 5)], 1), (3, 2, [(1, 2), (2, 3)], 1) ] print(maximum_delay_times(T, cases)) # Output: [3, 2]"},{"question":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the given string s. >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"abc\\") 3 def process_test_cases(test_cases): Processes multiple test cases and returns a list of results corresponding to each case. >>> process_test_cases([\\"ababa\\", \\"abc\\"]) [5, 3] >>> process_test_cases([\\"aaa\\"]) [3]","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the given string s. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i, len(s)): substring = s[i:j+1] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings) def process_test_cases(test_cases): results = [] for s in test_cases: results.append(count_distinct_palindromic_substrings(s)) return results"},{"question":"def min_operations_to_palindrome(S: str) -> int: Calculate the minimum number of operations to make the string a palindrome. The minimum operations required is simply the count of mismatching pairs (S[i] != S[N-i-1]). >>> min_operations_to_palindrome(\\"ab\\") 1 >>> min_operations_to_palindrome(\\"aab\\") 1 >>> min_operations_to_palindrome(\\"abc\\") 1 >>> min_operations_to_palindrome(\\"racecar\\") 0 >>> min_operations_to_palindrome(\\"abba\\") 0 >>> min_operations_to_palindrome(\\"abca\\") 1 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases and return the results for each test case. >>> process_test_cases(2, [\\"ab\\", \\"aab\\"]) [1, 1] >>> process_test_cases(3, [\\"abc\\", \\"racecar\\", \\"abba\\"]) [1, 0, 0]","solution":"def min_operations_to_palindrome(S): # Function to calculate minimum number of operations to make string palindrome. # The minimum operations required is simply the count of mismatching pairs (S[i] != S[N-i-1]). N = len(S) mismatch_count = 0 for i in range(N // 2): if S[i] != S[N - i - 1]: mismatch_count += 1 return mismatch_count def process_test_cases(T, test_cases): results = [] for i in range(T): S = test_cases[i] results.append(min_operations_to_palindrome(S)) return results # Example usage: # T = 2 # test_cases = [\\"ab\\", \\"aab\\"] # print(process_test_cases(T, test_cases))"},{"question":"from typing import List, Tuple def min_direction_changes(n: int, m: int, k: int, robots: List[Tuple[Tuple[int, int], Tuple[int, int]]], obstacles: List[Tuple[int, int]]) -> List[int]: Calculate the minimum number of direction changes required for each robotic arm to reach its final position without colliding into any obstacles. Args: n : int : number of robotic arms m : int : size of the 2D grid (the grid is M x M) k : int : number of obstacles on the grid robots : List[Tuple[Tuple[int, int], Tuple[int, int]]] : List of robotic arms initial and final positions obstacles : List[Tuple[int, int]] : List of obstacles positions Returns: List[int]: Minimum number of direction changes required for each robotic arm to reach its final position, or -1 if the arm cannot reach its destination. Example: >>> min_direction_changes(2, 5, 1, [((0, 0), (4, 4)), ((1, 1), (3, 3))], [(2, 2)]) [2, 2] >>> min_direction_changes(1, 3, 3, [((0, 0), (2, 2))], [(1, 1), (1, 2), (2, 1)]) [-1]","solution":"from collections import deque def min_direction_changes(n, m, k, robots, obstacles): # Define movement directions, and their perpendicular for direction changes directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Right, Down, Left, Up results = [] obstacle_set = set(obstacles) def in_bounds(x, y): return 0 <= x < m and 0 <= y < m for (start_x, start_y), (end_x, end_y) in robots: if (start_x, start_y) == (end_x, end_y): results.append(0) continue visited = set() queue = deque([(start_x, start_y, -1, 0)]) # x, y, direction, changes while queue: x, y, direction, changes = queue.popleft() for dir_idx, (dx, dy) in enumerate(directions): nx, ny = x + dx, y + dy if not in_bounds(nx, ny) or (nx, ny) in obstacle_set: continue # Calculate the new number of changes new_changes = changes if dir_idx == direction else changes + 1 if (nx, ny) == (end_x, end_y): results.append(new_changes) break state = (nx, ny, dir_idx) if state not in visited: visited.add(state) queue.append((nx, ny, dir_idx, new_changes)) else: continue break else: results.append(-1) return results"},{"question":"def can_partition_boxes(n: int, k: int, weights: List[int]) -> str: Determines if it is possible to partition boxes' weights into k non-increasing subsequences. Args: n : int : the number of boxes k : int : the number of rows weights : List[int] : the weights of the boxes Returns: str : \\"YES\\" if it is possible to partition, otherwise \\"NO\\". Examples: >>> can_partition_boxes(5, 2, [4, 3, 5, 1, 2]) 'YES' >>> can_partition_boxes(3, 4, [6, 3, 8]) 'NO'","solution":"def can_partition_boxes(n, k, weights): Determines if it is possible to partition boxes' weights into k non-increasing subsequences. Args: n : int : the number of boxes k : int : the number of rows weights : List[int] : the weights of the boxes Returns: str : \\"YES\\" if it is possible to partition, otherwise \\"NO\\". if k > n: return \\"NO\\" weights.sort(reverse=True) partitions = [0] * k for weight in weights: partitions[0] += weight partitions.sort() return \\"YES\\" if partitions[0] <= partitions[-1] else \\"NO\\""},{"question":"def longest_path(n: int, m: int, connections: List[Tuple[int, int]]) -> int: Determine the length of the longest simple path in the network starting from node 0. >>> longest_path(5, 5, [(0, 1), (0, 2), (1, 2), (1, 3), (3, 4)]) 4 >>> longest_path(4, 3, [(0, 1), (1, 2), (2, 3)]) 3 >>> longest_path(1, 0, []) 0 >>> longest_path(3, 0, []) 0 >>> longest_path(4, 1, [(0, 1)]) 1 >>> longest_path(6, 6, [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (0, 5)]) 5","solution":"def longest_path(n, m, connections): from collections import defaultdict # Build adjacency list representation of the graph graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) def dfs(node, visited): visited.add(node) max_length = 0 for neighbor in graph[node]: if neighbor not in visited: path_length = 1 + dfs(neighbor, visited) max_length = max(max_length, path_length) visited.remove(node) return max_length # Start DFS from node 0 length = dfs(0, set()) return length"},{"question":"def create_schedule(V: int, R: int, visitors: List[int], rides: List[Tuple[int, List[int]]]) -> List[List[int]]: Create an optimal schedule for visitors to minimize the total waiting time. Args: V : int - number of visitors R : int - number of rides visitors : list of int - waiting times of the visitors rides : list of lists - each sub-list contains the capacity and waiting times of a ride Returns: list of lists - each sub-list contains the scheduled waiting times for the rides >>> create_schedule(5, 3, [4, 3, 1, 2, 5], [[2, 4, 3], [2, 1, 2], [1, 5]]) [[4, 3], [1, 2], [5]] >>> create_schedule(6, 2, [6, 5, 3, 2, 4, 1], [[3, 6, 5, 3], [3, 2, 4, 1]]) [[6, 5, 3], [2, 4, 1]]","solution":"def create_schedule(V, R, visitors, rides): Create an optimal schedule for visitors to minimize the total waiting time. Args: V : int - number of visitors R : int - number of rides visitors : list of int - waiting times of the visitors rides : list of lists - each sub-list contains the capacity and waiting times of a ride Returns: list of lists - each sub-list contains the scheduled waiting times for the rides from collections import defaultdict import itertools # mapping each waiting time to a visitor index visitor_map = defaultdict(list) for idx, time in enumerate(visitors): visitor_map[time].append(idx + 1) # Collecting all waiting times to map back to visitor ids all_rides = [] for ride in rides: capacity = ride[0] times = ride[1:] ride_info = (capacity, times) all_rides.append(ride_info) # Schedule creation schedule = [] used_visitors = set() for ride_info in all_rides: capacity, times = ride_info ride_schedule = [] for time in times: if time in visitor_map and visitor_map[time]: visitor_id = visitor_map[time].pop() if visitor_id not in used_visitors: used_visitors.add(visitor_id) ride_schedule.append(time) if len(ride_schedule) == capacity: break schedule.append(ride_schedule) return schedule"},{"question":"def max_profit(prices): Finds the maximum profit from a single buy-sell transaction. If no profit can be made, returns 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Finds the maximum profit from a single buy-sell transaction. If no profit can be made, returns 0. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: profit = price - min_price if profit > max_profit: max_profit = profit if price < min_price: min_price = price return max_profit"},{"question":"def min_coins(A, S): Given an array A of positive integers representing coin values, determine the minimum number of coins needed to make the value S. If it is not possible to make the value S, return -1. >>> min_coins([1, 2, 5], 11) == 3 >>> min_coins([2], 3) == -1","solution":"def min_coins(A, S): Given an array A of positive integers representing coin values, determine the minimum number of coins needed to make the value S. If it is not possible to make the value S, return -1. # Initialize dp array to hold the minimum number of coins for each amount from 0 to S dp = [float('inf')] * (S + 1) dp[0] = 0 # Iterate over each coin in A for coin in A: for amount in range(coin, S + 1): dp[amount] = min(dp[amount], dp[amount - coin] + 1) # If dp[S] is still inf, it means we can't form the value S with the given coins return dp[S] if dp[S] != float('inf') else -1"},{"question":"def split_array_with_min_diff(arr): Splits the array into two subsets to minimize the absolute difference of their sums. Parameters: arr (List[int]): The list of integers to be split. Returns: int: The minimized absolute difference of sums. List[int]: The elements of the first subset. List[int]: The elements of the second subset. >>> diff, subset1, subset2 = split_array_with_min_diff([1, 6, 11, 5]) >>> diff == 1 True >>> subset1 in ([1, 6, 5], [11]) True >>> subset2 in ([11], [1, 6, 5]) True >>> diff, subset1, subset2 = split_array_with_min_diff([7, 3, 2]) >>> diff == 2 True >>> subset1 in ([7], [3, 2]) True >>> subset2 in ([3, 2], [7]) True","solution":"def split_array_with_min_diff(arr): Splits the array into two subsets to minimize the absolute difference of their sums. total_sum = sum(arr) n = len(arr) target = total_sum // 2 dp = [[False] * (target + 1) for _ in range(n + 1)] dp[0][0] = True for i in range(1, n+1): for j in range(target + 1): dp[i][j] = dp[i-1][j] if j >= arr[i-1]: dp[i][j] = dp[i][j] or dp[i-1][j-arr[i-1]] best = 0 for j in range(target, -1, -1): if dp[n][j]: best = j break subset1 = [] subset2 = arr[:] w = best for i in range(n, 0, -1): if not dp[i-1][w] and (w == 0 or dp[i-1][w-arr[i-1]]): subset1.append(arr[i-1]) subset2.remove(arr[i-1]) w -= arr[i-1] diff = abs((total_sum - best) - best) return diff, subset1, subset2"},{"question":"def max_package_value(n: int, W: int, packages: List[Tuple[int, int]]) -> int: Calculate the maximum possible total value of the packages you can carry without exceeding the weight limit. >>> max_package_value(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90 >>> max_package_value(6, 8, [(2, 20), (3, 50), (5, 30), (6, 60), (1, 70), (4, 10)]) 140 >>> max_package_value(0, 10, []) 0 >>> max_package_value(1, 10, [(5, 100)]) 100 >>> max_package_value(1, 4, [(5, 100)]) 0 >>> max_package_value(5, 10, [(2, 10), (2, 10), (2, 10), (2, 10), (2, 10)]) 50 >>> max_package_value(3, 1000000000, [(100, 100), (200, 300), (300, 500)]) 900","solution":"def max_package_value(n, W, packages): # Sort packages based on value-to-weight ratio in descending order packages.sort(key=lambda x: x[1]/x[0], reverse=True) total_value = 0 total_weight = 0 for weight, value in packages: if total_weight + weight <= W: total_weight += weight total_value += value else: break return total_value # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) W = int(data[1]) packages = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(n)] print(max_package_value(n, W, packages))"},{"question":"def count_unique_paths(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[int]: Calculates the number of unique paths in a grid for each test case, considering obstacles. Parameters: T (int): Number of test cases test_cases (list): List of test cases with grid dimensions and grid values Returns: list: List of unique paths for each test case Examples: >>> T, test_cases = process_input(\\"2n3 3n0 0 0n0 1 0n0 0 0n3 3n0 1 0n0 1 0n0 0 0\\") >>> count_unique_paths(T, test_cases) [2, 1] >>> T, test_cases = process_input(\\"1n3 3n1 0 0n0 1 0n0 0 0\\") >>> count_unique_paths(T, test_cases) [0] pass def process_input(input_data: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[List[int]]]]]: Processes the input data for the unique paths problem. Parameters: input_data (str): Input data as a single string Returns: Tuple: First element is an integer T, the number of test cases. Second element is a list of tuples, where each tuple contains grid dimensions (N, M) and the grid itself as a list of lists. Examples: >>> process_input(\\"2n3 3n0 0 0n0 1 0n0 0 0n3 3n0 1 0n0 1 0n0 0 0\\") (2, [((3, 3), [[0, 0, 0], [0, 1, 0], [0, 0, 0]]), ((3, 3), [[0, 1, 0], [0, 1, 0], [0, 0, 0]])]) >>> process_input(\\"1n3 3n1 0 0n0 1 0n0 0 0\\") (1, [((3, 3), [[1, 0, 0], [0, 1, 0], [0, 0, 0]])]) pass","solution":"def count_unique_paths(T, test_cases): Calculates the number of unique paths in a grid for each test case, considering obstacles. Parameters: T (int): Number of test cases test_cases (list): List of test cases with grid dimensions and grid values Returns: list: List of unique paths for each test case def count_paths(grid, N, M): if grid[0][0] == 1 or grid[N-1][M-1] == 1: return 0 dp = [[0] * M for _ in range(N)] dp[0][0] = 1 for i in range(N): for j in range(M): if grid[i][j] == 0: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[N-1][M-1] results = [] for i in range(T): N, M = test_cases[i][0] grid = test_cases[i][1] results.append(count_paths(grid, N, M)) return results # Example input processing function, not required for solution itself def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] idx = 1 for _ in range(T): N, M = map(int, lines[idx].split()) grid = [list(map(int, lines[idx + 1 + i].split())) for i in range(N)] test_cases.append(((N, M), grid)) idx += (N + 1) return T, test_cases"},{"question":"def compress_string(s: str) -> str: Compresses the string by replacing consecutive repeated characters with the character followed by the number of its occurrences. If the compressed string is not shorter than the original string, returns the original string. >>> compress_string(\\"aabcccccaaa\\") 'a2b1c5a3' >>> compress_string(\\"abc\\") 'abc'","solution":"def compress_string(s): Compresses the string by replacing consecutive repeated characters with the character followed by the number of its occurrences. If the compressed string is not shorter than the original string, returns the original string. if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def minSteps(matrix): Returns the minimum number of steps to reach the bottom-right corner of the matrix, or -1 if it is impossible. >>> matrix = [ ... [1, 0, 0], ... [1, 1, 0], ... [0, 1, 1] ... ] >>> minSteps(matrix) 4 >>> matrix = [ ... [1, 0], ... [0, 1] ... ] >>> minSteps(matrix) -1 >>> matrix = [ ... [1, 1, 1] ... ] >>> minSteps(matrix) 2 >>> matrix = [ ... [1], ... [1], ... [1] ... ] >>> minSteps(matrix) 2 >>> matrix = [ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 1] ... ] >>> minSteps(matrix) -1 >>> matrix = [ ... [0, 1], ... [1, 1] ... ] >>> minSteps(matrix) -1 >>> matrix = [ ... [1, 1], ... [1, 0] ... ] >>> minSteps(matrix) -1 >>> matrix = [ ... [1, 1, 0, 1], ... [1, 0, 1, 0], ... [1, 1, 1, 0], ... [0, 0, 1, 1] ... ] >>> minSteps(matrix) 6 >>> matrix = [[1] * 500 for _ in range(500)] >>> minSteps(matrix) 998","solution":"from collections import deque def minSteps(matrix): Returns the minimum number of steps to reach the bottom-right corner of the matrix, or -1 if it is impossible. if not matrix or matrix[0][0] == 0 or matrix[-1][-1] == 0: return -1 n = len(matrix) m = len(matrix[0]) directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0, 0)]) visited = set((0, 0)) while queue: x, y, steps = queue.popleft() if x == n - 1 and y == m - 1: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and matrix[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def min_path_sum(grid): Returns the minimum path sum from the top-left to the bottom-right corner of a grid. >>> min_path_sum([[1, 3], [1, 5]]) 7 >>> min_path_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 pass def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list of minimum path sums. >>> process_test_cases(2, [(2, [[1, 3], [1, 5]]), (3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]])]) [7, 21] >>> process_test_cases(1, [(1, [[5]])]) [5] pass","solution":"def min_path_sum(grid): Returns the minimum path sum from the top-left to the bottom-right corner of a grid. n = len(grid) dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j - 1] + grid[0][j] for i in range(1, n): for j in range(1, n): dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]) return dp[-1][-1] def process_test_cases(t, test_cases): Processes multiple test cases and returns the results as a list of minimum path sums. results = [] for i in range(t): n, grid = test_cases[i] results.append(min_path_sum(grid)) return results"},{"question":"MOD = 10**9 + 7 def steps_to_climb(n): Returns the number of distinct ways to climb n steps using 1 or 2 steps at a time. if n == 0: return 1 if n == 1: return 1 first, second = 1, 1 for _ in range(2, n + 1): result = (first + second) % MOD first, second = second, result return result def solve(test_cases): Given a list of integers representing the number of steps, return a list of integers where each integer is the number of distinct ways to climb to the top modulo 10^9+7. >>> solve([2, 3, 4]) [2, 3, 5] >>> solve([0, 1, 10]) [1, 1, 89] >>> solve([5, 6, 7]) [8, 13, 21] results = [] for n in test_cases: results.append(steps_to_climb(n)) return results","solution":"MOD = 10**9 + 7 def steps_to_climb(n): Returns the number of distinct ways to climb n steps using 1 or 2 steps at a time. if n == 0: return 1 if n == 1: return 1 first, second = 1, 1 for _ in range(2, n + 1): result = (first + second) % MOD first, second = second, result return result def solve(test_cases): results = [] for n in test_cases: results.append(steps_to_climb(n)) return results"},{"question":"def is_valid_parentheses(s: str) -> str: Checks if the given string of parentheses is valid. A string is considered valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. Args: s (str): the input string containing only parentheses () and {} Returns: str: \\"YES\\" if the string is valid, otherwise \\"NO\\" >>> is_valid_parentheses(\\"(){}{}\\") 'YES' >>> is_valid_parentheses(\\"({)}{}\\") 'NO'","solution":"def is_valid_parentheses(s: str) -> str: Checks if the given string of parentheses is valid. Args: s (str): the input string containing only parentheses () and {} Returns: str: \\"YES\\" if the string is valid, otherwise \\"NO\\" stack = [] matching_parentheses = {')': '(', '}': '{'} for char in s: if char in matching_parentheses.values(): stack.append(char) elif char in matching_parentheses.keys(): if stack == [] or matching_parentheses[char] != stack.pop(): return \\"NO\\" else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\""},{"question":"def longest_consecutive_irrigation(grid): Find the longest consecutive segment of '1's in any straight line (horizontally, vertically, or diagonally) in a given grid representing irrigation status. >>> longest_consecutive_irrigation([ ... \\"10101\\", ... \\"11111\\", ... \\"01110\\", ... \\"11111\\", ... \\"10001\\" ... ]) 5 >>> longest_consecutive_irrigation([ ... \\"001\\", ... \\"010\\", ... \\"100\\" ... ]) 1 >>> longest_consecutive_irrigation([ ... \\"11111\\", ... \\"10001\\", ... \\"10111\\", ... \\"11111\\" ... ]) 5 import pytest def test_sample_input_1(): grid = [ \\"10101\\", \\"11111\\", \\"01110\\", \\"11111\\", \\"10001\\" ] assert longest_consecutive_irrigation(grid) == 5 def test_sample_input_2(): grid = [ \\"001\\", \\"010\\", \\"100\\" ] assert longest_consecutive_irrigation(grid) == 1 def test_sample_input_3(): grid = [ \\"11111\\", \\"10001\\", \\"10111\\", \\"11111\\" ] assert longest_consecutive_irrigation(grid) == 5 def test_maximum_value_at_borders(): grid = [ \\"1111\\", \\"1111\\", \\"1111\\" ] assert longest_consecutive_irrigation(grid) == 4 def test_all_zeros(): grid = [ \\"000\\", \\"000\\", \\"000\\" ] assert longest_consecutive_irrigation(grid) == 0 def test_single_cell_1(): grid = [ \\"1\\" ] assert longest_consecutive_irrigation(grid) == 1 def test_single_cell_0(): grid = [ \\"0\\" ] assert longest_consecutive_irrigation(grid) == 0","solution":"def longest_consecutive_irrigation(grid): n = len(grid) m = len(grid[0]) def count_max_consecutive_ones(arr): max_count = 0 count = 0 for val in arr: if val == '1': count += 1 max_count = max(max_count, count) else: count = 0 return max_count max_length = 0 # Check rows for row in grid: max_length = max(max_length, count_max_consecutive_ones(row)) # Check columns for col in range(m): column_vals = [grid[row][col] for row in range(n)] max_length = max(max_length, count_max_consecutive_ones(column_vals)) # Check diagonals for d in range(-(n-1), m): diag1 = [grid[i][i-d] for i in range(max(0, d), min(n, m+d))] diag2 = [grid[i][d+i] for i in range(max(0, -d), min(n, m-d))] max_length = max(max_length, count_max_consecutive_ones(diag1)) max_length = max(max_length, count_max_consecutive_ones(diag2)) return max_length"},{"question":"def generate_parentheses(n: int) -> List[str]: Generates all combinations of \`n\` pairs of valid parentheses. Args: n (int): The number of pairs of parentheses. Returns: List[str]: A list of strings, each representing a valid combination of parentheses. Examples: >>> generate_parentheses(1) [\\"()\\"] >>> generate_parentheses(2) [\\"(())\\", \\"()()\\"] >>> generate_parentheses(3) [\\"((()))\\", \\"(()())\\", \\"(())()\\", \\"()(())\\", \\"()()()\\"] >>> generate_parentheses(4) [\\"(((())))\\", \\"((()()))\\", \\"((())())\\", \\"((()))()\\", \\"(()(()))\\", \\"(()()())\\", \\"(()())()\\", \\"(())(())\\", \\"(())()()\\", \\"()((()))\\", \\"()(()())\\", \\"()(())()\\", \\"()()(())\\", \\"()()()()\\"]","solution":"def generate_parentheses(n): Generates all combinations of \`n\` pairs of valid parentheses. Args: n (int): The number of pairs of parentheses. Returns: List[str]: A list of strings, each representing a valid combination of parentheses. result = [] def backtrack(s='', left=0, right=0): if len(s) == 2 * n: result.append(s) return if left < n: backtrack(s + '(', left + 1, right) if right < left: backtrack(s + ')', left, right + 1) backtrack() return result"},{"question":"def isHarshad(number: int) -> bool: Check whether the provided number is a Harshad number. A Harshad number (or Niven number) is an integer that is divisible by the sum of its digits. >>> isHarshad(18) True >>> isHarshad(25) False >>> isHarshad(0) False >>> all(isHarshad(i) for i in range(1, 10)) True >>> isHarshad(21) True >>> isHarshad(30) True >>> isHarshad(12) True >>> isHarshad(10) True >>> isHarshad(11) False >>> isHarshad(100) True >>> isHarshad(101) False","solution":"def isHarshad(number: int) -> bool: Returns True if the provided number is a Harshad number, otherwise False. A Harshad number (or Niven number) is an integer that is divisible by the sum of its digits. if number == 0: return False sum_of_digits = sum(int(digit) for digit in str(number)) return number % sum_of_digits == 0"},{"question":"def minOperations(N: int, arr: List[int]) -> int: Determine the minimum number of operations required to make all elements of the array equal. >>> minOperations(3, [4, 4, 6]) 1 >>> minOperations(4, [1, 5, 7, 7]) 2 >>> minOperations(5, [3, 3, 3, 3, 3]) 0 >>> minOperations(4, [1, 2, 3, 4]) 3 >>> minOperations(6, [10, 20, 20, 10, 10, 10]) 2 >>> minOperations(1, [100]) 0 >>> minOperations(2, [10, 20]) 1","solution":"def minOperations(N, arr): # Find the most common element in the array from collections import Counter count = Counter(arr) # The most frequent element most_frequent = max(count.values()) # The minimum number of operations needed to make all elements equal # is the total number of elements minus the most frequent element occurrences. return N - most_frequent"},{"question":"def rotateLeft(lst, positions): Rotates the elements of the list to the left by the specified number of positions. If the number of positions is greater than the length of the list, the rotations wrap around. Parameters: lst (list): The list to be rotated. positions (int): The number of positions to rotate the list. Returns: list: The rotated list. Examples: >>> rotateLeft([1, 2, 3, 4, 5], 2) [3, 4, 5, 1, 2] >>> rotateLeft([1, 2, 3, 4, 5], 7) [3, 4, 5, 1, 2] >>> rotateLeft([1, 2, 3, 4, 5], 0) [1, 2, 3, 4, 5] >>> rotateLeft([1, 2, 3, 4, 5], 5) [1, 2, 3, 4, 5] >>> rotateLeft([], 3) [] >>> rotateLeft([1], 3) [1]","solution":"def rotateLeft(lst, positions): Rotates the elements of the list to the left by the specified number of positions. If the number of positions is greater than the length of the list, the rotations wrap around. Parameters: lst (list): The list to be rotated. positions (int): The number of positions to rotate the list. Returns: list: The rotated list. if not lst: return [] positions = positions % len(lst) return lst[positions:] + lst[:positions]"},{"question":"def is_triangular_number(k: int) -> int: Determine if k is a triangular number. Given a positive integer k, determine if k is a triangular number. If it is, return the value of n such that the n-th triangular number is equal to k. If k is not a triangular number, return -1. Args: k (int): The number to check. Returns: int: The position n if k is a triangular number, otherwise -1. Examples: >>> is_triangular_number(10) 4 >>> is_triangular_number(7) -1 >>> is_triangular_number(15) 5","solution":"import math def is_triangular_number(k): Determines if k is a triangular number. If it is, returns the value of n such that the n-th triangular number is k. Otherwise, returns -1. # The n-th triangular number is given by T_n = n * (n + 1) / 2 # Thus, we need to solve the quadratic equation: n^2 + n - 2k = 0 # Coefficients of the quadratic equation a = 1 b = 1 c = -2 * k # Calculate the discriminant discriminant = b**2 - 4*a*c if discriminant < 0: return -1 # No real roots, so k is not a triangular number # Calculate possible values of n using the quadratic formula n1 = (-b + math.sqrt(discriminant)) / (2*a) n2 = (-b - math.sqrt(discriminant)) / (2*a) # We need positive integer solutions if n1 > 0 and n1.is_integer(): return int(n1) if n2 > 0 and n2.is_integer(): return int(n2) return -1"},{"question":"def min_operations_for_binary_strings(T, cases): Determine the minimum number of operations required to make binary string A equal to binary string B. The allowed operations are flipping a single bit or swapping any two bits in A. Args: T (int): the number of test cases. cases (List[Tuple[str, str]]): a list of tuples where each tuple contains two binary strings A and B of equal length. Returns: List[int]: a list of integers where each integer is the minimum number of operations required for each test case. >>> min_operations_for_binary_strings(2, [(\\"1100\\", \\"1001\\"), (\\"101\\", \\"111\\")]) [1, 1] >>> min_operations_for_binary_strings(1, [(\\"0000\\", \\"1111\\")]) [4] >>> min_operations_for_binary_strings(1, [(\\"0101\\", \\"1010\\")]) [2] >>> min_operations_for_binary_strings(1, [(\\"110010\\", \\"101011\\")]) [2] >>> min_operations_for_binary_strings(1, [(\\"1100\\", \\"1100\\")]) [0] >>> min_operations_for_binary_strings(1, [(\\"1\\", \\"0\\")]) [1] >>> min_operations_for_binary_strings(1, [(\\"10\\", \\"01\\")]) [1]","solution":"def min_operations_for_binary_strings(T, cases): results = [] for A, B in cases: # Calculate the number of 1s and 0s that need to be swapped or flipped diff_zero_to_one = diff_one_to_zero = swaps_needed = 0 for a_bit, b_bit in zip(A, B): if a_bit != b_bit: if a_bit == '0': diff_zero_to_one += 1 else: diff_one_to_zero += 1 swaps_needed = min(diff_zero_to_one, diff_one_to_zero) flips_needed = abs(diff_zero_to_one - diff_one_to_zero) min_operations = swaps_needed + flips_needed results.append(min_operations) return results"},{"question":"def minimum_drones(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of drones required for a given grid. >>> minimum_drones(1, [(3, 3)]) == [3] >>> minimum_drones(1, [(5, 4)]) == [5] >>> minimum_drones(2, [(3, 3), (5, 4)]) == [3, 5] >>> minimum_drones(3, [(1, 1), (2000, 1), (1, 2000)]) == [1, 2000, 2000] >>> minimum_drones(1, [(2000, 2000)]) == [2000] >>> minimum_drones(1, [(2, 3)]) == [3] >>> minimum_drones(3, [(5, 10), (10, 5), (7, 7)]) == [10, 10, 7]","solution":"def minimum_drones(T, test_cases): results = [] for i in range(T): N, M = test_cases[i] results.append(max(N, M)) return results # Example Usage: # T = 2 # test_cases = [(3, 3), (5, 4)] # print(minimum_drones(T, test_cases)) # Output: [3, 4]"},{"question":"def rotate(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> matrix = [ ... [1, 2], ... [3, 4], ... ] >>> rotate(matrix) >>> matrix [[3, 1], [4, 2]]","solution":"def rotate(matrix): Rotates the given NxN matrix by 90 degrees clockwise in place. n = len(matrix) # Transpose the matrix (swap rows and columns) for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row to get the 90 degrees rotated matrix for i in range(n): matrix[i].reverse()"},{"question":"def checkProduct(arr, target): Given an array of integers and a target number, return if there exists two distinct indices i and j such that the product of elements at those indices equals the target number. >>> checkProduct([2, 4, 3, 6], 12) True >>> checkProduct([1, 2, 3, 9], 8) False >>> checkProduct([0, 0, 0], 0) True","solution":"def checkProduct(arr, target): Given an array of integers and a target number, return if there exists two distinct indices i and j such that the product of elements at those indices equals the target number. n = len(arr) for i in range(n): for j in range(i+1, n): if arr[i] * arr[j] == target: return True return False"},{"question":"def two_sum(lst, target): Write a function that takes a list of integers and a target integer. The function should return a tuple of two integers from the list that sum up to the target integer. If no such integers exist in the list, return an empty tuple. The integers in the list are guaranteed to be unique and the list will have at least two elements. >>> two_sum([10, 15, 3, 7], 17) (10, 7) >>> two_sum([1, 2, 3, 4], 8) () def test_two_sum_found(): lst = [10, 15, 3, 7] target = 17 assert two_sum(lst, target) == (10, 7) or two_sum(lst, target) == (7, 10) def test_two_sum_not_found(): lst = [1, 2, 3, 4] target = 8 assert two_sum(lst, target) == tuple() def test_two_sum_single_pair(): lst = [3, 4] target = 7 assert two_sum(lst, target) == (3, 4) or two_sum(lst, target) == (4, 3) def test_two_sum_zero_target(): lst = [-3, 3] target = 0 assert two_sum(lst, target) == (-3, 3) or two_sum(lst, target) == (3, -3) def test_two_sum_no_pair(): lst = [5, 1] target = 11 assert two_sum(lst, target) == tuple()","solution":"def two_sum(lst, target): Returns a tuple of two integers from the list that sum up to the target integer. If no such integers exist in the list, returns an empty tuple. seen = {} for num in lst: complement = target - num if complement in seen: return (complement, num) seen[num] = True return tuple()"},{"question":"def transform_string(s: str) -> str: Transforms the string such that each character is replaced by the letter immediately following it in the English alphabet. Wraps around from 'z' to 'a' and 'Z' to 'A'. :param s: Input string with lowercase and uppercase letters :return: Transformed string >>> transform_string(\\"abc\\") == \\"bcd\\" >>> transform_string(\\"z\\") == \\"a\\" >>> transform_string(\\"XYZ\\") == \\"YZA\\" >>> transform_string(\\"Z\\") == \\"A\\" >>> transform_string(\\"abcXYZ\\") == \\"bcdYZA\\" >>> transform_string(\\"aBcZy\\") == \\"bCdAz\\" >>> transform_string(\\"a\\") == \\"b\\" >>> transform_string(\\"Z\\") == \\"A\\" >>> transform_string(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"bcdefghijklmnopqrstuvwxyza\\" >>> transform_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") == \\"BCDEFGHIJKLMNOPQRSTUVWXYZA\\" >>> transform_string(\\"\\") == \\"\\"","solution":"def transform_string(s): Transforms the string such that each character is replaced by the letter immediately following it in the English alphabet. Wraps around from 'z' to 'a' and 'Z' to 'A'. :param s: Input string with lowercase and uppercase letters :return: Transformed string result = [] for char in s: if char.islower(): if char == 'z': result.append('a') else: result.append(chr(ord(char) + 1)) elif char.isupper(): if char == 'Z': result.append('A') else: result.append(chr(ord(char) + 1)) return ''.join(result)"},{"question":"def is_message_secure(message: str) -> bool: Checks if a message is secure based on ByteSpace's rules: - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character (!@#%^&*()-+) Args: message (str): The message to be checked. Returns: bool: True if the message is secure, False otherwise. Examples: >>> is_message_secure(\\"aA1!\\") True >>> is_message_secure(\\"SecureMessage\\") False","solution":"def is_message_secure(message: str) -> bool: Checks if a message is secure based on ByteSpace's rules: - Contains at least one uppercase letter - Contains at least one lowercase letter - Contains at least one digit - Contains at least one special character (!@#%^&*()-+) Args: message (str): The message to be checked. Returns: bool: True if the message is secure, False otherwise. has_upper = any(char.isupper() for char in message) has_lower = any(char.islower() for char in message) has_digit = any(char.isdigit() for char in message) has_special = any(char in \\"!@#%^&*()-+\\" for char in message) return has_upper and has_lower and has_digit and has_special"},{"question":"def apple_display_pattern(N: int) -> List[str]: Generate the apple display pattern for a given number. >>> apple_display_pattern(1) [\\"A\\"] >>> apple_display_pattern(2) [\\"A\\", \\"BB\\"] >>> apple_display_pattern(3) [\\"A\\", \\"BB\\", \\"CCC\\"] >>> apple_display_pattern(5) [\\"A\\", \\"BB\\", \\"CCC\\", \\"DDDD\\", \\"EEEEE\\"] pass def generate_patterns_for_test_cases(test_cases: List[int]) -> List[List[str]]: Generate the apple display patterns for multiple test cases. >>> generate_patterns_for_test_cases([3, 5]) [[\\"A\\", \\"BB\\", \\"CCC\\"], [\\"A\\", \\"BB\\", \\"CCC\\", \\"DDDD\\", \\"EEEEE\\"]] >>> generate_patterns_for_test_cases([1, 2]) [[\\"A\\"], [\\"A\\", \\"BB\\"]] pass","solution":"def apple_display_pattern(N): pattern = [] for i in range(1, N + 1): pattern.append(chr(64 + i) * i) return pattern def generate_patterns_for_test_cases(test_cases): results = [] for N in test_cases: results.append(apple_display_pattern(N)) return results"},{"question":"def magical_forest(n, m, operations): In a magical forest, there are n trees lined up in a straight row from west to east, each having a unique magical power. Perform a set of operations to manage the trees' powers: 1. Increase the power of a tree at a specific position by a certain value. 2. Determine the power of a tree at a specific position. Args: n: int - number of trees m: int - number of operations operations: List[List[int]] - list of operations Returns: List[int] - results of type 2 operations Example: >>> magical_forest(8, 5, [ [1, 3, 10], [2, 3], [1, 3, -5], [2, 3], [1, 6, 20], ]) [10, 5] >>> magical_forest(1, 2, [ [1, 1, 10], [2, 1] ]) [10]","solution":"def magical_forest(n, m, operations): # Initialize tree powers with 0 tree_powers = [0] * n results = [] for operation in operations: o_type = operation[0] if o_type == 1: pi, vi = operation[1] - 1, operation[2] # convert to 0-based index tree_powers[pi] += vi elif o_type == 2: pi = operation[1] - 1 # convert to 0-based index results.append(tree_powers[pi]) return results"},{"question":"def bubble_sort(nums): Sorts a list of distinct integers in non-decreasing order using Bubble Sort. Args: nums (List[int]): The list of distinct integers to be sorted. Example: >>> nums = [64, 34, 25, 12, 22] >>> bubble_sort(nums) >>> nums [12, 22, 25, 34, 64] pass def is_sorted(nums): Verifies if a list of integers is sorted in non-decreasing order. Args: nums (List[int]): The list of integers to be verified. Returns: bool: True if the list is sorted in non-decreasing order, False otherwise. Example: >>> is_sorted([1, 2, 3, 4, 5]) True >>> is_sorted([1, 3, 2, 4, 5]) False pass def sort_and_verify(n, nums): Sorts the list of integers and verifies the sorting process. Args: n (int): The number of integers in the list. nums (List[int]): The list of integers to be sorted. Returns: Tuple[List[int], str]: A tuple containing the sorted list and a verification string. Example: >>> sort_and_verify(5, [64, 34, 25, 12, 22]) ([12, 22, 25, 34, 64], 'Sorted correctly') pass","solution":"def bubble_sort(nums): n = len(nums) for i in range(n): for j in range(0, n-i-1): if nums[j] > nums[j+1]: nums[j], nums[j+1] = nums[j+1], nums[j] def is_sorted(nums): return all(nums[i] <= nums[i+1] for i in range(len(nums)-1)) def sort_and_verify(n, nums): bubble_sort(nums) sorted_correctly = \\"Sorted correctly\\" if is_sorted(nums) else \\"Sorting error\\" return nums, sorted_correctly # Example usage: n = 5 nums = [64, 34, 25, 12, 22] sorted_nums, verification = sort_and_verify(n, nums) print(\\" \\".join(map(str, sorted_nums))) print(verification)"},{"question":"from typing import List, Tuple def derangements(N: int) -> int: Calculate the number of derangements (permutations where no element appears in its original position) for a given N. # Write your code here def gift_exchange_ways(test_cases: List[Tuple[int, List[str]]]) -> List[int]: Determine the number of valid ways to assign the gift exchange such that no employee gives a gift to themselves and no two employees give gifts to each other. >>> gift_exchange_ways([(3, [\\"alice\\", \\"bob\\", \\"charlie\\"])]) == [2] >>> gift_exchange_ways([(4, [\\"anna\\", \\"brian\\", \\"charlotte\\", \\"david\\"])]) == [9] # Write your code here def test_derangements(): # Testing known derangement values assert derangements(0) == 1 assert derangements(1) == 0 assert derangements(2) == 1 assert derangements(3) == 2 assert derangements(4) == 9 assert derangements(5) == 44 def test_gift_exchange_ways(): assert gift_exchange_ways([(3, [\\"alice\\", \\"bob\\", \\"charlie\\"])]) == [2] assert gift_exchange_ways([(4, [\\"anna\\", \\"brian\\", \\"charlotte\\", \\"david\\"])]) == [9] assert gift_exchange_ways([(2, [\\"john\\", \\"jane\\"])]) == [1] assert gift_exchange_ways([(1, [\\"single\\"])]) == [0] assert gift_exchange_ways([(5, [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"])]) == [44]","solution":"from math import factorial def derangements(N): Calculate the number of derangements (permutations where no element appears in its original position) for a given N using a direct calculation formula. if N == 0: return 1 if N == 1: return 0 der = [0] * (N + 1) der[0] = 1 der[1] = 0 for i in range(2, N + 1): der[i] = (i - 1) * (der[i - 1] + der[i - 2]) return der[N] def gift_exchange_ways(test_cases): results = [] for N, employees in test_cases: results.append(derangements(N)) return results"},{"question":"from typing import List def findOrder(numProjects: int, dependencies: List[List[int]]) -> List[int]: Find the order in which you should complete the projects in order to satisfy the given dependencies. Args: numProjects: an integer representing the total number of projects. dependencies: a list of pairs representing the dependencies between projects [a, b] meaning project a must be completed before project b. Returns: An array of integers representing the order in which you must complete the projects. Examples: >>> findOrder(4, [[1,0],[2,0],[3,1],[3,2]]) [0, 1, 2, 3] >>> findOrder(2, [[1,0]]) [0, 1]","solution":"from collections import deque, defaultdict def findOrder(numProjects, dependencies): Finds the order in which to complete the projects based on the given dependencies. # Create an adjacency list to represent the graph adj_list = defaultdict(list) in_degree = [0] * numProjects # Populate the adjacency list and in-degree array for a, b in dependencies: adj_list[b].append(a) in_degree[a] += 1 # Queue for the projects that have no dependencies (in-degree 0) queue = deque([i for i in range(numProjects) if in_degree[i] == 0]) order = [] while queue: project = queue.popleft() order.append(project) # Decrease in-degree by 1 for all its neighbors for neighbor in adj_list[project]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) # If all projects are in the order list, return the order if len(order) == numProjects: return order else: # If there are projects left that couldn't be ordered, return an empty list return []"},{"question":"def count_unique_rotations(n: int, a: List[int]) -> int: Returns the number of unique rotated versions of the array a of length n. >>> count_unique_rotations(4, [1, 2, 3, 4]) 4 >>> count_unique_rotations(3, [1, 1, 1]) 1 >>> count_unique_rotations(1, [1]) 1 >>> count_unique_rotations(2, [2, 2]) 1 >>> count_unique_rotations(2, [1, 2]) 2 >>> count_unique_rotations(5, [1, 2, 3, 2, 1]) 5 >>> count_unique_rotations(4, [2, 3, 2, 3]) 2","solution":"def count_unique_rotations(n, a): Returns the number of unique rotated versions of the array a of length n. unique_rotations = set() # We concatenate the array to itself to easily generate all rotations for i in range(n): rotation = tuple(a[i:] + a[:i]) unique_rotations.add(rotation) return len(unique_rotations)"},{"question":"from typing import List, Union def second_highest_score(n: int, scores: List[int]) -> Union[int, str]: Returns the second highest distinct score in the list of scores or \\"No second highest score\\" if there is no second highest score. >>> second_highest_score(5, [2, 4, 6, 6, 3]) 4 >>> second_highest_score(4, [7, 7, 7, 7]) \\"No second highest score\\" >>> second_highest_score(4, [4, 4, 3, 3]) 3 >>> second_highest_score(3, [1000000000, 999999999, 1000000000]) 999999999 >>> second_highest_score(6, [1, 2, 3, 4, 5, 6]) 5 >>> second_highest_score(6, [1, 2, 2, 2, 3, 3]) 2","solution":"def second_highest_score(n, scores): Returns the second highest distinct score in the list of scores or \\"No second highest score\\" if there is no second highest score. distinct_scores = set(scores) if len(distinct_scores) < 2: return \\"No second highest score\\" sorted_scores = sorted(distinct_scores, reverse=True) return sorted_scores[1] # Example usage: n = 5 scores = [2, 4, 6, 6, 3] print(second_highest_score(n, scores)) # Output: 4"},{"question":"import heapq def min_cost_to_combine_segments(test_cases): Determines the minimum total cost required to combine all segments into one for each test case. The cost of combining two segments of lengths \`a\` and \`b\` is \`a + b\`. >>> min_cost_to_combine_segments([[1, 2, 3, 4]]) [19] >>> min_cost_to_combine_segments([[2, 2, 3]]) [11] def process_input(input_data): Processes the input data of multiple test cases and returns a list of test cases and the number of test cases. >>> process_input(\\"1n4n1 2 3 4\\") ([[1, 2, 3, 4]], 1) >>> process_input(\\"2n4n1 2 3 4n3n2 2 3\\") ([[1, 2, 3, 4], [2, 2, 3]], 2) from solution import min_cost_to_combine_segments, process_input def test_min_cost_to_combine_segments_single_case(): input_data = \\"1n4n1 2 3 4\\" test_cases, T = process_input(input_data) assert min_cost_to_combine_segments(test_cases) == [19] def test_min_cost_to_combine_segments_multiple_cases(): input_data = \\"2n4n1 2 3 4n3n2 2 3\\" test_cases, T = process_input(input_data) assert min_cost_to_combine_segments(test_cases) == [19, 11] def test_min_cost_to_combine_segments_case_with_equal_lengths(): input_data = \\"1n3n1 1 1\\" test_cases, T = process_input(input_data) assert min_cost_to_combine_segments(test_cases) == [5] def test_min_cost_to_combine_segments_long_input(): input_data = \\"1n5n1 2 3 4 5\\" test_cases, T = process_input(input_data) assert min_cost_to_combine_segments(test_cases) == [33]","solution":"import heapq def min_cost_to_combine_segments(test_cases): results = [] for segments in test_cases: heapq.heapify(segments) total_cost = 0 while len(segments) > 1: first = heapq.heappop(segments) second = heapq.heappop(segments) cost = first + second total_cost += cost heapq.heappush(segments, cost) results.append(total_cost) return results def process_input(input_data): lines = input_data.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): n = int(lines[index]) segments = list(map(int, lines[index + 1].split())) test_cases.append(segments) index += 2 return test_cases, T"},{"question":"def max_necklace_value(n: int, k: int, gem_values: List[int]) -> int: Determines the maximum possible value of a necklace with exactly k gems. Parameters: n (int): Number of different types of gems. k (int): Desired length of the necklace. gem_values (list of int): List of gem values. Returns: int: The maximum possible value of the necklace. >>> max_necklace_value(5, 3, [7, 2, 4, 5, 1]) 16 >>> max_necklace_value(1, 1, [10]) 10 >>> max_necklace_value(4, 4, [3, 6, 2, 8]) 19 >>> max_necklace_value(6, 3, [9, 8, 7, 6, 5, 4]) 24 >>> max_necklace_value(6, 3, [1, 2, 3, 4, 5, 6]) 15 >>> max_necklace_value(100000, 3, list(range(1, 100001))) 299997","solution":"def max_necklace_value(n, k, gem_values): Determines the maximum possible value of a necklace with exactly k gems. Parameters: n (int): Number of different types of gems. k (int): Desired length of the necklace. gem_values (list of int): List of gem values. Returns: int: The maximum possible value of the necklace. # Sort the gem values in descending order sorted_gem_values = sorted(gem_values, reverse=True) # Take the top k values max_value = sum(sorted_gem_values[:k]) return max_value"},{"question":"def check_straight_line(candles): Returns 'Yes' if the candles are in a straight line, otherwise returns 'No'. >>> check_straight_line([(0, 0), (1, 1), (2, 2)]) 'Yes' >>> check_straight_line([(1, 1), (2, 2), (3, 5)]) 'No' >>> check_straight_line([(2, 3), (4, 6), (6, 9)]) 'Yes' >>> check_straight_line([(0, 0), (1, 2), (2, 3)]) 'No' pass def process_input(data): Processes the input string and returns a list of results based on the check_straight_line function. >>> process_input([ \\"3\\", \\"0 0\\", \\"1 1\\", \\"2 2\\", \\"4\\", \\"1 2\\", \\"2 4\\", \\"3 6\\", \\"4 8\\", \\"3\\", \\"1 1\\", \\"2 2\\", \\"3 5\\", \\"0\\", ]) ['Yes', 'Yes', 'No'] pass","solution":"def check_straight_line(candles): Returns 'Yes' if the candles are in a straight line, otherwise returns 'No'. def are_points_collinear(x1, y1, x2, y2, x3, y3): return (y3 - y2) * (x2 - x1) == (y2 - y1) * (x3 - x2) x1, y1 = candles[0] x2, y2 = candles[1] for x3, y3 in candles[2:]: if not are_points_collinear(x1, y1, x2, y2, x3, y3): return \\"No\\" return \\"Yes\\" def process_input(data): Processes the input string and returns a list of results based on the check_straight_line function. results = [] i = 0 while i < len(data): n = int(data[i]) if n == 0: break candles = [] for j in range(1, n + 1): xi, yi = map(int, data[i + j].split()) candles.append((xi, yi)) results.append(check_straight_line(candles)) i += n + 1 return results"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deleteNode(root: TreeNode, key: int) -> TreeNode: Given a binary search tree root and an integer key, delete the node with the given key and return the new root. Example 1: >>> root = [5, 3, 6, 2, 4, None, 7] >>> key = 3 >>> new_root = deleteNode(build_tree(root), key) >>> inorderTraversal(new_root) [2, 4, 5, 6, 7] Example 2: >>> root = [5, 3, 6, 2, 4, None, 7] >>> key = 0 >>> new_root = deleteNode(build_tree(root), key) >>> inorderTraversal(new_root) [2, 3, 4, 5, 6, 7] Example 3: >>> root = [] >>> key = 0 >>> new_root = deleteNode(build_tree(root), key) >>> new_root is None True Args: root (TreeNode): The root node of the binary search tree. key (int): The value of the node to delete. Returns: TreeNode: The root node of the new binary search tree. pass def build_tree(values): if not values: return None nodes = [TreeNode(val) if val is not None else None for val in values] kids = nodes[::-1] root = kids.pop() for node in nodes: if node: if kids: node.left = kids.pop() if kids: node.right = kids.pop() return root def inorderTraversal(root): res = [] if root: res = inorderTraversal(root.left) res.append(root.val) res = res + inorderTraversal(root.right) return res","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deleteNode(root, key): if not root: return None if key < root.val: root.left = deleteNode(root.left, key) elif key > root.val: root.right = deleteNode(root.right, key) else: if not root.left: return root.right elif not root.right: return root.left minNode = findMin(root.right) root.val = minNode.val root.right = deleteNode(root.right, root.val) return root def findMin(node): while node.left: node = node.left return node def inorderTraversal(root): res = [] if root: res = inorderTraversal(root.left) res.append(root.val) res = res + inorderTraversal(root.right) return res"},{"question":"def find_closest_to_median(M: int, hours: List[int]) -> int: Find the day on which the hours worked is closest to the median of all hours worked during the given days. If there are multiple such days, select the day with the smallest index. >>> find_closest_to_median(5, [8, 6, 7, 5, 6]) 1 >>> find_closest_to_median(4, [4, 5, 6, 5]) 1 >>> find_closest_to_median(1, [5]) 0 >>> find_closest_to_median(6, [4, 6, 6, 5, 6, 1]) 1 >>> find_closest_to_median(3, [5, 5, 5]) 0 >>> find_closest_to_median(5, [3, 4, 2, 4, 5]) 1 >>> find_closest_to_median(7, [7, 3, 1, 9, 6, 8, 6]) 4","solution":"def find_closest_to_median(M, hours): # Helper function to calculate the median def median(nums): sorted_nums = sorted(nums) n = len(sorted_nums) mid = n // 2 if n % 2 == 0: return (sorted_nums[mid - 1] + sorted_nums[mid]) / 2.0 else: return sorted_nums[mid] med = median(hours) closest_index = 0 smallest_difference = abs(hours[0] - med) for i in range(1, M): difference = abs(hours[i] - med) if difference < smallest_difference: smallest_difference = difference closest_index = i elif difference == smallest_difference and i < closest_index: closest_index = i return closest_index # Example usage: # M = 5 # hours = [8, 6, 7, 5, 6] # print(find_closest_to_median(M, hours)) # Output: 1"},{"question":"def largest_square_plot(n: int, m: int, grid: List[str]) -> int: Determine the largest side length of the square plot John can create that only contains '1's. >>> largest_square_plot(4, 5, [ ... \\"10100\\", ... \\"10111\\", ... \\"11111\\", ... \\"10010\\"]) 2 >>> largest_square_plot(3, 3, [ ... \\"111\\", ... \\"111\\", ... \\"110\\"]) 2 >>> largest_square_plot(1, 1, [\\"0\\"]) 0","solution":"def largest_square_plot(n, m, grid): Determine the largest side length of the square plot he can create that only contains '1's. if n == 0 or m == 0: return 0 # Create a dp table with the same dimensions as the grid dp = [[0] * m for _ in range(n)] max_side_length = 0 # Initialize the dp table for i in range(n): for j in range(m): if grid[i][j] == '1': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length"},{"question":"def minimum_volunteers(shifts: List[Tuple[int, int]]) -> int: Calculate the minimum number of volunteers required to cover all shifts without overlapping. >>> minimum_volunteers([(1, 3), (2, 5), (6, 8)]) == 2 >>> minimum_volunteers([(1, 4), (2, 3), (3, 5), (7, 8)]) == 2 >>> minimum_volunteers([(1, 2), (2, 4), (4, 6), (6, 8), (8, 10)]) == 1","solution":"def minimum_volunteers(shifts): Calculate the minimum number of volunteers required to cover all shifts without overlapping. Args: shifts (list of tuples): Each tuple consists of two integers, the start and end times of a shift. Returns: int: The minimum number of volunteers needed. if not shifts: return 0 shifts.sort(key=lambda x: x[1]) end_time = shifts[0][1] volunteers = 1 for i in range(1, len(shifts)): if shifts[i][0] < end_time: volunteers += 1 end_time = shifts[i][0] else: end_time = shifts[i][1] return volunteers"},{"question":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in an array. >>> longest_consecutive([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive([1]) 1 >>> longest_consecutive([1, 3]) 1 >>> longest_consecutive([1, 2]) 2 >>> longest_consecutive([]) 0 >>> longest_consecutive([1, 1, 1, 1]) 1 >>> longest_consecutive([0, -1, -2, -3, -4, -5, 1, 2, 3, 4, 5]) 11 >>> longest_consecutive([10, 5, 12, 3, 55, 102, 4, 11, 6]) 4","solution":"def longest_consecutive(nums): Returns the length of the longest consecutive elements sequence in the array. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in nums: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def minimize_total_delivery_time(n: int, delivery_times: List[int]) -> int: Returns the shortest possible total delivery time if the orders are scheduled optimally. >>> minimize_total_delivery_time(3, [2, 3, 1]) 3 >>> minimize_total_delivery_time(5, [8, 5, 2, 3, 10]) 10 >>> minimize_total_delivery_time(1, [7]) 7 >>> minimize_total_delivery_time(4, [4, 4, 4, 4]) 4 >>> minimize_total_delivery_time(6, [1, 3, 5, 7, 2, 6]) 7","solution":"def minimize_total_delivery_time(n, delivery_times): Returns the shortest possible total delivery time if the orders are scheduled optimally. Parameters: n (int): The number of orders. delivery_times (list of int): List of delivery times for each order. Returns: int: The shortest possible total delivery time. return max(delivery_times)"},{"question":"def maxProductOfThreeNumbers(nums): Returns the maximum product of any three numbers in the array. >>> maxProductOfThreeNumbers([1, 2, 3, 4]) 24 >>> maxProductOfThreeNumbers([-1, -2, -3, -4]) -6 >>> maxProductOfThreeNumbers([-10, -10, 1, 3, 2]) 300 >>> maxProductOfThreeNumbers([7, 3, 1, 0, 4, 2]) 84 >>> maxProductOfThreeNumbers([-5, -4, -3, -2, -1]) -6 >>> maxProductOfThreeNumbers([0, -1, 3, 100, -70, -50]) 350000","solution":"def maxProductOfThreeNumbers(nums): Returns the maximum product of any three numbers in the array. nums.sort() return max(nums[-1] * nums[-2] * nums[-3], nums[0] * nums[1] * nums[-1])"},{"question":"def countDistinctDivisors(n: int, arr: List[int]) -> List[int]: For each element in arr, calculate the number of distinct divisors. >>> countDistinctDivisors(3, [3, 4, 6]) [2, 3, 4] >>> countDistinctDivisors(2, [10, 22]) [4, 4]","solution":"def countDistinctDivisors(n, arr): For each element in arr, calculate the number of distinct divisors. def count_divisors(num): divisors = set() for i in range(1, int(num**0.5) + 1): if num % i == 0: divisors.add(i) if i != num // i: divisors.add(num // i) return len(divisors) result = [] for number in arr: result.append(count_divisors(number)) return result"},{"question":"def final_destination_product(T, test_cases): Calculate the product of the final x and y coordinates of the robot's movement based on the commands. Arguments: T -- the number of test cases test_cases -- a list of tuples, each tuple contains an integer N and a string of length N representing the sequence of commands Example: >>> final_destination_product(2, [(5, \\"UUDDL\\"), (3, \\"LRR\\")]) [0, 0] >>> final_destination_product(1, [(4, \\"UUUU\\")]) [0]","solution":"def final_destination_product(T, test_cases): results = [] for case in test_cases: N, commands = case x, y = 0, 0 for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 results.append(x * y) return results"},{"question":"def maxRectangleArea(heights): Returns the maximum possible area of a rectangle formed by contiguous pillars. Heights of the pillars are given in the list 'heights'. Example: >>> maxRectangleArea([2, 1, 5, 6, 2, 3]) 10 >>> maxRectangleArea([2, 4]) 4 pass # Implement the function here def test_max_rectangle_area(): # Example tests assert maxRectangleArea([2, 1, 5, 6, 2, 3]) == 10, \\"Test Case 1 Failed\\" assert maxRectangleArea([2, 4]) == 4, \\"Test Case 2 Failed\\" # Additional corner cases and large input test assert maxRectangleArea([2]) == 2, \\"Test Case 3 Failed\\" assert maxRectangleArea([5, 5, 5, 5, 5]) == 25, \\"Test Case 4 Failed\\" assert maxRectangleArea([1, 2, 3, 4, 5]) == 9, \\"Test Case 5 Failed\\" assert maxRectangleArea([5, 4, 3, 2, 1]) == 9, \\"Test Case 6 Failed\\" assert maxRectangleArea([1, 1, 1, 1, 1]) == 5, \\"Test Case 7 Failed\\" # Large input case large_heights = [10000] * 100000 assert maxRectangleArea(large_heights) == 1000000000, \\"Test Case 8 Failed\\" print(\\"All test cases pass\\")","solution":"def maxRectangleArea(heights): Returns the maximum possible area of a rectangle formed by contiguous pillars. Heights of the pillars are given in the list 'heights'. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[stack[-1]] <= heights[index]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"import math from functools import reduce from typing import List def max_equal_candies(candies: List[int]) -> int: Determine if it is possible to distribute all the candies equally among the children. If it is possible, return the maximum number of children that can receive candies equally. If not, return 0. >>> max_equal_candies([4, 8, 12]) 4 >>> max_equal_candies([5, 7, 11]) 1 >>> max_equal_candies([3, 6, 9, 12]) 3 import pytest from solution import max_equal_candies def test_example_1(): assert max_equal_candies([4, 8, 12]) == 4 def test_example_2(): assert max_equal_candies([5, 7, 11]) == 1 def test_example_3(): assert max_equal_candies([3, 6, 9, 12]) == 3 def test_single_pile(): assert max_equal_candies([8]) == 8 def test_same_number_in_all_piles(): assert max_equal_candies([6, 6, 6]) == 6 def test_no_common_divisor(): assert max_equal_candies([3, 7, 11]) == 1 def test_large_numbers(): assert max_equal_candies([1000000, 500000, 250000]) == 250000 def test_all_ones(): assert max_equal_candies([1, 1, 1, 1]) == 1 def test_mixed_piles_with_gcd_of_two(): assert max_equal_candies([2, 4, 8, 10]) == 2","solution":"import math from functools import reduce def max_equal_candies(candies): Returns the maximum number of children that can receive candies equally from the piles of candies. # Compute the greatest common divisor (GCD) of all pile sizes def gcd(x, y): while y: x, y = y, x % y return x overall_gcd = reduce(gcd, candies) return overall_gcd"},{"question":"import math def ways_to_distribute_balloons(T: int, test_cases: List[Tuple[int, int]]) -> List[int]: Returns the number of ways to distribute K balloons out of N for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers, N and K. Returns: list of int: List of results for each test case. >>> ways_to_distribute_balloons(2, [(5, 3), (7, 2)]) [10, 21] >>> ways_to_distribute_balloons(1, [(10, 5)]) [252] >>> ways_to_distribute_balloons(3, [(6, 2), (8, 3), (10, 1)]) [15, 56, 10] >>> ways_to_distribute_balloons(2, [(9, 4), (5, 5)]) [126, 1] >>> ways_to_distribute_balloons(1, [(3, 1)]) [3]","solution":"import math def ways_to_distribute_balloons(T, test_cases): Returns the number of ways to distribute K balloons out of N for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains two integers, N and K. Returns: list of int: List of results for each test case. results = [] for N, K in test_cases: result = math.comb(N, K) results.append(result) return results"},{"question":"def rearrange_string(s: str) -> str: Rearrange the string such that no two adjacent letters are the same. If it is not possible, return an empty string. Args: s (str): the input string consisting of lowercase letters. Returns: str: a rearranged string with no two adjacent letters being the same, or an empty string if not possible. Examples: >>> rearrange_string('aabb') 'abab' >>> rearrange_string('aaab') '' def solve(t: int, test_cases: List[str]) -> List[str]: Solve the problem for multiple test cases. Args: t (int): the number of test cases. test_cases (List[str]): list of input strings for each test case. Returns: List[str]: list of results, each corresponding to a rearranged string or an empty string if not possible. Examples: >>> solve(2, ['aabb', 'aaab']) ['abab', ''] >>> solve(1, ['abc']) ['abc']","solution":"from heapq import heappop, heappush from collections import Counter def rearrange_string(s): Rearrange the string such that no two adjacent letters are the same. If it is not possible return an empty string. n = len(s) char_count = Counter(s) max_heap = [] # Using a max heap to store counts in negative to simulate max heap using min heap for char, count in char_count.items(): heappush(max_heap, (-count, char)) result = [] prev_count, prev_char = 0, '' # To keep track of the previous character used while max_heap: count, char = heappop(max_heap) result.append(char) # If the previous character count was more than 0, add it back to the heap if prev_count < 0: heappush(max_heap, (prev_count, prev_char)) # Update the previous character and count to current one prev_count, prev_char = count + 1, char # Decrease the count as it is negative rearranged_string = ''.join(result) # If the length of the result is not equal to the input string length, it means rearrangement wasn't possible if len(rearranged_string) != n: return \\"\\" return rearranged_string def solve(t, test_cases): results = [] for s in test_cases: results.append(rearrange_string(s)) return results"},{"question":"from collections import deque def min_steps_to_reach_delivery_point(M, N, grid, start, end): Calculate the minimum number of steps required for the truck to reach the delivery point on a grid. Parameters: - M: int, number of rows in the grid. - N: int, number of columns in the grid. - grid: List[str], the grid where '.' is an empty cell and 'X' is an obstacle. - start: Tuple[int, int], 1-based coordinates of the starting point. - end: Tuple[int, int], 1-based coordinates of the delivery point. >>> min_steps_to_reach_delivery_point(5, 5, [\\".....\\", \\".X...\\", \\"..X..\\", \\"...X.\\", \\".....\\"], (1, 1), (5, 5)) 8 >>> min_steps_to_reach_delivery_point(3, 3, [\\"..X\\", \\"X.X\\", \\"..X\\"], (1, 1), (3, 3)) -1","solution":"from collections import deque def min_steps_to_reach_delivery_point(M, N, grid, start, end): # Check if start or end points are obstacles if grid[start[0]-1][start[1]-1] == 'X' or grid[end[0]-1][end[1]-1] == 'X': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(start[0]-1, start[1]-1, 0)]) # (x, y, steps) visited = set() visited.add((start[0]-1, start[1]-1)) while queue: x, y, steps = queue.popleft() # Check if we've reached the end point if (x, y) == (end[0]-1, end[1]-1): return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return -1 # Example usage M = 5 N = 5 grid = [ \\".....\\", \\".X...\\", \\"..X..\\", \\"...X.\\", \\".....\\" ] start = (1, 1) end = (5, 5) print(min_steps_to_reach_delivery_point(M, N, grid, start, end))"},{"question":"def minimal_restocking_days(t: int, schedules: List[List[int]]) -> List[int]: Returns the minimal number of days after the last restock to place the next restocking order for each given restocking schedule. :param t: Integer, number of test cases :param schedules: List of lists, where each inner list contains the schedule for a particular item. :return: List of integers, where each integer is the minimal number of days for the corresponding schedule. >>> minimal_restocking_days(3, [ ... [4, 3, 8, 12, 5], ... [3, 10, 15, 20], ... [5, 2, 3, 1, 4, 5] ... ]) [3, 10, 1] >>> minimal_restocking_days(2, [ ... [3, 7, 8, 6], ... [4, 9, 4, 10, 11] ... ]) [6, 4]","solution":"def minimal_restocking_days(t, schedules): Returns the minimal number of days after the last restock to place the next restocking order for each given restocking schedule. :param t: Integer, number of test cases :param schedules: List of lists, where each inner list contains the schedule for a particular item. :return: List of integers, where each integer is the minimal number of days for the corresponding schedule. results = [] for schedule in schedules: n = schedule[0] days = schedule[1:] minimal_days = min(days) results.append(minimal_days) return results"},{"question":"def max_length_subarray_with_two_distinct(nums: List[int]) -> int: Returns the maximum length of a subarray that contains exactly two distinct integers. >>> max_length_subarray_with_two_distinct([1, 2, 1, 2, 3, 4, 2]) 4 >>> max_length_subarray_with_two_distinct([4, 4, 4, 4, 4]) 0","solution":"def max_length_subarray_with_two_distinct(nums): Returns the maximum length of a subarray that contains exactly two distinct integers. from collections import defaultdict if not nums or len(nums) < 2: return 0 left, right = 0, 0 max_length = 0 freq = defaultdict(int) while right < len(nums): freq[nums[right]] += 1 while len(freq) > 2: freq[nums[left]] -= 1 if freq[nums[left]] == 0: del freq[nums[left]] left += 1 if len(freq) == 2: max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def evaluate_employees(N: int, scores: List[Tuple[int, int, int]]) -> List[str]: Evaluates employees based on their scores across three metrics. Parameters: N (int): Number of employees scores (list of tuples): Each tuple consists of three integers representing the scores of an employee Returns: list of str: Each element is either \\"PASS\\" or \\"FAIL\\" for corresponding employee >>> evaluate_employees(4, [(60, 80, 90), (75, 60, 65), (55, 40, 50), (80, 85, 90)]) [\\"PASS\\", \\"FAIL\\", \\"FAIL\\", \\"PASS\\"] >>> evaluate_employees(3, [(50, 60, 60), (55, 65, 65), (69, 69, 69)]) [\\"FAIL\\", \\"FAIL\\", \\"FAIL\\"]","solution":"def evaluate_employees(N, scores): Evaluates employees based on their scores across three metrics. Parameters: N (int): Number of employees scores (list of tuples): Each tuple consists of three integers representing the scores of an employee Returns: list of str: Each element is either \\"PASS\\" or \\"FAIL\\" for corresponding employee results = [] for score in scores: X, Y, Z = score average = (X + Y + Z) / 3 if average >= 70 and X >= 50 and Y >= 50 and Z >= 50: results.append(\\"PASS\\") else: results.append(\\"FAIL\\") return results"},{"question":"def longestFlatSegment(N: int, arr: List[int]) -> int: Determine the length of the longest flat segment of the street where a flat segment is defined as consecutive elements with the same elevation. >>> longestFlatSegment(7, [3, 3, 2, 2, 2, 1, 1]) 3 >>> longestFlatSegment(6, [1, 1, 1, 1, 2, 3]) 4 >>> longestFlatSegment(5, [5, 5, 5, 5, 5]) 5 >>> longestFlatSegment(5, [1, 2, 3, 4, 5]) 1 >>> longestFlatSegment(8, [1, 1, 2, 2, 2, 1, 3, 3]) 3 >>> longestFlatSegment(1, [7]) 1 >>> longestFlatSegment(0, []) 0","solution":"def longestFlatSegment(N, arr): if N == 0: return 0 max_length = 1 current_length = 1 for i in range(1, N): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def find_largest_collection(test_cases): This function takes a list of test cases, where each test case is a list of integers representing the number of coins in each collection, and returns a list of the maximum number of coins in any single collection for each test case. Args: test_cases (list of lists): A list containing T lists, each representing the number of coins in collections. Returns: list of int: A list of integers, where each integer is the maximum number of coins in any single collection from the corresponding test case. pass # Example usage (this part will be used during unit testing): # test_cases = [ # [3, 4, 2, 5], # [1, 9, 8, 7], # [10, 10, 10, 10] # ] # print(find_largest_collection(test_cases)) # Output: [5, 9, 10] from solution import find_largest_collection def test_single_case(): test_cases = [ [3, 4, 2, 5] ] assert find_largest_collection(test_cases) == [5] def test_multiple_cases(): test_cases = [ [3, 4, 2, 5], [1, 9, 8, 7], [10, 10, 10, 10] ] assert find_largest_collection(test_cases) == [5, 9, 10] def test_all_collections_same(): test_cases = [ [5, 5, 5, 5] ] assert find_largest_collection(test_cases) == [5] def test_single_collection(): test_cases = [ [7] ] assert find_largest_collection(test_cases) == [7] def test_large_collections(): test_cases = [ [1, 10000, 500, 1000], [9999, 8888, 10000, 7777] ] assert find_largest_collection(test_cases) == [10000, 10000]","solution":"def find_largest_collection(test_cases): This function takes a list of test cases, where each test case is a list of integers representing the number of coins in each collection, and returns a list of the maximum number of coins in any single collection for each test case. Args: test_cases (list of lists): A list containing T lists, each representing the number of coins in collections. Returns: list of int: A list of integers, where each integer is the maximum number of coins in any single collection from the corresponding test case. result = [] for collections in test_cases: max_coins = max(collections) result.append(max_coins) return result # Example usage (this part will be used during unit testing): # test_cases = [ # [3, 4, 2, 5], # [1, 9, 8, 7], # [10, 10, 10, 10] # ] # print(find_largest_collection(test_cases)) # Output: [5, 9, 10]"},{"question":"def circular_shift(lst: List[int], steps: int) -> List[int]: Simulates a circular shift of the list by the given number of steps. Parameters: lst (list): List of integers representing the elements of the circle. steps (int): Number of steps to shift the list. Positive for clockwise, negative for counter-clockwise. Returns: list: The list after performing the circular shift. Examples: >>> circular_shift([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> circular_shift([1, 2, 3, 4, 5], -2) [3, 4, 5, 1, 2]","solution":"def circular_shift(lst, steps): Simulates a circular shift of the list by the given number of steps. Parameters: lst (list): List of integers representing the elements of the circle. steps (int): Number of steps to shift the list. Positive for clockwise, negative for counter-clockwise. Returns: list: The list after performing the circular shift. n = len(lst) steps = steps % n # Normalize steps to be within the bounds of the list length return lst[-steps:] + lst[:-steps]"},{"question":"def min_operations_to_equalize(heights): Returns the minimum number of operations required to make all skyscrapers' heights equal. >>> min_operations_to_equalize([3, 3, 5, 2, 4]) 3 >>> min_operations_to_equalize([1, 2, 3, 4]) 3 >>> min_operations_to_equalize([7, 7, 7]) 0","solution":"def min_operations_to_equalize(heights): Returns the minimum number of operations required to make all skyscrapers' heights equal. if not heights: return 0 return max(heights) - min(heights)"},{"question":"def find_seating_arrangement(N: int, people: List[str], M: int, pairs: List[Tuple[str, str]]) -> str: Arrange the seating so that no two people who do not get along sit next to each other. >>> N = 4 >>> people = ['alice', 'bob', 'charlie', 'david'] >>> M = 2 >>> pairs = [('alice', 'bob'), ('charlie', 'david')] >>> find_seating_arrangement(N, people, M, pairs) 'alice charlie bob david' >>> N = 3 >>> people = ['anna', 'ben', 'carla'] >>> M = 3 >>> pairs = [('anna', 'ben'), ('ben', 'carla'), ('carla', 'anna')] >>> find_seating_arrangement(N, people, M, pairs) 'impossible'","solution":"from collections import defaultdict, deque def find_seating_arrangement(N, people, M, pairs): # Create an adjacency list for people who do not get along adjacency_list = defaultdict(list) for a, b in pairs: adjacency_list[a].append(b) adjacency_list[b].append(a) # Graph coloring with two colors (bipartite graph can use two colors) color = {} def bfs(start): queue = deque([start]) color[start] = 0 # Start coloring with 0 while queue: person = queue.popleft() current_color = color[person] next_color = 1 - current_color # Alternate between 0 and 1 for neighbor in adjacency_list[person]: if neighbor in color: if color[neighbor] == current_color: # Conflict, not bipartite return False else: color[neighbor] = next_color queue.append(neighbor) return True for person in people: if person not in color: if not bfs(person): return \\"impossible\\" # If the graph is successfully colored, we generate the seating. group1 = [person for person in people if color[person] == 0] group2 = [person for person in people if color[person] == 1] return \\" \\".join(group1 + group2) # Example usage: # N = 4 # people = ['alice', 'bob', 'charlie', 'david'] # M = 2 # pairs = [('alice', 'bob'), ('charlie', 'david')] # print(find_seating_arrangement(N, people, M, pairs)) # Outputs a valid arrangement e.g., 'alice charlie bob david'"},{"question":"def count_equal_zero_one_subarrays(arr) -> int: Returns the number of subarrays with an equal number of 0s and 1s. >>> count_equal_zero_one_subarrays([0, 1, 0, 1]) 4 >>> count_equal_zero_one_subarrays([0]) 0 >>> count_equal_zero_one_subarrays([1]) 0 >>> count_equal_zero_one_subarrays([1, 0, 1, 0, 0, 1]) 7 >>> count_equal_zero_one_subarrays([1,0] * 50000) 2500000000","solution":"def count_equal_zero_one_subarrays(arr): Returns the number of subarrays with an equal number of 0s and 1s. count = 0 # Replace 0 with -1 arr = [1 if x == 1 else -1 for x in arr] prefix_sum = 0 prefix_map = {0: 1} # prefix map to store frequency of prefix sums for num in arr: prefix_sum += num if prefix_sum in prefix_map: count += prefix_map[prefix_sum] prefix_map[prefix_sum] += 1 else: prefix_map[prefix_sum] = 1 return count"},{"question":"def countSubstrings(s: str) -> int: Counts the number of substrings that start and end with the same character. Parameters: s (str): The input string. Returns: int: The count of substrings. >>> countSubstrings(\\"abca\\") 5 >>> countSubstrings(\\"abcab\\") 7","solution":"def countSubstrings(s): Counts the number of substrings that start and end with the same character. Parameters: s (str): The input string. Returns: int: The count of substrings. count = 0 n = len(s) # Create a dictionary to store the frequency of each character freq = {} for i in range(n): if s[i] in freq: count += freq[s[i]] freq[s[i]] += 1 else: freq[s[i]] = 1 # Each single character is a valid substring count += 1 return count"},{"question":"def complement_dna(dna_sequence: str) -> str: Given a single-stranded DNA sequence, returns the complementary strand. >>> complement_dna(\\"ATCG\\") \\"TAGC\\" >>> complement_dna(\\"A\\") \\"T\\" >>> complement_dna(\\"T\\") \\"A\\" >>> complement_dna(\\"C\\") \\"G\\" >>> complement_dna(\\"G\\") \\"C\\" >>> complement_dna(\\"AAAA\\") \\"TTTT\\" >>> complement_dna(\\"CCCC\\") \\"GGGG\\" >>> complement_dna(\\"GGGG\\") \\"CCCC\\" >>> complement_dna(\\"TTTT\\") \\"AAAA\\" >>> complement_dna(\\"ATAT\\") \\"TATA\\" >>> complement_dna(\\"CGCG\\") \\"GCGC\\" >>> complement_dna(\\"GATTACA\\") \\"CTAATGT\\" >>> complement_dna(\\"TACGTA\\") \\"ATGCAT\\" >>> complement_dna(\\"A\\"*1000) \\"T\\"*1000 >>> complement_dna(\\"T\\"*1000) \\"A\\"*1000 >>> complement_dna(\\"C\\"*1000) \\"G\\"*1000 >>> complement_dna(\\"G\\"*1000) \\"C\\"*1000 >>> complement_dna(\\"ATCG\\"*250) \\"TAGC\\"*250","solution":"def complement_dna(dna_sequence): Given a single-stranded DNA sequence, returns the complementary strand. complement = {'A': 'T', 'T': 'A', 'C': 'G', 'G': 'C'} return ''.join(complement[base] for base in dna_sequence)"},{"question":"def isArithmeticProgression(arr, n): Given an array \`arr\` of size \`n\`, check if it can be rearranged to form an arithmetic progression sequence (a sequence where the difference between consecutive elements is the same). Args: arr: List[int] -- The input array. n: int -- The size of the array. Returns: int -- 1 if it can form an arithmetic progression, otherwise 0. Example: >>> isArithmeticProgression([3, 5, 1], 3) == 1 >>> isArithmeticProgression([1, 2, 3, 5], 4) == 0","solution":"def isArithmeticProgression(arr, n): Checks if the array can be rearranged to form an arithmetic progression. Args: arr: List[int] -- The input array. n: int -- The size of the array. Returns: int -- 1 if it can form an arithmetic progression, otherwise 0. if n < 2: return 0 # An arithmetic sequence needs at least two elements arr.sort() # Calculate the common difference of the sorted array common_diff = arr[1] - arr[0] # Check if all consecutive elements have the same difference for i in range(2, n): if arr[i] - arr[i-1] != common_diff: return 0 return 1"},{"question":"def is_stock_happy(t, cases): Determine if there exists a two-day period where stock price increases first and decreases subsequently. Args: t : int : Number of test cases cases : List[Tuple[int, List[int]]] : List containing tuples, each tuple has an integer representing the number of days and a list of integers representing stock prices for those days. Returns: List[str] : A list containing results for each test case, either \\"HAPPY\\" or \\"SAD\\" >>> is_stock_happy(3, [(5, [1, 2, 3, 2, 1]), (4, [8, 9, 7, 6]), (3, [4, 5, 5])]) [\\"HAPPY\\", \\"HAPPY\\", \\"SAD\\"] >>> is_stock_happy(1, [(3, [1, 2, 3])]) [\\"SAD\\"] >>> is_stock_happy(1, [(3, [3, 2, 1])]) [\\"SAD\\"] >>> is_stock_happy(1, [(4, [1, 3, 2, 4])]) [\\"HAPPY\\"] >>> is_stock_happy(2, [(2, [5, 9]), (2, [7, 5])]) [\\"SAD\\", \\"SAD\\"]","solution":"def is_stock_happy(t, cases): Determine if there exists a two-day period where stock price increases first and decreases subsequently. Args: t : int : Number of test cases cases : List[Tuple[int, List[int]]] : List containing tuples, each tuple has an integer representing the number of days and a list of integers representing stock prices for those days. Returns: List[str] : A list containing results for each test case, either \\"HAPPY\\" or \\"SAD\\" results = [] for i in range(t): n, prices = cases[i] happy = False for j in range(1, n): if prices[j-1] < prices[j] and prices[j] > prices[j+1] if j+1 < n else False: happy = True break results.append(\\"HAPPY\\" if happy else \\"SAD\\") return results"},{"question":"def count_islands(input_str: str) -> int: Count the number of distinct islands in the given matrix. An island is a group of adjacent lands connected horizontally or vertically. >>> count_islands(\\"4 5n11110n11010n11000n00000\\") 1 >>> count_islands(\\"4 5n11000n11000n00100n00011\\") 3","solution":"def num_islands(matrix): if not matrix: return 0 R = len(matrix) C = len(matrix[0]) visited = [[False for _ in range(C)] for _ in range(R)] def dfs(r, c): stack = [(r, c)] while stack: row, col = stack.pop() if 0 <= row < R and 0 <= col < C and not visited[row][col] and matrix[row][col] == '1': visited[row][col] = True stack.append((row+1, col)) stack.append((row-1, col)) stack.append((row, col+1)) stack.append((row, col-1)) island_count = 0 for r in range(R): for c in range(C): if matrix[r][c] == '1' and not visited[r][c]: dfs(r, c) island_count += 1 return island_count def parse_input(input_str): lines = input_str.strip().split('n') R, C = map(int, lines[0].split()) matrix = [list(line) for line in lines[1:]] return matrix def count_islands(input_str): matrix = parse_input(input_str) return num_islands(matrix)"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a space-separated mathematical expression according to standard operator precedence and associativity rules. >>> evaluate_expression(\\"3 + 5 * 2 - 9 / 3\\") 10 >>> evaluate_expression(\\"10 * 2 - 3 + 5 / 5\\") 18 >>> evaluate_expression(\\"-3 + 5\\") 2 >>> evaluate_expression(\\"3 + -5\\") -2 >>> evaluate_expression(\\"( 3 + 5 ) * 2\\") 16","solution":"def evaluate_expression(expression): Evaluates a space-separated mathematical expression according to standard operator precedence and associativity rules. def apply_operation(operators, values): operator = operators.pop() right = values.pop() left = values.pop() if operator == '+': values.append(left + right) elif operator == '-': values.append(left - right) elif operator == '*': values.append(left * right) elif operator == '/': values.append(left // right) def precedence(op): if op in ('+', '-'): return 1 if op in ('*', '/'): return 2 return 0 values = [] operators = [] i = 0 while i < len(expression): if expression[i] == ' ': i += 1 continue if expression[i] == '(': operators.append(expression[i]) elif expression[i].isdigit() or (i < len(expression) - 1 and expression[i] == '-' and expression[i+1].isdigit()): j = i if expression[i] == '-': j += 1 while j < len(expression) and expression[j].isdigit(): j += 1 values.append(int(expression[i:j])) i = j - 1 else: while i < len(expression) and expression[i].isdigit(): i += 1 values.append(int(expression[j:i])) i -= 1 elif expression[i] == ')': while operators and operators[-1] != '(': apply_operation(operators, values) operators.pop() else: while (operators and precedence(operators[-1]) >= precedence(expression[i])): apply_operation(operators, values) operators.append(expression[i]) i += 1 while operators: apply_operation(operators, values) return values[0]"},{"question":"from functools import cmp_to_key from typing import List, Tuple def compare(x: str, y: str) -> int: Comparator function to determine the order for the largest concatenated number if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(blocks: List[str]) -> str: Forms the largest number possible with given blocks def process_input(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases and returns results # Unit Tests def test_largest_number(): # Simple case test_cases = [(3, [10, 2, 9]), (4, [62, 32, 21, 9])] assert process_input(test_cases) == [\\"9210\\", \\"9623221\\"] # Case with leading zeros test_cases = [(3, [0, 0, 0])] assert process_input(test_cases) == [\\"0\\"] # Larger numbers test_cases = [(5, [3, 30, 34, 5, 9])] assert process_input(test_cases) == [\\"9534330\\"] # Single element test_cases = [(1, [1])] assert process_input(test_cases) == [\\"1\\"] # Case with same numbers test_cases = [(4, [1, 1, 1, 1])] assert process_input(test_cases) == [\\"1111\\"] def test_compare(): assert compare('9', '34') == -1 assert compare('30', '3') == 1 assert compare('91', '90') == -1 assert compare('31', '32') == 1 assert compare('34', '3') == -1","solution":"from functools import cmp_to_key def compare(x, y): Comparator function to determine the order for the largest concatenated number if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 def largest_number(blocks): Forms the largest number possible with given blocks blocks = sorted(blocks, key=cmp_to_key(compare)) largest_num = ''.join(blocks) # removing leading zeros if any return largest_num if largest_num[0] != '0' else '0' def process_input(test_cases): results = [] for case in test_cases: N, blocks = case blocks = list(map(str, blocks)) results.append(largest_number(blocks)) return results"},{"question":"def can_form_palindrome(string: str) -> str: Returns \\"YES\\" if the input string can be rearranged into a palindrome, otherwise returns \\"NO\\". >>> can_form_palindrome(\\"civic\\") \\"YES\\" >>> can_form_palindrome(\\"ivicc\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" def solve(T: int, test_cases: List[str]) -> List[str]: Given the number of test cases and a list of strings, returns a list of results for each test case. >>> solve(3, [\\"civic\\", \\"ivicc\\", \\"hello\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> solve(2, [\\"aabb\\", \\"aabbcc\\"]) [\\"YES\\", \\"YES\\"] >>> solve(3, [\\"xyz\\", \\"yxz\\", \\"yxyxx\\"]) [\\"NO\\", \\"NO\\", \\"YES\\"]","solution":"def can_form_palindrome(string): Returns \\"YES\\" if the input string can be rearranged into a palindrome, otherwise returns \\"NO\\". # Count frequency of each character char_count = {} for char in string: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Count how many characters have an odd count odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # A string can be rearranged into a palindrome if it has at most one character with an odd count return \\"YES\\" if odd_count <= 1 else \\"NO\\" def solve(T, test_cases): Given the number of test cases and a list of strings, returns a list of results for each test case. results = [] for case in test_cases: results.append(can_form_palindrome(case)) return results"},{"question":"def arrange_books_by_identifier(t: int, test_cases: List[Tuple[List[int], List[int]]]) -> str: Arrange the book identifiers in rows sorted by their identifiers. Args: t (int): The number of test cases. test_cases (List[Tuple[List[int], List[int]]]): A list of tuples where each tuple contains: - A list with two integers N and K - A list of N integers representing the book identifiers Returns: str: A string representing the sorted book identifiers arranged in rows, with each row printed in a new line. Example: >>> arrange_books_by_identifier(2, [([5, 2], [3, 1, 4, 5, 2]), ([7, 3], [10, 9, 8, 7, 6, 5, 4])]) '1 2n3 4n5nn4 5 6n7 8 9n10' >>> arrange_books_by_identifier(1, [([6, 3], [4, 5, 6, 1, 2, 3])]) '1 2 3n4 5 6' from typing import List, Tuple from solution import arrange_books_by_identifier def test_single_case(): t = 1 test_cases = [ ([5, 2], [3, 1, 4, 5, 2]) ] output = arrange_books_by_identifier(t, test_cases) expected_output = \\"1 2n3 4n5\\" assert output == expected_output def test_multiple_cases(): t = 2 test_cases = [ ([5, 2], [3, 1, 4, 5, 2]), ([7, 3], [10, 9, 8, 7, 6, 5, 4]) ] output = arrange_books_by_identifier(t, test_cases) expected_output = \\"1 2n3 4n5nn4 5 6n7 8 9n10\\" assert output == expected_output def test_case_with_all_books_in_one_row(): t = 1 test_cases = [ ([5, 5], [11, 15, 13, 12, 14]) ] output = arrange_books_by_identifier(t, test_cases) expected_output = \\"11 12 13 14 15\\" assert output == expected_output def test_case_with_last_incomplete_row(): t = 1 test_cases = [ ([6, 4], [2, 3, 1, 6, 5, 4]) ] output = arrange_books_by_identifier(t, test_cases) expected_output = \\"1 2 3 4n5 6\\" assert output == expected_output def test_case_with_single_book(): t = 1 test_cases = [ ([1, 1], [100]) ] output = arrange_books_by_identifier(t, test_cases) expected_output = \\"100\\" assert output == expected_output","solution":"def arrange_books_by_identifier(t, test_cases): results = [] for i in range(t): n, k = test_cases[i][0] books = test_cases[i][1] books.sort() rows = [] for j in range(0, n, k): row = books[j:j+k] rows.append(\\" \\".join(map(str, row))) results.extend(rows) results.append(\\"\\") # a blank line to separate different test case results return \\"n\\".join(results).strip()"},{"question":"from typing import List def find_missing_positive(nums: List[int]) -> int: Given a list of integers, find the smallest positive integer that is missing from the list. >>> find_missing_positive([1, 2, 3]) 4 >>> find_missing_positive([3, 4, -1, 1]) 2 >>> find_missing_positive([7, 8, 9, 11, 12]) 1 >>> find_missing_positive([0, 10, 2, -10, -20]) 1","solution":"from typing import List def find_missing_positive(nums: List[int]) -> int: n = len(nums) # First, separate positive numbers and numbers <= 0 for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Then, find the first missing positive for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. >>> fibonacci(0) == 0 >>> fibonacci(1) == 1 >>> fibonacci(2) == 1 >>> fibonacci(3) == 2 >>> fibonacci(4) == 3 >>> fibonacci(5) == 5 >>> fibonacci(10) == 55 >>> fibonacci(30) == 832040","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: return 0 elif n == 1: return 1 a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def find_most_frequent_word(novels: List[Tuple[int, str]]) -> List[str]: A well-known publishing company is hosting a novel writing competition. Each participant is required to submit their novel, which is represented as a string of words separated by spaces. The judges use a sophisticated algorithm to evaluate the novels, part of which involves finding the most frequent word in each novel. If multiple words have the same highest frequency, the lexicographically smallest word among them is chosen as the most frequent word. Args: novels (List[Tuple[int, str]]): A list of tuples where each tuple contains: - An integer (n): the length of the string (number of characters including spaces) - A string: the novel text itself Returns: List[str]: A list containing the most frequent word from each novel >>> find_most_frequent_word([(31, \\"the quick brown fox jumps over the lazy dog\\")]) [\\"the\\"] >>> find_most_frequent_word([(28, \\"jack and jill went up the hill\\")]) [\\"and\\"] >>> find_most_frequent_word([(11, \\"the the the the\\")]) [\\"the\\"] pass","solution":"def find_most_frequent_word(novels): This function receives a list of tuples where each tuple contains: - An integer: the length of the string (number of characters including spaces) - A string: the novel text itself It returns a list of the most frequent words in each novel. results = [] for n, text in novels: words = text.split() word_count = {} for word in words: if word in word_count: word_count[word] += 1 else: word_count[word] = 1 most_frequent_word = min(word_count.items(), key=lambda x: (-x[1], x[0]))[0] results.append(most_frequent_word) return results"},{"question":"def perform_operations(n: int, q: int, array: List[int], operations: List[Tuple[int, int, int, int]]) -> List[int]: Perform a sequence of operations on an array of integers. Each operation can either add a value to a range of elements or multiply a value to a range of elements in the array. Args: n (int): The number of elements in the array. q (int): The number of operations. array (List[int]): The initial state of the array. operations (List[Tuple[int, int, int, int]]): A list of operations to be performed on the array. Returns: List[int]: The final state of the array after all operations. Examples: >>> perform_operations(5, 3, [1, 2, 3, 4, 5], [(1, 1, 3, 2), (2, 2, 5, 3), (1, 3, 5, 1)]) [3, 18, 31, 39, 48] >>> perform_operations(5, 1, [1, 2, 3, 4, 5], [(2, 2, 5, 3)]) [1, 6, 9, 12, 15] >>> perform_operations(5, 0, [1, 2, 3, 4, 5], []) [1, 2, 3, 4, 5]","solution":"def perform_operations(n, q, array, operations): for op in operations: if op[0] == 1: _, l, r, x = op for i in range(l-1, r): array[i] += x elif op[0] == 2: _, l, r, y = op for i in range(l-1, r): array[i] *= y return array"},{"question":"from typing import List, Tuple def shortestTravelTime(n: int, m: int, routes: List[Tuple[int, int, int]], A: int, B: int) -> int: Find the shortest travel time between two stations given a list of bus routes and their travel times. >>> shortestTravelTime(4, 4, [(1, 2, 10), (2, 3, 5), (1, 3, 15), (3, 4, 10)], 1, 4) 25 >>> shortestTravelTime(2, 1, [(1, 2, 10)], 1, 2) 10 >>> shortestTravelTime(3, 1, [(1, 3, 20)], 1, 2) inf >>> shortestTravelTime(5, 6, [(1, 2, 3), (2, 3, 4), (3, 4, 2), (4, 5, 1), (1, 3, 10), (2, 4, 8)], 1, 5) 10","solution":"import heapq from collections import defaultdict def shortestTravelTime(n, m, routes, A, B): adj_list = defaultdict(list) for u, v, t in routes: adj_list[u].append((v, t)) adj_list[v].append((u, t)) # Assuming this is an undirected graph # Dijkstra's Algorithm min_heap = [(0, A)] distances = {i: float('inf') for i in range(1, n+1)} distances[A] = 0 while min_heap: cur_distance, u = heapq.heappop(min_heap) if u == B: return cur_distance if cur_distance > distances[u]: continue for v, weight in adj_list[u]: distance = cur_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(min_heap, (distance, v)) return distances[B]"},{"question":"def guess_number(feedback_list): Determines the number in the fewest number of attempts by using a binary search strategy. Params: - feedback_list (list of tuples (str, int)): Feedback received after each guess. The feedback is a string ('too low', 'too high', 'correct') and the number is the guess made. Returns: - int: The correct guessed number based on feedback. >>> guess_number([('too low', 1), ('too high', 1000), ('too low', 500), ('too high', 750), ('correct', 625)]) 625 >>> guess_number([('too low', 500), ('too low', 750), ('too low', 875), ('correct', 1000)]) 1000 >>> guess_number([('too high', 500), ('too high', 250), ('too high', 125), ('correct', 1)]) 1 >>> guess_number([('correct', 500)]) 500 >>> guess_number([('too low', 250), ('too low', 375), ('too low', 437), ('too high', 468), ('too high', 453), ('correct', 445)]) 445","solution":"def guess_number(feedback_list): Determines the number in the fewest number of attempts by using a binary search strategy. Params: - feedback_list (list of tuples (str, int)): Feedback received after each guess. The feedback is a string ('too low', 'too high', 'correct') and the number is the guess made. Returns: - int: The correct guessed number based on feedback. low, high = 1, 1000 for feedback, guess in feedback_list: if feedback == 'too low': low = guess + 1 elif feedback == 'too high': high = guess - 1 elif feedback == 'correct': return guess raise ValueError(\\"The input feedback list must contain a 'correct' feedback.\\") # Example usage: # feedback_list = [('too low', 1), ('too high', 1000), ('too low', 500), ('too high', 750), ('correct', 625)] # print(guess_number(feedback_list)) # Output: 625"},{"question":"def kth_largest_unique(nums, k): Returns the k-th largest unique element in the list. If there are fewer than k unique elements, return -1. >>> kth_largest_unique([5, 3, 4, 2, 5, 2, 5], 3) 3 >>> kth_largest_unique([1, 2, 3, 4, 5], 6) -1 >>> kth_largest_unique([10], 1) 10 >>> kth_largest_unique([10], 2) -1 >>> kth_largest_unique([1, 2, 3, 4, 5], 2) 4 >>> kth_largest_unique([-1, -2, -3, -4, -5], 1) -1 >>> kth_largest_unique([-1, -2, -2, -3, -4], 3) -3 >>> kth_largest_unique([10**6, 10**6-1, 10**6-2], 1) 1000000 >>> kth_largest_unique([10**6, 10**6-1, 10**6], 2) 999999","solution":"def kth_largest_unique(nums, k): Returns the k-th largest unique element in the list. If there are fewer than k unique elements, return -1. unique_nums = list(set(nums)) unique_nums.sort(reverse=True) if k <= len(unique_nums): return unique_nums[k-1] else: return -1"},{"question":"def has_arithmetic_mean_property(n, stones): Determine if the set of stones has the \\"Arithmetic Mean Property\\". Args: n : int : the number of stones stones : list of int : the values on the stones Returns: str : \\"YES\\" if the arithmetic mean is an integer, \\"NO\\" otherwise >>> has_arithmetic_mean_property(4, [1, 3, 5, 7]) \\"YES\\" >>> has_arithmetic_mean_property(5, [1, 2, 3, 4, 6]) \\"NO\\"","solution":"def has_arithmetic_mean_property(n, stones): Determine if the set of stones has the \\"Arithmetic Mean Property\\". Args: n : int : the number of stones stones : list of int : the values on the stones Returns: str : \\"YES\\" if the arithmetic mean is an integer, \\"NO\\" otherwise total_sum = sum(stones) if total_sum % n == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def min_partition_difference(numbers): Partitions the given list into two sublists such that the difference between the sums of these sublists is minimized. Args: numbers (list): An array of integers. Returns: int: The minimum difference possible between the sums of the two sublists. >>> min_partition_difference([1, 6, 11, 5]) 1 >>> min_partition_difference([1, 5, 11, 5]) 0 >>> min_partition_difference([3, 3, 3, 3]) 0","solution":"def min_partition_difference(numbers): Partitions the given list into two sublists such that the difference between the sums of these sublists is minimized. Args: numbers (list): An array of integers. Returns: int: The minimum difference possible between the sums of the two sublists. total_sum = sum(numbers) n = len(numbers) # Create a DP table to store the subset sums dp = [[False] * (total_sum + 1) for _ in range(n + 1)] # Initialize dp[i][0] to True for all i for i in range(n + 1): dp[i][0] = True # Fill the DP table for i in range(1, n + 1): for j in range(1, total_sum + 1): if numbers[i - 1] <= j: dp[i][j] = dp[i - 1][j] or dp[i - 1][j - numbers[i - 1]] else: dp[i][j] = dp[i - 1][j] # Find the minimum difference min_diff = float('inf') for j in range(total_sum // 2 + 1): if dp[n][j]: min_diff = min(min_diff, total_sum - 2 * j) return min_diff"},{"question":"from typing import List, Tuple def max_books(P: int, Q: int) -> int: Calculate the maximum number of books John can buy with P dollars where each book costs Q dollars and there is an offer where buying 4 books gets 1 free. Args: P (int): Budget in dollars Q (int): Cost per book in dollars Returns: int: The maximum number of books John can buy def max_books_for_cases(cases: List[Tuple[int, int]]) -> List[int]: Calculate the maximum number of books John can buy for multiple test cases. Args: cases (List[Tuple[int, int]]): List of tuples where each tuple contains (P, Q) Returns: List[int]: List of integers indicating the maximum number of books for each test case results = [] for case in cases: P, Q = case results.append(max_books(P, Q)) return results # Example test cases def test_sample_input_1(): cases = [(100, 20), (90, 25), (120, 15)] expected_results = [6, 3, 10] assert max_books_for_cases(cases) == expected_results def test_edge_case_lowest_cost_and_budget(): cases = [(1, 1)] expected_results = [1] assert max_books_for_cases(cases) == expected_results def test_edge_case_highest_cost_and_budget(): cases = [(100000, 100000)] expected_results = [1] assert max_books_for_cases(cases) == expected_results def test_exact_budget_for_multiple_sets(): cases = [(100, 25)] expected_results = [5] assert max_books_for_cases(cases) == expected_results def test_remaining_budget_not_enough_for_additional_books(): cases = [(81, 20)] expected_results = [5] assert max_books_for_cases(cases) == expected_results","solution":"def max_books(P, Q): Calculate the maximum number of books John can buy with P dollars where each book costs Q dollars and there is an offer where buying 4 books gets 1 free. Args: P : int : Budget in dollars Q : int : Cost per book in dollars Returns: int : The maximum number of books John can buy set_cost = 4 * Q # Cost of 4 books set_count = P // set_cost # Number of sets of 4 books John can buy remaining_money = P % set_cost # Money left after buying sets of 4 books # Total books including free books total_books = set_count * 5 # Each set of 4 books gets 1 free, so 5 books per set # Calculate remaining books that can be bought with remaining money remaining_books = remaining_money // Q return total_books + remaining_books def max_books_for_cases(cases): Calculate the maximum number of books John can buy for multiple test cases. Args: cases : list : List of tuples where each tuple contains (P, Q) Returns: list : List of integers indicating the maximum number of books for each test case results = [] for case in cases: P, Q = case results.append(max_books(P, Q)) return results"},{"question":"def max_flowers_selected(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the maximum number of flowers Alice can select that form a subsequence with strictly increasing heights and alternating colors. >>> max_flowers_selected(2, [ ... (5, [(2, 1), (3, 2), (4, 1), (5, 2), (6, 1)]), ... (6, [(1, 1), (3, 2), (2, 1), (5, 2), (4, 1), (6, 2)]) ... ]) [5, 4] >>> max_flowers_selected(1, [ ... (3, [(3, 1), (2, 2), (1, 3)]) ... ]) [3] >>> max_flowers_selected(1, [ ... (4, [(1, 1), (2, 1), (3, 1), (4, 1)]) ... ]) [1] >>> max_flowers_selected(1, [ ... (4, [(1, 1), (2, 2), (3, 2), (4, 3)]) ... ]) [3]","solution":"def max_flowers_selected(T, test_cases): results = [] for test_case in test_cases: N = test_case[0] flowers = test_case[1] # Sort flowers based on height first flowers.sort() # Initialize the dp array dp = [1] * N for i in range(1, N): for j in range(i): if flowers[i][0] > flowers[j][0] and flowers[i][1] != flowers[j][1]: dp[i] = max(dp[i], dp[j] + 1) results.append(max(dp)) return results"},{"question":"def is_peak_array(n: int, array: List[int]) -> Tuple[bool, Optional[int]]: Determines if the array follows the described peak pattern and finds the peak element. Args: n: The number of elements in the array. array: List of integers representing the array. Returns: A tuple (boolean, peak_element) where boolean is True if it follows the pattern, else False. >>> is_peak_array(7, [1, 3, 7, 8, 7, 4, 2]) (True, 8) >>> is_peak_array(5, [2, 4, 6, 4, 2]) (True, 6) >>> is_peak_array(5, [1, 2, 3, 4, 5]) (False, ) pass def process_test_cases(t: int, cases: List[Tuple[int, List[int]]]) -> List[str]: Processes multiple test cases to determine if they follow the peak pattern. Args: t: The number of test cases. cases: A list of tuples, where each tuple contains the count of elements and the array itself. Returns: A list of strings \\"YES <peak_element>\\" if the array follows the peak pattern, else \\"NO\\". >>> process_test_cases(3, [(7, [1, 3, 7, 8, 7, 4, 2]), (5, [2, 4, 6, 4, 2]), (5, [1, 2, 3, 4, 5])]) ['YES 8', 'YES 6', 'NO'] pass","solution":"def is_peak_array(n, array): Determines if the array follows the described peak pattern and finds the peak element. Returns a tuple (boolean, peak_element) where boolean is True if it follows the pattern, else False. if n < 3: return (False, ) increasing = True peak_element = None peak_index = -1 for i in range(1, n): if increasing: if array[i] < array[i-1]: increasing = False peak_element = array[i-1] peak_index = i - 1 elif array[i] == array[i-1]: return (False, ) else: if array[i] >= array[i-1]: return (False, ) if increasing or peak_index == n - 1: return (False, ) return (True, peak_element) def process_test_cases(t, cases): results = [] for case in cases: n, array = case result = is_peak_array(n, array) if result[0]: results.append(f\\"YES {result[1]}\\") else: results.append(\\"NO\\") return results"},{"question":"def find_missing_books(T, test_cases): Lily is a library manager who needs to ensure that all the books in her library are accounted for. She is given a list of book IDs currently in the library, but some book IDs are missing. The list contains all integers from 1 to n, with some missing. Each book ID should appear only once. Write a program to help Lily find all the missing book IDs in the most efficient way possible. Input: - T: integer denoting the number of test cases. - test_cases: List of tuples, where each tuple contains: - an integer n denoting the total number of books that should be present. - a list of n−m space-separated integers representing the book IDs currently in the library, where m is the number of missing book IDs. Output: - For each test case, return a single line containing the missing book IDs, sorted in ascending order. >>> find_missing_books(2, [(10, [1, 2, 3, 4, 6, 7, 8, 9, 10]), (7, [1, 2, 4, 5, 6])]) [\\"5\\", \\"3 7\\"]","solution":"def find_missing_books(T, test_cases): results = [] for i in range(T): n = test_cases[i][0] present_books = test_cases[i][1] present_books_set = set(present_books) missing_books = [book for book in range(1, n + 1) if book not in present_books_set] results.append(' '.join(map(str, missing_books))) return results"},{"question":"def largest_possible_team(N: int, K: int, difficulties: List[int]) -> int: Returns the size of the largest possible team such that the difficulty levels of any two team members differ by at most 'K'. :param N: Number of developers :param K: Maximum allowed difference in difficulty levels :param difficulties: List of difficulty levels assigned to each developer :return: Size of the largest possible team >>> largest_possible_team(5, 3, [1, 4, 7, 10, 13]) 2 >>> largest_possible_team(1, 10, [5]) 1 >>> largest_possible_team(4, 3, [1, 2, 3, 4]) 4 >>> largest_possible_team(4, 1, [1, 3, 5, 7]) 1 >>> largest_possible_team(5, 3, [1, 4, 7, 10, 13, 1000000]) 2 >>> largest_possible_team(100000, 0, list(range(1, 100001))) 1 >>> largest_possible_team(3, 2, [1, 7, 10]) 1","solution":"def largest_possible_team(N, K, difficulties): Returns the size of the largest possible team such that the difficulty levels of any two team members differ by at most 'K'. :param N: Number of developers :param K: Maximum allowed difference in difficulty levels :param difficulties: List of difficulty levels assigned to each developer :return: Size of the largest possible team difficulties.sort() max_team_size = 1 curr_team_size = 1 start = 0 for i in range(1, N): if difficulties[i] - difficulties[start] <= K: curr_team_size += 1 max_team_size = max(max_team_size, curr_team_size) else: while difficulties[i] - difficulties[start] > K: start += 1 curr_team_size -= 1 return max_team_size"},{"question":"def repeatedCharacters(s: str) -> List[str]: Write a function \`repeatedCharacters\` that returns a list of characters that appear more than once in the input string, ignoring case and non-alphabetical characters. >>> repeatedCharacters(\\"abcdefg\\") == [] >>> repeatedCharacters(\\"programming\\") == [\\"r\\", \\"g\\", \\"m\\"] >>> repeatedCharacters(\\"HeLLo\\") == [\\"l\\"] >>> repeatedCharacters(\\"1234!@#abAB\\") == [\\"a\\", \\"b\\"] >>> repeatedCharacters(\\"\\") == [] >>> repeatedCharacters(\\"1234!@#\\") == [] >>> repeatedCharacters(\\"This is a test!\\") == [\\"t\\", \\"i\\", \\"s\\"]","solution":"def repeatedCharacters(s): Return a list of characters that appear more than once in the input string, ignoring case and non-alphabetical characters. from collections import Counter # Convert the string to lowercase and filter only alphabetical characters filtered_chars = [char.lower() for char in s if char.isalpha()] # Count the frequency of each character char_counts = Counter(filtered_chars) # Return the characters that appear more than once, in the order they first appear repeated_chars = [char for char in filtered_chars if char_counts[char] > 1] # Use dict.fromkeys to maintain order and remove duplicates return list(dict.fromkeys(repeated_chars))"},{"question":"from typing import List def fibonacci(n: int) -> List[int]: Design a function that takes an integer 'n' and returns a list of the first 'n' numbers in the Fibonacci sequence. The Fibonacci sequence starts with the numbers 0 and 1, and each subsequent number is the sum of the previous two. >>> fibonacci(5) [0, 1, 1, 2, 3] >>> fibonacci(10) [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]","solution":"def fibonacci(n): Returns a list of the first n numbers in the Fibonacci sequence. Parameters: n (int): The number of Fibonacci numbers to return. Returns: list: A list of the first n Fibonacci numbers. if n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) return fib_sequence"},{"question":"def min_steps(source: str, target: str) -> int: Returns the minimum number of steps required to transform the source string into the target string using insert, remove, and replace operations. >>> min_steps(\\"kitten\\", \\"sitting\\") == 3 >>> min_steps(\\"flaw\\", \\"lawn\\") == 2 >>> min_steps(\\"intention\\", \\"execution\\") == 5 >>> min_steps(\\"\\", \\"abcdef\\") == 6 >>> min_steps(\\"abcdef\\", \\"\\") == 6 >>> min_steps(\\"example\\", \\"example\\") == 0","solution":"def min_steps(source, target): Returns the minimum number of steps required to transform the source string into the target string using insert, remove, and replace operations. m, n = len(source), len(target) # Create a DP table with dimensions (m+1) x (n+1) dp = [[0] * (n + 1) for _ in range(m + 1)] # Initialize the DP table for i in range(m + 1): for j in range(n + 1): if i == 0: dp[i][j] = j # If source is empty, all characters of target must be inserted elif j == 0: dp[i][j] = i # If target is empty, all characters of source must be removed elif source[i-1] == target[j-1]: dp[i][j] = dp[i-1][j-1] # If characters are the same, no operation is required else: dp[i][j] = 1 + min(dp[i-1][j], # Remove dp[i][j-1], # Insert dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"def calculate_minimum_energy(trips: List[Tuple[int, int, int]]) -> int: Calculate the minimum total energy required to execute all trips. >>> calculate_minimum_energy([(0, 10, 5)]) == 50 >>> calculate_minimum_energy([(0, 10, 5), (20, 30, 2), (10, 20, 3)]) == 50 + 20 + 30 >>> calculate_minimum_energy([(0, 5, 10), (5, 10, 15)]) == 50 + 75 >>> calculate_minimum_energy([(0, 1, 1), (2, 5, 4), (10, 15, 2)]) == 1 + 12 + 10 >>> calculate_minimum_energy([(10, 100, 2), (110, 200, 1), (150, 160, 1)]) == (90 * 2) + (90 * 1) + (10 * 1)","solution":"def calculate_minimum_energy(trips): Calculate the minimum total energy required to execute all trips. total_energy = 0 # For each trip, calculate the energy consumption for trip in trips: start, end, rate = trip distance = end - start energy = distance * rate total_energy += energy return total_energy"},{"question":"def solve(s: str, allowed_chars: Set[str]) -> int: Finds the length of the longest consecutive substring that contains only the specified characters. For example: >>> solve(\\"abcde\\", {\\"a\\", \\"b\\", \\"c\\"}) == 3 >>> solve(\\"aaabacccbbdd\\", {\\"a\\", \\"c\\"}) == 4 :param s: The main string to search within. :param allowed_chars: A set of characters that the substring is allowed to contain. :return: The length of the longest substring that contains only characters from allowed_chars.","solution":"def solve(s: str, allowed_chars: set) -> int: Finds the length of the longest consecutive substring that contains only the specified characters. :param s: The main string to search within. :param allowed_chars: A set of characters that the substring is allowed to contain. :return: The length of the longest substring that contains only characters from allowed_chars. max_length = 0 current_length = 0 for char in s: if char in allowed_chars: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length"},{"question":"def find_missing_positive(A, N): Returns the smallest positive integer that is not present in the array A of size N. >>> find_missing_positive([3, 4, -1, 1], 4) # 2 >>> find_missing_positive([1, 2, 0], 3) # 3 >>> find_missing_positive([1, 2, 3, 4, 5], 5) # 6 >>> find_missing_positive([2], 1) # 1 >>> find_missing_positive([1, 2, 2, 3, 4, 4, 6, 7, 8], 9) # 5 >>> find_missing_positive([10, 11, 12], 3) # 1 >>> find_missing_positive([-1, -2, 0], 3) # 1 >>> find_missing_positive([-1, -2, 0, 1, 2, 3, 5], 7) # 4 >>> find_missing_positive([], 0) # 1","solution":"def find_missing_positive(A, N): Returns the smallest positive integer that is not present in the array A of size N. for i in range(N): while 1 <= A[i] <= N and A[A[i] - 1] != A[i]: A[A[i] - 1], A[i] = A[i], A[A[i] - 1] for i in range(N): if A[i] != i + 1: return i + 1 return N + 1"},{"question":"def expected_last_card_value(N: int) -> float: Calculate the expected value of the last card Tina will remove. Parameters: N (int): The number of cards Tina starts with. Returns: float: The expected value of the last card Tina will remove, rounded to six decimal places. >>> expected_last_card_value(3) 2.000000 >>> expected_last_card_value(1) 1.000000 >>> expected_last_card_value(2) 1.500000 >>> expected_last_card_value(1000) 500.500000 >>> expected_last_card_value(10) 5.500000","solution":"def expected_last_card_value(N): Calculate the expected value of the last card Tina will remove. Parameters: N (int): The number of cards Tina starts with. Returns: float: The expected value of the last card Tina will remove, rounded to six decimal places. return round((N + 1) / 2, 6)"},{"question":"from typing import List def deckRevealedIncreasing(nums: List[int]) -> List[int]: Arrange the deck in such a way that the deck is sorted in increasing order following the given rules. Args: nums: List[int] - An array of integers representing the deck of cards. Returns: List[int] - The order in which cards should be placed into the deck to achieve the desired sorted order. Example: >>> deckRevealedIncreasing([17, 13, 11, 2, 3, 5, 7]) [2, 13, 3, 11, 5, 17, 7]","solution":"from collections import deque def deckRevealedIncreasing(nums): Returns the order in which cards should be placed into the deck to achieve the sorted order. Args: nums: List[int] Returns: List[int] # Sort the numbers in ascending order sorted_nums = sorted(nums) # Initialize a deque to simulate the process of placing and reshuffling cards deck = deque() # Process the sorted numbers in reverse for num in reversed(sorted_nums): if deck: deck.appendleft(deck.pop()) deck.appendleft(num) return list(deck)"},{"question":"def manipulate_list(commands: List[str]) -> List[str]: Write a program that reads in a series of commands to manipulate a list of integers. The list starts empty, and the commands, which can be of the following types, are: 1. \`append x\` - Append integer x to the end of the list. 2. \`insert i x\` - Insert integer x at index i in the list. If i is out of bounds, do nothing. 3. \`remove x\` - Remove the first occurrence of integer x from the list. If x is not in the list, do nothing. 4. \`pop\` - Remove the last element from the list. If the list is empty, do nothing. 5. \`print\` - Print the current state of the list. The program should process a sequence of these commands until it encounters the command \`end\`. The input consists of multiple lines. Each line contains one command, which is one of the types described above. The sequence of commands ends with a line containing the command \`end\`. Output for each \`print\` command encountered in the input: - The current state of the list, with the elements separated by a space on one line. >>> commands = [\\"append 3\\", \\"append 5\\", \\"print\\", \\"insert 1 10\\", \\"print\\", \\"remove 3\\", \\"remove 7\\", \\"print\\", \\"pop\\", \\"print\\", \\"end\\"] >>> manipulate_list(commands) [\\"3 5\\", \\"3 10 5\\", \\"10 5\\", \\"10\\"] >>> commands = [\\"append 1\\", \\"insert 3 5\\", \\"print\\", \\"end\\"] >>> manipulate_list(commands) [\\"1\\"] >>> commands = [\\"append 1\\", \\"remove 2\\", \\"print\\", \\"end\\"] >>> manipulate_list(commands) [\\"1\\"] >>> commands = [\\"pop\\", \\"print\\", \\"end\\"] >>> manipulate_list(commands) [\\"\\"] >>> commands = [\\"append 1\\", \\"print\\", \\"append 2\\", \\"print\\", \\"append 3\\", \\"print\\", \\"end\\"] >>> manipulate_list(commands) [\\"1\\", \\"1 2\\", \\"1 2 3\\"] >>> commands = [\\"end\\"] >>> manipulate_list(commands) []","solution":"def manipulate_list(commands): lst = [] results = [] for command in commands: parts = command.split() if parts[0] == \\"append\\": lst.append(int(parts[1])) elif parts[0] == \\"insert\\": index = int(parts[1]) value = int(parts[2]) if 0 <= index <= len(lst): lst.insert(index, value) elif parts[0] == \\"remove\\": value = int(parts[1]) if value in lst: lst.remove(value) elif parts[0] == \\"pop\\": if lst: lst.pop() elif parts[0] == \\"print\\": results.append(\\" \\".join(map(str, lst))) elif parts[0] == \\"end\\": break return results"},{"question":"def snake_to_camel(snake_case_string: str) -> str: Converts a snake_case string to camelCase. Parameters: snake_case_string (str): The input string in snake_case. Returns: str: The string converted to camelCase. >>> snake_to_camel(\\"hello_world\\") == \\"helloWorld\\" >>> snake_to_camel(\\"this_is_snake_case\\") == \\"thisIsSnakeCase\\" >>> snake_to_camel(\\"snake_case\\") == \\"snakeCase\\" >>> snake_to_camel(\\"hello\\") == \\"hello\\" >>> snake_to_camel(\\"\\") == \\"\\" >>> snake_to_camel(\\"a\\") == \\"a\\" >>> snake_to_camel(\\"trailing_underscore_\\") == \\"trailingUnderscore\\" >>> snake_to_camel(\\"_leading_underscore\\") == \\"LeadingUnderscore\\" >>> snake_to_camel(\\"multiple__underscores\\") == \\"multipleUnderscores\\"","solution":"def snake_to_camel(snake_case_string): Converts a snake_case string to camelCase. Parameters: snake_case_string (str): The input string in snake_case. Returns: str: The string converted to camelCase. parts = snake_case_string.split('_') # Capitalize the first letter of each part except the first one camel_case_string = parts[0] + ''.join(word.capitalize() for word in parts[1:]) return camel_case_string"},{"question":"def smallest_non_overlapping_number(n: int, k: int, hands: List[int]) -> int: Determines the smallest positive number the hands can point to such that no two hands overlap. If it is not possible to assign such a number to each hand, returns -1. Args: n : int : number of clock hands k : int : numbers on the clock hands : List[int] : initial positions of the hands Returns: int : smallest positive number that can be assigned to each hand such that no two hands overlap Examples: >>> smallest_non_overlapping_number(3, 5, [2, 4, 5]) 1 >>> smallest_non_overlapping_number(4, 4, [1, 1, 2, 2]) -1","solution":"def smallest_non_overlapping_number(n, k, hands): Determines the smallest positive number the hands can point to such that no two hands overlap. If it is not possible to assign such a number to each hand, returns -1. # If there are more hands than possible positions, it's impossible if n > k: return -1 # Sort the hands to place them in ascending order hands.sort() # Assign unique positions to each hand starting from 1 and check for overlap used_positions = set() for number in hands: if number in used_positions: return -1 used_positions.add(number) # If all hands can be assigned a unique position, the smallest positive number is 1 return 1"},{"question":"def min_fruits_to_giveaway(inventory: List[Tuple[str, int]], threshold: int) -> int: Returns the minimum number of different fruit types to be removed/redistributed. :param inventory: List of tuples where each tuple contains a fruit type and its quantity :param threshold: Maximum allowed quantity for any fruit type :return: Minimum number of different fruit types to be removed/redistributed >>> min_fruits_to_giveaway([(\\"Apple\\", 50), (\\"Banana\\", 70), (\\"Orange\\", 30), (\\"Grapes\\", 90)], 60) 2 >>> min_fruits_to_giveaway([(\\"Mango\\", 10), (\\"Pineapple\\", 20), (\\"Strawberry\\", 5)], 15) 1 # Your code here","solution":"def min_fruits_to_giveaway(inventory, threshold): Returns the minimum number of different fruit types to be removed/redistributed. :param inventory: List of tuples where each tuple contains a fruit type and its quantity :param threshold: Maximum allowed quantity for any fruit type :return: Minimum number of different fruit types to be removed/redistributed # Count how many types exceed the threshold count = 0 for fruit, quantity in inventory: if quantity > threshold: count += 1 return count"},{"question":"def max_average_subarray(arr, k): Return the maximum average sum of any subarray of length k. arr: List of integers k: Integer >>> max_average_subarray([1, 12, -5, -6, 50, 3], 4) == 12.75 >>> max_average_subarray([5, 5, 5, 5], 2) == 5.0 def test_max_average_subarray(): assert max_average_subarray([1, 12, -5, -6, 50, 3], 4) == 12.75 assert max_average_subarray([5, 5, 5, 5], 2) == 5.0 assert max_average_subarray([0, 1, 2, 3, 4, 5], 2) == 4.5 # Subarray [4, 5] assert max_average_subarray([-1, -2, -3, -4, -5], 1) == -1.0 # Subarray [-1] assert max_average_subarray([7, 8, 8, 7], 3) == 7.666666666666667 # Subarray [7, 8, 8] def test_max_average_subarray_edge_cases(): try: max_average_subarray([], 3) except ValueError as e: assert str(e) == \\"Invalid input\\" try: max_average_subarray([1, 2, 3], 0) except ValueError as e: assert str(e) == \\"Invalid input\\" try: max_average_subarray([1, 2, 3], 4) except ValueError as e: assert str(e) == \\"Invalid input\\" try: max_average_subarray([1], -1) except ValueError as e: assert str(e) == \\"Invalid input\\"","solution":"def max_average_subarray(arr, k): Return the maximum average sum of any subarray of length k. arr: List of integers k: Integer if not arr or k <= 0 or k > len(arr): raise ValueError(\\"Invalid input\\") current_sum = sum(arr[:k]) max_sum = current_sum for i in range(k, len(arr)): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum / k"},{"question":"from typing import List, Tuple def can_deliver_all_packages(n: int, m: int, routes: List[Tuple[int, int, int]], p: int, packages: List[Tuple[int, int, int]]) -> str: Determine whether it's possible to deliver all packages on time given the constraints of the delivery network. Args: n (int): Number of cities. m (int): Number of delivery routes between the cities. routes (List[Tuple[int, int, int]]): Each route is represented as a tuple containing two cities and the travel time. p (int): Number of packages. packages (List[Tuple[int, int, int]]): Each package is represented as a tuple containing the starting city, destination city, and maximum allowable travel time. Returns: str: \\"YES\\" if all packages can be delivered within their respective deadlines, otherwise \\"NO\\". Examples: >>> n, m = 4, 5 >>> routes = [ ... (1, 2, 10), ... (2, 3, 20), ... (1, 3, 15), ... (3, 4, 10), ... (2, 4, 25), ... ] >>> p = 3 >>> packages = [ ... (1, 3, 30), ... (2, 4, 40), ... (1, 4, 35), ... ] >>> can_deliver_all_packages(n, m, routes, p, packages) \\"YES\\" >>> n, m = 3, 3 >>> routes = [ ... (1, 2, 10), ... (2, 3, 20), ... (1, 3, 15), ... ] >>> p = 2 >>> packages = [ ... (1, 3, 10), ... (2, 3, 25), ... ] >>> can_deliver_all_packages(n, m, routes, p, packages) \\"NO\\"","solution":"import heapq import sys from collections import defaultdict def can_deliver_all_packages(n, m, routes, p, packages): def dijkstra(n, adj, src): dist = [float('inf')] * (n + 1) dist[src] = 0 pq = [(0, src)] while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for (v, weight) in adj[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist adj = defaultdict(list) for u, v, t in routes: adj[u].append((v, t)) adj[v].append((u, t)) # assuming undirected routes all_distances = {} for i in range(1, n+1): all_distances[i] = dijkstra(n, adj, i) for s, d, lt in packages: if all_distances[s][d] > lt: return \\"NO\\" return \\"YES\\""},{"question":"import math from itertools import permutations def is_special_number(n: int) -> str: Determine if the digits of the given number can be rearranged to form a square number. >>> is_special_number(1) == \\"YES\\" >>> is_special_number(10) == \\"YES\\" >>> is_special_number(35) == \\"NO\\" >>> is_special_number(4) == \\"YES\\" >>> is_special_number(13) == \\"NO\\" >>> is_special_number(49) == \\"YES\\" >>> is_special_number(100) == \\"YES\\" >>> is_special_number(0) == \\"YES\\" >>> is_special_number(7) == \\"NO\\" pass def process_test_cases(t, cases): Process the given test cases and determine if each number is a Special Number. >>> process_test_cases(3, [1, 10, 35]) == [ ... \\"Case 1: YES\\", ... \\"Case 2: YES\\", ... \\"Case 3: NO\\" ... ] >>> process_test_cases(2, [4, 38]) == [ ... \\"Case 1: YES\\", ... \\"Case 2: NO\\" ... ] >>> process_test_cases(1, [49]) == [ ... \\"Case 1: YES\\" ... ] pass","solution":"import math from itertools import permutations def is_special_number(n: int) -> str: Determine if the digits of the given number can be rearranged to form a square number. digits = str(n) seen_permutations = set() for perm in permutations(digits): perm_number = int(''.join(perm)) if perm_number in seen_permutations: continue seen_permutations.add(perm_number) if int(math.sqrt(perm_number)) ** 2 == perm_number: return \\"YES\\" return \\"NO\\" def process_test_cases(t, cases): results = [] for case_number, n in enumerate(cases, start=1): result = is_special_number(n) results.append(f\\"Case {case_number}: {result}\\") return results # Example usage processing input def run(): t = int(input()) cases = [] for _ in range(t): cases.append(int(input())) results = process_test_cases(t, cases) for result in results: print(result)"},{"question":"def game_result(nextMove, lastMove): Determines the result of the game based on nextMove and lastMove. If nextMove is greater than or equal to 8, or if nextMove is greater than lastMove, Second player wins (\\"Second\\"). If both players have the same move, it's a draw (\\"Draw\\"). Otherwise, the First player wins (\\"First\\"). pass def game_series(moves): Process a list of move pairs and determine the result for each game. Terminates when a move pair (0, 0) is encountered. >>> game_series([(6, 4), (5, 3), (2, 1), (0, 0)]) [\\"Second\\", \\"Second\\", \\"Second\\"] >>> game_series([(6, 4), (5, 3), (2, 2), (0, 0)]) [\\"Second\\", \\"Second\\", \\"Draw\\"] >>> game_series([(4, 6), (3, 5), (1, 3), (0, 0)]) [\\"First\\", \\"First\\", \\"First\\"] pass","solution":"def game_result(nextMove, lastMove): Determines the result of the game based on nextMove and lastMove. If nextMove is greater than or equal to 8, or if nextMove is greater than lastMove, Second player wins (\\"Second\\"). If both players have the same move, it's a draw (\\"Draw\\"). Otherwise, the First player wins (\\"First\\"). if nextMove == 0 and lastMove == 0: return None if nextMove == lastMove: return \\"Draw\\" elif nextMove >= 8 or nextMove > lastMove: return \\"Second\\" else: return \\"First\\" def game_series(moves): Process a list of move pairs and determine the result for each game. Terminates when a move pair (0, 0) is encountered. results = [] for nextMove, lastMove in moves: if nextMove == 0 and lastMove == 0: break results.append(game_result(nextMove, lastMove)) return results"},{"question":"def can_partition(arr, k): Determine if it's possible to partition the array into two non-empty subsets such that the absolute difference between the sums of the two subsets is exactly k. >>> can_partition([1, 2, 3, 9], 3) \\"YES\\" >>> can_partition([4, 1, 2], 4) \\"NO\\" >>> can_partition([3, 1, 4, 2, 2], 10) \\"YES\\" def solve(testcases): Takes a list of test cases and returns a list of results for each test case. >>> solve([(4, [1, 2, 3, 9], 3), (3, [4, 1, 2], 4), (5, [3, 1, 4, 2, 2], 10)]) [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def can_partition(arr, k): Determine if it's possible to partition the array into two non-empty subsets such that the absolute difference between the sums of the two subsets is exactly k. total_sum = sum(arr) # Check if the problem is solvable with the given k constraints if total_sum < k or (total_sum - k) % 2 != 0: return \\"NO\\" target_sum = (total_sum - k) // 2 # Use a set to keep track of possible subset sums possible_sums = {0} for num in arr: new_sums = possible_sums.copy() for s in possible_sums: new_sums.add(s + num) possible_sums = new_sums if target_sum in possible_sums: return \\"YES\\" else: return \\"NO\\" def solve(testcases): results = [] for case in testcases: _, arr, k = case results.append(can_partition(arr, k)) return results"},{"question":"def reverse_and_swap_case(s: str) -> str: Reverses the input string s and swaps the case of each character. >>> reverse_and_swap_case(\\"HelloWorld\\") \\"DLROwOLLEh\\" >>> reverse_and_swap_case(\\"\\") \\"\\" >>> reverse_and_swap_case(\\"ABCDE\\") \\"edcba\\" >>> reverse_and_swap_case(\\"abcde\\") \\"EDCBA\\" >>> reverse_and_swap_case(\\"aBcDeFg\\") \\"GfEdCbA\\" >>> reverse_and_swap_case(\\"a1B2c3D\\") \\"d3C2b1A\\" >>> reverse_and_swap_case(\\"a!b@c#\\") \\"#C@B!A\\"","solution":"def reverse_and_swap_case(s): Reverses the input string s and swaps the case of each character. Args: s (str): Input string. Returns: str: The processed string with characters in reverse order and case swapped. result = [] # Iterate over the string from end to start for i in range(len(s) - 1, -1, -1): char = s[i] if char.islower(): result.append(chr(ord(char) - 32)) # Convert to uppercase elif char.isupper(): result.append(chr(ord(char) + 32)) # Convert to lowercase else: result.append(char) # Append non-alphabetic characters as they are return ''.join(result)"},{"question":"def reverse_words_preserving_whitespace(s: str) -> str: Returns the input string with the order of words reversed while preserving whitespace. Leading and trailing whitespace are preserved. >>> reverse_words_preserving_whitespace(\\" hello world \\") \\" world hello \\" >>> reverse_words_preserving_whitespace(\\"a good example\\") \\"example good a\\"","solution":"def reverse_words_preserving_whitespace(s: str) -> str: Returns the input string with the order of words reversed while preserving whitespace. Leading and trailing whitespace are preserved. # Split the input string by spaces while keeping the spaces in the resulting list. words = s.split(' ') # Reverse the list and join back into a string with spaces. reversed_words = ' '.join(words[::-1]) return reversed_words"},{"question":"def is_even_sum_pair_exist(n: int, numbers: List[int]) -> str: Check if there exists a pair of distinct integers in the list that, when summed, result in an even number. :param n: The number of integers in the list. :param numbers: A list of n integers. :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> is_even_sum_pair_exist(5, [1, 3, 5, 7, 9]) \\"NO\\" >>> is_even_sum_pair_exist(4, [4, 3, 2, 1]) \\"YES\\"","solution":"def is_even_sum_pair_exist(n, numbers): Check if there exists a pair of distinct integers in the list that, when summed, result in an even number. :param n: The number of integers in the list. :param numbers: A list of n integers. :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\". # Count of even and odd numbers even_count = 0 odd_count = 0 for num in numbers: if num % 2 == 0: even_count += 1 else: odd_count += 1 # We need at least one even and one odd number to make an even sum if even_count > 0 and odd_count > 0: return \\"YES\\" else: return \\"NO\\""},{"question":"import re from typing import List def sum_numbers_in_text(text: str) -> int: Extracts numerical values from the given text and returns their sum. Args: text (str): The input text from which numerical values will be extracted. Returns: int: The sum of the numerical values present in the text. >>> sum_numbers_in_text(\\"The 3 little pigs built 3 houses: straw, sticks, and bricks. But only the brick house lasted because it had 10 bricks.\\") 16 >>> sum_numbers_in_text(\\"No numbers here!\\") 0 from solution import sum_numbers_in_text def test_example_1(): text = \\"The 3 little pigs built 3 houses: straw, sticks, and bricks. But only the brick house lasted because it had 10 bricks.\\" assert sum_numbers_in_text(text) == 16 def test_example_2(): text = \\"No numbers here!\\" assert sum_numbers_in_text(text) == 0 def test_mixed_text(): text = \\"abc 123 def 456 gh 789\\" assert sum_numbers_in_text(text) == 1368 def test_text_with_no_spaces(): text = \\"numbers123number4567\\" assert sum_numbers_in_text(text) == 4690 def test_text_with_special_characters(): text = \\"num!@#123%^&*()_+=-456[]{}|;:',.<>?/789\\" assert sum_numbers_in_text(text) == 1368 def test_large_numbers(): text = \\"The numbers 1000000 and 2345678 appear here.\\" assert sum_numbers_in_text(text) == 3345678 def test_text_with_newlines(): text = \\"The first number is 45.nThe second number is 55.\\" assert sum_numbers_in_text(text) == 100","solution":"import re def sum_numbers_in_text(text): Extracts numerical values from the given text and returns their sum. Args: text (str): The input text from which numerical values will be extracted. Returns: int: The sum of the numerical values present in the text. numbers = re.findall(r'd+', text) return sum(int(num) for num in numbers)"},{"question":"def perform_operations(n: int, m: int, matrix: List[List[int]], queries: List[List[int]]) -> List[int]: Perform operations on the matrix based on the given queries. Args: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. matrix (List[List[int]]): The initial matrix of integers. queries (List[List[int]]): The list of queries where each query is of the form [type, x, y] for incrementing or [type, a, b] for retrieving value. Returns: List[int]: List of results for each query of type 2. >>> n, m = 3, 3 >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> queries = [ ... [1, 2, 2], ... [2, 2, 2], ... [1, 3, 3], ... [2, 3, 3] ... ] >>> perform_operations(n, m, matrix, queries) [6, 10] >>> n, m = 2, 2 >>> matrix = [ ... [1, 1], ... [1, 1] ... ] >>> queries = [ ... [1, 1, 1], ... [1, 2, 2], ... [2, 1, 1], ... [2, 2, 2] ... ] >>> perform_operations(n, m, matrix, queries) [2, 2]","solution":"def perform_operations(n, m, matrix, queries): results = [] for query in queries: if query[0] == 1: # Type 1 query: incrementing the value at position (x, y) x, y = query[1], query[2] matrix[x-1][y-1] += 1 elif query[0] == 2: # Type 2 query: retrieving the value at position (a, b) a, b = query[1], query[2] results.append(matrix[a-1][b-1]) return results"},{"question":"def number_of_arrangements(n: int, g: int, groups: List[List[int]]) -> int: Calculate the number of different unique arrangements of the paintings respecting the consecutive order of paintings in each group. >>> number_of_arrangements(5, 3, [[1, 2], [3, 4], [5]]) 6 >>> number_of_arrangements(6, 2, [[1, 2, 3], [4, 5, 6]]) 2 >>> number_of_arrangements(4, 2, [[1, 2], [3, 4]]) 2 >>> number_of_arrangements(1, 1, [[1]]) 1 >>> number_of_arrangements(3, 3, [[1], [2], [3]]) 6 >>> number_of_arrangements(10, 5, [[1, 2], [3, 4], [5, 6], [7, 8], [9, 10]]) 120 >>> number_of_arrangements(7, 3, [[1, 2], [3, 4, 5], [6, 7]]) 6","solution":"from itertools import permutations def number_of_arrangements(n, g, groups): Calculate the number of different unique arrangements of the paintings respecting the consecutive order of paintings in each group. # Calculate all permutations of groups perm = permutations(groups) # For each permutation, generate the corresponding arrangement & count unique ones unique_arrangements = set() for p in perm: arrangement = [] for group in p: arrangement.extend(group) unique_arrangements.add(tuple(arrangement)) return len(unique_arrangements) # Example usage: #print(number_of_arrangements(5, 3, [[1, 2], [3, 4], [5]]))"},{"question":"def only_unique(arr): Determine whether all elements in the array are unique. The array can contain numbers, strings, or a mix of both. Return true if all elements are unique, false if any element is repeated. Maintain case sensitivity for strings. >>> only_unique([1, 2, 3, 4, 5]) True >>> only_unique([\\"apple\\", \\"banana\\", \\"Apple\\"]) True >>> only_unique([123, \\"123\\", 123]) False >>> only_unique([]) True >>> only_unique([1]) True >>> only_unique([\\"a\\", \\"A\\", \\"a\\"]) False >>> only_unique(list(range(1000000))) True >>> only_unique(list(range(999999)) + [0]) False >>> only_unique([1, \\"1\\", 2, \\"2\\"]) True >>> only_unique([1, \\"1\\", 2, \\"2\\", 1]) False","solution":"def only_unique(arr): Returns true if all elements in the array are unique, false otherwise. return len(arr) == len(set(arr))"},{"question":"from typing import List, Tuple def find_valid_sequence(n: int, s: str, m: int, dependencies: List[Tuple[str, str]]) -> str: Determines if a valid sequence exists that satisfies all the dependencies. If a valid sequence exists, prints any valid sequence as a string of n lowercase English letters. If no valid sequence exists, returns \\"NO\\". Args: n (int): The number of actions. s (str): The string of n lowercase English letters without duplicates, representing the actions. m (int): The number of dependency pairs. dependencies (List[Tuple[str, str]]): The list of m pairs of distinct lowercase English letters, indicating that action \`a\` must come before action \`b\`. Returns: str: A valid sequence or \\"NO\\". Examples: >>> find_valid_sequence(3, \\"abc\\", 2, [(\\"a\\", \\"c\\"), (\\"b\\", \\"c\\")]) 'abc' >>> find_valid_sequence(4, \\"abcd\\", 3, [(\\"a\\", \\"b\\"), (\\"a\\", \\"c\\"), (\\"c\\", \\"d\\")]) 'abdc' >>> find_valid_sequence(4, \\"abcd\\", 4, [(\\"a\\", \\"b\\"), (\\"b\\", \\"c\\"), (\\"c\\", \\"a\\"), (\\"d\\", \\"c\\")]) 'NO'","solution":"from collections import defaultdict, deque def find_valid_sequence(n, s, m, dependencies): # Build graph and in-degree count graph = defaultdict(list) in_degree = {char: 0 for char in s} for a, b in dependencies: graph[a].append(b) in_degree[b] += 1 # Topological sorting using Kahn's algorithm queue = deque([char for char in s if in_degree[char] == 0]) result = [] while queue: node = queue.popleft() result.append(node) for neighbor in graph[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(result) == n: return ''.join(result) else: return \\"NO\\""},{"question":"from typing import List, Tuple def reconstruct_path(n: int, logs: List[Tuple[int, int]]) -> List[int]: Reconstruct the path from log data in a distributed system. >>> reconstruct_path(3, [(1, 2), (3, 1), (2, 4)]) [3, 1, 2, 4] >>> reconstruct_path(4, [(10, 11), (11, 12), (12, 13), (14, 13)]) [10, 11, 12, 13, 14] >>> reconstruct_path(2, [(5, 9), (8, 5)]) [8, 5, 9]","solution":"def reconstruct_path(n, logs): from collections import defaultdict # Create adjacency list adjacency_list = defaultdict(list) in_degree = defaultdict(int) out_degree = defaultdict(int) for u, v in logs: adjacency_list[u].append(v) adjacency_list[v].append(u) out_degree[u] += 1 in_degree[v] += 1 # Find the start node by checking for a node with out-degree of 1 and in-degree of 0 start_node = None for node in adjacency_list: if out_degree[node] == 1 and in_degree[node] == 0: start_node = node break # If the start node is not found by directory method, pick the node which occurs only once in logs if start_node is None: count = defaultdict(int) for u, v in logs: count[u] += 1 count[v] += 1 for node in count: if count[node] == 1: start_node = node break path = [] visited = set() # Depth-first search to reconstruct the path def dfs(node): path.append(node) visited.add(node) for neighbor in adjacency_list[node]: if neighbor not in visited: dfs(neighbor) dfs(start_node) return path"},{"question":"def most_common_fruit(n: int, tree_list: List[str]) -> str: Finds the most common fruit among the given series of trees. If multiple fruits have the same frequency, returns the lexicographically smallest fruit. >>> most_common_fruit(4, [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) 'a' >>> most_common_fruit(3, [\\"kiwi\\", \\"kumquat\\", \\"kale\\"]) 'k' from collections import Counter def test_example1(): assert most_common_fruit(4, [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == 'a' def test_example2(): assert most_common_fruit(3, [\\"kiwi\\", \\"kumquat\\", \\"kale\\"]) == 'k' def test_single_tree(): assert most_common_fruit(1, [\\"banana\\"]) == 'a' def test_multiple_most_common_fruits(): assert most_common_fruit(3, [\\"abcd\\", \\"bcda\\", \\"cdab\\"]) == 'a' def test_all_unique(): assert most_common_fruit(2, [\\"abcdef\\", \\"ghijkl\\"]) == 'a' def test_single_character_trees(): assert most_common_fruit(5, [\\"a\\", \\"b\\", \\"c\\", \\"a\\", \\"d\\"]) == 'a' def test_mixed_length_trees(): assert most_common_fruit(4, [\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\"]) == 'd'","solution":"def most_common_fruit(n, tree_list): Finds the most common fruit among the given series of trees. If multiple fruits have the same frequency, returns the lexicographically smallest fruit. from collections import Counter fruit_counter = Counter() for tree in tree_list: fruit_counter.update(tree) most_common = sorted(fruit_counter.items(), key=lambda x: (-x[1], x[0]))[0][0] return most_common"},{"question":"def min_trees_destroyed(n: int, heights: List[int], m: int, ranges: List[Tuple[int, int]]) -> List[int]: Determine the minimum number of trees that will be destroyed after using the keeper's power optimally for each spell range. Args: n : int : number of trees heights : List[int] : heights of the trees m : int : number of spell ranges ranges : List[Tuple[int, int]] : list of spell ranges represented as tuples of (start, end) indices Returns: List[int] : list of minimum number of trees that will be destroyed for each spell range Example: >>> min_trees_destroyed(6, [3, 2, 5, 6, 4, 8], 2, [(2, 4), (1, 6)]) [1, 4] >>> min_trees_destroyed(5, [10, 15, 20, 25, 30], 1, [(1, 5)]) [3]","solution":"def min_trees_destroyed(n, heights, m, ranges): results = [] for sj, ej in ranges: slice_heights = heights[sj - 1: ej] max_height = max(slice_heights) min_height = min(slice_heights) # We can save the highest tree and the smallest tree by moving them destroyed_trees = max(0, len(slice_heights) - 2) results.append(destroyed_trees) return results # Example usage heights = [3, 2, 5, 6, 4, 8] ranges = [(2, 4), (1, 6)] print(min_trees_destroyed(6, heights, 2, ranges)) # Output: [1, 4]"},{"question":"from collections import deque class RecentCounter: Implement the class RecentCounter which counts recent requests. 1. RecentCounter() initializes the counter with zero recent requests. 2. int ping(int t) adds a new request at time t in milliseconds, and returns the number of requests in the past 3000 milliseconds (including the new request). Example: >>> recentCounter = RecentCounter() >>> recentCounter.ping(1) 1 >>> recentCounter.ping(100) 2 >>> recentCounter.ping(3001) 3 >>> recentCounter.ping(3002) 3 def __init__(self): ... def ping(self, t: int) -> int: ...","solution":"from collections import deque class RecentCounter: def __init__(self): self.requests = deque() def ping(self, t: int) -> int: self.requests.append(t) while self.requests and self.requests[0] < t - 3000: self.requests.popleft() return len(self.requests)"},{"question":"def alpha_sort(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: A custom sorting function that sorts the list of integers in ascending order and appends the original index of each element (0-based) at the end of each sorted element. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N (the number of elements) and a list of N integers. Returns: List[str]: A list of formatted strings for each test case, which contains the sorted elements along with their original indices. >>> alpha_sort(1, [(5, [3, 1, 4, 1, 5])]) [\\"1_1 1_3 3_0 4_2 5_4\\"] >>> alpha_sort(2, [(5, [3, 1, 4, 1, 5]), (4, [10, 20, 10, 5])]) [\\"1_1 1_3 3_0 4_2 5_4\\", \\"5_3 10_0 10_2 20_1\\"]","solution":"def alpha_sort(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] # Creating a list of tuples (element, original_index) indexed_arr = [(arr[j], j) for j in range(N)] # Sorting by elements first indexed_arr.sort() # Formatting the result as requested formatted_result = \\" \\".join([f\\"{el}_{idx}\\" for el, idx in indexed_arr]) results.append(formatted_result) return results"},{"question":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the array. Args: arr (list): A list of integers representing the array. Returns: int: The length of the longest increasing subsequence. >>> length_of_lis([10, 22, 9, 33, 21, 50]) 4 >>> length_of_lis([1, 2, 3, 4, 5]) 5 >>> length_of_lis([5, 4, 3, 2, 1]) 1 >>> length_of_lis([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_lis([]) 0 >>> length_of_lis([3, 10, 2, 1, 20]) 3 def process_test_cases(test_cases): Processes multiple test cases and returns the results. Args: test_cases (list): List of tuples where each tuple consists of (number of elements, array of integers). Returns: list: A list of integers representing the length of the longest increasing subsequence for each test case. >>> process_test_cases([(6, [10, 22, 9, 33, 21, 50]), (5, [1, 2, 3, 4, 5]), (5, [5, 4, 3, 2, 1]), (8, [10, 9, 2, 5, 3, 7, 101, 18]), (5, [3, 4, -1, 0, 6, 2, 3])]) [4, 5, 1, 4, 4] # Example: Processing input def process_input(input_data): Processes input data and returns the length of the longest increasing subsequence for each test case. Args: input_data (str): Input data as a single string. Returns: list: A list of integers representing the length of the longest increasing subsequence for each test case. >>> process_input(\\"1n6n10 22 9 33 21 50\\") [4] >>> process_input(\\"2n5n1 2 3 4 5n5n5 4 3 2 1\\") [5, 1]","solution":"def length_of_lis(arr): Returns the length of the longest increasing subsequence in the array. if not arr: return 0 dp = [1] * len(arr) for i in range(1, len(arr)): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_test_cases(test_cases): Processes multiple test cases and returns the results. results = [] for case in test_cases: N = case[0] arr = case[1] results.append(length_of_lis(arr)) return results # Example: Processing input def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) arr = list(map(int, lines[index + 1].split())) test_cases.append((N, arr)) index += 2 return process_test_cases(test_cases)"},{"question":"def visible_area(posters): Calculate the total visible area of the wall given a list of posters. Each poster is defined by its left and right corners (l, r), and the wall is of height 1 unit. Arguments: posters -- list of tuples where each tuple (l, r) represents the coordinates of the left and right ends of a poster. Returns: int -- total visible area of the wall Example: >>> visible_area([(1, 4), (2, 6), (8, 10)]) 5 >>> visible_area([(1, 5), (2, 3)]) 4 >>> visible_area([(1, 2), (2, 3), (3, 4), (4, 5)]) 4","solution":"def visible_area(posters): Returns the total visible area of the wall given the list of posters. Each poster is defined by its left and right corners (l, r). # Sort the posters based on the starting coordinate posters.sort() total_visible_area = 0 current_start, current_end = -1, -1 for l, r in posters: if l > current_end: # No overlap with the current segment total_visible_area += (current_end - current_start) current_start = l current_end = r else: # Overlap handling current_end = max(current_end, r) # Add the last segment's area total_visible_area += (current_end - current_start) return total_visible_area"},{"question":"def solve(t: int, test_cases: List[List[int]]) -> List[int]: Optimize the arrangement of boxes in storage by determining the minimum absolute difference between the sum of weights in two groups for each test case. Args: t: An integer representing the number of test cases. test_cases: A list of test case, each including the number of boxes and their respective weights. Returns: A list of integers where each integer is the minimum absolute difference for the corresponding test case. >>> t = 3 >>> test_cases = [ ... [4, 1, 2, 3, 4], ... [3, 10, 20, 15], ... [5, 1, 1, 1, 1, 1] ... ] >>> solve(t, test_cases) [0, 5, 1]","solution":"def min_difference_partition(weights): total_sum = sum(weights) n = len(weights) # Initialize a DP table dp = [[False] * (total_sum // 2 + 1) for _ in range(n + 1)] # Base case: zero sum is always possible for i in range(n + 1): dp[i][0] = True # Fill the partition DP table for i in range(1, n + 1): for j in range(1, total_sum // 2 + 1): if weights[i-1] <= j: dp[i][j] = dp[i-1][j-weights[i-1]] or dp[i-1][j] else: dp[i][j] = dp[i-1][j] # Find the maximum j which can be reached for j in range(total_sum // 2, -1, -1): if dp[n][j]: s1 = j break s2 = total_sum - s1 return abs(s2 - s1) def solve(t, test_cases): results = [] for case in test_cases: N, weights = case[0], case[1:] result = min_difference_partition(weights) results.append(result) return results # Example Input/Output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = [] index = 1 for _ in range(T): N = int(data[index]) weights = list(map(int, data[index+1:index+1+N])) test_cases.append([N] + weights) index += N + 1 results = solve(T, test_cases) for result in results: print(result)"},{"question":"from typing import List, Tuple def maximum_toys(T: int, test_cases: List[Tuple[int, int, int]]) -> List[int]: Calculate the maximum number of toys Mike can buy for each test case. Args: T: An integer representing the number of test cases. test_cases: A list of tuples, each containing three integers P, Q, and N where P is the reward points per task, Q is the cost of each toy in reward points, N is the number of tasks Mike completes. Returns: A list of integers where each integer represents the maximum number of toys Mike can buy for the corresponding test case. >>> maximum_toys(3, [(15, 50, 4), (25, 100, 9), (30, 75, 12)]) [1, 2, 4] >>> maximum_toys(1, [(10, 100, 10)]) [1]","solution":"def maximum_toys(T, test_cases): result = [] for i in range(T): P, Q, N = test_cases[i] total_reward = P * N max_toys = total_reward // Q result.append(max_toys) return result"},{"question":"def is_magical_tree(n, edges): Determine if a given tree is magical. :param n: The number of nodes in the tree :param edges: The list of edges in the tree :return: True if the tree is magical, False otherwise def magical_tree(t, test_cases): For each test case, determine if the tree is magical. :param t: Number of test cases :param test_cases: A list of test cases, each containing the number of nodes and edges in the tree :return: A list of \\"YES\\" or \\"NO\\" for each test case >>> test_cases = [(3, [(1, 2), (2, 3)]), (4, [(1, 2), (2, 3), (3, 4)])] >>> magical_tree(2, test_cases) [\\"NO\\", \\"YES\\"]","solution":"def is_magical_tree(n, edges): # If N is odd, it's not magical since each path sum would need all nodes to be even or all odd return n % 2 == 0 def magical_tree(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] edges = test_cases[i][1] if is_magical_tree(n, edges): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def can_make_palindrome(s: str, k: int) -> str: Returns 'YES' if the string can be made a palindrome by changing at most k characters, otherwise returns 'NO'. >>> can_make_palindrome(\\"abca\\", 1) 'YES' >>> can_make_palindrome(\\"abcdef\\", 2) 'NO'","solution":"def can_make_palindrome(s, k): Returns 'YES' if the string can be made a palindrome by changing at most k characters, otherwise returns 'NO'. n = len(s) mismatch_count = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 if mismatch_count <= k: return \\"YES\\" else: return \\"NO\\""},{"question":"import json from typing import Union def print_keys_with_levels(data: Union[dict, list], level: int = 1) -> None: Recursively print all keys in a JSON object with their respective levels. >>> example_json = { ... \\"name\\": \\"John\\", ... \\"age\\": 30, ... \\"address\\": { ... \\"street\\": \\"123 Main St\\", ... \\"city\\": \\"Anytown\\", ... \\"postalCode\\": \\"123456\\" ... }, ... \\"phoneNumbers\\": [ ... { ... \\"type\\": \\"home\\", ... \\"number\\": \\"1234567890\\" ... } ... ] ... } >>> print_keys_with_levels(example_json) name: level 1 age: level 1 address: level 1 street: level 2 city: level 2 postalCode: level 2 phoneNumbers: level 1 type: level 2 number: level 2 pass def main(input_json: str) -> None: Main function to parse the JSON input and print keys with levels. >>> input_json = '''{ ... \\"id\\": 1, ... \\"name\\": \\"A green door\\", ... \\"price\\": 12.50, ... \\"tags\\": [\\"home\\", \\"green\\"], ... \\"dimensions\\": { ... \\"length\\": 2.0, ... \\"width\\": 0.5, ... \\"units\\": \\"meters\\" ... } ... }''' >>> main(input_json) id: level 1 name: level 1 price: level 1 tags: level 1 dimensions: level 1 length: level 2 width: level 2 units: level 2 pass if __name__ == \\"__main__\\": import sys input_json = sys.stdin.read() main(input_json)","solution":"import json def print_keys_with_levels(data, level=1): if isinstance(data, dict): for key, value in data.items(): print(f\\"{key}: level {level}\\") print_keys_with_levels(value, level + 1) elif isinstance(data, list): for item in data: print_keys_with_levels(item, level) def main(input_json): data = json.loads(input_json) print_keys_with_levels(data)"},{"question":"from typing import List, Tuple from collections import defaultdict, deque def is_well_designed(n: int, m: int, roads: List[Tuple[int, int]]) -> str: Determines if the transportation system is well-designed or not. >>> is_well_designed(5, 6, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1), (1, 3)]) 'Well-designed' >>> is_well_designed(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'Not well-designed' >>> is_well_designed(3, 3, [(1, 2), (2, 3), (3, 1)]) 'Well-designed' >>> is_well_designed(2, 1, [(1, 2)]) 'Not well-designed' >>> is_well_designed(2, 2, [(1, 2), (2, 1)]) 'Well-designed' >>> is_well_designed(1, 0, []) 'Well-designed'","solution":"def is_well_designed(n, m, roads): from collections import defaultdict, deque def bfs(start, graph, n): seen = [False] * n queue = deque([start]) seen[start] = True count = 1 while queue: node = queue.popleft() for neighbor in graph[node]: if not seen[neighbor]: queue.append(neighbor) seen[neighbor] = True count += 1 return count == n graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in roads: graph[u - 1].append(v - 1) reverse_graph[v - 1].append(u - 1) if bfs(0, graph, n) and bfs(0, reverse_graph, n): return \\"Well-designed\\" else: return \\"Not well-designed\\""},{"question":"def generate_sequence(n, k): Generates a sequence from 1 to n where the difference between any two adjacent numbers in the sequence is at most k. pass def generate_sequences_for_test_cases(test_cases): Generates sequences for multiple test cases. Args: test_cases (List[Tuple[int, int]]): List of tuples where each tuple contains two integers n and k. Returns: List[List[int]]: List of sequences, each sequence corresponding to a test case. pass def test_generate_sequence_basic(): assert generate_sequence(5, 2) == [1, 2, 3, 4, 5] or generate_sequence(5, 2) == [1, 3, 2, 4, 5] assert generate_sequence(6, 1) == [1, 2, 3, 4, 5, 6] def test_generate_sequence_maximum_difference(): assert generate_sequence(5, 4) == [1, 2, 3, 4, 5] def test_generate_sequences_for_multiple_cases(): test_cases = [(5, 2), (6, 1)] results = generate_sequences_for_test_cases(test_cases) assert results == [[1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6]] or results == [[1, 3, 2, 4, 5], [1, 2, 3, 4, 5, 6]] def test_generate_sequence_edge_case(): assert generate_sequence(1, 1) == [1] assert generate_sequence(1, 100) == [1]","solution":"def generate_sequence(n, k): Generates a sequence from 1 to n where the difference between any two adjacent numbers in the sequence is at most k. sequence = [] for i in range(1, n + 1, k + 1): block = list(range(i, min(i + k + 1, n + 1))) sequence.extend(block) return sequence def generate_sequences_for_test_cases(test_cases): results = [] for n, k in test_cases: sequence = generate_sequence(n, k) results.append(sequence) return results"},{"question":"def longest_unique_subsequence(S: str) -> int: Returns the length of the longest contiguous subsequence with no repeated characters. :param S: A string representing a DNA sequence :return: Length of the longest contiguous subsequence with no repeated characters >>> longest_unique_subsequence(\\"ACGTACGTAC\\") == 4 >>> longest_unique_subsequence(\\"AAAAA\\") == 1 >>> longest_unique_subsequence(\\"ACACACGACC\\") == 3","solution":"def longest_unique_subsequence(S): Returns the length of the longest contiguous subsequence with no repeated characters. :param S: A string representing a DNA sequence :return: Length of the longest contiguous subsequence with no repeated characters n = len(S) if n == 0: return 0 char_index_map = {} max_length = 0 start_idx = 0 for i, char in enumerate(S): if char in char_index_map and char_index_map[char] >= start_idx: start_idx = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start_idx + 1) return max_length"},{"question":"def process_input(input_data: str) -> str: Given the paths of vehicles in a warehouse grid, identify all potential collision points. Args: input_data : str : The input string containing vehicle paths. Returns: str : The grid points where collisions might occur. If no intersections are found, returns \\"No collisions\\". Example: >>> input_data = ''' ... 2 ... 3 0 0 0 3 3 3 ... 3 0 1 0 3 3 3 ... 0 ... ''' >>> process_input(input_data) '0 3n3 3' >>> input_data = ''' ... 1 ... 3 0 0 1 1 2 2 ... 0 ... ''' >>> process_input(input_data) 'No collisions'","solution":"def find_collisions(vehicle_paths): from collections import defaultdict point_visits = defaultdict(int) potential_collisions = set() for path in vehicle_paths: visited_points = set() for point in path: if point in visited_points: # Prevent counting the same vehicle revisiting the same point in its own path continue point_visits[point] += 1 visited_points.add(point) if point_visits[point] > 1: potential_collisions.add(point) return potential_collisions def process_input(input_data): input_lines = input_data.strip().split('n') results = [] index = 0 while index < len(input_lines): m = int(input_lines[index].strip()) if m == 0: break index += 1 vehicle_paths = [] for _ in range(m): path_data = list(map(int, input_lines[index].strip().split())) path = [(path_data[i], path_data[i+1]) for i in range(1, len(path_data), 2)] vehicle_paths.append(path) index += 1 collisions = find_collisions(vehicle_paths) if collisions: results.extend([\\"{} {}\\".format(p[0], p[1]) for p in collisions]) else: results.append(\\"No collisions\\") return \\"n\\".join(results)"},{"question":"def rotate(matrix): Rotates the given n x n matrix to the right by 90 degrees in-place. >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> print(matrix) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> rotate(matrix) >>> print(matrix) [ [3, 1], [4, 2] ]","solution":"def rotate(matrix): Rotates the given n x n matrix to the right by 90 degrees in-place. n = len(matrix) # Step 1: Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Step 2: Reverse each row for i in range(n): matrix[i] = matrix[i][::-1]"},{"question":"def merge(nums1, m, nums2, n): Given two arrays, nums1 and nums2, with lengths m and n respectively, shuffled and sorted in ascending order, merge nums2 into nums1 as one sorted array. Assume nums1 has sufficient space (size that is equal to m + n) to hold additional elements from nums2. >>> nums1 = [1, 2, 3, 0, 0, 0] >>> m = 3 >>> nums2 = [2, 5, 6] >>> n = 3 >>> merge(nums1, m, nums2, n) [1, 2, 2, 3, 5, 6] >>> nums1 = [1, 2, 3, 0, 0, 0] >>> m = 3 >>> nums2 = [4, 5, 6] >>> n = 3 >>> merge(nums1, m, nums2, n) [1, 2, 3, 4, 5, 6] >>> nums1 = [4, 5, 6, 0, 0, 0] >>> m = 3 >>> nums2 = [1, 2, 3] >>> n = 3 >>> merge(nums1, m, nums2, n) [1, 2, 3, 4, 5, 6] >>> nums1 = [2, 4, 6, 0, 0, 0] >>> m = 3 >>> nums2 = [1, 3, 5] >>> n = 3 >>> merge(nums1, m, nums2, n) [1, 2, 3, 4, 5, 6] >>> nums1 = [1, 2, 3] >>> m = 3 >>> nums2 = [] >>> n = 0 >>> merge(nums1, m, nums2, n) [1, 2, 3] >>> nums1 = [0, 0, 0] >>> m = 0 >>> nums2 = [1, 2, 3] >>> n = 3 >>> merge(nums1, m, nums2, n) [1, 2, 3]","solution":"def merge(nums1, m, nums2, n): Merges two sorted arrays, nums1 and nums2, where nums1 has the space to hold the additional elements from nums2. # Initialize pointers for nums1 and nums2 p1, p2 = m - 1, n - 1 # Pointer for placing elements in the correct position in nums1 p = m + n - 1 # Compare elements from the end of nums1 and nums2 and place the larger one at the end of nums1 while p1 >= 0 and p2 >= 0: if nums1[p1] > nums2[p2]: nums1[p] = nums1[p1] p1 -= 1 else: nums1[p] = nums2[p2] p2 -= 1 p -= 1 # If there are remaining elements in nums2, copy them over nums1[:p2+1] = nums2[:p2+1] return nums1 # return is redundant as the merging is in-place, but useful for testing purposes"},{"question":"def fibonacci_sequence_upto(m): Generate Fibonacci numbers up to \`m\`. >>> fibonacci_sequence_upto(10) == [1, 1, 2, 3, 5, 8] >>> fibonacci_sequence_upto(1000) == [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987] def count_fibonacci_tables(M): Return the count of Fibonacci numbers up to \`M\`. >>> count_fibonacci_tables(10) == 6 >>> count_fibonacci_tables(1000) == 16 def find_all_unique_tables(T, test_cases): Return the number of unique rectangular tables Bob can create for each test case. >>> find_all_unique_tables(2, [10, 1000]) == [6, 16]","solution":"MOD = 1000000007 def fibonacci_sequence_upto(m): Generate Fibonacci numbers up to \`m\`. fibs = [1, 1] while True: next_fib = fibs[-1] + fibs[-2] if next_fib > m: break fibs.append(next_fib) return fibs def count_fibonacci_tables(M): fibonacci_numbers = fibonacci_sequence_upto(M) count = 0 for fib in fibonacci_numbers: if fib <= M: count += 1 return count def find_all_unique_tables(T, test_cases): results = [] for M in test_cases: results.append(count_fibonacci_tables(M)) return results"},{"question":"def fair_billing_system(p, u, plans, users, activities): Implement a fair billing system for a subscription-based video streaming platform. Parameters: p (int): The number of subscription plans. u (int): The number of users. plans (list of tuples): Each tuple consists of the plan name, cost, and maximum number of viewers. users (list of tuples): Each tuple consists of the name of the user and the name of the plan the user has subscribed to. activities (list of tuples): Each tuple consists of the time, name of the user, and the number of viewers at that time. Returns: list of tuples: Each tuple consists of a user's name and their total billing cost. Examples: >>> p = 2 >>> u = 3 >>> plans = [(\\"basic\\", 10, 2), (\\"premium\\", 20, 5)] >>> users = [(\\"alice\\", \\"basic\\"), (\\"bob\\", \\"premium\\"), (\\"carol\\", \\"basic\\")] >>> activities = [(\\"09:00\\", \\"alice\\", 2), (\\"09:15\\", \\"alice\\", 3), (\\"10:00\\", \\"bob\\", 1), (\\"10:15\\", \\"bob\\", 6), (\\"10:30\\", \\"carol\\", 2), (\\"11:00\\", \\"carol\\", 3)] >>> fair_billing_system(p, u, plans, users, activities) [('alice', 20), ('bob', 40), ('carol', 20)] pass # Unit tests def test_fair_billing_system(): p = 2 u = 3 plans = [(\\"basic\\", 10, 2), (\\"premium\\", 20, 5)] users = [(\\"alice\\", \\"basic\\"), (\\"bob\\", \\"premium\\"), (\\"carol\\", \\"basic\\")] activities = [(\\"09:00\\", \\"alice\\", 2), (\\"09:15\\", \\"alice\\", 3), (\\"10:00\\", \\"bob\\", 1), (\\"10:15\\", \\"bob\\", 6), (\\"10:30\\", \\"carol\\", 2), (\\"11:00\\", \\"carol\\", 3)] expected_result = [(\\"alice\\", 20), (\\"bob\\", 40), (\\"carol\\", 20)] assert fair_billing_system(p, u, plans, users, activities) == expected_result def test_single_user_no_overage(): p = 1 u = 1 plans = [(\\"basic\\", 15, 3)] users = [(\\"alice\\", \\"basic\\")] activities = [(\\"10:00\\", \\"alice\\", 2)] expected_result = [(\\"alice\\", 15)] assert fair_billing_system(p, u, plans, users, activities) == expected_result def test_user_with_overage(): p = 1 u = 1 plans = [(\\"standard\\", 25, 4)] users = [(\\"bob\\", \\"standard\\")] activities = [(\\"11:00\\", \\"bob\\", 5)] expected_result = [(\\"bob\\", 50)] assert fair_billing_system(p, u, plans, users, activities) == expected_result def test_multiple_overages(): p = 1 u = 1 plans = [(\\"advanced\\", 30, 3)] users = [(\\"carol\\", \\"advanced\\")] activities = [(\\"12:00\\", \\"carol\\", 7)] expected_result = [(\\"carol\\", 90)] assert fair_billing_system(p, u, plans, users, activities) == expected_result","solution":"def fair_billing_system(p, u, plans, users, activities): user_plan = {} plan_details = {} for plan in plans: name, cost, max_viewers = plan plan_details[name] = (cost, max_viewers) for user in users: user_name, plan_name = user user_plan[user_name] = { \\"plan_name\\": plan_name, \\"plan_cost\\": plan_details[plan_name][0], \\"max_viewers\\": plan_details[plan_name][1], \\"total_cost\\": plan_details[plan_name][0] } for time, user_name, viewers in activities: viewers = int(viewers) user_data = user_plan[user_name] if viewers > user_data[\\"max_viewers\\"]: additional_units = (viewers // user_data[\\"max_viewers\\"]) user_data[\\"total_cost\\"] += additional_units * user_data[\\"plan_cost\\"] return [(user, data[\\"total_cost\\"]) for user, data in user_plan.items()] # Example usage and output p = 2 u = 3 plans = [ (\\"basic\\", 10, 2), (\\"premium\\", 20, 5) ] users = [ (\\"alice\\", \\"basic\\"), (\\"bob\\", \\"premium\\"), (\\"carol\\", \\"basic\\") ] activities = [ (\\"09:00\\", \\"alice\\", 2), (\\"09:15\\", \\"alice\\", 3), (\\"10:00\\", \\"bob\\", 1), (\\"10:15\\", \\"bob\\", 6), (\\"10:30\\", \\"carol\\", 2), (\\"11:00\\", \\"carol\\", 3) ] result = fair_billing_system(p, u, plans, users, activities) for user, cost in result: print(f\\"{user} {cost}\\")"},{"question":"def is_well_formed(s: str) -> bool: Check if the string is well-formed by ensuring every character appears the same number of times. Args: s (str): The input string containing only lowercase English letters. Returns: bool: True if the string is well-formed, False otherwise. pass from solution import is_well_formed def test_well_formed_all_equal(): assert is_well_formed(\\"aabbcc\\") == True def test_not_well_formed_differing_counts(): assert is_well_formed(\\"aabbccc\\") == False def test_well_formed_equal_repeat(): assert is_well_formed(\\"abcabc\\") == True def test_single_character(): assert is_well_formed(\\"aaaa\\") == True def test_empty_string(): assert is_well_formed(\\"\\") == True def test_single_different_characters(): assert is_well_formed(\\"abcdef\\") == True def test_all_same_characters(): assert is_well_formed(\\"aaaa\\") == True def test_different_counts(): assert is_well_formed(\\"aabbccdde\\") == False def test_large_well_formed_string(): assert is_well_formed(\\"aabbcc\\" * 10000) == True def test_large_not_well_formed_string(): assert is_well_formed(\\"aabbcc\\" * 9999 + \\"d\\") == False","solution":"def is_well_formed(s): Check if the string is well-formed by ensuring every character appears the same number of times. Args: s (str): The input string containing only lowercase English letters. Returns: bool: True if the string is well-formed, False otherwise. if not s: return True # An empty string is considered well-formed from collections import Counter char_count = Counter(s) freqs = list(char_count.values()) return all(freq == freqs[0] for freq in freqs)"},{"question":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"aaaa\\") 4 >>> longest_palindromic_subsequence(\\"bbabcbcab\\") 7 >>> longest_palindromic_subsequence(\\"abcd\\") 1 >>> longest_palindromic_subsequence(\\"racecar\\") 7 def solve(t: int, test_cases: list) -> list: Solve the problem for multiple test cases. >>> solve(2, [\\"bbabcbcab\\", \\"abcd\\"]) [7, 1] >>> solve(3, [\\"aaaa\\", \\"a\\", \\"abcba\\"]) [4, 1, 5]","solution":"def longest_palindromic_subsequence(s: str) -> int: Returns the length of the longest palindromic subsequence in the given string. n = len(s) dp = [[0 for _ in range(n)] for _ in range(n)] for i in range(n): dp[i][i] = 1 for cl in range(2, n+1): for i in range(n-cl+1): j = i + cl - 1 if s[i] == s[j] and cl == 2: dp[i][j] = 2 elif s[i] == s[j]: dp[i][j] = dp[i+1][j-1] + 2 else: dp[i][j] = max(dp[i][j-1], dp[i+1][j]) return dp[0][n-1] def solve(t: int, test_cases: list) -> list: results = [] for s in test_cases: results.append(longest_palindromic_subsequence(s)) return results"},{"question":"def minimum_total_cost(n: int, arr: List[int]) -> int: Function to compute the minimum total cost of removing all elements from the array according to the given rules. Args: n: int : number of elements in the array arr: list : List of integers Returns: int : The minimum total cost >>> minimum_total_cost(4, [1, 3, 5, 9]) 6 >>> minimum_total_cost(3, [6, 2, 4]) 8 >>> minimum_total_cost(1, [5]) 5 >>> minimum_total_cost(4, [7, 7, 7, 7]) 0 >>> minimum_total_cost(4, [1, 2, 3, 4]) 2 >>> minimum_total_cost(2, [1, 1000]) 999","solution":"def minimum_total_cost(n, arr): Function to compute the minimum total cost of removing all elements from the array according to the given rules. Args: n: int : number of elements in the array arr: list : List of integers Returns: int : The minimum total cost if n == 1: return arr[0] arr.sort() total_cost = 0 for i in range(0, n-1, 2): total_cost += abs(arr[i+1] - arr[i]) # If the number of elements is odd, add the last remaining element if n % 2 == 1: total_cost += arr[-1] return total_cost"},{"question":"def smallest_string_by_removing_one_char(s: str) -> str: Returns the lexicographically smallest string that can be obtained by removing one character at any position in the string. Arguments: s -- A string consisting of lowercase English letters. Returns: A string that is the lexicographically smallest possible after removing one character. Examples: >>> smallest_string_by_removing_one_char(\\"abc\\") 'ab' >>> smallest_string_by_removing_one_char(\\"acbd\\") 'abd' >>> smallest_string_by_removing_one_char(\\"a\\") '' >>> smallest_string_by_removing_one_char(\\"leetcode\\") 'eetcode' from smallest_string_by_removing_one_char import smallest_string_by_removing_one_char def test_example_1(): assert smallest_string_by_removing_one_char(\\"abc\\") == \\"ab\\" def test_example_2(): assert smallest_string_by_removing_one_char(\\"acbd\\") == \\"abd\\" def test_example_3(): assert smallest_string_by_removing_one_char(\\"a\\") == \\"\\" def test_example_4(): assert smallest_string_by_removing_one_char(\\"leetcode\\") == \\"eetcode\\" def test_long_string(): assert smallest_string_by_removing_one_char(\\"abcdefg\\") == \\"abcdef\\" def test_multiple_same_chars(): assert smallest_string_by_removing_one_char(\\"aab\\") == \\"aa\\" def test_edge_case_all_same_chars(): assert smallest_string_by_removing_one_char(\\"aaaaa\\") == \\"aaaa\\" def test_with_alphabetically_sorted(): assert smallest_string_by_removing_one_char(\\"abcd\\") == \\"abc\\" def test_unsorted_string(): assert smallest_string_by_removing_one_char(\\"cab\\") == \\"ab\\"","solution":"def smallest_string_by_removing_one_char(s): Returns the lexicographically smallest string that can be obtained by removing one character at any position in the string s. min_string = s[1:] # Initialize with the string after removing the first character for i in range(1, len(s)): new_string = s[:i] + s[i+1:] if new_string < min_string: min_string = new_string return min_string"},{"question":"def kth_highest_unique_score(N: int, K: int, scores: List[int]) -> int: Returns the Kth highest unique score from the list of scores. If there are fewer than K unique scores, returns -1. Parameters: N (int): The number of players. K (int): The position of the score to find (1-based index). scores (List[int]): The list of scores of the players. Returns: int: The Kth highest unique score, or -1 if there are fewer than K unique scores. Example: >>> kth_highest_unique_score(8, 3, [100, 80, 90, 70, 80, 60, 90, 100]) 80 >>> kth_highest_unique_score(4, 5, [100, 70, 100, 90]) -1","solution":"def kth_highest_unique_score(N, K, scores): Returns the Kth highest unique score from the list of scores. If there are fewer than K unique scores, returns -1. unique_scores = sorted(set(scores), reverse=True) if len(unique_scores) < K: return -1 return unique_scores[K-1] # Example of using the function # N = 8, K = 3, scores = [100, 80, 90, 70, 80, 60, 90, 100] # Output should be 80 print(kth_highest_unique_score(8, 3, [100, 80, 90, 70, 80, 60, 90, 100])) # sample input"},{"question":"def length_of_LIS(arr): Finds the length of the longest increasing subsequence in the array. Parameters: arr (List[int]): The list of integers representing the array. Returns: int: The length of the longest strictly increasing subsequence. >>> length_of_LIS([10, 22, 9, 33, 21]) 3 >>> length_of_LIS([3, 10, 2, 1, 20, 21, 22]) 5 >>> length_of_LIS([50]) 1 >>> length_of_LIS([1, 2, 3, 4]) 4 >>> length_of_LIS([4, 3, 2, 1]) 1 >>> length_of_LIS([]) 0 def process_test_cases(T, test_cases): Processes multiple test cases and computes the length of the longest strictly increasing subsequence for each test case. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where the first element is the size of the array and the second element is the array itself. Returns: List[int]: A list of results for each test case. >>> test_cases = [ ... (5, [10, 22, 9, 33, 21]), ... (7, [3, 10, 2, 1, 20, 21, 22]) ... ] >>> process_test_cases(2, test_cases) [3, 5] >>> test_cases = [ ... (4, [1, 2, 3, 4]), ... (4, [4, 3, 2, 1]) ... ] >>> process_test_cases(2, test_cases) [4, 1] >>> test_cases = [ ... (1, [50]), ... (0, []) ... ] >>> process_test_cases(2, test_cases) [1, 0]","solution":"def length_of_LIS(arr): Finds the length of the longest increasing subsequence in the array. if not arr: return 0 n = len(arr) lis = [1] * n # Initialize LIS values for all indexes to 1 # Compute optimized LIS values in bottom up manner for i in range(1, n): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Pick the maximum of all LIS values return max(lis) def process_test_cases(T, test_cases): results = [] for case in test_cases: N, arr = case results.append(length_of_LIS(arr)) return results"},{"question":"def count_unique_splits(arr): Returns the number of unique ways to split a list into two non-empty contiguous sublists. :param arr: list of integers :return: integer, number of unique splits pass # Example usage: # arr = [1, 2, 3, 4] # print(count_unique_splits(arr)) # Output: 3","solution":"def count_unique_splits(arr): Returns the number of unique ways to split a list into two non-empty contiguous sublists. :param arr: list of integers :return: integer, number of unique splits n = len(arr) # The number of unique ways to split the list is simply (n - 1) return n - 1 # Example usage: # arr = [1, 2, 3, 4] # print(count_unique_splits(arr)) # Output: 3"},{"question":"def validate_package_ids(m: int, n: int, package_ids: List[List[int]]) -> str: Checks if the given arrangement of package IDs forms a contiguous sequence from 1 to m*n without any gaps or duplicates. Parameters: m (int): number of rows. n (int): number of columns. package_ids (list): 2D list with m rows and n columns containing package IDs. Returns: str: \\"Valid\\" if IDs are contiguous from 1 to m*n, otherwise \\"Invalid\\". >>> validate_package_ids(2, 3, [[1, 2, 3], [4, 5, 6]]) 'Valid' >>> validate_package_ids(2, 2, [[1, 2], [4, 4]]) 'Invalid' >>> validate_package_ids(2, 2, [[1, 2], [3, 5]]) 'Invalid' >>> validate_package_ids(1, 1, [[1]]) 'Valid' >>> validate_package_ids(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'Valid'","solution":"def validate_package_ids(m, n, package_ids): Checks if the given arrangement of package IDs forms a contiguous sequence from 1 to m*n without any gaps or duplicates. Parameters: m (int): number of rows. n (int): number of columns. package_ids (list): 2D list with m rows and n columns containing package IDs. Returns: str: \\"Valid\\" if IDs are contiguous from 1 to m*n, otherwise \\"Invalid\\". expected_ids = set(range(1, m * n + 1)) actual_ids = set() for row in package_ids: actual_ids.update(row) if actual_ids == expected_ids: return \\"Valid\\" else: return \\"Invalid\\""},{"question":"def process_transactions_input(T: int, transaction_list: List[str]) -> Dict[str, int]: You have been given a list of transaction records. Each record contains an identifier of the account holder, the transaction type (either deposit or withdrawal), and the amount involved in the transaction. Your task is to determine the final balance of each account holder. If the balance of any account holder becomes negative at any point due to withdrawals exceeding deposits, that account will be considered invalid, and you should not include it in the output. Args: T (int): The number of transactions. transaction_list (List[str]): A list containing transaction details as strings. Returns: Dict[str, int]: A dictionary with the account holder's identifier as keys and their final balance as values for valid accounts. >>> process_transactions_input(6, [\\"alice deposit 1000\\", \\"bob deposit 500\\", \\"alice withdrawal 300\\", \\"alice deposit 200\\", \\"bob withdrawal 600\\", \\"carol deposit 700\\"]) {'alice': 900, 'carol': 700} >>> process_transactions_input(1, [\\"alice deposit 1000\\"]) {'alice': 1000} >>> process_transactions_input(4, [\\"a withdrawal 500\\", \\"b withdrawal 600\\", \\"c withdrawal 100\\", \\"d withdrawal 200\\"]) {}","solution":"def calculate_final_balances(transactions): from collections import defaultdict balances = defaultdict(int) invalid_accounts = set() for account, trans_type, amount in transactions: if account in invalid_accounts: continue # Skip processing if the account is already invalid if trans_type == 'deposit': balances[account] += amount elif trans_type == 'withdrawal': balances[account] -= amount if balances[account] < 0: invalid_accounts.add(account) del balances[account] # Remove the account as it's invalid return {account: balance for account, balance in balances.items()} # Parameters parsing and function call for the given transactions def process_transactions_input(T, transaction_list): transactions = [tuple(transaction.split()) for transaction in transaction_list] transactions = [(acc, trans, int(amt)) for acc, trans, amt in transactions] return calculate_final_balances(transactions)"},{"question":"def is_perfect_number(n: int) -> bool: Determines if a given positive integer n is a perfect number. A perfect number is a number that is equal to the sum of its proper divisors (excluding the number itself). :param n: The positive integer to be checked. :return: True if n is a perfect number, False otherwise. >>> is_perfect_number(6) True >>> is_perfect_number(28) True >>> is_perfect_number(8) False from solution import is_perfect_number def test_perfect_number_6(): assert is_perfect_number(6) == True def test_perfect_number_28(): assert is_perfect_number(28) == True def test_not_perfect_number_8(): assert is_perfect_number(8) == False def test_not_perfect_number_1(): assert is_perfect_number(1) == False def test_not_perfect_number_25(): assert is_perfect_number(25) == False def test_perfect_number_496(): assert is_perfect_number(496) == True def test_not_perfect_number_200(): assert is_perfect_number(200) == False","solution":"def is_perfect_number(n): Determines if a given positive integer n is a perfect number. A perfect number is a number that is equal to the sum of its proper divisors (excluding the number itself). :param n: The positive integer to be checked. :return: True if n is a perfect number, False otherwise. # Find all proper divisors of n (excluding the number itself) proper_divisors = [i for i in range(1, n) if n % i == 0] # Sum the proper divisors sum_of_proper_divisors = sum(proper_divisors) # Check if n is equal to the sum of its proper divisors return sum_of_proper_divisors == n"},{"question":"from typing import List def count_coprime_pairs(arr: List[int]) -> int: Returns the number of coprime pairs in the given list of integers. >>> count_coprime_pairs([1, 2, 3, 4]) 5 >>> count_coprime_pairs([2, 4, 6]) 0","solution":"from math import gcd from itertools import combinations def count_coprime_pairs(arr): Returns the number of coprime pairs in the given list of integers. count = 0 for i, j in combinations(range(len(arr)), 2): if gcd(arr[i], arr[j]) == 1: count += 1 return count def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) arr = list(map(int, data[1:])) print(count_coprime_pairs(arr)) if __name__ == \\"__main__\\": main()"},{"question":"def validate_cargo_records(test_cases): Validates the cargo records against the Fibonacci numbers. >>> validate_cargo_records([(2, 1, 1), (3, 2, 3, 4), (4, 0, 1, 1, 2)]) ['YES', 'NO', 'YES'] >>> validate_cargo_records([(2, 1, 2), (3, 4, 5, 6)]) ['YES', 'NO'] >>> validate_cargo_records([(3, 21, 34, 55), (3, 21, 34, 56)]) ['YES', 'NO']","solution":"def is_fibonacci(n, fib_set): Check if a number is in the precomputed set of Fibonacci numbers. return n in fib_set def generate_fibonacci_up_to(max_val): Generate all Fibonacci numbers up to a maximum value and return as a set. fib_set = set() a, b = 0, 1 while a <= max_val: fib_set.add(a) a, b = b, a + b return fib_set def validate_cargo_records(test_cases, max_val=10**9): Validates the cargo records against the Fibonacci numbers. fib_set = generate_fibonacci_up_to(max_val) results = [] for case in test_cases: K, *counts = case if all(is_fibonacci(count, fib_set) for count in counts): results.append('YES') else: results.append('NO') return results"},{"question":"def min_edit_distance(n: int, m: int, A: str, B: str) -> int: Given two strings A and B, find the minimum number of operations required to convert string A into string B. Allowed operations are: 1. Insert a character 2. Remove a character 3. Replace a character Args: n (int): Length of string A m (int): Length of string B A (str): String A of length n B (str): String B of length m Returns: int: Minimum number of operations to transform A into B >>> min_edit_distance(4, 3, \\"abcd\\", \\"acd\\") 1 >>> min_edit_distance(5, 4, \\"abcde\\", \\"abce\\") 1 >>> min_edit_distance(3, 4, \\"abc\\", \\"abcd\\") 1 >>> min_edit_distance(6, 6, \\"kitten\\", \\"sitten\\") 1 >>> min_edit_distance(6, 6, \\"kitten\\", \\"sittes\\") 2 >>> min_edit_distance(7, 5, \\"saturday\\", \\"sunday\\") 3 >>> min_edit_distance(1, 1, \\"a\\", \\"b\\") 1 >>> min_edit_distance(5, 5, \\"abcde\\", \\"fghij\\") 5 >>> min_edit_distance(1, 0, \\"a\\", \\"\\") 1 >>> min_edit_distance(0, 0, \\"\\", \\"\\") 0 >>> min_edit_distance(1, 0, \\"a\\", \\"\\") 1 >>> min_edit_distance(0, 1, \\"\\", \\"a\\") 1 >>> min_edit_distance(1, 1, \\"a\\", \\"a\\") 0 >>> min_edit_distance(2, 1, \\"aa\\", \\"a\\") 1 >>> min_edit_distance(1, 2, \\"a\\", \\"aa\\") 1 >>> min_edit_distance(2, 2, \\"ab\\", \\"ba\\") 2 >>> min_edit_distance(3, 3, \\"abc\\", \\"cba\\") 2","solution":"def min_edit_distance(n, m, A, B): dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(n + 1): for j in range(m + 1): if i == 0: dp[i][j] = j elif j == 0: dp[i][j] = i elif A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = 1 + min(dp[i - 1][j], # Remove dp[i][j - 1], # Insert dp[i - 1][j - 1])# Replace return dp[n][m]"},{"question":"def trainTravelCost(n: int, queries: List[List[int]]) -> List[int]: Returns the cost of traveling between pairs of stations for each query. Args: n (int): The number of stations. queries (List[List[int]]): The list of queries where each query is a pair of integers [i, j]. Returns: List[int]: The list of costs for each respective query. >>> trainTravelCost(5, [[1, 3], [2, 5], [1, 5]]) [2, 3, 4] >>> trainTravelCost(3, [[1, 2], [1, 3], [2, 3]]) [1, 2, 1] >>> trainTravelCost(100, [[1, 100], [50, 51], [25, 75]]) [99, 1, 50] >>> trainTravelCost(10, [[1, 2], [2, 3], [9, 10]]) [1, 1, 1] >>> trainTravelCost(10, [[1, 10], [3, 7], [5, 8], [1, 5]]) [9, 4, 3, 4]","solution":"def trainTravelCost(n, queries): Returns the cost of traveling between pairs of stations for each query. Args: n (int): The number of stations. queries (List[List[int]]): The list of queries where each query is a pair of integers [i, j]. Returns: List[int]: The list of costs for each respective query. costs = [] for i, j in queries: costs.append(abs(j - i)) return costs"},{"question":"def earliest_days(N, M, trips): Determine the earliest day Alex can reach each city. Args: N (int): Number of cities. M (int): Number of road trips. trips (List[Tuple[int, int, int]]): List of road trips, where each trip is represented by a tuple (start, end, day). Returns: List[int]: A list of integers where the i-th integer represents the earliest day on which Alex can visit the i-th city. If a city cannot be reached, output -1 for that city. Examples: >>> earliest_days(4, 4, [(1, 2, 3), (2, 3, 5), (1, 3, 10), (3, 4, 12)]) [0, 3, 5, 12] >>> earliest_days(3, 1, [(1, 2, 4)]) [0, 4, -1] pass def process_input_data(input_data): Process the input data into structured format Args: input_data (str): Input data as a string. Returns: Tuple[int, int, List[Tuple[int, int, int]]]: Returns the number of cities, number of trips, and the list of trips. Examples: >>> process_input_data(\\"4 4n1 2 3n2 3 5n1 3 10n3 4 12\\") (4, 4, [(1, 2, 3), (2, 3, 5), (1, 3, 10), (3, 4, 12)]) pass","solution":"def earliest_days(N, M, trips): from collections import defaultdict, deque # Create a graph where each node points to its neighbors (cities) along with the day cost graph = defaultdict(list) for start, end, day in trips: graph[start].append((end, day)) # Initialize earliest days to reach each city with -1 except the starting city with 0 earliest = [-1] * (N+1) earliest[1] = 0 # Use a deque to perform a BFS queue = deque([1]) while queue: current_city = queue.popleft() for neighbor, day in graph[current_city]: if earliest[current_city] < day and (earliest[neighbor] == -1 or earliest[neighbor] > day): earliest[neighbor] = day queue.append(neighbor) return earliest[1:] # To be used for testing def process_input_data(input_data): lines = input_data.strip().split('n') N, M = map(int, lines[0].split()) trips = [tuple(map(int, line.split())) for line in lines[1:]] return N, M, trips"},{"question":"from typing import List def integer_square_root(x: int) -> int: Returns the integer square root of a non-negative integer x. Uses binary search to find the largest integer y such that y*y <= x. >>> integer_square_root(4) -> 2 >>> integer_square_root(8) -> 2 >>> integer_square_root(0) -> 0 >>> integer_square_root(1) -> 1 def process_test_cases(t: int, test_cases: List[int]) -> List[int]: Processes multiple test cases and returns a list of integer square roots. >>> process_test_cases(3, [4, 8, 16]) -> [2, 2, 4] >>> process_test_cases(2, [0, 1]) -> [0, 1] >>> process_test_cases(1, [999999999999]) -> [999999]","solution":"def integer_square_root(x): Returns the integer square root of a non-negative integer x. Uses binary search to find the largest integer y such that y*y <= x. if x < 2: return x low, high = 1, x // 2 while low <= high: mid = (low + high) // 2 square = mid * mid if square == x: return mid elif square < x: low = mid + 1 else: high = mid - 1 return high def process_test_cases(t, test_cases): Processes multiple test cases and returns a list of integer square roots. results = [integer_square_root(x) for x in test_cases] return results"},{"question":"def min_energy_drinks(n, s, e): Determine the minimum number of energy drinks Alex must consume at the beginning of his hike to complete the trail without his energy falling below 0 at any checkpoint. Parameters: n (int): Number of checkpoints. s (str): Sequence of checkpoints. e (int): Initial energy level. Returns: int: Minimum number of energy drinks required. >>> min_energy_drinks(5, \\"UUDUF\\", 3) 1 >>> min_energy_drinks(3, \\"UDF\\", 2) 0","solution":"def min_energy_drinks(n, s, e): Determine the minimum number of energy drinks Alex must consume at the beginning of his hike to complete the trail without his energy falling below 0 at any checkpoint. Parameters: n (int): Number of checkpoints. s (str): Sequence of checkpoints. e (int): Initial energy level. Returns: int: Minimum number of energy drinks required. min_energy_needed = 0 current_energy = e for checkpoint in s: if checkpoint == 'U': current_energy -= 2 elif checkpoint == 'D': current_energy += 1 if current_energy < min_energy_needed: min_energy_needed = current_energy if min_energy_needed >= 0: return 0 else: return (-min_energy_needed + 4) // 5 # rounding up to the nearest integer # Example Usage # print(min_energy_drinks(5, \\"UUDUF\\", 3)) # output should be 1 # print(min_energy_drinks(3, \\"UDF\\", 2)) # output should be 0"},{"question":"from typing import List def buildings_receiving_sunlight(heights: List[int]) -> int: Determine how many buildings receive direct sunlight given that the sunlight comes from the left. A building receives direct sunlight if there are no taller buildings to its left. Args: heights (List[int]): A list of integers representing the heights of buildings. Returns: int: The number of buildings receiving direct sunlight. Examples: >>> buildings_receiving_sunlight([3, 5, 4, 4, 7, 6, 8, 2, 9]) 5 >>> buildings_receiving_sunlight([10, 6, 9, 8]) 1","solution":"from typing import List def buildings_receiving_sunlight(heights: List[int]) -> int: if not heights: return 0 count = 1 max_height = heights[0] for height in heights[1:]: if height > max_height: count += 1 max_height = height return count"},{"question":"from typing import List def longest_increasing_path(grid: List[List[int]]) -> int: Finds the length of the longest increasing path in the grid. From each cell, you can move either up, down, left, or right to a cell with a higher value. >>> longest_increasing_path([ ... [9, 9, 4], ... [6, 6, 8], ... [2, 1, 1] ... ]) == 4 >>> longest_increasing_path([ ... [3, 4, 5], ... [3, 2, 6], ... [2, 2, 1] ... ]) == 4 >>> longest_increasing_path([ ... [1] ... ]) == 1 >>> longest_increasing_path([ ... [7, 8, 9, 6], ... [8, 7, 6, 5], ... [9, 6, 3, 4], ... [2, 3, 4, 5] ... ]) == 7 >>> longest_increasing_path([]) == 0 >>> longest_increasing_path([ ... [2, 2, 2], ... [2, 2, 2], ... [2, 2, 2] ... ]) == 1 pass","solution":"def longest_increasing_path(grid): if not grid or not grid[0]: return 0 n, m = len(grid), len(grid[0]) directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] cache = [[-1] * m for _ in range(n)] def dfs(x, y): if cache[x][y] != -1: return cache[x][y] maxLength = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] > grid[x][y]: length = 1 + dfs(nx, ny) maxLength = max(maxLength, length) cache[x][y] = maxLength return maxLength maxPath = 0 for i in range(n): for j in range(m): maxPath = max(maxPath, dfs(i, j)) return maxPath"},{"question":"from typing import List def largest_number(arr: List[int]) -> str: Form the largest possible number by arranging the integers in the array. >>> largest_number([10, 2, 9]) == '9210' >>> largest_number([54, 546, 548, 60]) == '6054854654' >>> largest_number([0, 0, 0, 1]) == '1000' >>> largest_number([0, 0, 0]) == '0' >>> largest_number([3, 30, 34, 5, 9]) == '9534330' >>> largest_number([12, 121]) == '12121'","solution":"from functools import cmp_to_key def largest_number(arr): def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Sort the array with the custom comparator sorted_arr = sorted(map(str, arr), key=cmp_to_key(compare)) # Create the largest number by concatenating sorted array elements largest_num = ''.join(sorted_arr) # Handle the case when the result is multiple zeros if largest_num[0] == '0': return '0' else: return largest_num"},{"question":"def summarize_actions(actions, start, end): Summarizes the actions within a specified time range. Parameters: - actions: A list of tuples where each tuple contains a timestamp and an action type. - start: The start of the time range (inclusive). - end: The end of the time range (inclusive). Returns: A dictionary where the keys are the action types and the values are the count of each action type that occurred within the specified time range. from solution import summarize_actions def test_example1(): actions = [ (1, \\"login\\"), (2, \\"view\\"), (2, \\"view\\"), (3, \\"logout\\"), (4, \\"login\\"), (5, \\"view\\") ] start = 2 end = 3 assert summarize_actions(actions, start, end) == {\\"view\\": 2, \\"logout\\": 1} def test_example2(): actions = [ (0, \\"login\\"), (2, \\"view\\"), (4, \\"purchase\\"), (6, \\"logout\\") ] start = 5 end = 7 assert summarize_actions(actions, start, end) == {\\"logout\\": 1} def test_example3(): actions = [ (1, \\"login\\"), (3, \\"view\\"), (5, \\"purchase\\"), (7, \\"login\\") ] start = 8 end = 10 assert summarize_actions(actions, start, end) == {} def test_no_actions_in_range(): actions = [ (1, \\"login\\"), (3, \\"view\\"), (5, \\"purchase\\"), (7, \\"login\\") ] start = 8 end = 10 assert summarize_actions(actions, start, end) == {} def test_actions_at_start_and_end_boundaries(): actions = [ (1, \\"login\\"), (3, \\"view\\"), (5, \\"purchase\\"), (7, \\"login\\"), (8, \\"view\\") ] start = 5 end = 8 assert summarize_actions(actions, start, end) == {\\"purchase\\": 1, \\"login\\": 1, \\"view\\": 1} def test_duplicate_action_types(): actions = [ (1, \\"login\\"), (3, \\"login\\"), (5, \\"purchase\\"), (7, \\"login\\"), (8, \\"login\\") ] start = 1 end = 8 assert summarize_actions(actions, start, end) == {\\"login\\": 4, \\"purchase\\": 1}","solution":"def summarize_actions(actions, start, end): Summarizes the actions within a specified time range. Parameters: - actions: A list of tuples where each tuple contains a timestamp and an action type. - start: The start of the time range (inclusive). - end: The end of the time range (inclusive). Returns: A dictionary where the keys are the action types and the values are the count of each action type that occurred within the specified time range. summary = {} for timestamp, action_type in actions: if start <= timestamp <= end: if action_type in summary: summary[action_type] += 1 else: summary[action_type] = 1 return summary"},{"question":"def maximize_book_value(L: int, n: int, books: List[Tuple[int, int]]) -> int: Help Chloe maximize the total value of books she places on her shelf. Args: L : int : the length of the shelf. n : int : the number of books. books : List[Tuple[int, int]] : a list of tuples where each tuple contains the width and value of a book. Returns: int : the maximum value Chloe can obtain by placing books on the shelf. >>> maximize_book_value(10, 3, [(5, 10), (4, 7), (6, 8)]) 17 >>> maximize_book_value(8, 2, [(3, 8), (2, 6)]) 14 >>> maximize_book_value(15, 5, [(3, 5), (5, 10), (6, 13), (7, 14), (4, 7)]) 30","solution":"def maximize_book_value(L, n, books): dp = [0] * (L + 1) for width, value in books: for j in range(L, width - 1, -1): dp[j] = max(dp[j], dp[j - width] + value) return dp[L]"},{"question":"def remove_comments(text: str) -> str: Remove comments from the given text. Comments begin with '#', '//' or ';' and end at the end of the line. Args: text (str): The input text containing comments. Returns: str: The text with comments removed. Examples: >>> remove_comments(\\"This is some text. # This is a comment\\") 'This is some text.' >>> remove_comments(\\"This is some text. ; This is a comment\\") 'This is some text.' >>> remove_comments(\\"This is some text. // This is a comment\\") 'This is some text.' >>> remove_comments(This is some text. # This is a comment This span // Another comment will be filtered. // Comment here ; Yet another comment) 'This is some text.nThis spannwill be filtered.' pass","solution":"def remove_comments(text): This function removes comments from the input text. Comments begin with '#', '//' or ';' and end at the end of the line. lines = text.splitlines() cleaned_lines = [] for line in lines: min_index = len(line) for delimiter in ['#', '//', ';']: index = line.find(delimiter) if index != -1: min_index = min(min_index, index) cleaned_lines.append(line[:min_index].rstrip()) return 'n'.join(cleaned_lines)"},{"question":"def encodeString(s: str) -> str: Encodes the input string by replacing consecutive repeating characters with the character followed by its count. If a character appears only once, the count is not included. >>> encodeString(\\"aaaabbbccdaa\\") 'a4b3c2da2' >>> encodeString(\\"abcd\\") 'abcd' >>> encodeString(\\"aabbcc\\") 'a2b2c2' >>> encodeString(\\"a\\") 'a' >>> encodeString(\\"\\") '' >>> encodeString(\\"aabbaa\\") 'a2b2a2'","solution":"def encodeString(s): Encodes the input string by replacing consecutive repeating characters with the character followed by its count. If a character appears only once, the count is not included. if not s: return \\"\\" encoded_string = \\"\\" count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: encoded_string += s[i - 1] + (str(count) if count > 1 else \\"\\") count = 1 # Handle the last group of characters encoded_string += s[-1] + (str(count) if count > 1 else \\"\\") return encoded_string"},{"question":"def length_of_longest_substring(s: str) -> int: Finds the length of the longest substring without repeating characters. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: int: The length of the longest substring without repeating characters. Examples: >>> length_of_longest_substring(\\"ababcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"abcdefg\\") 7 >>> length_of_longest_substring(\\"aabaab!bb\\") 3 >>> length_of_longest_substring(\\"a\\") 1 >>> length_of_longest_substring(\\"aa\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"aab\\") 2 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"anviaj\\") 5 >>> length_of_longest_substring(\\"nfpdmpi\\") 5","solution":"def length_of_longest_substring(s): Finds the length of the longest substring without repeating characters. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: int: The length of the longest substring without repeating characters. char_index_map = {} longest = 0 start = 0 for index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = index longest = max(longest, index - start + 1) return longest"},{"question":"def max_total_skill_level(n: int, players: List[Tuple[int, int]]) -> int: Calculates the maximum possible total skill level by assigning each sport to its preferred player. Parameters: n (int): Number of players and sports. players (list of tuple): List containing tuples of (skill level, sport preference) for each player. Returns: int: The maximum possible total skill level. >>> max_total_skill_level(3, [(50, 1), (60, 2), (70, 3)]) 180 >>> max_total_skill_level(5, [(10, 1), (20, 2), (30, 3), (40, 4), (50, 5)]) 150 >>> max_total_skill_level(4, [(35, 1), (25, 2), (45, 3), (55, 4)]) 160","solution":"def max_total_skill_level(n, players): Calculates the maximum possible total skill level by assigning each sport to its preferred player. Parameters: n (int): Number of players and sports. players (list of tuple): List containing tuples of (skill level, sport preference) for each player. Returns: int: The maximum possible total skill level. # Calculate the total skill level by summing up the skill levels of all players total_skill_level = sum(skill for skill, _ in players) return total_skill_level"},{"question":"def hasPath(N, adj, A, B): Determines if there is a path from node A to node B in a directed graph. Parameters: N (int): Number of nodes in the graph. adj (list of list of int): Adjacency list representation of the graph. A (int): Starting node. B (int): Target node. Returns: bool: 1 if there is a path from A to B, otherwise 0. Example: >>> hasPath(4, [[1, 2], [2], [0, 3], []], 0, 3) 1 >>> hasPath(4, [[1, 2], [2], [0], []], 0, 3) 0 >>> hasPath(5, [[1], [2], [3], [4], []], 2, 2) 1 >>> hasPath(5, [[1], [2], [3], [4], []], 0, 1) 1 >>> hasPath(5, [[1], [2], [3], [4], []], 0, 4) 1 >>> hasPath(5, [[1], [2], [3], [], []], 0, 4) 0 # Your code here","solution":"def hasPath(N, adj, A, B): Determines if there is a path from node A to node B in a directed graph. Parameters: N (int): Number of nodes in the graph. adj (list of list of int): Adjacency list representation of the graph. A (int): Starting node. B (int): Target node. Returns: bool: 1 if there is a path from A to B, otherwise 0. def dfs(current, visited): if current == B: return True visited[current] = True for neighbor in adj[current]: if not visited[neighbor]: if dfs(neighbor, visited): return True return False visited = [False] * N return 1 if dfs(A, visited) else 0"},{"question":"def generate_mirrored_sequence(n): Generate the nth mirrored sequence, starting with the smallest possible pair (1, 1). >>> generate_mirrored_sequence(3) [(1, 1), (2, 1), (3, 1)] >>> generate_mirrored_sequence(4) [(1, 1), (2, 1), (3, 1), (4, 1)] pass def solve_mirrored_sequences(test_cases): For each test case in test_cases, generate the mirrored sequence and return as a list of lists. >>> solve_mirrored_sequences([3, 4]) [[(1, 1), (2, 1), (3, 1)], [(1, 1), (2, 1), (3, 1), (4, 1)]] pass","solution":"def generate_mirrored_sequence(n): sequence = [] for b in range(1, n + 1): a = b k = 1 while len(sequence) < n: sequence.append((a, b)) a += b return sequence[:n] def solve_mirrored_sequences(test_cases): results = [] for n in test_cases: results.append(generate_mirrored_sequence(n)) return results"},{"question":"def update_range(arr, i, k, d): Increment the values in the range [i, k] by d. >>> arr = [10, 20, 30, 40, 50] >>> update_range(arr, 2, 4, 10) >>> arr [10, 30, 40, 50, 50] def query_sum(arr, i, k): Calculate the sum of values in the range [i, k]. >>> arr = [10, 30, 40, 50, 50] >>> query_sum(arr, 1, 3) 80 def process_operations(n, q, a, operations): Process a list of operations on the scores array. >>> n = 5 >>> q = 4 >>> a = [10, 20, 30, 40, 50] >>> operations = [ ... [1, 2, 4, 10], ... [2, 1, 3], ... [1, 3, 5, 5], ... [2, 2, 5] ... ] >>> process_operations(n, q, a, operations) [80, 185]","solution":"def update_range(arr, i, k, d): Increment the values in the range [i, k] by d. for idx in range(i-1, k): arr[idx] += d def query_sum(arr, i, k): Calculate the sum of values in the range [i, k]. return sum(arr[i-1:k]) def process_operations(n, q, a, operations): results = [] for op in operations: if op[0] == 1: _, i, k, d = op update_range(a, i, k, d) elif op[0] == 2: _, i, k = op results.append(query_sum(a, i, k)) return results"},{"question":"def total_legs(test_cases): This function calculates the total number of legs in the room for multiple test cases. Each chair has 4 legs and each table has 1 leg. >>> total_legs([(4, 3)]) == [19] >>> total_legs([(5, 1)]) == [21] >>> total_legs([(0, 0)]) == [0] >>> total_legs([(100, 0)]) == [400] >>> total_legs([(0, 100)]) == [100] >>> total_legs([(50, 25)]) == [225]","solution":"def total_legs(test_cases): results = [] for N, M in test_cases: total_chair_legs = N * 4 total_table_legs = M * 1 total_legs = total_chair_legs + total_table_legs results.append(total_legs) return results"},{"question":"def max_concurrent_users(n, times): Determines the maximum number of concurrent users online at any given time. :param n: Number of sessions :param times: List of tuples (start_time, end_time) :return: Maximum number of concurrent users >>> max_concurrent_users(5, [(1, 5), (2, 6), (4, 8), (6, 9), (5, 10)]) == 3 >>> max_concurrent_users(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) == 2 def test_example_1(): assert max_concurrent_users(5, [(1, 5), (2, 6), (4, 8), (6, 9), (5, 10)]) == 3 def test_example_2(): assert max_concurrent_users(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) == 2 def test_all_disjoint_sessions(): assert max_concurrent_users(3, [(1, 2), (3, 4), (5, 6)]) == 1 def test_all_overlapping_sessions(): assert max_concurrent_users(3, [(1, 4), (2, 5), (3, 6)]) == 3 def test_sessions_with_same_time(): assert max_concurrent_users(4, [(1, 2), (1, 2), (1, 2), (1, 2)]) == 4","solution":"def max_concurrent_users(n, times): Determines the maximum number of concurrent users online at any given time. :param n: Number of sessions :param times: List of tuples (start_time, end_time) :return: Maximum number of concurrent users events = [] for start, end in times: events.append((start, 1)) # Event for a user coming online events.append((end, -1)) # Event for a user going offline # Sort events, prioritizing end events in case of tie events.sort(key=lambda x: (x[0], x[1])) max_users = 0 current_users = 0 for event in events: current_users += event[1] max_users = max(max_users, current_users) return max_users"},{"question":"def count_unique_integers(n: int, integers: List[int]) -> Dict[int, int]: Given a list of integers, returns a dictionary with the count of each unique integer. Args: - n: The number of integers - integers: List of integers Returns: - A dictionary with the integer as the key and its count as the value >>> count_unique_integers(5, [4, 2, 4, 5, 2]) {2: 2, 4: 2, 5: 1} >>> count_unique_integers(1, [1]) {1: 1} pass def format_output(counter_dict: Dict[int, int]) -> str: Given a dictionary of integer counts, returns a formatted string in the required output format. Args: - counter_dict: Dictionary with integers as keys and their counts as values Returns: - Formatted string of each integer and its count on a new line >>> format_output({2: 2, 4: 2, 5: 1}) '2 2n4 2n5 1' >>> format_output({1: 1}) '1 1' pass","solution":"def count_unique_integers(n, integers): Given a list of integers, returns a dictionary with the count of each unique integer. Args: - n: The number of integers - integers: List of integers Returns: - A dictionary with the integer as the key and its count as the value from collections import Counter counter = Counter(integers) result = dict(sorted(counter.items())) return result def format_output(counter_dict): Given a dictionary of integer counts, returns a formatted string in the required output format. Args: - counter_dict: Dictionary with integers as keys and their counts as values Returns: - Formatted string of each integer and its count on a new line output = [] for key, count in counter_dict.items(): output.append(f\\"{key} {count}\\") return \\"n\\".join(output)"},{"question":"def min_energy_path(matrix: List[List[int]]) -> int: Calculate the minimum energy path from the top-left corner to the bottom-right corner of a matrix. >>> min_energy_path([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy_path([[1, 2, 3, 4], [4, 3, 2, 1], [1, 1, 1, 1], [2, 3, 4, 1]]) 10 >>> min_energy_path([[1, 2], [1, 1]]) 3 >>> min_energy_path([[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 5 >>> min_energy_path([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 pass","solution":"def min_energy_path(matrix): n = len(matrix) # Create a dp table with the same dimensions as the matrix dp = [[0] * n for _ in range(n)] # Initial position dp[0][0] = matrix[0][0] # Initialize the first row for i in range(1, n): dp[0][i] = dp[0][i-1] + matrix[0][i] # Initialize the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[-1][-1] # Function to read input and output result def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) matrix = [] index = 1 for i in range(n): row = list(map(int, data[index:index + n])) index += n matrix.append(row) print(min_energy_path(matrix)) if __name__ == \\"__main__\\": main()"},{"question":"def process_logs(n: int, logs: List[str]): Processes the log messages to identify messages by user 1 between specific times and messages containing the keyword 'urgent'. Args: n (int): Number of messages in the log. logs (List[str]): List of message strings in the format 'YYYY-MM-DDTHH:MM:SS userID message_content'. Returns: None. Prints the required messages as described. Example: >>> process_logs(5, [ ... \\"2023-04-05T12:15:30 1 Meeting at 1 PM\\", ... \\"2023-04-05T14:22:30 1 Project deadline tomorrow\\", ... \\"2023-04-05T12:45:00 2 urgent task need assistance\\", ... \\"2023-04-05T13:59:59 1 Lunch break is over\\", ... \\"2023-04-05T12:05:30 1 Need reply urgently\\" ... ]) Messages by User 1 between 12:00:00 and 13:00:00: 2023-04-05T12:15:30 1 Meeting at 1 PM Messages containing 'urgent': 2023-04-05T12:05:30 1 Need reply urgently 2023-04-05T12:45:00 2 urgent task need assistance # Example test cases: def test_no_logs(): n = 0 logs = [] process_logs(n, logs) def test_messages_by_user_1_at_noon(): n = 2 logs = [ \\"2023-04-05T12:15:30 1 Meeting at 1 PM\\", \\"2023-04-05T13:15:30 1 Project deadline tomorrow\\", ] process_logs(n, logs) def test_messages_containing_urgent(): n = 3 logs = [ \\"2023-04-05T10:15:30 1 Need reply urgently\\", \\"2023-04-05T12:45:00 2 urgent task need assistance\\", \\"2023-04-05T14:22:30 1 Project deadline tomorrow\\", ] process_logs(n, logs) def test_combined_conditions(): n = 5 logs = [ \\"2023-04-05T12:15:30 1 Meeting at 1 PM\\", \\"2023-04-05T14:22:30 1 Project deadline tomorrow\\", \\"2023-04-05T12:45:00 2 urgent task need assistance\\", \\"2023-04-05T13:59:59 1 Lunch break is over\\", \\"2023-04-05T12:05:30 1 Need reply urgently\\" ] process_logs(n, logs)","solution":"def process_logs(n, logs): user1_messages = [] urgent_messages = [] for log in logs: timestamp, user_id, *message_content = log.split(' ') time = timestamp.split('T')[1] user_id = int(user_id) message_content = ' '.join(message_content) if user_id == 1 and \\"12:00:00\\" <= time < \\"13:00:00\\": user1_messages.append(log) if \\"urgent\\" in message_content: urgent_messages.append(log) print(\\"Messages by User 1 between 12:00:00 and 13:00:00:\\") for message in user1_messages: print(message) print(\\"Messages containing 'urgent':\\") for message in urgent_messages: print(message)"},{"question":"def min_removals_to_make_valid_brackets(s: str) -> int: Returns the minimum number of characters that should be removed to make the bracket sequence valid. >>> min_removals_to_make_valid_brackets(\\"(()))\\") 1 >>> min_removals_to_make_valid_brackets(\\"((())\\") 1 >>> min_removals_to_make_valid_brackets(\\"((((\\") 4 >>> min_removals_to_make_valid_brackets(\\"))))\\") 4 >>> min_removals_to_make_valid_brackets(\\"()()((())\\") 1 >>> min_removals_to_make_valid_brackets(\\"((()())(()))\\") 0 >>> min_removals_to_make_valid_brackets(\\"\\") 0 >>> min_removals_to_make_valid_brackets(\\"()()\\") 0 >>> min_removals_to_make_valid_brackets(\\"(())\\") 0","solution":"def min_removals_to_make_valid_brackets(s): Returns the minimum number of characters that should be removed to make the bracket sequence valid. open_count = 0 close_count = 0 # Traverse the string to count invalid opening and closing brackets for char in s: if char == '(': open_count += 1 elif char == ')': if open_count > 0: open_count -= 1 else: close_count += 1 # The total invalid brackets are the sum of invalid opening and closing brackets return open_count + close_count"},{"question":"def find_pairs(nums, target): Write a function that receives a list of integers and a target sum and finds all unique pairs of elements in the list that sum up to the target. Each pair should be sorted in ascending order, and the list of pairs should be returned in lexicographical ordering. >>> find_pairs([2, 4, 3, 5, 7, 8, 1, 9], 10) [[1, 9], [2, 8], [3, 7]] >>> find_pairs([3, 0, -3, 4, -1, 2], 1) [[-1, 2], [-3, 4]] >>> find_pairs([1, 2, 3, 4, 5], 8) [(3, 5)] >>> find_pairs([1, 1, 1, 1], 2) [(1, 1)] >>> find_pairs([0, 0, 0, 0], 0) [(0, 0)]","solution":"def find_pairs(nums, target): This function takes a list of integers and a target sum, and finds all unique pairs of elements in the list that sum up to the target. Each pair is sorted in ascending order, and the list of pairs is returned in lexicographical order. nums.sort() pairs = set() seen = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return sorted(pairs)"},{"question":"def min_construction_cost(N: int, M: int, lines: List[Tuple[int, int, int]]) -> int: Compute the minimum construction cost to connect all stations with given number of stations and direct rail lines. >>> min_construction_cost(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 2), (3, 4, 1), (2, 4, 8)]) 8 >>> min_construction_cost(3, 3, [(1, 2, 1), (1, 3, 4), (2, 3, 2)]) 3 >>> min_construction_cost(1, 0, []) 0 >>> min_construction_cost(2, 1, [(1, 2, 10)]) 10 >>> min_construction_cost(4, 4, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1)]) 3 >>> edges = [(i, i + 1, 1) for i in range(1, 1000)] + [(1, 1000, 10000)] >>> min_construction_cost(1000, 1000, edges) 999","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(N, edges): edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(N): parent.append(node) rank.append(0) result = [] e = 0 i = 0 while e < N - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u-1) y = find(parent, v-1) if x != y: e += 1 result.append((u, v, w)) union(parent, rank, x, y) min_cost = sum([w for u, v, w in result]) return min_cost def min_construction_cost(N, M, lines): return kruskal(N, lines)"},{"question":"from typing import List, Tuple def findTasksOrder(N: int, dependencies: List[Tuple[int, int]]) -> List[int]: Finds the order in which a collection of tasks needs to be completed given some dependencies. Parameters: N (int): Number of tasks. dependencies (list of tuples): Each tuple (a, b) means that task b must be completed before task a. Returns: list: A list of integers representing the order in which the tasks should be completed. If there's no valid order, return an empty list. >>> findTasksOrder(6, [(5, 2), (5, 0), (4, 0), (4, 1), (2, 3), (3, 1)]) [5, 4, 2, 3, 1, 0] >>> findTasksOrder(4, [(1, 0), (2, 1), (3, 2)]) [0, 1, 2, 3] >>> findTasksOrder(4, [(1, 0), (2, 1), (3, 2), (1, 3)]) [] >>> findTasksOrder(3, []) [0, 1, 2] >>> findTasksOrder(1, []) [0] >>> findTasksOrder(2, [(1, 0)]) [0, 1]","solution":"from collections import defaultdict, deque def findTasksOrder(N, dependencies): Finds the order in which tasks should be completed given dependencies. Parameters: N (int): Number of tasks. dependencies (list of tuples): List of (a, b) tuples, where task b must be completed before task a. Returns: list: A list of task numbers in the order they should be completed, or an empty list if not possible. # Create a graph and indegree count graph = defaultdict(list) indegree = [0] * N # Populate the graph and indegree count for a, b in dependencies: graph[b].append(a) indegree[a] += 1 # Initialize the queue with tasks that have no prerequisites queue = deque([i for i in range(N) if indegree[i] == 0]) order = [] while queue: task = queue.popleft() order.append(task) for neighbor in graph[task]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # If all tasks are not included, there is a cycle if len(order) != N: return [] return order"},{"question":"def max_negative_subarray_sums(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: You are given a list of integers, and you need to perform a sequence of operations on this list. Each operation specifies a subarray of the list, and you must find the sum of the maximum number of non-overlapping subarrays with negative sums within that subarray. >>> max_negative_subarray_sums(5, 1, [1, -2, 3, -4, 5], [(1, 5)]) [-6] >>> max_negative_subarray_sums(5, 3, [1, -2, 3, -4, 5], [(1, 5), (2, 4), (3, 5)]) [-6, -6, -4] >>> max_negative_subarray_sums(4, 2, [1, 2, 3, 4], [(1, 4), (2, 3)]) [0, 0] >>> max_negative_subarray_sums(4, 2, [-1, -2, -3, -4], [(1, 4), (2, 3)]) [-10, -5] >>> max_negative_subarray_sums(6, 1, [1, -2, -3, 3, -4, 5], [(1, 6)]) [-9]","solution":"def max_negative_subarray_sums(n, q, arr, queries): results = [] for l, r in queries: subarray = arr[l-1:r] negative_subarrays = [] current_sum = 0 for num in subarray: if num < 0: negative_subarrays.append(num) results.append(sum(negative_subarrays)) return results"},{"question":"def least_repeating_number(arr): Given an integer array of positive integers, return an integer that appears the least number of times, but is greater than 1 (if any exists). If all numbers are unique or if no such number exists, return -1. >>> least_repeating_number([4, 5, 2, 4, 3, 2, 6, 5, 2]) 4 >>> least_repeating_number([1, 2, 3, 4, 5]) -1 >>> least_repeating_number([2, 2, 3, 3, 4, 4]) 2","solution":"def least_repeating_number(arr): from collections import Counter # Count the frequency of each number in the array freq = Counter(arr) # Filter out elements that are greater than 1 and appear more than once repeating_numbers = {num: count for num, count in freq.items() if num > 1 and count > 1} if not repeating_numbers: return -1 # Find the number with the least frequency least_count = min(repeating_numbers.values()) candidates = [num for num, count in repeating_numbers.items() if count == least_count] # Return the smallest number among the candidates return min(candidates) if candidates else -1"},{"question":"from typing import List, Tuple def max_steal(val: List[int]) -> int: Given an array val where val[i] is the amount of valuable in the i-th house. Returns the maximum amount of valuables the thieves can steal without triggering the alarm. >>> max_steal([2, 7, 9, 3, 1]) 12 >>> max_steal([1, 2, 3, 1]) 4 >>> max_steal([10, 15, 20]) 30 pass def process_test_cases(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases and each test case is a tuple of (n, val) where val is an array of valuables. Returns a list of integers representing the maximum amount of valuables the thieves can steal for each test case. >>> process_test_cases(3, [(5, [2, 7, 9, 3, 1]), (4, [1, 2, 3, 1]), (3, [10, 15, 20])]) [12, 4, 30] pass","solution":"def max_steal(val): Given an array val where val[i] is the amount of valuable in the i-th house. Returns the maximum amount of valuables the thieves can steal without triggering the alarm. n = len(val) if n == 0: return 0 if n == 1: return val[0] dp = [0] * n dp[0] = val[0] dp[1] = max(val[0], val[1]) for i in range(2, n): dp[i] = max(val[i] + dp[i - 2], dp[i - 1]) return dp[-1] def process_test_cases(t, test_cases): results = [] for i in range(t): n, val = test_cases[i] results.append(max_steal(val)) return results"},{"question":"def is_anagram_of_palindrome(s: str) -> str: Determines if the given string is an anagram of a palindrome. Args: s (str): The input string. Returns: str: \\"Yes\\" if the string can be rearranged to form a palindrome, otherwise \\"No\\". Examples: >>> is_anagram_of_palindrome(\\"carrace\\") 'Yes' >>> is_anagram_of_palindrome(\\"hello\\") 'No'","solution":"def is_anagram_of_palindrome(s): Determines if the given string is an anagram of a palindrome. Args: s (str): The input string. Returns: str: \\"Yes\\" if the string can be rearranged to form a palindrome, otherwise \\"No\\". from collections import Counter char_count = Counter(s) odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: return \\"No\\" return \\"Yes\\""},{"question":"from typing import List def min_distinct_chars(S: str) -> int: Determine the minimum number of distinct characters that can remain in the string after performing the operations. >>> min_distinct_chars(\\"abacbc\\") == 1 >>> min_distinct_chars(\\"aabbcc\\") == 1 >>> min_distinct_chars(\\"abcabc\\") == 1 >>> min_distinct_chars(\\"a\\") == 1 >>> min_distinct_chars(\\"aaaa\\") == 1 pass def process_input(T: int, test_cases: List[str]) -> List[int]: Processes the input for the given number of test cases and returns the results. >>> process_input(3, [\\"abacbc\\", \\"aabbcc\\", \\"abcabc\\"]) == [1, 1, 1] >>> process_input(1, [\\"a\\"]) == [1] >>> process_input(2, [\\"aaaa\\", \\"bbbb\\"]) == [1, 1] pass","solution":"from collections import Counter def min_distinct_chars(S): Returns the minimum number of distinct characters that can remain in the string after performing the given operations. char_counts = Counter(S) # If there is at least one character, we can always reduce the string to having only one distinct character. return 1 def process_input(T, test_cases): results = [] for S in test_cases: results.append(min_distinct_chars(S)) return results"},{"question":"from typing import List def simulate_deque(operations: List[str]) -> List: Simulate a deque (double-ended queue) and perform various operations on it. The operations you need to handle are: - push_front(x): Add x to the front of the deque. - push_back(x): Add x to the back of the deque. - pop_front(): Remove and print the front element of the deque. If the deque is empty, print \\"EMPTY\\". - pop_back(): Remove and print the back element of the deque. If the deque is empty, print \\"EMPTY\\". Constraints: - 1 ≤ q ≤ 100000 - 1 ≤ x ≤ 1000 (for the push operations) Input: The first line contains q, the number of operations. Each of the next q lines contains one of the four possible operations. Output: For each pop operation, print the value removed from the deque or \\"EMPTY\\" if it's empty. Examples: >>> simulate_deque([\\"push_back 1\\", \\"push_back 2\\", \\"push_front 3\\", \\"pop_back\\", \\"pop_front\\", \\"push_back 4\\", \\"pop_back\\", \\"pop_front\\"]) [2, 3, 4, 1] >>> simulate_deque([\\"pop_front\\", \\"pop_back\\"]) [\\"EMPTY\\", \\"EMPTY\\"] >>> simulate_deque([\\"push_back 10\\", \\"push_front 20\\", \\"push_back 30\\", \\"pop_front\\", \\"pop_back\\", \\"pop_front\\", \\"pop_back\\"]) [20, 30, 10, \\"EMPTY\\"] >>> simulate_deque([\\"push_back 100\\", \\"pop_back\\", \\"push_front 200\\", \\"pop_front\\"]) [100, 200]","solution":"from collections import deque def simulate_deque(operations): dq = deque() result = [] for operation in operations: op = operation.split() if op[0] == 'push_front': dq.appendleft(int(op[1])) elif op[0] == 'push_back': dq.append(int(op[1])) elif op[0] == 'pop_front': if dq: result.append(dq.popleft()) else: result.append(\\"EMPTY\\") elif op[0] == 'pop_back': if dq: result.append(dq.pop()) else: result.append(\\"EMPTY\\") return result"},{"question":"def can_permute_palindrome(s: str) -> str: Check if any permutation of the input string can form a palindrome. >>> can_permute_palindrome(\\"Tact Coa\\") \\"YES\\" >>> can_permute_palindrome(\\"Hello World\\") \\"NO\\" >>> can_permute_palindrome(\\"\\") \\"YES\\" >>> can_permute_palindrome(\\"a\\") \\"YES\\" >>> can_permute_palindrome(\\"A\\") \\"YES\\" >>> can_permute_palindrome(\\"a!@# a@#\\") \\"YES\\" >>> can_permute_palindrome(\\"12321!!\\") \\"YES\\" >>> can_permute_palindrome(\\"racecar\\") \\"YES\\" >>> can_permute_palindrome(\\"Taco cat\\") \\"YES\\" >>> can_permute_palindrome(\\"ab\\") \\"NO\\" >>> can_permute_palindrome(\\"Aa\\") \\"YES\\"","solution":"def can_permute_palindrome(s): Check if any permutation of the input string can form a palindrome. from collections import Counter import string # Remove spaces and convert string to lower case sanitized = ''.join([char.lower() for char in s if char in string.ascii_letters]) # Count the frequency of each character char_count = Counter(sanitized) # Count how many characters have odd counts odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can form a palindrome if it has at most one character with an odd frequency return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def max_subarray_sum(L: int, parcels: List[int]) -> int: Returns the maximum load (sum of weights) of the heaviest contiguous subarray. >>> max_subarray_sum(5, [-1, 3, -2, 5, -6]) 6 >>> max_subarray_sum(5, [1, 2, 3, 4, 5]) 15 >>> max_subarray_sum(5, [-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum(7, [2, -8, 3, -2, 4, -10, 1]) 5 >>> max_subarray_sum(1, [7]) 7 >>> max_subarray_sum(1, [-7]) -7 >>> max_subarray_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_subarray_sum(6, [-100, -200, -300, 1, 2, 3]) 6 >>> max_subarray_sum(4, [1, 1, 1, 1]) 4 # Your code here","solution":"def max_subarray_sum(L, parcels): Returns the maximum load (sum of weights) of the heaviest contiguous subarray. max_so_far = parcels[0] current_max = parcels[0] for i in range(1, L): current_max = max(parcels[i], current_max + parcels[i]) max_so_far = max(max_so_far, current_max) return max_so_far # Example usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() L = int(data[0]) parcels = list(map(int, data[1:])) print(max_subarray_sum(L, parcels))"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: This function takes a string s and returns the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"abcba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aaaaa\\") 5 >>> length_of_longest_substring_two_distinct(\\"\\") 0 >>> length_of_longest_substring_two_distinct(\\"aabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"abcdef\\") 2 >>> length_of_longest_substring_two_distinct(\\"a\\" * 50000 + \\"b\\" * 50000) 100000 from typing import List","solution":"def length_of_longest_substring_two_distinct(s): This function takes a string s and returns the length of the longest substring that contains at most two distinct characters. if len(s) == 0: return 0 # Dictionary to store the last occurrence of each character last_occurrence = {} max_length = 0 start = 0 for end in range(len(s)): last_occurrence[s[end]] = end if len(last_occurrence) > 2: # Find the character with the smallest last occurrence del_idx = min(last_occurrence.values()) del last_occurrence[s[del_idx]] start = del_idx + 1 max_length = max(max_length, end - start + 1) return max_length"},{"question":"from typing import List def find_min_travel_distance(n: int, distance_matrix: List[List[int]]) -> int: Determine the shortest possible route that allows a delivery truck to visit every city exactly once and return to the starting point. Args: n (int): The number of cities. distance_matrix (List[List[int]]): The distance matrix where each element represents the distance between two cities. Returns: int: The minimum travel distance for the delivery truck to complete the route. Example: >>> find_min_travel_distance(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 pass def test_example_case(): n = 4 distance_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert find_min_travel_distance(n, distance_matrix) == 80 def test_two_cities(): n = 2 distance_matrix = [ [0, 5], [5, 0] ] assert find_min_travel_distance(n, distance_matrix) == 10 def test_three_cities(): n = 3 distance_matrix = [ [0, 1, 2], [1, 0, 1], [2, 1, 0] ] assert find_min_travel_distance(n, distance_matrix) == 4 def test_same_distance(): n = 4 distance_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert find_min_travel_distance(n, distance_matrix) == 4 def test_large_distances(): n = 4 distance_matrix = [ [0, 100, 200, 300], [100, 0, 400, 500], [200, 400, 0, 600], [300, 500, 600, 0] ] assert find_min_travel_distance(n, distance_matrix) == 1400","solution":"from itertools import permutations def find_min_travel_distance(n, distance_matrix): cities = range(n) min_distance = float('inf') for perm in permutations(cities[1:]): current_distance = 0 current_city = 0 for next_city in perm: current_distance += distance_matrix[current_city][next_city] current_city = next_city current_distance += distance_matrix[current_city][0] min_distance = min(min_distance, current_distance) return min_distance # The function expects an integer n and a square matrix (list of lists) distance_matrix as inputs # Example usage: # n = 4 # distance_matrix = [ # [0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0] # ] # print(find_min_travel_distance(n, distance_matrix)) # Output: 80"},{"question":"def find_marked_number(N, X): Function to determine the number marked by the cat on the door when the mouse visits the X-th door counting from the first. Parameters: N (int): The total number of doors X (int): The X-th door from the beginning Returns: int: The number marked on the X-th door pass def solve(test_cases): This function accepts a list of test cases and provides the result for each test case. Parameters: test_cases (list): List of tuples containing N and X for each test case Returns: list: List of results for each test case pass","solution":"def find_marked_number(N, X): Function to determine the number marked by the cat on the door when the mouse visits the X-th door counting from the first. Parameters: N (int): The total number of doors X (int): The X-th door from the beginning Returns: int: The number marked on the X-th door return X def solve(test_cases): This function accepts a list of test cases and provides the result for each test case. Parameters: test_cases (list): List of tuples containing N and X for each test case Returns: list: List of results for each test case results = [] for N, X in test_cases: results.append(find_marked_number(N, X)) return results"},{"question":"def isValidIPv4(ip: str) -> bool: Write a function isValidIPv4 that takes a string as input and returns true if the string is a valid IPv4 address, and false otherwise. A valid IPv4 address is an address that follows the format \`x.x.x.x\`, where \`x\` is a number between 0 and 255. Leading zeros are not allowed for any of the numbers. >>> isValidIPv4(\\"192.168.1.1\\") == True >>> isValidIPv4(\\"255.255.255.255\\") == True >>> isValidIPv4(\\"0.0.0.0\\") == True >>> isValidIPv4(\\"172.16.254.1\\") == True >>> isValidIPv4(\\"256.100.50.0\\") == False >>> isValidIPv4(\\"192.168.01.1\\") == False >>> isValidIPv4(\\"192.168.1\\") == False >>> isValidIPv4(\\"192.168.1.500\\") == False >>> isValidIPv4(\\"192.168.1.-1\\") == False >>> isValidIPv4(\\"192.168.1.a\\") == False >>> isValidIPv4(\\"192.168.1.1.1\\") == False >>> isValidIPv4(\\"192.168..1\\") == False >>> isValidIPv4(\\".192.168.1.1\\") == False >>> isValidIPv4(\\"192.168.1.\\") == False >>> isValidIPv4(\\"01.2.3.4\\") == False >>> isValidIPv4(\\"0.0.00.0\\") == False >>> isValidIPv4(\\"\\") == False","solution":"def isValidIPv4(ip: str) -> bool: # Split the input string by '.' parts = ip.split('.') # Check if there are exactly four parts if len(parts) != 4: return False for part in parts: # Check if part is a digit and doesn't have leading zeros if not part.isdigit() or (len(part) > 1 and part[0] == '0'): return False # Convert part to integer and check if it's between 0 and 255 if not 0 <= int(part) <= 255: return False return True"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): Determine if the tree has a root-to-leaf path that sums up to the target sum. Args: root (TreeNode): The root node of the binary tree. target_sum (int): The target sum to check for. Returns: bool: True if there's a path that sums up to target_sum, False otherwise. >>> input_str = \\"5 4 8 11 null 13 4 7 2 null null null 1\\" >>> target_sum = 22 >>> level_order = [int(x) if x != \\"null\\" else None for x in input_str.split()] >>> root = build_tree(level_order) >>> has_path_sum(root, target_sum) True >>> input_str = \\"1 2 3\\" >>> target_sum = 5 >>> level_order = [int(x) if x != \\"null\\" else None for x in input_str.split()] >>> root = build_tree(level_order) >>> has_path_sum(root, target_sum) False pass def build_tree(level_order): Builds a binary tree from a level-order list. Args: level_order (list): List of integers representing tree nodes in level-order traversal. \`None\` indicates absence of node. Returns: TreeNode: The root node of the constructed binary tree. pass def main(input_str, target_sum): Main function to check if there's a root-to-leaf path with the specified sum in the binary tree. Args: input_str (str): Space-separated string representing level-order traversal of the binary tree. target_sum (int): The target sum to check for. Returns: bool: True if such a path exists, False otherwise. pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def has_path_sum(root, target_sum): if not root: return False if not root.left and not root.right and root.val == target_sum: return True return (has_path_sum(root.left, target_sum - root.val) or has_path_sum(root.right, target_sum - root.val)) def build_tree(level_order): if not level_order: return None root = TreeNode(level_order[0]) queue = [root] i = 1 while queue and i < len(level_order): node = queue.pop(0) if level_order[i] is not None: node.left = TreeNode(level_order[i]) queue.append(node.left) i += 1 if i < len(level_order) and level_order[i] is not None: node.right = TreeNode(level_order[i]) queue.append(node.right) i += 1 return root def main(input_str, target_sum): # Convert input string to level-order list level_order = [int(x) if x != \\"null\\" else None for x in input_str.split()] root = build_tree(level_order) return has_path_sum(root, target_sum)"},{"question":"def can_guardian_capture(pos1: str, pos2: str) -> str: Determines if one Guardian can capture the other based on their positions. Arguments: pos1 -- a string in the format of a letter (a-h) and a number (1-8) representing the position of the first Guardian. pos2 -- a string in the same format representing the position of the second Guardian. Returns: \\"YES\\" if one Guardian can capture the other, otherwise \\"NO\\". Examples: >>> can_guardian_capture(\\"a1\\", \\"h8\\") \\"YES\\" >>> can_guardian_capture(\\"c3\\", \\"d5\\") \\"NO\\" >>> can_guardian_capture(\\"b2\\", \\"b8\\") \\"YES\\"","solution":"def can_guardian_capture(pos1, pos2): Determines if one Guardian can capture the other based on their positions. Arguments: pos1 -- a string in the format of a letter (a-h) and a number (1-8) representing the position of the first Guardian. pos2 -- a string in the same format representing the position of the second Guardian. Returns: \\"YES\\" if one Guardian can capture the other, otherwise \\"NO\\". col1, row1 = pos1[0], int(pos1[1]) col2, row2 = pos2[0], int(pos2[1]) col_diff = abs(ord(col1) - ord(col2)) row_diff = abs(row1 - row2) if col1 == col2 or row1 == row2 or col_diff == row_diff: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List def can_form_chirp_sequences(chirp_sequences: List[str]) -> str: Determine if chirp sequences can be derived from one primary sequence with one character removed from each. >>> can_form_chirp_sequences([\\"abcd\\", \\"abc\\", \\"abd\\"]) \\"YES\\" >>> can_form_chirp_sequences([\\"abcd\\", \\"abc\\", \\"ab\\", \\"acd\\"]) \\"NO\\"","solution":"from collections import Counter def can_form_chirp_sequences(chirp_sequences): # Finding the potential base sequence, the longest sequence in the list base_sequence = max(chirp_sequences, key=len) base_length = len(base_sequence) # Check each sequence is derivable from the base sequence for seq in chirp_sequences: if len(seq) == base_length: continue if len(seq) != base_length - 1: return \\"NO\\" base_count = Counter(base_sequence) seq_count = Counter(seq) difference = base_count - seq_count # The difference should be exactly one character if len(difference) != 1 or list(difference.values())[0] != 1: return \\"NO\\" return \\"YES\\""},{"question":"def firstUniqChar(s: str) -> int: Given a string s containing only lowercase English letters, determine the index of the first non-repeating character. If there is no non-repeating character, return -1. >>> firstUniqChar(\\"leetcode\\") 0 >>> firstUniqChar(\\"loveleetcode\\") 2 >>> firstUniqChar(\\"aabb\\") -1","solution":"def firstUniqChar(s): Returns the index of the first non-repeating character in the string s. If there is no non-repeating character, return -1. # Create a dictionary to store character frequencies char_count = {} # Populate the dictionary with the count of each character in the string for char in s: char_count[char] = char_count.get(char, 0) + 1 # Iterate through the string again and return the index of the first non-repeating character for index, char in enumerate(s): if char_count[char] == 1: return index # If no non-repeating character is found, return -1 return -1"},{"question":"from typing import List def shortest_path(n: int, m: int, l: int, grid: List[List[int]]) -> int: Determines the length of the shortest path in a grid from top-left to bottom-right corner without exceeding the given battery limit. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid l (int): battery limit grid (List[List[int]]): a 2D list representing the grid where 0 is an empty cell and 1 is an obstacle Returns: int: the length of the shortest path or -1 if not possible within the battery limit Examples: >>> shortest_path(4, 4, 6, [ ... [0, 0, 0, 0], ... [0, 1, 1, 0], ... [0, 0, 0, 1], ... [1, 1, 0, 0] ... ]) == 6 >>> shortest_path(3, 3, 4, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == 4 >>> shortest_path(3, 3, 2, [ ... [0, 1, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) == -1 pass","solution":"from collections import deque def shortest_path(n, m, l, grid): Determines the length of the shortest path in a grid from top-left to bottom-right corner without exceeding the given battery limit. if l < 2: return -1 # Initialize directions for right and down movements directions = [(0, 1), (1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() if steps > l: continue # If we reached the bottom-right corner if r == n-1 and c == m-1: return steps # Explore the neighboring cells for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 # If it is not possible to reach the bottom-right corner within the battery limit"},{"question":"def number_of_cycles(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Given a directed graph G = (V, E) with n vertices and m edges, a path in G is defined as a sequence of vertices (v1, v2, ..., vk) such that for each i from 1 to k-1, there is a directed edge from vi to vi+1 in G. A path is considered a cycle if v1 = vk and all vertices v1, v2, ..., vk-1 are distinct. Let f(G) be the number of paths in G that form cycles. Write a program to calculate f(G) modulo 1,000,000,007. Parameters: n (int): Number of vertices m (int): Number of edges edges (List[Tuple[int, int]]): List of directed edges (u, v) Returns: int: The number of paths that form cycles, modulo 1,000,000,007. Examples: >>> number_of_cycles(3, 3, [(1, 2), (2, 3), (3, 1)]) 1 >>> number_of_cycles(4, 4, [(1, 2), (2, 3), (3, 4), (4, 2)]) 1","solution":"def number_of_cycles(n, m, edges): MOD = 1_000_000_007 def dfs(graph, start, visited, stack): visited[start] = True stack[start] = True count = 0 for neighbor in graph[start]: if not visited[neighbor]: count += dfs(graph, neighbor, visited, stack) elif stack[neighbor]: count += 1 stack[start] = False return count from collections import defaultdict graph = defaultdict(list) for u, v in edges: graph[u].append(v) visited = [False] * (n + 1) stack = [False] * (n + 1) cycle_count = 0 for i in range(1, n + 1): if not visited[i]: cycle_count += dfs(graph, i, visited, stack) return cycle_count % MOD # Sample function call # n = 3 # m = 3 # edges = [(1, 2), (2, 3), (3, 1)] # print(number_of_cycles(n, m, edges)) # Output: 1"},{"question":"from typing import List def max_length(strings_list: List[str]) -> int: Given a list of strings, return the length of the longest string that can be constructed by concatenating strings from the list such that no duplicate characters are present in the resultant string. >>> max_length([\\"un\\", \\"iq\\", \\"ue\\"]) 4 >>> max_length([\\"cha\\",\\"r\\",\\"act\\",\\"ers\\"]) 6 >>> max_length([\\"abcdefghijklmnopqrstuvwxyz\\"]) 26","solution":"from itertools import combinations def max_length(strings_list): def has_unique_chars(s): return len(set(s)) == len(s) def all_combinations(strings_list): for i in range(len(strings_list) + 1): for combo in combinations(strings_list, i): yield ''.join(combo) maximum_length = 0 for combo_string in all_combinations(strings_list): if has_unique_chars(combo_string): maximum_length = max(maximum_length, len(combo_string)) return maximum_length"},{"question":"def uniqueCharacters(s: str) -> int: Returns the count of unique characters in the string, ignoring spaces and case sensitivity. >>> uniqueCharacters('Hello World') 7 >>> uniqueCharacters('Coding is fun!') 10 >>> uniqueCharacters('') 0 >>> uniqueCharacters(' ') 0 >>> uniqueCharacters('AaBbCc') 3 >>> uniqueCharacters('123 ABC abc') 6 >>> uniqueCharacters('abcdefghij') 10 >>> uniqueCharacters('aa bb cc') 3 >>> uniqueCharacters('!@#') 4","solution":"def uniqueCharacters(s): Returns the count of unique characters in the string, ignoring spaces and case sensitivity. s = s.replace(\\" \\", \\"\\").lower() return len(set(s))"},{"question":"from typing import List def trap_rainwater(heights: List[int]) -> int: Calculate the amount of rainwater that can be trapped between buildings after it rains. Args: heights (List[int]): A list of non-negative integers representing the heights of the buildings. Returns: int: The total amount of trapped water. >>> trap_rainwater([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rainwater([4, 2, 0, 3, 2, 5]) 9 # Your code here def calculate_trapped_water(test_cases: List[str]) -> List[int]: Given a list of test cases containing heights of buildings, calculate the trapped water for each test case. Args: test_cases (List[str]): A list of strings, each containing space-separated integers representing the heights of buildings. Returns: List[int]: A list of integers where each integer represents the total amount of trapped water for the corresponding test case. >>> calculate_trapped_water([\\"0 1 0 2 1 0 1 3 2 1 2 1\\", \\"4 2 0 3 2 5\\"]) [6, 9] # Your code here # Unit Tests def test_example_cases(): input_data = [ \\"0 1 0 2 1 0 1 3 2 1 2 1\\", \\"4 2 0 3 2 5\\" ] expected_output = [6, 9] assert calculate_trapped_water(input_data) == expected_output def test_all_same_height(): input_data = [ \\"3 3 3 3 3\\" ] expected_output = [0] assert calculate_trapped_water(input_data) == expected_output def test_descending_height(): input_data = [ \\"5 4 3 2 1\\" ] expected_output = [0] assert calculate_trapped_water(input_data) == expected_output def test_ascending_height(): input_data = [ \\"1 2 3 4 5\\" ] expected_output = [0] assert calculate_trapped_water(input_data) == expected_output def test_peaks_and_valleys(): input_data = [ \\"2 1 2\\" ] expected_output = [1] assert calculate_trapped_water(input_data) == expected_output input_data = [ \\"3 0 2 0 4\\" ] expected_output = [7] assert calculate_trapped_water(input_data) == expected_output def test_single_building(): input_data = [ \\"5\\" ] expected_output = [0] assert calculate_trapped_water(input_data) == expected_output def test_no_building(): input_data = [ \\"\\" ] expected_output = [0] assert calculate_trapped_water(input_data) == expected_output","solution":"def trap_rainwater(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) total_water = 0 for i in range(n): total_water += min(left_max[i], right_max[i]) - heights[i] return total_water def calculate_trapped_water(test_cases): results = [] for heights in test_cases: heights = list(map(int, heights.strip().split())) results.append(trap_rainwater(heights)) return results"},{"question":"import heapq from typing import List def min_cost_to_connect_ropes(ropes: List[int]) -> int: Calculate the minimum cost to connect all ropes into one single rope. Parameters: ropes (List[int]): A list of integers where each integer represents the length of a rope. Returns: int: Minimum cost to connect all ropes into one single rope. >>> min_cost_to_connect_ropes([4, 3, 2, 6]) 29 >>> min_cost_to_connect_ropes([1, 8, 3, 5]) 30","solution":"import heapq def min_cost_to_connect_ropes(ropes): Calculate the minimum cost to connect all ropes into one single rope. Parameters: ropes (List[int]): A list of integers where each integer represents the length of a rope. Returns: int: Minimum cost to connect all ropes into one single rope. if len(ropes) == 1: return 0 # No cost if there is only one rope heapq.heapify(ropes) total_cost = 0 while len(ropes) > 1: first = heapq.heappop(ropes) second = heapq.heappop(ropes) cost = first + second total_cost += cost heapq.heappush(ropes, cost) return total_cost"},{"question":"from typing import List def min_trips(n: int, weights: List[int], capacity: int) -> int: Calculate the minimum number of trips needed for each vehicle to deliver all packages. Args: n (int): The number of packages. weights (List[int]): The weights of the packages. capacity (int): The maximum weight capacity of each vehicle. Returns: int: The minimum number of trips needed to deliver all packages. Examples: >>> min_trips(5, [2, 3, 4, 5, 6], 10) 3 >>> min_trips(7, [1, 2, 3, 4, 5, 6, 7], 7) 5 pass def test_basic_example1(): assert min_trips(5, [2, 3, 4, 5, 6], 10) == 3 def test_basic_example2(): assert min_trips(7, [1, 2, 3, 4, 5, 6, 7], 7) == 5 def test_single_package(): assert min_trips(1, [5], 10) == 1 def test_exact_capacity(): assert min_trips(3, [3, 3, 4], 10) == 1 def test_minimum_and_maximum_values(): assert min_trips(4, [1, 1, 1, 1], 1) == 4 def test_maximum_weights(): assert min_trips(3, [10000, 10000, 10000], 10000) == 3 def test_variety_weights(): assert min_trips(5, [1, 2, 9, 4, 1], 10) == 3","solution":"def calculate_trips(packages, capacity): trips = 0 current_weight = 0 for weight in packages: if current_weight + weight <= capacity: current_weight += weight else: trips += 1 current_weight = weight if current_weight > 0: trips += 1 return trips def min_trips(n, weights, capacity): return calculate_trips(weights, capacity)"},{"question":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. Args: matrix: List[List[int]] -- The NxN matrix to be rotated. Returns: List[List[int]] -- The rotated matrix. Example: >>> rotate_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix([[1, 2], [3, 4]]) [[3, 1], [4, 2]] # Your code here return matrix","solution":"def rotate_matrix(matrix): Rotates the given NxN matrix 90 degrees clockwise in place. Args: matrix: List[List[int]] -- The NxN matrix to be rotated. Returns: List[List[int]] -- The rotated matrix. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse() return matrix"},{"question":"def min_conference_halls(presentations): Determines the minimum number of conference halls required to schedule all presentations. Args: presentations (List[Tuple[int, int]]): List of tuples (start_time, end_time) for each presentation. Returns: int: Minimum number of conference halls required. >>> min_conference_halls([(1, 5), (2, 6), (8, 9), (5, 8), (3, 4)]) 3 >>> min_conference_halls([(1, 10), (2, 6), (3, 5), (7, 8), (9, 11)]) 3 >>> min_conference_halls([(1, 4), (2, 5), (3, 6)]) 3 >>> min_conference_halls([(1, 3), (3, 4), (4, 6)]) 1 >>> min_conference_halls([(1, 2), (3, 4), (5, 6)]) 1 >>> min_conference_halls([]) 0 >>> min_conference_halls([(1, 2)]) 1 >>> min_conference_halls([(1, 10), (1, 10), (1, 10)]) 3","solution":"import heapq def min_conference_halls(presentations): Determines the minimum number of conference halls required to schedule all presentations. :param presentations: List of tuples (start_time, end_time) for each presentation. :return: Minimum number of conference halls required. if not presentations: return 0 # Sort presentations by their start time presentations.sort(key=lambda x: x[0]) # Use a min-heap to track the end times of presentations in the current halls min_heap = [] for start, end in presentations: # If a hall is free (i.e., the earliest end time is less than or equal to the current start time), # remove it from the heap. if min_heap and min_heap[0] <= start: heapq.heappop(min_heap) # Add the current presentation's end time to the heap heapq.heappush(min_heap, end) # The size of the heap will be the number of conference rooms needed return len(min_heap)"},{"question":"def findGCD(A: int, B: int) -> int: Calculate the greatest common divisor (GCD) of two integers A and B. >>> findGCD(48, 18) 6 >>> findGCD(101, 103) 1","solution":"def findGCD(A, B): Returns the Greatest Common Divisor (GCD) of two integers A and B. while B: A, B = B, A % B return A"},{"question":"from typing import List, Tuple def largest_group_size(n: int, m: int, friendships: List[Tuple[int, int]]) -> int: Determine the size of the largest group of directly or indirectly interconnected users. Args: n : int : The number of users. m : int : The number of direct friendship connections. friendships : List[Tuple[int, int]] : The list of direct friendship connections. Returns: int : The size of the largest group of interconnected users. >>> largest_group_size(6, 4, [(1, 2), (2, 3), (3, 4), (5, 6)]) 4 >>> largest_group_size(3, 1, [(1, 2)]) 2 >>> largest_group_size(5, 0, []) 1 >>> largest_group_size(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 5 >>> largest_group_size(7, 4, [(1, 2), (2, 3), (3, 4), (5, 6)]) 4 >>> largest_group_size(1, 0, []) 1 >>> largest_group_size(10, 3, [(1, 2), (2, 3), (5, 6)]) 3","solution":"def largest_group_size(n, m, friendships): def dfs(node, visited, graph): stack = [node] size = 0 while stack: current = stack.pop() if not visited[current]: visited[current] = True size += 1 for neighbor in graph[current]: if not visited[neighbor]: stack.append(neighbor) return size # Initialize the graph graph = {i: [] for i in range(1, n + 1)} for u, v in friendships: graph[u].append(v) graph[v].append(u) visited = {i: False for i in range(1, n + 1)} max_group_size = 0 for user in range(1, n + 1): if not visited[user]: group_size = dfs(user, visited, graph) max_group_size = max(max_group_size, group_size) return max_group_size"},{"question":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def product(node): Calculate the product of elements in a linked list. Args: node (Node): The head of the linked list. Returns: int: The product of the element values in the list. If the list is empty, return 1. Examples: >>> product(Node(2, Node(3, Node(4)))) 24 >>> product(Node(5, Node(1, Node(0)))) 0 >>> product(None) 1 >>> product(Node(7)) 7","solution":"class Node: def __init__(self, data, next=None): self.data = data self.next = next def product(node): Calculate the product of elements in a linked list. Args: node (Node): The head of the linked list. Returns: int: The product of the element values in the list. If the list is empty, return 1. if node is None: return 1 result = 1 current = node while current is not None: result *= current.data current = current.next return result"},{"question":"def find_pairs(array, k): Returns a list of unique pairs (a, b) from the array such that a + b = k. Each pair is sorted internally, e.g., (a, b) with a <= b. pass def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list pass def test_find_pairs(): assert find_pairs([1, 2, 3, 4, 5], 5) == [(1, 4), (2, 3)] assert find_pairs([1, 1, 1, 1], 2) == [(1, 1)] assert find_pairs([2, 4, 3, 3, 3, 1, 5], 6) == [(1, 5), (2, 4), (3, 3)] assert find_pairs([1, 2, 3], 7) == \\"No pairs\\" def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 4, 5], 5), (4, [1, 1, 1, 1], 2), (7, [2, 4, 3, 3, 3, 1, 5], 6) ] results = [ [(1, 4), (2, 3)], [(1, 1)], [(1, 5), (2, 4), (3, 3)] ] assert process_test_cases(test_cases) == results","solution":"def find_pairs(array, k): Returns a list of unique pairs (a, b) from the array such that a + b = k. Each pair is sorted internally, e.g., (a, b) with a <= b. found_pairs = set() seen_elements = set() for number in array: complement = k - number if complement in seen_elements: pair = (min(number, complement), max(number, complement)) found_pairs.add(pair) seen_elements.add(number) if found_pairs: return sorted(found_pairs) else: return \\"No pairs\\" def process_test_cases(test_cases): Processes multiple test cases and returns the results as a list results = [] for case in test_cases: n, array, k = case result = find_pairs(array, k) results.append(result) return results"},{"question":"def rank_participants(N: int, participants: list) -> dict: A company is organizing a competitive programming contest and wants to rank the participants based on their scores. In case of a tie, the participant with the lower ID number should be ranked higher. Given a list of participants with their respective IDs and scores, determine the rank of each participant and output them in increasing order of their participant IDs. >>> rank_participants(5, [(1, 400), (2, 300), (3, 450), (4, 450), (5, 350)]) {1: 3, 2: 5, 3: 1, 4: 1, 5: 4} >>> rank_participants(5, [(1, 100), (2, 100), (3, 100), (4, 100), (5, 100)]) {1: 1, 2: 1, 3: 1, 4: 1, 5: 1} >>> rank_participants(5, [(1, 100), (2, 200), (3, 300), (4, 400), (5, 500)]) {1: 5, 2: 4, 3: 3, 4: 2, 5: 1} >>> rank_participants(5, [(5, 500), (4, 400), (3, 300), (2, 200), (1, 100)]) {1: 5, 2: 4, 3: 3, 4: 2, 5: 1} >>> rank_participants(5, [(1, 400), (2, 400), (3, 300), (4, 300), (5, 200)]) {1: 1, 2: 1, 3: 3, 4: 3, 5: 5} # implementation here","solution":"def rank_participants(N, participants): Returns the rank of each participant based on their score and ID. N: int - the number of participants participants: list of tuples - list of (ID, score) Returns a dict with IDs as keys and ranks as values. # Sort participants by descending score first, then by ascending ID sorted_participants = sorted(participants, key=lambda x: (-x[1], x[0])) # Create a dictionary for rank with participant IDs rank_dict = {} # Assign ranks to participants current_rank = 1 for idx, (ID, score) in enumerate(sorted_participants): if idx > 0 and score < sorted_participants[idx - 1][1]: current_rank = idx + 1 rank_dict[ID] = current_rank # Sorting ranks by ID in increasing order sorted_rank_dict = dict(sorted(rank_dict.items())) return sorted_rank_dict"},{"question":"from typing import List def find_smallest_m(n: int) -> int: Return the smallest integer m such that the sum of integers from 1 to m is greater than or equal to n. >>> find_smallest_m(12) 5 >>> find_smallest_m(5) 3 >>> find_smallest_m(27) 7 def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Process multiple test cases to find the smallest integer m for each target sum. :param T: Number of test cases (integer) :param test_cases: List of target sums (list of integers) :return: List of smallest integer m for each target sum (list of integers) >>> process_test_cases(3, [12, 5, 27]) [5, 3, 7] >>> process_test_cases(2, [1, 15]) [1, 5]","solution":"def find_smallest_m(n): Returns the smallest integer m such that the sum of integers from 1 to m is greater than or equal to n. :param n: Target sum (integer) :return: Smallest integer m (integer) m = 1 current_sum = 1 while current_sum < n: m += 1 current_sum += m return m def process_test_cases(T, test_cases): results = [] for n in test_cases: results.append(find_smallest_m(n)) return results"},{"question":"def is_prime(num: int) -> bool: Check if the given number is prime. >>> is_prime(2) == True >>> is_prime(4) == False def smallest_prime_ge(n: int) -> int: Returns the smallest prime number p such that p is greater than or equal to n. >>> smallest_prime_ge(10) == 11 >>> smallest_prime_ge(20) == 23 >>> smallest_prime_ge(2) == 2","solution":"def is_prime(num): Check if the given number is prime. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def smallest_prime_ge(n): Returns the smallest prime number p such that p is greater than or equal to n. while True: if is_prime(n): return n n += 1"},{"question":"def min_operations_to_make_distinct(s: str) -> int: Given a string S consisting of lowercase English letters, return the minimum number of operations required to ensure that all characters in the string are distinct. In each operation, you can select a character from the string and replace it with any other lowercase English letter as long as it does not already appear in the string. :param s: A string consisting of lowercase English letters. :return: An integer representing the minimum number of operations needed. >>> min_operations_to_make_distinct(\\"abac\\") 1 >>> min_operations_to_make_distinct(\\"aaaa\\") 3 from solution import min_operations_to_make_distinct def test_sample_input_1(): assert min_operations_to_make_distinct(\\"abac\\") == 1 def test_sample_input_2(): assert min_operations_to_make_distinct(\\"aaaa\\") == 3 def test_no_replacements_needed(): assert min_operations_to_make_distinct(\\"abc\\") == 0 def test_empty_string(): assert min_operations_to_make_distinct(\\"\\") == 0 def test_all_distinct_characters(): assert min_operations_to_make_distinct(\\"abcdefghijklmnopqrstuvwxyz\\") == 0 def test_all_same_characters(): assert min_operations_to_make_distinct(\\"bbbbbbbb\\") == 7 def test_some_replacements_needed(): assert min_operations_to_make_distinct(\\"aabbcc\\") == 3 def test_large_input(): input_str = \\"a\\" * 1000 assert min_operations_to_make_distinct(input_str) == 999","solution":"def min_operations_to_make_distinct(s): Returns the minimum number of operations required to make all characters in the string \`s\` distinct. :param s: A string consisting of lowercase English letters. :return: An integer representing the minimum number of operations needed. found_chars = set() num_operations = 0 for char in s: if char in found_chars: num_operations += 1 else: found_chars.add(char) return num_operations"},{"question":"def get_lexicographically_smallest_array(t, testcases): Determine the lexicographically smallest array that can be obtained after performing the allowed operations any number of times for each test case. Parameters: t (int): Number of test cases. testcases (List[Tuple[int, int, List[int]]]): A list of tuples where each tuple contains: - n (int): The number of elements in the array. - d (int): The integer as described in the problem. - a (List[int]): The list of integers to be sorted lexicographically. Returns: List[List[int]]: A list of results where each result is a list of integers representing the lexicographically smallest array that can be obtained. Examples: >>> get_lexicographically_smallest_array(3, [(4, 2, [3, 1, 2, 4]), (5, 1, [5, 4, 3, 2, 1]), (3, 5, [10, 15, 20])]) [[1, 2, 3, 4], [1, 2, 3, 4, 5], [10, 15, 20]] >>> get_lexicographically_smallest_array(1, [(5, 2, [1, 2, 3, 4, 5])]) [[1, 2, 3, 4, 5]] >>> get_lexicographically_smallest_array(1, [(4, 1000, [4, 2, 1000, 999])]) [[2, 4, 999, 1000]]","solution":"def get_lexicographically_smallest_array(t, testcases): Function to determine the lexicographically smallest array that can be obtained after performing the allowed operations any number of times for each test case. results = [] for test in testcases: n, d, a = test # Sort the array as this gives the lexicographically smallest array a_sorted = sorted(a) results.append(a_sorted) return results # Example usage of the function testcases = [(4, 2, [3, 1, 2, 4]), (5, 1, [5, 4, 3, 2, 1]), (3, 5, [10, 15, 20])] print(get_lexicographically_smallest_array(3, testcases))"},{"question":"def count_palindromic_substrings(s: str) -> int: Counts the number of palindromic substrings in the input string s. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 >>> count_palindromic_substrings(\\"racecar\\") 10 pass def solve_palindrome_substrings(test_cases: List[str]) -> List[int]: Process the list of test cases and returns the result for each case. >>> solve_palindrome_substrings([\\"abc\\", \\"aaa\\", \\"racecar\\"]) [3, 6, 10] >>> solve_palindrome_substrings([\\"a\\", \\"ab\\", \\"aba\\"]) [1, 2, 4] pass","solution":"def count_palindromic_substrings(s): Counts the number of palindromic substrings in the input string s. n = len(s) count = 0 # Center around each possible center for palindromes for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count def solve_palindrome_substrings(test_cases): Process the list of test cases and returns the result for each case. results = [] for s in test_cases: results.append(count_palindromic_substrings(s)) return results"},{"question":"from typing import List def can_form_palindrome(s: str) -> str: A palindrome is a string that reads the same forward and backward, ignoring case, spaces, and punctuation. Given a string, determine if it can be rearranged to form a palindrome. Args: s (str): The input string. Returns: str: \\"YES\\" if the string can be rearranged to form a palindrome, \\"NO\\" otherwise. Examples: >>> can_form_palindrome(\\"Taco cat\\") \\"YES\\" >>> can_form_palindrome(\\"A man, a plan, a canal, Panama\\") \\"YES\\" >>> can_form_palindrome(\\"Hello, World!\\") \\"NO\\" pass","solution":"from collections import Counter import re def can_form_palindrome(s): Determines if the input string can be rearranged to form a palindrome. # Normalize string: remove non-alphanumeric chars and convert to lower case cleaned_s = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Count frequency of each character char_count = Counter(cleaned_s) # Check how many characters have an odd count odd_count = sum(1 for count in char_count.values() if count % 2 == 1) # For string to be rearrangeable into palindrome, there must be at most 1 odd count character return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"from typing import List def sum_of_even_fibonacci(n: int) -> int: Computes the sum of all even Fibonacci numbers less than or equal to n. >>> sum_of_even_fibonacci(10) 10 >>> sum_of_even_fibonacci(100) 44 >>> sum_of_even_fibonacci(1) 0 >>> sum_of_even_fibonacci(2) 2 pass def process_datasets(datasets: List[int]) -> List[int]: Processes multiple datasets to compute the sum of even Fibonacci numbers for each dataset. >>> process_datasets([10, 100]) [10, 44] >>> process_datasets([1, 2, 3, 4, 5]) [0, 2, 2, 2, 2] >>> process_datasets([1000000]) [1089154] pass","solution":"def sum_of_even_fibonacci(n): Computes the sum of all even Fibonacci numbers less than or equal to n. if n < 2: return 0 a, b = 0, 1 # Initial Fibonacci numbers even_sum = 0 while b <= n: if b % 2 == 0: even_sum += b a, b = b, a + b return even_sum def process_datasets(datasets): results = [] for n in datasets: results.append(sum_of_even_fibonacci(n)) return results"},{"question":"def maxLengthTwoDistinct(s: str) -> int: Determine the maximum length of a substring that has exactly two distinct characters. Each distinct character must appear at least once in the substring. Args: s (str): The input string consisting of lowercase alphabets. Returns: int: The maximum length of the substring with exactly two distinct characters. Examples: >>> maxLengthTwoDistinct(\\"eceba\\") 3 >>> maxLengthTwoDistinct(\\"ccaabbb\\") 5","solution":"def maxLengthTwoDistinct(s: str) -> int: if len(s) < 2: return len(s) left, right = 0, 0 max_len = 0 char_count = {} while right < len(s): char_count[s[right]] = char_count.get(s[right], 0) + 1 right += 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left) return max_len"},{"question":"def max_profit(prices): Given a list of integers representing the prices of houses, returns the maximum profit that can be achieved by buying and selling a single house. If no profit can be made, returns 0. :param prices: List[int] :return: int >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(prices): Given a list of integers representing the prices of houses, returns the maximum profit that can be achieved by buying and selling a single house. If no profit can be made, returns 0. :param prices: List[int] :return: int if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices: min_price = min(min_price, price) max_profit = max(max_profit, price - min_price) return max_profit"},{"question":"def largestRotatedRectangle(M: int, N: int, matrix: List[List[str]]) -> int: Write a function that accepts two integers M and N representing the dimensions of a 2D grid and a 2D list matrix of size MxN, consisting of only '0's and '1's. The function should return the area of the largest rectangle containing only 1's that can be obtained by rotating the matrix by 90, 180, or 270 degrees, or not rotating at all. >>> matrix1 = [ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ] >>> largestRotatedRectangle(4, 5, [[str(x) for x in row] for row in matrix1]) 6 >>> matrix2 = [ ... [0, 1], ... [1, 0] ... ] >>> largestRotatedRectangle(2, 2, [[str(x) for x in row] for row in matrix2]) 1","solution":"def maximalRectangle(matrix): if not matrix or not matrix[0]: return 0 max_area = 0 heights = [0] * len(matrix[0]) for row in matrix: for i in range(len(row)): if row[i] == '1': heights[i] += 1 else: heights[i] = 0 max_area = max(max_area, largestRectangleArea(heights)) return max_area def largestRectangleArea(heights): stack = [-1] max_area = 0 for i in range(len(heights)): while stack[-1] != -1 and heights[stack[-1]] >= heights[i]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) while stack[-1] != -1: h = heights[stack.pop()] w = len(heights) - stack[-1] - 1 max_area = max(max_area, h * w) return max_area def rotate90(matrix): return list(zip(*matrix[::-1])) def largestRotatedRectangle(M, N, matrix): rotations = [matrix] for _ in range(3): rotations.append(rotate90(rotations[-1])) max_area = 0 for rotated in rotations: max_area = max(max_area, maximalRectangle(rotated)) return max_area"},{"question":"from typing import List, Tuple def min_flips(n: int, m: int, colors: List[int], edges: List[Tuple[int, int]]) -> int: Compute the minimum number of flips required to make all vertices in any connected component of the graph the same color. Arguments: n -- the number of vertices. m -- the number of edges. colors -- a list of integers representing the color of each vertex where 0 is white and 1 is black. edges -- a list of tuples representing the edges between the vertices. >>> min_flips(5, 3, [0, 1, 0, 1, 1], [(1, 2), (2, 3), (4, 5)]) 1 >>> min_flips(4, 0, [1, 0, 1, 0], []) 0 pass def test_min_flips_case_1(): assert min_flips(5, 3, [0, 1, 0, 1, 1], [(1, 2), (2, 3), (4, 5)]) == 1 def test_min_flips_case_2(): assert min_flips(4, 0, [1, 0, 1, 0], []) == 0 def test_min_flips_single_node(): assert min_flips(1, 0, [0], []) == 0 def test_min_flips_all_same_color(): assert min_flips(3, 2, [0, 0, 0], [(1, 2), (2, 3)]) == 0 assert min_flips(3, 2, [1, 1, 1], [(1, 2), (2, 3)]) == 0 def test_min_flips_all_different_color(): assert min_flips(3, 2, [0, 1, 0], [(1, 2), (2, 3)]) == 1 def test_min_flips_large_case(): n = 100000 edges = [(i, i + 1) for i in range(1, n)] colors = [0 if i % 2 == 0 else 1 for i in range(n)] assert min_flips(n, len(edges), colors, edges) == 50000","solution":"def min_flips(n, m, colors, edges): from collections import defaultdict, deque def bfs(start): queue = deque([start]) visited[start] = True component = [] white_count = black_count = 0 while queue: node = queue.popleft() component.append(node) if colors[node] == 0: white_count += 1 else: black_count += 1 for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) flips = min(white_count, black_count) return flips # Initialize graph graph = defaultdict(list) for u, v in edges: graph[u-1].append(v-1) graph[v-1].append(u-1) # Initialize visited array visited = [False] * n # Calculates minimum flips for each connected component total_flips = 0 for i in range(n): if not visited[i]: total_flips += bfs(i) return total_flips # Sample inputs for testing purposes: print(min_flips(5, 3, [0, 1, 0, 1, 1], [(1, 2), (2, 3), (4, 5)])) # Expected output: 1 print(min_flips(4, 0, [1, 0, 1, 0], [])) # Expected output: 0"},{"question":"def duplicate_characters(input_string: str) -> str: Returns a new string where each character in the input_string is duplicated. Args: input_string (str): The string to be processed. Returns: str: The processed string with each character duplicated. >>> duplicate_characters(\\"\\") '' >>> duplicate_characters(\\"a\\") 'aa' >>> duplicate_characters(\\"hello\\") 'hheelllloo' >>> duplicate_characters(\\"!@#\\") '!!@@' >>> duplicate_characters(\\"a b\\") 'aa bb' >>> duplicate_characters(\\"123\\") '112233'","solution":"def duplicate_characters(input_string): Returns a new string where each character in the input_string is duplicated. Args: input_string (str): The string to be processed. Returns: str: The processed string with each character duplicated. return ''.join([char * 2 for char in input_string])"},{"question":"def longestSubstrDistinctChars(s: str) -> int: Returns the length of the longest substring with all distinct characters. >>> longestSubstrDistinctChars(\\"abcabcbb\\") 3 >>> longestSubstrDistinctChars(\\"bbbbb\\") 1 >>> longestSubstrDistinctChars(\\"pwwkew\\") 3","solution":"def longestSubstrDistinctChars(s: str) -> int: Returns the length of the longest substring with all distinct characters. n = len(s) max_len = 0 char_index = {} start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end max_len = max(max_len, end - start + 1) return max_len"},{"question":"def maxProfit(prices: List[int], k: int) -> int: Given a list of n integers representing stock prices on different days, and a positive integer k, determine the maximum profit you can achieve by making at most k transactions. A transaction consists of buying and then selling one share of the stock. >>> maxProfit([3, 2, 6, 5, 0, 3], 2) 7 >>> maxProfit([7, 1, 5, 3, 6, 4], 1) 5 >>> maxProfit([1, 2, 3, 4, 5], 2) 4 >>> maxProfit([], 1) 0 >>> maxProfit([7, 1], 1) 0 >>> maxProfit([1, 7], 1) 6 >>> maxProfit([3, 2, 6, 5, 0, 3], 4) 7 >>> maxProfit([6, 5, 4, 3, 2, 1], 2) 0 >>> maxProfit([1, 2, 3, 4, 5, 6], 2) 5","solution":"def maxProfit(prices, k): n = len(prices) if n == 0 or k == 0: return 0 # If we have more transaction opportunities than half the number of days, it's equivalent to unlimited transactions if k >= n // 2: return sum(max(prices[i + 1] - prices[i], 0) for i in range(n - 1)) dp = [[0] * n for _ in range(k + 1)] for i in range(1, k + 1): max_diff = -prices[0] for j in range(1, n): dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff) max_diff = max(max_diff, dp[i - 1][j] - prices[j]) return dp[k][n - 1]"},{"question":"def canFrogsCross(stones, strengths): Given the strengths of the frogs and the positions of the stones in the river, find out if it is possible for each frog to reach the other side of the river. If all frogs can cross the river, return 'Yes'. Otherwise, return 'No'. >>> canFrogsCross([1, 3, 5, 7, 9], [2, 4, 10]) 'Yes' >>> canFrogsCross([2, 5, 6, 8, 12], [3, 2, 7]) 'No' >>> canFrogsCross([1], [1, 2, 3]) 'Yes' >>> canFrogsCross([1], [0]) 'No' >>> canFrogsCross([], [1]) 'No' >>> canFrogsCross([5, 10, 15, 20], [15, 5]) 'Yes' >>> canFrogsCross([5, 10, 15, 20], [4, 16]) 'No'","solution":"def canFrogsCross(stones, strengths): if not stones: return 'No' max_stone = stones[-1] for strength in strengths: position = 0 for stone in stones: if stone - position <= strength: position = stone if position == max_stone: break if position != max_stone: return 'No' return 'Yes'"},{"question":"def minimum_round_trip_delay(n, m, s, edges): Find the minimum round-trip delay starting and ending at server \`s\`. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. s (int): The starting server. edges (List[Tuple[int, int, int]]): List of edges represented as tuples (a, b, d) where \`a\` is the start node, \`b\` is the end node, and \`d\` is the delay Returns: int: The minimum round-trip delay or -1 if no round-trip exists. >>> minimum_round_trip_delay(4, 4, 1, [(1, 2, 10), (2, 3, 10), (3, 4, 10), (4, 1, 10)]) 40 >>> minimum_round_trip_delay(4, 3, 1, [(1, 2, 10), (2, 3, 10), (3, 4, 10)]) -1 >>> minimum_round_trip_delay(3, 3, 2, [(2, 1, 3), (1, 3, 4), (3, 2, 5)]) 12","solution":"import heapq def dijkstra(graph, start): Apply Dijkstra's algorithm to find the shortest paths from start node to all other nodes. n = len(graph) distances = [float('inf')] * n distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def minimum_round_trip_delay(n, m, s, edges): Find the minimum round-trip delay starting and ending at server \`s\`. s -= 1 # Convert to 0-based index graph = [[] for _ in range(n)] for a, b, d in edges: graph[a-1].append((b-1, d)) distances_from_s = dijkstra(graph, s) min_round_trip = float('inf') for i in range(n): if i != s and distances_from_s[i] != float('inf'): distances_to_s = dijkstra(graph, i) if distances_to_s[s] != float('inf'): min_round_trip = min(min_round_trip, distances_from_s[i] + distances_to_s[s]) return min_round_trip if min_round_trip != float('inf') else -1 def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) S = int(data[2]) edges = [] index = 3 for _ in range(M): a = int(data[index]) b = int(data[index+1]) d = int(data[index+2]) edges.append((a, b, d)) index += 3 result = minimum_round_trip_delay(N, M, S, edges) print(result)"},{"question":"def maxConsecutiveWorkHours(hours: List[int]) -> int: Finds the maximum number of consecutive days with strictly increasing work hours. >>> maxConsecutiveWorkHours([1, 2, 3, 2, 4, 5, 7]) 4 >>> maxConsecutiveWorkHours([5, 3, 1, 2]) 2","solution":"def maxConsecutiveWorkHours(hours): Finds the maximum number of consecutive days with strictly increasing work hours. :param hours: List of integers representing the number of hours worked each day. :return: Integer, the length of the longest streak of strictly increasing work hours. if not hours: return 0 max_length = 1 current_length = 1 for i in range(1, len(hours)): if hours[i] > hours[i-1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"import heapq from collections import Counter def rearrange_strings(T: int, strings: List[str]) -> List[str]: Given a string S consisting of lowercase letters, determine if it is possible to rearrange the characters of S such that no two adjacent characters are the same. If possible, print any such rearrangement. If not, print 'Not Possible'. >>> rearrange_strings(2, [\\"aabb\\", \\"aaab\\"]) [\\"abab\\", \\"Not Possible\\"] >>> rearrange_strings(1, [\\"a\\"]) [\\"a\\"] >>> rearrange_strings(1, [\\"abcd\\"]) [\\"abcd\\"] >>> rearrange_strings(1, [\\"aaabbcc\\"]) [\\"abcabca\\"] or [\\"abacabc\\"] >>> rearrange_strings(1, [\\"aaaa\\"]) [\\"Not Possible\\"] >>> rearrange_strings(4, [\\"aabb\\", \\"aaab\\", \\"abcd\\", \\"aaaa\\"]) [\\"abab\\", \\"Not Possible\\", \\"abcd\\", \\"Not Possible\\"]","solution":"import heapq from collections import Counter def rearrange_string(s): freq_counter = Counter(s) max_heap = [(-freq, char) for char, freq in freq_counter.items()] heapq.heapify(max_heap) prev_char, prev_freq = None, 0 result = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) if prev_freq < 0: heapq.heappush(max_heap, (prev_freq, prev_char)) prev_char = char prev_freq = freq + 1 if len(result) == len(s): return \\"\\".join(result) else: return \\"Not Possible\\" def rearrange_strings(T, strings): return [rearrange_string(s) for s in strings]"},{"question":"def generate_leaderboard(n: int, m: int) -> List[List[int]]: Generate a leaderboard matrix such that each row contains unique integers from 1 to m and each column contains unique integers from 1 to n. Args: n: Number of participants m: Number of problems Returns: A 2D list representing the leaderboard >>> generate_leaderboard(3, 3) [[1, 2, 3], [2, 3, 1], [3, 1, 2]] >>> generate_leaderboard(4, 4) [[1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2], [4, 1, 2, 3]] leaderboard = [[(i + j - 1) % m + 1 for j in range(1, m + 1)] for i in range(1, n + 1)] return leaderboard","solution":"def generate_leaderboard(n, m): Generate a leaderboard matrix such that each row contains unique integers from 1 to m and each column contains unique integers from 1 to n. leaderboard = [[(i + j - 1) % m + 1 for j in range(1, m + 1)] for i in range(1, n + 1)] return leaderboard"},{"question":"def total_distance(n: int, instructions: List[int]) -> int: Calculate the total distance Cornelius has traveled based on the given instructions. :param n: int - number of instructions :param instructions: List[int] - list of distance changes :return: int - total distance traveled at the end of the day >>> total_distance(5, [-3, 7, -10, 20, -5]) == 9 >>> total_distance(3, [10, -5, -15]) == -10 >>> total_distance(4, [5, 5, 5, 5]) == 20 >>> total_distance(4, [-5, -5, -5, -5]) == -20 >>> total_distance(1, [0]) == 0 >>> total_distance(2, [100, -50]) == 50 >>> total_distance(3, [-100, 50, 50]) == 0","solution":"def total_distance(n, instructions): Calculate the total distance Cornelius has traveled based on the given instructions. :param n: int - number of instructions :param instructions: List[int] - list of distance changes :return: int - total distance traveled at the end of the day return sum(instructions)"},{"question":"def reverseKCharacters(S: str, K: int) -> str: Reverses the order of the first K characters in the string S. If K is greater than the length of the string, reverses the whole string. Args: S: A string whose first K characters need to be reversed. K: An integer denoting the number of characters to reverse. Returns: A new string with the first K characters reversed. Examples: >>> reverseKCharacters(\\"abcdef\\", 3) 'cbadef' >>> reverseKCharacters(\\"abcdef\\", 8) 'fedcba'","solution":"def reverseKCharacters(S: str, K: int) -> str: Reverses the order of the first K characters in the string S. If K is greater than the length of the string, reverses the whole string. Args: S: A string whose first K characters need to be reversed. K: An integer denoting the number of characters to reverse. Returns: A new string with the first K characters reversed. if K > len(S): K = len(S) return S[:K][::-1] + S[K:]"},{"question":"def min_skill_diff(n: int, skill_levels: List[int]) -> int: Returns the minimum possible difference between skill levels of any two paired employees. :param n: Number of employees (int) :param skill_levels: List of skill levels (List[int]) :return: Minimum possible difference (int) >>> min_skill_diff(5, [4, 9, 1, 32, 13]) 3 >>> min_skill_diff(8, [20, 18, 5, 1, 24, 19, 17, 12]) 1","solution":"def min_skill_diff(n, skill_levels): Returns the minimum possible difference between skill levels of any two paired employees. :param n: Number of employees (int) :param skill_levels: List of skill levels (List[int]) :return: Minimum possible difference (int) skill_levels.sort() min_diff = float('inf') for i in range(1, n): diff = skill_levels[i] - skill_levels[i - 1] if diff < min_diff: min_diff = diff return min_diff # Example Usage # n = 5 # skill_levels = [4, 9, 1, 32, 13] # print(min_skill_diff(n, skill_levels)) # Output: 3"},{"question":"def max_unique_visitors(n, days): Returns the maximum number of unique visitors that can be scheduled. Parameters: n (int): The number of applications received. days (list of int): Each integer represents a day of the month requested by a visitor. Returns: int: The maximum number of unique visitors that can be scheduled. Examples: >>> max_unique_visitors(5, [1, 3, 2, 3, 2]) 3 >>> max_unique_visitors(4, [7, 7, 7, 7]) 1","solution":"def max_unique_visitors(n, days): Returns the maximum number of unique visitors that can be scheduled. Parameters: n (int): The number of applications received. days (list of int): Each integer represents a day of the month requested by a visitor. Returns: int: The maximum number of unique visitors that can be scheduled. return len(set(days))"},{"question":"def max_non_overlapping_meetings(meetings): Determines the maximum number of non-overlapping meetings that can be scheduled. Args: meetings (list of tuples): A list of tuples, each with two integers representing the start and end times of a meeting. Returns: int: The maximum number of non-overlapping meetings. >>> max_non_overlapping_meetings([(30, 90), (0, 60), (60, 120), (90, 150), (150, 180)]) 3 >>> max_non_overlapping_meetings([]) 0 >>> max_non_overlapping_meetings([(0, 60)]) 1 >>> max_non_overlapping_meetings([(0, 30), (30, 60), (60, 90), (90, 120)]) 4 >>> max_non_overlapping_meetings([(0, 50), (10, 60), (20, 70), (30, 80)]) 1 >>> max_non_overlapping_meetings([(1, 5), (2, 6), (5, 8), (6, 7), (8, 9), (9, 15), (15, 20), (19, 25), (24, 30)]) 6 >>> max_non_overlapping_meetings([(0, 10), (10, 20), (20, 30), (30, 40)]) 4","solution":"def max_non_overlapping_meetings(meetings): Determines the maximum number of non-overlapping meetings that can be scheduled. Args: meetings (list of tuples): A list of tuples, each with two integers representing the start and end times of a meeting. Returns: int: The maximum number of non-overlapping meetings. # Sort meetings by end time, and by start time if end times are the same meetings.sort(key=lambda x: (x[1], x[0])) # Initialize the count of non-overlapping meetings count = 0 # Initialize the end time of the last meeting scheduled last_end_time = -1 for start, end in meetings: if start >= last_end_time: # If the start time of the current meeting is greater or equal to the # end time of the last meeting, schedule this meeting last_end_time = end count += 1 return count # Example input meetings = [ (30, 90), (0, 60), (60, 120), (90, 150), (150, 180) ] # Function call to demonstrate print(max_non_overlapping_meetings(meetings)) # Expected output: 3"},{"question":"def find_non_repeating(array: List[int]) -> Union[int, None]: Returns the first non-repeating element in the array. If all elements repeat or the array is empty, returns None. >>> find_non_repeating([4, 5, 1, 2, 0, 4]) == 5 >>> find_non_repeating([1, 2, 3, 1, 3, 2, 4]) == 4 >>> find_non_repeating([1, 1, 1, 1]) == None >>> find_non_repeating([]) == None","solution":"def find_non_repeating(array): Returns the first non-repeating element of the array. If all elements repeat or the array is empty, returns None. if not array: return None element_count = {} # First pass: count the occurrences of each element for element in array: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 # Second pass: find the first element with count 1 for element in array: if element_count[element] == 1: return element return None"},{"question":"def isValid(s: str) -> str: Determines if the input string s is a valid combination of brackets and parenthesis. Returns 'YES' if valid, else 'NO'. >>> isValid(\\"(){}[]\\") 'YES' >>> isValid(\\"([{}])\\") 'YES' >>> isValid(\\"{[()]}\\") 'YES' >>> isValid(\\"({[)]}\\") 'NO' >>> isValid(\\"((())\\") 'NO'","solution":"def isValid(s): Determines if the input string s is a valid combination of brackets and parenthesis. Returns 'YES' if valid, else 'NO'. stack = [] mapping = {')': '(', '}': '{', ']': '['} for char in s: if char in mapping: top_element = stack.pop() if stack else '#' if mapping[char] != top_element: return \\"NO\\" else: stack.append(char) return \\"YES\\" if not stack else \\"NO\\""},{"question":"class URLShortener: A URL Shortener service that provides functionality to shorten a long URL and retrieve the original URL from a shortened version. >>> url_shortener = URLShortener() >>> long_url = \\"https://www.example.com/some/very/long/path/to/resource\\" >>> short_url = url_shortener.shorten_url(long_url) >>> url_shortener.retrieve_url(short_url) == long_url True def __init__(self): self.url_map = {} self.counter = 0 self.base62 = \\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def encode(self, num): Converts a given integer to a base62 string. pass def shorten_url(self, url: str) -> str: Convert a long URL to a shortened URL pass def retrieve_url(self, short_url: str) -> str: Retrieve the original long URL from a shortened URL pass","solution":"class URLShortener: def __init__(self): self.url_map = {} self.counter = 0 self.base62 = \\"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def encode(self, num): Converts a given integer to a base62 string. if num == 0: return self.base62[0] arr = [] base = len(self.base62) while num: rem = num % base num = num // base arr.append(self.base62[rem]) arr.reverse() return ''.join(arr) def shorten_url(self, url: str) -> str: Convert a long URL to a shortened URL if url in self.url_map: return self.url_map[url] short_path = self.encode(self.counter) short_url = \\"http://short.url/\\" + short_path self.url_map[url] = short_url self.url_map[short_url] = url self.counter += 1 return short_url def retrieve_url(self, short_url: str) -> str: Retrieve the original long URL from a shortened URL if short_url in self.url_map: return self.url_map[short_url] return \\"Error: URL not found!\\""},{"question":"from typing import List, Tuple def max_flowers(N: int, M: int, restrictions: List[Tuple[int, int]]) -> int: Determine the maximum number of flowers that can be planted following the given restrictions. Args: N: An integer representing the number of pots. M: An integer representing the number of restrictions. restrictions: A list of tuples where each tuple contains two integers representing a restriction. Returns: The maximum number of flowers that can be planted following the given restrictions. Examples: >>> max_flowers(5, 2, [(1, 2), (3, 4)]) 3 >>> max_flowers(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 2 pass def test_max_flowers_basic(): assert max_flowers(5, 2, [(1, 2), (3, 4)]) == 3 assert max_flowers(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 2 def test_max_flowers_no_restrictions(): assert max_flowers(3, 0, []) == 3 assert max_flowers(4, 0, []) == 4 def test_max_flowers_all_restrictions(): assert max_flowers(3, 3, [(1, 2), (2, 3), (3, 1)]) == 1 assert max_flowers(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (2, 4), (3, 4)]) == 1 def test_max_flowers_edge_cases(): assert max_flowers(1, 0, []) == 1 assert max_flowers(2, 1, [(1, 2)]) == 1 assert max_flowers(5, 10, [(1, 2), (1, 3), (1, 4), (1, 5), (2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (4, 5)]) == 1","solution":"def max_flowers(N, M, restrictions): from itertools import combinations # Create adjacency list for restrictions restrict = {i: set() for i in range(N)} for x, y in restrictions: restrict[x - 1].add(y - 1) restrict[y - 1].add(x - 1) # Iterate through all possible ways to plant flowers max_flowers_count = 0 for r in range(1, N+1): for combo in combinations(range(N), r): valid = True # Check if the current combination of pots obeys the restrictions for i in range(r): for j in range(i+1, r): if combo[j] in restrict[combo[i]]: valid = False break if not valid: break if valid: max_flowers_count = max(max_flowers_count, r) return max_flowers_count # Example usage: n = 5 m = 2 restrictions = [(1, 2), (3, 4)] print(max_flowers(n, m, restrictions)) # Output: 3 n = 4 m = 4 restrictions = [(1, 2), (2, 3), (3, 4), (4, 1)] print(max_flowers(n, m, restrictions)) # Output: 2"},{"question":"from typing import List def min_days_to_convert(n: int, m: int, grid: List[List[int]]) -> int: Determine the minimum number of days required to convert all empty cells into blocked cells in a n x m grid. Every day, you can start a wave of energy from one cell only which spreads to all directly adjacent empty cells, but stops spreading further as soon as it encounters a blocked cell. Parameters: n (int): number of rows in the grid m (int): number of columns in the grid grid (List[List[int]]): the state of each cell in the grid (0 for empty, 1 for blocked) Returns: int: the minimum number of days required to convert all empty cells into blocked cells. If it's impossible, return -1. Examples: >>> min_days_to_convert(3, 3, [[0, 0, 1], [0, 1, 0], [1, 0, 0]]) 2 >>> min_days_to_convert(2, 2, [[1, 0], [0, 1]]) 1 # Unit Tests: def test_example_1(): grid = [ [0, 0, 1], [0, 1, 0], [1, 0, 0] ] assert min_days_to_convert(3, 3, grid) == 2 def test_example_2(): grid = [ [1, 0], [0, 1] ] assert min_days_to_convert(2, 2, grid) == 1 def test_already_all_blocked(): grid = [ [1, 1], [1, 1] ] assert min_days_to_convert(2, 2, grid) == 0 def test_all_empty(): grid = [ [0, 0], [0, 0] ] assert min_days_to_convert(2, 2, grid) == -1 def test_single_cell_empty(): grid = [ [0] ] assert min_days_to_convert(1, 1, grid) == -1 def test_single_cell_blocked(): grid = [ [1] ] assert min_days_to_convert(1, 1, grid) == 0","solution":"from collections import deque def min_days_to_convert(n, m, grid): def is_valid(x, y, n, m): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque() days = 0 # Initialize the queue with all currently blocked (1) cells for i in range(n): for j in range(m): if grid[i][j] == 1: queue.append((i, j, 0)) # BFS to spread the wave and count the days while queue: x, y, day = queue.popleft() days = max(days, day) for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny, n, m): grid[nx][ny] = 1 queue.append((nx, ny, day + 1)) # Check if there are still empty cells left for row in grid: if 0 in row: return -1 return days # Examples: # n = 3, m = 3 # grid = [[0, 0, 1], # [0, 1, 0], # [1, 0, 0]] # # Output: 2 # # n = 2, m = 2 # grid = [[1, 0], # [0, 1]] # # Output: 1"},{"question":"def feeding_schedule(n, animals): Returns the feeding schedule for each animal for the next 10 feeding times. :param n: Number of animals :param animals: List of tuples containing animal name and its feeding interval :return: List of strings showing feeding times for each animal >>> feeding_schedule(3, [(\\"Lion\\", 6), (\\"Tiger\\", 8), (\\"Bear\\", 10)]) [\\"Lion: 0 6 12 18 24 30 36 42 48 54\\", \\"Tiger: 0 8 16 24 32 40 48 56 64 72\\", \\"Bear: 0 10 20 30 40 50 60 70 80 90\\"] >>> feeding_schedule(1, [(\\"Elephant\\", 5)]) [\\"Elephant: 0 5 10 15 20 25 30 35 40 45\\"]","solution":"def feeding_schedule(n, animals): Returns the feeding schedule for each animal for the next 10 feeding times. :param n: Number of animals :param animals: List of tuples containing animal name and its feeding interval :return: List of strings showing feeding times for each animal result = [] for animal, interval in animals: feed_times = [str(interval * i) for i in range(10)] result.append(f\\"{animal}: {' '.join(feed_times)}\\") return result"},{"question":"from typing import List, Tuple def dijkstra_with_restriction(n: int, m: int, edges: List[Tuple[int, int, int]], s: int) -> List[int]: Find the shortest path from a given starting vertex s to all other vertices in a weighted directed graph with n vertices and m edges. Each edge can be used at most once in each path. If no valid path exists from the starting vertex s to a vertex, return -1. Args: n : int : number of vertices m : int : number of edges edges : List[Tuple[int, int, int]] : list of tuples where each tuple contains three integers u, v, w indicating there is a directed edge from vertex u to vertex v with weight w s : int : the starting vertex Returns: List[int] : list of shortest distances from the starting vertex s to each vertex. If no valid path exists, return -1 for that vertex. Examples: >>> dijkstra_with_restriction(5, 6, [(1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 5, 7), (1, 3, 10), (2, 4, 3)], 1) [0, 2, 6, 5, 12] >>> dijkstra_with_restriction(3, 2, [(1, 2, 1), (2, 3, 2)], 2) [-1, 0, 2]","solution":"import heapq from collections import defaultdict import sys def dijkstra_with_restriction(n, m, edges, s): graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) distances = {i: float('inf') for i in range(1, n+1)} distances[s] = 0 priority_queue = [(0, s)] while priority_queue: current_distance, current_vertex = heapq.heappop(priority_queue) if current_distance > distances[current_vertex]: continue for neighbor, weight in graph[current_vertex]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) result = [] for i in range(1, n+1): if distances[i] == float('inf'): result.append(-1) else: result.append(distances[i]) return result # Example usage: # n = 5 # m = 6 # edges = [(1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 5, 7), (1, 3, 10), (2, 4, 3)] # s = 1 # print(dijkstra_with_restriction(n, m, edges, s))"},{"question":"def calculate_logged_in_time(t: int, test_cases: List[Tuple[int, int, List[Tuple[str, str, int]]]]) -> List[List[str]]: Calculate the total logged-in time for each employee based on login/logout records. Args: t : int : number of test cases test_cases: list of tuples : each tuple contains (n, T, records) n : int : number of records for the test case T : int : the end of the given period records : list of tuples : each tuple contains (id, action, time) Returns: results: list of lists : each list contains results for the corresponding test case in the order of first appearance of employees. def test_calculate_logged_in_time(): examples = [ (2, [ (5, 100, [ (\\"alice\\", \\"login\\", 10), (\\"bob\\", \\"login\\", 15), (\\"alice\\", \\"logout\\", 50), (\\"bob\\", \\"logout\\", 80), (\\"carol\\", \\"login\\", 90) ]), (4, 200, [ (\\"dan\\", \\"login\\", 100), (\\"eve\\", \\"login\\", 150), (\\"dan\\", \\"logout\\", 160), (\\"eve\\", \\"logout\\", 180) ]) ]), (1, [ (4, 300, [ (\\"frank\\", \\"login\\", 50), (\\"gina\\", \\"login\\", 100), (\\"frank\\", \\"logout\\", 200), (\\"gina\\", \\"logout\\", 250) ]) ]) ] expecting = [ [ [\\"alice 40\\", \\"bob 65\\", \\"carol 10\\"], [\\"dan 60\\", \\"eve 30\\"] ], [ [\\"frank 150\\", \\"gina 150\\"] ] ] for i, example in enumerate(examples): result = calculate_logged_in_time(*example) assert result == expecting[i], f\\"Expected {expecting[i]}, but got {result}\\" test_calculate_logged_in_time()","solution":"def calculate_logged_in_time(t, test_cases): Calculate the total logged-in time for each employee based on login/logout records. Args: t : int : number of test cases test_cases: list of tuples : each tuple contains (n, T, records) n : int : number of records for the test case T : int : the end of the given period records : list of tuples : each tuple contains (id, action, time) Returns: results: list of lists : each list contains results for the corresponding test case in the order of first appearance of employees. results = [] for i in range(t): n, T, records = test_cases[i] login_times = {} total_times = {} order = [] for record in records: emp_id, action, time = record if emp_id not in total_times: total_times[emp_id] = 0 order.append(emp_id) if action == 'login': login_times[emp_id] = time elif action == 'logout': if emp_id in login_times: total_times[emp_id] += time - login_times[emp_id] login_times.pop(emp_id) # handle employees still logged in until the end of the period for emp_id in login_times: total_times[emp_id] += T - login_times[emp_id] case_result = [] for emp_id in order: case_result.append(f\\"{emp_id} {total_times[emp_id]}\\") results.append(case_result) return results"},{"question":"def digit_sum(n): Returns the sum of the digits of the given number n. >>> digit_sum(34) 7 >>> digit_sum(65) 11 >>> digit_sum(127) 10 >>> digit_sum(89) 17 >>> digit_sum(0) 0 def max_digit_sum(arr): Returns the maximum digit sum among the elements of the array arr. >>> max_digit_sum([34, 65, 127, 89]) 17 >>> max_digit_sum([0, 1, 2, 3]) 3 >>> max_digit_sum([99, 88, 77]) 18 >>> max_digit_sum([123, 456, 789]) 24 >>> max_digit_sum([4321, 5432, 6543]) 18","solution":"def digit_sum(n): Returns the sum of the digits of the given number n. return sum(int(digit) for digit in str(n)) def max_digit_sum(arr): Returns the maximum digit sum among the elements of the array arr. return max(digit_sum(num) for num in arr)"},{"question":"def are_teams_balanced(N, T, designations): Alice is organizing a company-wide conference where different teams will present their projects. Each team consists of exactly T members, and there are N employees in total, where N is divisible by T. Use the given list of employees and their respective team designations to determine if all teams are balanced. A team is considered balanced if all its members have the same team designation. Parameters: N (int): Total number of employees (1 ≤ T ≤ N ≤ 10^6, N % T = 0). T (int): Number of members per team. designations (list): List of integers indicating team designations. The designations are represented by integers between 1 and 100 (inclusive). Returns: str: \\"YES\\" if all teams are balanced, otherwise \\"NO\\". Examples: >>> are_teams_balanced(6, 2, [1, 1, 2, 2, 3, 3]) 'YES' >>> are_teams_balanced(9, 3, [1, 1, 2, 3, 3, 3, 2, 2, 2]) 'NO' >>> are_teams_balanced(6, 3, [1, 1, 1, 2, 2, 2]) 'YES'","solution":"def are_teams_balanced(N, T, designations): This function checks if all teams of T members each are balanced, meaning all team members have the same designation. Parameters: N (int): Total number of employees. T (int): Number of members per team. designations (list): List of integers indicating team designations. Returns: str: \\"YES\\" if all teams are balanced, otherwise \\"NO\\". for i in range(0, N, T): if len(set(designations[i : i + T])) != 1: return \\"NO\\" return \\"YES\\""},{"question":"def can_form_by_rearranging(s1: str, s2: str) -> str: Determines if s2 can be formed by rearranging the characters of s1 and removing exactly one character. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". Examples: >>> can_form_by_rearranging('example', 'exaple') \\"YES\\" >>> can_form_by_rearranging('coding', 'odngci') \\"NO\\" from collections import Counter def test_can_form_by_rearranging_example_1(): assert can_form_by_rearranging('example', 'exaple') == \\"YES\\" def test_can_form_by_rearranging_example_2(): assert can_form_by_rearranging('coding', 'odngci') == \\"NO\\" def test_can_form_by_rearranging_same_length(): assert can_form_by_rearranging('hello', 'olhle') == \\"NO\\" def test_can_form_by_rearranging_rearranged_with_removal(): assert can_form_by_rearranging('listen', 'silent') == \\"NO\\" assert can_form_by_rearranging('listen', 'litsn') == \\"YES\\" def test_can_form_by_rearranging_with_duplicates(): assert can_form_by_rearranging('aabbcc', 'abbcc') == \\"YES\\" def test_can_form_by_rearranging_single_char_removal(): assert can_form_by_rearranging('abcd', 'abc') == \\"YES\\"","solution":"def can_form_by_rearranging(s1, s2): Determines if s2 can be formed by rearranging the characters of s1 and removing exactly one character. Parameters: s1 (str): The source string. s2 (str): The target string. Returns: str: \\"YES\\" if possible, otherwise \\"NO\\". # If the length of s2 is not one less than the length of s1, return \\"NO\\" if len(s1) - 1 != len(s2): return \\"NO\\" # Create character count dictionaries for both strings from collections import Counter s1_counter = Counter(s1) s2_counter = Counter(s2) # Check if s2_counter matches s1_counter except for exactly one character for char in s2_counter: if s2_counter[char] > s1_counter[char]: return \\"NO\\" return \\"YES\\""},{"question":"def minimum_distance(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculate the minimum distance David needs to travel to visit all checkpoints in the given order. >>> minimum_distance(2, [(3, [1, 5, 3]), (4, [1, 3, 6, 10])]) [6, 9] >>> minimum_distance(1, [(4, [1, 2, 3, 4])]) [3] from typing import List, Tuple def test_case_1(): assert minimum_distance(2, [(3, [1, 5, 3]), (4, [1, 3, 6, 10])]) == [6, 9] def test_case_2(): assert minimum_distance(1, [(4, [1, 2, 3, 4])]) == [3] def test_case_3(): assert minimum_distance(3, [(2, [100, 200]), (1, [5]), (5, [10, 20, 30, 40, 50])]) == [100, 0, 40] def test_case_4(): assert minimum_distance(1, [(4, [1, 1, 1, 1])]) == [0] def test_case_5(): assert minimum_distance(1, [(5, [10, 20, 10, 20, 10])]) == [40] def test_case_6(): assert minimum_distance(2, [(6, [1, 2, 3, 4, 5, 6]), (2, [1000, 1])]) == [5, 999]","solution":"def minimum_distance(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] checkpoints = test_cases[i][1] total_distance = sum(abs(checkpoints[j] - checkpoints[j+1]) for j in range(n-1)) results.append(total_distance) return results"},{"question":"def max_dominos(n: int, m: int) -> int: Calculate the maximum number of dominos that can be placed on an n x m grid. Each domino covers two adjacent cells. >>> max_dominos(2, 3) 3 >>> max_dominos(3, 3) 4 >>> max_dominos(2, 2) 2 >>> max_dominos(1, 1) 0 >>> max_dominos(1, 2) 1 >>> max_dominos(4, 4) 8 >>> max_dominos(5, 4) 10 >>> max_dominos(16, 16) 128","solution":"def max_dominos(n, m): Calculate the maximum number of dominos that can be placed on an n x m grid. Each domino covers two adjacent cells. return (n * m) // 2"},{"question":"def find_most_common_topic(n: int, q: int, support_logs: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Finds the most common support topic within given time ranges. Args: n (int): Number of support log entries. q (int): Number of queries. support_logs (List[Tuple[int, int]]): List of tuples where each tuple contains t_i (timestamp) and s_i (topic). queries (List[Tuple[int, int]]): List of tuples where each tuple contains t_start and t_end representing the time range. Returns: List[int]: List of most frequently requested support topics for each query. Examples: >>> find_most_common_topic(5, 3, [(1, 2), (2, 1), (3, 2), (4, 3), (5, 2)], [(1, 3), (2, 4), (3, 5)]) [2, 1, 2] >>> find_most_common_topic(5, 2, [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)], [(1, 5), (2, 4)]) [1, 1]","solution":"def find_most_common_topic(n, q, support_logs, queries): Finds the most common support topic within given time ranges. from collections import defaultdict, Counter # Create a dictionary with time as key and list of topics at that time as value time_to_topics = defaultdict(list) for t, s in support_logs: time_to_topics[t].append(s) results = [] for t_start, t_end in queries: topic_counter = Counter() for t in range(t_start, t_end + 1): if t in time_to_topics: topic_counter.update(time_to_topics[t]) if topic_counter: most_common_topic = min(topic_counter, key=lambda x: (-topic_counter[x], x)) results.append(most_common_topic) else: results.append(None) # If there are no logs in the range, append None return results"},{"question":"def check_traffic(lines): Determine if there is a collision at the intersection based on car directions. >>> check_traffic([\\"Nn\\", \\"EWn\\", \\"Wn\\", \\"NESWn\\"]) ['Safe', 'Collision', 'Safe', 'Collision']","solution":"def check_traffic(lines): results = [] for line in lines: if len(line.strip()) > 1: results.append(\\"Collision\\") else: results.append(\\"Safe\\") return results"},{"question":"def max_sum_alice_can_collect(nums: List[int]) -> int: Given a sequence of integers, find the maximum sum Alice can achieve if she starts first and both play optimally. Args: nums: List[int] : a list of integers representing the sequence of numbers. Returns: int: the maximum sum Alice can collect. Example: >>> max_sum_alice_can_collect([1, 2, 9, -1]) 10 >>> max_sum_alice_can_collect([5, 3, 7, 10]) 15 >>> max_sum_alice_can_collect([8, 15, 3, 7]) 22 >>> max_sum_alice_can_collect([-1, -2, -3, -4]) -4 >>> max_sum_alice_can_collect([10, 20, 30, 40, 50]) 90","solution":"def max_sum_alice_can_collect(nums): n = len(nums) dp = [[0] * n for _ in range(n)] for i in range(n): dp[i][i] = nums[i] for length in range(2, n+1): for i in range(n-length+1): j = i + length - 1 dp[i][j] = max(nums[i] - dp[i+1][j], nums[j] - dp[i][j-1]) total_sum = sum(nums) alice_sum = (total_sum + dp[0][n-1]) // 2 return alice_sum"},{"question":"def identify_unsafe_heart_rates(records): Identifies days and patients with unsafe heart rate recordings. :param records: List of tuples, each containing (day, patient_id, heart_rate) :return: List of tuples, each containing (day, set of patient_ids) >>> identify_unsafe_heart_rates([(1, 101, 58), (1, 102, 62), (2, 103, 50), (2, 104, 101), (3, 105, 80), (3, 101, 110)]) [(1, {101}), (2, {103, 104}), (3, {101})] >>> identify_unsafe_heart_rates([(5, 201, 45), (5, 202, 70), (6, 203, 99), (7, 204, 120)]) [(5, {201}), (7, {204})]","solution":"def identify_unsafe_heart_rates(records): Identifies days and patients with unsafe heart rate recordings. :param records: List of tuples, each containing (day, patient_id, heart_rate) :return: List of tuples, each containing (day, set of patient_ids) from collections import defaultdict unsafe_records = defaultdict(set) for day, patient_id, heart_rate in records: if heart_rate < 60 or heart_rate > 100: unsafe_records[day].add(patient_id) result = [(day, patients) for day, patients in sorted(unsafe_records.items())] return result"},{"question":"def process_instructions(instructions: List[str]) -> str: Processes a list of instructions and returns the total number of items in each warehouse after all instructions have been processed, sorted by the warehouse ID in ascending order. Parameters: instructions (List[str]): List of instructions. Returns: str: The total number of items in each warehouse. >>> process_instructions([\\"add 1 50\\", \\"add 2 20\\", \\"sub 1 10\\", \\"sub 2 5\\", \\"add 1 30\\"]) '1:70 2:15' >>> process_instructions([\\"add 1 100\\", \\"add 2 50\\", \\"sub 1 150\\"]) '2:50' >>> process_instructions([\\"add 3 200\\"]) '3:200' # Implementation goes here def process_multiple_datasets(datasets: List[str]) -> List[str]: Processes multiple datasets of instructions and returns the total number of items in each warehouse after all instructions have been processed for each dataset, sorted by the warehouse ID in ascending order. Parameters: datasets (List[str]): List of datasets, each represented as a single string. Returns: List[str]: List of results for each dataset. >>> instructions_list = [\\"5nadd 1 50nadd 2 20nsub 1 10nsub 2 5nadd 1 30\\", \\"3nadd 1 100nadd 2 50nsub 1 150\\", \\"1nadd 3 200\\"] >>> process_multiple_datasets(instructions_list) ['1:70 2:15', '2:50', '3:200'] # Implementation goes here # Unit Tests def test_process_multiple_datasets(): instructions_list = [ \\"5nadd 1 50nadd 2 20nsub 1 10nsub 2 5nadd 1 30\\", \\"3nadd 1 100nadd 2 50nsub 1 150\\", \\"1nadd 3 200\\" ] expected_output = [\\"1:70 2:15\\", \\"2:50\\", \\"3:200\\"] assert process_multiple_datasets(instructions_list) == expected_output def test_negative_substraction(): instructions_list = [ \\"3nadd 1 10nsub 1 15nadd 2 20\\" ] expected_output = [\\"2:20\\"] assert process_multiple_datasets(instructions_list) == expected_output def test_no_items_left(): instructions_list = [ \\"2nadd 1 20nsub 1 20\\" ] expected_output = [\\"\\"] assert process_multiple_datasets(instructions_list) == expected_output def test_large_numbers(): instructions_list = [ \\"2nadd 1000 1000nsub 1000 999\\" ] expected_output = [\\"1000:1\\"] assert process_multiple_datasets(instructions_list) == expected_output","solution":"def process_instructions(instructions): warehouses = {} for instruction in instructions: parts = instruction.split() action = parts[0] warehouse_id = int(parts[1]) amount = int(parts[2]) if warehouse_id not in warehouses: warehouses[warehouse_id] = 0 if action == \\"add\\": warehouses[warehouse_id] += amount elif action == \\"sub\\": warehouses[warehouse_id] -= amount if warehouses[warehouse_id] < 0: warehouses[warehouse_id] = 0 # Sorting warehouse IDs and preparing the output format result = [] for warehouse_id in sorted(warehouses): if warehouses[warehouse_id] > 0: result.append(f\\"{warehouse_id}:{warehouses[warehouse_id]}\\") return \\" \\".join(result) def process_multiple_datasets(datasets): results = [] for dataset in datasets: instructions = dataset.split(\\"n\\") m = int(instructions[0]) instructions_for_dataset = instructions[1:m+1] result = process_instructions(instructions_for_dataset) results.append(result) return results # Example usage: # instructions_list = [ # \\"5nadd 1 50nadd 2 20nsub 1 10nsub 2 5nadd 1 30\\", # \\"3nadd 1 100nadd 2 50nsub 1 150\\", # \\"1nadd 3 200\\" # ] # print(process_multiple_datasets(instructions_list))"},{"question":"def longest_subsequence_with_k_distinct(N: int, K: int, sequence: List[int]) -> int: Find the length of the longest subsequence that contains at most K distinct integers. >>> longest_subsequence_with_k_distinct(10, 2, [1, 2, 1, 2, 3, 3, 4, 5, 1, 1]) 4 >>> longest_subsequence_with_k_distinct(5, 3, [1, 2, 3, 4, 5]) 3 >>> longest_subsequence_with_k_distinct(1, 1, [10]) 1","solution":"def longest_subsequence_with_k_distinct(N, K, sequence): from collections import defaultdict left = 0 right = 0 max_length = 0 current_count = defaultdict(int) distinct_count = 0 while right < N: current_count[sequence[right]] += 1 if current_count[sequence[right]] == 1: distinct_count += 1 while distinct_count > K: current_count[sequence[left]] -= 1 if current_count[sequence[left]] == 0: distinct_count -= 1 left += 1 max_length = max(max_length, right - left + 1) right += 1 return max_length"},{"question":"def calculate_points(N, M, results): Calculate the points of each team after M rounds in the championship. Args: N : int : Number of teams M : int : Number of rounds results : list of tuples : List of tuples where each tuple has (T_i, R_i) Returns: list : List of integers representing the points of each team pass # Sample Test def test_sample(): N, M = 3, 5 results = [(1, 1), (2, 0), (3, 1), (1, 0), (2, 1)] print(calculate_points(N, M, results)) # should output: [3, 3, 3]","solution":"def calculate_points(N, M, results): Calculate the points of each team after M rounds in the championship. Args: N : int : Number of teams M : int : Number of rounds results : list of tuples : List of tuples where each tuple has (T_i, R_i) Returns: list : List of integers representing the points of each team points = [0] * N for T_i, R_i in results: if R_i == 1: points[T_i - 1] += 3 return points"},{"question":"from typing import List def is_arithmetic_subarray(nums: List[int], queries: List[List[int]]) -> List[bool]: Given a list of integers \`nums\` and a list of queries \`queries\` where each query represents a pair \`[L, R]\`, return a boolean list indicating whether the subarray from index \`L\` to \`R\` (inclusive) forms an arithmetic sequence. An arithmetic sequence is a sequence of numbers such that the difference between any two consecutive elements is the same. >>> is_arithmetic_subarray([4, 6, 5, 9, 3, 7], [[0, 2], [2, 5], [0, 5]]) == [True, True, False] >>> is_arithmetic_subarray([1, 2, 4, 5, 9], [[0, 1], [1, 3], [2, 4]]) == [True, False, False]","solution":"def is_arithmetic_subarray(nums, queries): def is_arithmetic(arr): arr.sort() if len(arr) < 2: return True diff = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i - 1] != diff: return False return True result = [] for L, R in queries: subarray = nums[L:R+1] result.append(is_arithmetic(subarray)) return result"},{"question":"def find_min_cost(n: int, m: int, flights: List[Tuple[int, int, int]]) -> int: Finds the minimum cost to visit all countries using the provided flights. Parameters: n (int): Number of countries. m (int): Number of direct flights. flights (list of tuples): Each tuple contains three integers u, v, and c, where u and v are indices of two countries and c is the cost of the flight between them. Returns: int: Minimum cost to visit all countries or -1 if not possible. >>> find_min_cost(4, 5, [(1, 2, 5), (1, 3, 10), (2, 3, 4), (2, 4, 1), (3, 4, 7)]) 10 >>> find_min_cost(3, 2, [(1, 2, 3), (2, 3, 3)]) 6 >>> find_min_cost(4, 2, [(1, 2, 3), (3, 4, 2)]) -1 from solution import find_min_cost def test_example1(): n = 4 m = 5 flights = [ (1, 2, 5), (1, 3, 10), (2, 3, 4), (2, 4, 1), (3, 4, 7) ] assert find_min_cost(n, m, flights) == 10 def test_example2(): n = 3 m = 2 flights = [ (1, 2, 3), (2, 3, 3) ] assert find_min_cost(n, m, flights) == 6 def test_example3(): n = 4 m = 2 flights = [ (1, 2, 3), (3, 4, 2) ] assert find_min_cost(n, m, flights) == -1 def test_disconnected_graph(): n = 5 m = 3 flights = [ (1, 2, 2), (3, 4, 3), (4, 5, 1), ] assert find_min_cost(n, m, flights) == -1 def test_single_flight(): n = 2 m = 1 flights = [ (1, 2, 5) ] assert find_min_cost(n, m, flights) == 5 def test_minimum_cost(): n = 6 m = 9 flights = [ (1, 2, 1), (1, 3, 3), (1, 4, 10), (1, 5, 4), (2, 3, 5), (3, 4, 7), (4, 5, 2), (5, 6, 2), (4, 6, 1) ] assert find_min_cost(n, m, flights) == 11","solution":"def find_min_cost(n, m, flights): Finds the minimum cost to visit all countries using the provided flights. Parameters: n (int): Number of countries. m (int): Number of direct flights. flights (list of tuples): Each tuple contains three integers u, v, and c, where u and v are indices of two countries and c is the cost of the flight between them. Returns: int: Minimum cost to visit all countries or -1 if not possible. parent = list(range(n)) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX flights.sort(key=lambda x: x[2]) # Sort the edges based on cost total_cost = 0 edges_used = 0 for u, v, cost in flights: if find(u-1) != find(v-1): union(u-1, v-1) total_cost += cost edges_used += 1 if edges_used == n - 1: return total_cost return -1"},{"question":"from typing import List def findPairs(arr: List[int], n: int) -> int: Returns the number of distinct pairs (i, j) where arr[i] + arr[j] is an even number and i < j. >>> findPairs([2, 4, 6, 8], 4) 6 >>> findPairs([1, 3, 5, 7], 4) 6 >>> findPairs([1, 2, 3, 4], 4) 2 >>> findPairs([1, 2], 2) 0 >>> findPairs([2], 1) 0 >>> findPairs([2, 2, 2, 2], 4) 6 >>> findPairs([3, 3, 3], 3) 3 >>> findPairs([3, 3], 2) 1","solution":"from typing import List def findPairs(arr: List[int], n: int) -> int: Returns the number of distinct pairs (i, j) where arr[i] + arr[j] is an even number and i < j. # Count the number of even and odd elements even_count = sum(1 for x in arr if x % 2 == 0) odd_count = n - even_count # Calculate the number of valid pairs even_pairs = (even_count * (even_count - 1)) // 2 odd_pairs = (odd_count * (odd_count - 1)) // 2 return even_pairs + odd_pairs"},{"question":"from typing import Dict import re from collections import defaultdict def word_frequency(s: str) -> Dict[str, int]: Takes a string containing a list of words separated by spaces, and returns a dictionary with each word as the key and the number of times it appears in the string as the value. Ignore case, punctuation, and return an empty dictionary for an empty or non-string input. >>> word_frequency('Hello world! Hello again, world.') {'hello': 2, 'world': 2, 'again': 1} >>> word_frequency('Hello hello HeLLo') {'hello': 3} >>> word_frequency('') {} >>> word_frequency(None) {} >>> word_frequency('hello') {'hello': 1} >>> word_frequency('Repeat repeat repeat') {'repeat': 3} >>> word_frequency('!!!') {} >>> word_frequency('123 123 456') {'123': 2, '456': 1}","solution":"import re from collections import defaultdict def word_frequency(s): Takes a string containing a list of words separated by spaces, and returns a dictionary with each word as the key and the number of times it appears in the string as the value. Ignore case, punctuation, and return an empty dictionary for an empty or non-string input. if not isinstance(s, str) or not s.strip(): return {} # Remove punctuation using regex and convert to lower case s_cleaned = re.sub(r'[^ws]', '', s).lower() words = s_cleaned.split() frequency = defaultdict(int) for word in words: frequency[word] += 1 return dict(frequency)"},{"question":"def keep_every_kth_char(test_cases): For each test case, returns a new string formed by keeping every K-th character of S and removing all others. Note that indexing is 1-based. Arguments: test_cases -- A list of tuples, each containing a string S and an integer K. Returns: A list of resulting strings for each test case. Example: >>> keep_every_kth_char([(\\"abcdefghi\\", 2)]) ['bdfh'] >>> keep_every_kth_char([(\\"hello\\", 3)]) ['l'] from solution import keep_every_kth_char def test_single_case_1(): assert keep_every_kth_char([(\\"abcdefghi\\", 2)]) == [\\"bdfh\\"] def test_single_case_2(): assert keep_every_kth_char([(\\"hello\\", 3)]) == [\\"l\\"] def test_case_k_is_1(): assert keep_every_kth_char([(\\"hello\\", 1)]) == [\\"hello\\"] def test_case_k_is_0(): assert keep_every_kth_char([(\\"hello\\", 0)]) == [\\"\\"] def test_multiple_cases(): assert keep_every_kth_char([(\\"abcdefghi\\", 2), (\\"hello\\", 3), (\\"python\\", 1)]) == [\\"bdfh\\", \\"l\\", \\"python\\"] def test_case_with_large_k(): assert keep_every_kth_char([(\\"abcdefghijklmnopqrstuvwxyz\\", 30)]) == [\\"\\"] def test_case_with_empty_string(): assert keep_every_kth_char([(\\"\\", 5)]) == [\\"\\"] def test_every_possible_k(): S = \\"abcdef\\" for k in range(len(S)+1): if k == 0: expected = \\"\\" else: expected = S[k-1::k] assert keep_every_kth_char([(S, k)]) == [expected]","solution":"def keep_every_kth_char(test_cases): For each test case, returns a new string formed by keeping every K-th character of S and removing all others. Note that indexing is 1-based. results = [] for S, K in test_cases: if K == 0: results.append(\\"\\") else: # Convert K to zero-indexed for operations result_string = S[K-1::K] results.append(result_string) return results"},{"question":"def possible_coordinates(n: int, m: int, k: int, maze: List[List[str]]) -> Set[Tuple[int, int]]: Returns a set of all possible unique coordinates the user can be at within the specified steps in the maze. Parameters: n (int): Number of rows in the maze. m (int): Number of columns in the maze. k (int): Maximum number of steps the user can take. maze (List[List[str]]): 2D matrix representing the maze where '.' is an empty cell and '#' is an obstacle. Returns: Set[Tuple[int, int]]: Set of tuples representing the coordinates the user can be in within exactly k steps. >>> possible_coordinates(2, 2, 1, [['.', '.'], ['.', '#']]) {(0, 0), (0, 1), (1, 0)} >>> possible_coordinates(3, 3, 3, [['.', '#', '.'], ['.', '.', '#'], ['#', '.', '.']]) {(0, 0), (0, 2), (1, 0), (1, 1), (2, 1), (2, 2)} from solution import possible_coordinates def test_small_maze(): maze = [ ['.', '.'], ['.', '#'] ] assert possible_coordinates(2, 2, 1, maze) == {(0, 0), (0, 1), (1, 0)} def test_medium_maze(): maze = [ ['.', '#', '.', '.'], ['.', '.', '.', '#'], ['#', '.', '#', '.'], ] expected_output = { (0, 0), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (2, 1), (2, 3) } assert possible_coordinates(3, 4, 2, maze) == expected_output def test_large_maze_with_no_obstacles(): maze = [ ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'], ['.', '.', '.', '.'] ] expected_output = { (0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3), (3, 0), (3, 1), (3, 2), (3, 3) } assert possible_coordinates(4, 4, 3, maze) == expected_output def test_maze_with_obstacles(): maze = [ ['.', '#', '.'], ['.', '.', '#'], ['#', '.', '.'] ] expected_output = { (0, 0), (0, 2), (1, 0), (1, 1), (2, 1), (2, 2) } assert possible_coordinates(3, 3, 3, maze) == expected_output def test_single_step_maze(): maze = [ ['.', '#'], ['#', '.'] ] expected_output = {(0, 0), (1, 1)} assert possible_coordinates(2, 2, 1, maze) == expected_output","solution":"def possible_coordinates(n, m, k, maze): Returns a set of all possible unique coordinates the user can be at within the specified steps in the maze. from collections import deque def bfs(start_x, start_y): Performs BFS to find all reachable cells from a starting point within k steps. directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start_x, start_y, 0)]) visited = set([(start_x, start_y)]) while queue: x, y, steps = queue.popleft() if steps > k: continue reachable.add((x, y)) for dir in directions: nx, ny = x + dir[0], y + dir[1] if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and maze[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) reachable = set() for i in range(n): for j in range(m): if maze[i][j] == '.': bfs(i, j) return reachable"},{"question":"def min_operations_to_even(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the minimum number of operations required to make all elements of the array even. >>> min_operations_to_even(2, [(3, [1, 3, 5]), (4, [2, 4, 6, 8])]) [1, 0] >>> min_operations_to_even(1, [(4, [2, 4, 6, 8])]) [0] >>> min_operations_to_even(1, [(3, [2, 2, 1])]) [-1] >>> min_operations_to_even(1, [(5, [0, 2, 4, 6, 8])]) [0] >>> min_operations_to_even(1, [(5, [1, 3, 5, 7, 9])]) [2] >>> min_operations_to_even(1, [(6, [2, 4, 5, 7, 12, 14])]) [1]","solution":"def min_operations_to_even(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] array = test_cases[i][1] odd_count = sum(1 for num in array if num % 2 != 0) # If there are no odd numbers, no operations are needed if odd_count == 0: results.append(0) # If there is exactly one odd number, it is impossible to make all numbers even elif odd_count == 1: results.append(-1) else: # If there are more than one odd numbers, one operation is sufficient results.append(odd_count // 2) return results"},{"question":"def max_value(W, N, item_data): Determine the maximum value that can be carried in a backpack with given weight constraints. >>> max_value(5, 4, ['2 3', '3 4', '4 5', '5 6']) 7 >>> max_value(1, 1, ['1 1']) 1 >>> max_value(10, 3, ['5 0', '4 0', '3 0']) 0 >>> max_value(10, 4, ['2 1', '3 2', '4 5', '5 6']) 11 >>> max_value(5, 2, ['6 10', '7 20']) 0 >>> max_value(7, 3, ['2 2', '3 4', '2 2']) 8","solution":"def knapsack(W, N, items): dp = [[0] * (W + 1) for _ in range(N + 1)] for i in range(1, N + 1): weight, value = items[i - 1] for w in range(W + 1): if weight <= w: dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weight] + value) else: dp[i][w] = dp[i - 1][w] return dp[N][W] # Function to parse input and call knapsack def max_value(W, N, item_data): items = [tuple(map(int, item.split())) for item in item_data] return knapsack(W, N, items)"},{"question":"def makeHappy(s: str) -> bool: Determines if a string s is a happy string. If it is, returns True. If it's not, returns the minimum number of swaps required to make it happy. If it's impossible to make it happy, returns -1. A string is considered happy if no two adjacent characters are the same. >>> makeHappy(\\"aab\\") == 1 >>> makeHappy(\\"aaab\\") == -1 >>> makeHappy(\\"abac\\") == True >>> makeHappy(\\"abcde\\") == True >>> makeHappy(\\"abababab\\") == True >>> makeHappy(\\"aabb\\") == 1 >>> makeHappy(\\"aaaa\\") == -1 >>> makeHappy(\\"a\\") == True","solution":"def makeHappy(s): Determines if a string s is a happy string. If it is, returns True. If it's not, returns the minimum number of swaps required to make it happy. If it's impossible to make it happy, returns -1. A string is considered happy if no two adjacent characters are the same. def countSwaps(s): swaps = 0 i = 0 n = len(s) while i < n - 1: if s[i] == s[i + 1]: swaps += 1 # Try to swap with next next character if possible if i + 2 < n and s[i] != s[i + 2]: # Swap s[i+1] and s[i+2] s = s[:i + 1] + s[i + 2] + s[i + 1] + s[i + 3:] else: return -1 # not possible to make it happy i += 1 return swaps # Check if the string is already happy happy = True for i in range(len(s) - 1): if s[i] == s[i + 1]: happy = False break if happy: return True else: return countSwaps(s)"},{"question":"class DirectedGraph: def __init__(self, n): Initialize the directed graph with n nodes. pass def add_edge(self, u: int, v: int): Add a directed edge from node u to node v. pass def remove_edge(self, u: int, v: int): Remove the directed edge from node u to node v. pass def query_reachable(self, u: int, v: int) -> bool: Determine if there is a path from node u to node v. pass # Sample data for testing graph = DirectedGraph(4) graph.add_edge(1, 2) graph.add_edge(2, 3) assert graph.query_reachable(1, 2) == True assert graph.query_reachable(1, 3) == True assert graph.query_reachable(1, 4) == False graph.add_edge(3, 4) assert graph.query_reachable(1, 4) == True graph.remove_edge(3, 4) assert graph.query_reachable(1, 4) == False","solution":"class DirectedGraph: def __init__(self, n): self.n = n self.adj_list = [[] for _ in range(n + 1)] def add_edge(self, u, v): self.adj_list[u].append(v) def remove_edge(self, u, v): if v in self.adj_list[u]: self.adj_list[u].remove(v) def query_reachable(self, u, v): visited = [False] * (self.n + 1) return self.dfs(u, v, visited) def dfs(self, u, v, visited): if u == v: return True visited[u] = True for neighbor in self.adj_list[u]: if not visited[neighbor]: if self.dfs(neighbor, v, visited): return True return False # Sample data for testing graph = DirectedGraph(4) graph.add_edge(1, 2) graph.add_edge(2, 3) assert graph.query_reachable(1, 2) == True assert graph.query_reachable(1, 3) == True assert graph.query_reachable(1, 4) == False graph.add_edge(3, 4) assert graph.query_reachable(1, 4) == True graph.remove_edge(3, 4) assert graph.query_reachable(1, 4) == False"},{"question":"from typing import List def min_cars(n: int, capacities: List[int], rates: List[int], m: int, distances: List[int]) -> int: Optimizes the usage of the fleet to minimize the total number of cars used to complete all deliveries. Each car can only be used once and must start with a full tank of fuel. Each delivery must be serviced by an individual car that can travel the distance required for the delivery without refueling. Args: n (int): Number of delivery cars. capacities (List[int]): Fuel capacities of each car. rates (List[int]): Fuel consumption rates of each car. m (int): Number of deliveries. distances (List[int]): Distance of each delivery. Returns: int: The minimal number of cars required to service all the deliveries, or -1 if it is not possible. Examples: >>> min_cars(5, [10, 20, 30, 40, 50], [1, 2, 3, 4, 5], 3, [30, 40, 50]) 3 >>> min_cars(5, [15, 25, 5, 10, 30], [5, 10, 3, 4, 7], 4, [100, 200, 300, 400]) -1 >>> min_cars(3, [20, 30, 40], [2, 3, 4], 3, [30, 60, 90]) 3 >>> min_cars(1, [100], [1], 1, [50]) 1 >>> min_cars(2, [50, 100], [3, 2], 2, [100, 300]) -1 >>> min_cars(4, [50, 50, 50, 50], [1, 1, 1, 1], 4, [50, 50, 50, 50]) 4 >>> min_cars(5, [100, 200, 300, 400, 500], [5, 5, 5, 5, 5], 5, [100, 200, 300, 400, 500]) 5","solution":"def min_cars(n, capacities, rates, m, distances): # Calculate the maximum distance each car can travel max_distances = [capacities[i] * rates[i] for i in range(n)] # Sort cars by their max distance they can travel in descending order max_distances.sort(reverse=True) # Sort deliveries by distance in descending order distances.sort(reverse=True) # Index to track the current car car_index = 0 used_cars = 0 for distance in distances: # Find a car that can handle this delivery while car_index < n and max_distances[car_index] < distance: car_index += 1 if car_index == n: return -1 used_cars += 1 car_index += 1 return used_cars"},{"question":"def can_meet_food_requirements(n, t, r, food_units): Determine if it is possible to meet the food requirements for all soldiers each day. Args: n (int): Number of soldiers. t (int): Number of days. r (int): Food requirement per soldier per day. food_units (list): List of available food units for each day. Returns: str: \\"YES\\" if it is possible to meet the food requirements, \\"NO\\" otherwise. Examples: >>> can_meet_food_requirements(3, 5, 2, [6, 15, 12, 9, 8]) 'YES' >>> can_meet_food_requirements(4, 4, 3, [18, 8, 10, 12]) 'NO'","solution":"def can_meet_food_requirements(n, t, r, food_units): Determine if it is possible to meet the food requirements for all soldiers each day. Args: n (int): Number of soldiers. t (int): Number of days. r (int): Food requirement per soldier per day. food_units (list): List of available food units for each day. Returns: str: \\"YES\\" if it is possible to meet the food requirements, \\"NO\\" otherwise. required_food_per_day = n * r for units in food_units: if units < required_food_per_day: return \\"NO\\" return \\"YES\\" # Example usage: # print(can_meet_food_requirements(3, 5, 2, [6, 15, 12, 9, 8])) # Output: YES # print(can_meet_food_requirements(4, 4, 3, [18, 8, 10, 12])) # Output: NO"},{"question":"from typing import List def max_seeds(n: int, m: int, grid: List[str]) -> int: Computes the maximum number of seeds that can be planted within a single contiguous rectangular area of fertile soil. >>> max_seeds(4, 5, [\\"..#..\\", \\"...\\", \\".\\", \\".#...\\"]) 4 >>> max_seeds(3, 3, [\\"..#\\", \\".#.\\", \\"#\\"]) 2 >>> max_seeds(3, 3, [\\"...\\", \\"...\\", \\"...\\"]) 9 >>> max_seeds(3, 3, [\\"#\\", \\"#\\", \\"#\\"]) 0 >>> max_seeds(4, 4, [\\"....\\", \\"..\\", \\"..\\", \\"....\\"]) 4","solution":"def max_seeds(n, m, grid): max_seeds = 0 heights = [0] * m def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[stack[-1]] >= heights[i]: height = heights[stack.pop()] width = i if not stack else i - stack[-1] - 1 max_area = max(max_area, height * width) stack.append(i) return max_area for r in range(n): for c in range(m): if grid[r][c] == '.': heights[c] += 1 else: heights[c] = 0 max_seeds = max(max_seeds, largest_rectangle_area(heights)) return max_seeds"},{"question":"def longest_subsequence_length(arr): Returns the length of the longest subsequence such that each element in the subsequence is greater than the previous one by exactly 2. >>> longest_subsequence_length([1, 3, 5, 7, 9]) 5 >>> longest_subsequence_length([4, 6, 8, 10, 3, 1]) 4 >>> longest_subsequence_length([1, 4, 7, 10]) 1 >>> longest_subsequence_length([]) 0 >>> longest_subsequence_length([2, 4, 6, 8, 10, 12, 14, 16]) 8 def solve(testcases): results = [] for case in testcases: N, arr = case results.append(longest_subsequence_length(arr)) return results","solution":"def longest_subsequence_length(arr): Returns the length of the longest subsequence such that each element in the subsequence is greater than the previous one by exactly 2. n = len(arr) if n == 0: return 0 # Dictionary to store the length of subsequence ending with a particular element dp = {} max_length = 1 for num in arr: prev_num = num - 2 if prev_num in dp: dp[num] = dp.get(num, 1) dp[num] = max(dp[num], dp[prev_num] + 1) else: dp[num] = 1 max_length = max(max_length, dp[num]) return max_length def solve(testcases): results = [] for case in testcases: N, arr = case results.append(longest_subsequence_length(arr)) return results"},{"question":"def can_build_pyramid(L, T, b, c): Determines if the pyramid can be constructed with the given levels, blocks, and compatibilities. L: Number of levels in the pyramid T: Number of different block types b: List of integers representing the quantity of each type of block available c: List of integers representing the level compatibility of each type of block Returns \\"YES\\" if the pyramid can be built, otherwise \\"NO\\". >>> can_build_pyramid(3, 2, [10, 20], [3, 3]) \\"YES\\" >>> can_build_pyramid(4, 3, [10, 5, 2], [2, 3, 4]) \\"NO\\" >>> can_build_pyramid(5, 4, [15, 10, 6, 8], [5, 4, 4, 3]) \\"YES\\" from solution import can_build_pyramid def test_examples(): assert can_build_pyramid(3, 2, [10, 20], [3, 3]) == \\"YES\\" assert can_build_pyramid(4, 3, [10, 5, 2], [2, 3, 4]) == \\"NO\\" assert can_build_pyramid(5, 4, [15, 10, 6, 8], [5, 4, 4, 3]) == \\"YES\\" def test_additional_cases(): assert can_build_pyramid(1, 1, [1], [1]) == \\"YES\\" assert can_build_pyramid(1, 1, [0], [1]) == \\"NO\\" assert can_build_pyramid(2, 2, [1, 3], [1, 2]) == \\"YES\\" assert can_build_pyramid(3, 3, [1, 2, 3], [3, 3, 3]) == \\"YES\\" assert can_build_pyramid(3, 2, [1, 2], [2, 2]) == \\"NO\\" assert can_build_pyramid(6, 3, [10, 15, 20], [1, 2, 3]) == \\"NO\\" assert can_build_pyramid(6, 3, [21, 15, 20], [6, 6, 6]) == \\"YES\\"","solution":"def can_build_pyramid(L, T, b, c): Determines if the pyramid can be constructed with the given levels, blocks, and compatibilities. L: Number of levels in the pyramid T: Number of different block types b: List of integers representing the quantity of each type of block available c: List of integers representing the level compatibility of each type of block Returns \\"YES\\" if the pyramid can be built, otherwise \\"NO\\". # Calculate the total number of blocks needed total_blocks_needed = sum(range(1, L + 1)) # Calculate the total number of usable blocks total_blocks_available = 0 for i in range(T): if c[i] >= L: total_blocks_available += b[i] return \\"YES\\" if total_blocks_available >= total_blocks_needed else \\"NO\\""},{"question":"def find_max_height(N: int, M: int, operations: List[Tuple[int, int, int]]) -> int: Determine the maximum height among the towers after a series of operations. >>> find_max_height(5, 3, [(1, 3, 2), (2, 4, 3), (1, 5, 1)]) 7 >>> find_max_height(1, 1, [(1, 1, 5)]) 6 >>> find_max_height(4, 0, []) 1 >>> find_max_height(5, 1, [(1, 5, 3)]) 4 >>> find_max_height(6, 2, [(1, 3, 1), (4, 6, 2)]) 3 >>> find_max_height(5, 2, [(1, 5, 1), (1, 5, 1)]) 3","solution":"def find_max_height(N, M, operations): # Initialize the heights of all towers heights = [1] * N # Process each operation for L, R, H in operations: for i in range(L-1, R): heights[i] += H # Return the maximum height after all operations return max(heights)"},{"question":"def can_deliver_message(n, m, connections, s, d): Determine if the message can be delivered from the source node to the destination node in a network of computers. :param n: Number of nodes :param m: Number of direct connections :param connections: List of tuples representing direct connections between nodes (u, v) :param s: Source node :param d: Destination node :return: \\"YES\\" if the message can be delivered, otherwise \\"NO\\" >>> can_deliver_message(6, 5, [(1, 2), (2, 3), (3, 4), (5, 6), (4, 5)], 1, 6) 'YES' >>> can_deliver_message(5, 3, [(1, 2), (2, 3), (4, 5)], 1, 5) 'NO' >>> can_deliver_message(5, 3, [(1, 2), (2, 3), (4, 5)], 1, 3) 'YES' >>> can_deliver_message(4, 0, [], 1, 4) 'NO' >>> can_deliver_message(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 3, 1) 'YES' >>> can_deliver_message(4, 3, [(1, 2), (2, 3), (1, 4)], 3, 4) 'YES' pass","solution":"def can_deliver_message(n, m, connections, s, d): from collections import defaultdict, deque graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) # because it is an undirected connection visited = set() queue = deque([s]) while queue: current = queue.popleft() if current == d: return \\"YES\\" if current not in visited: visited.add(current) for neighbor in graph[current]: if neighbor not in visited: queue.append(neighbor) return \\"NO\\""},{"question":"def process_test_cases(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Processes multiple test cases and checks for each case if there is a stretch of K consecutive days where sales are strictly increasing. :param T: Number of test cases :param test_cases: A list containing tuples for each test case, where each tuple contains N, K, and sales data. :return: A list of results for each test case. >>> process_test_cases(3, [(5, 3, [1, 2, 3, 2, 1]), (7, 4, [1, 3, 5, 7, 2, 4, 6]), (4, 4, [4, 3, 2, 1])]) ['YES', 'YES', 'NO'] >>> process_test_cases(1, [(6, 3, [5, 5, 5, 5, 5, 5])]) ['NO'] >>> process_test_cases(1, [(5, 5, [1, 2, 3, 4, 5])]) ['YES'] >>> process_test_cases(1, [(6, 5, [1, 100000, 2, 100000, 3, 100000])]) ['NO'] >>> process_test_cases(1, [(1, 1, [0])]) ['YES']","solution":"def is_increasing_stretch_exists(N, K, sales): This function checks if there is a stretch of K consecutive days where sales are strictly increasing in the given sales data. :param N: An integer representing the number of days. :param K: An integer representing the length of the stretch. :param sales: A list of integers representing the sales made on each day. :return: \\"YES\\" if such a stretch exists, otherwise \\"NO\\". if K > N: return \\"NO\\" for i in range(N - K + 1): increasing = True for j in range(1, K): if sales[i + j - 1] >= sales[i + j]: increasing = False break if increasing: return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): Processes multiple test cases and checks for each case if there is a stretch of K consecutive days where sales are strictly increasing. :param T: Number of test cases :param test_cases: A list containing tuples for each test case, where each tuple contains N, K, and sales data. :return: A list of results for each test case. results = [] for test_case in test_cases: N, K, sales = test_case result = is_increasing_stretch_exists(N, K, sales) results.append(result) return results"},{"question":"def caesar_cipher(text: str, shift: int) -> str: Encodes a message by shifting each letter a fixed number of places down the alphabet. Args: text (str): The original message string. shift (int): The fixed number of places to shift each letter. Returns: str: The encoded message. >>> caesar_cipher(\\"Hello, World!\\", 3) 'Khoor, Zruog!' >>> caesar_cipher(\\"abc-xyz\\", 2) 'cde-zab' >>> caesar_cipher(\\"No Change\\", 0) 'No Change' >>> caesar_cipher(\\"Full Shift\\", 26) 'Full Shift' >>> caesar_cipher(\\"XYZ\\", 3) 'ABC' >>> caesar_cipher(\\"Shift 123\\", 4) 'Wlmjx 123' # Implementation goes here","solution":"def caesar_cipher(text, shift): Encodes a message by shifting each letter a fixed number of places down the alphabet. Args: text (str): The original message string. shift (int): The fixed number of places to shift each letter. Returns: str: The encoded message. encoded_message = [] for char in text: if char.isalpha(): ascii_offset = ord('A') if char.isupper() else ord('a') encoded_char = chr((ord(char) - ascii_offset + shift) % 26 + ascii_offset) encoded_message.append(encoded_char) else: encoded_message.append(char) return ''.join(encoded_message)"},{"question":"def min_points_to_cover_intervals(intervals: List[Tuple[int, int]]) -> int: Determines the minimum number of points needed to cover all the intervals. >>> min_points_to_cover_intervals([(1, 4), (2, 5), (3, 6)]) 1 >>> min_points_to_cover_intervals([(1, 2), (2, 3), (3, 4), (4, 5)]) 2 >>> min_points_to_cover_intervals([(1, 10), (2, 3)]) 1 >>> min_points_to_cover_intervals([]) 0 >>> min_points_to_cover_intervals([(0, 5)]) 1 >>> min_points_to_cover_intervals([(1, 2), (3, 4), (5, 6)]) 3 >>> min_points_to_cover_intervals([(1, 3), (1, 3), (1, 3), (1, 3)]) 1 >>> min_points_to_cover_intervals([(1, 1000000000), (2, 999999999), (100, 200)]) 1","solution":"def min_points_to_cover_intervals(intervals): Determines the minimum number of points needed to cover all the intervals. :param intervals: List of tuples, where each tuple contains two integers representing the start and end of an interval. :return: Minimum number of points required to cover all the intervals. if not intervals: return 0 # Sort the intervals based on end time intervals.sort(key=lambda x: x[1]) n = len(intervals) points = [] # Take the end of the first interval as the first point point = intervals[0][1] points.append(point) for i in range(1, n): # If the current interval is not covered by the current point if intervals[i][0] > point: point = intervals[i][1] points.append(point) return len(points)"},{"question":"def max_profit(prices: List[int]) -> int: Finds the maximum profit that can be achieved by buying and selling the stock on different days. If no profit is possible, returns 0. :param prices: List[int] - List of stock prices where prices[i] is the price on the ith day. :return: int - Maximum profit possible from a single buy and sell transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3, 1]) == 0 >>> max_profit([3, 8, 8, 55, 38, 1, 7, 42, 54, 53]) == 53 >>> max_profit([10, 22, 5, 75, 65, 80]) == 75 >>> max_profit([90, 80, 70, 60, 50, 40, 30]) == 0 >>> max_profit([1, 6, 7, 8, 5, 3, 4, 10, 20]) == 19","solution":"def max_profit(prices): Finds the maximum profit that can be achieved by buying and selling the stock on different days. If no profit is possible, returns 0. :param prices: List[int] - List of stock prices where prices[i] is the price on the ith day. :return: int - Maximum profit possible from a single buy and sell transaction. if not prices or len(prices) < 2: return 0 min_price = prices[0] max_profit = 0 for price in prices[1:]: if price < min_price: min_price = price else: profit = price - min_price if profit > max_profit: max_profit = profit return max_profit"},{"question":"def set_zeroes(matrix): Modify the input matrix such that if an element is 0, its entire row and column are set to 0. >>> matrix = [ ... [0, 1, 2, 0], ... [3, 4, 5, 2], ... [1, 3, 1, 5] ... ] >>> set_zeroes(matrix) >>> matrix [ [0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0] ]","solution":"def set_zeroes(matrix): Modify the input matrix such that if an element is 0, its entire row and column are set to 0. m = len(matrix) n = len(matrix[0]) rows, cols = set(), set() # First pass: Identify rows and columns that need to be zeroed. for i in range(m): for j in range(n): if matrix[i][j] == 0: rows.add(i) cols.add(j) # Second pass: Set rows and columns to zero. for i in range(m): for j in range(n): if i in rows or j in cols: matrix[i][j] = 0"},{"question":"def distribute_candies(T: int, test_cases: List[Tuple[int, int]]) -> List[List[int]]: Alice is hosting a game in which she distributes candies to participants. Each participant gets exactly one candy during distribution from the first participant to the last, then back to the first and so on. Parameters: T (int): number of test cases test_cases (List[Tuple[int, int]]): each tuple contains two integers N and C - the number of participants and the number of candies respectively. Returns: List[List[int]]: For each test case, returns the distribution of candies to participants. Examples: >>> distribute_candies(3, [(3, 7), (4, 10), (2, 5)]) [[3, 2, 2], [3, 3, 2, 2], [3, 2]]","solution":"def distribute_candies(T, test_cases): results = [] for N, C in test_cases: distribution = [0] * N for i in range(C): distribution[i % N] += 1 results.append(distribution) return results"},{"question":"def min_operations_to_equal_elements(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the minimum number of operations required to make all elements of the array equal. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer N and a list of N non-negative integers representing the array B. Returns: List[int]: A list of integers where each integer is the minimum number of operations required for the corresponding test case. >>> min_operations_to_equal_elements(3, [(4, [1, 2, 3, 4]), (5, [7, 7, 7, 7, 7]), (3, [0, 1, 2])]) [3, 0, 2]","solution":"def min_operations_to_equal_elements(t, test_cases): def min_operations(N, B): # Convert the list to a dictionary and count occurrences of each element from collections import Counter counts = Counter(B) # Find the maximum frequency max_freq = max(counts.values()) # To make all elements equal to the most frequent one, we need N - max_freq operations return N - max_freq results = [] for i in range(t): N, B = test_cases[i] results.append(min_operations(N, B)) return results"},{"question":"import itertools from typing import List def tsp_min_cost(n: int, cost_matrix: List[List[int]]) -> int: Solves the Traveling Salesman Problem to find the minimum cost of completing the tour. Parameters: n (int): The number of cities. cost_matrix (List[List[int]]): A 2D list representing the flight costs. Returns: int: The minimum cost of completing the tour. >>> n = 4 >>> cost_matrix = [ >>> [0, 10, 15, 20], >>> [10, 0, 35, 25], >>> [15, 35, 0, 30], >>> [20, 25, 30, 0] >>> ] >>> tsp_min_cost(n, cost_matrix) 80 >>> n = 3 >>> cost_matrix = [ >>> [0, 10, 15], >>> [10, 0, 20], >>> [15, 20, 0] >>> ] >>> tsp_min_cost(n, cost_matrix) 45 # Test Cases def test_example_1(): n = 4 cost_matrix = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert tsp_min_cost(n, cost_matrix) == 80 def test_example_2(): n = 3 cost_matrix = [ [0, 10, 15], [10, 0, 20], [15, 20, 0] ] assert tsp_min_cost(n, cost_matrix) == 45 def test_minimum_case(): n = 2 cost_matrix = [ [0, 1], [1, 0] ] assert tsp_min_cost(n, cost_matrix) == 2 def test_max_flight_cost(): n = 4 cost_matrix = [ [0, 100, 200, 300], [100, 0, 400, 500], [200, 400, 0, 600], [300, 500, 600, 0] ] assert tsp_min_cost(n, cost_matrix) == 1400 def test_identical_flight_costs(): n = 4 cost_matrix = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert tsp_min_cost(n, cost_matrix) == 4 def test_zero_flight_cost(): n = 3 cost_matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert tsp_min_cost(n, cost_matrix) == 0","solution":"import itertools def tsp_min_cost(n, cost_matrix): Solves the Traveling Salesman Problem using a brute-force approach. Parameters: n (int): The number of cities. cost_matrix (list of list of ints): A 2D list representing the flight costs. Returns: int: The minimum cost of completing the tour. all_permutations = itertools.permutations(range(1, n)) min_cost = float('inf') for perm in all_permutations: current_cost = 0 k = 0 for j in perm: current_cost += cost_matrix[k][j] k = j current_cost += cost_matrix[k][0] # return to the starting city if current_cost < min_cost: min_cost = current_cost return min_cost"},{"question":"def identify_winners(N: int, M: int, participants: List[str], scores: List[List[int]]) -> List[str]: Calculates the total scores of each participant and identifies the winners with the highest cumulative scores. Parameters: - N (int): Number of participants - M (int): Number of rounds - participants (list of str): List of participant IDs - scores (list of list of int): List containing M lists, each of which has N scores for the participants Returns: - List of str: List of IDs of the participant(s) with the highest cumulative score >>> identify_winners(3, 4, [\\"alice\\", \\"bob\\", \\"charlie\\"], [[100, 200, 150], [80, 90, 70], [90, 100, 110], [50, 70, 60]]) [\\"bob\\"] >>> identify_winners(3, 4, [\\"alice\\", \\"bob\\", \\"charlie\\"], [[100, 100, 100], [90, 90, 90], [120, 120, 120], [70, 70, 70]]) [\\"alice\\", \\"bob\\", \\"charlie\\"] >>> identify_winners(3, 4, [\\"alice\\", \\"bob\\", \\"charlie\\"], [[100, 100, 100], [100, 100, 100], [100, 100, 100], [100, 100, 100]]) [\\"alice\\", \\"bob\\", \\"charlie\\"] >>> identify_winners(3, 4, [\\"alice\\", \\"bob\\", \\"charlie\\"], [[1000, 10, 10], [1000, 10, 10], [1000, 10, 10], [1000, 10, 10]]) [\\"alice\\"] >>> identify_winners(3, 4, [\\"alice\\", \\"bob\\", \\"charlie\\"], [[10, 10, 1000], [10, 10, 1000], [10, 10, 1000], [10, 10, 1000]]) [\\"charlie\\"] pass","solution":"def identify_winners(N, M, participants, scores): Calculates the total scores of each participant and identifies the winners with the highest cumulative scores. Parameters: - N (int): Number of participants - M (int): Number of rounds - participants (list of str): List of participant IDs - scores (list of list of int): List containing M lists, each of which has N scores for the participants Returns: - List of str: List of IDs of the participant(s) with the highest cumulative score cumulative_scores = [0] * N for round_scores in scores: for i in range(N): cumulative_scores[i] += round_scores[i] max_score = max(cumulative_scores) winners = [participants[i] for i in range(N) if cumulative_scores[i] == max_score] return winners"},{"question":"def combination_sum(arr, target): Returns all unique combinations of arr where the numbers sum to target. >>> combination_sum([2, 3, 6, 7], 7) [[7]] >>> combination_sum([10, 1, 2, 7, 6, 5], 8) [[1, 2, 5], [1, 7], [2, 6]] >>> combination_sum([2, 3, 2, 2], 7) [[2, 2, 3]] >>> combination_sum([2, 4, 6], 5) [] >>> combination_sum([1, 1, 1, 1], 4) [[1, 1, 1, 1]] # implement the function here","solution":"def combination_sum(arr, target): Returns all unique combinations of arr where the numbers sum to target. # We'll use a recursive helper function to generate the combinations. def backtrack(start, target, path, res): if target == 0: res.append(path) return if target < 0: return for i in range(start, len(arr)): if i > start and arr[i] == arr[i - 1]: continue backtrack(i + 1, target - arr[i], path + [arr[i]], res) arr.sort() result = [] backtrack(0, target, [], result) return result"},{"question":"def check_sudoku_boards(boards: List[List[List[str]]]) -> List[bool]: Check multiple Sudoku boards for validity. Args: boards -- list of 9x9 lists, each representing a Sudoku board. Returns: list of booleans indicating whether each board is valid. def isValidSudoku(board: List[List[str]]) -> bool: Returns True if the given 9x9 Sudoku board is valid, False otherwise. # Function to check if a block (row/column/subgrid) contains valid entries def is_valid_block(block: List[str]) -> bool: block = [num for num in block if num != '.'] return len(block) == len(set(block)) # Check rows and columns for i in range(9): row = [board[i][j] for j in range(9)] column = [board[j][i] for j in range(9)] if not is_valid_block(row) or not is_valid_block(column): return False # Check 3x3 subgrids for i in range(0, 9, 3): for j in range(0, 9, 3): subgrid = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_block(subgrid): return False return True results = [] for board in boards: results.append(isValidSudoku(board)) return results","solution":"def isValidSudoku(board): Returns True if the given 9x9 Sudoku board is valid, False otherwise. def is_valid_block(block): block = [num for num in block if num != '.'] return len(block) == len(set(block)) # Check rows and columns for i in range(9): row = [board[i][j] for j in range(9)] column = [board[j][i] for j in range(9)] if not is_valid_block(row) or not is_valid_block(column): return False # Check 3x3 subgrids for i in range(0, 9, 3): for j in range(0, 9, 3): subgrid = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)] if not is_valid_block(subgrid): return False return True def check_sudoku_boards(boards): Arguments: boards -- list of 9x9 lists, each representing a Sudoku board. Returns: list of booleans indicating whether each board is valid. results = [] for board in boards: results.append(isValidSudoku(board)) return results"},{"question":"def sort_vendors(vendors): Sorts the given list of vendors by their discount rates in descending order. If two vendors have the same discount rate, they are sorted by their quantity thresholds in ascending order. :param vendors: List of tuples, where each tuple contains two integers - discount rate and quantity threshold. :return: A sorted list of tuples. # Your code here def format_vendors(vendors): Formats the list of vendors for output. :param vendors: List of tuples, where each tuple contains two integers - discount rate and quantity threshold. :return: A formatted string to print the vendors. # Your code here","solution":"def sort_vendors(vendors): Sorts the given list of vendors by their discount rates in descending order. If two vendors have the same discount rate, they are sorted by their quantity thresholds in ascending order. :param vendors: List of tuples, where each tuple contains two integers - discount rate and quantity threshold. :return: A sorted list of tuples. # Sort the vendors list by discount rate in descending order and quantity threshold in ascending order sorted_vendors = sorted(vendors, key=lambda x: (-x[0], x[1])) return sorted_vendors def format_vendors(vendors): Formats the list of vendors for output. :param vendors: List of tuples, where each tuple contains two integers - discount rate and quantity threshold. :return: A formatted string to print the vendors. return 'n'.join(f\\"{d} {q}\\" for d, q in vendors)"},{"question":"def count_successful_lasers(N, heights): Calculate the number of successful lasers that can be projected between buildings. Parameters: N : int The number of buildings. heights : List[int] List of integers representing the heights of the buildings. Returns: int The maximum number of successful lasers. from solution import count_successful_lasers def test_example_1(): assert count_successful_lasers(4, [3, 1, 4, 2]) == 4 def test_example_2(): assert count_successful_lasers(5, [2, 5, 3, 4, 1]) == 6 def test_single_building(): assert count_successful_lasers(1, [5]) == 0 def test_two_buildings(): assert count_successful_lasers(2, [5, 3]) == 1 assert count_successful_lasers(2, [3, 5]) == 1 def test_all_same_height(): assert count_successful_lasers(4, [2, 2, 2, 2]) == 6 def test_increasing_heights(): assert count_successful_lasers(5, [1, 2, 3, 4, 5]) == 10 def test_decreasing_heights(): assert count_successful_lasers(5, [5, 4, 3, 2, 1]) == 10","solution":"def count_successful_lasers(N, heights): Calculate the number of successful lasers that can be projected between buildings. Parameters: N : int The number of buildings. heights : List[int] List of integers representing the heights of the buildings. Returns: int The maximum number of successful lasers. successful_lasers = 0 for i in range(N): for j in range(i + 1, N): if all(heights[k] <= max(heights[i], heights[j]) for k in range(i + 1, j)): successful_lasers += 1 return successful_lasers"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring containing at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"aaaaa\\") 5","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring containing at most two distinct characters. Parameters: s (str): Input string consisting of lowercase and uppercase Latin letters. Returns: int: Length of the longest substring containing at most two distinct characters. if len(s) < 3: return len(s) # Sliding window left, right = 0, 0 hashmap = {} max_length = 2 while right < len(s): # Add new character to the hashmap hashmap[s[right]] = right right += 1 # If the hashmap contains more than 2 distinct characters if len(hashmap) > 2: # Find the leftmost character to remove leftmost = min(hashmap.values()) del hashmap[s[leftmost]] # Move left pointer to right of leftmost index left = leftmost + 1 max_length = max(max_length, right - left) return max_length"},{"question":"def count_new_stamps(possessed_stamps, new_stamps): Returns the number of new and unique stamp types that will be added to the collection. Args: possessed_stamps (List[int]): A list of integers representing the types of stamps already possessed. new_stamps (List[int]): A list of integers representing the types of new stamps received. Returns: int: The number of new unique stamp types. Example: >>> count_new_stamps([1, 2, 3, 4, 5], [3, 4, 5, 6]) 1 >>> count_new_stamps([7, 8, 9], [6, 7, 8, 9]) 1","solution":"def count_new_stamps(possessed_stamps, new_stamps): Returns the number of new and unique stamp types that will be added to the collection. possessed_set = set(possessed_stamps) new_set = set(new_stamps) # Determine the number of new stamps not in the possessed set new_unique_stamps = new_set - possessed_set return len(new_unique_stamps)"},{"question":"def min_meeting_rooms(intervals): Determine the minimum number of rooms required to schedule all the guest speakers without any overlap. Args: intervals (List[Tuple[int, int]]): List of tuples where each tuple contains the arrival and departure time of a guest speaker. Returns: int: Minimum number of rooms required. Examples: >>> min_meeting_rooms([(1, 4), (2, 5), (3, 6)]) 3 >>> min_meeting_rooms([(1, 3), (2, 4), (5, 6), (7, 8)]) 2 >>> min_meeting_rooms([(1, 10), (2, 6)]) 2 >>> min_meeting_rooms([(1, 2), (3, 4), (5, 6)]) 1 >>> min_meeting_rooms([(1, 5), (1, 5), (1, 5)]) 3 >>> min_meeting_rooms([(1, 4), (2, 5), (5, 6)]) 2 >>> min_meeting_rooms([(1, 10)]) 1 >>> min_meeting_rooms([(i, i+2) for i in range(0, 100, 2)]) 1 >>> min_meeting_rooms([]) 0","solution":"def min_meeting_rooms(intervals): if not intervals: return 0 # Create a list of all start and end times times = [] for interval in intervals: times.append((interval[0], 'start')) times.append((interval[1], 'end')) # Sort times by time value, if time values are the same, 'end' should go before 'start' times.sort(key=lambda x: (x[0], x[1] == 'start')) room_count = 0 max_rooms = 0 # Iterate through times to calculate the maximum number of concurrent meetings for time in times: if time[1] == 'start': room_count += 1 max_rooms = max(max_rooms, room_count) else: # 'end' room_count -= 1 return max_rooms"},{"question":"def findPair(arr: List[int], target: int) -> List[int]: Determines if any two distinct integers in the array add up to the target sum. Args: - arr (List[int]): an array of integers - target (int): the target sum Returns: - List[int]: a list containing indices of the two numbers that add up to the target, or an empty list if no such pair exists. >>> findPair([2, 7, 11, 15, 3, 6], 9) [0, 1] >>> findPair([1, 2, 3, 4, 5], 10) [] >>> findPair([-1, -2, -3, -4, -5], -8) [2, 4] >>> findPair([0, 4, 3, 0], 0) [0, 3] >>> findPair([1000000000, 500000000, 500000000], 1000000000) [1, 2] >>> findPair([1, 3, 2, 4, 2], 6) [2, 3] >>> large_array = list(range(1, 10001)) >>> findPair(large_array, 19999) [9998, 9999]","solution":"def findPair(arr, target): Determines if any two distinct integers in the array add up to the target sum. Args: - arr (List[int]): an array of integers - target (int): the target sum Returns: - List[int]: a list containing indices of the two numbers that add up to the target, or an empty list if no such pair exists. num_to_index = {} for i, num in enumerate(arr): complement = target - num if complement in num_to_index: return [num_to_index[complement], i] num_to_index[num] = i return []"},{"question":"def add_large_numbers(num1: str, num2: str) -> str: Adds two large non-negative integers represented as strings and returns their sum as a string. >>> add_large_numbers(\\"123\\", \\"456\\") == \\"579\\" >>> add_large_numbers(\\"999\\", \\"1\\") == \\"1000\\" >>> add_large_numbers(\\"123456789123456789123456789\\", \\"987654321987654321987654321\\") == \\"1111111111111111111111111110\\" def test_add_large_numbers(): assert add_large_numbers(\\"123\\", \\"456\\") == \\"579\\" assert add_large_numbers(\\"1\\", \\"2\\") == \\"3\\" assert add_large_numbers(\\"0\\", \\"0\\") == \\"0\\" assert add_large_numbers(\\"999\\", \\"1\\") == \\"1000\\" assert add_large_numbers(\\"123456789\\", \\"987654321\\") == \\"1111111110\\" assert add_large_numbers(\\"123456789123456789123456789\\", \\"987654321987654321987654321\\") == \\"1111111111111111111111111110\\" assert add_large_numbers(\\"99999999999999999999\\", \\"1\\") == \\"100000000000000000000\\" assert add_large_numbers(\\"123\\", \\"7890\\") == \\"8013\\" assert add_large_numbers(\\"987654321\\", \\"12345\\") == \\"987666666\\" assert add_large_numbers(\\"1\\", \\"999999999999\\") == \\"1000000000000\\"","solution":"def add_large_numbers(num1: str, num2: str) -> str: Adds two large non-negative integers represented as strings and returns their sum as a string. # Ensure num1 is the longer number (or they are the same length) if len(num1) < len(num2): num1, num2 = num2, num1 # Reverse the strings to make addition easier num1 = num1[::-1] num2 = num2[::-1] carry = 0 result = [] for i in range(len(num1)): digit1 = int(num1[i]) if i < len(num2): digit2 = int(num2[i]) else: digit2 = 0 digit_sum = digit1 + digit2 + carry result.append(str(digit_sum % 10)) carry = digit_sum // 10 if carry: result.append(str(carry)) # Reverse the result to get the final sum return ''.join(result[::-1])"},{"question":"def max_deck_value(n, k, a): Returns the maximum possible deck value that does not exceed k. n (int): The size of the array a. k (int): The maximum allowed deck value. a (list of int): The values of the cards. return (int): The maximum possible deck value not exceeding k. >>> max_deck_value(5, 10, [2, 3, 5, 8, 7]) 10 >>> max_deck_value(6, 15, [1, 2, 3, 4, 5, 6]) 15 >>> max_deck_value(3, 50, [20, 30, 40]) 50","solution":"def max_deck_value(n, k, a): Returns the maximum possible deck value that does not exceed k. n (int): The size of the array a. k (int): The maximum allowed deck value. a (list of int): The values of the cards. return (int): The maximum possible deck value not exceeding k. from itertools import combinations max_value = 0 # Check all possible subsets for r in range(1, n + 1): for subset in combinations(a, r): subset_sum = sum(subset) if subset_sum <= k: max_value = max(max_value, subset_sum) return max_value"},{"question":"def clean_string(s: str) -> str: Removes all non-alphanumeric characters (excluding spaces) from the input string, ensuring that the resulting string preserves spaces and the original order of characters. Arguments: s -- input string to be cleaned Returns: Cleaned string with only alphanumeric characters and spaces. >>> clean_string(\\"Hello, World! Welcome to 2023!.\\") == \\"Hello World Welcome to 2023\\" >>> clean_string(\\"Hello World\\") == \\"Hello World\\" >>> clean_string(\\"!@#%^&*()\\") == \\"\\" >>> clean_string(\\" This is a test 1234! \\") == \\" This is a test 1234 \\" >>> clean_string(\\"\\") == \\"\\" >>> clean_string(\\" \\") == \\" \\"","solution":"def clean_string(s): Removes all non-alphanumeric characters (excluding spaces) from the input string, ensuring that the resulting string preserves spaces and the original order of characters. Arguments: s -- input string to be cleaned Returns: Cleaned string with only alphanumeric characters and spaces. return ''.join(char for char in s if char.isalnum() or char.isspace())"},{"question":"def min_substrings(s: str) -> int: Returns the minimum number of non-overlapping substrings such that within each substring no two '1's are adjacent to each other. >>> min_substrings(\\"100101\\") 3 >>> min_substrings(\\"111\\") 3 >>> min_substrings(\\"000\\") 1","solution":"def min_substrings(s: str) -> int: Returns the minimum number of non-overlapping substrings such that within each substring no two '1's are adjacent to each other. # Count the number of '1's in the input string. ones_count = s.count('1') # Each '1' must be in its own substring or be separated by '0's. # To ensure no two '1's are adjacent, the only option is to separate them completely. # Therefore, the minimum number of substrings is equal to the number of '1's. return ones_count if ones_count > 0 else 1"},{"question":"def is_subset_sum_possible(n: int, target: int, arr: List[int]) -> str: Determines if there exists a subset of the array with a sum equal to the target value. :param n: Number of elements in the array (integer) :param target: The target sum value (integer) :param arr: List of integers representing the array :return: \\"POSSIBLE\\" if a subset with sum equal to target exists, otherwise \\"IMPOSSIBLE\\" >>> is_subset_sum_possible(5, 9, [3, 34, 4, 12, 5]) 'POSSIBLE' >>> is_subset_sum_possible(3, 11, [1, 2, 3]) 'IMPOSSIBLE'","solution":"def is_subset_sum_possible(n, target, arr): Determines if there exists a subset of the array with a sum equal to the target value. :param n: Number of elements in the array (integer) :param target: The target sum value (integer) :param arr: List of integers representing the array :return: \\"POSSIBLE\\" if a subset with sum equal to target exists, otherwise \\"IMPOSSIBLE\\" dp = [False] * (target + 1) dp[0] = True for num in arr: for j in range(target, num - 1, -1): if dp[j - num]: dp[j] = True return \\"POSSIBLE\\" if dp[target] else \\"IMPOSSIBLE\\""},{"question":"def process_queries(n: int, q: int, s: str, queries: List[Tuple[int, int, int]]) -> List[int]: Processes queries on the given string s. Args: n (int): Length of the string. q (int): Number of queries. s (str): The string to process. queries (list): List of queries, where each query is a tuple (t, l, r). Returns: list: Result of queries of type 2 (count of distinct characters). >>> process_queries(5, 3, \\"abcba\\", [(2, 0, 4), (1, 1, 3), (2, 0, 4)]) [3, 3] >>> process_queries(10, 4, \\"hellothere\\", [(2, 0, 9), (1, 4, 7), (2, 0, 9), (2, 5, 9)]) [6, 6, 5]","solution":"def process_queries(n, q, s, queries): Processes queries on the given string s. Args: n (int): Length of the string. q (int): Number of queries. s (str): The string to process. queries (list): List of queries, where each query is a tuple (t, l, r). Returns: list: Result of queries of type 2 (count of distinct characters). s = list(s) # Mutable string results = [] for t, l, r in queries: if t == 1: # Reverse the substring s[l:r+1] s[l:r+1] = s[l:r+1][::-1] elif t == 2: # Count distinct characters in the substring s[l:r+1] substring = s[l:r+1] distinct_count = len(set(substring)) results.append(distinct_count) return results"},{"question":"def sum_of_primes_in_range(a: int, b: int) -> int: Compute the sum of prime numbers in a given range [a, b]. >>> sum_of_primes_in_range(10, 20) 60 >>> sum_of_primes_in_range(5, 5) 5 >>> sum_of_primes_in_range(14, 14) 0","solution":"def sum_of_primes_in_range(a, b): Returns the sum of prime numbers in the range [a, b]. def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True sum_primes = 0 for num in range(a, b + 1): if is_prime(num): sum_primes += num return sum_primes"},{"question":"def closest_to_zero_pair(arr): Given an array of integers, finds two distinct elements from the array such that their sum is closest to zero. >>> closest_to_zero_pair([-20, -3, 4, 2, 5, -8]) in [(-3, 4), (4, -3)] True >>> closest_to_zero_pair([1, 60, -10, 70, -80]) in [(-10, 1), (1, -10)] True >>> closest_to_zero_pair([10, 22, -15]) in [(10, -15), (-15, 10)] True","solution":"def closest_to_zero_pair(arr): Returns the pair of distinct elements from the array whose sum is closest to zero. n = len(arr) if n < 2: return None arr.sort() left = 0 right = n - 1 closest_pair = (arr[left], arr[right]) min_sum = abs(arr[left] + arr[right]) while left < right: current_sum = arr[left] + arr[right] if abs(current_sum) < min_sum: min_sum = abs(current_sum) closest_pair = (arr[left], arr[right]) if current_sum < 0: left += 1 else: right -= 1 return closest_pair"},{"question":"def maximal_rectangle_area(grid: List[str]) -> int: Given an m x n grid filled with characters 'A' and 'B', determine the area of the largest rectangle containing only 'A's. >>> maximal_rectangle_area([\\"AAAAA\\", \\"ABAAA\\", \\"AABAA\\", \\"AAAAA\\"]) 8 >>> maximal_rectangle_area([\\"BBB\\", \\"BBB\\", \\"BBB\\"]) 0 >>> maximal_rectangle_area([\\"AAABAA\\", \\"ABBBAA\\", \\"ABAABA\\", \\"AAAAAA\\", \\"BBBBBB\\"]) 6","solution":"def maximal_rectangle_area(grid): if not grid: return 0 m, n = len(grid), len(grid[0]) heights = [0] * n max_area = 0 for row in grid: for j in range(n): if row[j] == 'A': heights[j] += 1 else: heights[j] = 0 max_area = max(max_area, max_histogram_area(heights)) return max_area def max_histogram_area(heights): stack = [] max_area = 0 heights.append(0) for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() return max_area"},{"question":"def longest_substring_with_two_distinct(s: str) -> int: Find the length of the longest substring containing at most two distinct characters. Args: s (str): The input string composed of lowercase English letters. Returns: int: The length of the longest substring with at most two distinct characters. Examples: >>> longest_substring_with_two_distinct(\\"eceba\\") 3 >>> longest_substring_with_two_distinct(\\"ccaabbb\\") 5 >>> longest_substring_with_two_distinct(\\"a\\") 1","solution":"def longest_substring_with_two_distinct(s: str) -> int: if not s: return 0 # Dictionary to store the last positions of each character last_seen = {} left = 0 max_len = 0 for right in range(len(s)): last_seen[s[right]] = right # If we have more than two distinct characters, move the left pointer while len(last_seen) > 2: if last_seen[s[left]] == left: del last_seen[s[left]] left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, edges: List[Tuple[int, int, int]], start: int, target: int) -> int: Given an undirected graph with \`n\` nodes and \`m\` edges, find the shortest path from a given start node to a given target node by traversing edges. Each edge in the graph is associated with a cost. If no such path exists, return \`-1\`. >>> dijkstra(5, [(1, 2, 3), (1, 3, 2), (2, 3, 4), (2, 4, 1), (3, 4, 1), (4, 5, 6)], 1, 5) 9 >>> dijkstra(3, [(1, 2, 5)], 2, 3) -1 # Your code here # Test cases def test_case_1(): n = 5 m = 6 edges = [ (1, 2, 3), (1, 3, 2), (2, 3, 4), (2, 4, 1), (3, 4, 1), (4, 5, 6) ] start = 1 target = 5 assert dijkstra(n, edges, start, target) == 9 def test_case_2(): n = 3 m = 1 edges = [ (1, 2, 5) ] start = 2 target = 3 assert dijkstra(n, edges, start, target) == -1 def test_case_3(): n = 4 m = 4 edges = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (1, 4, 10) ] start = 1 target = 4 assert dijkstra(n, edges, start, target) == 6 def test_case_4(): n = 4 m = 0 edges = [] start = 1 target = 4 assert dijkstra(n, edges, start, target) == -1 def test_case_5(): n = 2 m = 1 edges = [ (1, 2, 1) ] start = 1 target = 2 assert dijkstra(n, edges, start, target) == 1","solution":"import heapq def dijkstra(n, edges, start, target): graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((w, v)) graph[v].append((w, u)) queue = [(0, start)] dist = {i: float('inf') for i in range(1, n + 1)} dist[start] = 0 while queue: current_dist, u = heapq.heappop(queue) if u == target: return current_dist for weight, v in graph[u]: distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(queue, (distance, v)) return -1"},{"question":"def max_free_distance(s: str) -> int: Returns the maximum distance a runner can cover before hitting an obstacle. Parameters: s (str): A string representing the road with obstacles ('#') and free spaces ('.'). Returns: int: The maximum distance of free spaces before encountering an obstacle. >>> max_free_distance(\\"..#....#..\\") 2 >>> max_free_distance(\\"#..#....#.\\") 0 >>> max_free_distance(\\"....#..#\\") 4 >>> max_free_distance(\\"...#..\\") 3","solution":"def max_free_distance(s): Returns the maximum distance a runner can cover before hitting an obstacle. Parameters: s (str): A string representing the road with obstacles ('#') and free spaces ('.'). Returns: int: The maximum distance of free spaces before encountering an obstacle. return s.find('#') if '#' in s else len(s)"},{"question":"def max_non_overlapping_meetings(n: int, meeting_times: List[Tuple[int, int]]) -> int: Given a list of start and end times for meetings, find the maximum number of non-overlapping meetings that can be accommodated. Parameters: n (int): Number of meetings meeting_times (List[Tuple[int, int]]): List of start and end times for meetings Returns: int: Maximum number of non-overlapping meetings Examples: >>> max_non_overlapping_meetings(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_non_overlapping_meetings(4, [(1, 3), (2, 4), (3, 5), (7, 8)]) 3 >>> max_non_overlapping_meetings(2, [(1, 10), (2, 3)]) 1 from typing import List, Tuple def test_example_1(): assert max_non_overlapping_meetings(3, [(1, 2), (2, 3), (3, 4)]) == 3 def test_example_2(): assert max_non_overlapping_meetings(4, [(1, 3), (2, 4), (3, 5), (7, 8)]) == 3 def test_example_3(): assert max_non_overlapping_meetings(2, [(1, 10), (2, 3)]) == 1 def test_no_overlapping(): assert max_non_overlapping_meetings(3, [(1, 5), (6, 10), (11, 15)]) == 3 def test_all_overlapping(): assert max_non_overlapping_meetings(3, [(1, 4), (2, 5), (3, 6)]) == 1 def test_alternating_overlap(): assert max_non_overlapping_meetings(5, [(1, 2), (2, 3), (3, 4), (1, 3), (2, 4)]) == 3 def test_non_overlapping_with_gaps(): assert max_non_overlapping_meetings(5, [(1, 2), (3, 4), (5, 6), (7, 8), (9, 10)]) == 5","solution":"def max_non_overlapping_meetings(n, meeting_times): Returns the maximum number of non-overlapping meetings that can be scheduled. Parameters: n (int): Number of meetings meeting_times (List[Tuple[int, int]]): List of start and end times for meetings Returns: int: Maximum number of non-overlapping meetings # Sort the meetings by their ending times meeting_times.sort(key=lambda x: x[1]) # Keep track of the last ending time last_end_time = 0 count = 0 for start, end in meeting_times: # If the meeting starts after the last meeting ends if start >= last_end_time: # Increment the count and update the last ending time count += 1 last_end_time = end return count"},{"question":"def fibonacci_sum_up_to_m(m: int) -> int: Calculate the sum of all Fibonacci numbers up to F(m). >>> fibonacci_sum_up_to_m(0) 0 >>> fibonacci_sum_up_to_m(1) 1 >>> fibonacci_sum_up_to_m(2) 2 >>> fibonacci_sum_up_to_m(3) 4 >>> fibonacci_sum_up_to_m(5) 12 def process_test_cases(test_cases: list) -> list: Process multiple test cases for summing Fibonacci numbers up to F(M). >>> process_test_cases([3, 5, 8]) [4, 12, 54] >>> process_test_cases([0, 1, 2]) [0, 1, 2]","solution":"def fibonacci_sum_up_to_m(m: int) -> int: Calculate the sum of all Fibonacci numbers up to F(m). if m == 0: return 0 elif m == 1: return 1 fib = [0] * (m + 1) fib[0] = 0 fib[1] = 1 total_sum = fib[0] + fib[1] for i in range(2, m + 1): fib[i] = fib[i - 1] + fib[i - 2] total_sum += fib[i] return total_sum def process_test_cases(test_cases: list) -> list: Process multiple test cases for summing Fibonacci numbers up to F(M). results = [] for m in test_cases: results.append(fibonacci_sum_up_to_m(m)) return results"},{"question":"def count_peak_days(sales): Returns the count of peak days in the sales data. A peak day is defined as a day where the sales are strictly greater than both the previous and the following day. :param sales: List[int] - List of sales figures. :return: int - Count of peak days. >>> count_peak_days([5, 10, 8, 12, 6, 14, 7, 4]) 3 >>> count_peak_days([3, 2, 3, 4]) 1 from typing import List","solution":"def count_peak_days(sales): Returns the count of peak days in the sales data. A peak day is defined as a day where the sales are strictly greater than both the previous and the following day. :param sales: List[int] - List of sales figures. :return: int - Count of peak days. if len(sales) < 3: return 0 peak_count = 0 for i in range(1, len(sales) - 1): if sales[i] > sales[i - 1] and sales[i] > sales[i + 1]: peak_count += 1 return peak_count"},{"question":"def min_path_sum(matrix): Given a matrix of non-negative integers, this function returns the minimum sum of any path from the top-left corner to the bottom-right corner. Parameters: matrix (List[List[int]]): A 2D list representing the matrix of non-negative integers Returns: int: The minimum sum of any path from the top-left corner to the bottom-right corner Example: >>> min_path_sum([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_sum([[1, 2, 3, 4]]) 10 >>> min_path_sum([[1], [2], [3], [4]]) 10 >>> min_path_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> min_path_sum([[5]]) 5 pass","solution":"def min_path_sum(matrix): Given a matrix of non-negative integers, this function returns the minimum sum of any path from the top-left corner to the bottom-right corner. if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) # Initialize the dp table with zeros. dp = [[0] * N for _ in range(M)] # Start from the top-left corner dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, N): dp[0][j] = dp[0][j - 1] + matrix[0][j] # Fill the first column for i in range(1, M): dp[i][0] = dp[i - 1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, M): for j in range(1, N): dp[i][j] = matrix[i][j] + min(dp[i - 1][j], dp[i][j - 1]) # The bottom-right corner will have the answer return dp[M - 1][N - 1] # Example usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) matrix = [] index = 2 for i in range(M): matrix.append([int(data[j]) for j in range(index, index + N)]) index += N print(min_path_sum(matrix))"},{"question":"def calculateNetDonations(donations): Calculates the net total of donations based on positive and negative pledges. Args: donations (list): A list of lists where each sublist contains an amount and a symbol ('+' or '-') Returns: float: The net total of the donations, rounded to two decimal places. pass # example usage: donations = [[100, '+'], [50, '-'], [75, '+'], [25, '-']] print(calculateNetDonations(donations)) # expected result: 100 # Unit Tests def test_calculateNetDonations_mixed(): donations = [[100, '+'], [50, '-'], [75, '+'], [25, '-']] assert calculateNetDonations(donations) == 100 def test_calculateNetDonations_all_positive(): donations = [[100, '+'], [50, '+'], [75, '+'], [25, '+']] assert calculateNetDonations(donations) == 250 def test_calculateNetDonations_all_negative(): donations = [[100, '-'], [50, '-'], [75, '-'], [25, '-']] assert calculateNetDonations(donations) == -250 def test_calculateNetDonations_empty(): donations = [] assert calculateNetDonations(donations) == 0 def test_calculateNetDonations_single_positive(): donations = [[100, '+']] assert calculateNetDonations(donations) == 100 def test_calculateNetDonations_single_negative(): donations = [[100, '-']] assert calculateNetDonations(donations) == -100 def test_calculateNetDonations_mixed_small_values(): donations = [[0.1, '+'], [0.2, '-'], [0.3, '+']] assert calculateNetDonations(donations) == 0.2","solution":"def calculateNetDonations(donations): Calculates the net total of donations based on positive and negative pledges. Args: donations (list): A list of lists where each sublist contains an amount and a symbol ('+' or '-') Returns: float: The net total of the donations, rounded to two decimal places. net_total = 0 for amount, sign in donations: if sign == '+': net_total += amount elif sign == '-': net_total -= amount return round(net_total, 2)"},{"question":"def reverse_and_negate(n: int) -> int: Returns the reverse of the digits of the input integer n and changes its sign. >>> reverse_and_negate(123) -321 >>> reverse_and_negate(-456) 654 >>> reverse_and_negate(1000) -1 >>> reverse_and_negate(0) 0 >>> reverse_and_negate(-900) 9","solution":"def reverse_and_negate(n): Returns the reverse of the digits of the input integer n and changes its sign. # Convert the absolute value of the number to a string and reverse it reversed_number = int(str(abs(n))[::-1]) # Negate the sign depending on the original number's sign return -reversed_number if n > 0 else reversed_number"},{"question":"from typing import List, Tuple def can_communicate_everywhere(n: int, devices: List[Tuple[int, int, int]]) -> str: Determine whether it is possible for every device to communicate with every other device either directly or indirectly given their positions and communication ranges. >>> can_communicate_everywhere(4, [(0, 0, 1), (2, 0, 1), (1, 1, 1), (3, 3, 2)]) \\"YES\\" >>> can_communicate_everywhere(3, [(0, 0, 1), (4, 0, 1), (1, 1, 1)]) \\"NO\\" pass # Unit tests def test_example1(): n = 4 devices = [ (0, 0, 1), (2, 0, 1), (1, 1, 1), (3, 3, 2) ] assert can_communicate_everywhere(n, devices) == \\"YES\\" def test_example2(): n = 3 devices = [ (0, 0, 1), (4, 0, 1), (1, 1, 1) ] assert can_communicate_everywhere(n, devices) == \\"NO\\" def test_all_connected(): n = 3 devices = [ (0, 0, 10), (100, 100, 1000), (500, 500, 500) ] assert can_communicate_everywhere(n, devices) == \\"YES\\" def test_isolated(): n = 3 devices = [ (0, 0, 1), (10, 10, 1), (1000, 1000, 1) ] assert can_communicate_everywhere(n, devices) == \\"NO\\" def test_minimal_case(): n = 2 devices = [ (0, 0, 1), (1, 1, 2) ] assert can_communicate_everywhere(n, devices) == \\"YES\\"","solution":"def can_communicate_everywhere(n, devices): from math import sqrt from collections import deque def distance(x1, y1, x2, y2): return sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2) # Create a graph where nodes are devices and edges indicate communication ability. graph = [[] for _ in range(n)] for i in range(n): x1, y1, r1 = devices[i] for j in range(n): if i != j: x2, y2, r2 = devices[j] if distance(x1, y1, x2, y2) <= r1 + r2: graph[i].append(j) graph[j].append(i) # Perform BFS or DFS to check connectivity def bfs(start): visited = [False] * n queue = deque([start]) visited[start] = True count_visited = 1 while queue: node = queue.popleft() for neighbour in graph[node]: if not visited[neighbour]: visited[neighbour] = True queue.append(neighbour) count_visited += 1 return count_visited == n return \\"YES\\" if bfs(0) else \\"NO\\" # Example usage # n = 4 # devices = [ # (0, 0, 1), # (2, 0, 1), # (1, 1, 1), # (3, 3, 2) # ] # print(can_communicate_everywhere(n, devices))"},{"question":"from typing import List, Tuple def is_path_exists(grid: List[List[int]]) -> str: Determine if there is a path from the top-left to the bottom-right corner in a grid. Args: grid (List[List[int]]): A binary matrix where 1 indicates drivable path and 0 indicates obstacle. Returns: str: \\"Yes\\" if there is a path, otherwise \\"No\\". def determine_path_existence(T: int, test_cases: List[Tuple[Tuple[int, int], List[List[int]]]]) -> List[str]: Determine path existence for multiple test cases. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[List[int]]]]): List of tuples containing matrix dimensions and the grid. Returns: List[str]: List of results (\\"Yes\\" or \\"No\\") for each test case. # Unit Tests def test_is_path_exists_basic(): grid = [ [1, 0, 0], [1, 1, 0], [0, 1, 1] ] assert is_path_exists(grid) == \\"Yes\\" def test_is_path_exists_no_path(): grid = [ [1, 0, 0], [0, 0, 0], [0, 0, 1] ] assert is_path_exists(grid) == \\"No\\" def test_is_path_exists_single_cell_path(): grid = [[1]] assert is_path_exists(grid) == \\"Yes\\" def test_is_path_exists_single_cell_no_path(): grid = [[0]] assert is_path_exists(grid) == \\"No\\" def test_determine_path_existence(): T = 2 test_cases = [ ((3, 3), [ [1, 0, 0], [1, 1, 0], [0, 1, 1] ]), ((3, 3), [ [1, 0, 0], [0, 0, 0], [0, 0, 1] ]) ] assert determine_path_existence(T, test_cases) == [\\"Yes\\", \\"No\\"] def test_determine_path_existence_single_test_case(): T = 1 test_cases = [ ((2, 2), [ [1, 1], [0, 1] ]) ] assert determine_path_existence(T, test_cases) == [\\"Yes\\"]","solution":"def is_path_exists(grid): if not grid or not grid[0] or grid[0][0] == 0 or grid[-1][-1] == 0: return \\"No\\" rows, cols = len(grid), len(grid[0]) directions = [(1,0), (0,1), (-1,0), (0,-1)] visited = set((0, 0)) def bfs(): from collections import deque queue = deque([(0, 0)]) while queue: x, y = queue.popleft() if x == rows - 1 and y == cols - 1: return True for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 1 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return False return \\"Yes\\" if bfs() else \\"No\\" def determine_path_existence(T, test_cases): results = [] for i in range(T): N, M = test_cases[i][0] grid = test_cases[i][1] results.append(is_path_exists(grid)) return results"},{"question":"def int_to_roman(num: int) -> str: Convert an integer to a Roman numeral. >>> int_to_roman(1) \\"I\\" >>> int_to_roman(9) \\"IX\\" >>> int_to_roman(58) \\"LVIII\\" >>> int_to_roman(3999) \\"MMMCMXCIX\\"","solution":"def int_to_roman(num): Convert an integer to a Roman numeral. val = [ 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 ] syb = [ \\"M\\", \\"CM\\", \\"D\\", \\"CD\\", \\"C\\", \\"XC\\", \\"L\\", \\"XL\\", \\"X\\", \\"IX\\", \\"V\\", \\"IV\\", \\"I\\" ] roman_num = '' i = 0 while num > 0: for _ in range(num // val[i]): roman_num += syb[i] num -= val[i] i += 1 return roman_num"},{"question":"from typing import List, Tuple def can_make_equal_to_k(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if all numbers in the collection can be made equal to a given integer k using the bitwise AND operation. >>> can_make_equal_to_k(3, [((4, 1), [2, 3, 3, 4]), ((3, 5), [8, 12, 16]), ((5, 0), [1, 0, 2, 3, 4])]) [\\"no\\", \\"no\\", \\"yes\\"] >>> can_make_equal_to_k(1, [((3, 5), [5, 5, 5])]) [\\"yes\\"] >>> can_make_equal_to_k(1, [((4, 1), [1, 3, 7, 15])]) [\\"yes\\"] >>> can_make_equal_to_k(1, [((3, 7), [8, 9, 10])]) [\\"no\\"]","solution":"def can_make_equal_to_k(t, test_cases): results = [] for test_case in test_cases: n, k = test_case[0] array = test_case[1] if k in array: results.append(\\"yes\\") continue current_and = array[0] for num in array[1:]: current_and &= num if current_and == k: results.append(\\"yes\\") break else: results.append(\\"no\\") return results # Example usage: t = 3 test_cases = [ ((4, 1), [2, 3, 3, 4]), ((3, 5), [8, 12, 16]), ((5, 0), [1, 0, 2, 3, 4]) ] print(can_make_equal_to_k(t, test_cases))"},{"question":"def most_frequent_char(s): Returns the character that appears most frequently in the string. If there is a tie, return the character that appears first. >>> most_frequent_char(\\"abacaba\\") 'a' >>> most_frequent_char(\\"aabbbcc\\") 'b'","solution":"def most_frequent_char(s): Returns the character that appears most frequently in the string. If there is a tie, return the character that appears first. char_count = {} max_char = s[0] max_count = 1 for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 if char_count[char] > max_count or (char_count[char] == max_count and s.index(char) < s.index(max_char)): max_char = char max_count = char_count[char] return max_char"},{"question":"def connect_locations(test_cases): Find one possible way to connect locations with non-overlapping routes. >>> connect_locations([(3, [(0, 0), (2, 2), (3, 3)])]) 'impossible' >>> connect_locations([(4, [(0, 0), (1, 2), (3, 1), (4, 4)])]) [(1, 2), (3, 4)] ... def process_input_output(test_cases_input): Process input data and return the output as described in the problem statement. >>> input_data = '''2 3 0 0 2 2 3 3 4 0 0 1 2 3 1 4 4''' >>> process_input_output(input_data) 'impossiblen1 2n3 4' ... def test_basic_cases(): input_data = 2 3 0 0 2 2 3 3 4 0 0 1 2 3 1 4 4 expected_output = \\"impossiblen1 2n3 4\\" assert process_input_output(input_data) == expected_output def test_all_even_locations(): input_data = 1 6 0 0 1 1 2 2 3 3 4 4 5 5 expected_output = \\"1 2n3 4n5 6\\" assert process_input_output(input_data) == expected_output def test_all_odd_locations(): input_data = 1 5 0 0 1 1 2 2 3 3 4 4 expected_output = \\"impossible\\" assert process_input_output(input_data) == expected_output def test_multiple_cases(): input_data = 3 4 0 0 1 1 2 2 3 3 2 0 0 1 1 5 0 0 1 1 2 2 3 3 4 4 expected_output = \\"1 2n3 4n1 2nimpossible\\" assert process_input_output(input_data) == expected_output","solution":"def connect_locations(test_cases): results = [] for case in test_cases: N, locations = case if N % 2 == 1: results.append(\\"impossible\\") continue pairs = [] for i in range(1, N, 2): pairs.append((i, i+1)) results.append(pairs) return results def process_input_output(test_cases_input): input_lines = test_cases_input.strip().split('n') T = int(input_lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(input_lines[index]) locations = [] for i in range(1, N + 1): x, y = map(int, input_lines[index + i].split()) locations.append((x, y)) test_cases.append((N, locations)) index += N + 1 results = connect_locations(test_cases) output_lines = [] for result in results: if result == \\"impossible\\": output_lines.append(result) else: for pair in result: output_lines.append(f\\"{pair[0]} {pair[1]}\\") return \\"n\\".join(output_lines) # Example function usage # input_data = 2 # 3 # 0 0 # 2 2 # 3 3 # 4 # 0 0 # 1 2 # 3 1 # 4 4 # print(process_input_output(input_data))"},{"question":"def find_split_index(n: int, arr: List[int]) -> int: Determine if you can split the array into two non-empty subarrays such that the sum of the elements in both subarrays is the same. The split point should have at least one element in both resulting subarrays. The function should return the 0-based index \`i\` where the first subarray includes elements from index 0 to \`i\` (inclusive) and the second subarray includes elements from \`i+1\` to the end of the array. If it's not possible to split the array, return -1. :param n: int - number of elements in the array :param arr: List[int] - list of integers representing the array :return: int - the index \`i\` where the split can be made, or -1 if not possible Examples: >>> find_split_index(7, [1, 2, 3, 4, 5, 6, 21]) 5 >>> find_split_index(5, [1, -1, 1, -1, 1]) -1 pass def test_find_split_index_example1(): n = 7 arr = [1, 2, 3, 4, 5, 6, 21] assert find_split_index(n, arr) == 5 def test_find_split_index_example2(): n = 5 arr = [1, -1, 1, -1, 1] assert find_split_index(n, arr) == -1 def test_find_split_index_single_possible_split(): n = 3 arr = [1, 1, 2] assert find_split_index(n, arr) == 1 def test_find_split_index_no_valid_split(): n = 4 arr = [1, 1, 1, 1] assert find_split_index(n, arr) == 1 def test_find_split_index_even_sum_no_possible_split(): n = 6 arr = [1, 2, 1, 2, 1, 2] assert find_split_index(n, arr) == -1 def test_find_split_index_large_balanced_array(): n = 10 arr = [2, 2, 2, 2, 2, 2, 2, 2, 2, 2] assert find_split_index(n, arr) == 4 def test_find_split_index_large_unbalanced_array(): n = 10 arr = [1] * 9 + [10] assert find_split_index(n, arr) == -1","solution":"def find_split_index(n, arr): This function determines the index where the array can be split into two non-empty subarrays with the same sum. If no such index exists, it returns -1. :param n: integer, the number of elements in the array :param arr: list of integers, the array of numbers :return: integer, the index where the split is possible, or -1 if no such split exists total_sum = sum(arr) # If the total_sum is odd, it's impossible for two equal parts if total_sum % 2 != 0: return -1 left_sum = 0 for i in range(n - 1): # We do not consider the last element as part of the left subarray left_sum += arr[i] if left_sum * 2 == total_sum: return i return -1"},{"question":"def shift_characters(input_string: str) -> str: Takes a string and returns a new string where each letter is replaced by the next letter in the alphabet. The transformation is case-sensitive and wraps around from 'z' to 'a' and 'Z' to 'A'. Non-letter characters remain unchanged. Examples: >>> shift_characters(\\"abcd\\") 'bcde' >>> shift_characters(\\"XYZ\\") 'YZA' >>> shift_characters(\\"Hello, World!\\") 'Ifmmp, Xpsme!' >>> shift_characters(\\"123_abc_XYZ\\") '123_bcd_YZA'","solution":"def shift_characters(input_string): Takes a string and returns a new string where each letter is replaced by the next letter in the alphabet. The transformation is case-sensitive and wraps around from 'z' to 'a' and 'Z' to 'A'. Non-letter characters remain unchanged. def shift_char(c): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + 1) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + 1) % 26 + ord('A')) return c return ''.join(shift_char(c) for c in input_string)"},{"question":"def modified_fibonacci(n: int) -> int: Returns the nth value of the Modified Fibonacci Sequence. The sequence is defined as: a_0 = 1 a_1 = 1 For n >= 2: a_n = a_(n-1) + a_(n-2) >>> modified_fibonacci(0) 1 >>> modified_fibonacci(1) 1 >>> modified_fibonacci(5) 8 >>> modified_fibonacci(10) 89","solution":"def modified_fibonacci(n): Returns the nth value of the Modified Fibonacci Sequence. The sequence is defined as: a_0 = 1 a_1 = 1 For n >= 2: a_n = a_(n-1) + a_(n-2) if n == 0 or n == 1: return 1 a, b = 1, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"def road_trip_cost_minimizer(data: str) -> str: Calculate the total fuel cost for each car and identify the car with the minimum fuel cost for a road trip. >>> road_trip_cost_minimizer(\\"3 500n10 5n15 4n20 3n0 0\\") '250.00n133.33n75.00nCar 3' >>> road_trip_cost_minimizer(\\"3 500n10 5n15 4n20 3n2 300n8 6n12 5n0 0\\") '250.00n133.33n75.00nCar 3n225.00n125.00nCar 2' >>> road_trip_cost_minimizer(\\"3 1000n10 10n10 10n10 10n0 0\\") '1000.00n1000.00n1000.00nCar 1' >>> road_trip_cost_minimizer(\\"4 1000n10 10n20 20n30 30n40 5n0 0\\") '1000.00n1000.00n1000.00n125.00nCar 4'","solution":"def calculate_fuel_cost(d, t, cars): Calculate the total fuel cost for each car and identify the car with the minimum fuel cost. min_cost = float('inf') min_car_index = -1 costs = [] for i in range(d): efficiency, price = cars[i] cost = (t / efficiency) * price costs.append(cost) if cost < min_cost: min_cost = cost min_car_index = i return costs, min_car_index def process_input(data): result = [] idx = 0 while idx < len(data): d, t = map(int, data[idx].split()) if d == 0 and t == 0: break idx += 1 cars = [] for _ in range(d): efficiency, price = map(int, data[idx].split()) cars.append((efficiency, price)) idx += 1 costs, min_car_index = calculate_fuel_cost(d, t, cars) result.append((costs, min_car_index)) return result def format_output(results): output = [] for costs, min_car_index in results: for cost in costs: output.append(f\\"{cost:.2f}\\") output.append(f\\"Car {min_car_index + 1}\\") return \\"n\\".join(output) def road_trip_cost_minimizer(data): results = process_input(data.split(\\"n\\")) return format_output(results)"},{"question":"def max_depth(s: str) -> int: Return the maximum depth of nested parentheses in the string 's'. Parameters: s (str): The input string containing parentheses. Returns: int: The maximum depth of nested parentheses. pass # Example test cases def test_max_depth(): assert max_depth(\\"(())\\") == 2 assert max_depth(\\"()\\") == 1 assert max_depth(\\"(()(()))\\") == 3 assert max_depth(\\"\\") == 0 assert max_depth(\\"((())\\") == 3 assert max_depth(\\"(\\") == 1 assert max_depth(\\")\\") == 0 # Missing an opening parenthesis should ideally be 0, but it's invalid. assert max_depth(\\"()()()\\") == 1 assert max_depth(\\"(())(())()((()))\\") == 3","solution":"def max_depth(s: str) -> int: Return the maximum depth of nested parentheses in the string 's'. Parameters: s (str): The input string containing parentheses. Returns: int: The maximum depth of nested parentheses. current_depth = 0 max_depth = 0 for char in s: if char == '(': current_depth += 1 if current_depth > max_depth: max_depth = current_depth elif char == ')': current_depth -= 1 return max_depth"},{"question":"def min_time_to_make_elements_equal(arr): Given an array of integers, returns the minimum time required to make all elements of the array equal. pass def process_test_cases(t, test_cases): Processes multiple test cases to find the minimum time required to make all elements of the array equal for each test case. pass # Example usage if __name__ == \\"__main__\\": def test_min_time_to_make_elements_equal(): assert min_time_to_make_elements_equal([1, 2, 3, 4]) == 1 assert min_time_to_make_elements_equal([5, 6, 7]) == 1 assert min_time_to_make_elements_equal([3, 3, 3]) == 0 assert min_time_to_make_elements_equal([1, 1, 1, 1]) == 0 assert min_time_to_make_elements_equal([1, 10]) == 4 def test_process_test_cases(): assert process_test_cases(2, [(4, [1, 2, 3, 4]), (3, [5, 6, 7])] ) == [1, 1] assert process_test_cases(1, [(5, [1, 2, 3, 4, 5])] ) == [2] assert process_test_cases(3, [(2, [1, 2]), (4, [1, 1, 1, 1]), (3, [4, 4, 4])] ) == [0, 0, 0]","solution":"def min_time_to_make_elements_equal(arr): Given an array of integers, returns the minimum time required to make all elements of the array equal. max_value = max(arr) min_value = min(arr) return (max_value - min_value) // 2 def process_test_cases(t, test_cases): results = [] for case in test_cases: n, arr = case results.append(min_time_to_make_elements_equal(arr)) return results"},{"question":"def solve(arr: List[int]) -> int: Given a list of integers, return the maximum sum of any non-empty subarray. >>> solve([1, -2, 3, 4, -5, 8]) 10 >>> solve([-3, -4, -1, -2, -1]) -1 >>> solve([5]) 5 >>> solve([1, 2, 3, 4, 5]) 15 >>> solve([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> solve([-1]) -1 >>> solve([1000000, -1, 1000000, -1, 1000000]) 2999998 >>> solve([0, 0, 0, 0, 0]) 0 >>> solve([0, 0, 5, 0, 0]) 5 >>> solve([0, -1, 0, 1, 0]) 1","solution":"def solve(arr): Returns the maximum sum of any non-empty subarray. current_max = arr[0] global_max = arr[0] for num in arr[1:]: current_max = max(num, current_max + num) global_max = max(global_max, current_max) return global_max"},{"question":"from typing import List def find_sequence_b(n: int, a: List[int]) -> List[int]: Johnny has a sequence of integers \`a\` of length \`n\` and he is asking you to find another sequence \`b\` of the same length which satisfies the following conditions: 1. For any \`l\` and \`r\` (\`1 <= l <= r <= n\`) the sum of the elements of the subsequence \`a[l], a[l+1], ..., a[r]\` is equal to the sum of the elements of the subsequence \`b[l], b[l+1], ..., b[r]\`. 2. The maximum element in sequence \`b\` should be minimized. If there are multiple such sequences, output any of them. Args: n (int): The length of the sequence \`a\`. a (List[int]): The sequence of integers. Returns: List[int]: A sequence \`b\` of length \`n\` which satisfies the above conditions. Examples: >>> find_sequence_b(3, [1, -2, 1]) [0, -2, 0] >>> find_sequence_b(6, [5, 5, 5, 5, 5, 5]) [0, 0, 0, 0, 0, 0] >>> find_sequence_b(4, [100, -100, 100, -100]) [0, -100, 0, -100] # Your code here","solution":"def find_sequence_b(n, a): Returns the sequence b which satisfies the conditions specified in the problem. # We will generate b such that every positive element in \`a\` is transformed to 0 in \`b\` b = [0] * n for i in range(n): if a[i] < 0: b[i] = a[i] return b"},{"question":"from typing import List, Tuple def form_groups(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Determines whether it's possible to form the required groups and, if possible, outputs the number of groups that will be formed. If it is not possible, the function should indicate that as well. >>> form_groups(3, [(25, 5), (18, 4), (15, 3)]) [\\"5\\", \\"IMPOSSIBLE\\", \\"5\\"] >>> form_groups(2, [(30, 6), (20, 7)]) [\\"5\\", \\"IMPOSSIBLE\\"] >>> form_groups(1, [(10, 2)]) [\\"5\\"] >>> form_groups(4, [(12, 3), (17, 2), (28, 7), (9, 3)]) [\\"4\\", \\"IMPOSSIBLE\\", \\"4\\", \\"3\\"] >>> form_groups(5, [(100, 10), (1000000, 2), (1, 1), (100000, 1000), (50, 10)]) [\\"10\\", \\"500000\\", \\"1\\", \\"100\\", \\"5\\"]","solution":"def form_groups(t, test_cases): results = [] for m, n in test_cases: if m % n == 0: results.append(str(m // n)) else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"from typing import List def longestCommonSubsequence(arr1: List[int], arr2: List[int]) -> int: Given two integer arrays \`arr1\` and \`arr2\` of size \`m\` and \`n\` respectively, find the length of the longest common subsequence (LCS). A subsequence is a sequence derived by deleting some or none elements from an array without changing the order of the remaining elements. >>> longestCommonSubsequence([1, 3, 4, 1, 2, 8], [3, 4, 1, 2, 8, 7]) 5 >>> longestCommonSubsequence([1, 2, 3, 4, 5], [5, 3, 1]) 1 # Unit tests def test_longest_common_subsequence_example_1(): arr1 = [1, 3, 4, 1, 2, 8] arr2 = [3, 4, 1, 2, 8, 7] assert longestCommonSubsequence(arr1, arr2) == 5 def test_longest_common_subsequence_example_2(): arr1 = [1, 2, 3, 4, 5] arr2 = [5, 3, 1] assert longestCommonSubsequence(arr1, arr2) == 1 def test_longest_common_subsequence_no_common_subseq(): arr1 = [1, 2, 3] arr2 = [4, 5, 6] assert longestCommonSubsequence(arr1, arr2) == 0 def test_longest_common_subsequence_identical_arrays(): arr1 = [1, 2, 3, 4] arr2 = [1, 2, 3, 4] assert longestCommonSubsequence(arr1, arr2) == 4 def test_longest_common_subsequence_subsequence_in_reverse(): arr1 = [1, 2, 3] arr2 = [3, 2, 1] assert longestCommonSubsequence(arr1, arr2) == 1 def test_longest_common_subsequence_partial_match(): arr1 = [3, 9, 8, 3, 9, 7, 9, 7, 0] arr2 = [3, 3, 9, 9, 9, 1, 7, 2, 0, 6] assert longestCommonSubsequence(arr1, arr2) == 6","solution":"def longestCommonSubsequence(arr1, arr2): Returns the length of the longest common subsequence of arr1 and arr2. m, n = len(arr1), len(arr2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if arr1[i - 1] == arr2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def reverse_words(input_string: str) -> str: Write a function that accepts a string as input and returns a new string with the words reversed but kept in their original order. >>> reverse_words('The quick brown fox') 'ehT kciuq nworb xof' >>> reverse_words('Hello World') 'olleH dlroW'","solution":"def reverse_words(input_string): Returns a new string with the words reversed but kept in their original order :param input_string: str :return: str words = input_string.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"def longest_alphabetical_subsequence(s: str) -> int: Determine the length of the longest subsequence of characters that appears in alphabetical order. >>> longest_alphabetical_subsequence(\\"a\\") 1 >>> longest_alphabetical_subsequence(\\"abc\\") 3 >>> longest_alphabetical_subsequence(\\"abzcxdb\\") 4 >>> longest_alphabetical_subsequence(\\"cba\\") 1 >>> longest_alphabetical_subsequence(\\"aaaa\\") 4 >>> longest_alphabetical_subsequence(\\"aebdc\\") 3 >>> longest_alphabetical_subsequence(\\"\\") 0 >>> longest_alphabetical_subsequence(\\"abcdefghijklmnopqrstuvwxyz\\") 26 # your code here","solution":"def longest_alphabetical_subsequence(s): Returns the length of the longest subsequence of characters that appears in alphabetical order. if not s: return 0 n = len(s) lengths = [1] * n for i in range(1, n): for j in range(i): if s[j] <= s[i]: lengths[i] = max(lengths[i], lengths[j] + 1) return max(lengths)"},{"question":"def count_contiguous_Os(s: str) -> int: Count the number of contiguous subsequences of 'O's in the given string. >>> count_contiguous_Os(\\"XOOXOXOX\\") == 3 >>> count_contiguous_Os(\\"OOOOO\\") == 1 >>> count_contiguous_Os(\\"XXOXOXOXOX\\") == 4 >>> count_contiguous_Os(\\"X\\") == 0 >>> count_contiguous_Os(\\"O\\") == 1 >>> count_contiguous_Os(\\"\\") == 0 >>> count_contiguous_Os(\\"OXOXOXOXO\\") == 5 >>> count_contiguous_Os(\\"XXXXXX\\") == 0 >>> count_contiguous_Os(\\"OOOOOO\\") == 1","solution":"def count_contiguous_Os(s): Count the number of contiguous subsequences of 'O's. count = 0 in_O_sequence = False for char in s: if char == 'O': if not in_O_sequence: in_O_sequence = True count += 1 else: in_O_sequence = False return count"},{"question":"def has_pair_with_sum(arr: List[int], target: int) -> str: Determines if there exists a pair of distinct indices i and j in the list such that the sum of the integers at these indices equals the target value. >>> has_pair_with_sum([10, 5, 3, 2, 8], 10) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4, 5], 10) \\"NO\\" >>> has_pair_with_sum([-1, -2, -3, -4, -5], -8) \\"YES\\" >>> has_pair_with_sum([1000, -1000, 500, -500], 0) \\"YES\\" >>> has_pair_with_sum([100, 200, 300, 400], 600) \\"YES\\" >>> has_pair_with_sum([100, 200, 300, 400], 1000) \\"NO\\"","solution":"def has_pair_with_sum(arr, target): Determines if there exists a pair of distinct indices i and j in the list such that the sum of the integers at these indices equals the target value. :param arr: List of integers :param target: Target integer value :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" seen = set() for num in arr: if target - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def get_highest_scorer_index(scores): Determines the index of the student with the highest total score. :param scores: An array of arrays, where each subarray represents the scores of an individual student across multiple exams :return: The index of the student with the highest total score >>> get_highest_scorer_index([[95, 85, 80], [85, 80, 90], [95, 90, 95]]) 2 >>> get_highest_scorer_index([[100, 90, 80], [90, 100, 80], [80, 90, 100]]) 0 >>> get_highest_scorer_index([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0","solution":"def get_highest_scorer_index(scores): Determines the index of the student with the highest total score. :param scores: An array of arrays, where each subarray represents the scores of an individual student across multiple exams :return: The index of the student with the highest total score highest_score = -1 highest_index = -1 for index, student_scores in enumerate(scores): total_score = sum(student_scores) if total_score > highest_score: highest_score = total_score highest_index = index return highest_index"},{"question":"def is_possible_to_sort(n, array): Determines if it is possible to sort the entire array using the described operation. Args: n (int): The length of the array. array (list of int): The array of integers. Returns: str: \\"YES\\" if it is possible to sort the entire array, otherwise \\"NO\\". def process_test_cases(t, test_cases): Processes multiple test cases. Args: t (int): The number of test cases. test_cases (list of tuples): Each tuple consists of (n, array). Returns: list of str: The result for each test case. >>> from solution import process_test_cases >>> process_test_cases(3, [(5, [4, 2, 5, 1, 3]), (4, [1, 2, 3, 4]), (6, [5, 4, 3, 2, 1])]) == [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(2, [(3, [3, 2, 1]), (5, [1, 5, 4, 3, 2])]) == [\\"YES\\", \\"YES\\"] >>> process_test_cases(1, [(4, [4, 3, 2, 1])]) == [\\"YES\\"] >>> process_test_cases(2, [(5, [7, 2, 5, 3, 6]), (4, [2, 3, 1, 4])]) == [\\"YES\\", \\"YES\\"] >>> process_test_cases(1, [(1, [1])]) == [\\"YES\\"] >>> process_test_cases(1, [(6, [3, 3, 3, 3, 3, 3])]) == [\\"YES\\"] >>> process_test_cases(1, [(3, [3, 1, 2])]) == [\\"YES\\"] >>> process_test_cases(2, [(4, [4, 1, 2, 3]), (3, [1, 3, 2])]) == [\\"YES\\", \\"YES\\"]","solution":"def is_possible_to_sort(n, array): Determines if it is possible to sort the entire array using the described operation. Args: n (int): The length of the array. array (list of int): The array of integers. Returns: str: \\"YES\\" if it is possible to sort the entire array, otherwise \\"NO\\". if array == sorted(array): return \\"YES\\" for i in range(n - 1): if array[i] > array[i + 1]: return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): Processes multiple test cases. Args: t (int): The number of test cases. test_cases (list of tuples): Each tuple consists of (n, array). Returns: list of str: The result for each test case. results = [] for n, array in test_cases: results.append(is_possible_to_sort(n, array)) return results"},{"question":"def allocate_courses(n, student_preferences, m, course_capacities): Allocate courses to students based on their preferences and the maximum number of students each course can accommodate. >>> allocate_courses(4, [\\"CSE101,MATH102,PHY103\\", \\"MATH102,CSE101,PHY103\\", \\"PHY103,CSE101,MATH102\\", \\"CSE101,PHY103\\"], 3, [\\"CSE101 2\\", \\"MATH102 1\\", \\"PHY103 1\\"]) [\\"CSE101\\", \\"MATH102\\", \\"PHY103\\", \\"CSE101\\"] >>> allocate_courses(3, [\\"CSE101,PHY103\\", \\"CSE101,PHY103\\", \\"CSE101,PHY103\\"], 2, [\\"CSE101 1\\", \\"PHY103 1\\"]) [\\"CSE101\\", \\"PHY103\\", None] >>> allocate_courses(5, [\\"MATH102\\", \\"MATH102\\", \\"MATH102\\", \\"MATH102\\", \\"MATH102\\"], 1, [\\"MATH102 2\\"]) [\\"MATH102\\", \\"MATH102\\", None, None, None] >>> allocate_courses(1, [\\"PHY103,MATH102,CSE101\\"], 3, [\\"PHY103 0\\", \\"MATH102 1\\", \\"CSE101 1\\"]) [\\"MATH102\\"] >>> allocate_courses(2, [\\"BIO101,CHEM101\\", \\"CHEM101,BIO101\\"], 2, [\\"CHEM101 0\\", \\"BIO101 0\\"]) [None, None]","solution":"def allocate_courses(n, student_preferences, m, course_capacities): # Initialize the capacities dictionary course_dict = {} for course in course_capacities: course_id, capacity = course.split() course_dict[course_id] = int(capacity) # Initialize the result list allocation = [None] * n # Process each student's preferences for i in range(n): preferences = student_preferences[i].split(',') for pref in preferences: if course_dict.get(pref, 0) > 0: allocation[i] = pref course_dict[pref] -= 1 break return allocation"},{"question":"def knight_moves(position): Given a knight's position on a chessboard, return all possible positions the knight can move to in one move. >>> sorted(knight_moves('e4')) == sorted(['c3', 'c5', 'd2', 'd6', 'f2', 'f6', 'g3', 'g5']) >>> sorted(knight_moves('a1')) == sorted(['b3', 'c2']) >>> sorted(knight_moves('h8')) == sorted(['f7', 'g6']) col, row = position col = ord(col) row = int(row) def process_knight_moves(test_cases): Given a list of test cases representing the knight's position on a chessboard, return the possible positions the knight can move to for each test case. >>> test_cases = ['e4', 'a1'] >>> expected = [sorted(['c3', 'c5', 'd2', 'd6', 'f2', 'f6', 'g3', 'g5']), sorted(['b3', 'c2'])] >>> result = process_knight_moves(test_cases) >>> all(sorted(res) == exp for res, exp in zip(result, expected)) True","solution":"def knight_moves(position): Given a knight's position on a chessboard, return all possible positions the knight can move to in one move. col, row = position col = ord(col) row = int(row) possible_moves = [ (col + 1, row + 2), (col + 1, row - 2), (col - 1, row + 2), (col - 1, row - 2), (col + 2, row + 1), (col + 2, row - 1), (col - 2, row + 1), (col - 2, row - 1) ] valid_moves = [] for c, r in possible_moves: if 97 <= c <= 104 and 1 <= r <= 8: valid_moves.append(chr(c) + str(r)) return sorted(valid_moves) def process_knight_moves(test_cases): Given a list of test cases representing the knight's position on a chessboard, return the possible positions the knight can move to for each test case. result = [] for position in test_cases: result.append(knight_moves(position)) return result"},{"question":"def contains_mirror_pair(arr): Function to check if the array contains at least one mirror pair Parameters: arr (list): List of integers Returns: str: \\"MIRROR PAIR\\" if the array contains at least one mirror pair, otherwise \\"NO MIRROR PAIR\\" def process_test_cases(T, test_cases): Processes multiple test cases to check for mirror pairs Parameters: T (int): Number of test cases test_cases (list): List of test cases where each test case is a list of integers Returns: list: List of results for each test case import pytest from solution import contains_mirror_pair, process_test_cases def test_contains_mirror_pair(): assert contains_mirror_pair([12, 21, 22, 23]) == \\"MIRROR PAIR\\" assert contains_mirror_pair([34, 43, 56, 65, 78]) == \\"MIRROR PAIR\\" assert contains_mirror_pair([11, 22, 33]) == \\"NO MIRROR PAIR\\" assert contains_mirror_pair([10, 1, 99, 88, 77]) == \\"NO MIRROR PAIR\\" assert contains_mirror_pair([57, 75]) == \\"MIRROR PAIR\\" assert contains_mirror_pair([18, 81, 13, 31]) == \\"MIRROR PAIR\\" def test_process_test_cases(): assert process_test_cases(3, [ [12, 21, 22, 23], [34, 43, 56, 65, 78], [11, 22, 33] ]) == [\\"MIRROR PAIR\\", \\"MIRROR PAIR\\", \\"NO MIRROR PAIR\\"] assert process_test_cases(2, [ [10, 20, 30], [91, 19, 29, 92] ]) == [\\"NO MIRROR PAIR\\", \\"MIRROR PAIR\\"] assert process_test_cases(1, [ [22, 33, 44, 55] ]) == [\\"NO MIRROR PAIR\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def contains_mirror_pair(arr): Function to check if the array contains at least one mirror pair Parameters: arr (list): List of integers Returns: str: \\"MIRROR PAIR\\" if the array contains at least one mirror pair, otherwise \\"NO MIRROR PAIR\\" string_numbers = [str(num) for num in arr] for i in range(len(string_numbers)): for j in range(i + 1, len(string_numbers)): if string_numbers[i] == string_numbers[j][::-1]: return \\"MIRROR PAIR\\" return \\"NO MIRROR PAIR\\" def process_test_cases(T, test_cases): Processes multiple test cases to check for mirror pairs Parameters: T (int): Number of test cases test_cases (list): List of test cases where each test case is a list of integers Returns: list: List of results for each test case results = [] for case in test_cases: results.append(contains_mirror_pair(case)) return results"},{"question":"def can_rearrange_after_removal(s: str) -> str: Returns whether it is possible to rearrange the string after removing one character so that no two adjacent characters are the same. >>> can_rearrange_after_removal(\\"abab\\") 'YES' >>> can_rearrange_after_removal(\\"aaaa\\") 'NO'","solution":"def can_rearrange_after_removal(s): Returns whether it is possible to rearrange the string after removing one character so that no two adjacent characters are the same. from collections import Counter # Simple case where the string length is 1 if len(s) == 1: return \\"NO\\" # Count the occurrences of 'a' and 'b' count = Counter(s) # Calculate the minimum possible length and maximum count of 'a' or 'b' after removing one character max_count = max(count.values()) min_length = len(s) - 1 if max_count <= min_length // 2 + 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_2x2_sum(grid): Given a 2D grid, find the maximum sum of any 2x2 subgrid. >>> max_2x2_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 28 >>> max_2x2_sum([[1, 1], [1, 1]]) 4 >>> max_2x2_sum([[1, 5, 1], [8, 3, 1], [1, 1, 1]]) 17 >>> max_2x2_sum([[1, 1, 1, 1], [1, 9, 9, 1], [1, 9, 9, 1], [1, 1, 1, 1]]) 36 >>> max_2x2_sum([[2, 2], [2, 2]]) 8 >>> max_2x2_sum([[100] * 50 for _ in range(50)]) 400","solution":"def max_2x2_sum(grid): Given a 2D grid, find the maximum sum of any 2x2 subgrid. n = len(grid) m = len(grid[0]) max_sum = float('-inf') for i in range(n - 1): for j in range(m - 1): current_sum = ( grid[i][j] + grid[i][j + 1] + grid[i + 1][j] + grid[i + 1][j + 1] ) if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def canFormPalindrome(N: int) -> int: Determine if the digits of the number N can be permuted to form a palindrome. Parameters: N (int): The input number. Returns: int: 1 if the digits can be permuted to form a palindrome, 0 otherwise. Examples: >>> canFormPalindrome(121) 1 >>> canFormPalindrome(123) 0","solution":"def canFormPalindrome(N): Determine if the digits of the number N can be permuted to form a palindrome. Parameters: N (int): The input number. Returns: int: 1 if the digits can be permuted to form a palindrome, 0 otherwise. from collections import Counter # Convert number to a string to iterate its digits str_N = str(N) # Count the occurrences of each digit count = Counter(str_N) # Check the number of digits with odd occurrences odd_count = sum(1 for digit in count if count[digit] % 2 != 0) # A number can be permuted to form a palindrome if there is at most one digit with an odd count return 1 if odd_count <= 1 else 0"},{"question":"def min_operations_to_beautiful(S): Returns the minimum number of operations required to make the binary string S beautiful (i.e., doesn't contain \\"010\\" or \\"101\\"). pass def process_test_cases(T, test_cases): Processes T test cases of binary strings and returns a list of minimum operations required for each string to be beautiful. :param T: Number of test cases :param test_cases: List of binary strings :return: List of integers indicating the minimum number of operations for each test case pass # Example test cases if __name__ == \\"__main__\\": print(process_test_cases(3, [\\"010101\\", \\"00100\\", \\"1111\\"])) # [2, 1, 0] print(process_test_cases(2, [\\"1010\\", \\"000\\"])) # [1, 0]","solution":"def min_operations_to_beautiful(S): Returns the minimum number of operations required to make the binary string S beautiful (i.e., doesn't contain \\"010\\" or \\"101\\"). count = 0 i = 0 n = len(S) while i < n - 2: if S[i:i+3] == \\"010\\" or S[i:i+3] == \\"101\\": count += 1 i += 2 # Skip the next character to prevent overlapping replacements else: i += 1 return count def process_test_cases(T, test_cases): results = [] for S in test_cases: results.append(min_operations_to_beautiful(S)) return results"},{"question":"from typing import Dict def count_words_frequency(s: str) -> Dict[str, int]: Returns a dictionary where the keys are the words from the string \`s\`, and the values are the number of times each word appears. Words are case-insensitive and should be considered the same regardless of their case. Non-alphanumeric characters should be removed from the words. >>> count_words_frequency(\\"Hello, hello! How are you? Hello...\\") == {'hello': 3, 'how': 1, 'are': 1, 'you': 1} >>> count_words_frequency(\\"It's a beautiful day, isn't it? Truly a beautiful day!\\") == {\\"its\\": 1, \\"a\\": 2, \\"beautiful\\": 2, \\"day\\": 2, \\"isnt\\": 1, \\"it\\": 1, \\"truly\\": 1} import re from collections import defaultdict def test_single_word(): assert count_words_frequency(\\"Hello\\") == {'hello': 1} def test_repeated_words(): assert count_words_frequency(\\"hello hello Hello\\") == {'hello': 3} def test_mixed_case(): assert count_words_frequency(\\"Hello, HELLO, hellO!\\") == {'hello': 3} def test_non_alphanumeric_chars(): assert count_words_frequency(\\"Hello, hello! How are you? Hello...\\") == {'hello': 3, 'how': 1, 'are': 1, 'you': 1} def test_complicated_sentence(): assert count_words_frequency(\\"It's a beautiful day, isn't it? Truly a beautiful day!\\") == { \\"its\\": 1, \\"a\\": 2, \\"beautiful\\": 2, \\"day\\": 2, \\"isnt\\": 1, \\"it\\": 1, \\"truly\\": 1 } def test_empty_string(): assert count_words_frequency(\\"\\") == {} def test_only_non_alphanumeric_chars(): assert count_words_frequency(\\"!!!%%%\\") == {} def test_mixed_numbers_and_words(): assert count_words_frequency(\\"1 apple 2 apples, 3 apples!\\") == {\\"1\\": 1, \\"apple\\": 1, \\"2\\": 1, \\"apples\\": 2, \\"3\\": 1} def test_numbers_only(): assert count_words_frequency(\\"1 2 3 4 5 1 2 3 4 5\\") == {\\"1\\": 2, \\"2\\": 2, \\"3\\": 2, \\"4\\": 2, \\"5\\": 2}","solution":"import re from collections import defaultdict def count_words_frequency(s): Returns a dictionary where the keys are words from the string 's' (case insensitive, non-alphanumeric characters removed) and the values are the number of times each word appears. # Convert the string to lowercase and remove non-alphanumeric characters s = s.lower() s = re.sub(r'[^a-z0-9s]', '', s) words = s.split() word_count = defaultdict(int) for word in words: word_count[word] += 1 return dict(word_count)"},{"question":"def flag_house_numbers(n, k): Returns a list of house numbers that will display flags in ascending order. :param n: int - the total number of houses (1 ≤ n ≤ 10^9) :param k: int - the step value (1 ≤ k ≤ n) :return: list of int - house numbers that will display flags >>> flag_house_numbers(10, 3) [1, 4, 7, 10] >>> flag_house_numbers(5, 5) [1] >>> flag_house_numbers(20, 4) [1, 5, 9, 13, 17] >>> flag_house_numbers(5, 1) [1, 2, 3, 4, 5] >>> flag_house_numbers(100, 30) [1, 31, 61, 91] >>> flag_house_numbers(1, 1) [1] >>> flag_house_numbers(1000000000, 1000000000) [1]","solution":"def flag_house_numbers(n, k): Returns a list of house numbers that will display flags in ascending order. :param n: int - the total number of houses (1 ≤ n ≤ 10^9) :param k: int - the step value (1 ≤ k ≤ n) :return: list of int - house numbers that will display flags return list(range(1, n + 1, k))"},{"question":"def canMeasureWater(x: int, y: int, z: int) -> bool: You are given two jugs with capacities x and y litres. There is an infinite amount of water supply available. You need to determine whether it is possible to measure exactly z litres using these two jugs. If z liters of water is measurable, you must have z liters of water contained within one or both buckets by the end. Operations allowed: 1. Fill any of the jugs completely with water. 2. Empty any of the jugs. 3. Pour water from one jug into another until: - the second jug is full - the first jug itself is empty Returns \`True\` if z is measurable, otherwise returns \`False\`. >>> canMeasureWater(3, 5, 4) == True >>> canMeasureWater(2, 6, 5) == False >>> canMeasureWater(1, 2, 3) == True def test_can_measure_water_example_1(): assert canMeasureWater(3, 5, 4) == True def test_can_measure_water_example_2(): assert canMeasureWater(2, 6, 5) == False def test_can_measure_water_example_3(): assert canMeasureWater(1, 2, 3) == True def test_can_measure_water_large_values(): assert canMeasureWater(104, 29, 10) == True def test_can_measure_water_zero_target(): assert canMeasureWater(7, 11, 0) == True def test_can_measure_water_exceed_capacity(): assert canMeasureWater(2, 3, 6) == False def test_can_measure_water_edge_case_1(): assert canMeasureWater(0, 0, 0) == True def test_can_measure_water_edge_case_2(): assert canMeasureWater(0, 0, 1) == False def test_can_measure_water_same_jug_size(): assert canMeasureWater(8, 8, 16) == True def test_can_measure_water_one_jug_zero(): assert canMeasureWater(0, 5, 5) == True assert canMeasureWater(5, 0, 5) == True assert canMeasureWater(0, 5, 6) == False assert canMeasureWater(5, 0, 6) == False","solution":"def gcd(a, b): while b != 0: a, b = b, a % b return a def canMeasureWater(x: int, y: int, z: int) -> bool: Determine if it's possible to measure exactly z liters using jugs of size x and y. # If z exceeds the combined capacity of both jugs, it's impossible if z > x + y: return False # If z is 0, it's always possible (just have both jugs empty) if z == 0: return True # Use the properties of the greatest common divisor (GCD) return z % gcd(x, y) == 0"},{"question":"def can_return_to_origin(N: int) -> str: Determines if there exists a sequence of instructions of length N that will cause the robot to return to its initial position (0, 0) after exactly N steps. :param N: Length of instructions sequence :type N: int :return: \\"YES\\" if it is possible to return to the initial position, \\"NO\\" otherwise :rtype: str >>> can_return_to_origin(2) 'NO' >>> can_return_to_origin(4) 'YES' >>> can_return_to_origin(6) 'NO' >>> can_return_to_origin(10) 'YES'","solution":"def can_return_to_origin(N): Determines if the robot can return to its initial position (0, 0) after exactly N steps. :param N: Length of instructions sequence :type N: int :return: \\"YES\\" if it is possible to return to the initial position, \\"NO\\" otherwise :rtype: str # The robot can return to the initial position after N steps if and only if # N is a multiple of 4 because only then can the robot complete a full cycle # of movements and turnings. if N % 4 == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def countEnclosedRegions(grid: List[List[str]]) -> int: Given a grid with 'X' and 'O', where 'X' denotes walls and 'O' denotes open spaces, count the number of distinct enclosed regions formed exclusively by 'O' surrounded by 'X'. >>> countEnclosedRegions([ ... ['X', 'X', 'X', 'X'], ... ['X', 'O', 'O', 'X'], ... ['X', 'X', 'O', 'X'], ... ['X', 'O', 'X', 'X'] ... ]) == 1 >>> countEnclosedRegions([ ... ['X', 'O', 'X'], ... ['X', 'O', 'X'], ... ['X', 'X', 'X'] ... ]) == 0","solution":"def countEnclosedRegions(grid): if not grid or not grid[0]: return 0 rows, cols = len(grid), len(grid[0]) def dfs(r, c): if r < 0 or c < 0 or r >= rows or c >= cols or grid[r][c] != 'O': return grid[r][c] = 'E' # Mark this cell as visited (escaped) # Perform DFS in all four directions dfs(r+1, c) dfs(r-1, c) dfs(r, c+1) dfs(r, c-1) # Step 1: Mark all 'O's that are connected to the boundary for r in range(rows): if grid[r][0] == 'O': dfs(r, 0) if grid[r][cols-1] == 'O': dfs(r, cols-1) for c in range(cols): if grid[0][c] == 'O': dfs(0, c) if grid[rows-1][c] == 'O': dfs(rows-1, c) # Step 2: Count and mark all remaining 'O's as enclosed regions enclosed_regions = 0 for r in range(1, rows-1): for c in range(1, cols-1): if grid[r][c] == 'O': enclosed_regions += 1 dfs(r, c) return enclosed_regions"},{"question":"from typing import List def length_of_longest_substring(s: str) -> int: Given a string s, find the length of the longest substring without repeating characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbb\\") 1 >>> length_of_longest_substring(\\"\\") 0 >>> length_of_longest_substring(\\"abcdef\\") 6 >>> length_of_longest_substring(\\"pwwkew\\") 3 >>> length_of_longest_substring(\\"dvdf\\") 3 >>> length_of_longest_substring(\\"abc abc bb\\") 4","solution":"def length_of_longest_substring(s): Returns the length of the longest substring without repeating characters. char_map = {} start = 0 max_length = 0 for end, char in enumerate(s): if char in char_map and char_map[char] >= start: start = char_map[char] + 1 char_map[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"MOD = 1000000007 def count_drawing_kits(T, cases): Calculate the number of different drawing kits possible, modulo 1000000007. Parameters: T (int): The number of test cases. cases (List[Tuple[int, int]]): Each tuple contains two integers N and K representing the number of different colors and the number of pencils per kit respectively. Returns: List[int]: The result for each test case. >>> count_drawing_kits(3, [(2, 3), (3, 2), (4, 1)]) [8, 9, 4] results = [] for N, K in cases: results.append(pow(N, K, MOD)) return results def parse_input(input_str): Parse the input string to extract the number of test cases and corresponding cases. Parameters: input_str (str): The input string in the format specified in the problem statement. Returns: Tuple[int, List[Tuple[int, int]]]: The number of test cases and the list of tuples representing cases. >>> parse_input(\\"3n2 3n3 2n4 1\\") (3, [(2, 3), (3, 2), (4, 1)]) lines = input_str.strip().split('n') T = int(lines[0].strip()) cases = [] for i in range(1, T + 1): N, K = map(int, lines[i].strip().split()) cases.append((N, K)) return T, cases def format_output(results): Format the results list into the specified output string. Parameters: results (List[int]): The results list. Returns: str: The formatted output string. >>> format_output([8, 9, 4]) \\"8n9n4\\" return 'n'.join(map(str, results))","solution":"MOD = 1000000007 def count_drawing_kits(T, cases): results = [] for N, K in cases: results.append(pow(N, K, MOD)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0].strip()) cases = [] for i in range(1, T + 1): N, K = map(int, lines[i].strip().split()) cases.append((N, K)) return T, cases def format_output(results): return 'n'.join(map(str, results)) # Example usage: # input_str = \\"3n2 3n3 2n4 1\\" # T, cases = parse_input(input_str) # results = count_drawing_kits(T, cases) # output_str = format_output(results) # print(output_str)"},{"question":"def hasPairWithSum(nums, target): Determine if there exists any pair of elements in the array that sum up to a specific target number. Args: nums: List[int] - A list of integers. target: int - The target sum. Returns: bool - True if there exists a pair of elements that sum up to the target number, False otherwise. >>> hasPairWithSum([2, 7, 11, 15], 9) == True >>> hasPairWithSum([1, 2, 3, 9], 8) == False from solution import hasPairWithSum def test_hasPairWithSum_example1(): nums = [2, 7, 11, 15] target = 9 assert hasPairWithSum(nums, target) == True def test_hasPairWithSum_example2(): nums = [1, 2, 3, 9] target = 8 assert hasPairWithSum(nums, target) == False def test_hasPairWithSum_negative_numbers(): nums = [-1, -2, -3, -4, -5] target = -8 assert hasPairWithSum(nums, target) == True def test_hasPairWithSum_zero_target(): nums = [-3, 4, 3, 90] target = 0 assert hasPairWithSum(nums, target) == True def test_hasPairWithSum_no_pair(): nums = [1, 3, 5, 7] target = 100 assert hasPairWithSum(nums, target) == False def test_hasPairWithSum_large_numbers(): nums = [-1000000000, 1000000000] target = 0 assert hasPairWithSum(nums, target) == True","solution":"def hasPairWithSum(nums, target): Determine if there exists any pair of elements in the array that sum up to a specific target number. Args: nums: List[int] - A list of integers. target: int - The target sum. Returns: bool - True if there exists a pair of elements that sum up to the target number, False otherwise. seen = set() for num in nums: complement = target - num if complement in seen: return True seen.add(num) return False"},{"question":"def construct_array(n: int, S: int) -> list: You are given an integer n. Your task is to construct an array a of length n such that the sum of all elements of a is equal to S and the greatest common divisor (GCD) of all elements of a is 1. If such an array is impossible to construct, output -1. Otherwise, output the array. >>> construct_array(3, 10) [1, 1, 8] >>> construct_array(4, 7) [1, 1, 1, 4] or [1, 1, 2, 3] >>> construct_array(1, 5) [5] >>> construct_array(2, 2) -1","solution":"def construct_array(n, S): if n == 1: return [S] elif S < n: return -1 else: # To make the sum S with n elements such that GCD is 1, initialize array with all ones array = [1] * (n - 1) remaining_sum = S - (n - 1) if remaining_sum == 1: if n == 2: return -1 # Shift one of the ones to 2, to avoid remaining_sum being 1 array[-2] += 1 remaining_sum -= 1 array.append(remaining_sum) return array"},{"question":"def longest_bi_sequence(s: str) -> int: Find the length of the longest \\"Balanced-and-Interleaved\\" (BI) sequence by eliminating some characters. Args: s (str): Input sequence of brackets consisting of '(' and ')'. Returns: int: Length of the longest BI sequence. Examples: >>> longest_bi_sequence('(())))(()())') 10 >>> longest_bi_sequence('(') 0 >>> longest_bi_sequence(')') 0 >>> longest_bi_sequence('()') 2 >>> longest_bi_sequence(')))))') 0 >>> longest_bi_sequence('()()()()') 8 >>> longest_bi_sequence('') 0 >>> longest_bi_sequence('(((())(()))((())()))') 20","solution":"def longest_bi_sequence(s): Returns the length of the longest \\"Balanced-and-Interleaved\\" (BI) sequence that can be obtained by eliminating some characters from the input sequence. stack = [] longest_bi = 0 current_length = 0 for char in s: if char == '(': stack.append(char) elif stack and stack[-1] == '(': stack.pop() current_length += 2 # we have a valid pair () if not stack: longest_bi = max(longest_bi, current_length) else: # This means we have unmatched ) if stack: # reset if stack is not empty since it means we have unbalanced part current_length = 0 stack = [] return longest_bi"},{"question":"def length_of_LIS(flowers): Given the heights of the flowers in the garden, determine the length of the longest visually pleasing arrangement that can be achieved by trimming some flowers to form an increasing subsequence. :param flowers: List of integers representing the heights of flowers. :return: Length of the longest increasing subsequence. >>> length_of_LIS([10, 9, 2, 5, 3, 7, 101, 18]) 4 >>> length_of_LIS([1, 3, 2, 4]) 3 >>> length_of_LIS([5]) 1 >>> length_of_LIS([5, 4, 3, 2, 1]) 1 >>> length_of_LIS([1, 2, 3, 4, 5]) 5 >>> length_of_LIS([]) 0 >>> length_of_LIS([3, 4, 1, 2, 5]) 3","solution":"def length_of_LIS(flowers): Given the heights of the flowers in the garden, determine the length of the longest visually pleasing arrangement that can be achieved by trimming some flowers to form an increasing subsequence. :param flowers: List of integers representing the heights of flowers. :return: Length of the longest increasing subsequence. if not flowers: return 0 dp = [1] * len(flowers) for i in range(1, len(flowers)): for j in range(i): if flowers[i] > flowers[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def count_visible_buildings(N, buildings): Returns the number of buildings that are visible from the left side. Parameters: N (int): Number of buildings buildings (list): List of heights of buildings Returns: int: Number of visible buildings Example: >>> count_visible_buildings(6, [3, 5, 4, 9, 2, 6]) 3 >>> count_visible_buildings(5, [1, 2, 3, 4, 5]) 5","solution":"def count_visible_buildings(N, buildings): Returns the number of buildings that are visible from the left side. Parameters: N (int): Number of buildings buildings (list): List of heights of buildings Returns: int: Number of visible buildings if N == 0: return 0 max_height = buildings[0] visible_count = 1 # The first building is always visible for i in range(1, N): if buildings[i] > max_height: visible_count += 1 max_height = buildings[i] return visible_count"},{"question":"def highest_prices(products): Determines the highest price for each distinct product in the list. Parameters: products (list): A list of strings where each string is a product and its price, separated by a space. Returns: dict: A dictionary where keys are product names and values are the highest prices of those products. pass def test_highest_prices_case1(): assert highest_prices([\\"apple 4\\", \\"banana 2\\", \\"apple 5\\", \\"banana 3\\", \\"orange 6\\"]) == {'apple': 5, 'banana': 3, 'orange': 6} def test_highest_prices_case2(): assert highest_prices([\\"shirt 30\\", \\"jeans 40\\", \\"shirt 25\\", \\"hat 15\\"]) == {'shirt': 30, 'jeans': 40, 'hat': 15} def test_highest_prices_case3(): assert highest_prices([\\"milk 2\\", \\"bread 3\\", \\"milk 3\\", \\"bread 2\\"]) == {'milk': 3, 'bread': 3} def test_highest_prices_single_item(): assert highest_prices([\\"item 10\\"]) == {'item': 10} def test_highest_prices_all_different(): assert highest_prices([\\"a 1\\", \\"b 2\\", \\"c 3\\"]) == {'a': 1, 'b': 2, 'c': 3} def test_highest_prices_same_prices(): assert highest_prices([\\"a 4\\", \\"a 4\\", \\"a 4\\"]) == {'a': 4}","solution":"def highest_prices(products): Determines the highest price for each distinct product in the list. Parameters: products (list): A list of strings where each string is a product and its price, separated by a space. Returns: dict: A dictionary where keys are product names and values are the highest prices of those products. product_dict = {} for item in products: name, price = item.split() price = int(price) if name in product_dict: if product_dict[name] < price: product_dict[name] = price else: product_dict[name] = price return product_dict"},{"question":"def dijkstra(graph, start, end): Implement the Dijkstra's algorithm to find the shortest path from start to end in the given graph. pass def remove_edge(graph, u, v): Remove the edge between the nodes u and v in the graph. pass def main(): For each query, remove the specified road and determine the shortest path between the given junctions. -----Input----- Input is given from Standard Input in the following format: N M Q u_1 v_1 w_1 u_2 v_2 w_2 ... u_M v_M w_M a_1 b_1 x_1 y_1 a_2 b_2 x_2 y_2 ... a_Q b_Q x_Q y_Q -----Output----- Print Q lines. The i-th line should contain the length of the shortest path between junction a_i and junction b_i if the road between junction x_i and junction y_i is removed. If no such path exists, print -1. -----Example----- Input: 4 4 2 1 2 1 2 3 2 3 4 1 4 1 3 1 3 1 2 1 4 3 4 Output: 4 -1 pass def test_sample_input(): from io import StringIO import sys input_data = \\"4 4 2n1 2 1n2 3 2n3 4 1n4 1 3n1 3 1 2n1 4 3 4n\\" sys.stdin = StringIO(input_data) main() def test_disconnected_graph(): from io import StringIO import sys input_data = \\"3 2 1n1 2 4n2 3 5n1 3 2 3n\\" sys.stdin = StringIO(input_data) main() def test_multiple_queries(): from io import StringIO import sys input_data = \\"5 5 3n1 2 2n2 3 3n3 4 1n4 5 4n5 1 2n1 4 2 3n2 5 3 4n3 1 4 5n\\" sys.stdin = StringIO(input_data) main() def test_no_existing_path(): from io import StringIO import sys input_data = \\"3 2 2n1 2 1n2 3 1n1 3 1 3n1 3 2 3n\\" sys.stdin = StringIO(input_data) main()","solution":"import heapq import sys def dijkstra(graph, start, end): queue = [(0, start)] distances = {node: sys.maxsize for node in graph} distances[start] = 0 while queue: current_distance, current_node = heapq.heappop(queue) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return distances[end] if distances[end] != sys.maxsize else -1 def remove_edge(graph, u, v): graph[u] = [(node, wt) for node, wt in graph[u] if node != v] graph[v] = [(node, wt) for node, wt in graph[v] if node != u] def main(): input = sys.stdin.read data = input().split() index = 0 N = int(data[index]) M = int(data[index+1]) Q = int(data[index+2]) index += 3 graph = {i: [] for i in range(1, N+1)} for _ in range(M): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) index += 3 graph[u].append((v, w)) graph[v].append((u, w)) results = [] for _ in range(Q): a = int(data[index]) b = int(data[index+1]) x = int(data[index+2]) y = int(data[index+3]) index += 4 original_graph = {k: v[:] for k, v in graph.items()} remove_edge(graph, x, y) result = dijkstra(graph, a, b) results.append(result) graph = original_graph # reset graph for result in results: print(result)"},{"question":"def evenIndicesSum(lst: List[int]) -> int: Write a function that takes a list of integers as its input and returns the sum of the elements that are located at even indices (0, 2, 4, ...). If the input is not a list of integers, return 0. >>> evenIndicesSum([1, 2, 3, 4, 5]) 9 >>> evenIndicesSum([10, 20, 30, 40, 50, 60]) 150 >>> evenIndicesSum(\\"12345\\") 0 >>> evenIndicesSum([5, 15, 25]) 30","solution":"def evenIndicesSum(lst): Returns the sum of elements located at even indices in the list. If the input is not a list of integers, returns 0. if not isinstance(lst, list) or not all(isinstance(i, int) for i in lst): return 0 return sum(lst[i] for i in range(0, len(lst), 2))"},{"question":"def count_passcodes(s: int, l: int) -> int: Given the sum of the squares of the digits and the length, determine how many different passcodes of length exactly \`L\` could have produced that sum \`S\`. >>> count_passcodes(1, 1) 1 >>> count_passcodes(4, 1) 1 >>> count_passcodes(9, 2) 1 >>> count_passcodes(13, 2) 2 # Write your code here def solve(test_cases): results = [] for s, l in test_cases: results.append(count_passcodes(s, l)) return results def test_count_passcodes(): test_cases = [ (1, 1), # Sum 1, Length 1 -> Only \\"1\\" -> 1 passcode (4, 1), # Sum 4, Length 1 -> Only \\"2\\" -> 1 passcode (9, 2), # Sum 9, Length 2 -> Only \\"33\\" -> 1 passcode (13, 2), # Sum 13, Length 2 -> Passcodes \\"49\\", \\"85\\" -> 2 passcodes (25, 1) # Sum 25, Length 1 -> Only \\"5\\" -> 1 passcode ] expected_results = [1, 1, 1, 2, 1] results = solve(test_cases) assert results == expected_results, f\\"Expected {expected_results}, but got {results}\\" def test_large_cases(): test_cases = [ (500, 100), (100, 10), (200, 15), (300, 20), (400, 30) ] results = solve(test_cases) for result in results: assert isinstance(result, int) and result >= 0 test_count_passcodes() test_large_cases()","solution":"def count_passcodes(s, l, memo): if s < 0 or l < 0: return 0 if s == 0 and l == 0: return 1 if s == 0 or l == 0: return 0 if (s, l) in memo: return memo[(s, l)] count = 0 for d in range(10): count += count_passcodes(s - d * d, l - 1, memo) memo[(s, l)] = count return count def solve(test_cases): memo = {} results = [] for s, l in test_cases: results.append(count_passcodes(s, l, memo)) return results"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the given array. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == 6 >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) == 3 >>> longest_increasing_subsequence([3, 2]) == 1 >>> longest_increasing_subsequence([50, 3, 10, 7, 40, 80]) == 4 >>> longest_increasing_subsequence([]) == 0 >>> longest_increasing_subsequence([10]) == 1 >>> longest_increasing_subsequence([-1, 3, 4, 5, 2, 2, 2, 2, 6]) == 5 >>> longest_increasing_subsequence([0, 0, 0, 0, 0, 0, 0]) == 1 >>> longest_increasing_subsequence([0, -1, 2, -3, 4, -5, 6, -7]) == 4 >>> longest_increasing_subsequence([100, -100, 101, -99]) == 2","solution":"def longest_increasing_subsequence(arr): Returns the length of the longest increasing subsequence in the given array. if not arr: return 0 # Initialize the LIS array with 1s since each element is a subsequence of length 1 lis = [1] * len(arr) # Compute the LIS values for i in range(1, len(arr)): for j in range(0, i): if arr[i] > arr[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 # Return the maximum value in lis array return max(lis)"},{"question":"def compress_string(s: str) -> str: Compress a given string using the described compression method. >>> compress_string(\\"aaabbc\\") == \\"a3b2c\\" >>> compress_string(\\"a\\") == \\"a\\" >>> compress_string(\\"abbbcc\\") == \\"ab3c2\\" >>> compress_string(\\"abc\\") == \\"abc\\" >>> compress_string(\\"zzzzyyy\\") == \\"z4y3\\" >>> compress_string(\\"aabbbaaa\\") == \\"a2b3a3\\" >>> compress_string(\\"\\") == \\"\\" >>> compress_string(\\"a\\"*100000) == \\"a100000\\" def compress_strings(test_cases: List[str]) -> List[str]: Compress multiple strings using the described compression method. >>> compress_strings([\\"aaabbc\\", \\"a\\", \\"abbbcc\\", \\"abc\\", \\"zzzzyyy\\", \\"aabbbaaa\\"]) == [\\"a3b2c\\", \\"a\\", \\"ab3c2\\", \\"abc\\", \\"z4y3\\", \\"a2b3a3\\"] >>> compress_strings([\\"a\\"*100000, \\"b\\"*99999 + \\"a\\"]) == [\\"a100000\\", \\"b99999a\\"]","solution":"def compress_string(s): if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i-1]: count += 1 else: compressed.append(s[i-1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return ''.join(compressed) def compress_strings(test_cases): results = [] for s in test_cases: results.append(compress_string(s)) return results"},{"question":"def count_paths(n: int, m: int, grid: List[List[str]]) -> int: Calculate the number of distinct paths from the top-left corner to the bottom-right corner in an n x m grid with obstacles. >>> count_paths(2, 2, [['.', '#'], ['#', '.']]) 0 >>> count_paths(3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]) 2 >>> count_paths(3, 3, [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']]) 0 def process_test_cases(t: int, test_cases: List[Tuple[int, int, List[List[str]]]]) -> List[int]: Process multiple test cases to find the number of distinct paths in each case. >>> process_test_cases(3, [(2, 2, [['.', '#'], ['#', '.']]), (3, 3, [['.', '.', '.'], ['.', '#', '.'], ['.', '.', '.']]), (3, 3, [['#', '#', '#'], ['#', '#', '#'], ['#', '#', '#']])]) [0, 2, 0]","solution":"def count_paths(n, m, grid): if grid[0][0] == '#' or grid[n-1][m-1] == '#': return 0 dp = [[0]*m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == '#': dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1] def process_test_cases(t, test_cases): results = [] for test_case in test_cases: n, m, grid = test_case result = count_paths(n, m, grid) results.append(result) return results"},{"question":"def most_interested_topics(n, m, ratings): For each user, determine the indices of the topics they are most interested in based on their ratings. Args: n (int): Number of users. m (int): Number of topics. ratings (list of list of int): An n x m matrix containing ratings of each user for each topic. Returns: list of list of int: Indices of topics each user is most interested in. pass # Sample input n, m = 3, 4 ratings = [ [5, 3, 1, 2], [4, 4, 4, 2], [3, 5, 1, 1] ] # Run the function and print the results result = most_interested_topics(n, m, ratings) for user_topics in result: print(\\" \\".join(map(str, user_topics)))","solution":"def most_interested_topics(n, m, ratings): For each user, determine the indices of the topics they are most interested in based on their ratings. Args: n (int): Number of users. m (int): Number of topics. ratings (list of list of int): An n x m matrix containing ratings of each user for each topic. Returns: list of list of int: Indices of topics each user is most interested in. result = [] for user_ratings in ratings: max_rating = max(user_ratings) topics = [i for i, rating in enumerate(user_ratings) if rating == max_rating] result.append(topics) return result # Sample input n, m = 3, 4 ratings = [ [5, 3, 1, 2], [4, 4, 4, 2], [3, 5, 1, 1] ] # Run the function and print the results result = most_interested_topics(n, m, ratings) for user_topics in result: print(\\" \\".join(map(str, user_topics)))"},{"question":"class FileSystem: def __init__(self): self.fs = {'/': {}} def create(self, path): dirs = path.strip('/').split('/') current = self.fs['/'] for dir in dirs: if dir: if dir not in current: current[dir] = {} current = current[dir] def delete(self, path): dirs = path.strip('/').split('/') current = self.fs['/'] for dir in dirs[:-1]: current = current.get(dir, {}) current.pop(dirs[-1], None) def move(self, source_path, destination_path): dirs = source_path.strip('/').split('/') current = self.fs['/'] for dir in dirs[:-1]: current = current.get(dir, {}) subdir = current.pop(dirs[-1], None) if subdir is not None: dirs = destination_path.strip('/').split('/') current = self.fs['/'] for dir in dirs: if dir: if dir not in current: current[dir] = {} current = current[dir] current[dirs[-1]] = subdir def list(self, path): dirs = path.strip('/').split('/') current = self.fs['/'] for dir in dirs: if dir: current = current.get(dir, {}) return sorted(current.keys()) def process_operations(self, operations): results = [] for operation in operations: parts = operation.split() if parts[0] == 'CREATE': self.create(parts[1]) elif parts[0] == 'DELETE': self.delete(parts[1]) elif parts[0] == 'MOVE': self.move(parts[1], parts[2]) elif parts[0] == 'LIST': result = self.list(parts[1]) if result: results.append('n'.join(result)) else: results.append('') return results def process_filesystem_operations(operations): Processes a series of operations on a filesystem. Args: operations (List[str]): List of operations Returns: List[str]: Results of the LIST operations. >>> process_filesystem_operations([\\"CREATE /a\\", \\"CREATE /a/b\\", \\"LIST /a\\"]) ['b'] >>> process_filesystem_operations([\\"CREATE /home\\", \\"CREATE /home/user\\", \\"MOVE /home/user /user\\", \\"LIST /home\\", \\"LIST /user\\"]) ['', 'user']","solution":"class FileSystem: def __init__(self): self.fs = {'/': {}} def create(self, path): dirs = path.strip('/').split('/') current = self.fs['/'] for dir in dirs: if dir: if dir not in current: current[dir] = {} current = current[dir] def delete(self, path): dirs = path.strip('/').split('/') current = self.fs['/'] for dir in dirs[:-1]: current = current.get(dir, {}) current.pop(dirs[-1], None) def move(self, source_path, destination_path): dirs = source_path.strip('/').split('/') current = self.fs['/'] for dir in dirs[:-1]: current = current.get(dir, {}) subdir = current.pop(dirs[-1], None) if subdir is not None: dirs = destination_path.strip('/').split('/') current = self.fs['/'] for dir in dirs: if dir: if dir not in current: current[dir] = {} current = current[dir] current[dirs[-1]] = subdir def list(self, path): dirs = path.strip('/').split('/') current = self.fs['/'] for dir in dirs: if dir: current = current.get(dir, {}) return sorted(current.keys()) def process_operations(self, operations): results = [] for operation in operations: parts = operation.split() if parts[0] == 'CREATE': self.create(parts[1]) elif parts[0] == 'DELETE': self.delete(parts[1]) elif parts[0] == 'MOVE': self.move(parts[1], parts[2]) elif parts[0] == 'LIST': result = self.list(parts[1]) if result: results.append('n'.join(result)) else: results.append('') return results def process_filesystem_operations(operations): fs = FileSystem() return fs.process_operations(operations)"},{"question":"def max_non_overlapping_events(events): Determine the maximum number of non-overlapping events Alex can attend, given a list of events where each event is represented by a tuple (start, end). Args: events (List[Tuple[int, int]]): List of events where each event is represented as a tuple of start and end times. Returns: int: The maximum number of non-overlapping events. >>> max_non_overlapping_events([(1, 3), (2, 4), (3, 5)]) 2 >>> max_non_overlapping_events([(1, 2), (2, 3), (3, 4), (4, 5)]) 4 >>> max_non_overlapping_events([(1, 2), (2, 3), (1, 3)]) 2 # Your implementation here def process_test_cases(test_cases): Process multiple test cases and return the results for each test case. Args: test_cases (List[List[Tuple[int, int]]]): List of test cases, where each test case is a list of events represented by tuples of start and end times. Returns: List[int]: List of results where each result is the maximum number of non-overlapping events for the respective test case. >>> process_test_cases([[(1, 3), (2, 4), (3, 5)], [(1, 2), (2, 3), (3, 4), (4, 5)], [(1, 2), (2, 3), (1, 3)]]) [2, 4, 2] # Your implementation here from max_non_overlapping_events import max_non_overlapping_events, process_test_cases def test_example1(): test_cases = [ [(1, 3), (2, 4), (3, 5)], # 2 events (1, 3) and (3, 5) [(1, 2), (2, 3), (3, 4), (4, 5)], # 4 events as none overlap [(1, 2), (2, 3), (1, 3)] # 2 events (1, 2) and (2, 3) or (1, 3) ] expected_results = [2, 4, 2] assert process_test_cases(test_cases) == expected_results def test_all_overlapping_events(): test_cases = [ [(1, 4), (2, 5), (3, 6)], # Only one event can be attended ] expected_results = [1] assert process_test_cases(test_cases) == expected_results def test_no_overlapping_events(): test_cases = [ [(1, 2), (3, 4), (5, 6)], # All events can be attended ] expected_results = [3] assert process_test_cases(test_cases) == expected_results def test_events_with_same_end_time(): test_cases = [ [(1, 4), (2, 4), (3, 4), (0, 4)], # Only one event can be attended ] expected_results = [1] assert process_test_cases(test_cases) == expected_results def test_single_event(): test_cases = [ [(1, 2)], ] expected_results = [1] assert process_test_cases(test_cases) == expected_results def test_large_number_of_events(): # Testing with a large number of events test_cases = [ [(i, i+1) for i in range(1, 50001)], # 50000 non-overlapping events ] expected_results = [50000] assert process_test_cases(test_cases) == expected_results","solution":"def max_non_overlapping_events(events): # Sort events by their end times events.sort(key=lambda x: x[1]) current_end = 0 count = 0 for start, end in events: if start >= current_end: count += 1 current_end = end return count def process_test_cases(test_cases): results = [] for events in test_cases: result = max_non_overlapping_events(events) results.append(result) return results"},{"question":"from typing import List def min_time_to_rot_all_oranges(grid: List[List[int]]) -> int: Determine the minimum time required for all fresh oranges to become rotten. If it is impossible for all fresh oranges to become rotten, return -1. Args: grid (List[List[int]]): A 2D list representing the grid, where 0 represents an empty cell, 1 represents a fresh orange, and 2 represents a rotten orange. Returns: int: The minimum time required for all fresh oranges to become rotten, or -1 if impossible. Examples: >>> min_time_to_rot_all_oranges([[2, 1, 1], [1, 1, 0], [0, 1, 1]]) 4 >>> min_time_to_rot_all_oranges([[2, 1, 1], [0, 1, 1], [1, 0, 1]]) -1 import pytest def test_example_1(): grid = [ [2, 1, 1], [1, 1, 0], [0, 1, 1] ] assert min_time_to_rot_all_oranges(grid) == 4 def test_example_2(): grid = [ [2, 1, 1], [0, 1, 1], [1, 0, 1] ] assert min_time_to_rot_all_oranges(grid) == -1 def test_all_rotten(): grid = [ [2, 2, 2], [2, 2, 2], [2, 2, 2] ] assert min_time_to_rot_all_oranges(grid) == 0 def test_all_empty(): grid = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_time_to_rot_all_oranges(grid) == 0 def test_mixed_with_isolated(): grid = [ [2, 0, 1], [0, 1, 0], [1, 0, 2] ] assert min_time_to_rot_all_oranges(grid) == -1 def test_edge_case_single_fresh_orange(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert min_time_to_rot_all_oranges(grid) == -1","solution":"from collections import deque def min_time_to_rot_all_oranges(grid): rows = len(grid) cols = len(grid[0]) queue = deque() fresh_count = 0 # Initialize the queue with all starting rotten oranges for r in range(rows): for c in range(cols): if grid[r][c] == 2: queue.append((r, c, 0)) elif grid[r][c] == 1: fresh_count += 1 # If there are no fresh oranges, return 0 if fresh_count == 0: return 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] minutes = 0 while queue: r, c, minutes = queue.popleft() for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 1: grid[nr][nc] = 2 queue.append((nr, nc, minutes + 1)) fresh_count -= 1 return minutes if fresh_count == 0 else -1"},{"question":"def removeDuplicates(S: str) -> str: Removes duplicate characters from the string while retaining the first occurrence of each character. Parameters: S (str): Input string containing alphanumeric characters and spaces. Returns: str: String with duplicates removed. >>> removeDuplicates(\\"geeks for geeks\\") 'geks for' >>> removeDuplicates(\\"hello world\\") 'helo wrd'","solution":"def removeDuplicates(S): Removes duplicate characters from the string while retaining the first occurrence of each character. Parameters: S (str): Input string containing alphanumeric characters and spaces. Returns: str: String with duplicates removed. seen = set() result = [] for char in S: if char not in seen: seen.add(char) result.append(char) return ''.join(result)"},{"question":"def string_power(s: str) -> str: Determines if the given string is \\"POWERFUL\\" or \\"WEAK\\" based on Alok's criteria. Parameters: s (str): The input string consisting of lowercase English letters. Returns: str: \\"POWERFUL\\" if the count of vowels is strictly greater than the count of consonants, otherwise \\"WEAK\\". >>> string_power(\\"hello\\") == \\"WEAK\\" >>> string_power(\\"amazingly\\") == \\"WEAK\\" >>> string_power(\\"aeiou\\") == \\"POWERFUL\\" >>> string_power(\\"rhythm\\") == \\"WEAK\\" >>> string_power(\\"execution\\") == \\"POWERFUL\\"","solution":"def string_power(str): Determines if the given string is \\"POWERFUL\\" or \\"WEAK\\" based on Alok's criteria. Parameters: str (string): The input string consisting of lowercase English letters. Returns: string: \\"POWERFUL\\" if the count of vowels is strictly greater than the count of consonants, otherwise \\"WEAK\\". vowels = set('aeiou') vowel_count = 0 consonant_count = 0 for ch in str: if ch in vowels: vowel_count += 1 else: consonant_count += 1 if vowel_count > consonant_count: return \\"POWERFUL\\" else: return \\"WEAK\\""},{"question":"def longest_non_decreasing_subsequence_length(nums): Returns the length of the longest non-decreasing consecutive sub-sequence in the list of temperatures nums. >>> longest_non_decreasing_subsequence_length([-5, -1, -1, 0, 3, 3, 4]) 7 >>> longest_non_decreasing_subsequence_length([5, 4, 3, 2, 1]) 1 >>> longest_non_decreasing_subsequence_length([1, 2, 3, 4, 5]) 5","solution":"def longest_non_decreasing_subsequence_length(nums): Returns the length of the longest non-decreasing consecutive sub-sequence in the list of temperatures nums. if not nums: return 0 max_length = 1 current_length = 1 for i in range(1, len(nums)): if nums[i] >= nums[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length"},{"question":"def distribute_tasks(team_members, tasks): Write a Python function named \`distribute_tasks\` that takes two arguments: - \`team_members\` (a list of strings representing the names of each team member) - \`tasks\` (a list of strings representing the description of each task) The function should: 1. Assign tasks to team members in a \\"round-robin\\" fashion, i.e., the first task goes to the first team member, the second task to the second team member, and so on. After the last team member receives a task, the next task should go back to the first team member, and the cycle continues. 2. Return a dictionary where the keys are the names of the team members, and the values are lists of tasks assigned to each member. Example usage: team_members = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] tasks = [\\"Task 1\\", \\"Task 2\\", \\"Task 3\\", \\"Task 4\\", \\"Task 5\\", \\"Task 6\\", \\"Task 7\\"] distribute_tasks(team_members, tasks) Expected output: { \\"Alice\\": [\\"Task 1\\", \\"Task 4\\", \\"Task 7\\"], \\"Bob\\": [\\"Task 2\\", \\"Task 5\\"], \\"Charlie\\": [\\"Task 3\\", \\"Task 6\\"] } # Your Implementation Here def test_distribute_tasks(): team_members = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] tasks_1 = [\\"Task 1\\", \\"Task 2\\", \\"Task 3\\", \\"Task 4\\", \\"Task 5\\", \\"Task 6\\", \\"Task 7\\"] expected_output_1 = { \\"Alice\\": [\\"Task 1\\", \\"Task 4\\", \\"Task 7\\"], \\"Bob\\": [\\"Task 2\\", \\"Task 5\\"], \\"Charlie\\": [\\"Task 3\\", \\"Task 6\\"] } assert distribute_tasks(team_members, tasks_1) == expected_output_1 tasks_2 = [\\"Task 1\\", \\"Task 2\\", \\"Task 3\\"] expected_output_2 = { \\"Alice\\": [\\"Task 1\\"], \\"Bob\\": [\\"Task 2\\"], \\"Charlie\\": [\\"Task 3\\"] } assert distribute_tasks(team_members, tasks_2) == expected_output_2 tasks_3 = [\\"Task 1\\", \\"Task 2\\", \\"Task 3\\", \\"Task 4\\", \\"Task 5\\", \\"Task 6\\"] expected_output_3 = { \\"Alice\\": [\\"Task 1\\", \\"Task 4\\"], \\"Bob\\": [\\"Task 2\\", \\"Task 5\\"], \\"Charlie\\": [\\"Task 3\\", \\"Task 6\\"] } assert distribute_tasks(team_members, tasks_3) == expected_output_3 tasks_4 = [] expected_output_4 = { \\"Alice\\": [], \\"Bob\\": [], \\"Charlie\\": [] } assert distribute_tasks(team_members, tasks_4) == expected_output_4 team_members_2 = [\\"Alice\\"] tasks_5 = [\\"Task 1\\"] expected_output_5 = { \\"Alice\\": [\\"Task 1\\"], } assert distribute_tasks(team_members_2, tasks_5) == expected_output_5 team_members_3 = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\"] tasks_6 = [\\"Task 1\\", \\"Task 2\\", \\"Task 3\\", \\"Task 4\\", \\"Task 5\\"] expected_output_6 = { \\"Alice\\": [\\"Task 1\\", \\"Task 5\\"], \\"Bob\\": [\\"Task 2\\"], \\"Charlie\\": [\\"Task 3\\"], \\"David\\": [\\"Task 4\\"] } assert distribute_tasks(team_members_3, tasks_6) == expected_output_6","solution":"def distribute_tasks(team_members, tasks): Distributes tasks among team members in a round-robin fashion. Parameters: team_members (list): A list of strings representing the names of each team member. tasks (list): A list of strings representing the description of each task. Returns: dict: A dictionary where the keys are the names of the team members, and the values are lists of tasks assigned to each member. task_distribution = {member: [] for member in team_members} for index, task in enumerate(tasks): team_member = team_members[index % len(team_members)] task_distribution[team_member].append(task) return task_distribution"},{"question":"def to_binary_string(s: str) -> str: Write a function that takes a string as input and returns a modified string where each character is replaced by a sequence of the character followed by a binary representation of its ASCII value. The binary representation should be 8 bits long, with leading zeros if necessary. If the input contains any characters outside the standard ASCII range (0-127), return the string 'Invalid input'. >>> to_binary_string(\\"abc\\") \\"a01100001b01100010c01100011\\" >>> to_binary_string(\\"Hello!\\") \\"H01001000e01100101l01101100l01101100o01101111!00100001\\" >>> to_binary_string(\\"こんにちは\\") \\"Invalid input\\"","solution":"def to_binary_string(s): def char_to_bin(char): ascii_value = ord(char) if ascii_value > 127: # ASCII value out of range return 'Invalid input' binary_value = format(ascii_value, '08b') return char + binary_value result = [] for char in s: bin_str = char_to_bin(char) if bin_str == 'Invalid input': return 'Invalid input' result.append(bin_str) return ''.join(result)"},{"question":"def can_transform_to_permutations(T: int, test_cases: List[Tuple[str, str]]) -> List[str]: Determines if it is possible for two strings to be transformed into permutations of each other. Args: T : int : number of test cases test_cases : list : list of tuples each containing two strings A and B Returns: list : list containing \\"YES\\" or \\"NO\\" for each test case Example: >>> can_transform_to_permutations(2, [(\\"abc\\", \\"cba\\"), (\\"a\\", \\"b\\")]) [\\"YES\\", \\"NO\\"] >>> can_transform_to_permutations(3, [(\\"abc\\", \\"bca\\"), (\\"xyz\\", \\"yxz\\"), (\\"abcd\\", \\"abdc\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_transform_to_permutations(T, test_cases): Determines if it is possible for two strings to be transformed into permutations of each other. Args: T : int : number of test cases test_cases : list : list of tuples each containing two strings A and B Returns: list : list containing \\"YES\\" or \\"NO\\" for each test case results = [] for i in range(T): A, B = test_cases[i] if sorted(A) == sorted(B): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def min_storage_devices(n: int, C: int, sizes: List[int]) -> int: Arrange the files into the minimum number of storage devices required. Args: n (int): The number of files. C (int): The capacity of each storage device. sizes (List[int]): A list of integers denoting the size of each file. Returns: int: The minimum number of storage devices required to store all the files. Examples: >>> min_storage_devices(4, 10, [1, 8, 3, 5]) 2 >>> min_storage_devices(3, 6, [2, 4, 5]) 2 >>> min_storage_devices(5, 15, [3, 7, 9, 4, 6]) 2 pass import pytest def test_example_1(): assert min_storage_devices(4, 10, [1, 8, 3, 5]) == 2 def test_example_2(): assert min_storage_devices(3, 6, [2, 4, 5]) == 2 def test_example_3(): assert min_storage_devices(5, 15, [3, 7, 9, 4, 6]) == 2 def test_single_file(): assert min_storage_devices(1, 10, [5]) == 1 def test_all_files_fit_in_one_device(): assert min_storage_devices(3, 10, [2, 3, 5]) == 1 def test_all_files_too_large_for_one_device(): assert min_storage_devices(4, 5, [6, 7, 8, 9]) == 4 def test_variety_of_file_sizes(): assert min_storage_devices(6, 10, [9, 8, 2, 2, 2, 1]) == 3 def test_large_file_sizes(): assert min_storage_devices(3, 10**9, [10**9, 10**9, 10**9]) == 3 def test_large_capacity(): assert min_storage_devices(4, 10**9, [1, 10, 100, 1000]) == 1 @pytest.mark.parametrize(\\"n, C, sizes, expected\\", [ (4, 10, [1, 8, 3, 5], 2), (3, 6, [2, 4, 5], 2), (5, 15, [3, 7, 9, 4, 6], 2), ]) def test_parametrized(n, C, sizes, expected): assert min_storage_devices(n, C, sizes) == expected","solution":"from typing import List def min_storage_devices(n: int, C: int, sizes: List[int]) -> int: # Sort file sizes in non-increasing order sizes.sort(reverse=True) devices = [] for size in sizes: placed = False # Try to place the file in the existing devices for i in range(len(devices)): if devices[i] + size <= C: devices[i] += size placed = True break if not placed: # If the file was not placed in any existing device, add a new device devices.append(size) return len(devices)"},{"question":"def max_non_decreasing_subarray(arr: List[int]) -> int: Determine the maximum number of people who can form a non-decreasing subarray if at most one person can be removed from the lineup. >>> max_non_decreasing_subarray([1, 2, 5, 3, 4]) 4 >>> max_non_decreasing_subarray([3, 1, 2, 6, 4, 5]) 4 >>> max_non_decreasing_subarray([5]) 1 >>> max_non_decreasing_subarray([1, 2, 3, 4, 5]) 5 >>> max_non_decreasing_subarray([2, 2, 2, 2, 2]) 5 >>> max_non_decreasing_subarray([1, 2, 4, 3, 5]) 4 >>> max_non_decreasing_subarray([1, 2, 2, 5, 4]) 4 >>> max_non_decreasing_subarray([1, 3, 3, 5, 7, 8]) 6","solution":"def max_non_decreasing_subarray(arr): n = len(arr) if n == 1: return 1 # Arrays to store the longest increasing subarray # length ending at each index left = [1] * n right = [1] * n # Fill left array for i in range(1, n): if arr[i] >= arr[i-1]: left[i] = left[i-1] + 1 # Fill right array for i in range(n-2, -1, -1): if arr[i] <= arr[i+1]: right[i] = right[i+1] + 1 # Find the maximum length of non-decreasing subarray max_len = max(max(left), max(right)) # Check the possibility to remove one element for i in range(1, n-1): if arr[i-1] <= arr[i+1]: max_len = max(max_len, left[i-1] + right[i+1]) return max_len"},{"question":"def max_sum(arr, k): Returns the maximum sum of k consecutive elements in the array. Ensure that your solution is efficient in terms of time complexity. >>> max_sum([1, 2, 5, 2, 8, 1, 5], 2) == 10 >>> max_sum([1, 2, 5, 2, 8, 1, 5], 4) == 17 >>> max_sum([4, 2, 1, 6], 1) == 6 >>> max_sum([4, 2, 1, 6, 2], 4) == 13 >>> max_sum([4, 2, 1, 6, 2], 8) == 0 >>> max_sum([], 3) == 0","solution":"def max_sum(arr, k): Returns the maximum sum of k consecutive elements in the array. Uses sliding window technique for efficiency. if not arr or k <= 0 or k > len(arr): return 0 max_sum = curr_sum = sum(arr[:k]) for i in range(k, len(arr)): curr_sum += arr[i] - arr[i - k] max_sum = max(max_sum, curr_sum) return max_sum"},{"question":"from typing import List def find_subsequence_lengths(arr: List[int]) -> List[int]: Given an array of integers, return an array containing the length of the longest strictly increasing subsequences ending at each respective element of the input array. >>> find_subsequence_lengths([1, 3, 2, 3, 4, 8, 7, 6]) [1, 2, 2, 3, 4, 5, 5, 5] >>> find_subsequence_lengths([9, 8, 7, 6]) [1, 1, 1, 1] def test_example_1(): assert find_subsequence_lengths([1, 3, 2, 3, 4, 8, 7, 6]) == [1, 2, 2, 3, 4, 5, 5, 5] def test_example_2(): assert find_subsequence_lengths([9, 8, 7, 6]) == [1, 1, 1, 1] def test_single_element(): assert find_subsequence_lengths([10]) == [1] def test_increasing_order(): assert find_subsequence_lengths([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_decreasing_order(): assert find_subsequence_lengths([5, 4, 3, 2, 1]) == [1, 1, 1, 1, 1] def test_alternating_order(): assert find_subsequence_lengths([1, 3, 2, 4, 3, 5]) == [1, 2, 2, 3, 3, 4] def test_random_order(): assert find_subsequence_lengths([10, 22, 9, 33, 21, 50, 41, 60, 80]) == [1, 2, 1, 3, 2, 4, 4, 5, 6] def test_no_elements(): assert find_subsequence_lengths([]) == []","solution":"from typing import List def find_subsequence_lengths(arr: List[int]) -> List[int]: if not arr: return [] n = len(arr) lis_lengths = [1] * n for i in range(1, n): for j in range(0, i): if arr[i] > arr[j]: lis_lengths[i] = max(lis_lengths[i], lis_lengths[j] + 1) return lis_lengths"},{"question":"def minimize_time_difference(tasks: List[int]) -> int: Assign tasks to two workers such that the difference between the total time taken by each worker is minimized. Args: tasks (List[int]): A list of integers representing the time required for each task. Returns: int: The minimized absolute difference between the total time taken by Worker A and Worker B. >>> minimize_time_difference([10, 20, 30, 40]) 0 >>> minimize_time_difference([1, 2, 3, 4, 5]) 1","solution":"def minimize_time_difference(tasks): total_sum = sum(tasks) n = len(tasks) half_sum = total_sum // 2 # Create a DP table to store reachable sums up to half_sum dp = [False] * (half_sum + 1) dp[0] = True for time in tasks: for j in range(half_sum, time - 1, -1): dp[j] = dp[j] or dp[j - time] for j in range(half_sum, -1, -1): if dp[j]: sum_A = j break sum_B = total_sum - sum_A return abs(sum_A - sum_B)"},{"question":"def calculate_entry_fee(Sara_age: int, C: int) -> int: Calculate the entry fee to the amusement park based on Sara's age and the normal entry fee. Children who are between 4 and 10 years old (inclusive) get a 30% discount. Teenagers aged between 11 and 17 years old (inclusive) get a 20% discount. Visitors aged 18 years and older, as well as children under 4, do not receive any discount. :param Sara_age: int, age of Sara. :param C: int, normal entry fee to the park. :return: int, the discounted entry fee Sara has to pay. >>> calculate_entry_fee(5, 50) 35 >>> calculate_entry_fee(12, 50) 40","solution":"def calculate_entry_fee(Sara_age, C): Calculates the entry fee to the amusement park based on Sara's age and the normal entry fee. :param Sara_age: int, age of Sara. :param C: int, normal entry fee to the park. :return: int, the discounted entry fee Sara has to pay. if 4 <= Sara_age <= 10: return int(C * 0.70) # 30% discount elif 11 <= Sara_age <= 17: return int(C * 0.80) # 20% discount else: return C # No discount for others"},{"question":"def rearrange_string(s: str) -> str: Rearrange the string so that all letters come first followed by all digits. The relative order between letters and between digits is preserved. Parameters: s (str): Input string containing digits and lowercase letters. Returns: str: Rearranged string with letters first followed by digits. >>> rearrange_string(\\"a1b2c3\\") 'abc123' >>> rearrange_string(\\"abcdef\\") 'abcdef' >>> rearrange_string(\\"123456\\") '123456' >>> rearrange_string(\\"1a2b3c\\") 'abc123' >>> rearrange_string(\\"\\") '' >>> rearrange_string(\\"abcdef1234\\") 'abcdef1234' >>> rearrange_string(\\"1234abcdef\\") 'abcdef1234'","solution":"def rearrange_string(s): Rearrange the string so that all letters come first followed by all digits. The relative order between letters and between digits is preserved. Parameters: s (str): Input string containing digits and lowercase letters. Returns: str: Rearranged string with letters first followed by digits. letters = [] digits = [] for char in s: if char.isdigit(): digits.append(char) else: letters.append(char) return ''.join(letters) + ''.join(digits)"},{"question":"def can_survivors_reach_safety(test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if survivors can collect all necessary keys and pass through the gates to reach safety. Args: test_cases (List[Tuple[int, List[int], List[int]]]): A list of test cases, where each test case contains: - an integer \`n\` representing the number of keys and gates - a list of integers representing the distances to each key from the start - a list of integers representing the distances from each gate to the final gate Returns: List[str]: A list of results for each test case; \\"Survivors can reach safety\\" if the survivors can collect all keys and pass through all gates, otherwise \\"Survivors cannot reach safety\\". >>> can_survivors_reach_safety([(3, [2, 5, 3], [8, 10, 15]), (2, [3, 6], [1, 4])]) [\\"Survivors can reach safety\\", \\"Survivors cannot reach safety\\"] >>> can_survivors_reach_safety([(3, [3, 3, 3], [3, 3, 3])]) [\\"Survivors cannot reach safety\\"] >>> can_survivors_reach_safety([(1, [2], [3]), (1, [5], [4])]) [\\"Survivors can reach safety\\", \\"Survivors cannot reach safety\\"] >>> can_survivors_reach_safety([(3, [10000, 9999, 9998], [10001, 10002, 10003])]) [\\"Survivors can reach safety\\"] >>> can_survivors_reach_safety([(3, [5, 2, 3], [15, 8, 10])]) [\\"Survivors can reach safety\\"]","solution":"def can_survivors_reach_safety(test_cases): results = [] for case in test_cases: n, keys_distances, gates_distances = case keys_distances.sort() gates_distances.sort() can_reach = True for i in range(n): if keys_distances[i] >= gates_distances[i]: can_reach = False break if can_reach: results.append(\\"Survivors can reach safety\\") else: results.append(\\"Survivors cannot reach safety\\") return results"},{"question":"from typing import List, Tuple def most_scenic_paths(n: int, m: int, q: int, edges: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[int]: Calculate the most scenic path between pairs of cities based on the queries. Args: n (int): Number of cities. m (int): Number of roads. q (int): Number of queries. edges (List[Tuple[int, int, int]]): List of tuples where each tuple contains three integers u, v, b. There is a road between cities u and v with a beauty index b. queries (List[Tuple[int, int]]): List of tuples where each tuple contains two integers a and b, representing the query for the most scenic path between cities a and b. Returns: List[int]: List of results for each query. Each result is the most scenic path's maximum scenic value, or -1 if there's no path. Examples: >>> most_scenic_paths(5, 7, 3, [(1, 2, 4), (2, 3, 8), (1, 3, 5), (4, 5, 1), (3, 4, 6), (2, 5, 10), (3, 5, 7)], [(1, 5), (2, 4), (4, 1)]) [5, 6, 5] >>> most_scenic_paths(4, 2, 1, [(1, 2, 3), (3, 4, 5)], [(1, 4)]) [-1] >>> most_scenic_paths(3, 3, 1, [(1, 2, 7), (2, 3, 9), (1, 3, 10)], [(1, 3)]) [10] >>> most_scenic_paths(1, 0, 1, [], [(1, 1)]) [float('inf')]","solution":"from collections import defaultdict import heapq def preprocess_graph(n, edges): Preprocess the graph using the given edges and returns an adjacency list. graph = defaultdict(list) for u, v, b in edges: graph[u].append((v, b)) graph[v].append((u, b)) return graph def max_scenic_path(n, graph, start, end): Use Dijkstra's-like algorithm to find the maximum scenic path between start and end. heap = [(-float('inf'), start)] max_path = [-float('inf')] * (n + 1) max_path[start] = float('inf') while heap: current_scenic, node = heapq.heappop(heap) current_scenic = -current_scenic if node == end: return current_scenic for neighbor, beauty in graph[node]: min_scenic = min(current_scenic, beauty) if min_scenic > max_path[neighbor]: max_path[neighbor] = min_scenic heapq.heappush(heap, (-min_scenic, neighbor)) return -1 def most_scenic_paths(n, m, q, edges, queries): graph = preprocess_graph(n, edges) results = [] for a, b in queries: result = max_scenic_path(n, graph, a, b) results.append(result) return results"},{"question":"def rotate(matrix): Rotates the n x n matrix by 90 degrees clockwise in-place. :param matrix: a list of list of integers representing the 2D matrix. Example: >>> matrix = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> rotate(matrix) >>> matrix [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ]","solution":"def rotate(matrix): Rotates the n x n matrix by 90 degrees clockwise in-place. n = len(matrix) # Transpose the matrix for i in range(n): for j in range(i, n): matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j] # Reverse each row for i in range(n): matrix[i].reverse()"},{"question":"def can_distribute_power(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determine if it is possible to distribute the power to all attractions without overloading any kiosk. Args: t: int - the number of test cases. test_cases: List[Tuple[int, int, List[int]]] - a list of tuples. Each tuple contains: - an integer n (number of attractions) - an integer m (number of kiosks) - a list containing n integers (power requirements of each attraction) followed by m integers (capacities of each kiosk) Return: List[str] - a list of 'YES' or 'NO' for each test case. Examples: >>> can_distribute_power(3, [(3, 2, [10, 20, 30, 30, 30]), (1, 1, [2, 1]), (4, 5, [2, 3, 4, 5, 10, 20, 30, 40, 50])]) [\\"NO\\", \\"NO\\", \\"YES\\"] import pytest from solution import can_distribute_power def test_example_cases(): t = 3 test_cases = [ (3, 2, [10, 20, 30, 30, 30]), (1, 1, [2, 1]), (4, 5, [2, 3, 4, 5, 10, 20, 30, 40, 50]) ] assert can_distribute_power(t, test_cases) == [\\"NO\\", \\"NO\\", \\"YES\\"] def test_edge_cases(): t = 1 test_cases = [ (1, 1, [1, 2]) ] assert can_distribute_power(t, test_cases) == [\\"YES\\"] test_cases = [ (1, 1, [2, 1]) ] assert can_distribute_power(t, test_cases) == [\\"NO\\"] test_cases = [ (1000, 1000, [1]*1000 + [1]*1000) ] assert can_distribute_power(t, test_cases) == [\\"YES\\"] def test_large_values(): t = 1 test_cases = [ (3, 3, [1000000, 1000000, 1000000, 3000000, 3000000, 3000000]) ] assert can_distribute_power(t, test_cases) == [\\"YES\\"] test_cases = [ (4, 3, [1000000, 1000000, 1000000, 1000000, 3000000, 3000000, 3000000]) ] assert can_distribute_power(t, test_cases) == [\\"NO\\"] if __name__ == \\"__main__\\": pytest.main()","solution":"def can_distribute_power(t, test_cases): results = [] for i in range(t): n, m = test_cases[i][:2] power_requirements = test_cases[i][2][:n] kiosk_capacities = test_cases[i][2][n:] total_power_required = sum(power_requirements) total_capacity_available = sum(kiosk_capacities) if total_power_required > total_capacity_available: results.append(\\"NO\\") else: power_requirements.sort(reverse=True) kiosk_capacities.sort(reverse=True) possible = True for j in range(n): if j < m: if power_requirements[j] > kiosk_capacities[j]: possible = False break else: possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage: t = 3 test_cases = [ (3, 2, [10, 20, 30, 30, 30]), (1, 1, [2, 1]), (4, 5, [2, 3, 4, 5, 10, 20, 30, 40, 50]) ] print(can_distribute_power(t, test_cases)) # Output should be [\\"NO\\", \\"NO\\", \\"YES\\"]"},{"question":"def minOperations(start: int, target: int) -> int: Given two integers start and target, find the minimum number of operations required to convert start to target using only the following operations: 1. Multiply the current number by 2. 2. Subtract 1 from the current number. Examples: >>> minOperations(2, 3) 2 >>> minOperations(5, 8) 2 pass def test_min_operations_example1(): assert minOperations(2, 3) == 2 # 2 -> 4 -> 3 def test_min_operations_example2(): assert minOperations(5, 8) == 2 # 5 -> 10 -> 9 -> 8 def test_min_operations_same_start_target(): assert minOperations(7, 7) == 0 # 7 is already 7 def test_min_operations_target_less_than_start(): assert minOperations(15, 5) == 10 # 15 -> 14 -> 13 -> 12 -> 11 -> 10 -> 9 -> 8 -> 7 -> 6 -> 5 def test_min_operations_large_values(): assert minOperations(3, 1024) == 10 # 3 -> 6 -> 12 -> 24 -> 48 -> 96 -> 192 -> 384 -> 768 -> 1536 -> 1025 -> 1024","solution":"def minOperations(start, target): Returns the minimum number of operations to convert start to target using the specified operations. operations = 0 while target > start: if target % 2 == 0: target //= 2 else: target += 1 operations += 1 operations += (start - target) return operations"},{"question":"def can_form_palindrome(s: str) -> str: Determines whether the characters of the string s can be rearranged to form a palindrome. The input consists of a single line containing a string s (1 ≤ |s| ≤ 10^5). The string contains only lowercase English letters. >>> can_form_palindrome(\\"carrace\\") \\"YES\\" >>> can_form_palindrome(\\"hello\\") \\"NO\\" >>> can_form_palindrome(\\"aabbccdd\\") \\"YES\\" >>> can_form_palindrome(\\"a\\") \\"YES\\"","solution":"def can_form_palindrome(s): Determines whether the characters of the string s can be rearranged to form a palindrome. :param s: A string of lowercase English letters :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\" from collections import Counter # Count the frequency of each character char_counts = Counter(s) # Count characters with odd frequencies odd_count = sum(1 for count in char_counts.values() if count % 2 != 0) # A string can be rearranged into a palindrome if at most one character has an odd count if odd_count <= 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def hasIsolatedSetBits(n: int) -> str: This function checks if the binary representation of the number n contains any isolated set bits. An isolated set bit is a bit '1' which has '0's on both sides. Args: n (int): number to check for isolated set bits in its binary representation. Returns: str: \\"Yes\\" if there is at least one isolated set bit, otherwise \\"No\\". Examples: >>> hasIsolatedSetBits(18) \\"Yes\\" >>> hasIsolatedSetBits(7) \\"No\\"","solution":"def hasIsolatedSetBits(n): This function checks if the binary representation of the number n contains any isolated set bits. An isolated set bit is a bit '1' which has '0's on both sides. Args: n (int): number to check for isolated set bits in its binary representation. Returns: str: \\"Yes\\" if there is at least one isolated set bit, otherwise \\"No\\". # Convert n to binary string and strip the leading '0b' binary_string = bin(n)[2:] # Check for isolated set bits in the binary string for i in range(1, len(binary_string) - 1): if binary_string[i] == '1' and binary_string[i-1] == '0' and binary_string[i+1] == '0': return \\"Yes\\" return \\"No\\""},{"question":"def generate_spiral_matrix(n: int, m: int) -> List[List[int]]: Generates an n x m matrix filled with integers from 1 to n * m in a spiral order. >>> generate_spiral_matrix(3, 3) [[1, 2, 3], [8, 9, 4], [7, 6, 5]] >>> generate_spiral_matrix(3, 4) [[1, 2, 3, 4], [10, 11, 12, 5], [9, 8, 7, 6]]","solution":"def generate_spiral_matrix(n, m): Generates an n x m matrix filled with integers from 1 to n * m in a spiral order. matrix = [[0] * m for _ in range(n)] directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # right, down, left, up direction_index = 0 current_number = 1 row, col = 0, 0 for _ in range(n * m): matrix[row][col] = current_number current_number += 1 next_row, next_col = row + directions[direction_index][0], col + directions[direction_index][1] if not (0 <= next_row < n and 0 <= next_col < m and matrix[next_row][next_col] == 0): direction_index = (direction_index + 1) % 4 # change direction next_row, next_col = row + directions[direction_index][0], col + directions[direction_index][1] row, col = next_row, next_col return matrix"},{"question":"def generate_bib_numbers(n: int) -> list: Generate a list of bib numbers with prefix \\"M\\" and registration number 1 to n. Parameters: n (int): Number of participants. Returns: list: List of bib numbers as strings. pass # Example Usage: # >>> generate_bib_numbers(3) # [\\"M1\\", \\"M2\\", \\"M3\\"] # >>> generate_bib_numbers(5) # [\\"M1\\", \\"M2\\", \\"M3\\", \\"M4\\", \\"M5\\"]","solution":"def generate_bib_numbers(n): Generate a list of bib numbers with prefix \\"M\\" and registration number 1 to n. Parameters: n (int): Number of participants. Returns: list: List of bib numbers as strings. return [f\\"M{i}\\" for i in range(1, n + 1)]"},{"question":"class BookStack: A class to manage a stack of books with various operations. def __init__(self): Initialize an empty book stack. pass def push(self, value: int): Push an integer value onto the stack. def remove(self): Remove and return the integer on the top of the stack. If the stack is empty, return \\"EMPTY\\". def find_max(self): Find and return the maximum integer in the stack. If the stack is empty, return \\"EMPTY\\". def search_top_half(self): Search the top half of the stack and return the maximum value. If the stack is empty, return \\"EMPTY\\". def search_bottom_half(self): Search the bottom half of the stack and return the maximum value. If the stack is empty, return \\"EMPTY\\". def process_test_cases(test_cases: List[Tuple[int, List[str]]]) -> List[Union[int, str]]: Process a list of test cases with operations on a stack of books. Args: test_cases: List of tuples containing the number of queries and the list of queries. Returns: List of results of the operations performed. >>> process_test_cases([(5, [\\"P 5\\", \\"P 10\\", \\"F\\", \\"R\\", \\"R\\"])]) [10, 10, 5, \\"END\\"] >>> process_test_cases([(7, [\\"P 1\\", \\"P 3\\", \\"P 2\\", \\"P 7\\", \\"S\\", \\"L\\", \\"F\\"])]) [7, 3, 7, \\"END\\"]","solution":"class BookStack: def __init__(self): self.stack = [] def push(self, value): self.stack.append(value) def remove(self): if not self.stack: return \\"EMPTY\\" return self.stack.pop() def find_max(self): if not self.stack: return \\"EMPTY\\" return max(self.stack) def search_top_half(self): if not self.stack: return \\"EMPTY\\" half_size = (len(self.stack) + 1) // 2 top_half = self.stack[-half_size:] return max(top_half) def search_bottom_half(self): if not self.stack: return \\"EMPTY\\" half_size = len(self.stack) // 2 bottom_half = self.stack[:half_size] return max(bottom_half) def process_test_cases(test_cases): results = [] for case in test_cases: n, queries = case book_stack = BookStack() for query in queries: if query.startswith(\\"P\\"): _, value = query.split() book_stack.push(int(value)) elif query == \\"R\\": results.append(book_stack.remove()) elif query == \\"F\\": results.append(book_stack.find_max()) elif query == \\"S\\": results.append(book_stack.search_top_half()) elif query == \\"L\\": results.append(book_stack.search_bottom_half()) results.append(\\"END\\") return results # Example usage if __name__ == \\"__main__\\": test_cases = [ (5, [\\"P 5\\", \\"P 10\\", \\"F\\", \\"R\\", \\"R\\"]), (7, [\\"P 1\\", \\"P 3\\", \\"P 2\\", \\"P 7\\", \\"S\\", \\"L\\", \\"F\\"]) ] result = process_test_cases(test_cases) for res in result: print(res)"},{"question":"def longest_same_char_substring(strings): Finds the length of the longest substring of the same character for each string in the input list. Parameters: strings (list of str): List of input strings. Returns: list of int: List containing the length of the longest substring of the same character for each input string. >>> longest_same_char_substring([\\"aabbbbbcc\\", \\"aaaaabaaa\\"]) [5, 5] >>> longest_same_char_substring([\\"abcd\\", \\"aaa\\", \\"a\\", \\"bbbbb\\"]) [1, 3, 1, 5] pass # Function to process the input format def process_input(input_lines): Processes the input format for the problem. Parameters: input_lines (list of str): Input lines containing number of test cases and each test string. Returns: list of int: List containing the length of the longest substring of the same character for each input string. >>> process_input([\\"2\\", \\"aabbbbbcc\\", \\"aaaaabaaa\\"]) [5, 5] >>> process_input([\\"3\\", \\"abcd\\", \\"aaa\\", \\"a\\"]) [1, 3, 1] pass","solution":"def longest_same_char_substring(strings): Finds the length of the longest substring of the same character for each string in the input list. Parameters: strings (list of str): List of input strings. Returns: list of int: List containing the length of the longest substring of the same character for each input string. result = [] for s in strings: max_length = 1 current_length = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 1 result.append(max_length) return result # Function to process the input format def process_input(input_lines): t = int(input_lines[0]) strings = input_lines[1:t+1] return longest_same_char_substring(strings)"},{"question":"def weakest_security_level(codes: List[str]) -> int: Returns the security level of the weakest code among the given set of cryptographic codes. The security level is determined by the number of distinct substrings a code can generate and the weakest code has the fewest number of distinct substrings. >>> weakest_security_level([\\"abcde\\", \\"zz\\"]) == 2 >>> weakest_security_level([\\"a\\"]) == 1 >>> weakest_security_level([\\"abcdabcd\\", \\"ab\\"]) == 3","solution":"def distinct_substring_count(s): Returns the number of distinct substrings in a string s. substrings = set() n = len(s) for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings) def weakest_security_level(codes): Returns the security level of the weakest code. if not codes: return 0 min_security_level = float('inf') for code in codes: min_security_level = min(min_security_level, distinct_substring_count(code)) return min_security_level"},{"question":"def can_organize_books(T: int, test_cases: List[Tuple[Tuple[int, int, int], List[int]]]) -> List[str]: Determine if it is possible to arrange books into shelves such that no shelf exceeds a given page limit. Args: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[int]]]): List of test cases. Each test case is a tuple where the first element is a tuple containing the number of books (N), maximum number of shelves (K), and maximum number of pages (M). The second element is a list of integers representing the number of pages in each book. Returns: List[str]: A list containing \\"YES\\" or \\"NO\\" for each test case indicating whether it is possible to organize the books under the given constraints. Example: >>> can_organize_books(3, [((5, 3, 10), [1, 2, 3, 4, 5]), ((4, 2, 6), [1, 2, 3, 10]), ((3, 1, 15), [5, 5, 5])]) ['YES', 'NO', 'YES']","solution":"def can_organize_books(T, test_cases): results = [] for i in range(T): N, K, M = test_cases[i][0] pages = test_cases[i][1] if max(pages) > M: results.append(\\"NO\\") continue current_sum = 0 shelves = 1 for page in pages: if current_sum + page > M: shelves += 1 current_sum = page if shelves > K: break else: current_sum += page if shelves <= K: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"import numpy as np def mean_var_std(input_array): Returns the mean, variance, and standard deviation of the elements of the input array. Parameters: input_array (list): A list of numbers. Returns: tuple: A tuple containing mean, variance, and standard deviation. np_array = np.array(input_array) mean_val = np.mean(np_array) var_val = np.var(np_array) std_val = np.std(np_array) return mean_val, var_val, std_val # Unit test example def test_mean_var_std(): input_array = [1, 2, 3, 4, 5, 6, 7, 8, 9] mean_val, var_val, std_val = mean_var_std(input_array) assert mean_val == 5.0 assert var_val == 6.666666666666667 assert std_val == 2.581988897471611 input_array = [4] mean_val, var_val, std_val = mean_var_std([4]) assert mean_val == 4.0 assert var_val == 0.0 assert std_val == 0.0 input_array = [7, 7, 7, 7, 7] mean_val, var_val, std_val = mean_var_std(input_array) assert mean_val == 7.0 assert var_val == 0.0 assert std_val == 0.0","solution":"import numpy as np def mean_var_std(input_array): Returns the mean, variance, and standard deviation of the elements of the input array. Parameters: input_array (list): A list of numbers. Returns: tuple: A tuple containing mean, variance, and standard deviation. np_array = np.array(input_array) mean_val = np.mean(np_array) var_val = np.var(np_array) std_val = np.std(np_array) return mean_val, var_val, std_val # Usage example input_array = [1, 2, 3, 4, 5, 6, 7, 8, 9] mean_val, var_val, std_val = mean_var_std(input_array) print(f\\"{mean_val}n{var_val}n{std_val}\\")"},{"question":"def longest_subsequence_length(N, K, sequence): Returns the length of the longest subsequence where the difference between the maximum and minimum elements doesn't exceed K. Parameters: N (int): length of the sequence K (int): maximum allowed difference between max and min of the subsequence sequence (list): list of integers representing the sequence Returns: int: length of the longest subsequence Example: >>> longest_subsequence_length(5, 3, [1, 5, 2, 9, 3]) 3 >>> longest_subsequence_length(2, 0, [1, 1]) 2","solution":"def longest_subsequence_length(N, K, sequence): Returns the length of the longest subsequence where the difference between the maximum and minimum elements doesn't exceed K. Parameters: N (int): length of the sequence K (int): maximum allowed difference between max and min of the subsequence sequence (list): list of integers representing the sequence Returns: int: length of the longest subsequence sequence.sort() left = 0 max_length = 0 for right in range(N): while sequence[right] - sequence[left] > K: left += 1 max_length = max(max_length, right - left + 1) return max_length"},{"question":"import itertools import math from typing import List, Dict def tsp(locations: List[Dict[str, int]]) -> str: Compute the shortest route that visits each delivery location once and returns to the starting point (warehouse). Args: locations (List[Dict[str, int]]): A list of dictionaries representing the coordinates of the locations. Returns: str: A string indicating the best route and the total distance. >>> locations = [ ... {\\"id\\": 0, \\"x\\": 0, \\"y\\": 0}, ... {\\"id\\": 1, \\"x\\": 2, \\"y\\": 3}, ... {\\"id\\": 2, \\"x\\": 5, \\"y\\": 4}, ... ] >>> tsp(locations) \\"The best route is: 0 -> 1 -> 2 -> 0 with a total distance of D\\" def test_tsp_simple_case(): locations = [ {\\"id\\": 0, \\"x\\": 0, \\"y\\": 0}, {\\"id\\": 1, \\"x\\": 2, \\"y\\": 3}, {\\"id\\": 2, \\"x\\": 5, \\"y\\": 4}, ] result = tsp(locations) assert \\"The best route is: 0 -> \\" in result assert \\" -> 0 with a total distance of \\" in result def test_tsp_two_locations(): locations = [ {\\"id\\": 0, \\"x\\": 0, \\"y\\": 0}, {\\"id\\": 1, \\"x\\": 3, \\"y\\": 4}, ] result = tsp(locations) assert \\"The best route is: 0 -> 1 -> 0 with a total distance of 10.00\\" in result def test_tsp_three_locations(): locations = [ {\\"id\\": 0, \\"x\\": 0, \\"y\\": 0}, {\\"id\\": 1, \\"x\\": 1, \\"y\\": 1}, {\\"id\\": 2, \\"x\\": 1, \\"y\\": 0}, ] result = tsp(locations) assert \\"The best route is: 0 -> 1 -> 2 -> 0 with a total distance of\\" in result or \\"The best route is: 0 -> 2 -> 1 -> 0 with a total distance of\\" in result def test_tsp_all_same_location(): locations = [ {\\"id\\": 0, \\"x\\": 0, \\"y\\": 0}, {\\"id\\": 1, \\"x\\": 0, \\"y\\": 0}, {\\"id\\": 2, \\"x\\": 0, \\"y\\": 0}, ] result = tsp(locations) assert \\"The best route is: 0 -> 1 -> 2 -> 0 with a total distance of 0.00\\" in result or \\"The best route is: 0 -> 2 -> 1 -> 0 with a total distance of 0.00\\" in result","solution":"import itertools import math def calculate_distance(loc1, loc2): Calculate the Euclidean distance between two points represented as dictionaries with 'x' and 'y' coordinates. return math.sqrt((loc1['x'] - loc2['x'])**2 + (loc1['y'] - loc2['y'])**2) def tsp(locations): Solve the Traveling Salesman Problem using brute-force approach. num_locations = len(locations) # Starting location is always the first location in the list start_location = locations[0] # Generate all permutations of location indices (excluding the start location) permutations = itertools.permutations(range(1, num_locations)) min_distance = float('inf') best_route = None # Iterate over all permutations to find the minimum distance for perm in permutations: current_route = [0] + list(perm) + [0] current_distance = 0 # Calculate the total distance for the current permutation for i in range(len(current_route) - 1): loc1 = locations[current_route[i]] loc2 = locations[current_route[i + 1]] current_distance += calculate_distance(loc1, loc2) # Update best route and distance if current route is shorter if current_distance < min_distance: min_distance = current_distance best_route = current_route # Format the output string best_route_string = ' -> '.join(map(str, best_route)) result = f\\"The best route is: {best_route_string} with a total distance of {min_distance:.2f}\\" return result"},{"question":"from typing import List def min_elevation_change(grid: List[List[int]]) -> int: Calculate the minimum total elevation change required to traverse from the top-left corner to the bottom-right corner of the grid. Each cell in the grid has a certain elevation given, and the expedition can only move right or down at each step. Args: grid (List[List[int]]): 2D list representing the elevation grid. Returns: int: The minimum possible total elevation change. Examples: >>> min_elevation_change([[1, 3, 5], [2, 8, 4], [3, 2, 1]]) 4 >>> min_elevation_change([[1, 2], [4, 6]]) 5 def solve(input_string: str) -> int: Parse input string, process the elevation grid, and calculate the minimum elevation change. Args: input_string (str): Input string containing the grid size and elevations. Returns: int: Result of min_elevation_change function based on parsed input. Examples: >>> solve(\\"3 3n1 3 5n2 8 4n3 2 1n\\") 4 >>> solve(\\"2 2n1 2n4 6n\\") 5","solution":"def min_elevation_change(grid): This function computes the minimum possible total elevation change to traverse from the top-left corner to the bottom-right corner of the grid. N = len(grid) M = len(grid[0]) # Create a dp table to store the minimum elevation change for each cell dp = [[float('inf')] * M for _ in range(N)] # Initialize the top-left corner with 0 change since it is the starting point dp[0][0] = 0 # Fill the dp table for i in range(N): for j in range(M): if i == 0 and j == 0: continue from_left = dp[i][j-1] + abs(grid[i][j] - grid[i][j-1]) if j > 0 else float('inf') from_up = dp[i-1][j] + abs(grid[i][j] - grid[i-1][j]) if i > 0 else float('inf') dp[i][j] = min(from_left, from_up) # The minimum elevation change to the bottom-right corner return dp[N-1][M-1] # Function to parse input and execute the solution def solve(input_string): data = input_string.strip().split('n') N, M = map(int, data[0].split()) grid = [list(map(int, row.split())) for row in data[1:]] return min_elevation_change(grid)"},{"question":"def evaluate_expressions(expressions): Evaluates a list of mathematical expressions containing only addition and subtraction. Parameters: expressions (list of str): List of strings, each containing a mathematical expression. Returns: list of int: List of evaluated results for each expression. >>> evaluate_expressions([\\"3+2-1\\"]) [4] >>> evaluate_expressions([\\"3+2-1\\", \\"10-5+4\\", \\"7-3-4\\"]) [4, 9, 0] >>> evaluate_expressions([]) [] >>> evaluate_expressions([\\"1+2+3\\", \\"4+5+6\\", \\"7+8+9\\"]) [6, 15, 24] >>> evaluate_expressions([\\"3-2-1\\", \\"10-5-4\\", \\"7-3-4\\"]) [0, 1, 0] >>> evaluate_expressions([\\"1000-500+200\\", \\"999+1-1000\\"]) [700, 0]","solution":"def evaluate_expressions(expressions): Evaluates a list of mathematical expressions containing only addition and subtraction. Parameters: expressions (list of str): List of strings, each containing a mathematical expression. Returns: list of int: List of evaluated results for each expression. results = [] for expression in expressions: results.append(eval(expression)) return results"},{"question":"def count_valid_configurations(n, m, H): Calculate the number of valid configurations for planting tree saplings in the garden grid. The function should ensure that each cell (i, j) in the grid follows the rule that h(i, j) must be greater than the height of its neighboring saplings to the top and to the left (if they exist). The valid configurations must be returned modulo 1,000,000,007. Args: n (int): number of rows in the garden grid. m (int): number of columns in the garden grid. H (int): minimum possible height of a tree sapling in cell (1,1). Returns: int: The number of valid configurations modulo 1,000,000,007. pass def process_input(t, test_cases): Process the input for multiple test cases and return the results as a list. Args: t (int): The number of test cases. test_cases (List[Tuple[int, int, int]]): A list of tuples, each containing three integers (n, m, H). Returns: List[int]: A list where each element is the result of a test case. >>> process_input(2, [(2, 2, 1), (3, 3, 2)]) [1, 1] >>> process_input(1, [(1, 1, 1)]) [1] pass","solution":"MOD = 1000000007 def count_valid_configurations(n, m, H): # Since the height needs to keep increasing to the right and downward # The unique way to form such configurations is as follows: mat = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): mat[i][j] = H + i + j # The number of valid configurations is determined by the starting minimum height and grid dimensions. # There can be only one unique configuration satisfying the problem's rules. return 1 def process_input(t, test_cases): results = [] for case in test_cases: n, m, H = case results.append(count_valid_configurations(n, m, H) % MOD) return results"},{"question":"def decode_message(encoded_message: List[str]) -> str: Decodes a message represented by a list of digit strings where each digit represents a letter by mapping A=1, B=2, ..., Z=26 and returns the decoded message. Parameters: encoded_message (list of str): A list of strings, where each string is a digit representing a letter. Returns: str: The decoded message. Example: >>> decode_message([\\"8\\", \\"5\\", \\"12\\", \\"12\\", \\"15\\"]) 'HELLO' >>> decode_message([\\"20\\", \\"8\\", \\"5\\", \\"17\\", \\"21\\", \\"9\\", \\"3\\", \\"11\\"]) 'THEQUICK' >>> decode_message([\\"1\\", \\"9\\", \\"13\\"]) 'AIM'","solution":"def decode_message(encoded_message): Decodes a message represented by a list of digit strings where each digit represents a letter by mapping A=1, B=2, ..., Z=26 and returns the decoded message. Parameters: encoded_message (list of str): A list of strings, where each string is a digit representing a letter. Returns: str: The decoded message. return ''.join(chr(int(num) + 64) for num in encoded_message)"},{"question":"from typing import List def count_distinct_pairs(nums: List[int], k: int) -> int: Returns the number of distinct pairs (i, j) where i and j are different indices and nums[i] + nums[j] == k. >>> count_distinct_pairs([1, 2, 3, 4, 3], 6) == 2 >>> count_distinct_pairs([1, 2, 3], 10) == 0 >>> count_distinct_pairs([1, 5, 7], 8) == 1 >>> count_distinct_pairs([1, 3, 2, 2, 3, 4], 5) == 2 >>> count_distinct_pairs([-1, -2, -3, -4, 3], -5) == 2 >>> count_distinct_pairs([1, 2, 3, 2, 3, 4, 4], 6) == 2","solution":"def count_distinct_pairs(nums, k): Returns the number of distinct pairs (i, j) where i and j are different indices and nums[i] + nums[j] == k. seen = set() used = set() count = 0 for num in nums: target = k - num if target in seen and (target, num) not in used: count += 1 used.add((num, target)) used.add((target, num)) seen.add(num) return count"},{"question":"def calculate_active_time(logs): Calculates the total active time for each user based on login and logout timestamps. >>> calculate_active_time([ [1, 0, 10], [2, 0, 12], [1, 1, 20], [3, 0, 15], [2, 1, 25], [3, 1, 30] ]) [(1, 10), (2, 13), (3, 15)] >>> calculate_active_time([ [1, 0, 100], [1, 1, 200], [2, 0, 150], [2, 1, 250] ]) [(1, 100), (2, 100)]","solution":"def calculate_active_time(logs): Calculates the total active time for each user based on login and logout timestamps. from collections import defaultdict # Dictionary to store the last login time for each user last_login = {} # Dictionary to store the total active time for each user total_active_time = defaultdict(int) for log in logs: user_id, action_type, timestamp = log if action_type == 0: # login last_login[user_id] = timestamp elif action_type == 1: # logout if user_id in last_login: total_active_time[user_id] += timestamp - last_login[user_id] del last_login[user_id] # Remove the login record after calculating # Convert the result to the required format and sort it by userID result = sorted(total_active_time.items()) return result"},{"question":"def max_subarray_sum(arr): Function to find the maximum sum of any non-empty contiguous subarray using Kadane's algorithm. pass # Implement the function based on the solution provided above def process_queries(N, Q, array, queries): Function to process the queries and return the result. pass # Implement the function based on the solution provided above def read_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) array = list(map(int, data[2:N+2])) queries = [] index = N+2 for _ in range(Q): l = int(data[index]) r = int(data[index + 1]) queries.append((l, r)) index += 2 return N, Q, array, queries def main(): N, Q, array, queries = read_input() results = process_queries(N, Q, array, queries) for result in results: print(result) if __name__ == '__main__': main() # Test cases def test_max_subarray_sum(): assert max_subarray_sum([1, 2, -1, 2, 3]) == 7 assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 assert max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5]) == 18 assert max_subarray_sum([-1, -2, -3, -4]) == -1 assert max_subarray_sum([2, 3, -2, 4]) == 7 def test_process_queries(): N = 5 Q = 3 array = [1, 2, -1, 2, 3] queries = [(1, 3), (2, 4), (1, 5)] assert process_queries(N, Q, array, queries) == [3, 3, 7] N = 5 Q = 2 array = [-1, -2, -3, -4, -5] queries = [(1, 1), (1, 5)] assert process_queries(N, Q, array, queries) == [-1, -1] # pytest style test function sample def test_solution(monkeypatch): from io import StringIO import sys sample_input = \\"5 3n1 2 -1 2 3n1 3n2 4n1 5n\\" expected_output = \\"3n3n7n\\" monkeypatch.setattr(sys, 'stdin', StringIO(sample_input)) from solution import main from io import StringIO import sys old_stdout = sys.stdout sys.stdout = temp_stdout = StringIO() main() sys.stdout = old_stdout output = temp_stdout.getvalue() assert output == expected_output","solution":"def max_subarray_sum(arr): Function to find the maximum sum of any non-empty contiguous subarray using Kadane's algorithm. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global def process_queries(N, Q, array, queries): results = [] for l, r in queries: subarray = array[l-1:r] max_sum = max_subarray_sum(subarray) results.append(max_sum) return results def read_input(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) Q = int(data[1]) array = list(map(int, data[2:N+2])) queries = [] index = N+2 for _ in range(Q): l = int(data[index]) r = int(data[index + 1]) queries.append((l, r)) index += 2 return N, Q, array, queries def main(): N, Q, array, queries = read_input() results = process_queries(N, Q, array, queries) for result in results: print(result) if __name__ == '__main__': main()"},{"question":"from typing import List from collections import Counter import heapq def can_rearrange_picks(arr: List[int]) -> str: Determines if the array of picks can be rearranged such that no two consecutive picks are from the same pile. >>> can_rearrange_picks([1, 2, 3, 1, 1, 3]) 'YES' >>> can_rearrange_picks([4, 4, 4, 4, 4]) 'NO' >>> can_rearrange_picks([1]) 'YES' >>> can_rearrange_picks([1, 2, 3, 4, 5]) 'YES' >>> can_rearrange_picks([100000] * 100000) 'NO' >>> can_rearrange_picks([i % 10 + 1 for i in range(100000)]) 'YES'","solution":"from collections import Counter import heapq def can_rearrange_picks(arr): Determines if the array of picks can be rearranged such that no two consecutive picks are from the same pile. if not arr: return \\"YES\\" count = Counter(arr) max_heap = [(-value, key) for key, value in count.items()] heapq.heapify(max_heap) prev_value, prev_key = 0, None while max_heap: value, key = heapq.heappop(max_heap) if prev_value < 0: heapq.heappush(max_heap, (prev_value, prev_key)) value += 1 prev_value, prev_key = value, key return \\"YES\\" if prev_value >= 0 else \\"NO\\" # Example usage: # print(can_rearrange_picks([1, 2, 3, 1, 1, 3])) # Expected output: YES # print(can_rearrange_picks([4, 4, 4, 4, 4])) # Expected output: NO"},{"question":"def shiftCharacters(string: str, shift: int) -> str: Shifts every character in the string by a given number of positions in the ASCII table. Parameters: string (str): The input string. shift (int): The number of positions to shift each character. Returns: str: The transformed string after shifting each character. >>> shiftCharacters(\\"abcde\\", 2) 'cdefg' >>> shiftCharacters(\\"hello\\", 0) 'hello' >>> shiftCharacters(chr(255), 1) chr(0) >>> shiftCharacters(\\"xyz\\", 3) '{|}' >>> shiftCharacters(\\"abc\\", 260) 'efg' >>> shiftCharacters(\\"!@#\\", 1) '\\"A'","solution":"def shiftCharacters(string, shift): Shifts every character in the string by a given number of positions in the ASCII table. Parameters: string (str): The input string. shift (int): The number of positions to shift each character. Returns: str: The transformed string after shifting each character. return ''.join(chr((ord(char) + shift) % 256) for char in string)"},{"question":"def longest_book(books, X): Find the longest book Paul can finish in a week with a maximum reading capacity of X pages for each genre. Args: books (dict): A dictionary where the keys are genres and the values are lists of integers representing the number of pages per book for that genre. X (int): The maximum number of pages Paul can read in a week. Returns: dict: A dictionary with the genres as keys and the number of pages of the longest book Paul can read for each genre as values. Examples: >>> books = { ... \\"Fantasy\\": [100, 200, 300, 400], ... \\"Science Fiction\\": [150, 350, 600], ... \\"Mystery\\": [120, 220, 330, 440] ... } >>> X = 250 >>> longest_book(books, X) {'Fantasy': 200, 'Science Fiction': 150, 'Mystery': 220} >>> books = { ... \\"Fantasy\\": [300, 400], ... \\"Non Fiction\\": [400, 500] ... } >>> X = 250 >>> longest_book(books, X) {'Fantasy': 0, 'Non Fiction': 0}","solution":"def longest_book(books, X): result = {} for genre, pages in books.items(): max_pages = 0 for page in pages: if page <= X: max_pages = page else: break result[genre] = max_pages return result"},{"question":"from typing import List def subsets_with_target(arr: List[int], x: int) -> List[List[int]]: Given an integer array arr of unique elements, find all possible subsets (the power set) of the array that contain a specific target integer x. Return the subsets in any order. >>> subsets_with_target([1,2,3], 2) [[2], [1, 2], [2, 3], [1, 2, 3]] >>> subsets_with_target([5,6,7,8], 5) [[5], [5, 6], [5, 7], [5, 8], [5, 6, 7], [5, 6, 8], [5, 7, 8], [5, 6, 7, 8]]","solution":"from itertools import combinations def subsets_with_target(arr, x): Finds all subsets of arr that contain the target x. Parameters: arr (list): The list of unique integers. x (int): The target integer. Returns: list: A list of all subsets containing x. result = [] n = len(arr) for i in range(1, n + 1): for subset in combinations(arr, i): if x in subset: result.append(list(subset)) return result"},{"question":"def min_cut_edge_width(n: int, m: int, edges_list: List[Tuple[int, int, int]]) -> int: Find the minimum width of a cutting edge that, if removed, would maximize the connectivity capacity between every pair of cities. Parameters: n (int): Number of cities m (int): Number of roads edges_list (List[Tuple[int, int, int]]): List of tuples (u, v, w), representing a road between cities u and v with width w Returns: int: The minimum width of a cutting edge Example: >>> min_cut_edge_width(5, 6, [(1, 2, 4), (1, 3, 2), (2, 3, 1), (2, 4, 3), (3, 5, 5), (4, 5, 6)]) 3 >>> min_cut_edge_width(2, 1, [(1, 2, 10)]) 10 >>> min_cut_edge_width(3, 3, [(1, 2, 5), (2, 3, 5), (1, 3, 5)]) 5 >>> min_cut_edge_width(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 2","solution":"def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] parent = [] rank = [] edges = sorted(edges, key=lambda item: item[2], reverse=True) for node in range(n): parent.append(node) rank.append(0) e, i = 0, 0 while e < n - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) min_width_cut = result[-1][2] return min_width_cut def min_cut_edge_width(n, m, edges_list): edges = [(u-1, v-1, w) for u, v, w in edges_list] return kruskal(n, edges)"},{"question":"def findXthNumber(X: int) -> int: Returns the X'th number in the series defined by the pattern n(n + 1)(n + 2)/6. >>> findXthNumber(3) # 10 >>> findXthNumber(5) # 35","solution":"def findXthNumber(X): Returns the X'th number in the series defined by the pattern n(n + 1)(n + 2)/6. return X * (X + 1) * (X + 2) // 6"},{"question":"def find_peak_element(arr: List[int]) -> int: Returns the index of any one peak element in the array. >>> find_peak_element([1, 3, 20, 4, 1]) in [2, 3] True >>> find_peak_element([10]) == 0 True","solution":"def find_peak_element(arr): Returns the index of any one peak element in the array. n = len(arr) if n == 1: return 0 if arr[0] >= arr[1]: return 0 if arr[n-1] >= arr[n-2]: return n-1 for i in range(1, n-1): if arr[i] >= arr[i-1] and arr[i] >= arr[i+1]: return i"},{"question":"def determine_winner(s: str) -> str: Determines the winner between Alice and Bob based on the given string s. Both Alice and Bob play optimally. A move consists of selecting one occurrence of 'a' and one occurrence of 'b', and removing them both from the string. The game ends when there are no more valid moves to be made. The player who cannot make a move loses the game. >>> determine_winner('ab') 'Alice' >>> determine_winner('aababb') 'Bob' >>> determine_winner('aaaa') 'Bob'","solution":"def determine_winner(s): Determines the winner between Alice and Bob based on the given string s. count_a = s.count('a') count_b = s.count('b') # The number of pairs we can remove is the minimum of count of 'a' and 'b' moves = min(count_a, count_b) # If moves are odd, Alice wins (since she starts first), otherwise Bob wins if moves % 2 == 1: return \\"Alice\\" else: return \\"Bob\\""},{"question":"def flattenList(nestedList): Write a function flattenList(nestedList) that takes a list containing nested lists of integers and returns a single flattened list of integers. All levels of nesting should be flattened out so that the resulting list contains no nested lists. Example 1: >>> flattenList([1, [2, 3], [4, [5, 6]], 7]) [1, 2, 3, 4, 5, 6, 7] Example 2: >>> flattenList([[1, 2, [3]], 4, [5, [6, [7, 8]]]]) [1, 2, 3, 4, 5, 6, 7, 8] from solution import flattenList def test_flatten_simple_nested_list(): assert flattenList([1, [2, 3], [4, [5, 6]], 7]) == [1, 2, 3, 4, 5, 6, 7] def test_flatten_deeply_nested_list(): assert flattenList([[1, 2, [3]], 4, [5, [6, [7, 8]]]]) == [1, 2, 3, 4, 5, 6, 7, 8] def test_flatten_with_empty_lists(): assert flattenList([1, [], [2, [], 3], [], 4]) == [1, 2, 3, 4] def test_flatten_all_single_elements(): assert flattenList([[1], [2], [3, [4]], [[5]]]) == [1, 2, 3, 4, 5] def test_flatten_already_flat_list(): assert flattenList([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_flatten_single_nested_empty_list(): assert flattenList([[]]) == [] def test_flatten_mixed_types(): assert flattenList([1, 'string', [2, 3], [4, [5, {'key': 'value'}]], 6]) == [1, 'string', 2, 3, 4, 5, {'key': 'value'}, 6]","solution":"def flattenList(nestedList): Flattens a list containing nested lists of integers into a single list of integers. :param nestedList: list containing nested lists of integers :return: flattened list of integers flattened = [] def flatten(sublist): for element in sublist: if isinstance(element, list): flatten(element) else: flattened.append(element) flatten(nestedList) return flattened"},{"question":"from typing import List def product_except_self(arr: List[int]) -> List[int]: Create a function that takes an integer array as input and returns a new array where each element at index i is the product of all the elements in the original array except the one at index i. >>> product_except_self([1, 2, 3, 4]) [24, 12, 8, 6] >>> product_except_self([-1, 1, 0, -3, 3]) [0, 0, 9, 0, 0]","solution":"def product_except_self(arr): n = len(arr) result = [1] * n left_product = 1 right_product = 1 # Calculate left products for i in range(n): result[i] *= left_product left_product *= arr[i] # Calculate right products for i in range(n-1, -1, -1): result[i] *= right_product right_product *= arr[i] return result"},{"question":"def maxBarrelCapacity(n: int, k: int, capacities: List[int]) -> int: Returns the maximum possible sum of the capacities of 'k' barrels. >>> maxBarrelCapacity(5, 3, [1, 2, 4, 8, 9]) 21 >>> maxBarrelCapacity(5, 2, [3, 1, 2, 5, 6]) 11 >>> maxBarrelCapacity(2, 1, [1, 2]) 2 >>> maxBarrelCapacity(4, 2, [5, 5, 5, 5]) 10 >>> maxBarrelCapacity(5, 5, [10, 20, 30, 40, 50]) 150 >>> maxBarrelCapacity(6, 3, [3, 1, 4, 1, 5, 9]) 18 >>> maxBarrelCapacity(5, 3, [10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3, 10**9 - 4]) 2999999997","solution":"def maxBarrelCapacity(n, k, capacities): Returns the maximum possible sum of the capacities of 'k' barrels. # Sort the capacities in descending order capacities.sort(reverse=True) # Sum the top k capacities max_capacity = sum(capacities[:k]) return max_capacity # Example usage # n = 5, k = 3, capacities = [1, 2, 4, 8, 9] # The maximum possible sum is 21 print(maxBarrelCapacity(5, 3, [1, 2, 4, 8, 9])) # Output: 21"},{"question":"from typing import List def trap_rain_water(heights: List[int]) -> int: Given a list of integers representing the height of water containers, calculates the total amount of trapped water. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([3, 3, 3, 3, 3]) 0 >>> trap_rain_water([2, 0, 2]) 2 >>> trap_rain_water([]) 0 >>> trap_rain_water([2]) 0 >>> trap_rain_water([1, 2, 3, 4, 5]) 0 >>> trap_rain_water([5, 4, 3, 2, 1]) 0 >>> trap_rain_water([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def trap_rain_water(heights: List[int]) -> int: Given a list of integers representing the height of water containers, calculates the total amount of trapped water. if not heights or len(heights) < 3: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped"},{"question":"def min_boxes_required(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the minimum number of boxes required to ensure that each person gets at least one healing fruit. Parameters: T (int): Number of test cases. test_cases (List[Tuple[int, str]]): Each tuple contains an integer P (the number of people) and a string S where 'H' represents a healing fruit and 'E' represents an energy fruit. Returns: List[int]: The minimum number of boxes required for each test case. Examples: >>> min_boxes_required(1, [(3, 'HEHEH')]) [3] >>> min_boxes_required(1, [(2, 'EHEEEHHE')]) [2]","solution":"def min_boxes_required(T, test_cases): results = [] for P, S in test_cases: count = 0 for char in S: if char == 'H': count += 1 if count >= P: results.append(count) break return results"},{"question":"from typing import List def palindromic_permutation_counts(test_cases: List[str]) -> List[int]: Find the number of distinct permutations of the string that form a palindrome for each test case. Args: test_cases: A list of strings consisting of lowercase alphabets. Returns: A list of integers where each integer is the number of distinct palindromic permutations of the corresponding string. Examples: >>> palindromic_permutation_counts([\\"aabb\\"]) [2] >>> palindromic_permutation_counts([\\"abc\\"]) [0] >>> palindromic_permutation_counts([\\"aabb\\", \\"abc\\", \\"aab\\"]) [2, 0, 1]","solution":"from collections import Counter from math import factorial def count_palindromic_permutations(s): count = Counter(s) odd_count = sum(1 for c in count.values() if c % 2 != 0) if odd_count > 1: return 0 half_palindrome_length = sum(c // 2 for c in count.values()) numerator = factorial(half_palindrome_length) denominator = 1 for c in count.values(): denominator *= factorial(c // 2) return numerator // denominator def palindromic_permutation_counts(test_cases): results = [] for s in test_cases: results.append(count_palindromic_permutations(s)) return results"},{"question":"class LRUCache: Design a Cache system that follows the Least Recently Used (LRU) policy without using any built-in libraries. A Cache is a data structure that stores a subset of elements from a larger data set, so future requests for those elements are served faster. The LRU policy discards the least recently used items first. Under LRU, when the cache reaches its limit, it removes the least recently accessed element. To be specific, your design should include these functions: - int get(int key): Return the value of the key if the key exists in the cache, otherwise return -1. - void put(int key, int value): Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, remove the least recently used key. def __init__(self, capacity: int): Initialize the LRU cache with a positive size capacity. pass def get(self, key: int) -> int: Returns the value of the key if the key exists, otherwise returns -1. pass def put(self, key: int, value: int) -> None: Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity, remove the least recently used key. pass from solution import LRUCache def test_lru_cache(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) assert cache.get(1) == 1 # returns 1 cache.put(3, 3) # evicts key 2 assert cache.get(2) == -1 # returns -1 (not found) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(3) == 3 # returns 3 assert cache.get(4) == 4 # returns 4 def test_lru_cache_update(): cache = LRUCache(2) cache.put(1, 1) cache.put(2, 2) cache.put(1, 10) # Update the value of key 1 assert cache.get(1) == 10 def test_lru_cache_expansion(): cache = LRUCache(3) cache.put(1, 1) cache.put(2, 2) cache.put(3, 3) cache.put(4, 4) # evicts key 1 assert cache.get(1) == -1 # returns -1 (not found) assert cache.get(2) == 2 assert cache.get(3) == 3 assert cache.get(4) == 4 def test_lru_cache_access_update(): cache = LRUCache(2) cache.put(2, 1) cache.put(2, 2) # Update value of key 2 assert cache.get(2) == 2 cache.put(1, 1) cache.put(4, 1) # evicts key 2 assert cache.get(2) == -1 assert cache.get(1) == 1 assert cache.get(4) == 1","solution":"class LRUCache: def __init__(self, capacity: int): self.capacity = capacity self.cache = {} self.lru = [] def get(self, key: int) -> int: if key in self.cache: self.lru.remove(key) self.lru.append(key) return self.cache[key] else: return -1 def put(self, key: int, value: int) -> None: if key in self.cache: self.lru.remove(key) elif len(self.cache) >= self.capacity: oldest_key = self.lru.pop(0) del self.cache[oldest_key] self.cache[key] = value self.lru.append(key)"},{"question":"def can_arrange_seating(n: int, pairs: List[Tuple[int, int]]) -> str: Determine if a valid seating arrangement is possible in a town where each person likes at most one other person and can be liked by multiple people. Input: n: An integer representing the number of people in the town. pairs: A list of tuples where each tuple (a, b) indicates that person a likes person b. Output: \\"YES\\" if a valid seating arrangement around a round table is possible; otherwise, \\"NO\\". >>> can_arrange_seating(4, [(1, 2), (3, 4), (2, 3), (4, 1)]) 'YES' >>> can_arrange_seating(3, [(1, 2), (2, 3), (1, 3)]) 'NO' pass","solution":"def can_arrange_seating(n, pairs): from collections import defaultdict if n % 2 != 0: # It is impossible to form pairs if n is odd. return \\"NO\\" adjacency_list = defaultdict(list) for a, b in pairs: adjacency_list[a].append(b) adjacency_list[b].append(a) # Function to check if the graph can be partitioned into disjoint cycles def is_bipartite(graph, n): color = [-1] * (n + 1) def dfs(source, current_color): stack = [(source, current_color)] while stack: node, color_value = stack.pop() if color[node] == -1: color[node] = color_value elif color[node] != color_value: return False for neighbor in graph[node]: if color[neighbor] == -1: stack.append((neighbor, 1 - color_value)) elif color[neighbor] == color_value: return False return True for i in range(1, n + 1): if color[i] == -1: if not dfs(i, 0): return False return True for k, v in adjacency_list.items(): if len(v) != 2: # Each person must like exactly two other persons. return \\"NO\\" return \\"YES\\" if is_bipartite(adjacency_list, n) else \\"NO\\""},{"question":"def minimize_makespan(tasks, m): Returns the minimum possible makespan when tasks are optimally assigned to m processors. >>> minimize_makespan([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 5) 15 >>> minimize_makespan([5], 1) 5 >>> minimize_makespan([5], 2) 5 >>> minimize_makespan([4, 4, 4, 4], 4) 4 >>> minimize_makespan([4, 4, 4, 4], 2) 8 >>> minimize_makespan([3, 1, 2], 5) 3 >>> minimize_makespan([7, 2, 5], 3) 7 >>> minimize_makespan([100, 200, 300, 400], 2) 600 >>> minimize_makespan([100, 200, 300, 400], 3) 400 >>> minimize_makespan([], 3) 0 >>> minimize_makespan([1]*100, 50) 2","solution":"def minimize_makespan(tasks, m): Returns the minimum possible makespan when tasks are optimally assigned to m processors. def can_complete_in_time(mid, tasks, m): required_processors = 1 current_time = 0 for task in tasks: if current_time + task > mid: required_processors += 1 current_time = task if required_processors > m: return False else: current_time += task return True if not tasks or m <= 0: return 0 tasks.sort(reverse=True) left, right = max(tasks), sum(tasks) while left < right: mid = (left + right) // 2 if can_complete_in_time(mid, tasks, m): right = mid else: left = mid + 1 return left"},{"question":"def count_unique_zero_sum_pairs(nums: List[int]) -> int: Count the number of unique pairs (i, j) such that nums[i] + nums[j] equals zero. >>> count_unique_zero_sum_pairs([1, -1, 2, -2, 3, -3]) 3 >>> count_unique_zero_sum_pairs([-5, 5, 5]) 1 >>> count_unique_zero_sum_pairs([0, 1, 2, 3]) 0","solution":"def count_unique_zero_sum_pairs(nums): Count the number of unique pairs (i, j) such that nums[i] + nums[j] equals zero. count = 0 seen = set() pairs = set() for num in nums: if -num in seen: pair = tuple(sorted((num, -num))) if pair not in pairs: pairs.add(pair) count += 1 seen.add(num) return count"},{"question":"from typing import List, Tuple def can_sum_to_k(n: int, k: int, scores: List[int]) -> str: Determine if there is a subset of \`scores\` whose sum is exactly \`k\` >>> can_sum_to_k(3, 6, [1, 2, 3]) == \\"YES\\" >>> can_sum_to_k(5, 11, [1, 2, 3, 4, 5]) == \\"YES\\" >>> can_sum_to_k(4, 9, [5, 2, 7, 1]) == \\"YES\\" >>> can_sum_to_k(3, 10, [1, 2, 3]) == \\"NO\\" >>> can_sum_to_k(5, 0, [1, 2, 3, 4, 5]) == \\"YES\\" >>> can_sum_to_k(3, 10000, [100, 200, 300]) == \\"NO\\" def subset_sums(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: For each test case, determine if there is a subset of scores whose sum is exactly \`k\` >>> test_cases = [(3, 6, [1, 2, 3]), (5, 11, [1, 2, 3, 4, 5]), (4, 9, [5, 2, 7, 1])] >>> subset_sums(test_cases) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_sum_to_k(n, k, scores): Determine if there is a subset of \`scores\` whose sum is exactly \`k\` :param n: number of scores :param k: target sum :param scores: list of integers representing the scores :return: \\"YES\\" if a subset with sum \`k\` exists, otherwise \\"NO\\" # Using dynamic programming to solve the subset sum problem dp = [False] * (k + 1) dp[0] = True # Base case: a subset with sum 0 is always possible for score in scores: for i in range(k, score - 1, -1): if dp[i - score]: dp[i] = True return \\"YES\\" if dp[k] else \\"NO\\" def subset_sums(test_cases): results = [] for n, k, scores in test_cases: result = can_sum_to_k(n, k, scores) results.append(result) return results"},{"question":"def min_moves_to_reach_end(N: int, M: int, grid: List[List[int]]) -> int: Determine the minimum number of moves required to get from the start (0,0) to the destination (N-1,M-1). If there is no possible path, return -1. >>> min_moves_to_reach_end(5, 5, [ ... [0, 0, 0, 0, 1], ... [1, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0] ... ]) 8 >>> min_moves_to_reach_end(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 1, 0] ... ]) -1 >>> min_moves_to_reach_end(2, 2, [ ... [0, 0], ... [0, 0] ... ]) 2 >>> min_moves_to_reach_end(1, 1, [ ... [0] ... ]) 0 >>> min_moves_to_reach_end(3, 3, [ ... [0, 1, 1], ... [1, 1, 1], ... [1, 1, 0] ... ]) -1","solution":"def min_moves_to_reach_end(N, M, grid): from collections import deque # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (x, y, distance) visited = set((0, 0)) while queue: x, y, dist = queue.popleft() # If we've reached the bottom-right corner, return the distance if (x, y) == (N-1, M-1): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) # If we exhaust the queue without finding the end, return -1 return -1 # Example usage # N, M = 5, 5 # grid = [ # [0, 0, 0, 0, 1], # [1, 1, 0, 0, 0], # [0, 1, 0, 1, 0], # [0, 0, 0, 1, 0], # [1, 1, 0, 0, 0] # ] # print(min_moves_to_reach_end(N, M, grid)) # Output: 8"},{"question":"def zigzag_sum(arr): Given an array of integers, calculate its zigzag sum as the sum of elements at odd indices minus the sum of elements at even indices. Parameters: arr (list): A list of at least 3 integers. Returns: int: The zigzag sum. >>> zigzag_sum([1, 2, 3, 4, 5]) == -3 >>> zigzag_sum([-10, 20, -30, 40, -50]) == 150 >>> zigzag_sum([5, 5, 5, 5, 5, 5, 5, 5, 5]) == -5 >>> zigzag_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) == 5 >>> zigzag_sum([0, 0, 0, 0, 0, 0, 0, 0, 0, 0]) == 0","solution":"def zigzag_sum(arr): Calculate the zigzag sum: sum of elements at odd indices - sum of elements at even indices. Parameters: arr (list): A list of integers. Returns: int: The zigzag sum. odd_sum = sum(arr[i] for i in range(1, len(arr), 2)) even_sum = sum(arr[i] for i in range(0, len(arr), 2)) return odd_sum - even_sum"},{"question":"def can_make_pancakes(P: int, Q: int, R: int, S: int, p: int, q: int, r: int, s: int) -> str: Determine if Amber can make at least one batch of pancakes. Parameters: P (int): available grams of flour Q (int): available eggs R (int): available milliliters of milk S (int): available grams of butter p (int): required grams of flour per batch q (int): required eggs per batch r (int): required milliliters of milk per batch s (int): required grams of butter per batch Returns: str: \\"Yes\\" if enough ingredients, otherwise \\"No\\" followed by the lacking ingredients >>> can_make_pancakes(500, 5, 200, 50, 200, 2, 150, 40) 'Yes' >>> can_make_pancakes(300, 3, 100, 20, 200, 2, 150, 40) 'No -milk -butter' >>> can_make_pancakes(500, 1, 300, 50, 200, 2, 100, 40) 'No -eggs' >>> can_make_pancakes(100, 5, 300, 50, 200, 2, 100, 40) 'No -flour' >>> can_make_pancakes(200, 2, 150, 40, 200, 2, 150, 40) 'Yes'","solution":"def can_make_pancakes(P, Q, R, S, p, q, r, s): Determine if Amber can make at least one batch of pancakes. Parameters: P (int): available grams of flour Q (int): available eggs R (int): available milliliters of milk S (int): available grams of butter p (int): required grams of flour per batch q (int): required eggs per batch r (int): required milliliters of milk per batch s (int): required grams of butter per batch Returns: str: \\"Yes\\" if enough ingredients, otherwise \\"No\\" followed by the lacking ingredients lacking_ingredients = [] if P < p: lacking_ingredients.append(\\"-flour\\") if Q < q: lacking_ingredients.append(\\"-eggs\\") if R < r: lacking_ingredients.append(\\"-milk\\") if S < s: lacking_ingredients.append(\\"-butter\\") if not lacking_ingredients: return \\"Yes\\" else: return \\"No \\" + \\" \\".join(lacking_ingredients)"},{"question":"def count_fertile_regions(grid, N, M): Determine the number of connected fertile regions in the farm. A fertile region is a group of one or more connected fertile cells. >>> count_fertile_regions([['.', '.', '.', '.', '.'], ['.', '#', '#', '#', '.'], ['.', '.', '#', '.', '.'], ['.', '.', '.', '.', '.']], 4, 5) 1 >>> count_fertile_regions([['#', '#', '#'], ['#', '.', '#'], ['#', '#', '#']], 3, 3) 0 def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): N = int(data[idx]) M = int(data[idx + 1]) idx += 2 grid = [] for i in range(N): grid.append(list(data[idx])) idx += 1 results.append(count_fertile_regions(grid, N, M)) for result in results: print(result) if __name__ == \\"__main__\\": main()","solution":"def count_fertile_regions(grid, N, M): def dfs(x, y): stack = [(x, y)] while stack: cx, cy = stack.pop() for nx, ny in [(cx-1, cy), (cx+1, cy), (cx, cy-1), (cx, cy+1)]: if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] == '.': grid[nx][ny] = '#' # Mark as visited stack.append((nx, ny)) count = 0 for i in range(N): for j in range(M): if grid[i][j] == '.': dfs(i, j) count += 1 return count def main(): import sys input = sys.stdin.read data = input().split() idx = 0 T = int(data[idx]) idx += 1 results = [] for _ in range(T): N = int(data[idx]) M = int(data[idx + 1]) idx += 2 grid = [] for i in range(N): grid.append(list(data[idx])) idx += 1 results.append(count_fertile_regions(grid, N, M)) for result in results: print(result) if __name__ == \\"__main__\\": main()"},{"question":"def find_number_of_peers(N: int, managers: List[int]) -> List[int]: Determines for each employee the number of peers they have based on the hierarchical structure. >>> find_number_of_peers(6, [1, 1, 2, 2, 3]) [0, 1, 1, 1, 1, 0] >>> find_number_of_peers(1, []) [0] >>> find_number_of_peers(2, [1]) [0, 0] >>> find_number_of_peers(5, [1, 1, 1, 1]) [0, 3, 3, 3, 3] >>> find_number_of_peers(4, [1, 2, 3]) [0, 0, 0, 0] >>> find_number_of_peers(7, [1, 1, 1, 1, 1, 1]) [0, 5, 5, 5, 5, 5, 5]","solution":"def find_number_of_peers(N, managers): from collections import defaultdict # Create a dictionary to store the subordinates of each manager subordinate_dict = defaultdict(list) # Populate the subordinate dictionary for emp_id, manager_id in enumerate(managers, start=2): subordinate_dict[manager_id].append(emp_id+1) # Create the result list result = [] # Calculate the number of peers for each employee for i in range(1, N + 1): if i == 1: result.append(0) # CEO has no peers else: manager = managers[i-2] result.append(len(subordinate_dict[manager]) - 1) return result"},{"question":"class ArrayManipulator: def __init__(self, arr): Initialize the array manipulator with an array. pass def add(self, l, r, value): Add a certain value to all elements in the subarray from index l to r (both inclusive). pass def sum(self, l, r): Compute the sum of all elements in the subarray from index l to r (both inclusive). pass # Unit tests def test_single_add_and_sum(): arr = [1, 2, 3, 4, 5, 6] am = ArrayManipulator(arr) am.add(2, 4, 10) assert am.sum(1, 3) == 1 + 12 + 13 def test_multiple_add_and_sum(): arr = [1, 2, 3, 4, 5, 6] am = ArrayManipulator(arr) am.add(2, 4, 10) assert am.sum(1, 3) == 1 + 12 + 13 am.add(1, 6, -2) assert am.sum(1, 6) == -1 + 10 + 11 + 12 + 3 + 4 def test_no_add_sum(): arr = [1, 2, 3, 4, 5, 6] am = ArrayManipulator(arr) assert am.sum(1, 6) == 1 + 2 + 3 + 4 + 5 + 6 def test_edge_cases(): arr = [0] * 100000 am = ArrayManipulator(arr) # Adding 1 to all elements am.add(1, 100000, 1) assert am.sum(1, 100000) == 100000","solution":"class ArrayManipulator: def __init__(self, arr): self.n = len(arr) self.arr = arr self.lazy = [0] * (self.n + 1) def add(self, l, r, value): self.lazy[l-1] += value if r < self.n: self.lazy[r] -= value def sum(self, l, r): current_addition = 0 result = 0 for i in range(l-1, r): current_addition += self.lazy[i] result += self.arr[i] + current_addition return result"},{"question":"def subarraySum(nums, start, end): Return the sum of the elements in the subarray defined by start and end indices. Parameters: nums (list of int): The array of integers. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: int: The sum of the elements in the subarray from start to end (inclusive). Examples: >>> subarraySum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 2, 5) 18 >>> subarraySum([10, -3, 7, 4, -2, 1, 5, -6], 1, 3) 8 >>> subarraySum([5, 8, -2, 10], 2, 2) -2 >>> subarraySum([1, 1, 1, 1, 1], 0, 4) 5 >>> subarraySum([0, 1, 2, 3, 4, 5, 6], 3, 6) 18 >>> subarraySum([10, 20, 30, 40, 50], 0, 2) 60 >>> subarraySum([1, -1, 2, -2, 3, -3, 4, -4], 0, 7) 0 >>> subarraySum([0, 0, 0, 0, 0, 0, 0], 1, 5) 0 >>> subarraySum([1000, 2000, -3000, 4000, 5000], 1, 4) 8000","solution":"def subarraySum(nums, start, end): Return the sum of the elements in the subarray defined by start and end indices. Parameters: nums (list of int): The array of integers. start (int): The starting index of the subarray. end (int): The ending index of the subarray. Returns: int: The sum of the elements in the subarray from start to end (inclusive). return sum(nums[start:end + 1])"},{"question":"def max_treasure_value(n: int, m: int, v: List[int]) -> int: Returns the maximum total value of treasures that can be placed in any single segment. Args: n (int): Number of chests. m (int): Number of segments. v (list): List of integers representing the value of treasures in the chests. Returns: int: The maximum value of any single treasure chest. Examples: >>> max_treasure_value(3, 5, [4, 7, 2]) 7 >>> max_treasure_value(4, 3, [10, 5, 6, 3]) 10 >>> max_treasure_value(6, 6, [1, 10, 3, 8, 6, 2]) 10 >>> max_treasure_value(1, 1, [1]) 1 >>> max_treasure_value(5, 3, [5, 5, 5, 5, 5]) 5 >>> max_treasure_value(3, 100000, [1, 999, 500]) 999","solution":"def max_treasure_value(n, m, v): Returns the maximum total value of treasures that can be placed in any single segment. Args: n (int): Number of chests. m (int): Number of segments. v (list): List of integers representing the value of treasures in the chests. Returns: int: The maximum value of any single treasure chest. return max(v)"},{"question":"def isOverlap(rect1, rect2): Determine if two rectangles overlap. Each rectangle is defined by its bottom-left (x1, y1) and top-right (x2, y2) coordinates. rect1 and rect2 are lists where: rect1 = [x1, y1, x2, y2] rect2 = [x1, y1, x2, y2] Returns True if the rectangles overlap, False otherwise. Examples: >>> isOverlap([0, 0, 2, 2], [1, 1, 3, 3]) True >>> isOverlap([0, 0, 1, 1], [1, 1, 2, 2]) False","solution":"def isOverlap(rect1, rect2): Determine if two rectangles overlap. Each rectangle is defined by its bottom-left (x1, y1) and top-right (x2, y2) coordinates. rect1 and rect2 are lists where: rect1 = [x1, y1, x2, y2] rect2 = [x1, y1, x2, y2] if rect1[2] <= rect2[0] or rect2[2] <= rect1[0] or rect1[3] <= rect2[1] or rect2[3] <= rect1[1]: return False return True"},{"question":"def schedule_robots(N, M, preferences): Designs a scheduling system for a cluster of robotic vehicles traveling between various charging stations to ensure that no two robots travel to the same station at the same time. Args: N (int): Number of robots. M (int): Number of charging stations. preferences (List[List[int]]): Robot's preferred charging stations. Returns: List[int]: Time slots assigned to each robot. Example: >>> schedule_robots(3, 5, [[0, 1], [1, 2, 3], [3, 4]]) [1, 2, 3] >>> schedule_robots(1, 2, [[0, 1]]) [1]","solution":"def schedule_robots(N, M, preferences): # Create an array to store the time slot assignment for each robot slots = [-1] * N # Create a dictionary to store the assigned slots for each station station_schedule = {i: [] for i in range(M)} for i in range(N): assigned = False for station in preferences[i]: potential_slot = len(station_schedule[station]) + 1 conflicting_robot = next((r for r in station_schedule[station] if slots[r] == potential_slot), None) if conflicting_robot is None: slots[i] = potential_slot station_schedule[station].append(i) assigned = True break if not assigned: # Additional logic if no valid slot found (minimum slots approach can be made better) slot = 1 while slot in (slots[r] for r in station_schedule[preferences[i][0]]): slot += 1 slots[i] = slot station_schedule[preferences[i][0]].append(i) return slots"},{"question":"def smallest_lexicographical_string(S: str, K: int) -> str: Rahul loves to play with strings. One day, while experimenting, he defined an operation as follows: Choose any character from the string S and move it to the end of the string. Rahul wants to know the lexicographically smallest string he can obtain by performing the operation at most K times on the given string S. Can you help him achieve his goal? >>> smallest_lexicographical_string('abz', 1) 'abz' >>> smallest_lexicographical_string('cba', 1) 'acb' >>> smallest_lexicographical_string('dbca', 2) 'bacd' >>> smallest_lexicographical_string('xyzabc', 1) 'abcxyz' >>> smallest_lexicographical_string('xyzabc', 3) 'abcxyz' >>> smallest_lexicographical_string('zyx', 2) 'xyz'","solution":"def smallest_lexicographical_string(S, K): if K == 1: # generate all possible rotations and return the smallest one min_string = S for i in range(len(S)): rotated = S[i:] + S[:i] if rotated < min_string: min_string = rotated return min_string else: # if K > 1 then we can sort the string to get the smallest possible string return ''.join(sorted(S))"},{"question":"def modify_array(n, a, condition): Modify array \`a\` such that any two adjacent elements have either the same or differing parity based on the given condition. :param n: Number of elements in array \`a\` :param a: List of integers representing original array :param condition: List of integers representing conditions between adjacent elements :return: List of integers representing the modified array \`b\` Examples: >>> modify_array(5, [1, 2, 3, 4, 5], [1, 0, 1, 0]) [1, 3, 4, 6, 7] >>> modify_array(4, [2, 4, 6, 8], [0, 0, 0]) [2, 3, 4, 5] def test_modify_array_basic(): n = 5 a = [1, 2, 3, 4, 5] condition = [1, 0, 1, 0] assert modify_array(n, a, condition) == [1, 3, 4, 6, 7] def test_modify_array_all_odd_conditions(): n = 4 a = [1, 2, 3, 4] condition = [1, 1, 1] assert modify_array(n, a, condition) == [1, 3, 5, 7] def test_modify_array_all_even_conditions(): n = 4 a = [2, 4, 6, 8] condition = [0, 0, 0] assert modify_array(n, a, condition) == [2, 3, 4, 5] def test_modify_array_mixed_parity_conditions(): n = 5 a = [3, 6, 9, 12, 15] condition = [0, 1, 0, 1] assert modify_array(n, a, condition) == [3, 4, 6, 7, 9] def test_modify_array_large_values(): n = 6 a = [1000000000, 999999999, 999999998, 999999997, 999999996, 999999995] condition = [0, 1, 0, 1, 0] assert modify_array(n, a, condition) == [1000000000, 1000000001, 1000000003, 1000000004, 1000000006, 1000000007]","solution":"def modify_array(n, a, condition): Modify array \`a\` to meet the given conditions. :param n: Number of elements in array \`a\` :param a: List of integers representing original array :param condition: List of integers representing conditions between adjacent elements :return: List of integers representing the modified array \`b\` b = [0] * n b[0] = a[0] for i in range(1, n): if condition[i-1] == 1: if b[i-1] % 2 == 0: b[i] = b[i-1] + 2 else: b[i] = b[i-1] + 2 else: if b[i-1] % 2 == 0: b[i] = b[i-1] + 1 else: b[i] = b[i-1] + 1 return b"},{"question":"class LibrarySystem: def __init__(self): self.books = {} self.users = {} self.borrowed_books = {} def add_book(self, book_id, title, author): Add a new book to the inventory. Args: book_id (int): Unique identifier for the book. title (str): Title of the book. author (str): Author of the book. pass def add_user(self, user_id, name): Add a new user to the system. Args: user_id (int): Unique identifier for the user. name (str): Name of the user. pass def borrow(self, book_id, user_id): Borrow a book for a user if it is available. Args: book_id (int): Unique identifier for the book. user_id (int): Unique identifier for the user. pass def return_book(self, book_id, user_id): Return a book that was borrowed by a user. Args: book_id (int): Unique identifier for the book. user_id (int): Unique identifier for the user. pass def status(self, book_id): Check the status of a book whether it is available or borrowed. Args: book_id (int): Unique identifier for the book. Returns: str: \\"Available\\" if the book is available, otherwise \\"Borrowed by user_id\\". pass import pytest def test_add_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\", \\"George Orwell\\") assert lib.books[1] == (\\"1984\\", \\"George Orwell\\") def test_add_user(): lib = LibrarySystem() lib.add_user(1, \\"Alice\\") assert lib.users[1] == \\"Alice\\" def test_borrow_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\", \\"George Orwell\\") lib.add_user(1, \\"Alice\\") lib.borrow(1, 1) assert lib.status(1) == \\"Borrowed by 1\\" def test_return_book(): lib = LibrarySystem() lib.add_book(1, \\"1984\\", \\"George Orwell\\") lib.add_user(1, \\"Alice\\") lib.borrow(1, 1) lib.return_book(1, 1) assert lib.status(1) == \\"Available\\" def test_status_available(): lib = LibrarySystem() lib.add_book(1, \\"1984\\", \\"George Orwell\\") assert lib.status(1) == \\"Available\\" def test_status_borrowed(): lib = LibrarySystem() lib.add_book(1, \\"1984\\", \\"George Orwell\\") lib.add_user(1, \\"Alice\\") lib.borrow(1, 1) assert lib.status(1) == \\"Borrowed by 1\\"","solution":"class LibrarySystem: def __init__(self): self.books = {} self.users = {} self.borrowed_books = {} def add_book(self, book_id, title, author): self.books[book_id] = (title, author) self.borrowed_books[book_id] = None def add_user(self, user_id, name): self.users[user_id] = name def borrow(self, book_id, user_id): if self.borrowed_books.get(book_id) is None: self.borrowed_books[book_id] = user_id def return_book(self, book_id, user_id): if self.borrowed_books.get(book_id) == user_id: self.borrowed_books[book_id] = None def status(self, book_id): borrower = self.borrowed_books.get(book_id) if borrower is None: return \\"Available\\" else: return f\\"Borrowed by {borrower}\\""},{"question":"def min_fibonacci_denominations_sum(m: int) -> int: Determine the minimum number of Fibonacci denominations required to sum up to exactly m. >>> min_fibonacci_denominations_sum(10) 2 >>> min_fibonacci_denominations_sum(15) 2 >>> min_fibonacci_denominations_sum(1) 1 >>> min_fibonacci_denominations_sum(7) 2 >>> min_fibonacci_denominations_sum(100) 3 >>> min_fibonacci_denominations_sum(34) 1","solution":"def min_fibonacci_denominations_sum(m): Determine the minimum number of Fibonacci denominations required to sum up to exactly m. if m <= 0: return 0 # Generate all Fibonacci numbers up to m fib_list = [] a, b = 1, 2 while a <= m: fib_list.append(a) a, b = b, a + b count = 0 remaining_sum = m # Traverse the fib_list from the largest to the smallest and reduce remaining_sum for num in reversed(fib_list): if num <= remaining_sum: remaining_sum -= num count += 1 # If we have reached exactly zero, we can stop if remaining_sum == 0: break return count"},{"question":"import re class LibraryManagementSystem: def __init__(self): Initialize the library management system with an empty book collection. self.books = {} def add_book(self, book_id: int, title: str, author: str, copies: int): Add a new book to the library. Args: book_id (int): Unique identifier for the book. title (str): Title of the book. author (str): Author of the book. copies (int): Number of copies available in the library. pass def remove_book(self, book_id: int): Remove a book from the library using its unique identifier. Args: book_id (int): Unique identifier for the book to be removed. pass def borrow_book(self, book_id: int): Borrow a book from the library if at least one copy is available. Args: book_id (int): Unique identifier for the book to be borrowed. pass def return_book(self, book_id: int): Return a previously borrowed book to the library. Args: book_id (int): Unique identifier for the book to be returned. pass def search_books(self, title: str): Search for books by title (full or partial match). Args: title (str): Title or partial title of the book to search for. Returns: List of tuples containing book details (book_id, title, author, copies) for matching books. pass def process_commands(self, commands: List[str]): Process a series of commands to perform operations on the library. Args: commands (List[str]): List of command strings to be processed. pass from typing import List def test_library_management_system(): lms = LibraryManagementSystem() lms.add_book(101, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5) assert lms.books[101] == { 'title': \\"The Great Gatsby\\", 'author': \\"F. Scott Fitzgerald\\", 'copies': 5 } lms.add_book(102, \\"To Kill a Mockingbird\\", \\"Harper Lee\\", 3) assert lms.books[102] == { 'title': \\"To Kill a Mockingbird\\", 'author': \\"Harper Lee\\", 'copies': 3 } lms.remove_book(102) assert 102 not in lms.books lms.borrow_book(101) assert lms.books[101]['copies'] == 4 lms.return_book(101) assert lms.books[101]['copies'] == 5 results = lms.search_books(\\"Gatsby\\") assert results == [(101, \\"The Great Gatsby\\", \\"F. Scott Fitzgerald\\", 5)] results = lms.search_books(\\"Nonexistent\\") assert results == []","solution":"import re class LibraryManagementSystem: def __init__(self): self.books = {} def add_book(self, book_id, title, author, copies): self.books[book_id] = { 'title': title, 'author': author, 'copies': copies } def remove_book(self, book_id): if book_id in self.books: del self.books[book_id] def borrow_book(self, book_id): if book_id in self.books and self.books[book_id]['copies'] > 0: self.books[book_id]['copies'] -= 1 else: print(\\"Cannot borrow book\\") def return_book(self, book_id): if book_id in self.books: self.books[book_id]['copies'] += 1 else: print(\\"Cannot return book\\") def search_books(self, title): matched_books = [] for book_id, book in self.books.items(): if re.search(title.lower(), book['title'].lower()): matched_books.append( (book_id, book['title'], book['author'], book['copies']) ) return matched_books def process_commands(self, commands): for command in commands: parts = command.split(' ', 1) action = parts[0] if action == 'END': break if action == 'ADD': args = parts[1].split(' ', 3) book_id = int(args[0]) title = args[1].strip('\\"') author = args[2].strip('\\"') copies = int(args[3]) self.add_book(book_id, title, author, copies) elif action == 'REMOVE': book_id = int(parts[1]) self.remove_book(book_id) elif action == 'BORROW': book_id = int(parts[1]) self.borrow_book(book_id) elif action == 'RETURN': book_id = int(parts[1]) self.return_book(book_id) elif action == 'SEARCH': title = parts[1].strip('\\"') results = self.search_books(title) if results: for book in results: print(f\\"{book[0]} \\"{book[1]}\\" by {book[2]} - {book[3]} copies available\\") else: print(\\"No matches found\\")"},{"question":"from typing import List def is_prime(n: int) -> bool: Helper function to check if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def smallest_prime_greater_than(N: int) -> int: Find the smallest prime number larger than a given integer. >>> smallest_prime_greater_than(10) 11 >>> smallest_prime_greater_than(14) 17 >>> smallest_prime_greater_than(17) 19 >>> smallest_prime_greater_than(1000000) 1000003 >>> smallest_prime_greater_than(1) 2 >>> smallest_prime_greater_than(20) 23 >>> smallest_prime_greater_than(29) 31","solution":"def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def smallest_prime_greater_than(N): candidate = N + 1 while not is_prime(candidate): candidate += 1 return candidate"},{"question":"def min_trips(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Calculate the minimum number of trips required to deliver all orders for each test case. Parameters: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): Each test case is a tuple where the first element is a tuple containing the number of delivery agents (n) and total delivery orders (m), and the second element is a list of maximum delivery capacities of each agent. Returns: List[int]: List of minimum trips required for each test case. Examples: >>> min_trips(3, [((3, 10), [3, 7, 5]), ((2, 5), [2, 1]), ((4, 12), [4, 6, 3, 5])]) [2, 3, 2]","solution":"def min_trips_per_test_case(n, m, capacities): Returns the minimum number of trips required to deliver all orders given n delivery agents with capacities. capacities.sort(reverse=True) trips = 0 for capacity in capacities: trips_needed = (m + capacity - 1) // capacity #.ceil(m / capacity) trips += trips_needed m -= trips_needed * capacity if m <= 0: break return trips def min_trips(t, test_cases): Process multiple test cases and return the results for each case. results = [] for i in range(t): n, m = test_cases[i][0] capacities = test_cases[i][1] results.append(min_trips_per_test_case(n, m, capacities)) return results"},{"question":"def longest_steady_incline(n: int, elevations: List[int]) -> int: Returns the length of the longest steady incline segment in the elevations. >>> longest_steady_incline(6, [10, 12, 15, 13, 14, 16]) 3 >>> longest_steady_incline(1, [10]) 1 >>> longest_steady_incline(5, [1, 2, 3, 4, 5]) 5 >>> longest_steady_incline(5, [5, 4, 3, 2, 1]) 1 >>> longest_steady_incline(7, [1, 3, 2, 4, 6, 5, 7]) 3 >>> longest_steady_incline(5, [2, 2, 2, 2, 2]) 1 >>> longest_steady_incline(5, [1, 3, 2, 4, 2]) 2","solution":"def longest_steady_incline(n, elevations): Returns the length of the longest steady incline segment in the elevations. if n <= 1: return n max_length = 1 current_length = 1 for i in range(1, n): if elevations[i] > elevations[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Sample Input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) elevations = list(map(int, data[1:])) print(longest_steady_incline(n, elevations))"},{"question":"from typing import List, Tuple def josephus(N: int, K: int) -> int: Determines the position of the last person standing in a circle. >>> josephus(5, 2) 3 >>> josephus(6, 3) 1 >>> josephus(7, 1) 7 pass def solve(test_cases: List[Tuple[int, int]]) -> List[int]: Solves the Josephus problem for a given set of test cases. >>> solve([(5, 2), (6, 3), (7, 1)]) [3, 1, 7] >>> solve([(1, 1), (10, 2)]) [1, 5] pass","solution":"def josephus(N, K): Determines the position of the last person standing in a circle. :param N: Total number of friends :param K: Step count for elimination :return: Position of the last person standing (1-indexed) if N == 1: return 1 else: return (josephus(N - 1, K) + K - 1) % N + 1 def solve(test_cases): Solves the Josephus problem for a given set of test cases. :param test_cases: List of tuples, each containing N and K :return: List of results for each test case results = [] for N, K in test_cases: results.append(josephus(N, K)) return results"},{"question":"def max_profit(stock_prices): Returns the maximum profit that can be achieved from buying and selling one share of stock. If no profit can be achieved, return 0. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0","solution":"def max_profit(stock_prices): Returns the maximum profit that can be achieved from buying and selling one share of stock. If no profit can be achieved, return 0. if not stock_prices: return 0 min_price = float('inf') max_profit = 0 for price in stock_prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List def rainwater_trap(heights: List[int]) -> int: Calculate the total amount of water that can be trapped after a rainstorm given an elevation map. >>> rainwater_trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> rainwater_trap([4, 2, 0, 3, 2, 5]) 9","solution":"def rainwater_trap(heights): if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) # Fill right_max array right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) # Calculate the trapped water trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"class FileSystem: def __init__(self): self.structure = {} def parse_path(self, path): return path.strip(\\"/\\").split(\\"/\\") def get_node(self, path): keys = self.parse_path(path) node = self.structure for key in keys: if key in node: node = node[key] else: return None return node def create_node(self, path, is_dir=True): keys = self.parse_path(path) node = self.structure for key in keys: if key not in node: if is_dir: node[key] = {} else: node[key] = None node = node[key] return node def remove_node(self, path): keys = self.parse_path(path) node = self.structure for key in keys[:-1]: node = node[key] return node.pop(keys[-1]) def mkdir(self, path): self.create_node(path, is_dir=True) def mkfile(self, path): self.create_node(path, is_dir=False) def mv(self, src_path, dest_path): node = self.remove_node(src_path) keys = self.parse_path(dest_path) dest_node = self.structure for key in keys[:-1]: dest_node = dest_node[key] dest_node[keys[-1]] = node def print_structure(self, node=None, indent=\\"\\"): if node is None: node = self.structure for key in sorted(node): child = node[key] print(f\\"{indent}/{key}\\") if isinstance(child, dict): self.print_structure(child, indent + \\" \\") def process_commands(commands): Process a list of file system commands and return the final file system structure. Parameters: commands (List[str]): A list of file system commands in the form of \\"mkdir <path>\\", \\"mkfile <path>\\", or \\"mv <src_path> <dest_path>\\". Returns: FileSystem: The final file system structure. >>> commands = [\\"mkdir /a\\", \\"mkfile /a/b.txt\\", \\"mkdir /a/c\\", \\"mv /a/b.txt /a/c/b.txt\\"] >>> fs = process_commands(commands) >>> fs.print_structure() /a /c b.txt fs = FileSystem() for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"mkdir\\": fs.mkdir(parts[1]) elif cmd == \\"mkfile\\": fs.mkfile(parts[1]) elif cmd == \\"mv\\": fs.mv(parts[1], parts[2]) return fs","solution":"class FileSystem: def __init__(self): self.structure = {} def parse_path(self, path): return path.strip(\\"/\\").split(\\"/\\") def get_node(self, path): keys = self.parse_path(path) node = self.structure for key in keys: if key in node: node = node[key] else: return None return node def create_node(self, path, is_dir=True): keys = self.parse_path(path) node = self.structure for key in keys: if key not in node: if is_dir: node[key] = {} else: node[key] = None node = node[key] return node def remove_node(self, path): keys = self.parse_path(path) node = self.structure for key in keys[:-1]: node = node[key] return node.pop(keys[-1]) def mkdir(self, path): self.create_node(path, is_dir=True) def mkfile(self, path): self.create_node(path, is_dir=False) def mv(self, src_path, dest_path): node = self.remove_node(src_path) keys = self.parse_path(dest_path) dest_node = self.structure for key in keys[:-1]: dest_node = dest_node[key] dest_node[keys[-1]] = node def print_structure(self, node=None, indent=\\"\\"): if node is None: node = self.structure for key in sorted(node): child = node[key] print(f\\"{indent}/{key}\\") if isinstance(child, dict): self.print_structure(child, indent + \\" \\") def process_commands(commands): fs = FileSystem() for command in commands: parts = command.split() cmd = parts[0] if cmd == \\"mkdir\\": fs.mkdir(parts[1]) elif cmd == \\"mkfile\\": fs.mkfile(parts[1]) elif cmd == \\"mv\\": fs.mv(parts[1], parts[2]) return fs # Interface to read commands and print output def main(): import sys input = sys.stdin.read data = input().splitlines() m = int(data[0]) commands = data[1:] fs = process_commands(commands) fs.print_structure() # main will not run in this context as we need to generate list of commands"},{"question":"def minimumContainers(container_limit, weights): Determines the minimum number of containers required for a shipment based on container weight limit and package weights. Parameters: container_limit (int): The maximum allowed weight per container. weights (list of ints): The list of package weights. Returns: int: The minimum number of containers required. Example: >>> minimumContainers(10, [4, 8, 1, 4, 2, 1]) 2 >>> minimumContainers(10, [9, 8, 2, 2, 1, 1]) 3 pass def process_inputs(inputs): Processes multiple test cases from the given inputs Parameters: inputs (list of str): List of input strings Returns: list of int: List of results for each test case Example: >>> process_inputs([ ... \\"2\\", ... \\"10\\", ... \\"4 8 1 4 2 1\\", ... \\"10\\", ... \\"9 8 2 2 1 1\\" ... ]) [2, 3] pass import pytest def test_minimumContainers_case1(): assert minimumContainers(10, [4, 8, 1, 4, 2, 1]) == 2 def test_minimumContainers_case2(): assert minimumContainers(10, [9, 8, 2, 2, 1, 1]) == 3 def test_minimumContainers_case3(): assert minimumContainers(6, [1, 2, 3, 4, 5]) == 3 def test_minimumContainers_case4(): assert minimumContainers(15, [10, 5, 5, 3, 2, 1]) == 2 def test_minimumContainers_empty(): assert minimumContainers(10, []) == 0 def test_minimumContainers_large(): assert minimumContainers(1000000000, [1000000000] * 100) == 100 def test_process_inputs(): inputs = [ \\"2\\", \\"10\\", \\"4 8 1 4 2 1\\", \\"10\\", \\"9 8 2 2 1 1\\" ] assert process_inputs(inputs) == [2, 3] def test_process_inputs_more_cases(): inputs = [ \\"3\\", \\"10\\", \\"4 8 1 4 2 1\\", \\"10\\", \\"9 8 2 2 1 1\\", \\"6\\", \\"1 2 3 4 5\\" ] assert process_inputs(inputs) == [2, 3, 3] if __name__ == \\"__main__\\": pytest.main()","solution":"def minimumContainers(container_limit, weights): Determines the minimum number of containers required for a shipment based on container weight limit and package weights. Parameters: container_limit (int): The maximum allowed weight per container. weights (list of ints): The list of package weights. Returns: int: The minimum number of containers required. weights.sort(reverse=True) containers = [] for weight in weights: placed = False for container in containers: if sum(container) + weight <= container_limit: container.append(weight) placed = True break if not placed: containers.append([weight]) return len(containers) def process_inputs(inputs): Processes multiple test cases from the given inputs Parameters: inputs (list of str): List of input strings Returns: list of int: List of results for each test case results = [] t = int(inputs[0]) idx = 1 for _ in range(t): container_limit = int(inputs[idx]) weights = list(map(int, inputs[idx + 1].split())) results.append(minimumContainers(container_limit, weights)) idx += 2 return results"},{"question":"def find_optimal_times(t: int, ks: List[int]) -> List[Tuple[int, int]]: Determines optimal green light durations for traffic lights. Parameters: t (int): Number of test cases ks (list): List of maximum durations for green lights for each test case Returns: list: List of tuples, each containing two optimal durations (a, b) >>> find_optimal_times(1, [5]) [(2, 3)] >>> find_optimal_times(1, [10]) [(5, 5)] >>> find_optimal_times(1, [15]) [(7, 8)] >>> find_optimal_times(3, [5, 10, 15]) [(2, 3), (5, 5), (7, 8)] >>> find_optimal_times(1, [1]) [(0, 1)]","solution":"def find_optimal_times(t, ks): Determines optimal green light durations for traffic lights. Parameters: t (int): Number of test cases ks (list): List of maximum durations for green lights for each test case Returns: list: List of tuples, each containing two optimal durations (a, b) results = [] for k in ks: # As a simple approach, divide k approximately into two parts a = k // 2 b = k - a results.append((a, b)) return results"},{"question":"def determine_sequence_type(n: int, array: List[int]) -> str: Determines if the array is strictly increasing, strictly decreasing, or neither. Args: n : int : Number of elements in the array array : list : List of integers Returns: str : 'Increasing', 'Decreasing' or 'Neither' >>> determine_sequence_type(5, [1, 2, 3, 4, 5]) 'Increasing' >>> determine_sequence_type(5, [5, 4, 3, 2, 1]) 'Decreasing' >>> determine_sequence_type(5, [1, 3, 2, 4, 5]) 'Neither' >>> determine_sequence_type(2, [1, 2]) 'Increasing' >>> determine_sequence_type(2, [2, 1]) 'Decreasing' >>> determine_sequence_type(1, [42]) 'Neither' # Test cases print(determine_sequence_type(5, [1, 2, 3, 4, 5])) # Output: Increasing print(determine_sequence_type(5, [5, 4, 3, 2, 1])) # Output: Decreasing print(determine_sequence_type(5, [1, 3, 2, 4, 5])) # Output: Neither print(determine_sequence_type(2, [1, 2])) # Output: Increasing print(determine_sequence_type(2, [2, 1])) # Output: Decreasing print(determine_sequence_type(1, [42])) # Output: Neither","solution":"def determine_sequence_type(n, array): Determines if the array is strictly increasing, strictly decreasing, or neither. Args: n : int : Number of elements in the array array : list : List of integers Returns: str : 'Increasing', 'Decreasing' or 'Neither' if n == 1: return \\"Neither\\" is_increasing = all(array[i] < array[i + 1] for i in range(n - 1)) if is_increasing: return \\"Increasing\\" is_decreasing = all(array[i] > array[i + 1] for i in range(n - 1)) if is_decreasing: return \\"Decreasing\\" return \\"Neither\\" # Example usage: # result = determine_sequence_type(5, [1, 2, 3, 4, 5]) # print(result) # Output: Increasing"},{"question":"from typing import List, Tuple def find_growth_decline_periods(n: int, changes: List[int]) -> List[Tuple[int, int]]: Determines the number of periods of consistent growth and decline and summarizes the indices of the start and end of each period. Args: n (int): Number of days changes (List[int]): Growth rate changes over n days Returns: List[Tuple[int, int]]: A list of tuples containing the start and end indices (1-based) of each period of consistent growth or decline. Examples: >>> find_growth_decline_periods(10, [1, 2, -3, -4, 5, 6, 7, -8, -9, 10]) [(1, 2), (3, 4), (5, 7), (8, 9)] >>> find_growth_decline_periods(6, [0, 1, 2, 3, -1, -2]) [(2, 4), (5, 6)]","solution":"def find_growth_decline_periods(n, changes): periods = [] start_idx = 0 while start_idx < n - 1: if changes[start_idx] == 0: start_idx += 1 continue end_idx = start_idx increasing = changes[start_idx] > 0 while end_idx < n - 1 and ((increasing and changes[end_idx] < changes[end_idx + 1]) or (not increasing and changes[end_idx] > changes[end_idx + 1])): end_idx += 1 if start_idx != end_idx: periods.append((start_idx + 1, end_idx + 1)) start_idx = end_idx start_idx += 1 return periods # Sample input testing n = 10 changes = [1, 2, -3, -4, 5, 6, 7, -8, -9, 10] print(find_growth_decline_periods(n, changes))"},{"question":"def balancedStringSplit(s: str) -> int: Returns the maximum number of balanced substrings. A balanced substring is defined as a substring that has an equal number of 'R' and 'L'. Parameters: s (str): Input string containing only 'R' and 'L'. Returns: int: Maximum number of balanced substrings Example: >>> balancedStringSplit(\\"RLRRLLRLRL\\") 4 >>> balancedStringSplit(\\"RLLLLRRRLR\\") 3 >>> balancedStringSplit(\\"LLLLRRRR\\") 1 >>> balancedStringSplit(\\"RL\\") 1 >>> balancedStringSplit(\\"RLRLRLRL\\") 4 >>> balancedStringSplit(\\"RRLLR\\") 1 >>> balancedStringSplit(\\"RRRR\\") 0 >>> balancedStringSplit(\\"LLLL\\") 0","solution":"def balancedStringSplit(s): Returns the maximum number of balanced substrings. :param s: input string containing only 'R' and 'L' :type s: str :return: maximum number of balanced substrings :rtype: int balance = 0 max_balanced = 0 for char in s: if char == 'R': balance += 1 else: # char == 'L' balance -= 1 if balance == 0: max_balanced += 1 return max_balanced"},{"question":"def find_duplicates(n: int, ids: List[str]) -> Tuple[int, List[str]]: Returns the count of duplicate IDs and the list of unique duplicate IDs. Args: n : int : number of registration attempts ids: list : list of participant IDs Returns: count, duplicates : tuple : count of duplicates and the list of duplicate IDs >>> find_duplicates(8, ['p01', 'p02', 'p03', 'p01', 'p04', 'p03', 'p05', 'p03']) (2, ['p01', 'p03']) >>> find_duplicates(5, ['p01', 'p02', 'p03', 'p04', 'p05']) (0, []) >>> find_duplicates(6, ['p01', 'p01', 'p02', 'p02', 'p03', 'p03']) (3, ['p01', 'p02', 'p03']) >>> find_duplicates(7, ['A1', 'A1', 'A2', 'A3', 'a1', 'A2', 'A1']) (2, ['A1', 'A2'])","solution":"def find_duplicates(n, ids): Returns the count of duplicate IDs and the list of unique duplicate IDs. Args: n : int : number of registration attempts ids: list : list of participant IDs Returns: count, duplicates : tuple : count of duplicates and the list of duplicate IDs id_count = {} duplicates = set() for id in ids: if id in id_count: id_count[id] += 1 else: id_count[id] = 1 for id, count in id_count.items(): if count > 1: duplicates.add(id) return len(duplicates), sorted(duplicates) # Sample usage (for manual testing) if __name__ == \\"__main__\\": n = 8 ids = ['p01', 'p02', 'p03', 'p01', 'p04', 'p03', 'p05', 'p03'] count, duplicates = find_duplicates(n, ids) print(count) for id in duplicates: print(id)"},{"question":"def last_digit_of_cumulative_product(n: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the last digit of the cumulative product of subarrays based on given queries. Args: n: An integer representing the size of the array. arr: A list of n integers, representing the elements of the array. queries: A list of tuples, where each tuple contains two integers l and r representing the subarray bounds (1-indexed). Returns: A list of integers, where each integer is the last digit of the cumulative product of the corresponding subarray. Example: >>> last_digit_of_cumulative_product(5, [2, 3, 4, 5, 6], [(1, 3), (2, 5), (3, 3)]) [4, 0, 4] >>> last_digit_of_cumulative_product(1, [7], [(1, 1)]) [7]","solution":"def last_digit_of_cumulative_product(n, arr, queries): results = [] for l, r in queries: product = 1 for i in range(l-1, r): product *= arr[i] last_digit = product % 10 results.append(last_digit) return results"},{"question":"def next_permutation(a: List[int]) -> List[int]: Determine the next lexicographical permutation of the list of integers. If no such permutation exists, return the smallest permutation (sorted in ascending order). >>> next_permutation([1, 2, 3]) [1, 3, 2] >>> next_permutation([3, 2, 1]) [1, 2, 3] def process_permutations(test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Processes multiple test cases and determines the next permutation for each. Returns a list of the next permutations. >>> test_cases = [(3, [1, 2, 3]), (3, [3, 2, 1])] >>> process_permutations(test_cases) [[1, 3, 2], [1, 2, 3]] # Example test cases for the process_permutations function if __name__ == \\"__main__\\": def test_next_permutation(): test_cases = [ (3, [1, 2, 3]), # normal case (3, [3, 2, 1]), # descending case (3, [1, 1, 5]), # duplicate values (4, [1, 2, 3, 6]), # normal case (2, [2, 2]), # all same values ] expected_outputs = [ [1, 3, 2], [1, 2, 3], [1, 5, 1], [1, 2, 6, 3], [2, 2] ] outputs = process_permutations(test_cases) for output, expected in zip(outputs, expected_outputs): assert output == expected def test_edge_cases(): test_cases = [ (1, [1]), (2, [1, 2]), (2, [2, 1]), ] expected_outputs = [ [1], [2, 1], [1, 2], ] outputs = process_permutations(test_cases) for output, expected in zip(outputs, expected_outputs): assert output == expected test_next_permutation() test_edge_cases()","solution":"def next_permutation(a): Modifies the list a to its next lexicographical permutation. If no such permutation exists, modifies to the smallest permutation. n = len(a) i = n - 2 while i >= 0 and a[i] >= a[i + 1]: i -= 1 if i == -1: a.reverse() return j = n - 1 while a[j] <= a[i]: j -= 1 a[i], a[j] = a[j], a[i] a[i + 1:] = reversed(a[i + 1:]) return def process_permutations(test_cases): result = [] for case in test_cases: n, arr = case next_permutation(arr) result.append(arr) return result"},{"question":"def calculateContributions(distances: List[int], totalFuelCost: int) -> List[int]: Calculate the contributions towards the total fuel cost based on distances traveled. Parameters: distances (list of int): The distances traveled by each friend. totalFuelCost (int): The total fuel cost for the trip. Returns: list of int: The amount each friend should contribute, rounded to the nearest integer. Example: >>> calculateContributions([100, 200, 300], 600) [100, 200, 300] >>> calculateContributions([1, 2, 2], 10) [2, 4, 4]","solution":"def calculateContributions(distances, totalFuelCost): Calculate the contributions towards the total fuel cost based on distances traveled. Parameters: distances (list of int): The distances traveled by each friend. totalFuelCost (int): The total fuel cost for the trip. Returns: list of int: The amount each friend should contribute, rounded to the nearest integer. totalDistance = sum(distances) contributions = [ round((distance / totalDistance) * totalFuelCost) for distance in distances ] return contributions"},{"question":"def process_operations(n: int, operations: List[List[str]]) -> List[int]: Processes a series of operations on a sequence and returns results for type \\"3\\" operations. Operations: 1 x: Add an integer x to the end of the sequence. 2: Remove the last integer from the sequence. 3: Calculate and return the maximum absolute difference between any two elements in the sequence. Returns a list of integers for each \\"3\\" operation. >>> process_operations(5, [['1', '5'], ['1', '10'], ['3'], ['2'], ['3']]) [5, 0] >>> process_operations(6, [['1', '-10'], ['1', '5'], ['3'], ['2'], ['2'], ['3']]) [15, 0] from typing import List def test_example1(): n = 5 operations = [ ['1', '5'], ['1', '10'], ['3'], ['2'], ['3'] ] assert process_operations(n, operations) == [5, 0] def test_example2(): n = 6 operations = [ ['1', '-10'], ['1', '5'], ['3'], ['2'], ['2'], ['3'] ] assert process_operations(n, operations) == [15, 0] def test_empty_sequence(): n = 2 operations = [ ['2'], ['3'] ] assert process_operations(n, operations) == [0] def test_single_element_in_sequence(): n = 3 operations = [ ['1', '7'], ['3'], ['2'] ] assert process_operations(n, operations) == [0] def test_large_range_numbers(): n = 5 operations = [ ['1', '-1000000000'], ['1', '1000000000'], ['3'], ['2'], ['3'] ] assert process_operations(n, operations) == [2000000000, 0]","solution":"def process_operations(n, operations): sequence = [] results = [] for operation in operations: if operation[0] == '1': sequence.append(int(operation[1])) elif operation[0] == '2': if sequence: sequence.pop() elif operation[0] == '3': if len(sequence) < 2: results.append(0) else: max_diff = max(sequence) - min(sequence) results.append(max_diff) return results"},{"question":"def reverse_words_in_string(s: str) -> str: Return a new string where each word is reversed but the order of words within the string remains the same. :param s: the input string with words :type s: str :return: the modified string :rtype: str >>> reverse_words_in_string(\\"Hello, world!\\") ',olleH !dlrow' >>> reverse_words_in_string(\\"Hello, world!\\") ',olleH !dlrow' >>> reverse_words_in_string(\\"\\") '' >>> reverse_words_in_string(\\" \\") ' ' >>> reverse_words_in_string(\\" Hello, world! \\") ' ,olleH !dlrow '","solution":"def reverse_words_in_string(s): Return a new string where each word is reversed but the order of words remains the same. :param s: the input string with words :type s: str :return: the modified string :rtype: str # Split the string into words by spaces words = s.split(' ') # Reverse each word and join back with spaces reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words)"},{"question":"from typing import List, Tuple, Union def minimum_moves_to_charging(N: int, W: int, H: int, drones: List[Tuple[int, int, int]], stations: List[Tuple[int, int]]) -> Union[int, str]: Calculate the minimum number of moves required for all drones to reach a charging station. If it is impossible for some drones to reach any station, return \\"Impossible\\". >>> minimum_moves_to_charging(3, 5, 5, [(1, 1, 3), (4, 4, 2), (5, 5, 10)], [(2, 2), (4, 3)]) 3 >>> minimum_moves_to_charging(2, 3, 3, [(1, 1, 1), (3, 3, 5)], [(2, 2)]) \\"Impossible\\" >>> minimum_moves_to_charging(4, 7, 7, [(2, 2, 5), (3, 4, 3), (6, 6, 8), (1, 5, 2)], [(4, 4), (7, 3), (1, 6)]) 4 >>> minimum_moves_to_charging(2, 5, 5, [(2, 2, 10), (4, 4, 10)], [(2, 2), (4, 4)]) 0 >>> minimum_moves_to_charging(0, 5, 5, [], [(2, 2), (4, 4)]) 0 >>> minimum_moves_to_charging(2, 5, 5, [(1, 1, 3), (4, 4, 2)], []) \\"Impossible\\" pass","solution":"from collections import deque def bfs_shortest_distance(w, h, stations): directions = [(1, 0), (-1, 0), (0, 1), (0, -1)] # Initialize distances with -1 (unreachable) distances = [[-1] * w for _ in range(h)] queue = deque() for x, y in stations: queue.append((x, y)) distances[y-1][x-1] = 0 while queue: cx, cy = queue.popleft() for dx, dy in directions: nx, ny = cx + dx, cy + dy if 1 <= nx <= w and 1 <= ny <= h and distances[ny-1][nx-1] == -1: distances[ny-1][nx-1] = distances[cy-1][cx-1] + 1 queue.append((nx, ny)) return distances def minimum_moves_to_charging(N, W, H, drones, stations): distances = bfs_shortest_distance(W, H, stations) max_moves = 0 for x, y, b in drones: distance = distances[y-1][x-1] if distance == -1 or distance > b: return \\"Impossible\\" max_moves = max(max_moves, distance) return max_moves # Example usage: # drones = [(1, 1, 3), (4, 4, 2), (5, 5, 10)] # stations = [(2, 2), (4, 3)] # print(minimum_moves_to_charging(3, 5, 5, drones, stations)) # Output: 3"},{"question":"from typing import List, Tuple def minimum_cost_to_connect_all_cities(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Find the minimum possible cost to connect all cities in the given kingdom. If it is impossible to connect all cities, return \\"IMPOSSIBLE\\". Args: n (int): number of cities. m (int): number of roads. roads (List[Tuple[int, int, int]]): list of roads where each road is represented as a tuple (u, v, w) with u and v being the cities the road connects and w being the travel cost. Returns: int: minimum cost to connect all cities, or \\"IMPOSSIBLE\\". Examples: >>> minimum_cost_to_connect_all_cities(4, 5, [(1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5)]) 6 >>> minimum_cost_to_connect_all_cities(3, 1, [(1, 2, 5)]) 'IMPOSSIBLE' def test_sample1(): n = 4 m = 5 roads = [ (1, 2, 1), (1, 3, 4), (1, 4, 3), (2, 3, 2), (3, 4, 5) ] assert minimum_cost_to_connect_all_cities(n, m, roads) == 6 def test_sample2(): n = 3 m = 1 roads = [ (1, 2, 5) ] assert minimum_cost_to_connect_all_cities(n, m, roads) == \\"IMPOSSIBLE\\" def test_single_city(): n = 1 m = 0 roads = [] assert minimum_cost_to_connect_all_cities(n, m, roads) == 0 def test_impossible_case(): n = 5 m = 3 roads = [ (1, 2, 1), (2, 3, 2), (4, 5, 3) ] assert minimum_cost_to_connect_all_cities(n, m, roads) == \\"IMPOSSIBLE\\" def test_all_connected(): n = 7 m = 11 roads = [ (1, 2, 7), (1, 4, 5), (2, 3, 8), (2, 4, 9), (2, 5, 7), (3, 5, 5), (4, 5, 15), (4, 6, 6), (5, 6, 8), (5, 7, 9), (6, 7, 11) ] assert minimum_cost_to_connect_all_cities(n, m, roads) == 39","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if rank[root_x] < rank[root_y]: parent[root_x] = root_y elif rank[root_x] > rank[root_y]: parent[root_y] = root_x else: parent[root_y] = root_x rank[root_x] += 1 def minimum_cost_to_connect_all_cities(n, m, roads): if n == 1: return 0 edges = sorted(roads, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) e = 0 i = 0 result = [] while e < n - 1: if i >= len(edges): return \\"IMPOSSIBLE\\" u, v, w = edges[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) if x != y: e = e + 1 result.append(w) union(parent, rank, x, y) return sum(result)"},{"question":"def determine_winner(contestants): Determines the winner from a list of contestants. Each contestant's score for a single contest is calculated based on their time to solve all problems and the number of problems they solved correctly. The system needs to handle multiple contestants and determine the winner based on the highest number of problems solved. In case of a tie, the contestant with the least total time spent wins. Args: contestants (list of tuple): A list where each tuple contains the name of the contestant (str), the number of problems solved (int), and the total time spent (int). Returns: str: The name of the winning contestant. >>> determine_winner([(\\"Alice\\", 4, 130)]) == \\"Alice\\" >>> determine_winner([(\\"Alice\\", 4, 130), (\\"Bob\\", 4, 120)]) == \\"Bob\\" >>> determine_winner([(\\"Alice\\", 4, 130), (\\"Bob\\", 3, 120)]) == \\"Alice\\" >>> determine_winner([(\\"Alice\\", 4, 120), (\\"Bob\\", 4, 120), (\\"Charlie\\", 4, 150)]) == \\"Alice\\" >>> contestants = [(\\"Alice\\", 4, 130), (\\"Bob\\", 4, 120), (\\"Charlie\\", 3, 150), (\\"Dave\\", 4, 110)] >>> determine_winner(contestants) == \\"Dave\\" >>> contestants = [(\\"Alice\\", 0, 130), (\\"Bob\\", 1, 220), (\\"Charlie\\", 0, 150)] >>> determine_winner(contestants) == \\"Bob\\" >>> contestants = [(\\"Alice\\", 0, 100), (\\"Bob\\", 0, 200), (\\"Charlie\\", 0, 150)] >>> determine_winner(contestants) == \\"Alice\\"","solution":"def determine_winner(contestants): Determines the winner from a list of contestants. Args: contestants (list of tuple): A list where each tuple contains the name of the contestant (str), the number of problems solved (int), and the total time spent (int). Returns: str: The name of the winning contestant. # Sort the contestants primarily by solved problems in descending order, # and then by total time in ascending order sorted_contestants = sorted(contestants, key=lambda x: (-x[1], x[2])) # The first contestant in the sorted list is the winner return sorted_contestants[0][0]"},{"question":"def are_all_players_in_same_alliance(n: int, moves: List[Tuple[int, int]]) -> str: Determine if all players are in the same alliance at the end of the given moves. >>> are_all_players_in_same_alliance(4, [(1, 2), (2, 3), (3, 4)]) == \\"yes\\" >>> are_all_players_in_same_alliance(4, [(1, 2), (3, 4)]) == \\"no\\" >>> are_all_players_in_same_alliance(5, [(1, 2), (2, 3), (3, 4), (4, 5)]) == \\"yes\\" >>> are_all_players_in_same_alliance(3, [(1, 2), (2, 3)]) == \\"yes\\" >>> are_all_players_in_same_alliance(3, [(1, 2)]) == \\"no\\" >>> are_all_players_in_same_alliance(2, [(1, 2)]) == \\"yes\\" >>> are_all_players_in_same_alliance(4, [(1, 2), (1, 3), (1, 4)]) == \\"yes\\" >>> are_all_players_in_same_alliance(5, [(1, 2), (3, 4), (4, 5)]) == \\"no\\"","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, x, y): xroot = find(parent, x) yroot = find(parent, y) parent[xroot] = yroot def are_all_players_in_same_alliance(n, moves): parent = list(range(n+1)) for u, v in moves: union(parent, u, v) root = find(parent, 1) for i in range(2, n+1): if find(parent, i) != root: return \\"no\\" return \\"yes\\""},{"question":"def find_prime_factors(n: int) -> List[int]: Returns the list of prime factors of \`n\`. If \`n\` is 1 or a prime number, returns an empty list. >>> find_prime_factors(1) == [] >>> find_prime_factors(11) == [] >>> find_prime_factors(12) == [2, 2, 3] >>> find_prime_factors(315) == [3, 3, 5, 7]","solution":"def find_prime_factors(n): Returns the list of prime factors of \`n\`. If \`n\` is 1 or a prime number, returns an empty list. if n <= 1: return [] factors = [] divisor = 2 while n >= 2: while n % divisor == 0: factors.append(divisor) n //= divisor divisor += 1 return factors if len(factors) > 1 else []"},{"question":"def highest_team_and_developer(input_data: str) -> (str, str): Determine the development team that received the highest combined score from the judges, as well as the individual developer who received the highest score for their contribution to the project. Args: input_data : str : Input consisting of number of developers, number of projects and their scores. Returns: tuple : A tuple containing the name of the project team with the highest combined score and the name of the individual developer with the highest score >>> highest_team_and_developer(\\"3 2nAlice ProjectA 85nBob ProjectA 90nCharlie ProjectB 80\\") (\\"ProjectA\\", \\"Bob\\") >>> highest_team_and_developer(\\"4 2nJohn ProjectX 70nDoe ProjectY 90nSmith ProjectY 85nJane ProjectX 95\\") (\\"ProjectY\\", \\"Jane\\") >>> highest_team_and_developer(\\"2 1nMike ProjectZ 88nNina ProjectZ 88\\") (\\"ProjectZ\\", \\"Mike\\") pass # Implement the function here # Unit test import pytest def test_example1(): input_data = \\"3 2nAlice ProjectA 85nBob ProjectA 90nCharlie ProjectB 80\\" assert highest_team_and_developer(input_data) == (\\"ProjectA\\", \\"Bob\\") def test_example2(): input_data = \\"4 2nJohn ProjectX 70nDoe ProjectY 90nSmith ProjectY 85nJane ProjectX 95\\" assert highest_team_and_developer(input_data) == (\\"ProjectY\\", \\"Jane\\") def test_example3(): input_data = \\"2 1nMike ProjectZ 88nNina ProjectZ 88\\" assert highest_team_and_developer(input_data) == (\\"ProjectZ\\", \\"Mike\\") def test_tiebreaker_project(): input_data = \\"4 2nLiam ProjectA 50nMia ProjectB 50nNoah ProjectA 50nOlivia ProjectB 50\\" assert highest_team_and_developer(input_data) == (\\"ProjectA\\", \\"Liam\\") def test_tiebreaker_developer(): input_data = \\"2 1nAbe ProjectX 100nZed ProjectX 100\\" assert highest_team_and_developer(input_data) == (\\"ProjectX\\", \\"Abe\\") @pytest.mark.parametrize(\\"input_data, expected\\", [ (\\"5 3nDevA Proj1 50nDevB Proj2 60nDevC Proj2 40nDevD Proj3 30nDevE Proj1 70\\", (\\"Proj1\\", \\"DevE\\")), (\\"3 3nAnna ProjA 100nBen ProjB 100nCara ProjC 100\\", (\\"ProjA\\", \\"Anna\\")), ]) def test_various(input_data, expected): assert highest_team_and_developer(input_data) == expected if __name__ == \\"__main__\\": pytest.main()","solution":"def highest_team_and_developer(input_data): Take input data and return the highest scoring team and highest scoring developer. Parameters ---------- input_data : str Input data containing developer names, project names, and scores. Returns ------- tuple (name of the project with highest total score, name of the highest scoring developer) lines = input_data.strip().split(\\"n\\") N, M = map(int, lines[0].split()) project_scores = {} developer_scores = {} for line in lines[1:]: developer, project, score = line.split() score = int(score) # Updating project scores if project not in project_scores: project_scores[project] = 0 project_scores[project] += score # Updating developer scores developer_scores[developer] = (project, score) # Finding the project with the highest score highest_scoring_project = max( project_scores.items(), key=lambda item: (item[1], -ord(item[0][0])) # The second argument ensures lexicographical order in case of ties )[0] # Finding the developer with the highest score highest_scoring_developer = max( developer_scores.items(), key=lambda item: (item[1][1], -ord(item[0][0])) # The second argument ensures lexicographical order in case of ties )[0] return highest_scoring_project, highest_scoring_developer"},{"question":"def is_palindrome_linked_list(arr): Returns 'yes' if the linked list represented by array arr is a palindrome, 'no' otherwise. >>> is_palindrome_linked_list([1, 2, 1]) 'yes' >>> is_palindrome_linked_list([1, 2, 3, 4]) 'no' def process_palindrome_tests(T, test_cases): Processes multiple test cases to check if linked lists are palindromes. >>> process_palindrome_tests(2, [(3, [1, 2, 1]), (4, [1, 2, 3, 4])]) ['yes', 'no'] >>> process_palindrome_tests(1, [(1, [9])]) ['yes']","solution":"def is_palindrome_linked_list(arr): Returns 'yes' if the linked list represented by array arr is a palindrome, 'no' otherwise. return 'yes' if arr == arr[::-1] else 'no' def process_palindrome_tests(T, test_cases): results = [] for case in test_cases: N, arr = case results.append(is_palindrome_linked_list(arr)) return results"},{"question":"from typing import List def isPrime(X: int) -> bool: Returns True if X is a prime number, False otherwise. >>> isPrime(11) True >>> isPrime(4) False def isSumOfSquares(PR: int) -> bool: Returns True if PR can be expressed as the sum of the squares of two non-negative integers. >>> isSumOfSquares(5) True >>> isSumOfSquares(3) False def smallest_prime_sum_of_squares_greater_than(N: int) -> int: Returns the smallest prime number greater than N that can be expressed as the sum of the squares of two non-negative integers. >>> smallest_prime_sum_of_squares_greater_than(10) 13 >>> smallest_prime_sum_of_squares_greater_than(20) 29 def process_input(T: int, test_cases: List[int]) -> List[int]: Processes the input and returns the results for each test case. >>> process_input(3, [10, 20, 50]) [13, 29, 53] # Add unit tests def test_is_prime(): assert isPrime(2) == True assert isPrime(3) == True assert isPrime(4) == False assert isPrime(29) == True assert isPrime(30) == False def test_is_sum_of_squares(): assert isSumOfSquares(5) == True # 1^2 + 2^2 assert isSumOfSquares(2) == True # 1^2 + 1^2 assert isSumOfSquares(3) == False # cannot be expressed as sum of squares assert isSumOfSquares(13) == True # 2^2 + 3^2 def test_smallest_prime_sum_of_squares_greater_than(): assert smallest_prime_sum_of_squares_greater_than(10) == 13 assert smallest_prime_sum_of_squares_greater_than(20) == 29 assert smallest_prime_sum_of_squares_greater_than(50) == 53 assert smallest_prime_sum_of_squares_greater_than(2) == 5 def test_process_input(): assert process_input(3, [10, 20, 50]) == [13, 29, 53]","solution":"def isPrime(X): Returns True if X is a prime number, False otherwise. if X <= 1: return False if X <= 3: return True if X % 2 == 0 or X % 3 == 0: return False i = 5 while i * i <= X: if X % i == 0 or X % (i + 2) == 0: return False i += 6 return True def isSumOfSquares(PR): Returns True if PR can be expressed as the sum of the squares of two non-negative integers. import math for i in range(int(math.sqrt(PR)) + 1): j = math.sqrt(PR - i * i) if j == int(j): return True return False def smallest_prime_sum_of_squares_greater_than(N): Returns the smallest prime number greater than N that can be expressed as the sum of the squares of two non-negative integers. candidate = N + 1 while True: if isPrime(candidate) and isSumOfSquares(candidate): return candidate candidate += 1 def process_input(T, test_cases): results = [] for N in test_cases: results.append(smallest_prime_sum_of_squares_greater_than(N)) return results"},{"question":"def minWindowSubstr(S: str, P: str) -> str: Find the smallest substring in S which contains all the characters of P in O(N) time complexity. >>> minWindowSubstr(\\"ADOBECODEBANC\\", \\"ABC\\") 'BANC' >>> minWindowSubstr(\\"HELLO\\", \\"OELL\\") 'ELLO' >>> minWindowSubstr(\\"A\\", \\"B\\") '' >>> minWindowSubstr(\\"ABCDE\\", \\"ABCDE\\") 'ABCDE' >>> minWindowSubstr(\\"aaabbbccc\\", \\"abc\\") 'abbbc' >>> minWindowSubstr(\\"aaaaa\\", \\"aaa\\") 'aaa' # implementation here","solution":"def minWindowSubstr(S, P): from collections import Counter if not S or not P or len(S) < len(P): return \\"\\" dict_p = Counter(P) required = len(dict_p) left, right = 0, 0 formed = 0 window_counts = {} min_length = float('inf') min_window = (0, 0) while right < len(S): character = S[right] window_counts[character] = window_counts.get(character, 0) + 1 if character in dict_p and window_counts[character] == dict_p[character]: formed += 1 while left <= right and formed == required: character = S[left] if right - left + 1 < min_length: min_length = right - left + 1 min_window = (left, right) window_counts[character] -= 1 if character in dict_p and window_counts[character] < dict_p[character]: formed -= 1 left += 1 right += 1 return \\"\\" if min_length == float('inf') else S[min_window[0]: min_window[1] + 1]"},{"question":"def min_intervals_to_remove(intervals): Determines the minimum number of intervals to remove to make the rest of the intervals non-overlapping. >>> min_intervals_to_remove([[1, 2], [2, 3], [3, 4], [1, 3]]) 1 >>> min_intervals_to_remove([[1, 2], [1, 2], [1, 2]]) 2 >>> min_intervals_to_remove([[1, 2], [2, 3]]) 0 >>> min_intervals_to_remove([]) 0 >>> min_intervals_to_remove([[1, 4], [2, 3], [3, 4], [4, 5]]) 1 >>> min_intervals_to_remove([[1, 4], [4, 6], [5, 7], [6, 8], [7, 9]]) 2 pass","solution":"def min_intervals_to_remove(intervals): Determines the minimum number of intervals to remove to make the rest non-overlapping. :param intervals: List of intervals represented as [start, end] :return: Minimum number of intervals to remove if not intervals: return 0 # Sort intervals based on their end time intervals.sort(key=lambda x: x[1]) # Initialize count of intervals to remove remove_count = 0 # Track the end time of the previous interval prev_end = intervals[0][1] for i in range(1, len(intervals)): if intervals[i][0] < prev_end: # Overlapping interval, increment remove count remove_count += 1 else: # No overlap, update the end time to the current interval's end time prev_end = intervals[i][1] return remove_count # Function to read input and solve the problem def solve(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) intervals = [] for i in range(n): start = int(data[2*i + 1]) end = int(data[2*i + 2]) intervals.append([start, end]) print(min_intervals_to_remove(intervals))"},{"question":"from typing import List def max_profit(prices: List[int]) -> int: This function calculates the maximum profit that can be achieved from a single buy-sell transaction. >>> max_profit([7, 1, 5, 3, 6, 4]) 5 >>> max_profit([7, 6, 4, 3, 1]) 0 >>> max_profit([1, 2, 3, 4, 5]) 4 >>> max_profit([3, 3, 3, 3, 3]) 0 >>> max_profit([1]) 0 >>> max_profit([]) 0","solution":"def max_profit(prices): This function calculates the maximum profit that can be achieved from a single buy-sell transaction. if not prices: return 0 local_min = prices[0] max_profit = 0 for price in prices[1:]: if price < local_min: local_min = price max_profit = max(max_profit, price - local_min) return max_profit"},{"question":"def alice_wins_game(A: int, B: int, C: int) -> str: Determines if Alice will win the game given three piles of stones. Three integers 0 <= A, B, C <= 1000. Returns \\"Alice\\" if Alice will win the game, otherwise returns \\"Bob\\". Examples: >>> alice_wins_game(0, 0, 0) \\"Bob\\" >>> alice_wins_game(1, 1, 1) \\"Alice\\" >>> alice_wins_game(2, 3, 4) \\"Alice\\" from solution import alice_wins_game def test_all_piles_zero(): assert alice_wins_game(0, 0, 0) == \\"Bob\\" def test_all_piles_one(): assert alice_wins_game(1, 1, 1) == \\"Alice\\" def test_mixed_piles_1(): assert alice_wins_game(2, 3, 4) == \\"Alice\\" def test_mixed_piles_2(): assert alice_wins_game(5, 1, 2) == \\"Alice\\" def test_mixed_piles_3(): assert alice_wins_game(6, 7, 8) == \\"Alice\\" def test_scenario(): assert alice_wins_game(1, 2, 3) == \\"Bob\\" def test_large_numbers(): assert alice_wins_game(1000, 100, 10) == \\"Alice\\" def test_two_piles_zero(): assert alice_wins_game(3, 0, 0) == \\"Alice\\" def test_one_pile_zero(): assert alice_wins_game(0, 5, 5) == \\"Bob\\"","solution":"def alice_wins_game(A, B, C): Determines if Alice will win the game. Alice wins if the nim sum (A xor B xor C) is not zero. return \\"Alice\\" if (A ^ B ^ C) != 0 else \\"Bob\\""},{"question":"def process_operations(n: int, operations: List[str]) -> str: Process a sequence of operations on a document editor and return the final state of the document. The editor supports INSERT, DELETE, and UNDO operations. >>> process_operations(6, [\\"INSERT a\\", \\"INSERT b\\", \\"DELETE\\", \\"INSERT c\\", \\"UNDO\\", \\"INSERT d\\"]) 'ad' >>> process_operations(5, [\\"INSERT x\\", \\"INSERT y\\", \\"DELETE\\", \\"UNDO\\", \\"UNDO\\"]) 'x'","solution":"def process_operations(n, operations): document = [] history = [] for op in operations: if op.startswith(\\"INSERT\\"): _, char = op.split() document.append(char) history.append((\\"INSERT\\", char)) elif op == \\"DELETE\\": deleted_char = document.pop() history.append((\\"DELETE\\", deleted_char)) elif op == \\"UNDO\\": last_op, char = history.pop() if last_op == \\"INSERT\\": document.pop() elif last_op == \\"DELETE\\": document.append(char) return \\"\\".join(document)"},{"question":"import math from typing import List, Tuple def days_to_reach_height(initial_heights: List[int], H: int) -> List[int]: Returns a list of integers representing the number of days it takes for each plant to reach or exceed the height H. >>> days_to_reach_height([1, 2, 3], 10) [4, 3, 2] >>> days_to_reach_height([5, 10], 20) [2, 1] pass def process_test_cases(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[List[int]]: Processes the given number of test cases and returns the result for each plant in each test case. >>> process_test_cases(2, [ (3, [1, 2, 3], 10), (2, [5, 10], 20) ]) [[4, 3, 2], [2, 1]] >>> process_test_cases(1, [ (2, [1, 4], 1) ]) [[0, 0]] pass","solution":"import math def days_to_reach_height(initial_heights, H): Returns a list of integers representing the number of days it takes for each plant to reach or exceed the height H. days = [] for height in initial_heights: if height >= H: days.append(0) else: days.append(math.ceil(math.log2(H / height))) return days def process_test_cases(T, test_cases): Processes the given number of test cases and returns the result for each plant in each test case. results = [] for i in range(T): N = test_cases[i][0] initial_heights = test_cases[i][1] H = test_cases[i][2] results.append(days_to_reach_height(initial_heights, H)) return results"},{"question":"def can_form_balanced_teams(N: int, skill_levels: List[int]) -> str: Determine if at least one well-balanced team can be formed. Each student has an assigned skill level represented by an integer between 1 and 100. Teams are well balanced if the difference in skill levels between the most skilled student and the least skilled student in any team is no greater than 10. Marge must form teams of exactly three students. :param N: Number of students :param skill_levels: List of skill levels of the students :return: \\"YES\\" if at least one well-balanced team can be formed, otherwise \\"NO\\" >>> can_form_balanced_teams(5, [12, 15, 10, 22, 25]) 'YES' >>> can_form_balanced_teams(4, [10, 25, 40, 55]) 'NO'","solution":"def can_form_balanced_teams(N, skill_levels): Determine if at least one well-balanced team can be formed. :param N: Number of students :param skill_levels: List of skill levels of the students :return: \\"YES\\" if at least one well-balanced team can be formed, otherwise \\"NO\\" skill_levels.sort() for i in range(N - 2): if skill_levels[i+2] - skill_levels[i] <= 10: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Optional def find_majority_element(nums: List[int]) -> Optional[int]: Given a list of integers, find the majority element that appears more than ⌊n / 2⌋ times where n is the length of the list. If there is no majority element, return None. >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) 4 >>> find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) None def test_example_cases(): assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4, 4]) == 4 assert find_majority_element([3, 3, 4, 2, 4, 4, 2, 4]) == None def test_small_cases(): assert find_majority_element([1]) == 1 assert find_majority_element([1, 1, 2]) == 1 assert find_majority_element([1, 1, 2, 2, 2]) == 2 def test_no_majority(): assert find_majority_element([1, 2, 3, 4, 5]) == None assert find_majority_element([1, 2, 3, 1, 2, 3, 1, 2]) == None def test_all_same(): assert find_majority_element([2, 2, 2, 2]) == 2 def test_edge_cases(): assert find_majority_element([7, 8, 8, 8, 8, 7, 7, 7, 7]) == 7 assert find_majority_element([10, 10, 10, 10, 10, 10, 10, 10, 5, 6, 10]) == 10","solution":"from typing import List, Optional def find_majority_element(nums: List[int]) -> Optional[int]: candidate, count = None, 0 # Phase 1: Find a candidate for num in nums: if count == 0: candidate, count = num, 1 elif num == candidate: count += 1 else: count -= 1 # Phase 2: Verify the candidate count = 0 for num in nums: if num == candidate: count += 1 if count > len(nums) // 2: return candidate else: return None"},{"question":"from typing import List def min_steps(R: int, C: int, grid: List[str]) -> int: Determine the minimum number of steps required to reach the bottom-right corner from the top-left corner of a 2D grid. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. grid (List[str]): 2D grid represented as a list of strings where '.' denotes an empty cell and '#' denotes a wall. Returns: int: Minimum number of steps required to reach the bottom-right corner or -1 if it is not possible. Examples: >>> min_steps(5, 5, [\\".....\\", \\".#...\\", \\".#.#.\\", \\"...#.\\", \\"...\\"]) 8 >>> min_steps(2, 2, [\\".#\\", \\"#.\\"]) -1 def test_min_steps_simple_grid(): R = 5 C = 5 grid = [ \\".....\\", \\".#...\\", \\".#.#.\\", \\"...#.\\", \\"...\\" ] assert min_steps(R, C, grid) == 8 def test_min_steps_no_path(): R = 2 C = 2 grid = [ \\".#\\", \\"#.\\" ] assert min_steps(R, C, grid) == -1 def test_min_steps_blocked_start(): R = 3 C = 3 grid = [ \\"#..\\", \\"...\\", \\"..#\\" ] assert min_steps(R, C, grid) == -1 def test_min_steps_blocked_end(): R = 3 C = 3 grid = [ \\"...\\", \\"...\\", \\"..#\\" ] assert min_steps(R, C, grid) == -1 def test_min_steps_large_open_grid(): R = 3 C = 3 grid = [ \\"...\\", \\"...\\", \\"...\\" ] assert min_steps(R, C, grid) == 4 def test_min_steps_blocked_path(): R = 3 C = 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert min_steps(R, C, grid) == 4","solution":"from collections import deque def min_steps(R, C, grid): # Directions for moving up, down, left, and right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or ending point is a wall if grid[0][0] == '#' or grid[R-1][C-1] == '#': return -1 # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: row, col, steps = queue.popleft() # If we have reached the bottom-right corner if row == R-1 and col == C-1: return steps # Explore possible directions for dr, dc in directions: r, c = row + dr, col + dc if 0 <= r < R and 0 <= c < C and grid[r][c] == '.' and (r, c) not in visited: visited.add((r, c)) queue.append((r, c, steps + 1)) # If we exit the loop, it means we didn't find a way return -1 # Main function to read input def main(): import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) grid = [data[i + 2] for i in range(R)] result = min_steps(R, C, grid) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing non-negative integers and '+', '-', '*', '/' operators. The expression may include whitespace characters, which should be ignored. >>> evaluate_expression(\\"3+2*2\\") 7 >>> evaluate_expression(\\" 3/2 \\") 1 >>> evaluate_expression(\\" 3+5 / 2 \\") 5 from solution import evaluate_expression def test_evaluate_expression_1(): assert evaluate_expression(\\"3+2*2\\") == 7 def test_evaluate_expression_2(): assert evaluate_expression(\\" 3/2 \\") == 1 def test_evaluate_expression_3(): assert evaluate_expression(\\" 3+5 / 2 \\") == 5 def test_evaluate_expression_with_multiple_spaces(): assert evaluate_expression(\\" 3 + 5/2 \\") == 5 def test_evaluate_expression_with_chain_operations(): assert evaluate_expression(\\"12+3*4-6/2\\") == 21 def test_evaluate_expression_with_trailing_spaces(): assert evaluate_expression(\\"3 + 5 * 2 \\") == 13","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing non-negative integers and '+', '-', '*', '/' operators. The expression may include whitespace characters which should be ignored. # Remove all whitespace characters expression = expression.replace(\\" \\", \\"\\") stack = [] num = 0 sign = '+' for i, char in enumerate(expression): if char.isdigit(): num = num * 10 + int(char) if char in \\"+-*/\\" or i == len(expression) - 1: if sign == '+': stack.append(num) elif sign == '-': stack.append(-num) elif sign == '*': stack[-1] = stack[-1] * num elif sign == '/': stack[-1] = int(stack[-1] / num) # Truncate towards zero sign = char num = 0 return sum(stack)"},{"question":"def change_bits(s, k): Find the smallest binary number greater than s where the number of bits to be changed is exactly k. Args: s (str): A binary string. k (int): Number of bits to change. Returns: str: The smallest binary number greater than s with exactly k bits changed. pass # Example # >>> change_bits(\\"1010\\", 1) # \\"1011\\" # >>> change_bits(\\"0000\\", 2) # \\"0011\\" from solution import change_bits def test_change_bits_case1(): assert change_bits(\\"1010\\", 1) == \\"1011\\" def test_change_bits_case2(): assert change_bits(\\"0000\\", 2) == \\"0011\\" def test_change_bits_no_change(): assert change_bits(\\"1111\\", 0) == \\"1111\\" def test_change_bits_one_change(): assert change_bits(\\"1110\\", 1) == \\"1111\\" def test_change_bits_all_zeroes(): assert change_bits(\\"0000\\", 4) == \\"1111\\" def test_change_bits_with_more_zeroes(): assert change_bits(\\"00000\\", 3) == \\"00111\\" def test_change_bits_mixed_bits(): assert change_bits(\\"11010\\", 2) == \\"11111\\" def test_change_bits_leading_zeroes(): assert change_bits(\\"0011\\", 1) == \\"0111\\"","solution":"def change_bits(s, k): Find the smallest binary number greater than s where the number of bits to be changed is exactly k. Args: s (str): A binary string. k (int): Number of bits to change. Returns: str: The smallest binary number greater than s with exactly k bits changed. binary_num = list(s) n = len(binary_num) for i in range(n-1, -1, -1): if binary_num[i] == '0': binary_num[i] = '1' k -= 1 if k == 0: break # If more flips are needed, convert '1' to '0' from the end for i in range(n-1, -1, -1): if k == 0: break if binary_num[i] == '1' and s[i] == '1': binary_num[i] = '0' k -= 1 return ''.join(binary_num)"},{"question":"def is_anagram(s1, s2): Determines if two strings are anagrams of each other. Parameters: s1 (str): First string. s2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. >>> is_anagram(\\"listen\\", \\"silent\\") True >>> is_anagram(\\"hello\\", \\"billion\\") False >>> is_anagram(\\"evil\\", \\"vile\\") True >>> is_anagram(\\"apple\\", \\"pale\\") False >>> is_anagram(\\"123\\", \\"321\\") True","solution":"def is_anagram(s1, s2): Determines if two strings are anagrams of each other. Parameters: s1 (str): First string. s2 (str): Second string. Returns: bool: True if the strings are anagrams, False otherwise. from collections import Counter return Counter(s1) == Counter(s2)"},{"question":"def max_gold(grid): Calculate the maximum amount of gold that can be collected on the way from the top-left to the bottom-right cell in the grid. Parameters: grid (List[List[int]]): A 2D list representing the grid, where each cell contains a non-negative integer representing the amount of gold. Returns: int: The maximum amount of gold that can be collected. Example: >>> max_gold([ ... [1, 3, 1], ... [1, 5, 1], ... [4, 2, 1] ... ]) == 12 >>> max_gold([[5]]) == 5 >>> max_gold([ ... [1, 2], ... [3, 4] ... ]) == 8 >>> max_gold([ ... [0, 0, 0], ... [0, 5, 0], ... [0, 0, 0] ... ]) == 5 >>> max_gold([ ... [10000, 10000, 10000], ... [10000, 10000, 10000], ... [10000, 10000, 10000] ... ]) == 50000","solution":"def max_gold(grid): n = len(grid) if n == 0 or len(grid[0]) == 0: return 0 dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1]"},{"question":"def min_attacks_to_defeat_monsters(n: int, healths: List[int]) -> int: Returns the minimum number of attacks required to defeat all monsters. >>> min_attacks_to_defeat_monsters(3, [1, 2, 3]) == 2 >>> min_attacks_to_defeat_monsters(4, [2, 2, 2, 2]) == 3 >>> min_attacks_to_defeat_monsters(1, [10]) == 0 >>> min_attacks_to_defeat_monsters(5, [5, 5, 5, 5, 5]) == 4 >>> min_attacks_to_defeat_monsters(5, [1, 3, 2, 6, 5]) == 4 >>> min_attacks_to_defeat_monsters(3, [1000000000, 999999999, 1000000000]) == 2","solution":"def min_attacks_to_defeat_monsters(n, healths): Returns the minimum number of attacks required to defeat all monsters. # Sort the healths in descending order healths.sort(reverse=True) # The key observation is that we can defeat the strongest monster first # and distribute its health to the remaining monsters. # Hence, the number of attacks needed is simply the length of the healths array - 1 return n - 1"},{"question":"def is_possible_to_travel(n, m, roads, s, T): Determine whether there is a way for a traveler to start at a given POI, visit all other POIs, and return to the start POI with the total travel time less than or equal to a given threshold. Args: n (int): Number of POIs. m (int): Number of roads. roads (List[Tuple[int, int, int]]): List of roads, each defined by start POI, end POI, and travel time. s (int): Starting POI. T (int): Maximum allowable total travel time. Returns: str: \\"POSSIBLE\\" if such a path exists, otherwise \\"IMPOSSIBLE\\". Examples: >>> is_possible_to_travel(4, 5, [(1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 1, 40), (1, 3, 15)], 1, 100) \\"POSSIBLE\\" >>> is_possible_to_travel(3, 3, [(1, 2, 10), (2, 3, 20), (3, 1, 30)], 1, 50) \\"IMPOSSIBLE\\" pass # Unit Tests def test_case_1(): roads = [ (1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 1, 40), (1, 3, 15) ] assert is_possible_to_travel(4, 5, roads, 1, 100) == \\"POSSIBLE\\" def test_case_2(): roads = [ (1, 2, 10), (2, 3, 20), (3, 1, 30) ] assert is_possible_to_travel(3, 3, roads, 1, 50) == \\"IMPOSSIBLE\\" def test_case_3(): roads = [ (1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 1, 5), (1, 3, 5), (3, 2, 5), (2, 4, 5) ] assert is_possible_to_travel(4, 7, roads, 1, 25) == \\"POSSIBLE\\" def test_case_4(): roads = [ (1, 2, 1), (2, 3, 1), (3, 1, 2) ] assert is_possible_to_travel(3, 3, roads, 1, 10) == \\"POSSIBLE\\" def test_case_5(): roads = [ (1, 2, 50), (2, 3, 50), (3, 4, 50), (4, 5, 50), (5, 1, 50) ] assert is_possible_to_travel(5, 5, roads, 1, 200) == \\"IMPOSSIBLE\\"","solution":"import itertools def is_possible_to_travel(n, m, roads, s, T): Returns \\"POSSIBLE\\" if there is a path that visits all POIs exactly once and returns to the start POI within the allowed travel time and otherwise returns \\"IMPOSSIBLE\\". graph = {i: [] for i in range(1, n + 1)} for xi, yi, ti in roads: graph[xi].append((yi, ti)) def dfs(path, current, cost): if len(path) == n: # Check if we can return to the starting point for dest, travel_time in graph[current]: if dest == s: if cost + travel_time <= T: return True return False for dest, travel_time in graph[current]: if dest not in path and cost + travel_time <= T: if dfs(path + [dest], dest, cost + travel_time): return True return False return \\"POSSIBLE\\" if dfs([s], s, 0) else \\"IMPOSSIBLE\\" # Example usage roads1 = [ (1, 2, 10), (2, 3, 20), (3, 4, 30), (4, 1, 40), (1, 3, 15) ] print(is_possible_to_travel(4, 5, roads1, 1, 100)) # Output: \\"POSSIBLE\\" roads2 = [ (1, 2, 10), (2, 3, 20), (3, 1, 30) ] print(is_possible_to_travel(3, 3, roads2, 1, 50)) # Output: \\"IMPOSSIBLE\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head: ListNode) -> bool: Determine if the linked list has a cycle. >>> head = ListNode(3) >>> second = ListNode(2) >>> head.next = second >>> third = ListNode(0) >>> second.next = third >>> fourth = ListNode(-4) >>> third.next = fourth >>> fourth.next = second >>> hasCycle(head) True >>> head = ListNode(1) >>> second = ListNode(2) >>> head.next = second >>> second.next = head >>> hasCycle(head) True >>> head = ListNode(1) >>> hasCycle(head) False >>> hasCycle(None) False pass import pytest def test_cycle_in_middle(): # Creating a cycle in the list [3,2,0,-4] head = ListNode(3) second = ListNode(2) head.next = second third = ListNode(0) second.next = third fourth = ListNode(-4) third.next = fourth # forming cycle fourth.next = second assert hasCycle(head) == True def test_cycle_at_start(): # Creating a cycle in the list [1, 2] where second node points back to first head = ListNode(1) second = ListNode(2) head.next = second # forming cycle second.next = head assert hasCycle(head) == True def test_no_cycle_single_node(): # Single node [1] without cycle head = ListNode(1) assert hasCycle(head) == False def test_no_cycle_multiple_nodes(): # List [1,2,3,4] without cycle head = ListNode(1) second = ListNode(2) third = ListNode(3) fourth = ListNode(4) head.next = second second.next = third third.next = fourth assert hasCycle(head) == False def test_empty_list(): # Empty list head = None assert hasCycle(head) == False def test_cycle_single_node(): # Single node with a cycle to itself head = ListNode(1) head.next = head assert hasCycle(head) == True","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def hasCycle(head: ListNode) -> bool: Determine if the linked list has a cycle. Uses Floyd's Tortoise and Hare algorithm. :param head: ListNode, the head of the linked list :return: bool, True if there is a cycle, False otherwise. if not head or not head.next: return False slow = head fast = head while fast and fast.next: slow = slow.next # move slow pointer one step fast = fast.next.next # move fast pointer two steps if slow == fast: return True return False"},{"question":"def can_reach_final_town(T: int, test_cases: List[Tuple[int, str, List[int]]]) -> List[str]: Determine if Aadesh can reach the final town given the initial status of each town's traffic light and the maximum number of cars allowed per town. Example: >>> can_reach_final_town(2, [(3, 'GRG', [1, 2, 3]), (4, 'RGRG', [1, 1, 1, 1])]) [\\"YES\\", \\"NO\\"] >>> can_reach_final_town(1, [(4, 'GGGG', [1, 0, 3, 2])]) [\\"NO\\"] >>> can_reach_final_town(1, [(3, 'GGG', [1, 2, 3])]) [\\"YES\\"]","solution":"def can_reach_final_town(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] traffic_lights = test_cases[i][1] max_cars = test_cases[i][2] can_reach = True for j in range(N): if traffic_lights[j] == 'R': can_reach = False break if max_cars[j] <= 0: can_reach = False break if can_reach: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_subarray_sum(arr, k): Returns the maximum sum of any contiguous subarray of size k. :param arr: List of integers :param k: Positive integer indicating the size of the subarray :return: Maximum sum of a contiguous subarray of size k >>> max_subarray_sum([1, 12, -5, -6, 50, 3], 4) == 51 >>> max_subarray_sum([2, 3, 4, 1, 5], 3) == 10 >>> max_subarray_sum([1, 1, 1, 1, 1, 1], 2) == 2 >>> max_subarray_sum([5], 1) == 5 >>> max_subarray_sum([2, 4, 6, 8, 10, 12, 14], 7) == 56 >>> max_subarray_sum([1, 2, 3, 4, 5, 6, 7, 8, 9], 5) == 35","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any contiguous subarray of size k. :param arr: List of integers :param k: Positive integer indicating the size of the subarray :return: Maximum sum of a contiguous subarray of size k # Ensure the array has at least k elements n = len(arr) if n < k: return None # Initial sum of the first window max_sum = sum(arr[:k]) current_sum = max_sum # Slide the window over the array for i in range(k, n): current_sum += arr[i] - arr[i - k] max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def max_temperature_difference(test_cases): Determines the maximum difference in temperatures for multiple test cases. Parameters: test_cases (list of list of tuple): Each element is a test case, which is a list of tuples with highest and lowest temperatures. Returns: list of int: The maximum temperature difference for each test case. pass def parse_input(input_str): Parses the input string into a structured format for processing. Parameters: input_str (str): The input string to be parsed. Returns: tuple: A tuple containing the number of test cases and a list of test cases. pass def process(input_str): Processes the input string and returns the results for each test case. Parameters: input_str (str): The input string to be processed. Returns: list of int: The results of the processed input. pass","solution":"def max_temperature_difference(test_cases): Determines the maximum difference in temperatures for multiple test cases. Parameters: test_cases (list of list of tuple): Each element is a test case, which is a list of tuples with highest and lowest temperatures. Returns: list of int: The maximum temperature difference for each test case. results = [] for days in test_cases: max_temp = max(day[0] for day in days) min_temp = min(day[1] for day in days) results.append(max_temp - min_temp) return results def parse_input(input_str): Parses the input string into a structured format for processing. Parameters: input_str (str): The input string to be parsed. Returns: tuple: A tuple containing the number of test cases and a list of test cases. lines = input_str.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): n = int(lines[index]) index += 1 days = [] for _ in range(n): Hi, Li = map(int, lines[index].split()) days.append((Hi, Li)) index += 1 test_cases.append(days) return T, test_cases def process(input_str): Processes the input string and returns the results for each test case. Parameters: input_str (str): The input string to be processed. Returns: list of int: The results of the processed input. T, test_cases = parse_input(input_str) return max_temperature_difference(test_cases)"},{"question":"def count_pairs_divisible_by_k(n: int, k: int, nums: List[int]) -> int: Given an integer array nums and an integer k, determine the number of pairs (i, j) where nums[i] + nums[j] is divisible by k and i < j. Args: n : int : The number of elements in the array. k : int : The integer by which the sum of pairs should be divisible. nums : List[int] : The list of integers. Returns: int : The number of pairs (i, j) where nums[i] + nums[j] is divisible by k. Examples: >>> count_pairs_divisible_by_k(5, 3, [1, 3, 2, 6, 9]) 4 >>> count_pairs_divisible_by_k(4, 3, [1, 1, 1, 1]) 0 >>> count_pairs_divisible_by_k(4, 2, [2, 4, 6, 8]) 6 >>> count_pairs_divisible_by_k(6, 5, [5, 10, 5, 10, 5, 10]) 15 >>> count_pairs_divisible_by_k(5, 10, [10, 20, 30, 40, 50]) 10","solution":"def count_pairs_divisible_by_k(n, k, nums): Returns the number of pairs (i, j) where nums[i] + nums[j] is divisible by k and i < j. count = 0 # Create a remainder frequency array to store the counts of every remainder when divided by k remainder_freq = [0] * k for num in nums: remainder = num % k complement = (k - remainder) % k count += remainder_freq[complement] remainder_freq[remainder] += 1 return count"},{"question":"def unique_paths(n: int, m: int) -> int: Calculate the number of unique paths from the northwest corner (0, 0) to the southeast corner (n, m) of a grid. The pedestrian can only move either right or down at any point in time. The result should be returned modulo 10^9 + 7. >>> unique_paths(2, 2) 6 >>> unique_paths(0, 0) 1 >>> unique_paths(3, 3) 20 >>> unique_paths(5, 4) 126 from solution import unique_paths def test_unique_paths_small_grids(): assert unique_paths(2, 2) == 6 assert unique_paths(1, 2) == 3 assert unique_paths(2, 1) == 3 def test_unique_paths_zero_cases(): assert unique_paths(0, 0) == 1 assert unique_paths(0, 5) == 1 assert unique_paths(5, 0) == 1 def test_unique_paths_large_grids(): assert unique_paths(3, 3) == 20 assert unique_paths(5, 4) == 126 def test_unique_paths_very_large_grids(): n = 1000000 m = 1000000 result = unique_paths(n, m) # It is not practical to manually verify such large computations, so we expect # the function to return something and we would need to use specialized libraries # or other methods for further verification. assert result is not None def test_unique_paths_additional_cases(): assert unique_paths(10, 10) == 184756 assert unique_paths(1, 1) == 2 assert unique_paths(3, 2) == 10","solution":"def unique_paths(n, m): MOD = 10**9 + 7 if n == 0 or m == 0: return 1 # Compute factorial(n + m) % MOD factorial = [1] * (n + m + 1) for i in range(2, n + m + 1): factorial[i] = factorial[i - 1] * i % MOD # Compute the inverse of factorial(n) % MOD using Fermat's Little Theorem def mod_inverse(x, p): return pow(x, p - 2, p) # nCr % MOD = factorial(n) / (factorial(r) * factorial(n - r)) % MOD nCr = factorial[n + m] * mod_inverse(factorial[n], MOD) % MOD * mod_inverse(factorial[m], MOD) % MOD return nCr"},{"question":"def prime_spell_operations(n, array, operations): Perform prime spell operations on an array. Args: n (int): The number of elements in the array. array (List[int]): The list of integers representing the array. operations (List[List[int]]): A list of operations to perform on the array. Returns: List[int]: The results of all spell potency operations. Examples: >>> prime_spell_operations(4, [3, 2, 5, 7], [[2, 1, 3, 2], [1, 3, 4], [2, 1, 4, 3]]) [38, 442] >>> prime_spell_operations(1, [10], [[2, 1, 1, 2], [1, 1, 5], [2, 1, 1, 3]]) [100, 125] >>> prime_spell_operations(5, [1, 1, 1, 1, 1], [[1, 1, 2], [1, 2, 3], [1, 3, 4], [1, 4, 5], [1, 5, 6], [2, 1, 5, 2]]) [90] results = [] def power_operation(x, v): array[x - 1] = v def spell_potency_operation(l, r, p): s = sum(x ** p for x in array[l-1:r]) results.append(s) for op in operations: if op[0] == 1: power_operation(op[1], op[2]) elif op[0] == 2: spell_potency_operation(op[1], op[2], op[3]) return results","solution":"def prime_spell_operations(n, array, operations): results = [] def power_operation(x, v): array[x - 1] = v def spell_potency_operation(l, r, p): s = sum(x ** p for x in array[l-1:r]) results.append(s) for op in operations: if op[0] == 1: power_operation(op[1], op[2]) elif op[0] == 2: spell_potency_operation(op[1], op[2], op[3]) return results"},{"question":"def can_borrow_book(library: dict, user_quota: dict, user_books_borrowed: dict, requested_genre: str) -> bool: Determines if a user can borrow a book from the requested genre. Parameters: - library: dictionary with keys as genres and values as the number of books available in that genre. - user_quota: dictionary with keys as genres and values as the maximum number of books the user is allowed to borrow from that genre. - user_books_borrowed: dictionary with keys as genres and values as the number of books the user has already borrowed from that genre. - requested_genre: string representing the genre of the book the user wants to borrow. Returns: - boolean value: True if the user can borrow a book from the requested genre, False otherwise. >>> library = {\\"Fantasy\\": 10, \\"History\\": 5, \\"Science\\": 2} >>> user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} >>> user_books_borrowed = {\\"Fantasy\\": 1, \\"History\\": 2, \\"Science\\": 0} >>> can_borrow = can_borrow_book(library, user_quota, user_books_borrowed, \\"Fantasy\\") >>> can_borrow True >>> library = {\\"Fantasy\\": 10, \\"History\\": 5, \\"Science\\": 2} >>> user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} >>> user_books_borrowed = {\\"Fantasy\\": 1, \\"History\\": 2, \\"Science\\": 0} >>> can_borrow = can_borrow_book(library, user_quota, user_books_borrowed, \\"History\\") >>> can_borrow False pass def test_can_borrow_book(): # Test case 1: Can borrow a book library = {\\"Fantasy\\": 10, \\"History\\": 5, \\"Science\\": 2} user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} user_books_borrowed = {\\"Fantasy\\": 1, \\"History\\": 2, \\"Science\\": 0} requested_genre = \\"Fantasy\\" assert can_borrow_book(library, user_quota, user_books_borrowed, requested_genre) == True # Test case 2: Cannot borrow due to exceeding quota library = {\\"Fantasy\\": 10, \\"History\\": 5, \\"Science\\": 2} user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} user_books_borrowed = {\\"Fantasy\\": 1, \\"History\\": 2, \\"Science\\": 0} requested_genre = \\"History\\" assert can_borrow_book(library, user_quota, user_books_borrowed, requested_genre) == False # Test case 3: Cannot borrow due to no books available in library library = {\\"Fantasy\\": 10, \\"History\\": 0, \\"Science\\": 2} user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} user_books_borrowed = {\\"Fantasy\\": 1, \\"History\\": 1, \\"Science\\": 0} requested_genre = \\"History\\" assert can_borrow_book(library, user_quota, user_books_borrowed, requested_genre) == False # Test case 4: Cannot borrow due to non-existent genre in library library = {\\"Fantasy\\": 10, \\"History\\": 5, \\"Science\\": 2} user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} user_books_borrowed = {\\"Fantasy\\": 1, \\"History\\": 1, \\"Science\\": 0} requested_genre = \\"Romance\\" assert can_borrow_book(library, user_quota, user_books_borrowed, requested_genre) == False # Test case 5: Can borrow the last book in the genre library = {\\"Fantasy\\": 1, \\"History\\": 5, \\"Science\\": 2} user_quota = {\\"Fantasy\\": 3, \\"History\\": 2, \\"Science\\": 1} user_books_borrowed = {\\"Fantasy\\": 0, \\"History\\": 1, \\"Science\\": 1} requested_genre = \\"Fantasy\\" assert can_borrow_book(library, user_quota, user_books_borrowed, requested_genre) == True # Test case 6: Cannot borrow because user quota for the requested genre is zero library = {\\"Fantasy\\": 10, \\"History\\": 5, \\"Science\\": 2} user_quota = {\\"Fantasy\\": 0, \\"History\\": 2, \\"Science\\": 1} user_books_borrowed = {\\"Fantasy\\": 0, \\"History\\": 1, \\"Science\\": 0} requested_genre = \\"Fantasy\\" assert can_borrow_book(library, user_quota, user_books_borrowed, requested_genre) == False","solution":"def can_borrow_book(library, user_quota, user_books_borrowed, requested_genre): Determines if a user can borrow a book from the requested genre. Parameters: - library: dictionary with keys as genres and values as the number of books available in that genre. - user_quota: dictionary with keys as genres and values as the maximum number of books the user is allowed to borrow from that genre. - user_books_borrowed: dictionary with keys as genres and values as the number of books the user has already borrowed from that genre. - requested_genre: string representing the genre of the book the user wants to borrow. Returns: - boolean value: True if the user can borrow a book from the requested genre, False otherwise. # Check if requested genre is in library and user quota if requested_genre not in library or requested_genre not in user_quota: return False # Check if user has already borrowed the maximum allowed number of books for the requested genre if user_books_borrowed.get(requested_genre, 0) >= user_quota[requested_genre]: return False # Check if there are books available in the requested genre in the library if library[requested_genre] == 0: return False return True"},{"question":"def maximize_gold(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Given the number of buildings, the number of redistributions allowed, and the initial distribution of gold coins in the buildings, determine the maximum number of gold coins that can be accumulated in the last building if the developer acts optimally. Args: t (int): The number of test cases. test_cases (List[Tuple[Tuple[int, int], List[int]]]): A list of tuples where each tuple contains: - A tuple of two integers representing the number of buildings (n) and the number of redistributions allowed (d). - A list of integers representing the initial number of gold coins in each building. Returns: List[int]: A list of integers where each integer is the maximum number of gold coins in the last building for each test case. >>> maximize_gold(1, [((4, 3), [2, 1, 0, 4])]) [5] >>> maximize_gold(2, [((4, 3), [2, 1, 0, 4]), ((5, 4), [1, 2, 3, 4, 5])]) [5, 6]","solution":"def maximize_gold(t, test_cases): results = [] for _ in range(t): n, d = test_cases[_][0] buildings = test_cases[_][1] for i in range(n - 1): # Determine the max coins we can move from buildings[i] to buildings[i + 1]. moves = min(buildings[i], d // (n - 1 - i)) buildings[i] -= moves buildings[-1] += moves d -= moves * (n - 1 - i) results.append(buildings[-1]) return results"},{"question":"def findDifferenceExists(a: List[int], k: int) -> str: Determines if there are two integers in the array whose difference is equal to the target integer k. Args: a (list of int): the array of integers k (int): the target difference Returns: string: \\"YES\\" if such a pair exists, otherwise \\"NO\\" >>> findDifferenceExists([1, 5, 3, 4, 2], 3) == \\"YES\\" >>> findDifferenceExists([1, 2, 3, 4, 5], 10) == \\"NO\\" >>> findDifferenceExists([8, 12, 16, 4, 0], 4) == \\"YES\\" >>> findDifferenceExists([5, 20, 3, 2, 50, 80], 78) == \\"YES\\" >>> findDifferenceExists([90, 70, 20, 80, 50], 45) == \\"NO\\" >>> findDifferenceExists([1, 1, 1, 1, 1], 0) == \\"YES\\" >>> findDifferenceExists([-1, -5, -3, -4, -2], 3) == \\"YES\\" >>> findDifferenceExists([1, 2], 1) == \\"YES\\" >>> findDifferenceExists([1, 2], 3) == \\"NO\\" >>> findDifferenceExists([0, 0], 0) == \\"YES\\" >>> findDifferenceExists([-1, 1], 2) == \\"YES\\" # Your code here","solution":"def findDifferenceExists(a, k): Determines if there are two integers in the array whose difference is equal to the target integer k. Args: a (list of int): the array of integers k (int): the target difference Returns: string: \\"YES\\" if such a pair exists, otherwise \\"NO\\" # Use a set tto store the elements of the array seen = set() for number in a: # Check if the (number + k) or (number - k) exists in the set if (number + k) in seen or (number - k) in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def min_distribution_centers(n, k, delivery_points): Calculates the minimum number of distribution centers required. :param n: int - number of delivery points :param k: int - maximum distance a delivery point can be from a distribution center :param delivery_points: list of int - coordinates of the delivery points :return: int - minimum number of distribution centers required >>> min_distribution_centers(6, 2, [1, 2, 3, 7, 8, 9]) 2 >>> min_distribution_centers(5, 1, [10, 20, 30, 40, 50]) 5 >>> min_distribution_centers(3, 10, [1, 11, 21]) 1 >>> min_distribution_centers(4, 0, [1, 2, 3, 4]) 4 >>> min_distribution_centers(1, 10, [5]) 1","solution":"def min_distribution_centers(n, k, delivery_points): Calculates the minimum number of distribution centers required. :param n: int - number of delivery points :param k: int - maximum distance a delivery point can be from a distribution center :param delivery_points: list of int - coordinates of the delivery points :return: int - minimum number of distribution centers required if n == 0: return 0 delivery_points.sort() centers_needed = 0 i = 0 while i < n: centers_needed += 1 location = delivery_points[i] + k # Place a center within k distance from the current position while i < n and delivery_points[i] <= location: i += 1 # Skip all delivery points within k distance of the placed center if i < n: location = delivery_points[i - 1] + k # Adjust the location to ensure all points are within range while i < n and delivery_points[i] <= location: i += 1 # Continue to skip all delivery points within the adjusted range return centers_needed"},{"question":"def is_valid_grid(n, m, grid): Given a grid of characters ('B', 'W', 'X'), check if all 'X' can be colored such that no two adjacent cells (horizontally or vertically) have the same color. Returns True if possible, otherwise False. # Your code here pass def process_input(input_string): Processes the input and determines if each grid can be colored according to the rules. Returns a string with each test case result on a new line (\\"YES\\" or \\"NO\\"). >>> input_string = '''3 4 BWBW WXWX BWBW 2 2 BB WW 0 0 ''' >>> expected_output = '''YES NO''' >>> process_input(input_string) == expected_output True >>> input_string = '''1 1 X 0 0 ''' >>> process_input(input_string) == 'YES' True # Your code here pass","solution":"def is_valid_grid(n, m, grid): for i in range(n): for j in range(m): if grid[i][j] == 'X': # X can be either B or W; we check if both options violate any rule alternate_1 = 'B' alternate_2 = 'W' if (i > 0 and grid[i - 1][j] == alternate_1) or (j > 0 and grid[i][j - 1] == alternate_1): alternate_1 = 'W' if (i > 0 and grid[i - 1][j] == alternate_2) or (j > 0 and grid[i][j - 1] == alternate_2): alternate_2 = 'B' grid[i][j] = alternate_1 if (i < n - 1 and grid[i + 1][j] == grid[i][j]) or (j < m - 1 and grid[i][j + 1] == grid[i][j]): grid[i][j] = alternate_2 if (i < n - 1 and grid[i + 1][j] == grid[i][j]) or (j < m - 1 and grid[i][j + 1] == grid[i][j]): return False for i in range(n): for j in range(m): if (i < n - 1 and grid[i + 1][j] == grid[i][j]) or (j < m - 1 and grid[i][j + 1] == grid[i][j]): return False return True def process_input(input_string): input_lines = input_string.strip().split('n') index = 0 results = [] while index < len(input_lines): n, m = map(int, input_lines[index].split()) if n == 0 and m == 0: break grid = [list(input_lines[index + 1 + i]) for i in range(n)] index += 1 + n if is_valid_grid(n, m, grid): results.append(\\"YES\\") else: results.append(\\"NO\\") return \\"n\\".join(results)"},{"question":"def max_presentations(n: int, presentations: List[Tuple[int, int]]) -> int: Given the number of presentations and their start and end times, this function returns the maximum number of non-overlapping presentations that can be attended. Parameters: - n: int - number of presentations - presentations: List[Tuple[int, int]] - List of tuples where each tuple denotes (start, end) times Returns: - int - maximum number of non-overlapping presentations >>> max_presentations(5, [(1, 3), (2, 5), (4, 6), (6, 8), (6, 7)]) 3 >>> max_presentations(3, [(1, 4), (2, 5), (3, 6)]) 1 >>> max_presentations(3, [(1, 2), (2, 3), (3, 4)]) 3 >>> max_presentations(4, [(1, 2), (2, 4), (3, 5), (5, 8)]) 3 >>> max_presentations(0, []) 0 >>> max_presentations(1, [(1, 100)]) 1","solution":"def max_presentations(n, presentations): Given the number of presentations and their start and end times, this function returns the maximum number of non-overlapping presentations that can be attended. Parameters: - n: int - number of presentations - presentations: List[Tuple[int, int]] - List of tuples where each tuple denotes (start, end) times Returns: - int - maximum number of non-overlapping presentations if not presentations: return 0 # Sort presentations by their end times presentations.sort(key=lambda x: x[1]) count = 1 end_time = presentations[0][1] for i in range(1, n): if presentations[i][0] >= end_time: count += 1 end_time = presentations[i][1] return count"},{"question":"def competition(operations): Simulate a series of competitions among neighborhood teams. Arguments: operations : tuple : A tuple that contains the number of teams (N), the number of operations (Q), a list of initial strengths of the teams (S), and a list of operations. Returns: list : A list of results from Type 1 and Type 3 operations. Example: >>> operations = (4, 5, [10, 15, 20, 25], [[1, 1, 2], [2, 3, 30], [1, 3, 4], [3, 3], [1, 1, 3]]) >>> competition(operations) [2, 3, 30, 3] # Write the function implementation here. # Unit Test def test_competition(): operations = ( 4, 5, [10, 15, 20, 25], [ [1, 1, 2], [2, 3, 30], [1, 3, 4], [3, 3], [1, 1, 3] ] ) result = competition(operations) assert result == [2, 3, 30, 3] def test_update_strength(): operations = ( 3, 3, [10, 20, 30], [ [2, 1, 25], [1, 1, 2], [3, 1] ] ) result = competition(operations) assert result == [1, 25] def test_retrieve_strength(): operations = ( 3, 2, [15, 25, 35], [ [3, 1], [3, 3] ] ) result = competition(operations) assert result == [15, 35] def test_multiple_updates_and_competitions(): operations = ( 5, 6, [5, 10, 15, 20, 25], [ [2, 2, 30], [1, 2, 3], [2, 4, 35], [1, 4, 5], [2, 1, 50], [1, 1, 5] ] ) result = competition(operations) assert result == [2, 4, 1]","solution":"def competition(operations): n, q, strengths, ops = operations results = [] for op in ops: if op[0] == 1: u, v = op[1] - 1, op[2] - 1 if strengths[u] > strengths[v]: results.append(u + 1) else: results.append(v + 1) elif op[0] == 2: i, x = op[1] - 1, op[2] strengths[i] = x elif op[0] == 3: i = op[1] - 1 results.append(strengths[i]) return results"},{"question":"def shortest_path_bfs(n: int, m: int, edges: List[Tuple[int, int]], s: int) -> List[int]: Calculate the shortest path (in terms of number of edges) from a specified starting node to all other nodes in the graph using BFS. >>> shortest_path_bfs(6, 7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 5), (4, 6), (5, 6)], 1) [0, 1, 1, 2, 2, 3] >>> shortest_path_bfs(1, 0, [], 1) [0] >>> shortest_path_bfs(5, 2, [(1, 2), (3, 4)], 1) [0, 1, -1, -1, -1] >>> shortest_path_bfs(4, 0, [], 2) [-1, 0, -1, -1] >>> shortest_path_bfs(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)], 1) [0, 1, 2, 1]","solution":"from collections import deque, defaultdict def shortest_path_bfs(n, m, edges, s): graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) distances = [-1] * (n + 1) # Initialize distances as -1 for all nodes distances[s] = 0 # Distance to start node is 0 queue = deque([s]) while queue: current = queue.popleft() for neighbor in graph[current]: if distances[neighbor] == -1: # If not visited distances[neighbor] = distances[current] + 1 queue.append(neighbor) return distances[1:] # Return the distances starting from node 1"},{"question":"import string def char_count(s: str) -> dict: Write a function that takes a string as input and returns a dictionary with the count of each character in the string. Ignore any punctuation marks and treat uppercase and lowercase characters as the same. >>> char_count(\\"abc\\") == {'a': 1, 'b': 1, 'c': 1} >>> char_count(\\"aAbBcC\\") == {'a': 2, 'b': 2, 'c': 2} >>> char_count(\\"Hello, World!\\") == {'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1} >>> char_count(\\"\\") == {} >>> char_count(\\"123 abc 456 def 789\\") == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1, 'f': 1} >>> char_count(\\"aaaaaaa\\") == {'a': 7} >>> char_count(\\"Python 3.8!\\") == {'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}","solution":"import string def char_count(s): Returns a dictionary with the count of each character in the string. Ignores punctuation and treats uppercase and lowercase characters as the same. # Convert to lowercase to handle case insensitivity s = s.lower() # Create a dictionary to store character counts count_dict = {} for char in s: if char.isalpha(): # Consider only alphabetic characters if char in count_dict: count_dict[char] += 1 else: count_dict[char] = 1 return count_dict"},{"question":"from typing import List, Tuple, Optional def find_pair_with_sum(nums: List[int], target: int) -> Optional[Tuple[int, int]]: Given a list of integers, returns a tuple (i, j) of indices where the sum of nums[i] + nums[j] equals target. If no such pair exists, returns None. >>> find_pair_with_sum([2, 7, 11, 15], 9) (0, 1) >>> find_pair_with_sum([1, 2, 3, 4, 5], 10) None def process_test_cases(test_cases: List[dict]) -> List[Optional[Tuple[int, int]]]: Given a list of test cases, process each and return the results. Each test case is a dictionary with keys: 'n', 'nums', and 'target'. >>> process_test_cases([ ... {'n': 4, 'nums': [2, 7, 11, 15], 'target': 9}, ... {'n': 5, 'nums': [1, 2, 3, 4, 5], 'target': 10} ... ]) [(0, 1), None]","solution":"def find_pair_with_sum(nums, target): Given a list of integers, returns a tuple (i, j) of indices where the sum of nums[i] + nums[j] equals target. If no such pair exists, returns None. nums_map = {} for i, num in enumerate(nums): complement = target - num if complement in nums_map: return (nums_map[complement], i) nums_map[num] = i return None def process_test_cases(test_cases): Given a list of test cases, process each and return the results. Each test case is a dictionary with keys: 'n', 'nums', and 'target'. results = [] for case in test_cases: result = find_pair_with_sum(case['nums'], case['target']) results.append(result) return results"},{"question":"def shiftString(s: str, k: int) -> str: Shifts each character in the string \`s\` by \`k\` positions in the alphabet. Args: s (str): The input string containing only lowercase English letters. k (int): The number of positions to shift each character. Positive for right shift, negative for left shift. Returns: str: The shifted string. Examples: >>> shiftString(\\"abc\\", 2) 'cde' >>> shiftString(\\"xyz\\", 3) 'abc' >>> shiftString(\\"hello\\", -1) 'gdkkn'","solution":"def shiftString(s, k): Shifts each character in the string \`s\` by \`k\` positions in the alphabet. result = [] for char in s: new_char = chr(((ord(char) - ord('a') + k) % 26) + ord('a')) result.append(new_char) return ''.join(result)"},{"question":"def minimize_max_congestion(M: int, paths: List[Tuple[int, int, int]]) -> int: Returns the minimum possible value for the maximum congestion rate under optimal distribution of paths to three signages. Args: M : int : number of paths paths : list of tuples : each tuple contains (A, B, C) where A and B are attractions and C is the congestion rate Returns: int : Minimum possible value for the maximum congestion rate >>> minimize_max_congestion(6, [(1, 2, 10), (2, 3, 30), (3, 4, 20), (4, 5, 50), (5, 6, 40), (1, 6, 60)]) 60 >>> minimize_max_congestion(3, [(1, 2, 10), (2, 3, 20), (3, 4, 20)]) 20 >>> minimize_max_congestion(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 5, 4)]) 4 >>> minimize_max_congestion(1, [(1, 2, 50)]) 50 >>> minimize_max_congestion(5, [(1, 2, 5), (2, 3, 15), (3, 4, 25), (4, 5, 35), (5, 1, 45)]) 45","solution":"def minimize_max_congestion(M, paths): Returns the minimum possible value for the maximum congestion rate under optimal distribution of paths to three signages. Arguments: M : int : number of paths paths : list of tuples : each tuple contains (A, B, C) where A and B are attractions and C is the congestion rate # Binary search bounds for the minimum possible value for the maximum congestion rate left = 0 right = max([path[2] for path in paths]) def canDistributePaths(paths, maxCongestion): Helper function to determine if the paths can be distributed such that no signage controls paths with a congestion rate exceeding maxCongestion count = 1 current_sum = 0 for path in paths: if path[2] > maxCongestion: return False current_sum += path[2] if current_sum > maxCongestion: count += 1 current_sum = path[2] if count > 3: return False return True while left < right: mid = (left + right) // 2 if canDistributePaths(paths, mid): right = mid else: left = mid + 1 return left # Example usage: if __name__ == \\"__main__\\": M = 6 paths = [(1, 2, 10), (2, 3, 30), (3, 4, 20), (4, 5, 50), (5, 6, 40), (1, 6, 60)] print(minimize_max_congestion(M, paths)) # Expected output: 60"},{"question":"from typing import List def top_k_frequent_items(items: List[int], queries: List[int]) -> List[List[int]]: Determines the top K most frequent items for each query in the inventory. :param items: List of integers representing the items in the inventory. :param queries: List of integers representing the values of K for each query. :return: List of lists, where each list contains the top K frequent items sorted by frequency. pass def test_top_k_frequent_items(): items = [1, 1, 1, 2, 2, 3, 4, 4, 4, 4] queries = [2, 3] assert top_k_frequent_items(items, queries) == [[4, 1], [4, 1, 2]] def test_single_query(): items = [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] queries = [1] assert top_k_frequent_items(items, queries) == [[4]] def test_multiple_same_frequencies(): items = [5, 5, 5, 6, 6, 7, 7, 8] queries = [2, 3, 4] assert top_k_frequent_items(items, queries) == [[5, 6], [5, 6, 7], [5, 6, 7, 8]] def test_all_same_items(): items = [9, 9, 9, 9, 9] queries = [1, 2] assert top_k_frequent_items(items, queries) == [[9], [9]] def test_different_k_values(): items = [10, 10, 11, 11, 12, 13, 13, 14] queries = [1, 3] assert top_k_frequent_items(items, queries) == [[10], [10, 11, 13]] def test_empty_items(): items = [] queries = [] assert top_k_frequent_items(items, queries) == [] items = [] queries = [1, 2] assert top_k_frequent_items(items, queries) == [[], []] items = [1, 1, 2, 2, 2, 3, 3] queries = [] assert top_k_frequent_items(items, queries) == []","solution":"from collections import Counter from typing import List def top_k_frequent_items(items: List[int], queries: List[int]) -> List[List[int]]: Determines the top K most frequent items for each query in the inventory. :param items: List of integers representing the items in the inventory. :param queries: List of integers representing the values of K for each query. :return: List of lists, where each list contains the top K frequent items sorted by frequency. # Count the frequency of each item in the inventory item_count = Counter(items) # Sort the items first by frequency (in descending order) and then by the item value (in ascending order) sorted_items = sorted(item_count.items(), key=lambda x: (-x[1], x[0])) # Extract just the item values into a sorted list (we don't need frequencies for the final output) sorted_items_list = [item for item, count in sorted_items] # For each query, get the top K items from the sorted items list result = [] for k in queries: result.append(sorted_items_list[:k]) return result"},{"question":"def find_path(maze, n, m): Determine if it is possible to reach the exit point 'E' from the starting point 'S' in the maze. If it is possible, print \\"Solution exists.\\" and the shortest path. If there is no solution, print \\"No solution.\\" Args: maze: List of strings representing the maze. n: Integer, number of rows in the maze. m: Integer, number of columns in the maze. >>> n, m = 4, 5 >>> maze = [ ... \\"S....\\", ... \\".\\", ... \\".#E#.\\", ... \\".#...\\" ... ] >>> find_path(maze, n, m) Solution exists. RRRDD >>> n, m = 5, 5 >>> maze = [ ... \\"SE.\\", ... \\".#...\\", ... \\"...\\", ... \\"#...#\\", ... \\"#.#\\" ... ] >>> find_path(maze, n, m) No solution. >>> n, m = 3, 3 >>> maze = [ ... \\"S..\\", ... \\"#.#\\", ... \\"..E\\" ... ] >>> find_path(maze, n, m) Solution exists. RDD >>> n, m = 3, 4 >>> maze = [ ... \\"S..E\\", ... \\"#.#.\\", ... \\"....\\" ... ] >>> find_path(maze, n, m) Solution exists. RRRR pass","solution":"def find_path(maze, n, m): from collections import deque # Locate the start ('S') and end ('E') positions start = None end = None for i in range(n): for j in range(m): if maze[i][j] == 'S': start = (i, j) elif maze[i][j] == 'E': end = (i, j) # Directions for moving: Up, Down, Left, Right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] direction_symbols = ['U', 'D', 'L', 'R'] def in_bounds(x, y): return 0 <= x < n and 0 <= y < m # BFS for finding the shortest path queue = deque([(start, \\"\\")]) visited = set() visited.add(start) while queue: (current_x, current_y), path = queue.popleft() if (current_x, current_y) == end: print(\\"Solution exists.\\") print(path) return for (dx, dy), symbol in zip(directions, direction_symbols): next_x, next_y = current_x + dx, current_y + dy if in_bounds(next_x, next_y) and maze[next_x][next_y] != '#' and (next_x, next_y) not in visited: queue.append(((next_x, next_y), path + symbol)) visited.add((next_x, next_y)) print(\\"No solution.\\") # Test example # Maze input as a list of strings maze = [ \\"S....\\", \\".\\", \\".#E#.\\", \\".#...\\" ] n, m = 4, 5 find_path(maze, n, m)"},{"question":"from typing import List, Tuple def minimum_jumps_to_reach_end_from_start(N: int, S: int, E: int, positions: List[int], K: int) -> int: Determine the minimum number of jumps required to move from starting log S to ending log E, or return -1 if it's not possible. Parameters: N (int): Number of logs. S (int): Position of the starting log. E (int): Position of the ending log. positions (List[int]): List of integers representing the positions of the logs. K (int): Length of the jump. Returns: int: Minimum number of jumps needed to reach the ending log from the starting log or -1 if not possible. >>> minimum_jumps_to_reach_end_from_start(5, 1, 9, [1, 3, 5, 7, 9], 2) 4 >>> minimum_jumps_to_reach_end_from_start(5, 1, 8, [1, 3, 5, 7, 9], 2) -1 pass def solve_multi_case(T: int, test_cases: List[Tuple[Tuple[int, int, int], List[int], int]]) -> List[int]: Solve multiple test cases for the minimum jumps problem. Parameters: T (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[int], int]]): List of test cases, each containing number of logs, positions of the start and end logs, positions of the logs, and the length of jump respectively. Returns: List[int]: List of results for each test case. pass # Unit tests def test_minimum_jumps_to_reach_end_from_start(): assert minimum_jumps_to_reach_end_from_start(5, 1, 9, [1, 3, 5, 7, 9], 2) == 4 assert minimum_jumps_to_reach_end_from_start(5, 1, 8, [1, 3, 5, 7, 9], 2) == -1 assert minimum_jumps_to_reach_end_from_start(5, 3, 7, [1, 3, 5, 7, 9], 2) == 2 assert minimum_jumps_to_reach_end_from_start(5, 7, 9, [1, 3, 5, 7, 9], 2) == 1 assert minimum_jumps_to_reach_end_from_start(5, 1, 7, [1, 4, 6, 8, 10], 2) == -1 assert minimum_jumps_to_reach_end_from_start(1, 1, 1, [1], 2) == 0 def test_solve_multi_case(): test_cases = [ ([5, 1, 9], [1, 3, 5, 7, 9], 2), ([5, 1, 8], [1, 3, 5, 7, 9], 2), ([5, 3, 7], [1, 3, 5, 7, 9], 2), ([5, 7, 9], [1, 3, 5, 7, 9], 2), ([5, 1, 7], [1, 4, 6, 8, 10], 2), ([1, 1, 1], [1], 2) ] expected_results = [4, -1, 2, 1, -1, 0] results = solve_multi_case(len(test_cases), test_cases) assert results == expected_results","solution":"from collections import deque def minimum_jumps_to_reach_end_from_start(N, S, E, positions, K): Function to determine the minimum number of jumps required to move from starting log S to ending log E, or return -1 if it's not possible. if S == E: return 0 positions_set = set(positions) if S not in positions_set or E not in positions_set: return -1 queue = deque([(S, 0)]) visited = set([S]) while queue: current_position, jumps = queue.popleft() next_positions = [current_position + K, current_position - K] for next_pos in next_positions: if next_pos == E: return jumps + 1 if next_pos in positions_set and next_pos not in visited: queue.append((next_pos, jumps + 1)) visited.add(next_pos) return -1 def solve_multi_case(T, test_cases): results = [] for i in range(T): N, S, E = test_cases[i][0] positions = test_cases[i][1] K = test_cases[i][2] result = minimum_jumps_to_reach_end_from_start(N, S, E, positions, K) results.append(result) return results"},{"question":"def longest_increasing_contiguous_subarray_length(N, sequence): Returns the length of the longest increasing contiguous subarray. >>> longest_increasing_contiguous_subarray_length(9, [1, 2, 2, 3, 4, 5, 1, 2, 3]) 4 >>> longest_increasing_contiguous_subarray_length(1, [1]) 1 >>> longest_increasing_contiguous_subarray_length(5, [1, 2, 3, 4, 5]) 5 >>> longest_increasing_contiguous_subarray_length(5, [5, 4, 3, 2, 1]) 1 >>> longest_increasing_contiguous_subarray_length(6, [1, 2, 1, 2, 1, 2]) 2 >>> longest_increasing_contiguous_subarray_length(0, []) 0 >>> longest_increasing_contiguous_subarray_length(5, [1, 1, 1, 1, 1]) 1 >>> longest_increasing_contiguous_subarray_length(5, [1, 2, 3, 2, 3]) 3 >>> longest_increasing_contiguous_subarray_length(9, [1, 2, 3, 10, 11, 3, 4, 5, 6]) 5","solution":"def longest_increasing_contiguous_subarray_length(N, sequence): Returns the length of the longest increasing contiguous subarray. if N == 0: return 0 max_length = 1 current_length = 1 for i in range(1, N): if sequence[i] > sequence[i-1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) return max_length"},{"question":"def findSmallestMissingNum(arr): Returns the smallest positive integer that is not present in the list \`arr\`. >>> findSmallestMissingNum([1, 2, 3, 6, 4]) == 5 >>> findSmallestMissingNum([1, 3, 3, 3, 3]) == 2 >>> findSmallestMissingNum([1, 2, 0]) == 3 >>> findSmallestMissingNum([3, 4, -1, 1]) == 2 >>> findSmallestMissingNum([1, 2, 3]) == 4 >>> findSmallestMissingNum([7, 8, 9, 11, 12]) == 1 >>> findSmallestMissingNum([2]) == 1 >>> findSmallestMissingNum([1]) == 2 >>> findSmallestMissingNum([3, 4, 3, 1, 2]) == 5 >>> findSmallestMissingNum([1]) == 2 # Edge case with the minimum input size >>> findSmallestMissingNum([1000000] * 1000000) == 1 # Edge case with maximum allowed values","solution":"def findSmallestMissingNum(arr): Returns the smallest positive integer that is not present in the list \`arr\`. n = len(arr) for i in range(n): while 1 <= arr[i] <= n and arr[i] != arr[arr[i] - 1]: arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"from typing import List def rearrange_array(arr: List[int], k: int) -> List[int]: Rearranges the input array such that all elements less than or equal to k come before all elements greater than k. The relative order of these elements should be preserved. >>> rearrange_array([1, 4, 2, 10, 3, 6], 4) [1, 4, 2, 3, 10, 6] >>> rearrange_array([-3, 0, 2, -1, 7, 5, 3], 2) [-3, 0, 2, -1, 7, 5, 3] >>> rearrange_array([1, 2, 3, 4], 5) [1, 2, 3, 4] >>> rearrange_array([5, 6, 7, 8], 4) [5, 6, 7, 8] >>> rearrange_array([5, 1, 6, 2, 7, 3], 5) [5, 1, 2, 3, 6, 7] >>> rearrange_array([-5, -1, -6, -2, -7, -3], -4) [-5, -6, -7, -1, -2, -3] >>> rearrange_array([], 5) [] >>> rearrange_array([3], 5) [3] >>> rearrange_array([7], 5) [7] >>> rearrange_array([3, 3, 3], 3) [3, 3, 3]","solution":"from typing import List def rearrange_array(arr: List[int], k: int) -> List[int]: Rearranges the input array such that all elements less than or equal to k come before all elements greater than k. The relative order of these elements should be preserved. less_than_equal_k = [] greater_than_k = [] for num in arr: if num <= k: less_than_equal_k.append(num) else: greater_than_k.append(num) return less_than_equal_k + greater_than_k"},{"question":"from typing import List def distinct_prime_factors(n: int) -> int: Returns the number of distinct prime factors of the integer n. >>> distinct_prime_factors(12) 2 >>> distinct_prime_factors(15) 2 >>> distinct_prime_factors(20) 2 >>> distinct_prime_factors(2) 1 >>> distinct_prime_factors(13) 1 >>> distinct_prime_factors(30) 3 pass # Your implementation here def count_distinct_prime_factors(numbers: List[int]) -> List[int]: Takes a list of numbers and returns a list of the number of distinct prime factors for each number. >>> count_distinct_prime_factors([12, 15, 20]) [2, 2, 2] >>> count_distinct_prime_factors([2, 13, 30]) [1, 1, 3] >>> count_distinct_prime_factors([100, 49, 77]) [2, 1, 2] pass # Your implementation here if __name__ == \\"__main__\\": import doctest doctest.testmod()","solution":"def distinct_prime_factors(n): Returns the number of distinct prime factors of the integer n. def is_prime(x): if x <= 1: return False if x <= 3: return True if x % 2 == 0 or x % 3 == 0: return False i = 5 while i * i <= x: if x % i == 0 or x % (i + 2) == 0: return False i += 6 return True prime_factors = set() for i in range(2, n + 1): if is_prime(i) and n % i == 0: prime_factors.add(i) return len(prime_factors) def count_distinct_prime_factors(numbers): Takes a list of numbers and returns a list of the number of distinct prime factors for each number. return [distinct_prime_factors(n) for n in numbers]"},{"question":"def next_palindrome(n: int) -> int: Find the smallest palindrome number greater than n. >>> next_palindrome(123) 131 >>> next_palindrome(99) 101 >>> next_palindrome(1234) 1331 def is_palindrome(num: int) -> bool: Check if the given number is a palindrome.","solution":"def is_palindrome(num): Check if the given number is a palindrome. return str(num) == str(num)[::-1] def next_palindrome(n): Find the smallest palindrome number greater than n. n += 1 while not is_palindrome(n): n += 1 return n # Example usage: # next_palindrome(123) -> 131 # next_palindrome(99) -> 101 # next_palindrome(1234) -> 1331"},{"question":"from typing import List, Tuple def can_rearrange_sequence(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if the sequence can be rearranged so that the absolute difference between any two consecutive elements is at most 1 >>> test_cases = [(4, [1, 2, 2, 3]), (5, [5, 5, 5, 5, 5]), (6, [1, 3, 5, 7, 9, 11])] >>> can_rearrange_sequence(test_cases) ['YES', 'YES', 'NO'] >>> test_cases = [(3, [2, 2, 2]), (5, [7, 7, 7, 7, 7])] >>> can_rearrange_sequence(test_cases) ['YES', 'YES'] pass def parse_input(input_string: str) -> List[Tuple[int, List[int]]]: Parse input string into a list of test cases >>> input_string = \\"3n4n1 2 2 3n5n5 5 5 5 5n6n1 3 5 7 9 11\\" >>> parse_input(input_string) [(4, [1, 2, 2, 3]), (5, [5, 5, 5, 5, 5]), (6, [1, 3, 5, 7, 9, 11])] pass","solution":"def can_rearrange_sequence(test_cases): results = [] for case in test_cases: n, sequence = case sequence.sort() possible = True for i in range(1, n): if abs(sequence[i] - sequence[i - 1]) > 1: possible = False break results.append(\\"YES\\" if possible else \\"NO\\") return results def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] line_index = 1 for _ in range(T): n = int(lines[line_index]) sequence = list(map(int, lines[line_index + 1].split())) test_cases.append((n, sequence)) line_index += 2 return test_cases"},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Process the list of queries and modify the array accordingly. Parameters: n (int): Size of the array q (int): Number of queries arr (list of int): The initial array queries (list of tuples): Each tuple contains three integers (l, r, x) Returns: list of int: The modified array after processing all queries >>> process_queries(5, 1, [1, 2, 3, 4, 5], [(1, 3, 1)]) [2, 3, 4, 4, 5] >>> process_queries(4, 2, [1, 2, 3, 4], [(1, 2, 1), (3, 4, 2)]) [2, 3, 5, 6] >>> process_queries(5, 2, [1, 1, 1, 1, 1], [(1, 3, 1), (2, 5, 2)]) [2, 4, 4, 3, 3] >>> process_queries(3, 0, [1, 2, 3], []) [1, 2, 3] >>> process_queries(3, 1, [1, 2, 3], [(1, 3, 1000000000)]) [1000000001, 1000000002, 1000000003]","solution":"def process_queries(n, q, arr, queries): This function processes the list of queries and modifies the array accordingly. Parameters: n (int): Size of the array q (int): Number of queries arr (list of int): The initial array queries (list of tuples): Each tuple contains three integers (l, r, x) Returns: list of int: The modified array after processing all queries for l, r, x in queries: for i in range(l-1, r): arr[i] += x return arr"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(n, values, edges): nodes = [TreeNode(values[i]) for i in range(n)] for u, v in edges: nodes[u-1].children.append(nodes[v-1]) nodes[v-1].children.append(nodes[u-1]) return nodes[0] def find_longest_path_sum(root): def dfs(node, parent): max_depth, max_sum = 0, 0 for child in node.children: if child == parent: continue depth, path_sum = dfs(child, node) if depth + 1 > max_depth: max_depth, max_sum = depth + 1, path_sum + node.value elif depth + 1 == max_depth: max_sum = max(max_sum, path_sum + node.value) return max_depth, max_sum if max_depth > 0 else node.value return dfs(root, None)[1] def solve(n, values, edges): Find the sum of values of nodes on the longest path from the root to any leaf. If there are multiple longest paths, consider the path with the maximum sum of node values. Parameters: n (int): The number of nodes in the tree. values (List[int]): The values assigned to each node. edges (List[Tuple[int, int]]): The edges between nodes. Returns: int: The sum of values of nodes on the longest path from the root to any leaf. Examples: >>> solve(5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (2, 4), (2, 5)]) 8 >>> solve(3, [10, 2, 3], [(1, 2), (1, 3)]) 13","solution":"class TreeNode: def __init__(self, value): self.value = value self.children = [] def build_tree(n, values, edges): nodes = [TreeNode(values[i]) for i in range(n)] for u, v in edges: nodes[u-1].children.append(nodes[v-1]) nodes[v-1].children.append(nodes[u-1]) return nodes[0] def find_longest_path_sum(root): def dfs(node, parent): max_depth, max_sum = 0, 0 for child in node.children: if child == parent: continue depth, path_sum = dfs(child, node) if depth + 1 > max_depth: max_depth, max_sum = depth + 1, path_sum + node.value elif depth + 1 == max_depth: max_sum = max(max_sum, path_sum + node.value) return max_depth, max_sum if max_depth > 0 else node.value return dfs(root, None)[1] def solve(n, values, edges): root = build_tree(n, values, edges) return find_longest_path_sum(root)"},{"question":"def canAttendMeetings(intervals): Determines if a person can attend all meetings without overlap. Parameters: intervals (List[List[int]]): A list of meeting time intervals [start, end]. Returns: bool: True if a person can attend all meetings, False otherwise. Example: >>> canAttendMeetings([[0,30],[5,10],[15,20]]) False >>> canAttendMeetings([[7,10],[2,4]]) True","solution":"def canAttendMeetings(intervals): Determines if a person can attend all meetings without overlap. Parameters: intervals (List[List[int]]): A list of meeting time intervals [start, end]. Returns: bool: True if a person can attend all meetings, False otherwise. # Sort intervals by the start time intervals.sort(key=lambda x: x[0]) # Check for overlap for i in range(1, len(intervals)): if intervals[i][0] < intervals[i-1][1]: return False return True"},{"question":"from typing import List def longest_palindrome_length(S: str) -> int: Returns the length of the longest palindrome that can be built with the letters of the string S. :param S: A string consisting of lowercase English letters. :return: The length of the longest palindrome that can be built with S's letters. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 >>> longest_palindrome_length(\\"abcdefg\\") 1 >>> longest_palindrome_length(\\"aaaaaaa\\") 7 >>> longest_palindrome_length(\\"aaabbbbcccc\\") 11 >>> longest_palindrome_length(\\"\\") 0 >>> longest_palindrome_length(\\"aabbccddeeffg\\") 13","solution":"from collections import Counter def longest_palindrome_length(S: str) -> int: Returns the length of the longest palindrome that can be built with the letters of the string S. :param S: A string consisting of lowercase English letters. :return: The length of the longest palindrome that can be built with S's letters. freq = Counter(S) length = 0 odd_found = False for count in freq.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True if odd_found: length += 1 return length"},{"question":"def SumWithoutMax(arr): Returns the sum of array elements excluding the maximum value. If the array is empty or contains one element, return 0. If there are multiple occurrences of the maximum value, only exclude one. pass from solution import SumWithoutMax def test_sum_without_max_regular_case(): assert SumWithoutMax([1, 2, 3, 4, 5]) == 10 def test_sum_without_max_multiple_max_values(): assert SumWithoutMax([1, 4, 4, 4, 5]) == 13 def test_sum_without_max_single_element(): assert SumWithoutMax([10]) == 0 def test_sum_without_max_empty_array(): assert SumWithoutMax([]) == 0 def test_sum_without_max_negative_and_positive(): assert SumWithoutMax([-1, -2, 3, 4, 4]) == 4 def test_sum_without_max_negative_only(): assert SumWithoutMax([-1, -2, -3, -4, -5]) == -14 def test_sum_without_max_duplicate_non_max_values(): assert SumWithoutMax([1, 2, 2, 3, 4]) == 8 def test_sum_without_max_multiple_identical_elements(): assert SumWithoutMax([5, 5, 5, 5, 5]) == 20","solution":"def SumWithoutMax(arr): Returns the sum of array elements excluding the maximum value. If the array is empty or contains one element, return 0. If there are multiple occurrences of the maximum value, only exclude one. if len(arr) <= 1: return 0 max_value = max(arr) max_count = arr.count(max_value) total_sum = sum(arr) return total_sum - max_value"},{"question":"def can_partition(nums: list[int]) -> bool: Determine if a list of integers can be split into two subsets with equal sum. :param nums: A list of integers. :return: A boolean indicating whether the list can be partitioned into two equal sum subsets. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if a list of integers can be split into two subsets with equal sum. :param nums: A list of integers. :return: A boolean indicating whether the list can be partitioned into two equal sum subsets. total_sum = sum(nums) # If total sum is odd, we cannot split it into two equal subsets if total_sum % 2 != 0: return False target = total_sum // 2 n = len(nums) # Initialize a boolean DP array dp = [False] * (target + 1) dp[0] = True for num in nums: for j in range(target, num - 1, -1): dp[j] = dp[j] or dp[j - num] return dp[target]"},{"question":"def longest_unique_subarray_length(arr: List[int]) -> int: Given an array of N integers, return the length of the longest subarray consisting of unique elements. Parameters: arr (List[int]): An array of integers. Returns: int: The length of the longest subarray with all unique elements. Constraints: 1 <= len(arr) <= 10**5 1 <= arr[i] <= 10**6 Example: >>> longest_unique_subarray_length([1, 2, 3, 1, 2, 3]) 3 >>> longest_unique_subarray_length([4, 5, 4, 6, 7, 8]) 5 from typing import List def test_example_cases(): assert longest_unique_subarray_length([1, 2, 3, 1, 2, 3]) == 3 assert longest_unique_subarray_length([4, 5, 4, 6, 7, 8]) == 5 def test_single_element(): assert longest_unique_subarray_length([1]) == 1 assert longest_unique_subarray_length([1000000]) == 1 def test_all_unique(): assert longest_unique_subarray_length([1, 2, 3, 4, 5, 6]) == 6 assert longest_unique_subarray_length([6, 5, 4, 3, 2, 1]) == 6 def test_all_same(): assert longest_unique_subarray_length([7, 7, 7, 7, 7]) == 1 assert longest_unique_subarray_length([0, 0, 0, 0, 0]) == 1 def test_large_case(): assert longest_unique_subarray_length(list(range(100000))) == 100000 assert longest_unique_subarray_length(list(range(100000)) + [0]) == 100000 def test_mixed_cases(): assert longest_unique_subarray_length([1, 2, 3, 4, 5, 1, 2, 3, 4]) == 5 assert longest_unique_subarray_length([1, 2, 2, 1, 1]) == 2 assert longest_unique_subarray_length([10, 20, 30, 40, 50, 60, 10, 20, 30]) == 6","solution":"def longest_unique_subarray_length(arr): Returns the length of the longest subarray with all unique elements. element_index_map = {} max_length = 0 start = 0 for end, value in enumerate(arr): if value in element_index_map: start = max(start, element_index_map[value] + 1) element_index_map[value] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def merge_lists(lst1, lst2): Merges two lists, removes duplicates, and returns a sorted list without changing the type of the first instance found. The lists can contain a mix of integers and strings. Your function should: 1. Ignore the type when checking for uniqueness (i.e., the string \`\\"5\\"\` and the integer \`5\` should be considered the same). 2. Preserve the type of the first instance encountered (i.e., if \`\\"5\\"\` appears before \`5\`, then \`\\"5\\"\` should be in the output). If either input list contains an element that is neither an integer nor a string, the function should return \`\\"invalid input\\"\`. >>> merge_lists([1, 2], [\\"3\\", \\"4\\"]) [1, 2, \\"3\\", \\"4\\"] >>> merge_lists([\\"3\\", 5, \\"hello\\", \\"3\\"], [2, \\"hello\\", 5, 3]) [\\"3\\", 5, \\"hello\\", 2] >>> merge_lists([\\"5\\", 6], [5, \\"6\\", \\"5\\"]) [\\"5\\", 6] >>> merge_lists([1, \\"2\\", \\"3\\", 4], [\\"5\\", 2, 3, \\"4\\"]) [1, \\"2\\", \\"3\\", 4, \\"5\\"] >>> merge_lists([1, \\"string\\", 3.14], [2, \\"another\\"]) \\"invalid input\\" >>> merge_lists([None, \\"string\\"], [2, \\"another\\"]) \\"invalid input\\" >>> merge_lists([1, \\"string\\"], [{}, \\"another\\"]) \\"invalid input\\" >>> merge_lists([], []) [] >>> merge_lists([1, 2, 3], []) [1, 2, 3] >>> merge_lists([], [\\"1\\", \\"2\\", \\"3\\"]) [\\"1\\", \\"2\\", \\"3\\"]","solution":"def merge_lists(lst1, lst2): Merges two lists, removes duplicates, and returns a sorted list without changing the type of the first instance found. if any(not isinstance(i, (int, str)) for i in lst1 + lst2): return \\"invalid input\\" combined_list = lst1 + lst2 unique_dict = {} for item in combined_list: key = str(item) if isinstance(item, int) else item if key not in unique_dict: unique_dict[key] = item return list(unique_dict.values())"},{"question":"def find_missing_number(n, numbers): Returns the missing number from the array. Parameters: n (int): The upper bound of the range. numbers (List[int]): The list of unique numbers from the range except one. Returns: int: The missing number in the sequence. pass def process_test_cases(T, cases): Processes multiple test cases to find the missing number in each. Parameters: T (int): The number of test cases. cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains: - An integer N representing the upper bound of the range - A list of integers representing the numbers from \`[1, N]\` with one missing Returns: Union[List[Union[int, str]], str]: A list containing the missing number for each test case or \\"Invalid Input\\" if the input constraints are violated. Returns \\"Invalid Test\\" if T is not in the range [1, 10]. pass # Example unit tests import pytest def test_find_missing_number(): assert find_missing_number(5, [1, 2, 3, 5]) == 4 assert find_missing_number(10, [1, 2, 3, 4, 5, 6, 7, 9, 10]) == 8 assert find_missing_number(15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15]) == 12 def test_process_test_cases_valid(): T = 3 cases = [ (5, [1, 2, 3, 5]), (10, [1, 2, 3, 4, 5, 6, 7, 9, 10]), (15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15]) ] result = process_test_cases(T, cases) assert result == [4, 8, 12] def test_process_test_cases_invalid_test_range(): T = 11 cases = [ (5, [1, 2, 3, 5]), (10, [1, 2, 3, 4, 5, 6, 7, 9, 10]), (15, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15]) ] result = process_test_cases(T, cases) assert result == \\"Invalid Test\\" def test_process_test_cases_invalid_input(): T = 3 cases = [ (5, [1, 2, 3, 5]), (110, [1]*109), # Invalid N (15, [1, 2, 3, 4, 5, 6, 7, 9, 10]) # Array length not N-1 ] result = process_test_cases(T, cases) assert result == [4, \\"Invalid Input\\", \\"Invalid Input\\"]","solution":"def find_missing_number(n, numbers): Returns the missing number from the array. expected_sum = n * (n + 1) // 2 actual_sum = sum(numbers) return expected_sum - actual_sum def process_test_cases(T, cases): if T < 1 or T > 10: return \\"Invalid Test\\" results = [] for N, array in cases: if N < 2 or N > 100 or len(array) != N - 1: results.append(\\"Invalid Input\\") else: results.append(find_missing_number(N, array)) return results"},{"question":"def three_sum_zero(nums): Returns True if there are three distinct elements in nums that sum up to zero, else False. Example: >>> three_sum_zero([-1, 0, 1, 2, -1, -4]) True >>> three_sum_zero([1, 2, 3, 4, 5]) False","solution":"def three_sum_zero(nums): Returns True if there are three distinct elements in nums that sum up to zero, else False. nums.sort() n = len(nums) for i in range(n - 2): # To avoid duplicates if i > 0 and nums[i] == nums[i - 1]: continue left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if current_sum == 0: return True elif current_sum < 0: left += 1 else: right -= 1 return False"},{"question":"def findTriplets(arr, n): Finds all unique triples (arr[i], arr[j], arr[k]) such that 0 <= i < j < k < N and arr[i] + arr[j] + arr[k] == 0. Args: arr (List[int]): The list of integers. n (int): The size of the array. Returns: List[List[int]]: A list of lists containing the unique triplets that sum to zero, with each triplet sorted in non-decreasing order. Examples: >>> findTriplets([-1, 0, 1, 2, -1, -4], 6) [[-1, -1, 2], [-1, 0, 1]] >>> findTriplets([0, 0, 0, 0], 4) [[0, 0, 0]] pass def processTestCases(T, test_cases): Process multiple test cases to find triplets for each. Args: T (int): Number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples, each containing the size of the array and the array itself. Returns: List[List[List[int]]]: List of results for each test case, where each result is a list of unique triplets that sum to zero. Examples: >>> test_cases = [ ... (6, [-1, 0, 1, 2, -1, -4]), ... (4, [0, 0, 0, 0]) ... ] >>> processTestCases(2, test_cases) [[[ -1, -1, 2], [-1, 0, 1]], [[0, 0, 0]]] pass","solution":"def findTriplets(arr, n): arr.sort() triplets = [] for i in range(n - 2): if i > 0 and arr[i] == arr[i - 1]: continue left, right = i + 1, n - 1 while left < right: total = arr[i] + arr[left] + arr[right] if total == 0: triplets.append([arr[i], arr[left], arr[right]]) while left < right and arr[left] == arr[left + 1]: left += 1 while left < right and arr[right] == arr[right - 1]: right -= 1 left += 1 right -= 1 elif total < 0: left += 1 else: right -= 1 return triplets def processTestCases(T, test_cases): result = [] for i in range(T): N = test_cases[i][0] arr = test_cases[i][1] result.append(findTriplets(arr, N)) return result"},{"question":"def max_filled_positions(weights: List[int], matrix: List[List[int]], threshold: int) -> int: Returns the maximum number of positions filled without exceeding the threshold. :param weights: A list of non-negative integers representing weights. :param matrix: An n x m integer matrix consisting of zeros where weights can be placed. :param threshold: A non-negative integer representing the maximum allowed sum of weights in the matrix. :return: An integer representing the maximum number of positions filled without exceeding the threshold. >>> max_filled_positions([4, 2, 3, 5, 7], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], 10) 3 >>> max_filled_positions([1, 2, 1], [[0, 0], [0, 0]], 4) 3 >>> max_filled_positions([5], [[0, 0], [0, 0]], 4) 0 >>> max_filled_positions([1, 1, 1, 1, 1], [[0, 0], [0, 0]], 10) 5 >>> max_filled_positions([], [[0, 0], [0, 0]], 10) 0 >>> max_filled_positions([3, 2, 4, 1], [[0, 0, 0], [0, 0, 0], [0, 0, 0]], 7) 3","solution":"from itertools import combinations def max_filled_positions(weights, matrix, threshold): Returns the maximum number of positions filled without exceeding the threshold. n, m = len(matrix), len(matrix[0]) max_positions = 0 for r in range(1, len(weights) + 1): for combi in combinations(weights, r): if sum(combi) <= threshold: max_positions = max(max_positions, r) return max_positions # Example usage weights = [4, 2, 3, 5, 7] matrix = [ [0, 0, 0], [0, 0, 0], [0, 0, 0] ] threshold = 10 print(max_filled_positions(weights, matrix, threshold)) # Output: 3"},{"question":"def minimized_max_difference(n: int, abilities: List[int], k: int) -> int: Distribute participants into teams such that the maximum difference between the highest and lowest ability score within any team is minimized. Args: n (int): Number of participants. abilities (List[int]): Ability scores of the participants. k (int): Number of teams. Returns: int: The minimized maximum difference between the highest and lowest ability score in each team after the optimal distribution. >>> minimized_max_difference(6, [10, 20, 30, 40, 50, 60], 2) 20 >>> minimized_max_difference(7, [1, 2, 3, 4, 5, 6, 7], 3) 2 >>> minimized_max_difference(5, [5, 8, 12, 15, 20], 5) 0 def test_example_1(): assert minimized_max_difference(6, [10, 20, 30, 40, 50, 60], 2) == 20 def test_example_2(): assert minimized_max_difference(7, [1, 2, 3, 4, 5, 6, 7], 3) == 2 def test_example_3(): assert minimized_max_difference(5, [5, 8, 12, 15, 20], 5) == 0 def test_single_participant(): assert minimized_max_difference(1, [10], 1) == 0 def test_all_same_ability(): assert minimized_max_difference(4, [5, 5, 5, 5], 2) == 0 def test_all_teams_one_member(): assert minimized_max_difference(4, [5, 8, 15, 20], 4) == 0 def test_increasing_abilities(): assert minimized_max_difference(5, [1, 2, 3, 4, 5], 2) == 2","solution":"def minimized_max_difference(n, abilities, k): abilities.sort() def can_partition_with_max_diff(max_diff): # if true_partition = teams needed to keep maximum difference <= max_diff. teams, i = 1, 0 for j in range(1, n): if abilities[j] - abilities[i] > max_diff: teams += 1 i = j if teams > k: return False return True low, high = 0, abilities[-1] - abilities[0] while low < high: mid = (low + high) // 2 if can_partition_with_max_diff(mid): high = mid else: low = mid + 1 return low"},{"question":"def min_shelves(test_cases): Given a series of test cases with the number of books, maximum height of each shelf, and the heights of the books, determine the minimum number of shelves required to organize all the books. pass def parse_input(input_str): Parse the input string to extract the number of test cases and their respective details. pass import pytest def test_min_shelves(): input_str = 2 4 10 2 3 9 5 3 5 2 2 3 test_cases = parse_input(input_str) assert min_shelves(test_cases) == [2, 2] def test_single_case(): input_str = 1 3 6 1 2 3 test_cases = parse_input(input_str) assert min_shelves(test_cases) == [1] def test_max_shelf_limit(): input_str = 1 5 5 5 5 5 5 5 test_cases = parse_input(input_str) assert min_shelves(test_cases) == [5] def test_single_book(): input_str = 1 1 10 10 test_cases = parse_input(input_str) assert min_shelves(test_cases) == [1] def test_unsorted_books(): input_str = 1 4 7 3 1 6 2 test_cases = parse_input(input_str) assert min_shelves(test_cases) == [2] def test_zero_height_book(): input_str = 1 3 5 0 0 0 test_cases = parse_input(input_str) assert min_shelves(test_cases) == [1]","solution":"def min_shelves(test_cases): results = [] for case in test_cases: n, h, book_heights = case book_heights.sort(reverse=True) shelves = [] for height in book_heights: placed = False for shelf in shelves: if sum(shelf) + height <= h: shelf.append(height) placed = True break if not placed: shelves.append([height]) results.append(len(shelves)) return results def parse_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] current_line = 1 for _ in range(T): n, h = map(int, lines[current_line].split()) book_heights = list(map(int, lines[current_line + 1].split())) test_cases.append((n, h, book_heights)) current_line += 2 return test_cases"},{"question":"def is_valid_barcode(barcode: str) -> str: Determines if the barcode can be valid by replacing '?' with appropriate digits. >>> is_valid_barcode(\\"1234????1?\\") \\"Invalid\\" >>> is_valid_barcode(\\"12??56?93?\\") \\"Valid\\"","solution":"def is_valid_barcode(barcode): Determines if the barcode can be valid by replacing '?' with appropriate digits. if len(barcode) != 10: return \\"Invalid\\" if not all(char.isdigit() or char == '?' for char in barcode): return \\"Invalid\\" # Replace '?' with '0' and calculate the sum of digits to check if it is even zeroed_barcode = [int(char) if char != '?' else 0 for char in barcode] if sum(zeroed_barcode) % 2 != 0: return \\"Invalid\\" # Check if the sum of any 5 consecutive digits is at least 15 for i in range(6): current_sum = sum(zeroed_barcode[i:i+5]) max_possible_sum = current_sum + barcode[i:i+5].count('?') * 9 if max_possible_sum < 15: return \\"Invalid\\" return \\"Valid\\""},{"question":"def is_safe_navigation(w, h, grid): Determine if the spaceship can navigate from (0,0) to (w-1, h-1) without hitting an asteroid. A BFS or DFS can be used to traverse the grid. :param w: int, grid width :param h: int, grid height :param grid: list of str, the grid itself :return: str, \\"SAFE\\" if navigable, \\"TRAPPED\\" otherwise >>> is_safe_navigation(5, 5, [\\".....\\", \\".#.\\", \\".#...\\", \\".#.\\", \\".....\\"]) == \\"SAFE\\" >>> is_safe_navigation(3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]) == \\"TRAPPED\\" >>> is_safe_navigation(4, 4, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"]) == \\"SAFE\\" pass def process_datasets(datasets): Process multiple datasets to determine if the spaceship can navigate from (0,0) to (w-1,h-1) without hitting an asteroid. :param datasets: list of tuples, each tuple contains w, h and the grid configuration :return: list of str, \\"SAFE\\" or \\"TRAPPED\\" for each dataset >>> datasets = [ ... (5, 5, [\\".....\\", \\".#.\\", \\".#...\\", \\".#.\\", \\".....\\"]), ... (3, 3, [\\".#.\\", \\"#\\", \\".#.\\"]), ... (4, 4, [\\"....\\", \\".#..\\", \\".#..\\", \\"....\\"]) ... ] >>> process_datasets(datasets) == [\\"SAFE\\", \\"TRAPPED\\", \\"SAFE\\"] pass","solution":"def is_safe_navigation(w, h, grid): Determine if the spaceship can navigate from (0,0) to (w-1, h-1) without hitting an asteroid. A BFS or DFS can be used to traverse the grid. :param w: int, grid width :param h: int, grid height :param grid: list of str, the grid itself :return: str, \\"SAFE\\" if navigable, \\"TRAPPED\\" otherwise if grid[0][0] == '#' or grid[h-1][w-1] == '#': return \\"TRAPPED\\" from collections import deque directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: x, y = queue.popleft() if x == w-1 and y == h-1: return \\"SAFE\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < w and 0 <= ny < h and (nx, ny) not in visited and grid[ny][nx] == '.': visited.add((nx, ny)) queue.append((nx, ny)) return \\"TRAPPED\\" def process_datasets(datasets): results = [] for w, h, grid in datasets: results.append(is_safe_navigation(w, h, grid)) return results"},{"question":"def count_runners_can_finish(K: int, N: int, energies: List[int]) -> int: Determines the number of runners that can complete the marathon. Arguments: K : int - the number of checkpoints in the marathon. N : int - the number of runners. energies : list of int - the energy quotas of the runners. Returns: int - the number of runners that can complete the marathon. Example: >>> count_runners_can_finish(10, 5, [12, 8, 15, 10, 7]) 3 >>> count_runners_can_finish(10, 3, [5, 6, 7]) 0 >>> count_runners_can_finish(10, 3, [10, 20, 30]) 3","solution":"def count_runners_can_finish(K, N, energies): Determines the number of runners that can complete the marathon. Arguments: K : int - the number of checkpoints in the marathon. N : int - the number of runners. energies : list of int - the energy quotas of the runners. Returns: int - the number of runners that can complete the marathon. count = 0 for energy in energies: if energy >= K: count += 1 return count"},{"question":"def can_sort_by_reversing_subarrays(test_cases): Determines if it is possible to sort each array in the test cases in non-decreasing order by reversing subarrays. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple consists of the size of the array and the array itself. Returns: List[str]: A list of strings \\"YES\\" or \\"NO\\" indicating if it is possible to sort each array in non-decreasing order. def process_input(input_data): Processes the input data and returns the test cases. Args: input_data (str): The raw input string containing test cases. Returns: List[Tuple[int, List[int]]]: A list of tuples, where each tuple consists of the size of the array and the array itself. def process_output(results): Processes the results and returns the output string. Args: results (List[str]): A list of strings \\"YES\\" or \\"NO\\". Returns: str: The formatted output string. def main(input_data): Main function to determine if it is possible to sort arrays by reversing subarrays, given input data. Args: input_data (str): The raw input string containing test cases. Returns: str: The formatted output string. # Unit tests def test_can_sort_by_reversing_subarrays(): assert can_sort_by_reversing_subarrays([(5, [3, 1, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [1, 2, 3, 4, 5, 6])]) == [\\"YES\\", \\"YES\\", \\"YES\\"] assert can_sort_by_reversing_subarrays([(5, [3, 2, 1, 5, 4])]) == [\\"YES\\"] def test_process_input(): input_data = \\"3n5n3 1 2 4 5n4n4 3 2 1n6n1 2 3 4 5 6n\\" expected_output = [(5, [3, 1, 2, 4, 5]), (4, [4, 3, 2, 1]), (6, [1, 2, 3, 4, 5, 6])] assert process_input(input_data) == expected_output def test_process_output(): assert process_output([\\"YES\\", \\"YES\\", \\"YES\\"]) == \\"YESnYESnYES\\" assert process_output([\\"YES\\"]) == \\"YES\\" def test_main(): input_data = \\"3n5n3 1 2 4 5n4n4 3 2 1n6n1 2 3 4 5 6n\\" expected_result = \\"YESnYESnYES\\" assert main(input_data) == expected_result def test_edge_cases(): # Testing for minimal and maximal edge cases. assert can_sort_by_reversing_subarrays([(1, [1])]) == [\\"YES\\"] assert can_sort_by_reversing_subarrays([(2, [2, -10**9])]) == [\\"YES\\"] assert can_sort_by_reversing_subarrays([(2, [-10**9, 2])]) == [\\"YES\\"] large_input = list(range(10**5, 0, -1)) # A large array in fully descending order assert can_sort_by_reversing_subarrays([(10**5, large_input)]) == [\\"YES\\"]","solution":"def can_sort_by_reversing_subarrays(test_cases): results = [] for N, array in test_cases: if array == sorted(array): results.append(\\"YES\\") else: results.append(\\"YES\\") return results def process_input(input_data): lines = input_data.strip().split('n') T = int(lines[0]) index = 1 test_cases = [] for _ in range(T): N = int(lines[index]) array = list(map(int, lines[index + 1].split())) test_cases.append((N, array)) index += 2 return test_cases def process_output(results): return 'n'.join(results) def main(input_data): test_cases = process_input(input_data) results = can_sort_by_reversing_subarrays(test_cases) return process_output(results)"},{"question":"def max_profit(prices): This function calculates the maximum profit that can be made by buying and selling the stock on different days. >>> max_profit([7, 1, 5, 3, 6, 4]) == 5 >>> max_profit([7, 6, 4, 3]) == 0 >>> max_profit([1, 2, 3, 4, 5]) == 4 # Your code here def max_profit_multiple_cases(test_cases): This function processes multiple test cases for maximum profit calculation. >>> max_profit_multiple_cases([[7, 1, 5, 3, 6, 4], [7, 6, 4, 3], [1, 2, 3, 4, 5]]) == [5, 0, 4] >>> max_profit_multiple_cases([[3, 3, 5, 0, 0, 3, 1, 4], [], [5, 4, 3, 2, 1], [1, 1, 2, 2, 3, 3, 4, 4]]) == [4, 0, 0, 3] # Your code here","solution":"def max_profit(prices): This function calculates the maximum profit that can be made by buying and selling the stock on different days. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price else: current_profit = price - min_price if current_profit > max_profit: max_profit = current_profit return max_profit def max_profit_multiple_cases(test_cases): This function processes multiple test cases for maximum profit calculation. results = [] for prices in test_cases: results.append(max_profit(prices)) return results"},{"question":"def solve(input_text: str) -> List[int]: Calculate the total number of words in the specified book for each test case. Args: input_text (str): The input string containing test cases details. Returns: List[int]: A list containing the total number of words in the specified book for each test case. Examples: >>> solve(\\"2n3n1 3 100 200 300n2 2 50 75n3 4 10 20 30 40n2n2n1 3 100 200 300n3 4 10 20 30 40n3\\") [125, 100] >>> solve(\\"1n1n50 3 500 600 700n50\\") [1800] # Write your code here # Test cases def test_case_1(): input_text = \\"2n3n1 3 100 200 300n2 2 50 75n3 4 10 20 30 40n2n2n1 3 100 200 300n3 4 10 20 30 40n3\\" expected_output = [125, 100] assert solve(input_text) == expected_output def test_case_2(): input_text = \\"1n1n50 3 500 600 700n50\\" expected_output = [1800] assert solve(input_text) == expected_output def test_case_3(): input_text = \\"1n2n10 2 300 400n20 2 150 250n20\\" expected_output = [400] assert solve(input_text) == expected_output def test_case_4(): input_text = \\"3n2n101 1 500n102 3 100 200 300n101n1n150 2 250 250n150n1n200 4 100 100 100 100n200\\" expected_output = [500, 500, 400] assert solve(input_text) == expected_output def test_case_5(): input_text = \\"1n1n500 5 100 200 300 400 500n500\\" expected_output = [1500] assert solve(input_text) == expected_output","solution":"def calculate_total_words(test_cases): results = [] for test_case in test_cases: book_details = test_case['book_details'] query_id = test_case['query_id'] for book in book_details: if book['id'] == query_id: results.append(sum(book['words'])) break return results def parse_input(input_text): lines = input_text.split('n') T = int(lines[0].strip()) index = 1 test_cases = [] for _ in range(T): B = int(lines[index].strip()) index += 1 book_details = [] for _ in range(B): parts = list(map(int, lines[index].strip().split())) book_id = parts[0] P = parts[1] words = parts[2:] book_details.append({'id': book_id, 'words': words}) index += 1 query_id = int(lines[index].strip()) test_cases.append({'book_details': book_details, 'query_id': query_id}) index += 1 return test_cases def solve(input_text): test_cases = parse_input(input_text) return calculate_total_words(test_cases) # Sample Input sample_input = 2 3 1 3 100 200 300 2 2 50 75 3 4 10 20 30 40 2 2 1 3 100 200 300 3 4 10 20 30 40 3 # This line is for directly getting the output to ensure function is working. print(solve(sample_input)) # Expected output: [125, 100]"},{"question":"def track_max_position(n: int, commands: List[str]) -> Tuple[int, int]: Track the final position of Max in a 2D grid after executing movement commands. :param n: Number of commands :param commands: List of commands, each in the format \\"d x\\" :return: The final (x, y) coordinates of Max >>> track_max_position(4, [\\"R 5\\", \\"U 3\\", \\"L 2\\", \\"D 1\\"]) (3, 2) >>> track_max_position(3, [\\"L 4\\", \\"D 2\\", \\"R 1\\"]) (-3, -2)","solution":"def track_max_position(n, commands): Track the final position of Max in a 2D grid after executing movement commands. :param n: Number of commands :param commands: List of commands, each in the format \\"d x\\" :return: The final (x, y) coordinates of Max # Starting position x, y = 0, 0 # Process each command for command in commands: direction, distance = command.split() distance = int(distance) if direction == \\"U\\": y += distance elif direction == \\"D\\": y -= distance elif direction == \\"L\\": x -= distance elif direction == \\"R\\": x += distance return x, y"},{"question":"def sort_tasks(tasks): Sort tasks first by department code in ascending order, and then by task priority within each department in descending order. Args: tasks (list of tuples): list of tasks where each task is represented as a tuple (task_id, dept_code, priority) Returns: list of tuples: sorted list of tasks based on the specified order pass # Test cases def test_case_1(): input_data = [(1, 3, 500), (2, 1, 300), (3, 2, 400), (4, 1, 400), (5, 2, 200), (6, 3, 600)] expected_output = [(4, 1, 400), (2, 1, 300), (3, 2, 400), (5, 2, 200), (6, 3, 600), (1, 3, 500)] assert sort_tasks(input_data) == expected_output def test_case_2(): input_data = [(10, 1, 15), (11, 2, 35), (12, 2, 25), (13, 1, 45)] expected_output = [(13, 1, 45), (10, 1, 15), (11, 2, 35), (12, 2, 25)] assert sort_tasks(input_data) == expected_output def test_case_3(): input_data = [(101, 1, 50), (102, 1, 50), (103, 1, 60)] expected_output = [(103, 1, 60), (101, 1, 50), (102, 1, 50)] assert sort_tasks(input_data) == expected_output def test_case_4(): input_data = [(201, 3, 100), (202, 3, 200), (203, 2, 150)] expected_output = [(203, 2, 150), (202, 3, 200), (201, 3, 100)] assert sort_tasks(input_data) == expected_output def test_empty_input(): input_data = [] expected_output = [] assert sort_tasks(input_data) == expected_output def test_single_task(): input_data = [(301, 4, 500)] expected_output = [(301, 4, 500)] assert sort_tasks(input_data) == expected_output","solution":"def sort_tasks(tasks): Sort tasks first by department code in ascending order, and then by task priority within each department in descending order. Args: tasks (list of tuples): list of tasks where each task is represented as a tuple (task_id, dept_code, priority) Returns: list of tuples: sorted list of tasks based on the specified order # Sorting by department code (asc) and then by priority (desc) return sorted(tasks, key=lambda x: (x[1], -x[2]))"},{"question":"def isPathExist(graph, start, end): Determines if a path exists from start node to end node in the given directed graph. Parameters: graph (dict): The adjacency list representation of the graph. start (int): The starting node. end (int): The target node. Returns: bool: True if a path exists from start to end, False otherwise. Example: >>> graph = {1: [2, 3], 2: [4], 3: [], 4: [5], 5: []} >>> isPathExist(graph, 1, 5) True >>> isPathExist(graph, 1, 6) False >>> isPathExist(graph, 1, 1) True >>> isPathExist(graph, 1, 5) False >>> isPathExist(graph, 3, 5) True >>> isPathExist(graph, 1, 3) True >>> isPathExist(graph, 3, 4) False from solution import isPathExist def test_isPathExist_example1(): graph = {1: [2, 3], 2: [4], 3: [], 4: [5], 5: []} assert isPathExist(graph, 1, 5) == True def test_isPathExist_example2(): graph = {1: [2, 3], 2: [4], 3: [], 4: [5], 5: []} assert isPathExist(graph, 1, 6) == False def test_isPathExist_same_start_end(): graph = {1: [2, 3], 2: [4], 3: [], 4: [5], 5: []} assert isPathExist(graph, 1, 1) == True def test_isPathExist_no_path(): graph = {1: [2], 2: [3], 3: [], 4: [5], 5: []} assert isPathExist(graph, 1, 5) == False def test_isPathExist_direct_connection(): graph = {1: [2, 3], 2: [4], 3: [5], 4: [], 5: []} assert isPathExist(graph, 3, 5) == True def test_isPathExist_cyclic_graph(): graph = {1: [2], 2: [3], 3: [1], 4: [5], 5: []} assert isPathExist(graph, 1, 3) == True assert isPathExist(graph, 3, 4) == False","solution":"def isPathExist(graph, start, end): Determines if a path exists from start node to end node in the given directed graph. Parameters: graph (dict): The adjacency list representation of the graph. start (int): The starting node. end (int): The target node. Returns: bool: True if a path exists from start to end, False otherwise. # If start and end are the same, a trivial path exists if start == end: return True # Use Depth-First Search (DFS) to find the path def dfs(node, visited): if node == end: return True if node in visited or node not in graph: return False visited.add(node) for neighbor in graph[node]: if dfs(neighbor, visited): return True return False visited = set() return dfs(start, visited)"},{"question":"def max_treasures(t, test_cases): Determine the maximum number of treasures that can be collected on a valid path from the top-left to the bottom-right corner of the grid, moving only right or down. Args: t (int): The number of test cases. test_cases (list of dicts): Each dict contains 'dims' (tuple of two ints) representing the dimensions of the grid, and 'grid' (list of lists of ints) representing the grid layout. Returns: list of int: The number of treasures collected for each test case. >>> test_cases = [{'dims': (3, 3), 'grid': [[1, 0, 1], [0, -1, 0], [1, 0, 1]]}] >>> max_treasures(1, test_cases) [3]","solution":"def max_treasures(t, test_cases): results = [] for case in test_cases: n, m = case['dims'] grid = case['grid'] # Initialize the dp table dp = [[float('-inf')] * m for _ in range(n)] if grid[0][0] != -1: dp[0][0] = grid[0][0] for i in range(n): for j in range(m): if grid[i][j] == -1: continue if i > 0 and dp[i-1][j] != float('-inf'): dp[i][j] = max(dp[i][j], dp[i-1][j] + (1 if grid[i][j] == 1 else 0)) if j > 0 and dp[i][j-1] != float('-inf'): dp[i][j] = max(dp[i][j], dp[i][j-1] + (1 if grid[i][j] == 1 else 0)) results.append(0 if dp[n-1][m-1] == float('-inf') else dp[n-1][m-1]) return results"},{"question":"from typing import List def can_find_subarray(arr: List[int], k: int) -> str: Determines if there exists a contiguous subarray that sums to the given target value k. Returns \\"found\\" if such a subarray exists, otherwise returns \\"not found\\". >>> can_find_subarray([1, -1, 5, -2, 3], 3) \\"found\\" >>> can_find_subarray([-2, -1, 2, 1], 1) \\"found\\" >>> can_find_subarray([1, 2, 3], 6) \\"found\\" >>> can_find_subarray([1, 2, 3], -1) \\"not found\\" def test_can_find_subarray_example1(): arr = [1, -1, 5, -2, 3] k = 3 assert can_find_subarray(arr, k) == \\"found\\" def test_can_find_subarray_example2(): arr = [-2, -1, 2, 1] k = 1 assert can_find_subarray(arr, k) == \\"found\\" def test_can_find_subarray_example3(): arr = [1, 2, 3] k = 6 assert can_find_subarray(arr, k) == \\"found\\" def test_can_find_subarray_example4(): arr = [1, 2, 3] k = -1 assert can_find_subarray(arr, k) == \\"not found\\" def test_can_find_subarray_empty_array(): arr = [] k = 0 assert can_find_subarray(arr, k) == \\"not found\\" def test_can_find_subarray_single_element(): arr = [5] k = 5 assert can_find_subarray(arr, k) == \\"found\\" arr = [5] k = -5 assert can_find_subarray(arr, k) == \\"not found\\" def test_can_find_subarray_negative_numbers(): arr = [-1, -2, -3, -4, -5] k = -10 assert can_find_subarray(arr, k) == \\"found\\" k = -15 assert can_find_subarray(arr, k) == \\"found\\" k = -16 assert can_find_subarray(arr, k) == \\"not found\\" def test_can_find_subarray_mixed_numbers(): arr = [3, 4, -7, 1, 2, -1, 5] k = 3 assert can_find_subarray(arr, k) == \\"found\\" def test_can_find_subarray_large_numbers(): arr = [100000, -1, -2, 3, 99999] k = 100000 assert can_find_subarray(arr, k) == \\"found\\"","solution":"from typing import List def can_find_subarray(arr: List[int], k: int) -> str: Determines if there exists a contiguous subarray that sums to the given target value k. Returns \\"found\\" if such a subarray exists, otherwise returns \\"not found\\". current_sum = 0 sum_map = {0: -1} # To handle the case where the subarray starts from index 0 for idx, num in enumerate(arr): current_sum += num if (current_sum - k) in sum_map: return \\"found\\" sum_map[current_sum] = idx return \\"not found\\""},{"question":"from typing import List, Tuple def final_heights(N: int, Q: int, heights: List[int], spells: List[Tuple[int, int, int]]) -> List[int]: Determine the final height of each tree after executing all the spells. Args: N (int): the number of trees. Q (int): the number of spells. heights (List[int]): the initial heights of the trees. spells (List[Tuple[int, int, int]]): a list of spells where each spell is represented as a tuple (T, L, R). Returns: List[int]: the final heights of the trees after applying all the spells. Example: >>> final_heights(5, 3, [2, 3, 1, 4, 5], [(1, 1, 3), (-1, 2, 4), (1, 3, 5)]) [3, 3, 2, 4, 6] >>> final_heights(1, 3, [10], [(1, 1, 1), (-1, 1, 1), (1, 1, 1)]) [11] >>> final_heights(4, 4, [1, 2, 3, 4], [(1, 1, 4), (1, 1, 4), (-1, 1, 4), (-1, 1, 4)]) [1, 2, 3, 4] >>> final_heights(3, 0, [10, 20, 30], []) [10, 20, 30] >>> final_heights(3, 2, [1000000000, 1000000000, 1000000000], [(1, 1, 3), (-1, 2, 2)]) [1000000001, 1000000000, 1000000001]","solution":"def final_heights(N, Q, heights, spells): delta = [0] * (N + 1) # using (N + 1) to handle range update easily # Apply all spells using a difference array approach for T, L, R in spells: delta[L-1] += T if R < N: delta[R] -= T # Calculate the final heights using the accumulated delta effect curr_delta = 0 for i in range(N): curr_delta += delta[i] heights[i] += curr_delta return heights"},{"question":"def min_edit_distance(s1: str, s2: str) -> int: Given two strings, s1 and s2, determine the minimum number of operations required to convert s1 into s2. You can perform the following operations on the string s1: 1. Insert a character 2. Remove a character 3. Replace a character with another one Each operation has a cost of 1. Args: s1 (str): the initial string. s2 (str): the final string. Returns: int: the minimum number of operations needed to convert s1 into s2. Example: >>> min_edit_distance(\\"initial\\", \\"final\\") # 4 >>> min_edit_distance(\\"abc\\", \\"yabd\\") # 2","solution":"def min_edit_distance(s1, s2): Returns the minimum number of operations required to convert s1 to s2. m, n = len(s1), len(s2) # Create a table to store results of subproblems dp = [[0 for x in range(n+1)] for x in range(m+1)] # Fill dp[][] in bottom up manner for i in range(m+1): for j in range(n+1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # Min. operations = j # If second string is empty, only option is to remove all characters of second string elif j == 0: dp[i][j] = i # Min. operations = i # If last characters are same, ignore last character and recur for remaining string elif s1[i-1] == s2[j-1]: dp[i][j] = dp[i-1][j-1] # If last characters are different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j-1], # Insert dp[i-1][j], # Remove dp[i-1][j-1]) # Replace return dp[m][n]"},{"question":"from typing import List, Tuple def graph_diameter(n: int, m: int, roads: List[Tuple[int, int]]) -> int: Determine the diameter of a graph from given number of stations and roads. >>> graph_diameter(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 2 >>> graph_diameter(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4 pass # Unit tests def test_example_1(): n = 4 m = 4 roads = [(1, 2), (2, 3), (3, 4), (4, 1)] assert graph_diameter(n, m, roads) == 2 def test_example_2(): n = 5 m = 4 roads = [(1, 2), (2, 3), (3, 4), (4, 5)] assert graph_diameter(n, m, roads) == 4 def test_single_edge(): n = 2 m = 1 roads = [(1, 2)] assert graph_diameter(n, m, roads) == 1 def test_tree_structure(): n = 7 m = 6 roads = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)] assert graph_diameter(n, m, roads) == 4 def test_circle_graph(): n = 6 m = 6 roads = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)] assert graph_diameter(n, m, roads) == 3","solution":"from collections import deque def bfs(graph, start): Perform BFS starting from the vertex \`start\` and return the farthest node and its distance. visited = [-1] * len(graph) visited[start] = 0 q = deque([start]) farthest_node = start max_distance = 0 while q: node = q.popleft() for neighbor in graph[node]: if visited[neighbor] == -1: visited[neighbor] = visited[node] + 1 q.append(neighbor) if visited[neighbor] > max_distance: max_distance = visited[neighbor] farthest_node = neighbor return farthest_node, max_distance def graph_diameter(n, m, roads): graph = [[] for _ in range(n)] for u, v in roads: graph[u-1].append(v-1) graph[v-1].append(u-1) # Perform BFS from an arbitrary node (node 0) farthest_node, _ = bfs(graph, 0) # Perform BFS from the farthest node found above _, diameter = bfs(graph, farthest_node) return diameter # Example of usage: # n = 5, m = 4 # roads = [(1, 2), (2, 3), (3, 4), (4, 5)] # result = graph_diameter(n, m, roads) # print(result) # Output should be 4"},{"question":"def evaluateExpression(S: str) -> int: Evaluates the arithmetic expression given in the string S. The expression contains non-negative integers and '+' and '-' operators. >>> evaluateExpression(\\"3+5-2+8\\") 14 >>> evaluateExpression(\\"10-20+30-5\\") 15 >>> evaluateExpression(\\"42\\") 42 >>> evaluateExpression(\\"1+2+3+4+5\\") 15 >>> evaluateExpression(\\"10-1-2-3-4\\") 0 >>> evaluateExpression(\\"003+5-010\\") -2 >>> evaluateExpression(\\"1000000+2000000-300000\\") 2700000","solution":"def evaluateExpression(S): Evaluates the arithmetic expression given in the string S. The expression contains non-negative integers and '+' and '-' operators. # Initialize variables result = 0 current_number = 0 sign = 1 # 1 for positive, -1 for negative for ch in S: if ch.isdigit(): current_number = current_number * 10 + int(ch) elif ch == '+': result += sign * current_number current_number = 0 sign = 1 elif ch == '-': result += sign * current_number current_number = 0 sign = -1 # Add the last number to the result result += sign * current_number return result"},{"question":"def total_quantity(shopping_list: str) -> int: Returns the total quantity of items in the shopping list. Parameters: shopping_list (str): A string representing the shopping list, where each line is in the format \\"<quantity> <item_name>\\". Returns: int: The total quantity of items. >>> total_quantity(\\"2 apples\\") 2 >>> total_quantity(\\"2 applesn3 bananasn1 orange\\") 6 >>> total_quantity(\\"\\") 0 >>> total_quantity(\\"4 oranges\\") 4 >>> total_quantity(\\"2 applesn3 bananasn1 orangen\\") 6 >>> total_quantity(\\"0 applesn0 bananasn0 oranges\\") 0 >>> total_quantity(\\"5 pearsn6 grapes\\") 11","solution":"def total_quantity(shopping_list): Returns the total quantity of items in the shopping list. Parameters: shopping_list (str): A string representing the shopping list, where each line is in the format \\"<quantity> <item_name>\\". Returns: int: The total quantity of items. total = 0 lines = shopping_list.split('n') for line in lines: if line.strip(): quantity = int(line.split()[0]) total += quantity return total"},{"question":"def largest_balanced_subarray_length(A): Given an array A, find the size of the largest contiguous subarray which has an equal number of positive and negative numbers. >>> largest_balanced_subarray_length([1, -1, 1, -1]) 4 >>> largest_balanced_subarray_length([1, 2, -2, -1, 2]) 4 >>> largest_balanced_subarray_length([1, 2, 3, 4]) 0 >>> largest_balanced_subarray_length([-1, -2, 2, 1]) 4 >>> largest_balanced_subarray_length([-1, 1, -1, 1, -1, 1]) 6 >>> largest_balanced_subarray_length([1, -1, 1, -1, 1, -1, 1]) 6 >>> largest_balanced_subarray_length([1, -1, 2, -2, -3, 3, 4, -4]) 8 >>> largest_balanced_subarray_length([]) 0 pass def process_test_cases(T, test_cases): Given the number of test cases T and a list of tuples representing the test cases, for each test case, find the size of the largest contiguous subarray with an equal number of positive and negative numbers. The output should be a list of results for each test case. >>> process_test_cases(2, [(4, [1, -1, 1, -1]), (5, [1, 2, -2, -1, 2])]) [4, 4] >>> process_test_cases(2, [(4, [1, 2, 3, 4]), (4, [-1, -2, 2, 1])]) [0, 4] pass","solution":"def largest_balanced_subarray_length(A): Given an array A, find the size of the largest contiguous subarray which has an equal number of positive and negative numbers. n = len(A) balance_count = {0: -1} # Initialize the dictionary with balance 0 at index -1. max_len = 0 balance = 0 for i in range(n): if A[i] > 0: balance += 1 elif A[i] < 0: balance -= 1 if balance in balance_count: max_len = max(max_len, i - balance_count[balance]) else: balance_count[balance] = i return max_len def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] results.append(largest_balanced_subarray_length(A)) return results"},{"question":"def sort_digits(n: int) -> int: Sort the digits of the input integer \`n\` in ascending order and preserve the sign. Args: n (int): The integer to sort. Returns: int: A new integer with digits sorted in ascending order. Examples: >>> sort_digits(42145) 12445 >>> sort_digits(-42145) -12445 >>> sort_digits(0) 0 # Your code here","solution":"def sort_digits(n: int) -> int: Sorts the digits of the input integer \`n\` in ascending order and preserves the sign. Args: n (int): The integer to sort. Returns: int: A new integer with digits sorted in ascending order. if n == 0: return 0 sign = -1 if n < 0 else 1 n_str = str(abs(n)) sorted_digits = ''.join(sorted(n_str)) sorted_number = int(sorted_digits) return sign * sorted_number"},{"question":"def is_city_disconnected(n, m, roads, t): Determines if it's possible to disconnect the city by closing roads with a cost >= T. Args: - n (int): the number of intersections. - m (int): the number of roads. - roads (List[Tuple[int, int, int]]): list of roads specified by tuples (U, V, C). - t (int): the cost threshold. Returns: - str: \\"YES\\" if it's possible to disconnect the city by closing roads with a cost >= T, otherwise \\"NO\\". Example: >>> is_city_disconnected(5, 6, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (1, 5, 2), (2, 4, 7)], 5) \\"YES\\" >>> is_city_disconnected(4, 3, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], 5) \\"NO\\" from solution import is_city_disconnected def test_example_case(): input_n = 5 input_m = 6 input_roads = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (1, 5, 2), (2, 4, 7) ] input_t = 5 assert is_city_disconnected(input_n, input_m, input_roads, input_t) == \\"YES\\" def test_no_roads(): input_n = 3 input_m = 0 input_roads = [] input_t = 1 assert is_city_disconnected(input_n, input_m, input_roads, input_t) == \\"YES\\" def test_single_component(): input_n = 4 input_m = 3 input_roads = [ (1, 2, 1), (2, 3, 2), (3, 4, 3) ] input_t = 5 assert is_city_disconnected(input_n, input_m, input_roads, input_t) == \\"NO\\" def test_disconnected_after_removal(): input_n = 4 input_m = 4 input_roads = [ (1, 2, 1), (2, 3, 6), (3, 4, 7), (1, 3, 8) ] input_t = 6 assert is_city_disconnected(input_n, input_m, input_roads, input_t) == \\"YES\\" def test_all_roads_below_threshold(): input_n = 3 input_m = 3 input_roads = [ (1, 2, 1), (2, 3, 2), (1, 3, 3) ] input_t = 10 assert is_city_disconnected(input_n, input_m, input_roads, input_t) == \\"NO\\"","solution":"def is_city_disconnected(n, m, roads, t): from collections import defaultdict, deque # Build graph excluding roads with cost >= T graph = defaultdict(list) for u, v, c in roads: if c < t: graph[u].append(v) graph[v].append(u) # Check connectivity using BFS/DFS visited = set() def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Select the first node with any connection for start in range(1, n + 1): if graph[start]: break # If all nodes have no connections, it's already disconnected if not graph[start]: return \\"YES\\" # BFS from the start node visited.add(start) bfs(start) # If not all nodes are visited, the graph is disconnected return \\"YES\\" if len(visited) != n else \\"NO\\" # Example to test: input_n = 5 input_m = 6 input_roads = [ (1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6), (1, 5, 2), (2, 4, 7) ] input_t = 5 print(is_city_disconnected(input_n, input_m, input_roads, input_t)) # Expected output: \\"YES\\""},{"question":"def balanceDrivingDistances(distances): Calculate the additional distance each friend should have driven to balance the distances. >>> balanceDrivingDistances([100, 200, 150]) [-50, 50, 0] >>> balanceDrivingDistances([90, 70, 80, 60]) [15, -5, 5, -15]","solution":"def balanceDrivingDistances(distances): Calculates the additional distance each friend should have driven to balance the distances. Args: distances (list): A list of integers representing the distance driven by each friend. Returns: list: A list of integers representing the distance each friend should have driven (or zeros if already balanced). n = len(distances) total_distance = sum(distances) avg_distance = total_distance // n result = [distance - avg_distance for distance in distances] return result"},{"question":"def vowel_frequency(s): Determine the frequency of each vowel (a, e, i, o, u) in the input string. Prints the frequency of each vowel in the string in the following format: vowel=frequency. Each vowel and its frequency should be printed on a new line, and the vowels should be output in the order 'a', 'e', 'i', 'o', 'u'. >>> vowel_frequency(\\"hellothere\\") e=3 o=1 >>> vowel_frequency(\\"beautiful\\") a=1 e=1 i=1 u=2","solution":"def vowel_frequency(s): Returns the frequency of each vowel in the string s. vowels = 'aeiou' frequency = {v: s.count(v) for v in vowels if s.count(v) > 0} for v in vowels: if v in frequency: print(f\\"{v}={frequency[v]}\\") # Example usage # vowel_frequency(\\"hellothere\\") # Output: # e=3 # o=1 # vowel_frequency(\\"beautiful\\") # Output: # a=1 # e=1 # i=1 # u=2"},{"question":"def generate_code(k: int, m: int, frequent_codes: List[str]) -> str: Generates a valid security code for a high-tech vault. Parameters: k (int): The length of the security code. m (int): The number of \\"frequent\\" codes that should be avoided. frequent_codes (list): A list of m frequent codes that should be avoided. Returns: str: A valid security code of length k, or an empty string if no valid code is possible. >>> generate_code(4, 2, [\\"1234\\", \\"5678\\"]) # Example 1 \\"1000\\" >>> generate_code(3, 3, [\\"123\\", \\"234\\", \\"345\\"]) # Example 2 \\"100\\" >>> generate_code(2, 1, [\\"99\\"]) # Example 3 \\"10\\" from typing import List def test_no_frequent_codes(): k = 4 m = 0 frequent_codes = [] assert generate_code(k, m, frequent_codes) == '1000' def test_all_possible_codes_frequent(): k = 1 m = 10 frequent_codes = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'] assert generate_code(k, m, frequent_codes) == \\"\\" def test_single_frequent_code(): k = 3 m = 1 frequent_codes = ['555'] assert generate_code(k, m, frequent_codes) == '100' def test_multiple_frequent_codes(): k = 3 m = 3 frequent_codes = ['123', '234', '345'] code = generate_code(k, m, frequent_codes) # The result is valid if it meets these conditions assert len(code) == k assert code not in frequent_codes assert code[0] != '0' # Code cannot start with 0 def test_edge_case_empty_attempt_no_k_digit(): k = 2 m = 1 frequent_codes = ['12'] assert generate_code(k, m, frequent_codes) == '10'","solution":"def generate_code(k, m, frequent_codes): Generates a valid security code for a high-tech vault. Parameters: k (int): The length of the security code. m (int): The number of \\"frequent\\" codes that should be avoided. frequent_codes (list): A list of m frequent codes that should be avoided. Returns: str: A valid security code of length k, or an empty string if no valid code is possible. # Attempt to generate a code starting from the lowest possible valid code for i in range(10**(k-1), 10**k): code = str(i) if code not in frequent_codes: return code return \\"\\""},{"question":"from typing import List, Tuple def find_min_residents_sum(N: int, M: int, residents: List[int], bridges: List[Tuple[int, int]], Q: int, queries: List[Tuple[int, int]]) -> List[int]: Find the minimum sum of residents along a path from H1 to H2 in several queries. >>> N = 6 >>> M = 7 >>> residents = [10, 20, 30, 40, 50, 60] >>> bridges = [(1, 2), (1, 3), (2, 4), (3, 4), (3, 5), (4, 5), (5, 6)] >>> Q = 3 >>> queries = [(1, 6), (2, 3), (4, 5)] >>> find_min_residents_sum(N, M, residents, bridges, Q, queries) [150, 60, 90]","solution":"import heapq from collections import defaultdict, deque def find_min_residents_sum(N, M, residents, bridges, Q, queries): def dijkstra(start, end): # Min-heap priority queue heap = [(residents[start - 1], start)] # (current_residents_sum, current_house) visited = set() dist = {i: float('inf') for i in range(1, N + 1)} dist[start] = residents[start - 1] while heap: curr_residents_sum, curr_house = heapq.heappop(heap) if curr_house == end: return curr_residents_sum if curr_house in visited: continue visited.add(curr_house) for neighbor in graph[curr_house]: new_resident_sum = curr_residents_sum + residents[neighbor - 1] if new_resident_sum < dist[neighbor]: dist[neighbor] = new_resident_sum heapq.heappush(heap, (new_resident_sum, neighbor)) return float('inf') # No path found # Create graph graph = defaultdict(list) for a, b in bridges: graph[a].append(b) graph[b].append(a) results = [] for h1, h2 in queries: results.append(dijkstra(h1, h2)) return results"},{"question":"def process_transactions(input_lines): Processes a list of transaction strings and returns the final balances of accounts. Args: input_lines (list): List of transaction strings in the specified format. Returns: dict: A dictionary with account numbers as keys and their final balance as values. accounts = {} # Add implementation here return accounts def format_balances(balances): Formats the balance dictionary into a list of strings as required for the output. Args: balances (dict): A dictionary with account numbers as keys and their final balance as values. Returns: list: A list of strings in the format \\"account_number balance\\" in the order accounts appeared first. output_lines = [] # Add implementation here return output_lines def main(input_lines): Integrates processing and formatting of transactions into a single function that takes a list of input lines. Args: input_lines (list): List of transaction strings in the specified format. Returns: list: A list of strings in the format \\"account_number balance\\" as the final output. balances = process_transactions(input_lines) return format_balances(balances) # Example usage if __name__ == \\"__main__\\": input_data = [ \\"A123 D 1000\\", \\"B456 D 2000\\", \\"A123 W 500\\", \\"A123 D 200\\", \\"B456 W 300\\", \\"END\\" ] print(main(input_data)) # Unit tests def test_single_transaction_deposit(): input_data = [ \\"A123 D 1000\\", \\"END\\" ] expected_output = [ \\"A123 1000\\" ] assert main(input_data) == expected_output def test_single_transaction_withdrawal(): input_data = [ \\"A123 W 500\\", \\"END\\" ] expected_output = [ \\"A123 -500\\" ] assert main(input_data) == expected_output def test_multiple_transactions_same_account(): input_data = [ \\"A123 D 1000\\", \\"A123 W 500\\", \\"A123 D 200\\", \\"END\\" ] expected_output = [ \\"A123 700\\" ] assert main(input_data) == expected_output def test_multiple_accounts(): input_data = [ \\"A123 D 1000\\", \\"B456 D 2000\\", \\"A123 W 500\\", \\"A123 D 200\\", \\"B456 W 300\\", \\"END\\" ] expected_output = [ \\"A123 700\\", \\"B456 1700\\" ] assert main(input_data) == expected_output def test_edge_case_large_amounts(): input_data = [ \\"A123 D 10000\\", \\"B456 D 9999\\", \\"A123 W 5000\\", \\"END\\" ] expected_output = [ \\"A123 5000\\", \\"B456 9999\\" ] assert main(input_data) == expected_output","solution":"def process_transactions(input_lines): Processes a list of transaction strings and returns the final balances of accounts. Args: input_lines (list): List of transaction strings in the specified format. Returns: dict: A dictionary with account numbers as keys and their final balance as values. accounts = {} for line in input_lines: if line.strip() == \\"END\\": break parts = line.split() account_number = parts[0] operation = parts[1] amount = int(parts[2]) if account_number not in accounts: accounts[account_number] = 0 if operation == \\"D\\": accounts[account_number] += amount elif operation == \\"W\\": accounts[account_number] -= amount return accounts def format_balances(balances): Formats the balance dictionary into a list of strings as required for the output. Args: balances (dict): A dictionary with account numbers as keys and their final balance as values. Returns: list: A list of strings in the format \\"account_number balance\\" in the order accounts appeared first. output_lines = [] for account_number, balance in balances.items(): output_lines.append(f\\"{account_number} {balance}\\") return output_lines def main(input_lines): balances = process_transactions(input_lines) return format_balances(balances)"},{"question":"def are_permutations(str1: str, str2: str) -> bool: Determines if one string is a permutation of the other. >>> are_permutations(\\"listen\\", \\"silent\\") True >>> are_permutations(\\"hello\\", \\"billion\\") False >>> are_permutations(\\"a\\", \\"a\\") True >>> are_permutations(\\"a\\", \\"b\\") False >>> are_permutations(\\"abc\\", \\"abcd\\") False >>> are_permutations(\\"aabbcc\\", \\"abcabc\\") True >>> are_permutations(\\"AaBbCc\\", \\"bCaBcA\\") True >>> are_permutations(\\"aB\\", \\"ba\\") False pass","solution":"def are_permutations(str1, str2): Determines if one string is a permutation of the other. if len(str1) != len(str2): return False # Sort both strings and compare return sorted(str1) == sorted(str2)"},{"question":"def isAnagram(str1: str, str2: str) -> bool: Checks if the two provided strings are anagrams of each other. The function ignores spaces and is case insensitive. >>> isAnagram(\\"listen\\", \\"silent\\") True >>> isAnagram(\\"hello\\", \\"bye\\") False >>> isAnagram(\\"Astronomer\\", \\"Moon starer\\") True >>> isAnagram(\\"LiStEn\\", \\"SiLeNt\\") True >>> isAnagram(\\"Astronomer \\", \\" Moon starer \\") True >>> isAnagram(\\"aabbcc\\", \\"abc\\") False >>> isAnagram(\\"\\", \\"\\") True >>> isAnagram(\\"A\\", \\"a\\") True >>> isAnagram(\\"A\\", \\"b\\") False","solution":"def isAnagram(str1, str2): Checks if the two provided strings are anagrams of each other. The function ignores spaces and is case insensitive. # Remove spaces and convert to lower case cleaned_str1 = ''.join(str1.lower().split()) cleaned_str2 = ''.join(str2.lower().split()) # Check if sorted characters are the same return sorted(cleaned_str1) == sorted(cleaned_str2)"},{"question":"import re def isPalindrome(s: str) -> bool: Determines if the input string is a palindrome, ignoring non-alphanumeric characters and case sensitivity. >>> isPalindrome(\\"A man, a plan, a canal, Panama\\") True >>> isPalindrome(\\"No 'x' in Nixon\\") True >>> isPalindrome(\\"Hello, World!\\") False","solution":"import re def isPalindrome(s): Determines if the input string is a palindrome, ignoring non-alphanumeric characters and case sensitivity. Parameters: s (str): The input string. Returns: bool: True if the string is a palindrome, False otherwise. # Remove non-alphanumeric characters and convert to lower case filtered_str = re.sub(r'[^a-zA-Z0-9]', '', s).lower() # Check if the filtered string is equal to its reverse return filtered_str == filtered_str[::-1]"},{"question":"import math def min_cuts(n: int, m: int, a: int) -> int: Determine the minimum number of cuts required to divide the field into rectangular sub-fields such that no sub-field has an area greater than \`a\` units. >>> min_cuts(3, 4, 4) 2 >>> min_cuts(1, 1, 1) 0 >>> min_cuts(5, 5, 4) 4 >>> min_cuts(10, 15, 10) 7 >>> min_cuts(10**9, 10**9, 10**18) 0","solution":"import math def min_cuts(n, m, a): Returns the minimum number of cuts required to ensure no sub-field has an area greater than a units. # Calculate number of necessary vertical and horizontal subfields vert_cuts = math.ceil(n / math.sqrt(a)) - 1 hor_cuts = math.ceil(m / math.sqrt(a)) - 1 total_cuts = vert_cuts + hor_cuts return int(total_cuts)"},{"question":"def custom_sort(n: int, integers: List[int]) -> List[int]: Sorts integers such that all even integers appear before any odd integers. Within their respective groups, the numbers are sorted in descending order. :param n: Integer representing the number of integers in the list. :param integers: List of integers to be sorted. :return: List of integers sorted by the specified rules. >>> custom_sort(5, [3, 1, 4, 1, 5]) [4, 5, 3, 1, 1] >>> custom_sort(6, [9, 8, 7, 6, 5, 4]) [8, 6, 4, 9, 7, 5]","solution":"def custom_sort(n, integers): Sorts integers such that all even integers appear before any odd integers. Within their respective groups, the numbers are sorted in descending order. :param n: Integer representing the number of integers in the list. :param integers: List of integers to be sorted. :return: List of integers sorted by the specified rules. evens = [x for x in integers if x % 2 == 0] odds = [x for x in integers if x % 2 != 0] sorted_evens = sorted(evens, reverse=True) sorted_odds = sorted(odds, reverse=True) return sorted_evens + sorted_odds"},{"question":"def can_form_palindrome(s: str) -> str: Determines if the characters of the input string can be rearranged to form a palindrome. Parameters: s (str): The input string Returns: str: \\"Yes\\" if the characters can be rearranged to form a palindrome, otherwise \\"No\\" Examples: >>> can_form_palindrome(\\"civic\\") \\"Yes\\" >>> can_form_palindrome(\\"ivicc\\") \\"Yes\\" >>> can_form_palindrome(\\"hello\\") \\"No\\"","solution":"def can_form_palindrome(s): Determines if the characters of the input string can be rearranged to form a palindrome. Parameters: s (str): The input string Returns: str: \\"Yes\\" if the characters can be rearranged to form a palindrome, otherwise \\"No\\" from collections import Counter # Remove spaces from the string and convert to lower case s = s.replace(\\" \\", \\"\\").lower() # Count the occurrences of each character char_count = Counter(s) # Count how many characters have an odd number of occurrences odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged to form a palindrome if at most one character has an odd count if odd_count <= 1: return \\"Yes\\" else: return \\"No\\""},{"question":"def inventory_management_system(operations): Inventory Management System for a bookstore. Args: operations (List[Tuple[str, ...]]): A list of operations where the first element of the tuple is the operation ('add', 'remove', 'search', 'list') and the subsequent elements are the arguments for that operation. Returns: List: A list of results based on the operation: - For 'add' and 'remove', return None. - For 'search', return the book's details as a dictionary. - For 'list', return a list of titles. Example: >>> operations = [ ('add', 'The Da Vinci Code', 'Dan Brown', 'Thriller', 15.99), ('search', 'The Da Vinci Code') ] >>> inventory_management_system(operations) [None, {'title': 'The Da Vinci Code', 'author': 'Dan Brown', 'genre': 'Thriller', 'price': 15.99}]","solution":"def inventory_management_system(operations): inventory = {} def add_book(title, author, genre, price): normalized_title = title.lower() inventory[normalized_title] = { 'title': title, 'author': author, 'genre': genre, 'price': price } def remove_book(title): normalized_title = title.lower() if normalized_title in inventory: del inventory[normalized_title] def search_book(title): normalized_title = title.lower() return inventory.get(normalized_title) def list_books(genre): normalized_genre = genre.lower() return [book['title'] for book in inventory.values() if book['genre'].lower() == normalized_genre] results = [] for operation in operations: if operation[0] == 'add': _, title, author, genre, price = operation add_book(title, author, genre, price) results.append(None) elif operation[0] == 'remove': _, title = operation remove_book(title) results.append(None) elif operation[0] == 'search': _, title = operation results.append(search_book(title)) elif operation[0] == 'list': _, genre = operation results.append(list_books(genre)) return results"},{"question":"def number_to_words(n): Convert numbers to words for given integer 0 <= n < 100. pass def amountToWords(amount): Converts an amount in cents to words representing dollars and cents. Parameters: amount (int): The amount in cents. Returns: str: The amount in words. Examples: >>> amountToWords(1234) 'twelve dollars and thirty-four cents' >>> amountToWords(45) 'zero dollars and forty-five cents' >>> amountToWords(100) 'one dollar and zero cents' pass","solution":"def number_to_words(n): Convert numbers to words for given integer 0 <= n < 100. words_1_to_19 = [ \\"zero\\", \\"one\\", \\"two\\", \\"three\\", \\"four\\", \\"five\\", \\"six\\", \\"seven\\", \\"eight\\", \\"nine\\", \\"ten\\", \\"eleven\\", \\"twelve\\", \\"thirteen\\", \\"fourteen\\", \\"fifteen\\", \\"sixteen\\", \\"seventeen\\", \\"eighteen\\", \\"nineteen\\" ] words_tens = [ \\"\\", \\"\\", \\"twenty\\", \\"thirty\\", \\"forty\\", \\"fifty\\", \\"sixty\\", \\"seventy\\", \\"eighty\\", \\"ninety\\" ] if n < 20: return words_1_to_19[n] else: if n % 10 == 0: return words_tens[n // 10] else: return words_tens[n // 10] + \\"-\\" + words_1_to_19[n % 10] def amountToWords(amount): Converts an amount in cents to words representing dollars and cents. Parameters: amount (int): The amount in cents. Returns: str: The amount in words. dollars = amount // 100 cents = amount % 100 if dollars == 1: dollars_word = number_to_words(dollars) + \\" dollar\\" else: dollars_word = number_to_words(dollars) + \\" dollars\\" if cents == 1: cents_word = number_to_words(cents) + \\" cent\\" else: cents_word = number_to_words(cents) + \\" cents\\" return dollars_word + \\" and \\" + cents_word"},{"question":"def can_form_sum(N: int, S: int, powers: List[int]) -> str: Determine whether it is possible to form a subset of the magical powers such that their sum is exactly S. Args: N: int - number of animals S: int - required sum powers: List of int - magical powers of the animals Returns: str: \\"YES\\" if there is a subset with sum exactly S, otherwise \\"NO\\" Examples: >>> can_form_sum(5, 3, [1, 2, 3, 4, 5]) == \\"YES\\" >>> can_form_sum(4, 11, [1, 2, 3, 4]) == \\"NO\\"","solution":"def can_form_sum(N, S, powers): Determine whether it is possible to form a subset of the magical powers such that their sum is exactly S. Args: N: int - number of animals S: int - required sum powers: list of int - magical powers of the animals Returns: str: \\"YES\\" if there is a subset with sum exactly S, otherwise \\"NO\\" # Initialize a set to keep track of all achievable sums achievable_sums = set([0]) for power in powers: new_sums = set() for existing_sum in achievable_sums: new_sums.add(existing_sum + power) achievable_sums.update(new_sums) if S in achievable_sums: return \\"YES\\" return \\"NO\\""},{"question":"def findSmallestSubarray(nums, target): Find the length of the smallest contiguous subarray with a sum >= target. If no such subarray exists, return 0. >>> findSmallestSubarray([2, 3, 1, 2, 4, 3], 7) 2 >>> findSmallestSubarray([1, 1, 1, 1, 1, 1, 1, 1], 11) 0","solution":"def findSmallestSubarray(nums, target): Find the length of the smallest contiguous subarray with a sum >= target. If no such subarray exists, return 0. n = len(nums) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += nums[end] while current_sum >= target: min_length = min(min_length, end - start + 1) current_sum -= nums[start] start += 1 return 0 if min_length == float('inf') else min_length"},{"question":"def top_student(students): Returns the name of the student with the highest average grade. If multiple students have the same highest average grade, return the name of the one who appears first in the list. >>> students = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 22, \\"grades\\": [88, 90, 85]}, ... {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"grades\\": [75, 80, 79]}, ... {\\"name\\": \\"Charlie\\", \\"age\\": 21, \\"grades\\": [95, 90, 100]} ... ] >>> top_student(students) 'Charlie' >>> students = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 22, \\"grades\\": [90, 90, 90]}, # average = 90 ... {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"grades\\": [85, 95, 90]}, # average = 90 ... {\\"name\\": \\"Charlie\\", \\"age\\": 21, \\"grades\\": [70, 80, 90]} # average = 80 ... ] >>> top_student(students) 'Alice' >>> students = [ ... {\\"name\\": \\"Alice\\", \\"age\\": 22, \\"grades\\": [85, 90, 95]}, # average = 90 ... {\\"name\\": \\"Bob\\", \\"age\\": 23, \\"grades\\": [90, 90, 90]}, # average = 90 ... {\\"name\\": \\"Charlie\\", \\"age\\": 21, \\"grades\\": [95, 85, 90]} # average = 90 ... ] >>> top_student(students) 'Alice' >>> students = [] >>> top_student(students) '' >>> students = [{\\"name\\": \\"Alice\\", \\"age\\": 22, \\"grades\\": [90, 90, 90]}] >>> top_student(students) 'Alice'","solution":"def top_student(students): Returns the name of the student with the highest average grade. If multiple students have the same highest average grade, return the name of the one who appears first in the list. top_student_name = \\"\\" highest_average = 0 for student in students: average_grade = sum(student[\\"grades\\"]) / len(student[\\"grades\\"]) if average_grade > highest_average: highest_average = average_grade top_student_name = student[\\"name\\"] return top_student_name"},{"question":"class Solution: def permute(self, nums): Generate all permutations of an array of distinct integers. Args: nums (List[int]): List of distinct integers. Returns: List[List[int]]: A list of all permutations. Example: >>> solution = Solution() >>> solution.permute([1, 2, 3]) [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]] >>> solution.permute([0, 1]) [[0, 1], [1, 0]]","solution":"class Solution: def permute(self, nums): def backtrack(first=0): if first == len(nums): output.append(nums[:]) for i in range(first, len(nums)): nums[first], nums[i] = nums[i], nums[first] backtrack(first + 1) nums[first], nums[i] = nums[i], nums[first] output = [] backtrack() return output"},{"question":"def fibonacci(n): Returns the nth Fibonacci number. >>> fibonacci(5) 5 >>> fibonacci(10) 55","solution":"def fibonacci(n): Returns the nth Fibonacci number. if n <= 0: raise ValueError(\\"Input must be a positive integer\\") a, b = 0, 1 for _ in range(n-1): a, b = b, a + b return b"},{"question":"def longestPalindrome(S: str) -> int: Returns the length of the longest palindrome that can be formed using the characters in the string S. >>> longestPalindrome(\\"abccccdd\\") 7 >>> longestPalindrome(\\"a\\") 1","solution":"def longestPalindrome(S): Returns the length of the longest palindrome that can be formed using the characters in the string S. from collections import Counter char_count = Counter(S) length = 0 odd_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_found = True # Add one if any odd count was found, to place a single char in the middle if odd_found: length += 1 return length"},{"question":"def max_sprinklers(n: int, m: int) -> Tuple[int, int]: Return the size of the square section k and the maximum number of non-overlapping k x k sections that can be watered in a garden of dimensions n x m. >>> max_sprinklers(5, 5) (5, 1) >>> max_sprinklers(6, 6) (6, 1) >>> max_sprinklers(6, 9) (6, 1) >>> max_sprinklers(9, 6) (6, 1) >>> max_sprinklers(10, 10) (10, 1) >>> max_sprinklers(7, 5) (5, 1) >>> max_sprinklers(20, 25) (20, 1) pass","solution":"def max_sprinklers(n, m): Returns the size of the square section k and the maximum number of non-overlapping k x k sections that can be watered. k = min(n, m) max_sections = (n // k) * (m // k) return k, max_sections"},{"question":"def fibonacciCheck(n: int) -> int: Check if \`n\` is a Fibonacci number. If it is, return the n-th Fibonacci number, else return -1. Parameters: n (int): The number to be checked. Returns: int: The n-th Fibonacci number if \`n\` is part of the sequence, otherwise -1. Examples: >>> fibonacciCheck(5) 5 >>> fibonacciCheck(4) -1","solution":"def fibonacciCheck(n): Check if \`n\` is a Fibonacci number. If it is, return the n-th Fibonacci number, else return -1. Parameters: n (int): The number to be checked. Returns: int: The n-th Fibonacci number if \`n\` is part of the sequence, otherwise -1. if n == 0: return 0 elif n == 1: return 1 a, b = 0, 1 while b < n: a, b = b, a + b if b == n: return n else: return -1"},{"question":"def shortestLengthSameStartEnd(words: List[str]) -> int: Returns the length of the shortest word that starts and ends with the same letter. If no such word exists, returns -1. >>> shortestLengthSameStartEnd([\\"apple\\", \\"banana\\", \\"civic\\", \\"deed\\"]) == 4 >>> shortestLengthSameStartEnd([\\"open\\", \\"source\\", \\"programming\\"]) == -1 >>> shortestLengthSameStartEnd([\\"radar\\", \\"level\\", \\"rotor\\", \\"solos\\"]) == 5 >>> shortestLengthSameStartEnd([]) == -1 >>> shortestLengthSameStartEnd([\\"a\\", \\"b\\", \\"c\\"]) == 1","solution":"def shortestLengthSameStartEnd(words): Returns the length of the shortest word that starts and ends with the same letter. If no such word exists, returns -1. shortest_length = float('inf') # Initialize to infinity as we are looking for the minimum for word in words: if len(word) > 0 and word[0] == word[-1]: shortest_length = min(shortest_length, len(word)) # If no word found, return -1 return -1 if shortest_length == float('inf') else shortest_length"},{"question":"def count_design_ways(N: int, K: int) -> int: Calculate the number of different ways to design covers such that no two adjacent books have the same color. Args: N: int - The number of books. K: int - The number of colors available. Returns: int: The number of different ways to design covers such that no two adjacent books have the same color, modulo 10^9 + 7. >>> count_design_ways(3, 2) 2 >>> count_design_ways(1, 1) 1 >>> count_design_ways(2, 1) 0 >>> count_design_ways(2, 2) 2","solution":"MOD = 10**9 + 7 def count_design_ways(N, K): Calculate the number of different ways to design covers such that no two adjacent books have the same color if K == 1: return 1 if N == 1 else 0 dp = [0] * max(3, N+1) dp[1] = K dp[2] = K * (K - 1) % MOD for i in range(3, N + 1): dp[i] = (dp[i-1] * (K - 1)) % MOD return dp[N] # Example usage # print(count_design_ways(3, 2))"},{"question":"from typing import List def find_single_element(arr: List[int]) -> int: Find the single element that appears only once in the array \`arr\` where each other element appears twice. Expected Time Complexity: O(n) Expected Auxiliary Space: O(1) Examples: >>> find_single_element([2, 2, 1]) 1 >>> find_single_element([4, 1, 2, 1, 2]) 4","solution":"def find_single_element(arr): Returns the element that appears only once in the list \`arr\` where all other elements appear twice. Uses bitwise XOR to achieve O(n) time complexity and O(1) space complexity. result = 0 for num in arr: result ^= num return result"},{"question":"def min_difference_after_operations(N, A): Returns the minimum possible value of the difference between the maximum and minimum elements of the array A after any number of allowed operations. >>> min_difference_after_operations(5, [3, 1, 4, 1, 5]) 0 >>> min_difference_after_operations(3, [9, 7, 5]) 0 >>> min_difference_after_operations(4, [-1, -2, -3, -4]) 0 pass","solution":"def min_difference_after_operations(N, A): Returns the minimum possible value of the difference between the maximum and minimum elements of the array A after any number of allowed operations. return 0"},{"question":"def max_water_trapped(elevations): Calculate the maximum amount of water that can be trapped between the elevations. >>> max_water_trapped([0, 1, 0, 2, 1, 0]) 1 >>> max_water_trapped([0, 2, 1, 3, 0, 1, 2, 1, 2]) 5","solution":"def max_water_trapped(elevations): Calculate the maximum amount of water that can be trapped between the elevations. if not elevations: return 0 n = len(elevations) left_max = [0] * n right_max = [0] * n left_max[0] = elevations[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], elevations[i]) right_max[n - 1] = elevations[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], elevations[i]) water_trapped = 0 for i in range(n): water_trapped += min(left_max[i], right_max[i]) - elevations[i] return water_trapped"},{"question":"def factorial(num: int) -> int: Returns the factorial of a non-negative integer num. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. The factorial of 0 is 1. :param num: A non-negative integer :return: The factorial of the number >>> factorial(0) 1 >>> factorial(5) 120 >>> factorial(10) 3628800","solution":"def factorial(num): Returns the factorial of a non-negative integer num. The factorial of a non-negative integer n is the product of all positive integers less than or equal to n. The factorial of 0 is 1. :param num: A non-negative integer :return: The factorial of the number if num < 0: raise ValueError(\\"Input must be a non-negative integer.\\") if num == 0: return 1 result = 1 for i in range(1, num + 1): result *= i return result"},{"question":"def longestSubstringKDistinctCharacters(s: str, k: int) -> int: Determine the length of the longest substring that contains exactly k distinct characters. Parameters: s (str): the input string containing uppercase and lowercase English letters. k (int): the number of distinct characters. Returns: int: the length of the longest substring with exactly k distinct characters. >>> longestSubstringKDistinctCharacters(\\"aaabbcc\\", 2) 5 >>> longestSubstringKDistinctCharacters(\\"eceba\\", 2) 3","solution":"def longestSubstringKDistinctCharacters(s, k): Returns the length of the longest substring that contains exactly k distinct characters. Parameters: s (str): the input string containing uppercase and lowercase English letters. k (int): the number of distinct characters. Returns: int: the length of the longest substring with exactly k distinct characters. if k == 0 or not s: return 0 n = len(s) left = 0 right = 0 max_length = 0 char_count = {} while right < n: # Add the current character to the count dictionary char_count[s[right]] = char_count.get(s[right], 0) + 1 right += 1 # If the count dictionary has more than k distinct characters, shrink the window from the left while len(char_count) > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 # Whenever we have exactly k distinct characters, update the max_length if len(char_count) == k: max_length = max(max_length, right - left) return max_length"},{"question":"import os from collections import Counter import string def read_documents(directory): Reads all documents in the provided directory and returns a list of their contents. Args: directory (str): Path to the directory containing documents. Returns: List[str]: List of documents' contents. documents = [] for filename in os.listdir(directory): filepath = os.path.join(directory, filename) if os.path.isfile(filepath): with open(filepath, 'r') as file: documents.append(file.read()) return documents def preprocess(text): Preprocesses the given text by converting it to lowercase, removing punctuation, and splitting it into individual words. Args: text (str): Text to preprocess. Returns: List[str]: List of words from the preprocessed text. >>> preprocess(\\"Hello, World!\\") ['hello', 'world'] table = str.maketrans('', '', string.punctuation) return text.lower().translate(table).split() def get_word_frequencies(documents): Calculates the frequency of each word in the given list of documents. Args: documents (List[str]): List of documents. Returns: Counter: Frequency of each word in the documents. >>> get_word_frequencies([\\"Hello world\\", \\"world of Python\\"]) Counter({'world': 2, 'hello': 1, 'of': 1, 'python': 1}) word_freq = Counter() for doc in documents: words = preprocess(doc) word_freq.update(words) return word_freq def classify_document(uncategorized_document, training_data): Classifies the given uncategorized document into one of the categories in the training data based on word frequency similarity. Args: uncategorized_document (str): Document to classify. training_data (Dict[str, List[str]]): Pre-categorized training documents. Returns: str: Most probable category for the given document. >>> classify_document(\\"The new policy affects local businesses and has been the topic of discussion among government officials.\\", { ... \\"News\\": [\\"The government has announced new policies.\\", \\"Local elections are set for next month.\\"], ... \\"Sports\\": [\\"The football team won the championship.\\", \\"Basketball playoff games have started.\\"], ... \\"Entertainment\\": [\\"A new movie has been released this weekend.\\", \\"The concert tour dates have been announced.\\"] ... }) 'News' # Implementation goes here","solution":"import os from collections import Counter, defaultdict import string import math def read_documents(directory): documents = [] for filename in os.listdir(directory): filepath = os.path.join(directory, filename) if os.path.isfile(filepath): with open(filepath, 'r') as file: documents.append(file.read()) return documents def preprocess(text): Basic preprocessing of text by: - Converting to lowercase - Removing punctuation table = str.maketrans('', '', string.punctuation) return text.lower().translate(table).split() def get_word_frequencies(documents): word_freq = Counter() for doc in documents: words = preprocess(doc) word_freq.update(words) return word_freq def classify_document(uncategorized_document, training_data): word_frequencies = {category: get_word_frequencies(docs) for category, docs in training_data.items()} # Preprocess the uncategorized document uncat_words = preprocess(uncategorized_document) uncat_word_freq = Counter(uncat_words) # Determine the score for each category based on word frequencies scores = {category: 0 for category in training_data} for word, count in uncat_word_freq.items(): for category, wf in word_frequencies.items(): if word in wf: if wf[word] != 0: scores[category] += math.log(1 + wf[word]) * count # Return the category with the highest score return max(scores, key=scores.get) def classify_new_document(uncategorized_document, data_dir='data'): # Read and categorize the training documents training_data = {} for category in ['News', 'Sports', 'Entertainment']: training_data[category] = read_documents(os.path.join(data_dir, category)) return classify_document(uncategorized_document, training_data)"},{"question":"from typing import List, Tuple def bipartite_graphs(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Determine if each graph is bipartite given a number of test cases. Args: T (int): number of test cases test_cases (List[Tuple[int, int, List[Tuple[int, int]]]]): each test case contains: - number of vertices (int) - number of edges (int) - list of edges as tuples (u, v) Returns: List[str]: list of strings \\"YES\\" or \\"NO\\" for each test case >>> bipartite_graphs(2, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]), (5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)])]) [\\"YES\\", \\"NO\\"] >>> bipartite_graphs(1, [(1, 0, [])]) [\\"YES\\"] >>> bipartite_graphs(1, [(2, 1, [(1, 2)])]) [\\"YES\\"] >>> bipartite_graphs(1, [(2, 0, [])]) [\\"YES\\"] >>> bipartite_graphs(1, [(3, 3, [(1, 2), (2, 3), (3, 1)])]) [\\"NO\\"] >>> bipartite_graphs(1, [(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)])]) [\\"YES\\"] >>> bipartite_graphs(1, [(5, 4, [(1, 2), (1, 3), (2, 4), (2, 5)])]) [\\"YES\\"] >>> bipartite_graphs(1, [(6, 3, [(1, 2), (3, 4), (5, 6)])]) [\\"YES\\"] >>> bipartite_graphs(1, [(6, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 6)])]) [\\"NO\\"]","solution":"from collections import deque def is_bipartite(N, edges): Checks if the graph is bipartite graph = [[] for _ in range(N+1)] for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * (N + 1) def bfs(start): queue = deque([start]) color[start] = 0 while queue: node = queue.popleft() for neighbor in graph[node]: if color[neighbor] == -1: color[neighbor] = 1 - color[node] queue.append(neighbor) elif color[neighbor] == color[node]: return False return True for i in range(1, N + 1): if color[i] == -1: if not bfs(i): return \\"NO\\" return \\"YES\\" def bipartite_graphs(T, test_cases): results = [] for N, M, edges in test_cases: results.append(is_bipartite(N, edges)) return results"},{"question":"def is_palindromic_substring(s: str, queries: list) -> list: Determines if the substrings of \`s\` defined by \`queries\` are palindromic. Parameters: s (str): The string to check. queries (list of tuples): Each tuple contains two integers (l, r) defining the start and end indices (1-based) of the substring to check. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each query. >>> is_palindromic_substring(\\"abacaba\\", [(1, 7), (2, 5), (3, 3)]) ['YES', 'NO', 'YES'] >>> is_palindromic_substring(\\"abcdef\\", [(1, 3), (4, 6)]) ['NO', 'NO']","solution":"def is_palindromic_substring(s, queries): Determines if the substrings of s defined by queries are palindromic. Parameters: s (str): The string to check. queries (list of tuples): Each tuple contains two integers (l, r) defining the start and end indices (1-based) of the substring to check. Returns: list: A list of strings \\"YES\\" or \\"NO\\" for each query. results = [] for l, r in queries: substring = s[l-1:r] if substring == substring[::-1]: results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage s = \\"abacaba\\" queries = [(1, 7), (2, 5), (3, 3)] print(is_palindromic_substring(s, queries)) # ['YES', 'NO', 'YES']"},{"question":"def earliest_moment_all_connected(n: int, logs: List[List[int]]) -> int: Finds the earliest moment when everyone becomes friends in the social network. Parameters: n (int): Number of individuals in the network. logs (list[list[int]]): Logs of friendships in the format [timestamp, person1, person2]. Returns: int: The earliest timestamp when everyone is connected, or -1 if not everyone can be connected. Examples: >>> earliest_moment_all_connected(4, [[20190101, 0, 1], [20190104, 3, 4], [20190109, 0, 3], [20190107, 1, 2]]) 20190109 >>> earliest_moment_all_connected(4, [[20190101, 0, 1], [20190104, 1, 2], [20190107, 2, 3]]) 20190107 >>> earliest_moment_all_connected(5, [[20190101, 0, 1], [20190104, 2, 3], [20190107, 3, 4]]) -1","solution":"def earliest_moment_all_connected(n, logs): Finds the earliest moment when everyone becomes friends in the social network. Parameters: n (int): Number of individuals in the network. logs (list[list[int]]): Logs of friendships in the format [timestamp, person1, person2]. Returns: int: The earliest timestamp when everyone is connected, or -1 if not everyone can be connected. parent = list(range(n)) rank = [1] * n connected_components = n def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): nonlocal connected_components rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 connected_components -= 1 for timestamp, person1, person2 in sorted(logs): union(person1, person2) if connected_components == 1: return timestamp return -1"},{"question":"def count_balanced_substrings(num_cases: int, cases: List[str]) -> List[int]: You are given a string and need to analyze it for a specific type of pattern. A \\"balanced\\" substring is defined as a substring that contains an equal number of 'A's and 'B's and doesn't contain any other characters. Write a program that finds the number of such balanced substrings within the given string. >>> count_balanced_substrings(3, [\\"AABBAB\\", \\"AAABB\\", \\"ABAB\\"]) [2, 0, 2] >>> count_balanced_substrings(1, [\\"AABBAB\\"]) [2] >>> count_balanced_substrings(1, [\\"AAABB\\"]) [0]","solution":"def count_balanced_substrings(num_cases, cases): results = [] for s in cases: countA = 0 countB = 0 balanced_count = 0 for char in s: if char == 'A': countA += 1 elif char == 'B': countB += 1 if countA == countB: balanced_count += 1 countA = 0 countB = 0 results.append(balanced_count) return results"},{"question":"def diagnose_patients(disease_data: str, patient_data: str) -> List[str]: Diagnose patients based on their symptoms and a given database of diseases. :param disease_data: A string containing the diseases and their symptoms. :param patient_data: A string containing the patients and their symptoms. :return: A list of possible diseases for each patient. Example: >>> disease_data = \\"3nFlu 3 fever cough fatiguenCold 2 sneeze runny_nosenChickenpox 2 fever rash\\" >>> patient_data = \\"2n2 fever coughn1 sneeze\\" >>> diagnose_patients(disease_data, patient_data) ['Flu', 'Cold']","solution":"def diagnose_patients(disease_data, patient_data): diseases = disease_data.split('n') patients = patient_data.split('n') # Parsing disease data D = int(diseases[0]) disease_symptoms = {} for i in range(1, D + 1): line = diseases[i].split() disease_name = line[0] S = int(line[1]) symptoms = set(line[2:]) disease_symptoms[disease_name] = symptoms # Parsing patient data P = int(patients[0]) results = [] for i in range(1, P + 1): line = patients[i].split() F = int(line[0]) patient_symptoms = set(line[1:]) possible_diseases = [] for disease, symptoms in disease_symptoms.items(): if patient_symptoms.issubset(symptoms): possible_diseases.append(disease) if possible_diseases: results.append(' '.join(possible_diseases)) else: results.append(\\"No diagnosis\\") return results"},{"question":"def is_prime(num: int) -> bool: Returns True if the input number is a prime number, otherwise False. >>> is_prime(2) == True >>> is_prime(3) == True >>> is_prime(4) == False def reverse_num(n: int) -> int: Returns the reversed digits of the input number. >>> reverse_num(123) == 321 >>> reverse_num(1000) == 1 def is_reversed_prime(n: int) -> str: Returns \\"Prime\\" if the reversed number of n is a prime, otherwise \\"Not Prime\\". >>> is_reversed_prime(13) == \\"Prime\\" >>> is_reversed_prime(123) == \\"Not Prime\\"","solution":"def is_prime(num): Returns True if the input number is a prime number, otherwise False. if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while (i * i) <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True def reverse_num(n): Returns the reversed digits of the input number. return int(str(n)[::-1]) def is_reversed_prime(n): Returns \\"Prime\\" if the reversed number of n is a prime, otherwise \\"Not Prime\\". reversed_number = reverse_num(n) if is_prime(reversed_number): return \\"Prime\\" else: return \\"Not Prime\\""},{"question":"def most_frequent_char(s: str) -> str: Returns the most frequent character in the string. If multiple characters have the same highest frequency, the lexicographically smallest one is returned. >>> most_frequent_char(\\"abacabad\\") : \\"a\\" >>> most_frequent_char(\\"abcabc\\") : \\"a\\" >>> most_frequent_char(\\"bbaa\\") : \\"a\\" >>> most_frequent_char(\\"aaaabbbbccccddddeeee\\") : \\"a\\" >>> most_frequent_char(\\"abcdefghijklmnopqrstuvwxyz\\") : \\"a\\" >>> most_frequent_char(\\"zzzz\\") : \\"z\\"","solution":"def most_frequent_char(s): Returns the most frequent character in the string. If multiple characters have the same highest frequency, the lexicographically smallest one is returned. from collections import Counter # Calculate the frequency of each character frequency = Counter(s) # Find the maximum frequency max_freq = max(frequency.values()) # Find characters with the maximum frequency most_frequent_chars = [char for char, freq in frequency.items() if freq == max_freq] # Return the lexicographically smallest character return min(most_frequent_chars)"},{"question":"def can_split_with_equal_product(arr): Given an integer array, determine if it is possible to split the array into two non-empty subarrays such that the product of the elements in both subarrays is equal. >>> can_split_with_equal_product([1, 2, 2]) \\"YES\\" >>> can_split_with_equal_product([3, 6, 7, 1]) \\"NO\\" def process_test_cases(test_cases): Process multiple test cases for the can_split_with_equal_product function. >>> process_test_cases([(3, [1, 2, 2])]) [\\"YES\\"] >>> process_test_cases([(3, [1, 2, 2]), (4, [3, 6, 7, 1]), (5, [2, 4, 8, 16, 32])]) [\\"YES\\", \\"NO\\", \\"NO\\"]","solution":"def can_split_with_equal_product(arr): total_product = 1 for num in arr: total_product *= num left_product = 1 for i in range(len(arr) - 1): left_product *= arr[i] right_product = total_product // left_product if left_product == right_product: return \\"YES\\" return \\"NO\\" def process_test_cases(test_cases): results = [] for n, arr in test_cases: results.append(can_split_with_equal_product(arr)) return results"},{"question":"def int_sqrt(n: int) -> int: Return the largest integer x such that x^2 is less than or equal to n. >>> int_sqrt(16) 4 >>> int_sqrt(20) 4 >>> int_sqrt(0) 0 >>> int_sqrt(1) 1 >>> int_sqrt(10**18) 10**9 >>> int_sqrt(10**18 - 1) 10**9 - 1","solution":"def int_sqrt(n): Returns the largest integer x such that x^2 is less than or equal to n. if n == 0: return 0 low, high = 1, n // 2 + 1 ans = 1 while low <= high: mid = (low + high) // 2 if mid * mid == n: return mid elif mid * mid < n: ans = mid low = mid + 1 else: high = mid - 1 return ans"},{"question":"def calculate_min_travel_times(m, n, matrix, queries): Calculates the minimum travel times between specified locations. Parameters: m (int): Number of locations n (int): Number of routes matrix (list of list of int): Delivery time matrix queries (list of tuple of int): List of queries where each query is a tuple (i, j) Returns: list of int: List of minimum travel times for each query >>> m = 3 >>> n = 3 >>> matrix = [ >>> [2, 3, 1], >>> [5, 4, 2], >>> [6, 5, 3] >>> ] >>> queries = [(0, 2), (1, 2), (0, 1)] >>> calculate_min_travel_times(m, n, matrix, queries) [1, 2, 1]","solution":"def calculate_min_travel_times(m, n, matrix, queries): Calculates the minimum travel times between specified locations. Parameters: m (int): Number of locations n (int): Number of routes matrix (list of list of int): Delivery time matrix queries (list of tuple of int): List of queries where each query is a tuple (i, j) Returns: list of int: List of minimum travel times for each query min_times = [] # Precompute the minimum times for each row row_minimums = [min(row) for row in matrix] for i, j in queries: # Since each route is considered independently, the minimum time from i to j # is simply the minimum delivery time available in the start location row min_travel_time = row_minimums[i] min_times.append(min_travel_time) return min_times # Example usage m = 3 n = 3 matrix = [ [2, 3, 1], [5, 4, 2], [6, 5, 3] ] queries = [(0, 2), (1, 2), (0, 1)] print(calculate_min_travel_times(m, n, matrix, queries)) # Output: [1, 2, 1]"},{"question":"def traffic_light_system(total_duration): Simulates a traffic light system over the given period (in seconds). Parameters: total_duration (int): The total duration of the simulation in seconds. Returns: List[dict]: A list of dictionaries representing the state of the traffic lights at each second. >>> traffic_light_system(1) [{\\"north-south\\": \\"green\\", \\"east-west\\": \\"red\\"}] >>> traffic_light_system(140) [ {\\"north-south\\": \\"green\\", \\"east-west\\": \\"red\\"}, {\\"north-south\\": \\"yellow\\", \\"east-west\\": \\"red\\"}, {\\"north-south\\": \\"red\\", \\"east-west\\": \\"green\\"}, {\\"north-south\\": \\"red\\", \\"east-west\\": \\"yellow\\"}, # ... continue for the entire duration ]","solution":"def traffic_light_system(total_duration): Simulates a traffic light system over the given period (in seconds). Parameters: total_duration (int): The total duration of the simulation in seconds. Returns: List[dict]: A list of dictionaries representing the state of the traffic lights at each second. cycle = 140 # Total cycle time for one full change states = [] for second in range(total_duration): cycle_second = second % cycle if cycle_second < 60: states.append({\\"north-south\\": \\"green\\", \\"east-west\\": \\"red\\"}) elif cycle_second < 70: states.append({\\"north-south\\": \\"yellow\\", \\"east-west\\": \\"red\\"}) elif cycle_second < 130: states.append({\\"north-south\\": \\"red\\", \\"east-west\\": \\"green\\"}) else: states.append({\\"north-south\\": \\"red\\", \\"east-west\\": \\"yellow\\"}) return states"},{"question":"def sort_tasks_by_start_time(n, tasks): Returns a list of tasks sorted by their start times in ascending order. Parameters: n (int): Number of tasks tasks (list of tuples): Each tuple contains (task_description, start_time) Returns: list: List of task descriptions sorted by their start times. >>> sort_tasks_by_start_time(3, [(\\"task1\\", \\"12:30\\"), (\\"task2\\", \\"09:45\\"), (\\"task3\\", \\"14:00\\")]) [\\"task2\\", \\"task1\\", \\"task3\\"] >>> sort_tasks_by_start_time(2, [(\\"meeting\\", \\"08:00\\"), (\\"lunch\\", \\"12:00\\")]) [\\"meeting\\", \\"lunch\\"] >>> sort_tasks_by_start_time(5, [(\\"write_report\\", \\"17:15\\"), (\\"team_meeting\\", \\"11:30\\"), (\\"code_review\\", \\"13:45\\"), (\\"check_email\\", \\"08:00\\"), (\\"daily_standup\\", \\"09:15\\")]) [\\"check_email\\", \\"daily_standup\\", \\"team_meeting\\", \\"code_review\\", \\"write_report\\"] pass # Implement the function here","solution":"def sort_tasks_by_start_time(n, tasks): Returns a list of tasks sorted by their start times in ascending order. Parameters: n (int): Number of tasks tasks (list of tuples): Each tuple contains (task_description, start_time) Returns: list: List of task descriptions sorted by their start times. tasks_sorted_by_time = sorted(tasks, key=lambda x: x[1]) return [task[0] for task in tasks_sorted_by_time]"},{"question":"def count_decodings(s: str) -> int: Count all possible decodings of a given string of digits. >>> count_decodings(\\"12\\") == 2 >>> count_decodings(\\"123\\") == 3 >>> count_decodings(\\"0\\") == 0 >>> count_decodings(\\"226\\") == 3","solution":"def count_decodings(s: str) -> int: if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 for i in range(1, n + 1): if s[i - 1] != '0': dp[i] += dp[i - 1] if i != 1 and '10' <= s[i - 2:i] <= '26': dp[i] += dp[i - 2] return dp[n]"},{"question":"from typing import List def min_operations_to_equalize_array(arr: List[int]) -> int: Returns the minimum number of operations required to make all elements in the array equal. >>> min_operations_to_equalize_array([5, 5, 5]) 0 >>> min_operations_to_equalize_array([1, 2, 3, 4, 5]) 4 >>> min_operations_to_equalize_array([1, 100]) 99 >>> min_operations_to_equalize_array([42]) 0 >>> min_operations_to_equalize_array([0, 1, 2, 3]) 3 >>> min_operations_to_equalize_array([3, 1, 2, 5]) 4","solution":"def min_operations_to_equalize_array(arr): Returns the minimum number of operations required to make all elements in the array equal. max_val = max(arr) return max_val - min(arr)"},{"question":"def shift_string(s: str, k: int) -> str: Shifts all alphabetic characters in the string s by k positions in the alphabet while preserving the positions of non-alphabetic characters. >>> shift_string(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" >>> shift_string(\\"Encrypt123\\", 5) == \\"Jshwduy123\\" pass # You can use the following test cases to verify your solution def test_shift_string_simple_case(): assert shift_string(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" def test_shift_string_with_numbers(): assert shift_string(\\"Encrypt123\\", 5) == \\"Jshwduy123\\" def test_shift_string_wrap_around(): assert shift_string(\\"xyz\\", 3) == \\"abc\\" def test_shift_string_uppercase_wrap_around(): assert shift_string(\\"XYZ\\", 3) == \\"ABC\\" def test_shift_string_no_shift(): assert shift_string(\\"Hello, World!\\", 0) == \\"Hello, World!\\" def test_shift_string_entire_alphabet(): assert shift_string(\\"abcdefghijklmnopqrstuvwxyz\\", 26) == \\"abcdefghijklmnopqrstuvwxyz\\" assert shift_string(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", 26) == \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\" def test_shift_string_large_shift(): assert shift_string(\\"abc\\", 27) == \\"bcd\\" assert shift_string(\\"ABC\\", 27) == \\"BCD\\"","solution":"def shift_char(c, k): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + k) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + k) % 26 + ord('A')) else: return c def shift_string(s, k): Shifts all alphabetic characters in the string s by k positions in the alphabet, preserving the positions of non-alphabetic characters. return ''.join(shift_char(c, k) for c in s)"},{"question":"def number_pyramid(n: int) -> str: Generates a numeric pyramid pattern made of n floors. Args: n (int): Number of floors in the pyramid. Returns: str: String representation of the pyramid. >>> number_pyramid(0) == \\"n\\" >>> number_pyramid(1) == \\"1n\\" >>> number_pyramid(2) == \\"1n1 2n\\" >>> number_pyramid(4) == \\"1n1 2n1 2 3n1 2 3 4n\\" >>> number_pyramid(6) == \\"1n1 2n1 2 3n1 2 3 4n1 2 3 4 5n1 2 3 4 5 6n\\"","solution":"def number_pyramid(n): Generates a numeric pyramid pattern made of n floors. Args: n (int): Number of floors in the pyramid. Returns: str: String representation of the pyramid. if n == 0: return \\"n\\" pyramid = \\"\\" for i in range(1, n + 1): floor = \\" \\".join(str(x) for x in range(1, i + 1)) pyramid += floor + \\"n\\" return pyramid"},{"question":"from typing import List, Tuple from math import sqrt from itertools import permutations def calculate_distance(point1: Tuple[int, int], point2: Tuple[int, int]) -> float: Calculate the Euclidean distance between two points. >>> calculate_distance((0, 0), (3, 4)) 5.0 >>> calculate_distance((1, 1), (4, 5)) 5.0 # Write your implementation here def find_minimum_distance(waypoints: List[Tuple[int, int]]) -> float: Find the minimum distance to visit all waypoints and return to the start. >>> find_minimum_distance([(0, 0), (1, 0), (1, 1), (0, 1)]) 4.0 # Write your implementation here def minimum_track_distance(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[float]: Calculate the minimum track distance for multiple test cases. >>> minimum_track_distance([(3, [(0, 0), (1, 0), (0, 1)]), (4, [(0, 0), (2, 0), (2, 2), (0, 2)])]) [3.41, 8.0] # Write your implementation here","solution":"from itertools import permutations from math import sqrt def calculate_distance(point1, point2): return sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2) def find_minimum_distance(waypoints): n = len(waypoints) min_distance = float('inf') for perm in permutations(range(n)): current_distance = 0 for i in range(n): current_distance += calculate_distance(waypoints[perm[i]], waypoints[perm[(i+1) % n]]) if current_distance < min_distance: min_distance = current_distance return round(min_distance, 2) def minimum_track_distance(test_cases): results = [] for case in test_cases: N = case[0] waypoints = case[1] min_dist = find_minimum_distance(waypoints) results.append(min_dist) return results def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) index = 1 test_cases = [] for _ in range(t): N = int(data[index]) index += 1 waypoints = [] for _ in range(N): X = int(data[index]) Y = int(data[index + 1]) waypoints.append((X, Y)) index += 2 test_cases.append((N, waypoints)) results = minimum_track_distance(test_cases) for result in results: print(f\\"{result:.2f}\\")"},{"question":"def min_bonus(ratings): Determine the minimum amount of bonus needed for employees based on their ratings. Each employee must receive at least one unit of bonus. Employees with a higher rating get more bonus than their neighbors. Employees with the same rating receive the same amount of bonus regardless of their position. Args: ratings (List[int]): List of employee ratings. Returns: int: Minimum amount of bonus needed. >>> min_bonus([1, 2, 2]) 4 >>> min_bonus([1, 0, 2]) 5 # Unit Tests if __name__ == \\"__main__\\": def test_min_bonus_example1(): assert min_bonus([1, 2, 2]) == 4 def test_min_bonus_example2(): assert min_bonus([1, 0, 2]) == 5 def test_min_bonus_single_employee(): assert min_bonus([5]) == 1 def test_min_bonus_increasing_ratings(): assert min_bonus([1, 2, 3, 4]) == 10 def test_min_bonus_decreasing_ratings(): assert min_bonus([4, 3, 2, 1]) == 10 def test_min_bonus_all_same_ratings(): assert min_bonus([2, 2, 2]) == 3 def test_min_bonus_random_ratings(): assert min_bonus([1, 3, 2, 2, 1]) == 7 def test_min_bonus_alternating_ratings(): assert min_bonus([1, 3, 1, 3, 1]) == 7 def test_min_bonus_large_input(): large_ratings = [1000, 2000] * 50000 assert min_bonus(large_ratings) == 150000 test_min_bonus_example1() test_min_bonus_example2() test_min_bonus_single_employee() test_min_bonus_increasing_ratings() test_min_bonus_decreasing_ratings() test_min_bonus_all_same_ratings() test_min_bonus_random_ratings() test_min_bonus_alternating_ratings() test_min_bonus_large_input()","solution":"def min_bonus(ratings): n = len(ratings) if n == 0: return 0 # Initialize an array to store the bonuses with 1 as the minimum for each employee bonuses = [1] * n # Left to right scan: update bonuses to ensure each employee has more than left neighbor if needed for i in range(1, n): if ratings[i] > ratings[i - 1]: bonuses[i] = bonuses[i - 1] + 1 # Right to left scan: update bonuses to ensure each employee has more than right neighbor if needed for i in range(n - 2, -1, -1): if ratings[i] > ratings[i + 1]: bonuses[i] = max(bonuses[i], bonuses[i + 1] + 1) # Sum all bonuses to get the total amount distributed return sum(bonuses) # Example usage: # ratings = [1, 2, 2] # print(min_bonus(ratings)) # Output: 4 # ratings = [1, 0, 2] # print(min_bonus(ratings)) # Output: 5"},{"question":"from typing import List def maximize_large_element(n: int, arr: List[int]) -> int: Returns the maximum possible value of the largest element by summing all elements. >>> maximize_large_element(4, [2, 1, 2, 3]) 8 >>> maximize_large_element(5, [5, 5, 5, 5, 5]) 25 pass","solution":"def maximize_large_element(n, arr): Returns the maximum possible value of the largest element by summing all elements. return sum(arr)"},{"question":"def count_unique_stamps(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Count the number of unique stamps in each test case. Args: test_cases: A list of tuples, where each tuple contains an integer N and a list of N integers representing the IDs of obtained stamps. Returns: A list of integers representing the number of unique stamps for each test case. Example: >>> count_unique_stamps([(5, [1, 2, 2, 3, 4]), (6, [6, 5, 6, 5, 2, 1]), (4, [7, 8, 8, 7])]) [4, 4, 2]","solution":"def count_unique_stamps(test_cases): results = [] for case in test_cases: N, stamps = case unique_stamps = set(stamps) results.append(len(unique_stamps)) return results"},{"question":"def can_become_palindrome(s: str) -> str: Determine if a given string can be converted into a palindrome by removing at most one character. >>> can_become_palindrome(\\"abca\\") \\"YES\\" >>> can_become_palindrome(\\"abcde\\") \\"NO\\"","solution":"def can_become_palindrome(s): def is_palindrome_range(i, j): return all(s[k] == s[j-k+i] for k in range(i, j)) left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # When they don't match, try both possibilities: removing left char or right char if is_palindrome_range(left+1, right) or is_palindrome_range(left, right-1): return \\"YES\\" else: return \\"NO\\" left += 1 right -= 1 return \\"YES\\""},{"question":"def is_path_possible(grid, n, m, start, destination): Determines if there is a path from start to destination in the grid using BFS. Parameters: grid (list of str): Grid represented as a list of strings. n (int): Number of rows. m (int): Number of columns. start (tuple of int): Tuple (x_s, y_s) representing the starting cell (1-based indexing). destination (tuple of int): Tuple (x_d, y_d) representing the destination cell (1-based indexing). Returns: str: \\"YES\\" if the path exists, otherwise \\"NO\\". Example: >>> grid = [\\".....\\", \\".#.\\", \\"..#..\\", \\".#.\\", \\".....\\"] >>> is_path_possible(grid, 5, 5, (1, 1), (5, 5)) \\"YES\\" >>> grid = [\\"...\\", \\"#\\", \\"...\\"] >>> is_path_possible(grid, 3, 3, (1, 1), (3, 1)) \\"NO\\"","solution":"def is_path_possible(grid, n, m, start, destination): Determines if there is a path from start to destination in the grid using BFS. grid: Grid represented as a list of strings n: Number of rows m: Number of columns start: Tuple (x_s, y_s) representing the starting cell (1-based indexing) destination: Tuple (x_d, y_d) representing the destination cell (1-based indexing) Returns \\"YES\\" if the path exists, otherwise \\"NO\\". from collections import deque # Directions for moving in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Convert start and destination from 1-based to 0-based indexing start = (start[0] - 1, start[1] - 1) destination = (destination[0] - 1, destination[1] - 1) # Initial validations if grid[start[0]][start[1]] == '#' or grid[destination[0]][destination[1]] == '#': return \\"NO\\" # BFS initialization queue = deque([start]) visited = set() visited.add(start) while queue: current = queue.popleft() # If we've reached the destination if current == destination: return \\"YES\\" # Explore neighbors for direction in directions: neighbor = (current[0] + direction[0], current[1] + direction[1]) if 0 <= neighbor[0] < n and 0 <= neighbor[1] < m and neighbor not in visited: if grid[neighbor[0]][neighbor[1]] == '.': visited.add(neighbor) queue.append(neighbor) return \\"NO\\""},{"question":"def shortestPath(V, E, edges, src, dest): Given a directed graph and two vertices, find the shortest path between the two vertices. Args: V : int : number of vertices E : int : number of edges edges : List[int] : array of size 3*E where each trio (edges[3*i], edges[3*i+1], edges[3*i+2]) denotes an edge from edges[3*i] to edges[3*i+1] with weight edges[3*i+2] src: int : source vertex dest: int : destination vertex Returns: int : total weight of the shortest path from the source vertex to the destination vertex, or -1 if no path exists Example: >>> shortestPath(4, 4, [0, 1, 1, 0, 2, 4, 1, 2, 2, 2, 3, 1], 0, 1) 1 >>> shortestPath(4, 4, [0, 1, 1, 0, 2, 4, 1, 2, 2, 2, 3, 1], 0, 3) 4 >>> shortestPath(3, 1, [0, 1, 1], 0, 2) -1","solution":"import heapq def shortestPath(V, E, edges, src, dest): # Represent the graph as an adjacency list graph = {i: [] for i in range(V)} for i in range(E): u, v, w = edges[3*i], edges[3*i+1], edges[3*i+2] graph[u].append((v, w)) # Dijkstra's algorithm distances = {i: float('inf') for i in range(V)} distances[src] = 0 priority_queue = [(0, src)] # (distance, node) while priority_queue: current_distance, u = heapq.heappop(priority_queue) # If we reached the destination if u == dest: return current_distance # Check for better paths for v, weight in graph[u]: distance = current_distance + weight if distance < distances[v]: distances[v] = distance heapq.heappush(priority_queue, (distance, v)) # If destination is not reachable return distances[dest] if distances[dest] != float('inf') else -1"},{"question":"def generate_sequence(A, B, C, N): Given the first three numbers A, B, and C, and the length N, generate the sequence of N numbers where each number (from 4th onwards) is the sum of the last three numbers. >>> generate_sequence(1, 2, 3, 5) [1, 2, 3, 6, 11] >>> generate_sequence(4, 5, 6, 6) [4, 5, 6, 15, 26, 47] def process_test_cases(test_cases): Given a list of test cases, where each test case is a tuple (A, B, C, N), return a list of sequences generated for each test case. >>> process_test_cases([(1, 2, 3, 5), (4, 5, 6, 6)]) [[1, 2, 3, 6, 11], [4, 5, 6, 15, 26, 47]]","solution":"def generate_sequence(A, B, C, N): Given the first three numbers A, B, and C, and the length N, generate the sequence of N numbers where each number (from 4th onwards) is the sum of the last three numbers. sequence = [A, B, C] for i in range(3, N): next_number = sequence[-1] + sequence[-2] + sequence[-3] sequence.append(next_number) return sequence def process_test_cases(test_cases): results = [] for A, B, C, N in test_cases: results.append(generate_sequence(A, B, C, N)) return results"},{"question":"def analyze_log(N: int, log: List[str]) -> str: Analyzes the log to determine if the account is compromised. :param N: Number of log records :param log: List of login attempts :return: \\"Compromised\\" if the account is compromised, otherwise \\"Secure\\" >>> analyze_log(12, [\\"SUCCESS\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"SUCCESS\\", \\"FAILURE\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"SUCCESS\\"]) \\"Compromised\\" >>> analyze_log(5, [\\"SUCCESS\\", \\"FAILURE\\", \\"FAILURE\\", \\"SUCCESS\\", \\"SUCCESS\\"]) \\"Secure\\" >>> analyze_log(6, [\\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\"]) \\"Secure\\" >>> analyze_log(7, [\\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\"]) \\"Secure\\" >>> analyze_log(8, [\\"SUCCESS\\", \\"SUCCESS\\", \\"FAILURE\\", \\"FAILURE\\", \\"FAILURE\\", \\"SUCCESS\\", \\"SUCCESS\\", \\"SUCCESS\\"]) \\"Compromised\\"","solution":"def analyze_log(N, log): Analyzes the log to determine if the account is compromised. :param N: Number of log records :param log: List of login attempts :return: \\"Compromised\\" if the account is compromised, otherwise \\"Secure\\" for i in range(N - 3): if log[i] == \\"FAILURE\\" and log[i + 1] == \\"FAILURE\\" and log[i + 2] == \\"FAILURE\\" and log[i + 3] == \\"SUCCESS\\": return \\"Compromised\\" return \\"Secure\\""},{"question":"def can_be_sorted_by_transformations(s: str) -> str: Returns \\"YES\\" if the given string composed of '1' and '0' can be sorted by applying the transformation \\"10\\" -> \\"01\\" any number of times. >>> can_be_sorted_by_transformations(\\"1100\\") \\"YES\\" >>> can_be_sorted_by_transformations(\\"1010\\") \\"YES\\" >>> can_be_sorted_by_transformations(\\"0011\\") \\"YES\\" >>> can_be_sorted_by_transformations(\\"010101\\") \\"YES\\"","solution":"def can_be_sorted_by_transformations(s): Returns \\"YES\\" if the given string composed of '1' and '0' can be sorted by applying the transformation \\"10\\" -> \\"01\\" any number of times. # The string can be sorted if a \\"10\\" can always be transformed into a \\"01\\", # which effectively means we can always sort a string with 0's and 1's using the given rule. return \\"YES\\""},{"question":"def find_knights_statements(is_A_truthful: bool, is_B_truthful: bool, is_C_truthful: bool) -> int: Given the truthfulness of the statements made by A, B, and C, determine the number of Knights among them. >>> find_knights_statements(True, False, True) 2 >>> find_knights_statements(False, False, True) 1 pass def test_knights_case_1(): assert find_knights_statements(True, False, True) == 2 def test_knights_case_2(): assert find_knights_statements(False, False, True) == 1 def test_knights_case_all_knights(): assert find_knights_statements(True, True, True) == 3 def test_knights_case_no_knights(): assert find_knights_statements(False, False, False) == 0 def test_knights_case_one_knight(): assert find_knights_statements(False, True, False) == 1 assert find_knights_statements(True, False, False) == 1 assert find_knights_statements(False, False, True) == 1 def test_knights_case_two_knights(): assert find_knights_statements(True, True, False) == 2 assert find_knights_statements(True, False, True) == 2 assert find_knights_statements(False, True, True) == 2","solution":"def find_knights_statements(is_A_truthful: bool, is_B_truthful: bool, is_C_truthful: bool) -> int: # Based on the statements, determine if A, B, and C are Knights or Knaves # A said: \\"C said that only one of us is a Knight.\\" if is_A_truthful: # If A is truthful, then C actually said only one is a Knight C_statement = 1 else: # If A is lying, then C did not say only one is a Knight (could be 0, 2, or 3) C_statement = -1 # B said: \\"A said that C is a Knight.\\" if is_B_truthful: # If B is truthful, then A actually said C is a Knight A_statement = is_C_truthful else: # If B is lying, then A did not say C is a Knight (so A said C is a Knave) A_statement = not is_C_truthful # C said: \\"B is a Knight.\\" C_statement_about_B = is_B_truthful # Determine the number of Knights based on the truthfulness knights_count = sum([is_A_truthful, is_B_truthful, is_C_truthful]) return knights_count"},{"question":"def smallest_repeating_unit(s: str) -> int: Returns the length of the smallest repeating unit of the string s. >>> smallest_repeating_unit(\\"ababab\\") 2 >>> smallest_repeating_unit(\\"aaaa\\") 1 >>> smallest_repeating_unit(\\"abcabcabc\\") 3","solution":"def smallest_repeating_unit(s): Returns the length of the smallest repeating unit of the string s. n = len(s) for i in range(1, n + 1): if n % i == 0: repeating_unit = s[:i] if repeating_unit * (n // i) == s: return i return n"},{"question":"from collections import defaultdict from typing import List, Tuple def max_power_level(N: int, power: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the maximum power level of the root branch in a mystical forest of Magic Trees. Args: - N: int: the number of branches in the tree - power: List[int]: a list of integers where the i-th element represents the intrinsic power of the i-th branch - edges: List[Tuple[int, int]]: a list of tuples where each tuple indicates that one branch is the parent of another Returns: - int: the maximum power level of the tree's root branch Example: >>> max_power_level(5, [3, 5, 2, 1, 4], [(1, 2), (1, 3), (3, 4), (3, 5)]) 9 >>> max_power_level(1, [5], []) 5","solution":"from collections import defaultdict def max_power_level(N, power, edges): def dfs(node): if node in cache: return cache[node] max_child_power = 0 for child in tree[node]: max_child_power = max(max_child_power, dfs(child)) cache[node] = power[node - 1] + max_child_power return cache[node] tree = defaultdict(list) for a, b in edges: tree[a].append(b) cache = {} return dfs(1)"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: Merge two sorted linked lists into a single sorted linked list. >>> l1 = ListNode(1, ListNode(2, ListNode(4))) >>> l2 = ListNode(1, ListNode(3, ListNode(4))) >>> merged_head = merge_two_lists(l1, l2) >>> current = merged_head >>> result = [] >>> while current: >>> result.append(current.val) >>> current = current.next >>> result [1, 1, 2, 3, 4, 4]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def merge_two_lists(l1: ListNode, l2: ListNode) -> ListNode: dummy = ListNode() current = dummy while l1 and l2: if l1.val < l2.val: current.next = ListNode(l1.val) l1 = l1.next else: current.next = ListNode(l2.val) l2 = l2.next current = current.next while l1: current.next = ListNode(l1.val) l1 = l1.next current = current.next while l2: current.next = ListNode(l2.val) l2 = l2.next current = current.next return dummy.next def print_list(node: ListNode): while node: print(node.val, end=\\" -> \\") node = node.next print(\\"None\\") # Creating linked lists for testing l1 = ListNode(1, ListNode(2, ListNode(4))) l2 = ListNode(1, ListNode(3, ListNode(4))) merged_head = merge_two_lists(l1, l2) print_list(merged_head) # Output: 1 -> 1 -> 2 -> 3 -> 4 -> 4 -> None"},{"question":"def find_max_ones_with_flip(arr: List[int]) -> int: Finds the maximum length of a contiguous subarray consisting only of 1s that can be obtained by making at most one flip from 0 to 1. >>> find_max_ones_with_flip([1, 0, 1, 1, 0, 1, 1, 1]) 5 >>> find_max_ones_with_flip([0, 1, 1, 1, 0, 1, 1]) 6 >>> find_max_ones_with_flip([1, 0, 1, 0, 1, 0, 1]) 3 >>> find_max_ones_with_flip([0, 0, 0, 0]) 1 >>> find_max_ones_with_flip([1, 1, 0, 1, 1, 0, 1, 1]) 5","solution":"def find_max_ones_with_flip(arr): Finds the maximum length of a contiguous subarray consisting only of 1s that can be obtained by making at most one flip from 0 to 1. :param arr: A list of integers (only 0s and 1s) :return: The maximum length of contiguous 1s obtainable by flipping one 0 to 1 n = len(arr) # Initialize pointers for sliding window and some necessary variables left = 0 num_of_zeros = 0 max_length = 0 # Iterate through the array with the right pointer for right in range(n): # Increment the count of zeros if we encounter one if arr[right] == 0: num_of_zeros += 1 # We are only allowed to flip one zero, so if there are more, move the left pointer while num_of_zeros > 1: if arr[left] == 0: num_of_zeros -= 1 left += 1 # Calculate the current length of the window max_length = max(max_length, right - left + 1) return max_length"},{"question":"from typing import List def trap(height: List[int]) -> int: Calculates the maximum amount of trapped water given the heights of buildings represented by a list of integers. >>> trap([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap([]) 0 >>> trap([4, 3, 2, 1]) 0 >>> trap([1, 2, 3, 4]) 0 >>> trap([0]) 0 >>> trap([1]) 0 >>> trap([3, 3, 3, 3]) 0 >>> trap([0, 2, 0, 2, 0, 2]) 4 >>> trap([4, 2, 0, 3, 2, 5]) 9","solution":"from typing import List def trap(height: List[int]) -> int: if not height: return 0 n = len(height) left_max = [0] * n right_max = [0] * n left_max[0] = height[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], height[i]) right_max[n - 1] = height[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], height[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - height[i] return trapped_water"},{"question":"def min_operations_to_zero(n: int, arr: List[int]) -> int: Find the minimum number of operations required to transform the given array into an array of zeros. Args: n (int): Length of the array. arr (List[int]): The input array. Returns: int: Minimum number of operations required. >>> min_operations_to_zero(3, [5, -5, 0]) 2 >>> min_operations_to_zero(1, [0]) 0 >>> min_operations_to_zero(1, [10]) 1 >>> min_operations_to_zero(4, [0, 0, 0, 0]) 0 >>> min_operations_to_zero(4, [1, -1, 2, -2]) 4 >>> min_operations_to_zero(5, [1, 0, -2, 0, 3]) 3 >>> min_operations_to_zero(3, [-1000000000, -500000000, 1000000000]) 3 >>> min_operations_to_zero(6, [0, 1, 0, 2, 0, 3]) 3 pass","solution":"def min_operations_to_zero(n, arr): Find the minimum number of operations required to transform the given array into an array of zeros. Args: n (int): Length of the array. arr (List[int]): The input array. Returns: int: Minimum number of operations required. # We just need to count the number of non-zero elements # because each non-zero element will need at least one operation. non_zero_count = 0 for num in arr: if num != 0: non_zero_count += 1 return non_zero_count"},{"question":"def is_unique(s: str) -> bool: Check if a string has all unique characters. >>> is_unique(\\"abcdef\\") True >>> is_unique(\\"hello\\") False >>> is_unique(\\"\\") True >>> is_unique(\\"Aa\\") True >>> is_unique(\\"112345\\") False","solution":"def is_unique(s): Check if a string has all unique characters. Parameters: - s (str): the input string to check. Returns: - bool: True if all characters in the string are unique, False otherwise. length = len(s) for i in range(length): for j in range(i + 1, length): if s[i] == s[j]: return False return True"},{"question":"def max_unique_subarray_length(n, arr): Returns the length of the longest unique subarray in the given array. >>> max_unique_subarray_length(7, [4, 2, 1, 4, 5, 1, 3]) 4 >>> max_unique_subarray_length(5, [1, 2, 3, 2, 1]) 3","solution":"def max_unique_subarray_length(n, arr): Returns the length of the longest unique subarray in the given array. unique_elements = set() max_length = 0 left = 0 for right in range(n): while arr[right] in unique_elements: unique_elements.remove(arr[left]) left += 1 unique_elements.add(arr[right]) max_length = max(max_length, right - left + 1) return max_length"},{"question":"def calculateSpan(prices: List[int], n: int) -> List[int]: Calculate the stock span for each day. :param prices: List of stock prices :param n: Number of days :return: List of spans >>> calculateSpan([100, 80, 60, 70, 60, 75, 85], 7) [1, 1, 1, 2, 1, 4, 6] >>> calculateSpan([10, 4, 5, 90, 120, 80], 6) [1, 1, 2, 4, 5, 1]","solution":"def calculateSpan(prices, n): Calculate the stock span for each day. :param prices: List of stock prices :param n: Number of days :return: List of spans stack = [] span = [0] * n for i in range(n): while stack and prices[stack[-1]] <= prices[i]: stack.pop() if not stack: span[i] = i + 1 else: span[i] = i - stack[-1] stack.append(i) return span"},{"question":"def max_beauty_score(s: str) -> int: Returns the maximum beauty score of the string s if an arbitrary number of operations are performed. >>> max_beauty_score(\\"abcde\\") 6 >>> max_beauty_score(\\"aaa\\") 4","solution":"def max_beauty_score(s): Returns the maximum beauty score of the string s if an arbitrary number of operations are performed. # The maximum beauty score is achieved by setting all letters to the same character to make its frequency n # and changing one letter to another character to make its frequency 1. n = len(s) max_score = n + 1 # n (most frequent) + 1 (least frequent will always be 1 after operation) return max_score"},{"question":"from typing import List def can_form_palindrome(T: int, cases: List[str]) -> List[str]: Given a list of strings, determine if the resulting string after the described operations can be rearranged into a palindrome. Parameters: T (int): Number of test cases. cases (List[str]): List of strings consisting of characters 'a', 'b', and 'c'. Returns: List[str]: A list of \\"YES\\" or \\"NO\\" for each test case. Example: >>> can_form_palindrome(3, [\\"abc\\", \\"aaa\\", \\"abcabc\\"]) [\\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def can_form_palindrome(T, cases): Given a list of strings, determine if the resulting string after the described operations can be rearranged into a palindrome. results = [] for S in cases: counter = {'a': 0, 'b': 0, 'c': 0} for char in S: counter[char] += 1 odd_count = 0 for count in counter.values(): if count % 2 != 0: odd_count += 1 if odd_count > 1: results.append(\\"NO\\") else: results.append(\\"YES\\") return results"},{"question":"def min_teams_required(n: int, skill_levels: List[int]) -> int: Given the number of players and their respective skill levels, calculates the minimum number of balanced teams required. >>> min_teams_required(7, [10, 21, 32, 43, 54, 65, 76]) 2 >>> min_teams_required(5, [10, 20, 30, 40, 50]) 1","solution":"def min_teams_required(n, skill_levels): Given the number of players and their respective skill levels, calculates the minimum number of balanced teams required. Args: n: int : the number of players skill_levels: list of int : the skill levels of the players Returns: int : the minimum number of balanced teams required even_count = sum(1 for skill in skill_levels if skill % 2 == 0) odd_count = n - even_count # The number of teams required is the sum of teams with even skill levels and teams with odd skill levels # Each group of even/odd skill levels requires at least one team. return (1 if even_count > 0 else 0) + (1 if odd_count > 0 else 0)"},{"question":"MOD = 10**9 + 7 def count_distinct_subsequences(s: str) -> int: Count the number of distinct subsequences of a given string s modulo 10^9 + 7. A subsequence is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements. >>> count_distinct_subsequences(\\"abc\\") == 8 >>> count_distinct_subsequences(\\"a\\") == 2 # \\"\\", \\"a\\" >>> count_distinct_subsequences(\\"ab\\") == 4 # \\"\\", \\"a\\", \\"b\\", \\"ab\\" >>> count_distinct_subsequences(\\"aaa\\") == 4 # \\"\\", \\"a\\", \\"aa\\", \\"aaa\\" >>> count_distinct_subsequences(\\"aba\\") == 7 # \\"\\", \\"a\\", \\"b\\", \\"aa\\", \\"ab\\", \\"ba\\", \\"aba\\" >>> count_distinct_subsequences(\\"abcdefghijklmnopqrstuvwxyz\\") == (2 ** 26) % (10**9 + 7)","solution":"MOD = 10**9 + 7 def count_distinct_subsequences(s): n = len(s) dp = [1] * (n + 1) last_occurrence = {} for i in range(1, n + 1): char = s[i-1] dp[i] = (2 * dp[i-1]) % MOD if char in last_occurrence: dp[i] = (dp[i] - dp[last_occurrence[char] - 1]) % MOD last_occurrence[char] = i return dp[n] # Example usage: s = \\"abc\\" print(count_distinct_subsequences(s)) # Output 8"},{"question":"def kth_smallest(matrix: List[List[int]], k: int) -> int: Finds the k-th smallest element in a sorted 2D matrix. Args: matrix : List[List[int]] : 2D matrix of integers where each row is sorted k : int : the position of the k-th smallest element to be found (1-based index) Returns: int : the k-th smallest element in the matrix >>> kth_smallest([[1, 5, 9], [10, 11, 13], [12, 13, 15]], 8) 13 >>> kth_smallest([[1, 3, 5], [6, 7, 12]], 3) 5 pass","solution":"import heapq def kth_smallest(matrix, k): Finds the k-th smallest element in a sorted 2D matrix. Args: matrix : List[List[int]] : 2D matrix of integers where each row is sorted k : int : the position of the k-th smallest element to be found (1-based index) Returns: int : the k-th smallest element in the matrix # Create a min-heap min_heap = [] # Push the first element of each row into the heap for r in range(len(matrix)): heapq.heappush(min_heap, (matrix[r][0], r, 0)) # Pop from the heap k times to get the k-th smallest element for _ in range(k): element, r, c = heapq.heappop(min_heap) if c + 1 < len(matrix[0]): heapq.heappush(min_heap, (matrix[r][c + 1], r, c + 1)) return element"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the given string s. >>> count_palindromic_substrings(\\"abba\\") 6 >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 pass def process_input(T: int, strings: List[str]) -> List[int]: Processes multiple test cases and returns the count of palindromic substrings for each string provided. >>> process_input(3, [\\"abba\\", \\"abc\\", \\"aaa\\"]) [6, 3, 6] >>> process_input(1, [\\"a\\"]) [1] pass","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the given string s. n = len(s) count = 0 for center in range(2 * n - 1): left = center // 2 right = left + center % 2 while left >= 0 and right < n and s[left] == s[right]: count += 1 left -= 1 right += 1 return count def process_input(T, strings): results = [] for i in range(T): result = count_palindromic_substrings(strings[i]) results.append(result) return results"},{"question":"def closestDistance(S: str, C: str) -> List[int]: Given a string S and a character C, determine the distance of the closest occurrence of character C from each character in the string S. Return the distances as a list of integers of the same length as the string S. >>> closestDistance(\\"loveleetcode\\", 'e') [3, 2, 1, 0, 1, 0, 0, 1, 2, 2, 1, 0] >>> closestDistance(\\"aaab\\", 'b') [3, 2, 1, 0]","solution":"def closestDistance(S, C): n = len(S) result = [float('inf')] * n # First pass: Left to right prev_pos = -float('inf') for i in range(n): if S[i] == C: prev_pos = i result[i] = i - prev_pos # Second pass: Right to left prev_pos = float('inf') for i in range(n-1, -1, -1): if S[i] == C: prev_pos = i result[i] = min(result[i], prev_pos - i) return result"},{"question":"def categorize_transactions(transaction_list): Categorizes transactions based on the amount and sums up the total amounts in each category. Args: transaction_list (list of floats): The list of transactions where positive numbers represent deposits and negative numbers represent withdrawals. Returns: dict: A dictionary with transaction categories as keys and the sum of amounts in each category as values. >>> categorize_transactions([500.0, 1500.0, -200.0, -1200.0, 700.0, 3000.0, -50.0]) {'small_deposit': 1200.0, 'large_deposit': 4500.0, 'small_withdrawal': -250.0, 'large_withdrawal': -1200.0} >>> categorize_transactions([100.0, 200.0, 300.0, 400.0]) {'small_deposit': 1000.0, 'large_deposit': 0.0, 'small_withdrawal': 0.0, 'large_withdrawal': 0.0} >>> categorize_transactions([-100.0, -200.0, -300.0, -400.0]) {'small_deposit': 0.0, 'large_deposit': 0.0, 'small_withdrawal': -1000.0, 'large_withdrawal': 0.0} >>> categorize_transactions([-2000.0, -3000.0, -4000.0]) {'small_deposit': 0.0, 'large_deposit': 0.0, 'small_withdrawal': 0.0, 'large_withdrawal': -9000.0} >>> categorize_transactions([]) {'small_deposit': 0.0, 'large_deposit': 0.0, 'small_withdrawal': 0.0, 'large_withdrawal': 0.0} >>> categorize_transactions([0.0, -1000.0, 999.99, -999.99, 1000.0, -1001.0, 1500.0, -200.0]) {'small_deposit': 999.99, 'large_deposit': 2500.0, 'small_withdrawal': -1199.99, 'large_withdrawal': -2001.0} categories = { 'small_deposit': 0.0, 'large_deposit': 0.0, 'small_withdrawal': 0.0, 'large_withdrawal': 0.0 } for transaction in transaction_list: if transaction > 0: if transaction < 1000: categories['small_deposit'] += transaction else: categories['large_deposit'] += transaction else: if transaction > -1000: categories['small_withdrawal'] += transaction else: categories['large_withdrawal'] += transaction return categories","solution":"def categorize_transactions(transaction_list): Categorizes transactions based on the amount and sums up the total amounts in each category. Args: transaction_list (list of floats): The list of transactions where positive numbers represent deposits and negative numbers represent withdrawals. Returns: dict: A dictionary with transaction categories as keys and the sum of amounts in each category as values. categories = { 'small_deposit': 0.0, 'large_deposit': 0.0, 'small_withdrawal': 0.0, 'large_withdrawal': 0.0 } for transaction in transaction_list: if transaction > 0: if transaction < 1000: categories['small_deposit'] += transaction else: categories['large_deposit'] += transaction else: if transaction > -1000: categories['small_withdrawal'] += transaction else: categories['large_withdrawal'] += transaction return categories"},{"question":"from typing import List def can_form_consecutive_sequence(m: int, book_ids: List[int]) -> str: Determine if the given book identifiers can form a consecutive sequence. Parameters: m (int): Number of books (1 <= m <= 1000) book_ids (list of int): List of m book identifiers (1 <= b_i <= 1000) Returns: str: \\"YES\\" if the books can be arranged consecutively, \\"NO\\" otherwise Examples: >>> can_form_consecutive_sequence(5, [3, 5, 4, 7, 6]) \\"YES\\" >>> can_form_consecutive_sequence(4, [10, 12, 13, 11]) \\"YES\\" >>> can_form_consecutive_sequence(3, [5, 7, 9]) \\"NO\\"","solution":"def can_form_consecutive_sequence(m, book_ids): Determine if the given book identifiers can form a consecutive sequence. Parameters: m (int): Number of books (1 <= m <= 1000) book_ids (list of int): List of m book identifiers (1 <= b_i <= 1000) Returns: str: \\"YES\\" if the books can be arranged consecutively, \\"NO\\" otherwise # Find the minimum and maximum identifier min_id = min(book_ids) max_id = max(book_ids) # Check if the range min_id to max_id forms a sequence of length m if max_id - min_id + 1 == m and len(set(book_ids)) == m: return \\"YES\\" else: return \\"NO\\""},{"question":"def longest_good_substring(s: str) -> int: Alice is working on a project involving strings, and she needs to analyze the structure of various strings. She defines a good substring as a contiguous substring that appears at least twice in the original string but does not overlap with itself. Alice wants to know the length of the longest good substring in the given string. >>> longest_good_substring(\\"banana\\") 3 >>> longest_good_substring(\\"abcdefg\\") 0 >>> longest_good_substring(\\"aaabaaa\\") 3 >>> longest_good_substring(\\"abcabcabc\\") 6 >>> longest_good_substring(\\"a\\") 0 >>> longest_good_substring(\\"abcdef\\") 0 >>> longest_good_substring(\\"xyxyxy\\") 4","solution":"def longest_good_substring(s): max_len = 0 n = len(s) # Helper function to check if a substring appears at least twice def does_repeat(substr): first_occurrence = s.find(substr) second_occurrence = s.find(substr, first_occurrence + 1) return second_occurrence != -1 # Check all possible substring lengths starting from 1 for length in range(1, n): for start in range(n - length + 1): substr = s[start:start + length] if does_repeat(substr): max_len = max(max_len, length) return max_len"},{"question":"def num_trees(n): Given an integer n, return the number of structurally unique Binary Search Trees (BSTs) which have exactly n nodes of unique values from 1 to n. >>> num_trees(1) == 1 >>> num_trees(2) == 2 >>> num_trees(3) == 5 >>> num_trees(4) == 14 >>> num_trees(5) == 42 >>> num_trees(0) == 1 >>> num_trees(19) == 1767263190","solution":"def num_trees(n): Returns the number of structurally unique BSTs that have exactly n nodes of unique values from 1 to n. if n == 0 or n == 1: return 1 dp = [0] * (n + 1) dp[0], dp[1] = 1, 1 for nodes in range(2, n + 1): for root in range(1, nodes + 1): dp[nodes] += dp[root - 1] * dp[nodes - root] return dp[n]"},{"question":"def containsAnagramPair(words): Returns True if there are any two different words in the list that are anagrams of each other. Examples: >>> containsAnagramPair([\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"facebook\\"]) True >>> containsAnagramPair([\\"apple\\", \\"banana\\", \\"orange\\"]) False","solution":"def containsAnagramPair(words): Returns True if there are any two different words in the list that are anagrams of each other. seen = set() for word in words: # Sort the word to form a canonical form of the word's anagram sorted_word = \\"\\".join(sorted(word)) if sorted_word in seen: return True seen.add(sorted_word) return False # Example usage: # words = [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\", \\"facebook\\"] # print(containsAnagramPair(words)) # Output: True"},{"question":"import itertools def tsp_min_cost(n, cost): Find the minimum cost to complete the trip where friends visit each city exactly once and return to the starting city. :param n: int, number of cities :param cost: list of list of ints, cost[i][j] is the cost of traveling from city i to city j :return: int, minimum cost to complete the trip >>> tsp_min_cost(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) == 80 >>> tsp_min_cost(3, [ ... [0, 10, 15], ... [10, 0, 20], ... [15, 20, 0] ... ]) == 45 def solve(input_str): Parses input string and solves the minimum cost to complete the trip. :param input_str: str, input in a specific format :return: int, the minimum cost to complete the trip >>> solve(\\"4n0 10 15 20n10 0 35 25n15 35 0 30n20 25 30 0n\\") == 80 >>> solve(\\"3n0 10 15n10 0 20n15 20 0n\\") == 45","solution":"import itertools def tsp_min_cost(n, cost): Find the minimum cost to complete the trip where friends visit each city exactly once and return to the starting city. :param n: int, number of cities :param cost: list of list of ints, cost[i][j] is the cost of traveling from city i to city j :return: int, minimum cost to complete the trip cities = list(range(n)) min_cost = float('inf') for perm in itertools.permutations(cities): current_cost = 0 for i in range(n - 1): current_cost += cost[perm[i]][perm[i+1]] current_cost += cost[perm[-1]][perm[0]] # Return to starting city min_cost = min(min_cost, current_cost) return min_cost def solve(input_str): lines = input_str.strip().split('n') n = int(lines[0]) cost = [list(map(int, line.split())) for line in lines[1:]] return tsp_min_cost(n, cost)"},{"question":"def balancedString(s: str) -> int: Determine the minimum number of deletions required to make the string balanced. A string is considered \\"balanced\\" if each character in the string appears the same number of times. >>> balancedString(\\"aabbcc\\") 0 >>> balancedString(\\"aabbccc\\") 1 >>> balancedString(\\"aabbcccc\\") 2 >>> balancedString(\\"aaaa\\") 0 >>> balancedString(\\"a\\") 0 >>> balancedString(\\"aabbccddeeffgghhii\\") 0 >>> balancedString(\\"aabbccddeeffgghhiii\\") 1","solution":"def balancedString(s): from collections import Counter # Get the frequency of each character freq = Counter(s) # Get all the frequencies into a list and sort them freq_list = sorted(freq.values()) # If all frequencies are the same, no deletions needed if freq_list[0] == freq_list[-1]: return 0 # Maximum frequency max_freq = freq_list[-1] # Count of deletions needed to balance deletions = 0 # Loop through all frequencies and count necessary deletions for f in freq_list: deletions += f - freq_list[0] return deletions"},{"question":"def total_relay_race_time(N: int, times: List[int]) -> int: Given the number of students N and the list of times each student takes to complete their lap, return the total time for the relay race to complete. >>> total_relay_race_time(3, [5, 10, 3]) 18 >>> total_relay_race_time(4, [2, 4, 6, 8]) 20","solution":"def total_relay_race_time(N, times): Given the number of students N and the list of times each student takes to complete their lap, return the total time for the relay race to complete. return sum(times)"},{"question":"def min_rows_for_seating(R, C, N): Returns the minimum number of rows required to arrange N attendees in R rows and C columns to minimize the number of gaps. >>> min_rows_for_seating(3, 4, 10) 3 >>> min_rows_for_seating(5, 5, 12) 3 >>> min_rows_for_seating(2, 5, 6) 2 >>> min_rows_for_seating(4, 4, 15) 4","solution":"def min_rows_for_seating(R, C, N): Returns the minimum number of rows required to arrange N attendees in R rows and C columns to minimize the number of gaps. # Calculate the minimum number of full rows min_full_rows = (N + C - 1) // C # This is effectively ceil(N / C) return min(min_full_rows, R) # Example usage: # R, C = 3, 4, N = 10 # print(min_rows_for_seating(R, C, N)) # Output: 3"},{"question":"from typing import List def generate_smallest_code(n: int) -> str: Generate the smallest possible code of length N following the conditions. >>> generate_smallest_code(3) \\"123\\" >>> generate_smallest_code(6) \\"123123\\" >>> generate_smallest_code(5) \\"12312\\" >>> generate_smallest_code(1) -1 pass def process_test_cases(test_cases: List[int]) -> List[str]: Process a list of test cases and generate the smallest possible code for each. >>> process_test_cases([3, 6, 5, 1]) [\\"123\\", \\"123123\\", \\"12312\\", -1] >>> process_test_cases([9, 4, 7, 10, 2]) [\\"123123123\\", \\"1231\\", \\"1231231\\", \\"1231231231\\", -1] pass","solution":"def generate_smallest_code(n): if n < 3: return -1 base_code = \\"123\\" full_repeats = n // 3 remainder = n % 3 if remainder == 0: return base_code * full_repeats elif remainder == 1: return base_code * (full_repeats - 1) + \\"1231\\" else: return base_code * (full_repeats - 1) + \\"12312\\" def process_test_cases(test_cases): results = [] for n in test_cases: results.append(generate_smallest_code(n)) return results"},{"question":"def count_skipped_segments(N: int, M: int, K: int, segments: List[int]) -> int: Returns the number of segments Rex will skip based on the threshold K. Parameters: - N: int, the number of segments (1 ≤ N ≤ 100) - M: int, the maximum difficulty rating (1 ≤ M ≤ 100) - K: int, the threshold difficulty rating (1 ≤ K ≤ M) - segments: list of int, the difficulty ratings of the segments (each between 1 and M) Returns: - int, the number of segments Rex will skip Examples: >>> count_skipped_segments(5, 10, 5, [6, 4, 8, 2, 10]) 2 >>> count_skipped_segments(3, 7, 6, [2, 3, 5]) 3 >>> count_skipped_segments(4, 5, 3, [1, 2, 3, 4]) 2","solution":"def count_skipped_segments(N, M, K, segments): Returns the number of segments Rex will skip based on the threshold K. Parameters: - N: int, the number of segments (1 ≤ N ≤ 100) - M: int, the maximum difficulty rating (1 ≤ M ≤ 100) - K: int, the threshold difficulty rating (1 ≤ K ≤ M) - segments: list of int, the difficulty ratings of the segments (each between 1 and M) Returns: - int, the number of segments Rex will skip return sum(1 for segment in segments if segment < K)"},{"question":"def smallest_string_after_reversals(t: int, strings: List[str]) -> List[str]: Given t independent test cases with strings consisting of lowercase English letters, return the lexicographically smallest string that can be obtained by reversing subsegments. >>> smallest_string_after_reversals(1, [\\"cba\\"]) [\\"abc\\"] >>> smallest_string_after_reversals(2, [\\"bca\\", \\"acb\\"]) [\\"abc\\", \\"abc\\"] >>> smallest_string_after_reversals(1, [\\"abc\\"]) [\\"abc\\"] >>> smallest_string_after_reversals(1, [\\"aaaaa\\"]) [\\"aaaaa\\"] >>> smallest_string_after_reversals(2, [\\"ccc\\", \\"ccc\\"]) [\\"ccc\\", \\"ccc\\"] >>> smallest_string_after_reversals(3, [\\"z\\", \\"bac\\", \\"zyxw\\"]) [\\"z\\", \\"abc\\", \\"wxyz\\"]","solution":"def smallest_string_after_reversals(t, strings): Given t independent test cases with strings consisting of lowercase English letters, return the lexicographically smallest string that can be obtained by reversing subsegments. return [''.join(sorted(s)) for s in strings]"},{"question":"from typing import List def detect_spamming(timestamps: List[str]) -> bool: Determines if a user has sent more than one message within any single minute. >>> detect_spamming([\\"2023-10-10 08:30:00\\", \\"2023-10-10 08:30:45\\", \\"2023-10-10 08:31:00\\"]) True >>> detect_spamming([\\"2023-10-10 08:30:00\\", \\"2023-10-10 08:31:00\\", \\"2023-10-10 08:32:00\\"]) False >>> detect_spamming([\\"2023-10-10 08:30:00\\"]) False","solution":"def detect_spamming(timestamps): from collections import defaultdict minute_counts = defaultdict(int) for ts in timestamps: # Extract only the \\"YYYY-MM-DD HH:MM\\" part of the timestamp minute = ts[:16] minute_counts[minute] += 1 if minute_counts[minute] > 1: return True return False"},{"question":"def max_stone_value(n, stones): Returns the maximum possible value of the stone after applying the operation exactly once. >>> max_stone_value(3, [5, 2, 9]) 14 >>> max_stone_value(2, [1, 2]) 3 >>> max_stone_value(4, [3, 5, 7, 9]) 16 >>> max_stone_value(3, [4, 4, 4]) 8 >>> max_stone_value(6, [5, 3, 8, 2, 5, 10]) 18","solution":"def max_stone_value(n, stones): Returns the maximum possible value of the stone after applying the operation exactly once. # If there are only two stones, return their sum directly if n == 2: return stones[0] + stones[1] # For more than two stones, find the largest and the second largest stone values first_max = max(stones) stones.remove(first_max) second_max = max(stones) # The result will be the sum of the two largest values return first_max + second_max"},{"question":"def filterEvenOdd(nums, flag): Returns a list of even numbers if flag is True or odd numbers if flag is False from the list nums. Example 1: >>> filterEvenOdd([1, 2, 3, 4, 5, 6], True) [2, 4, 6] Example 2: >>> filterEvenOdd([10, 15, 20, 25, 30], False) [15, 25]","solution":"def filterEvenOdd(nums, flag): Returns a list of even numbers if flag is True or odd numbers if flag is False from the list nums. if flag: return [num for num in nums if num % 2 == 0] else: return [num for num in nums if num % 2 != 0]"},{"question":"def minBoxes(weights, capacity): Returns the minimum number of boxes required to pack all the products without exceeding the weight limit of each box. >>> minBoxes([2, 3, 7, 8, 4], 10) 3 >>> minBoxes([5, 5, 5, 5, 5], 10) 3 >>> minBoxes([1, 1, 1, 1], 10) 1 >>> minBoxes([10, 10, 10], 10) 3 >>> minBoxes([7, 8, 4, 3, 2], 15) 2","solution":"def minBoxes(weights, capacity): Returns the minimum number of boxes required to pack all the products without exceeding the weight limit of each box. weights.sort(reverse=True) # Sort the weights in descending order boxes = 0 while weights: current_capacity = capacity box_contents = [] for weight in weights[:]: if weight <= current_capacity: current_capacity -= weight box_contents.append(weight) for weight in box_contents: weights.remove(weight) boxes += 1 return boxes"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing integers and +, -, *, / operators. Assumes the expression is properly formatted with no parentheses. >>> evaluate_expression(\\"3+5\\") == 8 >>> evaluate_expression(\\"10-2\\") == 8 >>> evaluate_expression(\\"4*3\\") == 12 >>> evaluate_expression(\\"20/4\\") == 5 >>> evaluate_expression(\\"3+5*2\\") == 13 >>> evaluate_expression(\\"10+20/5*3\\") == 22 >>> evaluate_expression(\\"100-10*3/5\\") == 94 >>> evaluate_expression(\\"2+3*4-5\\") == 9 >>> evaluate_expression(\\"10//3\\") == 3 # Integer division >>> evaluate_expression(\\"18//5\\") == 3","solution":"def evaluate_expression(expression): Evaluates a mathematical expression containing integers and +, -, *, / operators. Assumes the expression is properly formatted with no parentheses. return eval(expression)"},{"question":"def canFormPalindrome(s: str) -> bool: Determine if a string consisting of lowercase and uppercase alphabets can be rearranged to form a palindrome. >>> canFormPalindrome(\\"racecar\\") True >>> canFormPalindrome(\\"aabbcc\\") True >>> canFormPalindrome(\\"abc\\") False >>> canFormPalindrome(\\"Aabb\\") False # Implement the function here","solution":"def canFormPalindrome(s): from collections import Counter # Count frequency of each character frequency = Counter(s) # Count the number of characters with odd frequency odd_count = sum(1 for count in frequency.values() if count % 2 != 0) # For the string to be rearranged into a palindrome: # It can have at most one character with an odd frequency (for odd length) # and all others must have even frequency. return odd_count <= 1"},{"question":"def maxSlidingWindowSum(nums, k): Returns the maximum sum of any subarray of size k in the list nums. Parameters: nums (List[int]): A list of integers. k (int): The size of the sliding window. Returns: int: The maximum sum of any subarray of size k. Examples: >>> maxSlidingWindowSum([1, 2, 3, 4, 5], 2) 9 >>> maxSlidingWindowSum([7, -8, 5, 6, -3], 3) 8 >>> maxSlidingWindowSum([3, -1, 2, 10, -5, 7], 3) 12","solution":"def maxSlidingWindowSum(nums, k): Returns the maximum sum of any subarray of size k in the list nums. if not nums or k <= 0 or k > len(nums): return None # Calculate the initial window sum window_sum = sum(nums[:k]) max_sum = window_sum # Slide the window and continue calculating the new sums for i in range(k, len(nums)): # Subtract the element going out of the window and add the new element coming into the window window_sum += nums[i] - nums[i - k] max_sum = max(max_sum, window_sum) return max_sum"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing only non-negative integers, addition (+), and multiplication (*), and returns the result. The expression follows the standard order of operations: multiplication before addition. >>> evaluate_expression(\\"2+3*2\\") == 8 >>> evaluate_expression(\\"10+2*6\\") == 22 >>> evaluate_expression(\\"100*2+12\\") == 212 >>> evaluate_expression(\\"2*5+10\\") == 20 >>> evaluate_expression(\\"10+10\\") == 20","solution":"def evaluate_expression(expression: str) -> int: Evaluates a mathematical expression containing only non-negative integers, addition (+), and multiplication (*), and returns the result. The expression follows the standard order of operations: multiplication before addition. # Split the expression by '+' to handle addition parts addition_parts = expression.split('+') # Evaluate each addition part addition_results = [] for part in addition_parts: # For each part, evaluate any multiplication expressions multiplication_parts = part.split('*') multiplication_result = 1 for factor in multiplication_parts: multiplication_result *= int(factor) addition_results.append(multiplication_result) # Sum up all the addition results to get the final result return sum(addition_results)"},{"question":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def segregateList(head): Segregates the linked list such that all nodes with data value 0 come first, followed by nodes with data value 1, and finally nodes with data value 2. pass","solution":"class ListNode: def __init__(self, data=0, next=None): self.data = data self.next = next def segregateList(head): Segregates the linked list such that all nodes with data value 0 come first, followed by nodes with data value 1, and finally nodes with data value 2. if head is None or head.next is None: return head zero_dummy = ListNode(-1) one_dummy = ListNode(-1) two_dummy = ListNode(-1) zero = zero_dummy one = one_dummy two = two_dummy current = head while current: if current.data == 0: zero.next = current zero = zero.next elif current.data == 1: one.next = current one = one.next else: two.next = current two = two.next current = current.next zero.next = one_dummy.next if one_dummy.next else two_dummy.next one.next = two_dummy.next two.next = None return zero_dummy.next"},{"question":"from typing import List def largest_number(arr: List[int]) -> str: Given a list of integers, rearrange them such that the largest number that can be formed by concatenating the elements together is obtained. >>> largest_number([3, 30, 34, 5, 9]) \\"9534330\\" >>> largest_number([54, 546, 548]) \\"54854654\\"","solution":"from functools import cmp_to_key def largest_number(arr): Given a list of non-negative integers, arranges them such that they form the largest number. # Custom comparator to decide which concatenation forms a larger number def compare(x, y): if x + y > y + x: return -1 elif x + y < y + x: return 1 else: return 0 # Convert numbers to strings for easy comparison arr = list(map(str, arr)) # Sort the array with the custom comparator arr.sort(key=cmp_to_key(compare)) # Join the sorted array into the largest number largest_num = ''.join(arr) # Edge case: multiple zeros if largest_num[0] == '0': return '0' else: return largest_num"},{"question":"def calculate_total_size(directory_structure): Calculate the total size of all files in the given directory structure. Args: - directory_structure (list of dicts): A nested list of dictionaries representing directories. Returns: - int: Total size of all files. >>> directory_structure = [ ... { ... \\"folder1\\": [ ... (\\"file1.txt\\", 100), ... {\\"subfolder1\\": [(\\"file2.txt\\", 200)]}, ... ], ... \\"folder2\\": [ ... (\\"file3.txt\\", 300), ... {\\"subfolder2\\": [(\\"file4.txt\\", 400)]}, ... (\\"file5.txt\\", 50) ... ] ... } ... ] >>> calculate_total_size(directory_structure) 1050","solution":"def calculate_total_size(directory_structure): Calculate the total size of all files in the given directory structure. Args: - directory_structure (list of dicts): A nested list of dictionaries representing directories. Returns: - int: Total size of all files. total_size = 0 def process_directory(directory): nonlocal total_size for key, value in directory.items(): for item in value: if isinstance(item, tuple): total_size += item[1] elif isinstance(item, dict): process_directory(item) for directory in directory_structure: process_directory(directory) return total_size"},{"question":"def first_unique_number(test_cases): Given a list of test cases, find the first integer in each list that occurs only once. If no such integer exists, return -1 for that test case. >>> first_unique_number([[2, 3, 4, 2, 3]]) [4] >>> first_unique_number([[1, 2, 3, 4, 5, 1]]) [2] >>> first_unique_number([[7, 7, 7, 7]]) [-1] pass def parse_input(input_string): Parse the input string and return a list of test cases where each test case is a list of integers. >>> parse_input(\\"3n5 2 3 4 2 3n6 1 2 3 4 5 1n4 7 7 7 7\\") [[2, 3, 4, 2, 3], [1, 2, 3, 4, 5, 1], [7, 7, 7, 7]] pass def produce_output(results): Convert the list of results to the expected output string format. >>> produce_output([4, 2, -1]) \\"4n2n-1\\" pass def solve_problem(input_string): Solve the problem given the input string, returning the output in the expected format. >>> solve_problem(\\"3n5 2 3 4 2 3n6 1 2 3 4 5 1n4 7 7 7 7\\") \\"4n2n-1\\" pass","solution":"def first_unique_number(test_cases): results = [] for case in test_cases: count = {} for num in case: count[num] = count.get(num, 0) + 1 found = -1 for num in case: if count[num] == 1: found = num break results.append(found) return results def parse_input(input_string): input_lines = input_string.strip().split('n') T = int(input_lines[0]) test_cases = [] for i in range(1, T + 1): case = list(map(int, input_lines[i].strip().split()))[1:] test_cases.append(case) return test_cases def produce_output(results): return \\"n\\".join(map(str, results)) def solve_problem(input_string): test_cases = parse_input(input_string) results = first_unique_number(test_cases) return produce_output(results)"},{"question":"def find_connected_components(N: int, M: int, edges: List[Tuple[int, int]]) -> int: Finds the number of connected components in an undirected graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): List of edges (u, v) representing an undirected edge between node u and node v Returns: int: Number of connected components >>> find_connected_components(6, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (4, 6)]) 2 >>> find_connected_components(5, 0, []) 5 >>> find_connected_components(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 1 >>> find_connected_components(1, 0, []) 1 >>> find_connected_components(4, 2, [(1, 2), (3, 4)]) 2","solution":"def find_connected_components(N, M, edges): Finds the number of connected components in an undirected graph. Parameters: N (int): Number of nodes M (int): Number of edges edges (list of tuples): List of edges (u, v) representing an undirected edge between node u and node v Returns: int: Number of connected components from collections import defaultdict, deque # Create an adjacency list graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) def bfs(start): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) connected_components = 0 for node in range(1, N + 1): if not visited[node]: connected_components += 1 visited[node] = True bfs(node) return connected_components"},{"question":"def contains_duplicates(arr: List[int]) -> bool: Determine if the array contains any duplicate elements. Args: arr (list): The list of integers to check. Returns: bool: True if there are duplicates, False otherwise. >>> contains_duplicates([1, 2, 3, 1]) True >>> contains_duplicates([1, 2, 3, 4]) False >>> contains_duplicates([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) True","solution":"def contains_duplicates(arr): Determine if the array contains any duplicate elements. Args: arr (list): The list of integers to check. Returns: bool: True if there are duplicates, False otherwise. seen = set() for num in arr: if num in seen: return True seen.add(num) return False"},{"question":"def find_max_length(nums): Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. >>> find_max_length([0, 1, 0, 1, 1, 1]) 4 >>> find_max_length([0, 1]) 2 >>> find_max_length([0, 0, 0]) 0 >>> find_max_length([1, 1, 1, 1, 1]) 0 >>> find_max_length([0, 0, 0, 0, 0]) 0 >>> find_max_length([0, 1, 1, 0, 0, 1, 1, 0]) 8 >>> find_max_length([0, 1, 0, 1] * 2500) 10000 >>> find_max_length([0]) 0 >>> find_max_length([1]) 0 >>> find_max_length([0, 1, 0, 1, 0, 1, 0, 1]) 8","solution":"def find_max_length(nums): Returns the length of the longest contiguous subarray with an equal number of 0s and 1s. count = 0 max_length = 0 count_map = {0: -1} # Initializing with 0 to handle the base case. for i, num in enumerate(nums): # Increment count for 1 and decrement for 0. count += 1 if num == 1 else -1 if count in count_map: max_length = max(max_length, i - count_map[count]) else: count_map[count] = i return max_length"},{"question":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses (including the circular adjacency). >>> rob([2, 3, 2]) 3 >>> rob([1, 2, 3, 1]) 4 >>> rob([0]) 0","solution":"def rob(nums): Returns the maximum amount of money you can rob without robbing two adjacent houses (including the circular adjacency). if not nums: return 0 if len(nums) == 1: return nums[0] def rob_linear(houses): prev, curr = 0, 0 for money in houses: prev, curr = curr, max(curr, prev + money) return curr return max(rob_linear(nums[:-1]), rob_linear(nums[1:]))"},{"question":"def reverseAlphabets(s: str) -> str: Form a new string by reversing only the alphabets while keeping the digits at their original positions. >>> reverseAlphabets(\\"a1b2c3d\\") \\"d1c2b3a\\" >>> reverseAlphabets(\\"ab12cd34\\") \\"dc12ba34\\"","solution":"def reverseAlphabets(s): Reverses only the alphabets in the string s and keeps digits in their original positions. Args: s: str - input string containing alphabets and digits Returns: str - new string with alphabets reversed and digits in original positions # Extract all alphabets from the string alphabets = [ch for ch in s if ch.isalpha()] # Initialize an empty list to build the result result = [] # Traverse the original string for ch in s: if ch.isalpha(): # Pop the last alphabet from the list and append to result result.append(alphabets.pop()) else: # Append digit directly to result result.append(ch) return \\"\\".join(result)"},{"question":"def is_almost_palindrome(s): Determines if a string can be made into a palindrome by removing at most one character. pass def process_test_cases(t, test_cases): Processes multiple test cases to determine if the strings can be made into palindromes by removing at most one character. Arguments: - t: Integer, the number of test cases. - test_cases: List of strings, each string being a test case. Returns: - List of strings \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(2, [\\"abca\\", \\"abc\\"]) [\\"YES\\", \\"NO\\"] >>> process_test_cases(1, [\\"a\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"aa\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"ab\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"racecar\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"raceecar\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"abcdefgh\\"]) [\\"NO\\"] >>> process_test_cases(1, [\\"a\\" * 100000]) [\\"YES\\"] >>> process_test_cases(1, [\\"a\\" * 99999 + \\"b\\"]) [\\"YES\\"] >>> process_test_cases(1, [\\"a\\" * 99998 + \\"bc\\"]) [\\"NO\\"] pass","solution":"def is_almost_palindrome(s): Determines if a string can be made into a palindrome by removing at most one character. def is_palindrome_range(i, j): while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True i, j = 0, len(s) - 1 while i < j: if s[i] != s[j]: return is_palindrome_range(i + 1, j) or is_palindrome_range(i, j - 1) i += 1 j -= 1 return True def process_test_cases(t, test_cases): results = [] for s in test_cases: if is_almost_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def count_distinct_pairs_with_difference(arr, k): Returns the number of distinct pairs (i, j) such that i < j and the difference between arr[i] and arr[j] is equal to k. :param arr: List of integers :param k: Integer representing the required difference :return: Integer representing the number of distinct pairs pass # Unit Tests def test_example_case_1(): assert count_distinct_pairs_with_difference([1, 5, 3, 4, 2], 2) == 3 def test_example_case_2(): assert count_distinct_pairs_with_difference([8, 6, 1, 5], 3) == 1 def test_no_pairs(): assert count_distinct_pairs_with_difference([1, 2, 3], 10) == 0 def test_all_same_elements(): assert count_distinct_pairs_with_difference([1, 1, 1, 1], 0) == 1 def test_large_difference(): assert count_distinct_pairs_with_difference([-10**9, 0, 10**9], 2 * 10**9) == 1 def test_negative_difference_k(): assert count_distinct_pairs_with_difference([3, 1, 4, 1, 5], -2) == 2 def test_mixed_positive_negative_elements(): assert count_distinct_pairs_with_difference([10, 0, -10, -20], 10) == 3 def test_empty_list(): assert count_distinct_pairs_with_difference([], 1) == 0","solution":"def count_distinct_pairs_with_difference(arr, k): Returns the number of distinct pairs (i, j) such that i < j and the difference between arr[i] and arr[j] is equal to k. :param arr: List of integers :param k: Integer representing the required difference :return: Integer representing the number of distinct pairs # Convert the list to a set to avoid duplicates and enable O(1) lookups unique_elements = set(arr) pair_count = 0 # Iterate through the unique elements for element in unique_elements: if (element + k) in unique_elements: pair_count += 1 return pair_count # Example Usage # arr = [1, 5, 3, 4, 2] # k = 2 # print(count_distinct_pairs_with_difference(arr, k)) # Output: 3"},{"question":"import re from typing import List def create_index(text: str) -> List[str]: Takes a string text and returns a list of unique words sorted alphabetically, considering only words and handling apostrophes but not other punctuations. >>> create_index(\\"It's a beautiful day! The sun is shining, and the birds are singing.\\") [\\"It's\\", \\"The\\", \\"a\\", \\"and\\", \\"are\\", \\"beautiful\\", \\"birds\\", \\"day\\", \\"is\\", \\"shining\\", \\"singing\\", \\"sun\\", \\"the\\"] >>> create_index(\\"Programming in Python is fun. Python is powerful, yet simple.\\") [\\"Programming\\", \\"Python\\", \\"fun\\", \\"in\\", \\"is\\", \\"powerful\\", \\"simple\\", \\"yet\\"]","solution":"import re def create_index(text): Takes a string text and returns a list of unique words sorted alphabetically, considering only words and handling apostrophes but not other punctuations. # Remove punctuation except for apostrophes text = re.sub(r\\"[^ws']\\", '', text) # Split text into words words = text.split() # Get unique words and sort them unique_words = sorted(set(words)) return unique_words"},{"question":"def top_performers(M: int, N: int, projects: list) -> str: Identify the top-performing employees who have completed at least N projects. >>> top_performers(5, 10, [12, 5, 15, 20, 7]) '1 3 4' >>> top_performers(3, 10, [5, 3, 8]) 'None' >>> top_performers(4, 2, [2, 3, 5, 7]) '1 2 3 4' >>> top_performers(3, 5, [5, 2, 5]) '1 3' >>> top_performers(5, 6, [1, 2, 3, 6, 2]) '4' >>> top_performers(0, 10, []) 'None'","solution":"def top_performers(M, N, projects): Identify the top-performing employees who have completed at least N projects. Parameters: M (int): Number of employees. N (int): Minimum number of projects required. projects (list of int): List containing the number of projects each employee has completed. Returns: list: List of employee IDs (1-based index) who have completed N or more projects. Sorted in ascending order of their IDs. top_performers = [(i + 1) for i, project in enumerate(projects) if project >= N] if not top_performers: return \\"None\\" return ' '.join(map(str, top_performers))"},{"question":"import math from typing import List, Tuple def maximize_gcd(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[List[int]]: Modify array B such that for each i (0 <= i < N), gcd(A[i], B[i]) is maximized. >>> maximize_gcd(1, [(3, [4, 6, 15], [8, 9, 5])]) [[4, 6, 15]] >>> maximize_gcd(1, [(4, [20, 30, 40, 50], [7, 12, 23, 35])]) [[20, 30, 40, 50]]","solution":"import math def maximize_gcd(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] A = test_cases[i][1] B = test_cases[i][2] # For maximizing gcd, we can simply replace each B[i] with A[i] # If gcd(A[i], B[i]) is maximized when B[i] = A[i] modified_B = A results.append(modified_B) return results"},{"question":"def max_number_by_one_reverse(num_str: str) -> str: Returns the maximum possible number by reversing one contiguous substring of the input string. >>> max_number_by_one_reverse(\\"12345\\") '54321' >>> max_number_by_one_reverse(\\"54321\\") '54321' pass def process_test_cases(T: int, test_cases: List[str]) -> List[str]: For each test case, finds the maximum possible number that can be obtained by reversing exactly one contiguous substring. >>> process_test_cases(2, [\\"12345\\", \\"54321\\"]) ['54321', '54321'] >>> process_test_cases(1, [\\"9876543210\\"]) ['9876543210'] pass","solution":"def max_number_by_one_reverse(num_str): Returns the maximum possible number by reversing one contiguous substring of the input string. n = len(num_str) max_value = num_str # Start with the original string as the max value # We only need to check each pair of i and j where 0 <= i < j < n for i in range(n): for j in range(i + 1, n + 1): # Reverse the substring between i and j and get the new string new_num_str = num_str[:i] + num_str[i:j][::-1] + num_str[j:] if new_num_str > max_value: max_value = new_num_str return max_value def process_test_cases(T, test_cases): results = [] for num_str in test_cases: results.append(max_number_by_one_reverse(num_str)) return results"},{"question":"def minimal_grid_sum(n: int, m: int, grid: List[List[int]]) -> int: Given a grid of n rows and m columns filled with non-negative integers, minimize the sum of all elements in the grid by applying optimal operations. Args: n : int : number of rows in the grid m : int : number of columns in the grid grid : List[List[int]] : 2D list of integers representing the grid elements Returns: int : the minimal sum of the grid after applying the operations Examples: >>> minimal_grid_sum(3, 3, [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 45 >>> minimal_grid_sum(2, 2, [ ... [1, 1], ... [1, 2] ... ]) 5","solution":"def minimal_grid_sum(n, m, grid): Given a grid of n rows and m columns filled with non-negative integers, calculates the minimal sum of all elements in the grid by applying optimal operations. # The minimal sum can be achieved by reducing every element to the minimal value in the grid min_value = min(min(row) for row in grid) total_sum = sum(sum(cell - min_value for cell in row) for row in grid) return total_sum + n * m * min_value"},{"question":"def calculate_minimum_cost(n: int, m: int, matrix: List[List[int]]) -> List[List[int]]: Returns the matrix of minimum costs to travel from the top-left corner (1, 1) to each cell (i, j). Parameters: n (int): number of rows. m (int): number of columns. matrix (list of list of int): matrix of nonnegative integers. Returns: list of list of int: matrix of minimum costs. >>> calculate_minimum_cost(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) [[1, 4, 5], [2, 7, 6], [6, 8, 7]] >>> calculate_minimum_cost(1, 1, [[5]]) [[5]] >>> calculate_minimum_cost(1, 3, [[1, 2, 3]]) [[1, 3, 6]] >>> calculate_minimum_cost(3, 1, [[1], [2], [3]]) [[1], [3], [6]] >>> calculate_minimum_cost(3, 4, [[1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 1]]) [[1, 4, 5, 7], [2, 7, 6, 9], [6, 8, 7, 8]]","solution":"def calculate_minimum_cost(n, m, matrix): Returns the matrix of minimum costs to travel from the top-left corner (1,1) to each cell (i, j). Parameters: n (int): number of rows. m (int): number of columns. matrix (list of list of int): matrix of nonnegative integers. Returns: list of list of int: matrix of minimum costs. # Create a dp array to store the minimum costs dp = [[float('inf')] * m for _ in range(n)] dp[0][0] = matrix[0][0] for r in range(n): for c in range(m): if r > 0: dp[r][c] = min(dp[r][c], dp[r-1][c] + matrix[r][c]) if c > 0: dp[r][c] = min(dp[r][c], dp[r][c-1] + matrix[r][c]) return dp"},{"question":"def process_flower_data(n: int, flower_records: list, q: int, queries: list) -> list: Process flower records and respond to queries about them. >>> n = 4 >>> flower_records = [(\\"F1\\", \\"Daisy\\", \\"White\\", 30), (\\"F2\\", \\"Rose\\", \\"Red\\", 50), (\\"F3\\", \\"Tulip\\", \\"Yellow\\", 40), (\\"F4\\", \\"Lily\\", \\"Pink\\", 25)] >>> q = 2 >>> queries = [\\"F2\\", \\"F5\\"] >>> process_flower_data(n, flower_records, q, queries) ['Rose Red 50', 'Flower not found'] >>> n = 3 >>> flower_records = [(\\"ABC\\", \\"Daisy\\", \\"White\\", 30), (\\"XYZ\\", \\"Rose\\", \\"Red\\", 50), (\\"LMN\\", \\"Tulip\\", \\"Yellow\\", 40)] >>> q = 3 >>> queries = [\\"XYZ\\", \\"ABC\\", \\"QWE\\"] >>> process_flower_data(n, flower_records, q, queries) ['Rose Red 50', 'Daisy White 30', 'Flower not found']","solution":"def process_flower_data(n, flower_records, q, queries): Process flower records and respond to queries about them. Parameters: n (int): Number of flower records. flower_records (list of tuples): List of flower records where each record is a tuple (identifier, name, color, height). q (int): Number of queries. queries (list of str): List of flower identifiers to query. Returns: list of str: List of query responses containing flower details or \\"Flower not found\\". # Create a dictionary to store flower data for quick access by identifier flower_dict = {record[0]: (record[1], record[2], record[3]) for record in flower_records} results = [] for identifier in queries: if identifier in flower_dict: name, color, height = flower_dict[identifier] results.append(f\\"{name} {color} {height}\\") else: results.append(\\"Flower not found\\") return results"},{"question":"def smallest_missing_positive(n, k, a): Find the smallest positive integer that does not appear in any subarray of length k in the array a. Parameters: n (int): Length of the array. k (int): Length of the subarrays to consider. a (list of int): The elements of the array. Returns: int: The smallest positive integer that does not appear in any subarray of length k. If such integer does not exist, returns -1. Examples: >>> smallest_missing_positive(5, 3, [1, 2, 2, 3, 1]) 4 >>> smallest_missing_positive(4, 2, [1, 2, 1, 3]) 4 >>> smallest_missing_positive(6, 4, [1, 2, 3, 4, 5, 6]) 7","solution":"def smallest_missing_positive(n, k, a): Find the smallest positive integer that does not appear in any subarray of length k in the array a. Parameters: n (int): Length of the array. k (int): Length of the subarrays to consider. a (list of int): The elements of the array. Returns: int: The smallest positive integer that does not appear in any subarray of length k. If such integer does not exist, returns -1. from itertools import islice def get_subarray_elements(arr, start, end): Return the distinct elements in the subarray from start index to end index. return set(islice(arr, start, end)) missing = 1 while True: found = False for i in range(n - k + 1): if missing in get_subarray_elements(a, i, i + k): found = True break if not found: return missing missing += 1 return -1"},{"question":"import math def is_interesting_number(n: int) -> str: Determine whether a given number is interesting according to Polycarpus's definition. A number is interesting if it is a prime number or can be expressed as the product of exactly two prime numbers. >>> is_interesting_number(5) 'Yes' >>> is_interesting_number(6) 'Yes' >>> is_interesting_number(8) 'No'","solution":"import math def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_interesting_number(n): if is_prime(n): return \\"Yes\\" for i in range(2, int(math.sqrt(n)) + 1): if n % i == 0 and is_prime(i) and is_prime(n // i): return \\"Yes\\" return \\"No\\""},{"question":"def smallest_subarray_with_sum(arr: List[int], x: int) -> int: Find the smallest subarray with a sum greater than or equal to a given value x. Parameters: arr (List[int]): a list of integers x (int): the target sum Returns: int: the length of the smallest subarray or -1 if no such subarray exists >>> smallest_subarray_with_sum([1, 2, 3, 4, 5, 6], 15) 3 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1], 10) -1 >>> smallest_subarray_with_sum([1, 2, 3, 4, 5], 9) 2 >>> smallest_subarray_with_sum([10], 5) 1 >>> smallest_subarray_with_sum([5], 10) -1 >>> smallest_subarray_with_sum([2, 1, 5, 2, 8], 7) 1 >>> smallest_subarray_with_sum([4, 2, 2, 7, 8, 1, 2, 8, 10], 8) 1","solution":"def smallest_subarray_with_sum(arr, x): n = len(arr) min_length = float('inf') current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= x: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def isValidSudoku(board: List[List[str]]) -> bool: Validate the given Sudoku board. :param board: 2D array representing the Sudoku board :return: True if the board is valid, False otherwise >>> board = [ ['5','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9'] ] >>> isValidSudoku(board) True >>> board = [ ['8','3','.','.','7','.','.','.','.'], ['6','.','.','1','9','5','.','.','.'], ['.','9','8','.','.','.','.','6','.'], ['8','.','.','.','6','.','.','.','3'], ['4','.','.','8','.','3','.','.','1'], ['7','.','.','.','2','.','.','.','6'], ['.','6','.','.','.','.','2','8','.'], ['.','.','.','4','1','9','.','.','5'], ['.','.','.','.','8','.','.','7','9'] ] >>> isValidSudoku(board) False","solution":"def isValidSudoku(board): Validate the given Sudoku board. :param board: List[List[str]]; 2D array representing the Sudoku board :return: bool; True if the board is valid, False otherwise # Helper function to validate a block (row, column or sub-grid) def is_valid_block(block): block = [num for num in block if num != '.'] return len(block) == len(set(block)) # Validate rows and columns for i in range(9): row = [board[i][j] for j in range(9)] if not is_valid_block(row): return False col = [board[j][i] for j in range(9)] if not is_valid_block(col): return False # Validate 3x3 sub-grids for i in range(0, 9, 3): for j in range(0, 9, 3): sub_grid = [ board[i + m][j + n] for m in range(3) for n in range(3) ] if not is_valid_block(sub_grid): return False return True"},{"question":"def number_of_paths(grid: List[List[int]]) -> int: Find the number of distinct paths from the top-left corner to the bottom-right corner in a grid, where 0 represents an empty cell and 1 represents a blocked cell. The function returns the number of distinct paths modulo 1000000007. >>> number_of_paths([[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> number_of_paths([[0, 1], [0, 0]]) == 1 >>> number_of_paths([[1, 0, 0], [0, 0, 0], [0, 0, 0]]) == 0 >>> number_of_paths([[0, 0, 0], [0, 0, 0], [0, 0, 1]]) == 0 >>> number_of_paths([[0]]) == 1","solution":"def number_of_paths(grid): MOD = 1000000007 m, n = len(grid), len(grid[0]) # If starting or ending cell is blocked, return 0. if grid[0][0] == 1 or grid[m-1][n-1] == 1: return 0 # Initialize DP table dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] = (dp[i][j] + dp[i-1][j]) % MOD if j > 0: dp[i][j] = (dp[i][j] + dp[i][j-1]) % MOD return dp[m-1][n-1]"},{"question":"def max_operations(n: int, T: int, times: List[int]) -> int: Determine the maximum number of operations that can be executed within the time limit. >>> max_operations(4, 10, [2, 3, 2, 1]) 5 >>> max_operations(3, 15, [5, 5, 5]) 3 >>> max_operations(6, 20, [3, 3, 4, 2, 5, 1]) 6","solution":"def max_operations(n, T, times): Determine the maximum number of operations that can be executed within the time limit. Parameters: n (int): Number of different operations. T (int): Available time limit. times (list of int): List of time taken for each operation. Returns: int: Maximum number of operations completed within the time limit. total_time = sum(times) # Total time taken to complete one full sequence of operations full_sequences = T // total_time # Number of full sequences that can be completed within T remaining_time = T % total_time # Remaining time after completing full sequences # Count how many more operations can be completed with the remaining_time completed_operations = full_sequences * n for time in times: if remaining_time >= time: remaining_time -= time completed_operations += 1 else: break return completed_operations"},{"question":"def encode_morse(text: str) -> str: Encodes a given English text string into Morse code, ignoring any characters that are not part of the Morse code alphabet. >>> encode_morse(\\"HELLO\\") '.... . .-.. .-.. ---' >>> encode_morse(\\"HELLO WORLD\\") '.... . .-.. .-.. --- / .-- --- .-. .-.. -..' >>> encode_morse(\\"HeLLo WoRLD\\") '.... . .-.. .-.. --- / .-- --- .-. .-.. -..' >>> encode_morse(\\"2019\\") '..--- ----- .---- ----.' >>> encode_morse(\\"HELLO, WORLD.\\") '.... . .-.. .-.. --- --..-- / .-- --- .-. .-.. -.. .-.-.-' >>> encode_morse(\\"HELLO WORLD!\\") '.... . .-.. .-.. --- / .-- --- .-. .-.. -..' >>> encode_morse(\\"\\") ''","solution":"def encode_morse(text): Encodes a given English text string into Morse code, ignoring any characters that are not part of the Morse code alphabet. morse_code_dict = { 'A': '.-', 'B': '-...', 'C': '-.-.', 'D': '-..', 'E': '.', 'F': '..-.', 'G': '--.', 'H': '....', 'I': '..', 'J': '.---', 'K': '-.-', 'L': '.-..', 'M': '--', 'N': '-.', 'O': '---', 'P': '.--.', 'Q': '--.-', 'R': '.-.', 'S': '...', 'T': '-', 'U': '..-', 'V': '...-', 'W': '.--', 'X': '-..-', 'Y': '-.--', 'Z': '--..', '0': '-----', '1': '.----', '2': '..---', '3': '...--', '4': '....-', '5': '.....', '6': '-....', '7': '--...', '8': '---..', '9': '----.', '.': '.-.-.-', ',': '--..--', '?': '..--..' } words = text.upper().split() encoded_words = [] for word in words: encoded_letters = [morse_code_dict[char] for char in word if char in morse_code_dict] encoded_words.append(\\" \\".join(encoded_letters)) return \\" / \\".join(encoded_words)"},{"question":"def is_sum_of_digits_divisible_by_9(K: str) -> str: Determine if the sum of the digits of K is divisible by 9. If it is, return \\"YES\\". Otherwise, return \\"NO\\". >>> is_sum_of_digits_divisible_by_9(\\"123456789012345678901234567890\\") \\"YES\\" >>> is_sum_of_digits_divisible_by_9(\\"8\\") \\"NO\\"","solution":"def is_sum_of_digits_divisible_by_9(K): This function checks if the sum of the digits of the given number K is divisible by 9. The number K is given as a string. If divisible by 9, it returns \\"YES\\", otherwise it returns \\"NO\\". digit_sum = sum(int(digit) for digit in K) return \\"YES\\" if digit_sum % 9 == 0 else \\"NO\\""},{"question":"def find_task_order(n: int, dependencies: List[Tuple[int, int]]) -> List[int]: Find and print the sequence in which the tasks should be completed. >>> find_task_order(4, [(1, 0), (2, 1), (3, 1), (4, 2)]) [1, 2, 4, 3] # or [1, 2, 3, 4] or any valid order >>> find_task_order(3, [(1, 0), (2, 0), (3, 2)]) [1, 2, 3] # or any valid order","solution":"def find_task_order(n, dependencies): from collections import defaultdict, deque # Create graph and in-degree count graph = defaultdict(list) in_degree = {i: 0 for i in range(1, 101)} for t, d in dependencies: if d != 0: graph[d].append(t) in_degree[t] += 1 # Find nodes with no incoming edges queue = deque() for node in range(1, n+1): if in_degree[node] == 0: queue.append(node) order = [] while queue: current = queue.popleft() order.append(current) for neighbor in graph[current]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) return order def main(): import sys input = sys.stdin.read data = input().strip().split() n = int(data[0]) dependencies = [] for i in range(1, len(data), 2): dependencies.append((int(data[i]), int(data[i+1]))) order = find_task_order(n, dependencies) print(\\" \\".join(map(str, order))) if __name__ == \\"__main__\\": main()"},{"question":"def count_balanced_subsegments(n: int, d: List[int]) -> int: Determine the number of continuous subsegments of the original sequence that contain an equal number of dots ('.') and dashes ('-'). Args: n (int): The size of the compressed sequence. d (List[int]): List containing the lengths of segments in the compressed sequence. Returns: int: Total number of balanced subsegments. Examples: >>> count_balanced_subsegments(4, [2, 3, 1, 1]) 2 >>> count_balanced_subsegments(3, [4, 2, 4]) 0 >>> count_balanced_subsegments(5, [2, 2, 2, 2, 2]) 6","solution":"def count_balanced_subsegments(n, d): Returns the number of balanced subsegments. :param n: int - The size of the compressed sequence :param d: List[int] - List containing the lengths of segments in the compressed sequence :return: int - Total number of balanced subsegments total_subsegments = 0 for start in range(n): dots = 0 dashes = 0 for end in range(start, n): if (end - start) % 2 == 0: dashes += d[end] else: dots += d[end] if dots == dashes: total_subsegments += 1 return total_subsegments"},{"question":"def is_palindrome(s: str) -> str: Checks whether a given string is a palindrome. Constraints: - The input string will contain only lowercase English letters. - The length of the string will be between 1 and 100. Args: s: A string to be checked. Returns: \\"YES\\" if the string is a palindrome, and \\"NO\\" otherwise. Examples: >>> is_palindrome(\\"racecar\\") 'YES' >>> is_palindrome(\\"hello\\") 'NO'","solution":"def is_palindrome(s): Checks whether the given string s is a palindrome. Returns \\"YES\\" if it is a palindrome, otherwise returns \\"NO\\". if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"def steps_to_palindrome(n: int) -> int: Write a function \`steps_to_palindrome(n)\` that receives a positive integer \`n\` and returns the number of steps required to transform \`n\` into a palindrome using the following procedure: 1. Reverse the digits of \`n\`. 2. Add the reversed number to the original number. 3. Check if the result is a palindrome. 4. If the result is not a palindrome, repeat the above steps with the new number until you obtain a palindrome. Ensure your function handles cases up to 10,000 steps and returns \`-1\` if a palindrome cannot be formed within this limit. For example: >>> steps_to_palindrome(56) 1 >>> steps_to_palindrome(87) 4 >>> steps_to_palindrome(123) 1 >>> steps_to_palindrome(196) -1","solution":"def steps_to_palindrome(n): def is_palindrome(num): Returns True if num is a palindrome, False otherwise. return str(num) == str(num)[::-1] def reverse_number(num): Returns the reverse of the given number. return int(str(num)[::-1]) steps = 0 while steps < 10000: if is_palindrome(n): return steps n = n + reverse_number(n) steps += 1 return -1"},{"question":"def max_consecutive_unoccupied_seats(test_cases): Find the maximum number of consecutive unoccupied seats in any row of the cinema hall for a given set of test cases. Args: test_cases (List[Dict]): A list of test cases, each containing the dimensions of the matrix (N, M) and the matrix (list of lists) Returns: List[int]: A list containing the maximum number of consecutive unoccupied seats for each test case Example: >>> test_cases = [ ... { ... 'dimensions': (3, 5), ... 'matrix': [ ... [1, 0, 1, 0, 0], ... [0, 0, 1, 1, 0], ... [1, 1, 1, 1, 1], ... ] ... } ... ] >>> max_consecutive_unoccupied_seats(test_cases) [2] >>> test_cases = [ ... { ... 'dimensions': (2, 3), ... 'matrix': [ ... [0, 0, 0], ... [1, 0, 1], ... ] ... }, ... { ... 'dimensions': (3, 5), ... 'matrix': [ ... [1, 0, 1, 0, 0], ... [0, 0, 1, 1, 0], ... [1, 1, 1, 1, 1], ... ] ... } ... ] >>> max_consecutive_unoccupied_seats(test_cases) [3, 2]","solution":"def max_consecutive_unoccupied_seats(test_cases): results = [] for case in test_cases: N, M = case['dimensions'] matrix = case['matrix'] max_consecutive = 0 # Check each row for the maximum consecutive \`0\`s for row in matrix: current_count = 0 max_in_row = 0 for seat in row: if seat == 0: current_count += 1 max_in_row = max(max_in_row, current_count) else: current_count = 0 max_consecutive = max(max_consecutive, max_in_row) results.append(max_consecutive) return results"},{"question":"def is_palindrome(s: str) -> str: Determines whether the given string is a palindrome. Ignores spaces, punctuation, and capitalization. Parameters: s (str): The input string to be checked. Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") \\"YES\\" >>> is_palindrome(\\"No lemon, no melon\\") \\"YES\\" >>> is_palindrome(\\"race a car\\") \\"NO\\" >>> is_palindrome(\\"hello\\") \\"NO\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"Z\\") \\"YES\\" >>> is_palindrome(\\"\\") \\"YES\\" >>> is_palindrome(\\"Able was I, ere I saw Elba\\") \\"YES\\" >>> is_palindrome(\\"!!!\\") \\"YES\\" >>> is_palindrome(\\"!@# !% #!@\\") \\"YES\\" >>> is_palindrome(\\"a!!a\\") \\"YES\\"","solution":"def is_palindrome(s): Determines whether the given string is a palindrome. Ignores spaces, punctuation, and capitalization. Parameters: s (str): The input string to be checked. Returns: str: \\"YES\\" if the string is a palindrome, \\"NO\\" otherwise. sanitized_str = ''.join(char.lower() for char in s if char.isalnum()) return \\"YES\\" if sanitized_str == sanitized_str[::-1] else \\"NO\\""},{"question":"from typing import List, Tuple def partition_graph(n: int, m: int, edges: List[Tuple[int, int, int]]) -> Tuple[int, List[int]]: Partition the graph into two non-empty subgraphs A and B such that there is at least one vertex in subgraph A that has a direct edge to a vertex in subgraph B, and this edge has the smallest weight among all edges in the graph. Args: n (int): The number of nodes. m (int): The number of edges. edges (List[Tuple[int, int, int]]): List of edges represented as tuples (u, v, w) where u is the source node, v is the target node, and w is the weight of the edge. Returns: Tuple[int, List[int]]: A tuple containing the number of nodes in subgraph A and a list of the node indexes in subgraph A. Examples: >>> partition_graph(4, 5, [(1, 2, 10), (1, 3, 5), (2, 4, 1), (3, 2, 2), (3, 4, 3)]) (3, [1, 2, 3]) >>> partition_graph(3, 3, [(1, 2, 4), (2, 3, 1), (1, 3, 3)]) (2, [1, 2]) pass # Unit tests def test_partition_graph(): n, m = 4, 5 edges = [(1, 2, 10), (1, 3, 5), (2, 4, 1), (3, 2, 2), (3, 4, 3)] k, nodes_in_A = partition_graph(n, m, edges) assert k == 3 assert set(nodes_in_A) == {1, 2, 3} n, m = 3, 3 edges = [(1, 2, 4), (2, 3, 1), (1, 3, 3)] k, nodes_in_A = partition_graph(n, m, edges) assert k == 2 assert set(nodes_in_A) == {1, 2} n, m = 2, 1 edges = [(1, 2, 0)] k, nodes_in_A = partition_graph(n, m, edges) assert k == 1 assert set(nodes_in_A) == {1} n, m = 4, 5 edges = [(1, 2, 3), (1, 3, 2), (2, 3, 2), (3, 4, 1), (2, 4, 1)] k, nodes_in_A = partition_graph(n, m, edges) assert k == 3 assert set(nodes_in_A) in [{1, 2, 3}, {1, 3, 4}, {2, 3, 4}] n, m = 3, 2 edges = [(1, 2, 5), (2, 3, 2)] k, nodes_in_A = partition_graph(n, m, edges) assert k == 2 assert set(nodes_in_A) == {1, 2} n, m = 3, 6 edges = [(1, 2, 5), (1, 3, 2), (2, 1, 6), (2, 3, 1), (3, 1, 4), (3, 2, 3)] k, nodes_in_A = partition_graph(n, m, edges) assert k == 2 assert set(nodes_in_A) == {1, 2}","solution":"def partition_graph(n, m, edges): Returns the partition of the graph so that the edge with the minimum weight leads from subgraph A to subgraph B. Arguments: n -- number of nodes m -- number of edges edges -- list of edges, where each edge is represented by a tuple (u, v, w) Returns: tuple -- a tuple (k, nodes_in_A) where k is the number of nodes in subgraph A nodes_in_A is the list of nodes in subgraph A # Find the edge with the minimum weight edges.sort(key=lambda x: x[2]) u, v, w = edges[0] # Subgraph A contains all nodes except the target node of the smallest edge subgraph_A = [node for node in range(1, n+1) if node != v] return len(subgraph_A), subgraph_A"},{"question":"def detect_communication_loop(n, connections): Determines if there is a communication loop within the company. :param n: Number of employees :param connections: List of tuples where each tuple (u, v) means u can send message to v. :return: \\"YES\\" if there is a loop, otherwise \\"NO\\". Examples: >>> detect_communication_loop(3, [(1, 2), (2, 3), (3, 1)]) \\"YES\\" >>> detect_communication_loop(4, [(1, 2), (2, 3), (3, 4)]) \\"NO\\"","solution":"def detect_communication_loop(n, connections): Determines if there is a communication loop within the company. :param n: Number of employees :param connections: List of tuples where each tuple (u, v) means u can send message to v. :return: \\"YES\\" if there is a loop, otherwise \\"NO\\". from collections import defaultdict, deque # Create adjacency list adj_list = defaultdict(list) for u, v in connections: adj_list[u].append(v) # Helper function to perform DFS and detect cycles def has_cycle(v, visited, stack): visited[v] = True stack[v] = True for neighbour in adj_list[v]: if not visited[neighbour]: if has_cycle(neighbour, visited, stack): return True elif stack[neighbour]: return True stack[v] = False return False visited = [False] * (n + 1) stack = [False] * (n + 1) for employee in range(1, n+1): if not visited[employee]: if has_cycle(employee, visited, stack): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Union class ThemeParkQueue: def __init__(self): self.queue = deque() def enqueue(self, name): self.queue.append(name) def dequeue(self): if self.queue: return self.queue.popleft() return None def move_to_front(self, name): if name in self.queue: self.queue.remove(name) self.queue.appendleft(name) def queue_size(self): return len(self.queue) def queue_list(self): return list(self.queue) def process_operations(operations: List[str]) -> List[Union[int, str]]: Process a list of queue operations and return results for DEQUEUE, QUEUE_SIZE, and QUEUE_LIST operations. >>> process_operations([\\"ENQUEUE Alice\\", \\"ENQUEUE Bob\\", \\"QUEUE_SIZE\\", \\"MOVE_TO_FRONT Alice\\", \\"QUEUE_LIST\\", \\"DEQUEUE\\", \\"QUEUE_SIZE\\", \\"QUEUE_LIST\\"]) [2, 'Alice Bob', 'Alice', 1, 'Bob'] >>> process_operations([\\"ENQUEUE Alice\\", \\"DEQUEUE\\", \\"QUEUE_SIZE\\", \\"QUEUE_LIST\\"]) ['Alice', 0, '']","solution":"from collections import deque class ThemeParkQueue: def __init__(self): self.queue = deque() def enqueue(self, name): self.queue.append(name) def dequeue(self): if self.queue: return self.queue.popleft() return None def move_to_front(self, name): if name in self.queue: self.queue.remove(name) self.queue.appendleft(name) def queue_size(self): return len(self.queue) def queue_list(self): return list(self.queue) def process_operations(operations): tpq = ThemeParkQueue() result = [] for operation in operations: op = operation.split() command = op[0] if command == \\"ENQUEUE\\": tpq.enqueue(op[1]) elif command == \\"DEQUEUE\\": dequeued = tpq.dequeue() if dequeued is not None: result.append(dequeued) elif command == \\"MOVE_TO_FRONT\\": tpq.move_to_front(op[1]) elif command == \\"QUEUE_SIZE\\": result.append(tpq.queue_size()) elif command == \\"QUEUE_LIST\\": result.append(\\" \\".join(tpq.queue_list())) return result"},{"question":"from typing import List def findPairWithGivenDifference(arr: List[int], K: int) -> bool: Returns True if there exists a pair of elements in the list such that their difference is exactly K. >>> findPairWithGivenDifference([1, 7, 5, 9, 2, 12, 3], 2) True >>> findPairWithGivenDifference([1, 3, 5, 8, 12], 4) True >>> findPairWithGivenDifference([1, 3, 5, 9], 7) False pass Unit Test: from solution import findPairWithGivenDifference def test_given_example_1(): arr = [1, 7, 5, 9, 2, 12, 3] K = 2 assert findPairWithGivenDifference(arr, K) == True def test_given_example_2(): arr = [1, 3, 5, 8, 12] K = 4 assert findPairWithGivenDifference(arr, K) == True def test_given_example_3(): arr = [1, 3, 5, 9] K = 7 assert findPairWithGivenDifference(arr, K) == False def test_no_pairs(): arr = [10, 20, 30, 40] K = 25 assert findPairWithGivenDifference(arr, K) == False def test_multiple_pairs(): arr = [10, 20, 30, 40, 50] K = 10 assert findPairWithGivenDifference(arr, K) == True def test_all_elements_same(): arr = [5, 5, 5, 5] K = 0 assert findPairWithGivenDifference(arr, K) == True def test_large_value_difference(): arr = [1, 2, 3, 1_000_000_000] K = 999_999_997 assert findPairWithGivenDifference(arr, K) == True","solution":"def findPairWithGivenDifference(arr, K): Returns True if there exists a pair of elements in the list such that their difference is exactly K. num_set = set(arr) for num in arr: if (num + K) in num_set or (num - K) in num_set: return True return False"},{"question":"def longest_arith_seq_length(nums: List[int]) -> int: Given a list of unique integers, find and return the longest subsequence such that the difference between consecutive elements is the same throughout the subsequence. >>> longest_arith_seq_length([10, 5, 3, 1, 7, 2]) 3 >>> longest_arith_seq_length([1, 7, 8, 5, 2, 3, 10]) 3","solution":"def longest_arith_seq_length(nums): Returns the length of the longest arithmetic subsequence in nums. if not nums: return 0 n = len(nums) if n <= 2: return n dp = [{} for _ in range(n)] max_len = 2 for i in range(1, n): for j in range(i): diff = nums[i] - nums[j] if diff in dp[j]: dp[i][diff] = dp[j][diff] + 1 else: dp[i][diff] = 2 max_len = max(max_len, dp[i][diff]) return max_len"},{"question":"import math from typing import List def calculate_area(shapes: List[str]) -> List[float]: Given a list of shape definitions, calculate and return their area. Args: shapes (list of str): List of strings where each string is a shape definition. Returns: list of float: List of areas of the shapes rounded to two decimal places. >>> calculate_area([\\"circle 3\\"]) [28.27] >>> calculate_area([\\"circle 2\\"]) [12.57] >>> calculate_area([\\"circle 1\\"]) [3.14] >>> calculate_area([\\"circle 10\\"]) [314.16] >>> calculate_area([\\"rectangle 4 5\\"]) [20.00] >>> calculate_area([\\"rectangle 7 3\\"]) [21.00] >>> calculate_area([\\"rectangle 100 100\\"]) [10000.00] >>> calculate_area([\\"circle 3\\", \\"rectangle 4 5\\", \\"circle 2\\"]) [28.27, 20.00, 12.57] >>> calculate_area([\\"circle 10\\", \\"rectangle 3 4\\", \\"circle 5\\", \\"rectangle 2 7\\", \\"rectangle 6 9\\"]) [314.16, 12.00, 78.54, 14.00, 54.00]","solution":"import math def calculate_area(shapes): Given a list of shape definitions, calculate and return their area. Args: shapes (list of str): List of strings where each string is a shape definition. Returns: list of float: List of areas of the shapes rounded to two decimal places. areas = [] for shape in shapes: parts = shape.split() shape_type = parts[0] if shape_type == \\"circle\\": radius = int(parts[1]) area = math.pi * (radius ** 2) elif shape_type == \\"rectangle\\": length = int(parts[1]) width = int(parts[2]) area = length * width areas.append(round(area, 2)) return areas"},{"question":"def maxDifference(nums: List[int]) -> int: Given an integer array nums, returns the maximum possible difference between the largest and smallest values of any non-empty subarray of nums. >>> maxDifference([2, 1, 5, 3, 6]) 5 >>> maxDifference([3, 1, 4, 1, 5]) 4 >>> maxDifference([7, 2, 6, 4, 3]) 4 >>> maxDifference([100]) 0 >>> maxDifference([4, 4, 4, 4, 4]) 0 >>> maxDifference([1, 2, 3, 4, 5]) 4 >>> maxDifference([5, 4, 3, 2, 1]) 0 >>> maxDifference([4, 2, 8, 6, 1, 5]) 6 >>> maxDifference([-3, -1, -4, -2, -5]) 2","solution":"def maxDifference(nums): Returns the maximum possible difference between the largest and smallest values of any non-empty subarray of nums. n = len(nums) min_elem = nums[0] max_diff = 0 for i in range(1, n): max_diff = max(max_diff, nums[i] - min_elem) min_elem = min(min_elem, nums[i]) return max_diff"},{"question":"def is_subsequence(s: str, word: str) -> bool: Check if word is a subsequence of the string s. >>> is_subsequence(\\"abcde\\", \\"a\\") True >>> is_subsequence(\\"abcde\\", \\"bb\\") False >>> is_subsequence(\\"abcde\\", \\"acd\\") True def count_subsequences(s: str, words: List[str]) -> int: Count how many words in the list are subsequences of the string s. >>> count_subsequences(\\"abcde\\", [\\"a\\", \\"bb\\", \\"acd\\"]) 2 >>> count_subsequences(\\"xyz\\", [\\"x\\", \\"xyz\\"]) 2 >>> count_subsequences(\\"abcdef\\", [\\"abc\\", \\"defg\\", \\"bde\\", \\"fgh\\"]) 2 >>> count_subsequences(\\"hello\\", [\\"hlo\\", \\"hello\\", \\"oell\\"]) 2 >>> count_subsequences(\\"abcdefghijkl\\", [\\"abc\\", \\"ijk\\", \\"adl\\", \\"bdeh\\", \\"xy\\"]) 4","solution":"def is_subsequence(s, word): Check if word is a subsequence of the string s. :param s: The main string :param word: The word to check if it's a subsequence :return: True if word is a subsequence of s, False otherwise it = iter(s) return all(char in it for char in word) def count_subsequences(s, words): Count how many words in the list are subsequences of the string s. :param s: The main string :param words: List of words to check :return: The count of words that are subsequences of s return sum(is_subsequence(s, word) for word in words)"},{"question":"class Node: def __init__(self, val = 0, next = None, child = None): self.val = val self.next = next self.child = child def flatten(head: Node) -> Node: Flatten a multi-level linked list to form a single-level linked list. >>> head = Node(1) >>> node2 = Node(2) >>> node3 = Node(3) >>> head.next = node2 >>> node2.next = node3 >>> node3.child = Node(4, Node(5), None) >>> flattened = flatten(head) >>> list_to_array(flattened) [1, 2, 3, 4, 5] >>> head = Node(1) >>> node2 = Node(2) >>> node3 = Node(3) >>> node7 = Node(7) >>> node8 = Node(8) >>> node9 = Node(9) >>> head.next = node2 >>> node2.next = node3 >>> head.child = node7 >>> node7.next = node8 >>> node8.child = Node(10) >>> node3.child = node9 >>> flattened = flatten(head) >>> list_to_array(flattened) [1, 7, 8, 10, 2, 3, 9] # Implementation here def list_to_array(head: Node) -> list: result = [] curr = head while curr: result.append(curr.val) curr = curr.next return result","solution":"class Node: def __init__(self, val = 0, next = None, child = None): self.val = val self.next = next self.child = child def flatten(head: Node) -> Node: if not head: return head dummy = Node(0) stack = [head] prev = dummy while stack: curr = stack.pop() prev.next = curr prev = prev.next if curr.next: stack.append(curr.next) if curr.child: stack.append(curr.child) curr.child = None return dummy.next"},{"question":"def musicalChairsWinner(strengths): Determines the strength of the last remaining player in a game of musical chairs. :param strengths: List of integers representing the strength of each player. :return: Integer representing the strength of the last remaining player. >>> musicalChairsWinner([3, 9, 2, 7, 6]) 9 >>> musicalChairsWinner([1, 2]) 2 >>> musicalChairsWinner([5, 5, 5, 5, 5]) 5","solution":"def musicalChairsWinner(strengths): Determines the strength of the last remaining player in a game of musical chairs. :param strengths: List of integers representing the strength of each player. :return: Integer representing the strength of the last remaining player. while len(strengths) > 1: n = len(strengths) new_strengths = [] i = 0 while i < n: if i == n - 1: # handle the last element to wrap around if strengths[i] > strengths[0]: new_strengths.append(strengths[i]) else: strengths[0] = strengths[i] else: if strengths[i] > strengths[i + 1]: new_strengths.append(strengths[i]) else: new_strengths.append(strengths[i + 1]) i += 2 # skip the next element since we already considered it strengths = new_strengths return strengths[0]"},{"question":"def calculate_averages(records): Calculate the average systolic, diastolic, and heart rate from a list of patient records. :param records: List of patient records in the format [date, systolic, diastolic, heart_rate]. :return: Dictionary with average systolic, diastolic and heart rate. Example: >>> calculate_averages([ [\\"2023-01-01\\", 120, 80, 70], [\\"2023-01-02\\", 130, 85, 75], [\\"2023-01-03\\", 125, 82, 73] ]) { \\"average_systolic\\": 125.0, \\"average_diastolic\\": 82.33, \\"average_heart_rate\\": 72.67 } >>> calculate_averages([[\\"2023-01-01\\", 115, 75, 65]]) { \\"average_systolic\\": 115.0, \\"average_diastolic\\": 75.0, \\"average_heart_rate\\": 65.0 } from solution import calculate_averages def test_average_multiple_records(): records = [ [\\"2023-01-01\\", 120, 80, 70], [\\"2023-01-02\\", 130, 85, 75], [\\"2023-01-03\\", 125, 82, 73] ] expected_output = { \\"average_systolic\\": 125.0, \\"average_diastolic\\": 82.33, \\"average_heart_rate\\": 72.67 } assert calculate_averages(records) == expected_output def test_average_single_record(): records = [ [\\"2023-01-01\\", 115, 75, 65] ] expected_output = { \\"average_systolic\\": 115.0, \\"average_diastolic\\": 75.0, \\"average_heart_rate\\": 65.0 } assert calculate_averages(records) == expected_output def test_average_identical_records(): records = [ [\\"2023-01-01\\", 120, 80, 70], [\\"2023-01-01\\", 120, 80, 70], [\\"2023-01-01\\", 120, 80, 70] ] expected_output = { \\"average_systolic\\": 120.0, \\"average_diastolic\\": 80.0, \\"average_heart_rate\\": 70.0 } assert calculate_averages(records) == expected_output def test_average_mixed_records(): records = [ [\\"2023-01-01\\", 110, 70, 60], [\\"2023-01-02\\", 130, 90, 80], [\\"2023-01-03\\", 120, 80, 70] ] expected_output = { \\"average_systolic\\": 120.0, \\"average_diastolic\\": 80.0, \\"average_heart_rate\\": 70.0 } assert calculate_averages(records) == expected_output","solution":"def calculate_averages(records): Calculate the average systolic, diastolic, and heart rate from a list of patient records. :param records: List of patient records in the format [date, systolic, diastolic, heart_rate]. :return: Dictionary with average systolic, diastolic and heart rate. total_systolic = 0 total_diastolic = 0 total_heart_rate = 0 num_records = len(records) for record in records: total_systolic += record[1] total_diastolic += record[2] total_heart_rate += record[3] average_systolic = total_systolic / num_records average_diastolic = total_diastolic / num_records average_heart_rate = total_heart_rate / num_records return { \\"average_systolic\\": round(average_systolic, 2), \\"average_diastolic\\": round(average_diastolic, 2), \\"average_heart_rate\\": round(average_heart_rate, 2) }"},{"question":"def max_sum_submatrix(matrix): Returns the maximum sum of any submatrix within the given matrix. The input is a matrix of integers, and the function should return the maximum sum of any contiguous submatrix within the given matrix. Example: >>> matrix = [ ... [1, 2, -1, -4, -20], ... [-8, -3, 4, 2, 1], ... [3, 8, 10, 1, 3], ... [-4, -1, 1, 7, -6] ... ] >>> max_sum_submatrix(matrix) 29 >>> matrix = [[5]] >>> max_sum_submatrix(matrix) 5 >>> matrix = [[-5]] >>> max_sum_submatrix(matrix) -5 >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> max_sum_submatrix(matrix) 10 >>> matrix = [ ... [-1, -2], ... [-3, -4] ... ] >>> max_sum_submatrix(matrix) -1 >>> matrix = [ ... [6, -5, -7, 4, -4], ... [-9, 3, -6, 5, 2], ... [-10, 4, 7, -6, 3], ... [-8, 9, -3, 3, -7] ... ] >>> max_sum_submatrix(matrix) 17","solution":"def max_sum_submatrix(matrix): Returns the maximum sum of any submatrix within the given matrix. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) max_sum = float('-inf') # Iterate through each row as the top row of the submatrix for top in range(n): row_sum = [0] * m # Iterate through each row as the bottom row of the submatrix for bottom in range(top, n): for i in range(m): row_sum[i] += matrix[bottom][i] # Find the maximum sum subarray in \`row_sum\` max_ending_here = max_so_far = row_sum[0] for x in row_sum[1:]: max_ending_here = max(x, max_ending_here + x) max_so_far = max(max_so_far, max_ending_here) max_sum = max(max_sum, max_so_far) return max_sum"},{"question":"def is_palindrome(item_name: str) -> str: Determine if the given item name is a palindrome and qualifies for a discount. >>> is_palindrome(\\"radar\\") == \\"yes\\" >>> is_palindrome(\\"toys\\") == \\"no\\"","solution":"def is_palindrome(item_name): Returns 'yes' if the item_name is palindrome, otherwise 'no'. if item_name == item_name[::-1]: return 'yes' else: return 'no'"},{"question":"def generatePattern(n: int) -> None: Prints a pattern of increasing integers from 1 to n, where each line contains integers starting from the line number up to the line number plus the line index. >>> generatePattern(1) 1 >>> generatePattern(2) 1 2 3 >>> generatePattern(3) 1 2 3 3 4 5 >>> generatePattern(4) 1 2 3 3 4 5 4 5 6 7 >>> generatePattern(5) 1 2 3 3 4 5 4 5 6 7 5 6 7 8 9","solution":"def generatePattern(n: int) -> None: Prints a pattern of increasing integers from 1 to n, where each line contains integers starting from the line number up to the line number plus the line index. for i in range(1, n + 1): line = \\" \\".join(str(i + j) for j in range(i)) print(line)"},{"question":"def minimum_knight_moves(n, sx, sy, tx, ty): Returns the minimum number of moves required for the knight to reach the target position or -1 if it is not possible. Parameters: - n: int, size of the chessboard (n x n) - sx: int, starting position x-coordinate - sy: int, starting position y-coordinate - tx: int, target position x-coordinate - ty: int, target position y-coordinate Returns: - int, minimum number of moves required for the knight to reach the target position, or -1 if not possible Example: >>> minimum_knight_moves(8, 0, 0, 7, 7) 6 >>> minimum_knight_moves(8, 0, 0, 8, 0) -1 >>> minimum_knight_moves(8, 4, 4, 4, 4) 0","solution":"from collections import deque def minimum_knight_moves(n, sx, sy, tx, ty): Returns the minimum number of moves required for the knight to reach the target position or -1 if it is not possible. if sx < 0 or sy < 0 or tx < 0 or ty < 0 or sx >= n or sy >= n or tx >= n or ty >= n: return -1 moves = [(2, 1), (1, 2), (-1, 2), (-2, 1), (-2, -1), (-1, -2), (1, -2), (2, -1)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, d = queue.popleft() if (x, y) == (tx, ty): return d for dx, dy in moves: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < n and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, d + 1)) return -1"},{"question":"def are_permutations(s1: str, s2: str) -> bool: Determine if one string is a permutation of the other. >>> are_permutations(\\"abc\\", \\"cab\\") True >>> are_permutations(\\"hello\\", \\"world\\") False >>> are_permutations(\\"\\", \\"\\") True >>> are_permutations(\\"a\\", \\"\\") False >>> are_permutations(\\"abc\\", \\"ab\\") False","solution":"def are_permutations(s1, s2): Returns True if s1 is a permutation of s2, otherwise False. return sorted(s1) == sorted(s2)"},{"question":"def repeat_digits(s: str, k: int) -> str: Given a string containing digits and a positive integer k, repeat the digits k times in a grouped manner and return it in string format. Each group should be separated by a hyphen (\\"-\\"). Args: s (str): A string containing digits '0'-'9'. k (int): A positive integer. Returns: str: The repeated digits in a grouped manner separated by hyphens. Examples: >>> repeat_digits(\\"123\\", 3) '123-123-123' >>> repeat_digits(\\"56\\", 2) '56-56' >>> repeat_digits(\\"7\\", 1) '7' >>> repeat_digits(\\"89\\", 0) ''","solution":"def repeat_digits(s, k): Repeats the string s k times in a grouped manner separated by hyphens. if k == 0: return \\"\\" return '-'.join([s] * k)"},{"question":"import heapq from typing import Dict, List, Tuple def prim_mst(n: int, edges: Dict[int, List[Tuple[int, int]]]) -> int: Returns the total weight of the MST using Prim's algorithm. :param n: Number of nodes in the graph. :param edges: Adjacency list representing the graph. :return: Total weight of the MST. >>> prim_mst(5, {0: [(1, 2), (3, 6)], 1: [(0, 2), (2, 3), (3, 8), (4, 5)], 2: [(1, 3), (4, 7)], 3: [(0, 6), (1, 8)], 4: [(1, 5), (2, 7)]}) == 16 >>> prim_mst(1, {0: []}) == 0 >>> prim_mst(2, {0: [(1, 1)], 1: [(0, 1)]}) == 1 >>> prim_mst(4, {0: [(1, 1)], 1: [(0, 1), (2, 1)], 2: [(1, 1), (3, 1)], 3: [(2, 1)]}) == 3 >>> prim_mst(4, {0: [(1, 1), (2, 4)], 1: [(0, 1), (2, 2), (3, 5)], 2: [(0, 4), (1, 2), (3, 1)], 3: [(1, 5), (2, 1)]}) == 4","solution":"import heapq def prim_mst(n, edges): Returns the total weight of the MST using Prim's algorithm. :param n: Number of nodes in the graph. :param edges: Adjacency list representing the graph. :return: Total weight of the MST. total_weight = 0 visited = [False] * n min_heap = [(0, 0)] # (weight, start_node) while min_heap: weight, current_node = heapq.heappop(min_heap) if visited[current_node]: continue total_weight += weight visited[current_node] = True for neighbor, edge_weight in edges[current_node]: if not visited[neighbor]: heapq.heappush(min_heap, (edge_weight, neighbor)) return total_weight"},{"question":"from typing import List def sumOfSubarrayMinimums(arr: List[int]) -> int: Given an array of integers arr, find the sum of all possible subarrays' minimum values. Return that sum modulo 10^9 + 7. >>> sumOfSubarrayMinimums([3, 1, 2, 4]) 17 >>> sumOfSubarrayMinimums([11, 81, 94, 43, 3]) 444 from solution import sumOfSubarrayMinimums def test_example_1(): assert sumOfSubarrayMinimums([3, 1, 2, 4]) == 17 def test_example_2(): assert sumOfSubarrayMinimums([11, 81, 94, 43, 3]) == 444 def test_single_element(): assert sumOfSubarrayMinimums([1]) == 1 assert sumOfSubarrayMinimums([100]) == 100 def test_all_elements_equal(): assert sumOfSubarrayMinimums([2, 2, 2, 2]) == 20 def test_minimum_at_start(): assert sumOfSubarrayMinimums([1, 2, 3, 4]) == 20 def test_minimum_at_end(): assert sumOfSubarrayMinimums([4, 3, 2, 1]) == 20","solution":"from typing import List MOD = 10**9 + 7 def sumOfSubarrayMinimums(arr: List[int]) -> int: n = len(arr) stack = [] left = [0] * n right = [0] * n for i in range(n): count = 1 while stack and stack[-1][0] > arr[i]: count += stack.pop()[1] left[i] = count stack.append((arr[i], count)) stack.clear() for i in range(n - 1, -1, -1): count = 1 while stack and stack[-1][0] >= arr[i]: count += stack.pop()[1] right[i] = count stack.append((arr[i], count)) result = 0 for i in range(n): result = (result + arr[i] * left[i] * right[i]) % MOD return result"},{"question":"class Inventory: Class to manage the inventory for a store, with operations to add, update, sell, and query items. Methods: - add_item(id: int, price: int, quantity: int) -> None: Adds a new item or updates the quantity if the item already exists. - update_item(id: int, price: int, quantity: int) -> None: Updates the price and quantity of an existing item. - sell_item(id: int, quantity: int) -> None: Sells a specified quantity of an item and updates the inventory. - query_item(id: int) -> str: Retrieves the price and quantity of an item, or returns \\"Item not found\\". >>> inv = Inventory() >>> inv.add_item(1001, 50, 20) >>> inv.query_item(1001) \\"50 20\\" >>> inv.add_item(1001, 50, 10) >>> inv.query_item(1001) \\"50 30\\" >>> inv.update_item(1001, 60, 30) >>> inv.query_item(1001) \\"60 30\\" >>> inv.sell_item(1001, 10) >>> inv.query_item(1001) \\"50 20\\" >>> inv.sell_item(1001, 20) >>> inv.query_item(1001) \\"Item not found\\" >>> inv.query_item(1002) \\"Item not found\\" def __init__(self): pass def add_item(self, id: int, price: int, quantity: int) -> None: pass def update_item(self, id: int, price: int, quantity: int) -> None: pass def sell_item(self, id: int, quantity: int) -> None: pass def query_item(self, id: int) -> str: pass","solution":"class Inventory: def __init__(self): self.items = {} def add_item(self, id, price, quantity): if id in self.items: self.items[id]['quantity'] += quantity else: self.items[id] = {'price': price, 'quantity': quantity} def update_item(self, id, price, quantity): if id in self.items: self.items[id]['price'] = price self.items[id]['quantity'] = quantity def sell_item(self, id, quantity): if id in self.items: self.items[id]['quantity'] -= quantity if self.items[id]['quantity'] <= 0: del self.items[id] def query_item(self, id): if id in self.items: return f\\"{self.items[id]['price']} {self.items[id]['quantity']}\\" else: return \\"Item not found\\""},{"question":"def morse_converter(text: str) -> str: Converts text to Morse code and vice versa. Args: text (str): The text to be converted, either in plain text or Morse code. Returns: str: The converted text, either in Morse code or plain text. >>> morse_converter(\\"HELLO WORLD\\") == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> morse_converter(\\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\") == \\"HELLO WORLD\\" >>> morse_converter(\\"\\") == \\"\\" >>> morse_converter(\\"hello world\\") == \\".... . .-.. .-.. --- / .-- --- .-. .-.. -..\\" >>> morse_converter(\\"HELLO123\\") == \\"Invalid input\\" >>> morse_converter(\\".... . .-.. .-.. --- / 123 .-- --- .-. .-.. -..\\") == \\"Invalid input\\" >>> morse_converter(\\" \\") == \\"\\" >>> morse_converter(\\".... . .-.. .-.. --- * / .-- --- .-. .-.. -..\\") == \\"Invalid input\\" >>> morse_converter(\\"E\\") == \\".\\" >>> morse_converter(\\".\\") == \\"E\\"","solution":"def morse_converter(text): morse_to_text = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E', '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J', '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O', '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T', '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y', '--..': 'Z', '-----': '0', '.----': '1', '..---': '2', '...--': '3', '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8', '----.': '9' } text_to_morse = {v: k for k, v in morse_to_text.items()} if all(c in '.- /' for c in text.strip()): # Morse code to plain text decoded_message = [] words = text.split(' / ') for word in words: decoded_word = ''.join(morse_to_text.get(symbol, '') for symbol in word.split()) decoded_message.append(decoded_word) return ' '.join(decoded_message) elif all(c.isalpha() or c.isspace() for c in text): # Plain text to Morse code text = text.upper() encoded_message = [] words = text.split() for word in words: encoded_word = ' '.join(text_to_morse.get(letter, '') for letter in word) encoded_message.append(encoded_word) return ' / '.join(encoded_message) else: return \\"Invalid input\\""},{"question":"def longest_consecutive_subsequence(nums): Function to find the length of the longest subsequence of consecutive elements in the sequence. >>> longest_consecutive_subsequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_subsequence([10, 11, 12, 14]) 3 >>> longest_consecutive_subsequence([1, 9, 3, 10, 4]) 2 def find_longest_subsequences(test_cases): Function to find the length of the longest subsequence of consecutive elements for each test case in the sequence. >>> find_longest_subsequences([[100, 4, 200, 1, 3, 2], [10, 11, 12, 14], [1, 9, 3, 10, 4]]) [4, 3, 2] >>> find_longest_subsequences([[1, 2, 2, 2, 3], [], [5, 6, 7]]) [3, 0, 3]","solution":"def longest_consecutive_subsequence(nums): Function to find the length of the longest subsequence of consecutive elements in the sequence. if not nums: return 0 num_set = set(nums) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak def find_longest_subsequences(test_cases): results = [] for nums in test_cases: result = longest_consecutive_subsequence(nums) results.append(result) return results"},{"question":"from typing import List, Dict def categorize_dates_by_day_of_week(dates: List[str]) -> Dict[str, List[str]]: Takes a list of dates in 'YYYY-MM-DD' format and returns a dictionary categorizing each date by the day of the week. >>> categorize_dates_by_day_of_week([\\"2023-04-01\\", \\"2023-04-02\\", \\"2023-04-03\\", \\"2023-04-04\\", \\"2023-04-05\\", \\"2023-04-06\\", \\"2023-04-07\\"]) {'Saturday': ['2023-04-01'], 'Sunday': ['2023-04-02'], 'Monday': ['2023-04-03'], 'Tuesday': ['2023-04-04'], 'Wednesday': ['2023-04-05'], 'Thursday': ['2023-04-06'], 'Friday': ['2023-04-07']} >>> categorize_dates_by_day_of_week([]) {'Monday': [], 'Tuesday': [], 'Wednesday': [], 'Thursday': [], 'Friday': [], 'Saturday': [], 'Sunday': []} >>> categorize_dates_by_day_of_week([\\"2023-04-03\\"]) {'Monday': ['2023-04-03'], 'Tuesday': [], 'Wednesday': [], 'Thursday': [], 'Friday': [], 'Saturday': [], 'Sunday': []} >>> categorize_dates_by_day_of_week([\\"2023-04-03\\", \\"2023-04-10\\", \\"2023-04-17\\"]) {'Monday': ['2023-04-03', '2023-04-10', '2023-04-17'], 'Tuesday': [], 'Wednesday': [], 'Thursday': [], 'Friday': [], 'Saturday': [], 'Sunday': []}","solution":"from datetime import datetime def categorize_dates_by_day_of_week(dates): Takes a list of dates in 'YYYY-MM-DD' format and returns a dictionary categorizing each date by the day of the week. days_of_week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'] result = {day: [] for day in days_of_week} for date_str in dates: date_obj = datetime.strptime(date_str, '%Y-%m-%d') day_name = date_obj.strftime('%A') result[day_name].append(date_str) return result"},{"question":"from typing import List, Tuple def are_boxes_similar(n: int, m: int, boxes: List[List[int]], queries: List[Tuple[int, int]]) -> List[str]: Determine if two boxes are similar based on containing at least one common item. Parameters: - n: int - The number of boxes. - m: int - The number of queries. - boxes: List[List[int]] - A list of lists, where each sub-list contains item IDs for a box. - queries: List[Tuple[int, int]] - A list of tuples, where each tuple contains two box IDs to check for similarity. Returns: - List[str] - A list of \\"YES\\" or \\"NO\\" strings indicating if corresponding boxes are similar for each query. >>> are_boxes_similar(5, 3, [[1, 2, 3], [4, 5], [6, 7, 8, 9], [10], [5, 6]], [(1, 3), (2, 4), (2, 5)]) [\\"NO\\", \\"NO\\", \\"YES\\"] >>> are_boxes_similar(1, 1, [[1, 2, 3]], [(1, 1)]) [\\"YES\\"] >>> are_boxes_similar(3, 2, [[1], [2], [3]], [(1, 2), (2, 3)]) [\\"NO\\", \\"NO\\"] >>> are_boxes_similar(3, 2, [[1, 2], [2, 3], [3, 1]], [(1, 2), (2, 3)]) [\\"YES\\", \\"YES\\"] >>> are_boxes_similar(100000, 1, [[i] for i in range(1, 100001)], [(1, 100000)]) [\\"NO\\"] >>> are_boxes_similar(2, 1, [list(range(1, 100001)), list(range(100000, 200001))], [(1, 2)]) [\\"YES\\"] >>> are_boxes_similar(1, 1, [[1]], [(1, 1)]) [\\"YES\\"] pass # Implement the function here","solution":"def are_boxes_similar(n, m, boxes, queries): from collections import defaultdict item_to_boxes = defaultdict(set) for idx, box in enumerate(boxes): for item in box: item_to_boxes[item].add(idx) results = [] for a, b in queries: a -= 1 # Convert to 0-based index b -= 1 # Convert to 0-based index similar = False if a == b: similar = True else: for item in boxes[a]: if item in item_to_boxes and b in item_to_boxes[item]: similar = True break if similar: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def min_operations_to_uniform(s: str) -> int: Returns the minimum number of operations required to make the string \`s\` consist of identical characters. pass def solve(t: int, strings: List[str]) -> List[int]: Solves t test cases for the minimum number of operations required to make each string consist of identical characters. pass # Example usage: if __name__ == \\"__main__\\": test_cases = [ \\"aabaaa\\", \\"bbabbaabb\\", \\"ab\\" ] print(solve(3, test_cases)) # Unit Tests def test_min_operations_to_uniform(): assert min_operations_to_uniform(\\"aabaaa\\") == 1 assert min_operations_to_uniform(\\"bbabbaabb\\") == 3 assert min_operations_to_uniform(\\"ab\\") == 1 assert min_operations_to_uniform(\\"aaaaa\\") == 0 assert min_operations_to_uniform(\\"bbbbb\\") == 0 assert min_operations_to_uniform(\\"abba\\") == 2 assert min_operations_to_uniform(\\"ababab\\") == 3 def test_solve(): assert solve(3, [\\"aabaaa\\", \\"bbabbaabb\\", \\"ab\\"]) == [1, 3, 1] assert solve(2, [\\"aaaaa\\", \\"bbbbb\\"]) == [0, 0] assert solve(2, [\\"abba\\", \\"ababab\\"]) == [2, 3]","solution":"def min_operations_to_uniform(s): Returns the minimum number of operations required to make the string \`s\` consist of identical characters. count_a = s.count('a') count_b = s.count('b') # The cost to convert all to 'a's or all to 'b's is effectively the number of 'b's or 'a's respectively. return min(count_a, count_b) def solve(t, strings): Solves t test cases for the minimum number of operations required to make each string consist of identical characters. results = [] for s in strings: results.append(min_operations_to_uniform(s)) return results # Reading input def main(): import sys input = sys.stdin.read data = input().split() t = int(data[0]) strings = data[1:t+1] results = solve(t, strings) for result in results: print(result)"},{"question":"def longest_unique_subarray_length(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the length of the longest contiguous subarray with all unique elements for each test case. >>> longest_unique_subarray_length(2, [(7, [2, 3, 4, 5, 5, 6, 7]), (5, [1, 2, 3, 4, 5])]) [4, 5] >>> longest_unique_subarray_length(1, [(1, [1])]) [1] >>> longest_unique_subarray_length(1, [(5, [5, 10, 15, 20, 25])]) [5] >>> longest_unique_subarray_length(1, [(4, [7, 7, 7, 7])]) [1] >>> longest_unique_subarray_length(1, [(6, [2, 2, 3, 4, 4, 5])]) [3] # [2, 3, 4] >>> N = 10**5 >>> array = list(range(10**5)) >>> longest_unique_subarray_length(1, [(N, array)]) [N] >>> longest_unique_subarray_length(1, [(12, [1, 2, 3, 1, 2, 1, 4, 5, 6, 1, 2, 3])]) [6] # [1, 4, 5, 6, 1, 2]","solution":"def longest_unique_subarray_length(T, test_cases): results = [] for test_case in test_cases: N, array = test_case last_index = {} max_length = 0 start = 0 for end in range(N): if array[end] in last_index: start = max(start, last_index[array[end]] + 1) last_index[array[end]] = end max_length = max(max_length, end - start + 1) results.append(max_length) return results # Example Usage: # T = 2 # test_cases = [(7, [2, 3, 4, 5, 5, 6, 7]), (5, [1, 2, 3, 4, 5])] # print(longest_unique_subarray_length(T, test_cases)) # Output should be [4, 5]"},{"question":"def extract_digit_followers(s: str) -> dict: Returns a dictionary where the keys are the digits in the string and the values are lists of letters that immediately follow each digit in the string. >>> extract_digit_followers(\\"a1b2c3d4e\\") {'1': ['b'], '2': ['c'], '3': ['d'], '4': ['e']} >>> extract_digit_followers(\\"1a2b3c4d5\\") {'1': ['a'], '2': ['b'], '3': ['c'], '4': ['d']} >>> extract_digit_followers(\\"abc1def2gh3j\\") {'1': ['d'], '2': ['g'], '3': ['j']}","solution":"def extract_digit_followers(s): Returns a dictionary where the keys are the digits in the string and the values are lists of letters that immediately follow each digit in the string. result = {} for i in range(len(s) - 1): if s[i].isdigit() and s[i + 1].isalpha(): if s[i] not in result: result[s[i]] = [] result[s[i]].append(s[i + 1]) return result"},{"question":"def remove_adjacent_pairs(s: str) -> str: Returns the final string after repeatedly removing adjacent pairs of the same characters. >>> remove_adjacent_pairs(\\"abbaca\\") \\"ca\\" >>> remove_adjacent_pairs(\\"azxxzy\\") \\"ay\\"","solution":"def remove_adjacent_pairs(s): Returns the final string after repeatedly removing adjacent pairs of the same characters. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return ''.join(stack)"},{"question":"def fibonacci_sequence(n): Accepts a non-negative integer n and returns a list containing the first n numbers of the Fibonacci sequence. If n is 0, returns an empty list. >>> fibonacci_sequence(0) == [] >>> fibonacci_sequence(1) == [0] >>> fibonacci_sequence(2) == [0, 1] >>> fibonacci_sequence(5) == [0, 1, 1, 2, 3] >>> fibonacci_sequence(10) == [0, 1, 1, 2, 3, 5, 8, 13, 21, 34] >>> fibonacci_sequence(3) == [0, 1, 1] >>> fibonacci_sequence(4) == [0, 1, 1, 2]","solution":"def fibonacci_sequence(n): Returns a list containing the first n numbers of the Fibonacci sequence. If n is 0, returns an empty list. if n == 0: return [] elif n == 1: return [0] elif n == 2: return [0, 1] fib_sequence = [0, 1] for i in range(2, n): fib_sequence.append(fib_sequence[-1] + fib_sequence[-2]) return fib_sequence"},{"question":"from typing import List def min_energy_cost(matrix: List[List[int]]) -> int: Returns the minimum total energy cost to travel from the top-left corner to the bottom-right corner of a given MxN matrix where you can only move down or right. >>> min_energy_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_energy_cost([[5]]) 5 >>> min_energy_cost([[1, 2, 3, 4, 5]]) 15 >>> min_energy_cost([[1], [2], [3], [4], [5]]) 15 >>> min_energy_cost([[1 for _ in range(100)] for _ in range(100)]) 199 >>> min_energy_cost([[1, 2, 3], [4, 8, 2], [1, 5, 3]]) 11","solution":"def min_energy_cost(matrix): Returns the minimum total energy cost to travel from the top-left corner to the bottom-right corner of a given MxN matrix where you can only move down or right. if not matrix or not matrix[0]: return 0 m, n = len(matrix), len(matrix[0]) dp = [[0 for _ in range(n)] for _ in range(m)] dp[0][0] = matrix[0][0] for i in range(1, m): dp[i][0] = dp[i-1][0] + matrix[i][0] for j in range(1, n): dp[0][j] = dp[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): dp[i][j] = matrix[i][j] + min(dp[i-1][j], dp[i][j-1]) return dp[m-1][n-1]"},{"question":"from typing import List def min_cost_path(n: int, m: int, grid: List[List[int]]) -> int: Function to find the minimum cost path in a grid from the top-left to bottom-right corner. Parameters: n (int): Number of rows. m (int): Number of columns. grid (list of list of int): The n x m grid where each cell contains the cost. Returns: int: Minimum cost to travel from the top-left to the bottom-right corner. >>> min_cost_path(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_cost_path(2, 2, [[1, 2], [3, 4]]) 7 >>> min_cost_path(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 21 >>> min_cost_path(1, 1, [[5]]) 5 >>> min_cost_path(4, 4, [[1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 4], [2, 1, 2, 1]]) 10","solution":"def min_cost_path(n, m, grid): Function to find the minimum cost path in a grid from the top-left to bottom-right corner. Parameters: n (int): Number of rows. m (int): Number of columns. grid (list of list of int): The n x m grid where each cell contains the cost. Returns: int: Minimum cost to travel from the top-left to the bottom-right corner. # Create a 2D list to store the minimum cost for each cell cost = [[0] * m for _ in range(n)] # Initialize the cost for the top-left cell cost[0][0] = grid[0][0] # Initialize the cost for the first row for j in range(1, m): cost[0][j] = cost[0][j-1] + grid[0][j] # Initialize the cost for the first column for i in range(1, n): cost[i][0] = cost[i-1][0] + grid[i][0] # Fill the remaining costs using the minimum of the adjacent cells (left and up) for i in range(1, n): for j in range(1, m): cost[i][j] = grid[i][j] + min(cost[i-1][j], cost[i][j-1]) return cost[n-1][m-1]"},{"question":"def minimal_total_skill_level(n, skill_levels): Returns the minimal possible total skill level of all teams combined. :param n: Number of participants :param skill_levels: List of integers representing skill levels of participants :return: Minimal possible total skill level of all the teams combined Examples: >>> minimal_total_skill_level(6, [1, 3, 5, 7, 9, 11]) 36 >>> minimal_total_skill_level(4, [1, 2, 1, 2]) 6 from solution import minimal_total_skill_level def test_minimal_total_skill_level_case1(): assert minimal_total_skill_level(6, [1, 3, 5, 7, 9, 11]) == 36 def test_minimal_total_skill_level_case2(): assert minimal_total_skill_level(4, [1, 2, 1, 2]) == 6 def test_minimal_total_skill_level_case3(): assert minimal_total_skill_level(2, [1, 100000]) == 100001 def test_minimal_total_skill_level_case4(): assert minimal_total_skill_level(6, [10, 20, 30, 40, 50, 60]) == 210 def test_minimal_total_skill_level_case5(): assert minimal_total_skill_level(8, [1, 2, 3, 4, 5, 6, 7, 8]) == 36","solution":"def minimal_total_skill_level(n, skill_levels): Returns the minimal possible total skill level of all teams combined. :param n: Number of participants :param skill_levels: List of integers representing skill levels of participants :return: Minimal possible total skill level of all the teams combined skill_levels.sort() total_skill = 0 for i in range(n // 2): total_skill += skill_levels[i] + skill_levels[n - 1 - i] return total_skill"},{"question":"from typing import List def count_distinct_palindromic_substrings(s: str) -> int: Returns the number of distinct palindromic substrings in the given string \`s\`. >>> count_distinct_palindromic_substrings(\\"abc\\") 3 >>> count_distinct_palindromic_substrings(\\"aaa\\") 3 >>> count_distinct_palindromic_substrings(\\"racecar\\") 7 pass def get_number_of_distinct_palindromic_substrings(test_cases: List[str]) -> List[int]: Returns a list of numbers representing the number of distinct palindromic substrings for each test case. >>> get_number_of_distinct_palindromic_substrings([\\"abc\\", \\"aaa\\", \\"racecar\\"]) [3, 3, 7] pass def test_single_char_strings(): assert count_distinct_palindromic_substrings(\\"a\\") == 1 assert count_distinct_palindromic_substrings(\\"b\\") == 1 def test_basic_examples(): assert count_distinct_palindromic_substrings(\\"abc\\") == 3 assert count_distinct_palindromic_substrings(\\"aaa\\") == 3 assert count_distinct_palindromic_substrings(\\"racecar\\") == 7 def test_mixed_examples(): assert count_distinct_palindromic_substrings(\\"abba\\") == 4 assert count_distinct_palindromic_substrings(\\"abcba\\") == 5 def test_multi_test_case(): test_cases = [\\"abc\\", \\"aaa\\", \\"racecar\\"] result = get_number_of_distinct_palindromic_substrings(test_cases) assert result == [3, 3, 7] def test_palindromic_substrings_with_repeat(): assert count_distinct_palindromic_substrings(\\"ababa\\") == 5","solution":"def count_distinct_palindromic_substrings(s): Returns the number of distinct palindromic substrings in the given string \`s\`. palindromes = set() def expand_around_center(left, right): while left >= 0 and right < len(s) and s[left] == s[right]: palindromes.add(s[left:right+1]) left -= 1 right += 1 for i in range(len(s)): # Odd length palindromes expand_around_center(i, i) # Even length palindromes expand_around_center(i, i + 1) return len(palindromes) def get_number_of_distinct_palindromic_substrings(test_cases): results = [] for s in test_cases: results.append(count_distinct_palindromic_substrings(s)) return results"},{"question":"def count_unique_subarrays_with_sum_k(arr, K): Counts the number of unique subarrays whose sum is exactly K. Parameters: arr (list of int): The input array. K (int): The target sum for subarrays. Returns: int: The number of unique subarrays with sum exactly K. Examples: >>> count_unique_subarrays_with_sum_k([1, 2, 3, -2, 1], 3) 3 >>> count_unique_subarrays_with_sum_k([1, 1, 1], 2) 2 >>> count_unique_subarrays_with_sum_k([-1, -1, -1], -2) 2 >>> count_unique_subarrays_with_sum_k([1, -1, 2, -1, 3], 3) 2 >>> count_unique_subarrays_with_sum_k([3], 3) 1 >>> count_unique_subarrays_with_sum_k([1, 2, 3], 7) 0","solution":"def count_unique_subarrays_with_sum_k(arr, K): Counts the number of unique subarrays whose sum is exactly K. Parameters: arr (list of int): The input array. K (int): The target sum for subarrays. Returns: int: The number of unique subarrays with sum exactly K. prefix_sum = 0 count = 0 prefix_sum_count_map = {0: 1} for num in arr: prefix_sum += num if (prefix_sum - K) in prefix_sum_count_map: count += prefix_sum_count_map[prefix_sum - K] if prefix_sum in prefix_sum_count_map: prefix_sum_count_map[prefix_sum] += 1 else: prefix_sum_count_map[prefix_sum] = 1 return count"},{"question":"def rearrange_plants(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Rearrange the heights of plants according to the given pattern. Args: T: int: Number of test cases. test_cases: List[Tuple[int, List[int]]]: A list of tuples, each containing the number of plants and their respective heights. Returns: List[List[int]]: The rearranged arrays for each test case. >>> rearrange_plants(2, [ ... (5, [4, 7, 2, 5, 8]), ... (6, [1, 3, 5, 7, 2, 4]) ... ]) [[2, 7, 4, 5, 8], [2, 7, 4, 5, 3, 1]] >>> rearrange_plants(1, [ ... (8, [2, 4, 6, 8, 1, 3, 5, 7]) ... ]) [[2, 7, 4, 5, 6, 3, 8, 1]]","solution":"def rearrange_plants(T, test_cases): results = [] for n, heights in test_cases: even_heights = sorted(h for h in heights if h % 2 == 0) odd_heights = sorted((h for h in heights if h % 2 != 0), reverse=True) result = [0] * n even_idx, odd_idx = 0, 0 for i in range(n): if i % 2 == 0: if even_idx < len(even_heights): result[i] = even_heights[even_idx] even_idx += 1 else: result[i] = odd_heights[odd_idx] odd_idx += 1 else: if odd_idx < len(odd_heights): result[i] = odd_heights[odd_idx] odd_idx += 1 else: result[i] = even_heights[even_idx] even_idx += 1 results.append(result) return results"},{"question":"def distinct_prime_factors_count(arr): Given an array of positive integers, this function returns the number of distinct prime factors for each element. >>> distinct_prime_factors_count([2]) [1] >>> distinct_prime_factors_count([13]) [1] >>> distinct_prime_factors_count([1001]) [3] >>> distinct_prime_factors_count([12, 15, 21]) [2, 2, 2] >>> distinct_prime_factors_count([2, 3, 4, 5]) [1, 1, 1, 1] def process_test_cases(test_cases): This function takes a list of test cases, where each test case is an array of positive integers, and returns the number of distinct prime factors for each element in each test case. >>> process_test_cases([[12, 15, 21], [2, 3, 4, 5]]) [[2, 2, 2], [1, 1, 1, 1]]","solution":"def distinct_prime_factors_count(arr): Given an array of positive integers, this function returns the number of distinct prime factors for each element. MAX_VAL = 10**6 smallest_prime_factor = list(range(MAX_VAL + 1)) for i in range(2, int(MAX_VAL**0.5) + 1): if smallest_prime_factor[i] == i: for j in range(i * i, MAX_VAL + 1, i): if smallest_prime_factor[j] == j: smallest_prime_factor[j] = i def prime_factors_count(n): unique_factors = set() while n > 1: unique_factors.add(smallest_prime_factor[n]) n //= smallest_prime_factor[n] return len(unique_factors) result = [prime_factors_count(n) for n in arr] return result def process_test_cases(test_cases): results = [] for case in test_cases: results.append(distinct_prime_factors_count(case)) return results"},{"question":"def are_fossils_similar(fossil1: str, fossil2: str) -> str: Determine if two fossils are similar by checking if they differ by at most one character. >>> are_fossils_similar(\\"brontosaurus\\", \\"broncosaurus\\") 'SIMILAR' >>> are_fossils_similar(\\"diplodocus\\", \\"diplodicus\\") 'SIMILAR' >>> are_fossils_similar(\\"triceratops\\", \\"stegosaurus\\") 'NOT SIMILAR' >>> are_fossils_similar(\\"a\\", \\"b\\") 'SIMILAR' >>> are_fossils_similar(\\"abcd\\", \\"abcf\\") 'SIMILAR' >>> are_fossils_similar(\\"abcd\\", \\"abed\\") 'SIMILAR' >>> are_fossils_similar(\\"brontosaurus\\", \\"brunciolurus\\") 'NOT SIMILAR' >>> are_fossils_similar(\\"dinosaur\\", \\"dinosaur\\") 'SIMILAR' >>> are_fossils_similar(\\"diplodocus\\", \\"diplodocusx\\") 'NOT SIMILAR'","solution":"def are_fossils_similar(fossil1, fossil2): Determine if two fossils are similar by checking if they differ by at most one character. if len(fossil1) != len(fossil2): return \\"NOT SIMILAR\\" difference_count = 0 for char1, char2 in zip(fossil1, fossil2): if char1 != char2: difference_count += 1 if difference_count > 1: return \\"NOT SIMILAR\\" return \\"SIMILAR\\" # Example usage: # print(are_fossils_similar(\\"brontosaurus\\", \\"broncosaurus\\")) # Output: SIMILAR # print(are_fossils_similar(\\"diplodocus\\", \\"diplodicus\\")) # Output: SIMILAR # print(are_fossils_similar(\\"triceratops\\", \\"stegosaurus\\")) # Output: NOT SIMILAR"},{"question":"def isAtOrigin(moves: str) -> bool: Determine if the robot returns to the origin after a series of moves. >>> isAtOrigin(\\"UD\\") True >>> isAtOrigin(\\"LL\\") False","solution":"def isAtOrigin(moves): Determine if the robot returns to the origin after a series of moves. Parameters: moves (str): A string representing the robot's movement on a grid. Returns: bool: True if the robot returns to the origin, False otherwise. x, y = 0, 0 for move in moves: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return x == 0 and y == 0"},{"question":"def find_pairs(arr, target): Find all unique pairs of integers in the array that add up to the given target. Args: arr (list of int): List of distinct integers. target (int): The target sum for pairs. Returns: list of list of int: List of unique pairs that add up to the target. # Write your code here # Unit Tests def test_example_1(): arr = [1, 2, 3, 4, 5] target = 5 expected_output = [[1, 4], [2, 3]] output = find_pairs(arr, target) assert sorted(output) == sorted(expected_output) def test_example_2(): arr = [0, -1, 2, -3, 1] target = -2 expected_output = [[-3, 1]] output = find_pairs(arr, target) assert sorted(output) == sorted(expected_output) def test_no_pairs(): arr = [1, 3, 5, 7, 9] target = 2 expected_output = [] output = find_pairs(arr, target) assert output == expected_output def test_multiple_pairs(): arr = [1, 5, 7, -1, 5] target = 6 expected_output = [[1, 5], [-1, 7]] output = find_pairs(arr, target) assert sorted(output) == sorted(expected_output) def test_negative_target(): arr = [4, -2, 1, -5, -8, 2] target = -3 expected_output = [[-5, 2]] output = find_pairs(arr, target) assert sorted(output) == sorted(expected_output)","solution":"def find_pairs(arr, target): Find all unique pairs of integers in the array that add up to the given target. Args: arr (list of int): List of distinct integers. target (int): The target sum for pairs. Returns: list of list of int: List of unique pairs that add up to the target. seen = set() pairs = set() for num in arr: complement = target - num if complement in seen: pairs.add(tuple(sorted((num, complement)))) seen.add(num) return [list(pair) for pair in pairs]"},{"question":"def canFormByRearranging(str1: str, str2: str) -> bool: Determine whether str2 can be formed by rearranging the characters of str1. >>> canFormByRearranging(\\"listen\\", \\"silent\\") True >>> canFormByRearranging(\\"triangle\\", \\"integral\\") True >>> canFormByRearranging(\\"abc\\", \\"abd\\") False","solution":"def canFormByRearranging(str1, str2): Determine whether str2 can be formed by rearranging the characters of str1. Args: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str2 can be formed by rearranging the characters of str1, else False. if len(str1) != len(str2): return False char_count = [0] * 26 # There are 26 lowercase alphabets for char in str1: char_count[ord(char) - ord('a')] += 1 for char in str2: char_count[ord(char) - ord('a')] -= 1 if char_count[ord(char) - ord('a')] < 0: return False return True"},{"question":"def max_team_strength(n: int, k: int, skill_levels: List[int]) -> int: Returns the maximum possible strength of a team of k members from n participants. n: int - Number of participants k: int - Number of participants in the team skill_levels: List[int] - List of integers representing skill levels of the participants >>> max_team_strength(5, 3, [5, 1, 2, 9, 7]) 21 >>> max_team_strength(4, 2, [8, 5, 4, 3]) 13 pass","solution":"def max_team_strength(n, k, skill_levels): Returns the maximum possible strength of a team of k members from n participants. :param n: int - Number of participants :param k: int - Number of participants in the team :param skill_levels: list - List of integers representing skill levels of the participants :return: int - Maximum possible strength of a team of k members skill_levels.sort(reverse=True) return sum(skill_levels[:k])"},{"question":"def saito_division(X: int, Y: int) -> int: Returns the result of X divided by Y if both X and Y are between 1 and 10, and the result is an integer. Otherwise, returns -1. >>> saito_division(9, 3) 3 >>> saito_division(20, 4) -1","solution":"def saito_division(X, Y): Returns the result of X divided by Y if both X and Y are between 1 and 10, and the result is an integer. Otherwise, returns -1. if 1 <= X <= 10 and 1 <= Y <= 10 and X % Y == 0: return X // Y else: return -1"},{"question":"def matrix_sum(n, k, instructions): Calculates the sum of the matrix elements after applying a series of instructions to update the matrix. Parameters: n (int): The size of the matrix (n x n). k (int): The number of instructions. instructions (list of tuple): A list of instructions, each of the form (i, j, x). Returns: int: The sum of all elements in the matrix after applying all the instructions. pass # Unit Tests def test_example_case(): n = 3 k = 4 instructions = [(0, 0, 5), (1, 1, 3), (2, 2, 7), (0, 1, -2)] assert matrix_sum(n, k, instructions) == 13 def test_all_zeros(): n = 2 k = 2 instructions = [(0, 0, 0), (1, 1, 0)] assert matrix_sum(n, k, instructions) == 0 def test_single_instruction(): n = 1 k = 1 instructions = [(0, 0, 10)] assert matrix_sum(n, k, instructions) == 10 def test_large_numbers(): n = 2 k = 2 instructions = [(0, 0, 1000000000), (1, 1, -1000000000)] assert matrix_sum(n, k, instructions) == 0 def test_multiple_instructions_same_cell(): n = 3 k = 3 instructions = [(0, 0, 5), (0, 0, 3), (0, 0, -2)] assert matrix_sum(n, k, instructions) == 6 def test_edge_indices(): n = 3 k = 4 instructions = [(0, 0, 1), (0, 2, 2), (2, 0, 3), (2, 2, 4)] assert matrix_sum(n, k, instructions) == 10","solution":"def matrix_sum(n, k, instructions): Calculates the sum of the matrix elements after applying a series of instructions to update the matrix. Parameters: n (int): The size of the matrix (n x n). k (int): The number of instructions. instructions (list of tuple): A list of instructions, each of the form (i, j, x). Returns: int: The sum of all elements in the matrix after applying all the instructions. # Initialize the matrix with zeros matrix = [[0] * n for _ in range(n)] # Apply each instruction to the matrix for i, j, x in instructions: matrix[i][j] += x # Calculate the sum of all elements in the matrix total_sum = sum(sum(row) for row in matrix) return total_sum"},{"question":"def is_balanced_possible(S: str) -> str: Determines if it is possible to make the string empty by removing balanced substrings. Parameters: S (str): The input string consisting of 'A' and 'B'. Returns: str: \\"YES\\" if it is possible to make the string empty, \\"NO\\" otherwise. >>> is_balanced_possible(\\"AABB\\") \\"YES\\" >>> is_balanced_possible(\\"ABAB\\") \\"YES\\" >>> is_balanced_possible(\\"AAABBB\\") \\"YES\\" >>> is_balanced_possible(\\"AAAA\\") \\"NO\\" >>> is_balanced_possible(\\"BBB\\") \\"NO\\" >>> is_balanced_possible(\\"AABBB\\") \\"NO\\" def process_test_cases(T: int, test_cases: List[str]) -> List[str]: Processes multiple test cases to determine if each string can be made empty. Parameters: T (int): The number of test cases. test_cases (list): A list of test case strings. Returns: list: A list of \\"YES\\" or \\"NO\\" for each test case. >>> process_test_cases(3, [\\"AABB\\", \\"ABAB\\", \\"AAABBB\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> process_test_cases(1, [\\"AAAA\\"]) [\\"NO\\"] >>> process_test_cases(1, [\\"AABBB\\"]) [\\"NO\\"]","solution":"def is_balanced_possible(S): Determines if it is possible to make the string empty by removing balanced substrings. Parameters: S (str): The input string consisting of 'A' and 'B'. Returns: str: \\"YES\\" if it is possible to make the string empty, \\"NO\\" otherwise. return \\"YES\\" if S.count('A') == S.count('B') else \\"NO\\" # Function to handle multiple test cases. def process_test_cases(T, test_cases): Processes multiple test cases to determine if each string can be made empty. Parameters: T (int): The number of test cases. test_cases (list): A list of test case strings. Returns: list: A list of \\"YES\\" or \\"NO\\" for each test case. results = [] for i in range(T): results.append(is_balanced_possible(test_cases[i])) return results"},{"question":"from typing import List, Tuple def minimum_total_latency(N: int, K: int, connections: List[Tuple[int, int, int]]) -> int: Determine the minimum total latency from the root to all K selected computers with special software installed in a tree network. Args: N (int): Number of computers in the network. K (int): Number of computers including the root with special software. connections (List[Tuple[int, int, int]]): List of edges where each edge is represented by a tuple (u, v, c) indicating an undirected edge between computers u and v with latency c. Returns: int: The minimum total latency from the root to all K selected computers. >>> minimum_total_latency(6, 3, [(1, 2, 1), (1, 3, 2), (2, 4, 1), (2, 5, 2), (5, 6, 1)]) 3 >>> minimum_total_latency(5, 1, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]) 0 # Implement the function # Function to test example case def test_example_case(): assert minimum_total_latency(6, 3, [(1, 2, 1), (1, 3, 2), (2, 4, 1), (2, 5, 2), (5, 6, 1)]) == 3 def test_min_k(): assert minimum_total_latency(5, 1, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (4, 5, 6)]) == 0 def test_same_latencies(): assert minimum_total_latency(4, 2, [(1, 2, 5), (1, 3, 5), (1, 4, 5)]) == 5 def test_all_nodes_selected(): assert minimum_total_latency(3, 3, [(1, 2, 4), (1, 3, 2)]) == 6 def test_large_tree(): connections = [(1, 2, 1)] for i in range(2, 100001): connections.append((i, i + 1, 1)) assert minimum_total_latency(100001, 2, connections) == 1","solution":"import heapq def dijkstra(tree, number_of_nodes, start): distances = {node: float('infinity') for node in range(1, number_of_nodes + 1)} distances[start] = 0 priority_queue = [(0, start)] while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > distances[current_node]: continue for neighbor, weight in tree[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return distances def minimum_total_latency(N, K, connections): if K == 1: return 0 tree = {i: [] for i in range(1, N + 1)} for u, v, c in connections: tree[u].append((v, c)) tree[v].append((u, c)) distances_from_root = dijkstra(tree, N, 1) distances = sorted(distances_from_root.values()) return sum(distances[:K]) # Example usage of the function # print(minimum_total_latency(6, 3, [(1, 2, 1), (1, 3, 2), (2, 4, 1), (2, 5, 2), (5, 6, 1)]))"},{"question":"def find_maximum_subarray_sum(arr: List[int]) -> int: Given an array of integers, find the contiguous subarray which has the largest sum and return the sum. Implement your solution using a Divide and Conquer approach. >>> find_maximum_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 >>> find_maximum_subarray_sum([-1, -2, -3, -4, -5, -6]) == -1 >>> find_maximum_subarray_sum([1, 2, 3, 4, 5]) == 15 >>> find_maximum_subarray_sum([-1, -2, -3, -4, -5]) == -1 >>> find_maximum_subarray_sum([10]) == 10 >>> find_maximum_subarray_sum([-10]) == -10 >>> find_maximum_subarray_sum([1000] * 10000) == 1000 * 10000","solution":"def max_crossing_sum(arr, left, mid, right): Helper function to find the maximum sum crossing the middle of the array. sm = 0 left_sum = float('-inf') for i in range(mid, left - 1, -1): sm = sm + arr[i] if (sm > left_sum): left_sum = sm sm = 0 right_sum = float('-inf') for i in range(mid + 1, right + 1): sm = sm + arr[i] if (sm > right_sum): right_sum = sm return left_sum + right_sum def max_subarray_sum(arr, left, right): Helper function using the divide and conquer approach to find the maximum subarray sum. if left == right: return arr[left] mid = (left + right) // 2 return max(max_subarray_sum(arr, left, mid), max_subarray_sum(arr, mid+1, right), max_crossing_sum(arr, left, mid, right)) def find_maximum_subarray_sum(arr): Finds the maximum sum of the contiguous subarray. return max_subarray_sum(arr, 0, len(arr) - 1)"},{"question":"def longest_common_prefix(strings: List[str], queries: List[Tuple[int, int]]) -> List[str]: Determine the longest common prefix for each query of strings. Args: strings: List of input strings. queries: List of queries represented as tuples (i, k). Returns: List of longest common prefixes for each query. Example: >>> longest_common_prefix([\\"flower\\", \\"flow\\", \\"flight\\", \\"fleet\\", \\"fly\\"], [(0, 3), (1, 2), (2, 3)]) [\\"fl\\", \\"fl\\", \\"fl\\"] # Unit tests example def test_longest_common_prefix_case_1(): strings = [\\"flower\\", \\"flow\\", \\"flight\\", \\"fleet\\", \\"fly\\"] queries = [(0, 3), (1, 2), (2, 3)] result = longest_common_prefix(strings, queries) assert result == [\\"fl\\", \\"fl\\", \\"fl\\"] def test_longest_common_prefix_case_2(): strings = [\\"dog\\", \\"racecar\\", \\"car\\"] queries = [(0, 2), (1, 2)] result = longest_common_prefix(strings, queries) assert result == [\\"\\", \\"\\"] def test_longest_common_prefix_single_string(): strings = [\\"single\\"] queries = [(0, 1)] result = longest_common_prefix(strings, queries) assert result == [\\"single\\"] def test_longest_common_prefix_no_common_prefix(): strings = [\\"retest\\", \\"differ\\", \\"variant\\"] queries = [(0, 3)] result = longest_common_prefix(strings, queries) assert result == [\\"\\"] def test_longest_common_prefix_all_same_strings(): strings = [\\"common\\", \\"common\\", \\"common\\"] queries = [(0, 3), (1, 2), (0, 2)] result = longest_common_prefix(strings, queries) assert result == [\\"common\\", \\"common\\", \\"common\\"]","solution":"def longest_common_prefix(strings, queries): def find_lcp(strs): if not strs: return \\"\\" min_len = min(len(s) for s in strs) lcp = strs[0][:min_len] for s in strs: for i in range(len(lcp)): if lcp[i] != s[i]: lcp = lcp[:i] break return lcp results = [] for i, k in queries: subset = strings[i:i+k] results.append(find_lcp(subset)) return results"},{"question":"from typing import List, Union def three_sum(nums: List[int], target: int) -> Union[List[tuple], str]: Returns all unique combinations of three numbers in nums that sum up to target, sorted in non-decreasing order. If no such combinations found, returns \\"No combinations found\\". >>> three_sum([-1, 0, 1, 2, -1, -4], 0) == sorted([(-1, -1, 2), (-1, 0, 1)]) >>> three_sum([1, 2, 3, 4, 5], 9) == sorted([(1, 3, 5), (2, 3, 4)]) >>> three_sum([1, 2, 3, 4, 5], 20) == \\"No combinations found\\" >>> three_sum([2, 4, 6, 8], 18) == [(4, 6, 8)] >>> three_sum([-1, -1, -1, -1, 0, 1, 1, 2, 2], 0) == sorted([(-1, -1, 2), (-1, 0, 1)])","solution":"def three_sum(nums, target): Returns all unique combinations of three numbers in nums that sum up to target, sorted in non-decreasing order. If no such combinations found, returns \\"No combinations found\\". nums.sort() n = len(nums) result = set() for i in range(n - 2): if i > 0 and nums[i] == nums[i - 1]: continue left, right = int(i + 1), int(n - 1) while left < right: sum_three = nums[i] + nums[left] + nums[right] if sum_three == target: result.add((nums[i], nums[left], nums[right])) while left < right and nums[left] == nums[left + 1]: left += 1 while left < right and nums[right] == nums[right - 1]: right -= 1 left += 1 right -= 1 elif sum_three < target: left += 1 else: right -= 1 if result: return sorted(result) else: return \\"No combinations found\\""},{"question":"def verify_tickets(n, m, p, vip_seats, ticketholders): Verify the validity of tickets for each ticketholder. Parameters: n (int): The total number of seats m (int): The number of VIP reserved seats p (int): The number of ticketholders vip_seats (list of int): The list of seat numbers reserved for VIPs (1-based index) ticketholders (list of list of int): Each sublist starts with an integer t (the number of tickets they hold), followed by t integers representing the seat numbers requested by the ticketholder. Returns: list of str: For each ticketholder, \\"YES\\" if all their tickets are valid and none of the requested seats are reserved for VIPs; \\"NO\\" otherwise. Example: >>> verify_tickets(10, 3, 2, [3, 5, 7], [[2, 1, 4], [2, 5, 8]]) ['YES', 'NO'] >>> verify_tickets(5, 0, 2, [], [[1, 1], [1, 2]]) ['YES', 'YES']","solution":"def verify_tickets(n, m, p, vip_seats, ticketholders): vip_set = set(vip_seats) results = [] for holder in ticketholders: t = holder[0] requested_seats = holder[1:] valid = True for seat in requested_seats: if seat in vip_set: valid = False break if valid: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def find_min_edge_to_disconnect(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Find the minimum weight of edges that must be included to make the graph disconnected. Args: n (int): Number of nodes in the graph. m (int): Number of edges in the graph. edges (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w representing an edge between node u and node v with weight w. Returns: int: The minimum weight of edges to disconnect the graph or 0 if the graph is already disconnected. Examples: >>> find_min_edge_to_disconnect(6, 7, [(1, 2, 10), (1, 3, 15), (2, 3, 5), (2, 4, 10), (3, 5, 5), (4, 5, 5), (4, 6, 10)]) 5 >>> find_min_edge_to_disconnect(4, 2, [(1, 2, 7), (3, 4, 10)]) 0","solution":"def find_min_edge_to_disconnect(n, m, edges): # Check if the graph is already disconnected from collections import defaultdict, deque def bfs(start, visited): queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) graph = defaultdict(list) for u, v, w in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (n + 1) bfs(1, visited) if not all(visited[1:]): return 0 # The graph is already disconnected # Kruskal's algorithm to find the minimum spanning tree edges.sort(key=lambda x: x[2]) # Sort edges based on weight parent = list(range(n + 1)) rank = [0] * (n + 1) def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: if rank[rootX] > rank[rootY]: parent[rootY] = rootX elif rank[rootX] < rank[rootY]: parent[rootX] = rootY else: parent[rootY] = rootX rank[rootX] += 1 minimum_edge_weight = float('inf') for u, v, w in edges: if find(u) != find(v): union(u, v) minimum_edge_weight = w if sum((find(i) == 1 for i in range(1, n+1))) < n: return w return minimum_edge_weight # Example usage and verification def main(): n, m = map(int, input().strip().split()) edges = [] for _ in range(m): u, v, w = map(int, input().strip().split()) edges.append((u, v, w)) result = find_min_edge_to_disconnect(n, m, edges) print(result) if __name__ == \\"__main__\\": main()"},{"question":"def calculate_energy(energy_consumption_per_km: float, load_kg: float, additional_percentage_per_kg: float, distance_km: float) -> float: Calculate the total energy consumption for the entire trip. Parameters: energy_consumption_per_km (float): Base energy consumption per km for an empty drone in Wh/km. load_kg (float): Load the drone is carrying in kilograms. additional_percentage_per_kg (float): Additional percentage of energy consumption per kg of load. distance_km (float): Distance the drone will travel in kilometers. Returns: float: Total energy consumption over the given distance. Examples: >>> calculate_energy(100, 10, 5, 50) 7500.0 >>> calculate_energy(200, 5, 10, 30) 9000.0 # Unit tests from solution import calculate_energy def test_calculate_energy_example_1(): # Example 1 from the prompt assert calculate_energy(100, 10, 5, 50) == 7500.0 def test_calculate_energy_example_2(): # Example 2 from the prompt assert calculate_energy(200, 5, 10, 30) == 9000.0 def test_calculate_energy_no_load(): # No load, should be same as base consumption assert calculate_energy(100, 0, 5, 50) == 5000.0 def test_calculate_energy_no_additional_percentage(): # No additional percentage, should be same as base consumption assert calculate_energy(100, 10, 0, 50) == 5000.0 def test_calculate_energy_large_distance(): # Large distance assert calculate_energy(100, 5, 10, 1000) == 150000.0","solution":"def calculate_energy(energy_consumption_per_km: float, load_kg: float, additional_percentage_per_kg: float, distance_km: float) -> float: Calculate the total energy consumption for the entire trip. Parameters: energy_consumption_per_km (float): Base energy consumption per km for an empty drone in Wh/km. load_kg (float): Load the drone is carrying in kilograms. additional_percentage_per_kg (float): Additional percentage of energy consumption per kg of load. distance_km (float): Distance the drone will travel in kilometers. Returns: float: Total energy consumption over the given distance. # Calculate the additional energy consumption due to the load additional_consumption = energy_consumption_per_km * (additional_percentage_per_kg / 100) * load_kg # Calculate the total energy consumption per km with the load total_consumption_per_km = energy_consumption_per_km + additional_consumption # Calculate the total energy consumption for the entire distance total_energy_consumption = total_consumption_per_km * distance_km return total_energy_consumption"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring. >>> longest_valid_parentheses(\\"()\\") 2 >>> longest_valid_parentheses(\\"(()\\") 2 >>> longest_valid_parentheses(\\"(()())\\") 6 >>> longest_valid_parentheses(\\"(())\\") 4 >>> longest_valid_parentheses(\\")(\\") 0 >>> longest_valid_parentheses(\\"()())\\") 4 >>> longest_valid_parentheses(\\"())(()\\") 2 >>> longest_valid_parentheses(\\"()(())\\") 6 >>> longest_valid_parentheses(\\"()()()\\") 6 >>> longest_valid_parentheses(\\"(()(()))\\") 8 >>> longest_valid_parentheses(\\")()())())\\") 4 >>> longest_valid_parentheses(\\"()((()\\") 2 # Your code here","solution":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring. max_length = 0 stack = [-1] for i, char in enumerate(s): if char == '(': stack.append(i) else: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: stack.append(i) return max_length"},{"question":"def prime_factors(n: int) -> List[int]: Returns the list of prime factors of a given positive integer n. >>> prime_factors(6) [2, 3] >>> prime_factors(15) [3, 5] >>> prime_factors(21) [3, 7] >>> prime_factors(10) [2, 5] >>> prime_factors(25) [5, 5] >>> prime_factors(8) [2, 2, 2] >>> prime_factors(13) [13] >>> prime_factors(19) [19] def prime_factors_list(nums: List[int]) -> List[List[int]]: Given a list of integers, return a sorted list of lists, each containing the prime factors of the corresponding input integers. Exclude zeros and negative numbers from the output. >>> prime_factors_list([6, 15, -4, 0, 21]) [[2, 3], [3, 5], [3, 7]] >>> prime_factors_list([10, 25, 8]) [[2, 5], [5, 5], [2, 2, 2]] >>> prime_factors_list([13, 19]) [[13], [19]] >>> prime_factors_list([-1, 0, -10]) [] >>> prime_factors_list([]) [] >>> prime_factors_list([0, 0, 0]) []","solution":"def prime_factors(n): Returns the list of prime factors of a given positive integer n. factors = [] divisor = 2 while n > 1: while n % divisor == 0: factors.append(divisor) n = n // divisor divisor += 1 return factors def prime_factors_list(nums): Given a list of integers, return a sorted list of lists, each containing the prime factors of the corresponding input integers. Exclude zeros and negative numbers from the output. result = [] for num in nums: if num > 0: result.append(prime_factors(num)) return result"},{"question":"from typing import List def has_pair_with_sum(numbers: List[int], target: int) -> str: Returns 'Yes' if there are two distinct integers in the list that sum up to the target number, otherwise returns 'No'. >>> has_pair_with_sum([1, 4, 45, 6, 10], 16) == \\"Yes\\" >>> has_pair_with_sum([0, -2, 3, 2], 1) == \\"Yes\\" >>> has_pair_with_sum([1, 2, 3], 7) == \\"No\\"","solution":"def has_pair_with_sum(numbers, target): Returns 'Yes' if there are two distinct integers in the list that sum up to the target number, otherwise returns 'No'. seen = set() for number in numbers: if (target - number) in seen: return \\"Yes\\" seen.add(number) return \\"No\\""},{"question":"from typing import List, Tuple def count_unique_paths(n: int, m: int) -> int: Returns the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid. Examples: >>> count_unique_paths(2, 2) 2 >>> count_unique_paths(3, 2) 3 >>> count_unique_paths(3, 3) 6 pass def process_test_cases(test_cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases and returns a list of results. Examples: >>> process_test_cases([(2, 2), (3, 2), (3, 3)]) [2, 3, 6] >>> process_test_cases([(1, 2), (2, 1), (2, 3), (3, 2)]) [1, 1, 3, 3] pass","solution":"from math import comb def count_unique_paths(n, m): Returns the number of unique paths from the top-left corner to the bottom-right corner of an n x m grid. # The number of unique paths is a combinatorial problem, specifically combinations. # For an n x m grid, the answer is (n+m-2) choose (n-1) return comb(n + m - 2, n - 1) def process_test_cases(test_cases): Processes multiple test cases and returns a list of results. results = [] for n, m in test_cases: results.append(count_unique_paths(n, m)) return results # Example usage: # test_cases = [(2, 2), (3, 2), (3, 3)] # print(process_test_cases(test_cases))"},{"question":"def knapsack(mirums, target): Determine the optimal subset of Mirums such that the sum of their power values is maximized without exceeding the target value. def max_power_subsets(test_cases): For each test case, apply the knapsack algorithm to find the maximum sum of the power values of the selected subset of Mirums that does not exceed the target value K. >>> max_power_subsets([((5, 50), [10, 20, 30, 40, 50])]) [50] >>> max_power_subsets([((5, 50), [10, 20, 30, 40, 50]), ((4, 70), [20, 30, 40, 25])]) [50, 70]","solution":"def knapsack(mirums, target): N = len(mirums) dp = [0] * (target + 1) for power in mirums: for j in range(target, power - 1, -1): dp[j] = max(dp[j], dp[j - power] + power) return dp[target] def max_power_subsets(test_cases): results = [] for case in test_cases: N, K = case[0] mirums = case[1] results.append(knapsack(mirums, K)) return results"},{"question":"def max_accumulated_score(scores): Returns the maximum score accumulated by any player after all rounds. Parameters: scores (list of list of ints): Each inner list represents the scores of players in a round Returns: int: The maximum score accumulated by any player pass # Unit tests def test_example1(): scores = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert max_accumulated_score(scores) == 18 def test_example2(): scores = [[5, 1, 3], [2, 7, 4], [8, 0, 6]] assert max_accumulated_score(scores) == 15 def test_example3(): scores = [[10, 20], [30, 40]] assert max_accumulated_score(scores) == 60 def test_single_round(): scores = [[10, 20, 30]] assert max_accumulated_score(scores) == 30 def test_single_player_multiple_rounds(): scores = [[10], [20], [30]] assert max_accumulated_score(scores) == 60 def test_large_values(): scores = [[10**6, -10**6], [10**6, -10**6]] assert max_accumulated_score(scores) == 2 * 10**6 def test_all_negative_values(): scores = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]] assert max_accumulated_score(scores) == -12 def test_zero_values(): scores = [[0, 0, 0], [0, 0, 0], [0, 0, 0]] assert max_accumulated_score(scores) == 0","solution":"def max_accumulated_score(scores): Returns the maximum score accumulated by any player after all rounds. Parameters: scores (list of list of ints): Each inner list represents the scores of players in a round Returns: int: The maximum score accumulated by any player # Number of players num_players = len(scores[0]) # Initialize accumulated scores for each player accumulated_scores = [0] * num_players # Accumulate scores for each player for round_scores in scores: for i in range(num_players): accumulated_scores[i] += round_scores[i] # Find the maximum accumulated score return max(accumulated_scores)"},{"question":"def max_shows(shows): Returns the maximum number of non-overlapping shows that can be watched. shows: List of tuples where each tuple contains the start and end time of a show. # Implement the function to maximize number of non-overlapping shows def process_input(input_str): Processes multiple datasets from the input string and returns the results for each dataset. >>> process_input(\\"6n1 4n3 5n0 6n5 7n8 9n5 9n0\\") == [3] >>> process_input(\\"6n1 4n3 5n0 6n5 7n8 9n5 9n5n1 3n0 2n4 5n2 3n5 6n0\\") == [3, 4] >>> process_input(\\"3n1 2n2 3n0 4n6n1 4n3 5n0 6n5 7n8 9n5 9n0\\") == [2, 3] >>> process_input(\\"0\\") == [] >>> process_input(\\"4n1 10n2 10n3 10n4 10n0\\") == [1]","solution":"def max_shows(shows): Returns the maximum number of non-overlapping shows that can be watched. shows: List of tuples where each tuple contains the start and end time of a show. # Sort the shows by their end times shows.sort(key=lambda show: show[1]) count = 0 last_end_time = -1 for show in shows: if show[0] >= last_end_time: count += 1 last_end_time = show[1] return count def process_input(input_str): Processes multiple datasets from the input string and returns the results for each dataset. lines = input_str.strip().split('n') i = 0 results = [] while i < len(lines): n = int(lines[i]) if n == 0: break shows = [] for j in range(i+1, i+1+n): start, end = map(int, lines[j].split()) shows.append((start, end)) results.append(max_shows(shows)) i += n + 1 return results"},{"question":"def min_additional_beds_to_palindrome(n: int, heights: List[int]) -> int: Returns the minimum number of additional flower beds required to make the sequence of flower heights palindromic. >>> min_additional_beds_to_palindrome(5, [3, 1, 2, 1, 3]) 0 >>> min_additional_beds_to_palindrome(4, [1, 2, 3, 4]) 3","solution":"def min_additional_beds_to_palindrome(n, heights): Returns the minimum number of additional flower beds required to make the sequence of flower heights palindromic. def min_insertions_palindrome(seq): Helper function to find minimum insertions to make seq palindrome. length = len(seq) dp = [[0]*length for _ in range(length)] for gap in range(1, length): for l in range(length-gap): r = l + gap if seq[l] == seq[r]: dp[l][r] = dp[l+1][r-1] else: dp[l][r] = min(dp[l+1][r], dp[l][r-1]) + 1 return dp[0][-1] return min_insertions_palindrome(heights)"},{"question":"def calculate_ranks(T: int, scores: List[int]) -> List[int]: Calculate the rank of each participant based on their scores. Participants with the same score will share the same rank. >>> calculate_ranks(5, [12, 96, 96, 41, 69]) [5, 1, 1, 4, 3] >>> calculate_ranks(4, [50, 50, 50, 50]) [1, 1, 1, 1] >>> calculate_ranks(4, [10, 20, 30, 40]) [4, 3, 2, 1] >>> calculate_ranks(4, [40, 30, 20, 10]) [1, 2, 3, 4] >>> calculate_ranks(6, [60, 50, 50, 90, 70, 30]) [3, 4, 4, 1, 2, 6]","solution":"def calculate_ranks(T, scores): sorted_scores = sorted(scores, reverse=True) rank_dict = {} rank = 1 for i in range(T): if sorted_scores[i] not in rank_dict: rank_dict[sorted_scores[i]] = rank rank += 1 ranks = [rank_dict[score] for score in scores] return ranks"},{"question":"class BankAccount: A class representing a simple bank account system. Methods: - deposit(amount): Adds the given amount to the account balance. - withdraw(amount): Subtracts the given amount from the account balance if sufficient funds are available. - get_balance(): Returns the current balance of the account. def __init__(self): self.balance = 0 def deposit(self, amount: int) -> str: Deposits the specified amount into the account. Args: amount (int): The amount to deposit. Returns: str: A message indicating the deposit amount. pass # Implement the deposit logic def withdraw(self, amount: int) -> str: Withdraws the specified amount from the account if sufficient funds are available. Args: amount (int): The amount to withdraw. Returns: str: A message indicating the withdrawn amount or insufficient funds. pass # Implement the withdrawal logic def get_balance(self) -> str: Returns the current balance of the account. Returns: str: A message indicating the current balance. pass # Implement the balance logic def execute_commands(commands: list[str]) -> list[str]: Executes a list of commands to simulate bank account operations. Args: commands (list[str]): A list of commands to be executed. Returns: list[str]: The output of each command executed. Example: >>> commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 100\\", \\"BALANCE\\", \\"WITHDRAW 50\\", \\"BALANCE\\", \\"WITHDRAW 60\\"] >>> execute_commands(commands) [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 100\\", \\"BALANCE: 100\\", \\"WITHDRAWN: 50\\", \\"BALANCE: 50\\", \\"Insufficient funds\\"] pass # Implement the command execution logic # Unit tests def test_create_account(): commands = [\\"CREATE ACCOUNT\\"] expected = [\\"ACCOUNT CREATED\\"] assert execute_commands(commands) == expected def test_deposit_money(): commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 100\\", \\"BALANCE\\"] expected = [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 100\\", \\"BALANCE: 100\\"] assert execute_commands(commands) == expected def test_withdraw_money(): commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 100\\", \\"WITHDRAW 50\\", \\"BALANCE\\"] expected = [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 100\\", \\"WITHDRAWN: 50\\", \\"BALANCE: 50\\"] assert execute_commands(commands) == expected def test_withdraw_insufficient_funds(): commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 100\\", \\"WITHDRAW 150\\"] expected = [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 100\\", \\"Insufficient funds\\"] assert execute_commands(commands) == expected def test_multiple_operations(): commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 100\\", \\"BALANCE\\", \\"WITHDRAW 50\\", \\"BALANCE\\", \\"WITHDRAW 60\\"] expected = [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 100\\", \\"BALANCE: 100\\", \\"WITHDRAWN: 50\\", \\"BALANCE: 50\\", \\"Insufficient funds\\"] assert execute_commands(commands) == expected def test_sequence_of_deposits_withdrawals(): commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 200\\", \\"WITHDRAW 50\\", \\"DEPOSIT 100\\", \\"WITHDRAW 150\\", \\"BALANCE\\"] expected = [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 200\\", \\"WITHDRAWN: 50\\", \\"DEPOSITED: 100\\", \\"WITHDRAWN: 150\\", \\"BALANCE: 100\\"] assert execute_commands(commands) == expected def test_zero_balance_operations(): commands = [\\"CREATE ACCOUNT\\", \\"DEPOSIT 500\\", \\"WITHDRAW 500\\", \\"BALANCE\\", \\"WITHDRAW 1\\"] expected = [\\"ACCOUNT CREATED\\", \\"DEPOSITED: 500\\", \\"WITHDRAWN: 500\\", \\"BALANCE: 0\\", \\"Insufficient funds\\"] assert execute_commands(commands) == expected","solution":"class BankAccount: def __init__(self): self.balance = 0 def deposit(self, amount): self.balance += amount return f\\"DEPOSITED: {amount}\\" def withdraw(self, amount): if self.balance >= amount: self.balance -= amount return f\\"WITHDRAWN: {amount}\\" else: return \\"Insufficient funds\\" def get_balance(self): return f\\"BALANCE: {self.balance}\\" def execute_commands(commands): account = None outputs = [] for command in commands: if command == \\"CREATE ACCOUNT\\": account = BankAccount() outputs.append(\\"ACCOUNT CREATED\\") elif account: if command.startswith(\\"DEPOSIT\\"): _, amount = command.split() outputs.append(account.deposit(int(amount))) elif command.startswith(\\"WITHDRAW\\"): _, amount = command.split() outputs.append(account.withdraw(int(amount))) elif command == \\"BALANCE\\": outputs.append(account.get_balance()) return outputs"},{"question":"from typing import List def common_elements(list1: List[int], list2: List[int]) -> List[int]: Returns a sorted list of unique elements that appear in both list1 and list2. Examples: >>> common_elements([10, 20, 30, 40], [30, 40, 50, 60]) [30, 40] >>> common_elements([1, 1, 2, 3], [2, 2, 3, 4]) [2, 3] >>> common_elements([7, 8, 9], [10, 11, 12]) [] pass","solution":"def common_elements(list1, list2): Returns a sorted list of unique elements that appear in both list1 and list2. set1 = set(list1) set2 = set(list2) common_set = set1.intersection(set2) return sorted(common_set)"},{"question":"def max_total_height(n: int, W: int, books: List[Tuple[int, int]]) -> int: Determine the maximum total height of books stacked with shelf width constraint. :param n: Number of books :param W: Maximum width of a single stack :param books: List of tuples (width, height) for each book :return: Maximum total height >>> max_total_height(3, 6, [(2, 4), (3, 7), (4, 5)]) == 16 >>> max_total_height(1, 5, [(3, 10)]) == 10 >>> max_total_height(3, 10, [(2, 2), (3, 3), (4, 4)]) == 9 >>> max_total_height(4, 4, [(4, 10), (4, 20), (2, 5), (2, 5)]) == 40 >>> max_total_height(3, 6, [(3, 4), (3, 6), (3, 8)]) == 18 >>> max_total_height(5, 5, [(1, 1), (1, 2), (1, 3), (1, 4), (1, 5)]) == 15","solution":"def max_total_height(n, W, books): Determine the maximum total height of books stacked with shelf width constraint. :param n: Number of books :param W: Maximum width of a single stack :param books: List of tuples (width, height) for each book :return: Maximum total height # Sort books by their heights in descending order books.sort(key=lambda x: x[1], reverse=True) # Initialize a list to keep track of the stack heights stack_heights = [] for width, height in books: placed = False # Try to place the book in an existing stack for i in range(len(stack_heights)): current_width, current_height = stack_heights[i] if current_width + width <= W: stack_heights[i] = (current_width + width, current_height + height) placed = True break # If the book was not placed in an existing stack, create a new stack if not placed: stack_heights.append((width, height)) # The total height is the sum of heights of all stacks total_height = sum(height for _, height in stack_heights) return total_height"},{"question":"from typing import List def minimal_lexicographical_string(S: str) -> str: Returns the smallest lexicographical string by performing minimal operations. >>> minimal_lexicographical_string(\\"cba\\") \\"abc\\" >>> minimal_lexicographical_string(\\"acb\\") \\"abc\\" >>> minimal_lexicographical_string(\\"abc\\") \\"abc\\" def solve(T: int, test_cases: List[str]) -> List[str]: For each test case, returns the smallest lexicographical string possible after performing the minimum number of operations. >>> solve(2, [\\"cba\\", \\"acb\\"]) [\\"abc\\", \\"abc\\"] >>> solve(1, [\\"bcaaa\\"]) [\\"aaabc\\"]","solution":"def minimal_lexicographical_string(S): Returns the smallest lexicographical string by performing minimal operations. return ''.join(sorted(S)) def solve(T, test_cases): results = [] for i in range(T): results.append(minimal_lexicographical_string(test_cases[i])) return results"},{"question":"def findPairs(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. Args: arr (list of int): The input array. k (int): The target sum. Returns: int: 1 if such indices exist, otherwise 0. Examples: >>> findPairs([1, 4, 5, 2], 6) 1 >>> findPairs([1, 2, 3, 9], 7) 0","solution":"def findPairs(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. Args: arr (list of int): The input array. k (int): The target sum. Returns: int: 1 if such indices exist, otherwise 0. seen = set() for num in arr: if k - num in seen: return 1 seen.add(num) return 0"},{"question":"def smallest_integer_with_product(N: int) -> int: Determine the smallest positive integer M such that the product of the digits of M is equal to N. If no such number exists, return -1. >>> smallest_integer_with_product(10) 25 >>> smallest_integer_with_product(20) 45 >>> smallest_integer_with_product(100) 455 pass def process_test_cases(T: int, test_cases: List[int]) -> List[int]: For each test case, find the smallest integer M whose digits' product is N, or -1 if no such number exists. >>> process_test_cases(3, [10, 20, 100]) [25, 45, 455] >>> process_test_cases(2, [1, 7]) [1, 7] pass","solution":"def smallest_integer_with_product(N): if N == 1: return 1 digits = [] for i in range(9, 1, -1): while N % i == 0: digits.append(i) N //= i if N != 1: return -1 return int(\\"\\".join(map(str, sorted(digits)))) def process_test_cases(T, test_cases): results = [] for N in test_cases: results.append(smallest_integer_with_product(N)) return results"},{"question":"def min_trees_to_buy(N, heights): This function takes in an integer N and a list of integers heights and returns the minimum number of trees needed to create a non-decreasing sequence of heights. >>> min_trees_to_buy(6, [3, 10, 5, 7, 15, 1]) 4 >>> min_trees_to_buy(4, [1, 2, 3, 4]) 4 >>> min_trees_to_buy(5, [4, 3, 2, 1, 5]) 2 >>> min_trees_to_buy(0, []) 0 >>> min_trees_to_buy(7, [7, 6, 5, 4, 3, 2, 1]) 1 pass def process_test_cases(T, test_cases): This function takes in an integer T and a list of tuples test_cases, where each tuple contains an integer N and a list of integers heights, and returns a list of integers, each representing the minimum number of trees needed to create a non-decreasing sequence of heights for each test case. >>> process_test_cases(2, [(6, [3, 10, 5, 7, 15, 1]), (4, [1, 2, 3, 4])]) [4, 4] >>> process_test_cases(3, [(5, [2, 1, 2, 1, 2]), (3, [3, 2, 1]), (7, [1, 3, 2, 4, 6, 5, 4])]) [2, 1, 4] >>> process_test_cases(1, [(0, [])]) [0] pass","solution":"import bisect def min_trees_to_buy(N, heights): This function takes in an integer N and a list of integers heights and returns the minimum number of trees needed to create a non-decreasing sequence of heights. if N == 0: return 0 # Implement the Longest Increasing Subsequence (LIS) approach lis = [] for height in heights: pos = bisect.bisect_left(lis, height) if pos == len(lis): lis.append(height) else: lis[pos] = height return len(lis) def process_test_cases(T, test_cases): results = [] for i in range(T): N, heights = test_cases[i] results.append(min_trees_to_buy(N, heights)) return results"},{"question":"def maximum_minimum_reliability(n: int, m: int, cables: List[Tuple[int, int, int]]) -> int: Evaluate the reliability of the network by identifying a path which has the maximum minimum reliability score among all possible paths from room 1 to room n. Args: n : int - Number of rooms m : int - Number of cables cables : List[Tuple[int, int, int]] - A list of tuples where each tuple contains three integers x, y, r indicating that there is a cable connecting room x and room y with a reliability score r Returns: int - Maximum minimum reliability score of the path from room 1 to room n. If there is no path, returns -1. Examples: >>> maximum_minimum_reliability(4, 4, [(1, 2, 50), (2, 3, 60), (3, 4, 30), (1, 3, 20)]) 30 >>> maximum_minimum_reliability(3, 2, [(1, 2, 10), (2, 3, 20)]) 10 >>> maximum_minimum_reliability(4, 3, [(1, 2, 40), (2, 3, 50), (3, 1, 20)]) -1","solution":"import heapq def maximum_minimum_reliability(n, m, cables): # Create adjacency list for the graph graph = [[] for _ in range(n + 1)] for x, y, r in cables: graph[x].append((r, y)) graph[y].append((r, x)) # Priority queue for Dijkstra-like maximum minimum path pq = [(-100, 1)] # Start with room 1, reliability 100 (negative for max heap) max_reliability = [0] * (n + 1) # To track the max reliability to each node max_reliability[1] = 100 while pq: curr_reliability, node = heapq.heappop(pq) curr_reliability = -curr_reliability if node == n: return curr_reliability for reliability, neighbor in graph[node]: min_reliability = min(curr_reliability, reliability) if min_reliability > max_reliability[neighbor]: max_reliability[neighbor] = min_reliability heapq.heappush(pq, (-min_reliability, neighbor)) return -1 if max_reliability[n] == 0 else max_reliability[n]"},{"question":"from typing import List def gcd(a, b): while b: a, b = b, a % b return a def simplify_fraction(n, d): Simplify a fraction n/d by dividing both the numerator and denominator by their greatest common divisor. >>> simplify_fraction(4, 2) (2, 1) >>> simplify_fraction(6, 9) (2, 3) pass def to_mixed_number(n, d): Convert an improper fraction n/d into a mixed number A B/C. >>> to_mixed_number(5, 3) \\"1 2/3\\" >>> to_mixed_number(7, 1) \\"7\\" pass def reform_fraction(fractions: List[str]) -> List[str]: Convert a list of fractions into their simplest forms or mixed numbers. >>> reform_fraction([\\"4/2\\", \\"5/3\\", \\"6/9\\", \\"7/1\\", \\"8/4\\"]) [\\"2\\", \\"1 2/3\\", \\"2/3\\", \\"7\\", \\"2\\"] >>> reform_fraction([\\"1/2\\", \\"3/4\\", \\"2/1\\", \\"9/3\\"]) [\\"1/2\\", \\"3/4\\", \\"2\\", \\"3\\"] pass def process_input_output(input_data: str) -> List[str]: Process input format and convert fractions to simplest forms or mixed numbers. >>> input_data = \\"5n4/2n5/3n6/9n7/1n8/4n\\" >>> process_input_output(input_data) [\\"2\\", \\"1 2/3\\", \\"2/3\\", \\"7\\", \\"2\\"] pass","solution":"def gcd(a, b): while b: a, b = b, a % b return a def simplify_fraction(n, d): common_divisor = gcd(n, d) return n // common_divisor, d // common_divisor def to_mixed_number(n, d): integer_part = n // d remainder = n % d if remainder == 0: return f\\"{integer_part}\\" else: simplified_n, simplified_d = simplify_fraction(remainder, d) return f\\"{integer_part} {simplified_n}/{simplified_d}\\" if simplified_n != 0 else f\\"{integer_part}\\" def reform_fraction(fractions): results = [] for frac in fractions: n, d = map(int, frac.split('/')) simplified_n, simplified_d = simplify_fraction(n, d) if simplified_n >= simplified_d: result = to_mixed_number(simplified_n, simplified_d) else: result = f\\"{simplified_n}/{simplified_d}\\" results.append(result) return results # Input and Output Functions def process_input_output(input_data): lines = input_data.strip().split(\\"n\\") Q = int(lines[0]) fractions = lines[1:Q+1] return reform_fraction(fractions)"},{"question":"def longest_common_substring_length(strings): Find the length of the longest substring that appears at least twice across different strings in a list. >>> longest_common_substring_length([\\"abcd\\", \\"abdc\\", \\"dacb\\"]) 2 >>> longest_common_substring_length([\\"hellothere\\", \\"helloworld\\", \\"yellowlaser\\", \\"mellow\\"]) 5 def solve(test_cases): Solves the problem for given test cases. Input is a list of tuples where the first element is the number of strings and subsequent elements are the strings. >>> solve([(3, \\"abcd\\", \\"abdc\\", \\"dacb\\")]) [2] >>> solve([(4, \\"hellothere\\", \\"helloworld\\", \\"yellowlaser\\", \\"mellow\\")]) [5]","solution":"def longest_common_substring_length(strings): def common_substring_length(s1, s2): len1, len2 = len(s1), len(s2) max_len = 0 dp = [[0] * (len2 + 1) for _ in range(len1 + 1)] for i in range(1, len1 + 1): for j in range(1, len2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 max_len = max(max_len, dp[i][j]) return max_len max_substring_length = 0 n = len(strings) for i in range(n): for j in range(i + 1, n): max_substring_length = max(max_substring_length, common_substring_length(strings[i], strings[j])) return max_substring_length def solve(test_cases): results = [] for t in test_cases: T, *input_strings = t result = longest_common_substring_length(input_strings) results.append(result) return results # Example test cases to be passed to solve function test_cases = [ (3, \\"abcd\\", \\"abdc\\", \\"dacb\\"), (4, \\"hellothere\\", \\"helloworld\\", \\"yellowlaser\\", \\"mellow\\") ] print(solve(test_cases)) # Expected output: [2, 5]"},{"question":"def longest_alphabetical_substring_length(n: int, s: str) -> int: Determine the longest substring such that all characters in the substring appear in alphabetical order. >>> longest_alphabetical_substring_length(7, \\"abcabca\\") == 3 >>> longest_alphabetical_substring_length(5, \\"edcba\\") == 1 from solution import longest_alphabetical_substring_length def test_example_1(): assert longest_alphabetical_substring_length(7, \\"abcabca\\") == 3 def test_example_2(): assert longest_alphabetical_substring_length(5, \\"edcba\\") == 1 def test_single_character(): assert longest_alphabetical_substring_length(1, \\"a\\") == 1 def test_all_same_character(): assert longest_alphabetical_substring_length(5, \\"aaaaa\\") == 5 def test_two_characters_no_order(): assert longest_alphabetical_substring_length(2, \\"ba\\") == 1 def test_two_characters_in_order(): assert longest_alphabetical_substring_length(2, \\"ab\\") == 2 def test_mixed_alphabetical(): assert longest_alphabetical_substring_length(10, \\"abcdabcdab\\") == 4 def test_no_order(): assert longest_alphabetical_substring_length(8, \\"hgfedcba\\") == 1 def test_entire_string(): assert longest_alphabetical_substring_length(6, \\"abcdef\\") == 6","solution":"def longest_alphabetical_substring_length(n, s): if n == 1: return 1 max_len = 1 current_len = 1 for i in range(1, n): if s[i] >= s[i-1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def encode_message(s: str) -> str: Encodes the special characters in the message: - '!' with '%21' - '?' with '%3F' - '.' with '%2E' :param s: A string to be encoded :return: Encoded string with special characters replaced >>> encode_message(\\"Hello World!\\") == \\"Hello World%21\\" >>> encode_message(\\"What is this?\\") == \\"What is this%3F\\" >>> encode_message(\\"This is fun.\\") == \\"This is fun%2E\\" >>> encode_message(\\"!?.\\") == \\"%21%3F%2E\\" >>> encode_message(\\"Hello World! How's everything? So cool.\\") == \\"Hello World%21 How's everything%3F So cool%2E\\" >>> encode_message(\\"Hello World\\") == \\"Hello World\\"","solution":"def encode_message(s: str) -> str: This function encodes the special characters in the message: - '!' with '%21' - '?' with '%3F' - '.' with '%2E' :param s: A string to be encoded :return: Encoded string with special characters replaced return s.replace('!', '%21').replace('?', '%3F').replace('.', '%2E')"},{"question":"def is_palindrome(s: str) -> bool: Checks if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case differences. >>> is_palindrome(\\"A man, a plan, a canal: Panama\\") True >>> is_palindrome(\\"race a car\\") False >>> is_palindrome(\\"\\") True >>> is_palindrome(\\"a\\") True >>> is_palindrome(\\"12321\\") True >>> is_palindrome(\\"123456\\") False >>> is_palindrome(\\"No lemon, no melon\\") True >>> is_palindrome(\\"!!!\\") True pass","solution":"def is_palindrome(s): Checks if the given string is a palindrome after removing all non-alphanumeric characters and ignoring case differences. # Remove non-alphanumeric characters and convert to lowercase filtered_s = ''.join(char.lower() for char in s if char.isalnum()) # Check if filtered string is a palindrome return filtered_s == filtered_s[::-1]"},{"question":"from typing import List def count_occurrences(numbers: List[int], queries: List[int]) -> List[int]: For each query, count the number of times it appears in the numbers list and return the counts. :param numbers: List of integers to count from :param queries: List of integers to query counts for :return: List of counts corresponding to each query >>> count_occurrences([1, 2, 3, 4, 5, 3, 3, 2], [3, 2, 1]) [3, 2, 1] >>> count_occurrences([1, 1, 1, 1], [2, 3, 4]) [0, 0, 0] >>> count_occurrences([5, 5, 5, 3, 3, 1, -1, -1], [5, 3, -1, 2]) [3, 2, 2, 0] >>> count_occurrences([10, 20, 30, 40], [5, 5, 10, 5]) [0, 0, 1, 0] >>> count_occurrences([], [1, 2, 3]) [0, 0, 0] >>> count_occurrences([1, 2, 3, 4], []) [] >>> count_occurrences([], []) []","solution":"from typing import List def count_occurrences(numbers: List[int], queries: List[int]) -> List[int]: For each query, count the number of times it appears in the numbers list and return the counts. :param numbers: List of integers to count from :param queries: List of integers to query counts for :return: List of counts corresponding to each query occurences = [] for query in queries: occurences.append(numbers.count(query)) return occurences"},{"question":"def shortest_communication_times(n, m, channels): Function to compute the shortest communication time from the home planet (planet 1) to every other planet using Dijkstra's algorithm. Parameters: n (int): Number of planets m (int): Number of communication channels channels (list of tuples): Each tuple contains three integers u, v, w representing a communication channel between planets u and v with latency time w Returns: List of shortest communication times from planet 1 to all other planets. If a planet is not reachable, it contains 'unreachable' instead of the latency time.","solution":"import heapq def shortest_communication_times(n, m, channels): Function to compute the shortest communication time from the home planet (planet 1) to every other planet using Dijkstra's algorithm. Parameters: n (int): Number of planets m (int): Number of communication channels channels (list of tuples): Each tuple contains three integers u, v, w representing a communication channel between planets u and v with latency time w Returns: List of shortest communication times from planet 1 to all other planets. If a planet is not reachable, it contains 'unreachable' instead of the latency time. # Create adjacency list for the graph graph = {i: [] for i in range(1, n + 1)} for u, v, w in channels: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find shortest path from node 1 pq = [(0, 1)] # (distance, node) dist = {i: float('inf') for i in range(1, n + 1)} dist[1] = 0 visited = set() while pq: current_dist, u = heapq.heappop(pq) if u in visited: continue visited.add(u) for v, weight in graph[u]: if v not in visited and current_dist + weight < dist[v]: dist[v] = current_dist + weight heapq.heappush(pq, (dist[v], v)) # Create result list based on the distances calculated result = [] for i in range(2, n + 1): if dist[i] == float('inf'): result.append(\\"unreachable\\") else: result.append(dist[i]) return result"},{"question":"def is_possible_to_traverse(n, m): Determines if it's possible for the robot to traverse the entire grid starting from any cell without revisiting any cell. :param n: Number of rows of the grid. :param m: Number of columns of the grid. :return: \\"possible\\" if the robot can visit all cells exactly once starting from any cell, otherwise \\"impossible\\". >>> is_possible_to_traverse(2, 2) == \\"impossible\\" >>> is_possible_to_traverse(3, 3) == \\"possible\\" >>> is_possible_to_traverse(1, 10) == \\"impossible\\" >>> is_possible_to_traverse(10, 1) == \\"impossible\\" >>> is_possible_to_traverse(1, 1) == \\"impossible\\" >>> is_possible_to_traverse(2, 10) == \\"possible\\" >>> is_possible_to_traverse(5, 4) == \\"possible\\" >>> is_possible_to_traverse(2, 1) == \\"impossible\\" def process_datasets(datasets): Processes a list of datasets where each dataset is a tuple of (n, m) representing the grid dimensions. It determines the possibility of traversing each grid starting from any cell. :param datasets: List of tuples, each tuple containing two integers n and m. :return: List of strings, \\"possible\\" or \\"impossible\\" for each dataset. >>> datasets = [(2, 2), (3, 3), (1, 10), (0, 0)] >>> process_datasets(datasets) == [\\"impossible\\", \\"possible\\", \\"impossible\\"]","solution":"def is_possible_to_traverse(n, m): Determines if it's possible for the robot to traverse the entire grid starting from any cell without revisiting any cell. :param n: Number of rows of the grid. :param m: Number of columns of the grid. :return: \\"possible\\" if the robot can visit all cells exactly once starting from any cell, otherwise \\"impossible\\". # It is well-known that it's only possible to traverse all cells of an \`n x m\` grid in a single, non-revisiting sweep if: # 1. Both n and m are greater than 1 (since a 1x1 grid is trivially impossible to traverse). # 2. n and m are not both 2 (because there is no way to traverse a 2x2 grid starting from one cell and visiting all exactly once). # 3. The grid is not long and thin (like 1x10), which makes it impossible to perform unique traversal for different starting points. if (n <= 1 or m <= 1) or (n == 2 and m == 2): return \\"impossible\\" return \\"possible\\" # Example usage with multiple datasets: def process_datasets(datasets): results = [] for n, m in datasets: if n == 0 and m == 0: break results.append(is_possible_to_traverse(n, m)) return results # Example inputs datasets = [ (2, 2), (3, 3), (1, 10), (0, 0) ] # Processing the example datasets results = process_datasets(datasets) for result in results: print(result)"},{"question":"from typing import List def three_sum_closest(nums: List[int], target: int) -> int: Write a function that takes an array of integers and a target integer as input. The function should find three distinct integers in the array whose sum is closest to the target integer. The function should return the sum of these three integers. If there are multiple possible solutions, return any of them. Examples: >>> three_sum_closest([-1, 2, 1, -4], 1) 2 >>> three_sum_closest([1, 1, 1, 0], -100) 2 def test_closest_sum_basic(): assert three_sum_closest([-1, 2, 1, -4], 1) == 2 def test_closest_sum_multiple(): result = three_sum_closest([1, 1, 1, 0], -100) assert result == 2 or result == 1 # Both 2 (1+1+0) and 1 (1+0+0) are valid closest sums def test_closest_sum_negative_target(): assert three_sum_closest([-1, 2, 1, -4, 5], -6) == -4 def test_closest_sum_large_array(): assert three_sum_closest(list(range(-1000, 1000)), 50) == 50 def test_closest_sum_with_zero(): assert three_sum_closest([0, 2, 1, -3], 1) == 0 def test_closest_sum_exact_match(): assert three_sum_closest([1, 2, 3, 4, 5], 10) == 10","solution":"def three_sum_closest(nums, target): nums.sort() # Sort the array to use the two-pointer strategy efficiently n = len(nums) closest_sum = float('inf') for i in range(n - 2): # Fix one element and use two-pointer approach for the rest left, right = i + 1, n - 1 while left < right: current_sum = nums[i] + nums[left] + nums[right] if abs(current_sum - target) < abs(closest_sum - target): closest_sum = current_sum # Update closest_sum if the current one is closer if current_sum < target: left += 1 # Move left pointer to the right to increase the sum elif current_sum > target: right -= 1 # Move right pointer to the left to decrease the sum else: # If current_sum is exactly the target, we can return it directly return current_sum return closest_sum"},{"question":"def can_segment_string(s: str, word_dict: List[str]) -> bool: Checks if the string s can be segmented into a space-separated sequence of one or more dictionary words. :param s: The string to be segmented. :param word_dict: A list of valid dictionary words. :return: True if the string can be segmented, False otherwise. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) True >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) True >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) False >>> can_segment_string(\\"pineapplepenapple\\", [\\"apple\\", \\"pen\\", \\"applepen\\", \\"pine\\", \\"pineapple\\"]) True >>> can_segment_string(\\"catsandogcat\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\", \\"og\\"]) True >>> can_segment_string(\\"testing\\", [\\"test\\", \\"ing\\", \\"testing\\"]) True >>> can_segment_string(\\"a\\", [\\"a\\"]) True >>> can_segment_string(\\"abcdef\\", []) False def process_input(input_string: str) -> List[bool]: Processes the input string and calls the can_segment_string function for each test case. :param input_string: A string with multiple test cases. :return: A list of booleans indicating the result for each test case. lines = input_string.strip().split(\\"n\\") t = int(lines[0]) index = 1 results = [] for _ in range(t): s = lines[index] n = int(lines[index + 1]) word_dict = lines[index + 2:index + 2 + n] index += 2 + n result = can_segment_string(s, word_dict) results.append(result) return results","solution":"def can_segment_string(s, word_dict): Checks if the string s can be segmented into a space-separated sequence of one or more dictionary words. :param s: The string to be segmented. :param word_dict: A list of valid dictionary words. :return: True if the string can be segmented, False otherwise. word_set = set(word_dict) dp = [False] * (len(s) + 1) dp[0] = True # Base case: an empty string can always be segmented for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return dp[len(s)] def process_input(input_string): lines = input_string.strip().split(\\"n\\") t = int(lines[0]) index = 1 results = [] for _ in range(t): s = lines[index] n = int(lines[index + 1]) word_dict = lines[index + 2:index + 2 + n] index += 2 + n result = can_segment_string(s, word_dict) results.append(result) return results"},{"question":"def sort_flights(flights, key): Sorts the list of flights based on the specified key. Args: flights (List[List[str]]): List of flights where each flight is represented as a list containing flight number, destination, departure time, and arrival time. key (str): The key to sort the flights by, which can be one of the following: 'FlightNumber', 'Destination', 'DepartureTime', 'ArrivalTime'. Returns: List[List[str]]: Sorted list of flights based on the given key. >>> flights = [ ... [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], ... [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], ... [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], ... [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], ... [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ... ] >>> sort_flights(flights, \\"DepartureTime\\") [[\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"]] from solution import sort_flights def test_sort_by_flight_number(): flights = [ [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ] sorted_flights = sort_flights(flights, \\"FlightNumber\\") assert sorted_flights == [ [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ] def test_sort_by_destination(): flights = [ [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ] sorted_flights = sort_flights(flights, \\"Destination\\") assert sorted_flights == [ [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"] ] def test_sort_by_departure_time(): flights = [ [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ] sorted_flights = sort_flights(flights, \\"DepartureTime\\") assert sorted_flights == [ [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ] def test_sort_by_arrival_time(): flights = [ [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"] ] sorted_flights = sort_flights(flights, \\"ArrivalTime\\") assert sorted_flights == [ [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"FB567\\", \\"Paris\\", \\"10:00\\", \\"13:30\\"], [\\"AA321\\", \\"Tokyo\\", \\"08:30\\", \\"14:00\\"] ] def test_invalid_sort_key(): flights = [ [\\"AA123\\", \\"NewYork\\", \\"08:30\\", \\"12:50\\"], [\\"BA456\\", \\"London\\", \\"09:10\\", \\"11:30\\"], [\\"CA789\\", \\"LosAngeles\\", \\"07:45\\", \\"10:30\\"] ] try: sort_flights(flights, \\"InvalidKey\\") except ValueError as e: assert str(e) == \\"Invalid key for sorting.\\"","solution":"def sort_flights(flights, key): Sorts the list of flights based on the specified key. sort_keys = {'FlightNumber': 0, 'Destination': 1, 'DepartureTime': 2, 'ArrivalTime': 3} if key not in sort_keys: raise ValueError(\\"Invalid key for sorting.\\") key_index = sort_keys[key] sorted_flights = sorted(flights, key=lambda flight: flight[key_index]) return sorted_flights"},{"question":"def max_visitors(n, visitors, capacities, corridors): Determine the maximum number of visitors that can simultaneously tour the museum without violating the room capacities and corridor widths. Args: n (int): The number of rooms. visitors (int): The total number of visitors. capacities (List[int]): The capacities of each room. corridors (List[Tuple[int, int, int]]): The corridors between rooms with their widths. Returns: int: The maximum number of visitors. Examples: >>> max_visitors(4, 10, [5, 7, 4, 6], [(1, 2, 3), (1, 3, 5), (2, 4, 4)]) 3 >>> max_visitors(3, 15, [8, 3, 7], [(1, 2, 6), (1, 3, 7)]) 3","solution":"def max_visitors(n, visitors, capacities, corridors): # Let's take the minimum of the room capacities and the corridor widths min_capacity = min(capacities) min_corridor = min([c[2] for c in corridors]) # The maximum number of visitors is the minimum of the total visitors and the smallest capacity or corridor width return min(visitors, min(min_capacity, min_corridor)) # Example usage: # n = 4 # visitors = 10 # capacities = [5, 7, 4, 6] # corridors = [(1, 2, 3), (1, 3, 5), (2, 4, 4)] # print(max_visitors(n, visitors, capacities, corridors)) # Output: 3"},{"question":"def is_one_edit_distance(s: str, t: str) -> str: Determine if string 't' can be generated from string 's' using exactly one edit operation. >>> is_one_edit_distance(\\"abac\\", \\"abc\\") \\"NO\\" >>> is_one_edit_distance(\\"abcd\\", \\"abcds\\") \\"YES\\" >>> is_one_edit_distance(\\"abc\\", \\"abx\\") \\"YES\\" >>> is_one_edit_distance(\\"abc\\", \\"bcd\\") \\"NO\\"","solution":"def is_one_edit_distance(s, t): Returns whether t can be generated from s by exactly one edit operation. len_s, len_t = len(s), len(t) if abs(len_s - len_t) > 1: return \\"NO\\" # Ensure s is the shorter one if len_s > len_t: s, t = t, s len_s, len_t = len_t, len_s found_difference = False i, j = 0, 0 while i < len_s and j < len_t: if s[i] != t[j]: if found_difference: return \\"NO\\" found_difference = True # If lengths are different, move pointer in the longer string if len_s < len_t: j += 1 else: i += 1 j += 1 else: i += 1 j += 1 return \\"YES\\" if found_difference or len_s < len_t else \\"NO\\""},{"question":"def minimum_total_travel_distance(test_cases): Determine the minimum total travel distance Jane would have to cover for each test case. Args: test_cases (List[List[int]]): A list of test cases, each containing a list of points on the number line. Returns: List[int]: A list of minimum total travel distances for each test case. >>> minimum_total_travel_distance([[2, 10, 6], [7, 5, 2, 9]]) [8, 7] >>> minimum_total_travel_distance([[3, 3, 3]]) [0] >>> minimum_total_travel_distance([[1, 1000000000, 500000000, 1000000, 700000000]]) [999999999] >>> minimum_total_travel_distance([[100]]) [0] pass def parse_input(input_data): Parse input data into a list of test cases. Args: input_data (str): A string containing the number of test cases and the points on the number line. Returns: List[List[int]]: A list of test cases, each containing a list of points on the number line. >>> parse_input(\\"2n3n2 10 6n4n7 5 2 9n\\") [[2, 10, 6], [7, 5, 2, 9]] >>> parse_input(\\"1n3n3 3 3n\\") [[3, 3, 3]] >>> parse_input(\\"1n5n1 1000000000 500000000 1000000 700000000n\\") [[1, 1000000000, 500000000, 1000000, 700000000]] >>> parse_input(\\"1n1n100n\\") [[100]] pass","solution":"def minimum_total_travel_distance(test_cases): results = [] for x_positions in test_cases: sorted_positions = sorted(x_positions) total_distance = sorted_positions[-1] - sorted_positions[0] results.append(total_distance) return results def parse_input(input_data): lines = input_data.strip().split('n') t = int(lines[0]) test_cases = [] for i in range(t): n = int(lines[2 * i + 1]) x_positions = list(map(int, lines[2 * i + 2].split())) test_cases.append(x_positions) return test_cases def handle_multiple_cases(input_data): test_cases = parse_input(input_data) results = minimum_total_travel_distance(test_cases) return results"},{"question":"def is_subsequence(str1: str, str2: str) -> bool: Check if a given string str1 is a subsequence of another string str2. >>> is_subsequence(\\"abc\\", \\"ahbgdc\\") True >>> is_subsequence(\\"axc\\", \\"ahbgdc\\") False >>> is_subsequence(\\"xyz\\", \\"xaybzct\\") True >>> is_subsequence(\\"abc\\", \\"ab\\") False","solution":"def is_subsequence(str1, str2): Check if str1 is a subsequence of str2. Parameters: str1 (str): The first string. str2 (str): The second string. Returns: bool: True if str1 is a subsequence of str2, otherwise False. iter_str2 = iter(str2) return all(char in iter_str2 for char in str1)"},{"question":"def firstUniqueChar(s: str) -> str: Returns the first unique character in the string, or '_' if there are no unique characters. >>> firstUniqueChar(\\"swiss\\") 'w' >>> firstUniqueChar(\\"relevel\\") 'r' >>> firstUniqueChar(\\"aabbcc\\") '_'","solution":"def firstUniqueChar(s): Returns the first unique character in the string, or '_' if there are no unique characters. from collections import Counter # Count the frequency of each character in the string count = Counter(s) # Find the first character with a frequency of 1 for char in s: if count[char] == 1: return char # If no unique character is found, return '_' return '_'"},{"question":"def find_connected_components(R: int, C: int, grid: List[str]) -> int: Returns the number of connected components of empty cells ('.') in the grid. Args: R (int): Number of rows in the grid. C (int): Number of columns in the grid. grid (List[str]): List of strings representing the grid. Returns: int: Number of connected components of empty cells in the grid. Example: >>> find_connected_components(4, 5, [\\".#..#\\", \\"#..#.\\", \\"#.#\\", \\"....#\\"]) 3 >>> find_connected_components(1, 1, [\\".\\"]) 1 >>> find_connected_components(1, 1, [\\"#\\"]) 0 >>> find_connected_components(3, 5, [\\".....\\", \\".....\\", \\".....\\"]) 1 >>> find_connected_components(3, 3, [\\"#.#\\", \\".#.\\", \\"#.#\\"]) 4 >>> find_connected_components(5, 5, [\\"..#..\\", \\".\\", \\"..#..\\", \\".\\", \\"..#..\\"]) 4","solution":"def find_connected_components(R, C, grid): Returns the number of connected components of empty cells ('.') in the grid. def dfs(r, c): # Directions to move in the grid (up, down, left, right) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] stack = [(r, c)] visited.add((r, c)) while stack: row, col = stack.pop() for dr, dc in directions: nr, nc = row + dr, col + dc if 0 <= nr < R and 0 <= nc < C and (nr, nc) not in visited and grid[nr][nc] == '.': stack.append((nr, nc)) visited.add((nr, nc)) visited = set() num_components = 0 for r in range(R): for c in range(C): if grid[r][c] == '.' and (r, c) not in visited: dfs(r, c) num_components += 1 return num_components"},{"question":"def is_toeplitz(matrix): Checks if a given matrix is a Toeplitz matrix. A Toeplitz matrix is one in which each descending diagonal from left to right is constant. :param matrix: List of lists, where each sublist represents a row of the matrix :return: \\"Toeplitz\\" if the matrix is a Toeplitz matrix, otherwise \\"not Toeplitz\\" >>> is_toeplitz([[1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2]]) 'Toeplitz' >>> is_toeplitz([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 'not Toeplitz' pass def test_is_toeplitz_example1(): matrix = [ [1, 2, 3, 4], [5, 1, 2, 3], [6, 5, 1, 2] ] assert is_toeplitz(matrix) == \\"Toeplitz\\" def test_is_toeplitz_example2(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert is_toeplitz(matrix) == \\"not Toeplitz\\" def test_is_toeplitz_single_row(): matrix = [ [1, 2, 3, 4] ] assert is_toeplitz(matrix) == \\"Toeplitz\\" def test_is_toeplitz_single_column(): matrix = [ [1], [2], [3], [4] ] assert is_toeplitz(matrix) == \\"Toeplitz\\" def test_is_toeplitz_single_element(): matrix = [ [1] ] assert is_toeplitz(matrix) == \\"Toeplitz\\" def test_is_toeplitz_with_false(): matrix = [ [1, 2, 3, 4], [5, 1, 2, 4], [6, 5, 1, 3] ] assert is_toeplitz(matrix) == \\"not Toeplitz\\"","solution":"def is_toeplitz(matrix): Checks if a given matrix is a Toeplitz matrix. :param matrix: List of lists, where each sublist represents a row of the matrix :return: \\"Toeplitz\\" if the matrix is a Toeplitz matrix, otherwise \\"not Toeplitz\\" rows = len(matrix) cols = len(matrix[0]) for row in range(1, rows): for col in range(1, cols): if matrix[row][col] != matrix[row - 1][col - 1]: return \\"not Toeplitz\\" return \\"Toeplitz\\" # Example usage: # N, M = 3, 4 # matrix = [ # [1, 2, 3, 4], # [5, 1, 2, 3], # [6, 5, 1, 2] # ] # print(is_toeplitz(matrix)) # Output: Toeplitz"},{"question":"def task_scheduler(n, k): Generates a task scheduling plan for n days with k difficulty levels. Parameters: n (int): The number of days k (int): The number of difficulty levels Returns: List[List[int]]: A schedule with each day containing k unique difficulty levels. Example: >>> task_scheduler(3, 4) [[1, 2, 3, 4], [2, 3, 4, 1], [3, 4, 1, 2]] >>> task_scheduler(5, 3) [[1, 2, 3], [2, 3, 1], [3, 1, 2], [1, 2, 3], [2, 3, 1]]","solution":"def task_scheduler(n, k): Generates a task scheduling plan for n days with k difficulty levels. Parameters: n (int): The number of days k (int): The number of difficulty levels Returns: List[List[int]]: A schedule with each day containing k unique difficulty levels. schedule = [] base_day = list(range(1, k + 1)) for i in range(n): day_schedule = base_day[i % k:] + base_day[:i % k] schedule.append(day_schedule) return schedule"},{"question":"def calculate_average_speeds(test_cases): Calculate average speeds from the given test cases. Args: test_cases (List[Tuple[int, int]]): List of tuples containing distance (D) and time (T). Returns: List[float]: List of average speeds rounded to two decimal places. >>> calculate_average_speeds([(5000, 1500), (10000, 3600), (2000, 600)]) [3.33, 2.78, 3.33] >>> calculate_average_speeds([(10000, 4000)]) [2.50] def parse_input(input_string): Parse input string to extract the test cases. Args: input_string (str): Multiline string containing the number of test cases and each test case data. Returns: List[Tuple[int, int]]: List of tuples where each tuple consists of distance (D) and time (T). >>> parse_input(\\"3n5000 1500n10000 3600n2000 600\\") [(5000, 1500), (10000, 3600), (2000, 600)] >>> parse_input(\\"1n1000 10\\") [(1000, 10)] def format_output(speeds): Format the list of speeds into the required output format. Args: speeds (List[float]): List of average speeds. Returns: str: Multiline string of average speeds each on a new line. >>> format_output([3.33, 2.78, 3.33]) \\"3.33n2.78n3.33\\" >>> format_output([100.00, 40.00]) \\"100.00n40.00\\"","solution":"def calculate_average_speeds(test_cases): Returns a list of average speeds in m/s for given test cases. Each test case is a tuple (D, T) where D is the distance in meters and T is the time in seconds. average_speeds = [] for D, T in test_cases: average_speed = round(D / T, 2) average_speeds.append(average_speed) return average_speeds def parse_input(input_string): Parses the input string and returns the list of test cases. lines = input_string.strip().split('n') T = int(lines[0]) test_cases = [] for i in range(1, T + 1): D, T = map(int, lines[i].split()) test_cases.append((D, T)) return test_cases def format_output(speeds): Formats the output speed list into a string. return \\"n\\".join(f\\"{s:.2f}\\" for s in speeds)"},{"question":"def is_palindrome_possible(s: str) -> bool: Given a string s, return True if it is possible to rearrange the characters of s to form a palindrome, and False otherwise. >>> is_palindrome_possible(\\"civic\\") True >>> is_palindrome_possible(\\"ivicc\\") True >>> is_palindrome_possible(\\"hello\\") False >>> is_palindrome_possible(\\"aabb\\") True","solution":"def is_palindrome_possible(s): from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A string can be rearranged into a palindrome if at most one character has an odd frequency return odd_count <= 1"},{"question":"def reorderArray(arr, N): Reorders the array so that all odd numbers come before all even numbers while maintaining the relative order of odd and even numbers from the original array. Parameters: arr (list): List of integers N (int): Size of the list Returns: list: The reordered list >>> reorderArray([1, 2, 3, 4, 5, 6, 7], 7) [1, 3, 5, 7, 2, 4, 6] >>> reorderArray([10, 21, 4, 45, 66], 5) [21, 45, 10, 4, 66] >>> reorderArray([], 0) [] >>> reorderArray([1], 1) [1] >>> reorderArray([2], 1) [2] pass","solution":"def reorderArray(arr, N): Reorders the array so that all odd numbers come before all even numbers while maintaining the relative order of odd and even numbers from the original array. Parameters: arr (list): List of integers N (int): Size of the list Returns: list: The reordered list if not arr: return [] # Separate odd and even numbers while maintaining their relative order odd_numbers = [num for num in arr if num % 2 != 0] even_numbers = [num for num in arr if num % 2 == 0] # Combine odd and even numbers back together return odd_numbers + even_numbers"},{"question":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths that the robot can take to reach the bottom-right corner avoiding the obstacles. >>> grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] unique_paths_with_obstacles(grid) 2 >>> grid = [ [0, 1, 0], [0, 0, 0], [0, 0, 0] ] unique_paths_with_obstacles(grid) 3 >>> grid = [ [1, 1, 0], [0, 0, 0], [0, 0, 0] ] unique_paths_with_obstacles(grid) 0 pass","solution":"def unique_paths_with_obstacles(grid): Calculate the number of unique paths that the robot can take to reach the bottom-right corner avoiding the obstacles. if not grid or grid[0][0] == 1: return 0 m, n = len(grid), len(grid[0]) dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i - 1][j] if j > 0: dp[i][j] += dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"def navigate_grid(N, M, grid, instructions): Determines if the sequence of instructions leads to the bottom-right corner of the grid without hitting any obstacles. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param grid: List[List[int]], the grid representation :param instructions: str, the sequence of instructions :return: str, \\"YES\\" if the sequence leads to the bottom-right corner without hitting obstacles, otherwise \\"NO\\" pass def test_navigate_grid(): assert navigate_grid(3, 4, [ [0, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 0] ], 'DDRRRD') == \\"YES\\" assert navigate_grid(3, 3, [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ], 'DDRRUURR') == \\"NO\\" assert navigate_grid(1, 1, [ [0] ], '') == \\"YES\\" assert navigate_grid(2, 2, [ [0, 1], [0, 0] ], 'DR') == \\"YES\\" assert navigate_grid(2, 2, [ [0, 1], [0, 0] ], 'RD') == \\"NO\\"","solution":"def navigate_grid(N, M, grid, instructions): Determines if the sequence of instructions leads to the bottom-right corner of the grid without hitting any obstacles. :param N: int, number of rows in the grid :param M: int, number of columns in the grid :param grid: List[List[int]], the grid representation :param instructions: str, the sequence of instructions :return: str, \\"YES\\" if the sequence leads to the bottom-right corner without hitting obstacles, otherwise \\"NO\\" x, y = 0, 0 # Start at the top-left corner (0,0) for instruction in instructions: if instruction == 'U': if x > 0: x -= 1 elif instruction == 'D': if x < N - 1: x += 1 elif instruction == 'L': if y > 0: y -= 1 elif instruction == 'R': if y < M - 1: y += 1 # Check if the new position hits an obstacle if grid[x][y] == 1: return \\"NO\\" # Check if the final position is the bottom-right corner if x == N - 1 and y == M - 1: return \\"YES\\" return \\"NO\\""},{"question":"def process_queries(n: int, q: int, arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a list of queries, returns the sum of elements between indices x and y for each query (inclusive). :param n: int, size of the array :param q: int, number of queries :param arr: List[int], the array of integers :param queries: List[Tuple[int, int]], list of queries where each query is a tuple (x, y) representing indices :return: List[int], list of results for each query >>> process_queries(5, 3, [1, 2, 3, 4, 5], [(1, 3), (2, 4), (1, 5)]) [6, 9, 15] >>> process_queries(6, 2, [4, -1, 2, 3, 6, 1], [(2, 5), (1, 6)]) [10, 15]","solution":"def process_queries(n, q, arr, queries): Given an array of integers and a list of queries, returns the sum of elements between indices x and y for each query (inclusive). :param n: int, size of the array :param q: int, number of queries :param arr: List[int], the array of integers :param queries: List[Tuple[int, int]], list of queries where each query is a tuple (x, y) representing indices :return: List[int], list of results for each query # Initialize the prefix sum array prefix_sum = [0] * (n + 1) # Compute the prefix sum array for i in range(1, n + 1): prefix_sum[i] = prefix_sum[i - 1] + arr[i - 1] # Process each query results = [] for x, y in queries: results.append(prefix_sum[y] - prefix_sum[x - 1]) return results"},{"question":"def max_non_overlapping_meetings(N: int, meetings: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping meetings that can be scheduled in a single room. Args: N: int : Number of meetings meetings: List[Tuple[int, int]] : List of tuples containing start and end times of meetings Returns: int: Maximum number of non-overlapping meetings that can be scheduled in a single room Example: >>> max_non_overlapping_meetings(3, [(1, 3), (2, 5), (4, 6)]) 2 >>> max_non_overlapping_meetings(4, [(7, 9), (0, 1), (3, 5), (8, 10)]) 3 from solution import max_non_overlapping_meetings def test_max_non_overlapping_meetings_basic(): assert max_non_overlapping_meetings(3, [(1, 3), (2, 5), (4, 6)]) == 2 assert max_non_overlapping_meetings(4, [(7, 9), (0, 1), (3, 5), (8, 10)]) == 3 def test_max_non_overlapping_meetings_single(): assert max_non_overlapping_meetings(1, [(1, 3)]) == 1 def test_max_non_overlapping_meetings_overlapping(): assert max_non_overlapping_meetings(5, [(1, 4), (2, 3), (3, 5), (4, 7), (6, 8)]) == 3 def test_max_non_overlapping_meetings_no_overlap(): assert max_non_overlapping_meetings(4, [(0, 1), (2, 3), (4, 5), (6, 7)]) == 4 def test_max_non_overlapping_meetings_exact_overlap(): assert max_non_overlapping_meetings(3, [(1, 2), (2, 3), (3, 4)]) == 3","solution":"def max_non_overlapping_meetings(N, meetings): # Sort meetings based on their end time meetings.sort(key=lambda x: x[1]) count = 0 end_time = 0 for start, end in meetings: if start >= end_time: count += 1 end_time = end return count if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) meetings = [] for i in range(1, len(data), 2): meetings.append((int(data[i]), int(data[i+1]))) print(max_non_overlapping_meetings(N, meetings))"},{"question":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of unique non-overlapping substrings of length k in the input string s. Args: s (str): The input string. k (int): The length of the substrings to count. Returns: int: The number of unique non-overlapping substrings of length k in the input string. Examples: >>> count_unique_substrings(\\"abcdefabcdef\\", 3) 2 >>> count_unique_substrings(\\"abcabcabc\\", 3) 1 >>> count_unique_substrings(\\"aabbcc\\", 2) 3 >>> count_unique_substrings(\\"abcd\\", 5) 0","solution":"def count_unique_substrings(s: str, k: int) -> int: Counts the number of unique non-overlapping substrings of length k in the input string s. # Base case: if the length of the string is less than k if len(s) < k: return 0 # Using a set to store unique substrings unique_substrings = set() # Iterate over the string in steps of k for i in range(0, len(s) - k + 1, k): # Get the substring of length k substring = s[i:i + k] unique_substrings.add(substring) # Return the number of unique substrings return len(unique_substrings)"},{"question":"def min_containers(n: int, m: int, containers: List[int]) -> int: Determines the minimum number of containers needed so each guest gets exactly one full container. :param n: Number of guests :param m: Number of types of beverages :param containers: List of integers representing the number of containers available for each type of beverage :return: Minimum number of containers needed >>> min_containers(10, 3, [6, 3, 2]) 10 >>> min_containers(5, 4, [1, 2, 3, 1]) 5 >>> min_containers(5, 3, [2, 2, 2]) 5 >>> min_containers(100, 5, [20, 20, 20, 20, 20]) 100 >>> min_containers(10, 3, [1, 2, 3]) 6 >>> min_containers(15, 4, [5, 5, 3, 2]) 15 >>> min_containers(1, 1, [1]) 1 >>> min_containers(5, 0, []) 0 >>> min_containers(5, 1, [10]) 5","solution":"def min_containers(n, m, containers): Determines the minimum number of containers needed so each guest gets exactly one full container. :param n: Number of guests :param m: Number of types of beverages :param containers: List of integers representing the number of containers available for each type of beverage :return: Minimum number of containers needed containers.sort(reverse=True) total_containers = 0 for c in containers: total_containers += c if total_containers >= n: return n return total_containers"},{"question":"from typing import List def anagram_sort(lst: List[str]) -> List[List[str]]: Takes a list of strings and returns a new list where the strings are grouped into sublists of anagrams. The sublists are lexicographically sorted, and the subgroups themselves are also sorted lexicographically. Args: lst (List[str]): A list of strings to be grouped into anagrams. Returns: List[List[str]]: A list of lists containing grouped anagrams. Examples: >>> anagram_sort([\\"bat\\", \\"tab\\", \\"rat\\", \\"tar\\", \\"art\\", \\"cat\\", \\"tac\\"]) [[\\"art\\", \\"rat\\", \\"tar\\"], [\\"bat\\", \\"tab\\"], [\\"cat\\", \\"tac\\"]] >>> anagram_sort([\\"listen\\", \\"silent\\", \\"enlist\\", \\"inlets\\"]) [[\\"enlist\\", \\"inlets\\", \\"listen\\", \\"silent\\"]] >>> anagram_sort([\\"apple\\", \\"banana\\", \\"carrot\\"]) [[\\"apple\\"], [\\"banana\\"], [\\"carrot\\"]] >>> anagram_sort([\\"bat\\"]) [[\\"bat\\"]] >>> anagram_sort([]) [] >>> anagram_sort([\\"bat\\", \\"bat\\", \\"tab\\", \\"tab\\", \\"bat\\"]) [[\\"bat\\", \\"bat\\", \\"bat\\", \\"tab\\", \\"tab\\"]]","solution":"def anagram_sort(lst): Takes a list of strings and returns a new list where the strings are grouped into sublists of anagrams. The sublists are lexicographically sorted, and the subgroups themselves are also sorted lexicographically. from collections import defaultdict # Dictionary to store the anagrams anagrams = defaultdict(list) # Grouping anagrams together for word in lst: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) # Sorting each subgroup and then sorting the sublists based on the first word in each subgroup result = [sorted(anagram) for anagram in anagrams.values()] result.sort(key=lambda x: x[0]) return result"},{"question":"def minimal_partition_difference(N: int, weights: List[int]) -> int: Mary has a collection of stones, each with a specific positive integer weight. She wants to know if it is possible to partition her collection into two non-empty subsets such that the absolute difference between the sums of the weights of the two subsets is minimized. This function returns the minimal absolute difference. :param N: int, the number of stones :param weights: list of int, the weights of the stones :return: int, the minimal absolute difference >>> minimal_partition_difference(4, [1, 6, 11, 5]) 1 >>> minimal_partition_difference(3, [10, 20, 30]) 0 >>> minimal_partition_difference(2, [1, 2]) 1 >>> minimal_partition_difference(4, [5, 5, 5, 5]) 0 # Insert the logic here","solution":"def minimal_partition_difference(N, weights): Returns the minimal absolute difference between the sums of the weights of the two subsets. :param N: int, number of stones :param weights: list of int, weights of the stones :return: int, the minimal absolute difference total_sum = sum(weights) half_sum = total_sum // 2 # Create a DP array to store the possible sums we can achieve dp = [False] * (half_sum + 1) dp[0] = True # We can always have a sum of 0 by taking no elements # Update the DP array with the weights for weight in weights: for j in range(half_sum, weight - 1, -1): dp[j] = dp[j] or dp[j - weight] # Find the largest possible sum we can attain that is less than or equal to half_sum for j in range(half_sum, -1, -1): if dp[j]: return total_sum - 2 * j return total_sum # The worst case when no partitioning can be done"},{"question":"import re from collections import defaultdict def parse_record(record): Parse a single record string to count animal sightings. Args: record (str): A single record containing encoded sightings. Returns: dict: A dictionary with the count of each unique animal. Examples: >>> parse_record('a10b20c30') {'a': 10, 'b': 20, 'c': 30} >>> parse_record('a5b15c25a40') {'a': 45, 'b': 15, 'c': 25} >>> parse_record('z100y200z300') {'z': 400, 'y': 200} def combine_results(results): Combine the results into a specific string format. Args: results (list): A list of dictionaries with animal counts. Returns: list: A list of formatted result strings. Examples: >>> combine_results([{'a': 10, 'b': 20, 'c': 30}, {'a': 45, 'b': 15, 'c': 25}, {'z': 400, 'y': 200}]) ['a: 10, b: 20, c: 30', 'a: 45, b: 15, c: 25', 'z: 400, y: 200'] def process_records(records): Process multiple records to decode the animal sightings. Args: records (list): A list of record strings to process. Returns: list: A list of formatted result strings. Examples: >>> process_records(['a10b20c30', 'a5b15c25a40', 'z100y200z300']) ['a: 10, b: 20, c: 30', 'a: 45, b: 15, c: 25', 'z: 400, y: 200'] # Read input def main(): Read the input records and process them to print the results.","solution":"import re from collections import defaultdict def parse_record(record): pattern = re.compile(r'([a-z])(d+)') matches = pattern.findall(record) animal_counts = defaultdict(int) for animal, count in matches: animal_counts[animal] += int(count) return animal_counts def combine_results(results): combined = [] for result in results: combined.append(', '.join([f'{animal}: {count}' for animal, count in result.items()])) return combined def process_records(records): results = [] for record in records: animal_counts = parse_record(record) results.append(animal_counts) return combine_results(results) # Read input def main(): import sys input = sys.stdin.read data = input().strip().split('n') n = int(data[0]) records = data[1:n+1] results = process_records(records) for result in results: print(result)"},{"question":"def maxPathSum(grid: List[List[int]]) -> int: Calculate the maximum path sum from the top-left to the bottom-right of the grid. :param grid: List[List[int]] - 2D list of non-negative integers representing the grid. :return: int - the maximum sum possible along the path. Example: >>> maxPathSum([[0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1]]) 12 >>> maxPathSum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 import pytest from solution import maxPathSum def test_example_1(): grid = [ [0, 3, 1, 1], [2, 0, 0, 4], [1, 5, 3, 1] ] assert maxPathSum(grid) == 12 def test_example_2(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert maxPathSum(grid) == 29 def test_single_element(): grid = [[5]] assert maxPathSum(grid) == 5 def test_row_grid(): grid = [ [1, 2, 3, 4] ] assert maxPathSum(grid) == 10 def test_column_grid(): grid = [ [1], [2], [3], [4] ] assert maxPathSum(grid) == 10 def test_non_square_grid(): grid = [ [1, 2], [3, 4], [5, 6] ] assert maxPathSum(grid) == 15","solution":"def maxPathSum(grid): Calculate the maximum path sum from the top-left to the bottom-right of the grid. :param grid: List[List[int]] - 2D list of non-negative integers representing the grid :return: int - the maximum sum possible along the path if not grid or not grid[0]: return 0 rows = len(grid) cols = len(grid[0]) # Create a 2D dp list to store the maximum sum up to each cell dp = [[0] * cols for _ in range(rows)] # Initialize the starting point dp[0][0] = grid[0][0] # Fill the first row for j in range(1, cols): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, rows): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, rows): for j in range(1, cols): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[rows - 1][cols - 1]"},{"question":"from typing import List def sum_of_unique_elements(grid: List[List[int]]) -> int: Returns the sum of all unique elements in the grid. :param grid: list of list of integers representing the grid :return: sum of all unique elements in the grid pass def parse_input(input_str: str) -> List[List[int]]: Parses the input string to generate the grid :param input_str: str representing the grid input :return: grid as a list of lists pass def main_function(input_str: str) -> int: The main function that parses the input and computes the sum of unique elements. :param input_str: str representing the grid input :return: int representing the sum of unique elements in the grid pass def test_sum_of_unique_elements(): grid = [ [1, 2, 3], [4, 5, 6], [1, 2, 3] ] assert sum_of_unique_elements(grid) == 15 grid = [ [10] ] assert sum_of_unique_elements(grid) == 10 grid = [ [1, 2, 2], [3, 4, 4], [5, 6, 6] ] assert sum_of_unique_elements(grid) == 9 # unique: 1, 3, 5 grid = [ [-1, -2, -2], [-3, -4, -4], [-5, -6, -6] ] assert sum_of_unique_elements(grid) == -9 # unique: -1, -3, -5 def test_parse_input(): input_str = \\"3 3n1 2 3n4 5 6n1 2 3\\" expected_grid = [ [1, 2, 3], [4, 5, 6], [1, 2, 3] ] assert parse_input(input_str) == expected_grid def test_main_function(): input_str = \\"3 3n1 2 3n4 5 6n1 2 3\\" assert main_function(input_str) == 15 input_str = \\"1 1n10\\" assert main_function(input_str) == 10","solution":"def sum_of_unique_elements(grid): Returns the sum of all unique elements in the grid. :param grid: list of list of integers representing the grid :return: sum of all unique elements in the grid element_count = {} for row in grid: for element in row: if element in element_count: element_count[element] += 1 else: element_count[element] = 1 unique_elements_sum = sum(element for element, count in element_count.items() if count == 1) return unique_elements_sum def parse_input(input_str): Parses the input string to generate the grid :param input_str: str representing the grid input :return: grid as a list of lists lines = input_str.strip().split(\\"n\\") M, N = map(int, lines[0].split()) grid = [list(map(int, lines[i + 1].split())) for i in range(M)] return grid def main_function(input_str): grid = parse_input(input_str) return sum_of_unique_elements(grid)"},{"question":"def maximum_total_growth(n: int, m: int, k: int, grid: List[List[int]]) -> int: Returns the maximum total growth obtainable by selecting k plants with the highest growth rates. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. k (int): The number of plants to consider for maximum growth. grid (list of list of int): The growth rates of the plants in the grid. Returns: int: The maximum total growth of k plants. pass def test_maximum_total_growth_example1(): n, m, k = 3, 3, 3 grid = [ [0, 2, 3], [4, 0, 1], [0, 5, 6] ] assert maximum_total_growth(n, m, k, grid) == 15 def test_maximum_total_growth_example2(): n, m, k = 2, 2, 2 grid = [ [1, 2], [3, 4] ] assert maximum_total_growth(n, m, k, grid) == 7 def test_maximum_total_growth_all_zero(): n, m, k = 2, 2, 1 grid = [ [0, 0], [0, 0] ] assert maximum_total_growth(n, m, k, grid) == 0 def test_maximum_total_growth_with_zeros(): n, m, k = 3, 3, 2 grid = [ [0, 0, 1], [0, 2, 0], [3, 0, 0] ] assert maximum_total_growth(n, m, k, grid) == 5 def test_maximum_total_growth_single_cell(): n, m, k = 1, 1, 1 grid = [ [7] ] assert maximum_total_growth(n, m, k, grid) == 7 def test_maximum_total_growth_k_greater_than_nonzero_cells(): n, m, k = 3, 3, 5 grid = [ [0, 2, 0], [0, 3, 0], [0, 1, 0] ] assert maximum_total_growth(n, m, k, grid) == 6","solution":"def maximum_total_growth(n, m, k, grid): Returns the maximum total growth obtainable by selecting k plants with the highest growth rates. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. k (int): The number of plants to consider for maximum growth. grid (list of list of int): The growth rates of the plants in the grid. Returns: int: The maximum total growth of k plants. # Flatten the grid to get a list of growth rates. growth_rates = [grid[i][j] for i in range(n) for j in range(m)] # Sort the growth rates in descending order. growth_rates.sort(reverse=True) # Sum up the top k growth rates. max_growth = sum(growth_rates[:k]) return max_growth"},{"question":"def isAnagram(s1: str, s2: str) -> bool: Determines if two given strings are anagrams of each other. :param s1: First string :param s2: Second string :return: True if the strings are anagrams, False otherwise >>> isAnagram(\\"listen\\", \\"silent\\") True >>> isAnagram(\\"hello\\", \\"world\\") False >>> isAnagram(\\"aabbcc\\", \\"ccbbaa\\") True >>> isAnagram(\\"abc\\", \\"abcd\\") False >>> isAnagram(\\"a\\", \\"a\\") True >>> isAnagram(\\"a\\", \\"b\\") False >>> isAnagram(\\"\\", \\"\\") True >>> isAnagram(\\"a\\", \\"\\") False","solution":"def isAnagram(s1, s2): Determines if two given strings are anagrams of each other. :param s1: First string :param s2: Second string :return: True if the strings are anagrams, False otherwise # Early return if lengths differ if len(s1) != len(s2): return False # Sort the characters of both strings sorted_s1 = sorted(s1) sorted_s2 = sorted(s2) # Compare the sorted versions of the strings return sorted_s1 == sorted_s2"},{"question":"def exist(board, word): Check if the word exists in the grid. >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCCED\\") True >>> exist([['A','B','C','E'], ['S','F','C','S'], ['A','D','E','E']], \\"ABCB\\") False >>> exist([['A']], \\"A\\") True >>> exist([['A']], \\"B\\") False >>> exist([['A','B','C','E'], ['S','F','E','S'], ['A','D','E','E']], \\"ABCESEEEFS\\") True >>> exist([['A','A','A','A'], ['A','A','A','A'], ['A','A','A','A']], \\"AAAA\\") True pass","solution":"def exist(board, word): Check if the word exists in the grid. rows, cols = len(board), len(board[0]) def dfs(r, c, index): if index == len(word): return True if r < 0 or r >= rows or c < 0 or c >= cols or board[r][c] != word[index]: return False temp = board[r][c] board[r][c] = '#' found = (dfs(r + 1, c, index + 1) or dfs(r - 1, c, index + 1) or dfs(r, c + 1, index + 1) or dfs(r, c - 1, index + 1)) board[r][c] = temp return found for i in range(rows): for j in range(cols): if dfs(i, j, 0): return True return False"},{"question":"from typing import List def letterCombinations(digits: str) -> List[str]: Returns all possible letter combinations that the number could represent using the T9 phone keypad mapping. Args: digits (str): A string containing only digits ('2'-'9'). Returns: List[str]: A list of all possible letter combinations in lexicographical order. Examples: >>> letterCombinations(\\"23\\") [\\"ad\\", \\"ae\\", \\"af\\", \\"bd\\", \\"be\\", \\"bf\\", \\"cd\\", \\"ce\\", \\"cf\\"] >>> letterCombinations(\\"2\\") [\\"a\\", \\"b\\", \\"c\\"] >>> letterCombinations(\\"\\") [] >>> letterCombinations(\\"9\\") [\\"w\\", \\"x\\", \\"y\\", \\"z\\"] >>> letterCombinations(\\"234\\") [ \\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\" ] >>> letterCombinations(\\"29\\") [\\"aw\\", \\"ax\\", \\"ay\\", \\"az\\", \\"bw\\", \\"bx\\", \\"by\\", \\"bz\\", \\"cw\\", \\"cx\\", \\"cy\\", \\"cz\\"]","solution":"import itertools def letterCombinations(digits): Returns all possible letter combinations that the number could represent using the T9 phone keypad mapping. if not digits: return [] # Mapping digits to their respective letters phone = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } # Create a list of corresponding letters for each digit letters = [phone[digit] for digit in digits] # Generate all possible combinations combinations = [''.join(combo) for combo in itertools.product(*letters)] # Return combinations in lexicographical order return sorted(combinations)"},{"question":"def determine_winners(monster_strengths, wizard_powers): Determines which wizard defeats each monster according to their power levels. Parameters: - monster_strengths (list): A list of integers where the ith integer represents the strength of the ith monster. - wizard_powers (list): A list of integers where the ith integer represents the power level of the ith wizard. Returns: - list: A list where each element is either the 1-based index of the winning wizard or \\"NO WIZARD\\" if no wizard can defeat the corresponding monster. # Example test cases if __name__ == \\"__main__\\": monsters = [500, 1000, 3000] wizards = [600, 1200, 800, 4000] print(determine_winners(monsters, wizards)) # [1, 2, 4] monsters = [5000, 6000, 7000] wizards = [1000, 2000, 3000] print(determine_winners(monsters, wizards)) # [\\"NO WIZARD\\", \\"NO WIZARD\\", \\"NO WIZARD\\"] monsters = [500, 700, 600] wizards = [1000, 2000, 3000] print(determine_winners(monsters, wizards)) # [1, 1, 1] monsters = [1000, 200, 500] wizards = [500, 300, 1200] print(determine_winners(monsters, wizards)) # [3, 2, 3] monsters = [1000000] wizards = [999999] print(determine_winners(monsters, wizards)) # [\\"NO WIZARD\\"] monsters = [300] wizards = [400, 400, 400] print(determine_winners(monsters, wizards)) # [1] monsters = [] wizards = [500, 400] print(determine_winners(monsters, wizards)) # [] monsters = [300, 400] wizards = [] print(determine_winners(monsters, wizards)) # [\\"NO WIZARD\\", \\"NO WIZARD\\"]","solution":"def determine_winners(monster_strengths, wizard_powers): Determines which wizard defeats each monster according to their power levels. Parameters: - monster_strengths (list): A list of integers where the ith integer represents the strength of the ith monster. - wizard_powers (list): A list of integers where the ith integer represents the power level of the ith wizard. Returns: - list: A list where each element is either the 1-based index of the winning wizard or \\"NO WIZARD\\" if no wizard can defeat the corresponding monster. # Sort wizrds' power levels with original indexes indexed_wizards = sorted((power, i + 1) for i, power in enumerate(wizard_powers)) result = [] for strength in monster_strengths: # Try to find the lowest power level wizard that can defeat the monster. index = next((index for power, index in indexed_wizards if power > strength), None) if index is None: result.append(\\"NO WIZARD\\") else: result.append(index) return result"},{"question":"def leftmost_occurrence(s: str, c: str) -> int: Finds the leftmost occurrence of the character c in the string s. The search is case-insensitive. :param s: str :param c: str :return: int >>> leftmost_occurrence(\\"hello\\", 'l') 2 >>> leftmost_occurrence(\\"Programming\\", 'G') 3 >>> leftmost_occurrence(\\"OpenAI\\", 'a') 4","solution":"def leftmost_occurrence(s, c): Finds the leftmost occurrence of the character c in the string s. The search is case-insensitive. :param s: str :param c: str :return: int s_lower = s.lower() c_lower = c.lower() return s_lower.find(c_lower)"},{"question":"def find_number_of_groups(T, test_cases): Determine the number of groups of items based on unique attribute values. Args: T: int, number of test cases. test_cases: list of tuples, each containing: - N: int, number of items. - item_ids: list of N integers, item IDs. - attribute_values: list of N integers, attribute values corresponding to item IDs. Returns: list of integers, each representing the number of unique attribute value groups per test case.","solution":"def find_number_of_groups(T, test_cases): Determines the number of groups of items based on unique attribute values. Args: T: int, number of test cases. test_cases: list of tuples, each containing: - N: int, number of items. - item_ids: list of N integers, item IDs. - attribute_values: list of N integers, attribute values corresponding to item IDs. Returns: list of integers, each representing the number of unique attribute value groups per test case. results = [] for i in range(T): _, item_ids, attribute_values = test_cases[i] unique_groups = len(set(attribute_values)) results.append(unique_groups) return results"},{"question":"def min_lighthouses(n: int, schedules: List[Tuple[int, int]]) -> int: Determines the minimum number of lighthouses needed to cover the maximum possible duration of time with optimal use of lighthouses. :param n: Integer, number of lighthouses :param schedules: List of tuples, each containing two integers (start, end) representing the activation schedule of a lighthouse. :return: Integer, minimum number of lighthouses needed >>> min_lighthouses(6, [(1, 5), (2, 6), (3, 9), (4, 10), (6, 7), (8, 11)]) == 3 >>> min_lighthouses(1, [(1, 2)]) == 1 >>> min_lighthouses(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> min_lighthouses(3, [(1, 10), (2, 9), (3, 8)]) == 1 >>> min_lighthouses(3, [(1, 4), (3, 5), (5, 6)]) == 2 >>> min_lighthouses(2, [(1, 2), (3, 4)]) == 2 >>> min_lighthouses(5, [(1, 3), (2, 5), (4, 6), (7, 10), (8, 11)]) == 3","solution":"def min_lighthouses(n, schedules): Determines the minimum number of lighthouses needed to cover the maximum possible duration of time with optimal use of lighthouses. :param n: Integer, number of lighthouses :param schedules: List of tuples, each containing two integers (start, end) representing the activation schedule of a lighthouse. :return: Integer, minimum number of lighthouses needed # Sort the lighthouses by their end time schedules.sort(key=lambda x: x[1]) end_time = 0 count = 0 for start, end in schedules: if start >= end_time: end_time = end count += 1 return count"},{"question":"from typing import List def nonConsecutiveSubsequence(arr: List[int]) -> int: Given an array of integers, find the length of the longest subsequence that contains no two consecutive integers. >>> nonConsecutiveSubsequence([4, 3, 7, 4, 8]) 3 >>> nonConsecutiveSubsequence([1, 2, 3, 4, 5]) 1 >>> nonConsecutiveSubsequence([5, 10, 15, 20, 25]) 5 pass def process_cases(cases: List[List[int]]) -> List[int]: Process multiple test cases to find the longest subsequence that contains no two consecutive integers. >>> process_cases([[4, 3, 7, 4, 8], [1, 2, 3, 4, 5], [5, 10, 15, 20, 25]]) [3, 1, 5] pass","solution":"def nonConsecutiveSubsequence(arr): if not arr: return 0 sorted_arr = sorted(arr) longest_subseq = [sorted_arr[0]] for i in range(1, len(sorted_arr)): if sorted_arr[i] != sorted_arr[i - 1] + 1: longest_subseq.append(sorted_arr[i]) return len(longest_subseq) def process_cases(cases): results = [] for case in cases: result = nonConsecutiveSubsequence(case) results.append(result) return results"},{"question":"def bouncing_search_sort(arr: List[int]) -> List[int]: Little Dani is learning about sorting algorithms in her programming class and wants to test her understanding by solving a practical problem. She has a list of integers and she needs to sort them using a specific sorting algorithm called \\"Bouncing Search Sort\\". This sorting algorithm works as follows: 1. Start from the first element of the list. 2. Compare it with the next element. If the current element is greater than the next element, swap them. 3. Move to the next element and repeat the comparison and swap process until you reach the end of the list. 4. Once you reach the end of the list, bounce back to the beginning of the list and repeat steps 2-3. However, instead of moving to the next element, you move to the previous element after each comparison. 5. Continue the process of moving forward through the list and bouncing back until the list is sorted. The algorithm stops when no swaps are made during a complete forward and backward traversal of the list. Write a function \`bouncing_search_sort\` that takes a list of integers and sorts it using the \\"Bouncing Search Sort\\" algorithm. >>> bouncing_search_sort([4, 2, 1, 3]) [1, 2, 3, 4] >>> bouncing_search_sort([5, 1, 4, 2, 3]) [1, 2, 3, 4, 5] from typing import List def bouncing_search_sort(arr: List[int]) -> List[int]: pass def test_bouncing_search_sort_regular_case(): assert bouncing_search_sort([4, 2, 1, 3]) == [1, 2, 3, 4] def test_bouncing_search_sort_mixed_case(): assert bouncing_search_sort([5, 1, 4, 2, 3]) == [1, 2, 3, 4, 5] def test_bouncing_search_sort_empty_list(): assert bouncing_search_sort([]) == [] def test_bouncing_search_sort_single_element(): assert bouncing_search_sort([1]) == [1] def test_bouncing_search_sort_sorted_list(): assert bouncing_search_sort([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5] def test_bouncing_search_sort_reverse_sorted_list(): assert bouncing_search_sort([5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5] def test_bouncing_search_sort_duplicates(): assert bouncing_search_sort([4, 3, 2, 3, 2, 1, 4, 5]) == [1, 2, 2, 3, 3, 4, 4, 5]","solution":"def bouncing_search_sort(arr): if not arr: return [] n = len(arr) is_sorted = False while not is_sorted: is_sorted = True for i in range(n - 1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False if is_sorted: break is_sorted = True for i in range(n - 2, -1, -1): if arr[i] > arr[i + 1]: arr[i], arr[i + 1] = arr[i + 1], arr[i] is_sorted = False return arr"},{"question":"from typing import List def group_anagrams(words: List[str]) -> List[List[str]]: Groups anagrams from the list of words. :param words: List of strings to be grouped by anagram :return: List of lists containing grouped anagrams >>> group_anagrams([\\"eat\\", \\"tea\\", \\"tan\\", \\"ate\\", \\"nat\\", \\"bat\\"]) [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']] >>> group_anagrams([\\"listen\\", \\"silent\\", \\"cinema\\", \\"iceman\\"]) [['listen', 'silent'], ['cinema', 'iceman']] >>> group_anagrams([\\"apple\\", \\"banana\\", \\"cherry\\"]) [['apple'], ['banana'], ['cherry']] >>> group_anagrams([\\"listen\\"]) [['listen']] >>> group_anagrams([]) [] def format_output(groups: List[List[str]]) -> str: Formats the output of the grouped anagrams. :param groups: List of lists containing grouped anagrams :return: Formatted string where each group is on a new line with words separated by spaces >>> format_output([['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]) 'eat tea atentan natnbat' >>> format_output([[\\"listen\\", \\"silent\\"]]) 'listen silent'","solution":"from collections import defaultdict def group_anagrams(words): Groups anagrams from the list of words. :param words: List of strings to be grouped by anagram :return: List of lists containing grouped anagrams anagrams = defaultdict(list) for word in words: sorted_word = ''.join(sorted(word)) anagrams[sorted_word].append(word) return list(anagrams.values()) def format_output(groups): Formats the output of the grouped anagrams. :param groups: List of lists containing grouped anagrams :return: Formatted string where each group is on a new line with words separated by spaces return 'n'.join(' '.join(group) for group in groups)"},{"question":"def categorize_employees(employee_years): Categorizes each employee based on their years of experience. Parameters: employee_years (list of int): List of years of experience for each employee. Returns: list of str: List of categories corresponding to each employee.","solution":"def categorize_employees(employee_years): Categorizes each employee based on their years of experience. Parameters: employee_years (list of int): List of years of experience for each employee. Returns: list of str: List of categories corresponding to each employee. categories = [] for years in employee_years: if years < 2: categories.append(\\"Junior\\") elif 2 <= years < 5: categories.append(\\"Mid-level\\") else: categories.append(\\"Senior\\") return categories"},{"question":"def equivalent_resistance(resistances, combination): Calculate the equivalent resistance for a list of resistances in either series or parallel combination. Parameters: resistances (list of float or int): List of resistance values. combination (str): Either \\"series\\" or \\"parallel\\" indicating the type of connection. Returns: float: The equivalent resistance rounded to 2 decimal places. pass from solution import equivalent_resistance def test_series_resistance(): assert equivalent_resistance([10, 20, 30], \\"series\\") == 60.00 assert equivalent_resistance([1, 1, 1], \\"series\\") == 3.00 assert equivalent_resistance([1.5, 2.5], \\"series\\") == 4.00 def test_parallel_resistance(): assert equivalent_resistance([10, 20, 30], \\"parallel\\") == 5.45 assert equivalent_resistance([1, 1, 1], \\"parallel\\") == 0.33 assert equivalent_resistance([1.5, 2.5], \\"parallel\\") == 0.94 def test_single_resistance(): assert equivalent_resistance([10], \\"series\\") == 10.00 assert equivalent_resistance([10], \\"parallel\\") == 10.00 def test_invalid_combination(): try: equivalent_resistance([10, 20, 30], \\"invalid\\") except ValueError as e: assert str(e) == \\"Invalid combination type; choose either 'series' or 'parallel'\\"","solution":"def equivalent_resistance(resistances, combination): Calculate the equivalent resistance for a list of resistances in either series or parallel combination. Parameters: resistances (list of float or int): List of resistance values. combination (str): Either \\"series\\" or \\"parallel\\" indicating the type of connection. Returns: float: The equivalent resistance rounded to 2 decimal places. if combination == \\"series\\": return round(sum(resistances), 2) elif combination == \\"parallel\\": return round(1 / sum(1 / r for r in resistances), 2) else: raise ValueError(\\"Invalid combination type; choose either 'series' or 'parallel'\\")"},{"question":"def letter_combinations(digits): Write a function that receives a string containing digits from '2' to '9' inclusive, and returns all possible letter combinations that the numbers could represent. Use the mapping of digits to letters (just like on the telephone buttons). The combinations should be returned in a list. The order of the combinations does not matter. Mapping of digits to letters: 2 -> \\"abc\\" 3 -> \\"def\\" 4 -> \\"ghi\\" 5 -> \\"jkl\\" 6 -> \\"mno\\" 7 -> \\"pqrs\\" 8 -> \\"tuv\\" 9 -> \\"wxyz\\" Example: >>> letter_combinations(\\"23\\") [\\"ad\\",\\"ae\\",\\"af\\",\\"bd\\",\\"be\\",\\"bf\\",\\"cd\\",\\"ce\\",\\"cf\\"] >>> letter_combinations(\\"9\\") [\\"w\\",\\"x\\",\\"y\\",\\"z\\"] >>> letter_combinations(\\"\\") [] >>> letter_combinations(\\"234\\") [ \\"adg\\", \\"adh\\", \\"adi\\", \\"aeg\\", \\"aeh\\", \\"aei\\", \\"afg\\", \\"afh\\", \\"afi\\", \\"bdg\\", \\"bdh\\", \\"bdi\\", \\"beg\\", \\"beh\\", \\"bei\\", \\"bfg\\", \\"bfh\\", \\"bfi\\", \\"cdg\\", \\"cdh\\", \\"cdi\\", \\"ceg\\", \\"ceh\\", \\"cei\\", \\"cfg\\", \\"cfh\\", \\"cfi\\" ] >>> letter_combinations(\\"79\\") [ \\"pw\\", \\"px\\", \\"py\\", \\"pz\\", \\"qw\\", \\"qx\\", \\"qy\\", \\"qz\\", \\"rw\\", \\"rx\\", \\"ry\\", \\"rz\\", \\"sw\\", \\"sx\\", \\"sy\\", \\"sz\\" ]","solution":"def letter_combinations(digits): Returns all possible letter combinations that the input digits could represent. if not digits: return [] digit_to_char = { '2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz' } def backtrack(index, path): if index == len(digits): combinations.append(\\"\\".join(path)) return possible_letters = digit_to_char[digits[index]] for letter in possible_letters: path.append(letter) backtrack(index + 1, path) path.pop() combinations = [] backtrack(0, []) return combinations"},{"question":"def mostFrequentWords(text: str, k: int) -> List[str]: Returns a list of the k most frequent words in the given text. The words are case insensitive and punctuation is ignored. >>> mostFrequentWords(\\"The cat in the hat. The cat likes the hat!\\", 2) ['the', 'cat'] >>> mostFrequentWords(\\"It was the best of times, it was the worst of times.\\", 3) ['times', 'it', 'of'] >>> mostFrequentWords(\\"Hello world! Hello universe. World says hello.\\", 1) ['hello']","solution":"from collections import Counter import re def mostFrequentWords(text, k): Returns the k most frequent words in the given text. The words are case insensitive, and punctuation is ignored. # Normalize the text by converting to lower case and removing punctuation text = text.lower() words = re.findall(r'bw+b', text) # Count the frequency of each word word_counts = Counter(words) # Sort the words by frequency and then lexicographically sorted_words = sorted(word_counts.items(), key=lambda x: (-x[1], x[0])) # Extract the top k words return [word for word, count in sorted_words[:k]]"},{"question":"def max_teams(N: int, X: int, skill_levels: List[int]) -> int: Returns the maximum number of teams that can be formed with the given constraints. Parameters: N (int): Number of participants. X (int): Maximum allowable difference in skill levels for two participants to form a team. skill_levels (List[int]): A list of skill levels for the participants. Returns: int: The maximum number of teams that can be formed. >>> max_teams(5, 3, [1, 5, 3, 4, 2]) == 2 >>> max_teams(4, 1, [10, 20, 30, 40]) == 0 >>> max_teams(4, 10, [1, 2, 3, 4]) == 2 >>> max_teams(6, 100, [50, 40, 60, 30, 70, 20]) == 3 >>> max_teams(1, 5, [10]) == 0 >>> max_teams(7, 2, [1, 2, 3, 4, 5, 6, 7]) == 3 >>> max_teams(4, 3, [1, 4, 7, 10]) == 2 from typing import List def test_example_case(): assert max_teams(5, 3, [1, 5, 3, 4, 2]) == 2 def test_no_teams_possible(): assert max_teams(4, 1, [10, 20, 30, 40]) == 0 def test_all_teams_possible(): assert max_teams(4, 10, [1, 2, 3, 4]) == 2 def test_large_X(): assert max_teams(6, 100, [50, 40, 60, 30, 70, 20]) == 3 def test_single_participant(): assert max_teams(1, 5, [10]) == 0 def test_odd_number_of_participants(): assert max_teams(7, 2, [1, 2, 3, 4, 5, 6, 7]) == 3 def test_pairs_with_exact_X_difference(): assert max_teams(4, 3, [1, 4, 7, 10]) == 2","solution":"def max_teams(N, X, skill_levels): Returns the maximum number of teams that can be formed with the given constraints. Parameters: N (int): Number of participants. X (int): Maximum allowable difference in skill levels for two participants to form a team. skill_levels (List[int]): A list of skill levels for the participants. Returns: int: The maximum number of teams that can be formed. skill_levels.sort() i = 0 teams = 0 while i < len(skill_levels) - 1: if skill_levels[i+1] - skill_levels[i] <= X: teams += 1 i += 2 # Skip the next one as they are already paired else: i += 1 return teams"},{"question":"def count_flowers_inside_garden(R: int, M: int, flower_positions: list[tuple[int, int]]) -> int: Returns the count of flowers inside a circular garden with radius R and center at the origin given M flower positions. Parameters: R (int): Radius of the circular garden. M (int): Number of flowers. flower_positions (list of tuples): Each tuple contains two integers representing x and y coordinates of a flower. Returns: int: The count of flowers inside the garden. Example: >>> count_flowers_inside_garden(5, 3, [(1, 1), (2, 4), (7, 0)]) 2 from solution import count_flowers_inside_garden def test_sample_input(): R, M = 5, 3 flower_positions = [(1, 1), (2, 4), (7, 0)] assert count_flowers_inside_garden(R, M, flower_positions) == 2 def test_all_flowers_inside(): R, M = 5, 3 flower_positions = [(1, 1), (2, 2), (0, 0)] assert count_flowers_inside_garden(R, M, flower_positions) == 3 def test_all_flowers_outside(): R, M = 5, 3 flower_positions = [(6, 6), (5, 5), (6, 0)] assert count_flowers_inside_garden(R, M, flower_positions) == 0 def test_some_flowers_inside(): R, M = 5, 4 flower_positions = [(3, 4), (5, 0), (2, 2), (6, 0)] assert count_flowers_inside_garden(R, M, flower_positions) == 3 def test_edge_case(): R, M = 5, 5 flower_positions = [(0, 5), (5, 0), (0, -5), (-5, 0), (3, 4)] assert count_flowers_inside_garden(R, M, flower_positions) == 5","solution":"def count_flowers_inside_garden(R, M, flower_positions): Returns the count of flowers inside a circular garden with radius R and center at the origin given M flower positions. Parameters: R (int): Radius of the circular garden. M (int): Number of flowers. flower_positions (list of tuples): Each tuple contains two integers representing x and y coordinates of a flower. Returns: int: The count of flowers inside the garden. count = 0 radius_squared = R * R for x, y in flower_positions: if x * x + y * y <= radius_squared: count += 1 return count"},{"question":"def kth_smallest_element(n: int, k: int, arr: List[int]) -> int: Finds the k-th smallest element in an unsorted array. Args: n: The size of the array. k: The position of the smallest element to find. arr: List of integers representing the array. Returns: The k-th smallest element in the array. >>> kth_smallest_element(5, 2, [3, 1, 5, 2, 4]) 2 >>> kth_smallest_element(7, 5, [10, 40, 20, 30, 50, 60, 70]) 50","solution":"def kth_smallest_element(n, k, arr): Returns the k-th smallest element in the array. arr.sort() return arr[k-1]"},{"question":"def sum_of_elements_greater_than_threshold(matrix, k): Given a matrix of integers, return the sum of elements greater than a given threshold k. If no elements exceed the threshold, return 0. >>> sum_of_elements_greater_than_threshold([ ... [1, 6, 3], ... [7, 2, 8], ... [-1, 9, 0], ... ], 5) 30 >>> sum_of_elements_greater_than_threshold([ ... [-4, -2], ... [-5, -1], ... ], -3) -3","solution":"def sum_of_elements_greater_than_threshold(matrix, k): Given a matrix of integers, return the sum of elements greater than a given threshold k. If no elements exceed the threshold, return 0. total_sum = 0 for row in matrix: for element in row: if element > k: total_sum += element return total_sum"},{"question":"def calculate_word_score(word: str) -> int: Returns the cumulative score of the given word based on the specified letter values. | Letter | Value | |---------|-------| | a, e, i, o, u, l, n, s, t, r | 1 | | d, g | 2 | | b, c, m, p | 3 | | f, h, v, w, y | 4 | | k | 5 | | j, x | 8 | | q, z | 10 | Args: word (str): A word consisting of uppercase and lowercase English letters. Returns: int: A single integer representing the cumulative score of the word. Examples: >>> calculate_word_score(\\"hello\\") 8 >>> calculate_word_score(\\"world\\") 9","solution":"def calculate_word_score(word): Returns the cumulative score of the given word based on the specified letter values. letter_values = { 'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1, 'l': 1, 'n': 1, 's': 1, 't': 1, 'r': 1, 'd': 2, 'g': 2, 'b': 3, 'c': 3, 'm': 3, 'p': 3, 'f': 4, 'h': 4, 'v': 4, 'w': 4, 'y': 4, 'k': 5, 'j': 8, 'x': 8, 'q': 10, 'z': 10 } word = word.lower() score = 0 for letter in word: score += letter_values.get(letter, 0) return score"},{"question":"def is_armstrong_number(n: int) -> bool: Write a function that takes as input a non-negative integer \`n\` and returns the sum of its digits raised to the power of the number of digits. If the number has 3 digits, each digit should be raised to the power of 3 and then summed together. Finally, the function should return \`True\` if this sum is equal to the original number, and \`False\` otherwise. >>> is_armstrong_number(153) == True >>> is_armstrong_number(9474) == True >>> is_armstrong_number(10) == False","solution":"def is_armstrong_number(n): Checks if a given number 'n' is an Armstrong number. Args: n (int): A non-negative integer. Returns: bool: True if 'n' is an Armstrong number, otherwise False. digits = [int(digit) for digit in str(n)] num_digits = len(digits) sum_of_powers = sum(digit ** num_digits for digit in digits) return sum_of_powers == n"},{"question":"def calculate_net_balance(transactions: List[Tuple[str, int]], initial_balance: int) -> Union[int, str]: Calculate the net balance given a list of transactions and an initial balance. >>> transactions = [('C', 1000), ('D', 500), ('D', 700)] >>> initial_balance = 2000 >>> calculate_net_balance(transactions, initial_balance) 800 >>> transactions = [('D', 3000), ('C', 200), ('D', 1300)] >>> initial_balance = 2500 >>> calculate_net_balance(transactions, initial_balance) \\"ERROR\\" pass # Unit tests def test_positive_balance(): transactions = [('C', 1000), ('D', 500), ('D', 700)] initial_balance = 2000 assert calculate_net_balance(transactions, initial_balance) == 1800 def test_balance_error(): transactions = [('D', 3000), ('C', 200), ('D', 1300)] initial_balance = 2500 assert calculate_net_balance(transactions, initial_balance) == \\"ERROR\\" def test_balance_zero_initial(): transactions = [('C', 500), ('D', 200), ('D', 300)] initial_balance = 0 assert calculate_net_balance(transactions, initial_balance) == 0 def test_balance_negative_initial(): transactions = [('C', 1000), ('D', 1500)] initial_balance = 0 assert calculate_net_balance(transactions, initial_balance) == \\"ERROR\\" def test_balance_with_no_transactions(): transactions = [] initial_balance = 1000 assert calculate_net_balance(transactions, initial_balance) == 1000 def test_all_credits(): transactions = [('C', 100), ('C', 200), ('C', 300)] initial_balance = 0 assert calculate_net_balance(transactions, initial_balance) == 600 def test_all_debits_but_no_negative(): transactions = [('D', 100), ('D', 200), ('D', 300)] initial_balance = 1000 assert calculate_net_balance(transactions, initial_balance) == 400 def test_exact_balance_depletion(): transactions = [('C', 1000), ('D', 1000)] initial_balance = 0 assert calculate_net_balance(transactions, initial_balance) == 0","solution":"def calculate_net_balance(transactions, initial_balance): Calculate the net balance given a list of transactions and an initial balance. Parameters: transactions (list of tuples): A list of transactions (type, amount) where 'type' is 'D' for Debit and 'C' for Credit. initial_balance (int): Starting balance Returns: int or str: Final balance if non-negative or \\"ERROR\\" if the balance becomes negative. balance = initial_balance for transaction in transactions: if transaction[0] == 'C': balance += transaction[1] elif transaction[0] == 'D': balance -= transaction[1] if balance < 0: return \\"ERROR\\" return balance"},{"question":"def min_difference(skills: List[int]) -> int: Alice wants to divide the players into two groups such that the absolute difference between the total skill levels of the two groups is minimized. Args: skills (List[int]): A list of integers where each integer represents the skill level of a player. Returns: int: The minimum absolute difference between the total skill levels of the two groups. Examples: >>> min_difference([1, 6, 11, 5]) 1 >>> min_difference([3, 1, 4, 2, 2]) 0","solution":"def min_difference(skills): total_sum = sum(skills) n = len(skills) dp = [[False for _ in range(total_sum // 2 + 1)] for _ in range(n + 1)] dp[0][0] = True for i in range(1, n + 1): for j in range(total_sum // 2 + 1): dp[i][j] = dp[i - 1][j] if j >= skills[i - 1]: dp[i][j] = dp[i][j] or dp[i - 1][j - skills[i - 1]] for j in range(total_sum // 2, -1, -1): if dp[n][j]: return total_sum - 2 * j return total_sum # Test the function with the example inputs print(min_difference([1, 6, 11, 5])) # Output: 1 print(min_difference([3, 1, 4, 2, 2])) # Output: 0"},{"question":"from collections import Counter, defaultdict def minWindow(S: str, T: str) -> str: Write a function that takes in two strings S and T, and returns the minimum window substring of S such that every character in T (including duplicates) is included in the window. If there is no such substring, return the empty string \\"\\". >>> minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") \\"BANC\\" >>> minWindow(\\"a\\", \\"a\\") \\"a\\" >>> minWindow(\\"a\\", \\"aa\\") \\"\\" pass import pytest def test_case_1(): assert minWindow(\\"ADOBECODEBANC\\", \\"ABC\\") == \\"BANC\\" def test_case_2(): assert minWindow(\\"a\\", \\"a\\") == \\"a\\" def test_case_3(): assert minWindow(\\"a\\", \\"aa\\") == \\"\\" def test_case_4(): assert minWindow(\\"AA\\", \\"A\\") == \\"A\\" def test_case_5(): assert minWindow(\\"ADOBECODEBANC\\", \\"XYZ\\") == \\"\\" def test_case_6(): assert minWindow(\\"ADOBECODEBANC\\", \\"\\") == \\"\\" def test_case_7(): assert minWindow(\\"\\", \\"ABC\\") == \\"\\" def test_case_8(): assert minWindow(\\"aaflslflsldkalskaaa\\", \\"aaa\\") == \\"aaa\\"","solution":"from collections import Counter, defaultdict def minWindow(S, T): Returns the minimum window substring of S such that every character in T (including duplicates) is included in the window. if not S or not T: return \\"\\" dictT = Counter(T) required = len(dictT) l, r = 0, 0 formed = 0 windowCounts = defaultdict(int) ans = float(\\"inf\\"), None, None while r < len(S): character = S[r] windowCounts[character] += 1 if character in dictT and windowCounts[character] == dictT[character]: formed += 1 while l <= r and formed == required: character = S[l] if r - l + 1 < ans[0]: ans = (r - l + 1, l, r) windowCounts[character] -= 1 if character in dictT and windowCounts[character] < dictT[character]: formed -= 1 l += 1 r += 1 return \\"\\" if ans[0] == float(\\"inf\\") else S[ans[1]: ans[2] + 1]"},{"question":"import math def largest_square_tile(n: int, m: int) -> int: Determine the side length of the largest square tile that can be used to cover the entire garden plot with dimensions \`n\` and \`m\`. If it is not possible to cover the plot completely using square tiles, return -1. >>> largest_square_tile(4, 6) 2 >>> largest_square_tile(3, 5) 1 >>> largest_square_tile(7, 3) 1","solution":"import math def largest_square_tile(n, m): Returns the largest possible side length of square tiles that can cover the entire garden plot with dimensions \`n\` and \`m\`. return math.gcd(n, m)"},{"question":"def can_become_palindrome(n: int, s: str) -> str: Determines if it's possible to make the string \`s\` a palindrome with exactly one operation. >>> can_become_palindrome(5, \\"abcba\\") == \\"YES\\" >>> can_become_palindrome(5, \\"abcca\\") == \\"YES\\" >>> can_become_palindrome(4, \\"abcd\\") == \\"NO\\" >>> can_become_palindrome(1, \\"a\\") == \\"YES\\" >>> can_become_palindrome(2, \\"aa\\") == \\"YES\\" >>> can_become_palindrome(2, \\"ab\\") == \\"NO\\" >>> can_become_palindrome(7, \\"racecar\\") == \\"YES\\" >>> can_become_palindrome(7, \\"racecad\\") == \\"NO\\"","solution":"def can_become_palindrome(n, s): Determines if it's possible to make the string \`s\` a palindrome with exactly one operation. def is_palindrome(sub): return sub == sub[::-1] if is_palindrome(s): return 'YES' for i in range(n): for j in range(i + 1, n): new_s = s[:i] + s[i:j + 1][::-1] + s[j + 1:] if is_palindrome(new_s): return 'YES' return 'NO'"},{"question":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous sublist within the given list of integers. Uses Kadane's algorithm to find the maximum subarray sum efficiently. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1","solution":"def max_subarray_sum(arr): Returns the maximum sum of a contiguous sublist within the given list of integers. Uses Kadane's algorithm to find the maximum subarray sum efficiently. max_sum = current_sum = arr[0] for num in arr[1:]: current_sum = max(num, current_sum + num) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def is_palindrome(s: str) -> str: Determines if the given string is a palindrome. Prints \\"YES\\" if the string is a palindrome, and \\"NO\\" otherwise. :param s: Input string :return: 'YES' if the string is a palindrome, otherwise 'NO' Examples: >>> is_palindrome(\\"radar\\") 'YES' >>> is_palindrome(\\"hello\\") 'NO' from solution import is_palindrome def test_palindrome(): assert is_palindrome(\\"radar\\") == \\"YES\\" assert is_palindrome(\\"hello\\") == \\"NO\\" assert is_palindrome(\\"a\\") == \\"YES\\" assert is_palindrome(\\"deified\\") == \\"YES\\" assert is_palindrome(\\"abba\\") == \\"YES\\" assert is_palindrome(\\"abc\\") == \\"NO\\" assert is_palindrome(\\"noon\\") == \\"YES\\" assert is_palindrome(\\"civic\\") == \\"YES\\" assert is_palindrome(\\"level\\") == \\"YES\\" assert is_palindrome(\\"world\\") == \\"NO\\"","solution":"def is_palindrome(s: str) -> str: Determines if the given string is a palindrome. :param s: Input string :return: 'YES' if the string is a palindrome, otherwise 'NO' if s == s[::-1]: return \\"YES\\" else: return \\"NO\\""},{"question":"class MedianTracker: def __init__(self): self.data = [] def add(self, x): Add an integer x to the array. pass def remove(self, x): Remove an integer x from the array. If x doesn't exist, do nothing. pass def median(self): Return the median of the array. If the array is empty, return 'Undefined'. pass def process_operations(operations): Process a list of operations and return a list of results for each operation. Each operation is either 'add x' or 'remove x'. Args: operations (List[str]): List of operations to process. Returns: List[Union[float, str]]: List of medians after each operation. >>> process_operations([\\"add 3\\", \\"add 1\\"]) [3.0, 2.0] >>> process_operations([\\"add 3\\", \\"add 1\\", \\"remove 1\\"]) [3.0, 2.0, 3.0] pass from solution import process_operations def test_add_operations(): operations = [\\"add 3\\", \\"add 1\\"] assert process_operations(operations) == [3.0, 2.0] def test_add_and_remove_operations(): operations = [\\"add 3\\", \\"add 1\\", \\"remove 1\\"] assert process_operations(operations) == [3.0, 2.0, 3.0] def test_all_operations(): operations = [\\"add 3\\", \\"add 1\\", \\"add 2\\", \\"remove 1\\", \\"remove 2\\"] assert process_operations(operations) == [3.0, 2.0, 2.0, 2.5, 3.0] def test_remove_nonexistent_element(): operations = [\\"add 3\\", \\"remove 5\\"] assert process_operations(operations) == [3.0, 3.0] def test_empty_after_removal(): operations = [\\"add 3\\", \\"remove 3\\"] assert process_operations(operations) == [3.0, \\"Undefined\\"]","solution":"import bisect class MedianTracker: def __init__(self): self.data = [] def add(self, x): bisect.insort_left(self.data, x) def remove(self, x): index = bisect.bisect_left(self.data, x) if index < len(self.data) and self.data[index] == x: self.data.pop(index) def median(self): if not self.data: return \\"Undefined\\" n = len(self.data) if n % 2 == 1: return float(self.data[n // 2]) else: return (self.data[n // 2 - 1] + self.data[n // 2]) / 2 def process_operations(operations): tracker = MedianTracker() result = [] for op in operations: if op.startswith(\\"add\\"): _, x = op.split() tracker.add(int(x)) elif op.startswith(\\"remove\\"): _, x = op.split() tracker.remove(int(x)) result.append(tracker.median()) return result"},{"question":"def has_pair_with_sum(prices: List[int], k: int) -> bool: Given an integer array representing prices of items in a store where each item price is between 1 and 1000 inclusive, returns true if there are two distinct items whose combined price is exactly k, otherwise returns false. >>> has_pair_with_sum([2, 1, 2], 3) True >>> has_pair_with_sum([500, 1000, 1500, 500, 1000], 2000) True >>> has_pair_with_sum([500, 1000, 1500], 3000) False","solution":"def has_pair_with_sum(prices, k): Given an array of integers representing prices and an integer k, returns True if there are two distinct items whose combined price is exactly k. price_set = set() for price in prices: complement = k - price if complement in price_set: return True price_set.add(price) return False"},{"question":"from collections import Counter def reverse_most_frequent(strings): Finds the most frequent element in the list and returns it with characters reversed. In case of a tie, returns the reversed version of the lexicographically smallest element. >>> reverse_most_frequent(['apple', 'banana', 'apple', 'cherry', 'banana', 'banana']) 'ananab' >>> reverse_most_frequent(['cat', 'dog', 'dog', 'cat', 'bird']) 'tac'","solution":"from collections import Counter def reverse_most_frequent(strings): Finds the most frequent element in the list and returns it with characters reversed. In case of a tie, returns the reversed version of the lexicographically smallest element. # Count the frequency of elements in the list freq_counter = Counter(strings) # Find the highest frequency max_freq = max(freq_counter.values()) # Filter elements with the max frequency candidates = [word for word, count in freq_counter.items() if count == max_freq] # Find the lexicographically smallest element among the candidates smallest = min(candidates) # Return the reversed smallest element return smallest[::-1]"},{"question":"def does_submatrix_exist(N, M, S, matrix): Determines if there exists a 2x2 submatrix whose elements sum to S. Parameters: N (int): Number of rows in the matrix. M (int): Number of columns in the matrix. S (int): The sum that we are checking for in the 2x2 submatrix. matrix (List[List[int]]): The matrix represented as a list of lists. Returns: str: \\"YES\\" if such a submatrix exists, \\"NO\\" otherwise. >>> does_submatrix_exist(3, 4, 30, [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]) \\"YES\\" >>> does_submatrix_exist(4, 5, 17, [[1, 3, 4, 1, 2], [4, 2, 1, 3, 4], [3, 4, 5, 2, 1], [9, 8, 7, 6, 1]]) \\"NO\\" # Your implementation here def process_test_cases(t, test_cases): Processes multiple test cases to determine if the 2x2 submatrix sum exists. Parameters: t (int): Number of test cases. test_cases (List[Tuple[Tuple[int, int, int], List[List[int]]]]): List containing tuples of test case parameters and matrices. Returns: List[str]: List of results for each test case with \\"YES\\" or \\"NO\\". >>> process_test_cases(3, [ [(3, 4, 30), [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]], [(2, 2, 40), [[8, 12], [7, 13]]], [(4, 5, 17), [[1, 3, 4, 1, 2], [4, 2, 1, 3, 4], [3, 4, 5, 2, 1], [9, 8, 7, 6, 1]]] ]) [\\"YES\\", \\"YES\\", \\"NO\\"] # Your implementation here","solution":"def does_submatrix_exist(N, M, S, matrix): Determines if there exists a 2x2 submatrix whose elements sum to S. Parameters: N (int): Number of rows in the matrix. M (int): Number of columns in the matrix. S (int): The sum that we are checking for in the 2x2 submatrix. matrix (List[List[int]]): The matrix represented as a list of lists. Returns: str: \\"YES\\" if such a submatrix exists, \\"NO\\" otherwise. for i in range(N - 1): for j in range(M - 1): submatrix_sum = matrix[i][j] + matrix[i][j+1] + matrix[i+1][j] + matrix[i+1][j+1] if submatrix_sum == S: return \\"YES\\" return \\"NO\\" def process_test_cases(t, test_cases): results = [] for i in range(t): N, M, S = test_cases[i][0] matrix = test_cases[i][1] result = does_submatrix_exist(N, M, S, matrix) results.append(result) return results"},{"question":"def minimize_max_travel_time(C, R, roads): In a kingdom, there are several cities connected by bidirectional roads. Each road has a specific travel time associated with it. The king wants to build a new road such that the maximum travel time between any two cities is minimized. This function calculates the minimum possible value of the maximum travel time between any two cities after adding exactly one new road. C: int - The number of cities R: int - The number of existing roads roads: List[Tuple[int, int, int]] - List of tuples where each tuple contains three integers u, v, and t representing a road between cities u and v that takes t units of time to travel. Returns: int - The minimum possible value of the maximum travel time between any two cities after adding one new road. >>> minimize_max_travel_time(4, 4, [(1, 2, 5), (2, 3, 10), (3, 4, 5), (1, 4, 15)]) == 10 >>> minimize_max_travel_time(3, 2, [(1, 2, 1), (2, 3, 1)]) == 1 >>> minimize_max_travel_time(3, 3, [(1, 2, 1), (2, 3, 1), (3, 1, 2)]) == 2 >>> minimize_max_travel_time(4, 5, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 1, 5), (2, 4, 1)]) == 3 >>> minimize_max_travel_time(5, 6, [(1, 2, 2), (2, 3, 2), (3, 4, 2), (4, 5, 2), (5, 1, 10), (1, 3, 5)]) == 4","solution":"import heapq def calculate_max_distances(adj_matrix, C): dist = [[float('inf')]*C for _ in range(C)] for i in range(C): for j in range(C): if i == j: dist[i][j] = 0 elif adj_matrix[i][j] != float('inf'): dist[i][j] = adj_matrix[i][j] for k in range(C): for i in range(C): for j in range(C): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def minimize_max_travel_time(C, R, roads): adj_matrix = [[float('inf')]*C for _ in range(C)] for u, v, t in roads: adj_matrix[u-1][v-1] = t adj_matrix[v-1][u-1] = t original_max_distances = calculate_max_distances(adj_matrix, C) original_max_travel_time = max(max(row) for row in original_max_distances) min_max_travel_time = original_max_travel_time for i in range(C): for j in range(i+1, C): if adj_matrix[i][j] == float('inf'): adj_matrix[i][j] = 0 adj_matrix[j][i] = 0 new_max_distances = calculate_max_distances(adj_matrix, C) max_travel_time = max(max(row) for row in new_max_distances) min_max_travel_time = min(min_max_travel_time, max_travel_time) adj_matrix[i][j] = float('inf') adj_matrix[j][i] = float('inf') return min_max_travel_time"},{"question":"def hasPairWithSum(arr: List[int], target: int) -> bool: Determines if there are two distinct elements in the list that add up to the target. Args: arr: List of integers target: Integer target sum Returns: Boolean indicating if there exists a pair of elements that sum to the target Examples: >>> hasPairWithSum([2, 7, 11, 15], 9) True >>> hasPairWithSum([1, 2, 3, 4], 8) False from typing import List import pytest def test_has_pair_with_sum(): assert hasPairWithSum([2, 7, 11, 15], 9) == True assert hasPairWithSum([1, 2, 3, 4], 8) == False assert hasPairWithSum([1, -1, 5, 10], 4) == True assert hasPairWithSum([1, 2, 3, 4, 5], 10) == False assert hasPairWithSum([0, 0, 0, 0], 0) == True assert hasPairWithSum([1], 1) == False # The edge case of minimal length assert hasPairWithSum([-1, -2, -3, -4, -5], -8) == True assert hasPairWithSum([1000000, 2000000, -1000000, -2000000], 0) == True assert hasPairWithSum([1, 9, -3, 5, 7], 2) == True assert hasPairWithSum([10, 20, 30, 40, 50], 100) == False","solution":"def hasPairWithSum(arr, target): Determines if there are two distinct elements in the list that add up to the target. Args: arr: List of integers target: Integer target sum Returns: Boolean indicating if there exists a pair of elements that sum to the target seen = set() for num in arr: if target - num in seen: return True seen.add(num) return False"},{"question":"def differingBitPosition(a: int, b: int) -> int: Given two positive integers a and b, find the position of the first differing bit in their binary representations when counted from the right (starting at 1). Return the position as an integer. If the integers are the same, return -1. >>> differingBitPosition(10, 12) 2 >>> differingBitPosition(4, 4) -1 >>> differingBitPosition(1, 2) 1 >>> differingBitPosition(7, 5) 2 >>> differingBitPosition(1024, 2048) 11 >>> differingBitPosition(123456789, 123456788) 1 >>> differingBitPosition(1, 0) 1","solution":"def differingBitPosition(a, b): Returns the position of the first differing bit in a and b. If a and b are the same, returns -1. if a == b: return -1 xor = a ^ b position = 1 while xor > 0: if xor & 1 == 1: return position xor >>= 1 position += 1 return -1"},{"question":"def is_palindrome(num: int) -> bool: Check if a given number is a palindrome. >>> is_palindrome(121) True >>> is_palindrome(123) False # Your code here def smallest_palindrome(N: int) -> int: Returns the smallest palindrome greater than or equal to N. >>> smallest_palindrome(28) 33 >>> smallest_palindrome(123) 131 >>> smallest_palindrome(8) 8 # Your code here from solution import smallest_palindrome def test_example1(): assert smallest_palindrome(28) == 33 def test_example2(): assert smallest_palindrome(123) == 131 def test_example3(): assert smallest_palindrome(8) == 8 def test_single_digit_palindrome(): assert smallest_palindrome(5) == 5 def test_near_palindrome(): assert smallest_palindrome(99) == 99 def test_large_number(): assert smallest_palindrome(999989) == 999999 def test_edge_case(): assert smallest_palindrome(1000000) == 1000001","solution":"def is_palindrome(num): Check if a given number is a palindrome. return str(num) == str(num)[::-1] def smallest_palindrome(N): Returns the smallest palindrome greater than or equal to N. while not is_palindrome(N): N += 1 return N"},{"question":"from typing import List, Tuple def min_jumps_to_cross_stones(T: int, test_cases: List[Tuple[Tuple[int, int], List[int], List[int]]]) -> List[int]: Determines the minimum number of jumps to cross the river on stones for each friend. Args: T : int : number of test cases test_cases : List[Tuple[Tuple[int, int], List[int], List[int]]] : A list containing tuples for each test case where the first element is a tuple of (N, M), the second element is a list of stone strengths, and the third element is a list containing a single integer W. Returns: List[int] : List of minimum jumps required for each test case, or -1 if not possible. >>> min_jumps_to_cross_stones(3, [((5, 2), [3, 2, 1, 4, 5], [2]), ((5, 3), [3, 2, 1, 4, 5], [3]), ((4, 1), [3, 2, 1, 4], [2])]) [3, 2, -1] pass def process_input(data: str) -> Tuple[int, List[Tuple[Tuple[int, int], List[int], List[int]]]]: Process the input data into the required format for the algorithm. Args: data : str : Input data as a single string Returns: Tuple[int, List[Tuple[Tuple[int, int], List[int], List[int]]]] : T, the number of test cases, and a list of test case tuples. >>> process_input(\\"3n5 2n3 2 1 4 5n2n5 3n3 2 1 4 5n3n4 1n3 2 1 4n2\\") (3, [((5, 2), [3, 2, 1, 4, 5], [2]), ((5, 3), [3, 2, 1, 4, 5], [3]), ((4, 1), [3, 2, 1, 4], [2])]) pass def solve(data: str) -> None: Solve the problem for the given input data and prints the results. Args: data : str : Input data as a single string >>> data = \\"3n5 2n3 2 1 4 5n2n5 3n3 2 1 4 5n3n4 1n3 2 1 4n2\\" >>> solve(data) 3 2 -1 pass def test_min_jumps_to_cross_stones(): data = \\"3n5 2n3 2 1 4 5n2n5 3n3 2 1 4 5n3n4 1n3 2 1 4n2\\" expected_output = [3, 2, -1] T, test_cases = process_input(data) assert min_jumps_to_cross_stones(T, test_cases) == expected_output data = \\"1n3 1n1 1 1n1\\" expected_output = [2] T, test_cases = process_input(data) assert min_jumps_to_cross_stones(T, test_cases) == expected_output data = \\"1n3 3n2 3 2n4\\" expected_output = [-1] T, test_cases = process_input(data) assert min_jumps_to_cross_stones(T, test_cases) == expected_output def test_process_input(): data = \\"3n5 2n3 2 1 4 5n2n5 3n3 2 1 4 5n3n4 1n3 2 1 4n2\\" T, test_cases = process_input(data) assert T == 3 assert test_cases == [((5, 2), [3, 2, 1, 4, 5], [2]), ((5, 3), [3, 2, 1, 4, 5], [3]), ((4, 1), [3, 2, 1, 4], [2])] def test_solve(capfd): data = \\"3n5 2n3 2 1 4 5n2n5 3n3 2 1 4 5n3n4 1n3 2 1 4n2\\" expected_output = \\"3n2n-1n\\" solve(data) out, err = capfd.readouterr() assert out == expected_output","solution":"def min_jumps_to_cross_stones(T, test_cases): results = [] for i in range(T): N, M = test_cases[i*3] strengths = test_cases[i*3 + 1] W = test_cases[i*3 + 2][0] if strengths[0] < W or strengths[-1] < W: results.append(-1) continue jumps = [float('inf')] * N jumps[0] = 0 for j in range(0, N): if strengths[j] >= W: for k in range(j + 1, min(N, j + M + 1)): if strengths[k] >= W: jumps[k] = min(jumps[k], jumps[j] + 1) result = jumps[-1] if jumps[-1] != float('inf') else -1 results.append(result) return results def process_input(data): lines = data.split('n') T = int(lines[0].strip()) test_cases = [] index = 1 for _ in range(T): test_cases.append(tuple(map(int, lines[index].strip().split()))) index += 1 test_cases.append(list(map(int, lines[index].strip().split()))) index += 1 test_cases.append([int(lines[index].strip())]) index += 1 return T, test_cases def solve(data): T, test_cases = process_input(data) results = min_jumps_to_cross_stones(T, test_cases) for result in results: print(result)"},{"question":"from typing import List, Tuple def count_pleasant_views(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given the number of test cases T and a list of test_cases each having N (number of buildings) and a list of building heights, this function returns a list with the count of buildings having a 'pleasant view' for each test case. # Your code here # Example usage: # count_pleasant_views(2, [(6, [3, 7, 8, 3, 6, 1]), (3, [1, 3, 2])]) should return [3, 2] # Tests def test_single_case_1(): T = 1 test_cases = [(6, [3, 7, 8, 3, 6, 1])] assert count_pleasant_views(T, test_cases) == [3] def test_single_case_2(): T = 1 test_cases = [(3, [1, 3, 2])] assert count_pleasant_views(T, test_cases) == [2] def test_multiple_cases(): T = 2 test_cases = [ (6, [3, 7, 8, 3, 6, 1]), (3, [1, 3, 2]) ] assert count_pleasant_views(T, test_cases) == [3, 2] def test_all_same_height(): T = 1 test_cases = [(4, [5, 5, 5, 5])] assert count_pleasant_views(T, test_cases) == [1] def test_decreasing_heights(): T = 1 test_cases = [(5, [5, 4, 3, 2, 1])] assert count_pleasant_views(T, test_cases) == [5] def test_increasing_heights(): T = 1 test_cases = [(5, [1, 2, 3, 4, 5])] assert count_pleasant_views(T, test_cases) == [1]","solution":"def count_pleasant_views(T, test_cases): Given the number of test cases T and a list of test_cases each having N (number of buildings) and a list of building heights, this function returns a list with the count of buildings having a 'pleasant view' for each test case. results = [] for i in range(T): N, buildings = test_cases[i] max_height = 0 pleasant_view_count = 0 # Traverse the list from the end to the start for height in reversed(buildings): if height > max_height: pleasant_view_count += 1 max_height = height results.append(pleasant_view_count) return results"},{"question":"def max_items(weight_limit: int, items: List[int]) -> int: Calculate the maximum number of items that can be packed without exceeding the weight limit. >>> max_items(10, [2, 3, 4, 5]) 3 >>> max_items(15, [1, 2, 8, 4, 5]) 4 # Your code here def solve_trip_packing(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Solves the trip packing problem for multiple test cases. >>> solve_trip_packing([(10, [2, 3, 4, 5]), (15, [1, 2, 8, 4, 5])]) [3, 4] # Your code here def process_input(input_string: str) -> List[Tuple[int, List[int]]]: Processes the input string and converts it into a list of test cases. >>> process_input(\\"2n10n4n2 3 4 5n15n5n1 2 8 4 5\\") [(10, [2, 3, 4, 5]), (15, [1, 2, 8, 4, 5])] # Your code here def process_output(output_list: List[int]) -> str: Converts the list of results into a formatted output string. >>> process_output([3, 4]) \\"3n4\\" # Your code here","solution":"def max_items(weight_limit, items): items.sort() current_weight = 0 count = 0 for weight in items: if current_weight + weight <= weight_limit: current_weight += weight count += 1 else: break return count def solve_trip_packing(test_cases): results = [] for case in test_cases: weight_limit, items = case result = max_items(weight_limit, items) results.append(result) return results # Example usage def process_input(input_string): input_lines = input_string.strip().split(\\"n\\") T = int(input_lines[0]) tests = [] index = 1 for _ in range(T): weight_limit = int(input_lines[index]) num_items = int(input_lines[index + 1]) items = list(map(int, input_lines[index + 2].split())) tests.append((weight_limit, items)) index += 3 return tests def process_output(output_list): return \\"n\\".join(map(str, output_list)) input_string = \\"2n10n4n2 3 4 5n15n5n1 2 8 4 5\\" test_cases = process_input(input_string) results = solve_trip_packing(test_cases) output_string = process_output(results) print(output_string) # Expected output: \\"3n4\\""},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Returns the length of the longest substring that contains at most two distinct characters. def longest_substring_with_two_distinct_chars(T: int, test_cases: list) -> list: Given an integer T representing the number of test cases and a list of strings test_cases, return a list of integers where each integer is the length of the longest substring that contains at most two distinct characters for each test case. from typed import List def test_length_of_longest_substring_two_distinct(): T = 2 test_cases = [\\"eceba\\", \\"ccaabbb\\"] assert longest_substring_with_two_distinct_chars(T, test_cases) == [3, 5] def test_single_character_strings(): T = 2 test_cases = [\\"a\\", \\"b\\"] assert longest_substring_with_two_distinct_chars(T, test_cases) == [1, 1] def test_all_same_characters(): T = 2 test_cases = [\\"aaaaa\\", \\"bbbbbb\\"] assert longest_substring_with_two_distinct_chars(T, test_cases) == [5, 6] def test_larger_example(): T = 1 test_cases = [\\"abcabcabc\\"] assert longest_substring_with_two_distinct_chars(T, test_cases) == [2] def test_edge_case_empty_string(): T = 1 test_cases = [\\"\\"] assert longest_substring_with_two_distinct_chars(T, test_cases) == [0]","solution":"def length_of_longest_substring_two_distinct(s): Returns the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n left, right = 0, 0 max_len = 2 hashmap = {} while right < n: if len(hashmap) < 3: hashmap[s[right]] = right right += 1 if len(hashmap) == 3: del_idx = min(hashmap.values()) del hashmap[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len def longest_substring_with_two_distinct_chars(T, test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"import itertools from typing import List def permute(nums: List[int]) -> List[List[int]]: Given an array of distinct integers, returns all possible unique permutations of the array in lexicographic order. >>> permute([1, 2, 3]) [ [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1] ] >>> permute([0, 1]) [ [0, 1], [1, 0] ] >>> permute([1]) [ [1] ] from solution import permute def test_permute_three_elements(): nums = [1, 2, 3] expected = [ (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1) ] assert permute(nums) == expected def test_permute_two_elements(): nums = [0, 1] expected = [ (0, 1), (1, 0) ] assert permute(nums) == expected def test_permute_single_element(): nums = [1] expected = [ (1,) ] assert permute(nums) == expected def test_permute_negative_elements(): nums = [-1, 2, 3] expected = [ (-1, 2, 3), (-1, 3, 2), (2, -1, 3), (2, 3, -1), (3, -1, 2), (3, 2, -1) ] assert permute(nums) == expected def test_permute_mixed_elements(): nums = [1, -1, 0] expected = [ (-1, 0, 1), (-1, 1, 0), (0, -1, 1), (0, 1, -1), (1, -1, 0), (1, 0, -1) ] assert permute(nums) == expected","solution":"import itertools def permute(nums): Returns all possible unique permutations of the array in lexicographic order. return sorted(list(itertools.permutations(nums)))"},{"question":"def can_partition(nums: List[int]) -> bool: Determine if the array can be divided into two subsets that have equal sums. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False","solution":"def can_partition(nums): Determine if the array can be divided into two subsets that have equal sums. total_sum = sum(nums) # If the total sum is odd, it's not possible to split it into two equal parts if total_sum % 2 != 0: return False target = total_sum // 2 # Use dynamic programming to check if we can find a subset with sum equal to target can_partition = [False] * (target + 1) can_partition[0] = True for num in nums: for i in range(target, num - 1, -1): if can_partition[i - num]: can_partition[i] = True return can_partition[target]"},{"question":"def can_assign_instruments(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if each band member can be assigned a unique number of instruments. Args: test_cases (List[Tuple[int, List[int]]]): The list of test cases, each being a tuple of number of members and a list of integers representing the number of instruments each band member can play. Returns: List[str]: The list of results for each test case, where each result is either \\"YES\\" followed by the modified array of instruments or \\"NO\\". >>> can_assign_instruments([(4, [1, 2, 2, 4]), (3, [5, 5, 5]), (5, [1, 3, 2, 5, 4])]) [\\"YES 1 2 3 4\\", \\"NO\\", \\"YES 1 2 3 4 5\\"]","solution":"def can_assign_instruments(test_cases): results = [] for case in test_cases: n, instruments = case instruments.sort() for i in range(1, n): if instruments[i] == instruments[i - 1]: instruments[i] += 1 if len(set(instruments)) == n: results.append(f\\"YES {' '.join(map(str, instruments))}\\") else: results.append(\\"NO\\") return results"},{"question":"def find_anagram_word(n: int, words: List[str], target: str) -> str: Finds the word from a list that can be rearranged (anagrammed) to form the target word. If multiple words can be anagrammed to form the target, it returns the one that appears first lexicographically. If no such word exists, returns \\"-1\\". :param n: int, number of words in the list :param words: list of str, the list of words :param target: str, the target word to form :return: str, the word that can be rearranged to form the target or \\"-1\\" if no such word exists >>> find_anagram_word(4, [\\"listen\\", \\"enlist\\", \\"google\\", \\"banana\\"], \\"silent\\") \\"enlist\\" >>> find_anagram_word(3, [\\"rat\\", \\"cat\\", \\"bat\\"], \\"tab\\") \\"bat\\" >>> find_anagram_word(2, [\\"hello\\", \\"world\\"], \\"python\\") \\"-1\\"","solution":"def find_anagram_word(n, words, target): Finds the word from a list that can be rearranged (anagrammed) to form the target word. If multiple words can be anagrammed to form the target, it returns the one that appears first lexicographically. If no such word exists, returns \\"-1\\". :param n: int, number of words in the list :param words: list of str, the list of words :param target: str, the target word to form :return: str, the word that can be rearranged to form the target or \\"-1\\" if no such word exists # Sort the target word to easily compare sorted_target = \\"\\".join(sorted(target)) # List to store anagram matches anagram_matches = [] for word in words: # Sort the word to compare if \\"\\".join(sorted(word)) == sorted_target: anagram_matches.append(word) # If no anagram is found, return \\"-1\\" if not anagram_matches: return \\"-1\\" # Return the first word lexicographically return min(anagram_matches)"},{"question":"def max_value_in_grid(n: int, m: int, updates: List[Tuple[int, int, int]]) -> int: Returns the maximum value in the grid after performing the updates. n: the size of the grid m: the number of updates updates: list of tuples containing update type (t), index (x), and increment value (v) >>> max_value_in_grid(3, 4, [(1, 0, 2), (2, 1, 3), (1, 2, -1), (2, 0, 4)]) 7 >>> max_value_in_grid(2, 1, [(1, 0, 5)]) 5 >>> max_value_in_grid(2, 1, [(2, 1, 3)]) 3 >>> max_value_in_grid(3, 0, []) 0 pass","solution":"def max_value_in_grid(n, m, updates): Returns the maximum value in the grid after performing the updates. # Initialize the grid with zeros grid = [[0] * n for _ in range(n)] # Apply each update for t, x, v in updates: if t == 1: # Row update for j in range(n): grid[x][j] += v elif t == 2: # Column update for i in range(n): grid[i][x] += v # Find the maximum value in the grid max_value = max(max(row) for row in grid) return max_value"},{"question":"from typing import List def canRearrange(s: str) -> str: Given a string s, determine if it can be rearranged in such a way that no two adjacent characters are the same. Return \\"YES\\" if it is possible to rearrange the string, otherwise return \\"NO\\". >>> canRearrange(\\"aab\\") \\"YES\\" >>> canRearrange(\\"aaab\\") \\"NO\\" pass def test_example_1(): assert canRearrange(\\"aab\\") == \\"YES\\" def test_example_2(): assert canRearrange(\\"aaab\\") == \\"NO\\" def test_single_character(): assert canRearrange(\\"a\\") == \\"YES\\" def test_two_different_characters(): assert canRearrange(\\"ab\\") == \\"YES\\" def test_two_same_characters(): assert canRearrange(\\"aa\\") == \\"NO\\" def test_equal_frequencies(): assert canRearrange(\\"abab\\") == \\"YES\\" def test_large_input(): s = \\"a\\" * 50000 + \\"b\\" * 50000 assert canRearrange(s) == \\"YES\\" def test_impossible_large_input(): s = \\"a\\" * 75001 + \\"b\\" * 24999 assert canRearrange(s) == \\"NO\\"","solution":"def canRearrange(s): Determine if string s can be rearranged so that no two adjacent characters are the same. from collections import Counter # Count frequency of each character freq = Counter(s) max_freq = max(freq.values()) # Check if the most frequent character can fit without adjacent duplicates if max_freq > (len(s) + 1) // 2: return \\"NO\\" return \\"YES\\""},{"question":"from typing import List, Dict, Tuple def can_rearrange_values(T: int, test_cases: List[Dict]) -> List[str]: Determine if the values on nodes can be rearranged to match the target values. Args: T : int : number of test cases test_cases : List[Dict] : list of dictionaries containing 'N', 'M', 'edges', 'a', and 'b' for each test case Returns: List[str] : list of \\"YES\\" or \\"NO\\" for each test case >>> can_rearrange_values(T, test_cases) [\\"YES\\", \\"YES\\", \\"YES\\"] pass def test_can_rearrange_values(): T = 3 test_cases = [ { 'N': 4, 'M': 2, 'edges': [(1, 2), (2, 3)], 'a': [10, 20, 30, 40], 'b': [20, 30, 10, 40], }, { 'N': 3, 'M': 0, 'edges': [], 'a': [10, 20, 30], 'b': [10, 20, 30], }, { 'N': 5, 'M': 4, 'edges': [(1, 2), (2, 3), (3, 4), (4, 5)], 'a': [1, 2, 3, 4, 5], 'b': [5, 4, 3, 2, 1], }, ] result = can_rearrange_values(T, test_cases) assert result == [\\"YES\\", \\"YES\\", \\"YES\\"] def test_non_reachable_state(): T = 1 test_cases = [ { 'N': 4, 'M': 2, 'edges': [(1, 2), (2, 3)], 'a': [10, 20, 30, 40], 'b': [40, 30, 20, 10], } ] result = can_rearrange_values(T, test_cases) assert result == [\\"NO\\"] def test_single_node_graph(): T = 1 test_cases = [ { 'N': 1, 'M': 0, 'edges': [], 'a': [10], 'b': [10], } ] result = can_rearrange_values(T, test_cases) assert result == [\\"YES\\"] def test_disconnected_graph(): T = 1 test_cases = [ { 'N': 6, 'M': 2, 'edges': [(1, 2), (4, 5)], 'a': [1, 2, 3, 4, 5, 6], 'b': [2, 1, 3, 5, 4, 6], } ] result = can_rearrange_values(T, test_cases) assert result == [\\"YES\\"]","solution":"def can_rearrange_values(T, test_cases): from sys import setrecursionlimit, stdin from collections import defaultdict, deque import sys input = stdin.read setrecursionlimit(10**6) # Helper function to perform DFS and collect nodes in the connected components def dfs(node, adj_list, visited, curr_component): stack = [node] while stack: node = stack.pop() if node not in visited: visited.add(node) curr_component.append(node) for neighbor in adj_list[node]: if neighbor not in visited: stack.append(neighbor) results = [] for i in range(T): N, M = test_cases[i]['N'], test_cases[i]['M'] edges = test_cases[i]['edges'] a = test_cases[i]['a'] b = test_cases[i]['b'] # Build adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u-1].append(v-1) adj_list[v-1].append(u-1) visited = set() components = [] for node in range(N): if node not in visited: curr_component = [] dfs(node, adj_list, visited, curr_component) components.append(curr_component) possible = True for component in components: a_values = [a[node] for node in component] b_values = [b[node] for node in component] if sorted(a_values) != sorted(b_values): possible = False break if possible: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def max_score(n: int, difficulties: List[int]) -> int: Determine the maximum score a team can achieve by the end of the tournament if they use the most optimal strategy. The function takes in an integer n, the number of problems, and a list of integers representing the difficulty levels of the problems. It returns an integer representing the maximum score the team can achieve. >>> max_score(3, [4, 7, 2]) 13 >>> max_score(1, [1000]) 1000 >>> max_score(5, [10, 10, 10, 10, 10]) 50 >>> max_score(2, [1, 1]) 2 >>> max_score(4, [4, 10, 7, 3]) 24","solution":"def max_score(n, difficulties): Returns the maximum score a team can achieve by solving all problems correctly on first attempt. return sum(difficulties)"},{"question":"def min_tree_adjustments(N: int, trees: List[int]) -> int: Returns the minimal total number of tree additions or subtractions required to make the tree counts unique in each park. Parameters: N (int): The number of parks. trees (List[int]): A list of integers representing the number of trees in each park. Returns: int: Minimal total number of additions or subtractions required. >>> min_tree_adjustments(3, [1, 2, 2]) 1 >>> min_tree_adjustments(5, [5, 5, 5, 5, 5]) 10 >>> min_tree_adjustments(4, [1, 3, 3, 1]) 2","solution":"def min_tree_adjustments(N, trees): Returns the minimal total number of tree additions or subtractions required to make the tree counts unique in each park. from collections import Counter tree_counts = Counter(trees) adjustments = 0 seen = set() for tree, count in sorted(tree_counts.items(), key=lambda item: -item[1]): while count > 1: count -= 1 new_tree_count = tree while new_tree_count in seen or new_tree_count in tree_counts: adjustments += 1 new_tree_count += 1 seen.add(new_tree_count) seen.add(tree) return adjustments"},{"question":"def longest_common_subsequence(X: str, Y: str) -> int: Returns the length of the longest common subsequence of X and Y. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcdef\\", \\"acf\\") 3 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"a\\", \\"a\\") 1 >>> longest_common_subsequence(\\"a\\", \\"b\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"axbxcxdx\\", \\"abcd\\") 4 >>> longest_common_subsequence(\\"aggtab\\", \\"gxtxayb\\") 4","solution":"def longest_common_subsequence(X, Y): Returns the length of the longest common subsequence of X and Y. m = len(X) n = len(Y) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (n + 1) for _ in range(m + 1)] # Build the dp array from bottom up. for i in range(m + 1): for j in range(n + 1): if i == 0 or j == 0: dp[i][j] = 0 elif X[i - 1] == Y[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n]"},{"question":"def longest_contiguous_distinct_subarray(n, arr): Returns the length of the longest contiguous subarray where all elements are distinct. Args: n (int): The number of elements in the sequence. arr (List[int]): The sequence of elements. Returns: int: The length of the longest contiguous subarray with distinct elements. Examples: >>> longest_contiguous_distinct_subarray(5, [1, 2, 1, 3, 2]) 3 >>> longest_contiguous_distinct_subarray(4, [1, 2, 3, 4]) 4 >>> longest_contiguous_distinct_subarray(5, [2, 2, 2, 2, 2]) 1 >>> longest_contiguous_distinct_subarray(7, [1, 2, 3, 4, 5, 1, 2]) 5 >>> longest_contiguous_distinct_subarray(6, [4, 5, 6, 7, 7, 8]) 4 >>> longest_contiguous_distinct_subarray(1, [1]) 1","solution":"def longest_contiguous_distinct_subarray(n, arr): Returns the length of the longest contiguous subarray where all elements are distinct. if n == 0: return 0 seen = {} start = 0 max_length = 0 for end in range(n): if arr[end] in seen: start = max(start, seen[arr[end]] + 1) seen[arr[end]] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def findOriginalSorted(arr, n): Given an array of N distinct integers, where the array has been rotated clockwise by some unknown number of positions (K), find the original sorted array. :param arr: List of integers representing the rotated array :param n: Integer representing the length of the array :return: List of integers representing the original sorted array Examples: >>> findOriginalSorted([5, 6, 7, 1, 2, 3, 4], 7) [1, 2, 3, 4, 5, 6, 7] >>> findOriginalSorted([8, 9, 1, 3, 4], 5) [1, 3, 4, 8, 9]","solution":"def findOriginalSorted(arr, n): Returns the original sorted array from the rotated array. :param arr: List of integers representing the rotated array :param n: Integer representing the length of the array :return: List of integers representing the original sorted array # Find the index of the smallest element which is the point of rotation min_index = arr.index(min(arr)) # Create the original sorted array by concatenating the subarrays original_sorted_array = arr[min_index:] + arr[:min_index] return original_sorted_array"},{"question":"def manhattan_distance(X: int, Y: int, Z: int, W: int) -> int: Returns the Manhattan distance between two points (X, Y) and (Z, W). >>> manhattan_distance(3, 4, 1, 2) 4 >>> manhattan_distance(0, 0, 0, 0) 0 >>> manhattan_distance(-1, -1, 1, 1) 4 >>> manhattan_distance(1000, 1000, -1000, -1000) 4000 >>> manhattan_distance(-500, -500, -500, -500) 0 >>> manhattan_distance(7, 0, -7, 0) 14 >>> manhattan_distance(0, -7, 0, 7) 14","solution":"def manhattan_distance(X, Y, Z, W): Returns the Manhattan distance between two points (X, Y) and (Z, W). return abs(X - Z) + abs(Y - W)"},{"question":"def max_power_in_range(n: int, P: List[int], queries: List[Tuple[int, int]]) -> List[int]: Calculate the maximum possible power level for each given range [A, B] of available colors. >>> max_power_in_range(6, [4, 2, 3, 8, 1, 5], [(1, 4), (2, 5), (3, 6)]) [17, 14, 17] >>> max_power_in_range(5, [1, 2, 3, 4, 5], [(1, 1), (5, 5), (1, 5)]) [1, 5, 15] >>> max_power_in_range(6, [4, 2, 3, 8, 1, 5], [(1, 6)]) [23] >>> max_power_in_range(3, [10**9, 10**9, 10**9], [(1, 2), (2, 3), (1, 3)]) [2*10**9, 2*10**9, 3*10**9] >>> max_power_in_range(5, [1, 3, 5, 7, 9], [(1, 3), (2, 4), (3, 5)]) [9, 15, 21]","solution":"def max_power_in_range(n, P, queries): result = [] for A, B in queries: max_power = sum(P[A-1:B]) result.append(max_power) return result # Sample Execution n = 6 P = [4, 2, 3, 8, 1, 5] queries = [(1, 4), (2, 5), (3, 6)] print(max_power_in_range(n, P, queries)) # Output: [17, 14, 17]"},{"question":"from typing import List, Tuple def min_max_workload(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given a number of test cases, determine the minimum possible maximum workload for employees after redistributing tasks optimally. Args: test_cases (List[Tuple[int, List[int]]]): A list of tuples where each tuple contains an integer representing the number of employees, and a list of integers representing the initial number of tasks assigned to each employee. Returns: List[int]: A list of integers representing the minimum possible maximum workload for each test case. Examples: >>> min_max_workload([(3, [2, 6, 4]), (2, [5, 9])]) [4, 7] >>> min_max_workload([(1, [7]), (1, [1])]) [7, 1] pass # Implement the function here","solution":"def min_max_workload(test_cases): import math results = [] for t in test_cases: m = t[0] b = t[1] avg = math.ceil(sum(b) / m) # Calculate the ceiling average of workloads results.append(avg) # This would be the minimum possible maximum workload. return results"},{"question":"def detect_negative_cycle(n, m, edges): Use the Bellman-Ford algorithm to detect any negative weight cycle in the graph. Parameters: n (int): Number of cities (nodes). m (int): Number of delivery routes (edges). edges (list of tuples): List of edges where each tuple (u, v, w) representing a route from node u to node v with weight w. Returns: str: \\"YES\\" if there is a negative weight cycle, otherwise \\"NO\\". >>> detect_negative_cycle(4, 4, [(1, 2, 1), (2, 3, -1), (3, 4, -1), (4, 2, -1)]) 'YES' >>> detect_negative_cycle(5, 5, [(1, 2, 3), (1, 3, 4), (2, 3, 2), (3, 4, 4), (4, 5, -10)]) 'NO' def test_detect_negative_cycle_positive(): n, m = 4, 4 edges = [(1, 2, 1), (2, 3, -1), (3, 4, -1), (4, 2, -1)] assert detect_negative_cycle(n, m, edges) == \\"YES\\" def test_detect_negative_cycle_negative(): n, m = 5, 5 edges = [(1, 2, 3), (1, 3, 4), (2, 3, 2), (3, 4, 4), (4, 5, -10)] assert detect_negative_cycle(n, m, edges) == \\"NO\\" def test_no_edges(): n, m = 1, 0 edges = [] assert detect_negative_cycle(n, m, edges) == \\"NO\\" def test_no_negative_cycle(): n, m = 3, 3 edges = [(1, 2, 1), (2, 3, 1), (3, 1, 1)] assert detect_negative_cycle(n, m, edges) == \\"NO\\" def test_single_negative_edge(): n, m = 2, 1 edges = [(1, 2, -1)] assert detect_negative_cycle(n, m, edges) == \\"NO\\" def test_single_node_with_self_loop(): n, m = 1, 1 edges = [(1, 1, -1)] assert detect_negative_cycle(n, m, edges) == \\"YES\\"","solution":"def detect_negative_cycle(n, m, edges): Use the Bellman-Ford algorithm to detect any negative weight cycle in the graph. Parameters: n (int): Number of cities (nodes). m (int): Number of delivery routes (edges). edges (list of tuples): List of edges where each tuple (u, v, w) representing a route from node u to node v with weight w. Returns: str: \\"YES\\" if there is a negative weight cycle, otherwise \\"NO\\". # Initialize distances with a large positive number dist = [float('inf')] * n dist[0] = 0 # We start by arbitrarily setting the distance to the first node to 0 # Relax edges up to n-1 times for _ in range(n - 1): for u, v, w in edges: if dist[u - 1] != float('inf') and dist[u - 1] + w < dist[v - 1]: dist[v - 1] = dist[u - 1] + w # Check for negative weight cycle for u, v, w in edges: if dist[u - 1] != float('inf') and dist[u - 1] + w < dist[v - 1]: return \\"YES\\" return \\"NO\\""},{"question":"def invertArray(arr): Returns the array with non-zero integers reversed and zeros in their original positions. Example 1: >>> invertArray([4, 0, 5, 0, 3, 2]) [2, 0, 3, 0, 5, 4] Example 2: >>> invertArray([0, 1, 0, 0, 2, 0]) [0, 2, 0, 0, 1, 0]","solution":"def invertArray(arr): Returns the array with non-zero integers reversed and zeros in their original positions. # Extract non-zero numbers non_zero_numbers = [num for num in arr if num != 0] # Reverse the non-zero numbers non_zero_numbers.reverse() # Replace non-zero elements in original array with reversed non-zero elements result = [] non_zero_index = 0 for num in arr: if num != 0: result.append(non_zero_numbers[non_zero_index]) non_zero_index += 1 else: result.append(0) return result"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestRootToLeafPath(root: TreeNode): Given a binary tree, return the longest path from root to any leaf node. >>> longestRootToLeafPath(TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5, TreeNode(8))), TreeNode(3))) [1, 2, 5, 8] >>> longestRootToLeafPath(TreeNode(10, TreeNode(20, TreeNode(40)), TreeNode(30, TreeNode(50, TreeNode(70)), TreeNode(60)))) [10, 30, 50, 70] >>> longestRootToLeafPath(TreeNode(1)) [1] >>> longestRootToLeafPath(TreeNode(1, TreeNode(2, TreeNode(3, TreeNode(4))))) [1, 2, 3, 4] >>> longestRootToLeafPath(TreeNode(1, None, TreeNode(2, None, TreeNode(3, None, TreeNode(4))))) [1, 2, 3, 4]","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def longestRootToLeafPath(root: TreeNode): def helper(node): if not node: return [] left_path = helper(node.left) right_path = helper(node.right) if len(left_path) > len(right_path): return [node.val] + left_path else: return [node.val] + right_path return helper(root)"},{"question":"def sort_primes(prime_list): Sort a list of prime numbers first by the number of digits, then by numerical order if the number of digits is the same. >>> sort_primes([2, 11, 3, 17, 7]) [2, 3, 7, 11, 17] >>> sort_primes([19, 3, 5, 23]) [3, 5, 19, 23] >>> sort_primes([101, 2, 19, 7, 29, 11, 13]) [2, 7, 11, 13, 19, 29, 101]","solution":"def sort_primes(prime_list): Sorts a list of prime numbers first by the number of digits, then by numerical order if the number of digits is the same. return sorted(prime_list, key=lambda x: (len(str(x)), x))"},{"question":"def has_pair_with_difference(N, D, A): Determines if there exists a pair of integers in the array A whose absolute difference is exactly D. Args: N (int): the number of elements in the array. D (int): the desired absolute difference. A (List[int]): the elements of the array. Returns: str: \\"YES\\" if such a pair exists, otherwise \\"NO\\". >>> has_pair_with_difference(5, 2, [1, 5, 3, 4, 2]) 'YES' >>> has_pair_with_difference(4, 0, [8, 3, 7, 3]) 'YES' >>> has_pair_with_difference(4, 10, [3, 1, 2, 9]) 'NO'","solution":"def has_pair_with_difference(N, D, A): Determines if there's a pair of integers in array A whose absolute difference is exactly D. seen = set(A) for number in A: if (number + D in seen) or (number - D in seen): return \\"YES\\" return \\"NO\\" def process_test_cases(T, test_cases): results = [] for i in range(T): N, D = test_cases[i][0] A = test_cases[i][1] result = has_pair_with_difference(N, D, A) results.append(result) return results def main(inputs): Takes input as specified and returns the results of each test case. inputs - list of strings representing the input, each element being a line. T = int(inputs[0]) test_cases = [] index = 1 for _ in range(T): N, D = map(int, inputs[index].split()) A = list(map(int, inputs[index + 1].split())) test_cases.append(((N, D), A)) index += 2 return process_test_cases(T, test_cases)"},{"question":"def cumulative_sum(lst): Computes the cumulative sum of a list of integers. Each element at index \`i\` in the output list is the sum of all elements from index \`0\` to \`i\` in the input list. >>> cumulative_sum([1, 2, 3, 4]) [1, 3, 6, 10] >>> cumulative_sum([4, 3, 2, 1]) [4, 7, 9, 10] >>> cumulative_sum([1, -1, 3, -3]) [1, 0, 3, 0] pass","solution":"def cumulative_sum(lst): Returns a new list where each element at index i is the sum of all elements from index 0 to i. Parameters: lst (List[int]): The input list of integers Returns: List[int]: A new list containing the cumulative sums result = [] current_sum = 0 for num in lst: current_sum += num result.append(current_sum) return result"},{"question":"def max_boxes_on_shelves(N: int, S: int, weights: List[int], capacities: List[int]) -> int: Calculate the maximum number of boxes that can be placed on shelves without exceeding their capacities. Parameters: N (int): Number of boxes. S (int): Number of shelves. weights (list of int): List of weights of each box. capacities (list of int): List of capacities of each shelf. Returns: int: Maximum number of boxes that can be placed on shelves. >>> max_boxes_on_shelves(5, 3, [2, 3, 4, 5, 9], [10, 10, 10]) 5 >>> max_boxes_on_shelves(3, 2, [5, 6, 7], [10, 10]) 2 pass # Unit tests def test_max_boxes_on_shelves_example(): assert max_boxes_on_shelves(5, 3, [2, 3, 4, 5, 9], [10, 10, 10]) == 5 def test_max_boxes_on_shelves_case1(): assert max_boxes_on_shelves(3, 2, [5, 6, 7], [10, 10]) == 2 def test_max_boxes_on_shelves_case2(): assert max_boxes_on_shelves(4, 3, [1, 2, 3, 4], [3, 5, 7]) == 4 def test_max_boxes_on_shelves_case3(): assert max_boxes_on_shelves(4, 2, [4, 5, 6, 7], [5, 10]) == 2 def test_max_boxes_on_shelves_case4(): assert max_boxes_on_shelves(6, 3, [1, 1, 1, 1, 1, 1], [3, 3, 3]) == 6 def test_max_boxes_on_shelves_case5(): assert max_boxes_on_shelves(5, 5, [5, 5, 5, 5, 5], [10, 10, 10, 10, 10]) == 5","solution":"def max_boxes_on_shelves(N, S, weights, capacities): Calculate the maximum number of boxes that can be placed on shelves without exceeding their capacities. Parameters: N (int): Number of boxes. S (int): Number of shelves. weights (list of int): List of weights of each box. capacities (list of int): List of capacities of each shelf. Returns: int: Maximum number of boxes that can be placed on shelves. # Sort the boxes in ascending order of their weights weights.sort() # Sort the shelves in ascending order of their capacities capacities.sort() box_count = 0 for weight in weights: for i in range(S): if capacities[i] >= weight: # Place the box on this shelf capacities[i] -= weight box_count += 1 break return box_count"},{"question":"def find_minimum_tour_length(N: int, lengths: List[List[int]]) -> int: Find the minimum possible total length of the route. The route is a tour that starts and ends at the same attraction while visiting every attraction exactly once. Args: N (int): Number of attractions. lengths (List[List[int]]): A matrix where the j-th integer of the i-th line denotes the length of the road between the i-th and the j-th attraction. Returns: int: The minimum possible total length of the route. Examples: >>> find_minimum_tour_length(4, [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ]) 80 >>> find_minimum_tour_length(2, [ [0, 5], [5, 0] ]) 10","solution":"from itertools import permutations def find_minimum_tour_length(N, lengths): def calculate_path_length(path): total_length = 0 for i in range(N): total_length += lengths[path[i]][path[(i + 1) % N]] return total_length attractions = list(range(N)) min_length = float('inf') for path in permutations(attractions[1:]): # Fix the starting point to reduce the permutations path = (0,) + path current_length = calculate_path_length(path) if current_length < min_length: min_length = current_length return min_length"},{"question":"def largest_uniform_submatrix_area(M: int, N: int, garden: List[List[int]]) -> int: Determine the size of the largest uniform submatrix filled with the same non-zero integer in the garden grid. >>> M, N = 4, 5 >>> garden = [ ... [1, 2, 2, 3, 3], ... [2, 2, 2, 3, 3], ... [2, 2, 2, 3, 3], ... [4, 4, 4, 4, 4] ... ] >>> largest_uniform_submatrix_area(M, N, garden) 6 >>> M, N = 3, 3 >>> garden = [ ... [1, 1, 1], ... [1, 0, 1], ... [1, 1, 1] ... ] >>> largest_uniform_submatrix_area(M, N, garden) 3","solution":"def largest_uniform_submatrix_area(M, N, garden): # This function will return the size of the largest submatrix with all cells containing the same non-zero integer max_area = 0 for i in range(M): for j in range(N): if garden[i][j] != 0: # Check the possible rectangles starting from (i, j) for row in range(i, M): for col in range(j, N): if garden[row][col] == garden[i][j]: # Check if the submatrix is still valid valid = True for sub_row in range(i, row + 1): for sub_col in range(j, col + 1): if garden[sub_row][sub_col] != garden[i][j]: valid = False break if not valid: break if valid: area = (row - i + 1) * (col - j + 1) if area > max_area: max_area = area else: break return max_area"},{"question":"def first_non_repeating_character(s: str) -> str: Finds the first non-repeating character in a string. If every character repeats, returns '_'. >>> first_non_repeating_character(\\"aabcc\\") \\"b\\" >>> first_non_repeating_character(\\"xxyz\\") \\"y\\" >>> first_non_repeating_character(\\"abcdef\\") \\"a\\" >>> first_non_repeating_character(\\"aabbcc\\") \\"_\\" >>> first_non_repeating_character(\\"abacaba\\") \\"c\\"","solution":"def first_non_repeating_character(s): Finds the first non-repeating character in a string. If every character repeats, returns '_'. Args: s (str): The input string Returns: str: The first non-repeating character or '_' if all characters repeat. # Create a dictionary to count the occurrences of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Iterate over the string to find the first character that appears only once for char in s: if char_count[char] == 1: return char return '_'"},{"question":"def calculate_signature(m: int, s: str) -> int: Calculates the signature for a given string s and integer m. Args: m (int): The divisor used in the calculation. s (str): The input string. Returns: int: The signature of the string. >>> calculate_signature(5, \\"Hello\\") 0 >>> calculate_signature(10, \\"world\\") 2","solution":"def calculate_signature(m, s): Calculates the signature for a given string s and integer m. Args: m (int): The divisor used in the calculation. s (str): The input string. Returns: int: The signature of the string. # Convert each character in string to its ASCII value and sum them up ascii_sum = sum(ord(char) for char in s) # Calculate remainder of the sum when divided by m signature = ascii_sum % m return signature"},{"question":"from typing import List def is_prime(n: int) -> bool: Checks if a number n is prime. pass # implement the function def move_primes_to_front(nums: List[int]) -> List[int]: Write a function that takes a list of integers and returns a new list where all the prime numbers are moved to the front, and the non-prime numbers are moved to the back, preserving their original order within their respective groups. >>> move_primes_to_front([10, 3, 4, 7, 6, 11, 13, 15]) == [3, 7, 11, 13, 10, 4, 6, 15] True >>> move_primes_to_front([1, 2, 3, 5, 8, 9, 10]) == [2, 3, 5, 1, 8, 9, 10] True >>> move_primes_to_front([4, 6, 8, 10, 12]) == [4, 6, 8, 10, 12] True >>> move_primes_to_front([2, 2, 2, 3, 3, 3]) == [2, 2, 2, 3, 3, 3] True pass # implement the function","solution":"def is_prime(n): Checks if a number n is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def move_primes_to_front(nums): Returns a new list where all the prime numbers are at the front and non-prime numbers at the back. primes = [num for num in nums if is_prime(num)] non_primes = [num for num in nums if not is_prime(num)] return primes + non_primes"},{"question":"def can_be_made_increasing(arr): Determines if the array can be made strictly increasing by removing exactly one element. >>> can_be_made_increasing([1, 2, 3, 4, 5]) \\"YES\\" >>> can_be_made_increasing([5, 4, 3, 2, 1]) \\"NO\\" >>> can_be_made_increasing([1, 3, 2, 4, 5, 6]) \\"YES\\" >>> can_be_made_increasing([3, 4, 2, 1, 5, 6]) \\"NO\\" >>> can_be_made_increasing([10, 5, 7]) \\"YES\\" >>> can_be_made_increasing([1, 2, 1]) \\"YES\\" >>> can_be_made_increasing([5, 1, 2, 3, 4]) \\"YES\\"","solution":"def can_be_made_increasing(arr): Determines if the array can be made strictly increasing by removing exactly one element. :param arr: List[int] - The input array of integers :return: str - \\"YES\\" if it can be made strictly increasing by removing one element, \\"NO\\" otherwise n = len(arr) count = 0 for i in range(1, n): if arr[i] <= arr[i - 1]: count += 1 if count > 1: return \\"NO\\" if i > 1 and i < n - 1 and arr[i] <= arr[i - 2] and arr[i + 1] <= arr[i - 1]: return \\"NO\\" return \\"YES\\""},{"question":"def shortest_path(grid: List[List[str]], sx: int, sy: int, dx: int, dy: int) -> int: Determine the shortest path from the start to the destination in a grid. Args: grid (List[List[str]]): The M x N grid representing the warehouse. sx (int): The starting x-coordinate. sy (int): The starting y-coordinate. dx (int): The destination x-coordinate. dy (int): The destination y-coordinate. Returns: int: The length of the shortest path from the start to the destination, or -1 if it is not possible. >>> grid = [ ... ['.', '.', '.'], ... ['.', '#', '.'], ... ['.', '.', '.'] ... ] >>> shortest_path(grid, 0, 0, 2, 2) 4 >>> grid = [ ... ['.', '#', '.'], ... ['#', '#', '#'], ... ['.', '#', '.'] ... ] >>> shortest_path(grid, 0, 0, 2, 2) -1 >>> grid = [ ... ['.', '.', '.', '#', '.', '.', '.'], ... ['.', '#', '.', '.', '.', '#', '.'], ... ['.', '#', '.', '.', '.', '.', '.'], ... ['.', '.', '#', '#', '.', '.', '.'], ... ['.', '.', '.', '.', '.', '.', '.'] ... ] >>> shortest_path(grid, 0, 0, 4, 6) 10 >>> grid = [['.']] >>> shortest_path(grid, 0, 0, 0, 0) 0","solution":"from collections import deque def shortest_path(grid, sx, sy, dx, dy): rows, cols = len(grid), len(grid[0]) # directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Check if the starting or destination points are valid if grid[sx][sy] == '#' or grid[dx][dy] == '#': return -1 # Queue for BFS queue = deque([(sx, sy, 0)]) # (current_x, current_y, distance_travelled) visited = set((sx, sy)) while queue: x, y, distance = queue.popleft() if (x, y) == (dx, dy): return distance for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] == '.': queue.append((nx, ny, distance + 1)) visited.add((nx, ny)) return -1"},{"question":"from typing import List, Tuple, Optional def isFullBinaryTree(tree: List[Tuple[int, Optional[int], Optional[int]]]) -> bool: Determine if a given binary tree is a full binary tree. A Full Binary Tree is a tree in which every node except the leaves has exactly two children. Args: tree (List[Tuple[int, Optional[int], Optional[int]]]): List of tuples where each tuple contains the node value, left child value, and right child value. Returns: bool: True if the tree is a Full Binary Tree, False otherwise. >>> isFullBinaryTree([(1, 2, 3), (2, 4, 5), (3, None, None), (4, None, None), (5, None, None)]) True >>> isFullBinaryTree([(1, 2, 3), (2, 4, None), (3, None, None), (4, None, None)]) False >>> isFullBinaryTree([]) True >>> isFullBinaryTree([(1, None, None)]) True >>> isFullBinaryTree([(1, 2, None), (2, None, 3), (3, None, None)]) False >>> isFullBinaryTree([(1, 2, 3), (2, 4, 5), (3, 6, 7), (4, None, None), (5, None, None), (6, None, None), (7, None, None)]) True","solution":"from typing import List, Tuple, Optional def isFullBinaryTree(tree: List[Tuple[int, Optional[int], Optional[int]]]) -> bool: if not tree: return True node_dict = {node[0]: node for node in tree} for node in tree: node_value, left_child, right_child = node if (left_child is None and right_child is not None) or (left_child is not None and right_child is None): return False return True"},{"question":"def longest_common_subsequence(s: str, t: str) -> int: Returns the length of the longest common subsequence of s and t. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"qwerty\\") 0 >>> longest_common_subsequence(\\"abcd\\", \\"efgh\\") 0 def process_test_cases(q: int, test_cases: List[Tuple[str, str]]) -> List[int]: Processes multiple test cases and returns a list of results. >>> test_cases = [(\\"abcde\\", \\"ace\\"), (\\"abc\\", \\"qwerty\\"), (\\"abcd\\", \\"efgh\\")] >>> process_test_cases(3, test_cases) [3, 0, 0] >>> test_cases = [(\\"abc\\", \\"abc\\"), (\\"abcdefg\\", \\"abcdefg\\"), (\\"abcdefgh\\", \\"acegh\\")] >>> process_test_cases(3, test_cases) [3, 7, 5]","solution":"def longest_common_subsequence(s, t): Returns the length of the longest common subsequence of s and t. m, n = len(s), len(t) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s[i - 1] == t[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def process_test_cases(q, test_cases): Processes multiple test cases and returns a list of results. results = [] for s, t in test_cases: results.append(longest_common_subsequence(s, t)) return results"},{"question":"def floyd_warshall(n, graph): Given a list of edges in a graph, computes the shortest paths between all pairs of vertices using the Floyd-Warshall algorithm. >>> floyd_warshall(4, [(1,2,1),(2,3,1),(3,4,1),(4,1,1)]) [[0, 1, 2, 1], [1, 0, 1, 2], [2, 1, 0, 1], [1, 2, 1, 0]] pass def strong_distance(n, graph): Given a list of edges in a graph, computes the strong distance between each pair of vertices. >>> strong_distance(4, [(1,2,1),(2,3,1),(3,4,1),(4,1,1)]) [[0, 2, 2, 2], [2, 0, 2, 2], [2, 2, 0, 2], [2, 2, 2, 0]] pass def solve(T, testcases): Given multiple testcases of graphs, computes the strong distances for each graph. >>> solve(1, [(4, 4, [(1,2,1),(2,3,1),(3,4,1),(4,1,1)])]) [[[0, 2, 2, 2], [2, 0, 2, 2], [2, 2, 0, 2], [2, 2, 2, 0]]] pass","solution":"def floyd_warshall(n, graph): dist = [[float('inf')] * n for _ in range(n)] for i in range(n): dist[i][i] = 0 for u, v, w in graph: dist[u-1][v-1] = w dist[v-1][u-1] = w for k in range(n): for i in range(n): for j in range(n): if dist[i][j] > dist[i][k] + dist[k][j]: dist[i][j] = dist[i][k] + dist[k][j] return dist def strong_distance(n, graph): shortest_paths = floyd_warshall(n, graph) result = [[0]*n for _ in range(n)] for i in range(n): for j in range(n): if i == j: result[i][j] = 0 else: max_path = 0 for k in range(n): for l in range(n): if (k == i or k == j or l == i or l == j) and shortest_paths[k][l] != float('inf'): max_path = max(max_path, shortest_paths[k][l]) result[i][j] = max_path return result def solve(T, testcases): results = [] for case in testcases: N, M, edges = case result = strong_distance(N, edges) results.append(result) return results"},{"question":"def longest_unique_substring(s: str) -> int: Given a string, return the length of the longest substring without repeating characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"\\") 0 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"aab\\") 2","solution":"def longest_unique_substring(s): Returns the length of the longest substring without repeating characters. if not s: return 0 start = 0 max_length = 0 char_index_map = {} for i, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start: start = char_index_map[char] + 1 char_index_map[char] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def longest_contiguous_subarray(T: int, test_cases: List[List[int]]) -> List[int]: Determine the length of the longest contiguous subarray where all elements have the same value. Args: T (int): Number of test cases. test_cases (List[List[int]]): List of test cases, where each test case is a list of integers starting with N. Returns: List[int]: List of results for each test case. >>> longest_contiguous_subarray(3, [ ... [10, 1, 2, 2, 2, 3, 3, 3, 3, 3, 1, 1], ... [5, 4, 4, 4, 4, 4], ... [7, 7, 8, 8, 8, 8, 7, 7] ... ]) [5, 5, 4]","solution":"def longest_contiguous_subarray(T, test_cases): results = [] for case in test_cases: N, arr = case[0], case[1:] max_length = 1 current_length = 1 for i in range(1, N): if arr[i] == arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 results.append(max_length) return results"},{"question":"import numpy as np def generate_repeated_linspace(start, end, num, K): Generates a list of size N containing evenly spaced values between a start and end value. From this list, creates a new array where each element in the original list is repeated K times. Parameters: start (float): The start value of the interval. end (float): The end value of the interval. num (int): The number of evenly spaced values. K (int): The number of times each value should be repeated. Returns: numpy.ndarray: The resultant array where each evenly spaced value is repeated K times. Example: >>> generate_repeated_linspace(2.0, 3.0, 5, 2) array([2. , 2. , 2.25, 2.25, 2.5 , 2.5 , 2.75, 2.75, 3. , 3. ]) >>> generate_repeated_linspace(1.0, 1.0, 1, 3) array([1.0, 1.0, 1.0])","solution":"import numpy as np def generate_repeated_linspace(start, end, num, K): Generates a list of size N containing evenly spaced values between a start and end value. From this list, creates a new array where each element in the original list is repeated K times. Parameters: start (float): The start value of the interval. end (float): The end value of the interval. num (int): The number of evenly spaced values. K (int): The number of times each value should be repeated. Returns: numpy.ndarray: The resultant array where each evenly spaced value is repeated K times. linspace_values = np.linspace(start, end, num) repeated_values = np.repeat(linspace_values, K) return repeated_values"},{"question":"def longest_palindromic_substring(s: str) -> int: Find the length of the longest palindromic substring within the given string. >>> longest_palindromic_substring(\\"babad\\") 3 >>> longest_palindromic_substring(\\"cbbd\\") 2 >>> longest_palindromic_substring(\\"a\\") 1 >>> longest_palindromic_substring(\\"ac\\") 1 >>> longest_palindromic_substring(\\"aa\\") 2 pass def longest_palindromic_substring_all_cases(test_cases: List[str]) -> List[int]: Processes multiple test cases and returns the length of the longest palindromic substrings. >>> longest_palindromic_substring_all_cases([\\"babad\\", \\"cbbd\\", \\"a\\", \\"ac\\", \\"aa\\"]) [3, 2, 1, 1, 2] pass","solution":"def longest_palindromic_substring(s): Returns the length of the longest palindromic substring. n = len(s) if n == 0: return 0 # Table to store results of subproblems dp = [[False] * n for _ in range(n)] # All substrings of length 1 are palindromic by default max_length = 1 for i in range(n): dp[i][i] = True # Check for sub-strings of length 2 start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 # Check for lengths greater than 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i + 1][j - 1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length def longest_palindromic_substring_all_cases(test_cases): Processes multiple test cases and returns the length of the longest palindromic substrings. results = [] for s in test_cases: results.append(longest_palindromic_substring(s)) return results"},{"question":"def can_make_all_equal(t: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Determine if all elements in an array can be made equal by subtracting the same positive integer d. >>> can_make_all_equal(3, [((3, 2), [2, 4, 6]), ((4, 3), [1, 4, 7, 10]), ((2, 5), [10, 3])]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> can_make_all_equal(1, [((3, 1), [1, 2, 3])]) [\\"YES\\"] from typing import List, Tuple def test_case_1(): t = 3 test_cases = [ [(3, 2), [2, 4, 6]], [(4, 3), [1, 4, 7, 10]], [(2, 5), [10, 3]] ] expected = [\\"YES\\", \\"YES\\", \\"NO\\"] assert can_make_all_equal(t, test_cases) == expected def test_case_2(): t = 1 test_case = [((3, 1), [1, 2, 3])] expected = [\\"YES\\"] assert can_make_all_equal(t, test_case) == expected def test_case_3(): t = 1 test_case = [((3, 2), [2, 3, 4])] expected = [\\"NO\\"] assert can_make_all_equal(t, test_case) == expected def test_case_4(): t = 2 test_cases = [ [(2, 1), [2, 2]], [(5, 10), [10, 20, 30, 40, 50]] ] expected = [\\"YES\\", \\"YES\\"] assert can_make_all_equal(t, test_cases) == expected def test_case_5(): t = 1 test_case = [((5, 3), [3, 6, 9, 12, 15])] expected = [\\"YES\\"] assert can_make_all_equal(t, test_case) == expected","solution":"def can_make_all_equal(t, test_cases): results = [] for i in range(t): n, d = test_cases[i][0] a = test_cases[i][1] # Find the minimum element in the array min_val = min(a) # Check if all elements in the array minus the minimum element are divisible by d if all((x - min_val) % d == 0 for x in a): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def calculate_paint_requirements(length, width, height, coverage_rate=20.0): Calculate the total paintable area of the walls and the amount of paint required. Args: length (int): The length of the room. width (int): The width of the room. height (int): The height of the room. coverage_rate (float): The coverage rate of the paint in square units per liter. Default is 20. Returns: (float, float): A tuple containing the total area and the amount of paint required. def process_input(input_data): Process the input data and produce the output for each dataset until '0 0 0' is encountered. Args: input_data (list of str): The input data. Returns: list of str: The list containing the output for each line. from solution import process_input, calculate_paint_requirements def test_calculate_paint_requirements(): assert calculate_paint_requirements(10, 15, 2) == (100.0, 5.0) assert calculate_paint_requirements(6, 4, 3) == (60.0, 3.0) assert calculate_paint_requirements(5, 5, 5, 25.0) == (100.0, 4.0) assert calculate_paint_requirements(12, 8, 3) == (120.0, 6.0) assert calculate_paint_requirements(0, 0, 0) == (0.0, 0.0) # Edge case, though it should not be processed by main function def test_process_input(): input_data = [ \\"10 15 2\\", \\"6 4 3\\", \\"0 0 0\\" ] assert process_input(input_data) == [\\"100.00 5.000000\\", \\"60.00 3.000000\\"] input_data = [ \\"12 8 3\\", \\"5 5 5\\", \\"0 0 0\\" ] assert process_input(input_data) == [\\"120.00 6.000000\\", \\"100.00 5.000000\\"] input_data = [ \\"6 6 6\\", \\"7 7 7\\", \\"8 8 8\\", \\"0 0 0\\" ] assert process_input(input_data) == [\\"144.00 7.200000\\", \\"196.00 9.800000\\", \\"256.00 12.800000\\"]","solution":"def calculate_paint_requirements(length, width, height, coverage_rate=20.0): Calculate the total paintable area of the walls and the amount of paint required. Args: length (int): The length of the room. width (int): The width of the room. height (int): The height of the room. coverage_rate (float): The coverage rate of the paint in square units per liter. Default is 20. Returns: (float, float): A tuple containing the total area and the amount of paint required. area_wall1 = length * height area_wall2 = width * height total_area = 2 * (area_wall1 + area_wall2) paint_required = total_area / coverage_rate return total_area, paint_required def process_input(input_data): Process the input data and produce the output for each dataset until '0 0 0' is encountered. Args: input_data (list of str): The input data. Returns: list of str: The list containing the output for each line. results = [] for line in input_data: L, W, H = map(int, line.split()) if L == 0 and W == 0 and H == 0: break total_area, paint_required = calculate_paint_requirements(L, W, H) results.append(f\\"{total_area:.2f} {paint_required:.6f}\\") return results"},{"question":"from typing import List, Tuple def distinct_integers_count(n: int, m: int, k: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]: Find the number of distinct integers in the subarray a[l..r] that are strictly greater than or equal to k for each query. Args: n: Integer, the length of the array \`a\`. m: Integer, the number of queries. k: Integer, the threshold value. a: List of integers, the elements of the array. queries: List of tuples, each tuple contains two integers \`l\` and \`r\` representing the range of the subarray. Returns: List of integers, where the i-th integer is the answer to the i-th query. Examples: >>> distinct_integers_count(8, 3, 5, [1, 3, 5, 5, 7, 8, 5, 10], [(1, 5), (2, 7), (4, 8)]) [2, 3, 4] >>> distinct_integers_count(5, 2, 1, [1, 1, 1, 1, 1], [(1, 3), (2, 5)]) [1, 1] >>> distinct_integers_count(7, 1, 0, [-5, 0, 2, 3, -2, 1, 4], [(1, 7)]) [5] # Function implementation","solution":"def distinct_integers_count(n, m, k, a, queries): results = [] for query in queries: l, r = query distinct_set = set() for i in range(l-1, r): # l and r are 1-based, converting to 0-based if a[i] >= k: distinct_set.add(a[i]) results.append(len(distinct_set)) return results"},{"question":"def is_symmetric_matrix(matrix): Checks if the given matrix is symmetric. >>> is_symmetric_matrix([[1, 2, 3], [2, 4, 5], [3, 5, 6]]) == \\"YES\\" >>> is_symmetric_matrix([[1, 0, 0], [2, 4, 5], [3, 5, 6]]) == \\"NO\\" n = len(matrix) for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return \\"NO\\" return \\"YES\\" def process_input(matrix_description): Process the input to extract matrix dimension and elements. >>> process_input([\\"3\\", \\"1 2 3\\", \\"2 4 5\\", \\"3 5 6\\"]) == \\"YES\\" >>> process_input([\\"3\\", \\"1 0 0\\", \\"2 4 5\\", \\"3 5 6\\"]) == \\"NO\\" >>> process_input([\\"1\\", \\"5\\"]) == \\"YES\\" n = int(matrix_description[0]) matrix = [] for i in range(1, n + 1): row = list(map(int, matrix_description[i].split())) matrix.append(row) return is_symmetric_matrix(matrix)","solution":"def is_symmetric_matrix(matrix): Checks if the given matrix is symmetric. n = len(matrix) for i in range(n): for j in range(n): if matrix[i][j] != matrix[j][i]: return \\"NO\\" return \\"YES\\" def process_input(matrix_description): Process the input to extract matrix dimension and elements. n = int(matrix_description[0]) matrix = [] for i in range(1, n + 1): row = list(map(int, matrix_description[i].split())) matrix.append(row) return is_symmetric_matrix(matrix)"},{"question":"def knapsack(n, W, items): You are given n different types of items, each item i has a specified weight wi and value vi. You also have a knapsack that can hold a maximum weight W. Your goal is to determine the maximum value you can accumulate by putting items into the knapsack without exceeding its weight capacity. :param int n: Number of items. :param int W: Maximum weight the knapsack can hold. :param list items: List of tuples where each tuple contains two integers (weight, value) for each item. :return: Maximum value that can be accumulated. :rtype: int >>> knapsack(4, 7, [(1, 1), (3, 4), (4, 5), (5, 7)]) 9 >>> knapsack(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 from solution import knapsack def test_knapsack_example_1(): n = 4 W = 7 items = [(1, 1), (3, 4), (4, 5), (5, 7)] assert knapsack(n, W, items) == 9 def test_knapsack_example_2(): n = 3 W = 50 items = [(10, 60), (20, 100), (30, 120)] assert knapsack(n, W, items) == 220 def test_knapsack_single_item(): n = 1 W = 10 items = [(5, 10)] assert knapsack(n, W, items) == 10 def test_knapsack_small_capacity(): n = 4 W = 5 items = [(4, 5), (2, 3), (3, 7), (1, 2)] assert knapsack(n, W, items) == 10 def test_knapsack_exact_fit(): n = 4 W = 6 items = [(5, 8), (4, 5), (3, 4), (2, 2)] assert knapsack(n, W, items) == 8 def test_knapsack_no_fit(): n = 3 W = 1 items = [(2, 3), (3, 4), (4, 5)] assert knapsack(n, W, items) == 0","solution":"def knapsack(n, W, items): Returns the maximum value that can be accumulated without exceeding the knapsack's weight capacity. :param int n: Number of items. :param int W: Maximum weight the knapsack can hold. :param list items: List of tuples where each tuple contains two integers (weight, value) for each item. :return: Maximum value that can be accumulated. :rtype: int dp = [[0] * (W + 1) for _ in range(n + 1)] for i in range(1, n + 1): wi, vi = items[i - 1] for w in range(W + 1): dp[i][w] = dp[i - 1][w] if w >= wi: dp[i][w] = max(dp[i][w], dp[i - 1][w - wi] + vi) return dp[n][W] # Process input and call function def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) W = int(data[1]) items = [] for i in range(n): wi = int(data[2 + 2 * i]) vi = int(data[3 + 2 * i]) items.append((wi, vi)) print(knapsack(n, W, items)) if __name__ == \\"__main__\\": main()"},{"question":"def recommend_songs(t, test_cases): A new online music streaming service has a recommendation system that suggests songs to its users. Each day, a user is provided with a list of recommended songs based on their previous listening habits. Each song has a unique identifier and a popularity score. The recommendation system aims to improve user satisfaction by ensuring that the recommendations include as many distinct songs as possible, where the sum of the popularity scores of the selected songs is maximized without exceeding a given daily listening limit. Given a list of songs with their unique identifiers and popularity scores, and the maximum allowable total popularity score for the day, determine the list of distinct song identifiers that should be recommended to the user. Input The first line contains an integer t (1 ≤ t ≤ 100,000) — the number of test cases. The description of each test case follows. Each test case begins with an integer m (1 ≤ m ≤ 300) — the maximum total popularity score for the day. The next line contains an integer l (1 ≤ l ≤ 100) — the number of songs. Each of the next l lines contains two integers: identifier (1 ≤ identifier ≤ 10^6) and popularity (1 ≥ popularity ≤ 100) — the identifier and popularity score of each song. Output For each test case, print a line with the identifiers of the songs that should be recommended. If there are multiple valid solutions, print any. Examples: >>> t = 2 >>> test_cases = [ (50, [(1, 10), (2, 20), (3, 40)]), (75, [(10, 25), (20, 35), (30, 45), (40, 55)]) ] >>> recommend_songs(t, test_cases) [\\"1 2\\", \\"10 20\\"] pass def format_input(raw_input): Helper function to read the input in a structured format. Example: >>> raw_input = \\"2n50n3n1 10n2 20n3 40n75n4n10 25n20 35n30 45n40 55\\" >>> format_input(raw_input) (2, [ (50, [(1, 10), (2, 20), (3, 40)]), (75, [(10, 25), (20, 35), (30, 45), (40, 55)]) ]) pass if __name__ == \\"__main__\\": import doctest doctest.testmod() raw_input = \\"2n50n3n1 10n2 20n3 40n75n4n10 25n20 35n30 45n40 55\\" t, test_cases = format_input(raw_input) results = recommend_songs(t, test_cases) for result in results: print(result)","solution":"def recommend_songs(t, test_cases): # Function to process each test case and generate song recommendations results = [] for i in range(t): m, songs = test_cases[i] songs = sorted(songs, key=lambda x: x[1]) # Sort songs by popularity score total_popularity = 0 selected_songs = [] for song in songs: if total_popularity + song[1] <= m: total_popularity += song[1] selected_songs.append(song[0]) results.append(\\" \\".join(map(str, selected_songs))) return results # Helper function to read the input in a structured format def format_input(raw_input): raw_input = raw_input.split(\\"n\\") t = int(raw_input[0]) index = 1 test_cases = [] for _ in range(t): m = int(raw_input[index]) l = int(raw_input[index + 1]) songs = [] for j in range(l): identifier, popularity = map(int, raw_input[index + 2 + j].split()) songs.append((identifier, popularity)) test_cases.append((m, songs)) index += 2 + l return t, test_cases # Sample input processing raw_input = \\"2n50n3n1 10n2 20n3 40n75n4n10 25n20 35n30 45n40 55\\" t, test_cases = format_input(raw_input) results = recommend_songs(t, test_cases) for result in results: print(result)"},{"question":"def max_subarray_sum(nums): Returns the sum of the maximum subarray using Kadane's Algorithm. If the input list is empty, returns 0. >>> max_subarray_sum([1, 2, 3, 4, 5]) 15 >>> max_subarray_sum([-1, -2, -3, -4, -5]) -1 >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([100]) 100 >>> max_subarray_sum([]) 0 >>> max_subarray_sum([2, 2, 2, 2]) 8 >>> max_subarray_sum([-3, -2, 0, -1]) 0 >>> max_subarray_sum([100, -200, 300, -100, 500]) 700","solution":"def max_subarray_sum(nums): Returns the sum of the maximum subarray using Kadane's Algorithm. If the input list is empty, returns 0. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_product_of_two_stones(n: int, stones: list[int]) -> int: Returns the maximum product of two distinct numbers in the sequence or -1 if not possible. Parameters: n (int): The number of stones. stones (list of int): A list containing the numbers on the stones. Returns: int: The maximum product of two distinct numbers or -1 if it is not possible. >>> max_product_of_two_stones(4, [1, 2, 3, 4]) 12 >>> max_product_of_two_stones(3, [2, 2, 2]) -1","solution":"def max_product_of_two_stones(n, stones): Returns the maximum product of two distinct numbers in the sequence or -1 if not possible. Parameters: n (int): The number of stones. stones (list of int): A list containing the numbers on the stones. Returns: int: The maximum product of two distinct numbers or -1 if it is not possible. if len(stones) != len(set(stones)): return -1 # If there are duplicates, return -1 # Sort the stones in ascending order sorted_stones = sorted(stones) # Return the product of the two largest distinct numbers return sorted_stones[-1] * sorted_stones[-2]"},{"question":"def find_dominant_color(n, m, grid): This function determines the dominant color in an n x m grid. A color is considered dominant if it appears in more than half of the cells in the grid. Returns the dominant color or \\"None\\" if no such color exists. :param n: int: number of rows in the grid :param m: int: number of columns in the grid :param grid: List[List[int]]: 2-dimensional list representing the colors of the cells :return: int or str: the dominant color or \\"None\\" >>> find_dominant_color(3, 3, [ ... [1, 2, 1], ... [2, 1, 1], ... [1, 3, 1] ... ]) 1 >>> find_dominant_color(4, 4, [ ... [1, 2, 3, 4], ... [4, 3, 2, 1], ... [1, 2, 3, 4], ... [2, 4, 1, 3] ... ]) 'None'","solution":"def find_dominant_color(n, m, grid): This function determines the dominant color in an n x m grid. A color is considered dominant if it appears in more than half of the cells in the grid. Returns the dominant color or \\"None\\" if no such color exists. from collections import Counter # Flatten the grid to get a single list of colors flat_grid = [color for row in grid for color in row] # Count the occurrences of each color using Counter color_count = Counter(flat_grid) # Calculate the total number of cells total_cells = n * m # Iterate through the color counts to find the dominant color for color, count in color_count.items(): if count > total_cells // 2: return color return \\"None\\""},{"question":"from typing import List def findMatchingWords(W: str, D: List[str]) -> List[str]: Given a string W and an array of strings D, return the array of words from D that contain all the characters of W in any order with exact frequency. Args: W (str): A string whose characters need to be matched. D (List[str]): A list of words to check against string W. Returns: List[str]: A list of words that match the characters and frequency of W. Examples: >>> findMatchingWords(\\"abc\\", [\\"a\\", \\"b\\", \\"ab\\", \\"ba\\", \\"cab\\", \\"bac\\", \\"abc\\", \\"bca\\"]) [\\"cab\\", \\"bac\\", \\"abc\\", \\"bca\\"] >>> findMatchingWords(\\"aabb\\", [\\"bbaacc\\", \\"baab\\", \\"abba\\", \\"bbab\\", \\"bbbaa\\", \\"aabbcc\\"]) [\\"baab\\", \\"abba\\"]","solution":"from collections import Counter def findMatchingWords(W, D): target_count = Counter(W) result = [] for word in D: if Counter(word) == target_count: result.append(word) return result"},{"question":"def solve_game(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the total sum of values that Alice can collect if both play optimally. Args: T: int - the number of test cases. test_cases: List[Tuple[int, List[int]]] - a list containing T pairs of an integer N and an array A of N integers. Returns: List[int] - a list of integers representing the total sum Alice collects for each test case. Examples: >>> solve_game(1, [(4, [8, 15, 3, 7])]) [22] >>> solve_game(2, [(4, [8, 15, 3, 7]), (4, [2, 2, 2, 2])]) [22, 4] >>> solve_game(1, [(1, [10])]) [10] >>> solve_game(1, [(4, [1000000000, 1000000000, 1000000000, 1000000000])]) [2000000000] >>> solve_game(1, [(4, [1, 1000, 1, 1000])]) [2000]","solution":"def optimal_game_strategy(A): N = len(A) dp = [[0] * N for _ in range(N)] for gap in range(N): for i in range(N - gap): j = i + gap x = dp[i + 2][j] if (i + 2) <= j else 0 y = dp[i + 1][j - 1] if (i + 1) <= (j - 1) else 0 z = dp[i][j - 2] if i <= (j - 2) else 0 dp[i][j] = max(A[i] + min(x, y), A[j] + min(y, z)) return dp[0][N - 1] def solve_game(T, test_cases): results = [] for i in range(T): N, A = test_cases[i] results.append(optimal_game_strategy(A)) return results # Example (you can run to check) # T = 1 # test_cases = [(4, [8, 15, 3, 7])] # print(solve_game(T, test_cases)) # should return [22]"},{"question":"def calculate_department_averages(input_data: str) -> str: Calculate the average number of projects completed by employees for each department. Each department's data is provided as a string, with the number of departments followed by each department's employee data. Args: input_data (str): Multi-line string containing the number of departments and a list of project completion counts for employees. Returns: str: New line-separated string, each line showing the average number of projects for a department, rounded to two decimal places. Example: >>> calculate_department_averages(\\"3n4 10 20 30 40n3 50 60 70n2 100 200\\") '25.00n60.00n150.00' # Your code here from solution import calculate_department_averages def test_single_department(): input_data = \\"1n4 10 20 30 40\\" expected_output = \\"25.00\\" assert calculate_department_averages(input_data) == expected_output def test_multiple_departments(): input_data = \\"3n4 10 20 30 40n3 50 60 70n2 100 200\\" expected_output = \\"25.00n60.00n150.00\\" assert calculate_department_averages(input_data) == expected_output def test_single_employee_departments(): input_data = \\"2n1 100n1 200\\" expected_output = \\"100.00n200.00\\" assert calculate_department_averages(input_data) == expected_output def test_all_zero_projects(): input_data = \\"2n3 0 0 0n2 0 0\\" expected_output = \\"0.00n0.00\\" assert calculate_department_averages(input_data) == expected_output def test_large_numbers(): input_data = \\"2n3 1000 1000 1000n2 999 1000\\" expected_output = \\"1000.00n999.50\\" assert calculate_department_averages(input_data) == expected_output","solution":"def calculate_department_averages(input_data): results = [] lines = input_data.strip().split(\\"n\\") n = int(lines[0]) for i in range(1, n + 1): department_data = list(map(int, lines[i].split())) m = department_data[0] project_counts = department_data[1:] average_projects = sum(project_counts) / m results.append(f\\"{average_projects:.2f}\\") return \\"n\\".join(results)"},{"question":"def max_readers(arrivals, departures): Determines the maximum number of readers present in the library at any given time. :param arrivals: List of arrival times of the readers. :param departures: List of departure times of the readers. :return: Maximum number of readers present at the same time. >>> max_readers([1, 2, 9, 5, 5], [4, 5, 12, 9, 7]) 3 >>> max_readers([1], [1]) 1 >>> max_readers([1, 1, 1], [5, 5, 5]) 3 >>> max_readers([1, 5, 10], [4, 8, 15]) 1 >>> max_readers([1, 3, 5], [2, 6, 8]) 2 >>> max_readers([1, 10**6], [1, 10**6]) 1","solution":"def max_readers(arrivals, departures): Determines the maximum number of readers present in the library at any given time. :param arrivals: List of arrival times of the readers. :param departures: List of departure times of the readers. :return: Maximum number of readers present at the same time. events = [] for i in range(len(arrivals)): events.append((arrivals[i], 'arrival')) events.append((departures[i], 'departure')) # Sort events, prioritizing arrivals if times are the same events.sort(key=lambda x: (x[0], x[1] == 'departure')) current_readers = 0 max_readers = 0 for event in events: if event[1] == 'arrival': current_readers += 1 max_readers = max(max_readers, current_readers) else: current_readers -= 1 return max_readers"},{"question":"def daily_temperatures(n, temperatures): Returns an array of days to wait until a warmer temperature for each day. >>> daily_temperatures(7, [73, 74, 75, 71, 69, 72, 76]) [1, 1, 4, 2, 1, 1, 0] >>> daily_temperatures(5, [30, 40, 50, 60, 70]) [1, 1, 1, 1, 0] >>> daily_temperatures(1, [30]) [0] >>> daily_temperatures(5, [70, 60, 50, 40, 30]) [0, 0, 0, 0, 0] >>> daily_temperatures(6, [30, 50, 40, 70, 60, 80]) [1, 2, 1, 2, 1, 0]","solution":"def daily_temperatures(n, temperatures): Returns an array of days to wait until a warmer temperature for each day. result = [0] * n # initialize the result array with 0s stack = [] # stack to keep indexes of temperatures for i in range(n): # while stack is not empty and the current temperature is higher than # the temperature at the index stored at the top of the stack while stack and temperatures[i] > temperatures[stack[-1]]: prev_index = stack.pop() # pop from the stack result[prev_index] = i - prev_index # calculate the difference stack.append(i) # push current index onto the stack return result"},{"question":"def longestValidSubstring(S: str) -> int: Returns the length of the longest valid bracket substring. >>> longestValidSubstring(\\"[]][[\\") 2 >>> longestValidSubstring(\\"[[][]]\\") 6 >>> longestValidSubstring(\\"[[[[[\\") 0 >>> longestValidSubstring(\\"]]]]]\\") 0 >>> longestValidSubstring(\\"[][]][[]\\") 4 >>> longestValidSubstring(\\"\\") 0 >>> longestValidSubstring(\\"[]\\") 2 >>> longestValidSubstring(\\"[\\" * 50000 + \\"]\\" * 50000) 100000 >>> longestValidSubstring(\\"[[[]]]\\") 6 >>> longestValidSubstring(\\"[][][]\\") 6 pass","solution":"def longestValidSubstring(S): Returns the length of the longest valid bracket substring. stack = [] max_length = 0 last_invalid = -1 # position before the start of the string for i in range(len(S)): if S[i] == '[': stack.append(i) else: if stack: stack.pop() if stack: max_length = max(max_length, i - stack[-1]) else: max_length = max(max_length, i - last_invalid) else: last_invalid = i return max_length"},{"question":"def findSingle(nums): Given a list of integers where each integer appears three times except for one integer which appears only once, return the integer that appears only once. >>> findSingle([2, 2, 3, 2]) # 3 >>> findSingle([0, 1, 0, 1, 0, 1, 99]) # 99 >>> findSingle([1, 1, 1, 2]) # 2 >>> findSingle([30000, 500, 100, 30000, 100, 30000, 100]) # 500 >>> findSingle([-2, -2, -2, -1]) # -1 >>> findSingle([200, 200, 200, 0]) # 0 def test_findSingle(): assert findSingle([2, 2, 3, 2]) == 3 assert findSingle([0, 1, 0, 1, 0, 1, 99]) == 99 assert findSingle([1, 1, 1, 2]) == 2 assert findSingle([30000, 500, 100, 30000, 100, 30000, 100]) == 500 assert findSingle([-2, -2, -2, -1]) == -1 assert findSingle([200, 200, 200, 0]) == 0 test_findSingle()","solution":"def findSingle(nums): Given a list of integers where each integer appears three times except for one integer which appears only once, return the integer that appears only once. ones, twos = 0, 0 for num in nums: # accumulate bits that appear 2nd time (twos) twos |= ones & num # accumulate bits that appear 1st time (ones) ones ^= num # remove bits that appear 3rd time threes = ones & twos ones &= ~threes twos &= ~threes return ones"},{"question":"def find_substrings(s: str) -> list: Extracts all possible substrings from a given string s and returns them in a sorted list of unique substrings. The substrings should be sorted lexicographically, and only contain unique values. >>> find_substrings(\\"abc\\") [\\"a\\", \\"ab\\", \\"abc\\", \\"b\\", \\"bc\\", \\"c\\"] >>> find_substrings(\\"banana\\") [\\"a\\", \\"an\\", \\"ana\\", \\"anan\\", \\"anana\\", \\"b\\", \\"ba\\", \\"ban\\", \\"bana\\", \\"banan\\", \\"banana\\", \\"n\\", \\"na\\", \\"nan\\", \\"nana\\"]","solution":"def find_substrings(s: str) -> list: Finds all unique substrings of the given string and returns them sorted lexicographically. substrings = set() for i in range(len(s)): for j in range(i + 1, len(s) + 1): substrings.add(s[i:j]) return sorted(substrings)"},{"question":"def distribute_rice_packets(n: int, packet_weights: List[int], m: int, citizens: List[Tuple[int, List[int]]]) -> List[Tuple[int, int]]: Determines which rice packet each citizen will receive based on their preferences. Parameters: n (int): The number of rice packets available. packet_weights (list of ints): The weights of the available rice packets. m (int): The number of citizens. citizens (list of tuples): Each tuple contains a citizen ID followed by a list of preferred packet weights. Returns: list of tuples: Each tuple contains a citizen ID and the weight of the rice packet they receive or -1 if they receive none. Example: >>> distribute_rice_packets(5, [10, 20, 30, 40, 50], 3, [(1, [50, 10]), (2, [20, 10, 5]), (3, [30])]) [(1, 50), (2, 20), (3, 30)]","solution":"def distribute_rice_packets(n, packet_weights, m, citizens): Determines which rice packet each citizen will receive based on their preferences. Parameters: n (int): The number of rice packets available. packet_weights (list of ints): The weights of the available rice packets. m (int): The number of citizens. citizens (list of tuples): Each tuple contains a citizen ID followed by a list of preferred packet weights. Returns: list of tuples: Each tuple contains a citizen ID and the weight of the rice packet they receive or -1 if they receive none. from collections import defaultdict # Sort the rice packets in descending order packet_weights.sort(reverse=True) # Create a dictionary to keep track of which packets are taken taken_packets = defaultdict(bool) results = [] for citizen_id, prefs in citizens: assigned_packet = -1 for pref in prefs: if pref in packet_weights and not taken_packets[pref]: assigned_packet = pref taken_packets[pref] = True break results.append((citizen_id, assigned_packet)) return results # Example usage n = 5 packet_weights = [10, 20, 30, 40, 50] m = 3 citizens = [(1, [50, 10]), (2, [20, 10, 5]), (3, [30])] print(distribute_rice_packets(n, packet_weights, m, citizens))"},{"question":"def range_sum_of_k_largest(n: int, q: int, arr: list[int], queries: list[tuple[int, int, int]]) -> list[int]: Takes the number of elements in the array, number of queries, the array itself, and a list of queries as inputs. Each query specifies a range [l, r] and asks to determine the sum of the k largest elements within that range. Args: - n (int): Number of elements in the array. - q (int): Number of queries. - arr (list of int): The array of integers. - queries (list of tuples): A list of queries, where each query is represented by a tuple (l, r, k). Returns: - list of int: A list of sums for each query. >>> n = 6 >>> q = 3 >>> arr = [4, 5, 1, 2, 8, 3] >>> queries = [(1, 4, 2), (2, 6, 3), (1, 6, 1)] >>> range_sum_of_k_largest(n, q, arr, queries) [9, 16, 8] >>> n = 5 >>> q = 2 >>> arr = [10, 20, 30, 40, 50] >>> queries = [(1, 1, 1), (5, 5, 1)] >>> range_sum_of_k_largest(n, q, arr, queries) [10, 50]","solution":"def range_sum_of_k_largest(n: int, q: int, arr: list[int], queries: list[tuple[int, int, int]]) -> list[int]: results = [] for l, r, k in queries: # Extract the subarray from l to r (1-based to 0-based index) subarray = arr[l-1:r] # Sort the subarray in descending order subarray.sort(reverse=True) # Sum the first \`k\` elements from the sorted subarray result = sum(subarray[:k]) results.append(result) return results"},{"question":"from typing import List, Tuple def calculate_average_ratings(transactions: List[Tuple[int, int, int, int]]) -> List[Tuple[int, int]]: Calculate the average rating for each seller based on transaction data. Args: transactions (List[Tuple[int, int, int, int]]): A list of tuples, each representing a transaction. Each tuple contains transaction_id (int), buyer_id (int), seller_id (int), and rating (int). Returns: List[Tuple[int, int]]: A list of tuples, each containing user id of the seller and their average rating, sorted by user id in ascending order. Examples: >>> calculate_average_ratings([(1, 101, 201, 5), (2, 102, 202, 4), (3, 103, 201, 3), (4, 104, 202, 5), (5, 105, 203, 2), (6, 106, 202, 1)]) [(201, 4), (202, 3), (203, 2)] >>> calculate_average_ratings([(1, 101, 201, 2), (2, 102, 202, 4), (3, 101, 201, 1), (4, 103, 203, 5), (5, 104, 202, 3)]) [(201, 2), (202, 4), (203, 5)]","solution":"def calculate_average_ratings(transactions): from collections import defaultdict import math # Dictionary to hold the sum of ratings and the count of ratings for each seller. seller_ratings = defaultdict(lambda: [0, 0]) for trans_id, buyer_id, seller_id, rating in transactions: seller_ratings[seller_id][0] += rating seller_ratings[seller_id][1] += 1 average_ratings = [] for seller_id, (total_rating, count) in sorted(seller_ratings.items()): average = total_rating / count rounded_average = math.ceil(average) if average - int(average) >= 0.5 else math.floor(average) average_ratings.append((seller_id, rounded_average)) return average_ratings"},{"question":"class TreeNode: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] def find_deepest_node_depth(root: 'TreeNode') -> int: Given an n-ary tree, find and return the depth of the deepest node. Args: - root: TreeNode: the root of the n-ary tree. Returns: - int: the depth of the deepest node. pass # Unit Tests def test_deepest_node_in_complex_tree(): root = TreeNode(1, [ TreeNode(2), TreeNode(3, [ TreeNode(5), TreeNode(6, [ TreeNode(7) ]) ]), TreeNode(4), ]) assert find_deepest_node_depth(root) == 3 def test_deepest_node_in_single_node_tree(): root = TreeNode(1) assert find_deepest_node_depth(root) == 0 def test_deepest_node_in_empty_tree(): root = None assert find_deepest_node_depth(root) == 0 def test_deepest_node_in_two_level_tree(): root = TreeNode(1, [ TreeNode(2), TreeNode(3), TreeNode(4) ]) assert find_deepest_node_depth(root) == 1 def test_deepest_node_with_multiple_branches(): root = TreeNode(1, [ TreeNode(2, [ TreeNode(8, [ TreeNode(9), TreeNode(10) ]) ]), TreeNode(3, [ TreeNode(5) ]), TreeNode(4, [ TreeNode(6, [ TreeNode(7) ]) ]) ]) assert find_deepest_node_depth(root) == 3","solution":"class TreeNode: def __init__(self, val=0, children=None): self.val = val self.children = children if children is not None else [] def find_deepest_node_depth(root: 'TreeNode') -> int: Given an n-ary tree, find and return the depth of the deepest node. Args: - root: TreeNode: the root of the n-ary tree. Returns: - int: the depth of the deepest node. if not root: return 0 def dfs(node, depth): if not node.children: return depth max_depth = 0 for child in node.children: max_depth = max(max_depth, dfs(child, depth + 1)) return max_depth return dfs(root, 0)"},{"question":"def smallest_window_with_subsequence(S: str, T: str) -> Union[Tuple[int, int], int]: Find the smallest window in S that contains all the characters of T in the same order as they appear in T. >>> smallest_window_with_subsequence(\\"ADOBECODEBANC\\", \\"ABC\\") (1, 6) >>> smallest_window_with_subsequence(\\"HELLO\\", \\"LO\\") (4, 5) >>> smallest_window_with_subsequence(\\"HELLO\\", \\"WORLD\\") -1 from typing import Tuple, Union def test_example_1(): assert smallest_window_with_subsequence('ADOBECODEBANC', 'ABC') == (1, 6) def test_example_2(): assert smallest_window_with_subsequence('HELLO', 'LO') == (4, 5) def test_example_3(): assert smallest_window_with_subsequence('HELLO', 'WORLD') == -1 def test_single_char_match(): assert smallest_window_with_subsequence('A', 'A') == (1, 1) def test_single_char_no_match(): assert smallest_window_with_subsequence('A', 'B') == -1 def test_subsequence_at_end(): assert smallest_window_with_subsequence('12345ABC', 'ABC') == (6, 8) def test_T_larger_than_S(): assert smallest_window_with_subsequence('ABC', 'ABCD') == -1 def test_S_equals_T(): assert smallest_window_with_subsequence('ABCDEFG', 'ABCDEFG') == (1, 7)","solution":"def smallest_window_with_subsequence(S, T): S_len, T_len = len(S), len(T) dp = [[-1] * (T_len + 1) for _ in range(S_len + 1)] for i in range(S_len + 1): dp[i][0] = i for i in range(1, S_len + 1): for j in range(1, T_len + 1): if S[i - 1] == T[j - 1]: dp[i][j] = dp[i - 1][j - 1] else: dp[i][j] = dp[i - 1][j] start, min_len = -1, float('inf') for i in range(1, S_len + 1): if dp[i][T_len] != -1: cur_len = i - dp[i][T_len] if cur_len < min_len: min_len = cur_len start = dp[i][T_len] if start == -1: return -1 else: return start + 1, start + min_len"},{"question":"def minimize_workload(task_times: list) -> list: Assign tasks to workers such that each worker gets exactly two tasks and the overall time is minimized. >>> minimize_workload([3, 2, 1, 1, 4, 5]) [[1, 5], [2, 4], [1, 3]] >>> minimize_workload([6, 3, 2, 7, 5, 1]) [[1, 7], [2, 6], [3, 5]] >>> minimize_workload([4, 4, 4, 4]) [[4, 4], [4, 4]] >>> minimize_workload([1, 100, 2, 99, 3, 98]) [[1, 100], [2, 99], [3, 98]] >>> minimize_workload([1, 2]) [[1, 2]] >>> minimize_workload([1, 2, 3, 4]) [[1, 4], [2, 3]]","solution":"def minimize_workload(task_times): Assign tasks to workers such that each worker gets exactly two tasks and the overall time is minimized. task_times.sort() work_distribution = [] i = 0 j = len(task_times) - 1 while i < j: work_distribution.append([task_times[i], task_times[j]]) i += 1 j -= 1 return work_distribution"},{"question":"def find_unique_books(t, test_cases): This function takes the number of test cases and a list of test cases as input and returns the unique book IDs for each test case after removing duplicates. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each containing the number of books and a list of book IDs. Returns: list: A list of lists, each containing the unique book IDs for each test case. >>> find_unique_books(2, [(5, [12, 23, 12, 34, 45]), (4, [56, 78, 56, 90])]) [[23, 34, 45], [78, 90]] >>> find_unique_books(1, [(3, [1, 2, 3])]) [[1, 2, 3]]","solution":"def find_unique_books(t, test_cases): This function takes the number of test cases and a list of test cases as input and returns the unique book IDs for each test case after removing duplicates. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each containing the number of books and a list of book IDs. Returns: list: A list of lists, each containing the unique book IDs for each test case. results = [] for i in range(t): n, book_ids = test_cases[i] book_set = set() duplicates = set() for book_id in book_ids: if book_id in book_set: duplicates.add(book_id) else: book_set.add(book_id) unique_books = sorted(book_set - duplicates) results.append(unique_books) return results"},{"question":"def countingSortString(s: str) -> str: Sorts a string in lexicographical order using counting sort. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: A new string with characters sorted in lexicographical order. Examples: >>> countingSortString(\\"geeksforgeeks\\") \\"eeeefggkkorss\\" >>> countingSortString(\\"programming\\") \\"aggimmnoprr\\" from typing import List def test_countingSortString(): assert countingSortString(\\"geeksforgeeks\\") == \\"eeeefggkkorss\\" assert countingSortString(\\"programming\\") == \\"aggimmnoprr\\" assert countingSortString(\\"abc\\") == \\"abc\\" assert countingSortString(\\"cba\\") == \\"abc\\" assert countingSortString(\\"aabbcc\\") == \\"aabbcc\\" assert countingSortString(\\"aaa\\") == \\"aaa\\" assert countingSortString(\\"\\") == \\"\\" def test_countingSortString_edge_cases(): assert countingSortString(\\"z\\") == \\"z\\" assert countingSortString(\\"zzzz\\") == \\"zzzz\\" def test_countingSortString_large_input(): large_input = \\"abcde\\" * 20000 expected_output = \\"a\\" * 20000 + \\"b\\" * 20000 + \\"c\\" * 20000 + \\"d\\" * 20000 + \\"e\\" * 20000 assert countingSortString(large_input) == expected_output","solution":"def countingSortString(s): Sorts a string in lexicographical order using counting sort. Parameters: s (str): The input string consisting of lowercase alphabets. Returns: str: A new string with characters sorted in lexicographical order. # As a fixed number of lowercase English letters (26), we use a fixed size count array count = [0] * 26 # Counting each character in the input string for char in s: count[ord(char) - ord('a')] += 1 # Building the output string by appending characters in sorted order sorted_string = [] for i in range(26): sorted_string.append(chr(i + ord('a')) * count[i]) return ''.join(sorted_string)"},{"question":"from collections import deque from typing import List def shortest_path(m: int, n: int, sx: int, sy: int, dx: int, dy: int, grid: List[str]) -> int: Finds the shortest path from the start position (sx, sy) to the destination (dx, dy) avoiding obstacles. Returns the length of the shortest path, or -1 if no such path exists. >>> shortest_path(5, 5, 0, 0, 4, 4, ['00000', '01110', '00010', '01110', '00000']) 8 >>> shortest_path(3, 3, 0, 0, 2, 2, ['010', '010', '010']) -1 pass def test_shortest_path(): assert shortest_path(5, 5, 0, 0, 4, 4, [ '00000', '01110', '00010', '01110', '00000' ]) == 8 assert shortest_path(3, 3, 0, 0, 2, 2, [ '010', '010', '010' ]) == -1 assert shortest_path(3, 3, 0, 0, 2, 2, [ '000', '010', '000' ]) == 4 assert shortest_path(1, 1, 0, 0, 0, 0, [ '0' ]) == 0 assert shortest_path(2, 2, 0, 0, 1, 1, [ '00', '01' ]) == -1 assert shortest_path(2, 2, 0, 0, 1, 1, [ '00', '00' ]) == 2 # Larger grid test assert shortest_path(6, 6, 0, 0, 5, 5, [ '000000', '010000', '010000', '010000', '010000', '000000' ]) == 10","solution":"from collections import deque def shortest_path(m, n, sx, sy, dx, dy, grid): Finds the shortest path from the start position (sx, sy) to the destination (dx, dy) avoiding obstacles. Returns the length of the shortest path, or -1 if no such path exists. if sx == dx and sy == dy: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right visited = [[False] * n for _ in range(m)] queue = deque([(sx, sy, 0)]) # (current row, current column, distance) visited[sx][sy] = True while queue: x, y, dist = queue.popleft() for dxn, dyn in directions: nx, ny = x + dxn, y + dyn if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == '0': if nx == dx and ny == dy: return dist + 1 queue.append((nx, ny, dist + 1)) visited[nx][ny] = True return -1"},{"question":"def does_robot_return_to_origin(movements: str) -> str: Determines if the robot returns to the origin point (0, 0) after completing its path. Parameters: movements (str): A sequence of movements as a string of characters consisting of 'U', 'D', 'L', and 'R'. Returns: str: \\"Yes\\" if the robot returns to the origin, \\"No\\" otherwise. >>> does_robot_return_to_origin('UDLR') \\"Yes\\" >>> does_robot_return_to_origin('UDLUR') \\"No\\" >>> does_robot_return_to_origin('U') \\"No\\" >>> does_robot_return_to_origin('UUDDLLRR') \\"Yes\\" >>> does_robot_return_to_origin('UUDDLRLR') \\"Yes\\" >>> does_robot_return_to_origin('LLRRLUDU') \\"No\\"","solution":"def does_robot_return_to_origin(movements): Determines if the robot returns to the origin point (0, 0) after completing its path. Parameters: movements (str): A sequence of movements as a string of characters consisting of 'U', 'D', 'L', and 'R'. Returns: str: \\"Yes\\" if the robot returns to the origin, \\"No\\" otherwise. x, y = 0, 0 for move in movements: if move == 'U': y += 1 elif move == 'D': y -= 1 elif move == 'L': x -= 1 elif move == 'R': x += 1 return \\"Yes\\" if x == 0 and y == 0 else \\"No\\""},{"question":"def count_anagram_pairs(test_cases): Given a list of strings, determine the number of pairs of strings (i, j) such that string i and string j are anagrams of each other. Args: test_cases (List[Tuple[int, List[str]]]): List of test cases with each test case containing an integer N and a list of N strings. Returns: List[int]: List containing the number of anagram pairs for each test case. Example: >>> count_anagram_pairs([(4, [\\"listen\\", \\"silent\\", \\"enlist\\", \\"google\\"])]) [3] >>> count_anagram_pairs([(3, [\\"abc\\", \\"bac\\", \\"xyz\\"])]) [1]","solution":"def count_anagram_pairs(test_cases): from collections import defaultdict results = [] for case in test_cases: N, strings = case anagram_groups = defaultdict(int) for s in strings: sorted_s = ''.join(sorted(s)) anagram_groups[sorted_s] += 1 count_pairs = sum(count * (count - 1) // 2 for count in anagram_groups.values()) results.append(count_pairs) return results"},{"question":"def sum_of_even_numbers(numbers: List[int]) -> int: Calculate the sum of all even numbers in a given list of integers. >>> sum_of_even_numbers([2, 4, 6, 8]) 20 >>> sum_of_even_numbers([1, 2, 3, 4, 5]) 6 >>> sum_of_even_numbers([1, 3, 5, 7]) 0 >>> sum_of_even_numbers([-2, -3, 4, 5, -6, 7]) -4 >>> sum_of_even_numbers([0, 0, 0, 0]) 0 >>> sum_of_even_numbers([]) 0","solution":"def sum_of_even_numbers(numbers): Returns the sum of all even numbers in the given list of integers. return sum(num for num in numbers if num % 2 == 0)"},{"question":"def find_communities(N, M, edges): Find all communities within a graph and return their sizes in non-decreasing order. A community is defined as a connected component in the graph, where there is a path between any pair of nodes within the component. Args: N (int): The number of nodes in the graph. M (int): The number of edges in the graph. edges (List[Tuple[int, int]]): A list of M pairs of integers representing the edges of the graph. Returns: List[int]: A list of sizes of each community in non-decreasing order. >>> find_communities(7, 5, [(1, 2), (2, 3), (4, 5), (5, 6), (6, 7)]) [3, 4] >>> find_communities(4, 2, [(1, 2), (3, 4)]) [2, 2] >>> find_communities(5, 0, []) [1, 1, 1, 1, 1] >>> find_communities(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) [5] >>> find_communities(1, 0, []) [1] >>> find_communities(6, 3, [(1, 2), (3, 4), (5, 6)]) [2, 2, 2]","solution":"def find_communities(N, M, edges): from collections import defaultdict, deque def bfs(node, graph, visited): queue = deque([node]) visited[node] = True size = 0 while queue: current = queue.popleft() size += 1 for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return size # Create the graph graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) visited = [False] * (N + 1) community_sizes = [] for node in range(1, N + 1): if not visited[node]: community_size = bfs(node, graph, visited) community_sizes.append(community_size) return sorted(community_sizes)"},{"question":"def vigenere_cipher(plaintext: str, keyword: str) -> str: Encrypts the given plaintext using the Vigenère cipher with the provided keyword. >>> vigenere_cipher(\\"ATTACKATDAWN\\", \\"LEMONLEMONLE\\") 'LXFOPVEFRNHR' >>> vigenere_cipher(\\"HELLOWORLD\\", \\"KEYKEYKEYKE\\") 'RIJVSUYVJN' >>> vigenere_cipher(\\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\", \\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\") 'ACEGIKMOQSUWYACEGIKMOQSUWY' >>> vigenere_cipher(\\"HELLO\\", \\"AAAAA\\") 'HELLO' >>> vigenere_cipher(\\"HELLO\\", \\"ZZZZZ\\") 'GDKKN' >>> vigenere_cipher(\\"HELLOWORLD\\", \\"KEY\\") 'RIJVSUYVJN'","solution":"def vigenere_cipher(plaintext, keyword): Encrypts the given plaintext using the Vigenère cipher with the provided keyword. ciphertext = [] keyword_repeated = (keyword * (len(plaintext) // len(keyword) + 1))[:len(plaintext)] for p, k in zip(plaintext, keyword_repeated): shift = ord(k) - ord('A') encrypted_char = chr((ord(p) - ord('A') + shift) % 26 + ord('A')) ciphertext.append(encrypted_char) return ''.join(ciphertext)"},{"question":"from typing import List, Tuple def can_be_sorted(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Check if it is possible to obtain a non-decreasing array by reversing subarrays. >>> can_be_sorted(3, [(3, [3, 1, 2]), (4, [4, 3, 2, 1]), (5, [1, 2, 3, 4, 5])]) ['YES', 'YES', 'YES'] >>> can_be_sorted(2, [(3, [2, 1, 3]), (5, [4, 5, 1, 3, 2])]) ['YES', 'YES'] >>> can_be_sorted(2, [(1, [1]), (1, [1000])]) ['YES', 'YES'] >>> can_be_sorted(2, [(3, [1, 2, 3]), (4, [10, 20, 30, 40])]) ['YES', 'YES'] >>> can_be_sorted(1, [(4, [10, 9, 8, 7])]) ['YES']","solution":"def can_be_sorted(t, test_cases): results = [] for i in range(t): n, a = test_cases[i] if a == sorted(a): results.append(\\"YES\\") else: results.append(\\"YES\\") return results # Example input processing function def process_input(input_lines): t = int(input_lines[0]) test_cases = [] current_line = 1 for _ in range(t): n = int(input_lines[current_line]) a = list(map(int, input_lines[current_line + 1].split())) test_cases.append((n, a)) current_line += 2 return t, test_cases # Example function that can be used for the complete input-output process def main(input_lines): t, test_cases = process_input(input_lines) return can_be_sorted(t, test_cases)"},{"question":"import heapq from typing import List, Tuple def dijkstra(n: int, graph: List[List[Tuple[int, int]]], start: int) -> List[int]: Compute shortest paths from the start node to all other nodes using Dijkstra's algorithm. Args: n (int): Number of nodes. graph (List[List[Tuple[int, int]]]): The graph represented as adjacency list. start (int): The starting node. Returns: List[int]: List containing shortest distances from start to all other nodes. distances = [float('inf')] * (n + 1) distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def find_palace_city(n: int, roads: List[Tuple[int, int, int]]) -> int: Determine the city to place the palace such that the maximum distance from any city to the palace is minimized. Args: n (int): Number of cities. roads (List[Tuple[int, int, int]]): List of tuples where each tuple represents a road (u, v, w) connecting city u and city v with weight w. Returns: int: The optimal city to place the palace. >>> find_palace_city(4, [(1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 1, 3)]) 1 >>> find_palace_city(3, [(1, 2, 5), (2, 3, 7)]) 2 pass # Unit Tests def test_find_palace_city_example1(): n = 4 m = 4 roads = [ (1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 1, 3) ] assert find_palace_city(n, roads) == 1 def test_find_palace_city_example2(): n = 3 m = 2 roads = [ (1, 2, 5), (2, 3, 7) ] assert find_palace_city(n, roads) == 2 def test_find_palace_city_single_city(): n = 1 m = 0 roads = [] assert find_palace_city(n, roads) == 1 def test_find_palace_city_disjointed_graph(): n = 2 m = 1 roads = [ (1, 2, 10) ] assert find_palace_city(n, roads) == 1 def test_find_palace_city_large_graph(): n = 5 m = 6 roads = [ (1, 2, 1), (1, 3, 1), (2, 3, 2), (2, 4, 1), (3, 4, 3), (4, 5, 1) ] assert find_palace_city(n, roads) == 2","solution":"import heapq def dijkstra(n, graph, start): distances = [float('inf')] * (n + 1) distances[start] = 0 pq = [(0, start)] while pq: current_distance, current_node = heapq.heappop(pq) if current_distance > distances[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances def find_palace_city(n, roads): graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) best_city = -1 best_max_distance = float('inf') for city in range(1, n + 1): distances = dijkstra(n, graph, city) max_distance = max(distances[1:]) if max_distance < best_max_distance: best_max_distance = max_distance best_city = city elif max_distance == best_max_distance: best_city = min(best_city, city) return best_city # Example usage: n = 4 m = 4 roads = [ (1, 2, 2), (2, 3, 4), (3, 4, 1), (4, 1, 3) ] print(find_palace_city(n, roads)) # Output: 1"},{"question":"def can_be_palindrome(s: str, k: int) -> bool: Determine if a string s can be transformed into a palindrome by replacing at most k characters. Args: s (str): The input string consisting of lowercase English letters. k (int): The maximum number of character replacements allowed. Returns: bool: True if it is possible to make the string a palindrome by replacing at most k characters, otherwise False. Examples: >>> can_be_palindrome(\\"abca\\", 1) True >>> can_be_palindrome(\\"abcba\\", 0) True >>> can_be_palindrome(\\"abcd\\", 2) True >>> can_be_palindrome(\\"abcd\\", 1) False def check_palindrome_possibility(test_cases: List[Tuple[str, int]]) -> List[str]: Determine if each string in a list of test cases can be made a palindrome with at most k replacements. Args: test_cases (List[Tuple[str, int]]): A list of tuples where each tuple contains a string s and an integer k. Returns: List[str]: A list of results \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. Examples: >>> test_cases = [(\\"abca\\", 1), (\\"abcba\\", 0), (\\"abcd\\", 2)] >>> check_palindrome_possibility(test_cases) [\\"POSSIBLE\\", \\"POSSIBLE\\", \\"IMPOSSIBLE\\"]","solution":"def can_be_palindrome(s, k): Determine if a string s can be transformed into a palindrome by replacing at most k characters. n = len(s) mismatches = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: mismatches += 1 return mismatches <= k def check_palindrome_possibility(test_cases): Given a list of test cases, determine if each string can be made a palindrome with at most k replacements. :param test_cases: List of tuples (s, k) where s is the string and k is the max replacements. :return: List of results \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. results = [] for s, k in test_cases: if can_be_palindrome(s, int(k)): results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"def distribute_boxes(boxes: List[str]) -> int: Returns the minimum possible absolute difference between the total candies each child receives if it is possible to evenly distribute the boxes among the two children. If it is not possible, return -1. :param boxes: List of strings, where each string contains the type of candy and the quantity :return: Minimum possible absolute difference or -1 if an even distribution is not feasible Examples: >>> distribute_boxes([\\"chocolate 10\\", \\"vanilla 5\\", \\"chocolate 20\\", \\"vanilla 15\\"]) 0 >>> distribute_boxes([\\"chocolate 10\\", \\"vanilla 10\\", \\"chocolate 10\\", \\"vanilla 10\\"]) 0 >>> distribute_boxes([\\"chocolate 10\\", \\"vanilla 5\\", \\"chocolate 20\\", \\"vanilla 7\\", \\"vanilla 3\\"]) -1 >>> distribute_boxes([\\"chocolate 10\\", \\"vanilla 8\\", \\"chocolate 20\\", \\"vanilla 15\\", \\"chocolate 7\\", \\"vanilla 12\\"]) != -1 # Some valid distribution","solution":"def distribute_boxes(boxes): Returns the minimum possible absolute difference between the total candies each child receives if it is possible to evenly distribute the boxes among the two children. If it is not possible, return -1. n = len(boxes) # If the number of boxes is odd, distribution is not possible if n % 2 != 0: return -1 candies = [int(box.split()[1]) for box in boxes] # Find total number of candies total_candies = sum(candies) # We are trying to find a subset with sum closest to total_candies / 2 desired_sum = total_candies // 2 # DP array to keep track of feasible sums with subset sizes up to n//2 dp = [[False] * (desired_sum + 1) for _ in range(n//2 + 1)] dp[0][0] = True for candy in candies: for i in range(n//2, 0, -1): # Iterate over subset sizes for j in range(desired_sum, candy - 1, -1): # Iterate over possible sums dp[i][j] = dp[i][j] or dp[i-1][j-candy] # Find the maximum sum feasible with n//2 boxes <= desired_sum for sum_with_half_boxes in range(desired_sum, -1, -1): if dp[n//2][sum_with_half_boxes]: break sum_with_other_half_boxes = total_candies - sum_with_half_boxes return abs(sum_with_other_half_boxes - sum_with_half_boxes)"},{"question":"def is_palindrome(s: str) -> str: Returns 'Yes' if the given string s is a palindrome, 'No' otherwise. >>> is_palindrome(\\"racecar\\") 'Yes' >>> is_palindrome(\\"hello\\") 'No' >>> is_palindrome(\\"madam\\") 'Yes' def check_palindromes(test_cases: List[str]) -> List[str]: Given a list of strings, returns a list where each element is 'Yes' if the corresponding string is a palindrome and 'No' otherwise. >>> check_palindromes([\\"racecar\\", \\"hello\\", \\"madam\\"]) ['Yes', 'No', 'Yes'] >>> check_palindromes([\\"a\\", \\"ab\\", \\"aba\\"]) ['Yes', 'No', 'Yes'] >>> check_palindromes([\\"abcba\\", \\"palindrome\\", \\"level\\"]) ['Yes', 'No', 'Yes']","solution":"def is_palindrome(s): Returns 'Yes' if the given string s is a palindrome, 'No' otherwise. return \\"Yes\\" if s == s[::-1] else \\"No\\" def check_palindromes(test_cases): Given a list of strings, returns a list where each element is 'Yes' if the corresponding string is a palindrome and 'No' otherwise. return [is_palindrome(s) for s in test_cases]"},{"question":"from typing import List, Tuple def max_mystical_power(n: int, strengths: List[int]) -> int: Returns the maximum mystical power of any subarray of trees. >>> max_mystical_power(5, [1, -2, 3, 4, -5]) 7 >>> max_mystical_power(3, [2, -1, 2]) 3 def process_test_cases(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Processes multiple test cases and returns the results for each case. >>> process_test_cases([(5, [1, -2, 3, 4, -5]), (3, [2, -1, 2])]) [7, 3] results = [] for n, strengths in test_cases: results.append(max_mystical_power(n, strengths)) return results","solution":"def max_mystical_power(n, strengths): Returns the maximum mystical power of any subarray. max_sum = current_sum = strengths[0] for strength in strengths[1:]: current_sum = max(strength, current_sum + strength) max_sum = max(max_sum, current_sum) return max_sum def process_test_cases(test_cases): results = [] for n, strengths in test_cases: results.append(max_mystical_power(n, strengths)) return results"},{"question":"def max_cities_to_visit(num_routes, max_distance, max_budget, routes): Given the number of routes, the maximum distance the fuel tank can cover, and the budget for tolls, this function determines the maximum number of cities that can be visited. :param num_routes: int - the number of routes :param max_distance: int - the maximum distance the fuel tank can cover :param max_budget: int - the budget for tolls :param routes: List[Tuple[int, int]] - list of tuples where each tuple represents (distance, toll cost) :return: int - the maximum number of cities that can be visited def main(input_data): Processes the input data and determines the maximum number of cities that can be visited for each test case. :param input_data: str - the input data containing the number of test cases, the number of routes, the maximum distance, the budget, and the details of each route. :return: List[int] - a list of integers where each integer represents the maximum number of cities that can be visited for each test case. # Example usage: # input_data = \\"2n3 100 50n30 10n70 20n100 50n2 200 30n150 10n200 25n\\" # expected_output = [3, 2] # assert main(input_data) == expected_output","solution":"def max_cities_to_visit(num_routes, max_distance, max_budget, routes): Given the number of routes, the maximum distance the fuel tank can cover, and the budget for tolls, this function determines the maximum number of cities that can be visited. :param num_routes: int - the number of routes :param max_distance: int - the maximum distance the fuel tank can cover :param max_budget: int - the budget for tolls :param routes: List[Tuple[int, int]] - list of tuples where each tuple represents (distance, toll cost) :return: int - the maximum number of cities that can be visited reachable_routes = [route for route in routes if route[0] <= max_distance and route[1] <= max_budget] return len(reachable_routes) def main(input_data): lines = input_data.strip().split('n') T = int(lines[0]) results = [] index = 1 for _ in range(T): M, F, B = map(int, lines[index].split()) routes = [] for j in range(M): D, C = map(int, lines[index + 1 + j].split()) routes.append((D, C)) index += M + 1 results.append(max_cities_to_visit(M, F, B, routes)) return results"},{"question":"def can_form_arithmetic_sequence(n: int, sequence: List[int]) -> str: Determine if the sequence can be rearranged into an arithmetic sequence. >>> can_form_arithmetic_sequence(5, [3, 1, 5, 7, 9]) 'YESn1 2' >>> can_form_arithmetic_sequence(4, [2, 4, 6, 8]) 'YESn2 2' >>> can_form_arithmetic_sequence(3, [1, 4, 9]) 'NO' >>> can_form_arithmetic_sequence(5, [2, 2, 2, 2, 2]) 'YESn2 0' >>> can_form_arithmetic_sequence(2, [1, 3]) 'YESn1 2' >>> can_form_arithmetic_sequence(2, [2, 2]) 'YESn2 0' >>> can_form_arithmetic_sequence(3, [-1000000000, 0, 1000000000]) 'YESn-1000000000 1000000000' >>> can_form_arithmetic_sequence(4, [-1000000000, -999999998, -999999996, -999999994]) 'YESn-1000000000 2'","solution":"def can_form_arithmetic_sequence(n, sequence): sequence.sort() d = sequence[1] - sequence[0] for i in range(2, n): if sequence[i] - sequence[i - 1] != d: return \\"NO\\" a1 = sequence[0] return \\"YESn{} {}\\".format(a1, d)"},{"question":"def find_arithmetic_subsequence(n: int, k: int, sequence: List[int]) -> Union[str, Tuple[str, int]]: Finds an arithmetic subsequence of length k in the given sequence. :param n: Length of the sequence :param k: Desired length of the subsequence :param sequence: List of integers representing the sequence :return: \\"Yes\\" and the 1-indexed starting position of the subsequence, or \\"No\\" >>> find_arithmetic_subsequence(6, 3, [1, 3, 5, 7, 9, 11]) (\\"Yes\\", 1) >>> find_arithmetic_subsequence(5, 4, [2, 4, 7, 8, 10]) 'No' >>> find_arithmetic_subsequence(7, 3, [10, 20, 30, 25, 35, 45, 50]) (\\"Yes\\", 1) pass","solution":"def find_arithmetic_subsequence(n, k, sequence): Finds an arithmetic subsequence of length k in the given sequence. :param n: Length of the sequence :param k: Desired length of the subsequence :param sequence: List of integers representing the sequence :return: \\"Yes\\" and the 1-indexed starting position of the subsequence, or \\"No\\" for i in range(n - k + 1): d = sequence[i + 1] - sequence[i] is_arithmetic = True for j in range(2, k): if sequence[i + j] - sequence[i + j - 1] != d: is_arithmetic = False break if is_arithmetic: return \\"Yes\\", i + 1 return \\"No\\" # Example usage n, k = 7, 3 sequence = [10, 20, 30, 25, 35, 45, 50] print(find_arithmetic_subsequence(n, k, sequence))"},{"question":"from typing import List, Tuple def construct_b_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: Create a sequence b from sequence a according to the given rules. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): List of tuples where each tuple contains an integer n and a list of integers a. Returns: List[List[int]]: The sequence b for each test case, as a list of lists. Example: >>> construct_b_sequence(3, [(5, [1, 2, 2, 2, 2]), (4, [5, 5, 5, 5]), (6, [3, 10, 3, 2, 1, 8])]) [[1, 2, 3, 4, 5], [5, 6, 7, 8], [3, 10, 11, 12, 13, 14]] # Your code here # Unit tests def test_case1(): t = 3 test_cases = [ (5, [1, 2, 2, 2, 2]), (4, [5, 5, 5, 5]), (6, [3, 10, 3, 2, 1, 8]) ] expected = [ [1, 2, 3, 4, 5], [5, 6, 7, 8], [3, 10, 11, 12, 13, 14] ] assert construct_b_sequence(t, test_cases) == expected def test_case2(): t = 1 test_cases = [ (3, [0, 0, 0]) ] expected = [ [0, 1, 2] ] assert construct_b_sequence(t, test_cases) == expected def test_case3(): t = 2 test_cases = [ (4, [1, 1, 1, 1]), (5, [10, 9, 8, 7, 6]) ] expected = [ [1, 2, 3, 4], [10, 11, 12, 13, 14] ] assert construct_b_sequence(t, test_cases) == expected def test_case4(): t = 3 test_cases = [ (3, [1000000000, 1000000000, 1000000000]), (5, [0, 1, 0, 1, 0]), (4, [10, 20, 30, 40]) ] expected = [ [1000000000, 1000000001, 1000000002], [0, 1, 2, 3, 4], [10, 20, 30, 40] ] assert construct_b_sequence(t, test_cases) == expected","solution":"def construct_b_sequence(t, test_cases): results = [] for case in test_cases: n, a = case b = [a[0]] # Initialize with the first element of a for i in range(1, n): b.append(max(b[i-1] + 1, a[i])) results.append(b) return results"},{"question":"def find_largest_subarray_with_equal_0s_1s(n: int, S: str) -> int: Determine the size of the largest contiguous subarray that has an equal number of '0's and '1's. Args: n (int): Length of the binary string S. S (str): Binary string of length n. Returns: int: Size of the largest contiguous subarray with equal number of '0's and '1's, or 0 if no such subarray exists. >>> find_largest_subarray_with_equal_0s_1s(8, '11010011') == 6 >>> find_largest_subarray_with_equal_0s_1s(5, '11111') == 0 >>> find_largest_subarray_with_equal_0s_1s(10, '1100010110') == 10","solution":"def find_largest_subarray_with_equal_0s_1s(n, S): Returns the size of the largest contiguous subarray with an equal number of '0's and '1's. :param n: Length of the binary string S :param S: Binary string of length n :return: Size of the largest contiguous subarray or 0 if no such subarray exists # Dictionary to store (index, balance) pairs balance_index_map = {0: -1} max_length = 0 balance = 0 for i in range(n): # Increment balance for '1', decrement balance for '0' if S[i] == '1': balance += 1 else: balance -= 1 # Check if balance has been seen before if balance in balance_index_map: # Update maximum length max_length = max(max_length, i - balance_index_map[balance]) else: # Store balance with the current index balance_index_map[balance] = i return max_length"},{"question":"def max_influence_subgraph(n, m, influences, connections, k): Find the maximum sum of influence levels by selecting exactly k users in the subgraph. Args: n : int : number of users m : int : number of connections influences : List[int] : list of influence levels for each user connections : List[Tuple[int, int]] : list of directed connections between users k : int : exact number of users to be selected Returns: int : the maximum sum of influence levels Example: >>> max_influence_subgraph(5, 4, [10, 20, 30, 40, 50], [(1, 2), (2, 3), (3, 4), (4, 5)], 2) 90 >>> max_influence_subgraph(5, 0, [10, 20, 30, 40, 50], [], 3) 120","solution":"def max_influence_subgraph(n, m, influences, connections, k): from collections import defaultdict # Create an adjacency list for the graph adj_list = defaultdict(list) for a, b in connections: adj_list[a].append(b) # Sort nodes by influence levels in descending order sorted_users = sorted(range(n), key=lambda x: influences[x], reverse=True) selected_users = set() max_influence_sum = 0 selected_count = 0 # Select users focusing on the highest influence first for user in sorted_users: if selected_count < k: selected_users.add(user + 1) # +1 to convert 0-index to 1-index max_influence_sum += influences[user] selected_count += 1 else: break return max_influence_sum"},{"question":"def min_moves_to_zero_matrix(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Determine the minimum number of moves required to make all elements in at least one row or column zero. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples, each containing an integer N and an N by N matrix of integers. Returns: List[int]: A list of integers representing the minimum number of moves required for each test case. >>> min_moves_to_zero_matrix(2, [(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]), (2, [[5, 5], [5, 5]])]) [1, 5] >>> min_moves_to_zero_matrix(1, [(4, [[2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2], [2, 2, 2, 2]])]) [2]","solution":"def min_moves_to_zero_matrix(T, test_cases): def min_moves(matrix): Given an NxN matrix, this function determines the minimum number of moves required to make all elements in at least one row or column zero. N = len(matrix) row_mins = [min(row) for row in matrix] col_mins = [min(matrix[i][j] for i in range(N)) for j in range(N)] return min(min(row_mins), min(col_mins)) results = [] for i in range(T): N = test_cases[i][0] matrix = test_cases[i][1] results.append(min_moves(matrix)) return results"},{"question":"def total_eggs_produced(n: int, d: int, feeding_days: List[List[int]]) -> int: Calculates the total number of eggs produced on the farm. Parameters: n (int): Number of chickens. d (int): Number of days in the period. feeding_days (list of lists): List of sublists where each sublist contains integers representing the days a particular chicken is fed. Returns: int: Total number of eggs produced. >>> total_eggs_produced(3, 5, [[1, 2, 3], [2, 3, 4, 5], [1, 5]]) 9 >>> total_eggs_produced(1, 5, [[1, 2, 3, 4, 5]]) 5 >>> total_eggs_produced(3, 5, [[], [], []]) 0 >>> total_eggs_produced(2, 7, [[1, 3, 4, 5, 7], [2, 2, 2, 3, 4]]) 10 >>> total_eggs_produced(2, 1, [[1], [1]]) 2","solution":"def total_eggs_produced(n, d, feeding_days): Calculates the total number of eggs produced on the farm. Parameters: n (int): Number of chickens. d (int): Number of days in the period. feeding_days (list of lists): List of sublists where each sublist contains integers representing the days a particular chicken is fed. Returns: int: Total number of eggs produced. total_eggs = 0 for chicken_feed in feeding_days: total_eggs += len(chicken_feed) return total_eggs"},{"question":"def longest_increasing_subsequence(sequence): Returns the length of the longest increasing subsequence. >>> longest_increasing_subsequence([1, 3, 2, 5, 6]) 4 >>> longest_increasing_subsequence([3, 10, 2, 1, 20, 4]) 3 >>> longest_increasing_subsequence([]) 0 >>> longest_increasing_subsequence([10, 9, 8, 7, 6]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) 5 >>> longest_increasing_subsequence([5, 4, 3, 2, 1, 2, 3, 4]) 4 def solve(thor_puzzle_cases): Solves multiple test cases of Thor's puzzle and returns the results for each case. >>> cases = [(5, [1, 3, 2, 5, 6]), (6, [3, 10, 2, 1, 20, 4])] >>> solve(cases) [4, 3] >>> cases = [(1, [100]), (2, [100, 100])] >>> solve(cases) [1, 1] >>> cases = [(4, [1, 3, 2, 4]), (4, [3, 1, 4, 1])] >>> solve(cases) [3, 2]","solution":"def longest_increasing_subsequence(sequence): Returns the length of the longest increasing subsequence. if not sequence: return 0 n = len(sequence) lis = [1] * n for i in range(1, n): for j in range(i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 return max(lis) def solve(thor_puzzle_cases): results = [] for case in thor_puzzle_cases: n, sequence = case results.append(longest_increasing_subsequence(sequence)) return results"},{"question":"def is_isogram(s: str) -> str: Determines if the input string is an isogram. An isogram is a word without any repeating letters. Args: s (str): Input string consisting of lowercase English letters. Returns: str: \\"isogram\\" if the string is an isogram, \\"not isogram\\" otherwise. >>> is_isogram(\\"isogram\\") == \\"isogram\\" >>> is_isogram(\\"hello\\") == \\"not isogram\\" >>> is_isogram(\\"background\\") == \\"isogram\\" >>> is_isogram(\\"mississippi\\") == \\"not isogram\\" >>> is_isogram(\\"a\\") == \\"isogram\\" >>> is_isogram(\\"\\") == \\"isogram\\" >>> is_isogram(\\"abcdefghijklmnopqrstuvwxyz\\") == \\"isogram\\"","solution":"def is_isogram(s): Determines if the input string is an isogram. An isogram is a word without any repeating letters. Args: s (str): Input string consisting of lowercase English letters. Returns: str: \\"isogram\\" if the string is an isogram, \\"not isogram\\" otherwise. if len(s) != len(set(s)): return \\"not isogram\\" return \\"isogram\\""},{"question":"def calculate_final_score(n: int, scores: List[int]) -> int: Calculate the final score given a list of scores for a coding competition. The final score is calculated as follows: 1. Find the sum of all positive scores. 2. Find the sum of all negative scores (take the absolute value for the calculation). 3. If the total number of positive scores is greater than the total number of negative scores, the final score is obtained by adding the sum of positive scores and the sum of absolute values of negative scores. 4. Otherwise, the final score is obtained by subtracting the sum of absolute values of negative scores from the sum of positive scores. :param n: Number of scores (integer) :param scores: List of scores (list of integers) :return: Final calculated score (integer) >>> calculate_final_score(5, [3, -2, 7, -4, 1]) 17 >>> calculate_final_score(4, [2, -3, 5, -1]) 3 >>> calculate_final_score(3, [-5, -3, -2]) -10","solution":"def calculate_final_score(n, scores): Calculate the final score given a list of scores for a coding competition. :param n: Number of scores (integer) :param scores: List of scores (list of integers) :return: Final calculated score (integer) positive_sum = 0 negative_sum = 0 positive_count = 0 negative_count = 0 for score in scores: if score > 0: positive_sum += score positive_count += 1 elif score < 0: negative_sum += -score negative_count += 1 if positive_count > negative_count: return positive_sum + negative_sum else: return positive_sum - negative_sum"},{"question":"def generate_teams(team_names: List[str], roles: List[int]) -> List[str]: Generate all possible teams with unique names and distinct combinations of roles. >>> generate_teams([\\"Alpha\\", \\"Beta\\"], [1, 2, 3]) [ \\"Alpha:1\\", \\"Alpha:2\\", \\"Alpha:3\\", \\"Alpha:1,2\\", \\"Alpha:1,3\\", \\"Alpha:2,3\\", \\"Alpha:1,2,3\\", \\"Beta:1\\", \\"Beta:2\\", \\"Beta:3\\", \\"Beta:1,2\\", \\"Beta:1,3\\", \\"Beta:2,3\\", \\"Beta:1,2,3\\" ] >>> generate_teams([\\"Gamma\\"], [4, 5]) [\\"Gamma:4\\", \\"Gamma:5\\", \\"Gamma:4,5\\"] >>> generate_teams([\\"Delta\\"], []) []","solution":"from itertools import combinations def generate_teams(team_names, roles): result = [] for team in team_names: # Generate all possible non-empty subsets of roles for r in range(1, len(roles) + 1): for combo in combinations(roles, r): result.append(f\\"{team}:{','.join(map(str, combo))}\\") return result"},{"question":"def smallest_missing_integer(arr: List[int]) -> int: Return the smallest missing integer from an array of integers. :param arr: List of integers :return: The smallest missing integer >>> smallest_missing_integer([2, 3, 7, 6, 8]) 1 >>> smallest_missing_integer([1, 2, 3]) 4 >>> smallest_missing_integer([1, 2, 2, 5]) 3","solution":"def smallest_missing_integer(arr): Return the smallest missing integer from the array of integers. :param arr: List of integers :return: The smallest missing integer n = len(arr) # Initialize a list indicating the presence of integers from 1 to n+1 present = [False] * (n + 1) # Mark the integers that are present in the array for num in arr: if 1 <= num <= n: present[num] = True # Find the smallest integer that is missing for i in range(1, n+1): if not present[i]: return i return n + 1"},{"question":"class Library: Library system to handle book transactions. The system should be able to: 1. Add a new book to the library. 2. Check out a book for a patron. 3. Return a book that was previously checked out by a patron. 4. List all books currently checked out by a specific patron. >>> library = Library() >>> library.add_book(1001, \\"HarryPotter\\") >>> library.add_book(1002, \\"LordOfTheRings\\") >>> library.checkout_book(2001, 1001) >>> library.checkout_book(2001, 1002) >>> library.list_checked_out_books(2001) 1001 HarryPotter 1002 LordOfTheRings >>> library.return_book(2001, 1001) >>> library.list_checked_out_books(2001) 1002 LordOfTheRings >>> library.list_checked_out_books(2002) None def __init__(self): pass def add_book(self, book_id, title): pass def checkout_book(self, patron_id, book_id): pass def return_book(self, patron_id, book_id): pass def list_checked_out_books(self, patron_id): pass","solution":"class Library: def __init__(self): self.books = {} self.checked_out_books = {} self.patron_books = {} def add_book(self, book_id, title): self.books[book_id] = title def checkout_book(self, patron_id, book_id): if book_id in self.books and book_id not in self.checked_out_books: self.checked_out_books[book_id] = patron_id if patron_id not in self.patron_books: self.patron_books[patron_id] = [] self.patron_books[patron_id].append(book_id) def return_book(self, patron_id, book_id): if book_id in self.checked_out_books and self.checked_out_books[book_id] == patron_id: self.patron_books[patron_id].remove(book_id) del self.checked_out_books[book_id] def list_checked_out_books(self, patron_id): if patron_id in self.patron_books and self.patron_books[patron_id]: for book_id in self.patron_books[patron_id]: print(f\\"{book_id} {self.books[book_id]}\\") else: print(\\"None\\")"},{"question":"def is_colorful_number(n: int) -> str: Determines if a number n is colorful or not. A number is colorful if the product of every digit of a contiguous subsequence is unique. Args: n (int): The input number. Returns: str: \\"Colorful\\" if the number is colorful, otherwise \\"Not Colorful\\". pass from solution import is_colorful_number def test_is_colorful_number_colorful(): assert is_colorful_number(324) == \\"Colorful\\" assert is_colorful_number(263) == \\"Colorful\\" assert is_colorful_number(987) == \\"Colorful\\" # 9, 8, 7, 72, 56, 63, 504 are all unique assert is_colorful_number(1) == \\"Colorful\\" # Single digit, trivially colorful def test_is_colorful_number_not_colorful(): assert is_colorful_number(232) == \\"Not Colorful\\" assert is_colorful_number(12) == \\"Not Colorful\\" # Products 1, 2, 2 assert is_colorful_number(122) == \\"Not Colorful\\" # Products 1, 2, 2, 2, 4 assert is_colorful_number(144) == \\"Not Colorful\\" # Products 1, 4, 4, 16, 16, 64","solution":"def is_colorful_number(n): Determines if a number n is colorful or not. A number is colorful if the product of every digit of a contiguous subsequence is unique. Args: n (int): The input number. Returns: str: \\"Colorful\\" if the number is colorful, otherwise \\"Not Colorful\\". str_n = str(n) length = len(str_n) products = set() # Iterate over all possible contiguous subsequences for i in range(length): for j in range(i, length): # Calculate the product of digits from index i to j product = 1 for k in range(i, j + 1): product *= int(str_n[k]) # Check if the product is already in the set if product in products: return \\"Not Colorful\\" products.add(product) return \\"Colorful\\""},{"question":"from typing import List def min_moves(n: int, m: int, grid: List[List[int]]) -> int: Returns the minimum number of moves required to move from the top-left corner to the bottom-right corner of the grid, or -1 if it is not possible to reach the bottom-right corner. pass # Example unit tests def test_min_moves_possible(): n = 3 m = 3 grid = [ [0, 0, -1], [0, 0, 0], [-1, 0, 0] ] assert min_moves(n, m, grid) == 4 def test_min_moves_impossible(): n = 3 m = 3 grid = [ [0, -1, 0], [0, -1, 0], [0, -1, 0] ] assert min_moves(n, m, grid) == -1 def test_min_moves_blocked_start(): n = 3 m = 3 grid = [ [-1, 0, 0], [0, 0, 0], [0, 0, 0] ] assert min_moves(n, m, grid) == -1 def test_min_moves_blocked_end(): n = 3 m = 3 grid = [ [0, 0, 0], [0, 0, 0], [0, 0, -1] ] assert min_moves(n, m, grid) == -1 def test_min_moves_small_grid(): n = 2 m = 2 grid = [ [0, 0], [0, 0] ] assert min_moves(n, m, grid) == 2 def test_min_moves_one_cell(): n = 1 m = 1 grid = [ [0] ] assert min_moves(n, m, grid) == 0","solution":"from collections import deque def min_moves(n, m, grid): Returns the minimum number of moves required to move from the top-left corner to the bottom-right corner of the grid, or -1 if it is not possible to reach the bottom-right corner. if grid[0][0] == -1 or grid[n-1][m-1] == -1: return -1 # Directions: right, down, left, up directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] # BFS initialization queue = deque([(0, 0, 0)]) # (row, col, steps) visited = set((0, 0)) while queue: r, c, steps = queue.popleft() # If we reached the bottom-right corner if r == n-1 and c == m-1: return steps # Explore the neighbors for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < n and 0 <= nc < m and (nr, nc) not in visited and grid[nr][nc] == 0: visited.add((nr, nc)) queue.append((nr, nc, steps + 1)) return -1 # Example usage n = 3 m = 3 grid = [ [0, 0, -1], [0, 0, 0], [-1, 0, 0] ] print(min_moves(n, m, grid)) # Output: 4"},{"question":"def can_transfer_energy(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if it's possible to transfer all energy to one creature based on the given test cases. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains an integer N followed by a list of N integers :return: List of \\"Yes\\" or \\"No\\" for each test case >>> can_transfer_energy(4, [(3, [4, 8, 16]), (2, [7, 9]), (4, [2, 2, 2, 2]), (5, [1, 3, 5, 7, 9])]) [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] ----- Unit Test ------ from solution import can_transfer_energy def test_all_even(): assert can_transfer_energy(1, [(3, [4, 8, 16])]) == [\\"Yes\\"] def test_all_odd(): assert can_transfer_energy(1, [(5, [1, 3, 5, 7, 9])]) == [\\"Yes\\"] def test_mixed_even_odd(): assert can_transfer_energy(1, [(2, [7, 9])]) == [\\"Yes\\"] assert can_transfer_energy(1, [(3, [7, 9, 2])]) == [\\"No\\"] def test_same_energy(): assert can_transfer_energy(1, [(4, [2, 2, 2, 2])]) == [\\"Yes\\"] def test_multiple_test_cases(): assert can_transfer_energy(4, [ (3, [4, 8, 16]), (2, [7, 9]), (4, [2, 2, 2, 2]), (5, [1, 3, 5, 7, 9]) ]) == [\\"Yes\\", \\"No\\", \\"Yes\\", \\"Yes\\"] def test_single_test_case_mixed(): assert can_transfer_energy(1, [(5, [1, 2, 3, 4, 5])]) == [\\"No\\"]","solution":"def can_transfer_energy(t, test_cases): Determines if it's possible to transfer all energy to one creature based on the given test cases. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains an integer N followed by a list of N integers :return: List of \\"Yes\\" or \\"No\\" for each test case results = [] for i in range(t): N, energies = test_cases[i] even_count = sum(1 for energy in energies if energy % 2 == 0) odd_count = N - even_count if even_count == 0 or odd_count == 0: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def can_sort_with_k_operations(N: int, K: int, A: List[int]) -> str: Determine if it's possible to sort the array in non-decreasing order with at most K reverse operations. >>> can_sort_with_k_operations(5, 1, [3, 2, 1, 5, 4]) \\"NO\\" >>> can_sort_with_k_operations(4, 2, [1, 4, 3, 2]) \\"YES\\" pass def can_sort_arrays(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[str]: Args: - T: int, number of test cases - test_cases: list of tuples, each tuple contains: - a tuple containing N and K - a list of N integers representing the array Returns a list of strings, \\"YES\\" or \\"NO\\" for each test case. >>> can_sort_arrays(3, [((5, 1), [3, 2, 1, 5, 4]), ((4, 2), [1, 4, 3, 2]), ((5, 0), [4, 3, 2, 1, 5])]) [\\"NO\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_sort_with_k_operations(N, K, A): sorted_A = sorted(A) # If the array is already sorted if A == sorted_A: return \\"YES\\" # When K is zero and array is not sorted if K == 0: return \\"NO\\" # Check the sorted segments segments = [] start = 0 for i in range(1, N): if A[i] < A[i - 1]: segments.append(A[start:i]) start = i segments.append(A[start:N]) # Minimum number of operations to sort these segments min_operations_needed = len(segments) - 1 if min_operations_needed <= K: return \\"YES\\" else: return \\"NO\\" def can_sort_arrays(T, test_cases): results = [] for case in test_cases: N, K = case[0] A = case[1] results.append(can_sort_with_k_operations(N, K, A)) return results"},{"question":"def smallest_missing_positive(nums): Returns the smallest positive integer missing from the list nums. Args: nums: List[int] Returns: int >>> smallest_missing_positive([3, 4, -1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([1, 2, 3, 4]) 5 >>> smallest_missing_positive([10, 1, 2, 5, 4, 7]) 3 >>> smallest_missing_positive([-5, -9, -3, -1]) 1 >>> smallest_missing_positive([]) 1 >>> smallest_missing_positive([1]) 2 >>> smallest_missing_positive([2]) 1 >>> smallest_missing_positive([0]) 1 >>> smallest_missing_positive([-1]) 1 >>> smallest_missing_positive([10**6, 10**6-1, 1, 2, 3]) 4 pass","solution":"def smallest_missing_positive(nums): Returns the smallest positive integer missing from the list nums. Args: nums: List[int] Returns: int n = len(nums) # First pass - Relocate elements to the position corresponding to their value for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] # Second pass - Identify the first missing positive for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def find_missing_block(blocks: List[int]) -> int: Find the missing block number from a list of blocks. The function takes a list of unique block numbers from 1 to \`n\` in ascending order with exactly one number missing. It returns the missing block number. Examples: >>> find_missing_block([1, 2, 3, 5]) 4 >>> find_missing_block([2, 3, 4, 5, 6, 7, 8]) 1 >>> find_missing_block([1, 3, 4, 5, 6]) 2 >>> find_missing_block([1, 2, 3, 4, 5, 6, 7, 8, 9]) 10 >>> find_missing_block([1]) 2 >>> find_missing_block([2]) 1 >>> find_missing_block([]) 1 >>> find_missing_block(list(range(2, 100001))) 1","solution":"def find_missing_block(blocks): Find the missing block number from a list of blocks. :param blocks: List of unique block numbers in ascending order from 1 to n with one number missing :return: The missing block number n = len(blocks) + 1 expected_sum = n * (n + 1) // 2 actual_sum = sum(blocks) missing_block = expected_sum - actual_sum return missing_block"},{"question":"def minimum_swaps(n: int, box1: List[int], box2: List[int]) -> int: Determine the minimum number of adjacent swaps required to make the second box's balls match the order of the first box's balls. Parameters: n (int): The number of balls in each box. box1 (List[int]): The order of balls in the first box. box2 (List[int]): The order of balls in the second box. Returns: int: The minimum number of adjacent swaps required. >>> minimum_swaps(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1]) 10 >>> minimum_swaps(4, [4, 3, 2, 1], [1, 2, 3, 4]) 6 >>> minimum_swaps(3, [1, 2, 3], [3, 2, 1]) 3 >>> minimum_swaps(3, [3, 2, 1], [1, 2, 3]) 3 >>> minimum_swaps(6, [1, 3, 5, 2, 4, 6], [6, 4, 2, 5, 3, 1]) 15 >>> minimum_swaps(1, [1], [1]) 0 >>> minimum_swaps(2, [1, 2], [2, 1]) 1 >>> minimum_swaps(3, [1, 2, 3], [1, 2, 3]) 0 >>> minimum_swaps(4, [4, 3, 2, 1], [4, 3, 2, 1]) 0","solution":"def minimum_swaps(n, box1, box2): Returns the minimum number of swaps required to make the second box's balls match the order of the first box's balls. # Position map for balls in the first box position_map = {ball: index for index, ball in enumerate(box1)} # Translate box2 to box1 positions transformed_box2 = [position_map[ball] for ball in box2] # Count inversions (This gives us the minimum swaps needed) swaps = 0 for i in range(n): for j in range(i + 1, n): if transformed_box2[i] > transformed_box2[j]: swaps += 1 return swaps"},{"question":"def max_refreshment_points(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Calculates the maximum number of refreshment points a runner can collect without collecting from two consecutive segments. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains (n, points) where n is the number of segments and points is a list of integers representing the refreshment points. Returns: list: A list of integers representing the maximum refreshment points for each test case. >>> max_refreshment_points(1, [(5, [3, 2, 5, 10, 7])]) [15] >>> max_refreshment_points(1, [(4, [3, 2, 7, 10])]) [13] >>> max_refreshment_points(1, [(3, [3, 2, 5])]) [8] >>> max_refreshment_points(3, [(5, [3, 2, 5, 10, 7]), (4, [3, 2, 7, 10]), (3, [3, 2, 5])]) [15, 13, 8] >>> max_refreshment_points(1, [(1, [5])]) [5] >>> max_refreshment_points(1, [(2, [5, 10])]) [10] >>> max_refreshment_points(1, [(2, [10, 5])]) [10] >>> max_refreshment_points(1, [(0, [])]) [0] >>> max_refreshment_points(1, [(5, [0, 0, 0, 0, 0])]) [0] >>> max_refreshment_points(1, [(3, [10000, 0, 10000])]) [20000]","solution":"def max_refreshment_points(t, test_cases): Calculates the maximum number of refreshment points a runner can collect without collecting from two consecutive segments. Parameters: t (int): The number of test cases. test_cases (list of tuples): Each tuple contains (n, points) where n is the number of segments and points is a list of integers representing the refreshment points. Returns: list: A list of integers representing the maximum refreshment points for each test case. results = [] for case in test_cases: n, points = case if n == 0: results.append(0) continue if n == 1: results.append(points[0]) continue dp = [0] * n dp[0] = points[0] dp[1] = max(points[0], points[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + points[i]) results.append(dp[-1]) return results"},{"question":"from typing import Optional, List, Union class TreeNode: def __init__(self, val: int = 0, left: 'TreeNode' = None, right: 'TreeNode' = None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return a 2D list containing the vertical order traversal of the tree. For each vertical line, the nodes should be ordered from top to bottom. If two nodes have the same position, they should be ordered by their horizontal distance from the root (left to right). Args: root (TreeNode): The root of the binary tree. Returns: List[List[int]]: The 2D list containing the vertical order traversal. Example: >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> verticalOrderTraversal(root) [[9], [3, 15], [20], [7]] >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.left = TreeNode(6) >>> root.right.right = TreeNode(7) >>> verticalOrderTraversal(root) [[4], [2], [1, 5, 6], [3], [7]]","solution":"from collections import defaultdict, deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def verticalOrderTraversal(root: TreeNode): if not root: return [] column_table = defaultdict(list) queue = deque([(root, 0)]) while queue: node, column = queue.popleft() if node is not None: column_table[column].append(node.val) queue.append((node.left, column - 1)) queue.append((node.right, column + 1)) sorted_columns = sorted(column_table.keys()) return [column_table[column] for column in sorted_columns]"},{"question":"def max_groups(n: int, k: int, arr: List[int]) -> int: Given an integer array \`arr\` of size \`n\` containing distinct integers, form multiple groups such that each group contains three elements and the absolute difference between the maximum and minimum element in each group is less than or equal to a given integer \`k\`. Once a group is formed, those elements are removed from the array. Return the maximum number of such groups that can be formed. :param n: The size of the array :param k: The maximum allowed absolute difference between the maximum and minimum element in each group :param arr: The list of integers :return: The maximum number of groups that can be formed >>> max_groups(7, 3, [1, 3, 5, 6, 7, 9, 10]) 2 >>> max_groups(5, 1, [1, 5, 10, 15, 20]) 0 >>> max_groups(9, 0, [5, 5, 5, 5, 5, 5, 5, 5, 5]) 3 >>> max_groups(1, 3, [1]) 0 >>> max_groups(8, 100, [1, 2, 3, 100, 101, 102, 200, 201]) 2","solution":"def max_groups(n, k, arr): arr.sort() count = 0 i = 0 while i + 2 < n: if arr[i+2] - arr[i] <= k: count += 1 i += 3 else: i += 1 return count"},{"question":"def max_unique_integers_in_subarrays(nums: List[int], k: int) -> int: Given an array of integers nums and an integer k, return the maximum number of unique integers among all possible contiguous subarrays of length k in the given array. >>> max_unique_integers_in_subarrays([1, 2, 3, 2, 2, 3, 4], 3) 3 >>> max_unique_integers_in_subarrays([1, 2, 2, 1, 3, 3], 4) 3 >>> max_unique_integers_in_subarrays([1, 1, 1, 1, 1], 1) 1 >>> max_unique_integers_in_subarrays([1, 2, 3, 4, 5], 5) 5 >>> max_unique_integers_in_subarrays([1, 1, 1, 1, 2, 2, 3], 3) 2 >>> max_unique_integers_in_subarrays([], 0) 0 >>> max_unique_integers_in_subarrays([], 1) 0 >>> max_unique_integers_in_subarrays([1], 1) 1 >>> max_unique_integers_in_subarrays([1, 2, 3], 3) 3 >>> max_unique_integers_in_subarrays([1, 2, 3], 0) 0","solution":"def max_unique_integers_in_subarrays(nums, k): from collections import defaultdict n = len(nums) if n == 0 or k == 0: return 0 current_window = defaultdict(int) max_unique_count = 0 for i in range(k): current_window[nums[i]] += 1 max_unique_count = len(current_window) for i in range(k, n): current_window[nums[i]] += 1 current_window[nums[i - k]] -= 1 if current_window[nums[i - k]] == 0: del current_window[nums[i - k]] max_unique_count = max(max_unique_count, len(current_window)) return max_unique_count"},{"question":"def common_checkpoints(n: int, m: int, first_driver: List[int], second_driver: List[int]) -> str: Returns the list of common checkpoints visited by both drivers. Otherwise, returns \\"No common checkpoints\\". >>> common_checkpoints(3, 4, [1, 60, 2, 120, 3, 180], [2, 150, 3, 240, 4, 60, 1, 90]) \\"1 2 3\\" >>> common_checkpoints(2, 3, [5, 300, 6, 720], [1, 1440, 2, 60, 3, 320]) \\"No common checkpoints\\"","solution":"def common_checkpoints(n, m, first_driver, second_driver): Returns the list of common checkpoints visited by both drivers. Otherwise, returns \\"No common checkpoints\\". checkpoints_first = {first_driver[i*2] for i in range(n)} checkpoints_second = {second_driver[i*2] for i in range(m)} common = sorted(checkpoints_first & checkpoints_second) if common: return ' '.join(map(str, common)) else: return \\"No common checkpoints\\""},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists in reverse order. :param l1: ListNode :param l2: ListNode :return: ListNode def add_linked_list_pairs(input_data): Processes the input_data and prints the result linked list of the sum of linked list pairs. :param input_data: List[str] def parse_input(input_data): pairs = [] current_pair = ([], []) is_second = False for line in input_data: line = line.strip() if line == '0': break if line == '-': is_second = True continue if line == '': pairs.append(current_pair) current_pair = ([], []) is_second = False elif is_second: current_pair[1].append(int(line)) else: current_pair[0].append(int(line)) return pairs def build_linked_list(lst): head = None for value in reversed(lst): head = ListNode(value, head) return head pairs = parse_input(input_data) results = [] for l1_values, l2_values in pairs: l1 = build_linked_list(l1_values) l2 = build_linked_list(l2_values) result_list = addTwoNumbers(l1, l2) current = result_list while current: results.append(str(current.val)) current = current.next results.append('-') return results # Test cases to validate the solution def parse_output(output_list): lists = [] current_list = [] for item in output_list: if item == '-': lists.append(current_list) current_list = [] else: current_list.append(int(item)) return lists def test_add_two_linked_lists(): input_data = [ \\"2\\", \\"4\\", \\"3\\", \\"-\\", \\"5\\", \\"6\\", \\"4\\", \\"\\", \\"4\\", \\"-\\", \\"5\\", \\"6\\", \\"\\", \\"0\\" ] expected_output = [\\"7\\", \\"0\\", \\"8\\", \\"-\\", \\"9\\", \\"6\\", \\"-\\"] output = add_linked_list_pairs(input_data) output_lists = parse_output(output) expected_lists = parse_output(expected_output) assert output_lists == expected_lists def test_add_two_single_digit_linked_lists(): input_data = [ \\"5\\", \\"-\\", \\"5\\", \\"\\", \\"0\\" ] expected_output = [\\"0\\", \\"1\\", \\"-\\"] output = add_linked_list_pairs(input_data) output_lists = parse_output(output) expected_lists = parse_output(expected_output) assert output_lists == expected_lists def test_add_empty_linked_lists(): input_data = [ \\"0\\" ] expected_output = [] output = add_linked_list_pairs(input_data) assert output == expected_output def test_add_large_numbers_linked_lists(): input_data = [ \\"9\\", \\"9\\", \\"9\\", \\"9\\", \\"-\\", \\"1\\", \\"\\", \\"0\\" ] expected_output = [\\"0\\", \\"0\\", \\"0\\", \\"0\\", \\"1\\", \\"-\\"] output = add_linked_list_pairs(input_data) output_lists = parse_output(output) expected_lists = parse_output(expected_output) assert output_lists == expected_lists","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): Adds two numbers represented by linked lists in reverse order. :param l1: ListNode :param l2: ListNode :return: ListNode dummy_head = ListNode(0) current = dummy_head carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 carry, out = divmod(val1 + val2 + carry, 10) current.next = ListNode(out) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy_head.next def add_linked_list_pairs(input_data): Processes the input_data and prints the result linked list of the sum of linked list pairs. :param input_data: List[str] def parse_input(input_data): pairs = [] current_pair = ([], []) is_second = False for line in input_data: line = line.strip() if line == '0': break if line == '-': is_second = True continue if line == '': pairs.append(current_pair) current_pair = ([], []) is_second = False elif is_second: current_pair[1].append(int(line)) else: current_pair[0].append(int(line)) return pairs def build_linked_list(lst): head = None for value in reversed(lst): head = ListNode(value, head) return head pairs = parse_input(input_data) results = [] for l1_values, l2_values in pairs: l1 = build_linked_list(l1_values) l2 = build_linked_list(l2_values) result_list = addTwoNumbers(l1, l2) current = result_list while current: results.append(str(current.val)) current = current.next results.append('-') return results"},{"question":"def min_edit_distance(branchA: str, branchB: str) -> int: Calculate the minimum number of operations required to transform branchA into branchB. Operations allowed are: - Insert a character - Remove a character - Replace a character Args: branchA (str): The original string representing the code changes in branchA. branchB (str): The target string representing the code changes in branchB. Returns: int: The Levenshtein distance between branchA and branchB. Examples: >>> min_edit_distance(\\"kitten\\", \\"sitting\\") 3 >>> min_edit_distance(\\"flaw\\", \\"lawn\\") 2 >>> min_edit_distance(\\"intention\\", \\"execution\\") 5 >>> min_edit_distance(\\"abc\\", \\"\\") 3 >>> min_edit_distance(\\"\\", \\"abc\\") 3 >>> min_edit_distance(\\"abc\\", \\"abc\\") 0 >>> min_edit_distance(\\"abcdef\\", \\"azced\\") 3 def levenshtein_distance(T: int, cases: List[str]) -> List[int]: Calculate the minimum number of operations required to transform branchA into branchB for multiple test cases. Args: T (int): The number of test cases. cases (List[str]): A list of strings, each containing two space-separated strings branchA and branchB. Returns: List[int]: A list of integers, each representing the Levenshtein distance for a corresponding test case. Examples: >>> levenshtein_distance(3, [\\"kitten sitting\\", \\"flaw lawn\\", \\"intention execution\\"]) [3, 2, 5] >>> levenshtein_distance(2, [\\"abc xyz\\", \\"a a\\"]) [3, 0] >>> levenshtein_distance(1, [\\"abcdef abcdef\\"]) [0] >>> levenshtein_distance(1, [\\"abcdef azced\\"]) [3]","solution":"def min_edit_distance(branchA, branchB): Calculate the Levenshtein distance between two strings branchA and branchB. len_a = len(branchA) len_b = len(branchB) # Create a DP table to store results of subproblems dp = [[0 for x in range(len_b + 1)] for x in range(len_a + 1)] # Fill dp array for i in range(len_a + 1): for j in range(len_b + 1): # If first string is empty, only option is to insert all characters of second string if i == 0: dp[i][j] = j # If second string is empty, only option is to remove all characters of first string elif j == 0: dp[i][j] = i # If last characters are the same, ignore the last char and recur for remaining string elif branchA[i - 1] == branchB[j - 1]: dp[i][j] = dp[i - 1][j - 1] # If last character is different, consider all possibilities and find the minimum else: dp[i][j] = 1 + min(dp[i][j - 1], # Insert dp[i - 1][j], # Remove dp[i - 1][j - 1]) # Replace return dp[len_a][len_b] def levenshtein_distance(T, cases): results = [] for case in cases: branchA, branchB = case.split() results.append(min_edit_distance(branchA, branchB)) return results"},{"question":"def is_almost_fibonacci_valid(N, p, x, V): Determines if the almost Fibonacci sequence with specified parameters is valid. Args: N (int): Length of the sequence. p (int): Position to replace with x. x (int): Value to replace at position p. V (int): Expected validation sum. Returns: str: \\"YES\\" if the sequence sum is equal to V, otherwise \\"NO\\". pass def test_almost_fibonacci_example(): assert is_almost_fibonacci_valid(5, 2, 7, 7) == \\"NO\\" def test_almost_fibonacci_valid_seq(): assert is_almost_fibonacci_valid(5, 2, 7, 31) == \\"YES\\" def test_almost_fibonacci_no_change_needed(): assert is_almost_fibonacci_valid(5, 2, 1, 7) == \\"YES\\" def test_almost_fibonacci_large_n(): assert is_almost_fibonacci_valid(10, 5, 100, 1234) == \\"NO\\" def test_almost_fibonacci_custom_x(): assert is_almost_fibonacci_valid(10, 3, 5, 134) == \\"NO\\" def test_invalid_p_position(): assert is_almost_fibonacci_valid(5, 5, 7, 7) == \\"NO\\" def test_negative_x_value(): assert is_almost_fibonacci_valid(6, 3, -8, 10) == \\"NO\\" def test_zero_v_value(): assert is_almost_fibonacci_valid(4, 2, 7, 10) == \\"NO\\"","solution":"def is_almost_fibonacci_valid(N, p, x, V): Determines if the almost Fibonacci sequence with specified parameters is valid. Args: N (int): Length of the sequence. p (int): Position to replace with x. x (int): Value to replace at position p. V (int): Expected validation sum. Returns: str: \\"YES\\" if the sequence sum is equal to V, otherwise \\"NO\\". if p >= N or p < 2: return \\"NO\\" # Initialize the Fibonacci sequence up to N with the changes applied fib = [0] * N fib[0] = 0 fib[1] = 1 for i in range(2, N): if i == p: fib[i] = x else: fib[i] = fib[i-1] + fib[i-2] # Correct the following elements after p to maintain the Fibonacci property for i in range(p + 1, N): fib[i] = fib[i-1] + fib[i-2] # Compute the sum of the sequence sum_fib = sum(fib) # Check if the sum matches the validation sum return \\"YES\\" if sum_fib == V else \\"NO\\""},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping the left and right children of each node. :param root: TreeNode, the root of the binary tree to be inverted :return: TreeNode, the root of the inverted binary tree pass def tree_to_list(root): Helper function to convert binary tree to list (level order traversal) to facilitate easy comparison in tests. if not root: return [] result, queue = [], [root] while queue: node = queue.pop(0) if node: result.append(node.val) queue.append(node.left) queue.append(node.right) else: result.append(None) # Remove trailing Nones representing missing nodes in complete binary tree while result and result[-1] is None: result.pop() return result def test_invertTree_empty(): assert invertTree(None) is None def test_invertTree_single_node(): root = TreeNode(1) inverted_root = invertTree(root) assert tree_to_list(inverted_root) == [1] def test_invertTree_multiple_nodes(): root = TreeNode(4, TreeNode(2, TreeNode(1), TreeNode(3)), TreeNode(7, TreeNode(6), TreeNode(9))) inverted_root = invertTree(root) inverted_list = tree_to_list(inverted_root) expected_list = [4, 7, 2, 9, 6, 3, 1] assert inverted_list == expected_list def test_invertTree_asymmetric(): root = TreeNode(1, TreeNode(2, None, TreeNode(4)), TreeNode(3)) inverted_root = invertTree(root) inverted_list = tree_to_list(inverted_root) expected_list = [1, 3, 2, None, None, 4] assert inverted_list == expected_list","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def invertTree(root: TreeNode) -> TreeNode: Inverts a binary tree by swapping the left and right children of each node. :param root: TreeNode, the root of the binary tree to be inverted :return: TreeNode, the root of the inverted binary tree if root is None: return None # Swap the left and right children root.left, root.right = root.right, root.left # Recursively invert the left and right subtrees invertTree(root.left) invertTree(root.right) return root"},{"question":"def shortest_unique_substring_length(s: str) -> int: Returns the length of the shortest substring of \`s\` that contains all unique characters of \`s\`. >>> shortest_unique_substring_length(\\"aaaaaa\\") == 1 >>> shortest_unique_substring_length(\\"abca\\") == 3 >>> shortest_unique_substring_length(\\"aabcbcdbca\\") == 4 >>> shortest_unique_substring_length(\\"abcdef\\") == 6 pass # Unit Test def test_single_char_string(): assert shortest_unique_substring_length(\\"aaaaaa\\") == 1 def test_simple_case(): assert shortest_unique_substring_length(\\"abca\\") == 3 def test_longer_case(): assert shortest_unique_substring_length(\\"aabcbcdbca\\") == 4 def test_string_with_non_repeating_characters(): assert shortest_unique_substring_length(\\"abcdef\\") == 6 def test_multiple_minimal_substrings(): assert shortest_unique_substring_length(\\"abcdab\\") == 4 def test_chars_at_the_ends(): assert shortest_unique_substring_length(\\"bdcaabc\\") == 4 def test_empty_string(): assert shortest_unique_substring_length(\\"\\") == float('inf') def test_substring_at_the_end(): assert shortest_unique_substring_length(\\"aaaabcde\\") == 5","solution":"def shortest_unique_substring_length(s): Returns the length of the shortest substring of \`s\` that contains all unique characters of \`s\`. unique_chars = set(s) required_char_count = len(unique_chars) char_count = {} left = 0 min_length = float('inf') for right in range(len(s)): char = s[right] if char in char_count: char_count[char] += 1 else: char_count[char] = 1 while len(char_count) == required_char_count: min_length = min(min_length, right - left + 1) char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 return min_length"},{"question":"def find_odd_occurrence(numbers): Returns the integer that appears an odd number of times in the list. pass def find_odd_occurrences_in_cases(cases): Returns a list of answers for each test case. pass def parse_input(input_data): Parses the input data. pass import pytest def test_find_odd_occurrence(): assert find_odd_occurrence([1, 2, 3, 2, 3, 1, 3]) == 3 assert find_odd_occurrence([4, 4, 3, 3, 5]) == 5 assert find_odd_occurrence([9, 9, 7, 7, 7]) == 7 assert find_odd_occurrence([10**9, 1, 2, 2, 1, 10**9, 5, 5, 5]) == 5 def test_find_odd_occurrences_in_cases_single(): cases = [(7, [1, 2, 3, 2, 3, 1, 3]), (5, [4, 4, 3, 3, 5])] assert find_odd_occurrences_in_cases(cases) == [3, 5] def test_parse_input(): input_data = \\"2n7n1 2 3 2 3 1 3n5n4 4 3 3 5\\" parsed = parse_input(input_data) assert parsed == [(7, [1, 2, 3, 2, 3, 1, 3]), (5, [4, 4, 3, 3, 5])] def test_find_odd_occurrences_in_cases_multiple(): input_data = \\"2n7n1 2 3 2 3 1 3n5n4 4 3 3 5\\" cases = parse_input(input_data) assert find_odd_occurrences_in_cases(cases) == [3, 5]","solution":"def find_odd_occurrence(numbers): Returns the integer that appears an odd number of times in the list. result = 0 for number in numbers: result ^= number return result def find_odd_occurrences_in_cases(cases): Returns a list of answers for each test case. results = [] for _, numbers in cases: results.append(find_odd_occurrence(numbers)) return results def parse_input(input_data): Parses the input data. lines = input_data.strip().split('n') T = int(lines[0]) cases = [] index = 1 for _ in range(T): N = int(lines[index]) numbers = list(map(int, lines[index + 1].split())) cases.append((N, numbers)) index += 2 return cases"},{"question":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence between s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"abc\\") 3 >>> longest_common_subsequence(\\"abc\\", \\"def\\") 0 >>> longest_common_subsequence(\\"abcd\\", \\"abdc\\") 3 >>> longest_common_subsequence(\\"\\", \\"abc\\") 0 >>> longest_common_subsequence(\\"abc\\", \\"\\") 0 >>> longest_common_subsequence(\\"abcde\\", \\"abc\\") 3 def solve_lcs(test_cases): Solves multiple test cases and returns the list of LCS lengths. >>> solve_lcs([(\\"abcde\\", \\"ace\\"), (\\"abc\\", \\"abc\\"), (\\"abc\\", \\"def\\"), (\\"abcd\\", \\"abdc\\")]) [3, 3, 0, 3] >>> solve_lcs([(\\"\\", \\"abc\\"), (\\"abc\\", \\"\\"), (\\"abcde\\", \\"abc\\")]) [0, 0, 3] >>> solve_lcs([(\\"aaaa\\", \\"aa\\"), (\\"abcdefg\\", \\"aceg\\"), (\\"xyz\\", \\"xyaz\\")]) [2, 4, 3]","solution":"def longest_common_subsequence(s1, s2): Returns the length of the longest common subsequence between s1 and s2. m, n = len(s1), len(s2) dp = [[0] * (n + 1) for _ in range(m + 1)] for i in range(1, m + 1): for j in range(1, n + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[m][n] def solve_lcs(test_cases): Solves multiple test cases and returns the list of LCS lengths. results = [] for s1, s2 in test_cases: results.append(longest_common_subsequence(s1, s2)) return results"},{"question":"def is_valid_sudoku(grid): Determine if a given 9x9 grid is a valid Sudoku solution. Parameters: grid (List[List[int]]): A 9x9 grid of integers where 0 represents an empty cell. Returns: str: \\"valid\\" if the grid is a valid Sudoku solution, \\"invalid\\" otherwise. >>> is_valid_sudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 0, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9], ... ]) \\"valid\\" >>> is_valid_sudoku([ ... [5, 3, 0, 0, 7, 0, 0, 0, 0], ... [6, 0, 0, 1, 9, 5, 0, 0, 0], ... [0, 9, 8, 0, 0, 0, 0, 6, 0], ... [8, 0, 0, 0, 6, 0, 0, 0, 3], ... [4, 0, 0, 8, 0, 3, 0, 0, 1], ... [7, 0, 0, 0, 2, 0, 2, 0, 6], ... [0, 6, 0, 0, 0, 0, 2, 8, 0], ... [0, 0, 0, 4, 1, 9, 0, 0, 5], ... [0, 0, 0, 0, 8, 0, 0, 7, 9], ... ]) \\"invalid\\" import pytest def test_valid_sudoku(): grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] assert is_valid_sudoku(grid) == \\"valid\\" def test_invalid_sudoku(): grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 2, 0, 6], # Invalid row (two 2's) [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 0, 0, 8, 0, 0, 7, 9] ] assert is_valid_sudoku(grid) == \\"invalid\\" def test_invalid_sudoku_column(): grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 9, 0, 0, 8, 0, 0, 7, 9] # Invalid column (two 9's) ] assert is_valid_sudoku(grid) == \\"invalid\\" def test_invalid_sudoku_square(): grid = [ [5, 3, 0, 0, 7, 0, 0, 0, 0], [6, 0, 0, 1, 9, 5, 0, 0, 0], [0, 9, 8, 0, 0, 0, 0, 6, 0], [8, 0, 0, 0, 6, 0, 0, 0, 3], [4, 0, 0, 8, 0, 3, 0, 0, 1], [7, 0, 0, 0, 2, 0, 0, 0, 6], [0, 6, 0, 0, 0, 0, 2, 8, 0], [0, 0, 0, 4, 1, 9, 0, 0, 5], [0, 0, 9, 0, 8, 0, 0, 7, 9] # Invalid square (two 9's in bottom right square) ] assert is_valid_sudoku(grid) == \\"invalid\\"","solution":"def is_valid_sudoku(grid): def is_unit_valid(unit): nums = [x for x in unit if x != 0] return len(nums) == len(set(nums)) def is_row_valid(): for row in grid: if not is_unit_valid(row): return False return True def is_col_valid(): for col in zip(*grid): if not is_unit_valid(col): return False return True def is_square_valid(): for i in range(0, 9, 3): for j in range(0, 9, 3): square = [grid[x][y] for x in range(i, i+3) for y in range(j, j+3)] if not is_unit_valid(square): return False return True return \\"valid\\" if is_row_valid() and is_col_valid() and is_square_valid() else \\"invalid\\""},{"question":"def find_min_absolute_difference(n: int, arr: List[int]) -> Tuple[int, int, int]: Given an array of integers, find the two elements that have the smallest absolute difference between them. >>> find_min_absolute_difference(5, [1, 5, 3, 19, 18]) (18, 19, 1) >>> find_min_absolute_difference(3, [-1, -6, -3]) (-3, -1, 2)","solution":"def find_min_absolute_difference(n, arr): arr.sort() min_diff = float('inf') min_pair = (0, 0) for i in range(n - 1): diff = abs(arr[i + 1] - arr[i]) if diff < min_diff: min_diff = diff min_pair = (arr[i], arr[i + 1]) return min_pair[0], min_pair[1], min_diff"},{"question":"def smallest_missing_positive(arr): Find the smallest missing positive integer in an array of integers. The array contains integers between 1 and n, possibly with duplicates and missing elements. The function should have O(n) time complexity and O(1) space complexity. >>> smallest_missing_positive([3, 4, -1, 1, 1]) 2 >>> smallest_missing_positive([1, 2, 0]) 3 >>> smallest_missing_positive([2, 3, 3, 1]) 4","solution":"def smallest_missing_positive(arr): n = len(arr) # Place each number in its correct position if possible for i in range(n): while 1 <= arr[i] <= n and arr[arr[i] - 1] != arr[i]: # swap arr[i] with arr[arr[i] - 1] arr[arr[i] - 1], arr[i] = arr[i], arr[arr[i] - 1] # Find the smallest missing positive number for i in range(n): if arr[i] != i + 1: return i + 1 return n + 1"},{"question":"def length_of_longest_substring_two_distinct(s: str) -> int: Finds the length of the longest substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") == 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") == 5 >>> length_of_longest_substring_two_distinct(\\"a\\") == 1 >>> length_of_longest_substring_two_distinct(\\"abcabcabc\\") == 2 >>> length_of_longest_substring_two_distinct(\\"abaccc\\") == 4 def process_strings(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases to find the length of longest substrings with at most two distinct characters. >>> process_strings(2, [\\"eceba\\", \\"ccaabbb\\"]) == [3, 5] >>> process_strings(3, [\\"aabbcc\\", \\"abcabcabc\\", \\"abaccc\\"]) == [4, 2, 4]","solution":"def length_of_longest_substring_two_distinct(s): Finds the length of the longest substring that contains at most two distinct characters. n = len(s) if n < 3: return n left = 0 right = 0 max_len = 2 char_map = {} while right < n: char_map[s[right]] = right right += 1 if len(char_map) == 3: del_idx = min(char_map.values()) del char_map[s[del_idx]] left = del_idx + 1 max_len = max(max_len, right - left) return max_len def process_strings(T, test_cases): Process multiple test cases to find the length of longest substrings with at most two distinct characters. results = [] for case in test_cases: results.append(length_of_longest_substring_two_distinct(case)) return results"},{"question":"def is_prime(n: int) -> bool: Return True if n is a prime number, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(16) False >>> is_prime(17) True pass def sort_special(nums: List[int]) -> List[int]: Returns a list of the numbers sorted such that prime numbers come first in their original order followed by non-prime numbers in ascending order. >>> sort_special([29, 4, 17, 2, 1, 23, 8]) [29, 17, 2, 23, 1, 4, 8] >>> sort_special([11, 13, 15, 16, 18, 19]) [11, 13, 19, 15, 16, 18] >>> sort_special([3, 14, 7, 27, 9, 5]) [3, 7, 5, 9, 14, 27] >>> sort_special([7]) [7] >>> sort_special([10]) [10] >>> sort_special([10, 7]) [7, 10] >>> sort_special([]) [] pass","solution":"def is_prime(n): Return True if n is a prime number, otherwise False. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False sqrt_n = int(n**0.5) + 1 for i in range(3, sqrt_n, 2): if n % i == 0: return False return True def sort_special(nums): Returns a list of the numbers sorted such that prime numbers come first in their original order followed by non-prime numbers in ascending order. primes = [num for num in nums if is_prime(num)] non_primes = sorted([num for num in nums if not is_prime(num)]) return primes + non_primes"},{"question":"def most_frequent_word(s: str) -> str: Create a function that takes a string and returns the most frequent word in the string. If there is a tie, return the word that appears first. Words are defined as sequences of alphanumeric characters and are case-insensitive. >>> most_frequent_word(\\"Apple banana apple\\") \\"apple\\" >>> most_frequent_word(\\"Banana banana apple\\") \\"banana\\" >>> most_frequent_word(\\"\\") \\"\\" >>> most_frequent_word(\\"Zebra apple zebra Zebra Apple\\") \\"zebra\\"","solution":"def most_frequent_word(s): import re from collections import Counter words = re.findall(r'bw+b', s.lower()) if not words: return \\"\\" word_counts = Counter(words) most_common_word, _ = word_counts.most_common(1)[0] return most_common_word"},{"question":"from typing import List def find_first_occurrence(arr: List[int], x: int) -> int: Returns the index of the first occurrence of x in sorted list arr. If x is not in arr, returns -1. >>> find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) 1 >>> find_first_occurrence([1, 1, 1, 1, 1, 1, 1], 1) 0 >>> find_first_occurrence([1, 2, 3, 4, 5], 6) -1 def test_find_first_occurrence_single_element(): assert find_first_occurrence([1], 1) == 0 assert find_first_occurrence([1], 2) == -1 def test_find_first_occurrence_multiple_unique_elements(): assert find_first_occurrence([1, 2, 3, 4, 5], 3) == 2 assert find_first_occurrence([1, 2, 3, 4, 5], 6) == -1 def test_find_first_occurrence_multiple_duplicates(): assert find_first_occurrence([1, 2, 2, 2, 3, 4, 5], 2) == 1 assert find_first_occurrence([1, 1, 1, 1, 1, 1, 1], 1) == 0 assert find_first_occurrence([1, 1, 1, 1, 1, 1, 1], 2) == -1 def test_find_first_occurrence_edge_cases(): assert find_first_occurrence([], 1) == -1 assert find_first_occurrence([-3, -2, -1, 0, 1, 2, 3], -1) == 2 assert find_first_occurrence([-3, -2, -1, 0, 1, 2, 3], 0) == 3 def test_find_first_occurrence_large_list(): large_list = [1] * 50000 + [2] * 50000 assert find_first_occurrence(large_list, 2) == 50000 assert find_first_occurrence(large_list, 1) == 0 assert find_first_occurrence(large_list, 3) == -1","solution":"def find_first_occurrence(arr, x): Returns the index of the first occurrence of x in sorted list arr. If x is not in arr, returns -1. left, right = 0, len(arr) - 1 result = -1 while left <= right: mid = left + (right - left) // 2 if arr[mid] == x: result = mid right = mid - 1 # look on the left side to find the first occurrence elif arr[mid] < x: left = mid + 1 else: right = mid - 1 return result"},{"question":"def perfectly_balanced(N: int) -> int: Determines if there exists a \\"Perfectly Balanced\\" list of exactly N integers. Returns one example if such a list exists, otherwise returns -1. def handle_test_cases(T: int, test_cases: List[int]) -> List[int]: Handles multiple test cases to determine if a \\"Perfectly Balanced\\" list exists for each case. Takes the number of test cases T and a list of test cases. Returns a list of results for each test case. >>> handle_test_cases(3, [2, 3, 4]) == [[1, 4], -1, [1, 4, 7, 10]] >>> handle_test_cases(2, [6, 7]) == [[1, 4, 7, 10, 13, 16], -1]","solution":"def perfectly_balanced(N): Determines if there exists a \\"Perfectly Balanced\\" list of exactly N integers. Returns one example if such a list exists, otherwise returns -1. # If N is odd, return -1 because it's impossible to create such a list if N % 2 != 0: return -1 # Start with any integer, e.g., 1, and increment by a constant D, e.g., 3 D = 3 result = [1 + i * D for i in range(N)] return result def handle_test_cases(T, test_cases): results = [] for N in test_cases: result = perfectly_balanced(N) results.append(result) return results"},{"question":"def max_product(arr): Returns the maximum product that can be obtained by multiplying two elements in the array. >>> max_product([1, 10, 2, 6]) 60 >>> max_product([-10, -20, 0, 3, 4]) 200 >>> max_product([1, 2, 3]) 6 def find_max_products(input_data): Takes multiple test cases input and returns the list of maximum products for each test case. >>> find_max_products([ ... 3, ... 4, ... 1, 10, 2, 6, ... 5, ... -10, -20, 0, 3, 4, ... 3, ... 1, 2, 3, ... ]) [60, 200, 6]","solution":"def max_product(arr): Returns the maximum product that can be obtained by multiplying two elements in the array. arr.sort() # Maximum product can be between two largest values or two smallest negative values. max_product_end = arr[-1] * arr[-2] max_product_start = arr[0] * arr[1] return max(max_product_end, max_product_start) def find_max_products(input_data): Takes multiple test cases input and returns the list of maximum products for each test case. result = [] index = 0 T = input_data[index] index += 1 for _ in range(T): N = input_data[index] index += 1 array = input_data[index:index + N] index += N result.append(max_product(array)) return result"},{"question":"from typing import List, Tuple def max_paintings(wall_width: int, paintings: List[Tuple[int, int]]) -> int: Calculate the maximum number of paintings that can be hung on the wall without overlap. :param wall_width: The width of the wall. :param paintings: List of tuples [(p_i, h_i), ...] representing width and height of each painting. :return: Maximum number of paintings that can be hung without overlap. pass def solve(t: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Solve the problem of finding the maximum number of paintings that can be hung on the wall for multiple test cases. :param t: The number of test cases. :param test_cases: List of test cases where each test case contains the width of the wall and a list of paintings. :return: List of integers representing the maximum number of paintings that can be hung without overlap for each test case. def test_solve(): # Test case 1 t = 2 test_cases = [ ((10, 4), [(3, 2), (4, 3), (2, 1), (5, 4)]), ((15, 5), [(5, 10), (10, 12), (3, 7), (7, 8), (6, 6)]) ] expected = [3, 3] assert solve(t, test_cases) == expected # Test case 2 t = 1 test_cases = [ ((8, 3), [(3, 2), (3, 3), (4, 1)]) ] expected = [2] assert solve(t, test_cases) == expected # Test case 3: Minimum input t = 1 test_cases = [ ((1, 1), [(1, 1)]) ] expected = [1] assert solve(t, test_cases) == expected # Test case 4: All paintings fit exactly t = 1 test_cases = [ ((10, 4), [(2, 1), (2, 2), (3, 3), (3, 4)]) ] expected = [4] assert solve(t, test_cases) == expected # Test case 5: None fit t = 1 test_cases = [ ((5, 3), [(6, 1), (7, 2), (8, 3)]) ] expected = [0] assert solve(t, test_cases) == expected","solution":"def max_paintings(wall_width, paintings): Calculate the maximum number of paintings that can be hung on the wall without overlap. :param wall_width: The width of the wall. :param paintings: List of tuples [(p_i, h_i), ...] representing width and height of each painting. :return: Maximum number of paintings that can be hung without overlap. paintings = sorted(paintings, key=lambda x: x[0]) current_width = 0 count = 0 for painting in paintings: if current_width + painting[0] <= wall_width: current_width += painting[0] count += 1 else: break return count def solve(t, test_cases): results = [] for i in range(t): wall_width, n_paintings = test_cases[i][0] paintings = test_cases[i][1] results.append(max_paintings(wall_width, paintings)) return results"},{"question":"def max_min_strength(N: int, K: int, strengths: List[int]) -> int: Determine the maximum possible value of the minimum strength of any selected subset of K heroes. :param N: Number of heroes (int) :param K: Number of heroes to select (int) :param strengths: List of strengths of heroes (List[int]) :return: Maximum possible value of the minimum strength of the selected subset (int) >>> max_min_strength(5, 3, [1, 3, 5, 9, 12]) 5 >>> max_min_strength(5, 3, [2, 2, 2, 2, 2]) 2 >>> max_min_strength(6, 4, [1, 2, 3, 4, 5, 6]) 3 >>> max_min_strength(6, 2, [5, 1, 6, 3, 9, 10]) 9 >>> max_min_strength(1, 1, [1]) 1 >>> max_min_strength(5, 5, [1, 7, 8, 9, 10]) 1 >>> max_min_strength(10, 5, [100, 200, 300, 400, 500, 600, 700, 800, 900, 1000]) 600 >>> max_min_strength(100000, 100000, list(range(1, 100001))) 1","solution":"def max_min_strength(N, K, strengths): Function to determine the maximum possible value of the minimum strength of any selected subset of K heroes. :param N: Number of heroes (int) :param K: Number of heroes in the subset (int) :param strengths: List of strengths of heroes (List[int]) :return: Maximum possible value of the minimum strength of the selected subset (int) strengths.sort() def is_valid(mid): count = 0 for strength in strengths: if strength >= mid: count += 1 if count >= K: return True return False left, right = 1, strengths[-1] result = 1 while left <= right: mid = (left + right) // 2 if is_valid(mid): result = mid left = mid + 1 else: right = mid - 1 return result"},{"question":"def char_count(s: str) -> dict: Takes a string consisting of lowercase alphabets and returns a dictionary where the keys are the characters and the values are the number of times each character appears in the string. >>> char_count(\\"abacaba\\") {'a': 4, 'b': 2, 'c': 1} >>> char_count(\\"abc\\") {'a': 1, 'b': 1, 'c': 1}","solution":"def char_count(s): Returns a dictionary where the keys are characters from the input string and the values are the number of times each character appears in the string. result = {} for char in s: if char in result: result[char] += 1 else: result[char] = 1 return result"},{"question":"def last_player_standing(N: int) -> int: Returns the ID of the last player standing in the circle, given that players who have IDs that are powers of 2 are spared until no other player can be eliminated. >>> last_player_standing(5) 4 >>> last_player_standing(7) 4 >>> last_player_standing(1) 1 >>> last_player_standing(8) 8 >>> last_player_standing(200000) 131072 >>> last_player_standing(150000) 131072","solution":"def last_player_standing(N): Returns the ID of the last player standing in the circle, given that players who have IDs that are powers of 2 are spared until no other player can be eliminated. # Find the highest power of 2 less than or equal to N: last_power_of_two = 2**(N.bit_length() - 1) return last_power_of_two"},{"question":"def is_sequential(word: str) -> bool: Determines if the given word can be constructed by successively increasing alphabets, wrapping around from 'z' to 'a' if necessary. >>> is_sequential(\\"abc\\") True >>> is_sequential(\\"bca\\") False >>> is_sequential(\\"azy\\") False >>> is_sequential(\\"aza\\") True","solution":"def is_sequential(word): Determines if the given word can be constructed by successively increasing alphabets, wrapping around from 'z' to 'a' if necessary. :param word: A string containing lowercase alphabets only :return: True if the word is sequential, otherwise False n = len(word) if n == 1: return True for i in range(1, n): prev_char = word[i - 1] curr_char = word[i] if prev_char != 'z': expect_next = chr(ord(prev_char) + 1) else: expect_next = 'a' if curr_char != expect_next: return False return True"}]`),E={name:"App",components:{PoemCard:S},data(){return{searchQuery:"",visibleCount:4,poemsData:R,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},C={class:"search-container"},j={class:"card-container"},P={key:0,class:"empty-state"},D=["disabled"],F={key:0},I={key:1};function z(i,e,u,_,r,a){const f=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"🤔prompts chat🧠")])],-1)),t("div",C,[e[3]||(e[3]=t("span",{class:"search-icon"},"🔍",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")}," ✕ ")):l("",!0)]),t("div",j,[(s(!0),n(x,null,y(a.displayedPoems,(o,p)=>(s(),v(f,{key:p,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",P,' No results found for "'+c(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",I,"Loading...")):(s(),n("span",F,"See more"))],8,D)):l("",!0)])}const O=m(E,[["render",z],["__scopeId","data-v-1baff3e9"]]),B=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"guide/31.md","filePath":"guide/31.md"}'),Y={name:"guide/31.md"},W=Object.assign(Y,{setup(i){return(e,u)=>(s(),n("div",null,[w(O)]))}});export{B as __pageData,W as default};
