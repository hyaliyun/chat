import{_ as d,o as s,c as n,a as t,m,t as _,C as h,M as g,U as b,f as l,F as y,p as x,e as v,q as w}from"./chunks/framework.B1z0IdBH.js";const q={name:"PoemCard",props:{poem:{type:Object,required:!0}}},k={class:"poem-container"},L={class:"review"},T={class:"review-title"},N={class:"review-content"};function A(i,e,u,c,r,a){return s(),n("div",k,[t("div",L,[t("div",T,[e[0]||(e[0]=t("span",{class:"icon"},"question:",-1)),m(_(u.poem.question),1)]),e[2]||(e[2]=t("div",{class:"divider"},null,-1)),t("p",N,[e[1]||(e[1]=t("span",{class:"icon"},"answer:",-1)),m(_(u.poem.solution),1)])])])}const R=d(q,[["render",A],["__scopeId","data-v-1b9a7465"]]),S=JSON.parse(`[{"question":"def shortest_subarray_with_sum(N: int, X: int, prices: List[int]) -> int: Finds the length of the shortest contiguous subarray whose sum equals X. If there are multiple such subarrays, the one with the smallest starting index is chosen. If no such subarray is found, return -1. Args: N (int): The number of gadgets X (int): The exact sum to be matched prices (List[int]): List of gadget prices Returns: int: Length of the shortest subarray with sum equal to X, or -1 if no such subarray exists. Examples: >>> shortest_subarray_with_sum(6, 9, [1, 2, 3, 4, 5, 6]) 2 >>> shortest_subarray_with_sum(5, 50, [1, 2, 3, 4, 5]) -1 from typing import List def test_shortest_subarray_with_sum(): # Sample test case assert shortest_subarray_with_sum(6, 9, [1, 2, 3, 4, 5, 6]) == 2 # Test case where no subarray sums to X assert shortest_subarray_with_sum(5, 50, [1, 2, 3, 4, 5]) == -1 # Test case where entire array sums to X assert shortest_subarray_with_sum(3, 6, [1, 2, 3]) == 3 # Test having multiple subarrays with sum = X assert shortest_subarray_with_sum(7, 15, [1, 2, 3, 4, 5, 5, 10]) == 2 # Test case with smallest subarray at the beginning assert shortest_subarray_with_sum(5, 3, [3, 1, 1, 1, 1]) == 1 # Test case with smallest subarray at the end assert shortest_subarray_with_sum(5, 5, [1, 2, 1, 1, 5]) == 1 # Test for large numbers assert shortest_subarray_with_sum(10, 15, [1000000]*10) == -1 # Test with repeated numbers but with valid subarray in the middle assert shortest_subarray_with_sum(8, 20, [5, 5, 5, 5, 1, 2, 3, 4]) == 4 # Test with multiple valid subarrays assert shortest_subarray_with_sum(6, 5, [1, 1, 1, 1, 1, 1]) == 5 # Edge case with a single element subarray that equals X assert shortest_subarray_with_sum(5, 2, [1, 2, 3, 4, 5]) == 1 if __name__ == \\"__main__\\": test_shortest_subarray_with_sum()","solution":"def shortest_subarray_with_sum(N, X, prices): Finds the length of the shortest contiguous subarray whose sum equals X. If there are multiple such subarrays, the one with the smallest starting index is chosen. If no such subarray is found, return -1. from collections import deque min_length = float('inf') current_sum = 0 start = 0 subarray_indices = (-1, -1) for end in range(N): current_sum += prices[end] while current_sum >= X: if current_sum == X: if (end - start + 1) < min_length: min_length = end - start + 1 subarray_indices = (start, end) current_sum -= prices[start] start += 1 return min_length if min_length != float('inf') else -1"},{"question":"def convert_to_title_case(s: str) -> str: Converts a given string into Title Case, where the first letter of each word is capitalized and the remaining letters are in lowercase. Parameters: s (str): Input string containing only alphabetic characters and spaces. Returns: str: The string converted to Title Case. Examples: >>> convert_to_title_case(\\"hello world\\") 'Hello World' >>> convert_to_title_case(\\"python programming is fun\\") 'Python Programming Is Fun' >>> convert_to_title_case(\\"This Is a Test\\") 'This Is A Test' >>> convert_to_title_case(\\"hELLo woRLd\\") 'Hello World' >>> convert_to_title_case(\\"PyTHoN PrOgRaMmInG Is FuN\\") 'Python Programming Is Fun' >>> convert_to_title_case(\\"HELLO WORLD\\") 'Hello World' >>> convert_to_title_case(\\"PYTHON PROGRAMMING IS FUN\\") 'Python Programming Is Fun'","solution":"def convert_to_title_case(s): Converts a given string into Title Case. Parameters: s (str): Input string containing only alphabetic characters and spaces. Returns: str: The string converted to Title Case. return s.title()"},{"question":"def minimum_spanning_tree(towns: int, road_data: List[List[int]]) -> int: Find the total length of the minimum spanning tree in the given road network. >>> minimum_spanning_tree(5, [[1, 2, 4], [1, 3, 2], [2, 3, 1], [2, 4, 7], [3, 4, 3], [3, 5, 5], [4, 5, 6]]) == 11 >>> minimum_spanning_tree(4, [[1, 2, 1], [1, 3, 2], [1, 4, 3], [2, 3, 4], [3, 4, 5]]) == 6 >>> minimum_spanning_tree(3, [[1, 2, 1], [1, 3, 3], [2, 3, 4]]) == 4 >>> minimum_spanning_tree(4, [[1, 2, 3], [1, 3, 1], [2, 3, 3], [3, 4, 1], [2, 4, 8]]) == 5","solution":"import heapq def find(parent, i): A function to find the set of an element i (uses path compression technique) if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): A function that does union of two sets of x and y (uses union by rank) xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal_mst(towns, roads): Function to construct MST using Kruskal's algorithm result = [] # Step 1: Sort all the edges in non-decreasing order of their weight. roads = sorted(roads, key=lambda item: item[2]) parent = [] rank = [] # Create V subsets with single elements for node in range(towns): parent.append(node) rank.append(0) # Number of edges to be taken is equal to V-1 e = 0 i = 0 # Step 2: Pick the smallest edge. Check if it forms a cycle with the spanning tree # formed so far. If cycle is not formed, include this edge. Else, discard it. while e < towns - 1: # Step 2.1: Pick the smallest edge and increment the index for next iteration u, v, w = roads[i] i = i + 1 x = find(parent, u - 1) y = find(parent, v - 1) # If including this edge does't cause cycle, include it in result and increment # the index of result for next edge if x != y: e = e + 1 result.append([u, v, w]) union(parent, rank, x, y) # Else discard the edge # Print the contents of result[] to display the built MST minimum_cost = sum([w for u, v, w in result]) return minimum_cost def minimum_spanning_tree(towns, road_data): return kruskal_mst(towns, road_data)"},{"question":"from typing import List import math from functools import reduce def gcd(a: int, b: int) -> int: return math.gcd(a, b) def gcd_of_list(lst: List[int]) -> int: return reduce(gcd, lst) def gcd_of_subarray(arr: List[int], l: int, r: int) -> int: Given a list of integers, find the GCD of the subarray specified by the range [l, r]. >>> gcd_of_subarray([2, 3, 6, 9, 5], 1, 3) 1 >>> gcd_of_subarray([2, 3, 6, 9, 5], 2, 5) 1 >>> gcd_of_subarray([2, 3, 6, 9, 5], 1, 5) 1 subarray = arr[l-1:r] return gcd_of_list(subarray) # Unit tests def test_gcd_of_subarray_case1(): arr = [2, 3, 6, 9, 5] assert gcd_of_subarray(arr, 1, 3) == 1 def test_gcd_of_subarray_case2(): arr = [2, 3, 6, 9, 5] assert gcd_of_subarray(arr, 2, 5) == 1 def test_gcd_of_subarray_case3(): arr = [2, 3, 6, 9, 5] assert gcd_of_subarray(arr, 1, 5) == 1 def test_gcd_of_subarray_single_element(): arr = [2, 3, 6, 9, 5] assert gcd_of_subarray(arr, 2, 2) == 3 def test_gcd_of_subarray_entire_array(): arr = [2, 4, 6, 8] assert gcd_of_subarray(arr, 1, 4) == 2 def test_gcd_of_subarray_with_trivial_gcd(): arr = [5, 10, 15, 20] assert gcd_of_subarray(arr, 1, 4) == 5 def test_gcd_of_subarray_all_same_elements(): arr = [7, 7, 7, 7] assert gcd_of_subarray(arr, 1, 4) == 7 def test_gcd_of_subarray_subarray_with_common_divisor(): arr = [2, 4, 8, 16] assert gcd_of_subarray(arr, 2, 3) == 4","solution":"import math from functools import reduce def gcd(a, b): return math.gcd(a, b) def gcd_of_list(lst): return reduce(gcd, lst) def gcd_of_subarray(arr, l, r): subarray = arr[l-1:r] return gcd_of_list(subarray)"},{"question":"def longest_palindrome_length(s: str) -> int: Determine the length of the longest palindrome that can be constructed using the characters of the string. >>> longest_palindrome_length(\\"abccccdd\\") 7 >>> longest_palindrome_length(\\"a\\") 1 def process_test_cases(test_cases: List[str]) -> List[int]: For each test case, print the length of the longest possible palindrome that can be constructed using the characters of the string. >>> process_test_cases([\\"abccccdd\\", \\"a\\", \\"abc\\", \\"aaabbb\\", \\"abacaba\\"]) [7, 1, 1, 5, 7]","solution":"def longest_palindrome_length(s): from collections import Counter char_counts = Counter(s) length = 0 odd_count_found = False for char, count in char_counts.items(): if count % 2 == 0: length += count else: length += count - 1 odd_count_found = True if odd_count_found: length += 1 return length def process_test_cases(test_cases): results = [] for s in test_cases: result = longest_palindrome_length(s) results.append(result) return results"},{"question":"def find_min_toll(N: int, M: int, roads: List[Tuple[int, int, int]]) -> int: Given the number of cities and list of roads with their toll fees, determine the minimized total toll fee after disconnecting unnecessary roads while ensuring the network remains connected. Parameters: - N: int, number of cities - M: int, number of roads - roads: List[Tuple[int, int, int]], list of roads where each tuple represents (u, v, w) Returns: - int: minimized total toll fee pass # Test cases def test_find_min_toll_example(): N, M = 4, 5 roads = [ (1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5) ] assert find_min_toll(N, M, roads) == 6 def test_find_min_toll_basic(): N, M = 3, 3 roads = [ (1, 2, 1), (2, 3, 1), (1, 3, 3) ] assert find_min_toll(N, M, roads) == 2 def test_find_min_toll_larger_graph(): N, M = 5, 7 roads = [ (1, 2, 3), (2, 3, 1), (3, 4, 4), (4, 5, 2), (1, 3, 5), (2, 4, 2), (3, 5, 6) ] assert find_min_toll(N, M, roads) == 8 def test_find_min_toll_disconnected_graph(): N, M = 4, 4 roads = [ (1, 2, 1), (1, 3, 3), (2, 3, 2), (3, 4, 4) ] assert find_min_toll(N, M, roads) == 7 def test_find_min_toll_identical_costs(): N, M = 4, 4 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 1, 1) ] assert find_min_toll(N, M, roads) == 3","solution":"def find_min_toll(N, M, roads): Finds the minimum toll fees to keep the network operational using Kruskal's algorithm to find the Minimum Spanning Tree (MST). Parameters: N (int): Number of cities M (int): Number of roads roads (list): List of tuples where each tuple contains (u, v, w) Returns: int: The minimized total toll fee # Initialize parent and rank arrays for union-find operation parent = list(range(N + 1)) rank = [0] * (N + 1) def find(u): if parent[u] != u: parent[u] = find(parent[u]) return parent[u] def union(u, v): root_u = find(u) root_v = find(v) if root_u != root_v: if rank[root_u] > rank[root_v]: parent[root_v] = root_u elif rank[root_u] < rank[root_v]: parent[root_u] = root_v else: parent[root_v] = root_u rank[root_u] += 1 # Sort all the roads based on their toll fees roads.sort(key=lambda x: x[2]) mst_cost = 0 edges_used = 0 for u, v, w in roads: if find(u) != find(v): union(u, v) mst_cost += w edges_used += 1 if edges_used == N - 1: break return mst_cost"},{"question":"class DrawingApplication: def __init__(self): pass def add_rectangle(self, id, x, y, width, height): pass def add_circle(self, id, x, y, radius): pass def resize_rectangle(self, id, new_width, new_height): pass def resize_circle(self, id, new_radius): pass def move_shape(self, id, new_x, new_y): pass def process_commands(self, commands): pass def get_final_state(self): pass def execute_drawing_commands(n, commands): Interpret and execute a list of drawing commands to render basic shapes. :param n: Number of drawing commands :param commands: List of drawing commands :return: Final state of each shape after processing all commands Example: >>> commands = [ \\"AR rect1 10 10 20 30\\", \\"AC circle1 15 15 10\\", \\"M rect1 25 25\\", \\"RR rect1 40 50\\", \\"RC circle1 20\\" ] >>> execute_drawing_commands(5, commands) [\\"Rectangle rect1 at (25, 25) with width 40 and height 50\\", \\"Circle circle1 at (15, 15) with radius 20\\"] app = DrawingApplication() app.process_commands(commands) return app.get_final_state() from solution import execute_drawing_commands def test_example_case(): commands = [ \\"AR rect1 10 10 20 30\\", \\"AC circle1 15 15 10\\", \\"M rect1 25 25\\", \\"RR rect1 40 50\\", \\"RC circle1 20\\" ] expected = [ \\"Rectangle rect1 at (25, 25) with width 40 and height 50\\", \\"Circle circle1 at (15, 15) with radius 20\\" ] assert execute_drawing_commands(5, commands) == expected def test_add_multiple_shapes(): commands = [ \\"AR rect1 0 0 10 20\\", \\"AR rect2 10 10 5 15\\", \\"AC circle1 5 5 10\\", \\"AC circle2 10 10 20\\" ] expected = [ \\"Rectangle rect1 at (0, 0) with width 10 and height 20\\", \\"Rectangle rect2 at (10, 10) with width 5 and height 15\\", \\"Circle circle1 at (5, 5) with radius 10\\", \\"Circle circle2 at (10, 10) with radius 20\\" ] assert execute_drawing_commands(4, commands) == expected def test_resize_and_move_shapes(): commands = [ \\"AR rect1 0 0 10 20\\", \\"AC circle1 5 5 10\\", \\"RR rect1 20 30\\", \\"RC circle1 15\\", \\"M rect1 10 10\\", \\"M circle1 20 20\\" ] expected = [ \\"Rectangle rect1 at (10, 10) with width 20 and height 30\\", \\"Circle circle1 at (20, 20) with radius 15\\" ] assert execute_drawing_commands(6, commands) == expected def test_no_shape(): commands = [] expected = [] assert execute_drawing_commands(0, commands) == expected def test_invalid_commands(): commands = [ \\"AR rect1 10 10 20 30\\", \\"INVALID_CMD\\", \\"RR rect1 40 50\\", \\"XYZ_CMD\\" ] expected = [ \\"Rectangle rect1 at (10, 10) with width 40 and height 50\\" ] assert execute_drawing_commands(4, commands) == expected","solution":"class DrawingApplication: def __init__(self): self.shapes = {} self.order = [] def add_rectangle(self, id, x, y, width, height): self.shapes[id] = {\\"type\\": \\"Rectangle\\", \\"x\\": x, \\"y\\": y, \\"width\\": width, \\"height\\": height} self.order.append(id) def add_circle(self, id, x, y, radius): self.shapes[id] = {\\"type\\": \\"Circle\\", \\"x\\": x, \\"y\\": y, \\"radius\\": radius} self.order.append(id) def resize_rectangle(self, id, new_width, new_height): if id in self.shapes and self.shapes[id][\\"type\\"] == \\"Rectangle\\": self.shapes[id][\\"width\\"] = new_width self.shapes[id][\\"height\\"] = new_height def resize_circle(self, id, new_radius): if id in self.shapes and self.shapes[id][\\"type\\"] == \\"Circle\\": self.shapes[id][\\"radius\\"] = new_radius def move_shape(self, id, new_x, new_y): if id in self.shapes: self.shapes[id][\\"x\\"] = new_x self.shapes[id][\\"y\\"] = new_y def process_commands(self, commands): for command in commands: parts = command.split() if parts[0] == \\"AR\\": self.add_rectangle(parts[1], int(parts[2]), int(parts[3]), int(parts[4]), int(parts[5])) elif parts[0] == \\"AC\\": self.add_circle(parts[1], int(parts[2]), int(parts[3]), int(parts[4])) elif parts[0] == \\"RR\\": self.resize_rectangle(parts[1], int(parts[2]), int(parts[3])) elif parts[0] == \\"RC\\": self.resize_circle(parts[1], int(parts[2])) elif parts[0] == \\"M\\": self.move_shape(parts[1], int(parts[2]), int(parts[3])) def get_final_state(self): result = [] for id in self.order: shape = self.shapes[id] if shape[\\"type\\"] == \\"Rectangle\\": result.append(f\\"Rectangle {id} at ({shape['x']}, {shape['y']}) with width {shape['width']} and height {shape['height']}\\") elif shape[\\"type\\"] == \\"Circle\\": result.append(f\\"Circle {id} at ({shape['x']}, {shape['y']}) with radius {shape['radius']}\\") return result def execute_drawing_commands(n, commands): app = DrawingApplication() app.process_commands(commands) return app.get_final_state()"},{"question":"def count_unique_pairs_with_difference_k(arr, k): Count the number of unique pairs (a, b) in the array such that |a - b| = k. >>> count_unique_pairs_with_difference_k([1, 5, 3, 4, 2], 2) 3 >>> count_unique_pairs_with_difference_k([1, 2, 3, 4], 1) 3 >>> count_unique_pairs_with_difference_k([1, 1, 1], 0) 3 >>> count_unique_pairs_with_difference_k([1, 6, 11, 16], 5) 3 >>> count_unique_pairs_with_difference_k([1, 2, 3], 4) 0 pass def process_test_cases(test_cases): results = [] for n, k, arr in test_cases: results.append(count_unique_pairs_with_difference_k(arr, k)) return results","solution":"def count_unique_pairs_with_difference_k(arr, k): Count the number of unique pairs (a, b) in the array such that |a - b| = k. if k == 0: return sum(arr.count(x) * (arr.count(x) - 1) // 2 for x in set(arr)) elements = set(arr) unique_pairs = set() for elem in elements: if elem + k in elements: unique_pairs.add((min(elem, elem + k), max(elem, elem + k))) if elem - k in elements: unique_pairs.add((min(elem, elem - k), max(elem, elem - k))) return len(unique_pairs) def process_test_cases(test_cases): results = [] for n, k, arr in test_cases: results.append(count_unique_pairs_with_difference_k(arr, k)) return results"},{"question":"def find_task_order(n: int, dependencies: List[Tuple[int, int]]) -> List[int]: Determines a valid execution order of tasks or returns an empty list if a valid order is not possible. Parameters: - n: integer, number of tasks - dependencies: list of tuples, each containing two integers (x, y) indicating task x must precede task y Returns: - list of integers, representing the task execution order, or an empty list if no valid order exists. Examples: >>> find_task_order(5, [[2, 3], [3, 1], [4, 0], [4, 1], [5, 2]]) [4, 5, 2, 3, 1, 0] >>> find_task_order(3, [[1, 2], [2, 3], [3, 1]]) [] >>> find_task_order(3, []) [1, 2, 3]","solution":"from collections import defaultdict, deque def find_task_order(n, dependencies): Determines a valid execution order of tasks or returns an empty list if a valid order is not possible. Parameters: - n: integer, number of tasks - dependencies: list of tuples, each containing two integers (x, y) indicating task x must precede task y Returns: - list of integers, representing the task execution order, or an empty list if no valid order exists. # Create an adjacency list and in-degree list adjacency_list = defaultdict(list) in_degree = [0] * n # Fill the adjacency list and in-degree list for x, y in dependencies: adjacency_list[x - 1].append(y - 1) in_degree[y - 1] += 1 # Queue for nodes with in-degree of 0 queue = deque([i for i in range(n) if in_degree[i] == 0]) order = [] while queue: node = queue.popleft() order.append(node + 1) # Convert back to 1-based index for neighbor in adjacency_list[node]: in_degree[neighbor] -= 1 if in_degree[neighbor] == 0: queue.append(neighbor) if len(order) == n: return order else: return []"},{"question":"def max_energy(crystals): Returns the maximum energy the wizard can collect without picking adjacent crystals. >>> max_energy([3, 2, 5, 10, 7]) == 15 >>> max_energy([3, 5, -7, 8]) == 13 >>> max_energy([-1, -2, -3, -4]) == 0 >>> max_energy([-1, 2, -3, 4]) == 6 >>> max_energy([1, -2, 3, -4, 5]) == 9 >>> max_energy([1000000, -1000000, 1000000]) == 2000000","solution":"def max_energy(crystals): Returns the maximum energy the wizard can collect without picking adjacent crystals. if not crystals: return 0 n = len(crystals) if n == 1: return max(0, crystals[0]) # Initialize dp array dp = [0] * n dp[0] = max(0, crystals[0]) if n > 1: dp[1] = max(dp[0], crystals[1]) # Fill dp array using the recurrence relation for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + max(0, crystals[i])) return dp[-1]"},{"question":"def find_paths(grid): Find the number of distinct paths from the top-left corner to the bottom-right corner in a grid where some cells are inaccessible. Parameters: grid (List[List[int]]): A 2D list representing the grid, where 0 is an accessible cell and -1 is an inaccessible cell. Returns: int: The number of distinct paths from the top-left to the bottom-right corner. Examples: >>> find_paths([[0, 0, 0], [0, -1, 0], [0, 0, 0]]) 2 >>> find_paths([[0, -1, 0], [-1, 0, 0], [0, 0, 0]]) 0 # Write your code here def process_input(input_data): Process the input data to extract grid information and calculate the number of distinct paths for each dataset. Parameters: input_data (str): The input data in the specified format. Returns: List[int]: A list providing the number of distinct paths for each dataset. Examples: >>> process_input(\\"3 3n0 0 0n0 -1 0n0 0 0n0\\") [2] >>> process_input(\\"3 3n0 -1 0n-1 0 0n0 0 0n0\\") [0] # Write your code here","solution":"def find_paths(grid): m = len(grid) n = len(grid[0]) if grid[0][0] == -1 or grid[m-1][n-1] == -1: return 0 dp = [[0] * n for _ in range(m)] dp[0][0] = 1 for i in range(m): for j in range(n): if grid[i][j] == -1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[-1][-1] def process_input(input_data): results = [] lines = input_data.splitlines() i = 0 while i < len(lines): line = lines[i] if line == \\"0\\": break m, n = map(int, line.split()) i += 1 grid = [] for _ in range(m): grid.append(list(map(int, lines[i].split()))) i += 1 results.append(find_paths(grid)) return results"},{"question":"def min_swaps_to_permutation(nums): Returns the minimum number of swap operations needed to transform the array into a permutation of the numbers from 0 to n-1. >>> min_swaps_to_permutation([1, 0, 3, 2]) 2 >>> min_swaps_to_permutation([4, 2, 0, 3, 1]) 3 pass def solve(test_cases): Solve the test cases by transforming each array into a permutation of the numbers from 0 to n-1. >>> solve([[1, 0, 3, 2], [4, 2, 0, 3, 1], [2, 1, 0]]) [2, 3, 1] >>> solve([[0, 1, 2, 3], [3, 2, 1, 0]]) [0, 2] pass","solution":"def min_swaps_to_permutation(nums): Returns the minimum number of swap operations needed to transform the array into a permutation of the numbers from 0 to n-1. n = len(nums) positions = { value: idx for idx, value in enumerate(nums) } swaps = 0 for i in range(n): while nums[i] != i: swap_with_index = positions[i] nums[i], nums[swap_with_index] = nums[swap_with_index], nums[i] positions[nums[swap_with_index]] = swap_with_index swaps += 1 return swaps def solve(test_cases): results = [] for nums in test_cases: results.append(min_swaps_to_permutation(nums)) return results"},{"question":"def divide_field(D, datasets): Simulate the process of dividing a farmer's rectangular field into smaller plots. Parameters: D (int): Number of data sets. datasets (list of tuples): Each tuple contains: - Length and width of the field. - Number of divisions. - List of division points along the length. Returns: List of tuples: Each tuple contains the total number of plots created and a list of their areas. Example: >>> D = 2 >>> datasets = [(10, 3, 2, [4, 7]), (12, 2, 3, [3, 6, 9])] >>> divide_field(D, datasets) [(3, [12, 9, 9]), (4, [6, 6, 6, 6])] >>> D = 1 >>> datasets = [(10, 3, 0, [])] >>> divide_field(D, datasets) [(1, [30])] pass def process_input(input_str): Process the input string to extract the number of datasets and the datasets themselves. Parameters: input_str (str): Multi-line string containing the input data. Returns: Tuple: Number of data sets and a list of tuples representing the datasets. Example: >>> input_str = \\"2n10 3n2n4n7n12 2n3n3n6n9n\\" >>> process_input(input_str) (2, [(10, 3, 2, [4, 7]), (12, 2, 3, [3, 6, 9])]) pass import pytest def test_divide_field_example(): input_data = \\"2n10 3n2n4n7n12 2n3n3n6n9n\\" D, datasets = process_input(input_data) expected_output = [ (3, [12, 9, 9]), (4, [6, 6, 6, 6]) ] assert divide_field(D, datasets) == expected_output def test_divide_field_no_division(): input_data = \\"1n10 3n0n\\" D, datasets = process_input(input_data) expected_output = [ (1, [30]) ] assert divide_field(D, datasets) == expected_output def test_divide_field_single_division(): input_data = \\"1n10 2n1n5n\\" D, datasets = process_input(input_data) expected_output = [ (2, [10, 10]) ] assert divide_field(D, datasets) == expected_output def test_divide_field_multiple_divisions(): input_data = \\"1n15 4n3n3n7n10n\\" D, datasets = process_input(input_data) expected_output = [ (4, [12, 16, 12, 20]) ] assert divide_field(D, datasets) == expected_output def test_process_input(): input_data = \\"2n10 3n2n4n7n12 2n3n3n6n9n\\" D, datasets = process_input(input_data) expected_datasets = [ (10, 3, 2, [4, 7]), (12, 2, 3, [3, 6, 9]) ] assert D == 2 assert datasets == expected_datasets if __name__ == \\"__main__\\": pytest.main()","solution":"def divide_field(D, datasets): results = [] for data in datasets: L, W, N, divisions = data divisions.sort() plots = [] previous = 0 for d in divisions: plots.append(d - previous) previous = d plots.append(L - previous) areas = [plot * W for plot in plots] results.append((len(plots), areas)) return results def process_input(input_str): input_lines = input_str.strip().split(\\"n\\") D = int(input_lines[0]) datasets = [] index = 1 for _ in range(D): L, W = map(int, input_lines[index].split()) N = int(input_lines[index + 1]) divisions = [int(input_lines[index + 2 + i]) for i in range(N)] datasets.append((L, W, N, divisions)) index += 2 + N return D, datasets"},{"question":"from typing import List def min_swaps_to_sort_heights(n: int, heights: List[int]) -> int: Returns the minimum number of swaps required to sort the list of heights in non-decreasing order. >>> min_swaps_to_sort_heights(5, [2, 3, 4, 1, 5]) 3 >>> min_swaps_to_sort_heights(4, [4, 3, 2, 1]) 2 >>> min_swaps_to_sort_heights(6, [1, 3, 5, 2, 4, 6]) 3 >>> min_swaps_to_sort_heights(1, [10]) 0","solution":"def min_swaps_to_sort_heights(n, heights): Returns the minimum number of swaps required to sort the list of heights in non-decreasing order. indexed_heights = [(heights[i], i) for i in range(n)] # pair of (value, index) indexed_heights.sort() # sort based on the heights visited = [False] * n swaps = 0 for i in range(n): if visited[i] or indexed_heights[i][1] == i: continue cycle_length = 0 j = i while not visited[j]: visited[j] = True j = indexed_heights[j][1] cycle_length += 1 if cycle_length > 0: swaps += (cycle_length - 1) return swaps"},{"question":"def can_form_class_photo(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Determine if it is possible to rearrange students in each class to form a class photo. Args: T: Number of test cases. test_cases: A list of tuples where each tuple contains: - An integer N indicating the number of students in each class. - A list of integers representing the heights of students in class A. - A list of integers representing the heights of students in class B. Returns: A list of strings \\"Yes\\" or \\"No\\" for each test case. Examples: >>> can_form_class_photo(2, [(3, [5, 8, 11], [6, 9, 12]), (4, [4, 6, 7, 10], [12, 1, 8, 7])]) [\\"Yes\\", \\"No\\"] >>> can_form_class_photo(1, [(3, [5, 5, 5], [5, 5, 5])]) [\\"No\\"] >>> can_form_class_photo(1, [(3, [5, 5, 5], [6, 6, 6])]) [\\"Yes\\"] >>> can_form_class_photo(1, [(3, [6, 6, 6], [5, 5, 5])]) [\\"Yes\\"] >>> can_form_class_photo(1, [(5, [1, 2, 3, 4, 5], [5, 4, 3, 2, 1])]) [\\"No\\"]","solution":"def can_form_class_photo(T, test_cases): results = [] for case in test_cases: N, class_A, class_B = case class_A.sort() class_B.sort() # Check if class A can be strictly lesser than class B is_A_less_than_B = all(a < b for a, b in zip(class_A, class_B)) # Check if class A can be strictly greater than class B is_A_greater_than_B = all(a > b for a, b in zip(class_A, class_B)) if is_A_less_than_B or is_A_greater_than_B: results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def sort_books(n: int, books: List[Tuple[str, str, int]]) -> List[Tuple[str, str, int]]: Sort the books first by genre in alphabetical order and then by their identifier in ascending order within each genre. Args: n (int): Number of books. books (list of tuples): List of books where each tuple is (book_name, genre, identifier). Returns: list of tuples: Sorted list of books. >>> sort_books(4, [(\\"harry potter\\", \\"fantasy\\", 1), (\\"the hobbit\\", \\"fantasy\\", 2), (\\"a brief history of time\\", \\"science\\", 1), (\\"the art of computer programming\\", \\"science\\", 2)]) [('harry potter', 'fantasy', 1), ('the hobbit', 'fantasy', 2), ('a brief history of time', 'science', 1), ('the art of computer programming', 'science', 2)] >>> sort_books(3, [(\\"war and peace\\", \\"literature\\", 2), (\\"the great gatsby\\", \\"literature\\", 1), (\\"moby dick\\", \\"literature\\", 3)]) [('the great gatsby', 'literature', 1), ('war and peace', 'literature', 2), ('moby dick', 'literature', 3)] >>> sort_books(0, []) [] >>> sort_books(1, [(\\"1984\\", \\"dystopian\\", 1)]) [(\\"1984\\", \\"dystopian\\", 1)]","solution":"def sort_books(n, books): Sort the books first by genre in alphabetical order and then by their identifier in ascending order within each genre. Args: n (int): Number of books. books (list of tuples): List of books where each tuple is (book_name, genre, identifier). Returns: list of tuples: Sorted list of books. if not books: return [] # Sort the books by genre and then by identifier within each genre sorted_books = sorted(books, key=lambda x: (x[1], x[2])) return sorted_books"},{"question":"def max_ants(n: int, m: int, ants: List[int], tunnels: List[Tuple[int, int]]) -> int: Calculate the maximum number of ants that can end up in any chamber after moving through the tunnels optimally. >>> max_ants(4, 4, [3, 0, 0, 0], [(1, 2), (2, 3), (3, 4), (1, 3)]) 24 >>> max_ants(5, 6, [1, 0, 2, 0, 0], [(1, 2), (1, 3), (2, 4), (3, 4), (4, 5), (2, 5)]) 8","solution":"from collections import defaultdict, deque def max_ants(n, m, ants, tunnels): graph = defaultdict(list) in_degrees = [0] * n max_ants_in_chamber = ants[:] for u, v in tunnels: graph[u - 1].append(v - 1) in_degrees[v - 1] += 1 queue = deque([i for i in range(n) if in_degrees[i] == 0]) while queue: u = queue.popleft() for v in graph[u]: max_ants_in_chamber[v] = max(max_ants_in_chamber[v], 2 * max_ants_in_chamber[u]) in_degrees[v] -= 1 if in_degrees[v] == 0: queue.append(v) return max(max_ants_in_chamber)"},{"question":"from typing import List, Tuple def sieve_primes_upto(limit: int) -> set: Returns a set of all primes up to the specified limit. is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers primes = set() for p in range(limit + 1): if is_prime[p]: primes.add(p) return primes def sum_of_unique_primes(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: For each query, returns the sum of all the unique prime numbers in the subarray from L to R (inclusive). >>> sum_of_unique_primes([2, 3, 4, 5, 6], [(1, 3), (2, 4), (1, 5)]) [5, 8, 10] >>> sum_of_unique_primes([10, 15, 21, 25, 30], [(1, 3), (3, 5), (1, 5)]) [0, 0, 0]","solution":"def sieve_primes_upto(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers primes = set() for p in range(limit + 1): if is_prime[p]: primes.add(p) return primes def sum_of_unique_primes(arr, queries): max_val = max(arr) primes = sieve_primes_upto(max_val) result = [] for L, R in queries: subarray = arr[L-1:R] unique_primes = set(filter(lambda x: x in primes, subarray)) result.append(sum(unique_primes)) return result"},{"question":"def total_effort(n: int, elevations: List[int]) -> int: Calculate the total effort required for passing the baton in a relay race. :param n: Number of segments in the race track. :param elevations: List of elevation differences for each segment. :return: Total effort required. # Example usage: # total_effort(5, [3, -2, 5, 0, 2]) == 10 # total_effort(3, [-1, -4, 0]) == 0 from solution import total_effort def test_example_1(): assert total_effort(5, [3, -2, 5, 0, 2]) == 10 def test_example_2(): assert total_effort(3, [-1, -4, 0]) == 0 def test_example_3(): assert total_effort(4, [1, 2, -1, 3]) == 6 def test_all_negative(): assert total_effort(5, [-5, -3, -2, -1, -4]) == 0 def test_mixed_elevations(): assert total_effort(6, [-2, 3, -1, 4, 0, 1]) == 8 def test_single_positive(): assert total_effort(1, [7]) == 7 def test_single_negative(): assert total_effort(1, [-7]) == 0 def test_all_zeroes(): assert total_effort(4, [0, 0, 0, 0]) == 0","solution":"def total_effort(n, elevations): Calculate the total effort required for passing the baton in a relay race. :param n: Number of segments in the race track. :param elevations: List of elevation differences for each segment. :return: Total effort required. return sum(elev for elev in elevations if elev > 0)"},{"question":"from typing import List, Tuple, Union def find_max_values(data_entries: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[Union[int, str]]: Find the maximum value for each time range in queries from the list of data entries. :param data_entries: List of tuples [(Ti, Vi)] :param queries: List of tuples [(L, R)] :return: List of maximum values or \\"No data\\" for each query pass import bisect def process_input(input_data: str) -> List[Union[int, str]]: input_lines = input_data.strip().split('n') N, M = map(int, input_lines[0].split()) data_entries = [tuple(map(int, line.split())) for line in input_lines[1:N+1]] queries = [tuple(map(int, line.split())) for line in input_lines[N+1:N+M+1]] return find_max_values(data_entries, queries) def test_find_max_values(): data_entries = [ (1, 5), (3, 10), (5, 7), (6, 9), (8, 12), (10, 6) ] queries = [ (2, 5), (1, 7), (4, 9) ] expected = [10, 10, 12] assert find_max_values(data_entries, queries) == expected data_entries = [ (1, 5), (3, 10) ] queries = [ (2, 2), (5, 6) ] expected = [\\"No data\\", \\"No data\\"] assert find_max_values(data_entries, queries) == expected def test_find_max_values_with_edge_cases(): data_entries = [ (1, 5), (1, 10), (1, 7), (1, 9), ] queries = [ (1, 2) ] expected = [10] assert find_max_values(data_entries, queries) == expected def test_process_input(): input_data = \\"6 3n1 5n3 10n5 7n6 9n8 12n10 6n2 5n1 7n4 9\\" expected = [10, 10, 12] assert process_input(input_data) == expected if __name__ == \\"__main__\\": test_find_max_values() test_find_max_values_with_edge_cases() test_process_input() print(\\"All tests passed!\\")","solution":"def find_max_values(data_entries, queries): Find the maximum value for each time range in queries from the list of data entries. :param data_entries: List of tuples [(Ti, Vi)] :param queries: List of tuples [(L, R)] :return: List of maximum values or \\"No data\\" for each query import bisect # Sort data entries by timestamp data_entries.sort() # Extract separated lists for timestamps and values timestamps = [entry[0] for entry in data_entries] values = [entry[1] for entry in data_entries] results = [] # For each query range (L, R) for L, R in queries: # Find the index range in the timestamps list using binary search left_index = bisect.bisect_left(timestamps, L) right_index = bisect.bisect_right(timestamps, R) if right_index > left_index: # Get the maximum value in the range max_value = max(values[left_index:right_index]) results.append(max_value) else: results.append(\\"No data\\") return results def process_input(input_data): input_lines = input_data.strip().split('n') N, M = map(int, input_lines[0].split()) data_entries = [tuple(map(int, line.split())) for line in input_lines[1:N+1]] queries = [tuple(map(int, line.split())) for line in input_lines[N+1:N+M+1]] return find_max_values(data_entries, queries)"},{"question":"def compute_total_slowdown(n: int, m: int, obstacles: List[Tuple[int, int]]) -> List[List[int]]: Computes the total slowdown for each participant after each obstacle. :param n: int, number of participants :param m: int, number of obstacles :param obstacles: List of tuples, each containing (xi, yi) :return: List of lists, each containing the total slowdown for each participant pass # Replace with the actual implementation # Unit Test def test_compute_total_slowdown(): assert compute_total_slowdown(3, 4, [(100, 5), (200, 3), (150, 2), (300, 4)]) == [ [5, 8, 10, 14], [5, 8, 10, 14], [5, 8, 10, 14] ] assert compute_total_slowdown(2, 3, [(50, 1), (100, 2), (150, 3)]) == [ [1, 3, 6], [1, 3, 6] ] assert compute_total_slowdown(1, 1, [(0, 1)]) == [ [1] ] assert compute_total_slowdown(2, 2, [(0, 1), (1000, 100)]) == [ [1, 101], [1, 101] ] assert compute_total_slowdown(3, 3, [(10, 2), (20, 3), (30, 5)]) == [ [2, 5, 10], [2, 5, 10], [2, 5, 10] ]","solution":"def compute_total_slowdown(n, m, obstacles): Computes the total slowdown for each participant after each obstacle. :param n: int, number of participants :param m: int, number of obstacles :param obstacles: List of tuples, each containing (xi, yi) :return: List of lists, each containing the total slowdown for each participant cumulative_slowdowns = [0] * m total_slowdown = 0 for i in range(m): total_slowdown += obstacles[i][1] cumulative_slowdowns[i] = total_slowdown result = [] for _ in range(n): result.append(cumulative_slowdowns) return result"},{"question":"def max_users_logged_in(timestamps: List[Tuple[int, int]]) -> int: Given a list of timestamps representing when users logged into a system, determine the maximum number of users that were logged in at the same time. >>> max_users_logged_in([(1, 4), (2, 5), (3, 6), (5, 7), (6, 8)]) 3 >>> max_users_logged_in([(10, 20), (15, 25), (20, 30)]) 2 >>> max_users_logged_in([(1, 2), (3, 4), (5, 6)]) 1 >>> max_users_logged_in([(1, 5), (2, 6), (3, 7), (4, 8)]) 4 >>> max_users_logged_in([(5, 6)]) 1 >>> max_users_logged_in([(i, i+1) for i in range(1000)]) 1 >>> max_users_logged_in([(i, i+2) for i in range(50000)]) 2","solution":"def max_users_logged_in(timestamps): events = [] for login, logout in timestamps: events.append((login, 1)) # A user logs in events.append((logout, -1)) # A user logs out events.sort() max_users = current_users = 0 for time, event in events: current_users += event max_users = max(max_users, current_users) return max_users"},{"question":"def minMeetingRooms(intervals: List[Tuple[int, int]]) -> int: Given an array of meeting time intervals consisting of start and end times, determine the minimum number of meeting rooms required. Args: intervals (List[Tuple[int, int]]): A list of (start, end) intervals for meetings. Returns: int: The minimum number of meeting rooms required to accommodate all meetings. >>> minMeetingRooms([(1, 4), (2, 5), (7, 9)]) 2 >>> minMeetingRooms([(3, 6), (1, 4), (5, 8), (2, 3)]) 2 >>> minMeetingRooms([(1, 3), (3, 6), (6, 9)]) 1 >>> minMeetingRooms([(0, 30), (5, 10), (15, 20)]) 2 >>> minMeetingRooms([]) 0 >>> minMeetingRooms([(1, 10), (2, 7), (3, 5), (8, 9)]) 3 >>> minMeetingRooms([(0, 30), (5, 10), (15, 20), (25, 35)]) 2","solution":"def minMeetingRooms(intervals): Given an array of meeting time intervals consisting of start and end times, determine the minimum number of meeting rooms required. Args: intervals (List[Tuple[int, int]]): A list of (start, end) intervals for meetings. Returns: int: The minimum number of meeting rooms required to accommodate all meetings. if not intervals: return 0 # Create two separate lists for start and end times starts = sorted([i[0] for i in intervals]) ends = sorted([i[1] for i in intervals]) s_ptr, e_ptr = 0, 0 # Start pointers for both lists num_rooms = 0 max_rooms = 0 while s_ptr < len(intervals): # If there's a meeting that has started by the time the current meeting ends, # we need a new room. if starts[s_ptr] < ends[e_ptr]: num_rooms += 1 s_ptr += 1 else: # Otherwise, we can use the same room. num_rooms -= 1 e_ptr += 1 max_rooms = max(max_rooms, num_rooms) return max_rooms # Example usage: # n = int(input()) # meetings = [tuple(map(int, input().split())) for _ in range(n)] # print(minMeetingRooms(meetings))"},{"question":"def has_pair_with_sum(arr, x): Check if there exists a pair of distinct elements in the array that sum up to x. :param arr: List of integers :param x: Target sum :return: \\"YES\\" if there's a pair with sum x, otherwise \\"NO\\" >>> has_pair_with_sum([1, 3, 4, 2, 7], 9) \\"YES\\" >>> has_pair_with_sum([1, 2, 3, 4], 8) \\"NO\\" >>> has_pair_with_sum([1], 2) \\"NO\\" >>> has_pair_with_sum([1, 1], 2) \\"YES\\" >>> has_pair_with_sum([5, 6, 7, 8], 3) \\"NO\\" >>> has_pair_with_sum([1000000000, 1000000000], 2000000000) \\"YES\\" >>> has_pair_with_sum([1, 1, 1, 1, 1, 8], 9) \\"YES\\" >>> has_pair_with_sum([-1, -2, -3, 1, 2, 3], 0) \\"YES\\" >>> has_pair_with_sum([10, 20, 30, 40, 50], 80) \\"YES\\" >>> has_pair_with_sum([10, 20, 30, 40, 50], 5) \\"NO\\"","solution":"def has_pair_with_sum(arr, x): Check if there exists a pair of distinct elements in the array that sum up to x. :param arr: List of integers :param x: Target sum :return: \\"YES\\" if there's a pair with sum x, otherwise \\"NO\\" seen = set() for number in arr: if x - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\""},{"question":"def find_minimum_moves(test_cases): A delivery service operates in a city represented as a 2D grid. Each cell in the grid can either be empty or contain an obstacle. The service uses a drone which can move up, down, left, or right but cannot pass through obstacles. The goal is to deliver a package from a starting point to a destination point in the minimum number of moves. >>> test_cases = [ ... ([ ... ['S', '.', '.', '.', '.'], ... ['#', '.', '#', '.', '.'], ... ['#', '.', '#', '.', '.'], ... ['#', '.', '.', '.', 'E'], ... ['.', '.', '.', '.', '.'] ... ], (0, 0), (3, 4)), ... ... ([ ... ['S', '.', '#', '.', '.'], ... ['#', '.', '#', '.', '.'], ... ['#', '.', '#', '.', '.'], ... ['.', '.', '.', '#', 'E'], ... ['.', '.', '#', '#', '#'] ... ], (0, 0), (3, 4)) ... ] >>> find_minimum_moves(test_cases) [7, -1] pass # Implement the function here. # Unit tests import pytest def test_min_moves(): test_cases = [ ( [ ['S', '.', '.', '.', '.'], ['#', '.', '#', '.', '.'], ['#', '.', '#', '.', '.'], ['#', '.', '.', '.', 'E'], ['.', '.', '.', '.', '.'] ], (0, 0), (3, 4) ), ( [ ['S', '.', '#', '.', '.'], ['#', '.', '#', '.', '.'], ['#', '.', '#', '.', '.'], ['.', '.', '.', '#', 'E'], ['.', '.', '#', '#', '#'] ], (0, 0), (3, 4) ) ] expected_results = [7, -1] assert find_minimum_moves(test_cases) == expected_results def test_no_obstacles(): test_cases = [ ( [ ['S', '.', '.'], ['.', '.', '.'], ['.', '.', 'E'] ], (0, 0), (2, 2) ) ] expected_results = [4] assert find_minimum_moves(test_cases) == expected_results def test_start_is_end(): test_cases = [ ( [ ['E'] ], (0, 0), (0, 0) ) ] expected_results = [0] assert find_minimum_moves(test_cases) == expected_results def test_case_no_valid_path(): test_cases = [ ( [ ['S', '#', 'E'] ], (0, 0), (0, 2) ) ] expected_results = [-1] assert find_minimum_moves(test_cases) == expected_results def test_multiple_cases(): test_cases = [ ( [ ['S', '.', '.'], ['.', '#', '.'], ['.', '.', 'E'] ], (0, 0), (2, 2) ), ( [ ['S', '#', '#', '#', 'E'] ], (0, 0), (0, 4) ) ] expected_results = [4, -1] assert find_minimum_moves(test_cases) == expected_results","solution":"from collections import deque def min_moves(grid, start, end): rows, cols = len(grid), len(grid[0]) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) visited = set() visited.add((start[0], start[1])) while queue: x, y, moves = queue.popleft() if (x, y) == (end[0], end[1]): return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and grid[nx][ny] != '#': queue.append((nx, ny, moves + 1)) visited.add((nx, ny)) return -1 def find_minimum_moves(test_cases): results = [] for grid, start, end in test_cases: result = min_moves(grid, start, end) results.append(result) return results"},{"question":"def most_frequent_digit(sequences: List[str]) -> List[str]: For each sequence in the list, returns the most frequently occurring digit. If there is a tie, returns the smallest digit among them. >>> most_frequent_digit([\\"122333444455555\\"]) == [\\"5\\"] >>> most_frequent_digit([\\"9876543210 122333\\"]) == [\\"3\\"] >>> most_frequent_digit([\\"000111222 333444 555666\\"]) == [\\"0\\"]","solution":"def most_frequent_digit(sequences): For each sequence in the list, returns the most frequently occurring digit. If there is a tie, returns the smallest digit among them. results = [] for sequence in sequences: digit_counts = [0] * 10 for char in sequence: if char.isdigit(): digit_counts[int(char)] += 1 max_count = max(digit_counts) most_freq_digit = digit_counts.index(max_count) results.append(str(most_freq_digit)) return results def process_input_and_find_most_frequent(): Reads input for sequences from standard input and computes the most frequently occurring digit(s) for each sequence. import sys input = sys.stdin.read() data = input.splitlines() N = int(data[0]) sequences = data[1:N+1] results = most_frequent_digit(sequences) for result in results: print(result)"},{"question":"def longest_increasing_subsequence(cards: List[int]) -> int: Find the length of the longest strictly increasing subsequence of card ranks. >>> longest_increasing_subsequence([5, 1, 3, 6, 2, 4]) 3 >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6]) 6","solution":"def longest_increasing_subsequence(cards): from bisect import bisect_left if not cards: return 0 lis = [] for card in cards: pos = bisect_left(lis, card) if pos == len(lis): lis.append(card) else: lis[pos] = card return len(lis)"},{"question":"def find_key_pattern(n: int, k: int, scrambled_message: str) -> str: Determines the smallest repeating unit of the given message with the specified pattern length. Args: n (int): Length of the message. k (int): Length of the key pattern. scrambled_message (str): The scrambled message. Returns: str: The key pattern that forms the repeating unit of the message. Examples: >>> find_key_pattern(6, 2, \\"ababab\\") \\"ab\\" >>> find_key_pattern(7, 3, \\"abcabcd\\") \\"abc\\" >>> find_key_pattern(8, 2, \\"abcdabcd\\") \\"ab\\" from solution import find_key_pattern def test_case_1(): assert find_key_pattern(6, 2, \\"ababab\\") == \\"ab\\" def test_case_2(): assert find_key_pattern(7, 3, \\"abcabcd\\") == \\"abc\\" def test_case_3(): assert find_key_pattern(8, 2, \\"abcdabcd\\") == \\"ab\\" def test_case_4(): assert find_key_pattern(9, 3, \\"xyzxyzxyz\\") == \\"xyz\\" def test_case_5(): assert find_key_pattern(5, 1, \\"aaaaa\\") == \\"a\\" def test_case_6(): assert find_key_pattern(10, 5, \\"hijklhijkl\\") == \\"hijkl\\"","solution":"def find_key_pattern(n, k, scrambled_message): Determines the smallest repeating unit of the given message with the specified pattern length. Args: n (int): Length of the message. k (int): Length of the key pattern. scrambled_message (str): The scrambled message. Returns: str: The key pattern that forms the repeating unit of the message. return scrambled_message[:k]"},{"question":"def longest_unique_substtr(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substtr(\\"abcabcbb\\") 3 >>> longest_unique_substtr(\\"bbbbb\\") 1 >>> longest_unique_substtr(\\"pwwkew\\") 3 >>> longest_unique_substtr(\\"abcdef\\") 6 >>> longest_unique_substtr(\\"abacdedcba\\") 5 >>> longest_unique_substtr(\\"\\") 0 >>> longest_unique_substtr(\\"a\\") 1 >>> longest_unique_substtr(\\"abababab\\") 2","solution":"def longest_unique_substtr(s): Returns the length of the longest substring with all unique characters. n = len(s) result = 0 char_index = {} start = 0 for end in range(n): if s[end] in char_index: start = max(start, char_index[s[end]] + 1) char_index[s[end]] = end result = max(result, end - start + 1) return result"},{"question":"def rearrange_to_palindrome(s: str) -> str: Returns a palindrome rearrangement of the input string if possible, otherwise returns \\"Not Possible\\". >>> rearrange_to_palindrome(\\"aabbcc\\") \\"abccba\\" >>> rearrange_to_palindrome(\\"abc\\") \\"Not Possible\\"","solution":"from collections import Counter def rearrange_to_palindrome(s): Returns a palindrome rearrangement of the input string if possible, otherwise returns \\"Not Possible\\". count = Counter(s) odd_count = sum(1 for freq in count.values() if freq % 2 != 0) if odd_count > 1: return \\"Not Possible\\" half = [] middle = [] for char, freq in count.items(): if freq % 2 == 0: half.extend([char] * (freq // 2)) else: half.extend([char] * (freq // 2)) middle.append(char) half_str = ''.join(half) return half_str + ''.join(middle) + half_str[::-1]"},{"question":"def find_scc_count(n: int, m: int, edges: List[Tuple[int, int]]) -> int: Find the number of strongly connected components (SCCs) in a directed graph with N nodes and M edges. Parameters ---------- n : int Number of nodes in the graph m : int Number of edges in the graph edges : List[Tuple[int, int]] The edges in the graph, where each edge is represented by a tuple (u, v) indicating a directed edge from node u to node v. Returns ------- int The number of SCCs in the graph. Examples -------- >>> find_scc_count(5, 5, [(1, 2), (2, 3), (3, 1), (4, 5), (5, 4)]) 2 >>> find_scc_count(5, 0, []) 5 >>> find_scc_count(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) 1 >>> find_scc_count(6, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) 6 >>> find_scc_count(6, 7, [(1, 2), (2, 1), (2, 3), (4, 5), (5, 4), (5, 6), (6, 4)]) 3","solution":"from collections import defaultdict, deque def kosaraju_scc_count(n, edges): def dfs(v, graph, visited, stack=None, component=None): visited[v] = True if component is not None: component.append(v) for neighbour in graph[v]: if not visited[neighbour]: dfs(neighbour, graph, visited, stack, component) if stack is not None: stack.append(v) graph = defaultdict(list) reverse_graph = defaultdict(list) for u, v in edges: graph[u].append(v) reverse_graph[v].append(u) stack = [] visited = [False] * (n + 1) for i in range(1, n + 1): if not visited[i]: dfs(i, graph, visited, stack) visited = [False] * (n + 1) scc_count = 0 while stack: node = stack.pop() if not visited[node]: component = [] dfs(node, reverse_graph, visited, component=component) if component: scc_count += 1 return scc_count # Function to process input and call the SCC function def find_scc_count(n, m, edges): return kosaraju_scc_count(n, edges)"},{"question":"from typing import Tuple def final_position(commands: str) -> Tuple[int, int]: Takes a string of commands and returns the final position of the robotic arm. >>> final_position(\\"UURDDLLR\\") (0, 0) >>> final_position(\\"UUDDLRLR\\") (0, 0) >>> final_position(\\"LLLL\\") (-4, 0) >>> final_position(\\"UUUUU\\") (0, 5) >>> final_position(\\"RRR\\") (3, 0) >>> final_position(\\"UDLRUDLR\\") (0, 0) >>> final_position(\\"UUDDLLRR\\") (0, 0) >>> final_position(\\"URDLURDL\\") (0, 0) >>> final_position(\\"ULDRULDR\\") (0, 0) >>> final_position(\\"URURDDLL\\") (0, 0)","solution":"def final_position(commands): Takes a string of commands and returns the final position of the robotic arm. Parameters: commands (str): A string containing the commands executed by the robotic arm Returns: tuple: A tuple of two integers representing the final coordinates # Initialize the starting position x, y = 0, 0 # Iterate over each command and update the position accordingly for command in commands: if command == 'U': y += 1 elif command == 'D': y -= 1 elif command == 'L': x -= 1 elif command == 'R': x += 1 return (x, y) # Function to print the result in the correct format def print_final_position(commands): x, y = final_position(commands) print(f\\"{x} {y}\\")"},{"question":"def maximize_sum(test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of N integers, perform multiple operations to maximize the sum of the array elements. The operations involve choosing any two different elements X and Y, and replacing them with a single element X + Y. Parameters: test_cases (List[Tuple[int, List[int]]]): A list of test cases, each containing an integer N and a list of N integers. Returns: List[int]: A list of results for each test case, representing the maximum possible sum of the elements. Examples: >>> maximize_sum([(3, [1, 2, 3]), (4, [2, 5, 6, 1])]) [6, 14] >>> maximize_sum([(1, [10])]) [10]","solution":"def maximize_sum(test_cases): results = [] for N, array in test_cases: if N == 1: results.append(array[0]) else: total_sum = sum(array) results.append(total_sum) return results"},{"question":"def calculate_trapped_water(heights): Calculate the total units of water trapped between an array of building heights. :param heights: A list of integers representing building heights :return: An integer representing the total units of water trapped >>> calculate_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> calculate_trapped_water([4, 2, 0, 3, 2, 5]) 9 >>> calculate_trapped_water([1, 1, 1, 1, 1]) 0 >>> calculate_trapped_water([3, 0, 2, 0, 4]) 7 >>> calculate_trapped_water([0, 0, 0, 0]) 0 >>> calculate_trapped_water([5, 5, 5, 5, 5]) 0 >>> calculate_trapped_water([0, 8, 0, 8]) 8 >>> calculate_trapped_water([]) 0 def trapped_water_test_cases(T, cases): Process multiple test cases for trapped water calculation. :param T: Number of test cases :param cases: A list of tuples where each tuple contains an integer N and a list of N integers representing building heights :return: A list of integers, each representing the total units of water trapped for corresponding test case >>> trapped_water_test_cases(3, [(6, [0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]), (9, [4, 2, 0, 3, 2, 5]), (5, [1, 1, 1, 1, 1])]) [6, 9, 0]","solution":"def calculate_trapped_water(heights): Calculate the total units of water trapped between buildings given their heights. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n water_trapped = 0 # Fill left_max array left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i - 1], heights[i]) # Fill right_max array right_max[n - 1] = heights[n - 1] for i in range(n - 2, -1, -1): right_max[i] = max(right_max[i + 1], heights[i]) # Calculate the water trapped for i in range(n): water_trapped += min(left_max[i], right_max[i]) - heights[i] return water_trapped def trapped_water_test_cases(T, cases): Process multiple test cases for trapped water calculation. results = [] for case in cases: N, heights = case results.append(calculate_trapped_water(heights)) return results"},{"question":"def maximize_animal_strength(n: int, strengths: List[int]) -> int: Returns the maximum possible strength of a single animal after performing all possible battles. Args: n (int): Number of animals. strengths (List[int]): List of strengths of each animal. Returns: int: The maximum possible strength for a single animal. Examples: >>> maximize_animal_strength(5, [2, 3, 1, 6, 4]) 16 >>> maximize_animal_strength(4, [5, 5, 5, 5]) 20","solution":"def maximize_animal_strength(n, strengths): Returns the maximum possible strength of a single animal after performing all possible battles. # As the goal is to maximize one animal's strength, let's consider consolidating all strengths towards a single position. max_strength = max(strengths) total_strength = sum(strengths) return total_strength"},{"question":"def process_operations(n: int, operations: List[str]) -> List[int]: Perform a series of addition and query operations on a string and return results for query operations. >>> process_operations(6, [\\"1 a\\", \\"1 b\\", \\"1 c\\", \\"2 2\\", \\"1 d\\", \\"2 3\\"]) [2, 2] >>> process_operations(6, [\\"1 a\\", \\"1 a\\", \\"1 a\\", \\"2 1\\", \\"1 b\\", \\"2 2\\"]) [1, 2] >>> process_operations(7, [\\"1 x\\", \\"1 y\\", \\"1 z\\", \\"2 1\\", \\"2 2\\", \\"1 a\\", \\"2 3\\"]) [3, 2, 2] >>> process_operations(0, []) [] >>> process_operations(100001, [\\"1 a\\"] * 100000 + [\\"2 100000\\"]) [1]","solution":"def process_operations(n, operations): current_string = \\"\\" results = [] for operation in operations: op = operation.split() if op[0] == '1': # Append character to the current string current_string += op[1] elif op[0] == '2': # Query operation k = int(op[1]) substrings = set() for i in range(len(current_string) - k + 1): substrings.add(current_string[i:i+k]) results.append(len(substrings)) return results"},{"question":"def can_paint_wall_without_repeating_colors(n, k, colors): Determines if it's possible to paint the wall without repeating colors in any segment of length k. Parameters: n (int): The number of days / length of the colors array. k (int): The segment length. colors (list of int): The colors array. Returns: str: \\"YES\\" if it's possible, otherwise \\"NO\\". >>> can_paint_wall_without_repeating_colors(6, 3, [1, 2, 3, 1, 2, 3]) \\"YES\\" >>> can_paint_wall_without_repeating_colors(5, 2, [1, 1, 2, 2, 3]) \\"NO\\"","solution":"def can_paint_wall_without_repeating_colors(n, k, colors): Determines if it's possible to paint the wall without repeating colors in any segment of length k. Parameters: n (int): The number of days / length of the colors array. k (int): The segment length. colors (list of int): The colors array. Returns: str: \\"YES\\" if it's possible, otherwise \\"NO\\". for i in range(n - k + 1): segment = colors[i:i + k] if len(segment) != len(set(segment)): return \\"NO\\" return \\"YES\\""},{"question":"def tallest_tower_height(n: int) -> int: Determines the height of the tallest triangular tower that can be built with exactly n blocks. :param n: Total number of blocks available. :type n: int :return: Height of the tallest triangular tower. :rtype: int >>> tallest_tower_height(10) 4 >>> tallest_tower_height(3) 2 >>> tallest_tower_height(1) 1 >>> tallest_tower_height(0) 0 >>> tallest_tower_height(15) 5 >>> tallest_tower_height(20) 5 >>> tallest_tower_height(6) 3 >>> tallest_tower_height(21) 6","solution":"def tallest_tower_height(n): Determines the height of the tallest triangular tower that can be built with exactly n blocks. :param n: Total number of blocks available. :type n: int :return: Height of the tallest triangular tower. :rtype: int height = 0 total_blocks = 0 while total_blocks + height + 1 <= n: height += 1 total_blocks += height return height"},{"question":"def find_isolated_individuals(n: int, adjacency_matrix: List[List[int]]) -> Union[List[int], str]: Finds and returns the indices of isolated individuals in the network. Parameters: n (int): The number of individuals in the network. adjacency_matrix (list of list of int): The adjacency matrix. Returns: list: The indices of isolated individuals or \\"None\\" if there are no isolated individuals. >>> find_isolated_individuals(4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]) [3] >>> find_isolated_individuals(4, [[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]) \\"None\\" >>> find_isolated_individuals(5, [[0, 1, 0, 0, 0], [1, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0], [0, 0, 0, 0, 0]]) [2, 3, 4] >>> find_isolated_individuals(3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) [0, 1, 2]","solution":"def find_isolated_individuals(n, adjacency_matrix): Finds and returns the indices of isolated individuals in the network. Parameters: n (int): The number of individuals in the network. adjacency_matrix (list of list of int): The adjacency matrix. Returns: list: The indices of isolated individuals or None if there are no isolated individuals. isolated_indices = [] for i in range(n): if all(adjacency_matrix[i][j] == 0 for j in range(n)): # Check whole row for connections isolated_indices.append(i) return isolated_indices if isolated_indices else \\"None\\""},{"question":"def is_balanced_word(word) -> str: Determines if a given word is balanced. A word is considered balanced if the sum of the ASCII values of its characters is a multiple of the length of the word. :param word: A string to be checked if it's balanced :return: \\"BALANCED\\" if the word is balanced, otherwise \\"NOT BALANCED\\" >>> is_balanced_word(\\"ace\\") == \\"BALANCED\\" >>> is_balanced_word(\\"hello\\") == \\"NOT BALANCED\\" pass def process_test_cases(test_cases) -> list: Processes a list of test cases and returns the results for each one. :param test_cases: A list of strings, each representing a test case :return: A list of results for each test case, either \\"BALANCED\\" or \\"NOT BALANCED\\" >>> process_test_cases([\\"ace\\", \\"hello\\"]) == [\\"BALANCED\\", \\"NOT BALANCED\\"] >>> process_test_cases([\\"world\\", \\"ae\\"]) == [\\"NOT BALANCED\\", \\"BALANCED\\"] pass def test_is_balanced_word_balanced(): assert is_balanced_word(\\"ace\\") == \\"BALANCED\\" assert is_balanced_word(\\"ae\\") == \\"BALANCED\\" def test_is_balanced_word_not_balanced(): assert is_balanced_word(\\"hello\\") == \\"NOT BALANCED\\" assert is_balanced_word(\\"world\\") == \\"NOT BALANCED\\" def test_process_test_cases(): test_cases = [\\"ace\\", \\"hello\\"] assert process_test_cases(test_cases) == [\\"BALANCED\\", \\"NOT BALANCED\\"] test_cases = [\\"world\\", \\"ae\\"] assert process_test_cases(test_cases) == [\\"NOT BALANCED\\", \\"BALANCED\\"] def test_empty_and_one_char(): assert is_balanced_word(\\"a\\") == \\"BALANCED\\" assert is_balanced_word(\\"b\\") == \\"BALANCED\\" assert process_test_cases([\\"a\\", \\"b\\"]) == [\\"BALANCED\\", \\"BALANCED\\"]","solution":"def is_balanced_word(word): Determines if a given word is balanced. A word is considered balanced if the sum of the ASCII values of its characters is a multiple of the length of the word. :param word: A string to be checked if it's balanced :return: \\"BALANCED\\" if the word is balanced, otherwise \\"NOT BALANCED\\" ascii_sum = sum(ord(char) for char in word) if ascii_sum % len(word) == 0: return \\"BALANCED\\" else: return \\"NOT BALANCED\\" def process_test_cases(test_cases): Processes a list of test cases and returns the results for each one. :param test_cases: A list of strings, each representing a test case :return: A list of results for each test case, either \\"BALANCED\\" or \\"NOT BALANCED\\" results = [] for word in test_cases: results.append(is_balanced_word(word)) return results"},{"question":"from collections import defaultdict, deque from typing import List, Tuple def max_transport_distance(n: int, roads: List[Tuple[int, int, int]]) -> int: Calculate the maximum distance Farmer John can transport hay from one field to another. Args: n (int): The number of fields. roads (List[Tuple[int, int, int]]): Road connections with their lengths. Returns: int: The maximum distance for transporting hay. Examples: >>> max_transport_distance(5, [(1, 2, 5), (2, 3, 4), (3, 4, 3), (3, 5, 2)]) 12 >>> max_transport_distance(3, [(1, 2, 7), (2, 3, 4)]) 11 from solution import max_transport_distance def test_case_1(): n = 5 roads = [ (1, 2, 5), (2, 3, 4), (3, 4, 3), (3, 5, 2) ] assert max_transport_distance(n, roads) == 12 def test_case_2(): n = 3 roads = [ (1, 2, 7), (2, 3, 4) ] assert max_transport_distance(n, roads) == 11 def test_case_3(): n = 4 roads = [ (1, 2, 1), (2, 3, 1), (3, 4, 1) ] assert max_transport_distance(n, roads) == 3 def test_case_4(): n = 6 roads = [ (1, 2, 2), (2, 3, 3), (3, 4, 4), (4, 5, 5), (5, 6, 6) ] assert max_transport_distance(n, roads) == 20 def test_case_5(): n = 2 roads = [ (1, 2, 1000) ] assert max_transport_distance(n, roads) == 1000","solution":"import sys from collections import defaultdict, deque def max_transport_distance(n, roads): if n == 2: return roads[0][2] graph = defaultdict(list) for u, v, length in roads: graph[u].append((v, length)) graph[v].append((u, length)) def bfs(start): visited = [-1] * (n + 1) q = deque([(start, 0)]) visited[start] = 0 furthest_node, max_dist = start, 0 while q: node, dist = q.popleft() if dist > max_dist: furthest_node, max_dist = node, dist for neighbor, length in graph[node]: if visited[neighbor] == -1: visited[neighbor] = dist + length q.append((neighbor, dist + length)) return furthest_node, max_dist first_node, _ = bfs(1) _, max_distance = bfs(first_node) return max_distance"},{"question":"def gcd(x, y): Compute the greatest common divisor of x and y. while y: x, y = y, x % y return x def simplify_fraction(numerator, denominator): Simplify a fraction given the numerator and denominator. Args: numerator (int): The numerator of the fraction. denominator (int): The denominator of the fraction. Returns: str: The simplified fraction in the form \\"numerator/denominator\\". >>> simplify_fraction(8, 24) \\"1/3\\" >>> simplify_fraction(25, 100) \\"1/4\\" >>> simplify_fraction(15, 5) \\"3/1\\" gcd_value = gcd(numerator, denominator) return f\\"{numerator // gcd_value}/{denominator // gcd_value}\\" def process_fractions(input_data): Process a series of fraction inputs and return their simplified forms. Args: input_data (str): Multi-line string where each line contains two integers separated by a space. Returns: List[str]: A list of simplified fractions in the form \\"numerator/denominator\\". >>> process_fractions(\\"8 24n25 100n15 5n0 0\\") [\\"1/3\\", \\"1/4\\", \\"3/1\\"] >>> process_fractions(\\"50 100n30 10n75 25n40 100n0 0\\") [\\"1/2\\", \\"3/1\\", \\"3/1\\", \\"2/5\\"] results = [] for data in input_data.strip().split(\\"n\\"): numerator, denominator = map(int, data.split()) if numerator == 0 and denominator == 0: break results.append(simplify_fraction(numerator, denominator)) return results","solution":"def gcd(x, y): while y: x, y = y, x % y return x def simplify_fraction(numerator, denominator): gcd_value = gcd(numerator, denominator) return f\\"{numerator // gcd_value}/{denominator // gcd_value}\\" def process_fractions(input_data): results = [] for data in input_data.strip().split(\\"n\\"): numerator, denominator = map(int, data.split()) if numerator == 0 and denominator == 0: break results.append(simplify_fraction(numerator, denominator)) return results"},{"question":"from collections import defaultdict import heapq def dijkstra(n, graph, start): Calculate the shortest paths from the start node to all other nodes. Parameters: n (int): The number of nodes. graph (dict): The graph represented as adjacency lists. start (int): The starting node. Returns: List[int]: A list of distances where the i-th index represents the shortest path from the start node to node i. pass def main(): Perform multiple updates on the graph and calculate the shortest paths after each update. Input: The input should be read from standard input and should consist of: - Two integers n and m. - m lines of three integers u, v, w describing the roads. - A single integer s indicating the starting site. - A single integer q indicating the number of updates. - q lines each containing four integers t, u, v, w describing the updates. Output: For each update, output a line with n integers representing the shortest paths from s. pass # Unit tests to test the dijkstra function def test_dijkstra_initial(): from solution import dijkstra graph = { 1: {2: 3, 5: 8}, 2: {1: 3, 3: 4}, 3: {2: 4, 4: 5}, 4: {3: 5, 5: 6}, 5: {4: 6, 1: 8, 2: 2} } assert dijkstra(5, graph, 1) == [float('inf'), 0, 3, 7, 12, 8] def test_update_road_and_recalculate(): from solution import dijkstra graph = { 1: {2: 3, 3: 2, 5: 8}, 2: {1: 3, 3: 4}, 3: {1: 2, 2: 4, 4: 5}, 4: {3: 5, 5: 6}, 5: {4: 6, 1: 8, 2: 2} } assert dijkstra(5, graph, 1) == [float('inf'), 0, 3, 2, 7, 8] def test_remove_road_and_recalculate(): from solution import dijkstra graph = { 1: {2: 3}, 2: {1: 3}, 3: {2: 4, 4: 5}, 4: {3: 5, 5: 6}, 5: {4: 6, 1: 8, 2: 2} } assert dijkstra(5, graph, 1) == [float('inf'), 0, 3, float('inf'), float('inf'), float('inf')] def test_modify_road_length_and_recalculate(): from solution import dijkstra graph = { 1: {2: 1, 3: 2, 5: 8}, 2: {1: 1, 3: 4}, 3: {1: 2, 2: 4, 4: 5}, 4: {3: 5, 5: 6}, 5: {4: 6, 1: 8, 2: 2} } assert dijkstra(5, graph, 1) == [float('inf'), 0, 1, 2, 7, 8]","solution":"import heapq from collections import defaultdict, deque import sys input = sys.stdin.read INF = float('inf') def dijkstra(n, graph, start): dist = [INF] * (n + 1) dist[start] = 0 pq = [(0, start)] heapq.heapify(pq) while pq: current_dist, u = heapq.heappop(pq) if current_dist > dist[u]: continue for v, weight in graph[u].items(): distance = current_dist + weight if distance < dist[v]: dist[v] = distance heapq.heappush(pq, (distance, v)) return dist def main(): data = input().split() idx = 0 n = int(data[idx]) m = int(data[idx + 1]) idx += 2 graph = defaultdict(dict) for _ in range(m): u = int(data[idx]) v = int(data[idx + 1]) w = int(data[idx + 2]) idx += 3 if v not in graph[u] or graph[u][v] > w: graph[u][v] = w if u not in graph[v] or graph[v][u] > w: graph[v][u] = w s = int(data[idx]) idx += 1 q = int(data[idx]) idx += 1 results = [] results.append(dijkstra(n, graph, s)) for _ in range(q): t = int(data[idx]) u = int(data[idx + 1]) v = int(data[idx + 2]) w = int(data[idx + 3]) idx += 4 if t == 1: if v not in graph[u] or graph[u][v] > w: graph[u][v] = w if u not in graph[v] or graph[v][u] > w: graph[v][u] = w elif t == 2: if v in graph[u]: del graph[u][v] if u in graph[v]: del graph[v][u] elif t == 3: if v in graph[u]: graph[u][v] = w if u in graph[v]: graph[v][u] = w results.append(dijkstra(n, graph, s)) sys.stdout.write('n'.join(' '.join(str(dist if dist != INF else -1) for dist in result[1:]) for result in results) + 'n')"},{"question":"def max_teams(skills, d): Returns the maximum number of teams that can be formed where the skill level difference between the strongest and weakest participant in each team does not exceed d. >>> max_teams([1, 2, 3, 4, 5, 6], 2) 2 >>> max_teams([1, 5, 7, 8, 10], 3) 1 >>> max_teams([10, 20, 30], 5) 0 >>> max_teams([1, 1, 1, 1, 1, 1], 0) 2 >>> max_teams([1, 100, 200, 300, 400, 500], 1000) 2 >>> max_teams([3, 4, 5, 9, 10, 11, 15, 16, 17], 2) 3 pass def test_max_teams_basic(): assert max_teams([1, 2, 3, 4, 5, 6], 2) == 2 def test_max_teams_single_team(): assert max_teams([1, 5, 7, 8, 10], 3) == 1 def test_max_teams_no_teams_possible(): assert max_teams([10, 20, 30], 5) == 0 def test_max_teams_all_skills_same(): assert max_teams([1, 1, 1, 1, 1, 1], 0) == 2 def test_max_teams_large_gap(): assert max_teams([1, 100, 200, 300, 400, 500], 1000) == 2 def test_max_teams_multiple_teams_with_remainders(): assert max_teams([3, 4, 5, 9, 10, 11, 15, 16, 17], 2) == 3","solution":"def max_teams(skills, d): Returns the maximum number of teams that can be formed where the skill level difference between the strongest and weakest participant in each team does not exceed d. # Sort the skills array to facilitate team formation skills.sort() teams = 0 i = 0 n = len(skills) # Traverse through the sorted skill list while i <= n - 3: # Check if a team can be formed with current participant and the next two participants if skills[i+2] - skills[i] <= d: teams += 1 i += 3 # Move to the next possible team else: i += 1 # Otherwise, try the next possible participant return teams"},{"question":"def find_longest_arithmetic_subsequence(n: int, arr: List[int]) -> Tuple[int, int]: Given a list of integers, find the length and the starting index of the longest subsequence which is an arithmetic sequence. Example: >>> find_longest_arithmetic_subsequence(8, [1, 3, 5, 7, 9, 11, 6, 8]) (6, 0) >>> find_longest_arithmetic_subsequence(6, [10, 7, 4, 1, -2, 1]) (5, 0) import pytest from solution import find_longest_arithmetic_subsequence def test_example_1(): assert find_longest_arithmetic_subsequence(8, [1, 3, 5, 7, 9, 11, 6, 8]) == (6, 0) def test_example_2(): assert find_longest_arithmetic_subsequence(6, [10, 7, 4, 1, -2, 1]) == (5, 0) def test_single_element(): assert find_longest_arithmetic_subsequence(1, [5]) == (1, 0) def test_no_sequence(): assert find_longest_arithmetic_subsequence(4, [1, 2, 4, 7]) == (2, 0) def test_all_different_diffs(): assert find_longest_arithmetic_subsequence(5, [1, 3, 6, 10, 15]) == (2, 0) def test_multiple_same_length(): assert find_longest_arithmetic_subsequence(10, [2, 4, 6, 8, 1, 3, 5, 7, 2, 4]) == (4, 0)","solution":"def find_longest_arithmetic_subsequence(n, arr): if n == 1: return 1, 0 max_length = 1 max_index = 0 current_length = 1 current_index = 0 for i in range(1, n): if i == 1 or arr[i] - arr[i-1] == arr[i-1] - arr[i-2]: current_length += 1 else: if current_length > max_length: max_length = current_length max_index = current_index current_length = 2 current_index = i - 1 if current_length > max_length: max_length = current_length max_index = current_index return max_length, max_index"},{"question":"def organize_stamps(stamps: List[str]) -> List[List[str]]: Organize stamps into pages with each page containing stamps from one country, sorted alphabetically by country name. >>> organize_stamps([\\"Canada\\", \\"Brazil\\", \\"India\\", \\"Canada\\", \\"Brazil\\", \\"China\\", \\"India\\"]) [['Brazil', 'Brazil'], ['Canada', 'Canada'], ['China'], ['India', 'India']] >>> organize_stamps([\\"India\\", \\"China\\", \\"Canada\\", \\"Brazil\\", \\"Canada\\", \\"China\\", \\"India\\", \\"Brazil\\"]) [['Brazil', 'Brazil'], ['Canada', 'Canada'], ['China', 'China'], ['India', 'India']]","solution":"def organize_stamps(stamps): Organize stamps into pages with each page containing stamps from one country, sorted alphabetically by country name. from collections import defaultdict stamp_dict = defaultdict(list) for stamp in stamps: stamp_dict[stamp].append(stamp) sorted_countries = sorted(stamp_dict.keys()) result = [stamp_dict[country] for country in sorted_countries] return result"},{"question":"from typing import List, Union def find_deployment_sequence(n: int, dependencies: List[str]) -> Union[List[str], str]: Determine the sequence of branches that must be deployed based on the given dependencies. Args: n (int): The number of deployment dependencies. dependencies (List[str]): A list of dependencies in the format \\"XXX->YYY\\". Returns: Union[List[str], str]: A list of branch codes in the order they should be deployed, or \\"impossible\\" if no valid sequence exists due to circular dependencies. Examples: >>> find_deployment_sequence(3, [\\"NYC->LON\\", \\"LON->BER\\", \\"NYC->BER\\"]) ['NYC', 'LON', 'BER'] >>> find_deployment_sequence(2, [\\"A->B\\", \\"B->A\\"]) 'impossible' pass # Unit tests: def test_find_deployment_sequence_example1(): dependencies = [\\"NYC->LON\\", \\"LON->BER\\", \\"NYC->BER\\"] assert find_deployment_sequence(3, dependencies) == [\\"NYC\\", \\"LON\\", \\"BER\\"] def test_find_deployment_sequence_example2(): dependencies = [\\"A->B\\", \\"B->A\\"] assert find_deployment_sequence(2, dependencies) == \\"impossible\\" def test_find_deployment_sequence_no_dependencies(): dependencies = [] assert find_deployment_sequence(0, dependencies) == [] def test_find_deployment_sequence_single_dependency(): dependencies = [\\"A->B\\"] assert find_deployment_sequence(1, dependencies) == [\\"A\\", \\"B\\"] def test_find_deployment_sequence_multiple_possible_sequences(): dependencies = [\\"A->B\\", \\"A->C\\", \\"B->D\\", \\"C->D\\"] result = find_deployment_sequence(4, dependencies) assert result == [\\"A\\", \\"B\\", \\"C\\", \\"D\\"] or result == [\\"A\\", \\"C\\", \\"B\\", \\"D\\"] def test_find_deployment_sequence_disconnected_graph(): dependencies = [\\"A->B\\", \\"C->D\\"] result = find_deployment_sequence(2, dependencies) assert result in [[\\"A\\", \\"C\\", \\"B\\", \\"D\\"], [\\"C\\", \\"A\\", \\"D\\", \\"B\\"]] def test_find_deployment_sequence_circular_long(): dependencies = [\\"A->B\\", \\"B->C\\", \\"C->A\\"] assert find_deployment_sequence(3, dependencies) == \\"impossible\\"","solution":"from collections import defaultdict, deque def find_deployment_sequence(n, dependencies): # Build the graph graph = defaultdict(list) indegree = defaultdict(int) branches = set() for dep in dependencies: src, tgt = dep.split(\\"->\\") graph[src].append(tgt) indegree[tgt] += 1 branches.add(src) branches.add(tgt) # Find all the branches with no incoming dependencies queue = deque() for branch in branches: if indegree[branch] == 0: queue.append(branch) # Topological sort sort_result = [] while queue: current = queue.popleft() sort_result.append(current) for neighbor in graph[current]: indegree[neighbor] -= 1 if indegree[neighbor] == 0: queue.append(neighbor) # Check for cycles in the graph if len(sort_result) == len(branches): return sort_result else: return \\"impossible\\""},{"question":"def min_distinct_characters(n: int, k: int, s: str) -> int: Returns the minimum number of distinct characters the string can have after making at most k replacements. >>> min_distinct_characters(10, 2, \\"abacabadab\\") 2 >>> min_distinct_characters(5, 1, \\"abcde\\") 4 >>> min_distinct_characters(6, 3, \\"aaaaaa\\") 1","solution":"def min_distinct_characters(n, k, s): Returns the minimum number of distinct characters the string can have after making at most k replacements. from collections import Counter char_count = Counter(s) # Number of distinct characters in the string distinct_char_count = len(char_count) # If k is greater or equal to number of different characters, we can reduce to 1 character if k >= distinct_char_count: return 1 # Sort characters by frequency char_freq = sorted(char_count.values(), reverse=True) # Reduce the number of distinct characters by merging the least frequency characters while k > 0 and distinct_char_count > 1: least_freq = char_freq[-1] if k >= least_freq: k -= least_freq char_freq.pop() distinct_char_count -= 1 else: break return distinct_char_count"},{"question":"def find_swap_pair(X, Y): This function finds two elements x from X and y from Y to swap such that the sum of the elements in X is unique from the sum of the elements in Y. >>> find_swap_pair([1, 2, 3], [3, 2, 1]) (1, 3) >>> find_swap_pair([1, 1, 3, 5], [2, 4, 3, 6]) (1, 2)","solution":"def find_swap_pair(X, Y): This function finds two elements x from X and y from Y to swap such that the sum of the elements in X is unique from the sum of the elements in Y. sum_x = sum(X) sum_y = sum(Y) diff_set = set() # To store the differences encountered for x in X: for y in Y: if (sum_x - x + y) != (sum_y - y + x): return (x, y) return None # In case no valid swap is found, though guaranteed one exists by problem constraints"},{"question":"def max_product_of_two(N, sequence): Returns the maximum product of any two distinct elements from the sequence. Parameters: N (int): The number of elements in the sequence sequence (list): List of N positive integers Returns: int: Maximum product of any two distinct elements >>> max_product_of_two(5, [1, 10, 2, 6, 5]) 60 >>> max_product_of_two(4, [3, 7, 1, 9]) 63","solution":"def max_product_of_two(N, sequence): Returns the maximum product of any two distinct elements from the sequence. Parameters: N (int): The number of elements in the sequence sequence (list): List of N positive integers Returns: int: Maximum product of any two distinct elements if N < 2: return None # Sort the sequence in descending order sorted_sequence = sorted(sequence, reverse=True) # The maximum product of two distinct elements will be the product of the first two elements in sorted array return sorted_sequence[0] * sorted_sequence[1]"},{"question":"def two_sum_exists(arr, target): Returns \\"YES\\" if there are two distinct indices in the array whose values sum up to the target, otherwise \\"NO\\". pass def process_test_cases(test_cases): Process multiple test cases and returns a list of results for each test case. pass def parse_input(input_string): Parses the input string and returns a list of test cases. pass # Unit Tests def test_two_sum_exists_yes(): assert two_sum_exists([1, 2, 3, 4, 5], 6) == \\"YES\\" assert two_sum_exists([0, -1, 2, -3], -1) == \\"YES\\" assert two_sum_exists([10, -2, 3, 5, -8, -6], -8) == \\"YES\\" def test_two_sum_exists_no(): assert two_sum_exists([1, 2, 3, 4, 5], 10) == \\"NO\\" assert two_sum_exists([0, -1, 2, -3], 10) == \\"NO\\" assert two_sum_exists([10, -2, 3, 5, -8, -6], 100) == \\"NO\\" def test_parse_input_single_case(): input_string = \\"1n5n1 2 3 4 5n6\\" expected_output = [(5, [1, 2, 3, 4, 5], 6)] assert parse_input(input_string) == expected_output def test_parse_input_multiple_cases(): input_string = \\"2n5n1 2 3 4 5n6n4n0 -1 2 -3n-1\\" expected_output = [ (5, [1, 2, 3, 4, 5], 6), (4, [0, -1, 2, -3], -1) ] assert parse_input(input_string) == expected_output def test_process_test_cases(): test_cases = [ (5, [1, 2, 3, 4, 5], 6), (4, [0, -1, 2, -3], -1), (5, [1, 2, 3, 4, 5], 10), (4, [0, -1, 2, -3], 10) ] expected_output = [\\"YES\\", \\"YES\\", \\"NO\\", \\"NO\\"] assert process_test_cases(test_cases) == expected_output","solution":"def two_sum_exists(arr, target): Returns \\"YES\\" if there are two distinct indices in the array whose values sum up to the target, otherwise \\"NO\\". complements = {} for num in arr: if target - num in complements: return \\"YES\\" complements[num] = True return \\"NO\\" def process_test_cases(test_cases): results = [] for case in test_cases: n, arr, target = case result = two_sum_exists(arr, target) results.append(result) return results def parse_input(input_string): data = input_string.strip().split('n') T = int(data[0]) index = 1 test_cases = [] for _ in range(T): N = int(data[index]) arr = list(map(int, data[index + 1].split())) target = int(data[index + 2]) test_cases.append((N, arr, target)) index += 3 return test_cases"},{"question":"def calculate_ranks_and_query(N: int, M: int, grades: List[List[int]], queries: List[int]) -> List[int]: Calculate the ranks of students based on their total scores and answer the rank queries. Args: N: Number of students. M: Number of subjects. grades: A list of list of integers where each inner list represents grades of a student. queries: A list of integers representing the student indices to query the rank for. Returns: A list of integers representing the ranks for the queried student indices. pass # Unit Tests def test_calculate_ranks_and_query_case_1(): N = 5 M = 3 grades = [ [85, 90, 78], [88, 92, 96], [70, 60, 75], [95, 98, 94], [50, 50, 50] ] queries = [1, 4, 2] output = calculate_ranks_and_query(N, M, grades, queries) assert output == [3, 1, 2] def test_calculate_ranks_and_query_with_ties(): N = 5 M = 2 grades = [ [100, 100], [90, 90], [80, 80], [100, 100], [70, 70] ] queries = [1, 4, 5] output = calculate_ranks_and_query(N, M, grades, queries) assert output == [1, 1, 5] def test_calculate_ranks_and_query_case_2(): N = 3 M = 4 grades = [ [20, 30, 40, 50], [50, 50, 50, 50], [0, 0, 0, 0] ] queries = [3, 1] output = calculate_ranks_and_query(N, M, grades, queries) assert output == [3, 2] def test_calculate_ranks_and_query_single_student(): N = 1 M = 5 grades = [ [100, 100, 100, 100, 100] ] queries = [1] output = calculate_ranks_and_query(N, M, grades, queries) assert output == [1]","solution":"def calculate_ranks_and_query(N, M, grades, queries): Calculate the ranks of students based on their total scores and answer the rank queries. Args: N: Number of students. M: Number of subjects. grades: A list of list of integers where each inner list represents grades of a student. queries: A list of integers representing the student indices to query the rank for. Returns: A list of integers representing the ranks for the queried student indices. # Calculate total scores for each student total_scores = [sum(student_grades) for student_grades in grades] # Pair each score with its index and sort by scores in descending order (and by index for stability) indexed_scores = sorted([(score, index) for index, score in enumerate(total_scores)], key=lambda x: x[0], reverse=True) # Initialize rank list with \`None\` values ranks = [None] * N # Assign ranks rank = 1 for i in range(N): if i > 0 and indexed_scores[i][0] != indexed_scores[i - 1][0]: rank = i + 1 ranks[indexed_scores[i][1]] = rank # Get ranks for the queries query_results = [ranks[query - 1] for query in queries] return query_results"},{"question":"def count_arrangements(r: int, t: int) -> int: Alice loves gardening and she has a special interest in arranging flowers in rows. She has a collection of flowers, and each flower is either a rose or a tulip. She would like to arrange the flowers in a row such that no two tulips are adjacent to each other. Given the number of roses and tulips, return the total number of distinct arrangements possible. >>> count_arrangements(3, 2) 4 >>> count_arrangements(5, 0) 1 >>> count_arrangements(0, 4) 0","solution":"def count_arrangements(r, t): if t == 0: return 1 if r < t - 1: return 0 if r == t: return r + 1 return r - t + 1 # Example usage: # print(count_arrangements(3, 2)) # Output: 4"},{"question":"def max_employees_logged_in(n: int, intervals: List[Tuple[int, int]]) -> int: Determine the maximum number of employees logged in simultaneously. Args: - n (int): Number of login-logout pairs. - intervals (list of tuples): List of (login, logout) times. Returns: - int: Maximum number of employees logged in simultaneously. from typing import List, Tuple # Test cases def test_max_employees_logged_in(): assert max_employees_logged_in(5, [(1, 5), (2, 6), (4, 8), (7, 10), (9, 12)]) == 3 assert max_employees_logged_in(4, [(1, 3), (2, 5), (4, 6), (7, 9)]) == 2 assert max_employees_logged_in(1, [(1, 10)]) == 1 assert max_employees_logged_in(3, [(1, 10), (1, 5), (1, 7)]) == 3 assert max_employees_logged_in(3, [(1, 5), (2, 5), (3, 5)]) == 3 assert max_employees_logged_in(3, [(1, 2), (3, 4), (5, 6)]) == 1 assert max_employees_logged_in(5, [(1, 5), (2, 3), (3, 7), (5, 8), (6, 9)]) == 3","solution":"def max_employees_logged_in(n, intervals): Determine the maximum number of employees logged in simultaneously. Args: - n (int): Number of login-logout pairs. - intervals (list of tuples): List of (login, logout) times. Returns: - int: Maximum number of employees logged in simultaneously. # Events will store tuples of (time, type) # Type is +1 for login, -1 for logout events = [] for login, logout in intervals: events.append((login, +1)) events.append((logout, -1)) # Sort events by time # If two events have the same time, -1 (logout) should come before +1 (login) events.sort(key=lambda x: (x[0], x[1])) max_logged_in = 0 current_logged_in = 0 for time, event_type in events: current_logged_in += event_type if current_logged_in > max_logged_in: max_logged_in = current_logged_in return max_logged_in"},{"question":"def calculate_full_boxes(datasets: List[Tuple[int, int]]) -> List[int]: Determine the number of full boxes of cakes that can be shipped given the number of cakes produced and the packaging size for each request. Args: datasets (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers: - cakes per box - cakes produced Returns: List[int]: A list of integers representing the number of full boxes for each dataset. Examples: >>> calculate_full_boxes([(10, 55), (20, 92), (15, 45), (0, 0)]) [5, 4, 3] >>> calculate_full_boxes([(8, 64), (12, 99), (7, 80), (0, 0)]) [8, 8, 11]","solution":"def calculate_full_boxes(datasets): results = [] for dataset in datasets: cakes_per_box, cakes_produced = dataset if cakes_per_box == 0 and cakes_produced == 0: break full_boxes = cakes_produced // cakes_per_box results.append(full_boxes) return results"},{"question":"def can_split_into_unique_substrings(n: int, g: str) -> str: Determines if the string g can be split into distinct, non-overlapping substrings. :param n: Length of the string g :param g: Gesture string consisting of uppercase English letters :return: \\"YES\\" if the string can be split into distinct non-overlapping substrings, otherwise \\"NO\\" >>> can_split_into_unique_substrings(6, \\"AABBCC\\") \\"YES\\" >>> can_split_into_unique_substrings(4, \\"ABAB\\") \\"NO\\" >>> can_split_into_unique_substrings(7, \\"ABCDEFG\\") \\"YES\\" >>> can_split_into_unique_substrings(1, \\"A\\") \\"YES\\" >>> can_split_into_unique_substrings(5, \\"AAAAA\\") \\"NO\\" >>> can_split_into_unique_substrings(100000, \\"A\\" * 50000 + \\"B\\" * 50000) \\"NO\\" >>> can_split_into_unique_substrings(8, \\"AABACADA\\") \\"YES\\" >>> can_split_into_unique_substrings(5, \\"ABCDE\\") \\"YES\\" >>> can_split_into_unique_substrings(8, \\"ABABABAB\\") \\"NO\\"","solution":"def can_split_into_unique_substrings(n, g): Determines if the string g can be split into distinct, non-overlapping substrings. :param n: Length of the string g :param g: Gesture string consisting of uppercase English letters :return: \\"YES\\" if the string can be split into distinct non-overlapping substrings, otherwise \\"NO\\" seen_substrings = set() temp_substring = \\"\\" for ch in g: temp_substring += ch if temp_substring in seen_substrings: return \\"NO\\" seen_substrings.add(temp_substring) temp_substring = ch return \\"YES\\" # Example Usage: # n = 6 # g = \\"AABBCC\\" # print(can_split_into_unique_substrings(n, g)) # Output: \\"YES\\""},{"question":"from typing import List, Dict, Union def smallest_greater_than_target(matrix: List[List[int]], target: int) -> int: Finds the smallest element in a sorted matrix that is greater than the target. :param matrix: List of lists, represents the sorted matrix. :param target: Integer, the target value. :return: The smallest integer in the matrix greater than the target, or -1 if no such element exists. pass def process_test_cases(t: int, test_cases: List[Dict[str, Union[List[List[int], int]]]]) -> List[int]: Processes multiple test cases and returns results for each case. :param t: Integer, the number of test cases. :param test_cases: List of test cases, each containing a matrix and a target value. :return: List of results for each test case. pass def test_smallest_greater_than_target(): matrix1 = [ [1, 3, 5], [2, 4, 6], [3, 5, 7] ] target1 = 4 assert smallest_greater_than_target(matrix1, target1) == 5 matrix2 = [ [1, 2], [3, 4] ] target2 = 5 assert smallest_greater_than_target(matrix2, target2) == -1 matrix3 = [ [1, 3, 5], [2, 8, 10], [7, 9, 11] ] target3 = 6 assert smallest_greater_than_target(matrix3, target3) == 7 matrix4 = [ [-10, -5, 0], [5, 10, 15], [20, 25, 30] ] target4 = -1 assert smallest_greater_than_target(matrix4, target4) == 0 matrix5 = [ [-10, -5, -3], [-2, 0, 1] ] target5 = -10 assert smallest_greater_than_target(matrix5, target5) == -5 def test_process_test_cases(): test_cases = [ { \\"matrix\\": [ [1, 3, 5], [2, 4, 6], [3, 5, 7] ], \\"target\\": 4 }, { \\"matrix\\": [ [1, 2], [3, 4] ], \\"target\\": 5 } ] assert process_test_cases(2, test_cases) == [5, -1] test_cases = [ { \\"matrix\\": [ [1, 3, 5], [2, 8, 10], [7, 9, 11] ], \\"target\\": 6 }, { \\"matrix\\": [ [-10, -5, 0], [5, 10, 15], [20, 25, 30] ], \\"target\\": -1 } ] assert process_test_cases(2, test_cases) == [7, 0]","solution":"def smallest_greater_than_target(matrix, target): Finds the smallest element in a sorted matrix that is greater than the target. :param matrix: List of lists, represents the sorted matrix. :param target: Integer, the target value. :return: The smallest integer in the matrix greater than the target, or -1 if no such element exists. m = len(matrix) n = len(matrix[0]) candidates = [] for i in range(m): for j in range(n): if matrix[i][j] > target: candidates.append(matrix[i][j]) if candidates: return min(candidates) else: return -1 def process_test_cases(t, test_cases): results = [] for i in range(t): matrix = test_cases[i][\\"matrix\\"] target = test_cases[i][\\"target\\"] results.append(smallest_greater_than_target(matrix, target)) return results"},{"question":"def simulate_spice_trading(N: int, initial_values: List[int], T: int, activities: List[Tuple[int, str]]) -> List[int]: Simulate the trading activities in the town and calculate the final trading values for each spice after processing all trading activities. Args: N (int): The number of different types of spices. initial_values (List[int]): Initial values of each spice. T (int): The number of trading activities. activities (List[Tuple[int, str]]): A list of trading activities where each activity is represented by a tuple (AI, SI). \`AI\` is 0 for buying and 1 for selling, and \`SI\` is the name of the spice. Returns: List[int]: The final values of the spices in the same order as their initial values. >>> simulate_spice_trading(3, [10, 5, 8], 6, [(1, 'spice_0'), (1, 'spice_1'), (0, 'spice_0'), (1, 'spice_2'), (0, 'spice_1'), (0, 'spice_2')]) [10, 5, 8] >>> simulate_spice_trading(2, [3, 4], 3, [(1, 'spice_0'), (1, 'spice_1'), (1, 'spice_0')]) [5, 5] # Unit Tests def test_all_selling(): assert simulate_spice_trading(2, [3, 4], 3, [(1, 'spice_0'), (1, 'spice_1'), (1, 'spice_0')]) == [5, 5] def test_all_buying(): assert simulate_spice_trading(3, [5, 6, 7], 4, [(0, 'spice_0'), (0, 'spice_1'), (0, 'spice_2'), (0, 'spice_2')]) == [4, 5, 5] def test_mixed_transactions(): assert simulate_spice_trading(3, [10, 5, 8], 6, [(1, 'spice_0'), (1, 'spice_1'), (0, 'spice_0'), (1, 'spice_2'), (0, 'spice_1'), (0, 'spice_2')]) == [10, 5, 8] def test_value_never_below_one(): assert simulate_spice_trading(2, [1, 2], 2, [(0, 'spice_0'), (0, 'spice_0')]) == [1, 2] def test_no_activities(): assert simulate_spice_trading(2, [5, 6], 0, []) == [5, 6]","solution":"def simulate_spice_trading(N, initial_values, T, activities): # Create a dictionary to store spice values with their names spice_values = {f\\"spice_{i}\\": initial_values[i] for i in range(N)} for activity in activities: action, spice_name = activity if action == 1: # Selling spice_values[spice_name] += 1 elif action == 0: # Buying spice_values[spice_name] -= 1 # Ensure that the spice value doesn't drop below 1 if spice_values[spice_name] < 1: spice_values[spice_name] = 1 # Return the final values of the spices in the same order as the initial values return [spice_values[f\\"spice_{i}\\"] for i in range(N)] # Example usage N = 3 initial_values = [10, 5, 8] T = 6 activities = [ (1, 'spice_0'), (1, 'spice_1'), (0, 'spice_0'), (1, 'spice_2'), (0, 'spice_1'), (0, 'spice_2') ] result = simulate_spice_trading(N, initial_values, T, activities) print(result) # Output: [10, 5, 8]"},{"question":"def can_form_wave(n: int, heights: List[int]) -> str: Determines if it's possible to arrange the plants in a \\"wave\\" pattern. Parameters: n (int): The number of plants. heights (list of int): The heights of the plants. Returns: str: \\"YES\\" if it's possible to form a wave, otherwise \\"NO\\". >>> can_form_wave(4, [4, 3, 2, 1]) 'YES' >>> can_form_wave(3, [1, 2, 2]) 'NO'","solution":"def can_form_wave(n, heights): Determines if it's possible to arrange the plants in a \\"wave\\" pattern. Parameters: n (int): The number of plants. heights (list of int): The heights of the plants. Returns: str: \\"YES\\" if it's possible to form a wave, otherwise \\"NO\\". heights.sort() # Check for duplicates for i in range(1, n): if heights[i] == heights[i-1]: return \\"NO\\" # We can always form a wave pattern if there are no duplicates return \\"YES\\""},{"question":"from typing import List, Tuple def max_flow(n: int, m: int, waterways: List[Tuple[int, int, int]]) -> int: Calculates the maximum water flow from the source dam to the sink dam using the capacities of the waterways. >>> max_flow(4, 5, [(1, 2, 100), (1, 3, 100), (2, 4, 50), (3, 4, 50), (2, 3, 50)]) 100 >>> max_flow(4, 3, [(1, 2, 10), (2, 3, 5)]) 0 >>> max_flow(3, 2, [(1, 2, 10), (2, 3, 5)]) 5 >>> max_flow(6, 8, [(1, 2, 10), (1, 3, 10), (2, 4, 5), (2, 5, 5), (3, 5, 10), (4, 6, 10), (5, 4, 10), (5, 6, 10)]) 20 >>> max_flow(4, 5, [(1, 2, 1000), (1, 3, 1000), (2, 4, 500), (3, 4, 500), (2, 3, 500)]) 1000","solution":"from collections import deque def bfs_capacity(graph, source, sink, parent): A BFS for finding the augmenting path in the residual graph. visited = [False] * len(graph) queue = deque([source]) visited[source] = True while queue: u = queue.popleft() for v, capacity in enumerate(graph[u]): if not visited[v] and capacity > 0: queue.append(v) visited[v] = True parent[v] = u if v == sink: return True return False def max_flow(n, m, waterways): Calculates the maximum flow from source to sink using the Ford-Fulkerson algorithm. source = 0 sink = n - 1 graph = [[0] * n for _ in range(n)] for u, v, c in waterways: graph[u - 1][v - 1] += c parent = [-1] * n max_flow = 0 while bfs_capacity(graph, source, sink, parent): path_flow = float('Inf') s = sink while s != source: path_flow = min(path_flow, graph[parent[s]][s]) s = parent[s] v = sink while v != source: u = parent[v] graph[u][v] -= path_flow graph[v][u] += path_flow v = parent[v] max_flow += path_flow return max_flow"},{"question":"from typing import List, Tuple def find_path(n: int, blocked: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Determine if there is a path from the top-left corner to the bottom-right corner in a grid, and return that path as a list of points or an empty list if no such path exists. Args: n (int): The size of the grid (n x n). blocked (List[Tuple[int, int]]): A list of tuples representing blocked intersections. Returns: List[Tuple[int, int]]: A list of tuples representing the path from the top-left to the bottom-right, or an empty list if no such path exists. Example: >>> find_path(3, [(1, 0), (1, 1)]) [(0, 0), (0, 1), (0, 2), (1, 2), (2, 2)] >>> find_path(3, [(1, 0), (1, 1), (0, 2), (2, 1)]) []","solution":"from typing import List, Tuple def find_path(n: int, blocked: List[Tuple[int, int]]) -> List[Tuple[int, int]]: from collections import deque # Create a grid to mark the blocked intersections grid = [[0] * n for _ in range(n)] for (x, y) in blocked: grid[x][y] = 1 # Define the possible moves: right, down, left, up moves = [(0, 1), (1, 0), (0, -1), (-1, 0)] # Function to check if a coordinate is within bounds and not blocked def is_valid(x, y): return 0 <= x < n and 0 <= y < n and grid[x][y] == 0 # Perform BFS to find the path queue = deque([((0, 0), [(0, 0)])]) visited = set((0, 0)) while queue: (x, y), path = queue.popleft() # If we reached the bottom-right corner, return the path if (x, y) == (n-1, n-1): return path # Explore the neighbors for dx, dy in moves: nx, ny = x + dx, y + dy if is_valid(nx, ny) and (nx, ny) not in visited: visited.add((nx, ny)) queue.append(((nx, ny), path + [(nx, ny)])) # If no path was found, return an empty list return []"},{"question":"def min_cost_path(matrix): Return the minimum cost path from the top-left to the bottom-right corner of a given matrix. The function takes an MxN matrix as input and returns the minimum cost to reach the bottom-right corner from the top-left corner. Args: matrix (List[List[int]]): The MxN cost matrix. Returns: int: The minimum cost to reach the bottom-right corner from the top-left corner. Examples: >>> matrix = [ ... [1, 2, 3], ... [4, 8, 2], ... [1, 5, 3] ... ] >>> min_cost_path(matrix) 8 >>> matrix = [ ... [5] ... ] >>> min_cost_path(matrix) 5 >>> matrix = [ ... [1, 2], ... [3, 4] ... ] >>> min_cost_path(matrix) 5 >>> matrix = [ ... [1, 2, 3, 4], ... [5, 6, 7, 8], ... [9, 10, 11, 12], ... [13, 14, 15, 16] ... ] >>> min_cost_path(matrix) 34","solution":"def min_cost_path(matrix): Returns the minimum cost path from top-left to bottom-right in a given matrix. if not matrix or not matrix[0]: return 0 M, N = len(matrix), len(matrix[0]) dp = [[float('inf')] * N for _ in range(M)] dp[0][0] = matrix[0][0] for i in range(M): for j in range(N): if i > 0: dp[i][j] = min(dp[i][j], dp[i-1][j] + matrix[i][j]) if j > 0: dp[i][j] = min(dp[i][j], dp[i][j-1] + matrix[i][j]) if i > 0 and j > 0: dp[i][j] = min(dp[i][j], dp[i-1][j-1] + matrix[i][j]) return dp[M-1][N-1] def parse_input(): import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) matrix = [] index = 2 for i in range(M): row = [int(data[index + j]) for j in range(N)] index += N matrix.append(row) return (M, N, matrix) if __name__ == \\"__main__\\": M, N, matrix = parse_input() print(min_cost_path(matrix))"},{"question":"def minimum_modifications(n: int, m: int, grid: List[List[int]]) -> int: Given a 2D grid representing a maze, find the minimum number of blocked cells that need to be made open to ensure there is a path from the top-left corner to the bottom-right corner. Args: n (int): number of rows in the grid. m (int): number of columns in the grid. grid (List[List[int]]): 2D grid representing the maze. Returns: int: minimum number of blocked cells to be made open to ensure a path. Example: >>> minimum_modifications(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ]) 1 >>> minimum_modifications(3, 3, [ ... [0, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 0 >>> minimum_modifications(3, 3, [ ... [0, 0, 1], ... [1, 1, 1], ... [0, 1, 0] ... ]) 2 >>> minimum_modifications(2, 2, [ ... [0, 0], ... [0, 0] ... ]) 0 >>> minimum_modifications(3, 3, [ ... [0, 1, 1], ... [1, 1, 0], ... [0, 0, 0] ... ]) 1","solution":"from collections import deque import heapq def minCellsToOpenForPath(grid): n = len(grid) m = len(grid[0]) if n == 0 or m == 0: return -1 def is_valid(x, y): return 0 <= x < n and 0 <= y < m directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] # Early exit if initial or final cell is blocked if grid[0][0] == 1 or grid[n-1][m-1] == 1: return -1 def dijkstra(): pq = [(0, 0, 0)] dist = [[float(\\"inf\\")] * m for _ in range(n)] dist[0][0] = 0 while pq: d, x, y = heapq.heappop(pq) if (x, y) == (n-1, m-1): return d for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny): new_dist = d + (1 if grid[nx][ny] == 1 else 0) if new_dist < dist[nx][ny]: dist[nx][ny] = new_dist heapq.heappush(pq, (new_dist, nx, ny)) return dist[n-1][m-1] result = dijkstra() return result if result != float(\\"inf\\") else -1 def minimum_modifications(n, m, grid): return minCellsToOpenForPath(grid)"},{"question":"def can_form_strictly_ordered_sequence(n: int, array: List[int]) -> str: Determine if the array can be rearranged to form a strictly ordered sequence. >>> can_form_strictly_ordered_sequence(5, [1, 3, 2, 4, 5]) \\"YES\\" >>> can_form_strictly_ordered_sequence(4, [4, 3, 2, 1]) \\"YES\\" >>> can_form_strictly_ordered_sequence(3, [1, 2, 3]) \\"YES\\" >>> can_form_strictly_ordered_sequence(3, [1, 1, 2]) \\"NO\\" pass def check_sequences(test_cases: List[Tuple[int, List[int]]]) -> List[str]: Check multiple sequences to determine if they can be rearranged to form strictly ordered sequences. >>> check_sequences([(5, [1, 3, 2, 4, 5]), (4, [4, 3, 2, 1]), (3, [1, 2, 3])]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_sequences([(3, [1, 1, 2]), (5, [5, 3, 2, 1, 4]), (4, [4, 4, 2, 1])]) [\\"NO\\", \\"YES\\", \\"NO\\"] pass","solution":"def can_form_strictly_ordered_sequence(n, array): Determine if the array can be rearranged to form a strictly ordered sequence. Args: n : int : number of elements in the array array : list of int : the elements of the array Returns: str : \\"YES\\" if a strictly ordered sequence can be formed, else \\"NO\\" sorted_array = sorted(array) if all(sorted_array[i] != sorted_array[i+1] for i in range(n-1)): return \\"YES\\" else: return \\"NO\\" def check_sequences(test_cases): results = [] for n, array in test_cases: result = can_form_strictly_ordered_sequence(n, array) results.append(result) return results"},{"question":"import string from typing import List def word_weight(word: str) -> int: Calculate the weight of a word based on the sum of the positions of its characters in the alphabet. >>> word_weight('a') 1 >>> word_weight('z') 26 >>> word_weight('abc') 6 >>> word_weight('test') 64 def sort_words_by_weight(phrase: str) -> str: Sort the words in the phrase based on their weight in ascending order. If two words have the same weight, maintain their original order. >>> sort_words_by_weight('this is a test') 'a is this test' >>> sort_words_by_weight('hack the planet') 'hack the planet' >>> sort_words_by_weight('random access memory') 'access random memory' def process_phrases(phrases: List[str]) -> List[str]: Process a list of phrases and return the sorted words by their weights for each phrase. >>> process_phrases(['this is a test', 'hack the planet', 'random access memory']) ['a is this test', 'hack the planet', 'access random memory']","solution":"def word_weight(word): Calculate the weight of a word based on the sum of the positions of its characters in the alphabet. return sum(ord(char) - ord('a') + 1 for char in word) def sort_words_by_weight(phrase): Sort the words in the phrase based on their weight in ascending order. If two words have the same weight, maintain their original order. words = phrase.split() weights = [(word, word_weight(word)) for word in words] sorted_words = sorted(weights, key=lambda x: x[1]) return ' '.join(word for word, _ in sorted_words) def process_phrases(phrases): Process a list of phrases and return the sorted words by their weights for each phrase. result = [] for phrase in phrases: result.append(sort_words_by_weight(phrase)) return result"},{"question":"from typing import List def print_filesystem_structure(paths: List[str]) -> None: Given a collection of directory paths, print the hierarchical structure of the filesystem with indentation. >>> paths = [ ... \\"/root/home/user\\", ... \\"/root/home/user/docs\\", ... \\"/root/etc\\", ... \\"/root/home/admin\\", ... \\"/root/local/bin\\" ... ] >>> expected_output = ( ... \\"/rootn\\" ... \\" /etcn\\" ... \\" /homen\\" ... \\" /adminn\\" ... \\" /usern\\" ... \\" /docsn\\" ... \\" /localn\\" ... \\" /binn\\" ... ) >>> print_filesystem_structure(paths) >>> # Check captured output with expected_output # Your implementation here def test_filesystem_structure(capsys): paths = [ \\"/root/home/user\\", \\"/root/home/user/docs\\", \\"/root/etc\\", \\"/root/home/admin\\", \\"/root/local/bin\\" ] expected_output = ( \\"/rootn\\" \\" /etcn\\" \\" /homen\\" \\" /adminn\\" \\" /usern\\" \\" /docsn\\" \\" /localn\\" \\" /binn\\" ) print_filesystem_structure(paths) captured = capsys.readouterr() assert captured.out == expected_output def test_filesystem_structure_another_test_case(capsys): paths = [ \\"/a/b/c\\", \\"/a/b/d\\", \\"/a/e\\", \\"/f/g/h\\", \\"/f/i\\" ] expected_output = ( \\"/an\\" \\" /bn\\" \\" /cn\\" \\" /dn\\" \\" /en\\" \\"/fn\\" \\" /gn\\" \\" /hn\\" \\" /in\\" ) print_filesystem_structure(paths) captured = capsys.readouterr() assert captured.out == expected_output def test_filesystem_structure_single_directory(capsys): paths = [ \\"/root\\" ] expected_output = \\"/rootn\\" print_filesystem_structure(paths) captured = capsys.readouterr() assert captured.out == expected_output def test_filesystem_structure_nested_directories(capsys): paths = [ \\"/a/b\\", \\"/a/b/c/d\\" ] expected_output = ( \\"/an\\" \\" /bn\\" \\" /cn\\" \\" /dn\\" ) print_filesystem_structure(paths) captured = capsys.readouterr() assert captured.out == expected_output","solution":"def print_filesystem_structure(paths): def add_path_to_tree(tree, path_parts): if not path_parts: return part = '/' + path_parts[0] if part not in tree: tree[part] = {} add_path_to_tree(tree[part], path_parts[1:]) paths = [path.split('/')[1:] for path in paths] filesystem_tree = {} for path in paths: add_path_to_tree(filesystem_tree, path) def print_tree(tree, indent=0): for key in sorted(tree.keys()): print(' ' * indent + key) print_tree(tree[key], indent + 4) print_tree(filesystem_tree)"},{"question":"def max_non_adjacent_sum(arr: List[int]) -> int: Given a list of integers, returns the maximum possible sum of a subsequence where no two elements are adjacent. Args: arr (List[int]): A list of integers. Returns: int: The maximum possible sum of a subsequence where no two elements are adjacent. Examples: >>> max_non_adjacent_sum([3, 2, 5, 10, 7]) 15 >>> max_non_adjacent_sum([1, 2, 3, 4, 5, 6]) 12 >>> max_non_adjacent_sum([5, 5, 10, 100, 10, 5]) 110 >>> max_non_adjacent_sum([-3, -2, -5, -10, -7]) 0 >>> max_non_adjacent_sum([3, -2, 5, -1, 2]) 10","solution":"def max_non_adjacent_sum(arr): Returns the maximum possible sum of a subsequence where no two elements are adjacent. if not arr: return 0 if len(arr) == 1: return max(0, arr[0]) # Initialize two variables to keep track of the maximum sum with and without the previous element incl = max(0, arr[0]) # max sum including the previous element excl = 0 # max sum excluding the previous element for num in arr[1:]: # Current max excluding the current number new_excl = max(incl, excl) # Current max including the current number incl = excl + num excl = new_excl # Return the maximum of incl and excl return max(incl, excl)"},{"question":"from typing import List def min_vehicles_required(w: int, n: int, packages: List[int]) -> int: Determine the minimum number of vehicles required to deliver all the packages, given the weight limit of each vehicle and the weights of the packages. >>> min_vehicles_required(10, 5, [8, 4, 2, 7, 1]) == 3 >>> min_vehicles_required(12, 7, [2, 3, 5, 7, 8, 4, 6]) == 3 >>> min_vehicles_required(15, 4, [5, 5, 3, 2]) == 1 >>> min_vehicles_required(5, 4, [6, 7, 8, 9]) == 4 >>> min_vehicles_required(10, 6, [9, 1, 7, 3, 6, 2]) == 3 >>> min_vehicles_required(10, 1, [5]) == 1 >>> min_vehicles_required(50, 10, [10, 20, 30, 10, 20, 30, 10, 20, 30, 15]) == 4","solution":"def min_vehicles_required(w, n, packages): # Sort packages in descending order to fit the largest one first packages.sort(reverse=True) vehicles = 0 used = [False] * n for i in range(n): if not used[i]: remaining_capacity = w - packages[i] used[i] = True for j in range(i + 1, n): if not used[j] and packages[j] <= remaining_capacity: remaining_capacity -= packages[j] used[j] = True vehicles += 1 return vehicles"},{"question":"def num_of_bsts(n: int) -> int: Compute the number of distinct binary search trees (BSTs) that can be formed using the given n nodes. Given a binary tree with n nodes, where each node has a unique value from 1 to n, find the number of distinct binary search trees (BSTs). The result should be returned modulo 1000000007 (10^9 + 7). Args: n: An integer representing the number of nodes. Returns: An integer representing the number of distinct BSTs modulo 1000000007. Examples: >>> num_of_bsts(1) 1 >>> num_of_bsts(2) 2 >>> num_of_bsts(3) 5 >>> num_of_bsts(4) 14 # Implementation goes here","solution":"def num_of_bsts(n): MOD = 1000000007 # Use dynamic programming to store Catalan numbers catalan = [0] * (n + 1) catalan[0] = 1 catalan[1] = 1 # Compute the values for each i till n for i in range(2, n + 1): catalan[i] = 0 for j in range(i): catalan[i] = (catalan[i] + catalan[j] * catalan[i - j - 1]) % MOD return catalan[n]"},{"question":"def max_savings(n: int, k: int, d: int, prices: List[int], categories: List[int]) -> int: Calculate the maximum possible savings a user can achieve by buying exactly one item from each of k different categories. Parameters: n (int): total number of items. k (int): required number of distinct categories. d (int): fixed bundle discount amount. prices (List[int]): prices of the items. categories (List[int]): categories of the items. Returns: int: the maximum possible savings a user can achieve. Example: >>> max_savings(5, 3, 100, [200, 50, 300, 20, 150], [1, 2, 3, 1, 2]) 120 >>> max_savings(4, 4, 50, [100, 200, 50, 400], [1, 2, 3, 3]) 0 pass import pytest def test_example_1(): n, k, d = 5, 3, 100 prices = [200, 50, 300, 20, 150] categories = [1, 2, 3, 1, 2] assert max_savings(n, k, d, prices, categories) == 370 - 100 def test_example_2(): n, k, d = 4, 4, 50 prices = [100, 200, 50, 400] categories = [1, 2, 3, 3] assert max_savings(n, k, d, prices, categories) == 0 def test_no_discount_needed(): n, k, d = 3, 3, 0 prices = [10, 20, 30] categories = [1, 2, 3] assert max_savings(n, k, d, prices, categories) == 60 def test_minimal_case(): n, k, d = 1, 1, 5 prices = [10] categories = [1] assert max_savings(n, k, d, prices, categories) == 10 - 5 def test_more_categories_than_needed(): n, k, d = 6, 3, 50 prices = [10, 20, 30, 40, 50, 60] categories = [1, 2, 3, 4, 5, 6] assert max_savings(n, k, d, prices, categories) == 60 - 50 def test_same_category_items(): n, k, d = 4, 2, 30 prices = [10, 10, 90, 10] categories = [1, 1, 2, 2] assert max_savings(n, k, d, prices, categories) == 20 - 30","solution":"def max_savings(n, k, d, prices, categories): from collections import defaultdict import heapq category_items = defaultdict(list) # Group items by their categories for i in range(n): category_items[categories[i]].append(prices[i]) # Check if it's possible to have exactly one item from k distinct categories if len(category_items) < k: return 0 # Extract the cheapest item from each category cheapest_items = [] for items in category_items.values(): heapq.heappush(cheapest_items, min(items)) # If there are more than k categories, we need to select only the k cheapest items if len(cheapest_items) > k: cheapest_items = heapq.nsmallest(k, cheapest_items) # Calculate total savings total_savings = sum(cheapest_items) - d return total_savings"},{"question":"class ParkingLot: A class to manage a parking lot with support for parking, removing, moving and checking cars in the spots. Methods: park(spot_number: int, car_code: str) -> Union[None, str] remove(spot_number: int) -> Union[None, str] move(source_spot: int, destination_spot: int) -> Union[None, str] check(car_code: str) -> Union[int, str] >>> parking_lot = ParkingLot() >>> parking_lot.park(1, \\"AB1234\\") >>> parking_lot.park(2, \\"CD5678\\") >>> parking_lot.check(\\"AB1234\\") 1 >>> parking_lot.move(1, 3) >>> parking_lot.check(\\"AB1234\\") 3 >>> parking_lot.remove(2) >>> parking_lot.check(\\"CD5678\\") 'NOT FOUND' >>> parking_lot.park(2, \\"EF9101\\") >>> parking_lot.move(3, 2) >>> parking_lot.check(\\"AB1234\\") 2 >>> parking_lot.check(\\"EF9101\\") 2 def __init__(self): self.spots = [None] * 100 # Initialize 100 parking spots def park(self, spot_number, car_code): if self.spots[spot_number - 1] is not None: return \\"ERROR: Spot already occupied\\" self.spots[spot_number - 1] = car_code def remove(self, spot_number): if self.spots[spot_number - 1] is None: return \\"ERROR: Spot already empty\\" self.spots[spot_number - 1] = None def move(self, source_spot, destination_spot): if self.spots[source_spot - 1] is None: return \\"ERROR: Invalid move - Source spot empty\\" if self.spots[destination_spot - 1] is not None: return \\"ERROR: Invalid move - Destination spot occupied\\" self.spots[destination_spot - 1] = self.spots[source_spot - 1] self.spots[source_spot - 1] = None def check(self, car_code): for i, car in enumerate(self.spots): if car == car_code: return i + 1 return \\"NOT FOUND\\"","solution":"class ParkingLot: def __init__(self): self.spots = [None] * 100 # Initialize 100 parking spots def park(self, spot_number, car_code): if self.spots[spot_number - 1] is not None: return \\"ERROR: Spot already occupied\\" self.spots[spot_number - 1] = car_code def remove(self, spot_number): if self.spots[spot_number - 1] is None: return \\"ERROR: Spot already empty\\" self.spots[spot_number - 1] = None def move(self, source_spot, destination_spot): if self.spots[source_spot - 1] is None: return \\"ERROR: Invalid move - Source spot empty\\" if self.spots[destination_spot - 1] is not None: return \\"ERROR: Invalid move - Destination spot occupied\\" self.spots[destination_spot - 1] = self.spots[source_spot - 1] self.spots[source_spot - 1] = None def check(self, car_code): for i, car in enumerate(self.spots): if car == car_code: return i + 1 return \\"NOT FOUND\\""},{"question":"from typing import List def decode_sequence(sequence: str) -> List[str]: Decodes a given sequence of number inputs into all possible strings based on the old mobile keypad mapping. >>> decode_sequence(\\"23\\") ['ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf'] >>> decode_sequence(\\"78\\") ['pt', 'pu', 'pv', 'qt', 'qu', 'qv', 'rt', 'ru', 'rv', 'st', 'su', 'sv'] >>> decode_sequence(\\"0\\") [' '] >>> decode_sequence(\\"201\\") ['a ', 'b ', 'c ']","solution":"from itertools import product def decode_sequence(sequence): Decodes a given sequence of number inputs into all possible strings based on the old mobile keypad mapping. digit_to_letters = { '1': [''], '2': ['a', 'b', 'c'], '3': ['d', 'e', 'f'], '4': ['g', 'h', 'i'], '5': ['j', 'k', 'l'], '6': ['m', 'n', 'o'], '7': ['p', 'q', 'r', 's'], '8': ['t', 'u', 'v'], '9': ['w', 'x', 'y', 'z'], '0': [' '] } if not sequence: return [] groups = [digit_to_letters[digit] for digit in sequence] possible_combinations = [''.join(combination) for combination in product(*groups)] return possible_combinations"},{"question":"def max_tasks_completed(R: int, T: int, capacities: List[int], task_intervals: List[Tuple[int, int]]) -> int: Determine the maximum number of tasks that can be completed by the robots without exceeding their capacities and respecting the time windows of the tasks. >>> max_tasks_completed(3, 5, [2, 3, 1], [(1, 4), (2, 6), (1, 3), (5, 8), (6, 9)]) == 5 >>> max_tasks_completed(4, 6, [1, 1, 1, 1], [(2, 5), (1, 3), (3, 4), (6, 8), (7, 10), (3, 9)]) == 4","solution":"def max_tasks_completed(R, T, capacities, task_intervals): # Sort tasks by their end times to maximize the number of tasks task_intervals.sort(key=lambda x: x[1]) # Dictionary to keep track of the tasks completed by each robot; initialized with capacity robots = {i: capacities[i] for i in range(R)} max_tasks = 0 for (start, end) in task_intervals: # Try to assign task to any available robot for robot in robots: if robots[robot] > 0: robots[robot] -= 1 max_tasks += 1 break return max_tasks # Inputs for the examples provided R1, T1 = 3, 5 capacities1 = [2, 3, 1] task_intervals1 = [(1, 4), (2, 6), (1, 3), (5, 8), (6, 9)] R2, T2 = 4, 6 capacities2 = [1, 1, 1, 1] task_intervals2 = [(2, 5), (1, 3), (3, 4), (6, 8), (7, 10), (3, 9)] print(max_tasks_completed(R1, T1, capacities1, task_intervals1)) # Output: 5 print(max_tasks_completed(R2, T2, capacities2, task_intervals2)) # Output: 4"},{"question":"from typing import List, Tuple def minimum_shipping_cost(test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[int]: Determine the least total shipping cost possible under the given constraints. >>> minimum_shipping_cost([(3, [(1, 100), (2, 200), (1, 150)])]) [300] >>> minimum_shipping_cost([(3, [(1, 100), (2, 200), (1, 150)]), (4, [(1, 100), (2, 200), (3, 300), (2, 250)])]) [300, 600] >>> minimum_shipping_cost([(3, [(1, 100), (2, 200), (3, 150)])]) [450] >>> minimum_shipping_cost([(4, [(1, 500), (1, 300), (1, 700), (2, 200)])]) [500] >>> minimum_shipping_cost([(0, [])]) [0] def read_input(input_str: str) -> List[Tuple[int, List[Tuple[int, int]]]]: Read the input string and convert it to a list of test cases. >>> read_input(\\"1n3n1 100n2 200n1 150\\") [(3, [(1, 100), (2, 200), (1, 150)])]","solution":"import itertools def minimum_shipping_cost(test_cases): result = [] for case in test_cases: N, goods = case destinations = set() cost_mapping = {} for destination, cost in goods: if destination not in cost_mapping: cost_mapping[destination] = [] cost_mapping[destination].append(cost) min_cost = 0 for destination in cost_mapping: min_cost += min(cost_mapping[destination]) result.append(min_cost) return result # Read Input def read_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) idx = 1 test_cases = [] for _ in range(T): N = int(lines[idx]) goods = [] for j in range(N): destination, cost = map(int, lines[idx + 1 + j].split()) goods.append((destination, cost)) test_cases.append((N, goods)) idx += N + 1 return test_cases # Example Usage input_str = 1 3 1 100 2 200 1 150 test_cases = read_input(input_str) output = minimum_shipping_cost(test_cases) for result in output: print(result)"},{"question":"def min_fireworks_to_cover(L, R, fireworks): Determine the minimum number of fireworks needed to cover the full length of the road from L to R. def solve(input_str): Parse the input string, run min_fireworks_to_cover for each dataset, and return the outputs as a single string. def test_min_fireworks_to_cover(): input_str = \\"0 10 3n2 4n8 2n10 1n0 15 2n5 5n10 4n0\\" expected_output = \\"2nIMPOSSIBLE\\" assert solve(input_str) == expected_output def test_single_firework_just_sufficient(): input_str = \\"0 5 1n2 3n0\\" assert solve(input_str) == \\"1\\" def test_multiple_fireworks_covering_exact(): input_str = \\"0 10 3n2 4n4 5n7 3n0\\" assert solve(input_str) == \\"2\\" def test_no_possible_coverage(): input_str = \\"0 15 2n1 1n13 1n0\\" assert solve(input_str) == \\"IMPOSSIBLE\\" def test_full_coverage_possible(): input_str = \\"0 15 4n2 4n5 6n10 5n14 2n0\\" assert solve(input_str) == \\"2\\" def test_edge_case_just_covering(): input_str = \\"0 10 2n0 10n10 1n0\\" assert solve(input_str) == \\"1\\"","solution":"def min_fireworks_to_cover(L, R, fireworks): Determine the minimum number of fireworks needed to cover the full length of the road from L to R. fireworks.sort(key=lambda x: x[0] - x[1]) end_reach = L num_fireworks = 0 i = 0 intervals = [] while end_reach < R: furthest_end = -1 while i < len(fireworks) and fireworks[i][0] - fireworks[i][1] <= end_reach: furthest_end = max(furthest_end, fireworks[i][0] + fireworks[i][1]) i += 1 if furthest_end == -1: return \\"IMPOSSIBLE\\" end_reach = furthest_end num_fireworks += 1 if end_reach >= R: return num_fireworks return \\"IMPOSSIBLE\\" def solve(input_str): input_lines = input_str.strip().split('n') result = [] i = 0 while i < len(input_lines): if input_lines[i] == \\"0\\": break L, R, n = map(int, input_lines[i].split()) i += 1 fireworks = [tuple(map(int, input_lines[i + j].split())) for j in range(n)] i += n result.append(str(min_fireworks_to_cover(L, R, fireworks))) return \\"n\\".join(result)"},{"question":"def maxSubArraySum(arr: List[int]) -> int: Returns the sum of the contiguous subarray with the largest sum. >>> maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> maxSubArraySum([1]) 1 >>> maxSubArraySum([5, -2, 3, -1, 6, -2, 1]) 11","solution":"def maxSubArraySum(arr): Returns the sum of the contiguous subarray with the largest sum. Uses Kadane's algorithm for finding the maximum sum subarray. max_current = max_global = arr[0] for num in arr[1:]: max_current = max(num, max_current + num) if max_current > max_global: max_global = max_current return max_global"},{"question":"from typing import List def maxPower(crystals: List[int]) -> int: An alien spaceship is traveling through an asteroid belt and needs to collect power crystals to boost its shields. Each crystal has a unique power value associated with it. Given a list of integers representing the power values of the crystals, the goal is to identify the maximum sum of non-adjacent power values they can collect. They can choose as many crystals as they want, but no two chosen crystals can be adjacent in the list. >>> maxPower([3, 2, 5, 10, 7]) 15 >>> maxPower([3, 2, 7, 10]) 13","solution":"from typing import List def maxPower(crystals: List[int]) -> int: n = len(crystals) if n == 0: return 0 if n == 1: return max(0, crystals[0]) # Using two variables to keep track of maximum sums prev1 = max(0, crystals[0]) prev2 = max(prev1, max(0, crystals[1])) for i in range(2, n): current = max(prev1 + max(0, crystals[i]), prev2) prev1 = prev2 prev2 = current return prev2"},{"question":"from typing import List def find_longest_subsequence_length(lst: List[int]) -> int: Given a sequence of integers, find the length of the longest subsequence where all elements are the same. If the dataset is empty, return \\"NA\\". >>> find_longest_subsequence_length([1, 2, 2, 2, 3, 3, 1, 1]) == 3 >>> find_longest_subsequence_length([4, 4, 4, 4]) == 4 >>> find_longest_subsequence_length([]) == \\"NA\\" >>> find_longest_subsequence_length([3, 3, 3, 4, 5, 6, 7, 8, 9, 3, 3, 3]) == 3 def parse_input_and_find_lengths(input_str: str) -> List: Parse multiple datasets from the input string and finds the length of the longest subsequence for each. The integer zero is not part of the sequence. >>> parse_input_and_find_lengths(\\"1 2 2 2 3 3 1 1 0n4 4 4 4 0n0n3 3 3 4 5 6 7 8 9 3 3 3 0n\\") == [3, 4, \\"NA\\", 3]","solution":"def find_longest_subsequence_length(lst): if len(lst) == 0: return \\"NA\\" max_length = 0 current_length = 1 for i in range(1, len(lst)): if lst[i] == lst[i-1]: current_length += 1 else: if current_length > max_length: max_length = current_length current_length = 1 # Last subsequence check if current_length > max_length: max_length = current_length return max_length if max_length > 0 else \\"NA\\" def parse_input_and_find_lengths(input_str): lines = input_str.strip().split('n') results = [] for line in lines: elements = list(map(int, line.split())) if not elements or elements == [0]: results.append(\\"NA\\") else: results.append(find_longest_subsequence_length(elements[:-1])) return results"},{"question":"from typing import List, Tuple def num_distinct_values(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Returns the number of distinct integers that the multiset can be reduced to after operations. >>> num_distinct_values(3, [(3, [12, 15, 6]), (4, [7, 5, 3, 9]), (2, [10, 15])]) [1, 1, 1] >>> num_distinct_values(2, [(5, [2, 4, 6, 8, 10]), (3, [21, 14, 35])]) [1, 1]","solution":"from math import gcd from functools import reduce def num_distinct_values(t, test_cases): Returns the number of distinct integers that the multiset can be reduced to after operations. results = [] for n, elements in test_cases: overall_gcd = reduce(gcd, elements) results.append(len({overall_gcd})) return results"},{"question":"def minimum_cooling_activations(n: int, chambers: List[Tuple[int, int]]) -> int: Compute the minimum number of cooling activations required to bring all chambers to a temperature at or below their respective maximum temperatures. :param n: int - Number of reaction chambers :param chambers: List[Tuple[int, int]] - Initial temperature and max allowable temperature for each chamber :return: int - Minimum number of activations needed >>> minimum_cooling_activations(3, [(100, 95), (200, 190), (150, 120)]) 45 >>> minimum_cooling_activations(2, [(50, 50), (60, 10)]) 50","solution":"def minimum_cooling_activations(n, chambers): Compute the minimum number of cooling activations required to bring all chambers to a temperature at or below their respective maximum temperatures. :param n: int - Number of reaction chambers :param chambers: List[Tuple[int, int]] - Initial temperature and max allowable temperature for each chamber :return: int - Minimum number of activations needed total_activations = 0 for initial, max_temp in chambers: if initial > max_temp: # Calculate the number of activations required to bring temperature down to max_temp total_activations += initial - max_temp return total_activations"},{"question":"def can_transform(S: str, T: str) -> bool: Determine if it is possible to transform the initial string S into the target string T using any number of substring reversals. Input S: str : initial string consisting of lowercase English letters T: str : target string consisting of lowercase English letters Output bool: True if the transformation is possible, otherwise False Examples: >>> can_transform(\\"abac\\", \\"caba\\") True >>> can_transform(\\"aabb\\", \\"bbaa\\") True >>> can_transform(\\"abcd\\", \\"dcba\\") True >>> can_transform(\\"abc\\", \\"def\\") False","solution":"def can_transform(S, T): Determines if it's possible to transform string S into string T by reversing any number of substrings. return sorted(S) == sorted(T) def main(): import sys input = sys.stdin.read data = input().split() S = data[0] T = data[1] if can_transform(S, T): print(\\"YES\\") else: print(\\"NO\\")"},{"question":"def check_differences_same(arr: List[int]) -> str: Determines if the differences between consecutive elements are all the same. >>> check_differences_same([3, 7, 11]) \\"YES\\" >>> check_differences_same([1, 3, 7, 9]) \\"NO\\" from solution import check_differences_same def test_single_element(): assert check_differences_same([5]) == \\"YES\\" def test_two_elements_same_difference(): assert check_differences_same([5, 10]) == \\"YES\\" def test_multiple_elements_same_difference(): assert check_differences_same([3, 7, 11]) == \\"YES\\" def test_multiple_elements_different_difference(): assert check_differences_same([1, 3, 7, 9]) == \\"NO\\" def test_negative_numbers(): assert check_differences_same([-5, -10, -15, -20]) == \\"YES\\" def test_mixed_numbers(): assert check_differences_same([10, 5, 0, -5]) == \\"YES\\" def test_large_range(): assert check_differences_same(list(range(-1000000000, 1000000000, 100000000))) def test_edge_case_identical_numbers(): assert check_differences_same([1, 1, 1, 1]) == \\"YES\\" def test_edge_case_zero_difference(): assert check_differences_same([0, 0, 0, 0]) == \\"YES\\"","solution":"def check_differences_same(arr): Determines if the difference between consecutive elements in the array is the same. Returns: \\"YES\\" if differences are the same, otherwise \\"NO\\". if len(arr) <= 1: return \\"YES\\" difference = arr[1] - arr[0] for i in range(2, len(arr)): if arr[i] - arr[i-1] != difference: return \\"NO\\" return \\"YES\\""},{"question":"def generate_tiles_sequence(t: int, test_cases: List[Tuple[int, int]]) -> List[str]: Generates sequences of tiles for given test cases where no three consecutive tiles are the same and each number from 1 to n is used at least once. Parameters: t (int): The number of test cases. test_cases (List[Tuple[int, int]]): A list of tuples where each tuple contains two integers m (length of the sequence) and n (the highest number on the tiles). Returns: List[str]: A list of strings where each string represents a valid sequence of tiles for a test case. >>> generate_tiles_sequence(1, [(4, 2)]) [\\"1 2 1 2\\"] >>> generate_tiles_sequence(1, [(10, 3)]) [\\"1 2 3 1 2 3 1 2 3 1\\"] >>> generate_tiles_sequence(1, [(7, 2)]) [\\"1 2 1 2 1 2 1\\"]","solution":"def generate_tiles_sequence(t, test_cases): results = [] for m, n in test_cases: sequence = [] for i in range(m): sequence.append((i % n) + 1) results.append(\\" \\".join(map(str, sequence))) return results # For example purposes, to display the output for input: # t = 3 # test_cases = [(4, 2), (10, 3), (7, 2)] # result = generate_tiles_sequence(t, test_cases) # for seq in result: # print(seq)"},{"question":"from typing import List def diagonalDifference(matrix: List[List[int]]) -> int: Calculate the absolute difference between the sums of the matrix's two diagonals. Args: matrix (List[List[int]]): A square matrix of size n x n. Returns: int: The absolute difference between the sums of the matrix's two diagonals. Examples: >>> diagonalDifference([ ... [11, 2, 4], ... [4, 5, 6], ... [10, 8, -12] ... ]) == 15 >>> diagonalDifference([ ... [3, 2], ... [4, 6] ... ]) == 3 def test_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert diagonalDifference(matrix) == 0 def test_2x2_matrix(): matrix = [ [3, 2], [4, 6] ] assert diagonalDifference(matrix) == 3 def test_3x3_matrix_with_negatives(): matrix = [ [11, 2, 4], [4, 5, 6], [10, 8, -12] ] assert diagonalDifference(matrix) == 15 def test_1x1_matrix(): matrix = [ [5] ] assert diagonalDifference(matrix) == 0 def test_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] assert diagonalDifference(matrix) == 0","solution":"from typing import List def diagonalDifference(matrix: List[List[int]]) -> int: Given a square matrix, this function returns the absolute difference between the sums of its two diagonals. n = len(matrix) # size of the matrix primary_diagonal_sum = 0 secondary_diagonal_sum = 0 for i in range(n): primary_diagonal_sum += matrix[i][i] secondary_diagonal_sum += matrix[i][n - 1 - i] return abs(primary_diagonal_sum - secondary_diagonal_sum)"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Returns the maximum sum of a contiguous subarray using Kadane's algorithm. Parameters: nums (list of int): List of integers representing the input array. Returns: int: The maximum sum of a contiguous subarray. pass from solution import max_subarray_sum def test_example_case(): assert max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6 def test_single_element(): assert max_subarray_sum([5]) == 5 assert max_subarray_sum([-5]) == -5 def test_all_positive(): assert max_subarray_sum([1, 2, 3, 4, 5]) == 15 def test_all_negative(): assert max_subarray_sum([-1, -2, -3, -4]) == -1 def test_mixed_elements(): assert max_subarray_sum([4, -1, 2, 1]) == 6 assert max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 def test_large_array(): assert max_subarray_sum([1]*1000) == 1000 assert max_subarray_sum([-1]*999 + [100]) == 100","solution":"def max_subarray_sum(nums): Returns the maximum sum of a contiguous subarray using Kadane's algorithm. Parameters: nums (list of int): List of integers representing the input array. Returns: int: The maximum sum of a contiguous subarray. current_max = 0 global_max = float('-inf') for num in nums: current_max = max(num, current_max + num) if current_max > global_max: global_max = current_max return global_max"},{"question":"def count_balanced_teams(n: int, experience_levels: List[int]) -> int: Determine the number of balanced teams that can be formed. A balanced team consists of exactly two participants: one with an odd level of experience and one with an even level of experience. >>> count_balanced_teams(6, [3, 5, 6, 2, 9, 8]) 3 >>> count_balanced_teams(5, [1, 3, 5, 7, 9]) 0 from typing import List def test_example_1(): assert count_balanced_teams(6, [3, 5, 6, 2, 9, 8]) == 3 def test_example_2(): assert count_balanced_teams(5, [1, 3, 5, 7, 9]) == 0 def test_even_only(): assert count_balanced_teams(4, [2, 4, 6, 8]) == 0 def test_odd_only(): assert count_balanced_teams(4, [1, 3, 5, 7]) == 0 def test_mixed(): assert count_balanced_teams(7, [1, 2, 3, 4, 5, 6, 7]) == 3 def test_single_participant(): assert count_balanced_teams(1, [1]) == 0 assert count_balanced_teams(1, [2]) == 0 def test_all_even_large(): assert count_balanced_teams(1000, [2] * 1000) == 0 def test_all_odd_large(): assert count_balanced_teams(1000, [1] * 1000) == 0 def test_balanced_large(): assert count_balanced_teams(1000, [i % 2 for i in range(1000)]) == 500","solution":"def count_balanced_teams(n, experience_levels): odd_count = sum(1 for level in experience_levels if level % 2 != 0) even_count = n - odd_count return min(odd_count, even_count)"},{"question":"def query_distinct_elements(n, q, arr, queries): Processes multiple queries to count distinct elements in subarrays of \`arr\` that are greater than or equal to a specified value \`k\`. :param n: Number of elements in the array \`arr\` :param q: Number of queries :param arr: List of integers representing the array :param queries: List of tuples where each tuple contains three integers (l, r, k) :return: List of integers, each representing the answer to one query Example: >>> query_distinct_elements(6, 3, [5, 1, 2, 3, 4, 5], [(1, 6, 3), (2, 5, 2), (3, 3, 1)]) [3, 3, 1] >>> query_distinct_elements(5, 2, [2, 2, 2, 2, 2], [(1, 5, 1), (1, 5, 2)]) [1, 1]","solution":"def query_distinct_elements(n, q, arr, queries): Processes multiple queries to count distinct elements in subarrays of \`arr\` that are greater than or equal to a specified value \`k\`. :param n: Number of elements in the array \`arr\` :param q: Number of queries :param arr: List of integers representing the array :param queries: List of tuples where each tuple contains three integers (l, r, k) :return: List of integers, each representing the answer to one query results = [] for l, r, k in queries: subarray = arr[l-1:r] distinct_elements = {x for x in subarray if x >= k} results.append(len(distinct_elements)) return results"},{"question":"def generate_unique_ids(t, team_sizes): Generates unique IDs for participants in teams. Each ID consists of a team identifier followed by a unique number within that team. Parameters: t (int): Number of teams team_sizes (list of int): List containing the number of participants in each team. Returns: list of list of str: List containing lists of IDs for each team. pass def format_output(id_list): Formats the output as expected. Parameters: id_list (list of list of str): List containing lists of IDs for each team. Output: Prints the IDs as required. pass # Example usage: if __name__ == \\"__main__\\": t = 3 team_sizes = [2, 3, 1] ids = generate_unique_ids(t, team_sizes) format_output(ids) # Unit tests def test_generate_unique_ids(): assert generate_unique_ids(3, [2, 3, 1]) == [['A1', 'A2'], ['B1', 'B2', 'B3'], ['C1']] assert generate_unique_ids(1, [5]) == [['A1', 'A2', 'A3', 'A4', 'A5']] assert generate_unique_ids(2, [1, 1]) == [['A1'], ['B1']] assert generate_unique_ids(4, [1, 2, 3, 4]) == [['A1'], ['B1', 'B2'], ['C1', 'C2', 'C3'], ['D1', 'D2', 'D3', 'D4']] def test_format_output(capsys): ids = [['A1', 'A2'], ['B1', 'B2', 'B3'], ['C1']] format_output(ids) captured = capsys.readouterr() assert captured.out == 'A1 A2nB1 B2 B3nC1n' ids = [['A1']] format_output(ids) captured = capsys.readouterr() assert captured.out == 'A1n'","solution":"def generate_unique_ids(t, team_sizes): Generates unique IDs for participants in teams. Each ID consists of a team identifier followed by a unique number within that team. Parameters: t (int): Number of teams team_sizes (list of int): List containing the number of participants in each team. Returns: list of list of str: List containing lists of IDs for each team. id_list = [] for i in range(t): team_id = chr(65 + i) # Get corresponding letter from ASCII value (A=65, B=66, ...) team_ids = [f\\"{team_id}{num+1}\\" for num in range(team_sizes[i])] id_list.append(team_ids) return id_list def format_output(id_list): Formats the output as expected. Parameters: id_list (list of list of str): List containing lists of IDs for each team. Output: Prints the IDs as required. for team_ids in id_list: print(\\" \\".join(team_ids))"},{"question":"def sieve_of_eratosthenes(max_num: int) -> List[int]: Helper function that uses the Sieve of Eratosthenes to find all primes <= max_num def multiply_digits(num: int) -> int: Helper function that multiplies all digits of a number until a single digit is obtained def single_digit_prime_product(N: int) -> int: Function to find the single digit product of the product of all primes <= N def process_input(test_cases: List[int]) -> List[int]: Function to process multiple test cases and compute the single digit product for each","solution":"def sieve_of_eratosthenes(max_num): Helper function that uses the Sieve of Eratosthenes to find all primes <= max_num is_prime = [True] * (max_num + 1) p = 2 while (p * p <= max_num): if (is_prime[p] == True): for i in range(p * p, max_num + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, max_num + 1) if is_prime[p]] return prime_numbers def multiply_digits(num): Helper function that multiplies all digits of a number until a single digit is obtained product = 1 for digit in str(num): product *= int(digit) while product >= 10: product = multiply_digits(product) return product def single_digit_prime_product(N): Function to find the single digit product of the product of all primes <= N primes = sieve_of_eratosthenes(N) product = 1 for prime in primes: product *= prime return multiply_digits(product) def process_input(test_cases): results = [] for N in test_cases: results.append(single_digit_prime_product(N)) return results"},{"question":"def max_sum_subarray(arr: List[int]) -> Tuple[int, int]: Given an array of integers, find a contiguous subarray with the largest sum. If there are multiple subarrays with the same largest sum, find the one with the smallest length. If there's still a tie, return the earliest subarray (i.e., the one with the smallest starting index). >>> max_sum_subarray([1, -2, 3, 4, -1, 2, 1, -5, 4]) (2, 5) >>> max_sum_subarray([-2, -3, 4, -1, -2, 1, 5, -3]) (2, 5) >>> max_sum_subarray([1, -1, 1, -1, 1]) (0, 1)","solution":"from typing import List, Tuple def max_sum_subarray(arr: List[int]) -> Tuple[int, int]: n = len(arr) max_sum = -float('inf') current_sum = 0 start, end = 0, 0 best_start, best_len = 0, n + 1 for i in range(n): if current_sum <= 0: start = i current_sum = arr[i] else: current_sum += arr[i] if (current_sum > max_sum or (current_sum == max_sum and (i - start + 1 < best_len))): max_sum = current_sum best_start = start best_len = i - start + 1 return (best_start, best_len)"},{"question":"def generate_sequence(n): Generates the first n numbers of the sequence based on the given rules. >>> generate_sequence(1) == [1] True >>> generate_sequence(2) == [1, 2] True >>> generate_sequence(5) == [1, 2, 3, 1, 4] True >>> generate_sequence(10) == [1, 2, 3, 1, 4, 3, 7, 4, 11, 7] True","solution":"def generate_sequence(n): Generates the first n numbers of the sequence based on the given rules. if n == 0: return [] sequence = [1, 2] for i in range(2, n): if (i + 1) % 2 != 0: # Odd position new_value = sequence[-1] + sequence[-2] else: # Even position new_value = abs(sequence[-1] - sequence[-2]) sequence.append(new_value) return sequence[:n]"},{"question":"def remove_duplicate_phrases(phrases: List[str]) -> List[str]: Returns a list of unique phrases, preserving the order of their first appearance. Args: phrases (List[str]): A list of phrases. Returns: List[str]: A list of unique phrases. >>> remove_duplicate_phrases([ \\"The quick brown fox\\", \\"jumps over the lazy dog\\", \\"The quick brown fox\\", \\"Lorem ipsum dolor sit\\", \\"amet consectetur\\", \\"Lorem ipsum dolor sit\\" ]) [\\"The quick brown fox\\", \\"jumps over the lazy dog\\", \\"Lorem ipsum dolor sit\\", \\"amet consectetur\\"] >>> remove_duplicate_phrases([ \\"Phrase one\\", \\"Phrase two\\", \\"Phrase three\\" ]) [\\"Phrase one\\", \\"Phrase two\\", \\"Phrase three\\"]","solution":"def remove_duplicate_phrases(phrases): Returns a list of unique phrases, preserving the order of their first appearance. seen = set() unique_phrases = [] for phrase in phrases: if phrase not in seen: unique_phrases.append(phrase) seen.add(phrase) return unique_phrases"},{"question":"def max_drivers_available(n: int, intervals: List[Tuple[int, int]]) -> int: Returns the maximum number of drivers available at the same time. :param n: int - the number of drivers :param intervals: list of tuples - each tuple containing start and end time in minutes :return: int - maximum number of drivers available at the same time >>> max_drivers_available(1, [(0, 1440)]) 1 >>> max_drivers_available(3, [(0, 500), (600, 1000), (1100, 1400)]) 1 >>> max_drivers_available(3, [(0, 1440), (0, 1440), (0, 1440)]) 3 >>> max_drivers_available(4, [(0, 500), (200, 700), (400, 900), (600, 1000)]) 3 >>> max_drivers_available(5, [(540, 600), (560, 620), (600, 720), (610, 670), (700, 800)]) 3 >>> max_drivers_available(2, [(0, 1), (1, 2)]) 1 >>> max_drivers_available(3, [(0, 500), (500, 1000), (1000, 1440)]) 1","solution":"def max_drivers_available(n, intervals): Returns the maximum number of drivers available at the same time. :param n: int - the number of drivers :param intervals: list of tuples - each tuple containing start and end time in minutes :return: int - maximum number of drivers available at the same time events = [] # Split intervals into start and end events for start, end in intervals: events.append((start, 1)) # Start of a driver's availability events.append((end, -1)) # End of a driver's availability # Sort events first by time, and then by type of event (start -> end) events.sort() max_drivers = 0 current_drivers = 0 # Sweep line to find the maximum number of drivers at any point in time for time, event in events: current_drivers += event max_drivers = max(max_drivers, current_drivers) return max_drivers"},{"question":"def process_integers(n: int, integers: List[int]) -> None: Given a list of integers, prints the maximum integer if the sum of the integers is even, otherwise prints the minimum integer. Args: n (int): The number of integers in the list. integers (list of int): The list of integers. Examples: >>> process_integers(3, [1, -5, 8]) 8 >>> process_integers(4, [2, 4, 6, 8]) 8","solution":"def process_integers(n, integers): Given a list of integers, prints the maximum integer if the sum of the integers is even, otherwise prints the minimum integer. Args: n (int): The number of integers in the list. integers (list of int): The list of integers. total_sum = sum(integers) if total_sum % 2 == 0: print(max(integers)) else: print(min(integers))"},{"question":"import math from typing import List, Tuple def find_closest_points(points: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Given a list of points, finds and returns the points closest to the origin (0, 0). Parameters: points (list): A list of tuples where each tuple contains two integers representing x and y coordinates of a point. Returns: list: A list of tuples representing the points closest to the origin. Examples: >>> find_closest_points([(1, 2), (3, 4), (-1, -1)]) [(-1, -1)] >>> find_closest_points([(1, 1), (2, 2), (1, -1), (-1, 1)]) [(1, 1), (1, -1), (-1, 1)] pass # Unit tests def test_single_point(): points = [(3, 4)] assert find_closest_points(points) == [(3, 4)] def test_multiple_points_with_one_closest(): points = [(1, 2), (3, 4), (-1, -1)] assert find_closest_points(points) == [(-1, -1)] def test_multiple_closest_points(): points = [(1, 1), (2, 2), (1, -1), (-1, 1)] closest_points = find_closest_points(points) expected_points = [(1, 1), (1, -1), (-1, 1)] assert set(closest_points) == set(expected_points) def test_all_points_are_zero(): points = [(0, 0), (0, 0), (0, 0)] assert find_closest_points(points) == [(0, 0), (0, 0), (0, 0)] def test_negative_coordinates(): points = [(-3, -3), (-1, -1), (-2, -2), (1, 1)] assert find_closest_points(points) == [(-1, -1), (1, 1)] def test_mixed_coordinates(): points = [(1, -1), (-1, 1), (-1, -1), (1, 1)] closest_points = find_closest_points(points) expected_points = [(1, -1), (-1, 1), (-1, -1), (1, 1)] assert set(closest_points) == set(expected_points)","solution":"import math def find_closest_points(points): Given a list of points, finds and returns the points closest to the origin (0, 0). Parameters: points (list): A list of tuples where each tuple contains two integers representing x and y coordinates of a point. Returns: list: A list of tuples representing the points closest to the origin. # Function to compute the squared distance from the origin def squared_distance_from_origin(point): return point[0] ** 2 + point[1] ** 2 # Compute the squared distances of all points from the origin distances = [(squared_distance_from_origin(point), point) for point in points] # Find the minimum squared distance min_distance = min(distances, key=lambda x: x[0])[0] # Collect all points with the minimum squared distance closest_points = [point for distance, point in distances if distance == min_distance] return closest_points # Example usage points = [(1, 2), (3, 4), (-1, -1)] closest_points = find_closest_points(points) output = \\" \\".join(f\\"({x}, {y})\\" for x, y in closest_points) print(output)"},{"question":"from typing import List, Tuple def range_update(n: int, q: int, arr: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Perform a series of q range update operations on a list of n integers. Parameters: n (int): The size of the list. q (int): The number of update operations. arr (List[int]): The initial elements of the list. operations (List[Tuple[int, int, int]]): A list of operations where each operation is represented by a tuple (l, r, v). Returns: List[int]: The updated list after performing all the operations. Examples: >>> range_update(5, 3, [1, 2, 3, 4, 5], [(1, 3, 2), (2, 4, -1), (3, 5, 3)]) [3, 3, 7, 6, 8] >>> range_update(6, 2, [0, 0, 0, 0, 0, 0], [(1, 6, 1), (2, 5, 2)]) [1, 3, 3, 3, 3, 1]","solution":"def range_update(n, q, arr, operations): for op in operations: l, r, v = op for i in range(l - 1, r): arr[i] += v return arr"},{"question":"def find_min_trees_to_cut(n: int, heights: List[int]) -> int: Determine the minimum number of trees the lumberjack has to chop down to achieve a strictly increasing path of tree heights from start to end of the forest. Args: n (int): the number of trees in the forest. heights (List[int]): list containing the heights of the trees in the order they appear in the forest. Returns: int: the minimum number of trees that need to be chopped down to create a strictly increasing sequence. Examples: >>> find_min_trees_to_cut(7, [4, 2, 3, 6, 5, 1, 7]) 3 >>> find_min_trees_to_cut(5, [1, 2, 3, 4, 5]) 0 >>> find_min_trees_to_cut(6, [6, 5, 4, 3, 2, 1]) 5 >>> find_min_trees_to_cut(1, [1]) 0 >>> find_min_trees_to_cut(4, [7, 7, 7, 7]) 3","solution":"def find_min_trees_to_cut(n, heights): from bisect import bisect_left if n == 0: return 0 # 'lis' keeps our longest increasing subsequence lis = [] for height in heights: pos = bisect_left(lis, height) # If pos is at the end of lis, expand it if pos == len(lis): lis.append(height) # Otherwise replace the existing element else: lis[pos] = height # The minimum trees to cut is the difference between total trees and the length of LIS return n - len(lis)"},{"question":"def process_operations(n: int, m: int, array: List[int], operations: List[Tuple[int, int, int]]) -> List[int]: Process a sequence of operations on an array and calculate the result of specific queries. >>> process_operations(5, 3, [1, 2, 3, 4, 5], [(2, 1, 3), (1, 3, 10), (2, 1, 3)]) [6, 13] >>> process_operations(5, 3, [1, 2, 3, 4, 5], [(1, 1, 10), (1, 2, 20), (1, 3, 30)]) []","solution":"def process_operations(n, m, array, operations): results = [] for op in operations: if op[0] == 1: # Update operation array[op[1] - 1] = op[2] elif op[0] == 2: # Range Sum Query l, r = op[1], op[2] results.append(sum(array[l-1:r])) return results"},{"question":"from typing import List, Tuple def process_tree_cost(n: int, k: int, values: List[int], edges: List[Tuple[int, int]]) -> int: Calculate the minimum cost required to make the leaf nodes have at least value k. Args: n (int): Number of nodes in the tree. k (int): Minimum required value for leaf nodes. values (List[int]): Initial values of each node. edges (List[Tuple[int, int]]): List of edges connecting the nodes. Returns: int: Minimum cost to achieve the required leaf node values. Example: >>> process_tree_cost(5, 5, [1, 2, 3, 4, 5], [(1, 2), (1, 3), (3, 4), (3, 5)]) 5 >>> process_tree_cost(4, 2, [2, 2, 2, 2], [(1, 2), (1, 3), (1, 4)]) 0 def test_example_case(): n, k = 5, 5 values = [1, 2, 3, 4, 5] edges = [(1, 2), (1, 3), (3, 4), (3, 5)] assert process_tree_cost(n, k, values, edges) == 5 def test_all_leaves_have_enough_value(): n, k = 4, 2 values = [2, 2, 2, 2] edges = [(1, 2), (1, 3), (1, 4)] assert process_tree_cost(n, k, values, edges) == 0 def test_leaves_need_to_be_increased(): n, k = 3, 3 values = [1, 1, 1] edges = [(1, 2), (1, 3)] assert process_tree_cost(n, k, values, edges) == 4 def test_complex_tree_structure(): n, k = 6, 5 values = [1, 2, 3, 1, 1, 2] edges = [(1, 2), (1, 3), (3, 4), (3, 5), (3, 6)] assert process_tree_cost(n, k, values, edges) == 13 def test_single_level_tree(): n, k = 4, 3 values = [1, 1, 1, 1] edges = [(1, 2), (1, 3), (1, 4)] assert process_tree_cost(n, k, values, edges) == 6","solution":"def min_cost_to_leaf_values(n, k, values, edges): from collections import defaultdict, deque tree = defaultdict(list) for u, v in edges: tree[u].append(v) tree[v].append(u) degrees = {i: len(adj) for i, adj in tree.items()} leaf_nodes = [i for i, d in degrees.items() if d == 1] current_values = dict(enumerate(values, 1)) total_cost = 0 visited = [False] * (n + 1) for leaf in leaf_nodes: queue = deque([leaf]) while queue: node = queue.popleft() if visited[node]: continue visited[node] = True needed_increases = max(0, k - current_values[node]) total_cost += needed_increases for neighbor in tree[node]: current_values[neighbor] += needed_increases if not visited[neighbor]: queue.append(neighbor) return total_cost # Helper function for the ease of test def process_tree_cost(n, k, values, edges): return min_cost_to_leaf_values(n, k, values, edges)"},{"question":"class RangeSumQuery: def __init__(self, array): # Initialize the data structure with the given array and build the prefix sum array. pass def _build_prefix_sum(self, array): # Construct the prefix sum array for quick range sum calculation. pass def update(self, pos, x): # Update the value at the given position and adjust the prefix sum array. pass def query(self, l, r): # Return the range sum for the subarray from index l to index r. pass def process_commands(n, array, commands): Process a series of update and range sum queries on an array. Args: n (int): The length of the array. array (List[int]): The initial array. commands (List[str]): The list of commands where each command is either an update or a range sum query. Returns: List[int]: The results of the range sum queries. Example: >>> n = 5 >>> array = [1, 2, 3, 4, 5] >>> commands = [\\"2 1 3\\", \\"1 3 10\\", \\"2 2 5\\", \\"1 5 1\\", \\"2 1 5\\"] >>> process_commands(n, array, commands) [6, 21, 18] >>> n = 3 >>> array = [1, 1, 1] >>> commands = [\\"1 1 2\\", \\"1 2 3\\", \\"1 3 4\\"] >>> process_commands(n, array, commands) [] >>> n = 4 >>> array = [1, 2, 3, 4] >>> commands = [\\"2 1 4\\", \\"2 1 2\\", \\"2 3 4\\"] >>> process_commands(n, array, commands) [10, 3, 7] >>> n = 4 >>> array = [1, 2, 3, 4] >>> commands = [\\"2 2 3\\", \\"1 2 10\\", \\"2 1 4\\"] >>> process_commands(n, array, commands) [5, 18] >>> n = 1 >>> array = [5] >>> commands = [\\"2 1 1\\", \\"1 1 10\\", \\"2 1 1\\"] >>> process_commands(n, array, commands) [5, 10] pass","solution":"class RangeSumQuery: def __init__(self, array): self.n = len(array) self.array = array self.prefix_sum = self._build_prefix_sum(array) def _build_prefix_sum(self, array): prefix_sum = [0] * (self.n + 1) for i in range(1, self.n + 1): prefix_sum[i] = prefix_sum[i - 1] + array[i - 1] return prefix_sum def update(self, pos, x): diff = x - self.array[pos - 1] self.array[pos - 1] = x for i in range(pos, self.n + 1): self.prefix_sum[i] += diff def query(self, l, r): return self.prefix_sum[r] - self.prefix_sum[l - 1] def process_commands(n, array, commands): rsq = RangeSumQuery(array) results = [] for command in commands: parts = command.split() if parts[0] == '1': pos, x = int(parts[1]), int(parts[2]) rsq.update(pos, x) elif parts[0] == '2': l, r = int(parts[1]), int(parts[2]) results.append(rsq.query(l, r)) return results"},{"question":"def simulate_automaton(transitions, input_string): Simulates the behavior of a simplified automaton processing a string based on a set of transition rules. >>> simulate_automaton([ ... ('start', 'a', 'x', 'state1'), ... ('state1', 'b', None, 'end'), ... ('start', 'b', 'y', 'state2'), ... ('state2', 'a', None, 'end') ... ], 'ab') ('x', 'end') >>> simulate_automaton([ ... ('start', 'a', 'z', 'state1'), ... ('state1', 'a', None, 'state1'), ... ('state1', 'b', None, 'end') ... ], 'aab') ('z', 'end')","solution":"def simulate_automaton(transitions, input_string): state = 'start' output = [] # Convert the transitions into a dictionary for quick look-up transition_dict = {} for current_state, char, print_char, next_state in transitions: if current_state not in transition_dict: transition_dict[current_state] = {} transition_dict[current_state][char] = (print_char, next_state) # Process the input string character by character for char in input_string: if state in transition_dict and char in transition_dict[state]: print_char, next_state = transition_dict[state][char] if print_char: output.append(print_char) state = next_state else: break return ''.join(output), state"},{"question":"def max_sublist_sum(n: int, arr: List[int]) -> Tuple[int, int, int]: Identify the sublist whose sum of elements is the maximum possible. The function returns a tuple containing the maximum possible sum, and the starting and ending indices (1-based) of the sublist. >>> max_sublist_sum(5, [1, -2, 3, 10, -4]) (13, 3, 4) >>> max_sublist_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) (7, 3, 7) :param n: int - The number of elements in the list. :param arr: list of int - The elements of the list. :return: tuple - The maximum sum and the 1-based starting and ending indices. import pytest def test_example_one(): assert max_sublist_sum(5, [1, -2, 3, 10, -4]) == (13, 3, 4) def test_example_two(): assert max_sublist_sum(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == (7, 3, 7) def test_single_element(): assert max_sublist_sum(1, [10]) == (10, 1, 1) def test_all_negative_elements(): assert max_sublist_sum(3, [-1, -2, -3]) == (-1, 1, 1) def test_mixed_elements(): assert max_sublist_sum(6, [2, -1, 2, 3, 4, -5]) == (10, 1, 5) def test_another_case(): assert max_sublist_sum(6, [-1, 2, -1, 2, 2, -1]) == (5, 2, 5)","solution":"def max_sublist_sum(n, arr): Returns the maximum sublist sum and the 1-based starting and ending indices of that sublist. :param n: int - The number of elements in the list. :param arr: list - The list of integers. :return: tuple - The maximum sum and the 1-based starting and ending indices. max_so_far = -float('inf') max_ending_here = 0 start = end = s = 0 for i in range(n): max_ending_here += arr[i] if max_so_far < max_ending_here: max_so_far = max_ending_here start = s end = i if max_ending_here < 0: max_ending_here = 0 s = i + 1 # Return the max sum and the 1-based indices return max_so_far, start + 1, end + 1"},{"question":"import itertools from typing import List def generate_permutations(n: int) -> List[str]: Generates and returns all permutations of integers from 1 to n in lexicographic order. >>> generate_permutations(3) [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\"] >>> generate_permutations(2) [\\"1 2\\", \\"2 1\\"] >>> generate_permutations(1) [\\"1\\"] >>> generate_permutations(0) [] def handle_inputs(inputs: List[int]) -> List[List[str]]: Handles multiple inputs and generates permutations for each input. >>> handle_inputs([3, 2, 0]) [ [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"2 3 1\\", \\"3 1 2\\", \\"3 2 1\\"], [\\"1 2\\", \\"2 1\\"] ]","solution":"import itertools def generate_permutations(n): Generates and returns all permutations of integers from 1 to n in lexicographic order. if n == 0: return [] permutations = itertools.permutations(range(1, n + 1)) result = [\\" \\".join(map(str, perm)) for perm in permutations] return result def handle_inputs(inputs): result = [] for n in inputs: if n == 0: break result.append(generate_permutations(n)) return result"},{"question":"def find_shortest_hamiltonian_cycle(nc: int, roads: List[Tuple[int, int, int]]) -> int: Given the number of castles and the list of roads with distances, find the shortest cyclic path that visits every castle exactly once and returns to the starting point. Parameters: nc (int): Number of castles roads (List[Tuple[int, int, int]]): List of tuples where each tuple contains two castles and the distance between them Returns: int: Length of the shortest Hamiltonian cycle >>> find_shortest_hamiltonian_cycle(3, [(1, 2, 5), (2, 3, 7), (1, 3, 9)]) 21 >>> find_shortest_hamiltonian_cycle(4, [(1, 2, 2), (1, 3, 4), (1, 4, 1), (2, 3, 5), (2, 4, 8), (3, 4, 2)]) 10 pass def process_input(data: List[str]) -> List[int]: Process the input data to extract and compute the shortest Hamiltonian cycles for multiple datasets. Parameters: data (List[str]): List of input lines containing multiple datasets Returns: List[int]: List of results for each dataset >>> data = [ ... \\"3 3\\", ... \\"1 2 5\\", ... \\"2 3 7\\", ... \\"1 3 9\\", ... \\"\\", ... \\"4 6\\", ... \\"1 2 2\\", ... \\"1 3 4\\", ... \\"1 4 1\\", ... \\"2 3 5\\", ... \\"2 4 8\\", ... \\"3 4 2\\", ... \\"\\", ... \\"0 0\\" ... ] >>> process_input(data) [21, 10] pass def test_process_input(): input_data = [ \\"3 3\\", \\"1 2 5\\", \\"2 3 7\\", \\"1 3 9\\", \\"\\", \\"4 6\\", \\"1 2 2\\", \\"1 3 4\\", \\"1 4 1\\", \\"2 3 5\\", \\"2 4 8\\", \\"3 4 2\\", \\"\\", \\"0 0\\" ] expected_output = [21, 10] assert process_input(input_data) == expected_output def test_case_1(): nc = 3 roads = [(1, 2, 5), (2, 3, 7), (1, 3, 9)] assert find_shortest_hamiltonian_cycle(nc, roads) == 21 def test_case_2(): nc = 4 roads = [(1, 2, 2), (1, 3, 4), (1, 4, 1), (2, 3, 5), (2, 4, 8), (3, 4, 2)] assert find_shortest_hamiltonian_cycle(nc, roads) == 10 def test_case_large(): nc = 4 roads = [(1, 2, 10), (2, 3, 10), (3, 4, 10), (1, 3, 10), (1, 4, 10), (2, 4, 10)] assert find_shortest_hamiltonian_cycle(nc, roads) == 40","solution":"from itertools import permutations def find_shortest_hamiltonian_cycle(nc, roads): # Create graph representation graph = [[float('inf')] * nc for _ in range(nc)] for a, b, d in roads: graph[a-1][b-1] = d graph[b-1][a-1] = d # Initialize the result with a large value min_cycle_length = float('inf') # Try all permutations of vertices to find the shortest Hamiltonian cycle for perm in permutations(range(1, nc)): # Start from node 0 current_length = graph[0][perm[0]] for i in range(nc - 2): current_length += graph[perm[i]][perm[i+1]] current_length += graph[perm[-1]][0] min_cycle_length = min(min_cycle_length, current_length) return min_cycle_length def process_input(data): index = 0 results = [] while index < len(data): line = data[index].strip() index += 1 if line == '0 0': break if line == '': continue nc, ml = map(int, line.split()) roads = [] for _ in range(ml): a, b, d = map(int, data[index].strip().split()) roads.append((a, b, d)) index += 1 results.append(find_shortest_hamiltonian_cycle(nc, roads)) return results"},{"question":"def trap_rain_water(heights: List[int]) -> int: Calculate the total amount of trapped rain water given the heights of buildings. :param heights: List of integers representing the height of buildings. :return: Integer representing the total trapped water. >>> trap_rain_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) 6 >>> trap_rain_water([]) 0 >>> trap_rain_water([4]) 0 >>> trap_rain_water([1, 1, 1, 1]) 0 >>> trap_rain_water([3, 0, 3]) 3 >>> trap_rain_water([2, 0, 2, 0, 2]) 4 >>> trap_rain_water([3, 2, 1, 0]) 0 >>> trap_rain_water([0, 1, 2, 3]) 0 >>> trap_rain_water([0, 8, 0, 8, 0, 8]) 16","solution":"def trap_rain_water(heights): Calculate the total amount of trapped rain water given the heights of buildings. :param heights: List of integers representing the height of buildings. :return: Integer representing the total trapped water. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def group_participants(participants, k): Groups participants into k groups as evenly as possible. :param participants: List of participants :param k: Number of groups :return: List of k groups, each group being a list of participants # Initialize list of lists for the groups groups = [[] for _ in range(k)] # Distribute participants to groups in round-robin manner for i, participant in enumerate(participants): groups[i % k].append(participant) return groups # Unit tests def test_group_even_distribution(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\"] k = 2 result = group_participants(participants, k) expected = [[\\"Alice\\", \\"Charlie\\", \\"Eve\\"], [\\"Bob\\", \\"David\\"]] assert result == expected def test_group_single_participant_each(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] k = 3 result = group_participants(participants, k) expected = [[\\"Alice\\"], [\\"Bob\\"], [\\"Charlie\\"]] assert result == expected def test_group_more_groups_than_participants(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\"] k = 4 result = group_participants(participants, k) expected = [[\\"Alice\\"], [\\"Bob\\"], [\\"Charlie\\"], []] assert result == expected def test_group_all_same_size(): participants = [\\"Alice\\", \\"Bob\\", \\"Charlie\\", \\"David\\", \\"Eve\\", \\"Frank\\"] k = 3 result = group_participants(participants, k) expected = [[\\"Alice\\", \\"David\\"], [\\"Bob\\", \\"Eve\\"], [\\"Charlie\\", \\"Frank\\"]] assert result == expected def test_group_empty_list(): participants = [] k = 3 result = group_participants(participants, k) expected = [[], [], []] assert result == expected","solution":"def group_participants(participants, k): Groups participants into k groups as evenly as possible. :param participants: List of participants :param k: Number of groups :return: List of k groups, each group being a list of participants # Initialize list of lists for the groups groups = [[] for _ in range(k)] # Distribute participants to groups in round-robin manner for i, participant in enumerate(participants): groups[i % k].append(participant) return groups"},{"question":"def longest_balanced_substring(s: str) -> int: Find the length of the longest balanced substring that contains an equal number of 'a's and 'b's in the input string s. >>> longest_balanced_substring('aababb') 6 >>> longest_balanced_substring('abababaaa') 6 >>> longest_balanced_substring('aaabbb') 6 >>> longest_balanced_substring('abab') 4 >>> longest_balanced_substring('aaaa') 0 >>> longest_balanced_substring('bbaa') 4 >>> longest_balanced_substring('aabbab') 6 >>> longest_balanced_substring('') 0 pass def process_test_cases(t: int, test_cases: List[str]) -> List[int]: Process multiple test cases for longest balanced substring. >>> process_test_cases(3, ['aababb', 'abababaaa', 'aaabbb']) [6, 6, 6] >>> process_test_cases(2, ['aaaa', 'ababab']) [0, 6] >>> process_test_cases(1, ['']) [0] pass","solution":"def longest_balanced_substring(s): Function to find the length of the longest balanced substring. max_length = 0 # Dictionary to store the first occurrence of a balance factor balance_index = {0: -1} # Initialize balance factor (net number of a's minus number of b's) balance = 0 for i, char in enumerate(s): if char == 'a': balance += 1 else: balance -= 1 if balance in balance_index: max_length = max(max_length, i - balance_index[balance]) else: balance_index[balance] = i return max_length def process_test_cases(t, test_cases): results = [] for i in range(t): results.append(longest_balanced_substring(test_cases[i])) return results"},{"question":"def calculate_max_scores(t: int, test_cases: List[Tuple[Tuple[int, int], List[Tuple[int, int]]]]) -> List[int]: Calculate the maximum total score a participant can achieve given a list of problems and their difficulty levels, scores, and the participant's skill level. :param t: Number of test cases :param test_cases: List of tuples, where each tuple contains: - A tuple with two integers representing the number of problems and the participant's skill level - A list of tuples where each tuple has two integers representing the problem's difficulty level and score :return: List of integers, each representing the maximum total score a participant can achieve for each test case >>> calculate_max_scores(2, [((3, 10), [(5, 80), (10, 100), (3, 50)]), ((4, 5), [(10, 100), (5, 50), (20, 30)])]) [230, 50] >>> calculate_max_scores(1, [((0, 10), [])]) [0] >>> calculate_max_scores(1, [((3, 1), [(5, 80), (10, 100), (3, 50)])]) [0] >>> calculate_max_scores(1, [((3, 100), [(5, 80), (10, 100), (3, 50)])]) [230] >>> calculate_max_scores(2, [((3, 10), [(5, 80), (10, 100), (3, 50)]), ((3, 5), [(1, 10), (5, 50), (3, 30)])]) [230, 90] # Your implementation here","solution":"def max_total_score(test_cases): results = [] for test_case in test_cases: n, l = test_case[0] problems = test_case[1] total_score = 0 for (d, s) in problems: if l >= d: total_score += s results.append(total_score) return results # Function to parse input and call the main function def calculate_max_scores(t, test_cases): return max_total_score(test_cases)"},{"question":"def get_region_sizes(grid): Given a square grid of size N*N filled with characters, returns the sizes of all distinct regions formed by contiguous characters. >>> get_region_sizes([['A', 'B', 'B'], ['B', 'B', 'A'], ['A', 'A', 'A']]) [1, 4, 4] >>> get_region_sizes([['A', 'A'], ['A', 'A']]) [4] >>> get_region_sizes([['A', 'B'], ['C', 'D']]) [1, 1, 1, 1] >>> get_region_sizes([['A', 'A', 'B', 'B'], ['A', 'A', 'B', 'B'], ['C', 'C', 'D', 'D'], ['C', 'C', 'D', 'D']]) [4, 4, 4, 4] >>> get_region_sizes([['A']]) [1] def parse_input_and_compute(s): Parses the input string to extract the grid and computes the sizes of all distinct regions. >>> s = \\"3nA B BnB B AnA A A\\" >>> parse_input_and_compute(s) \\"1 4 4\\" >>> s = \\"2nA AnA A\\" >>> parse_input_and_compute(s) \\"4\\" >>> s = \\"2nA BnC D\\" >>> parse_input_and_compute(s) \\"1 1 1 1\\" >>> s = \\"4nA A B BnA A B BnC C D DnC C D D\\" >>> parse_input_and_compute(s) \\"4 4 4 4\\" >>> s = \\"1nA\\" >>> parse_input_and_compute(s) \\"1\\"","solution":"def get_region_sizes(grid): Given a square grid of size N*N filled with characters, returns the sizes of all distinct regions formed by contiguous characters. n = len(grid) visited = [[False] * n for _ in range(n)] directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def dfs(x, y): stack = [(x, y)] count = 0 while stack: cx, cy = stack.pop() if not (0 <= cx < n and 0 <= cy < n) or visited[cx][cy]: continue visited[cx][cy] = True count += 1 for dx, dy in directions: nx, ny = cx + dx, cy + dy if 0 <= nx < n and 0 <= ny < n and not visited[nx][ny] and grid[nx][ny] == grid[cx][cy]: stack.append((nx, ny)) return count region_sizes = [] for i in range(n): for j in range(n): if not visited[i][j]: region_size = dfs(i, j) region_sizes.append(region_size) return sorted(region_sizes) def parse_input_and_compute(s): Parses the input string to extract the grid and computes the sizes of all distinct regions. lines = s.strip().split('n') n = int(lines[0]) grid = [lines[i + 1].split() for i in range(n)] region_sizes = get_region_sizes(grid) return ' '.join(map(str, region_sizes))"},{"question":"def max_subsequence_indices(n: int, arr: List[int]) -> Tuple[int, int]: Given a list of integers, find a contiguous subsequence with the maximum possible sum. If there are multiple such subsequences, return the one which has the smallest starting index. If there is still a tie, return the one which has the smallest ending index. >>> max_subsequence_indices(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) (4, 7) >>> max_subsequence_indices(5, [1, 2, 3, -2, 5]) (1, 5) >>> max_subsequence_indices(6, [-1, -2, -3, -4, -5, -6]) (1, 1) from typing import List, Tuple # Test cases def test_example1(): assert max_subsequence_indices(8, [-2, 1, -3, 4, -1, 2, 1, -5, 4]) == (4, 7) def test_example2(): assert max_subsequence_indices(5, [1, 2, 3, -2, 5]) == (1, 5) def test_example3(): assert max_subsequence_indices(6, [-1, -2, -3, -4, -5, -6]) == (1, 1) def test_all_negative_same(): assert max_subsequence_indices(4, [-1, -1, -1, -1]) == (1, 1) def test_all_positive(): assert max_subsequence_indices(4, [1, 2, 3, 4]) == (1, 4) def test_mixed_numbers(): assert max_subsequence_indices(7, [1, -2, 3, 5, -3, 2, 2]) == (3, 7) def test_starting_negative(): assert max_subsequence_indices(5, [-5, 4, 2, -1, 3]) == (2, 5) def test_large_input(): assert max_subsequence_indices(10, [10**9, -10**9, 10**9, -10**9, 10**9, -10**9, 10**9, -10**9, 10**9, -10**9]) == (1, 1)","solution":"def max_subsequence_indices(n, arr): max_sum = -float('inf') current_sum = 0 start = end = temp_start = 0 for i in range(n): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = temp_start end = i elif current_sum == max_sum: if i - temp_start < end - start: start = temp_start end = i if current_sum < 0: current_sum = 0 temp_start = i + 1 return start + 1, end + 1"},{"question":"class WorkoutStreaks: This class manages the workout streaks for users in Fastville. It supports setting, adding, resetting streaks, and retrieving maximum and total streaks. >>> ws = WorkoutStreaks(5) >>> ws.set_streak(1, 10) >>> ws.add_days(2, 5) >>> print(ws.max_streak()) # Output: 10 >>> print(ws.total_streak()) # Output: 15 def __init__(self, n: int): Initialize the WorkoutStreaks class with n users. pass def set_streak(self, i: int, k: int): Sets the current workout streak of user i to k days. pass def add_days(self, i: int, d: int): Adds d days to the current workout streak of user i. pass def reset_streak(self, i: int): Resets the workout streak of user i to 0. pass def max_streak(self) -> int: Returns the maximum streak among all users. pass def total_streak(self) -> int: Returns the sum of all users' workout streaks. pass import pytest def test_workout_streaks_operations(): ws = WorkoutStreaks(5) ws.set_streak(1, 10) assert ws.max_streak() == 10 assert ws.total_streak() == 10 ws.add_days(2, 5) assert ws.max_streak() == 10 assert ws.total_streak() == 15 ws.add_days(1, 5) assert ws.max_streak() == 15 assert ws.total_streak() == 20 ws.reset_streak(1) assert ws.max_streak() == 5 assert ws.total_streak() == 5 def test_reset_multiple_streaks(): ws = WorkoutStreaks(3) ws.set_streak(1, 10) ws.set_streak(2, 5) ws.set_streak(3, 7) assert ws.max_streak() == 10 assert ws.total_streak() == 22 ws.reset_streak(1) assert ws.max_streak() == 7 assert ws.total_streak() == 12 ws.reset_streak(3) assert ws.max_streak() == 5 assert ws.total_streak() == 5 ws.reset_streak(2) assert ws.max_streak() == 0 assert ws.total_streak() == 0 def test_add_days_no_existing_streak(): ws = WorkoutStreaks(2) ws.add_days(1, 6) assert ws.max_streak() == 6 assert ws.total_streak() == 6 ws.add_days(1, 4) assert ws.max_streak() == 10 assert ws.total_streak() == 10 ws.reset_streak(1) assert ws.max_streak() == 0 assert ws.total_streak() == 0","solution":"class WorkoutStreaks: def __init__(self, n): self.streaks = [0] * (n + 1) self.max_streak_value = 0 self.total_streak_value = 0 def set_streak(self, i, k): self.total_streak_value -= self.streaks[i] self.total_streak_value += k self.streaks[i] = k self.max_streak_value = max(self.streaks) def add_days(self, i, d): self.streaks[i] += d self.total_streak_value += d if self.streaks[i] > self.max_streak_value: self.max_streak_value = self.streaks[i] def reset_streak(self, i): self.total_streak_value -= self.streaks[i] self.streaks[i] = 0 self.max_streak_value = max(self.streaks) def max_streak(self): return self.max_streak_value def total_streak(self): return self.total_streak_value"},{"question":"def find_next_departure(current_time: str, departure_times: List[str]) -> str: Finds the next available departure time from the current time. Parameters: - current_time (str): The current time in HH:MM format. - departure_times (list): A list of departure times in HH:MM format. Returns: - (str): The next available departure time or 'NO_DEPARTURE' if no departure is available. Examples: >>> find_next_departure(\\"10:15\\", [\\"8:30\\",\\"11:00\\",\\"14:45\\"]) \\"11:00\\" >>> find_next_departure(\\"23:00\\", [\\"22:30\\",\\"22:45\\",\\"23:15\\"]) \\"23:15\\" >>> find_next_departure(\\"23:00\\", [\\"22:30\\",\\"22:45\\",\\"22:50\\"]) \\"NO_DEPARTURE\\"","solution":"def find_next_departure(current_time, departure_times): Finds the next available departure time from the current time. Parameters: - current_time (str): The current time in HH:MM format. - departure_times (list): A list of departure times in HH:MM format. Returns: - (str): The next available departure time or 'NO_DEPARTURE' if no departure is available. current_hours, current_minutes = map(int, current_time.split(':')) current_total_minutes = current_hours * 60 + current_minutes min_time_diff = float('inf') next_departure = 'NO_DEPARTURE' for dt in departure_times: dep_hours, dep_minutes = map(int, dt.split(':')) dep_total_minutes = dep_hours * 60 + dep_minutes if dep_total_minutes >= current_total_minutes and (dep_total_minutes - current_total_minutes) < min_time_diff: min_time_diff = dep_total_minutes - current_total_minutes next_departure = dt return next_departure"},{"question":"def fermat_little_theorem(a: int, p: int) -> int: Returns a^(p-1) % p based on Fermat's Little Theorem. >>> fermat_little_theorem(7, 13) 1 >>> fermat_little_theorem(10, 17) 1 >>> fermat_little_theorem(123456789, 1000000007) 1","solution":"def fermat_little_theorem(a, p): Returns a^(p-1) % p based on Fermat's Little Theorem. return pow(a, p-1, p)"},{"question":"def can_reach_exit(n: int, m: int, maze: List[List[int]], start_x: int, start_y: int) -> str: Determines if there is a path from the starting position to the exit (bottom-right corner) in the given maze. :param n: Number of rows in the maze :param m: Number of columns in the maze :param maze: 2D list representing the maze grid :param start_x: Starting x-coordinate (row) of the player :param start_y: Starting y-coordinate (column) of the player :return: \\"YES\\" if there is a path to the exit, otherwise \\"NO\\" >>> can_reach_exit(4, 4, [[0, 0, 1, 0], [1, 0, 1, 0], [1, 0, 0, 0], [1, 1, 0, 0]], 0, 0) \\"YES\\" >>> can_reach_exit(3, 3, [[0, 1, 1], [1, 1, 0], [0, 0, 0]], 0, 0) \\"NO\\"","solution":"def can_reach_exit(n, m, maze, start_x, start_y): Determines if there is a path from the starting position to the exit (bottom-right corner) in the given maze. :param n: Number of rows in the maze :param m: Number of columns in the maze :param maze: 2D list representing the maze grid :param start_x: Starting x-coordinate (row) of the player :param start_y: Starting y-coordinate (column) of the player :return: \\"YES\\" if there is a path to the exit, otherwise \\"NO\\" from collections import deque # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Set of visited coordinates for BFS (Breadth-First Search) visited = set() queue = deque([(start_x, start_y)]) while queue: x, y = queue.popleft() if (x, y) == (n-1, m-1): return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and maze[nx][ny] == 0 and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) return \\"NO\\""},{"question":"import heapq def min_wasp_attacks(n: int, H: int, honey_list: List[int]) -> int: Determines the minimum number of wasp attacks required to steal at least H units of honey. >>> min_wasp_attacks(3, 10, [2, 3, 5]) 3 >>> min_wasp_attacks(3, 20, [5, 3, 2]) -1 # Your implementation here # Unit Tests def test_example_case(): assert min_wasp_attacks(3, 10, [2, 3, 5]) == 3 def test_case_exact_amount(): assert min_wasp_attacks(3, 10, [5, 3, 2]) == 3 def test_case_more_than_needed(): assert min_wasp_attacks(3, 7, [5, 3, 2]) == 2 def test_case_not_enough_honey(): assert min_wasp_attacks(3, 20, [5, 3, 2]) == -1 def test_case_no_honey_needed(): assert min_wasp_attacks(3, 0, [5, 3, 2]) == 0 def test_case_single_cell(): assert min_wasp_attacks(1, 1, [1]) == 1 assert min_wasp_attacks(1, 2, [1]) == -1 def test_large_case(): assert min_wasp_attacks(5, 1000000, [300000, 300000, 300000, 300000, 300000]) == 4","solution":"import heapq def min_wasp_attacks(n, H, honey_list): Determines the minimum number of wasp attacks required to steal at least H units of honey. Parameters: n (int): Number of cells in the beehive. H (int): Amount of honey the wasps are aiming to steal. honey_list (list): Initial amounts of honey in each cell. Returns: int: Minimum number of attacks required, or -1 if target is not achievable. if sum(honey_list) < H: return -1 # Create a max-heap with initial honey amounts max_heap = [] for h in honey_list: heapq.heappush(max_heap, -h) total_honey_stolen = 0 attacks = 0 while total_honey_stolen < H and max_heap: # Steal honey from the cell with the maximum initial amount left honey = -heapq.heappop(max_heap) total_honey_stolen += honey attacks += 1 # Add the next steal potential for this cell to the heap heapq.heappush(max_heap, -(honey // 2)) return attacks if total_honey_stolen >= H else -1"},{"question":"def detect_suspicious_activity(k: int, test_cases: List[Tuple[int, List[str]]]) -> List[str]: Determine if a log contains any suspicious activity. A log contains suspicious activity if a specific pattern of repeated activities within a subarray of the user's activity log appears at least twice without any overlapping. Args: k (int): The number of test cases. test_cases (List[Tuple[int, List[str]]]): Each test case is a tuple containing an integer n indicating the number of activities and a list of strings representing the activities. Returns: List[str]: A list of \\"Yes\\" or \\"No\\" for each test case indicating if suspicious activity was detected or not. Example: >>> k = 3 >>> test_cases = [ >>> (5, [\\"login\\", \\"click\\", \\"scroll\\", \\"click\\", \\"scroll\\"]), >>> (6, [\\"view\\", \\"click\\", \\"scroll\\", \\"view\\", \\"click\\", \\"scroll\\"]), >>> (4, [\\"open\\", \\"close\\", \\"open\\", \\"close\\"]) >>> ] >>> detect_suspicious_activity(k, test_cases) [\\"Yes\\", \\"Yes\\", \\"Yes\\"]","solution":"def detect_suspicious_activity(k, test_cases): results = [] for i in range(k): n, activities = test_cases[i] for length in range(1, n // 2 + 1): seen = set() for start in range(n - 2 * length + 1): pattern = tuple(activities[start:start + length]) if pattern in seen: results.append(\\"Yes\\") break seen.add(pattern) else: continue break else: results.append(\\"No\\") return results # Example usage k = 3 test_cases = [ (5, [\\"login\\", \\"click\\", \\"scroll\\", \\"click\\", \\"scroll\\"]), (6, [\\"view\\", \\"click\\", \\"scroll\\", \\"view\\", \\"click\\", \\"scroll\\"]), (4, [\\"open\\", \\"close\\", \\"open\\", \\"close\\"]) ] print(detect_suspicious_activity(k, test_cases))"},{"question":"def max_subarray_sum(nums: List[int]) -> int: Find the contiguous subarray with the maximum sum. In case of multiple subarrays with the same maximum sum, return the subarray which has the smallest length and if still multiple, return the subarray that appears first. Args: nums (list of int): An array of integers containing both positive and negative numbers. Returns: int: The sum of the subarray. >>> max_subarray_sum([-2, 1, -3, 4, -1]) == 4 >>> max_subarray_sum([-2, -3, 4, -1, -2, 1, 5, -3]) == 7 >>> max_subarray_sum([2, 3, 4]) == 9 >>> max_subarray_sum([-2, -3, -4]) == -2 >>> max_subarray_sum([1, -3, 2, 1, -1, 2]) == 4 >>> max_subarray_sum([-1, -2, 4, -1, 2, 1]) == 6 >>> max_subarray_sum([1]) == 1 >>> max_subarray_sum([-1]) == -1","solution":"def max_subarray_sum(nums): Find the contiguous subarray with the maximum sum. In case of multiple subarrays with the same maximum sum, return the subarray which has the smallest length and if still multiple, return the subarray that appears first. Args: nums (list of int): An array of integers containing both positive and negative numbers. Returns: int: The sum of the subarray. max_sum = curr_sum = nums[0] max_start = max_end = start = 0 for i in range(1, len(nums)): if curr_sum < 0: curr_sum = nums[i] start = i else: curr_sum += nums[i] if (curr_sum > max_sum) or (curr_sum == max_sum and (i - start) < (max_end - max_start)): max_sum = curr_sum max_start, max_end = start, i return max_sum"},{"question":"import heapq import sys from typing import List, Tuple def dijkstra(N: int, flights: List[Tuple[int, int, int]], starting_city: int) -> List[int]: Determines the minimum travel time from the starting city to all other cities in the network. Args: N (int) - The number of cities. flights (List[Tuple[int, int, int]]) - A list of flights in the format (source city, destination city, travel time). starting_city (int) - The starting city for travel. Returns: List[int] - An array where the ith index represents the minimum travel time from the starting city to city i, or -1 if the city is unreachable. Test cases: >>> dijkstra(5, [(0, 1, 10), (0, 2, 3), (1, 2, 1), (2, 1, 4), (1, 3, 2), (2, 3, 8), (3, 4, 7)], 0) [0, 7, 3, 9, 16] >>> dijkstra(4, [(1, 2, 5), (2, 3, 1), (3, 1, 2)], 1) [-1, 0, 5, 6] >>> dijkstra(3, [(0, 1, 20), (1, 2, 10)], 0) [0, 20, 30] adj = {i: [] for i in range(N)} for src, dst, time in flights: adj[src].append((dst, time)) min_time = [sys.maxsize] * N min_time[starting_city] = 0 pq = [(0, starting_city)] while pq: current_time, city = heapq.heappop(pq) if current_time > min_time[city]: continue for neighbor, travel_time in adj[city]: new_time = current_time + travel_time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return [time if time != sys.maxsize else -1 for time in min_time] def find_min_travel_times(data: List[str]) -> List[int]: Parses input data and determines the minimum travel time from the starting city to all other cities. Args: data (List[str]) - List of strings containing input data. Returns: List[int] - The result from the dijkstra function. N, M = map(int, data[0].split()) starting_city = int(data[1]) flights = [tuple(map(int, line.split())) for line in data[2:]] return dijkstra(N, flights, starting_city)","solution":"import heapq import sys def dijkstra(N, flights, starting_city): adj = {i: [] for i in range(N)} for src, dst, time in flights: adj[src].append((dst, time)) min_time = [sys.maxsize] * N min_time[starting_city] = 0 pq = [(0, starting_city)] while pq: current_time, city = heapq.heappop(pq) if current_time > min_time[city]: continue for neighbor, travel_time in adj[city]: new_time = current_time + travel_time if new_time < min_time[neighbor]: min_time[neighbor] = new_time heapq.heappush(pq, (new_time, neighbor)) return [time if time != sys.maxsize else -1 for time in min_time] def find_min_travel_times(data): N, M = map(int, data[0].split()) starting_city = int(data[1]) flights = [tuple(map(int, line.split())) for line in data[2:]] return dijkstra(N, flights, starting_city)"},{"question":"class Warehouse: def __init__(self): self.inventory = {} def add(self, product, amount): if product in self.inventory: self.inventory[product] += amount else: self.inventory[product] = amount def remove(self, product, amount): if product in self.inventory: if self.inventory[product] <= amount: del self.inventory[product] else: self.inventory[product] -= amount def check(self, product): if product in self.inventory: return self.inventory[product] else: return \\"Out of stock\\" def manage_warehouse(queries): Manage the inventory of products in a warehouse given a list of queries. Args: queries (List[str]): List of queries to execute on the warehouse inventory. Returns: List[Union[int, str]]: Results of the check operations. Example: >>> queries = [ ... \\"0 pencil 100\\", ... \\"0 pen 50\\", ... \\"1 pencil\\", ... \\"2 pen 30\\", ... \\"1 pen\\", ... \\"2 pencil 50\\", ... \\"1 pencil\\" ... ] >>> manage_warehouse(queries) [100, 20, 50]","solution":"class Warehouse: def __init__(self): self.inventory = {} def add(self, product, amount): if product in self.inventory: self.inventory[product] += amount else: self.inventory[product] = amount def remove(self, product, amount): if product in self.inventory: if self.inventory[product] <= amount: del self.inventory[product] else: self.inventory[product] -= amount def check(self, product): if product in self.inventory: return self.inventory[product] else: return \\"Out of stock\\" def manage_warehouse(queries): warehouse = Warehouse() result = [] for query in queries: parts = query.split() cmd = int(parts[0]) product = parts[1] if cmd == 0: amount = int(parts[2]) warehouse.add(product, amount) elif cmd == 1: result.append(warehouse.check(product)) elif cmd == 2: amount = int(parts[2]) warehouse.remove(product, amount) return result"},{"question":"def calculate_loveliness(N: int, arr: List[int], K: int) -> List[int]: Calculates the loveliness of every subarray of length K. Parameters: N (int): Length of the array. arr (list): List of integers. K (int): Length of the subarray. Returns: list: A list of loveliness values for each subarray of length K. # Example test cases def test_calculate_loveliness_example_1(): result = calculate_loveliness(5, [1, 3, 5, 7, 9], 3) assert result == [4, 4, 4] def test_calculate_loveliness_example_2(): result = calculate_loveliness(6, [8, 2, 4, 7, 6, 5], 2) assert result == [6, 2, 3, 1, 1] def test_calculate_loveliness_single_element_subarrays(): result = calculate_loveliness(5, [1, 2, 3, 4, 5], 1) assert result == [0, 0, 0, 0, 0] def test_calculate_loveliness_full_array_as_subarray(): result = calculate_loveliness(5, [1, 2, 3, 4, 5], 5) assert result == [4] def test_calculate_loveliness_same_elements(): result = calculate_loveliness(5, [7, 7, 7, 7, 7], 3) assert result == [0, 0, 0] def test_calculate_loveliness_mixed_values(): result = calculate_loveliness(7, [4, 8, 6, 3, 2, 9, 1], 3) assert result == [4, 5, 4, 7, 8]","solution":"def calculate_loveliness(N, arr, K): Calculates the loveliness of every subarray of length K. Parameters: N (int): Length of the array. arr (list): List of integers. K (int): Length of the subarray. Returns: list: A list of loveliness values for each subarray of length K. loveliness = [] for i in range(N - K + 1): subarray = arr[i:i + K] max_val = max(subarray) min_val = min(subarray) loveliness.append(max_val - min_val) return loveliness"},{"question":"def is_mirrored_sequence_possible(sequence): This function checks if it's possible to remove zero or more elements from the sequence to create a mirrored sequence. >>> is_mirrored_sequence_possible([1, 2, 3, 3, 2, 1]) True >>> is_mirrored_sequence_possible([4, 5, 6, 7, 5, 4, 3]) False >>> is_mirrored_sequence_possible([5, 9, 5, 9, 5]) True >>> is_mirrored_sequence_possible([8, 8, 8, 8]) True >>> is_mirrored_sequence_possible([1, 2, 3, 4, 2, 1]) False def process_test_cases(T, test_cases): For each test case, determine if it is possible to convert the given sequence to a mirrored sequence. >>> process_test_cases(4, [(6, [1, 2, 3, 3, 2, 1]), (7, [4, 5, 6, 7, 5, 4, 3]), (5, [5, 9, 5, 9, 5]), (4, [8, 8, 8, 8])]) ['Yes', 'No', 'Yes', 'Yes'] >>> process_test_cases(4, [(5, [1, 2, 1, 2, 1]), (10, [1, 2, 3, 4, 5, 5, 4, 3, 2, 1]), (3, [1, 2, 3]), (6, [7, 8, 9, 9, 8, 7])]) ['Yes', 'Yes', 'No', 'Yes']","solution":"def is_mirrored_sequence_possible(sequence): This function checks if it's possible to remove zero or more elements from the sequence to create a mirrored sequence. def longest_palindromic_subsequence(seq): n = len(seq) lps = [[0] * n for _ in range(n)] for i in range(n): lps[i][i] = 1 for cl in range(2, n + 1): for i in range(n - cl + 1): j = i + cl - 1 if seq[i] == seq[j] and cl == 2: lps[i][j] = 2 elif seq[i] == seq[j]: lps[i][j] = lps[i + 1][j - 1] + 2 else: lps[i][j] = max(lps[i][j - 1], lps[i + 1][j]) return lps[0][n - 1] lps_length = longest_palindromic_subsequence(sequence) return lps_length >= len(sequence) // 2 * 2 def process_test_cases(T, test_cases): results = [] for i in range(T): N = test_cases[i][0] sequence = test_cases[i][1] if is_mirrored_sequence_possible(sequence): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def count_balance_points(grid): Determine the number of balance points in a given grid. A \\"balance point\\" is a cell for which the sum of its row is equal to the sum of its column. Args: grid (List[List[int]]): A list of lists containing non-negative integers. Returns: int: The number of balance points in the grid. Example: >>> count_balance_points([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) 1 >>> count_balance_points([ ... [4, 5, 6, 7], ... [1, 2, 3, 4], ... [8, 4, 3, 2], ... [5, 9, 7, 3] ... ]) 0 >>> count_balance_points([ ... [0, 0], ... [0, 0] ... ]) 4 pass # Unit tests def test_example_1(): grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert count_balance_points(grid) == 1 def test_example_2(): grid = [ [4, 5, 6, 7], [1, 2, 3, 4], [8, 4, 3, 2], [5, 9, 7, 3] ] assert count_balance_points(grid) == 0 def test_example_3(): grid = [ [0, 0], [0, 0] ] assert count_balance_points(grid) == 4 def test_single_cell_grid(): grid = [ [7] ] assert count_balance_points(grid) == 1 def test_all_balance_points(): grid = [ [1, 1, 1], [1, 1, 1], [1, 1, 1] ] assert count_balance_points(grid) == 9 def test_no_balance_points(): grid = [ [1, 2], [3, 4] ] assert count_balance_points(grid) == 0","solution":"def count_balance_points(grid): n = len(grid) # Compute the row sums row_sums = [sum(row) for row in grid] # Compute the column sums col_sums = [sum(grid[i][j] for i in range(n)) for j in range(n)] balance_count = 0 # Check for balance points for i in range(n): for j in range(n): if row_sums[i] == col_sums[j]: balance_count += 1 return balance_count # Test cases if __name__ == \\"__main__\\": grid1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(count_balance_points(grid1)) # Output: 1 grid2 = [ [4, 5, 6, 7], [1, 2, 3, 4], [8, 4, 3, 2], [5, 9, 7, 3] ] print(count_balance_points(grid2)) # Output: 0 grid3 = [ [0, 0], [0, 0] ] print(count_balance_points(grid3)) # Output: 4"},{"question":"def process_operations(T: int, test_cases: List[Tuple[int, int, List[str]]]) -> List[int]: Process the update and query operations on a virtual machine's tape. Args: - T: The number of test cases. - test_cases: A list containing T elements, each of which is a tuple (N, Q, operations) where N is the length of the tape, Q is the number of operations, and operations is a list of Q strings representing the operations. Returns: - A list of integers representing the results of the sum queries, in the order they appear. >>> process_operations(2, [(5, 3, [\\"update 1 3 5\\", \\"query 0 4\\", \\"query 1 2\\"]), (4, 4, [\\"update 0 2 3\\", \\"query 0 1\\", \\"update 1 3 2\\", \\"query 1 3\\"])]) [15, 10, 6, 6] >>> process_operations(1, [(4, 2, [\\"update 0 3 5\\", \\"query 0 3\\"])]) [20]","solution":"def process_operations(T, test_cases): results = [] for case in test_cases: N, Q, operations = case tape = [0] * N for operation in operations: op_parts = operation.split() if op_parts[0] == \\"update\\": x, y, v = int(op_parts[1]), int(op_parts[2]), int(op_parts[3]) for i in range(x, y + 1): tape[i] = v elif op_parts[0] == \\"query\\": x, y = int(op_parts[1]), int(op_parts[2]) results.append(sum(tape[x:y + 1])) return results"},{"question":"def evaluate_string(m: int, n: int, string: str) -> None: Prints the string if m multiplied by n is greater than or equal to 100, and prints 'under' otherwise. >>> evaluate_string(10, 10, 'excellent') excellent >>> evaluate_string(5, 5, 'hello') under >>> evaluate_string(10, 10, 'perfect100') perfect100 >>> evaluate_string(9, 11, 'almost') under >>> evaluate_string(20, 5, 'large') large >>> evaluate_string(4, 20, 'still_under') under","solution":"def evaluate_string(m, n, string): Prints the string if m multiplied by n is greater than or equal to 100, and prints 'under' otherwise. if m * n >= 100: print(string) else: print('under')"},{"question":"def find_pair_with_sum(arr, target): Function to find two distinct elements in the array that add up to the target sum. # Using a set to store the complements complements = set() for number in arr: if (target - number) in complements: return [target - number, number] complements.add(number) return -1 def solve(test_cases): Function to handle multiple test cases. results = [] for case in test_cases: n, k, array = case result = find_pair_with_sum(array, k) if result == -1: results.append(str(result)) else: results.append(f\\"{result[0]} {result[1]}\\") return results # Test cases for the completion task def test_example_cases(): test_cases = [ (5, 9, [2, 7, 11, 15, 3]), (4, 10, [1, 2, 3, 7]), (6, 13, [1, 2, 3, 4, 5, 6]) ] expected = [ \\"2 7\\", \\"3 7\\", \\"-1\\" ] assert solve(test_cases) == expected def test_no_pairs(): test_cases = [ (3, 10, [1, 2, 3]), (4, 8, [5, 5, 5, 5]), (2, 100, [1, 1]) ] expected = [ \\"-1\\", \\"-1\\", \\"-1\\" ] assert solve(test_cases) == expected def test_multiple_pairs(): test_cases = [ (5, 7, [2, 3, 4, 1, 6]), (6, 10, [1, 5, 5, 10, -5, 15]), ] expected = [ \\"3 4\\", \\"5 5\\" ] assert solve(test_cases) == expected def test_large_numbers(): test_cases = [ (5, 10**9, [10**9 - 1, 1, 2, 3, 4]), (4, 2 * 10**9, [10**9, 10**9, 1, 2]) ] expected = [ f\\"{10**9 - 1} 1\\", f\\"{10**9} {10**9}\\" ] assert solve(test_cases) == expected def test_edge_cases(): test_cases = [ (2, 2, [1, 1]), # smallest n (3, 2, [1, 2, 1]), # duplicate elements ] expected = [ \\"1 1\\", \\"1 1\\" ] assert solve(test_cases) == expected","solution":"def find_pair_with_sum(arr, target): Function to find two distinct elements in the array that add up to the target sum. # Using a set to store the complements complements = set() for number in arr: if (target - number) in complements: return [target - number, number] complements.add(number) return -1 def solve(test_cases): Function to handle multiple test cases. results = [] for case in test_cases: n, k, array = case result = find_pair_with_sum(array, k) if result == -1: results.append(str(result)) else: results.append(f\\"{result[0]} {result[1]}\\") return results"},{"question":"from collections import deque def max_in_subarrays(weights, n, k): Returns the maximum weights in every contiguous subarray of length k. Args: weights (List[int]): list of integers representing the weights lifted on each day. n (int): number of days. k (int): length of the sub-segment. Returns: List[int]: list of integers representing the maximum weights in each sub-segment of length k. Examples: >>> max_in_subarrays([1, 3, 2, 5, 8, 2, 3], 7, 3) [3, 5, 8, 8, 8] >>> max_in_subarrays([1], 1, 1) [1] >>> max_in_subarrays([5, 3], 2, 2) [5] >>> max_in_subarrays([2, 2, 2, 2], 4, 2) [2, 2, 2] >>> max_in_subarrays([1, 2, 3, 4, 5], 5, 3) [3, 4, 5] >>> max_in_subarrays([5, 4, 3, 2, 1], 5, 2) [5, 4, 3, 2] >>> max_in_subarrays([1, 2, 3, 4, 5], 5, 1) [1, 2, 3, 4, 5] >>> max_in_subarrays([4, 4, 4, 4], 4, 2) [4, 4, 4]","solution":"from collections import deque def max_in_subarrays(weights, n, k): Returns the maximum weights in every contiguous subarray of length k. d = deque() result = [] for i in range(n): # Remove elements that are out of this window if d and d[0] == i - k: d.popleft() # Remove all elements smaller than the currently being added element (not useful) while d and weights[d[-1]] < weights[i]: d.pop() d.append(i) # The element at the front of the deque is the largest element of # the previous window, so append it to the result list if i >= k - 1: result.append(weights[d[0]]) return result"},{"question":"MOD = 1000000007 def solve_fibonacci(test_cases: List[int]) -> List[int]: Compute the n-th Fibonacci number modulo 1000000007 for each test case. >>> solve_fibonacci([1]) [1] >>> solve_fibonacci([2]) [1] >>> solve_fibonacci([10]) [55] >>> solve_fibonacci([50]) [12586269025 % 1000000007] >>> solve_fibonacci([100]) [354224848179261915075 % 1000000007] pass # Use a helper function such as matrix exponentiation to compute this def test_fibonacci_cases(): assert solve_fibonacci([1]) == [1] assert solve_fibonacci([2]) == [1] assert solve_fibonacci([10]) == [55] assert solve_fibonacci([50]) == [12586269025 % 1000000007] assert solve_fibonacci([100]) == [354224848179261915075 % 1000000007] def test_multiple_fibonacci_cases(): test_cases = [1, 2, 10, 50, 100] expected = [1, 1, 55, 12586269025 % 1000000007, 354224848179261915075 % 1000000007] assert solve_fibonacci(test_cases) == expected","solution":"MOD = 1000000007 def matrix_mult(A, B, mod=MOD): return [ [(A[0][0] * B[0][0] + A[0][1] * B[1][0]) % mod, (A[0][0] * B[0][1] + A[0][1] * B[1][1]) % mod], [(A[1][0] * B[0][0] + A[1][1] * B[1][0]) % mod, (A[1][0] * B[0][1] + A[1][1] * B[1][1]) % mod] ] def matrix_pow(mat, exp, mod=MOD): res = [[1, 0], [0, 1]] base = mat while exp > 0: if exp % 2 == 1: res = matrix_mult(res, base, mod) base = matrix_mult(base, base, mod) exp //= 2 return res def fibonacci_mod(n, mod=MOD): if n == 1 or n == 2: return 1 F = [[1, 1], [1, 0]] result = matrix_pow(F, n - 1, mod) return result[0][0] def solve_fibonacci(test_cases): results = [] for n in test_cases: results.append(fibonacci_mod(n)) return results"},{"question":"def simulate_traffic_lights(N: int, M: int, G: int, T: int) -> (int, float): Simulates the traffic light system in a grid of intersections and calculates the number of cars passed and the average waiting time. Args: N (int): number of rows in the grid M (int): number of columns in the grid G (int): number of seconds each light remains green T (int): total duration of the simulation Returns: tuple: total number of cars passed and average waiting time for the cars >>> simulate_traffic_lights(2, 2, 10, 100) (x, y) >>> simulate_traffic_lights(3, 3, 10, 100) (x, y) pass","solution":"def simulate_traffic_lights(N, M, G, T): Simulates the traffic light system in a grid of intersections and calculates the number of cars passed and the average waiting time. Args: N (int): number of rows in the grid M (int): number of columns in the grid G (int): number of seconds each light remains green T (int): total duration of the simulation Returns: tuple: total number of cars passed and average waiting time for the cars cars_passed = 0 total_waiting_time = 0 total_cars = 0 for time in range(T): # For each intersection in the grid for i in range(N): for j in range(M): # Determine the state of the lights at the current time if (time // G) % 2 == 0: # North-South green passing_cars = 2 # cars passing N and S waiting_cars = 2 # cars waiting E and W else: # East-West green passing_cars = 2 # cars passing E and W waiting_cars = 2 # cars waiting N and S cars_passed += passing_cars total_waiting_time += waiting_cars * (G // 2 * (time // G)) total_cars += 4 avg_waiting_time = total_waiting_time / total_cars if total_cars > 0 else 0 return cars_passed, avg_waiting_time"},{"question":"def determine_winner(votes: List[str]) -> str: Determine the winner of a class election based on a sequence of votes. >>> determine_winner([\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"END\\"]) \\"Alice\\" >>> determine_winner([\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\", \\"END\\"]) \\"TIE\\" >>> determine_winner([\\"END\\"]) \\"NO VOTES\\"","solution":"def determine_winner(votes): vote_count = {} for vote in votes: if vote != \\"END\\": if vote in vote_count: vote_count[vote] += 1 else: vote_count[vote] = 1 if len(vote_count) == 0: return \\"NO VOTES\\" # Find the student with the maximum votes max_votes = max(vote_count.values()) # Check for tie winners = [name for name, votes in vote_count.items() if votes == max_votes] if len(winners) > 1: return \\"TIE\\" else: return winners[0]"},{"question":"def min_cost_to_palindrome(s: str) -> int: Return the minimum cost required to transform the given string into a palindrome. >>> min_cost_to_palindrome('abcba') 0 >>> min_cost_to_palindrome('abcd') 4 >>> min_cost_to_palindrome('a') 0 >>> min_cost_to_palindrome('aaaa') 0 >>> min_cost_to_palindrome('abccba') 0 >>> min_cost_to_palindrome('axbyc') abs(ord('x') - ord('y')) + abs(ord('a') - ord('c')) >>> min_cost_to_palindrome('abcdefgh') (abs(ord('a') - ord('h')) + abs(ord('b') - ord('g')) + abs(ord('c') - ord('f')) + abs(ord('d') - ord('e'))) >>> min_cost_to_palindrome('a' * 100000) 0","solution":"def min_cost_to_palindrome(s): Return the minimum cost to transform a given string into a palindrome. :param s: The input string. :return: The minimum cost to transform the string into a palindrome. n = len(s) cost = 0 # Only need to iterate over the first half since we are transforming the string into a palindrome for i in range(n // 2): cost += abs(ord(s[i]) - ord(s[n - i - 1])) return cost"},{"question":"def harmonious_numbers_count(m: int) -> int: Returns the count of harmonious numbers that are less than or equal to m. >>> harmonious_numbers_count(100) 18 >>> harmonious_numbers_count(1) 1 >>> harmonious_numbers_count(9) 9 >>> harmonious_numbers_count(10) 9 >>> harmonious_numbers_count(11) 10 >>> harmonious_numbers_count(999) 27 >>> harmonious_numbers_count(9999) 36","solution":"def harmonious_numbers_count(m): Returns the count of harmonious numbers that are less than or equal to m. count = 0 for i in range(1, 10): # single digit numbers num = i while num <= m: count += 1 num = num * 10 + i return count"},{"question":"def max_books(n: int, k: int, S: int, widths: List[int]) -> int: Returns the maximum number of books that can be placed on the bookshelf without exceeding the total width S and ensuring that the total number of books doesn't exceed count limit k. Parameters: n (int): Number of books k (int): Maximum number of books allowed on the shelf S (int): Total available width on the shelf widths (list of int): List of widths of each book Returns: int: Maximum number of books that can be placed on the shelf >>> max_books(5, 3, 10, [2, 3, 1, 5, 4]) 3 >>> max_books(4, 2, 7, [3, 8, 4, 2]) 2 >>> max_books(6, 2, 5, [3, 3, 3, 3, 3, 3]) 1","solution":"def max_books(n, k, S, widths): Returns the maximum number of books that can be placed on the bookshelf without exceeding the total width S and ensuring that the total number of books doesn't exceed count limit k. Parameters: n (int): Number of books k (int): Maximum number of books allowed on the shelf S (int): Total available width on the shelf widths (list of int): List of widths of each book Returns: int: Maximum number of books that can be placed on the shelf widths.sort() # Sort widths in ascending order total_width = 0 book_count = 0 for width in widths: if book_count < k and total_width + width <= S: total_width += width book_count += 1 else: break return book_count"},{"question":"def longest_palindromic_substring(s: str) -> str: Write a function that takes a string as an input and returns the longest palindromic substring within it. If multiple substrings of the same length are found, return the first one that appears. Args: s (str): The input string consisting of only lowercase English letters. Returns: str: The longest palindromic substring. Examples: >>> longest_palindromic_substring(\\"babad\\") 'bab' >>> longest_palindromic_substring(\\"cbbd\\") 'bb' >>> longest_palindromic_substring(\\"a\\") 'a' >>> longest_palindromic_substring(\\"ac\\") 'a' pass from longest_palindromic_substring import longest_palindromic_substring def test_palindromic_substring(): assert longest_palindromic_substring(\\"babad\\") == \\"bab\\" assert longest_palindromic_substring(\\"cbbd\\") == \\"bb\\" assert longest_palindromic_substring(\\"a\\") == \\"a\\" assert longest_palindromic_substring(\\"ac\\") == \\"a\\" def test_single_character(): assert longest_palindromic_substring(\\"z\\") == \\"z\\" def test_all_same_characters(): assert longest_palindromic_substring(\\"aaaa\\") == \\"aaaa\\" def test_mixed_characters(): assert longest_palindromic_substring(\\"bananas\\") == \\"anana\\" assert longest_palindromic_substring(\\"racecar\\") == \\"racecar\\" def test_empty_string(): assert longest_palindromic_substring(\\"\\") == \\"\\" def test_palindromic_substrings_with_same_length(): assert longest_palindromic_substring(\\"abacdfgdcaba\\") == \\"aba\\" assert longest_palindromic_substring(\\"abacdfgdcabba\\") == \\"abba\\"","solution":"def longest_palindromic_substring(s: str) -> str: def expand_around_center(left: int, right: int) -> str: while left >= 0 and right < len(s) and s[left] == s[right]: left -= 1 right += 1 return s[left + 1:right] longest = \\"\\" for i in range(len(s)): odd_palindrome = expand_around_center(i, i) # palindrome with odd length even_palindrome = expand_around_center(i, i + 1) # palindrome with even length if len(odd_palindrome) > len(longest): longest = odd_palindrome if len(even_palindrome) > len(longest): longest = even_palindrome return longest"},{"question":"def collect_pinecones(c: int, n: int, pinecones: list) -> int: Determines the total number of pinecones collected without exceeding basket capacity. Parameters: c (int): Capacity of the basket. n (int): Number of checkpoints. pinecones (list): List of pinecones at each checkpoint. Returns: int: Total number of pinecones collected. Examples: >>> collect_pinecones(10, 5, [3, 4, 2, 3, 1]) 10 >>> collect_pinecones(5, 3, [2, 3, 4]) 5 >>> collect_pinecones(15, 4, [5, 6, 4, 2]) 15","solution":"def collect_pinecones(c, n, pinecones): Determines the total number of pinecones collected without exceeding basket capacity. Parameters: c (int): Capacity of the basket. n (int): Number of checkpoints. pinecones (list): List of pinecones at each checkpoint. Returns: int: Total number of pinecones collected. total_collected = 0 for p in pinecones: if total_collected + p <= c: total_collected += p else: total_collected = c break return total_collected"},{"question":"def evaluate_participant(T: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[str]: Evaluates the participant's output against expected outputs for each test case. Parameters: - T (int): Number of test cases. - test_cases (list of tuples): Each tuple contains: - N (int): Number of test cases the participant's code has been tested against. - expected (list of int): Expected outputs. - actual (list of int): Participant's outputs. Returns: - list of str: \\"SUCCESS\\" or \\"FAIL\\" for each test case. from typing import List, Tuple def test_all_success(): T = 1 test_cases = [ (3, [5, 10, 15], [5, 10, 15]) ] assert evaluate_participant(T, test_cases) == [\\"SUCCESS\\"] def test_all_fail(): T = 1 test_cases = [ (3, [5, 10, 15], [5, 9, 15]) ] assert evaluate_participant(T, test_cases) == [\\"FAIL\\"] def test_mixed_results(): T = 2 test_cases = [ (3, [5, 10, 15], [5, 10, 15]), (4, [7, 22, 5, 13], [7, 20, 5, 13]) ] assert evaluate_participant(T, test_cases) == [\\"SUCCESS\\", \\"FAIL\\"] def test_single_test_case_success(): T = 2 test_cases = [ (1, [1], [1]), (1, [1000], [1000]) ] assert evaluate_participant(T, test_cases) == [\\"SUCCESS\\", \\"SUCCESS\\"] def test_single_test_case_fail(): T = 1 test_cases = [ (1, [1], [2]) ] assert evaluate_participant(T, test_cases) == [\\"FAIL\\"]","solution":"def evaluate_participant(T, test_cases): Evaluates the participant's output against expected outputs for each test case. Parameters: - T (int): Number of test cases. - test_cases (list of tuples): Each tuple contains: - N (int): Number of test cases the participant's code has been tested against. - expected (list of int): Expected outputs. - actual (list of int): Participant's outputs. Returns: - list of str: \\"SUCCESS\\" or \\"FAIL\\" for each test case. results = [] for i in range(T): N, expected, actual = test_cases[i] if expected == actual: results.append(\\"SUCCESS\\") else: results.append(\\"FAIL\\") return results"},{"question":"def city_with_highest_average_temperature(n: int, m: int, data: List[str]) -> str: Returns the name of the city with the highest average temperature. Parameters: n (int): Number of cities m (int): Number of days for which temperature data is provided data (list): List of strings with each string containing city name followed by m temperatures Returns: str: The name of the city with the highest average temperature Examples: >>> city_with_highest_average_temperature(3, 2, [\\"CityA 30 25\\", \\"CityB 20 30\\", \\"CityC 25 25\\"]) 'CityA' >>> city_with_highest_average_temperature(2, 3, [\\"CityA 20 30 40\\", \\"CityB 30 20 40\\"]) 'CityA'","solution":"def city_with_highest_average_temperature(n, m, data): Returns the name of the city with the highest average temperature. Parameters: n (int): Number of cities m (int): Number of days for which temperature data is provided data (list): List of strings with each string containing city name followed by m temperatures Returns: str: The name of the city with the highest average temperature max_avg_temp = -float('inf') city_with_max_avg_temp = \\"\\" for entry in data: parts = entry.split() city = parts[0] temperatures = list(map(int, parts[1:])) avg_temp = sum(temperatures) / m if avg_temp > max_avg_temp: max_avg_temp = avg_temp city_with_max_avg_temp = city return city_with_max_avg_temp"},{"question":"from typing import List def min_difference(heights: List[int]) -> int: Returns the minimum possible difference between the total heights of buildings painted by the two workers. Args: heights (List[int]): List of integers representing the heights of buildings. Returns: int: The minimum possible difference. Examples: >>> min_difference([1, 2, 3, 4, 5]) 1 >>> min_difference([4, 2, 3, 1]) 0 # Unit tests def test_example1(): assert min_difference([1, 2, 3, 4, 5]) == 1 def test_example2(): assert min_difference([4, 2, 3, 1]) == 0 def test_all_equal_heights(): assert min_difference([5, 5, 5, 5]) == 0 def test_large_difference(): assert min_difference([1, 1, 1, 99]) == 96 def test_single_building(): assert min_difference([10]) == 10 def test_two_buildings(): assert min_difference([100, 200]) == 100 def test_empty(): assert min_difference([]) == 0 def test_large_input(): heights = [i for i in range(1, 101)] # Sums to 5050, testing if function handles large input assert min_difference(heights) == 0","solution":"def min_difference(heights): Returns the minimum possible difference between the total heights of buildings painted by the two workers. total_height = sum(heights) n = len(heights) # Initialize a DP array where dp[i] indicates whether sum i is reachable using any subset of the buildings dp = [False] * (total_height + 1) dp[0] = True for height in heights: for j in range(total_height, height - 1, -1): if dp[j - height]: dp[j] = True min_diff = float('inf') for i in range(total_height // 2 + 1): if dp[i]: min_diff = min(min_diff, abs(total_height - 2 * i)) return min_diff # Example usage n = 5 heights = [1, 2, 3, 4, 5] print(min_difference(heights)) # Output: 1"},{"question":"def maximal_rectangle(matrix: List[List[int]]) -> int: Find the maximum area of a rectangle composed entirely of 1s in the matrix. >>> maximal_rectangle([ ... [1, 0, 1, 0, 0], ... [1, 0, 1, 1, 1], ... [1, 1, 1, 1, 1], ... [1, 0, 0, 1, 0] ... ]) 6 >>> maximal_rectangle([ ... [0, 0, 0], ... [0, 0, 0], ... [0, 0, 0] ... ]) 0 >>> maximal_rectangle([[1, 0, 1, 1]]) 2 >>> maximal_rectangle([ ... [1, 1, 1], ... [1, 1, 1], ... [1, 1, 1] ... ]) 9","solution":"def maximal_rectangle(matrix): if not matrix: return 0 n = len(matrix) m = len(matrix[0]) max_area = 0 heights = [0] * m for i in range(n): for j in range(m): heights[j] = heights[j] + 1 if matrix[i][j] == 1 else 0 max_area = max(max_area, largest_rectangle_area(heights)) return max_area def largest_rectangle_area(heights): stack = [] max_area = 0 heights.append(0) # Adding a sentinel value to pop all bars from the stack for i in range(len(heights)): while stack and heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i if not stack else i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) heights.pop() # Remove the sentinel value return max_area"},{"question":"def maximize_beauty(T: int, test_cases: List[Tuple[Tuple[int, int], List[int]]]) -> List[int]: Help John select a subset of photos to maximize the total beauty value without exceeding the maximum number he can take. >>> maximize_beauty(5, [((5, 3), [100, 200, 300, 400, 500]), ((4, 4), [50, 50, 50, 50]), ((3, 1), [10, 20, 30]), ((6, 2), [5, 1, 3, 6, 2, 8]), ((2, 1), [1000, 2000])]) [1200, 200, 30, 14, 2000] >>> maximize_beauty(1, [((5, 3), [0, 0, 0, 0, 0])]) [0] >>> maximize_beauty(1, [((1, 1), [500])]) [500] >>> maximize_beauty(1, [((10, 3), [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])]) [27] >>> maximize_beauty(1, [((4, 4), [100, 200, 50, 25])]) [375]","solution":"def maximize_beauty(T, test_cases): results = [] for t in range(T): N, M = test_cases[t][0] beauty_values = test_cases[t][1] beauty_values.sort(reverse=True) results.append(sum(beauty_values[:M])) return results"},{"question":"def max_path_sum(n, m, grid): Function to calculate the maximum sum of values from the top-left to the bottom-right in a grid. :param n: Integer, number of rows in the grid :param m: Integer, number of columns in the grid :param grid: List of lists, representing the grid with non-negative integers :return: Integer, maximum sum collected Example: >>> max_path_sum(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 29 >>> max_path_sum(1, 1, [[5]]) 5 >>> max_path_sum(1, 4, [[1, 2, 3, 4]]) 10 >>> max_path_sum(4, 1, [[1], [2], [3], [4]]) 10 >>> max_path_sum(3, 3, [[10, 33, 13], [23, 50, 25], [5, 19, 27]]) 145 >>> max_path_sum(2, 2, [[0, 0], [0, 0]]) 0 >>> grid = [[0]*1000 for _ in range(1000)] >>> grid[0][0] = 10000 >>> max_path_sum(1000, 1000, grid) 10000","solution":"def max_path_sum(n, m, grid): Function to calculate the maximum sum of values from the top-left to the bottom-right in a grid. :param n: Integer, number of rows in the grid :param m: Integer, number of columns in the grid :param grid: List of lists, representing the grid with non-negative integers :return: Integer, maximum sum collected dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] return dp[n - 1][m - 1]"},{"question":"from typing import List def can_assign_employees(m: int, n: int, employees: List[List[int]], projects: List[List[int]]) -> str: Assign employees to projects to ensure all required skills are covered. Args: m (int): Number of employees. n (int): Number of projects. employees (List[List[int]]): List of employees' skills. projects (List[List[int]]): List of projects' required skills. Returns: str: \\"YES\\" if all projects can have required skills covered, otherwise \\"NO\\". >>> can_assign_employees(3, 2, [[1, 2, 3], [1, 4], [2]], [[1, 2], [3]]) \\"YES\\" >>> can_assign_employees(2, 2, [[1, 2], [3]], [[1], [4]]) \\"NO\\" def test_can_assign_employees(): # Test case 1: Example from prompt assert can_assign_employees(3, 2, [[1, 2, 3], [1, 4], [2]], [[1, 2], [3]]) == \\"YES\\" # Test case 2: Example from prompt assert can_assign_employees(2, 2, [[1, 2], [3]], [[1], [4]]) == \\"NO\\" # Test case 3: All necessary skills covered assert can_assign_employees(2, 1, [[1, 2, 3], [4, 5, 6]], [[1, 4]]) == \\"YES\\" # Test case 4: Not all necessary skills covered assert can_assign_employees(1, 1, [[1, 2, 3]], [[4]]) == \\"NO\\" # Test case 5: Large m, n but feasible assignment assert can_assign_employees(50, 50, [[i] for i in range(1, 51)], [[i] for i in range(1, 51)]) == \\"YES\\" # Test case 6: Large m, n but infeasible assignment assert can_assign_employees(50, 50, [[i] for i in range(1, 51)], [[i+50] for i in range(1, 51)]) == \\"NO\\"","solution":"def can_assign_employees(m, n, employees, projects): # Function to aggregate all skills possessed by employees employee_skills = set() for emp in employees: employee_skills.update(emp) # Check each project skills against the aggregated employee skills for proj in projects: if not set(proj).issubset(employee_skills): return \\"NO\\" return \\"YES\\""},{"question":"def is_path_exists(n: int, grid: List[str]) -> str: Determine if there is a path from the top-left corner to the bottom-right corner in an n x n grid. Args: n (int): The size of the grid. grid (List[str]): A list of strings representing the grid, where '.' represents an empty cell and '#' represents an obstacle. Returns: str: \\"YES\\" if there is a path from the top-left corner to the bottom-right corner, otherwise \\"NO\\". Examples: >>> is_path_exists(3, [\\"..#\\", \\".#.\\", \\"...\\"]) \\"YES\\" >>> is_path_exists(4, [\\"..#.\\", \\"..\\", \\"..#.\\", \\"..#.\\"]) \\"NO\\"","solution":"def is_path_exists(n, grid): def dfs(x, y): if x == y == n-1: # reached bottom-right corner return True if x < 0 or y < 0 or x >= n or y >= n or grid[x][y] == '#': # out of bounds or obstacle return False if (x, y) in visited: # already visited return False visited.add((x, y)) # explore all 4 possible directions return dfs(x + 1, y) or dfs(x, y + 1) or dfs(x - 1, y) or dfs(x, y - 1) visited = set() return \\"YES\\" if dfs(0, 0) else \\"NO\\""},{"question":"from typing import List def tsp_min_cost(N: int, cost: List[List[int]]) -> int: Calculate the minimum travel cost to attend all conferences in sequence and return to the starting city. Args: N (int): The number of conferences (or cities). cost (List[List[int]]): An N x N matrix where the element at i-th row and j-th column represents the travel cost between city i and city j. Returns: int: The minimum travel cost to attend all conferences in sequence and return to the starting city. Example: >>> tsp_min_cost(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0] ... ]) 80 import itertools # Helper function to calculate the cost of a specific path def calculate_path_cost(path): total_cost = 0 for i in range(len(path) - 1): total_cost += cost[path[i]][path[i + 1]] # cost of returning to the start city total_cost += cost[path[-1]][path[0]] return total_cost # Generate all permutations of cities 1 to N-1 cities = list(range(1, N)) min_cost = float('inf') for perm in itertools.permutations(cities): current_path = [0] + list(perm) current_cost = calculate_path_cost(current_path) if current_cost < min_cost: min_cost = current_cost return min_cost # Unit tests def test_sample_case_1(): N = 4 cost = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert tsp_min_cost(N, cost) == 80 def test_sample_case_2(): N = 3 cost = [ [0, 1, 15], [1, 0, 25], [15, 25, 0] ] assert tsp_min_cost(N, cost) == 41 def test_all_equal_cost(): N = 4 cost = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert tsp_min_cost(N, cost) == 4 def test_zero_travel_cost(): N = 4 cost = [ [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0] ] assert tsp_min_cost(N, cost) == 0","solution":"def tsp_min_cost(N, cost): import itertools # Helper function to calculate the cost of a specific path def calculate_path_cost(path): total_cost = 0 for i in range(len(path) - 1): total_cost += cost[path[i]][path[i + 1]] # cost of returning to the start city total_cost += cost[path[-1]][path[0]] return total_cost # Generate all permutations of cities 1 to N-1 cities = list(range(1, N)) min_cost = float('inf') for perm in itertools.permutations(cities): current_path = [0] + list(perm) current_cost = calculate_path_cost(current_path) if current_cost < min_cost: min_cost = current_cost return min_cost # Example Usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) cost = [] idx = 1 for i in range(N): cost.append(list(map(int, data[idx:idx + N]))) idx += N print(tsp_min_cost(N, cost))"},{"question":"def shortest_path(n: int, m: int, grid: List[str]) -> int: Determine whether it is possible to reach the target position 'T' from the starting position 'S', and if so, find the shortest path. Args: n: number of rows in the grid m: number of columns in the grid grid: list of strings representing the grid Returns: The length of the shortest path from 'S' to 'T', or -1 if no such path exists. Examples: >>> shortest_path(4, 5, [\\"S...#\\", \\"..#..\\", \\".#...\\", \\"#.T\\"]) 7 >>> shortest_path(3, 3, [\\"S#.\\", \\".#.\\", \\"T\\"]) -1","solution":"from collections import deque def shortest_path(n, m, grid): def bfs(start_x, start_y, target_x, target_y): # directions array for moving up, down, left, right directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start_x, start_y, 0)]) # (current x, current y, distance) visited = set((start_x, start_y)) # set of visited cells while queue: x, y, dist = queue.popleft() # check if we have reached the target if (x, y) == (target_x, target_y): return dist # explore all directions for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1 # not reachable start_x = start_y = target_x = target_y = -1 for i in range(n): for j in range(m): if grid[i][j] == 'S': start_x, start_y = i, j elif grid[i][j] == 'T': target_x, target_y = i, j # Call bfs to find the shortest path return bfs(start_x, start_y, target_x, target_y)"},{"question":"def one_edit_away(s1: str, s2: str) -> str: Determine if s1 can be transformed into s2 using exactly one operation: insert, remove, or replace a character. Args: s1 (str): The original string. s2 (str): The target string. Returns: str: \\"Yes\\" if s1 can be transformed to s2 using exactly one operation, otherwise \\"No\\". Examples: >>> one_edit_away(\\"pale\\", \\"ple\\") \\"Yes\\" >>> one_edit_away(\\"pales\\", \\"pale\\") \\"Yes\\" >>> one_edit_away(\\"pale\\", \\"bale\\") \\"Yes\\" >>> one_edit_away(\\"pale\\", \\"bake\\") \\"No\\" from solution import one_edit_away def test_one_edit_away_no_changes_needed(): assert one_edit_away(\\"abc\\", \\"abc\\") == \\"Yes\\" def test_one_edit_away_insert(): assert one_edit_away(\\"pale\\", \\"ple\\") == \\"Yes\\" def test_one_edit_away_remove(): assert one_edit_away(\\"pales\\", \\"pale\\") == \\"Yes\\" def test_one_edit_away_replace(): assert one_edit_away(\\"pale\\", \\"bale\\") == \\"Yes\\" def test_one_edit_away_no(): assert one_edit_away(\\"pale\\", \\"bake\\") == \\"No\\" def test_one_edit_away_edge_case_empty_strings(): assert one_edit_away(\\"\\", \\"a\\") == \\"Yes\\" assert one_edit_away(\\"a\\", \\"\\") == \\"Yes\\" assert one_edit_away(\\"\\", \\"\\") == \\"Yes\\" def test_one_edit_away_large_strings(): s1 = \\"a\\" * 100000 s2 = \\"a\\" * 99999 assert one_edit_away(s1, s2) == \\"Yes\\" assert one_edit_away(s2, s1) == \\"Yes\\" def test_one_edit_away_different_lengths(): assert one_edit_away(\\"ab\\", \\"abc\\") == \\"Yes\\" assert one_edit_away(\\"abc\\", \\"ab\\") == \\"Yes\\" assert one_edit_away(\\"abcd\\", \\"ab\\") == \\"No\\"","solution":"def one_edit_away(s1: str, s2: str) -> str: if abs(len(s1) - len(s2)) > 1: return \\"No\\" if len(s1) == len(s2): # Check if one replacement can make the strings equal found_difference = False for ch1, ch2 in zip(s1, s2): if ch1 != ch2: if found_difference: return \\"No\\" found_difference = True return \\"Yes\\" if len(s1) + 1 == len(s2): # Check if inserting one character in s1 can make it equal to s2 i = j = 0 while i < len(s1) and j < len(s2): if s1[i] != s2[j]: if i != j: return \\"No\\" j += 1 else: i += 1 j += 1 return \\"Yes\\" if len(s1) - 1 == len(s2): # Check if removing one character from s1 can make it equal to s2 i = j = 0 while i < len(s1) and j < len(s2): if s1[i] != s2[j]: if i != j: return \\"No\\" i += 1 else: i += 1 j += 1 return \\"Yes\\" return \\"No\\""},{"question":"def longest_palindromic_subsequence(s: str) -> int: Find the length of the longest palindromic subsequence in the given string. >>> longest_palindromic_subsequence(\\"abacdfg\\") 3 >>> longest_palindromic_subsequence(\\"bbabcb\\") 5 >>> longest_palindromic_subsequence(\\"abcba\\") 5 >>> longest_palindromic_subsequence(\\"a\\") 1 >>> longest_palindromic_subsequence(\\"abcde\\") 1 def solve_longest_palindromic_subsequences(t: int, test_cases: List[Tuple[int, str]]) -> List[int]: Determine the length of the longest palindromic subsequence for multiple test cases.","solution":"def longest_palindromic_subsequence(s): Finds the length of the longest palindromic subsequence in the given string. n = len(s) dp = [[0] * n for _ in range(n)] # Palindromic subsequences of length 1 for i in range(n): dp[i][i] = 1 # Build the table for subsequences of length greater than 1 for length in range(2, n + 1): for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j]: dp[i][j] = 2 + dp[i + 1][j - 1] if length > 2 else 2 else: dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]) return dp[0][n - 1] def solve_longest_palindromic_subsequences(t, test_cases): Solves the problem for multiple test cases. results = [] for case in test_cases: n, s = case results.append(longest_palindromic_subsequence(s)) return results"},{"question":"from typing import List, Tuple def average_ratings(number_of_products: int, product_details: List[Tuple[str, int]]) -> List[Tuple[str, float]]: Calculate average ratings for each category and return them in alphabetical order. :param number_of_products: int, total number of products :param product_details: list of tuples, where each tuple contains (category, rating) :return: list of tuples, where each tuple contains (category, average_rating) >>> average_ratings(5, [('electronics', 5), ('books', 3), ('electronics', 4), ('books', 4), ('clothing', 2)]) [('books', 3.5), ('clothing', 2.0), ('electronics', 4.5)] >>> average_ratings(3, [('toys', 4), ('toys', 5), ('pets', 3)]) [('pets', 3.0), ('toys', 4.5)] >>> average_ratings(4, [('fruits', 2), ('vegetables', 3), ('fruits', 5), ('vegetables', 4)]) [('fruits', 3.5), ('vegetables', 3.5)] >>> average_ratings(1, [('gadgets', 5)]) [('gadgets', 5.0)] >>> average_ratings(6, [('clothing', 4), ('clothing', 5), ('food', 3), ('food', 4), ('electronics', 5), ('electronics', 5)]) [('clothing', 4.5), ('electronics', 5.0), ('food', 3.5)]","solution":"def average_ratings(number_of_products, product_details): Calculate average ratings for each category and return them in alphabetical order. :param number_of_products: int, total number of products :param product_details: list of tuples, where each tuple contains (category, rating) :return: list of tuples, where each tuple contains (category, average_rating) from collections import defaultdict # Dictionary to store total ratings and count for each category category_ratings = defaultdict(lambda: [0, 0]) # Process each product detail for category, rating in product_details: category_ratings[category][0] += rating category_ratings[category][1] += 1 # Calculate average ratings and store in a list result = [] for category in sorted(category_ratings.keys()): total, count = category_ratings[category] average = total / count result.append((category, round(average, 2))) return result"},{"question":"def is_path_possible(grid, sx, sy, dx, dy): Determines if there is a path from the start (sx, sy) to the destination (dx, dy) in the given grid. :param grid: List of list of integers representing the cell status (0 for open, 1 for blocked) :param sx: Starting x-coordinate :param sy: Starting y-coordinate :param dx: Destination x-coordinate :param dy: Destination y-coordinate :return: \\"YES\\" if a path is possible, \\"NO\\" otherwise def test_is_path_possible_1(): grid = [ [0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0], [1, 1, 0, 1, 1], [0,0,0,0,0] ] assert is_path_possible(grid, 0, 0, 4, 4) == \\"YES\\" def test_is_path_possible_2(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert is_path_possible(grid, 0, 0, 2, 2) == \\"YES\\" def test_is_path_possible_3(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 0] ] assert is_path_possible(grid, 0, 0, 1, 1) == \\"NO\\" def test_is_path_possible_blocked_start(): grid = [ [1, 0, 0], [0, 1, 0], [0, 0, 0] ] assert is_path_possible(grid, 0, 0, 2, 2) == \\"NO\\" def test_is_path_possible_blocked_destination(): grid = [ [0, 0, 0], [0, 1, 0], [0, 0, 1] ] assert is_path_possible(grid, 0, 0, 2, 2) == \\"NO\\"","solution":"def is_path_possible(grid, sx, sy, dx, dy): Determines if there is a path from the start (sx, sy) to the destination (dx, dy) in the given grid. :param grid: List of list of integers representing the cell status (0 for open, 1 for blocked) :param sx: Starting x-coordinate :param sy: Starting y-coordinate :param dx: Destination x-coordinate :param dy: Destination y-coordinate :return: \\"YES\\" if a path is possible, \\"NO\\" otherwise n = len(grid) m = len(grid[0]) def is_valid(x, y): return 0 <= x < n and 0 <= y < m and grid[x][y] == 0 def dfs(x, y): if not is_valid(x, y): return False if (x, y) == (dx, dy): return True grid[x][y] = 1 # Mark this cell as visited for direction in [(0, 1), (1, 0), (0, -1), (-1, 0)]: new_x, new_y = x + direction[0], y + direction[1] if dfs(new_x, new_y): return True return False return \\"YES\\" if dfs(sx, sy) else \\"NO\\""},{"question":"from typing import List def unobstructed_view_buildings(test_cases: List[List[int]]) -> List[int]: Compute the number of buildings that have an unobstructed view of the street for each test case. Args: test_cases (List[List[int]]): A list of test cases, each containing a list of building heights. Returns: List[int]: The number of buildings with an unobstructed view for each test case. >>> unobstructed_view_buildings([[3, 5, 4, 4, 3], [10, 12, 9, 13, 14, 7], [8, 7, 7]]) [2, 4, 1] >>> unobstructed_view_buildings([[1, 2, 3, 4]]) [4] >>> unobstructed_view_buildings([[5, 5, 5, 5, 5]]) [1] >>> unobstructed_view_buildings([[4, 3, 2, 1]]) [1] >>> unobstructed_view_buildings([[1, 3, 2, 4, 3, 5, 4]]) [4] pass def parse_input(input_string: str) -> List[List[int]]: Parse the input string into a list of test cases. Args: input_string (str): The input string. Returns: List[List[int]]: The parsed test cases. >>> parse_input(\\"3n5n3 5 4 4 3n6n10 12 9 13 14 7n3n8 7 7\\") [[3, 5, 4, 4, 3], [10, 12, 9, 13, 14, 7], [8, 7, 7]] pass def test_unobstructed_view_buildings(): input_data = \\"3n5n3 5 4 4 3n6n10 12 9 13 14 7n3n8 7 7\\" expected_output = [2, 4, 1] test_cases = parse_input(input_data) assert unobstructed_view_buildings(test_cases) == expected_output def test_single_test_case(): input_data = \\"1n4n1 2 3 4\\" expected_output = [4] test_cases = parse_input(input_data) assert unobstructed_view_buildings(test_cases) == expected_output def test_all_same_height(): input_data = \\"1n5n5 5 5 5 5\\" expected_output = [1] test_cases = parse_input(input_data) assert unobstructed_view_buildings(test_cases) == expected_output def test_decreasing_heights(): input_data = \\"1n4n4 3 2 1\\" expected_output = [1] test_cases = parse_input(input_data) assert unobstructed_view_buildings(test_cases) == expected_output def test_varying_heights(): input_data = \\"1n7n1 3 2 4 3 5 4\\" expected_output = [4] test_cases = parse_input(input_data) assert unobstructed_view_buildings(test_cases) == expected_output","solution":"def unobstructed_view_buildings(test_cases): results = [] for buildings in test_cases: max_height = 0 count = 0 for height in buildings: if height > max_height: max_height = height count += 1 results.append(count) return results def parse_input(input_string): data = input_string.strip().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 buildings = list(map(int, data[index:index + N])) test_cases.append(buildings) index += N return test_cases"},{"question":"def maximize_gold_distribution(n: int, k: int, d: int, coins: List[int]) -> int: Given the initial number of gold coins in each treasure chest, determines the maximum total amount of gold that can be evenly distributed across all treasure chests using the corruption process. Parameters: n (int): Number of treasure chests. k (int): Number of coins transferred during corruption. d (int): Maximum distance within which corruption can occur. coins (list of int): Initial number of gold coins in each treasure chest. Returns: int: Maximum total number of gold evenly distributed. Examples: >>> maximize_gold_distribution(5, 100, 2, [100, 200, 300, 400, 500]) 1500 >>> maximize_gold_distribution(3, 10, 1, [100, 100, 100]) 300 >>> maximize_gold_distribution(4, 5, 2, [10, 20, 30, 40]) 100 >>> maximize_gold_distribution(1, 10, 1, [999]) 999 >>> maximize_gold_distribution(4, 1000, 3, [1000000000, 2000000000, 3000000000, 4000000000]) 10000000000","solution":"def maximize_gold_distribution(n, k, d, coins): Given the initial number of gold coins in each treasure chest, determines the maximum total amount of gold that can be evenly distributed. Parameters: n (int): Number of treasure chests. k (int): Number of coins transferred during corruption. d (int): Maximum distance within which corruption can occur. coins (list of int): Initial number of gold coins in each treasure chest. Returns: int: Maximum total number of gold evenly distributed. total_gold = sum(coins) return total_gold # Example Usage if __name__ == \\"__main__\\": n, k, d = 5, 100, 2 coins = [100, 200, 300, 400, 500] print(maximize_gold_distribution(n, k, d, coins)) # Output: 1500"},{"question":"import re from collections import Counter from typing import Dict def word_frequency(paragraph: str) -> Dict[str, int]: Calculates the frequency of each word in the given paragraph, ignoring case and punctuation. Returns a dictionary of words and their frequencies sorted in descending order of frequency. In case of a tie, words are sorted alphabetically. Parameters: paragraph (str): The input paragraph. Returns: dict: A dictionary with words as keys and their frequencies as values. >>> word_frequency(\\"This is a test. This test is only a test.\\") {'test': 3, 'a': 2, 'is': 2, 'this': 2, 'only': 1} >>> word_frequency(\\"It's a student's book. It's his book.\\") {'it's': 2, 'book': 2, 'a': 1, 'his': 1, 'student's': 1}","solution":"import re from collections import Counter def word_frequency(paragraph): Calculates the frequency of each word in the given paragraph, ignoring case and punctuation. Returns a dictionary of words and their frequencies sorted in descending order of frequency. In case of a tie, words are sorted alphabetically. Parameters: paragraph (str): The input paragraph. Returns: dict: A dictionary with words as keys and their frequencies as values. # Convert paragraph to lowercase paragraph = paragraph.lower() # Use regex to find all words (sequences of alphanumeric characters and apostrophes) words = re.findall(r'bw+'?w*b', paragraph) # Get the frequency of each word using Counter word_count = Counter(words) # Sort the dictionary by frequency in descending order, then by word alphabetically sorted_word_count = dict(sorted(word_count.items(), key=lambda item: (-item[1], item[0]))) return sorted_word_count"},{"question":"def decompose_into_powers_of_two(n: int): Determine a way to split the integer n into a sum of distinct powers of two. Specifically, find distinct non-negative integers a_1, a_2, ..., a_k such that: n = 2^{a_1} + 2^{a_2} + ... + 2^{a_k} where 0  a_1 < a_2 < ... < a_k and all a_i are distinct. Args: n (int): A positive integer (1  n  10^9). Returns: A tuple containing: - A string \\"YES\\" or \\"NO\\" indicating whether such a decomposition exists. - An integer k representing the number of elements in the decomposition (if \\"YES\\"). - A list of k distinct non-negative integers representing the exponents in the decomposition (if \\"YES\\"). >>> decompose_into_powers_of_two(5) ('YES', 2, [0, 2]) >>> decompose_into_powers_of_two(10) ('YES', 2, [1, 3])","solution":"def decompose_into_powers_of_two(n): Returns a decomposition of the integer n into distinct powers of two if possible. powers = [] exponent = 0 while n > 0: if n & 1: powers.append(exponent) n >>= 1 exponent += 1 if powers: return \\"YES\\", len(powers), powers else: return \\"NO\\","},{"question":"def min_slots_needed(n: int, m: int, l: int, piles: List[int]) -> int: Determine the minimum number of slots needed to accommodate all the books with a limit of l books per slot. Parameters: - n (int): Number of bookshelf slots - m (int): Number of book piles - l (int): Limit of books per slot - piles (list): List of integers where each integer represents the number of books in each pile Returns: - int: Minimum number of slots needed >>> min_slots_needed(10, 5, 5, [4, 8, 1, 7, 4]) 5 >>> min_slots_needed(6, 3, 2, [3, 3, 3]) 5 >>> min_slots_needed(3, 1, 3, [3]) 1 >>> min_slots_needed(5, 3, 10, [2, 3, 4]) 1 >>> min_slots_needed(10, 5, 4, [5, 5, 5, 4, 4]) 6 >>> min_slots_needed(8, 4, 3, [2, 2, 2, 2]) 3 >>> min_slots_needed(20, 3, 2, [2, 2, 2]) 3 >>> min_slots_needed(5, 0, 3, []) 0 >>> min_slots_needed(1000, 1000, 1, [1] * 1000) 1000 pass","solution":"def min_slots_needed(n, m, l, piles): Determine the minimum number of slots needed to accommodate all the books with a limit of l books per slot. Parameters: - n (int): Number of bookshelf slots - m (int): Number of book piles - l (int): Limit of books per slot - piles (list): List of integers where each integer represents the number of books in each pile Returns: - int: Minimum number of slots needed total_books = sum(piles) # Calculate the minimum number of slots needed if each slot can hold up to l books slots_needed = (total_books + l - 1) // l # The slots needed should not exceed the number of slots on the bookshelf return min(slots_needed, n)"},{"question":"def min_add_to_make_balanced(s: str) -> int: Given a string consisting only of characters \\"(\\" and \\")\\", determine the minimum number of parentheses that need to be added to make the string balanced. Args: s (str): The input string containing only '(' and ')'. Returns: int: The minimum number of parentheses to be added to make the string balanced. Examples: >>> min_add_to_make_balanced(\\"(()\\") 1 >>> min_add_to_make_balanced(\\"())(\\") 2 >>> min_add_to_make_balanced(\\"((())\\") 1","solution":"def min_add_to_make_balanced(s): Given a string consisting only of characters \\"(\\" and \\")\\", determine the minimum number of parentheses that need to be added to make the string balanced. Args: s (str): The input string containing only '(' and ')'. Returns: int: The minimum number of parentheses to be added to make the string balanced. left_balance = 0 # Number of left parentheses needed to balance the string right_balance = 0 # Number of right parentheses needed to balance the string for char in s: if char == '(': left_balance += 1 else: if left_balance == 0: right_balance += 1 else: left_balance -= 1 return left_balance + right_balance"},{"question":"def find_permutation_indices(s: str, p: str) -> List[int]: Finds all starting indices of substrings in s that are permutations of p. >>> find_permutation_indices(\\"cbaebabacd\\", \\"abc\\") [0, 6] >>> find_permutation_indices(\\"abab\\", \\"ab\\") [0, 1, 2]","solution":"def find_permutation_indices(s, p): Finds all starting indices of substrings in s that are permutations of p. from collections import Counter p_count = Counter(p) s_count = Counter() result = [] p_len = len(p) s_len = len(s) for i in range(s_len): s_count[s[i]] += 1 if i >= p_len: if s_count[s[i - p_len]] == 1: del s_count[s[i - p_len]] else: s_count[s[i - p_len]] -= 1 if s_count == p_count: result.append(i - p_len + 1) return result"},{"question":"def has_hamiltonian_path(n, edges): Determine whether there exists any Hamiltonian path in the graph. Args: n (int): The number of vertices in the graph. edges (List[Tuple[int, int]]): List of edges in the graph, where each edge is represented by a tuple (u, v). Returns: str: \\"YES\\" if there is a Hamiltonian path, otherwise \\"NO\\". Examples: >>> has_hamiltonian_path(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> has_hamiltonian_path(4, [(1, 2), (2, 3)]) \\"NO\\" def test_has_hamiltonian_path_example(): assert has_hamiltonian_path(4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == \\"YES\\" def test_has_hamiltonian_path_no_path(): assert has_hamiltonian_path(4, [(1, 2), (2, 3)]) == \\"NO\\" def test_has_hamiltonian_path_single_vertex(): assert has_hamiltonian_path(1, []) == \\"YES\\" def test_has_hamiltonian_path_two_vertices(): assert has_hamiltonian_path(2, [(1, 2)]) == \\"YES\\" assert has_hamiltonian_path(2, []) == \\"NO\\" def test_has_hamiltonian_path_disconnected_graph(): assert has_hamiltonian_path(4, [(1, 2), (3, 4)]) == \\"NO\\" def test_has_hamiltonian_path_full_graph(): assert has_hamiltonian_path(3, [(1, 2), (2, 3), (3, 1)]) == \\"YES\\" assert has_hamiltonian_path(4, [(1,2), (2,3), (3,4), (4,1), (1,3), (2,4)]) == \\"YES\\"","solution":"def has_hamiltonian_path(n, edges): def is_hamiltonian_path(path, graph): for i in range(len(path) - 1): if path[i+1] not in graph[path[i]]: return False return True def backtrack(path, visited, graph): if len(path) == len(graph): if is_hamiltonian_path(path, graph): return True return False for vertex in range(1, n + 1): if not visited[vertex - 1]: visited[vertex - 1] = True path.append(vertex) if backtrack(path, visited, graph): return True path.pop() visited[vertex - 1] = False return False # Represent graph as adjacency list graph = {i: set() for i in range(1, n + 1)} for u, v in edges: graph[u].add(v) graph[v].add(u) # Try to find Hamiltonian path starting from any vertex for start in range(1, n + 1): path = [start] visited = [False] * n visited[start - 1] = True if backtrack(path, visited, graph): return \\"YES\\" return \\"NO\\" # Parse input def parse_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) edges = [] for i in range(m): u = int(data[2 + 2*i]) v = int(data[3 + 2*i]) edges.append((u, v)) return n, edges if __name__ == \\"__main__\\": n, edges = parse_input() print(has_hamiltonian_path(n, edges))"},{"question":"from typing import List, Tuple def max_overlapping_events(events: List[Tuple[int, int]]) -> int: Given a list of events with their start and end times, return the maximum number of events overlapping at any given time. >>> max_overlapping_events([(1, 5), (2, 6), (4, 7), (5, 8)]) == 3 >>> max_overlapping_events([(1, 2), (3, 4), (5, 6), (7, 8)]) == 1 >>> max_overlapping_events([(1, 10), (1, 10), (1, 10), (1, 10)]) == 4 >>> max_overlapping_events([(1, 5), (2, 3), (4, 7), (3, 6)]) == 3 >>> max_overlapping_events([(5, 10)]) == 1 >>> max_overlapping_events([(1, 2), (2, 3), (3, 4), (4, 5)]) == 1","solution":"def max_overlapping_events(events): Returns the maximum number of overlapping events at any given time. points = [] for start, end in events: points.append((start, 'start')) points.append((end, 'end')) points.sort() max_overlap = 0 current_overlap = 0 for point in points: if point[1] == 'start': current_overlap += 1 max_overlap = max(max_overlap, current_overlap) else: current_overlap -= 1 return max_overlap # Example usage: n = 4 events = [ (1, 5), (2, 6), (4, 7), (5, 8) ] print(max_overlapping_events(events)) # Output: 3"},{"question":"def encode_string(s: str) -> int: Encodes the string by converting each character to its positional value in the alphabet and summing these values. :param s: str: input string consisting of lowercase alphabetical characters :return: int: encoded value of the string Examples: >>> encode_string(\\"abc\\") 6 >>> encode_string(\\"zzz\\") 78 >>> encode_string(\\"hello\\") 52","solution":"def encode_string(s): Encodes the string by converting each character to its positional value in the alphabet and summing these values. :param s: str: input string consisting of lowercase alphabetical characters :return: int: encoded value of the string return sum(ord(c) - ord('a') + 1 for c in s)"},{"question":"def can_transform_by_one_swap(a: str, b: str) -> str: Determine if one string can be transformed into the other by swapping exactly one pair of characters. >>> can_transform_by_one_swap(\\"abcd\\", \\"abdc\\") \\"YES\\" >>> can_transform_by_one_swap(\\"abcd\\", \\"abcc\\") \\"NO\\" from solution import can_transform_by_one_swap def test_same_strings(): assert can_transform_by_one_swap(\\"abc\\", \\"abc\\") == \\"NO\\" def test_one_swap_needed(): assert can_transform_by_one_swap(\\"abcd\\", \\"abdc\\") == \\"YES\\" assert can_transform_by_one_swap(\\"ab\\", \\"ba\\") == \\"YES\\" def test_more_than_two_differences(): assert can_transform_by_one_swap(\\"abcd\\", \\"abcc\\") == \\"NO\\" assert can_transform_by_one_swap(\\"abcd\\", \\"aebf\\") == \\"NO\\" def test_two_differences_non_swappable(): assert can_transform_by_one_swap(\\"abcd\\", \\"abcd\\") == \\"NO\\" assert can_transform_by_one_swap(\\"abcd\\", \\"abdc\\") == \\"YES\\" def test_different_lengths(): assert can_transform_by_one_swap(\\"abc\\", \\"abcd\\") == \\"NO\\"","solution":"def can_transform_by_one_swap(a, b): if len(a) != len(b): return \\"NO\\" # Find indices where characters differ differences = [] for i in range(len(a)): if a[i] != b[i]: differences.append(i) # If there are exactly 2 differences, check if swapping them makes the strings equal if len(differences) == 2: i, j = differences if a[i] == b[j] and a[j] == b[i]: return \\"YES\\" return \\"NO\\""},{"question":"def longest_unique_substring(s: str) -> int: Returns the length of the longest contiguous substring of unique characters. >>> longest_unique_substring(\\"abcabcbb\\") 3 >>> longest_unique_substring(\\"bbbbb\\") 1 >>> longest_unique_substring(\\"pwwkew\\") 3 >>> longest_unique_substring(\\"a\\") 1 >>> longest_unique_substring(\\"aaaaaa\\") 1 >>> longest_unique_substring(\\"abcdef\\") 6 >>> longest_unique_substring(\\"abcbacbb\\") 3 >>> longest_unique_substring(\\"dvdf\\") 3 >>> longest_unique_substring(\\"anviaj\\") 5 >>> longest_unique_substring(\\"\\".join([\\"a\\" for _ in range(1000000)])) 1 >>> longest_unique_substring(\\"abcdefghijklmnopqrstuvwxyz\\" * 10000) 26","solution":"def longest_unique_substring(s): Returns the length of the longest contiguous substring of unique characters. char_index_map = {} max_length = start = 0 for i, ch in enumerate(s): if ch in char_index_map and char_index_map[ch] >= start: start = char_index_map[ch] + 1 char_index_map[ch] = i max_length = max(max_length, i - start + 1) return max_length"},{"question":"def longest_common_subsequence(s1: str, s2: str) -> str: Returns the longest common subsequence of s1 and s2. >>> longest_common_subsequence(\\"abcde\\", \\"ace\\") == \\"ace\\" >>> longest_common_subsequence(\\"abc\\", \\"abc\\") == \\"abc\\" >>> longest_common_subsequence(\\"abc\\", \\"def\\") == \\"\\"","solution":"def longest_common_subsequence(s1, s2): Returns the longest common subsequence of s1 and s2. len_s1, len_s2 = len(s1), len(s2) # Create a 2D array to store lengths of longest common subsequence. dp = [[0] * (len_s2 + 1) for _ in range(len_s1 + 1)] # Fill the dp array for i in range(1, len_s1 + 1): for j in range(1, len_s2 + 1): if s1[i - 1] == s2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) # Reconstruct the longest common subsequence from the dp array lcs = [] i, j = len_s1, len_s2 while i > 0 and j > 0: if s1[i - 1] == s2[j - 1]: lcs.append(s1[i - 1]) i -= 1 j -= 1 elif dp[i - 1][j] > dp[i][j - 1]: i -= 1 else: j -= 1 return ''.join(reversed(lcs))"},{"question":"def reverse_subarrays_and_sum(n: int, k: int, a: List[int]) -> int: Reverses all possible subarrays of length k and calculates the sum of the resulting list. :param n: int, the length of the list a. :param k: int, the length of the subarrays to be reversed. :param a: list of int, the original list. :return: int, the sum of the list after all possible subarray reversals. >>> reverse_subarrays_and_sum(5, 3, [1, 2, 3, 4, 5]) 15 >>> reverse_subarrays_and_sum(4, 2, [1, 3, 5, 7]) 16 >>> reverse_subarrays_and_sum(6, 2, [1, 2, 3, 4, 5, 6]) 21 >>> reverse_subarrays_and_sum(5, 5, [1, 2, 3, 4, 5]) 15 >>> reverse_subarrays_and_sum(3, 1, [10, 20, 30]) 60","solution":"def reverse_subarrays_and_sum(n, k, a): Reverses all possible subarrays of length k and calculates the sum of the resulting list. :param n: int, the length of the list a. :param k: int, the length of the subarrays to be reversed. :param a: list of int, the original list. :return: int, the sum of the list after all possible subarray reversals. a_copy = a.copy() # Reverse all possible subarrays of length k for start in range(0, n, k): end = min(start + k, n) a_copy[start:end] = reversed(a_copy[start:end]) return sum(a_copy) # Example usage: # n = 5, k = 3, a = [1, 2, 3, 4, 5] # Output: 24 # Explanation: reverse subarrays of length 3: [3, 2, 1, 5, 4], sum = 3 + 2 + 1 + 5 + 4 = 15 if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) k = int(data[1]) a = list(map(int, data[2:])) print(reverse_subarrays_and_sum(n, k, a))"},{"question":"def count_peaks(arr: List[int]) -> int: Returns the number of peak elements in the input array. >>> count_peaks([1, 2, 3, 1, 5]) 2 >>> count_peaks([10, 20, 10, 30]) 2 >>> count_peaks([10]) 1","solution":"def count_peaks(arr): Returns the number of peak elements in the input array. n = len(arr) peaks = 0 for i in range(n): if i == 0: # first element if n == 1 or arr[i] > arr[i + 1]: peaks += 1 elif i == n - 1: # last element if arr[i] > arr[i - 1]: peaks += 1 else: # middle elements if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks += 1 return peaks"},{"question":"from typing import List def reverse_bits(n: int) -> int: Returns the integer resulting from reversing the bits of the input integer n. >>> reverse_bits(13) # 1101 -> 1011 11 >>> reverse_bits(0) # 0 -> 0 0 >>> reverse_bits(4294967295) # 111...111 (32 1's) -> 111...111 4294967295 >>> reverse_bits(2) # 10 -> 01 1 def process_test_cases(T: int, test_cases: List[int]) -> List[int]: Processes multiple test cases of reversing bits. Parameters: - T (int): Number of test cases - test_cases (List[int]): List of integers to process Returns: - List of integers, each representing the result of reversing the bits of the corresponding input integer. >>> process_test_cases(3, [13, 0, 4294967295]) [11, 0, 4294967295] >>> process_test_cases(1, [1]) [1] >>> process_test_cases(5, [1, 2, 3, 4, 5]) [1, 1, 3, 1, 5]","solution":"def reverse_bits(n): Returns the integer resulting from reversing the bits of the input integer n. b = bin(n)[2:] # Convert n to binary string and strip the '0b' prefix b_rev = b[::-1] # Reverse the string return int(b_rev, 2) # Convert the reversed string back to an integer def process_test_cases(T, test_cases): Processes multiple test cases of reversing bits. Parameters: - T (int): Number of test cases - test_cases (list of int): List of integers to process Returns: - List of integers, each representing the result of reversing the bits of the corresponding input integer. results = [] for n in test_cases: results.append(reverse_bits(n)) return results"},{"question":"def roller_coaster_ride_completion_times(n: int, riders: List[Tuple[int, int]]) -> List[int]: Simulate the roller coaster ride based on rider arrival times and ride durations. Parameters: n (int): Number of riders riders (list of tuples): Each tuple contains two integers, ti and di Returns: list: Completion times for each rider Example: >>> roller_coaster_ride_completion_times(3, [(1, 5), (2, 3), (4, 7)]) [6, 9, 16] >>> roller_coaster_ride_completion_times(1, [(5, 10)]) [15] pass","solution":"def roller_coaster_ride_completion_times(n, riders): Simulate the roller coaster ride based on rider arrival times and ride durations. Parameters: n (int): Number of riders riders (list of tuples): Each tuple contains two integers, ti and di Returns: list: Completion times for each rider completion_times = [] current_time = 0 for arrival_time, ride_duration in riders: if arrival_time > current_time: current_time = arrival_time completion_time = current_time + ride_duration completion_times.append(completion_time) current_time = completion_time return completion_times"},{"question":"from typing import List def is_layout_valid(N: int, M: int, D: int, grid: List[str]) -> str: Determine if the city layout meets the requirements. Args: - N (int): Number of rows in the grid. - M (int): Number of columns in the grid. - D (int): Maximum allowed distance from a house to a hospital. - grid (List[str]): The N x M city grid containing 'F', 'H', 'R', '#', and '.'. Returns: - str: \\"YES\\" if all conditions are met, \\"NO\\" otherwise. >>> is_layout_valid(4, 5, 2, [\\"F....\\", \\".#H#.\\", \\"H..R.\\", \\"R....\\"]) \\"YES\\" >>> is_layout_valid(4, 5, 2, [\\"F.#..\\", \\"H#.\\", \\"H..R.\\", \\"R....\\"]) \\"NO\\" >>> is_layout_valid(4, 5, 1, [\\"F....\\", \\".#H#.\\", \\"H..R.\\", \\"R.#..\\"]) \\"NO\\" >>> is_layout_valid(4, 5, 2, [\\"F....\\", \\".#H#.\\", \\"H....\\", \\".....\\"]) \\"YES\\" >>> is_layout_valid(4, 5, 1, [\\"F.#..\\" , \\".#H#.\\", \\"R..R.\\", \\"R.#..\\"]) \\"NO\\"","solution":"from collections import deque def bfs(grid, start, N, M): directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False for _ in range(M)] for _ in range(N)] queue = deque([start]) visited[start[0]][start[1]] = True distances = [[float('inf') for _ in range(M)] for _ in range(N)] distances[start[0]][start[1]] = 0 while queue: x, y = queue.popleft() for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and not visited[nx][ny] and grid[nx][ny] != '#': visited[nx][ny] = True queue.append((nx, ny)) distances[nx][ny] = distances[x][y] + 1 return distances def is_layout_valid(N, M, D, grid): fire_station = None hospitals = [] houses = [] for i in range(N): for j in range(M): if grid[i][j] == 'F': fire_station = (i, j) elif grid[i][j] == 'H': hospitals.append((i, j)) elif grid[i][j] == 'R': houses.append((i, j)) if not fire_station: return \\"NO\\" distances_from_fire_station = bfs(grid, fire_station, N, M) for h in hospitals: if distances_from_fire_station[h[0]][h[1]] == float('inf'): return \\"NO\\" for r in houses: min_distance = float('inf') for h in hospitals: distance = abs(r[0] - h[0]) + abs(r[1] - h[1]) min_distance = min(min_distance, distance) if min_distance > D: return \\"NO\\" return \\"YES\\""},{"question":"def find_pair_with_sum_divisible_by_k(N: int, K: int, A: List[int]) -> str: Returns \\"Yes\\" if there exists a pair of distinct indices (i, j) such that A[i] + A[j] is divisible by K, else returns \\"No\\". :param N: int, the number of elements in array A :param K: int, the integer to check divisibility against :param A: list of int, the array of integers :return: str, \\"Yes\\" or \\"No\\" pass from solution import find_pair_with_sum_divisible_by_k def test_sample_input_1(): assert find_pair_with_sum_divisible_by_k(5, 4, [1, 2, 3, 4, 5]) == \\"Yes\\" def test_no_pair_exists(): assert find_pair_with_sum_divisible_by_k(4, 4, [1, 1, 1, 1]) == \\"No\\" def test_pair_exists_at_start(): assert find_pair_with_sum_divisible_by_k(3, 5, [4, 1, 6]) == \\"Yes\\" def test_large_numbers(): assert find_pair_with_sum_divisible_by_k(3, 5, [100000000, 100000005, 100000010]) == \\"Yes\\" def test_pair_with_large_k(): assert find_pair_with_sum_divisible_by_k(5, 2000000, [1000000, 1000000, 500000, 1500000, 500000]) == \\"Yes\\" def test_single_element(): assert find_pair_with_sum_divisible_by_k(1, 2, [1]) == \\"No\\"","solution":"def find_pair_with_sum_divisible_by_k(N, K, A): Returns \\"Yes\\" if there exists a pair of distinct indices (i, j) such that A[i] + A[j] is divisible by K, else returns \\"No\\". :param N: int, the number of elements in array A :param K: int, the integer to check divisibility against :param A: list of int, the array of integers :return: str, \\"Yes\\" or \\"No\\" remainder_map = {} for number in A: remainder = number % K # Check for complementary remainder to make the sum divisible by K complement = (K - remainder) % K if complement in remainder_map: return \\"Yes\\" if remainder not in remainder_map: remainder_map[remainder] = 0 remainder_map[remainder] += 1 return \\"No\\""},{"question":"def detect_anomalies(n, d, readings): Determine the number of anomalies in sensor readings based on the given threshold. Args: n (int): The number of sensor readings. d (int): The threshold for detecting anomalies. readings (List[Tuple[int, int]]): A list of tuples, where each tuple contains a timestamp and a reading. Returns: List[int]: A list of timestamps where anomalies were detected. Examples: >>> detect_anomalies(5, 10, [(1, 15), (2, 30), (3, 20), (4, 50), (5, 25)]) [2, 4, 5] >>> detect_anomalies(4, 5, [(101, 50), (102, 45), (103, 55), (104, 52)]) [102, 103] >>> detect_anomalies(3, 3, [(10, 100), (20, 105), (30, 102)]) [20] pass # Unit Tests def test_no_anomalies(): n = 3 d = 100 readings = [ (1, 1000), (2, 1090), (3, 1085), ] assert detect_anomalies(n, d, readings) == [] def test_some_anomalies(): n = 5 d = 10 readings = [ (1, 15), (2, 30), (3, 20), (4, 50), (5, 25) ] assert detect_anomalies(n, d, readings) == [2, 4, 5] def test_all_anomalies(): n = 4 d = 1 readings = [ (1, 0), (2, 5), (3, -5), (4, 10) ] assert detect_anomalies(n, d, readings) == [2, 3, 4] def test_single_anomaly(): n = 3 d = 3 readings = [ (10, 100), (20, 105), (30, 102) ] assert detect_anomalies(n, d, readings) == [20] def test_edge_case(): n = 2 d = 0 readings = [ (100, 50), (101, 50) ] assert detect_anomalies(n, d, readings) == []","solution":"def detect_anomalies(n, d, readings): anomalies = [] for i in range(1, n): prev_reading = readings[i - 1][1] current_reading = readings[i][1] if abs(current_reading - prev_reading) > d: anomalies.append(readings[i][0]) return anomalies # Sample usage if __name__ == \\"__main__\\": # Example input n = 5 d = 10 readings = [ (1, 15), (2, 30), (3, 20), (4, 50), (5, 25) ] anomalies = detect_anomalies(n, d, readings) print(len(anomalies)) for timestamp in anomalies: print(timestamp)"},{"question":"def remove_duplicates(n: int, elements: List[int]) -> List[int]: Removes duplicates from the list while maintaining the original order of first occurrences. Parameters: n (int): Number of elements in the list. elements (list): List of non-negative integers, possibly containing duplicates. Returns: list: A list with duplicates removed, maintaining the original order. pass # Test cases def test_remove_duplicates_example_1(): n = 7 elements = [1, 2, 2, 3, 4, 3, 5] assert remove_duplicates(n, elements) == [1, 2, 3, 4, 5] def test_remove_duplicates_example_2(): n = 5 elements = [5, 5, 5, 5, 5] assert remove_duplicates(n, elements) == [5] def test_remove_duplicates_no_duplicates(): n = 4 elements = [1, 2, 3, 4] assert remove_duplicates(n, elements) == [1, 2, 3, 4] def test_remove_duplicates_all_duplicates(): n = 6 elements = [1, 1, 1, 1, 1, 1] assert remove_duplicates(n, elements) == [1] def test_remove_duplicates_mixed_repeats(): n = 8 elements = [4, 5, 6, 4, 6, 7, 5, 8] assert remove_duplicates(n, elements) == [4, 5, 6, 7, 8] def test_remove_duplicates_large_input(): n = 10 elements = [3, 3, 4, 5, 6, 7, 8, 9, 3, 5] assert remove_duplicates(n, elements) == [3, 4, 5, 6, 7, 8, 9]","solution":"def remove_duplicates(n, elements): Removes duplicates from the list while maintaining the original order of first occurrences. Parameters: n (int): Number of elements in the list. elements (list): List of non-negative integers, possibly containing duplicates. Returns: list: A list with duplicates removed, maintaining the original order. seen = set() result = [] for element in elements: if element not in seen: seen.add(element) result.append(element) return result"},{"question":"from typing import List def min_steps_to_target(n: int, m: int, grid: List[str]) -> int: Determine the minimum steps required for the robot to reach the target point (T). >>> min_steps_to_target(4, 4, [\\".#..\\", \\"..#.\\", \\"#...\\", \\"...T\\"]) 6 >>> min_steps_to_target(3, 3, [\\"#\\", \\"#.T\\", \\".\\"]) -1 # Test Cases from solution import min_steps_to_target def test_example_1(): grid = [ \\".#..\\", \\"..#.\\", \\"#...\\", \\"...T\\" ] assert min_steps_to_target(4, 4, grid) == 6 def test_example_2(): grid = [ \\"#\\", \\"#.T\\", \\".\\" ] assert min_steps_to_target(3, 3, grid) == -1 def test_target_adjacent_to_start(): grid = [ \\".T\\", \\"..\\" ] assert min_steps_to_target(2, 2, grid) == 1 def test_large_grid_with_clear_path(): n = 1000 m = 1000 grid = [\\".\\" * m for _ in range(n)] grid[-1] = \\".\\" * (m - 1) + \\"T\\" assert min_steps_to_target(n, m, grid) == 1998 def test_large_grid_with_obstacle(): n = 1000 m = 1000 grid = [\\".\\" * m for _ in range(n)] grid[n//2] = \\"#\\" * m grid[-1] = \\".\\" * (m - 1) + \\"T\\" assert min_steps_to_target(n, m, grid) == -1","solution":"from collections import deque def min_steps_to_target(n, m, grid): # Directions for up, down, left, right movements directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Initialize the queue with starting point queue = deque([(0, 0, 0)]) # (row, col, steps) # Visited set to keep track of visited cells visited = set((0, 0)) # Find the target position 'T' target = None for i in range(n): for j in range(m): if grid[i][j] == 'T': target = (i, j) break if not target: return -1 # BFS for the shortest path while queue: x, y, steps = queue.popleft() if (x, y) == target: return steps for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and grid[nx][ny] != '#' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny, steps + 1)) return -1"},{"question":"def g_substring(s: str, queries: List[Tuple[int, int]]) -> List[str]: Function to get the substrings from given queries. Given a string s and a list of queries where each query is a tuple (l, r), the function returns the substrings from index l to r (1-based index) for each query. :param s: str - input string :param queries: list of tuples - each tuple contains two integers l and r :return: list of strings - results for each query >>> g_substring(\\"abcdef\\", [(1, 3), (2, 5), (1, 6)]) [\\"abc\\", \\"bcde\\", \\"abcdef\\"] >>> g_substring(\\"hello\\", [(1, 1), (1, 2), (1, 5), (2, 2), (3, 4)]) [\\"h\\", \\"he\\", \\"hello\\", \\"e\\", \\"ll\\"]","solution":"def g_substring(s, queries): Function to get the substrings from given queries. :param s: str - input string :param queries: list of tuples - each tuple contains two integers l and r :return: list of strings - results for each query results = [] for l, r in queries: # Extract the substring based on the given indices l and r results.append(s[l-1:r]) return results"},{"question":"def chemical_formula(formula: str) -> List[str]: Calculate the total number of each type of atoms in the formula and return them in lexicographical order of element names. Examples: >>> chemical_formula(\\"H2O\\") ['H 2', 'O 1'] >>> chemical_formula(\\"K4(ON(SO3)2)2\\") ['K 4', 'N 2', 'O 14', 'S 4']","solution":"import re from collections import defaultdict def parse_formula(formula): def parse(): stack = [defaultdict(int)] i = 0 while i < len(formula): if formula[i] == '(': stack.append(defaultdict(int)) i += 1 elif formula[i] == ')': group = stack.pop() i += 1 i_end = i while i_end < len(formula) and formula[i_end].isdigit(): i_end += 1 multiplier = int(formula[i:i_end] or '1') for element, count in group.items(): stack[-1][element] += count * multiplier i = i_end else: i_end = i + 1 while i_end < len(formula) and formula[i_end].islower(): i_end += 1 element = formula[i:i_end] i = i_end i_end = i while i_end < len(formula) and formula[i_end].isdigit(): i_end += 1 count = int(formula[i:i_end] or '1') stack[-1][element] += count i = i_end return stack[0] result = parse() sorted_elements = sorted(result.items()) return sorted_elements def chemical_formula(formula): parsed_formula = parse_formula(formula) result = [] for element, count in parsed_formula: result.append(f\\"{element} {count}\\") return result"},{"question":"def longest_even_segment(arr: List[int]) -> int: Find the length of the longest even segment in an array of integers. >>> longest_even_segment([1, 2, 4, 6, 1, 4, 2, 8]) == 3 >>> longest_even_segment([1, 3, 5, 7]) == 0 >>> longest_even_segment([2, 4, 6, 8, 10]) == 5 >>> longest_even_segment([2]) == 1 >>> longest_even_segment([1]) == 0 >>> longest_even_segment([1, 2, 1, 4, 6, 1, 4, 2, 8, 1]) == 3 >>> longest_even_segment([2, 2, 1, 2, 4, 6, 1, 2]) == 3","solution":"def longest_even_segment(arr): max_length = 0 current_length = 0 for num in arr: if num % 2 == 0: current_length += 1 max_length = max(max_length, current_length) else: current_length = 0 return max_length # Example usage: # N = int(input()) # arr = list(map(int, input().split())) # print(longest_even_segment(arr))"},{"question":"def min_operations_to_make_equal(arr: List[int]) -> int: Develop a function min_operations_to_make_equal(arr) that takes as input a list of positive integers arr and returns the minimum number of operations required to make all elements of the list equal. In one operation, you can either increment or decrement each element of the list by 1. >>> min_operations_to_make_equal([1, 2, 3]) 2 >>> min_operations_to_make_equal([10, 10, 10, 10]) 0 >>> min_operations_to_make_equal([10, 20, 30]) 20","solution":"def min_operations_to_make_equal(arr): Returns the minimum number of operations required to make all elements of the list equal by either incrementing or decrementing each element by 1 in each operation. if not arr: return 0 # sort the array to find the median arr.sort() # choose the median as the target value to minimize the total operations median = arr[len(arr) // 2] # calculate the total operations to make all elements equal to median min_operations = sum(abs(x - median) for x in arr) return min_operations"},{"question":"class Folder: def __init__(self, docs, subs): Initialize the Folder with documents and subfolders. :param docs: A list of document IDs directly in the folder. :param subs: A list of sub-folder objects directly in the folder. self._docs = docs self._subs = subs def getAllDocuments(self): Retrieve all document IDs from the folder and its subfolders in a flattened order. :return: A list of all document IDs in flat order. pass def printAllDocuments(self): Print all document IDs in a tree-like structure. Each document ID should be printed on a new line prefixed with a number of dashes ('-') indicating its depth level. Top-level documents have no dashes, documents in subfolders have one dash, documents in sub-subfolders have two dashes, and so on. pass # Unit Tests import pytest def test_getAllDocuments_no_subfolders(): folder = Folder([1, 2, 3], []) assert folder.getAllDocuments() == [1, 2, 3] def test_getAllDocuments_with_subfolders(): subfolder1 = Folder([4, 5], []) subfolder2 = Folder([6], []) folder = Folder([1, 2], [subfolder1, subfolder2]) assert folder.getAllDocuments() == [1, 2, 4, 5, 6] def test_getAllDocuments_complex_structure(): subfolder1 = Folder([4, 5], [ Folder([8], []), Folder([9, 10], []) ]) subfolder2 = Folder([6, 7], []) folder = Folder([1, 2, 3], [subfolder1, subfolder2]) assert folder.getAllDocuments() == [1, 2, 3, 4, 5, 8, 9, 10, 6, 7] def test_printAllDocuments_no_subfolders(capsys): folder = Folder([1, 2, 3], []) folder.printAllDocuments() captured = capsys.readouterr() assert captured.out == \\"1n2n3n\\" def test_printAllDocuments_with_subfolders(capsys): subfolder1 = Folder([4, 5], []) subfolder2 = Folder([6], []) folder = Folder([1, 2], [subfolder1, subfolder2]) folder.printAllDocuments() captured = capsys.readouterr() expected_output = \\"1n2n-4n-5n-6n\\" assert captured.out == expected_output def test_printAllDocuments_complex_structure(capsys): subfolder1 = Folder([4, 5], [ Folder([8], []), Folder([9, 10], []) ]) subfolder2 = Folder([6, 7], []) folder = Folder([1, 2, 3], [subfolder1, subfolder2]) folder.printAllDocuments() captured = capsys.readouterr() expected_output = \\"1n2n3n-4n-5n--8n--9n--10n-6n-7n\\" assert captured.out == expected_output","solution":"class Folder: def __init__(self, docs, subs): self._docs = docs self._subs = subs def getAllDocuments(self): result = [] self._collect_docs(self, result) return result def _collect_docs(self, folder, result): result.extend(folder._docs) for sub in folder._subs: self._collect_docs(sub, result) def printAllDocuments(self): self._print_docs(self, 0) def _print_docs(self, folder, depth): prefix = '-' * depth for doc in folder._docs: print(f\\"{prefix}{doc}\\") for sub in folder._subs: self._print_docs(sub, depth + 1)"},{"question":"def max_unique_stones(N: int, X: int, type_values: List[int]) -> int: Determines the maximum number of unique stone types Jim can collect without exceeding the total type value X. >>> max_unique_stones(5, 10, [1, 3, 3, 2, 6]) 4 >>> max_unique_stones(4, 7, [4, 2, 1, 5]) 3 >>> max_unique_stones(1, 10, [10]) 1 >>> max_unique_stones(5, 5, [6, 7, 8, 9, 10]) 0 >>> max_unique_stones(3, 15, [5, 5, 5]) 3 >>> max_unique_stones(6, 11, [1, 2, 2, 3, 3, 3]) 5 >>> max_unique_stones(3, 10000, [100, 200, 300]) 3 >>> max_unique_stones(1, 1, [1]) 1","solution":"def max_unique_stones(N, X, type_values): Determines the maximum number of unique stone types Jim can collect without exceeding the total type value X. type_values.sort() total_value = 0 unique_stones = 0 for value in type_values: if total_value + value <= X: total_value += value unique_stones += 1 else: break return unique_stones # Example usage: # print(max_unique_stones(5, 10, [1, 3, 3, 2, 6])) # Output: 4"},{"question":"def reverse_words(sentence: str) -> str: Reverses the words in a given sentence. Args: sentence (str): The sentence to be reversed. Returns: str: The sentence with the words in reverse order. Examples: >>> reverse_words(\\"Hello World\\") 'World Hello' >>> reverse_words(\\"The quick brown fox jumps over the lazy dog\\") 'dog lazy the over jumps fox brown quick The' >>> reverse_words(\\"Python\\") 'Python' >>> reverse_words(\\" this sentence has extra spaces \\") 'spaces extra has sentence this' >>> reverse_words(\\"\\") '' >>> reverse_words(\\"Hello, world!\\") 'world! Hello,'","solution":"def reverse_words(sentence): Reverses the words in a given sentence. Args: sentence (str): The sentence to be reversed. Returns: str: The sentence with the words in reverse order. words = sentence.split() reversed_words = ' '.join(reversed(words)) return reversed_words"},{"question":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): Insert a value into the Binary Search Tree (BST) if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def build_bst(arr): Build a BST from the given array of integers if not arr: return None root = TreeNode(arr[0]) for val in arr[1:]: root = insert_into_bst(root, val) return root def sum_of_nodes_greater_or_equal_to_k(root, k): Calculate the sum of all nodes in the BST which are greater than or equal to the threshold value k if not root: return 0 if root.value < k: return sum_of_nodes_greater_or_equal_to_k(root.right, k) return root.value + sum_of_nodes_greater_or_equal_to_k(root.left, k) + sum_of_nodes_greater_or_equal_to_k(root.right, k) def solve(n, arr, k): Construct the BST from the given array elements and find the sum of all nodes which are greater than or equal to k. >>> solve(5, [10, 5, 15, 3, 7], 7) 32 >>> solve(3, [5, 10, 15], 5) 30 >>> solve(3, [1, 2, 3], 10) 0 >>> solve(6, [20, 15, 25, 10, 30, 5], 17) 75 >>> solve(1, [10], 10) 10 >>> solve(1, [10], 20) 0 >>> solve(1, [10], 5) 10 bst = build_bst(arr) return sum_of_nodes_greater_or_equal_to_k(bst, k)","solution":"class TreeNode: def __init__(self, value): self.value = value self.left = None self.right = None def insert_into_bst(root, value): if root is None: return TreeNode(value) if value < root.value: root.left = insert_into_bst(root.left, value) else: root.right = insert_into_bst(root.right, value) return root def build_bst(arr): if not arr: return None root = TreeNode(arr[0]) for val in arr[1:]: insert_into_bst(root, val) return root def sum_of_nodes_greater_or_equal_to_k(root, k): if not root: return 0 if root.value < k: return sum_of_nodes_greater_or_equal_to_k(root.right, k) return root.value + sum_of_nodes_greater_or_equal_to_k(root.left, k) + sum_of_nodes_greater_or_equal_to_k(root.right, k) def solve(n, arr, k): bst = build_bst(arr) return sum_of_nodes_greater_or_equal_to_k(bst, k)"},{"question":"def decode_message(encoded_str: str) -> str: Decodes the encoded string by shifting each letter to the previous one in the alphabet. Non-alphabetical characters remain unchanged. >>> decode_message(\\"ifmmp\\") == \\"hello\\" >>> decode_message(\\"Tv!mfu't!ibwf!b!qbsuz\\") == \\"Su!let's!have!a!party\\" >>> decode_message(\\"UIJT!JT!B!UFTU\\") == \\"THIS!IS!A!TEST\\" >>> decode_message(\\"uijt!jt!b!uftu\\") == \\"this!is!a!test\\" >>> decode_message(\\"Uijt!JT!B!Uftu\\") == \\"This!IS!A!Test\\" >>> decode_message(\\"uijt123!JT!b!uftu456\\") == \\"this123!IS!a!test456\\" >>> decode_message(\\"zab\\") == \\"yza\\" >>> decode_message(\\"ZAB\\") == \\"YZA\\"","solution":"def decode_message(encoded_str): Decodes the encoded string by shifting each letter to the previous one in the alphabet. Non-alphabetical characters remain unchanged. Parameters: encoded_str (str): The encoded message Returns: str: The decoded message decoded_str = [] for char in encoded_str: if 'a' <= char <= 'z': decoded_str.append(chr((ord(char) - ord('a') - 1) % 26 + ord('a'))) elif 'A' <= char <= 'Z': decoded_str.append(chr((ord(char) - ord('A') - 1) % 26 + ord('A'))) else: decoded_str.append(char) return ''.join(decoded_str)"},{"question":"from typing import List def findKthLargest(nums: List[int], k: int) -> int: Given an integer array \`nums\` and an integer \`k\`, find the \`k\`-th largest element in the sorted order. >>> findKthLargest([3, 2, 1, 5, 6, 4], 2) 5 >>> findKthLargest([3, 2, 3, 1, 2, 4, 5, 5, 6], 4) 4 >>> findKthLargest([1, 1, 1, 1, 1], 3) 1 >>> findKthLargest([5, 3, 8, 4, 2], 5) 2 >>> findKthLargest([10], 1) 10 >>> findKthLargest([1, 2, 3, 4, 5], 1) 5 >>> findKthLargest([5, 4, 3, 2, 1], 3) 3","solution":"import heapq def findKthLargest(nums, k): Returns the k-th largest element in the sorted order of the array. # Use a min-heap to keep track of the largest k elements min_heap = nums[:k] heapq.heapify(min_heap) for num in nums[k:]: if num > min_heap[0]: heapq.heappushpop(min_heap, num) # The root of the heap will be the k-th largest element return min_heap[0]"},{"question":"def min_operations_to_reduce(N: int) -> int: Returns the minimum number of operations required to reduce a sequence of N integers to a single integer. Args: N (int): the length of the sequence Returns: int: the minimum number of operations >>> min_operations_to_reduce(1) 0 >>> min_operations_to_reduce(3) 2","solution":"def min_operations_to_reduce(N): Returns the minimum number of operations required to reduce a sequence of N integers to a single integer. Args: N (int): the length of the sequence Returns: int: the minimum number of operations if N <= 1: return 0 else: return N - 1"},{"question":"def determine_level_order(n: int, difficulties: List[int]) -> List[int]: Determines the order of levels based on difficulty ratings from easiest to hardest. Parameters: - n: int : Total number of levels - difficulties: List[int] : A list of difficulty ratings Returns: - List[int] : A list of 1-based indices representing the levels in the order they should be completed. >>> determine_level_order(5, [3, 1, 2, 5, 4]) [2, 3, 1, 5, 4] >>> determine_level_order(4, [2, 2, 3, 1]) [4, 1, 2, 3]","solution":"def determine_level_order(n, difficulties): Determines the order of levels based on difficulty ratings from easiest to hardest. Parameters: - n: int : Total number of levels - difficulties: List[int] : A list of difficulty ratings Returns: - List[int] : A list of 1-based indices representing the levels in the order they should be completed. # Create a list of (difficulty, index) tuples indexed_difficulties = [(difficulty, idx + 1) for idx, difficulty in enumerate(difficulties)] # Sort the list by the difficulty indexed_difficulties.sort() # Extract the indices in the sorted order sorted_indices = [idx for _, idx in indexed_difficulties] return sorted_indices"},{"question":"def count_distinct_l_terraces(a: int, b: int, c: int) -> int: Returns the number of distinct L-terraces that can be formed using the given dimensions a, b, and c. >>> count_distinct_l_terraces(3, 3, 3) 0 >>> count_distinct_l_terraces(1, 2, 3) 1 >>> count_distinct_l_terraces(2, 3, 3) 1 >>> count_distinct_l_terraces(2, 2, 3) 1 >>> count_distinct_l_terraces(3, 2, 2) 1 >>> count_distinct_l_terraces(2, 3, 4) 1 >>> count_distinct_l_terraces(5, 6, 7) 1 >>> count_distinct_l_terraces(1, 1, 2) 1 >>> count_distinct_l_terraces(1, 2, 2) 1","solution":"def count_distinct_l_terraces(a, b, c): Returns the number of distinct L-terraces that can be formed using the given dimensions a, b, and c. if a == b == c: return 0 if a == c or a == b or b == c: return 1 return 1"},{"question":"def count_nodes(edges): Counts the number of nodes in a binary tree given its edges. Args: edges (list of tuple): Each tuple contains a pair of integers representing a directed edge. Returns: int: The number of nodes in the binary tree. Examples: >>> count_nodes([(1, 2), (1, 3), (2, 4), (2, 5)]) 5 >>> count_nodes([(1, 2), (1, 3), (3, 4)]) 4 >>> count_nodes([]) 0 >>> count_nodes([(1, 2)]) 2 >>> count_nodes([(1, 2), (2, 3)]) 3 >>> count_nodes([(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (6, 8), (6, 9)]) 9","solution":"def count_nodes(edges): Counts the number of nodes in a binary tree given its edges. Args: edges (list of tuple): Each tuple contains a pair of integers representing a directed edge. Returns: int: The number of nodes in the binary tree. # Using set to avoid counting duplicate nodes nodes = set() for edge in edges: parent, child = edge nodes.add(parent) nodes.add(child) return len(nodes)"},{"question":"from typing import List def spiral_sum(matrix: List[List[int]]) -> int: This function takes a matrix and returns the sum of its elements in spiral order. >>> spiral_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> spiral_sum([[1, 2, 3, 4], [5, 6, 7, 8]]) 36 pass def process_matrices(input_string: str) -> List[int]: This function processes multi-dataset input and returns a list of spiral sums for each dataset. >>> process_matrices(\\"3 3n1 2 3n4 5 6n7 8 9n2 4n1 2 3 4n5 6 7 8n0 0\\") [45, 36] >>> process_matrices(\\"2 2n1 2n3 4n0 0\\") [10] pass","solution":"def spiral_sum(matrix): This function takes a matrix and returns the sum of its elements in spiral order. if not matrix or not matrix[0]: return 0 row_start, row_end = 0, len(matrix) col_start, col_end = 0, len(matrix[0]) spiral_order = [] while row_start < row_end and col_start < col_end: # Traverse Right for col in range(col_start, col_end): spiral_order.append(matrix[row_start][col]) row_start += 1 # Traverse Down for row in range(row_start, row_end): spiral_order.append(matrix[row][col_end - 1]) col_end -= 1 if row_start < row_end: # Traverse Left for col in range(col_end - 1, col_start - 1, -1): spiral_order.append(matrix[row_end - 1][col]) row_end -= 1 if col_start < col_end: # Traverse Up for row in range(row_end - 1, row_start - 1, -1): spiral_order.append(matrix[row][col_start]) col_start += 1 return sum(spiral_order) def process_matrices(input_string): This function processes multi-dataset input and returns a list of spiral sums for each dataset. lines = input_string.strip().split('n') i = 0 results = [] while i < len(lines): n, m = map(int, lines[i].split()) if n == 0 and m == 0: break matrix = [] for j in range(n): matrix.append(list(map(int, lines[i + 1 + j].split()))) results.append(spiral_sum(matrix)) i += n + 1 return results"},{"question":"def longest_valid_parentheses(s: str) -> int: Returns the length of the longest valid (well-formed) parentheses substring. >>> longest_valid_parentheses(\\"(()\\") 2 >>> longest_valid_parentheses(\\")()())\\") 4 >>> longest_valid_parentheses(\\"()(()\\") 2 >>> longest_valid_parentheses(\\"\\") 0 >>> longest_valid_parentheses(\\")(\\") 0","solution":"def longest_valid_parentheses(s): Returns the length of the longest valid (well-formed) parentheses substring. max_len = 0 stack = [-1] # Initialize stack with a base index for i, char in enumerate(s): if char == '(': stack.append(i) else: # char == ')' stack.pop() if stack: max_len = max(max_len, i - stack[-1]) else: stack.append(i) return max_len"},{"question":"def can_sum_to_k_with_three_elements(n: int, k: int, arr: List[int]) -> str: Determine if there are three elements in the list whose sum is equal to the target number k. :param n: int - the number of elements in the list :param k: int - the target sum :param arr: list[int] - the list of integers :return: str - \\"YES\\" if there are three elements whose sum is k, otherwise \\"NO\\" >>> can_sum_to_k_with_three_elements(5, 6, [1, 2, 3, 4, 5]) \\"YES\\" >>> can_sum_to_k_with_three_elements(4, 10, [1, 2, 3, 8]) \\"NO\\"","solution":"def can_sum_to_k_with_three_elements(n, k, arr): Determine if there are three elements in the list whose sum is equal to the target number k. :param n: int - the number of elements in the list :param k: int - the target sum :param arr: list[int] - the list of integers :return: str - \\"YES\\" if there are three elements whose sum is k, otherwise \\"NO\\" arr.sort() for i in range(n - 2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == k: return \\"YES\\" elif current_sum < k: left += 1 else: right -= 1 return \\"NO\\""},{"question":"def max_productivity_segment(N, productivity_scores): Given the productivity scores of employees in a department, find the maximum sum of productivity scores for any continuous segment of employees. :param N: int, number of employees :param productivity_scores: list of int, productivity scores of employees :return: int, maximum sum of productivity scores for any continuous segment >>> max_productivity_segment(5, [1, -2, 3, 10, -4]) 13 >>> max_productivity_segment(8, [-2, -3, 4, -1, -2, 1, 5, -3]) 7 >>> max_productivity_segment(3, [-1, -2, -3]) -1 def test_max_productivity_segment(): assert max_productivity_segment(5, [1, -2, 3, 10, -4]) == 13 assert max_productivity_segment(8, [-2, -3, 4, -1, -2, 1, 5, -3]) == 7 assert max_productivity_segment(3, [-1, -2, -3]) == -1 assert max_productivity_segment(1, [5]) == 5 assert max_productivity_segment(4, [2, 3, -2, -1]) == 5 assert max_productivity_segment(6, [-2, -3, -1, -5, -1, -2]) == -1 assert max_productivity_segment(5, [1, 2, 3, 4, 5]) == 15 assert max_productivity_segment(7, [-5, 1, 2, 3, -1, 2, -1]) == 7 if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def max_productivity_segment(N, productivity_scores): Given the productivity scores of employees in a department, find the maximum sum of productivity scores for any continuous segment of employees. :param N: int, number of employees :param productivity_scores: list of int, productivity scores of employees :return: int, maximum sum of productivity scores for any continuous segment if not productivity_scores or N == 0: return 0 max_so_far = productivity_scores[0] current_max = productivity_scores[0] for i in range(1, N): current_max = max(productivity_scores[i], current_max + productivity_scores[i]) max_so_far = max(max_so_far, current_max) return max_so_far"},{"question":"def num_blocks_and_largest_block(m, n, grid): You are given a rectangular grid representing a city map where '1' indicates a building and '0' indicates an empty lot. Buildings can only connect vertically or horizontally to form a block. Write a program to find the number of distinct blocks of buildings and the size of the largest block. >>> num_blocks_and_largest_block(5, 5, [list(row) for row in ['11000', '11011', '00011', '00000', '10001']]) (4, 4) >>> num_blocks_and_largest_block(1, 5, [list(row) for row in ['11011']]) (2, 2) >>> num_blocks_and_largest_block(4, 1, [list(row) for row in ['1', '0', '1', '1']]) (2, 2) >>> num_blocks_and_largest_block(3, 3, [list(row) for row in ['111', '111', '111']]) (1, 9) >>> num_blocks_and_largest_block(3, 3, [list(row) for row in ['100', '010', '001']]) (3, 1) >>> num_blocks_and_largest_block(3, 3, [list(row) for row in ['000', '000', '000']]) (0, 0) >>> num_blocks_and_largest_block(6, 5, [list(row) for row in ['11100', '01000', '01011', '00011', '00000', '00110']]) (3, 5)","solution":"def num_blocks_and_largest_block(m, n, grid): def dfs(x, y): if x < 0 or x >= m or y < 0 or y >= n or grid[x][y] == '0': return 0 grid[x][y] = '0' # Mark the cell as visited by setting it to '0' size = 1 # Each cell counts as part of the block size += dfs(x-1, y) size += dfs(x+1, y) size += dfs(x, y-1) size += dfs(x, y+1) return size num_blocks = 0 largest_block = 0 for i in range(m): for j in range(n): if grid[i][j] == '1': num_blocks += 1 block_size = dfs(i, j) largest_block = max(largest_block, block_size) return num_blocks, largest_block"},{"question":"def calculate_rounds(tournaments: List[int]) -> List[int]: Calculate the number of rounds required to determine the champion for each tournament. >>> calculate_rounds([4, 8, 16]) [2, 3, 4] >>> calculate_rounds([2, 1024, 2048]) [1, 10, 11] >>> calculate_rounds([2]) [1] >>> calculate_rounds([32, 64, 128, 256]) [5, 6, 7, 8] >>> calculate_rounds([512, 8192, 16384]) [9, 13, 14]","solution":"def calculate_rounds(tournaments): results = [] for participants in tournaments: rounds = 0 while participants > 1: participants //= 2 rounds += 1 results.append(rounds) return results"},{"question":"def can_travel_all_cities(n: int, m: int, roads: List[Tuple[int, int]]) -> str: Determines if it is possible to travel between any pair of cities using given roads. >>> can_travel_all_cities(3, 3, [(1, 2), (2, 3), (3, 1)]) 'Connected' >>> can_travel_all_cities(4, 2, [(1, 2), (3, 4)]) 'Not Connected'","solution":"def can_travel_all_cities(n, m, roads): from collections import defaultdict, deque if n == 1: return \\"Connected\\" graph = defaultdict(list) for a, b in roads: graph[a].append(b) graph[b].append(a) visited = set() queue = deque([1]) while queue: city = queue.popleft() if city not in visited: visited.add(city) for neighbor in graph[city]: if neighbor not in visited: queue.append(neighbor) if len(visited) == n: return \\"Connected\\" else: return \\"Not Connected\\" def from_input_string(input_string): lines = input_string.strip().split('n') n, m = map(int, lines[0].split()) roads = [tuple(map(int, line.split())) for line in lines[1:]] return n, m, roads def from_output_string(output_string): return output_string.strip() def to_input_string(inputs): n, m, roads = inputs return f\\"{n} {m}n\\" + 'n'.join(f\\"{a} {b}\\" for a, b in roads) def to_output_string(output): return output"},{"question":"def minimum_distance(n: int, m: int, lanes: List[List[int]]) -> int: Determine the minimum distance required to connect all warehouses into a single connected network. :param n: Number of warehouses :param m: Number of direct lanes :param lanes: List of lanes with each lane represented as [u, v, w] :return: Minimum total distance if possible, otherwise -1 >>> minimum_distance(4, 5, [[0, 1, 1], [1, 2, 2], [2, 3, 1], [0, 3, 4], [0, 2, 3]]) == 4 >>> minimum_distance(3, 1, [[0, 1, 2]]) == -1 def test_minimum_distance_case_1(): N = 4 M = 5 lanes = [ [0, 1, 1], [1, 2, 2], [2, 3, 1], [0, 3, 4], [0, 2, 3] ] assert minimum_distance(N, M, lanes) == 4 def test_minimum_distance_case_2(): N = 3 M = 1 lanes = [ [0, 1, 2] ] assert minimum_distance(N, M, lanes) == -1 def test_minimum_distance_no_edges(): N = 3 M = 0 lanes = [] assert minimum_distance(N, M, lanes) == -1 def test_minimum_distance_single_warehouse(): N = 1 M = 0 lanes = [] assert minimum_distance(N, M, lanes) == 0 def test_minimum_distance_multiple_disconnected_clusters(): N = 4 M = 2 lanes = [ [0, 1, 1], [2, 3, 1] ] assert minimum_distance(N, M, lanes) == -1","solution":"def find(parent, i): if parent[i] == i: return i else: parent[i] = find(parent, parent[i]) return parent[i] def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def kruskal(n, edges): result = [] i = 0 e = 0 edges = sorted(edges, key=lambda item: item[2]) parent = [] rank = [] for node in range(n): parent.append(node) rank.append(0) while e < n - 1 and i < len(edges): u, v, w = edges[i] i += 1 x = find(parent, u) y = find(parent, v) if x != y: e += 1 result.append((u, v, w)) union(parent, rank, x, y) if len(result) != n - 1: return -1 minimum_cost = 0 for u, v, weight in result: minimum_cost += weight return minimum_cost def minimum_distance(n, m, lanes): edges = [] for lane in lanes: u, v, w = lane edges.append((u, v, w)) return kruskal(n, edges)"},{"question":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: Determine the maximum number of non-overlapping tasks that can be scheduled from a list of given tasks. Each task is represented as a tuple (start_time, duration). Args: tasks (List[Tuple[int, int]]): The list of tasks where each task is a tuple of (start_time, duration). Returns: int: The maximum number of non-overlapping tasks. Example: >>> max_non_overlapping_tasks([(1, 2), (3, 2), (4, 1), (7, 3)]) 3 >>> max_non_overlapping_tasks([(0, 3), (2, 2), (4, 3)]) 2","solution":"from typing import List, Tuple def max_non_overlapping_tasks(tasks: List[Tuple[int, int]]) -> int: # Sort tasks based on end time (start_time + duration) tasks.sort(key=lambda x: x[0] + x[1]) count = 0 end_time = -1 for start_time, duration in tasks: if start_time >= end_time: count += 1 end_time = start_time + duration return count"},{"question":"from typing import List, Tuple def max_non_overlapping_contests(n: int, q: int, contests: List[Tuple[int, int]], queries: List[Tuple[int, int]]) -> List[int]: Determines the maximum number of non-overlapping coding contests Sara can participate in for given periods. >>> max_non_overlapping_contests(5, 3, [(10, 20), (15, 25), (30, 40), (35, 45), (50, 60)], [(10, 45), (20, 40), (1, 365)]) [2, 1, 3] >>> max_non_overlapping_contests(2, 2, [(10, 15), (20, 25)], [(5, 20), (10, 25)]) [1, 2] from solution import max_non_overlapping_contests def test_example_case(): n = 5 q = 3 contests = [(10, 20), (15, 25), (30, 40), (35, 45), (50, 60)] queries = [(10, 45), (20, 40), (1, 365)] assert max_non_overlapping_contests(n, q, contests, queries) == [2, 1, 3] def test_no_contests(): n = 0 q = 1 contests = [] queries = [(1, 365)] assert max_non_overlapping_contests(n, q, contests, queries) == [0] def test_single_contest_within_query_period(): n = 1 q = 1 contests = [(10, 20)] queries = [(1, 365)] assert max_non_overlapping_contests(n, q, contests, queries) == [1] def test_overlapping_contests(): n = 4 q = 1 contests = [(1, 5), (2, 6), (5, 10), (11, 15)] queries = [(1, 15)] assert max_non_overlapping_contests(n, q, contests, queries) == [2] def test_multiple_queries(): n = 5 q = 2 contests = [(1, 3), (4, 6), (7, 10), (8, 12), (13, 15)] queries = [(1, 10), (7, 15)] assert max_non_overlapping_contests(n, q, contests, queries) == [3, 2]","solution":"def max_non_overlapping_contests(n, q, contests, queries): Determines the maximum number of non-overlapping coding contests Sara can participate in for given periods. results = [] for a, b in queries: # Filter contests within the period [a, b] filtered_contests = [contest for contest in contests if contest[0] >= a and contest[1] <= b] # Sort contests by end date filtered_contests.sort(key=lambda x: x[1]) # Greedy algorithm to find maximum number of non-overlapping contests count = 0 last_end_time = -1 for start, end in filtered_contests: if start > last_end_time: count += 1 last_end_time = end results.append(count) return results"},{"question":"def max_profit(prices: List[int]) -> int: Returns the maximum profit with at most two transactions. :param prices: List[int] :return: int Examples: >>> max_profit([3,3,5,0,0,3,1,4]) 6 >>> max_profit([1,2,3,4,5]) 4 >>> max_profit([7,6,4,3,1]) 0","solution":"def max_profit(prices): Returns the maximum profit with at most two transactions. :param prices: List[int] :return: int if not prices: return 0 n = len(prices) if n == 1: return 0 # First transaction profits first_buy = float('-inf') first_sell = 0 second_buy = float('-inf') second_sell = 0 for price in prices: first_buy = max(first_buy, -price) first_sell = max(first_sell, first_buy + price) second_buy = max(second_buy, first_sell - price) second_sell = max(second_sell, second_buy + price) return second_sell"},{"question":"def total_water_usage(h: int, t: int, usage_logs: List[List[int]], queries: List[Tuple[int, int, int]]) -> List[int]: Compute total water usage for specified households during specific queried intervals. h: int - number of households t: int - number of time intervals usage_logs: List of Lists - water usage logs for each household queries: List of Tuples - each tuple contains three integers a, b, and c representing household and intervals Returns: List of integers - total water usage for each query >>> total_water_usage(3, 5, [[10, 20, 30, 40, 50], [5, 5, 5, 5, 5], [1, 2, 1, 2, 1]], [(1, 1, 3), (2, 2, 4), (3, 1, 5), (1, 5, 5), (2, 3, 3)]) [60, 15, 7, 50, 5] >>> total_water_usage(2, 3, [[3, 3, 3], [2, 2, 2]], [(1, 1, 1), (2, 1, 2), (1, 1, 3), (2, 3, 3), (2, 2, 3)]) [3, 4, 9, 2, 4] from solution import total_water_usage def test_case_1(): h = 3 t = 5 usage_logs = [ [10, 20, 30, 40, 50], [5, 5, 5, 5, 5], [1, 2, 1, 2, 1] ] queries = [(1, 1, 3), (2, 2, 4), (3, 1, 5), (1, 5, 5), (2, 3, 3)] expected_outputs = [60, 15, 7, 50, 5] assert total_water_usage(h, t, usage_logs, queries) == expected_outputs def test_case_2(): h = 1 t = 5 usage_logs = [ [1, 1, 1, 1, 1] ] queries = [(1, 1, 5), (1, 2, 4), (1, 3, 3)] expected_outputs = [5, 3, 1] assert total_water_usage(h, t, usage_logs, queries) == expected_outputs def test_case_3(): h = 2 t = 3 usage_logs = [ [3, 3, 3], [2, 2, 2] ] queries = [(1, 1, 1), (2, 1, 2), (1, 1, 3), (2, 3, 3), (2, 2, 3)] expected_outputs = [3, 4, 9, 2, 4] assert total_water_usage(h, t, usage_logs, queries) == expected_outputs def test_case_4(): h = 2 t = 5 usage_logs = [ [1, 2, 3, 4, 5], [5, 4, 3, 2, 1] ] queries = [(1, 1, 5), (2, 1, 5), (1, 2, 4), (2, 2, 4)] expected_outputs = [15, 15, 9, 9] assert total_water_usage(h, t, usage_logs, queries) == expected_outputs","solution":"def total_water_usage(h, t, usage_logs, queries): Compute total water usage for specified households during specific queried intervals. h: int - number of households t: int - number of time intervals usage_logs: List of Lists - water usage logs for each household queries: List of Tuples - each tuple contains three integers a, b, and c representing household and intervals Returns: List of integers - total water usage for each query results = [] for a, b, c in queries: total_usage = sum(usage_logs[a-1][b-1:c]) results.append(total_usage) return results"},{"question":"def island_perimeter(grid): Calculate the perimeter of the island in the given grid. Parameters: grid (List[List[int]]): A 2D list representing the map of the island. Returns: int: The perimeter of the island. Examples: >>> island_perimeter([ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 1, 0, 0] ... ]) 16 >>> island_perimeter([ ... [1, 1], ... [1, 1] ... ]) 8 >>> island_perimeter([ ... [1, 0], ... [1, 1], ... [0, 1] ... ]) 10","solution":"def island_perimeter(grid): Calculate the perimeter of the island in the given grid. if not grid or not grid[0]: return 0 m, n = len(grid), len(grid[0]) perimeter = 0 for i in range(m): for j in range(n): if grid[i][j] == 1: perimeter += 4 # Start with assuming all 4 sides are contributing to the perimeter if i > 0 and grid[i-1][j] == 1: # Check the cell above perimeter -= 2 if j > 0 and grid[i][j-1] == 1: # Check the cell to the left perimeter -= 2 return perimeter"},{"question":"from typing import List, Tuple def rotate_matrix_90_clockwise(matrix: List[List[int]]) -> List[List[int]]: Rotates the given N x N matrix 90 degrees clockwise in-place. Args: matrix (List[List[int]]): The NxN matrix to rotate. Returns: List[List[int]]: The rotated NxN matrix. def process_test_cases(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[List[List[int]]]: Processes the test cases and returns the results of rotating each matrix 90 degrees clockwise. Args: T (int): The number of test cases. test_cases (List[Tuple[int, List[List[int]]]]): A list of tuples where each tuple contains an integer N and an NxN matrix. Returns: List[List[List[int]]]: A list of rotated matrices for each test case. def test_rotate_3x3_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] expected = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_clockwise(matrix) == expected def test_rotate_4x4_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] expected = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix_90_clockwise(matrix) == expected def test_process_test_cases(): T = 2 test_cases = [ (3, [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ]), (4, [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ]) ] expected_results = [ [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ], [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] ] assert process_test_cases(T, test_cases) == expected_results","solution":"def rotate_matrix_90_clockwise(matrix): Rotates the given N x N matrix 90 degrees clockwise in-place. N = len(matrix) for i in range(N // 2): for j in range(i, N - i - 1): temp = matrix[i][j] matrix[i][j] = matrix[N - j - 1][i] matrix[N - j - 1][i] = matrix[N - i - 1][N - j - 1] matrix[N - i - 1][N - j - 1] = matrix[j][N - i - 1] matrix[j][N - i - 1] = temp return matrix def process_test_cases(T, test_cases): results = [] for test_case in test_cases: N, matrix = test_case rotated_matrix = rotate_matrix_90_clockwise(matrix) results.append(rotated_matrix) return results"},{"question":"from typing import List def min_operations_to_palindrome(t: int, strings: List[str]) -> List[int]: Given a list of strings containing only 'a' and 'b', return the minimum number of operations needed to transform each string into a palindrome. Args: t (int): The number of test cases. strings (List[str]): A list of strings to be transformed into palindromes. Returns: List[int]: A list of integers indicating the minimum number of operations for each string. >>> min_operations_to_palindrome(3, [\\"abba\\", \\"abca\\", \\"bbbb\\"]) [0, 1, 0] >>> min_operations_to_palindrome(2, [\\"aaaa\\", \\"bbbb\\"]) [0, 0] >>> min_operations_to_palindrome(2, [\\"abcd\\", \\"aabb\\"]) [2, 2] >>> min_operations_to_palindrome(2, [\\"abab\\", \\"baba\\"]) [2, 2] >>> min_operations_to_palindrome(2, [\\"aa\\", \\"ab\\"]) [0, 1] >>> large_string = \\"a\\" * 50000 + \\"b\\" * 50000 >>> min_operations_to_palindrome(1, [large_string]) [50000] >>> min_operations_to_palindrome(1, [\\"abccba\\"]) [0] >>> min_operations_to_palindrome(1, [\\"abcdba\\"]) [1]","solution":"def min_operations_to_palindrome(t, strings): results = [] for s in strings: n = len(s) ops = 0 for i in range(n // 2): if s[i] != s[n - 1 - i]: ops += 1 results.append(ops) return results"},{"question":"def longest_unique_substring_length(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> longest_unique_substring_length(\\"abcabcbb\\") 3 >>> longest_unique_substring_length(\\"abcdef\\") 6 >>> longest_unique_substring_length(\\"aaaaaa\\") 1 >>> longest_unique_substring_length(\\"ababcdef\\") 6 >>> longest_unique_substring_length(\\"\\") 0 >>> longest_unique_substring_length(\\"a\\") 1 >>> longest_unique_substring_length(\\"aabcaabcde\\") 5","solution":"def longest_unique_substring_length(s): Returns the length of the longest substring with all unique characters. if not s: return 0 max_length = 0 start = 0 seen_chars = {} for end, char in enumerate(s): if char in seen_chars and seen_chars[char] >= start: start = seen_chars[char] + 1 seen_chars[char] = end max_length = max(max_length, end - start + 1) return max_length"},{"question":"def distribute_items(n, m, shelves, items): Checks if it's possible to distribute items across shelves without exceeding the shelves' capacities and provides the distribution if possible. Args: - n: number of shelves (int) - m: number of different item types (int) - shelves: a list of integers representing the capacities of the shelves - items: a list of integers representing the quantities of each type of item Returns: - If possible, returns a list of strings representing the distribution of items on each shelf. - If not possible, returns \\"Impossible\\". >>> distribute_items(3, 2, [10, 15, 12], [8, 14]) ['Possible', 'shelf_1: item_1 4, item_2 5', 'shelf_2: item_1 2, item_2 6', 'shelf_3: item_1 2, item_2 3'] >>> distribute_items(2, 2, [10, 10], [15, 10]) 'Impossible' >>> distribute_items(1, 1, [10], [10]) ['Possible', 'shelf_1: item_1 10']","solution":"def distribute_items(n, m, shelves, items): Checks if it's possible to distribute items across shelves without exceeding the shelves' capacities and provides the distribution if possible. Args: - n: number of shelves (int) - m: number of different item types (int) - shelves: a list of integers representing the capacities of the shelves - items: a list of integers representing the quantities of each type of item Returns: - If possible, returns a list of strings representing the distribution of items on each shelf. - If not possible, returns \\"Impossible\\". total_capacity = sum(shelves) total_items = sum(items) # Check if the total capacity is sufficient if total_items > total_capacity: return \\"Impossible\\" # Distribute items distribution = [[] for _ in range(n)] shelf_indexes = list(range(n)) for item_index in range(m): remaining_quantity = items[item_index] while remaining_quantity > 0: shelf_indexes.sort(key=lambda i: shelves[i]) for i in shelf_indexes: if shelves[i] > 0: take = min(remaining_quantity, shelves[i]) distribution[i].append(f\\"item_{item_index + 1} {take}\\") shelves[i] -= take remaining_quantity -= take if remaining_quantity == 0: break if shelves[i] == 0: shelf_indexes.remove(i) break if not shelf_indexes: return \\"Impossible\\" output = [\\"Possible\\"] for i, items_on_shelf in enumerate(distribution): output.append(f\\"shelf_{i + 1}: \\" + \\", \\".join(items_on_shelf)) return output"},{"question":"def calculate_total_scores(input_data: List[str]) -> List[int]: This function processes multiple contest datasets and returns the sum of scores for each dataset. :param input_data: List of strings, where each string represents a line of input :return: List of integers, each integer is the total score of a dataset Example: >>> calculate_total_scores([\\"3\\", \\"50\\", \\"60\\", \\"40\\", \\"2\\", \\"80\\", \\"90\\", \\"4\\", \\"30\\", \\"20\\", \\"10\\", \\"40\\", \\"0\\"]) [150, 170, 100] >>> calculate_total_scores([\\"1\\", \\"100\\", \\"1\\", \\"200\\", \\"0\\"]) [100, 200]","solution":"def calculate_total_scores(input_data): This function processes multiple contest datasets and returns the sum of scores for each dataset. :param input_data: List of strings, where each string represents a line of input :return: List of integers, each integer is the total score of a dataset results = [] index = 0 while index < len(input_data): n = int(input_data[index]) if n == 0: break index += 1 total_score = 0 for _ in range(n): total_score += int(input_data[index]) index += 1 results.append(total_score) return results"},{"question":"def categorize_items(n: int, items: List[Tuple[str, float]]) -> List[str]: Design a warehouse management system that automatically categorizes incoming items based on their descriptions. Items with a weight greater than or equal to 50 kilograms are considered \\"Heavy-duty\\". Items with weight less than 50 kilograms are considered \\"Standard\\". >>> categorize_items(3, [(\\"hammer\\", 45.5), (\\"anvil\\", 150.0), (\\"nail\\", 0.3)]) == [\\"Standard-hammer\\", \\"Heavy-duty-anvil\\", \\"Standard-nail\\"] >>> categorize_items(1, [(\\"bulldozer\\", 120.5)]) == [\\"Heavy-duty-bulldozer\\"] >>> categorize_items(1, [(\\"wrench\\", 15.0)]) == [\\"Standard-wrench\\"] >>> categorize_items(2, [(\\"boundary_heavy\\", 50.0), (\\"boundary_standard\\", 49.9)]) == [\\"Heavy-duty-boundary_heavy\\", \\"Standard-boundary_standard\\"] >>> categorize_items(2, [(\\"lightest\\", 0.0), (\\"heaviest\\", 1000.0)]) == [\\"Standard-lightest\\", \\"Heavy-duty-heaviest\\"]","solution":"def categorize_items(n, items): categorized_items = [] for name, weight in items: if weight >= 50: categorized_items.append(f\\"Heavy-duty-{name}\\") else: categorized_items.append(f\\"Standard-{name}\\") return categorized_items # Example usage: # inputs = [(hammer, 45.5), (anvil, 150.0), (nail, 0.3)] # categorize_items(3, inputs)"},{"question":"def min_operations(n: int) -> int: Returns the minimum number of operations required to transform n to 1. >>> min_operations(2) 1 >>> min_operations(3) 2 def process_test_cases(test_cases: List[int]) -> List[int]: Processes a list of test cases and returns the results as a list. >>> process_test_cases([2, 3]) [1, 2] >>> process_test_cases([4, 7, 8]) [2, 4, 3]","solution":"def min_operations(n): Returns the minimum number of operations required to transform n to 1. operations = 0 while n > 1: if n % 2 == 0: n //= 2 else: n -= 1 operations += 1 return operations def process_test_cases(test_cases): Processes a list of test cases and returns the results as a list. results = [] for case in test_cases: results.append(min_operations(case)) return results"},{"question":"def most_frequent_word(text: str) -> str: Analyze the frequency of words in a given text and output the most frequent word along with its count. If there are multiple words with the same maximum frequency, output the lexicographically smallest word. Parameters: text (str): A single line of text containing lowercase letters and spaces. Returns: str: The most frequent word and its count separated by a space. >>> most_frequent_word(\\"the quick brown fox jumps over the lazy dog the dog was not so lazy\\") 'the 3' >>> most_frequent_word(\\"word\\") 'word 1' >>> most_frequent_word(\\"a b c a b\\") 'a 2' >>> most_frequent_word(\\"one two three four five\\") 'five 1' >>> most_frequent_word(\\"apple bat apple bat cat\\") 'apple 2' >>> most_frequent_word(\\"a a a b b c c c c d d d d d\\") 'd 5'","solution":"def most_frequent_word(text): from collections import Counter # Split text into words words = text.split() # Count the frequency of each word word_counts = Counter(words) # Find the maximum frequency max_freq = max(word_counts.values()) # Collect words that have the maximum frequency most_frequent_words = [word for word, count in word_counts.items() if count == max_freq] # Find the lexicographically smallest word among the most frequent words result_word = min(most_frequent_words) # Return the result as \\"word count\\" return f\\"{result_word} {word_counts[result_word]}\\""},{"question":"def max_total_difficulty(n: int, k: int, difficulties: List[int]) -> int: Find the maximum total difficulty of k contiguous segments. Parameters: n (int): Number of segments in the trail. k (int): Number of contiguous segments Jessica wants to cover. difficulties (list of int): Difficulty ratings of the segments. Returns: int: Maximum total difficulty of k contiguous segments. Example: >>> max_total_difficulty(5, 2, [1, 3, 2, 5, 1]) 7 >>> max_total_difficulty(8, 3, [4, 2, 1, 6, 5, 3, 8, 2]) 16","solution":"def max_total_difficulty(n, k, difficulties): Find the maximum total difficulty of k contiguous segments. Parameters: n (int): Number of segments in the trail. k (int): Number of contiguous segments Jessica wants to cover. difficulties (list of int): Difficulty ratings of the segments. Returns: int: Maximum total difficulty of k contiguous segments. # Calculate the initial window sum of the first \`k\` elements current_sum = sum(difficulties[:k]) max_sum = current_sum # Slide the window across the array for i in range(k, n): # Subtract the element that is leaving the window and add the new element current_sum += difficulties[i] - difficulties[i - k] # Update max_sum if we get a higher sum if current_sum > max_sum: max_sum = current_sum return max_sum # Example usage: n, k = 5, 2 difficulties = [1, 3, 2, 5, 1] print(max_total_difficulty(n, k, difficulties)) # Output should be 7"},{"question":"def is_possible_to_empty_array(q: int, test_cases: list) -> list: Determine if it is possible to empty the array by removing subarrays of length 'k' in each move. Parameters: q (int): Number of test cases. test_cases (list): List of tuples (n, k, nums) for each test case. Returns: list: List of results, \\"YES\\" or \\"NO\\" for each test case. Example: >>> q = 4 >>> test_cases = [ ... (6, 3, [1, 2, 3, 4, 5, 6]), ... (5, 2, [1, 2, 3, 4, 5]), ... (3, 1, [1, 2, 3]), ... (4, 2, [4, 3, 2, 1]) ... ] >>> is_possible_to_empty_array(q, test_cases) [\\"YES\\", \\"NO\\", \\"YES\\", \\"YES\\"]","solution":"def is_possible_to_empty_array(q, test_cases): Function to determine if it is possible to empty the array by removing subarrays of length 'k' in each move. Parameters: q (int): Number of test cases test_cases (list): List of tuples (n, k, nums) for each test case. Returns: list: List of results, \\"YES\\" or \\"NO\\" for each test case. results = [] for n, k, nums in test_cases: if n % k == 0: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def max_difference(arr: List[int]) -> int: Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If no such elements exist, return -1. >>> max_difference([7, 1, 5, 3, 6, 4]) 5 >>> max_difference([5, 4, 3, 2, 1]) -1 >>> max_difference([5]) -1 >>> max_difference([1, 2]) 1 >>> max_difference([2, 1]) -1 >>> max_difference([10, 3, 1, 9, 4, 7, 8, 11, 2]) 10 >>> max_difference([2, 2, 2, 2, 2]) -1 >>> max_difference([1, 4, 2, 6, 3, 7, 5, 8]) 7 >>> max_difference([-2, -1, 0, 1, 2]) 4","solution":"def max_difference(arr): Returns the maximum difference between any two elements such that the larger element comes after the smaller element. If no such elements exist, return -1. if len(arr) < 2: return -1 min_element = arr[0] max_diff = -1 for i in range(1, len(arr)): if arr[i] > min_element: max_diff = max(max_diff, arr[i] - min_element) min_element = min(min_element, arr[i]) return max_diff"},{"question":"def longest_contiguous_increasing_subsequence(sequence): Returns the length of the longest contiguously increasing subsequence in the given sequence. >>> longest_contiguous_increasing_subsequence([1, 2, 2, 3, 5, 7]) 4 >>> longest_contiguous_increasing_subsequence([3, 1, 2, 3, 2]) 3","solution":"def longest_contiguous_increasing_subsequence(sequence): Returns the length of the longest contiguously increasing subsequence in the given sequence. if not sequence: return 0 max_len = 1 current_len = 1 for i in range(1, len(sequence)): if sequence[i] > sequence[i - 1]: current_len += 1 else: current_len = 1 max_len = max(max_len, current_len) return max_len"},{"question":"def max_occupied_rooms(M, room_capacities, G, guest_groups): Returns the maximum number of rooms that can be occupied without exceeding capacity. :param M: Integer, number of rooms :param room_capacities: List of integers, capacities of each room :param G: Integer, number of guest groups :param guest_groups: List of integers, size of each guest group :return: Integer, maximum number of occupied rooms >>> max_occupied_rooms(5, [3, 5, 2, 7, 6], 4, [4, 3, 2, 5]) == 4 >>> max_occupied_rooms(3, [1, 2, 3], 4, [4, 5, 6, 7]) == 0 >>> max_occupied_rooms(3, [3, 3, 3], 3, [1, 2, 3]) == 3 >>> max_occupied_rooms(5, [1, 2, 3, 4, 5], 2, [1, 2]) == 2 >>> max_occupied_rooms(2, [3, 4], 5, [1, 2, 3, 4, 5]) == 2","solution":"def max_occupied_rooms(M, room_capacities, G, guest_groups): Returns the maximum number of rooms that can be occupied without exceeding capacity. :param M: Integer, number of rooms :param room_capacities: List of integers, capacities of each room :param G: Integer, number of guest groups :param guest_groups: List of integers, size of each guest group :return: Integer, maximum number of occupied rooms # Sort room capacities and guest groups room_capacities.sort() guest_groups.sort() # Initialize pointers and count of occupied rooms room_idx = 0 guest_idx = 0 occupied_count = 0 # Try to accommodate each guest group while room_idx < M and guest_idx < G: if guest_groups[guest_idx] <= room_capacities[room_idx]: occupied_count += 1 guest_idx += 1 room_idx += 1 return occupied_count"},{"question":"def longest_equal_substring(n: int, s: str) -> int: Find the length of the longest substring of s such that the number of 0s and 1s in that substring are equal. Args: n (int): The length of the binary string s. s (str): A binary string of length n. Returns: int: The length of the longest substring with equal number of 0s and 1s. >>> longest_equal_substring(4, \\"1100\\") 4 >>> longest_equal_substring(5, \\"01010\\") 4 >>> longest_equal_substring(6, \\"001101\\") 6 >>> longest_equal_substring(3, \\"111\\") 0 >>> longest_equal_substring(2, \\"01\\") 2 >>> longest_equal_substring(6, \\"000111\\") 6 >>> longest_equal_substring(10, \\"1010101010\\") 10 def solve(test_cases: list) -> list: Solve multiple test cases for finding the longest substring with equal number of 0s and 1s. Args: test_cases (list): A list of tuples, each containing an integer (length of the string) and a binary string. Returns: list: A list of results for each test case. >>> test_cases = [(4, \\"1100\\"), (5, \\"01010\\"), (6, \\"001101\\")] >>> solve(test_cases) [4, 4, 6] >>> test_cases = [(3, \\"111\\"), (2, \\"01\\"), (6, \\"000111\\"), (10, \\"1010101010\\")] >>> solve(test_cases) [0, 2, 6, 10]","solution":"def longest_equal_substring(n, s): balance_index = {0: -1} balance = 0 max_length = 0 for i in range(n): if s[i] == '0': balance -= 1 else: balance += 1 if balance in balance_index: max_length = max(max_length, i - balance_index[balance]) else: balance_index[balance] = i return max_length def solve(test_cases): results = [] for n, s in test_cases: results.append(longest_equal_substring(n, s)) return results"},{"question":"def max_subarray_sum(arr: List[int]) -> Tuple[int, int, int]: Given an array of integers, find a contiguous subarray which has the largest sum and return both the sum and the starting and ending indices of this subarray. If there are multiple subarrays with the same maximum sum, return the one with the smallest starting index. If there are still ties, return the one with the smallest ending index. >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) (6, 3, 6) >>> max_subarray_sum([1, -3, 2]) (2, 2, 2) >>> max_subarray_sum([5]) (5, 0, 0) >>> max_subarray_sum([-1, -2, -3, -4, -5]) (-1, 0, 0) >>> max_subarray_sum([1, 2, -1, 3, -1, 2, -1, 3]) (8, 0, 7) >>> max_subarray_sum([3, -1, -1, 3, -1, 3]) (6, 0, 5)","solution":"def max_subarray_sum(arr): Returns the maximum subarray sum along with its starting and ending indices. n = len(arr) max_sum = float('-inf') current_sum = 0 start = end = s = 0 for i in range(n): current_sum += arr[i] if current_sum > max_sum: max_sum = current_sum start = s end = i if current_sum < 0: current_sum = 0 s = i + 1 return max_sum, start, end"},{"question":"def can_arrange_cacti(n: int, spacings: List[int], sequence: str) -> str: Determine if it's possible to arrange the cacti as per the given spacing constraints. >>> can_arrange_cacti(3, [2, 1, 0], \\"CABACBAC\\") 'Impossible' >>> can_arrange_cacti(3, [2, 1, 1], \\"CABCBAC\\") 'Possible'","solution":"def can_arrange_cacti(n, spacings, sequence): last_position = {} for i in range(len(sequence)): cactus_type = sequence[i] type_index = ord(cactus_type) - ord('A') if cactus_type in last_position: if i - last_position[cactus_type] <= spacings[type_index]: return \\"Impossible\\" last_position[cactus_type] = i return \\"Possible\\" # Example usage n = 3 spacings = [2, 1, 0] sequence = \\"CABACBAC\\" print(can_arrange_cacti(n, spacings, sequence)) # Should print \\"Impossible\\""},{"question":"def fizz_buzz(n: int) -> list: Generates the integer sequence from 1 to n with substitutions: - \\"Fizz\\" for multiples of 3 - \\"Buzz\\" for multiples of 5 - \\"FizzBuzz\\" for multiples of both 3 and 5 Args: n (int): the end of the sequence (inclusive) Returns: list: the sequence with the appropriate substitutions","solution":"def fizz_buzz(n): Generates the integer sequence from 1 to n with substitutions: - \\"Fizz\\" for multiples of 3 - \\"Buzz\\" for multiples of 5 - \\"FizzBuzz\\" for multiples of both 3 and 5 Args: n (int): the end of the sequence (inclusive) Returns: list: the sequence with the appropriate substitutions result = [] for i in range(1, n + 1): if i % 3 == 0 and i % 5 == 0: result.append(\\"FizzBuzz\\") elif i % 3 == 0: result.append(\\"Fizz\\") elif i % 5 == 0: result.append(\\"Buzz\\") else: result.append(str(i)) return result"},{"question":"def calculate_total_score(n: int, task_points: List[Tuple[str, int]], m: int, completed_tasks: List[str]) -> int: Calculate the total score of a player in a computer game based on the completed tasks and their associated points. Args: n (int): Number of different types of tasks. task_points (List[Tuple[str, int]]): List of tuples where each tuple contains a task name and the points associated with it. m (int): Number of tasks completed. completed_tasks (List[str]): List of task names that the player has completed. Returns: int: Total score the player earned. Example: >>> n = 3 >>> task_points = [(\\"collect_coins\\", 10), (\\"defeat_enemy\\", 20), (\\"find_treasure\\", 50)] >>> m = 5 >>> completed_tasks = [\\"collect_coins\\", \\"defeat_enemy\\", \\"collect_coins\\", \\"find_treasure\\", \\"defeat_enemy\\"] >>> calculate_total_score(n, task_points, m, completed_tasks) 110","solution":"def calculate_total_score(n, task_points, m, completed_tasks): points_dict = {} for task, points in task_points: points_dict[task] = points total_score = 0 for task in completed_tasks: if task in points_dict: total_score += points_dict[task] return total_score"},{"question":"def min_length_after_operations(n: int, s: str) -> int: Returns the minimum possible length of the string s you can get after removing 'ab' or 'ba' pairs. >>> min_length_after_operations(8, \\"abbaabab\\") 0 >>> min_length_after_operations(4, \\"aaaa\\") 4 >>> min_length_after_operations(5, \\"ababa\\") 1 >>> min_length_after_operations(6, \\"ababab\\") 0","solution":"def min_length_after_operations(n, s): Returns the minimum possible length of the string s you can get after removing 'ab' or 'ba' pairs. stack = [] for char in s: if stack and ((stack[-1] == 'a' and char == 'b') or (stack[-1] == 'b' and char == 'a')): stack.pop() else: stack.append(char) return len(stack)"},{"question":"def max_bus_pass_value(n: int, values: List[int]) -> int: Compute the maximum possible total value of distributed bus passes under the constraint that no two consecutive bus passes can be distributed. >>> max_bus_pass_value(5, [3, 2, 7, 10, 12]) 22 >>> max_bus_pass_value(4, [8, 15, 3, 7]) 22","solution":"def max_bus_pass_value(n, values): if n == 0: return 0 elif n == 1: return values[0] # Initialize the max value array dp = [0] * n # Base cases dp[0] = values[0] dp[1] = max(values[0], values[1]) # Fill the dp array for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + values[i]) return dp[-1]"},{"question":"def inventory_system(m: int, p: int, k: int, operations: List[str]) -> List[str]: You are managing an inventory system with multiple warehouses, each represented as a list. Each warehouse can store a maximum of \`k\` unique types of items identified by their IDs. For \`m\` warehouses W_i (i = 0, 1, ..., m-1), perform a sequence of the following operations. * add(i, x): Add an item with ID x to warehouse W_i. If the warehouse is already storing an item with ID x, do nothing. If the warehouse is at capacity, do nothing. * remove(i, x): Remove an item with ID x from warehouse W_i. If the item isnt found in the warehouse, do nothing. * check(i, x): Check if an item with ID x exists in warehouse W_i. Print \\"yes\\" if found, otherwise print \\"no\\". In the initial state, all warehouses are empty and have a capacity of storing \`k\` types of items. >>> inventory_system(3, 7, 2, [\\"0 0 100\\", \\"0 0 200\\", \\"0 0 300\\", \\"2 0 100\\", \\"1 0 100\\", \\"2 0 100\\", \\"2 0 200\\"]) [\\"yes\\", \\"no\\", \\"yes\\"] >>> inventory_system(2, 5, 1, [\\"0 0 400\\", \\"0 0 500\\", \\"2 0 400\\", \\"1 0 400\\", \\"2 0 400\\"]) [\\"yes\\", \\"no\\"] >>> inventory_system(1, 3, 5, [\\"0 0 100\\", \\"0 0 200\\", \\"2 0 300\\"]) [\\"no\\"] >>> inventory_system(3, 6, 3, [\\"0 1 100\\", \\"0 1 200\\", \\"0 1 300\\", \\"1 1 200\\", \\"2 1 200\\", \\"2 1 100\\"]) [\\"no\\", \\"yes\\"] >>> inventory_system(4, 8, 4, [\\"0 2 500\\", \\"0 2 600\\", \\"2 2 500\\", \\"1 2 600\\", \\"2 2 600\\", \\"2 2 500\\", \\"0 3 700\\", \\"2 3 700\\"]) [\\"yes\\", \\"no\\", \\"yes\\", \\"yes\\"]","solution":"def inventory_system(m, p, k, operations): # initialize m warehouses with a capacity of k unique items each warehouses = [set() for _ in range(m)] result = [] for operation in operations: op, i, x = map(int, operation.split()) if op == 0: # add operation if len(warehouses[i]) < k: warehouses[i].add(x) elif op == 1: # remove operation if x in warehouses[i]: warehouses[i].remove(x) elif op == 2: # check operation if x in warehouses[i]: result.append(\\"yes\\") else: result.append(\\"no\\") return result"},{"question":"def max_points_with_one_skip(points: List[int]) -> int: Returns the maximum possible points by achieving all but one of the achievements. :param points: List of integers representing the points for each achievement. :return: Maximum points after skipping one achievement. >>> max_points_with_one_skip([5]) 0 >>> max_points_with_one_skip([10, 20]) 20 >>> max_points_with_one_skip([1, 2, 5, 8, 10]) 25 >>> max_points_with_one_skip([4, 2, 6, 3, 7, 9]) 29 >>> max_points_with_one_skip([10, 10, 10, 10]) 30 >>> max_points_with_one_skip([10**6, 999999, 999998]) 1999999","solution":"def max_points_with_one_skip(points): Returns the maximum possible points by achieving all but one of the achievements. :param points: List of integers representing the points for each achievement. :return: Maximum points after skipping one achievement. if len(points) <= 1: return 0 total_points = sum(points) min_points = min(points) return total_points - min_points"},{"question":"def partition_books(n, ids): Partition the sequence of book IDs into one or more contiguous subsequences where each subsequence has IDs in increasing order. Args: n (int): Total number of books. ids (List[int]): A list of book IDs in their current order. Returns: Union[int, Tuple[int, List[int]]]: -1 if no valid partition exists, otherwise a tuple with the number of shelves and a list of the sizes of each shelf. Examples: >>> partition_books(7, [2, 3, 5, 7, 11, 13, 17]) (1, [7]) >>> partition_books(8, [10, 12, 14, 11, 13, 15, 18, 20]) (2, [3, 5]) >>> partition_books(5, [1, 4, 2, 5, 3]) -1","solution":"def partition_books(n, ids): # Edge case: a single book is always a valid shelf if n == 1: return (1, [1]) # Attempt to partition the sequence into valid shelves partitions = [] current_partition = [ids[0]] for i in range(1, n): if ids[i] > ids[i - 1]: current_partition.append(ids[i]) else: partitions.append(len(current_partition)) current_partition = [ids[i]] partitions.append(len(current_partition)) # Add the last partition # Check if partitioning is valid, if there's any partition with a single element if any(p == 1 for p in partitions): return -1 return (len(partitions), partitions) # Example usage: # n = 8 # ids = [10, 12, 14, 11, 13, 15, 18, 20] # print(partition_books(n, ids))"},{"question":"def count_taller_students(n: int, heights: List[int]) -> int: Returns the number of students that are taller than the student with the minimum height. :param n: int, number of students :param heights: List[int], list of heights of students :return: int, number of students taller than the minimum height student >>> count_taller_students(5, [150, 160, 165, 155, 170]) == 4 >>> count_taller_students(3, [180, 175, 190]) == 2 >>> count_taller_students(4, [170, 160, 150, 140]) == 3 >>> count_taller_students(4, [170, 170, 170, 170]) == 0 >>> count_taller_students(6, [170, 160, 150, 180, 190, 200]) == 5 >>> count_taller_students(5, [180, 170, 160, 190, 150]) == 4 >>> count_taller_students(5, [140, 141, 142, 143, 144]) == 4","solution":"def count_taller_students(n, heights): Returns the number of students that are taller than the student with the minimum height. :param n: int, number of students :param heights: List[int], list of heights of students :return: int, number of students taller than the minimum height student min_height = min(heights) count = sum(1 for height in heights if height > min_height) return count"},{"question":"def generate_aps(n): Generates the first n elements of the Alternating Power Sequence (APS). Parameters: n (int): The number of elements to generate in the APS. Returns: List[int]: A list containing the first n elements of the APS. >>> generate_aps(4) [1, -4, 27, -256] >>> generate_aps(6) [1, -4, 27, -256, 3125, -46656]","solution":"def generate_aps(n): Generates the first n elements of the Alternating Power Sequence (APS). Parameters: n (int): The number of elements to generate in the APS. Returns: List[int]: A list containing the first n elements of the APS. aps = [] for i in range(1, n + 1): if i % 2 == 1: aps.append(i ** i) else: aps.append(-(i ** i)) return aps # Example usage: # n = 4 # print(generate_aps(n)) # Output: [1, -4, 27, -256]"},{"question":"def min_operations_to_equalize(n: int, arr: List[int]) -> int: This function calculates the minimum number of operations required to make all elements in the array equal using any combination of increment and rotate operations. :param n: Integer, the number of elements in the array :param arr: List of integers, the elements of the array :return: Integer, the minimum number of operations required >>> min_operations_to_equalize(1, [100]) == 0 >>> min_operations_to_equalize(4, [5, 5, 5, 5]) == 0 >>> min_operations_to_equalize(5, [1, 2, 3, 4, 5]) == 4 >>> min_operations_to_equalize(3, [2, 1, 3]) == 2 >>> min_operations_to_equalize(4, [1, 3, 5, 7]) == 6","solution":"def min_operations_to_equalize(n, arr): This function calculates the minimum number of operations required to make all elements in the array equal using any combination of increment and rotate operations. :param n: Integer, the number of elements in the array :param arr: List of integers, the elements of the array :return: Integer, the minimum number of operations required if n == 1: return 0 # Find the minimum and maximum element in the array min_elem = min(arr) max_elem = max(arr) # Difference between maximum and minimum gives us the maximum increments needed increments_needed = max_elem - min_elem return increments_needed"},{"question":"def first_unique_characters_word(word_list: List[str]) -> str: Returns the first word in the word_list with all unique characters, or \\"NONE\\" if no such word exists. >>> first_unique_characters_word([\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\"]) == \\"date\\" >>> first_unique_characters_word([\\"apple\\", \\"banana\\", \\"cherry\\"]) == \\"NONE\\" >>> first_unique_characters_word([\\"banana\\", \\"date\\"]) == \\"date\\" >>> first_unique_characters_word([\\"bat\\", \\"cue\\", \\"dog\\", \\"elf\\"]) == \\"bat\\" >>> first_unique_characters_word([]) == \\"NONE\\" # Your code goes here","solution":"def first_unique_characters_word(word_list): Returns the first word in the word_list with all unique characters, or \\"NONE\\" if no such word exists. for word in word_list: if len(word) == len(set(word)): # Checking for unique characters return word return \\"NONE\\""},{"question":"def fill_missing_heights(n: int, heights: List[int]) -> List[int]: Fills in the missing plant heights using linear interpolation. Parameters: n (int): The number of days. heights (List[int]): List of plant heights where -1 indicates a missing value. Returns: List[int]: List of plant heights with missing values filled in. >>> fill_missing_heights(5, [3, -1, -1, 7, 8]) [3, 4, 5, 7, 8] >>> fill_missing_heights(6, [-1, -1, 5, 10, -1, -1]) [5, 5, 5, 10, 10, 10] >>> fill_missing_heights(5, [-1, -1, -1, -1, -1]) [-1, -1, -1, -1, -1] >>> fill_missing_heights(5, [1, 2, 3, 4, 5]) [1, 2, 3, 4, 5] >>> fill_missing_heights(7, [-1, -1, 2, -1, -1, 5, -1]) [2, 2, 2, 3, 4, 5, 5] >>> fill_missing_heights(4, [1, -1, -1, 4]) [1, 2, 3, 4]","solution":"def fill_missing_heights(n, heights): Fills in the missing plant heights using linear interpolation. # Step 1: Find the first and last non-missing values first_known, last_known = None, None for i in range(n): if heights[i] != -1: first_known = i if first_known is None else first_known last_known = i # Step 2: Handle the beginning and end missing values if first_known is not None: # Ensure there is at least one known value for i in range(first_known): heights[i] = heights[first_known] for i in range(last_known + 1, n): heights[i] = heights[last_known] # Step 3: Linear interpolation for intermediate missing values i = 0 while i < n: if heights[i] == -1: # Found the gap start = i - 1 # Start from the previous known height while i < n and heights[i] == -1: i += 1 end = i # End at the next known height if i < n: for j in range(start + 1, end): heights[j] = heights[start] + ((heights[end] - heights[start]) * (j - start) // (end - start)) else: break else: i += 1 return heights # Example usage: # n = 5 # heights = [3, -1, -1, 7, 8] # print(fill_missing_heights(n, heights)) # Output: [3, 4, 5, 7, 8]"},{"question":"def min_operations_to_decreasing(n: int, array: List[int]) -> Union[int, str]: Determines the minimum number of operations required to make the array strictly decreasing. >>> min_operations_to_decreasing(5, [9, 7, 5, 3, 1]) 0 >>> min_operations_to_decreasing(5, [1, 3, 2, 4, 5]) 'Impossible' >>> min_operations_to_decreasing(4, [5, 5, 5, 5]) 'Impossible' >>> min_operations_to_decreasing(2, [2, 1]) 0 >>> min_operations_to_decreasing(2, [3, 3]) 'Impossible'","solution":"def min_operations_to_decreasing(n, array): operations = 0 for i in range(n - 1): if array[i] <= array[i + 1]: return \\"Impossible\\" return operations"},{"question":"from typing import List def longest_optimal_subarray(arr: List[int], k: int) -> int: Find the length of the longest subarray where the number of odd numbers is less than or equal to k. >>> longest_optimal_subarray([1, 2, 3, 4, 5], 2) 4 >>> longest_optimal_subarray([4, 2, 6, 8], 1) 4 >>> longest_optimal_subarray([1, 3, 5, 7, 9], 0) 0","solution":"def longest_optimal_subarray(arr, k): n = len(arr) left = 0 odd_count = 0 max_len = 0 for right in range(n): # Check if the current number is odd if arr[right] % 2 != 0: odd_count += 1 # If the number of odd numbers exceeds k, move the left pointer while odd_count > k: if arr[left] % 2 != 0: odd_count -= 1 left += 1 # Calculate the current length of the subarray [left, right] current_len = right - left + 1 if current_len > max_len: max_len = current_len return max_len"},{"question":"def longest_subsequence_with_product_k(k: int, p: int, s: List[int]) -> int: This function finds the length of the longest contiguous subsequence with a product exactly equal to p. Args: k (int): Length of sequence p (int): Target product s (List[int]): The sequence of integers Returns: int: Length of the longest contiguous subsequence with product equal to p >>> longest_subsequence_with_product_k(5, 6, [1, 2, 2, 3, 3]) 2 >>> longest_subsequence_with_product_k(4, 1, [1, 1, 1, 1]) 4 >>> longest_subsequence_with_product_k(3, 24, [2, 3, 4]) 3","solution":"def longest_subsequence_with_product_k(k, p, s): This function finds the length of the longest contiguous subsequence with a product exactly equal to p. :param k: Length of sequence :param p: Target product :param s: The sequence of integers :return: Length of the longest contiguous subsequence with product equal to p max_len = 0 left = 0 current_product = 1 for right in range(k): current_product *= s[right] while current_product > p and left <= right: current_product //= s[left] left += 1 if current_product == p: max_len = max(max_len, right - left + 1) return max_len"},{"question":"def min_items_to_collect(N, M, items): Returns the minimum number of items Takashi needs to collect to have exactly N distinct items. If it is not possible, returns -1. >>> min_items_to_collect(3, 5, [1, 2, 3, 3, 4]) == 3 >>> min_items_to_collect(4, 5, [1, 1, 2, 2, 3]) == -1 >>> min_items_to_collect(2, 3, [5, 5, 6]) == 2","solution":"def min_items_to_collect(N, M, items): Returns the minimum number of items Takashi needs to collect to have exactly N distinct items. If it is not possible, returns -1. distinct_items = set(items) # Get all distinct items if len(distinct_items) < N: return -1 return N"},{"question":"def min_replacements_to_alternate_parity(N: int, lst: List[int]) -> int: Determine the minimum number of replacements required to ensure every adjacent pair of elements in the list has different parity. >>> min_replacements_to_alternate_parity(5, [1, 3, 5, 7, 9]) 2 >>> min_replacements_to_alternate_parity(4, [2, 2, 2, 2]) 2 >>> min_replacements_to_alternate_parity(6, [1, 2, 3, 4, 5, 6]) 0 >>> min_replacements_to_alternate_parity(7, [1, 1, 1, 1, 1, 1, 1]) 3 >>> min_replacements_to_alternate_parity(3, [6, 2, 4]) 1 >>> min_replacements_to_alternate_parity(4, [1, 2, 3, 4]) 0 >>> min_replacements_to_alternate_parity(1, [7]) 0","solution":"def min_replacements_to_alternate_parity(N, lst): replacements = 0 for i in range(1, N): if (lst[i-1] % 2) == (lst[i] % 2): # adjacent elements have same parity replacements += 1 # Change current element's parity lst[i] = lst[i] + 1 if lst[i] % 2 == 0 else lst[i] - 1 return replacements"},{"question":"def longest_increasing_subarray_length(arr): Returns the length of the longest subarray consisting of only increasing numbers. >>> longest_increasing_subarray_length([1, 2, 2, 3, 4, 5]) == 4 >>> longest_increasing_subarray_length([1, 2, 3, 4, 5, 6, 7, 8, 9]) == 9 >>> longest_increasing_subarray_length([9, 8, 7, 6, 5, 4, 3, 2, 1]) == 1 >>> longest_increasing_subarray_length([1]) == 1 >>> longest_increasing_subarray_length([1, 3, 2, 4, 3, 5, 4, 6]) == 2 >>> longest_increasing_subarray_length([1, 2, 3, 1, 2, 3, 4, 1, 2]) == 4 >>> longest_increasing_subarray_length([2, 2, 2, 2, 2]) == 1 >>> longest_increasing_subarray_length([]) == 0","solution":"def longest_increasing_subarray_length(arr): Returns the length of the longest subarray consisting of only increasing numbers. if not arr: return 0 max_len = 1 current_len = 1 for i in range(1, len(arr)): if arr[i] > arr[i-1]: current_len += 1 max_len = max(max_len, current_len) else: current_len = 1 return max_len"},{"question":"def construct_special_tree(n: int): Constructs a special binary tree with n nodes. >>> construct_special_tree(1) 1 >>> construct_special_tree(2) 3 1 2 >>> construct_special_tree(3) 6 1 2 2 3 >>> construct_special_tree(4) 10 1 2 2 3 3 4 >>> construct_special_tree(5) 15 1 2 2 3 3 4 4 5 pass","solution":"def construct_special_tree(n): Constructs a special binary tree with n nodes. def is_prime(num): if num <= 1: return False if num <= 3: return True if num % 2 == 0 or num % 3 == 0: return False i = 5 while i * i <= num: if num % i == 0 or num % (i + 2) == 0: return False i += 6 return True tree = [] if n == 1: # Single node tree print(1) # sum of path from root to the maximum node (1 itself) is even print(\\"\\") return # Create a left skewed binary tree to ensure sum of path from root to maximum node is even for i in range(1, n): tree.append((i, i + 1)) # Output the sum of the path from root to the node with maximum value path_sum = sum(range(1, n + 1)) print(path_sum) for p, c in tree: print(p, c)"},{"question":"def get_alphabet_position(input_string: str) -> int: Returns the position of the first letter in the input_string in the alphabet. >>> get_alphabet_position(\\"b1234\\") == 2 >>> get_alphabet_position(\\"d5678\\") == 4 >>> get_alphabet_position(\\"h4321\\") == 8","solution":"def get_alphabet_position(input_string): Returns the position of the first letter in the input_string in the alphabet. first_char = input_string[0] return ord(first_char) - ord('a') + 1"},{"question":"def check_people_count(rooms_snapshots: List[List[int]], k: int) -> str: Determine if there was a moment when any room had at least the specified number of people. rooms_snapshots: list of lists containing integers, each sublist represents the snapshots for one room k: int, specified number of people to check against >>> check_people_count([[12, 8, 15, 6, 10], [9, 7, 5, 2], [1, 3, 11, 0, 4, 7]], 8) 'yes' >>> check_people_count([[4, 3, 2], [1, 1, 5, 2, 1]], 6) 'no' Returns 'yes' if any room had at least k number of people at any moment, otherwise 'no'.","solution":"def check_people_count(rooms_snapshots, k): Returns 'yes' if any room had at least k number of people at any moment, otherwise 'no'. rooms_snapshots: list of list of int, each sublist represents the snapshots for one room k: int, the specified number of people to check against for room in rooms_snapshots: if any(people_count >= k for people_count in room): return \\"yes\\" return \\"no\\""},{"question":"def minimal_path_sum(test_cases): Given a grid of size n x m, each cell contains a positive integer. This function finds the minimal path sum from the top-left corner to the bottom-right corner of the grid. You can only move either down or right at any point in time. :param test_cases: List of test cases where each test case is a tuple (n, m, grid) :return: List of integers representing the minimal path sum for each test case. Example: >>> minimal_path_sum([ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (3, 4, [ [1, 2, 5, 1], [4, 3, 2, 1], [3, 6, 2, 1] ]) ]) [7, 10] def test_minimal_path_sum(): test_cases = [ (3, 3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]), (3, 4, [ [1, 2, 5, 1], [4, 3, 2, 1], [3, 6, 2, 1] ]), (1, 1, [ [42] ]), (2, 2, [ [1, 3], [2, 1] ]), (2, 3, [ [1, 2, 3], [4, 5, 6] ]), ] expected_results = [7, 10, 42, 4, 12] results = minimal_path_sum(test_cases) for result, expected in zip(results, expected_results): assert result == expected test_minimal_path_sum()","solution":"def minimal_path_sum(test_cases): results = [] for case in test_cases: n, m, grid = case dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for j in range(1, m): dp[0][j] = dp[0][j-1] + grid[0][j] for i in range(1, n): for j in range(1, m): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] results.append(dp[n-1][m-1]) return results"},{"question":"from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level). >>> root = TreeNode(3) >>> root.left = TreeNode(9) >>> root.right = TreeNode(20) >>> root.right.left = TreeNode(15) >>> root.right.right = TreeNode(7) >>> levelOrder(root) [[3], [9, 20], [15, 7]] >>> root = TreeNode(1) >>> levelOrder(root) [[1]] >>> root = None >>> levelOrder(root) []","solution":"from collections import deque from typing import Optional, List class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def levelOrder(root: Optional[TreeNode]) -> List[List[int]]: if not root: return [] result = [] queue = deque([root]) while queue: level_size = len(queue) current_level = [] for _ in range(level_size): node = queue.popleft() current_level.append(node.val) if node.left is not None: queue.append(node.left) if node.right is not None: queue.append(node.right) result.append(current_level) return result"},{"question":"def delivery_order(N: int) -> List[int]: Generate the delivery order for the postal workers. The function should return a list of integers representing the order in which the postal workers should deliver packages, according to the given pattern. Args: N (int): An integer representing the number of houses from 1 to N. Returns: List[int]: A list of integers representing the delivery order. Examples: >>> delivery_order(5) [1, 3, 5, 2, 4] >>> delivery_order(8) [1, 3, 5, 7, 2, 4, 6, 8]","solution":"def delivery_order(N): Returns the order in which postal workers should deliver packages. odd_houses = [i for i in range(1, N + 1) if i % 2 != 0] even_houses = [i for i in range(1, N + 1) if i % 2 == 0] return odd_houses + even_houses"},{"question":"from typing import List def find_peak_element(nums: List[int]) -> int: Returns the index of any peak element. A peak element is an element that is strictly greater than its neighbors. For corner elements, we need to consider only one neighbor. Args: nums : List[int] - the input array Returns: int - the index of any peak element Examples: >>> find_peak_element([1, 2, 3]) 2 >>> find_peak_element([1, 2, 1, 3, 5]) 1 >>> find_peak_element([1]) 0","solution":"def find_peak_element(nums): Returns the index of any peak element. A peak element is an element that is strictly greater than its neighbors. For corner elements, we need to consider only one neighbor. Args: nums : List[int] - the input array Returns: int - the index of any peak element n = len(nums) if n == 1: return 0 if nums[0] > nums[1]: return 0 if nums[n - 1] > nums[n - 2]: return n - 1 for i in range(1, n - 1): if nums[i] > nums[i - 1] and nums[i] > nums[i + 1]: return i return -1 # in case no peak is found, which technically shouldn't happen"},{"question":"def max_customers_get_book(n: int, m: int, d: int, stalls: List[int], customers: List[int]) -> int: Returns the maximum number of customers who get their preferred book. :param n: Number of stalls :param m: Number of customers :param d: Maximum distance a customer is willing to move :param stalls: List of book ids at each stall (0 if stall is closed) :param customers: List of preferred book ids for each customer :return: Maximum number of customers who get their preferred book >>> max_customers_get_book(10, 3, 1, [5, 0, 3, 6, 2, 7, 1, 0, 4, 8], [5, 2, 10]) 2 >>> max_customers_get_book(8, 5, 2, [0, 13, 0, 25, 24, 0, 0, 30], [24, 25, 13, 13, 30]) 4","solution":"def max_customers_get_book(n, m, d, stalls, customers): Returns the maximum number of customers who get their preferred book. :param n: Number of stalls :param m: Number of customers :param d: Maximum distance a customer is willing to move :param stalls: List of book ids at each stall (0 if stall is closed) :param customers: List of preferred book ids for each customer :return: Maximum number of customers who get their preferred book # Create dictionaries to map book ids to their positions in the stalls available_books = {} for i in range(n): book = stalls[i] if book != 0: if book not in available_books: available_books[book] = [] available_books[book].append(i) # We will use a set to track occupied stalls after a book is bought occupied_stalls = set() satisfied_customers = 0 for preferred_book in customers: if preferred_book in available_books: found_book = False positions = available_books[preferred_book] for pos in positions: # Check within range [pos - d, pos + d] for check_pos in range(max(0, pos - d), min(n, pos + d + 1)): if check_pos not in occupied_stalls and stalls[check_pos] == preferred_book: occupied_stalls.add(check_pos) satisfied_customers += 1 found_book = True break if found_book: break return satisfied_customers"},{"question":"def is_possible_subsequence_product(n: int, target: int, sequence: List[int]) -> str: Determine if a subsequence of the numbers has a product equal to the target value. >>> is_possible_subsequence_product(3, 6, [1, 2, 3]) \\"Possible\\" >>> is_possible_subsequence_product(2, 15, [4, 5]) \\"Impossible\\" pass def solve_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Solve multiple test cases to check for each if there exists a subsequence with product equal to the target value. >>> test_cases = [ (3, 6, [1, 2, 3]), (4, 12, [2, 3, 4, 2]), (2, 15, [4, 5]) ] >>> solve_test_cases(test_cases) [\\"Possible\\", \\"Possible\\", \\"Impossible\\"] pass","solution":"def is_possible_subsequence_product(n, target, sequence): Check if it is possible to form the target product using a subsequence from the sequence. from itertools import combinations for r in range(1, n + 1): for combo in combinations(sequence, r): product = 1 for num in combo: product *= num if product == target: return \\"Possible\\" return \\"Impossible\\" def solve_test_cases(test_cases): results = [] for n, target, sequence in test_cases: results.append(is_possible_subsequence_product(n, target, sequence)) return results"},{"question":"def largest_palindrome_less_than_or_equal_to(m: int) -> int: Returns the largest palindrome number less than or equal to m. >>> largest_palindrome_less_than_or_equal_to(150) 141 >>> largest_palindrome_less_than_or_equal_to(8) 8 >>> largest_palindrome_less_than_or_equal_to(1000) 999 >>> largest_palindrome_less_than_or_equal_to(278) 272 >>> largest_palindrome_less_than_or_equal_to(3) 3 >>> largest_palindrome_less_than_or_equal_to(0) 0 >>> largest_palindrome_less_than_or_equal_to(1) 1","solution":"def largest_palindrome_less_than_or_equal_to(m): Returns the largest palindrome number less than or equal to m. for num in range(m, -1, -1): if str(num) == str(num)[0:][::-1]: return num"},{"question":"def min_operations_to_non_decreasing(n: int, a: List[int]) -> int: Returns the minimum number of operations required to make the sequence non-decreasing. Parameters: n (int): The length of the sequence. a (list): A list of integers representing the sequence. Returns: int: The minimum number of operations required. Examples: >>> min_operations_to_non_decreasing(4, [4, 3, 2, 1]) 6 >>> min_operations_to_non_decreasing(5, [1, 3, 2, 5, 4]) 2 >>> min_operations_to_non_decreasing(3, [1, 2, 3]) 0","solution":"def min_operations_to_non_decreasing(n, a): Returns the minimum number of operations required to make the sequence non-decreasing. Parameters: n (int): The length of the sequence. a (list): A list of integers representing the sequence. Returns: int: The minimum number of operations required. # we need to count number of inversions in the sequence def merge_and_count(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 # Conditions are checked to ensure that i doesn't exceed mid and j doesn't exceed right while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) j += 1 k += 1 # Copy the remaining elements of left subarray, if any while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 # Copy the remaining elements of right subarray, if any while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 # Copy the sorted subarray into Original array for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_and_count(arr, temp_arr, left, mid, right) return inv_count temp_arr = [0]*n return merge_sort_and_count(a, temp_arr, 0, n-1)"},{"question":"def reverse_words(sentence: str) -> str: Reverse each word in the given sentence while maintaining the order of words. >>> reverse_words(\\"Hello World!\\") 'olleH !dlroW' >>> reverse_words(\\"How are you?\\") 'woH era ?uoy' def process_sentences(test_cases: List[str]) -> List[str]: Process multiple sentences to reverse each word in each sentence. >>> process_sentences([\\"Hello World!\\", \\"How are you?\\"]) ['olleH !dlroW', 'woH era ?uoy'] from typing import List def test_reverse_words(): assert reverse_words(\\"Hello World!\\") == \\"olleH !dlroW\\" assert reverse_words(\\"How are you?\\") == \\"woH era ?uoy\\" assert reverse_words(\\"Alice loves Bob\\") == \\"ecilA sevol boB\\" assert reverse_words(\\"This is a test\\") == \\"sihT si a tset\\" assert reverse_words(\\"Python\\") == \\"nohtyP\\" def test_process_sentences(): test_cases = [ \\"Hello World!\\", \\"How are you?\\", \\"Alice loves Bob\\", \\"This is a test\\" ] expected_outputs = [ \\"olleH !dlroW\\", \\"woH era ?uoy\\", \\"ecilA sevol boB\\", \\"sihT si a tset\\" ] assert process_sentences(test_cases) == expected_outputs test_cases = [ \\"Python\\" ] expected_outputs = [ \\"nohtyP\\" ] assert process_sentences(test_cases) == expected_outputs","solution":"def reverse_words(sentence): Given a sentence, reverse each word in the sentence. :param sentence: str :return: str words = sentence.split() reversed_words = [word[::-1] for word in words] return ' '.join(reversed_words) def process_sentences(test_cases): Process multiple test cases of sentences to reverse each word. :param test_cases: list of str :return: list of str return [reverse_words(sentence) for sentence in test_cases]"},{"question":"def count_visible_buildings(buildings): Returns the number of visible buildings when looking from left to right. >>> count_visible_buildings([2, 5, 1, 7, 3, 1]) 3 >>> count_visible_buildings([8, 7, 6, 5]) 1 >>> count_visible_buildings([3, 3, 4, 4, 5]) 3 >>> count_visible_buildings([5]) 1 >>> count_visible_buildings([1, 2, 3, 4, 5]) 5 >>> count_visible_buildings([5, 5, 5, 5, 5]) 1 >>> count_visible_buildings([]) 0 pass","solution":"def count_visible_buildings(buildings): Returns the number of visible buildings when looking from left to right. if not buildings: return 0 visible_count = 0 max_height = 0 for height in buildings: if height > max_height: visible_count += 1 max_height = height return visible_count"},{"question":"def max_arithmetic_subsequence_length(n: int, a: List[int]) -> int: Paul has a sequence of n integers. He performs the following operation exactly once: 1. Choose any integer k such that 1  k  n. 2. Select a subsequence s of the array a, such that s is an arithmetic progression. An arithmetic progression is a sequence of numbers such that the difference between the consecutive terms is constant. Paul wants to maximize the length of the subsequence s that he can get by choosing the optimal k. >>> max_arithmetic_subsequence_length(5, [3, 7, 11, 15, 19]) 5 >>> max_arithmetic_subsequence_length(6, [1, 10, 20, 30, 25, 50]) 3 >>> max_arithmetic_subsequence_length(4, [5, 7, 10, 12]) 2","solution":"def max_arithmetic_subsequence_length(n, a): if n == 1: return 1 max_len = 1 for i in range(n): for j in range(i + 1, n): d = a[j] - a[i] current_len = 2 last_value = a[j] for k in range(j + 1, n): if a[k] - last_value == d: current_len += 1 last_value = a[k] max_len = max(max_len, current_len) return max_len"},{"question":"def calculate_final_score(n: int, points: List[int]) -> int: Calculate the final score after processing all tasks based on the given rules. Parameters: n (int): Number of tasks. points (list): A list of integers representing the points for each task. Returns: int: The final score. >>> calculate_final_score(5, [4, 2, 6, 6, 8]) == 26 >>> calculate_final_score(6, [1, 2, 2, 0, 0, 1]) == 6 >>> calculate_final_score(3, [-5, -5, -5]) == -15 >>> calculate_final_score(4, [10, 10, -1, -2]) == 17 >>> calculate_final_score(5, [0, 0, 0, 0, 0]) == 0 >>> calculate_final_score(4, [1, 1, 1, 1]) == 4 >>> calculate_final_score(7, [5, -5, 5, -5, 5, -5, 5]) == 5","solution":"def calculate_final_score(n, points): Calculate the final score after processing all tasks based on the given rules. Parameters: n (int): Number of tasks. points (list): A list of integers representing the points for each task. Returns: int: The final score. if n == 0: return 0 final_score = points[0] for i in range(1, n): if points[i] == points[i - 1]: final_score += points[i] else: final_score += points[i] return final_score"},{"question":"def next_closest_time(time: str) -> str: Given the current time displayed by a 24-hour digital clock as a string in the format \\"HH:MM\\", determine the next time the clock will display using only the digits present in the current time. Args: time (str): A string representing the current time in the format \\"HH:MM\\". Returns: str: A string representing the next valid time. Examples: >>> next_closest_time(\\"19:34\\") \\"19:39\\" >>> next_closest_time(\\"23:59\\") \\"22:22\\"","solution":"from itertools import product def next_closest_time(time): hours, minutes = time.split(\\":\\") current_minutes = int(hours) * 60 + int(minutes) digits = sorted(set(hours + minutes)) # Get unique digits and sort them all_possible_times = [] for h1, h2, m1, m2 in product(digits, repeat=4): hours_part = int(h1 + h2) minutes_part = int(m1 + m2) if hours_part < 24 and minutes_part < 60: all_possible_times.append((hours_part * 60 + minutes_part, f\\"{h1}{h2}:{m1}{m2}\\")) # Sort the times by total minutes and filter out the valid times only greater than the current one all_possible_times.sort() for minutes, time_str in all_possible_times: if minutes > current_minutes: return time_str # If no time was found that's greater than the current one, return the earliest valid time return all_possible_times[0][1]"},{"question":"def count_paths(n, m, grid): Determine the total number of distinct paths from the top-left to the bottom-right cell in a grid with blocked and free cells. >>> count_paths(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> count_paths(3, 3, [[0, 1, 0], [1, 1, 0], [0, 0, 0]]) == 0","solution":"def count_paths(n, m, grid): if grid[0][0] == 1 or grid[n-1][m-1] == 1: return 0 dp = [[0] * m for _ in range(n)] dp[0][0] = 1 for i in range(n): for j in range(m): if grid[i][j] == 1: dp[i][j] = 0 else: if i > 0: dp[i][j] += dp[i-1][j] if j > 0: dp[i][j] += dp[i][j-1] return dp[n-1][m-1]"},{"question":"def determine_message_sentiment(message: str) -> str: Determine if the message is positive based on the count of positive and negative words. >>> determine_message_sentiment(\\"I am feeling very happy today!\\") 'POSITIVE' >>> determine_message_sentiment(\\"This is so sad and painful.\\") 'NEGATIVE' def determine_messages_sentiments(T: int, messages: List[str]) -> List[str]: Determine the sentiment of multiple messages. >>> T = 3 >>> messages = [\\"I am feeling very happy today!\\", ... \\"This is so sad and painful.\\", ... \\"What an amazing and exciting experience!\\"] >>> determine_messages_sentiments(T, messages) ['POSITIVE', 'NEGATIVE', 'POSITIVE']","solution":"def determine_message_sentiment(message): positive_words = {\\"happy\\", \\"joy\\", \\"amazing\\", \\"excited\\"} negative_words = {\\"sad\\", \\"angry\\", \\"pain\\", \\"upset\\"} message_words = message.lower().split() positive_count = sum(word in positive_words for word in message_words) negative_count = sum(word in negative_words for word in message_words) return \\"POSITIVE\\" if positive_count > negative_count else \\"NEGATIVE\\" def determine_messages_sentiments(T, messages): results = [] for message in messages: results.append(determine_message_sentiment(message)) return results"},{"question":"def categorize_song_lengths(n: int, song_lengths: List[int]) -> Tuple[int, int, int, int]: Function to categorize song lengths. Parameters: n (int): Number of songs in the library. song_lengths (List[int]): List of song lengths in seconds. Returns: Tuple[int, int, int, int]: A tuple containing counts of songs in four categories: 1. Less than 60 seconds 2. From 60 to 119 seconds inclusive 3. From 120 to 299 seconds inclusive 4. 300 seconds or longer","solution":"def categorize_song_lengths(n, song_lengths): Function to categorize song lengths. Parameters: n (int): Number of songs in the library. song_lengths (List[int]): List of song lengths in seconds. Returns: Tuple[int, int, int, int]: A tuple containing counts of songs in four categories: 1. Less than 60 seconds 2. From 60 to 119 seconds inclusive 3. From 120 to 299 seconds inclusive 4. 300 seconds or longer count_less_60 = 0 count_60_119 = 0 count_120_299 = 0 count_300_or_more = 0 for length in song_lengths: if length < 60: count_less_60 += 1 elif 60 <= length <= 119: count_60_119 += 1 elif 120 <= length <= 299: count_120_299 += 1 else: count_300_or_more += 1 return (count_less_60, count_60_119, count_120_299, count_300_or_more)"},{"question":"from typing import List, Tuple def max_logged_in(records: List[Tuple[str, int, str]]) -> int: Determine the maximum number of employees logged in simultaneously based on the given records. Args: records (List[Tuple[str, int, str]]): A list of tuples where each tuple contains a string (timestamp), an integer (employee ID), and a string (event type), with timestamp formatted as \\"YYYY-MM-DD HH:MM\\". Returns: int: The maximum number of employees that were logged in simultaneously. Examples: >>> max_logged_in([ ... (\\"2023-10-01 08:00\\", 1, \\"login\\"), ... (\\"2023-10-01 09:00\\", 2, \\"login\\"), ... (\\"2023-10-01 10:00\\", 3, \\"login\\"), ... (\\"2023-10-01 11:00\\", 1, \\"logout\\"), ... (\\"2023-10-01 12:00\\", 2, \\"logout\\"), ... (\\"2023-10-01 13:00\\", 3, \\"logout\\"), ... (\\"2023-10-01 14:00\\", 4, \\"login\\"), ... (\\"2023-10-01 15:00\\", 5, \\"login\\"), ... (\\"2023-10-01 16:00\\", 4, \\"logout\\"), ... (\\"2023-10-01 17:00\\", 5, \\"logout\\"), ... ]) == 3 pass def test_single_record(): records = [(\\"2023-10-01 08:00\\", 1, \\"login\\")] assert max_logged_in(records) == 1 def test_no_overlap(): records = [ (\\"2023-10-01 08:00\\", 1, \\"login\\"), (\\"2023-10-01 09:00\\", 1, \\"logout\\"), (\\"2023-10-01 10:00\\", 2, \\"login\\"), (\\"2023-10-01 11:00\\", 2, \\"logout\\"), ] assert max_logged_in(records) == 1 def test_simple_overlap(): records = [ (\\"2023-10-01 08:00\\", 1, \\"login\\"), (\\"2023-10-01 09:00\\", 2, \\"login\\"), (\\"2023-10-01 10:00\\", 1, \\"logout\\"), (\\"2023-10-01 11:00\\", 2, \\"logout\\"), ] assert max_logged_in(records) == 2 def test_example_case(): records = [ (\\"2023-10-01 08:00\\", 1, \\"login\\"), (\\"2023-10-01 09:00\\", 2, \\"login\\"), (\\"2023-10-01 10:00\\", 3, \\"login\\"), (\\"2023-10-01 11:00\\", 1, \\"logout\\"), (\\"2023-10-01 12:00\\", 2, \\"logout\\"), (\\"2023-10-01 13:00\\", 3, \\"logout\\"), (\\"2023-10-01 14:00\\", 4, \\"login\\"), (\\"2023-10-01 15:00\\", 5, \\"login\\"), (\\"2023-10-01 16:00\\", 4, \\"logout\\"), (\\"2023-10-01 17:00\\", 5, \\"logout\\"), ] assert max_logged_in(records) == 3 def test_complex_overlap(): records = [ (\\"2023-10-01 08:00\\", 1, \\"login\\"), (\\"2023-10-01 08:30\\", 2, \\"login\\"), (\\"2023-10-01 09:00\\", 1, \\"logout\\"), (\\"2023-10-01 09:30\\", 3, \\"login\\"), (\\"2023-10-01 10:00\\", 3, \\"logout\\"), (\\"2023-10-01 10:30\\", 2, \\"logout\\"), ] assert max_logged_in(records) == 2 def test_all_login_then_all_logout(): records = [ (\\"2023-10-01 08:00\\", 1, \\"login\\"), (\\"2023-10-01 09:00\\", 2, \\"login\\"), (\\"2023-10-01 10:00\\", 3, \\"login\\"), (\\"2023-10-01 11:00\\", 1, \\"logout\\"), (\\"2023-10-01 11:30\\", 2, \\"logout\\"), (\\"2023-10-01 12:00\\", 3, \\"logout\\"), ] assert max_logged_in(records) == 3 def test_simultaneous_events(): records = [ (\\"2023-10-01 08:00\\", 1, \\"login\\"), (\\"2023-10-01 08:00\\", 2, \\"login\\"), (\\"2023-10-01 09:00\\", 1, \\"logout\\"), (\\"2023-10-01 09:00\\", 2, \\"logout\\"), ] assert max_logged_in(records) == 2","solution":"from typing import List, Tuple def max_logged_in(records: List[Tuple[str, int, str]]) -> int: events = [] for record in records: timestamp, _id, event_type = record if event_type == \\"login\\": events.append((timestamp, 1)) elif event_type == \\"logout\\": events.append((timestamp, -1)) # Sort events first by timestamp, then by type (login before logout if same timestamp) events.sort(key=lambda x: (x[0], x[1])) max_logged_in = 0 current_logged_in = 0 for event in events: current_logged_in += event[1] if current_logged_in > max_logged_in: max_logged_in = current_logged_in return max_logged_in"},{"question":"def rearrange_string(s: str, k: int) -> str: Rearrange the string such that each character appears at least k distance away from its previous occurrence. >>> rearrange_string(\\"aabbcc\\", 3) == \\"abcabc\\" >>> rearrange_string(\\"aaabc\\", 2) == \\"abaca\\" >>> rearrange_string(\\"aaabc\\", 3) == \\"-1\\" >>> rearrange_string(\\"a\\", 1) == \\"a\\" >>> rearrange_string(\\"aabbcc\\", 0) == \\"aabbcc\\"","solution":"from collections import Counter import heapq def rearrange_string(s, k): if k == 0: # If k is 0, no need to rearrange return s counter = Counter(s) max_heap = [(-value, key) for key, value in counter.items()] heapq.heapify(max_heap) result = [] wait_queue = [] while max_heap: count, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((count + 1, char)) if len(wait_queue) < k: continue to_push_back = wait_queue.pop(0) if to_push_back[0] < 0: heapq.heappush(max_heap, to_push_back) if len(result) != len(s): return \\"-1\\" return \\"\\".join(result)"},{"question":"from typing import List def rearrange_string(s: str) -> str: Reorders the characters of the string so that no two adjacent characters are the same. Returns a rearranged string or an empty string if no valid rearrangement is possible. >>> rearrange_string(\\"aab\\") 'aba' >>> rearrange_string(\\"aaab\\") ''","solution":"from collections import Counter import heapq def rearrange_string(s): Reorders the characters of the string so that no two adjacent characters are the same. Returns a rearranged string or an empty string if no valid rearrangement is possible. if not s: return \\"\\" # Count frequency of each character freq = Counter(s) # Use a max heap with negative counts for max-heap behavior max_heap = [(-count, char) for char, count in freq.items()] heapq.heapify(max_heap) # Previous character initialized as none prev_count, prev_char = 0, '' result = [] while max_heap: count, char = heapq.heappop(max_heap) # Append the character to the result result.append(char) # Since we used one occurrence of char, decrease the count if prev_count < 0: heapq.heappush(max_heap, (prev_count, prev_char)) # Update the previous character and count (convert count to positive) prev_count, prev_char = count + 1, char res_str = ''.join(result) # Check if rearranged string's length is same as original string's length return res_str if len(res_str) == len(s) else \\"\\""},{"question":"def reconstruct_secret_number(num_clues: int, clues: List[Tuple[int, int]]) -> str: Reconstructs the secret number from the given clues. :param num_clues: The number of clues :param clues: A list of tuples where each tuple contains a digit and its count :return: The reconstructed secret number as a string >>> reconstruct_secret_number(3, [(1, 2), (3, 1), (8, 3)]) == '113888' >>> reconstruct_secret_number(1, [(3, 1)]) == '3' >>> reconstruct_secret_number(0, []) == '' >>> reconstruct_secret_number(2, [(0, 4), (1, 1)]) == '00001' >>> reconstruct_secret_number(2, [(2, 2), (2, 3)]) == '22222' pass","solution":"def reconstruct_secret_number(num_clues, clues): Reconstructs the secret number from the given clues. :param num_clues: The number of clues :param clues: A list of tuples where each tuple contains a digit and its count :return: The reconstructed secret number as a string secret_number = [] for digit, count in clues: secret_number.append(str(digit) * count) # To ensure order doesn't matter, we can sort the number return ''.join(sorted(secret_number))"},{"question":"def knapsack(n: int, W: int, weights: List[int], values: List[int]) -> int: Determine the maximum value of items that can fit into a knapsack of given capacity. :param n: Number of items :param W: Capacity of the knapsack :param weights: List of weights of the items :param values: List of values of the items :return: Maximum value that fits into the knapsack >>> knapsack(4, 7, [1, 3, 4, 5], [1, 4, 5, 7]) 9 >>> knapsack(1, 1, [1], [1]) 1 >>> knapsack(3, 0, [1, 2, 3], [10, 20, 30]) 0","solution":"def knapsack(n, W, weights, values): Determine the maximum value of items that can fit into a knapsack of given capacity. :param n: Number of items :param W: Capacity of the knapsack :param weights: List of weights of the items :param values: List of values of the items :return: Maximum value that fits into the knapsack # Create a 2D DP array where dp[i][w] will hold the maximum value of the knapsack dp = [[0] * (W + 1) for _ in range(n + 1)] # Build the table dp[][] in bottom-up manner for i in range(1, n + 1): for w in range(1, W + 1): if weights[i - 1] <= w: # If including the item won't exceed the capacity dp[i][w] = max(dp[i - 1][w], dp[i - 1][w - weights[i - 1]] + values[i - 1]) else: dp[i][w] = dp[i - 1][w] # Else, don't include the item # The maximum value is found in dp[n][W] return dp[n][W]"},{"question":"def lamp_operations(n: int, q: int, operations: List[Tuple[int, int, int]]) -> List[int]: Perform a series of toggle and query operations on a set of lamps. Args: n (int): The number of lamps. q (int): The number of operations. operations (List[Tuple[int, int, int]]): The list of operations, where each operation is a tuple. Returns: List[int]: The results of the query operations. Example: >>> lamp_operations(5, 5, [(1, 2, 4), (2, 3), (2, 1), (1, 3, 5), (2, 3), (2, 5)]) [1, 0, 0, 1]","solution":"def lamp_operations(n, q, operations): lamps = [0] * (n + 1) result = [] for operation in operations: if operation[0] == 1: l, r = operation[1], operation[2] for i in range(l, r + 1): lamps[i] = 1 - lamps[i] elif operation[0] == 2: x = operation[1] result.append(lamps[x]) return result"},{"question":"from typing import List def maxProfit(prices: List[int]) -> int: Write a function to determine the maximum profit that can be achieved by buying and selling one stock over a given time period. The stock prices for each day are provided as an array, where the ith element represents the price of the stock on day i. You can only complete at most one transaction (i.e., buy one and sell one share of the stock), and you must buy before you sell. :param prices: List of integers where each represents the stock price on a given day :return: Maximum profit that can be achieved. 0 if no profit can be made. Examples: >>> maxProfit([7, 1, 5, 3, 6, 4]) 5 >>> maxProfit([7, 6, 4, 3, 1]) 0 pass # Implement the function def test_max_profit_case1(): prices = [7, 1, 5, 3, 6, 4] assert maxProfit(prices) == 5 def test_max_profit_case2(): prices = [7, 6, 4, 3, 1] assert maxProfit(prices) == 0 def test_max_profit_all_same(): prices = [5, 5, 5, 5] assert maxProfit(prices) == 0 def test_max_profit_single_day(): prices = [10] assert maxProfit(prices) == 0 def test_max_profit_decreasing_then_increasing(): prices = [6, 1, 3, 2, 4, 5] assert maxProfit(prices) == 4 def test_max_profit_increasing(): prices = [1, 2, 3, 4, 5, 6] assert maxProfit(prices) == 5 def test_max_profit_empty(): prices = [] assert maxProfit(prices) == 0","solution":"def maxProfit(prices): Finds the maximum profit that can be achieved by buying and selling one stock. :param prices: List of integers where each represents the stock price on a given day :return: Maximum profit that can be achieved. 0 if no profit can be made. if not prices: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"def next_palindrome(n: int) -> int: Alice loves palindromes, which are words or sequences that read the same backward as forward. She finds both numerical palindromes and string palindromes fascinating. However, she is particularly interested in the smallest palindrome greater than a given number. Given a positive integer \`n\`, help Alice find the smallest palindrome greater than \`n\`. >>> next_palindrome(123) == 131 >>> next_palindrome(808) == 818","solution":"def next_palindrome(n): def is_palindrome(s): return s == s[::-1] n = int(n) while True: n += 1 if is_palindrome(str(n)): return n"},{"question":"def rotate_matrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise. :param matrix: A list of list of integers representing the matrix. :return: The rotated matrix. >>> rotate_matrix([ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ]) [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] >>> rotate_matrix([ ... [1, 2], ... [3, 4] ... ]) [ [3, 1], [4, 2] ]","solution":"def rotate_matrix(matrix): Rotates the given n x n 2D matrix by 90 degrees clockwise. :param matrix: A list of list of integers representing the matrix. :return: The rotated matrix. n = len(matrix) for i in range(n // 2): for j in range(i, n - i - 1): # Save the top element top = matrix[i][j] # Move left to top matrix[i][j] = matrix[n - 1 - j][i] # Move bottom to left matrix[n - 1 - j][i] = matrix[n - 1 - i][n - 1 - j] # Move right to bottom matrix[n - 1 - i][n - 1 - j] = matrix[j][n - 1 - i] # Assign top to right matrix[j][n - 1 - i] = top return matrix"},{"question":"def min_workstations(N: int, C: int) -> int: Returns the minimum number of workstations required to accommodate all employees. Parameters: N (int): Number of employees C (int): Capacity of each workstation Returns: int: Minimum number of workstations required Example: >>> min_workstations(10, 5) 2 >>> min_workstations(25, 5) 5 >>> min_workstations(10, 3) 4 >>> min_workstations(7, 2) 4","solution":"def min_workstations(N, C): Returns the minimum number of workstations required to accommodate all employees. Parameters: N (int): Number of employees C (int): Capacity of each workstation Returns: int: Minimum number of workstations required return (N + C - 1) // C"},{"question":"def determine_winner(S: str) -> str: Determines the winner of the game between Alice and Bob based on the string S. Parameters: S (str): The input string consisting of lowercase English letters. Returns: str: The winner of the game (\\"Alice\\" or \\"Bob\\"). >>> determine_winner(\\"ababa\\") 'Alice' >>> determine_winner(\\"abcde\\") 'Bob' >>> determine_winner(\\"aaabaaa\\") 'Alice' # Your code here # Unit Tests def test_example_cases(): assert determine_winner(\\"ababa\\") == \\"Alice\\" assert determine_winner(\\"abcde\\") == \\"Bob\\" assert determine_winner(\\"aaabaaa\\") == \\"Alice\\" def test_no_repeated_substring(): assert determine_winner(\\"abcdefg\\") == \\"Bob\\" # All unique substrings def test_all_characters_same(): assert determine_winner(\\"aaaaaa\\") == \\"Alice\\" # All 'a's are the same, repeated def test_mixed_repeats(): assert determine_winner(\\"abcabc\\") == \\"Alice\\" # 'abc' is repeated def test_single_character(): assert determine_winner(\\"a\\") == \\"Bob\\" # Single character, no possible moves def test_longer_no_repeat(): assert determine_winner(\\"abcdefghijk\\") == \\"Bob\\" # Longer string with no repeats def test_edges(): assert determine_winner(\\"aabbcc\\") == \\"Alice\\" # Multiple repeated substrings","solution":"def determine_winner(S): Determines the winner of the game between Alice and Bob based on the string S. Parameters: S (str): The input string consisting of lowercase English letters. Returns: str: The winner of the game (\\"Alice\\" or \\"Bob\\"). # To find repeated substrings we can use a set seen = set() for i in range(len(S)): for j in range(i + 1, len(S) + 1): substring = S[i:j] if substring in seen: return \\"Alice\\" seen.add(substring) return \\"Bob\\""},{"question":"def sum_of_concatenated_digits(n: int) -> int: Returns the sum of all the digits in the number formed by concatenating all the integers from 1 to n into a single string. :param n: The maximum number up to which integers are concatenated. :type n: int :return: Sum of all digits in the concatenated string. :rtype: int >>> sum_of_concatenated_digits(12) 51 >>> sum_of_concatenated_digits(5) 15","solution":"def sum_of_concatenated_digits(n): Returns the sum of all the digits in the number formed by concatenating all the integers from 1 to n into a single string. :param n: The maximum number up to which integers are concatenated. :type n: int :return: Sum of all digits in the concatenated string. :rtype: int concatenated_string = ''.join(str(i) for i in range(1, n + 1)) return sum(int(digit) for digit in concatenated_string)"},{"question":"def min_buildings_to_increase(n: int, heights: List[int]) -> int: Determine the minimum number of buildings that need their height increased to make the array of building heights strictly non-decreasing. :param n: int, number of buildings :param heights: list of int, heights of each building :return: int, minimum number of buildings to adjust >>> min_buildings_to_increase(6, [1, 3, 2, 5, 4, 6]) == 2 >>> min_buildings_to_increase(5, [2, 2, 2, 2, 2]) == 0 >>> min_buildings_to_increase(4, [8, 7, 6, 5]) == 3","solution":"def min_buildings_to_increase(n, heights): Determine the minimum number of buildings that need their height increased to make the array of building heights strictly non-decreasing. :param n: int, number of buildings :param heights: list of int, heights of each building :return: int, minimum number of buildings to adjust adjustments = 0 for i in range(1, n): if heights[i] < heights[i - 1]: adjustments += 1 heights[i] = heights[i - 1] return adjustments"},{"question":"def matrix_sum_queries(n: int, m: int, matrix: List[List[int]], queries: List[Tuple[int, int, int, int]]) -> List[int]: Calculate the sum of elements in each submatrix defined by the given queries. Parameters: n (int): Number of rows in the matrix. m (int): Number of columns in the matrix. matrix (List[List[int]]): 2D list of integers representing the matrix. queries (List[Tuple[int, int, int, int]]): A list of tuples each containing four integers x1, y1, x2, y2 describing the submatrix. Returns: List[int]: A list of integers representing the sum of elements in each submatrix specified by the queries. >>> matrix_sum_queries(3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [(1, 1, 2, 2), (2, 2, 3, 3)]) [12, 28] >>> matrix_sum_queries(2, 2, [[1, 2], [3, 4]], [(1, 1, 1, 1), (2, 2, 2, 2)]) [1, 4]","solution":"def matrix_sum_queries(n, m, matrix, queries): # Create a prefix sum matrix prefix_sum = [[0] * (m+1) for _ in range(n+1)] # Fill the prefix sum matrix for i in range(1, n+1): for j in range(1, m+1): prefix_sum[i][j] = matrix[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] results = [] # Process each query for x1, y1, x2, y2 in queries: total = prefix_sum[x2][y2] - prefix_sum[x1-1][y2] - prefix_sum[x2][y1-1] + prefix_sum[x1-1][y1-1] results.append(total) return results # Example usage n = 3 m = 3 matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] queries = [(1, 1, 2, 2), (2, 2, 3, 3)] print(matrix_sum_queries(n, m, matrix, queries)) # Output: [12, 28]"},{"question":"from typing import List def min_steps_with_breaking_wall(n: int, m: int, grid: List[str]) -> int: Determine the minimum number of steps required to reach the bottom-right corner from the top-left corner in a maze, where you are allowed to break exactly one wall. Args: n: int : number of rows in the grid m: int : number of columns in the grid grid: List[str] : representation of the maze grid where '#' is a wall and '.' is a free path Returns: int : the minimum number of steps required to reach the goal or -1 if it's not possible Examples: >>> min_steps_with_breaking_wall(5, 6, [ ... \\"......\\", ... \\".#..#.\\", ... \\"..\\", ... \\".#.#..\\", ... \\"......\\" ... ]) == 9 >>> min_steps_with_breaking_wall(3, 3, [ ... \\".#.\\", ... \\"#\\", ... \\".#.\\" ... ]) == -1 >>> min_steps_with_breaking_wall(4, 5, [ ... \\"....#\\", ... \\"..#\\", ... \\".#.#.\\", ... \\".#.\\" ... ]) == 7 >>> min_steps_with_breaking_wall(2, 2, [ ... \\"..\\", ... \\"..\\" ... ]) == 2 >>> min_steps_with_breaking_wall(3, 4, [ ... \\".#..\\", ... \\"..\\", ... \\"....\\" ... ]) == 5 pass","solution":"from collections import deque def min_steps_with_breaking_wall(n, m, grid): def bfs(start): que = deque([start]) distances = [[[-1, -1] for _ in range(m)] for _ in range(n)] distances[start[0]][start[1]][start[2]] = 0 directions = [(1, 0), (0, 1), (-1, 0), (0, -1)] while que: x, y, wall_used = que.popleft() current_distance = distances[x][y][wall_used] if (x, y) == (n-1, m-1): return current_distance for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m: if grid[nx][ny] == '.' and distances[nx][ny][wall_used] == -1: distances[nx][ny][wall_used] = current_distance + 1 que.append((nx, ny, wall_used)) elif grid[nx][ny] == '#' and wall_used == 0 and distances[nx][ny][1] == -1: distances[nx][ny][1] = current_distance + 1 que.append((nx, ny, 1)) return -1 return bfs((0, 0, 0))"},{"question":"def min_traffic_lights_to_install(N: int, M: int, grid: List[str]) -> int: Determine the minimum number of intersections that need to install traffic lights so that every vertical street has at least one traffic light and every horizontal street has at least one traffic light. >>> min_traffic_lights_to_install(3, 3, [\\"101\\", \\"010\\", \\"001\\"]) 0 >>> min_traffic_lights_to_install(2, 2, [\\"00\\", \\"00\\"]) 2 >>> min_traffic_lights_to_install(4, 4, [\\"1000\\", \\"0000\\", \\"0000\\", \\"0001\\"]) 2 >>> min_traffic_lights_to_install(3, 3, [\\"111\\", \\"111\\", \\"111\\"]) 0 >>> min_traffic_lights_to_install(1, 1, [\\"0\\"]) 1 >>> min_traffic_lights_to_install(1, 1, [\\"1\\"]) 0 >>> min_traffic_lights_to_install(1000, 1000, [\\"0\\" * 1000] * 1000) 1000 >>> min_traffic_lights_to_install(2, 3, [\\"100\\", \\"010\\"]) 1","solution":"def min_traffic_lights_to_install(N, M, grid): # Determine which rows and columns already have a traffic light. rows_with_light = [False] * N cols_with_light = [False] * M for r in range(N): for c in range(M): if grid[r][c] == '1': rows_with_light[r] = True cols_with_light[c] = True # Count the number of rows and columns that do not have a traffic light. rows_without_light = rows_with_light.count(False) cols_without_light = cols_with_light.count(False) # The minimum number of lights to install will be the maximum of these counts return max(rows_without_light, cols_without_light) # Read input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [data[i] for i in range(2, 2 + N)] print(min_traffic_lights_to_install(N, M, grid))"},{"question":"from typing import List class TaskList: A class to manage a list of tasks with priorities. Methods: - add_task(description: str, priority: int): Adds a task with the given description and priority to the list. - get_sorted_tasks() -> List[str]: Returns a list of task descriptions sorted by priority in descending order. >>> task_list = TaskList() >>> task_list.add_task(\\"Buy groceries\\", 2) >>> task_list.add_task(\\"Wash car\\", 5) >>> task_list.get_sorted_tasks() ['Wash car', 'Buy groceries'] >>> task_list.add_task(\\"Learn coding\\", 3) >>> task_list.get_sorted_tasks() ['Wash car', 'Learn coding', 'Buy groceries'] def __init__(self): self.tasks = [] def add_task(self, description: str, priority: int): pass def get_sorted_tasks(self) -> List[str]: pass","solution":"from typing import List class TaskList: def __init__(self): self.tasks = [] def add_task(self, description: str, priority: int): self.tasks.append((priority, description)) def get_sorted_tasks(self) -> List[str]: # Sort tasks by priority (descending), keeping original order if priorities are the same sorted_tasks = sorted(self.tasks, key=lambda x: (-x[0], self.tasks.index(x))) return [task[1] for task in sorted_tasks]"},{"question":"def can_distribute_evenly(n: int, rewards: List[int]) -> str: Determines if it is possible to evenly distribute the rewards among all the customers. :param n: Number of customers who submitted the survey (integer). :param rewards: List of integers where each integer represents the ID of a reward chosen by a customer. :return: \\"YES\\" if it is possible to distribute the rewards evenly, otherwise \\"NO\\". >>> can_distribute_evenly(5, [1, 2, 2, 1, 3]) \\"NO\\" >>> can_distribute_evenly(6, [3, 3, 1, 1, 2, 2]) \\"YES\\"","solution":"def can_distribute_evenly(n, rewards): Determines if it is possible to evenly distribute the rewards among all the customers. :param n: Number of customers who submitted the survey (integer). :param rewards: List of integers where each integer represents the ID of a reward chosen by a customer. :return: \\"YES\\" if it is possible to distribute the rewards evenly, otherwise \\"NO\\". unique_rewards = set(rewards) types_of_rewards = len(unique_rewards) if n % types_of_rewards == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def can_form_palindrome(s: str) -> str: Determines if a given string can be rearranged to form a palindrome. Returns \\"YES\\" if it can be rearranged, otherwise returns \\"NO\\". >>> can_form_palindrome('racecar') 'YES' >>> can_form_palindrome('civicapp') 'NO' >>> can_form_palindrome('a') 'YES' >>> can_form_palindrome('aaabbbb') 'YES' >>> can_form_palindrome('abcdef') 'NO'","solution":"def can_form_palindrome(s): Determines if a given string can be rearranged to form a palindrome. Returns \\"YES\\" if it can be rearranged, otherwise returns \\"NO\\". from collections import Counter char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) if odd_count > 1: return \\"NO\\" return \\"YES\\""},{"question":"def can_travel_between_locations(N, M, roads, queries): Determine whether it's possible to travel between any two given locations using the roads in the city's plan. Args: N (int): Number of locations (1  N  100) M (int): Number of desired roads (0  M  1000) roads (List[Tuple[int, int]]): List of bidirectional roads queries (List[Tuple[int, int]]): List of query pairs Returns: List[str]: \\"YES\\" if there is a path between the queried locations, \\"NO\\" otherwise. Examples: >>> can_travel_between_locations(5, 3, [(1, 2), (2, 3), (4, 5)], [(1, 3), (3, 5)]) [\\"YES\\", \\"NO\\"] >>> can_travel_between_locations(4, 4, [(1, 2), (2, 3), (3, 4), (1, 4)], [(1, 4), (2, 4), (1, 3)]) [\\"YES\\", \\"YES\\", \\"YES\\"]","solution":"def can_travel_between_locations(N, M, roads, queries): from collections import defaultdict, deque def bfs(start, end): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node == end: return True if node not in visited: visited.add(node) queue.extend(graph[node] - visited) return False graph = defaultdict(set) for u, v in roads: graph[u].add(v) graph[v].add(u) results = [] for u, v in queries: if bfs(u, v): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def rearrange_array(n: int, arr: List[int]) -> Union[List[int], int]: Rearranges the array so that every pair of adjacent elements has a different parity (one is even, the other is odd). If it is not possible, returns -1. >>> rearrange_array(4, [4, 3, 2, 1]) [4, 3, 2, 1] >>> rearrange_array(5, [1, 3, 5, 7, 9]) -1 >>> rearrange_array(6, [1, 2, 3, 4, 5, 6]) in [[1, 2, 3, 4, 5, 6], [2, 1, 4, 3, 6, 5], [2, 1, 4, 3, 6, 5], [1, 2, 3, 4, 5, 6]] >>> rearrange_array(7, [2, 4, 6, 8, 1, 3, 5]) [2, 1, 4, 3, 6, 5, 8] >>> rearrange_array(4, [2, 4, 6, 8]) -1 >>> rearrange_array(1, [1]) [1]","solution":"def rearrange_array(n, arr): Rearranges the array so that every pair of adjacent elements has a different parity (one is even, the other is odd). If it is not possible, returns -1. odd = [x for x in arr if x % 2 != 0] even = [x for x in arr if x % 2 == 0] # If the difference between the count of odd and even numbers is greater than 1, it's impossible if abs(len(odd) - len(even)) > 1: return -1 result = [] # Start with the larger of the two counts if len(odd) > len(even): for i in range(len(even)): result.append(odd[i]) result.append(even[i]) result.append(odd[-1]) else: for i in range(len(odd)): result.append(even[i]) result.append(odd[i]) if len(even) > len(odd): result.append(even[-1]) return result"},{"question":"from typing import List, Tuple def mall_navigation(datasets: List[Tuple[Tuple[int, int, int, int], List[Tuple[int, int, str]]]]) -> List[str]: Determine if it is possible to travel from the start room to the goal room in a mall. >>> mall_navigation([((5, 7, 1, 5), [(1, 2, \\"corridor\\"), (2, 3, \\"escalator\\"), (3, 4, \\"corridor\\"), (4, 5, \\"corridor\\"), (2, 5, \\"corridor\\"), (3, 5, \\"elevator\\"), (1, 3, \\"escalator\\")]), ((4, 4, 1, 4), [(1, 2, \\"corridor\\"), (2, 3, \\"escalator\\"), (3, 4, \\"escalator\\"), (4, 1, \\"elevator\\")]), ((4, 4, 1, 3), [(1, 2, \\"elevator\\"), (2, 3, \\"corridor\\"), (3, 4, \\"corridor\\"), (1, 3, \\"escalator\\")])]) ['Reachable', 'Reachable', 'Reachable'] pass def parse_input(input_str: str) -> List[Tuple[Tuple[int, int, int, int], List[Tuple[int, int, str]]]]: Parse the input string into a list of datasets. >>> parse_input(\\"5 7 1 5n1 2 corridorn2 3 escalatorn3 4 corridorn4 5 corridorn2 5 corridorn3 5 elevatorn1 3 escalatorn0 0 0 0\\") [((5, 7, 1, 5), [(1, 2, \\"corridor\\"), (2, 3, \\"escalator\\"), (3, 4, \\"corridor\\"), (4, 5, \\"corridor\\"), (2, 5, \\"corridor\\"), (3, 5, \\"elevator\\"), (1, 3, \\"escalator\\")])] pass","solution":"def mall_navigation(datasets): from collections import defaultdict, deque results = [] for data in datasets: x, y, s, g = data[0] connections = data[1] adjacency_list = defaultdict(list) for p, q, type_ in connections: adjacency_list[p].append(q) if type_ == \\"elevator\\": adjacency_list[q].append(p) def bfs(start, goal): queue = deque([start]) visited = set() while queue: current = queue.popleft() if current == goal: return True visited.add(current) for neighbor in adjacency_list[current]: if neighbor not in visited: queue.append(neighbor) return False if bfs(s, g): results.append(\\"Reachable\\") else: results.append(\\"Unreachable\\") return results def parse_input(input_str): datasets = [] lines = input_str.strip().split('n') i = 0 while i < len(lines): x, y, s, g = map(int, lines[i].split()) if x == 0 and y == 0 and s == 0 and g == 0: break i += 1 connections = [] for _ in range(y): p, q, type_ = lines[i].split() connections.append((int(p), int(q), type_)) i += 1 datasets.append(((x, y, s, g), connections)) return datasets"},{"question":"from typing import List def manipulate_list(int_list: List[int], operations: List[str]) -> List[int]: Apply a sequence of operations to a list of integers. Parameters: - int_list: List[int], the list of integers. - operations: List[str], the list of operations in the format described. Returns: - List[int], the modified list of integers. pass def process_input(input_string: str) -> List[int]: Processes the input string and calls the manipulate_list function. Parameters: - input_string: str, multiline string with the input in the described format. Returns: - List[int], the manipulated list of integers. pass # Example usage: # >>> process_input('3 5 -2 7 4n3nadd 2 3nmultiply 1 4nset 4 10') # [3, 20, 1, 7, 10] # Unit tests def test_manipulate_list(): assert manipulate_list([3, 5, -2, 7, 4], ['add 2 3', 'multiply 1 4', 'set 4 10']) == [3, 20, 1, 7, 10] assert manipulate_list([0, 0, 0, 0, 0], ['add 0 1', 'add 1 1', 'add 2 1', 'add 3 1', 'add 4 1']) == [1, 1, 1, 1, 1] assert manipulate_list([1, 2, 3, 4, 5], ['multiply 0 2', 'multiply 1 2', 'multiply 2 2', 'multiply 3 2', 'multiply 4 2']) == [2, 4, 6, 8, 10] assert manipulate_list([-1, -2, -3, -4, -5], ['set 0 5', 'set 1 4', 'set 2 3', 'set 3 2', 'set 4 1']) == [5, 4, 3, 2, 1] assert manipulate_list([10, 20], ['add 0 -10', 'multiply 1 0']) == [0, 0] def test_process_input(): assert process_input('3 5 -2 7 4n3nadd 2 3nmultiply 1 4nset 4 10') == [3, 20, 1, 7, 10] assert process_input('0 0 0 0 0n5nadd 0 1nadd 1 1nadd 2 1nadd 3 1nadd 4 1') == [1, 1, 1, 1, 1] assert process_input('1 2 3 4 5n5nmultiply 0 2nmultiply 1 2nmultiply 2 2nmultiply 3 2nmultiply 4 2') == [2, 4, 6, 8, 10] assert process_input('-1 -2 -3 -4 -5n5nset 0 5nset 1 4nset 2 3nset 3 2nset 4 1') == [5, 4, 3, 2, 1] assert process_input('10 20n2nadd 0 -10nmultiply 1 0') == [0, 0]","solution":"def manipulate_list(int_list, operations): Apply a sequence of operations to a list of integers. Parameters: - int_list: List[int], the list of integers. - operations: List[str], the list of operations in the format described. Returns: - List[int], the modified list of integers. for operation in operations: operation_split = operation.split() op, x, y = operation_split[0], int(operation_split[1]), int(operation_split[2]) if op == 'add': int_list[x] += y elif op == 'multiply': int_list[x] *= y elif op == 'set': int_list[x] = y return int_list def process_input(input_string): Processes the input string and calls the manipulate_list function. Parameters: - input_string: str, multiline string with the input in the described format. Returns: - List[int], the manipulated list of integers. input_lines = input_string.strip().split('n') int_list = list(map(int, input_lines[0].split())) num_operations = int(input_lines[1]) operations = input_lines[2:2 + num_operations] result = manipulate_list(int_list, operations) return result"},{"question":"def is_divisible(n: int, k: int) -> str: Check if n is divisible by k. Return 'YES' if divisible, otherwise return 'NO'. >>> is_divisible(10, 2) 'YES' >>> is_divisible(10, 3) 'NO' >>> is_divisible(1000000000, 1) 'YES' >>> is_divisible(1, 1) 'YES' >>> is_divisible(10**9, 2) 'YES' >>> is_divisible(10**9, 10**8 + 1) 'NO'","solution":"def is_divisible(n, k): Check if n is divisible by k. Return 'YES' if divisible, otherwise return 'NO'. return \\"YES\\" if n % k == 0 else \\"NO\\""},{"question":"from typing import List def shortest_transformation_chain(start: str, end: str, word_list: List[str]) -> int: Given a start word, an end word, and a list of words, find the shortest chain to transform the start word into the end word. Each transformed word must exist in the given list of words, and only one letter can be changed at a time. Args: start (str): Starting word end (str): Ending word word_list (List[str]): List of words Returns: int: Length of the shortest transformation chain or -1 if no such chain exists Examples: >>> shortest_transformation_chain(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> shortest_transformation_chain(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\"]) -1 >>> shortest_transformation_chain(\\"a\\", \\"c\\", [\\"a\\", \\"b\\", \\"c\\"]) 2 >>> shortest_transformation_chain(\\"hit\\", \\"hot\\", [\\"hot\\"]) 2 >>> shortest_transformation_chain(\\"hit\\", \\"cog\\", [\\"hit\\", \\"hot\\", \\"dot\\", \\"dog\\", \\"cog\\", \\"lot\\", \\"log\\", \\"lit\\", \\"lie\\", \\"pie\\", \\"poi\\", \\"pot\\"]) 5","solution":"from collections import deque def shortest_transformation_chain(start, end, word_list): word_set = set(word_list) if end not in word_set: return -1 queue = deque([(start, 1)]) visited = set() while queue: current_word, length = queue.popleft() if current_word == end: return length for i in range(len(current_word)): for c in 'abcdefghijklmnopqrstuvwxyz': new_word = current_word[:i] + c + current_word[i+1:] if new_word in word_set and new_word not in visited: visited.add(new_word) queue.append((new_word, length + 1)) return -1"},{"question":"def count_distinct_configurations(N: int) -> int: Returns the number of distinct configurations for N stones placed on N positions. >>> count_distinct_configurations(1) 1 >>> count_distinct_configurations(2) 2 >>> count_distinct_configurations(3) 6 >>> count_distinct_configurations(4) 24 >>> count_distinct_configurations(5) 120 >>> count_distinct_configurations(6) 720 >>> count_distinct_configurations(7) 5040 >>> count_distinct_configurations(8) 40320 pass","solution":"import itertools def count_distinct_configurations(N): Returns the number of distinct configurations for N stones placed on N positions. # generate all permutations of stones for N positions positions = [i + 1 for i in range(N)] all_permutations = list(itertools.permutations(positions, N)) return len(all_permutations)"},{"question":"def has_subarray_with_sum(arr, k): Determines if there exists a contiguous subarray with a sum equal to k. :param arr: List[int] - A list of integers :param k: int - The target sum :return: str - \\"YES\\" if such a subarray exists, \\"NO\\" otherwise >>> has_subarray_with_sum([1, 2, 3, 7, 5], 12) \\"YES\\" >>> has_subarray_with_sum([1, 2, 3, 4], 10) \\"YES\\" >>> has_subarray_with_sum([1, 2, 3], 7) \\"NO\\" from solution import has_subarray_with_sum def test_subarray_exists_1(): assert has_subarray_with_sum([1, 2, 3, 7, 5], 12) == \\"YES\\" def test_subarray_exists_2(): assert has_subarray_with_sum([1, 2, 3, 4], 10) == \\"YES\\" def test_subarray_not_exists(): assert has_subarray_with_sum([1, 2, 3], 7) == \\"NO\\" def test_empty_array(): assert has_subarray_with_sum([], 5) == \\"NO\\" def test_single_element_equals_k(): assert has_subarray_with_sum([5], 5) == \\"YES\\" def test_single_element_not_equals_k(): assert has_subarray_with_sum([5], 10) == \\"NO\\" def test_negative_elements(): assert has_subarray_with_sum([-1, -2, -3, -4], -10) == \\"YES\\" def test_mixed_sign_elements(): assert has_subarray_with_sum([1, -1, 2, 3, -2, 4], 4) == \\"YES\\"","solution":"def has_subarray_with_sum(arr, k): Determines if there exists a contiguous subarray with a sum equal to k. n = len(arr) current_sum = 0 sum_dict = {} for i in range(n): current_sum += arr[i] if current_sum == k: return \\"YES\\" if (current_sum - k) in sum_dict: return \\"YES\\" sum_dict[current_sum] = i return \\"NO\\""},{"question":"def count_distinct_pairs(s: str) -> int: Returns the number of distinct subsequences that consist of pairs of identical characters. >>> count_distinct_pairs(\\"abca\\") 1 >>> count_distinct_pairs(\\"abcdef\\") 0 >>> count_distinct_pairs(\\"aabbccdd\\") 4 >>> count_distinct_pairs(\\"abcdefghijklmnopqrstuvwxyz\\") 0 >>> count_distinct_pairs(\\"aaaaaaaa\\") 4 >>> count_distinct_pairs(\\"aabbccddeeff\\") 6 >>> count_distinct_pairs(\\"\\") 0 >>> count_distinct_pairs(\\"a\\") 0 >>> count_distinct_pairs(\\"a\\"*2000) 1000","solution":"def count_distinct_pairs(s): Returns the number of distinct subsequences that consist of pairs of identical characters. from collections import Counter char_count = Counter(s) return sum(v // 2 for v in char_count.values())"},{"question":"def sum_of_digits(n: int) -> int: Returns the sum of the digits of the number n. >>> sum_of_digits(123) 6 >>> sum_of_digits(456) 15 >>> sum_of_digits(7890) 24 >>> sum_of_digits(0) 0 >>> sum_of_digits(9) 9 def process_test_cases(test_cases: List[int]) -> List[int]: Given a list of integers, returns a list of the sums of digits for each integer. >>> process_test_cases([123, 456, 7890, 0]) [6, 15, 24, 0] >>> process_test_cases([1, 22, 333, 4444]) [1, 4, 9, 16] >>> process_test_cases([1000, 9999, 5005]) [1, 36, 10]","solution":"def sum_of_digits(n): Returns the sum of the digits of the number n. return sum(int(digit) for digit in str(n)) def process_test_cases(test_cases): Given a list of integers, returns a list of the sums of digits for each integer. results = [] for case in test_cases: results.append(sum_of_digits(case)) return results"},{"question":"def longest_subseq_with_k_distinct_chars(s: str, k: int) -> int: Given a string s and an integer k, determine the length of the longest contiguous subsequence that contains exactly k distinct characters. >>> longest_subseq_with_k_distinct_chars(\\"abcba\\", 2) 3 >>> longest_subseq_with_k_distinct_chars(\\"aaabbc\\", 3) 6 def process_input(t: int, test_cases: List[Tuple[str, int]]) -> List[int]: Given the number of test cases and a list of tuples each containing a string s and an integer k, return a list of results for each test case. >>> process_input(2, [(\\"abcba\\", 2), (\\"aaabbc\\", 3)]) [3, 6]","solution":"def longest_subseq_with_k_distinct_chars(s, k): from collections import defaultdict n = len(s) if k > n: return 0 char_count = defaultdict(int) max_length = 0 start = 0 distinct_count = 0 for end in range(n): char_count[s[end]] += 1 if char_count[s[end]] == 1: distinct_count += 1 while distinct_count > k: char_count[s[start]] -= 1 if char_count[s[start]] == 0: distinct_count -= 1 start += 1 if distinct_count == k: max_length = max(max_length, end - start + 1) return max_length def process_input(t, test_cases): results = [] for s, k in test_cases: results.append(longest_subseq_with_k_distinct_chars(s, k)) return results"},{"question":"def isBalanced(s: str) -> bool: Determines if a string of brackets is balanced. Args: s (str): A string containing only '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is balanced, False otherwise. >>> isBalanced(\\"()\\") True >>> isBalanced(\\"([{}])\\") True >>> isBalanced(\\"([)]\\") False >>> isBalanced(\\"{([])}\\") True >>> isBalanced(\\"{{[[(())]]}}\\") True >>> isBalanced(\\"{[}\\") False","solution":"def isBalanced(s): Determines if a string of brackets is balanced. Args: s (str): A string containing only '(', ')', '{', '}', '[' and ']'. Returns: bool: True if the string is balanced, False otherwise. stack = [] brackets = {'(': ')', '{': '}', '[': ']'} for char in s: if char in brackets: stack.append(char) elif char in brackets.values(): if not stack or brackets[stack.pop()] != char: return False return not stack"},{"question":"def max_subarray_sum(nums): Returns the maximum sum of any non-empty subarray in nums. Args: nums: A list of integers. Returns: An integer representing the maximum sum of any subarray. Examples: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-2, -3, -1, -5]) -1","solution":"def max_subarray_sum(nums): Returns the maximum sum of any non-empty subarray in nums. Args: nums: A list of integers. Returns: An integer representing the maximum sum of any subarray. if not nums: return 0 max_current = max_global = nums[0] for num in nums[1:]: max_current = max(num, max_current + num) max_global = max(max_global, max_current) return max_global"},{"question":"def rearrange_string(s: str, k: int) -> str: Rearrange the string so that the same characters are at least k distance apart. Returns the rearranged string if possible, otherwise returns an empty string. >>> rearrange_string(\\"aabbcc\\", 3) \\"abcabc\\" >>> rearrange_string(\\"aaabc\\", 2) \\"abaca\\" >>> rearrange_string(\\"aa\\", 2) \\"\\"","solution":"import heapq from collections import Counter def rearrange_string(s, k): Rearrange the string so that the same characters are at least k distance apart. Returns the rearranged string if possible, otherwise returns an empty string. if k == 0: return s counter = Counter(s) max_heap = [] for char, freq in counter.items(): heapq.heappush(max_heap, (-freq, char)) result = [] wait_queue = [] while max_heap: freq, char = heapq.heappop(max_heap) result.append(char) wait_queue.append((freq + 1, char)) # Decrement the frequency and add to wait queue if len(wait_queue) < k: continue freq, char = wait_queue.pop(0) # Reinsert the character back into heap if k distance is maintained if -freq != 0: heapq.heappush(max_heap, (freq, char)) return \\"\\".join(result) if len(result) == len(s) else \\"\\""},{"question":"def process_events(t: int, events: List[str]) -> None: Processes a series of events related to players joining a game, losing lives, and leaving the game. Args: t (int): The number of events. events (List[str]): A list of event strings. Prints: The list of active players and their remaining lives in the order they were added to the game. If no players are active, prints \\"No active players\\". >>> process_events(6, [\\"JOIN player1 3\\", \\"JOIN player2 5\\", \\"HIT player1\\", \\"HIT player2\\", \\"HIT player1\\", \\"EXIT player2\\"]) player1 1 >>> process_events(5, [\\"JOIN alpha 4\\", \\"JOIN beta 2\\", \\"HIT beta\\", \\"HIT beta\\", \\"HIT alpha\\"]) alpha 3 >>> process_events(3, [\\"JOIN admin 3\\", \\"HIT admin\\", \\"EXIT admin\\"]) No active players","solution":"def process_events(t, events): players = {} for event in events: parts = event.split() command = parts[0] username = parts[1] if command == \\"JOIN\\": lives = int(parts[2]) players[username] = lives elif command == \\"HIT\\": if username in players: players[username] -= 1 if players[username] == 0: del players[username] elif command == \\"EXIT\\": if username in players: del players[username] if not players: print(\\"No active players\\") else: for username in events: if username.startswith(\\"JOIN\\") or username.startswith(\\"EXIT\\"): username = username.split()[1] if username in players: print(f\\"{username} {players[username]}\\")"},{"question":"def shortest_length_after_transformations(L: int, K: int, s: str) -> int: Determine the shortest possible length of the resultant string after K transformations. :param L: Length of the string s (1  L  2000) :param K: Number of transformations (1  K  1000) :param s: A string of length L consisting of lowercase English letters :return: The length of the resultant string after applying the transformation K times >>> shortest_length_after_transformations(4, 1, \\"abcd\\") 8 >>> shortest_length_after_transformations(4, 2, \\"abcd\\") 12 >>> shortest_length_after_transformations(3, 3, \\"abc\\") 12","solution":"def shortest_length_after_transformations(L, K, s): Function to determine the shortest possible length of the resultant string after K transformations. :param L: Length of the string s (1  L  2000) :param K: Number of transformations (1  K  1000) :param s: A string of length L consisting of lowercase English letters :return: The length of the resultant string after applying the transformation K times if K == 0: return L new_length = L + L * K return new_length"},{"question":"def max_gold(n: int, grid: List[List[int]]) -> int: Calculate the maximum amount of gold that can be collected while moving from the top-left cell to the bottom-right cell in an n x n grid. >>> max_gold(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold(4, [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) 28","solution":"def max_gold(n, grid): # Initialize a DP table where dp[i][j] will store the maximum gold collected to reach cell (i, j) dp = [[0] * n for _ in range(n)] # Base case: start from the top-left cell dp[0][0] = grid[0][0] # Fill the first row (since we can only move right in the first row) for j in range(1, n): dp[0][j] = dp[0][j-1] + grid[0][j] # Fill the first column (since we can only move down in the first column) for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, n): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + grid[i][j] # The bottom-right cell contains the maximum gold collected return dp[n-1][n-1]"},{"question":"def min_bins(capacity: int, weights: List[int]) -> int: Calculate the minimum number of bins required to pack all items such that no bin exceeds the given capacity. :param capacity: Maximum capacity of each bin. :param weights: List of weights of items. :return: Minimum number of bins required. >>> min_bins(10, [2, 5, 4, 7, 1, 3]) 3 >>> min_bins(5, [3, 3, 3, 3]) 4 >>> min_bins(15, [1, 15, 8, 3, 3, 8, 5]) 3 >>> min_bins(20, [10, 10, 20]) 2 >>> min_bins(10, []) 0 >>> min_bins(1000000000, [500000000, 500000000, 500000000]) 2","solution":"def min_bins(capacity, weights): Calculate the minimum number of bins required to pack all items such that no bin exceeds the given capacity. :param capacity: Maximum capacity of each bin. :param weights: List of weights of items. :return: Minimum number of bins required. weights.sort(reverse=True) bins = [] for weight in weights: placed = False for b in bins: if sum(b) + weight <= capacity: b.append(weight) placed = True break if not placed: bins.append([weight]) return len(bins) if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().strip().split() capacity = int(data[0]) num_items = int(data[1]) weights = list(map(int, data[2:])) print(min_bins(capacity, weights))"},{"question":"def min_cameras(n: int, m: int) -> int: Returns the minimum number of cameras needed to monitor an n x m grid. >>> min_cameras(2, 3) 2 >>> min_cameras(4, 4) 4 >>> min_cameras(1, 1) 1 >>> min_cameras(10, 5) 5 >>> min_cameras(6, 9) 6 >>> min_cameras(1000, 1) 1 >>> min_cameras(1000, 1000) 1000","solution":"def min_cameras(n, m): Returns the minimum number of cameras needed to monitor an n x m grid. # The minimum number of cameras needed is determined by the smaller of the two dimensions return min(n, m)"},{"question":"def minimum_cost_to_connect_villages(n: int, terr: List[int], h: int, p: int, m: int) -> int: Determine the minimum cost to connect all villages given the number of villages, their terrain types, and the costs to build roads based on the terrain. >>> minimum_cost_to_connect_villages(4, [1, 0, 0, 1], 3, 2, 1) 6 >>> minimum_cost_to_connect_villages(3, [1, 1, 1], 1, 5, 2) 2","solution":"def minimum_cost_to_connect_villages(n, terr, h, p, m): hill_count = terr.count(1) plain_count = terr.count(0) if hill_count == 0: return (n - 1) * p elif plain_count == 0: return (n - 1) * h else: total_cost = 0 # Cost of connecting hills and plains separately total_cost += (hill_count - 1) * h total_cost += (plain_count - 1) * p # Cost of connecting one hill to one plain total_cost += m return total_cost"},{"question":"def longest_interesting_subarray(arr: List[int]) -> int: Returns the length of the longest interesting subarray in \`arr\`. An interesting subarray is defined by a consistent absolute difference between any two consecutive elements. >>> longest_interesting_subarray([2, 4, 6, 8, 10, 12]) == 6 >>> longest_interesting_subarray([1, 3, 5, 8, 10, 12, 14]) == 4 >>> longest_interesting_subarray([5]) == 1 >>> longest_interesting_subarray([5, 10]) == 2 >>> longest_interesting_subarray([4, 4, 4, 4]) == 4 >>> longest_interesting_subarray([1, 2, 4, 7, 11]) == 2 >>> longest_interesting_subarray([1, 4, 7, 10, 8, 6, 4]) == 4 >>> longest_interesting_subarray([5, 5, 10, 20, 1, 2, 3]) == 3 >>> longest_interesting_subarray([1, 3, 6, 10, 15, 21, 28]) == 2","solution":"def longest_interesting_subarray(arr): Returns the length of the longest interesting subarray in \`arr\`. An interesting subarray is defined by a consistent absolute difference between any two consecutive elements. n = len(arr) if n <= 1: return n max_length = 1 current_length = 1 current_diff = arr[1] - arr[0] for i in range(1, n-1): diff = arr[i+1] - arr[i] if diff == current_diff: current_length += 1 else: current_diff = diff current_length = 1 max_length = max(max_length, current_length) return max_length + 1"},{"question":"def count_unique_values(n: int, array: List[int]) -> int: Given an array of integers, determine the number of unique values in the array. Constraints: - The array will have at most 100 elements. - Each element in the array will be an integer between -1000 and 1000 inclusive. Input: - n: the number of elements in the array - array: list of n integers Output: - the number of unique values in the array >>> count_unique_values(5, [1, 2, 2, 3, 4]) 4 >>> count_unique_values(6, [-1, -1, 0, 1, 2, 2]) 4 >>> count_unique_values(5, [1, 2, 3, 4, 5]) 5 >>> count_unique_values(4, [1, 1, 1, 1]) 1 >>> count_unique_values(0, []) 0","solution":"def count_unique_values(n, array): Returns the number of unique values in the array. return len(set(array)) # This function can be tested by verifying the count of unique values in the array is correct."},{"question":"from typing import List from collections import Counter def largest_palindrome(s: str) -> str: Returns the largest palindrome that can be formed by rearranging the characters of the string s. If multiple palindromes of same length exist, return the lexicographically smallest one. If no palindrome can be formed, return 'not possible'. >>> largest_palindrome(\\"aabbcc\\") 'abccba' >>> largest_palindrome(\\"abc\\") 'not possible' >>> largest_palindrome(\\"aaab\\") 'not possible'","solution":"from collections import Counter def largest_palindrome(s): Returns the largest palindrome that can be formed by rearranging the characters of the string s. If multiple palindromes of same length exist, returns the lexicographically smallest one. If no palindrome can be formed, returns \\"not possible\\". char_count = Counter(s) # Separate characters with odd and even counts odd_count_chars = [char for char, count in char_count.items() if count % 2 != 0] # If there are more than one character with odd count, palindrome is not possible if len(odd_count_chars) > 1: return \\"not possible\\" # Form the first half of the palindrome and then mirror it to form the full palindrome first_half = [] middle = '' for char in sorted(char_count.keys()): count = char_count[char] if count % 2 != 0: middle = char first_half.append(char * (count // 2)) first_half = ''.join(first_half) return first_half + middle + first_half[::-1]"},{"question":"def can_organize_hackathon(t: int, test_cases: List[Dict[str, Union[int, List[Tuple[str, int, int]]]]]) -> List[str]: Determines if it is possible to organize seating for the hackathon based on given constraints. >>> test_cases = [ ... { ... \\"n\\": 3, ... \\"p\\": 2, ... \\"constraints\\": [ ... ('F', 1, 2), ... ('R', 1, 3) ... ] ... }, ... { ... \\"n\\": 4, ... \\"p\\": 5, ... \\"constraints\\": [ ... ('F', 1, 2), ... ('F', 2, 3), ... ('F', 3, 4), ... ('R', 1, 3), ... ('R', 1, 4) ... ] ... }, ... { ... \\"n\\": 5, ... \\"p\\": 0, ... \\"constraints\\": [] ... } ... ] ... can_organize_hackathon(3, test_cases) ['YES', 'NO', 'YES']","solution":"def can_organize_hackathon(t, test_cases): Determines if it is possible to organize seating for the hackathon based on given constraints. from collections import defaultdict, deque results = [] for i in range(t): n, p = test_cases[i]['n'], test_cases[i]['p'] friends_constraints = defaultdict(list) rivals_constraints = [] for j in range(p): constraint = test_cases[i]['constraints'][j] if constraint[0] == 'F': _, u, v = constraint friends_constraints[u].append(v) friends_constraints[v].append(u) elif constraint[0] == 'R': _, x, y = constraint rivals_constraints.append((x, y)) parent = {i: i for i in range(1, n + 1)} def find(x): while parent[x] != x: parent[x] = parent[parent[x]] x = parent[x] return x def union(x, y): parent[find(x)] = find(y) for u in friends_constraints: for v in friends_constraints[u]: union(u, v) valid = True for x, y in rivals_constraints: if find(x) == find(y): valid = False break results.append(\\"YES\\" if valid else \\"NO\\") return results"},{"question":"def evaluate_expression(expr: str) -> Union[int, float]: Evaluates a mathematical expression given as a string. Supports +, *, and parentheses. Examples: >>> evaluate_expression(\\"2+3\\") 5 >>> evaluate_expression(\\"3*4\\") 12 >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"(2+3)*4\\") 20 >>> evaluate_expression(\\"3+4*2/(1-5)**2\\") 3.5 >>> evaluate_expression(\\"10+(2*3)\\") 16","solution":"def evaluate_expression(expr): Evaluates a mathematical expression given as a string. Supports +, *, and parentheses. try: result = eval(expr) except Exception as e: raise ValueError(\\"Invalid expression\\") from e return result"},{"question":"def decode_message(m: int, n: int, o: int) -> str: Decodes a single message based on the encoding scheme. >>> decode_message(3, 2, 4) 'M-N-O' >>> decode_message(7, 8, 9) 'M-N-O' pass def main(input_data: str) -> List[str]: Processes the input data and returns the decoded messages. >>> main(\\"2n3 2 4n7 8 9\\") ['M-N-O', 'M-N-O'] >>> main(\\"3n3 2 4n7 8 9n7 2 9\\") ['M-N-O', 'M-N-O', 'M-N-O'] pass","solution":"def decode_message(m, n, o): Decodes a single message based on the encoding scheme. encoding_map = { 3: 'M', 7: 'M', 2: 'N', 8: 'N', 4: 'O', 9: 'O' } return f\\"{encoding_map[m]}-{encoding_map[n]}-{encoding_map[o]}\\" def main(input_data): Processes the input data and returns the decoded messages. lines = input_data.strip().split('n') T = int(lines[0]) results = [] for i in range(1, T + 1): m, n, o = map(int, lines[i].split()) results.append(decode_message(m, n, o)) return results # You can run this code by passing input data to main function like this: # input_data = '2n3 2 4n7 8 9' # result = main(input_data) # print('n'.join(result))"},{"question":"def alvanian_to_decimal(numeral_string): Converts a numeral string from the Alvanian system to its decimal equivalent. Parameters: numeral_string (str): A string representing the numeral in Alvanian system. Returns: int: The decimal equivalent of the Alvanian numeral. >>> alvanian_to_decimal(\\"AG\\") 1001 >>> alvanian_to_decimal(\\"AE\\") 101 >>> alvanian_to_decimal(\\"CDF\\") 560 >>> alvanian_to_decimal(\\"DCBA\\") 66 from solution import alvanian_to_decimal def test_single_symbols(): assert alvanian_to_decimal(\\"A\\") == 1 assert alvanian_to_decimal(\\"B\\") == 5 assert alvanian_to_decimal(\\"C\\") == 10 assert alvanian_to_decimal(\\"D\\") == 50 assert alvanian_to_decimal(\\"E\\") == 100 assert alvanian_to_decimal(\\"F\\") == 500 assert alvanian_to_decimal(\\"G\\") == 1000 def test_example1(): assert alvanian_to_decimal(\\"AG\\") == 1001 def test_example2(): assert alvanian_to_decimal(\\"AE\\") == 101 def test_example3(): assert alvanian_to_decimal(\\"CDF\\") == 560 def test_example4(): assert alvanian_to_decimal(\\"DCBA\\") == 66 def test_combination(): assert alvanian_to_decimal(\\"ABBCCC\\") == (1+5*2+10*3) # 46 assert alvanian_to_decimal(\\"ABCDE\\") == (1+5+10+50+100) # 166 assert alvanian_to_decimal(\\"DEFG\\") == (50+100+500+1000) # 1650 def test_repeated_symbols(): assert alvanian_to_decimal(\\"AAA\\") == 3 assert alvanian_to_decimal(\\"BBBB\\") == 20 assert alvanian_to_decimal(\\"CCCC\\") == 40 assert alvanian_to_decimal(\\"DDD\\") == 150 assert alvanian_to_decimal(\\"EEEE\\") == 400 assert alvanian_to_decimal(\\"FFFF\\") == 2000 assert alvanian_to_decimal(\\"GGGG\\") == 4000","solution":"def alvanian_to_decimal(numeral_string): Converts a numeral string from the Alvanian system to its decimal equivalent. Parameters: numeral_string (str): A string representing the numeral in Alvanian system. Returns: int: The decimal equivalent of the Alvanian numeral. numeral_map = { 'A': 1, 'B': 5, 'C': 10, 'D': 50, 'E': 100, 'F': 500, 'G': 1000 } total = 0 for char in numeral_string: total += numeral_map[char] return total"},{"question":"def smallest_absolute_difference(arr: List[int]) -> int: Returns the smallest absolute difference between any two elements in the array. >>> smallest_absolute_difference([1, 5, 3, 19, 18]) 1 >>> smallest_absolute_difference([1, 2, 3, 4, 5]) 1 >>> smallest_absolute_difference([-1, -5, -3, -19, -18]) 1 >>> smallest_absolute_difference([1000000, -1000000, 0]) 1000000 >>> smallest_absolute_difference([5, 5, 3, 3, 1, 1]) 0 >>> smallest_absolute_difference([1, 2]) 1 >>> smallest_absolute_difference([-1, 1]) 2","solution":"def smallest_absolute_difference(arr): Returns the smallest absolute difference between any two elements in the array. if len(arr) < 2: raise ValueError(\\"Array must contain at least two elements.\\") arr.sort() min_diff = float('inf') for i in range(1, len(arr)): min_diff = min(min_diff, abs(arr[i] - arr[i-1])) return min_diff"},{"question":"from typing import List, Tuple def min_non_overlapping_intervals(intervals: List[Tuple[int, int]]) -> int: Returns the minimum number of non-overlapping intervals needed to cover all the points on the line that receive light from at least one tower. Args: intervals (List[Tuple[int, int]]): List of tuples, each representing an interval. Returns: int: Minimum number of non-overlapping intervals needed. >>> min_non_overlapping_intervals([(1, 5), (2, 6), (4, 8), (7, 9)]) 2 >>> min_non_overlapping_intervals([(1, 2)]) 1 >>> min_non_overlapping_intervals([(1, 2), (3, 4), (5, 6)]) 3 >>> min_non_overlapping_intervals([(1, 10), (2, 9), (3, 8)]) 1 >>> min_non_overlapping_intervals([(1, 3), (2, 6), (3, 5), (6, 8)]) 2 >>> min_non_overlapping_intervals([]) 0 >>> min_non_overlapping_intervals([(1, 4), (2, 3), (3, 6), (5, 7)]) 2","solution":"def min_non_overlapping_intervals(intervals): Returns the minimum number of non-overlapping intervals needed to cover all the points on the line that receive light from at least one tower. Args: intervals (List[Tuple[int, int]]): List of tuples, each representing an interval. Returns: int: Minimum number of non-overlapping intervals needed. if not intervals: return 0 # Sort intervals by the right endpoint intervals.sort(key=lambda x: x[1]) count = 0 end = -1 for interval in intervals: if interval[0] > end: # If the current interval starts after the last added interval ends, add it to the set count += 1 end = interval[1] return count"},{"question":"from math import gcd from typing import List from functools import reduce def min_possible_value(arr: List[int]) -> int: Given an array of positive integers, determine the minimum possible value of the only remaining element after performing the gcd operation on consecutive elements any number of times. Parameters: arr (List[int]): List of positive integers. Returns: int: The minimum possible value. Examples: >>> min_possible_value([6, 9, 15, 25]) 1 >>> min_possible_value([5, 10, 15]) 5 >>> min_possible_value([17]) 17 >>> min_possible_value([7, 7, 7, 7]) 7 >>> min_possible_value([14, 21, 35]) 7 >>> min_possible_value([1000000, 1000000, 1000000, 1000000]) 1000000 >>> min_possible_value([24, 36, 48, 60, 72, 84]) 12","solution":"from math import gcd from functools import reduce def min_possible_value(arr): Finds the minimum possible value by performing the given GCD operation on consecutive elements. Parameters: arr (list): List of positive integers. Returns: int: The minimum possible value. # Find the GCD of the entire array return reduce(gcd, arr)"},{"question":"def min_trips(n, w, m): Returns the minimum number of trips needed to deliver all packages. Parameters: - n: number of packages - w: weight of each package - m: maximum weight an agent can carry per trip Returns: - Minimum number of trips Examples: >>> min_trips(10, 5, 20) 3 >>> min_trips(7, 2, 5) 3 >>> min_trips(4, 5, 20) 1 >>> min_trips(100, 1, 50) 2 >>> min_trips(1, 10, 10) 1 >>> min_trips(1000, 1, 1) 1000 >>> min_trips(5, 3, 20) 1 >>> min_trips(1, 20, 5) 4","solution":"def min_trips(n, w, m): Returns the minimum number of trips needed to deliver all packages. Parameters: - n: number of packages - w: weight of each package - m: maximum weight an agent can carry per trip Returns: - Minimum number of trips # Calculate total weight of all packages total_weight = n * w # Calculate minimum number of trips trips = (total_weight + m - 1) // m # Ceiling division return trips"},{"question":"def can_recreate_original_string(S: str, T: str, c: str) -> str: Determine if it's possible to insert the character c at any position in T to recreate the original string S. Args: S (str): Original string given to Alice. T (str): String given to Bob after Alice removed one character. c (str): Character Bob needs to insert back to potentially recreate S. Returns: str: 'Yes' if Bob can recreate S by inserting c into T, 'No' otherwise. pass # Test cases def test_simple_cases(): assert can_recreate_original_string(\\"chokudai\\", \\"chokudai\\", \\"a\\") == \\"No\\" assert can_recreate_original_string(\\"a\\", \\"\\", \\"a\\") == \\"Yes\\" assert can_recreate_original_string(\\"hello\\", \\"hell\\", \\"o\\") == \\"Yes\\" def test_edge_cases(): assert can_recreate_original_string(\\"a\\", \\"\\", \\"a\\") == \\"Yes\\" assert can_recreate_original_string(\\"abc\\", \\"ac\\", \\"b\\") == \\"Yes\\" assert can_recreate_original_string(\\"abc\\", \\"ab\\", \\"c\\") == \\"Yes\\" assert can_recreate_original_string(\\"abcde\\", \\"abde\\", \\"c\\") == \\"Yes\\" assert can_recreate_original_string(\\"abcde\\", \\"bcde\\", \\"a\\") == \\"Yes\\" def test_negative_cases(): assert can_recreate_original_string(\\"chokudai\\", \\"chokudai\\", \\"b\\") == \\"No\\" assert can_recreate_original_string(\\"abcdef\\", \\"bdef\\", \\"a\\") == \\"No\\" assert can_recreate_original_string(\\"hello\\", \\"helo\\", \\"a\\") == \\"No\\" assert can_recreate_original_string(\\"test\\", \\"tes\\", \\"s\\") == \\"No\\" def test_duplicate_characters(): assert can_recreate_original_string(\\"aa\\", \\"a\\", \\"a\\") == \\"Yes\\" assert can_recreate_original_string(\\"abba\\", \\"bba\\", \\"a\\") == \\"Yes\\" assert can_recreate_original_string(\\"mississippi\\", \\"mississppi\\", \\"i\\") == \\"Yes\\"","solution":"def can_recreate_original_string(S, T, c): Determine if it's possible to insert the character c at any position in T to recreate the original string S. Args: S (str): Original string given to Alice. T (str): String given to Bob after Alice removed one character. c (str): Character Bob needs to insert back to potentially recreate S. Returns: str: 'Yes' if Bob can recreate S by inserting c into T, 'No' otherwise. # Loop through possible insertion points in T for i in range(len(T) + 1): # Create a potential string by inserting c at position i potential_S = T[:i] + c + T[i:] # Check if the potential string matches the original string S if potential_S == S: return 'Yes' return 'No'"},{"question":"def find_taller_trees(N: int, heights: List[int]) -> List[int]: Return the heights of the trees that are taller than both their neighboring trees. >>> find_taller_trees(7, [3, 7, 2, 10, 6, 8, 5]) [7, 10, 8] >>> find_taller_trees(5, [1, 1, 1, 1, 1]) [] >>> find_taller_trees(5, [1, 3, 1, 3, 1]) [3, 3] >>> find_taller_trees(1, [5]) [] >>> find_taller_trees(2, [5, 6]) [] >>> find_taller_trees(3, [1, 2, 1]) [2] >>> find_taller_trees(6, [1, 3, 2, 4, 3, 5]) [3, 4]","solution":"def find_taller_trees(N, heights): Return the heights of the trees that are taller than both their neighboring trees if N < 3: return [] result = [] for i in range(1, N-1): if heights[i] > heights[i-1] and heights[i] > heights[i+1]: result.append(heights[i]) return result"},{"question":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: Return the sum of the values of the deepest leaves in the binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> root.right.right = TreeNode(6) >>> root.left.left.left = TreeNode(7) >>> root.right.right.right = TreeNode(8) >>> deepestLeavesSum(root) 15 >>> root = TreeNode(1) >>> deepestLeavesSum(root) 1 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> root.left.right = TreeNode(5) >>> deepestLeavesSum(root) 9 # Your implementation here","solution":"from collections import deque class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def deepestLeavesSum(root: TreeNode) -> int: if not root: return 0 queue = deque([root]) while queue: level_sum = 0 level_size = len(queue) for _ in range(level_size): node = queue.popleft() level_sum += node.val if node.left: queue.append(node.left) if node.right: queue.append(node.right) return level_sum"},{"question":"def encode_message(s: str) -> str: Encode the given string by replacing each letter with the next letter in the alphabet. 'z' wraps around to 'a'. >>> encode_message(\\"hello\\") \\"ifmmp\\" >>> encode_message(\\"xyz\\") \\"yza\\"","solution":"def encode_message(s): Encodes the given string by replacing each letter with the next letter in the alphabet. 'z' wraps around to 'a'. encoded_chars = [] for char in s: if char == 'z': encoded_chars.append('a') else: encoded_chars.append(chr(ord(char) + 1)) return ''.join(encoded_chars)"},{"question":"from collections import defaultdict def count_unique_paths(n, queries, friendships): Given the number of users and friendships in the Friends Network, determine the number of unique friendship paths for each queried pair. Args: n : int : number of users queries : List[Tuple[int, int]] : pairs of users to check paths between friendships : List[Tuple[int, int]] : mutual friendships between users Returns: List[int] : list of counts of unique paths for each queried pair >>> n = 5 >>> queries = [(1, 4), (4, 5)] >>> friendships = [(1, 2), (1, 3), (2, 4), (2, 5)] >>> count_unique_paths(n, queries, friendships) [1, 1] >>> n = 4 >>> queries = [(1, 4), (2, 3), (2, 4)] >>> friendships = [(1, 2), (1, 3), (3, 4)] >>> count_unique_paths(n, queries, friendships) [1, 1, 1] pass def test_count_unique_paths(): n = 5 queries = [(1, 4), (4, 5)] friendships = [(1, 2), (1, 3), (2, 4), (2, 5)] result = count_unique_paths(n, queries, friendships) assert result == [1, 1] n = 4 queries = [(1, 4), (2, 3), (2, 4)] friendships = [(1, 2), (1, 3), (3, 4)] result = count_unique_paths(n, queries, friendships) assert result == [1, 1, 1] n = 6 queries = [(1, 6), (1, 5)] friendships = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] result = count_unique_paths(n, queries, friendships) assert result == [1, 1] n = 3 queries = [(1, 2), (2, 3)] friendships = [(1, 2), (2, 3)] result = count_unique_paths(n, queries, friendships) assert result == [1, 1] n = 7 queries = [(1, 7), (2, 5), (4, 6)] friendships = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)] result = count_unique_paths(n, queries, friendships) assert result == [1, 1, 1] if __name__ == \\"__main__\\": test_count_unique_paths() print(\\"All tests passed!\\")","solution":"from collections import defaultdict def count_unique_paths(n, queries, friendships): def bfs_count_paths(start, end): queue = [(start, [start])] visited = set() while queue: (node, path) = queue.pop(0) if node == end: return 1 if node not in visited: visited.add(node) for neighbor in adjacency_list[node]: if neighbor not in path: queue.append((neighbor, path + [neighbor])) return 0 adjacency_list = defaultdict(list) for u, v in friendships: adjacency_list[u].append(v) adjacency_list[v].append(u) results = [] for a, b in queries: count = bfs_count_paths(a, b) results.append(count) return results"},{"question":"def searchMatrix(matrix, target): Returns true if target exists in a 2D matrix where each row and each column is sorted in ascending order. >>> searchMatrix([[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16]], 5) True >>> searchMatrix([[1, 4, 7, 11], [2, 5, 8, 12], [3, 6, 9, 16]], 20) False","solution":"def searchMatrix(matrix, target): Returns true if target exists in the sorted matrix, false otherwise. if not matrix: return False m, n = len(matrix), len(matrix[0]) row, col = 0, n - 1 while row < m and col >= 0: if matrix[row][col] == target: return True elif matrix[row][col] < target: row += 1 else: col -= 1 return False"},{"question":"def sort_books(n: int, book_details: List[Tuple[str, str, int]]) -> List[Tuple[str, int, str]]: Sorts the books first by genre lexicographically and then by book ID within each genre. :param n: Number of books :param book_details: List of tuples containing (genre, author, ID) :return: Sorted list of books grouped by genre and then by book ID within each genre >>> n = 5 >>> book_details = [ ('drama', 'shakespeare', 3421), ('romance', 'austen', 5789), ('drama', 'ibsen', 1234), ('romance', 'bronte', 8472), ('sciencefiction', 'asimov', 1024) ] >>> sort_books(n, book_details) [('drama', 1234, 'ibsen'), ('drama', 3421, 'shakespeare'), ('romance', 5789, 'austen'), ('romance', 8472, 'bronte'), ('sciencefiction', 1024, 'asimov')]","solution":"def sort_books(n, book_details): Sorts the books first by genre lexicographically and then by book ID within each genre. :param n: Number of books :param book_details: List of tuples containing (genre, author, ID) :return: Sorted list of books grouped by genre and then by book ID within each genre from collections import defaultdict genres = defaultdict(list) # Group by genre for genre, author, book_id in book_details: genres[genre].append((book_id, author)) # Sort genres and sort IDs within each genre sorted_output = [] for genre in sorted(genres.keys()): for book_id, author in sorted(genres[genre]): sorted_output.append((genre, book_id, author)) return sorted_output"},{"question":"import sys import heapq from typing import List def dijkstra(grid: List[List[int]], n: int, m: int) -> int: Calculate the minimum time to traverse from the upper-left to the bottom-right corner of the grid using Dijkstra's algorithm. pass def min_travel_time(test_cases: List[List[List[int]]]) -> List[int]: Calculate the minimum travel time for each test case. pass def parse_input(input_str: str) -> List[List[List[int]]]: Parse the input string into the appropriate format for processing. pass def main(input_str: str) -> None: Parse the input, compute the results and print them. pass # Unit Test def test_parse_input(): input_str = \\"2n3 3n0 1 2n-1 0 1n2 -1 0n2 2n0 1n-1 0n\\" expected_output = [ [[0, 1, 2], [-1, 0, 1], [2, -1, 0]], [[0, 1], [-1, 0]] ] assert parse_input(input_str) == expected_output def test_dijkstra(): grid1 = [[0, 1, 2], [-1, 0, 1], [2, -1, 0]] assert dijkstra(grid1, 3, 3) == 5 grid2 = [[0, 1], [-1, 0]] assert dijkstra(grid2, 2, 2) == 3 def test_min_travel_time(): test_cases = [ [[0, 1, 2], [-1, 0, 1], [2, -1, 0]], [[0, 1], [-1, 0]] ] assert min_travel_time(test_cases) == [5, 3] def test_main(capsys): input_str = \\"2n3 3n0 1 2n-1 0 1n2 -1 0n2 2n0 1n-1 0n\\" main(input_str) captured = capsys.readouterr() assert captured.out == \\"5n3n\\"","solution":"import sys import heapq def dijkstra(grid, n, m): # Initialize time array with infinity time = [[sys.maxsize] * m for _ in range(n)] time[0][0] = max(1, 1 - grid[0][0]) # Priority queue for dijkstra's algorithm pq = [(time[0][0], 0, 0)] # Dijkstra's algorithm while pq: current_time, x, y = heapq.heappop(pq) if x == n-1 and y == m-1: return current_time # Check right neighbor if y + 1 < m: new_time = current_time + max(1, 1 - grid[x][y + 1]) if new_time < time[x][y + 1]: time[x][y + 1] = new_time heapq.heappush(pq, (new_time, x, y + 1)) # Check down neighbor if x + 1 < n: new_time = current_time + max(1, 1 - grid[x + 1][y]) if new_time < time[x + 1][y]: time[x + 1][y] = new_time heapq.heappush(pq, (new_time, x + 1, y)) def min_travel_time(test_cases): results = [] for grid in test_cases: n = len(grid) m = len(grid[0]) results.append(dijkstra(grid, n, m)) return results def parse_input(input_str): input_lines = input_str.strip().split('n') t = int(input_lines[0]) test_cases = [] idx = 1 for _ in range(t): n, m = map(int, input_lines[idx].split()) grid = [] for i in range(n): grid.append(list(map(int, input_lines[idx + 1 + i].split()))) test_cases.append(grid) idx += n + 1 return test_cases def main(input_str): test_cases = parse_input(input_str) results = min_travel_time(test_cases) for result in results: print(result)"},{"question":"def longest_ones_after_flip(s: str) -> int: Determine the length of the longest contiguous substring of '1's that can be obtained by performing at most one flip operation on the input string s. >>> longest_ones_after_flip(\\"1101101\\") 5 >>> longest_ones_after_flip(\\"11111\\") 5 >>> longest_ones_after_flip(\\"000\\") 1","solution":"def longest_ones_after_flip(s: str) -> int: Determine the length of the longest contiguous substring of '1's possible after performing at most one flip operation on the input string s. n = len(s) if '0' not in s: return n max_len = 0 left = 0 zero_count = 0 for right in range(n): if s[right] == '0': zero_count += 1 while zero_count > 1: if s[left] == '0': zero_count -= 1 left += 1 max_len = max(max_len, right - left + 1) return max_len"},{"question":"def get_sorted_files(directory): This function takes a nested directory structure as input and returns a sorted list of all files. >>> get_sorted_files([1, [4, [6]], 3]) [1, 3, 4, 6] >>> get_sorted_files([9, [3, [2, [5, [8, [7, 4]]]]], 6]) [2, 3, 4, 5, 6, 7, 8, 9] >>> get_sorted_files([[[1, 2], 3], 4]) [1, 2, 3, 4] def process_queries(t, queries): This function processes multiple queries to extract and sort files from nested directories. >>> process_queries(3, [\\"[1, [4, [6]], 3]\\", \\"[9, [3, [2, [5, [8, [7, 4]]]]], 6]\\", \\"[[[1, 2], 3], 4]\\"]) [[1, 3, 4, 6], [2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4]]","solution":"def get_sorted_files(directory): This function takes a nested directory structure as input and returns a sorted list of all files. :param directory: nested list representing the directory structure :return: sorted list of file names (integers) def retrieve_files(dir_structure, file_list): for item in dir_structure: if isinstance(item, list): retrieve_files(item, file_list) else: file_list.append(item) return file_list files = retrieve_files(directory, []) return sorted(files) def process_queries(t, queries): This function processes multiple queries to extract and sort files from nested directories. :param t: int, number of queries :param queries: list of nested list structures as strings representing directories :return: list of sorted file lists for each query results = [] for query in queries: directory_structure = eval(query) sorted_files = get_sorted_files(directory_structure) results.append(sorted_files) return results"},{"question":"def process_operations(q: int, operations: List[str]) -> List[str]: Process a series of book borrow and return operations and determine the current status of each book. Args: q: int : Number of operations. operations: List[str] : List of operations in the format \\"borrow book_id\\" or \\"return book_id\\". Returns: List[str] : List containing the status of the book after each operation, either \\"Available\\" or \\"Borrowed\\". >>> process_operations(5, [\\"borrow 1\\", \\"borrow 1\\", \\"return 1\\", \\"return 1\\", \\"borrow 2\\"]) [\\"Available\\", \\"Borrowed\\", \\"Borrowed\\", \\"Available\\", \\"Available\\"] >>> process_operations(1, [\\"borrow 10\\"]) [\\"Available\\"] >>> process_operations(1, [\\"return 10\\"]) [\\"Borrowed\\"] >>> process_operations(2, [\\"borrow 100\\", \\"borrow 100\\"]) [\\"Available\\", \\"Borrowed\\"] >>> process_operations(2, [\\"return 3\\", \\"return 3\\"]) [\\"Borrowed\\", \\"Available\\"] >>> process_operations(4, [\\"borrow 4\\", \\"return 4\\", \\"borrow 4\\", \\"borrow 4\\"]) [\\"Available\\", \\"Borrowed\\", \\"Available\\", \\"Borrowed\\"]","solution":"def process_operations(q, operations): book_status = {} result = [] for operation in operations: op, book_id = operation.split() book_id = int(book_id) if op == \\"borrow\\": if book_id in book_status and book_status[book_id] == \\"Borrowed\\": result.append(\\"Borrowed\\") else: book_status[book_id] = \\"Borrowed\\" result.append(\\"Available\\") elif op == \\"return\\": if book_id in book_status and book_status[book_id] == \\"Available\\": result.append(\\"Available\\") else: book_status[book_id] = \\"Available\\" result.append(\\"Borrowed\\") return result"},{"question":"def max_chairs(planks: List[int], k: int) -> int: Determines the maximum number of chairs that can be built using the given planks. Each chair requires k units of wood. :param planks: List of integers representing the lengths of the planks. :param k: Integer representing the required length of wood for one chair. :return: Integer representing the maximum number of chairs. >>> max_chairs([5, 6, 7, 8, 9], 10) 3 >>> max_chairs([4, 4, 4, 4], 10) 1","solution":"def max_chairs(planks, k): Determines the maximum number of chairs that can be built using the given planks. Each chair requires k units of wood. :param planks: List of integers representing the lengths of the planks. :param k: Integer representing the required length of wood for one chair. :return: Integer representing the maximum number of chairs. total_length = sum(planks) return total_length // k"},{"question":"def max_even_colors(n: int, balloons: List[int]) -> int: Determines the maximum number of different colors of balloons that have an even number of balloons. Args: n (int): The number of colors. balloons (List[int]): A list of integers representing the balloon counts of different colors. Returns: int: The maximum number of different colors that have an even number of balloons. >>> max_even_colors(3, [2, 3, 4]) 2 >>> max_even_colors(5, [1, 2, 3, 4, 5]) 2 >>> max_even_colors(4, [10, 5, 6, 8]) 3","solution":"def max_even_colors(n, balloons): Returns the maximum number of different colors that have an even number of balloons. count = 0 for balloon_count in balloons: if balloon_count % 2 == 0: count += 1 return count"},{"question":"def minimum_latency_to_connect_servers(N: int, M: int, connections: List[Tuple[int, int, int]]) -> int: Calculate the minimum total latency required to connect all servers. Args: N (int): Number of servers M (int): Number of links connections (List[Tuple[int, int, int]]): List of tuples where each tuple represents a connection as (u, v, w) where u and v are servers connected by a link and w is the latency of that link. Returns: int: The minimum total latency required to connect all servers. If it is not possible, return -1. >>> minimum_latency_to_connect_servers(4, 5, [(1, 2, 3), (2, 3, 4), (3, 4, 5), (1, 4, 10), (1, 3, 6)]) 12 >>> minimum_latency_to_connect_servers(4, 2, [(1, 2, 3), (3, 4, 5)]) -1 >>> minimum_latency_to_connect_servers(2, 1, [(1, 2, 5)]) 5 >>> minimum_latency_to_connect_servers(3, 3, [(1, 2, 1), (1, 3, 2), (2, 3, 3)]) 3 >>> minimum_latency_to_connect_servers(6, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (4, 5, 1), (5, 6, 1)]) 5 pass","solution":"def find(parent, node): if parent[node] == node: return node parent[node] = find(parent, parent[node]) return parent[node] def union(parent, rank, node1, node2): root1 = find(parent, node1) root2 = find(parent, node2) if root1 != root2: if rank[root1] > rank[root2]: parent[root2] = root1 elif rank[root1] < rank[root2]: parent[root1] = root2 else: parent[root2] = root1 rank[root1] += 1 def minimum_latency_to_connect_servers(N, M, connections): if M < N - 1: # Not enough edges to connect all servers return -1 connections.sort(key=lambda x: x[2]) parent = list(range(N + 1)) rank = [0] * (N + 1) total_latency = 0 num_edges_used = 0 for u, v, w in connections: if find(parent, u) != find(parent, v): union(parent, rank, u, v) total_latency += w num_edges_used += 1 if num_edges_used == N - 1: return total_latency return -1 # If we can't connect all servers def solve(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) connections = [] index = 2 for _ in range(M): u = int(data[index]) v = int(data[index+1]) w = int(data[index+2]) connections.append((u, v, w)) index += 3 result = minimum_latency_to_connect_servers(N, M, connections) print(result)"},{"question":"def most_frequent_word(n: int, document: str) -> str: Finds the most frequently occurring word in the document. In case of a tie, returns the lexicographically smallest word. >>> most_frequent_word(36, 'the quick brown fox jumps over the lazy dog') == 'the' >>> most_frequent_word(20, 'hello world hello anna') == 'hello'","solution":"def most_frequent_word(n, document): Finds the most frequently occurring word in the document. In case of a tie, returns the lexicographically smallest word. import re from collections import Counter # Split the document into words using regex to handle multiple spaces words = re.findall(r'bw+b', document) # Count frequency of each word word_count = Counter(words) # Find the highest frequency max_frequency = max(word_count.values()) # Get the words with the highest frequency most_frequent_words = [word for word, count in word_count.items() if count == max_frequency] # Return the lexicographically smallest word among the most frequent words return min(most_frequent_words)"},{"question":"from typing import List def tsp_min_cost(N: int, distances: List[List[int]]) -> int: Calculates the minimum possible sum of the distances for the shortest route that visits every destination exactly once and returns to the starting point. Args: N: int : Number of destinations distances: List[List[int]] : NxN matrix where distances[i][j] is the distance from destination i to destination j. Returns: int: Minimum route distance Examples: >>> tsp_min_cost(4, [ ... [0, 10, 15, 20], ... [10, 0, 35, 25], ... [15, 35, 0, 30], ... [20, 25, 30, 0]]) 80 >>> tsp_min_cost(2, [ ... [0, 5], ... [5, 0]]) 10 pass import pytest def test_sample_input(): distances = [ [0, 10, 15, 20], [10, 0, 35, 25], [15, 35, 0, 30], [20, 25, 30, 0] ] assert tsp_min_cost(4, distances) == 80 def test_two_destinations(): distances = [ [0, 5], [5, 0] ] assert tsp_min_cost(2, distances) == 10 def test_three_destinations(): distances = [ [0, 10, 15], [10, 0, 20], [15, 20, 0] ] assert tsp_min_cost(3, distances) == 45 def test_symmetric_distances(): distances = [ [0, 2, 9, 10], [1, 0, 6, 4], [15, 7, 0, 8], [6, 3, 12, 0] ] assert tsp_min_cost(4, distances) == 21 def test_all_same_distances(): distances = [ [0, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 1, 0] ] assert tsp_min_cost(4, distances) == 4","solution":"from itertools import permutations def tsp_min_cost(N, distances): Calculates the minimum possible sum of the distances for the shortest route that visits every destination exactly once and returns to the starting point. Args: N: int : Number of destinations distances: List[List[int]] : NxN matrix where distances[i][j] is the distance from destination i to destination j. Returns: int: Minimum route distance # Generate all possible tours starting from the first destination (0) all_tours = permutations(range(1, N)) min_cost = float('inf') for tour in all_tours: current_cost = 0 current_position = 0 # Calculate the cost of the tour starting and ending at the first destination for next_position in tour: current_cost += distances[current_position][next_position] current_position = next_position current_cost += distances[current_position][0] # Update the minimum cost if the current tour cost is lower if current_cost < min_cost: min_cost = current_cost return min_cost # Example usage: # N = 4 # distances = [ # [0, 10, 15, 20], # [10, 0, 35, 25], # [15, 35, 0, 30], # [20, 25, 30, 0] # ] # print(tsp_min_cost(N, distances)) # Output: 80"},{"question":"def smallest_subarray_with_sum(arr, N, X): Returns the length of the smallest subarray with sum greater than or equal to X. If no such subarray exists, returns -1. >>> smallest_subarray_with_sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10, 15) 2 >>> smallest_subarray_with_sum([10], 1, 5) 1 >>> smallest_subarray_with_sum([3], 1, 5) -1 >>> smallest_subarray_with_sum([1, 1, 1, 1, 1], 5, 10) -1 >>> smallest_subarray_with_sum([2, 3, 1, 2, 4, 3], 6, 7) 2 >>> smallest_subarray_with_sum([2, 3, 1, 2, 4, 3], 6, 6) 2 >>> smallest_subarray_with_sum([1, 2, 3, 4, 10], 5, 10) 1","solution":"def smallest_subarray_with_sum(arr, N, X): Returns the length of the smallest subarray with sum greater than or equal to X. If no such subarray exists, returns -1. min_length = float('inf') current_sum = 0 start_index = 0 for end_index in range(N): current_sum += arr[end_index] while current_sum >= X: min_length = min(min_length, end_index - start_index + 1) current_sum -= arr[start_index] start_index += 1 return min_length if min_length != float('inf') else -1"},{"question":"def can_segment_string(s: str, wordDict: List[str]) -> str: This function checks if the string s can be segmented into a space-separated sequence of one or more dictionary words. >>> can_segment_string(\\"leetcode\\", [\\"leet\\", \\"code\\"]) == \\"YES\\" >>> can_segment_string(\\"applepenapple\\", [\\"apple\\", \\"pen\\"]) == \\"YES\\" >>> can_segment_string(\\"catsandog\\", [\\"cats\\", \\"dog\\", \\"sand\\", \\"and\\", \\"cat\\"]) == \\"NO\\" >>> can_segment_string(\\"apple\\", [\\"apple\\"]) == \\"YES\\" >>> can_segment_string(\\"bananaapple\\", [\\"banana\\", \\"apple\\", \\"banana\\"]) == \\"YES\\" >>> can_segment_string(\\"hellothere\\", [\\"hello\\", \\"world\\"]) == \\"NO\\" >>> can_segment_string(\\"\\", [\\"a\\", \\"b\\"]) == \\"YES\\" # An empty string can be segmented vacuously >>> can_segment_string(\\"abcdef\\", []) == \\"NO\\"","solution":"def can_segment_string(s, wordDict): This function checks if the string s can be segmented into a space-separated sequence of one or more dictionary words. :param s: str, the string to be segmented :param wordDict: list, list of words as dictionary :return: str, \\"YES\\" if the string can be segmented, else \\"NO\\" word_set = set(wordDict) dp = [False] * (len(s) + 1) dp[0] = True for i in range(1, len(s) + 1): for j in range(i): if dp[j] and s[j:i] in word_set: dp[i] = True break return \\"YES\\" if dp[len(s)] else \\"NO\\""},{"question":"def sum_of_min_and_max_in_subarray(N, Q, A, queries): For each query, compute the sum of the minimum and maximum values in the specified subarray. Parameters: - N: int: size of the array - Q: int: number of queries - A: list of ints: the array of integers - queries: list of tuples: each tuple contains two integers L and R Returns: - list of ints: sum of the minimum and maximum values for each query Examples: >>> sum_of_min_and_max_in_subarray(6, 3, [1, 3, 2, 7, 9, 11], [(1, 4), (2, 5), (3, 6)]) [8, 11, 13] >>> sum_of_min_and_max_in_subarray(5, 3, [5, 2, 8, 4, 6], [(1, 1), (2, 2), (3, 3)]) [10, 4, 16] >>> sum_of_min_and_max_in_subarray(4, 1, [10, 20, 30, 40], [(1, 4)]) [50] >>> sum_of_min_and_max_in_subarray(5, 2, [-10, -20, -30, -5, -1], [(1, 2), (3, 5)]) [-30, -31] >>> sum_of_min_and_max_in_subarray(5, 2, [5, 5, 5, 5, 5], [(1, 3), (2, 4)]) [10, 10]","solution":"def sum_of_min_and_max_in_subarray(N, Q, A, queries): For each query, compute the sum of the minimum and maximum values in the specified subarray. Parameters: - N: int: size of the array - Q: int: number of queries - A: list of ints: the array of integers - queries: list of tuples: each tuple contains two integers L and R Returns: - list of ints: sum of the minimum and maximum values for each query results = [] for L, R in queries: subarray = A[L-1:R] min_val = min(subarray) max_val = max(subarray) results.append(min_val + max_val) return results # Example usage N = 6 Q = 3 A = [1, 3, 2, 7, 9, 11] queries = [(1, 4), (2, 5), (3, 6)] print(sum_of_min_and_max_in_subarray(N, Q, A, queries))"},{"question":"def highest_total_score(M: int, contest_data: List[Tuple[int, List[Tuple[str, int]]]]) -> int: Determines the highest total score earned by any contestant across all contests. :param M: Integer, number of contests :param contest_data: List of tuples, each containing contest information. Each tuple contains: - N: Integer, number of contestants in the contest - contestants: List of tuples, each containing a string (contestant's name) and an integer (their score) :return: The highest total score earned by any contestant >>> highest_total_score(2, [(3, [(\\"Alice\\", 50), (\\"Bob\\", 30), (\\"Charlie\\", 45)]), (2, [(\\"Alice\\", 75), (\\"Bob\\", 20)])]) 125 >>> highest_total_score(1, [(1, [(\\"Alice\\", 100)])]) 100 >>> highest_total_score(1, [(2, [(\\"Alice\\", 50), (\\"Bob\\", 70)])]) 70 >>> highest_total_score(3, [(1, [(\\"Alice\\", 30)]), (1, [(\\"Alice\\", 40)]), (1, [(\\"Alice\\", 50)])]) 120 >>> highest_total_score(3, [(2, [(\\"Alice\\", 30), (\\"Bob\\", 50)]), (2, [(\\"Bob\\", 40), (\\"Charlie\\", 60)]), (2, [(\\"Alice\\", 40), (\\"Charlie\\", 70)])]) 130 >>> highest_total_score(2, [(2, [(\\"Alice\\", 50), (\\"Bob\\", 30)]), (2, [(\\"Alice\\", 70), (\\"Bob\\", 50)])]) 120","solution":"def highest_total_score(M, contest_data): Determines the highest total score earned by any contestant across all contests. :param M: Integer, number of contests :param contest_data: List of tuples, each containing contest information. Each tuple contains: - N: Integer, number of contestants in the contest - contestants: List of tuples, each containing a string (contestant's name) and an integer (their score) :return: The highest total score earned by any contestant scores = {} for contest in contest_data: N = contest[0] contestants = contest[1] for contestant in contestants: name, score = contestant if name in scores: scores[name] += score else: scores[name] = score # Find the maximum score among all contestants highest_score = max(scores.values()) return highest_score"},{"question":"def min_missing_widgets(n: int, serial_numbers: List[int]) -> int: Determines the minimum number of missing widgets due to production error. Args: n : int - number of registered widgets' serial numbers. serial_numbers: list of int - the serial numbers of the registered widgets. Returns: int - the minimum number of missing widgets. Example: >>> min_missing_widgets(4, [16, 18, 19, 15]) 1 >>> min_missing_widgets(6, [20, 21, 23, 24, 25, 22]) 0 from solution import min_missing_widgets def test_min_missing_widgets_example1(): assert min_missing_widgets(4, [16, 18, 19, 15]) == 1 def test_min_missing_widgets_example2(): assert min_missing_widgets(6, [20, 21, 23, 24, 25, 22]) == 0 def test_min_missing_widgets_no_missing(): assert min_missing_widgets(3, [1, 2, 3]) == 0 def test_min_missing_widgets_large_interval(): assert min_missing_widgets(3, [100, 102, 101]) == 0 def test_min_missing_widgets_single_number(): assert min_missing_widgets(1, [5]) == 0 def test_min_missing_widgets_large_numbers(): assert min_missing_widgets(4, [1000000000, 1000000001, 1000000003, 1000000004]) == 1 def test_min_missing_widgets_unsorted_list(): assert min_missing_widgets(5, [10, 8, 6, 7, 9]) == 0","solution":"def min_missing_widgets(n, serial_numbers): Determines the minimum number of missing widgets. Args: n : int - number of registered widgets' serial numbers. serial_numbers: list of int - the serial numbers of the registered widgets. Returns: int - the minimum number of missing widgets. max_serial = max(serial_numbers) min_serial = min(serial_numbers) total_serial_count = max_serial - min_serial + 1 missing_count = total_serial_count - n return missing_count"},{"question":"def check_sequences(sequences: List[str]) -> List[str]: Given a list of sequences, returns a list of results indicating if each sequence is valid. >>> check_sequences([\\"()\\"]) [\\"YES\\"] >>> check_sequences([\\"()()\\"]) [\\"YES\\"]","solution":"def is_valid_parentheses_sequence(sequence): Returns \\"YES\\" if the sequence of parentheses is valid, otherwise \\"NO\\". stack = [] for char in sequence: if char == '(': stack.append(char) elif char == ')': if stack: stack.pop() else: return \\"NO\\" return \\"YES\\" if not stack else \\"NO\\" def check_sequences(sequences): Given a list of sequences, returns a list of results indicating if each sequence is valid. return [is_valid_parentheses_sequence(seq) for seq in sequences]"},{"question":"def can_maxim_reach_top(n: int, max_energy: int, heights: List[int]) -> str: Determines if Maxim can reach the top within the maximum energy limit. Args: n : int : The number of steps. max_energy : int : The maximum energy Maxim can expend. heights : list : A list of integers representing the heights of each step. Returns: str : \\"Possible\\" if Maxim can reach the top, otherwise \\"Impossible\\". Examples: >>> can_maxim_reach_top(5, 10, [1, 3, 6, 4, 8]) \\"Possible\\" >>> can_maxim_reach_top(5, 5, [1, 3, 6, 4, 8]) \\"Impossible\\"","solution":"def can_maxim_reach_top(n, max_energy, heights): Determines if Maxim can reach the top within the maximum energy limit. Arguments: n : int : The number of steps. max_energy : int : The maximum energy Maxim can expend. heights : list : A list of integers representing the heights of each step. Returns: str : \\"Possible\\" if Maxim can reach the top, otherwise \\"Impossible\\". dp = [float('inf')] * n dp[0] = 0 for i in range(1, n): dp[i] = min(dp[i], dp[i-1] + abs(heights[i] - heights[i-1])) if i > 1: dp[i] = min(dp[i], dp[i-2] + 2 * abs(heights[i] - heights[i-2])) return \\"Possible\\" if dp[-1] <= max_energy else \\"Impossible\\" if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) max_energy = int(data[1]) heights = list(map(int, data[2:2+n])) result = can_maxim_reach_top(n, max_energy, heights) print(result)"},{"question":"def can_reach_target(m, n, grid, start, target): Determine whether it's possible for the robot to reach the target position from the starting position in a warehouse grid. Parameters: - m (int): number of rows in the grid - n (int): number of columns in the grid - grid (List[List[str]]): warehouse grid where '.' represents free space and '#' represents an obstacle - start (Tuple[int, int]): starting position (x1, y1) - target (Tuple[int, int]): target position (x2, y2) Returns: - str: \\"YES\\" if the robot can reach the target position from the starting position, \\"NO\\" if it cannot reach Examples: >>> can_reach_target( ... 5, 5, ... [['.', '.', '.', '.', '.'], ... ['.', '.', '#', '.', '.'], ... ['.', '.', '#', '.', '.'], ... ['.', '.', '.', '.', '.'], ... ['.', '.', '.', '.', '.']], ... (0, 0), (4, 4) ... ) == \\"YES\\" >>> can_reach_target( ... 3, 4, ... [['.', '.', '.', '.'], ... ['.', '#', '#', '.'], ... ['.', '.', '.', '.']], ... (0, 0), (2, 3) ... ) == \\"YES\\" >>> can_reach_target( ... 3, 4, ... [['.', '.', '#', '.'], ... ['.', '#', '#', '.'], ... ['.', '.', '#', '.']], ... (0, 0), (2, 3) ... ) == \\"NO\\" # Write your implementation here pass def process_input(input_str): Processes input string to extract parameters for can_reach_target and returns the result. Parameters: - input_str (str): Input string with grid configuration and start, target positions Returns: - str: Result from can_reach_target function (\\"YES\\" or \\"NO\\") Examples: >>> process_input(\\"5 5n.....n..#..n..#..n.....n.....n0 0 4 4\\") == \\"YES\\" >>> process_input(\\"3 4n....n..n....n0 0 2 3\\") == \\"YES\\" >>> process_input(\\"3 4n..#.n..n..#.n0 0 2 3\\") == \\"NO\\" # Write your implementation here pass","solution":"def can_reach_target(m, n, grid, start, target): from collections import deque def is_valid(x, y): return 0 <= x < m and 0 <= y < n and grid[x][y] == '.' def bfs(start, target): queue = deque([start]) visited = [[False for _ in range(n)] for _ in range(m)] visited[start[0]][start[1]] = True directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while queue: x, y = queue.popleft() if (x, y) == target: return True for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid(nx, ny) and not visited[nx][ny]: queue.append((nx, ny)) visited[nx][ny] = True return False return \\"YES\\" if bfs(start, target) else \\"NO\\" def process_input(input_str): lines = input_str.strip().split(\\"n\\") m, n = map(int, lines[0].split()) grid = [list(lines[i + 1].strip()) for i in range(m)] x1, y1, x2, y2 = map(int, lines[m + 1].split()) start = (x1, y1) target = (x2, y2) return can_reach_target(m, n, grid, start, target)"},{"question":"def process_queries(N: int, Q: int, A: List[int], queries: List[Tuple[int, int, int]]) -> List[int]: Processes a list of queries on the array A. Args: N : int : Number of elements in the array A Q : int : Number of queries A : list of int : Array of integers queries : list of tuples : List of queries to process Returns: list of int : Result of the sum queries Example: >>> N = 5 >>> Q = 3 >>> A = [1, 2, 3, 4, 5] >>> queries = [(2, 1, 3), (1, 2, 10), (2, 1, 3)] >>> process_queries(N, Q, A, queries) [9, 16]","solution":"def process_queries(N, Q, A, queries): Processes a list of queries on the array A. Args: N : int : Number of elements in the array A Q : int : Number of queries A : list of int : Array of integers queries : list of tuples : List of queries to process Returns: list of int : Result of the sum queries results = [] for query in queries: if query[0] == 1: # Update the value at index X to Y X, Y = query[1], query[2] A[X] = Y elif query[0] == 2: # Calculate the sum of the subarray from index L to R L, R = query[1], query[2] results.append(sum(A[L:R+1])) return results"},{"question":"from typing import List def is_path_exist(n: int, m: int, grid: List[str]) -> str: Determine if there is a path from the starting point 'S' to the endpoint 'E' in the given grid such that the path does not go through any obstacles. Args: - n: number of rows in the grid. - m: number of columns in the grid. - grid: list of strings representing the grid. Returns: - \\"YES\\" if there is a path from 'S' to 'E', otherwise \\"NO\\". Examples: >>> is_path_exist(5, 5, [\\"S...#\\", \\"..#\\", \\".#..#\\", \\".#E.#\\", \\"#\\"]) \\"YES\\" >>> is_path_exist(5, 5, [\\"S...#\\", \\".#.\\", \\".#..#\\", \\".#..#\\", \\"#E#\\"]) \\"NO\\"","solution":"from collections import deque def is_path_exist(n, m, grid): def find_start_end(): start, end = None, None for i in range(n): for j in range(m): if grid[i][j] == 'S': start = (i, j) elif grid[i][j] == 'E': end = (i, j) return start, end start, end = find_start_end() if not start or not end: return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([start]) visited.add(start) while queue: current = queue.popleft() if current == end: return \\"YES\\" for direction in directions: new_x, new_y = current[0] + direction[0], current[1] + direction[1] if 0 <= new_x < n and 0 <= new_y < m and grid[new_x][new_y] != '#' and (new_x, new_y) not in visited: queue.append((new_x, new_y)) visited.add((new_x, new_y)) return \\"NO\\""},{"question":"def count_arithmetic_sequences(N: int, positions: List[int], L: int) -> int: Count the number of starting positions in 'positions' where an arithmetic sequence of length 'L' can be found. :param N: int, number of positions in the forest. :param positions: list of ints, integers at each position in the forest. :param L: int, desired length of the arithmetic sequence. :return: int, count of starting positions with the desired arithmetic sequence. >>> count_arithmetic_sequences(8, [1, 5, 9, 13, 17, 21, 2, 4], 3) 4 >>> count_arithmetic_sequences(5, [1, 2, 3, 5, 8], 4) 0 >>> count_arithmetic_sequences(4, [2, 4, 6, 8], 4) 1 >>> count_arithmetic_sequences(6, [2, 4, 6, 8, 10, 12], 3) 4 >>> count_arithmetic_sequences(5, [1000, 2000, 3000, 4000, 5000], 3) 3 >>> count_arithmetic_sequences(5, [-5, -10, -15, -20, -25], 3) 3","solution":"def count_arithmetic_sequences(N, positions, L): Count the number of starting positions in 'positions' where an arithmetic sequence of length 'L' can be found. :param N: int, number of positions in the forest. :param positions: list of ints, integers at each position in the forest. :param L: int, desired length of the arithmetic sequence. :return: int, count of starting positions with the desired arithmetic sequence. count = 0 for i in range(N - L + 1): is_arithmetic = True common_difference = positions[i + 1] - positions[i] for j in range(1, L - 1): if positions[i + j + 1] - positions[i + j] != common_difference: is_arithmetic = False break if is_arithmetic: count += 1 return count"},{"question":"def get_participant_rank(n: int, contests: List[Tuple[int, List[Tuple[str, int]]]], qname: str) -> int: Determine the rank of a specific participant based on total scores across contests. Args: n (int): Number of contests. contests (List[Tuple[int, List[Tuple[str, int]]]]): Contest data with the number of participants and their scores. qname (str): Name of the participant whose rank is to be determined. Returns: int: Rank of the participant specified by qname. Example: >>> n = 2 >>> contests = [ >>> (3, [(\\"Alice\\", 150), (\\"Bob\\", 200), (\\"Charlie\\", 100)]), >>> (2, [(\\"Alice\\", 90), (\\"Bob\\", 110)]) >>> ] >>> qname = \\"Alice\\" >>> get_participant_rank(n, contests, qname) == 2 >>> n = 1 >>> contests = [ >>> (3, [(\\"Alice\\", 150), (\\"Bob\\", 200), (\\"Charlie\\", 100)]) >>> ] >>> qname = \\"Charlie\\" >>> get_participant_rank(n, contests, qname) == 3","solution":"def get_participant_rank(n, contests, qname): from collections import defaultdict # Dictionary to store total score for each participant scores = defaultdict(int) # Process the contest data for contest in contests: m = contest[0] participants = contest[1] for participant in participants: name, score = participant scores[name] += score # Create a sorted list of participants by total score (descending) and name (lexicographic) sorted_participants = sorted(scores.items(), key=lambda x: (-x[1], x[0])) # Find the rank of the specific participant for rank, (name, score) in enumerate(sorted_participants, start=1): if name == qname: return rank"},{"question":"def inverted_building_block_pattern(N): Generates an inverted building block pattern of asterisks. Parameters: N (int): Number of asterisks in the first row. Returns: List: A list of strings representing the pattern. pass from solution import inverted_building_block_pattern def test_pattern_for_1(): assert inverted_building_block_pattern(1) == ['*'] def test_pattern_for_3(): pattern = inverted_building_block_pattern(3) assert pattern == [ '***', '**', '*' ] def test_pattern_for_5(): pattern = inverted_building_block_pattern(5) assert pattern == [ '*****', '****', '***', '**', '*' ] def test_pattern_for_max_value(): pattern = inverted_building_block_pattern(1000) # Check first few values assert pattern[:3] == [ '*' * 1000, '*' * 999, '*' * 998 ] # Check last few values assert pattern[-3:] == [ '***', '**', '*' ] # Check length assert len(pattern) == 1000","solution":"def inverted_building_block_pattern(N): Generates an inverted building block pattern of asterisks. Parameters: N (int): Number of asterisks in the first row. Returns: List: A list of strings representing the pattern. pattern = [] for i in range(N, 0, -1): pattern.append('*' * i) return pattern"},{"question":"def compress_string(s: str) -> str: Compress the given string using the following rules: 1. Consecutive characters that are the same should be replaced by one occurrence of that character followed by the number of occurrences. 2. If the character appears only once consecutively, it should appear in the compressed string as is without the number. >>> compress_string(\\"aabbccc\\") \\"a2b2c3\\" >>> compress_string(\\"abcd\\") \\"abcd\\" >>> compress_string(\\"aaabbbcccaaa\\") \\"a3b3c3a3\\"","solution":"def compress_string(s): if not s: return \\"\\" compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1]) if count > 1: compressed.append(str(count)) count = 1 compressed.append(s[-1]) if count > 1: compressed.append(str(count)) return \\"\\".join(compressed)"},{"question":"def can_split_array(arr: List[int]) -> bool: Determines if the array can be split into two non-empty contiguous subarrays with equal sums. >>> can_split_array([1, 2, 3, 3, 2, 1]) True >>> can_split_array([3, 1, 4, 1, 5]) False >>> can_split_array([1, 1]) True >>> can_split_array([1, 2]) False >>> can_split_array([2, 2, 2, 2]) True >>> can_split_array([5, 5, 5, 5]) True >>> can_split_array([10**4, -(10**4), 2 * 10**4, -(2 * 10**4)]) True >>> can_split_array([10**4, -(10**4), 3 * 10**4]) False","solution":"def can_split_array(arr): Determines if the array can be split into two non-empty contiguous subarrays with equal sums. :param arr: List of integers :return: Boolean value, True if such a split is possible, otherwise False total_sum = sum(arr) left_sum = 0 for i in range(len(arr) - 1): left_sum += arr[i] right_sum = total_sum - left_sum if left_sum == right_sum: return True return False"},{"question":"from typing import List, Tuple class BookInventory: def __init__(self): self.inventory = {} def addBook(self, id: int, title: str, author: str): Adds a new book with the given id, title, and author to the inventory. If a book with the same id already exists, it should be replaced. >>> inventory = BookInventory() >>> inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") >>> inventory.addBook(1, \\"Harry Potter and the Chamber of Secrets\\", \\"J.K. Rowling\\") >>> inventory.queryBooks() [(1, \\"Harry Potter and the Chamber of Secrets\\", \\"J.K. Rowling\\")] pass def removeBook(self, id: int): Removes the book with the given id from the inventory. If no such book exists, do nothing. >>> inventory = BookInventory() >>> inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") >>> inventory.removeBook(1) >>> inventory.queryBooks() [] pass def queryBooks(self) -> List[Tuple[int, str, str]]: Returns a list of all books in the inventory sorted by title in lexicographical order. >>> inventory = BookInventory() >>> inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") >>> inventory.addBook(2, \\"A Game of Thrones\\", \\"George R.R. Martin\\") >>> inventory.queryBooks() [(2, \\"A Game of Thrones\\", \\"George R.R. Martin\\"), (1, \\"Harry Potter\\", \\"J.K. Rowling\\")] pass def test_add_books_and_query(): inventory = BookInventory() inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") inventory.addBook(2, \\"A Game of Thrones\\", \\"George R.R. Martin\\") inventory.addBook(3, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") expected = [ (2, \\"A Game of Thrones\\", \\"George R.R. Martin\\"), (1, \\"Harry Potter\\", \\"J.K. Rowling\\"), (3, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") ] assert inventory.queryBooks() == expected def test_remove_book_and_query(): inventory = BookInventory() inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") inventory.addBook(2, \\"A Game of Thrones\\", \\"George R.R. Martin\\") inventory.addBook(3, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") inventory.removeBook(2) expected = [ (1, \\"Harry Potter\\", \\"J.K. Rowling\\"), (3, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") ] assert inventory.queryBooks() == expected def test_remove_non_existent_book(): inventory = BookInventory() inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") inventory.addBook(2, \\"A Game of Thrones\\", \\"George R.R. Martin\\") inventory.addBook(3, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") inventory.removeBook(4) expected = [ (2, \\"A Game of Thrones\\", \\"George R.R. Martin\\"), (1, \\"Harry Potter\\", \\"J.K. Rowling\\"), (3, \\"The Hobbit\\", \\"J.R.R. Tolkien\\") ] assert inventory.queryBooks() == expected def test_add_book_with_same_id(): inventory = BookInventory() inventory.addBook(1, \\"Harry Potter\\", \\"J.K. Rowling\\") inventory.addBook(1, \\"Harry Potter and the Chamber of Secrets\\", \\"J.K. Rowling\\") expected = [ (1, \\"Harry Potter and the Chamber of Secrets\\", \\"J.K. Rowling\\") ] assert inventory.queryBooks() == expected def test_query_empty_inventory(): inventory = BookInventory() expected = [] assert inventory.queryBooks() == expected","solution":"from typing import List, Tuple class BookInventory: def __init__(self): self.inventory = {} def addBook(self, id: int, title: str, author: str): self.inventory[id] = (title, author) def removeBook(self, id: int): if id in self.inventory: del self.inventory[id] def queryBooks(self) -> List[Tuple[int, str, str]]: return sorted([(id, title, author) for id, (title, author) in self.inventory.items()], key=lambda x: x[1])"},{"question":"def is_subsequence(s: str, p: str) -> str: Returns \\"YES\\" if p is a subsequence of s, otherwise returns \\"NO\\". >>> is_subsequence(\\"abacabadabacaba\\", \\"aacb\\") \\"YES\\" >>> is_subsequence(\\"hello\\", \\"llo\\") \\"YES\\" >>> is_subsequence(\\"abcdefg\\", \\"hij\\") \\"NO\\" def process_test_cases(test_cases: List[Tuple[str, str]]) -> List[str]: Process multiple test cases to determine if p is a subsequence of s for each case. >>> process_test_cases([(\\"abacabadabacaba\\", \\"aacb\\"), (\\"hello\\", \\"llo\\"), (\\"abcdefg\\", \\"hij\\")]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def is_subsequence(s, p): Returns \\"YES\\" if p is a subsequence of s, otherwise returns \\"NO\\". s_idx, p_idx = 0, 0 while s_idx < len(s) and p_idx < len(p): if s[s_idx] == p[p_idx]: p_idx += 1 s_idx += 1 return \\"YES\\" if p_idx == len(p) else \\"NO\\" def process_test_cases(test_cases): results = [] for s, p in test_cases: results.append(is_subsequence(s, p)) return results"},{"question":"def minimum_streets_to_add(n, m, streets): Calculate the minimum number of streets that need to be added to make the network connected. :param n: Number of intersections :param m: Number of existing streets :param streets: List of tuples where each tuple represents a street between two intersections :return: Minimum number of streets to add from solution import minimum_streets_to_add def test_example_1(): n = 5 m = 3 streets = [(1, 2), (2, 3), (4, 5)] assert minimum_streets_to_add(n, m, streets) == 1 def test_example_2(): n = 4 m = 1 streets = [(1, 2)] assert minimum_streets_to_add(n, m, streets) == 2 def test_single_node(): n = 1 m = 0 streets = [] assert minimum_streets_to_add(n, m, streets) == 0 def test_already_connected(): n = 4 m = 3 streets = [(1, 2), (2, 3), (3, 4)] assert minimum_streets_to_add(n, m, streets) == 0 def test_two_components(): n = 6 m = 4 streets = [(1, 2), (2, 3), (4, 5), (5, 6)] assert minimum_streets_to_add(n, m, streets) == 1 def test_no_existing_streets(): n = 3 m = 0 streets = [] assert minimum_streets_to_add(n, m, streets) == 2","solution":"def minimum_streets_to_add(n, m, streets): Calculate the minimum number of streets that need to be added to make the network connected. :param n: Number of intersections :param m: Number of existing streets :param streets: List of tuples where each tuple represents a street between two intersections :return: Minimum number of streets to add from collections import defaultdict, deque def bfs(start, visited, adj_list): queue = deque([start]) while queue: node = queue.popleft() for neighbor in adj_list[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) # Adjacency list representation of the graph adj_list = defaultdict(list) for u, v in streets: adj_list[u].append(v) adj_list[v].append(u) visited = set() num_components = 0 for i in range(1, n + 1): if i not in visited: bfs(i, visited, adj_list) num_components += 1 # Minimum number of streets to add to connect all components is (num_components - 1) return num_components - 1"},{"question":"from typing import List def largest_rectangle_area(heights: List[int]) -> int: Given an array of heights of buildings, return the area of the largest rectangle that can be formed using consecutive buildings. >>> largest_rectangle_area([2, 1, 5, 6, 2, 3]) 10 >>> largest_rectangle_area([2, 4]) 4 >>> largest_rectangle_area([6, 2, 5, 4, 5, 1, 6]) 12","solution":"def largest_rectangle_area(heights): Given an array of heights of buildings, return the area of the largest rectangle that can be formed using consecutive buildings. stack = [] max_area = 0 index = 0 while index < len(heights): if not stack or heights[index] >= heights[stack[-1]]: stack.append(index) index += 1 else: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) while stack: top_of_stack = stack.pop() area = (heights[top_of_stack] * ((index - stack[-1] - 1) if stack else index)) max_area = max(max_area, area) return max_area"},{"question":"from typing import List, Tuple def bipartite_subgraph(V: int, edges: List[Tuple[int, int]]) -> int: Given an undirected graph representing a network of computers and connections between them, find the size (number of edges) of the largest Bipartite Subgraph. A Bipartite Graph is a graph whose vertices can be divided into two disjoint sets such that no two vertices within the same set are adjacent. The function takes the number of vertices and a list of edges as input. >>> bipartite_subgraph(4, [(0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 0)]) 5 >>> bipartite_subgraph(5, [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 4), (3, 4)]) 6","solution":"from collections import defaultdict, deque def is_bipartite(graph, src, color): Helper function to check if the graph is bipartite starting from the source vertex. q = deque([src]) color[src] = 1 # Start coloring with 1 while q: node = q.popleft() for neighbor in graph[node]: if color[neighbor] == -1: # If this vertex is not colored color[neighbor] = 1 - color[node] q.append(neighbor) elif color[neighbor] == color[node]: # If the adjacent vertex has the same color, it's not bipartite return False return True def bipartite_subgraph(V, edges): Function to find the largest bipartite subgraph. graph = defaultdict(list) for u, v in edges: graph[u].append(v) graph[v].append(u) color = [-1] * V # Check each component of the graph for vertex in range(V): if color[vertex] == -1: if not is_bipartite(graph, vertex, color): return len(edges) - 1 # Return the number of edges - 1 if not bipartite return len(edges) # Example usage vertices = 4 edges_list = [ (0, 1), (0, 2), (1, 2), (1, 3), (2, 3), (3, 0) ] print(bipartite_subgraph(vertices, edges_list))"},{"question":"def largest_lexicographical_string(n: int, s: str) -> str: Returns the largest lexicographical permutation of the string s. Parameters: n (int): Length of the string (1  n  10^5) s (str): Input string consisting of lowercase English letters Returns: str: Largest lexicographical permutation of s Examples: >>> largest_lexicographical_string(5, 'abcde') 'edcba' >>> largest_lexicographical_string(3, 'cba') 'cba' >>> largest_lexicographical_string(1, 'a') 'a' >>> largest_lexicographical_string(4, 'aabb') 'bbaa' >>> largest_lexicographical_string(6, 'abcdef') 'fedcba' >>> largest_lexicographical_string(7, 'bacdfe') 'fedcba' >>> largest_lexicographical_string(8, 'aaabbbcc') 'ccbbbaaa'","solution":"def largest_lexicographical_string(n, s): Returns the largest lexicographical permutation of the string s. Parameters: n (int): Length of the string (1  n  10^5) s (str): Input string consisting of lowercase English letters Returns: str: Largest lexicographical permutation of s return ''.join(sorted(s, reverse=True))"},{"question":"from typing import List def maximalSquare(grid: List[str]) -> int: You have a rectangular grid of size n x m. Each cell in the grid can either be empty, or contain an obstacle, represented by '1'. An empty cell is represented by '0'. Find the largest square containing only 0's and return its area. >>> grid = [ ... \\"10100\\", ... \\"10111\\", ... \\"11111\\", ... \\"10010\\" ... ] >>> maximalSquare(grid) 1 >>> grid = [ ... \\"1101\\", ... \\"1101\\", ... \\"1111\\" ... ] >>> maximalSquare(grid) 1 >>> grid = [ ... \\"0000\\", ... \\"0000\\", ... \\"0000\\" ... ] >>> maximalSquare(grid) 9","solution":"from typing import List def maximalSquare(grid: List[str]) -> int: if not grid: return 0 n = len(grid) m = len(grid[0]) # Initialize a 2D dp array with zeroes dp = [[0] * m for _ in range(n)] max_side_length = 0 for i in range(n): for j in range(m): if grid[i][j] == '0': if i == 0 or j == 0: dp[i][j] = 1 # Edge case for first row or first column else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) return max_side_length * max_side_length"},{"question":"def determine_winner(n: int) -> str: Determine the winner of the game given n numbers. >>> determine_winner(3) == 'Alicia' >>> determine_winner(4) == 'Bob'","solution":"def determine_winner(n): Determine the winner of the game given n numbers. Parameters: n (int): The number of numbers arranged in a circle Returns: str: The name of the winner, either 'Alicia' or 'Bob' # If the number of elements is odd, Alicia wins, otherwise Bob wins. if n % 2 == 1: return 'Alicia' else: return 'Bob'"},{"question":"def is_well_connected(N: int, M: int, roads: List[Tuple[int, int]]) -> str: Determine if Pythlandia is well-connected, meaning that there is a path between any pair of villages. >>> is_well_connected(5, 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 'YES' >>> is_well_connected(4, 2, [(1, 2), (3, 4)]) 'NO'","solution":"def is_well_connected(N, M, roads): from collections import defaultdict, deque # Create an adjacency list representation of the graph graph = defaultdict(list) for u, v in roads: graph[u].append(v) graph[v].append(u) # Perform BFS or DFS from any starting node def bfs(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() if node not in visited: visited.add(node) for neighbor in graph[node]: if neighbor not in visited: queue.append(neighbor) return visited # Start from node 1 and see if we can visit all nodes visited = bfs(1) # Check if the number of visited nodes is equal to N if len(visited) == N: return \\"YES\\" else: return \\"NO\\""},{"question":"def find_longest_common_suffix(plants: List[Tuple[str, int]], queries: List[str]) -> List[str]: Amelia is a botanist who loves to catalog plants. She has a notebook containing various plant names paired with their unique IDs. Each plant name consists of lowercase letters only. Amelia is also interested in knowing which plants share the longest common suffix. A suffix is a substring that occurs at the end of a string. Your task is to help her find the longest common suffix for any given prefix of a plant name in her notebook. Input The first line contains an integer N - the number of plant names. Each of the next N lines contains a string Si followed by an integer IDi. Si stands for the plant name and IDi for the unique ID. The next line contains an integer Q - the number of queries. Each of the next Q lines contains a query string Qi, representing a prefix of a plant name she is interested in. Output Q lines, each containing the plant name that matches the prefix Qi with the longest common suffix. If there's a tie, return the plant name with the lexicographically smallest name. If no plant name matches the prefix, output \\"NO MATCH\\". Constraints: 0 <= N <= 1000 0 <= Q <= 1000 1 <= |Si| <= 1000 (length of each plant name Si) 1 <= |Qi| <= 1000 (length of each query Qi) 1 <= |IDi| <= 1000000 (unique ID for each plant) Example: Input: 4 dandelion 9001 rose 9002 liontail 9003 daisy 9004 3 dan rose li Output: dandelion rose liontail >>> plants = [('dandelion', 9001), ('rose', 9002), ('liontail', 9003), ('daisy', 9004)] >>> queries = ['dan', 'rose', 'li'] >>> find_longest_common_suffix(plants, queries) ['dandelion', 'rose', 'liontail'] >>> plants = [('dandelion', 9001), ('rose', 9002), ('liontail', 9003), ('daisy', 9004)] >>> queries = ['xyz', 'abc'] >>> find_longest_common_suffix(plants, queries) ['NO MATCH', 'NO MATCH'] >>> plants = [('apple', 9001), ('ample', 9002), ('anvil', 9003)] >>> queries = ['a', 'am'] >>> find_longest_common_suffix(plants, queries) ['ample', 'ample'] >>> plants = [] >>> queries = ['dan', 'rose', 'li'] >>> find_longest_common_suffix(plants, queries) ['NO MATCH', 'NO MATCH', 'NO MATCH'] >>> plants = [('daffodil', 9001), ('daisy', 9002), ('dahlia', 9003)] >>> queries = ['daisy', 'daff'] >>> find_longest_common_suffix(plants, queries) ['daisy', 'daffodil']","solution":"def find_longest_common_suffix(plants, queries): def common_suffix_length(s1, s2): min_len = min(len(s1), len(s2)) i = 1 while i <= min_len and s1[-i] == s2[-i]: i += 1 return i - 1 matching_results = [] plant_names = [plant[0] for plant in plants] for query in queries: longest_suffix_length = -1 best_match = \\"NO MATCH\\" for plant_name in plant_names: if plant_name.startswith(query): suffix_len = common_suffix_length(plant_name, query) if suffix_len > longest_suffix_length or (suffix_len == longest_suffix_length and plant_name < best_match): longest_suffix_length = suffix_len best_match = plant_name matching_results.append(best_match) return matching_results"},{"question":"def sequence_transformation(N: int, A: List[int]) -> int: Determines the number of distinct arrays B that can be generated following the rules. B[i] = A[i] + max(0, B[i-1] - (i-1)) for 1 <= i <= N where B[0] is considered 0. The function returns the number of distinct arrays B modulo 10^9+7. >>> sequence_transformation(3, [1, 2, 3]) 1 >>> sequence_transformation(2, [1000000000, 1000000000]) 1 >>> sequence_transformation(4, [1, 2, 2, 3]) 0 >>> sequence_transformation(5, [10, 15, 20, 25, 30]) 1 from solution import sequence_transformation def test_sample1(): assert sequence_transformation(3, [1, 2, 3]) == 1 def test_sample2(): assert sequence_transformation(2, [1000000000, 1000000000]) == 1 def test_sample3(): assert sequence_transformation(4, [1, 2, 2, 3]) == 0 def test_sample4(): assert sequence_transformation(5, [10, 15, 20, 25, 30]) == 1 def test_edge_cases(): assert sequence_transformation(1, [1]) == 1 assert sequence_transformation(1, [1000000000]) == 1 def test_large_input(): assert sequence_transformation(5, [1000000000, 999999999, 999999998, 999999997, 999999996]) == 1 def test_all_unique_values(): assert sequence_transformation(5, [1, 3, 5, 7, 9]) == 1 def test_non_unique_mid(): assert sequence_transformation(5, [1, 2, 2, 4, 5]) == 0","solution":"MOD = 10**9 + 7 def count_distinct_arrays(N, A): Determines the number of distinct arrays B that can be generated following the rules. B[i] = A[i] + max(0, B[i-1] - (i-1)) for 1 <= i <= N where B[0] is considered 0. B = [] prev_B = 0 for i in range(1, N+1): current_B = A[i-1] + max(0, prev_B - (i-1)) if current_B in B: return 0 B.append(current_B) prev_B = current_B return 1 def sequence_transformation(N, A): return count_distinct_arrays(N, A) % MOD"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSubtree(T1: TreeNode, T2: TreeNode) -> bool: You are given two binary trees, T1 and T2. Write a function to check if T2 is a subtree of T1. A subtree of T1 is a tree consisting of a node in T1 and all of this node's descendants. The tree T1 could also be considered as a subtree of itself. >>> T1 = TreeNode(3) >>> T1.left = TreeNode(4) >>> T1.right = TreeNode(5) >>> T1.left.left = TreeNode(1) >>> T1.left.right = TreeNode(2) >>> T2 = TreeNode(4) >>> T2.left = TreeNode(1) >>> T2.right = TreeNode(2) >>> isSubtree(T1, T2) == True >>> T1 = TreeNode(3) >>> T1.left = TreeNode(4) >>> T1.right = TreeNode(5) >>> T1.left.left = TreeNode(1) >>> T1.left.right = TreeNode(2) >>> T1.left.right.left = TreeNode(0) >>> T2 = TreeNode(4) >>> T2.left = TreeNode(1) >>> T2.right = TreeNode(2) >>> isSubtree(T1, T2) == False >>> T1 = TreeNode(1) >>> T1.left = TreeNode(2) >>> T1.right = TreeNode(3) >>> T2 = None >>> isSubtree(T1, T2) == True >>> T1 = None >>> T2 = TreeNode(1) >>> isSubtree(T1, T2) == False >>> T1 = None >>> T2 = None >>> isSubtree(T1, T2) == True","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def isSubtree(T1, T2): if not T2: return True # An empty tree is always a subtree if not T1: return False # Non-empty T2 can't be a subtree of an empty T1 if isSameTree(T1, T2): return True return isSubtree(T1.left, T2) or isSubtree(T1.right, T2) def isSameTree(s, t): if not s and not t: return True if not s or not t: return False return s.val == t.val and isSameTree(s.left, t.left) and isSameTree(s.right, t.right)"},{"question":"def min_patches_to_cover_cube(N: int) -> int: Calculate the minimum number of distinct square patches needed to cover the entire surface area of a cube with side length N. Parameters: - N (int): The side length of the cube (1  N  100) Returns: - int: The minimum number of distinct square patches needed Examples: >>> min_patches_to_cover_cube(1) 6 >>> min_patches_to_cover_cube(2) 6 >>> min_patches_to_cover_cube(3) 6 def test_case_1(): assert min_patches_to_cover_cube(1) == 6 def test_case_2(): assert min_patches_to_cover_cube(2) == 6 def test_case_3(): assert min_patches_to_cover_cube(3) == 6 def test_case_4(): assert min_patches_to_cover_cube(10) == 6 def test_case_5(): assert min_patches_to_cover_cube(100) == 6","solution":"def min_patches_to_cover_cube(N): This function calculates the minimum number of distinct square patches needed to cover the entire surface area of a cube with side length N. Parameters: - N (int): The side length of the cube (1  N  100) Returns: - int: The minimum number of distinct square patches needed # Each face of the cube of side N can be covered by one square patch of side N # There are 6 faces in a cube return 6"},{"question":"def count_visible_pairs(T: int, test_cases: List[Tuple[int, List[int], int]]) -> List[int]: You are given an array of integers, denoting positions of people standing in a line. A person can only see the person immediately ahead of them if the difference in their heights is at least K units. Your task is to find the number of pairs of people where one person can see the other. >>> count_visible_pairs(2, [(5, [1, 3, 2, 5, 4], 2), (4, [2, 2, 2, 2], 1)]) == [2, 0] >>> count_visible_pairs(1, [(1, [1], 2)]) == [0] >>> count_visible_pairs(1, [(4, [1, 1, 1, 1], 1)]) == [0] >>> count_visible_pairs(1, [(5, [1, 3, 5, 7, 9], 1)]) == [4] >>> count_visible_pairs(1, [(5, [1, 3, 5, 7, 9], 10)]) == [0]","solution":"def count_visible_pairs(T, test_cases): results = [] for case in test_cases: N, heights, K = case count = 0 for i in range(N - 1): if abs(heights[i] - heights[i + 1]) >= K: count += 1 results.append(count) return results"},{"question":"def generate_pyramid(n: int) -> list: Generates a numeric pyramid of \`n\` layers. Each layer i contains an increasing sequence of i numeric characters. Parameters: n (int): The number of layers in the pyramid. (1  n  100) Returns: list: A list of strings representing each layer of the pyramid. Example: >>> generate_pyramid(5) [\\" 1\\", \\" 12\\", \\" 123\\", \\" 1234\\", \\"12345\\"] >>> generate_pyramid(3) [\\" 1\\", \\" 12\\", \\"123\\"]","solution":"def generate_pyramid(n): Generates a numeric pyramid of \`n\` layers. Parameters: n (int): The number of layers in the pyramid. Returns: list: A list of strings representing each layer of the pyramid. pyramid = [] for i in range(1, n + 1): # Create the layer with spaces and numerical characters layer = ' ' * (n - i) + ''.join(str(x) for x in range(1, i + 1)) pyramid.append(layer) return pyramid"},{"question":"def restore_hexabracelet(n: int, s: str) -> str: Given a length n and a bracelet string s of length n, restores the bracelet by replacing '?' with the characters from 'R', 'G', 'B', 'Y', 'W', 'K' such that the count of each bead type is as equal as possible. Examples: >>> restore_hexabracelet(12, 'R?G?BY??KW?B') 'RGBYBYGKWKRB' >>> restore_hexabracelet(6, 'KWBRGY') 'KWBRGY' >>> restore_hexabracelet(7, 'W??RGB?') '#'","solution":"def restore_hexabracelet(n, s): Given a length n and a bracelet string s of length n, restores the bracelet by replacing '?' with the characters from 'R', 'G', 'B', 'Y', 'W', 'K' such that the count of each bead type is as equal as possible. if n % 6 != 0: return \\"#\\" beads = ['R', 'G', 'B', 'Y', 'W', 'K'] counter = {bead: 0 for bead in beads} for char in s: if char in counter: counter[char] += 1 max_count = n // 6 result = [] idx = 0 def replace_question_mark(): nonlocal idx while counter[beads[idx]] >= max_count: idx += 1 counter[beads[idx]] += 1 return beads[idx] for char in s: if char == '?': result.append(replace_question_mark()) else: result.append(char) return ''.join(result)"},{"question":"def battle_outcome(t, test_cases): Determine which army wins or if the battle ends in a draw given the strengths of the soldiers in both armies. Args: t (int): Number of test cases test_cases (List[Dict]): List of test cases containing 'n' (number of soldiers in the first army), 'first_army' (list of strengths of the first army), 'm' (number of soldiers in the second army), 'second_army' (list of strengths of the second army) Returns: List[str]: List of results for each test case, which can be \\"First Army\\", \\"Second Army\\", or \\"Draw\\" >>> battle_outcome(2, [ {'n': 5, 'first_army': [3, 6, 2, 8, 7], 'm': 4, 'second_army': [4, 5, 1, 10]}, {'n': 3, 'first_army': [7, 5, 4], 'm': 3, 'second_army': [6, 4, 5]} ]) [\\"First Army\\", \\"Draw\\"]","solution":"def battle_outcome(t, test_cases): results = [] for case in test_cases: n = case['n'] first_army = sorted(case['first_army'], reverse=True) m = case['m'] second_army = sorted(case['second_army'], reverse=True) # Number of common battles, will be the min(n, m) common_battles = min(n, m) # Compare the strongest to the weakest in the common_battles for i in range(common_battles): if first_army[i] > second_army[i]: results.append(\\"First Army\\") break elif first_army[i] < second_army[i]: results.append(\\"Second Army\\") break else: if n > m: results.append(\\"First Army\\") elif n < m: results.append(\\"Second Army\\") else: results.append(\\"Draw\\") return results # Test cases format for the function # t: Number of test cases # test_cases: List of dictionaries, each containing 'n', 'first_army', 'm', 'second_army' def main(): t = 2 test_cases = [ { 'n': 5, 'first_army': [3, 6, 2, 8, 7], 'm': 4, 'second_army': [4, 5, 1, 10] }, { 'n': 3, 'first_army': [7, 5, 4], 'm': 3, 'second_army': [6, 4, 5] } ] results = battle_outcome(t, test_cases) for result in results: print(result) # Sample execution for the sample test cases main()"},{"question":"def is_path_possible(grid, N, M): Determine if it is possible to navigate from the top-left corner to the bottom-right corner of the grid. >>> navigate_river(\\"5 5nL..R.nRL..RnR.RLLnLL.RLn....L\\") \\"YES\\" >>> navigate_river(\\"4 4nL.R.n.RL.nRLR.n.LRR\\") \\"NO\\" def navigate_river(grid_input): Parse the grid input and determine the path possibility. >>> navigate_river(\\"5 5nL..R.nRL..RnR.RLLnLL.RLn....L\\") \\"YES\\" >>> navigate_river(\\"4 4nL.R.n.RL.nRLR.n.LRR\\") \\"NO\\" def test_is_path_possible(): input1 = \\"5 5nL..R.nRL..RnR.RLLnLL.RLn....L\\" input2 = \\"4 4nL.R.n.RL.nRLR.n.LRR\\" input3 = \\"1 1nL\\" input4 = \\"2 2nLRnRR\\" assert navigate_river(input1) == \\"YES\\" assert navigate_river(input2) == \\"NO\\" assert navigate_river(input3) == \\"YES\\" assert navigate_river(input4) == \\"NO\\" input5 = \\"3 3nL..n.R.n..L\\" assert navigate_river(input5) == \\"YES\\" input6 = \\"3 3nL.Rn.R.nRR.\\" assert navigate_river(input6) == \\"NO\\"","solution":"def is_path_possible(grid, N, M): from collections import deque directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0)]) visited = set((0, 0)) while queue: r, c = queue.popleft() if (r, c) == (N-1, M-1): return \\"YES\\" for dr, dc in directions: nr, nc = r + dr, c + dc if 0 <= nr < N and 0 <= nc < M and (nr, nc) not in visited and grid[nr][nc] != 'R': visited.add((nr, nc)) queue.append((nr, nc)) return \\"NO\\" def navigate_river(grid_input): N, M = map(int, grid_input.split('n')[0].split()) grid = [list(row) for row in grid_input.strip().split('n')[1:]] return is_path_possible(grid, N, M)"},{"question":"def can_form_palindrome(s: str) -> bool: Determine if the string can be rearranged to form a palindrome. >>> can_form_palindrome(\\"civic\\") True >>> can_form_palindrome(\\"ivicc\\") True >>> can_form_palindrome(\\"hello\\") False >>> can_form_palindrome(\\"aaabbb\\") False","solution":"def can_form_palindrome(s): Determine if the string can be rearranged to form a palindrome. # Count frequencies of each character char_count = {} for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 # Check the number of characters with odd frequencies odd_count = 0 for count in char_count.values(): if count % 2 != 0: odd_count += 1 # For string to be rearranged to form a palindrome: # If the string length is even, no character should have an odd frequency. # If the string length is odd, one character can have an odd frequency. return odd_count <= 1"},{"question":"def count_ways_to_pack(T, cupcake_counts): Returns the number of unique ways to pack the cupcakes into bags such that each bag contains at least one of each type of cupcake. >>> count_ways_to_pack(3, [2, 2, 2]) 8 >>> count_ways_to_pack(2, [1, 2]) 2 >>> count_ways_to_pack(4, [1, 1, 1, 1]) 1 >>> count_ways_to_pack(3, [3, 2, 1]) 6 >>> count_ways_to_pack(1, [20]) 20 >>> count_ways_to_pack(5, [2, 3, 4, 5, 6]) 720","solution":"def count_ways_to_pack(T, cupcake_counts): Returns the number of unique ways to pack the cupcakes into bags such that each bag contains at least one of each type of cupcake. unique_ways = 1 for count in cupcake_counts: unique_ways *= count return unique_ways def main(): T = int(input().strip()) cupcake_counts = list(map(int, input().strip().split())) print(count_ways_to_pack(T, cupcake_counts))"},{"question":"def packet_id_lengths(packet_ids): Returns the frequency of packet ID lengths in ascending order. Args: packet_ids (List[str]): List of packet identifier strings. Returns: List[Tuple[int, int]]: List of tuples containing the length of packet IDs and the corresponding frequency, sorted in ascending order. Examples: >>> packet_id_lengths([\\"abc\\", \\"a\\", \\"abcd\\", \\"ab\\", \\"abcde\\"]) [(1, 1), (2, 1), (3, 2), (4, 1), (5, 1)] >>> packet_id_lengths([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeeee\\"]) [(1, 1), (2, 1), (3, 1), (4, 1), (5, 1)]","solution":"def packet_id_lengths(packet_ids): Returns the frequency of packet ID lengths in ascending order. length_freq = {} for packet_id in packet_ids: length = len(packet_id) if length in length_freq: length_freq[length] += 1 else: length_freq[length] = 1 sorted_lengths = sorted(length_freq.items()) return sorted_lengths"},{"question":"from typing import List def pacific_atlantic(heights: List[List[int]]) -> List[List[int]]: Determine the set of cells from which water can flow to both the Pacific Ocean and the Atlantic Ocean. >>> pacific_atlantic([ ... [1, 2, 2, 3, 5], ... [3, 2, 3, 4, 4], ... [2, 4, 5, 3, 1], ... [6, 7, 1, 4, 5], ... [5, 1, 1, 2, 4] ... ]) [[0,4], [1,3], [1,4], [2,2], [3,0], [3,1], [4,0]] >>> pacific_atlantic([ ... [2, 1], ... [1, 2] ... ]) [[0,0], [0,1], [1,0], [1,1]]","solution":"def pacific_atlantic(heights): if not heights or not heights[0]: return [] rows, cols = len(heights), len(heights[0]) pacific_reached = [[False] * cols for _ in range(rows)] atlantic_reached = [[False] * cols for _ in range(rows)] def dfs(r, c, visited): visited[r][c] = True for (dr, dc) in [(1, 0), (-1, 0), (0, 1), (0, -1)]: nr, nc = r + dr, c + dc if 0 <= nr < rows and 0 <= nc < cols and not visited[nr][nc] and heights[nr][nc] >= heights[r][c]: dfs(nr, nc, visited) for r in range(rows): dfs(r, 0, pacific_reached) dfs(r, cols - 1, atlantic_reached) for c in range(cols): dfs(0, c, pacific_reached) dfs(rows - 1, c, atlantic_reached) result = [] for r in range(rows): for c in range(cols): if pacific_reached[r][c] and atlantic_reached[r][c]: result.append([r, c]) return result"},{"question":"def is_possible_to_sort(k: int, nums: List[int]) -> str: Determines if it is possible to sort an array in non-decreasing order by incrementing or decrementing elements by 1. Parameters: k (int): The number of elements in the list. nums (list of ints): The list of integers. Returns: str: 'POSSIBLE' if the list can be sorted in non-decreasing order, 'IMPOSSIBLE' otherwise. >>> is_possible_to_sort(4, [1, 2, 3, 4]) == \\"POSSIBLE\\" >>> is_possible_to_sort(5, [3, 4, 7, 2, 5]) == \\"IMPOSSIBLE\\" >>> is_possible_to_sort(3, [2, 3, 4]) == \\"POSSIBLE\\" >>> is_possible_to_sort(5, [1, 2, 2, 3, 3]) == \\"POSSIBLE\\" >>> is_possible_to_sort(1, [42]) == \\"POSSIBLE\\" >>> is_possible_to_sort(2, [0, 1000]) == \\"IMPOSSIBLE\\"","solution":"def is_possible_to_sort(k, nums): Determines if it is possible to sort an array in non-decreasing order by incrementing or decrementing elements by 1. Parameters: k (int): The number of elements in the list. nums (list of ints): The list of integers. Returns: str: 'POSSIBLE' if the list can be sorted in non-decreasing order, 'IMPOSSIBLE' otherwise. for i in range(1, k): if abs(nums[i] - nums[i - 1]) > 1: return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def min_deletions_to_make_beautiful(s: str) -> int: Determines the minimum number of deletions required to make the string beautiful. A string is called beautiful if it can be obtained by deleting some (possibly zero) characters from \`s\` such that no two adjacent characters are the same. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of deletions required. Examples: >>> min_deletions_to_make_beautiful(\\"aab\\") 1 >>> min_deletions_to_make_beautiful(\\"aabb\\") 2","solution":"def min_deletions_to_make_beautiful(s): Determines the minimum number of deletions required to make the string beautiful. Parameters: s (str): The input string consisting of lowercase English letters. Returns: int: The minimum number of deletions required. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def treasure_hunt(t, test_cases): For each test case, determine if the string can be rearranged so that no character is in its original position. Args: t (int): The number of test cases. test_cases (List[str]): A list of strings to check for the rearrangement possibility. Returns: List[str]: A list of results \\"YES\\" or \\"NO\\" for each test case. Examples: >>> treasure_hunt(3, [\\"abcd\\", \\"aab\\", \\"abcde\\"]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> treasure_hunt(1, [\\"a\\"]) [\\"NO\\"] # hint: Helper function can_rearrange can be used to determine if a single string can be rearranged","solution":"def can_rearrange(s): Determines if the string s can be rearranged so that no character appears in its original position. from collections import Counter n = len(s) count = Counter(s) # We need to check two conditions: # 1. No character should have a count greater than (n + 1) // 2. # 2. The length of the string should be more than 1 since for a single character, rearrangement is not possible. if n == 1: return \\"NO\\" if max(count.values()) > (n + 1) // 2: return \\"NO\\" return \\"YES\\" def treasure_hunt(t, test_cases): For each test case, determine if the string can be rearranged so that no character is in its original position. results = [] for s in test_cases: results.append(can_rearrange(s)) return results"},{"question":"MOD = 10**9 + 7 def count_sequences(n: int) -> int: Returns the number of distinct sequences of length n such that the GCD of every consecutive pair is a prime number. >>> count_sequences(1) 3 >>> count_sequences(2) 9 >>> count_sequences(3) 27 >>> count_sequences(4) 81 >>> count_sequences(5) 243 pass","solution":"MOD = 10**9 + 7 def count_sequences(n): Returns the number of distinct sequences of length n such that the GCD of every consecutive pair is a prime number. if n == 1: return 3 primes = [2, 3, 5] base_count = len(primes) # number of primes to use total_sequences = 1 for _ in range(n): total_sequences = (total_sequences * base_count) % MOD return total_sequences"},{"question":"def max_score_not_completed(n: int, log: List[Tuple[int, int]]) -> int: Find the maximum score among the participants who have not completed all challenges. Parameters: n (int): The number of participants' entries in the log. log (list): A list of tuples where each tuple contains a participant's score and their completion status. Returns: int: The maximum score among participants who have not completed all challenges, or -1 if all have completed. Examples: >>> max_score_not_completed(5, [(500, 0), (400, 1), (300, 0), (400, 0), (350, 1)]) 500 >>> max_score_not_completed(3, [(200, 1), (300, 1), (400, 1)]) -1 >>> max_score_not_completed(4, [(100, 0), (100, 0), (50, 0), (60, 1)]) 100 from typing import List, Tuple def test_max_score_not_completed(): n = 5 log = [(500, 0), (400, 1), (300, 0), (400, 0), (350, 1)] assert max_score_not_completed(n, log) == 500 n = 3 log = [(200, 1), (300, 1), (400, 1)] assert max_score_not_completed(n, log) == -1 n = 4 log = [(100, 0), (100, 0), (50, 0), (60, 1)] assert max_score_not_completed(n, log) == 100 n = 2 log = [(1000, 1), (1000, 1)] assert max_score_not_completed(n, log) == -1 n = 6 log = [(500, 0), (700, 0), (800, 1), (250, 0), (200, 1), (900, 0)] assert max_score_not_completed(n, log) == 900 n = 1 log = [(500, 0)] assert max_score_not_completed(n, log) == 500 n = 1 log = [(500, 1)] assert max_score_not_completed(n, log) == -1 n = 4 log = [(100, 1), (200, 0), (100, 1), (150, 0)] assert max_score_not_completed(n, log) == 200","solution":"def max_score_not_completed(n, log): Find the maximum score among the participants who have not completed all challenges. Parameters: n (int): The number of participants' entries in the log. log (list): A list of tuples where each tuple contains a participant's score and their completion status. Returns: int: The maximum score among participants who have not completed all challenges, or -1 if all have completed. max_score = -1 for score, status in log: if status == 0: max_score = max(max_score, score) return max_score"},{"question":"def two_elements_sum_to_target(N: int, A: List[int], T: int) -> str: Determines if any two distinct elements in array A sum up to target T. Each of the function parameters is: - N: Length of the array A - A: List of integers - T: Target sum >>> two_elements_sum_to_target(5, [1, 2, 3, 9, 14], 11) \\"YES\\" >>> two_elements_sum_to_target(4, [-1, -2, -3, -4], -8) \\"NO\\" pass # Input parsing function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:N+1])) T = int(data[N+1]) print(two_elements_sum_to_target(N, A, T))","solution":"def two_elements_sum_to_target(N, A, T): Determines if any two distinct elements in array A sum up to target T. seen_elements = set() for number in A: if (T - number) in seen_elements: return \\"YES\\" seen_elements.add(number) return \\"NO\\" # Input parsing function def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) A = list(map(int, data[1:N+1])) T = int(data[N+1]) print(two_elements_sum_to_target(N, A, T))"},{"question":"def month_name(n: int) -> str: Given an integer n (1  n  12) representing a month of the year, returns the string representation of the corresponding month's name in English. >>> month_name(1) 'January' >>> month_name(5) 'May' >>> month_name(12) 'December'","solution":"def month_name(n): Returns the name of the month corresponding to the integer n (1  n  12). months = [ \\"January\\", \\"February\\", \\"March\\", \\"April\\", \\"May\\", \\"June\\", \\"July\\", \\"August\\", \\"September\\", \\"October\\", \\"November\\", \\"December\\" ] return months[n - 1]"},{"question":"def calculate_final_coordinates(datasets): Simulate the robot's movements and determine its final position for each dataset. Given a list of datasets, where each dataset is a list of movement commands, this function returns a list of tuples representing the final coordinates of the robot. >>> calculate_final_coordinates([[\\"UP 5\\", \\"RIGHT 3\\", \\"DOWN 2\\"]]) [(3, 3)] >>> calculate_final_coordinates([[\\"LEFT 1\\", \\"UP 4\\"]]) [(-1, 4)] pass def process_input(input_data): Process the input data to extract the list of command datasets. This function takes a single string input representing the entire series of command datasets, and returns a list of final coordinates for each dataset. >>> input_data = \\"3nUP 5nRIGHT 3nDOWN 2n2nLEFT 1nUP 4nSTOP\\" >>> process_input(input_data) [(3, 3), (-1, 4)] pass","solution":"def calculate_final_coordinates(datasets): results = [] for dataset in datasets: x, y = 0, 0 for command in dataset: direction, value = command.split() value = int(value) if direction == \\"UP\\": y += value elif direction == \\"DOWN\\": y -= value elif direction == \\"LEFT\\": x -= value elif direction == \\"RIGHT\\": x += value results.append((x, y)) return results def process_input(input_data): datasets = [] input_lines = input_data.splitlines() i = 0 while i < len(input_lines): if input_lines[i] == \\"STOP\\": break m = int(input_lines[i]) commands = [] for j in range(1, m + 1): commands.append(input_lines[i + j]) datasets.append(commands) i += m + 1 return calculate_final_coordinates(datasets)"},{"question":"def count_partitions(n: int, k: int, arr: List[int]) -> int: Determine the number of ways to partition a set of 'n' integers into 'k' non-empty subsets such that each subset has a non-decreasing order. >>> count_partitions(4, 2, [1, 2, 3, 4]) 7 >>> count_partitions(5, 3, [3, 1, 4, 2, 5]) 25","solution":"def count_partitions(n, k, arr): MOD = 1000000007 # Initialize a dp table with dimensions (n + 1) x (k + 1) dp = [[0] * (k + 1) for _ in range(n + 1)] dp[0][0] = 1 # Sort the array as the partition needs to be in non-decreasing order arr.sort() # Calculate the Stirling numbers of the second kind for i in range(1, n + 1): for j in range(1, k + 1): dp[i][j] = (dp[i - 1][j - 1] + (j * dp[i - 1][j]) % MOD) % MOD return dp[n][k]"},{"question":"class VendingMachine: A class to simulate the behavior of a vending machine with a selection of five different items, each with a different price and a limited quantity available. The machine accepts coins of three denominations: 10 cents, 20 cents, and 50 cents. The machine allows a user to: 1. Select an item by entering its corresponding code. 2. Insert the necessary coins to pay for the selected item. 3. Receive the item if the payment is sufficient, or be prompted to insert more coins if the amount is insufficient. If the inserted amount exceeds the item's price, the machine returns the appropriate change. 4. Be notified if the selected item is out of stock. The machine handles multiple user interactions until an \\"exit\\" command is received. def __init__(self): self.items = { \\"A\\": {\\"name\\": \\"Water\\", \\"price\\": 50, \\"quantity\\": 5}, \\"B\\": {\\"name\\": \\"Soda\\", \\"price\\": 70, \\"quantity\\": 5}, \\"C\\": {\\"name\\": \\"Chips\\", \\"price\\": 45, \\"quantity\\": 5}, \\"D\\": {\\"name\\": \\"Chocolate\\", \\"price\\": 65, \\"quantity\\": 5}, \\"E\\": {\\"name\\": \\"Gum\\", \\"price\\": 30, \\"quantity\\": 5} } self.valid_coins = [10, 20, 50] def select_item(self, item_code: str) -> str: Allows the user to select an item by entering its corresponding code. Parameters: item_code (str): Code of the selected item Returns: str: A message about the selected item, its price, or if the item is out of stock. def insert_coin(self, item_code: str, inserted_coins: list) -> str: Allows the user to insert the necessary coins to pay for the selected item. Parameters: item_code (str): Code of the selected item inserted_coins (list): List of inserted coin amounts (10, 20, or 50 cents) Returns: str: A message indicating if the payment is sufficient, insufficient, or invalid. def test_select_item(): vm = VendingMachine() assert vm.select_item(\\"A\\") == \\"Selected item: Water, price: 50 cents\\" assert vm.select_item(\\"B\\") == \\"Selected item: Soda, price: 70 cents\\" assert vm.select_item(\\"F\\") == \\"Invalid selection.\\" def test_select_item_out_of_stock(): vm = VendingMachine() vm.items[\\"A\\"][\\"quantity\\"] = 0 assert vm.select_item(\\"A\\") == \\"Sorry, Water is out of stock.\\" def test_insert_coin_insufficient(): vm = VendingMachine() assert vm.insert_coin(\\"A\\", [10, 10]) == \\"Not enough money inserted. Please insert 30 cents more.\\" def test_insert_coin_sufficient_no_change(): vm = VendingMachine() assert vm.insert_coin(\\"A\\", [50]) == \\"Dispensing Water. Change: 0 cents\\" def test_insert_coin_sufficient_with_change(): vm = VendingMachine() assert vm.insert_coin(\\"A\\", [20, 20, 20]) == \\"Dispensing Water. Change: 10 cents\\" def test_insert_coin_invalid_selection(): vm = VendingMachine() assert vm.insert_coin(\\"F\\", [10]) == \\"Invalid selection.\\" def test_item_quantity_decrease(): vm = VendingMachine() initial_quantity = vm.items[\\"A\\"][\\"quantity\\"] vm.insert_coin(\\"A\\", [50]) assert vm.items[\\"A\\"][\\"quantity\\"] == initial_quantity - 1","solution":"class VendingMachine: def __init__(self): self.items = { \\"A\\": {\\"name\\": \\"Water\\", \\"price\\": 50, \\"quantity\\": 5}, \\"B\\": {\\"name\\": \\"Soda\\", \\"price\\": 70, \\"quantity\\": 5}, \\"C\\": {\\"name\\": \\"Chips\\", \\"price\\": 45, \\"quantity\\": 5}, \\"D\\": {\\"name\\": \\"Chocolate\\", \\"price\\": 65, \\"quantity\\": 5}, \\"E\\": {\\"name\\": \\"Gum\\", \\"price\\": 30, \\"quantity\\": 5} } self.valid_coins = [10, 20, 50] def select_item(self, item_code): if item_code not in self.items: return \\"Invalid selection.\\" item = self.items[item_code] if item[\\"quantity\\"] == 0: return f\\"Sorry, {item['name']} is out of stock.\\" return f\\"Selected item: {item['name']}, price: {item['price']} cents\\" def insert_coin(self, item_code, inserted_coins): if item_code not in self.items: return \\"Invalid selection.\\" item = self.items[item_code] total_inserted = sum(inserted_coins) if total_inserted < item[\\"price\\"]: remaining = item[\\"price\\"] - total_inserted return f\\"Not enough money inserted. Please insert {remaining} cents more.\\" else: change = total_inserted - item[\\"price\\"] item[\\"quantity\\"] -= 1 return f\\"Dispensing {item['name']}. Change: {change} cents\\""},{"question":"def longest_unique_genre_playlist(n: int, genres: List[str]) -> int: Find the length of the longest playlist that contains only unique genres. >>> longest_unique_genre_playlist(7, ['rock', 'pop', 'jazz', 'classical', 'rock', 'pop', 'hip-hop']) == 5 >>> longest_unique_genre_playlist(4, ['rock', 'pop', 'jazz', 'classical']) == 4 >>> longest_unique_genre_playlist(5, ['rock', 'rock', 'rock', 'rock', 'rock']) == 1 >>> longest_unique_genre_playlist(6, ['rock', 'pop', 'pop', 'jazz', 'jazz', 'classical']) == 4 >>> longest_unique_genre_playlist(1, ['rock']) == 1","solution":"def longest_unique_genre_playlist(n, genres): Find the length of the longest playlist that contains only unique genres. :param n: int, number of music records :param genres: list of strings, each string represents a genre :return: int, length of the longest playlist with unique genres # Use a set to store unique genres unique_genres = set(genres) # Return the number of unique genres return len(unique_genres)"},{"question":"def selection_sort(weights: List[int]) -> List[int]: Sorts a list of box weights using the selection sort algorithm. Parameters: weights (List[int]): A list of integers representing the weights of the boxes. Returns: List[int]: The list of weights sorted in non-decreasing order. >>> selection_sort([29, 10, 14, 37, 13]) == [10, 13, 14, 29, 37] >>> selection_sort([5, 3, 8, 4, 2]) == [2, 3, 4, 5, 8] >>> selection_sort([1]) == [1] >>> selection_sort([100, 300, 20, 400, 50]) == [20, 50, 100, 300, 400] >>> selection_sort([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] >>> selection_sort([2, 4, 1, 3, 5]) == [1, 2, 3, 4, 5] >>> selection_sort([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1] >>> selection_sort([0, -1, 1, -2, 2, -3, 3]) == [-3, -2, -1, 0, 1, 2, 3]","solution":"def selection_sort(weights): Sorts a list of box weights using the selection sort algorithm. Parameters: weights (List[int]): A list of integers representing the weights of the boxes. Returns: List[int]: The list of weights sorted in non-decreasing order. n = len(weights) for i in range(n): # Find the minimum element in the remaining unsorted array min_index = i for j in range(i+1, n): if weights[j] < weights[min_index]: min_index = j # Swap the found minimum element with the first element of the unsorted part weights[i], weights[min_index] = weights[min_index], weights[i] return weights"},{"question":"def calculate_sum_and_max(numbers_str: str) -> (int, int): Given a string of numbers separated by commas, this function calculates and returns the sum of the numbers and the largest number in the list. >>> calculate_sum_and_max(\\"1,2,3,4,5\\") (15, 5) >>> calculate_sum_and_max(\\"-1,-2,-3,-4,5\\") (-5, 5) >>> calculate_sum_and_max(\\"10,20,30,-10,-20\\") (30, 30)","solution":"def calculate_sum_and_max(numbers_str): Given a string of numbers separated by commas, this function calculates and returns the sum of the numbers and the largest number in the list. numbers = list(map(int, numbers_str.split(','))) total_sum = sum(numbers) max_number = max(numbers) return total_sum, max_number"},{"question":"def reorder_words(input_line: str) -> str: Reorders the words in the input line in reverse order, prints them separated by one space. Args: input_line (str): The input line containing words separated by one or more spaces. Returns: str: A single string with words in reverse order, separated by one space. >>> reorder_words(\\"hello world this is an example\\") \\"example an is this world hello\\" >>> reorder_words(\\"openai chatgpt assistant\\") \\"assistant chatgpt openai\\"","solution":"def reorder_words(input_line): Reorders the words in the input line in reverse order, prints them separated by one space. Args: input_line (str): The input line containing words separated by one or more spaces. Returns: str: A single string with words in reverse order, separated by one space. # Splitting the input line by spaces will give all words as a list words = input_line.split() # Reversing this list of words reversed_words = words[::-1] # Joining the reversed list with a single space output_line = ' '.join(reversed_words) return output_line"},{"question":"def tower_of_hanoi(n, source, target, auxiliary, moves): Recursively solves the Tower of Hanoi problem. Parameters: n (int): Number of disks source (int): The source rod number target (int): The target rod number auxiliary (int): The auxiliary rod number moves (list): A list to record the moves Examples: >>> moves = [] >>> tower_of_hanoi(2, 1, 3, 2, moves) >>> moves ['Move disk 1 from rod 1 to rod 2', 'Move disk 2 from rod 1 to rod 3', 'Move disk 1 from rod 2 to rod 3'] if n == 1: moves.append(f\\"Move disk 1 from rod {source} to rod {target}\\") return tower_of_hanoi(n-1, source, auxiliary, target, moves) moves.append(f\\"Move disk {n} from rod {source} to rod {target}\\") tower_of_hanoi(n-1, auxiliary, target, source, moves) def solve_tower_of_hanoi(test_cases): Solves multiple Tower of Hanoi test cases. Parameters: test_cases (list): A list of integers, each representing the number of disks in a test case Returns: list: A list containing tuples, each with the number of moves and the moves themselves for each test case Examples: >>> solve_tower_of_hanoi([2]) [(3, ['Move disk 1 from rod 1 to rod 2', 'Move disk 2 from rod 1 to rod 3', 'Move disk 1 from rod 2 to rod 3'])] >>> solve_tower_of_hanoi([3]) [(7, ['Move disk 1 from rod 1 to rod 3', 'Move disk 2 from rod 1 to rod 2', 'Move disk 1 from rod 3 to rod 2', 'Move disk 3 from rod 1 to rod 3', 'Move disk 1 from rod 2 to rod 1', 'Move disk 2 from rod 2 to rod 3', 'Move disk 1 from rod 1 to rod 3'])]","solution":"def tower_of_hanoi(n, source, target, auxiliary, moves): if n == 1: moves.append(f\\"Move disk 1 from rod {source} to rod {target}\\") return tower_of_hanoi(n-1, source, auxiliary, target, moves) moves.append(f\\"Move disk {n} from rod {source} to rod {target}\\") tower_of_hanoi(n-1, auxiliary, target, source, moves) def solve_tower_of_hanoi(test_cases): results = [] for n in test_cases: moves = [] tower_of_hanoi(n, 1, 3, 2, moves) results.append((2**n - 1, moves)) return results"},{"question":"def encrypt_message(s: str, k: int) -> str: Encrypt the string s by shifting its alphabetic characters by k positions. The shift should wrap around within the alphabet if it goes past 'z' or 'Z'. Non-alphabetic characters should remain unchanged. :param s: The input string to be encrypted. :param k: The shift value. :return: The encrypted string. >>> encrypt_message(\\"Hello, World!\\", 3) == \\"Khoor, Zruog!\\" >>> encrypt_message(\\"abc xyz\\", 1) == \\"bcd yza\\" >>> encrypt_message(\\"Test Message\\", 0) == \\"Test Message\\" >>> encrypt_message(\\"aBz\\", 25) == \\"zAy\\" >>> encrypt_message(\\"123 ABC abc!\\", 2) == \\"123 CDE cde!\\" >>> long_input = \\"a\\" * 100000 >>> long_expected_output = \\"b\\" * 100000 >>> encrypt_message(long_input, 1) == long_expected_output","solution":"def encrypt_message(s, k): Encrypts the string s by shifting its alphabetic characters by k positions. :param s: The input string to be encrypted. :param k: The shift value. :return: The encrypted string. result = [] for char in s: if 'a' <= char <= 'z': # Shift and wrap within lowercase letters result.append(chr((ord(char) - ord('a') + k) % 26 + ord('a'))) elif 'A' <= char <= 'Z': # Shift and wrap within uppercase letters result.append(chr((ord(char) - ord('A') + k) % 26 + ord('A'))) else: # Non-alphabetic characters remain unchanged result.append(char) return ''.join(result)"},{"question":"from typing import List, Tuple def form_pairs(fitness_levels: List[int]) -> Tuple[List[Tuple[int, int]], int]: Forms pairs of runners based on their fitness levels to minimize the sum of absolute differences. :param fitness_levels: List of integers representing fitness levels :return: A tuple containing a list of tuples (pairs of runners) and a single integer representing the odd runner, if any. >>> form_pairs([10, 1, 8, 12]) ([(1, 8), (10, 12)], None) >>> form_pairs([4, 2, 7, 1, 8]) ([(1, 2), (4, 7)], 8) pass def marathon_pairs(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[Tuple[List[Tuple[int, int]], int]]: Processes multiple test cases for forming marathon pairs. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains (n, fitness_levels) :return: List of results for each test case >>> marathon_pairs(2, [(5, [4, 2, 7, 1, 8]), (4, [10, 1, 8, 12])]) [[(1, 2), (4, 7)], 8, [(1, 8), (10, 12)], None] >>> marathon_pairs(1, [(1, [5])]) [([], 5)] pass","solution":"def form_pairs(fitness_levels): Forms pairs of runners based on their fitness levels to minimize the sum of absolute differences :param fitness_levels: List of integers representing fitness levels :return: A list of tuples representing the pairs and a separate integer if there is an odd runner fitness_levels.sort() pairs = [] while len(fitness_levels) > 1: pairs.append((fitness_levels.pop(0), fitness_levels.pop(0))) # If there is an odd runner left, include them separately if fitness_levels: return pairs, fitness_levels[0] else: return pairs, None def marathon_pairs(t, test_cases): Processes multiple test cases for forming marathon pairs. :param t: Number of test cases :param test_cases: List of tuples where each tuple contains (n, fitness_levels) :return: List of results for each test case results = [] for i in range(t): n, fitness_levels = test_cases[i] results.append(form_pairs(fitness_levels)) return results"},{"question":"def smallest_missing_positive(nums): Returns the smallest positive integer that is missing from the list. This function runs in linear time and uses constant space. >>> smallest_missing_positive([1, 2, 0, -1, 5]) 3 >>> smallest_missing_positive([1, 2, 3]) 4 >>> smallest_missing_positive([3, 4, -1, 1, 9, 7, 8, 2]) 5 def test_smallest_missing_positive_example1(): assert smallest_missing_positive([1, 2, 0, -1, 5]) == 3 def test_smallest_missing_positive_example2(): assert smallest_missing_positive([1, 2, 3]) == 4 def test_smallest_missing_positive_example3(): assert smallest_missing_positive([3, 4, -1, 1, 9, 7, 8, 2]) == 5 def test_smallest_missing_positive_all_positive(): assert smallest_missing_positive([7, 8, 9, 11, 12]) == 1 def test_smallest_missing_positive_single_element(): assert smallest_missing_positive([1]) == 2 assert smallest_missing_positive([2]) == 1 def test_smallest_missing_positive_unordered_elements(): assert smallest_missing_positive([2, 1, 4, 3]) == 5 def test_smallest_missing_positive_max_elements(): assert smallest_missing_positive(list(range(1, 1000001))) == 1000001 def test_smallest_missing_positive_duplicates(): assert smallest_missing_positive([1, 1, 2, 2]) == 3","solution":"def smallest_missing_positive(nums): Returns the smallest positive integer that is missing from the list. This function runs in linear time and uses constant space. n = len(nums) # Place each number in its right place (i.e., 1 at index 0, 2 at index 1, ...) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: correct_pos = nums[i] - 1 nums[i], nums[correct_pos] = nums[correct_pos], nums[i] # Find the first place where the number is not the correct one for i in range(n): if nums[i] != i + 1: return i + 1 # If all positions are correct, then the smallest missing number is n + 1 return n + 1"},{"question":"def schedule_movies(n: int, screenings: List[Tuple[int, int]]) -> int: Given the number of movies and their start and end times, calculate the maximum number of non-overlapping screenings that can be scheduled. >>> schedule_movies(3, [(1, 3), (2, 5), (4, 7)]) 2 >>> schedule_movies(4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 4","solution":"def schedule_movies(n, screenings): Given the number of movies and their start and end times, this function calculates the maximum number of non-overlapping screenings that can be scheduled. # Sort the movies by their end times screenings.sort(key=lambda x: x[1]) max_screenings = 0 last_end_time = 0 for start, end in screenings: if start >= last_end_time: max_screenings += 1 last_end_time = end return max_screenings"},{"question":"def second_largest_unique_integer(s: str) -> int: Takes an input string containing a list of integers separated by spaces, and returns the second largest unique integer in the list. If the list contains fewer than two unique integers, return None. >>> second_largest_unique_integer(\\"4 2 3 1 2 3 5\\") 4 >>> second_largest_unique_integer(\\"7 7 7 7 7\\") None >>> second_largest_unique_integer(\\"1\\") None >>> second_largest_unique_integer(\\"2 2\\") None >>> second_largest_unique_integer(\\"3 3 5\\") 3 >>> second_largest_unique_integer(\\"1 2 -1 2 -3 5\\") 2 >>> second_largest_unique_integer(\\"-1 -2 -3 -1 -2 -3\\") -2 >>> second_largest_unique_integer(\\"1000000 -1000000 500000\\") 500000","solution":"def second_largest_unique_integer(s): Returns the second largest unique integer in the list of integers from the input string. If there are fewer than two unique integers, return None. integers = list(map(int, s.split())) unique_integers = set(integers) if len(unique_integers) < 2: return None sorted_uniques = sorted(unique_integers, reverse=True) return sorted_uniques[1]"},{"question":"def longest_failed_sequence(n: int, status: List[int]) -> int: Determines the length of the longest subsequence of consecutive failed sensors (1s) along a trail. Parameters: n (int): The number of sensors along the trail. status (list of int): The status of each sensor (0 for functioning, 1 for failed). Returns: int: The length of the longest consecutive sequence of failed sensors. >>> longest_failed_sequence(10, [1, 1, 0, 1, 1, 1, 0, 0, 1, 1]) 3 >>> longest_failed_sequence(5, [0, 0, 0, 0, 0]) 0 >>> longest_failed_sequence(8, [1, 1, 1, 0, 1, 1, 1, 1]) 4 >>> longest_failed_sequence(1, [1]) 1 >>> longest_failed_sequence(1, [0]) 0","solution":"def longest_failed_sequence(n, status): Determines the length of the longest subsequence of consecutive failed sensors (1s) along a trail. Parameters: n (int): The number of sensors along the trail. status (list of int): The status of each sensor (0 for functioning, 1 for failed). Returns: int: The length of the longest consecutive sequence of failed sensors. max_length = 0 current_length = 0 for sensor in status: if sensor == 1: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 0 return max_length"},{"question":"def sum_of_primes(n: int) -> int: Given an integer n (1  n  1,000,000), determine the sum of all prime numbers less than or equal to n. >>> sum_of_primes(10) 17 >>> sum_of_primes(100) 1060 >>> sum_of_primes(1) 0 >>> sum_of_primes(2) 2 >>> sum_of_primes(3) 5 >>> sum_of_primes(5) 10 >>> sum_of_primes(0) 0 >>> sum_of_primes(1000) 76127 >>> sum_of_primes(1000000) 37550402023","solution":"def sum_of_primes(n): Returns the sum of all prime numbers less than or equal to n. if n < 2: return 0 is_prime = [True] * (n + 1) is_prime[0] = is_prime[1] = False for i in range(2, int(n**0.5) + 1): if is_prime[i]: for j in range(i*i, n + 1, i): is_prime[j] = False prime_sum = 0 for i in range(2, n + 1): if is_prime[i]: prime_sum += i return prime_sum"},{"question":"def encrypt(plaintext: str, shift: int) -> str: Encrypt the given plaintext using the Circular Caesar Cipher method. Args: plaintext (str): The text to encrypt, consisting of lowercase letters and spaces. shift (int): The number of positions to shift each letter. Returns: str: The encrypted text. Example: >>> encrypt(\\"hello world\\", 3) 'khoor zruog' >>> encrypt(\\"abc xyz\\", 5) 'fgh cde' def decrypt(encrypted_text: str, shift: int) -> str: Decrypt the given encrypted text using the Circular Caesar Cipher method. Args: encrypted_text (str): The text to decrypt, consisting of lowercase letters and spaces. shift (int): The number of positions to shift each letter back. Returns: str: The decrypted text. Example: >>> decrypt(\\"khoor zruog\\", 3) 'hello world' >>> decrypt(\\"fgh cde\\", 5) 'abc xyz' def process_test_cases(t: int, test_cases: List[Tuple[int, str, str]]) -> List[Tuple[str, str]]: Process the given test cases to encrypt and decrypt texts using the Circular Caesar Cipher method. Args: t (int): The number of test cases. test_cases (List[Tuple[int, str, str]]): Each test case contains an integer shift value, a plaintext string, and an encrypted text string. Returns: List[Tuple[str, str]]: A list of tuples where each tuple contains the encrypted result of the plaintext and the decrypted result of the encrypted text. Example: >>> process_test_cases(2, [(3, \\"hello world\\", \\"khoor zruog\\"), (5, \\"abc xyz\\", \\"fgh cde\\")]) [('khoor zruog', 'hello world'), ('fgh cde', 'abc xyz')]","solution":"def encrypt(plaintext, shift): encrypted_text = [] for char in plaintext: if char == ' ': encrypted_text.append(' ') else: new_pos = (ord(char) - ord('a') + shift) % 26 new_char = chr(new_pos + ord('a')) encrypted_text.append(new_char) return ''.join(encrypted_text) def decrypt(encrypted_text, shift): decrypted_text = [] for char in encrypted_text: if char == ' ': decrypted_text.append(' ') else: new_pos = (ord(char) - ord('a') - shift) % 26 new_char = chr(new_pos + ord('a')) decrypted_text.append(new_char) return ''.join(decrypted_text) def process_test_cases(t, test_cases): results = [] for case in test_cases: s, plaintext, encrypted_text = case encrypted_res = encrypt(plaintext, s) decrypted_res = decrypt(encrypted_text, s) results.append((encrypted_res, decrypted_res)) return results"},{"question":"def final_position(n: int, commands: str) -> tuple: Returns the final position of the robot after executing the commands given. >>> final_position(5, \\"UUDLR\\") (0, 1) >>> final_position(3, \\"UUU\\") (0, 3) >>> final_position(4, \\"DDDD\\") (0, -4) >>> final_position(2, \\"LL\\") (-2, 0) >>> final_position(6, \\"RRRRRR\\") (6, 0) >>> final_position(10, \\"UUDDLRLRUU\\") (0, 2) >>> final_position(0, \\"\\") (0, 0)","solution":"def final_position(n, commands): Returns the final position of the robot after executing the commands given. Parameters: n (int): The number of commands commands (str): The string of commands Returns: tuple: The final (x, y) position of the robot x = 0 y = 0 move_map = { 'U': (0, 1), 'D': (0, -1), 'L': (-1, 0), 'R': (1, 0) } for command in commands: dx, dy = move_map[command] x += dx y += dy return (x, y)"},{"question":"def count_peaks(n: int, a: List[int]) -> int: Returns the number of peak elements in the array. >>> count_peaks(5, [1, 3, 2, 5, 4]) == 2 >>> count_peaks(3, [7, 7, 7]) == 3 >>> count_peaks(4, [4, 2, 1, 3]) == 2","solution":"def count_peaks(n, a): Returns the number of peak elements in the array. if n == 1: return 1 peaks = 0 for i in range(n): if i == 0: if a[i] >= a[i + 1]: peaks += 1 elif i == n - 1: if a[i] >= a[i - 1]: peaks += 1 else: if a[i] >= a[i - 1] and a[i] >= a[i + 1]: peaks += 1 return peaks"},{"question":"def max_non_overlapping_contests(contests): Returns the maximum number of non-overlapping contests. :param contests: List of tuples, each containing the start and end times of a contest (start_i, end_i) :return: Integer, maximum number of non-overlapping contests >>> max_non_overlapping_contests([(1, 3), (2, 5), (4, 6), (6, 7), (5, 8), (8, 9)]) == 4 >>> max_non_overlapping_contests([(1, 2), (2, 3), (3, 4), (4, 5)]) == 4 >>> max_non_overlapping_contests([(1, 2)]) == 1 >>> max_non_overlapping_contests([(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_contests([(1, 4), (2, 5), (3, 6)]) == 1 >>> max_non_overlapping_contests([(1, 4), (2, 6), (5, 8), (7, 9)]) == 2 >>> max_non_overlapping_contests([(1, 2), (1, 3), (1, 4), (2, 5), (3, 6)]) == 2","solution":"def max_non_overlapping_contests(contests): Returns the maximum number of non-overlapping contests. :param contests: List of tuples, each containing the start and end times of a contest (start_i, end_i) :return: Integer, maximum number of non-overlapping contests # Sort contests by their end times contests.sort(key=lambda x: x[1]) max_contests = 0 end_time = 0 for start, end in contests: if start >= end_time: max_contests += 1 end_time = end return max_contests"},{"question":"def convert_to_zorgian(n: int, keyboard_mapping: str, message: str) -> str: Converts a message from the Latin alphabet to the Zorgian alphabet using the custom keyboard layout. Parameters: - n (int): Number of letters in the Zorgian alphabet. - keyboard_mapping (str): A string of length n where each character represents the Zorgian letter mapped to the Latin alphabet. - message (str): The message to be converted. Returns: - str: The converted message in the Zorgian alphabet. Example: >>> convert_to_zorgian(5, 'fghij', 'abcde') 'fghij' >>> convert_to_zorgian(10, 'zxcvbnmasd', 'abcdefghij') 'zxcvbnmasd'","solution":"def convert_to_zorgian(n, keyboard_mapping, message): Converts a message from Latin alphabet to Zorgian alphabet using the custom keyboard layout. Parameters: - n (int): Number of letters in the Zorgian alphabet. - keyboard_mapping (str): A string of length n where each character represents the Zorgian letter mapped to the Latin alphabet. - message (str): The message to be converted. Returns: - str: The converted message in the Zorgian alphabet. # Create a mapping from Latin alphabet to Zorgian alphabet mapping = {chr(97 + i): keyboard_mapping[i] for i in range(n)} # Convert the message converted_message = ''.join(mapping[char] for char in message) return converted_message"},{"question":"def total_productive_time(tasks: List[Tuple[int, int]]) -> int: Compute the total productive time in hours for a series of tasks without counting overlapping times more than once. Args: tasks (List[Tuple[int, int]]): A list of tuples representing the start and end times of tasks, where 0 <= start < end <= 24. Returns: int: Total productive time in hours. Example: >>> total_productive_time([(1, 3), (2, 5), (6, 8)]) 5 >>> total_productive_time([(1, 2), (3, 4), (5, 6)]) 3 # Unit Tests from solution import total_productive_time def test_no_tasks(): assert total_productive_time([]) == 0 def test_non_overlapping_tasks(): assert total_productive_time([(1, 2), (3, 4), (5, 6)]) == 3 def test_fully_overlapping_tasks(): assert total_productive_time([(1, 5), (2, 6), (0, 4)]) == 6 def test_partially_overlapping_tasks(): assert total_productive_time([(1, 3), (2, 5), (4, 6)]) == 5 def test_edge_case_tasks(): assert total_productive_time([(0, 2), (2, 4), (4, 6)]) == 6 def test_mixed_tasks(): assert total_productive_time([(1, 3), (4, 6), (2, 5)]) == 5 def test_multiple_tasks_same_times(): assert total_productive_time([(2, 3), (2, 3), (2, 3)]) == 1 def test_task_spanning_midnight(): assert total_productive_time([(22, 24), (23, 24)]) == 2","solution":"from typing import List, Tuple def total_productive_time(tasks: List[Tuple[int, int]]) -> int: if not tasks: return 0 # Sort tasks based on the start times tasks.sort() total_time = 0 current_start, current_end = tasks[0] for start, end in tasks[1:]: if start > current_end: # no overlap total_time += current_end - current_start current_start, current_end = start, end else: # overlap current_end = max(current_end, end) total_time += current_end - current_start return total_time # Example usage tasks = [(1, 3), (2, 5), (6, 8)] print(total_productive_time(tasks)) # Output should be 5"},{"question":"def max_points_in_game(n: int, m: int, points: List[List[int]]) -> Tuple[int, int]: Find the maximum points a participant can achieve in any single game and the index of that game. If there are multiple games with the maximum score, return the index of the first such game. >>> max_points_in_game(4, 3, [ ... [10, 20, 30], ... [40, 15, 20], ... [25, 35, 10], ... [5, 10, 35] ... ]) == (40, 1) >>> max_points_in_game(3, 5, [ ... [5, 10, 20, 10, 5], ... [1, 2, 3, 4, 5], ... [20, 30, 10, 50, 60] ... ]) == (60, 5)","solution":"def max_points_in_game(n, m, points): max_points = -1 max_game_index = -1 for i in range(m): for j in range(n): if points[j][i] > max_points: max_points = points[j][i] max_game_index = i + 1 return max_points, max_game_index # Example usage: # n = 4 # m = 3 # points = [ # [10, 20, 30], # [40, 15, 20], # [25, 35, 10], # [5, 10, 35] # ] # print(max_points_in_game(n, m, points)) # Output should be (40, 1)"},{"question":"def generate_sequence(n: int, a0: int) -> List[int]: Generate a sequence of length n starting with a given number a0 using specific rules for even and odd indices. >>> generate_sequence(5, 97) [97, 2, 2, 2, 2] >>> generate_sequence(1, 15) [15]","solution":"def sum_of_digits(num): return sum(int(digit) for digit in str(num)) def smallest_prime_factor(n): if n <= 1: return n for i in range(2, int(n ** 0.5) + 1): if n % i == 0: return i return n def greatest_prime_factor(n): i = 2 max_prime = -1 while i * i <= n: while n % i == 0: max_prime = i n //= i i += 1 if n > 1: max_prime = n return max_prime def generate_sequence(n, a0): sequence = [a0] for i in range(1, n): prev_sum_digits = sum_of_digits(sequence[-1]) if i % 2 == 0: # even index next_value = greatest_prime_factor(prev_sum_digits) else: # odd index next_value = smallest_prime_factor(prev_sum_digits) sequence.append(next_value) return sequence"},{"question":"def max_meetings(n: int, meetings: List[Tuple[int, int]]) -> int: Determine the maximum number of non-conflicting meetings that can be held in the conference room. Parameters: n (int): the number of meetings. meetings (List[Tuple[int, int]]): the list of meetings with their start and end times. Returns: int: the maximum number of non-conflicting meetings. Examples: >>> max_meetings(3, [(1, 4), (2, 5), (6, 8)]) 2 >>> max_meetings(4, [(1, 2), (3, 4), (0, 6), (5, 7)]) 3","solution":"def max_meetings(n, meetings): # Sort meetings by their end times meetings.sort(key=lambda x: x[1]) # Initialize variables max_count = 0 last_end_time = 0 # Iterate through the meetings for start, end in meetings: if start >= last_end_time: max_count += 1 last_end_time = end return max_count"},{"question":"def longest_distinct_subarray(n: int, arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all distinct elements. Parameters: n (int): The number of elements in the sequence. arr (List[int]): The elements of the sequence. Returns: int: The length of the longest contiguous subarray with all distinct elements. Example: >>> longest_distinct_subarray(5, [1, 2, 1, 3, 4]) 4 >>> longest_distinct_subarray(7, [1, 2, 3, 4, 5, 6, 7]) 7 >>> longest_distinct_subarray(5, [1, 1, 1, 1, 1]) 1 pass","solution":"def longest_distinct_subarray(n, arr): Returns the length of the longest contiguous subarray with all distinct elements. # Dictionary to store the last positions of each element last_pos = {} start_idx = 0 max_len = 0 for i in range(n): if arr[i] in last_pos and last_pos[arr[i]] >= start_idx: start_idx = last_pos[arr[i]] + 1 last_pos[arr[i]] = i max_len = max(max_len, i - start_idx + 1) return max_len"},{"question":"def min_moves_to_equal_elements(n: int, quantities: List[int]) -> int: Determines the minimum number of moves required to make all quantities in the array equal. Parameters: n (int): Number of distinct products. quantities (list of int): Quantities of each product. Returns: int: Minimum number of moves required. >>> min_moves_to_equal_elements(3, [10, 10, 10]) 0 >>> min_moves_to_equal_elements(5, [1, 2, 3, 4, 5]) 6 >>> min_moves_to_equal_elements(4, [0, 0, 0, 0]) 0 >>> min_moves_to_equal_elements(1, [5]) 0 >>> min_moves_to_equal_elements(4, [0, 1000000, 500000, 500000]) 1000000 >>> min_moves_to_equal_elements(3, [3, 4, 5]) 2 >>> min_moves_to_equal_elements(3, [5, 4, 3]) 2","solution":"def min_moves_to_equal_elements(n, quantities): Determines the minimum number of moves required to make all quantities in the array equal. Parameters: n (int): Number of distinct products. quantities (list of int): Quantities of each product. Returns: int: Minimum number of moves required. # Sort the quantities quantities.sort() # Find the median median = quantities[n // 2] # Calculate the total number of moves moves = sum(abs(quantity - median) for quantity in quantities) return moves"},{"question":"def min_abs_difference_partition(n: int, array: List[int]) -> int: Given an array of integers, partition it into two non-overlapping subarrays such that the absolute difference between their sums is minimized. Returns the minimum possible absolute difference. Examples: >>> min_abs_difference_partition(4, [3, 1, 4, 2]) 0 >>> min_abs_difference_partition(5, [1, 2, 3, 4, 5]) 1 >>> min_abs_difference_partition(1, [10]) 10 >>> min_abs_difference_partition(2, [10, 12]) 2 >>> min_abs_difference_partition(3, [1, 1, 1000]) 998 >>> min_abs_difference_partition(3, [-2, -3, 4]) 1 >>> min_abs_difference_partition(6, [1, -1, 2, -2, 3, -3]) 0","solution":"def min_abs_difference_partition(n, array): Given an array of integers, partition it into two non-overlapping subarrays such that the absolute difference between their sums is minimized. Returns the minimum possible absolute difference. total_sum = sum(array) half_sum = total_sum / 2 dp = {0} for num in array: next_dp = dp.copy() for curr_sum in dp: new_sum = curr_sum + num next_dp.add(new_sum) dp = next_dp min_difference = float('inf') for s in dp: min_difference = min(min_difference, abs(total_sum - 2 * s)) return min_difference"},{"question":"def censor_comments(test_cases): Censor banned words in user comments by replacing them with asterisks of the same length. Args: test_cases (List[Dict[str, List[str]]]): List of test cases where each test case consists of 'banned_words' and 'comments'. Returns: List[List[str]]: The censored comments for each test case. Example: >>> test_cases = [{'banned_words': ['bad', 'word', 'evil'], 'comments': ['this is a bad comment', 'clean comment here', 'what an evil word']}] >>> censor_comments(test_cases) [['this is a *** comment', 'clean comment here', 'what an **** ****']] >>> test_cases = [{'banned_words': ['apple', 'pie'], 'comments': ['I love apple pie', 'this pie is great']}] >>> censor_comments(test_cases) [['I love ***** ***', 'this *** is great']] pass","solution":"def censor_comments(test_cases): results = [] for case in test_cases: banned_words = case['banned_words'] comments = case['comments'] censored_comments = [] for comment in comments: for banned_word in banned_words: comment = comment.replace(banned_word, '*' * len(banned_word)) censored_comments.append(comment) results.append(censored_comments) return results"},{"question":"from typing import List def min_steps_to_dest(n: int, grid: List[str], sx: int, sy: int, dx: int, dy: int) -> int: Returns the minimum number of steps to go from (sx, sy) to (dx, dy) in a grid. If the destination is unreachable, returns -1. >>> min_steps_to_dest(5, [\\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"], 0, 0, 4, 4) 8 >>> min_steps_to_dest(5, [\\".....\\", \\".#...\\", \\".....\\", \\"...#.\\", \\".....\\"], 0, 0, 3, 3) -1 >>> min_steps_to_dest(3, [\\"#\\", \\"#.#\\", \\"#\\"], 1, 1, 0, 0) -1 >>> min_steps_to_dest(3, [\\"..#\\", \\"#.#\\", \\"...\\"], 0, 0, 2, 2) 4 >>> min_steps_to_dest(2, [\\"..\\", \\"..\\"], 0, 0, 1, 1) 2 >>> min_steps_to_dest(1, [\\".\\"], 0, 0, 0, 0) 0","solution":"from collections import deque def min_steps_to_dest(n, grid, sx, sy, dx, dy): Returns the minimum number of steps to go from (sx, sy) to (dx, dy) in a grid. If the destination is unreachable, returns -1. if grid[sx][sy] == '#' or grid[dx][dy] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False] * n for _ in range(n)] queue = deque([(sx, sy, 0)]) visited[sx][sy] = True while queue: x, y, steps = queue.popleft() if x == dx and y == dy: return steps for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < n and 0 <= ny < n and grid[nx][ny] == '.' and not visited[nx][ny]: queue.append((nx, ny, steps + 1)) visited[nx][ny] = True return -1"},{"question":"def max_craftable_items(n: int, items: List[Tuple[int, int]]) -> int: Determine the maximum number of different items that a player can craft with an unlimited number of each type of ingredient. :param n: Integer, number of items. :param items: List of tuples, where each tuple contains two integers - item id and number of ingredients required. :return: Integer, the maximum number of different items that can be crafted. >>> max_craftable_items(4, [(1, 3), (2, 5), (3, 2), (4, 2)]) 4 >>> max_craftable_items(3, [(1, 1), (2, 2), (3, 3)]) 3 from solution import max_craftable_items def test_example_1(): n = 4 items = [(1, 3), (2, 5), (3, 2), (4, 2)] assert max_craftable_items(n, items) == 4 def test_example_2(): n = 3 items = [(1, 1), (2, 2), (3, 3)] assert max_craftable_items(n, items) == 3 def test_single_item(): n = 1 items = [(1, 1)] assert max_craftable_items(n, items) == 1 def test_multiple_items_same_ingredients(): n = 5 items = [(1, 2), (2, 2), (3, 2), (4, 2), (5, 2)] assert max_craftable_items(n, items) == 5","solution":"def max_craftable_items(n, items): Determine the maximum number of different items that a player can craft with an unlimited number of each type of ingredient. :param n: Integer, number of items. :param items: List of tuples, where each tuple contains two integers - item id and number of ingredients required. :return: Integer, the maximum number of different items that can be crafted. return n"},{"question":"def max_happiness_reduction(datasets): Given a list of datasets where each dataset contains initial happiness scores and reduction values for neighborhoods, calculate the max possible reduction in total happiness for each dataset. def parse_input(input_str): Parse the input string into datasets. # Add test cases to validate the solution def test_max_happiness_reduction(): input_data = 3 1000 200 900 150 1100 300 2 800 100 750 120 0 datasets = parse_input(input_data) results = max_happiness_reduction(datasets) assert results == [650, 220] def test_empty_input(): input_data = \\"0\\" datasets = parse_input(input_data) results = max_happiness_reduction(datasets) assert results == [] def test_single_neighborhood(): input_data = 1 1000 500 0 datasets = parse_input(input_data) results = max_happiness_reduction(datasets) assert results == [500] def test_multiple_datasets(): input_data = 2 500 200 600 300 4 100 50 200 25 300 75 400 20 0 datasets = parse_input(input_data) results = max_happiness_reduction(datasets) assert results == [500, 170]","solution":"def max_happiness_reduction(datasets): Given a list of datasets where each dataset contains initial happiness scores and reduction values for neighborhoods, calculate the max possible reduction in total happiness for each dataset. results = [] for data in datasets: max_reduction = 0 for H, R in data: max_reduction += R results.append(max_reduction) return results def parse_input(input_str): Parse the input string into datasets. lines = input_str.strip().split(\\"n\\") datasets = [] i = 0 while i < len(lines): N = int(lines[i]) if N == 0: break i += 1 dataset = [] for _ in range(N): H, R = map(int, lines[i].split()) i += 1 dataset.append((H, R)) datasets.append(dataset) return datasets"},{"question":"def count_substrings_with_one_distinct_letter(S: str) -> int: Counts the number of substrings with at most one distinct letter. >>> count_substrings_with_one_distinct_letter(\\"aaa\\") 6 >>> count_substrings_with_one_distinct_letter(\\"abc\\") 3 def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Processes multiple test cases and returns results for each. >>> process_test_cases(2, [\\"aaa\\", \\"abc\\"]) [6, 3] >>> process_test_cases(3, [\\"a\\", \\"bb\\", \\"ccc\\"]) [1, 3, 6]","solution":"def count_substrings_with_one_distinct_letter(S): Counts the number of substrings with at most one distinct letter. count = 0 n = len(S) i = 0 while i < n: j = i while j < n and S[j] == S[i]: j += 1 length = j - i count += (length * (length + 1)) // 2 i = j return count def process_test_cases(T, test_cases): results = [] for case in test_cases: results.append(count_substrings_with_one_distinct_letter(case)) return results"},{"question":"def find_smallest_rooms(n, room_capacities, m, event_capacities): Function to find the smallest room that can accommodate each event. Arguments: - n: number of rooms (int) - room_capacities: list of room capacities (list of int) - m: number of events (int) - event_capacities: list of event seating requirements (list of int) Returns: - list of int: smallest room capacity for each event or -1 if no room can accommodate the event >>> find_smallest_rooms(6, [50, 100, 200, 300, 400, 500], 4, [150, 100, 350, 50]) [200, 100, 400, 50] >>> find_smallest_rooms(5, [50, 75, 100, 150, 200], 3, [90, 110, 250]) [100, 150, -1] >>> find_smallest_rooms(3, [10, 20, 30], 3, [25, 5, 10]) [30, 10, 10] >>> find_smallest_rooms(1, [100], 1, [100]) [100] >>> find_smallest_rooms(5, [5, 9, 20, 30, 40], 5, [10, 8, 25, 1, 100]) [20, 9, 30, 5, -1]","solution":"from bisect import bisect_left def find_smallest_rooms(n, room_capacities, m, event_capacities): Function to find the smallest room that can accommodate each event. Arguments: - n: number of rooms (int) - room_capacities: list of room capacities (list of int) - m: number of events (int) - event_capacities: list of event seating requirements (list of int) Returns: - list of int: smallest room capacity for each event or -1 if no room can accommodate the event room_capacities.sort() result = [] for event in event_capacities: # Find the index of the smallest room that can accommodate the event index = bisect_left(room_capacities, event) if index == len(room_capacities): result.append(-1) else: result.append(room_capacities[index]) return result"},{"question":"def max_profit(n: int, prices: List[int]) -> int: Determine the maximum possible profit from a single transaction of buying and selling the stock. :param n: An integer representing the number of days. :param prices: A list of integers representing the daily closing prices of the stock. :return: An integer representing the maximum possible profit. If no profit can be made, return 0. >>> max_profit(6, [7, 1, 5, 3, 6, 4]) 5 >>> max_profit(5, [7, 6, 4, 3, 1]) 0","solution":"def max_profit(n, prices): if n < 2: return 0 min_price = float('inf') max_profit = 0 for price in prices: if price < min_price: min_price = price elif price - min_price > max_profit: max_profit = price - min_price return max_profit"},{"question":"from typing import List, Tuple def track_donations(donations: List[Tuple[str, int]]) -> Tuple[int, str]: Returns the total amount of donations and the name of the highest individual donor. Parameters: donations (list of tuples): A list where each element is a tuple containing a string (donor's name) and an integer (amount donated). Returns: tuple: (total_amount, highest_donor_name) >>> track_donations([(\\"Alice\\", 50)]) == (50, \\"Alice\\") >>> track_donations([(\\"Alice\\", 50), (\\"Bob\\", 75), (\\"Charlie\\", 75), (\\"Dave\\", 40)]) == (240, \\"Bob\\") >>> track_donations([]) == (0, \\"\\") >>> track_donations([(\\"Alice\\", 100), (\\"Bob\\", 100), (\\"Charlie\\", 50)]) == (250, \\"Alice\\") >>> track_donations([(\\"Alice\\", 20), (\\"Bob\\", 30), (\\"Charlie\\", 10), (\\"Dave\\", 40)]) == (100, \\"Dave\\") >>> track_donations([(\\"Alice\\", 50), (\\"Bob\\", 50), (\\"Charlie\\", 50), (\\"Dave\\", 50)]) == (200, \\"Alice\\")","solution":"def track_donations(donations): Returns the total amount of donations and the name of the highest individual donor. Parameters: donations (list of tuples): A list where each element is a tuple containing a string (donor's name) and an integer (amount donated). Returns: tuple: (total_amount, highest_donor_name) if not donations: return (0, \\"\\") total_amount = 0 highest_donor_name = \\"\\" highest_donation = 0 for donor, amount in donations: total_amount += amount if amount > highest_donation: highest_donation = amount highest_donor_name = donor return (total_amount, highest_donor_name)"},{"question":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: Finds all pairs of elements in a list that sum up to a given target number. The elements within each pair should be listed in ascending order, and the pairs themselves should be listed in ascending order based on the first element. >>> find_pairs_with_sum([1, 5, 3, 7, 9], 10) [(1, 9), (3, 7)] >>> find_pairs_with_sum([2, 4, 6, 3, 5, 7, 8], 10) [(2, 8), (3, 7), (4, 6)] >>> find_pairs_with_sum([1, 2, 3], 10) [] >>> find_pairs_with_sum([1, 1, 2, 2, 3, 3, 4, 4], 5) [(1, 4), (2, 3)] >>> find_pairs_with_sum([2, -2, 1, -1, 3, -3, 4, -4], 0) [(-4, 4), (-3, 3), (-2, 2), (-1, 1)] >>> find_pairs_with_sum([5], 5) [] >>> find_pairs_with_sum([], 5) []","solution":"from typing import List, Tuple def find_pairs_with_sum(arr: List[int], target: int) -> List[Tuple[int, int]]: seen = set() pairs = set() for number in arr: complement = target - number if complement in seen: pairs.add(tuple(sorted((number, complement)))) seen.add(number) return sorted(pairs)"},{"question":"def max_continuous_hours(N: int, battery_usage_rates: List[int], current_battery_percentage: int) -> int: Determines the maximum number of continuous hours the phone can last. Parameters: N (int): Number of apps. battery_usage_rates (List[int]): List of battery usage rates for each app. current_battery_percentage (int): Current battery percentage of the phone. Returns: int: Maximum continuous hours the phone can last. >>> max_continuous_hours(3, [20, 5, 10], 50) 10 >>> max_continuous_hours(1, [5], 50) 10 >>> max_continuous_hours(1, [10], 100) 10 >>> max_continuous_hours(4, [25, 10, 5, 20], 100) 20 >>> max_continuous_hours(4, [25, 10, 5, 20], 5) 1 >>> max_continuous_hours(100, [100]*100, 100) 1 >>> max_continuous_hours(1, [1], 1) 1","solution":"def max_continuous_hours(N, battery_usage_rates, current_battery_percentage): Determines the maximum number of continuous hours the phone can last. Parameters: N (int): Number of apps. battery_usage_rates (List[int]): List of battery usage rates for each app. current_battery_percentage (int): Current battery percentage of the phone. Returns: int: Maximum continuous hours the phone can last. min_battery_usage_rate = min(battery_usage_rates) return current_battery_percentage // min_battery_usage_rate"},{"question":"def longest_consecutive_sequence(arr: List[int]) -> int: Given an array of integers, find the longest sequence of consecutive integers and return its length. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([10, 30, 20, 40]) 1 >>> longest_consecutive_sequence([-1, -2, -3, -4, -5, -6]) 6 >>> longest_consecutive_sequence([-1, 0, 1, 2, 3, -2, -3, 4]) 8 >>> longest_consecutive_sequence([1, 2, 2, 3, 4, 4, 5]) 5 >>> longest_consecutive_sequence([100000, 99999, 99998, 99997, 100001]) 5","solution":"def longest_consecutive_sequence(arr): Returns the length of the longest sequence of consecutive integers in the array. num_set = set(arr) longest_streak = 0 for num in num_set: if num - 1 not in num_set: current_num = num current_streak = 1 while current_num + 1 in num_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak"},{"question":"def count_paths(n: int, m: int, grid: List[str]) -> int: Returns the number of unique paths from the top-left to the bottom-right corner of the grid, avoiding obstacles. >>> count_paths(3, 3, [\\"000\\", \\"010\\", \\"000\\"]) 2 >>> count_paths(2, 2, [\\"01\\", \\"00\\"]) 1 >>> count_paths(3, 3, [\\"011\\", \\"110\\", \\"000\\"]) 0 >>> count_paths(3, 3, [\\"011\\", \\"110\\", \\"000\\"]) 0 n = len(grid) m = len(grid[0]) # Special case for a 1x1 grid with no obstacle. if n == 1 and m == 1: return 1 if grid[0][0] == '0' else 0 # Create a 2D dp array to store the number of ways to reach each cell. dp = [[0] * m for _ in range(n)] # Initialize the starting point. dp[0][0] = 1 if grid[0][0] == '0' else 0 # Fill the dp array. for i in range(n): for j in range(m): if grid[i][j] == '1': dp[i][j] = 0 # No path through an obstacle else: if i > 0: dp[i][j] += dp[i - 1][j] # Paths from the top if j > 0: dp[i][j] += dp[i][j - 1] # Paths from the left # The result is the value at the bottom-right corner of the grid. return dp[-1][-1] # Demonstrate the count_paths if __name__ == \\"__main__\\": n, m = map(int, input().split()) grid = [] for _ in range(n): grid.append(input().strip()) print(count_paths(n, m, grid))","solution":"def unique_paths_with_obstacles(grid): Returns the number of unique paths from the top-left to the bottom-right corner of the grid, avoiding obstacles. n = len(grid) m = len(grid[0]) # Special case for a 1x1 grid with no obstacle. if n == 1 and m == 1: return 1 if grid[0][0] == '0' else 0 # Create a 2D dp array to store the number of ways to reach each cell. dp = [[0] * m for _ in range(n)] # Initialize the starting point. dp[0][0] = 1 if grid[0][0] == '0' else 0 # Fill the dp array. for i in range(n): for j in range(m): if grid[i][j] == '1': dp[i][j] = 0 # No path through an obstacle else: if i > 0: dp[i][j] += dp[i - 1][j] # Paths from the top if j > 0: dp[i][j] += dp[i][j - 1] # Paths from the left # The result is the value at the bottom-right corner of the grid. return dp[-1][-1] # Helper function to parse input and call the main function def count_paths(n, m, lines): grid = [list(line.strip()) for line in lines] return unique_paths_with_obstacles(grid)"},{"question":"from typing import List, Tuple def minimum_tiles_to_cover_field(T: int, dimensions: List[Tuple[int, int]]) -> List[int]: import math Determine the minimum number of tiles required to cover the entire field without cutting any tiles. >>> minimum_tiles_to_cover_field(2, [(6, 4), (7, 5)]) [6, 35] >>> minimum_tiles_to_cover_field(1, [(100000, 50000)]) [2] >>> minimum_tiles_to_cover_field(1, [(5, 5)]) [1] >>> minimum_tiles_to_cover_field(1, [(100, 100)]) [1] >>> minimum_tiles_to_cover_field(1, [(13, 7)]) [91] >>> minimum_tiles_to_cover_field(1, [(1, 1000000)]) [1000000] >>> minimum_tiles_to_cover_field(1, [(1000000, 1)]) [1000000]","solution":"import math def minimum_tiles_to_cover_field(T, dimensions): results = [] for dimensions in dimensions: M, N = dimensions k = math.gcd(M, N) # Find the largest possible square tile size min_tiles = (M // k) * (N // k) results.append(min_tiles) return results"},{"question":"from collections import defaultdict from typing import List, Tuple def has_circular_dependency(n: int, m: int, includes: List[Tuple[int, int]]) -> str: Determine if there exists a circular dependency between files based on 'Include' statements. Args: n (int): Number of files. m (int): Number of 'Include' statements. includes (List[Tuple[int, int]]): List of 'Include' statements represented as (ai, bi) pairs where ai includes bi. Returns: str: \\"YES\\" if there exists a circular dependency, otherwise \\"NO\\". Examples: >>> has_circular_dependency(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> has_circular_dependency(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\" def test_has_circular_dependency_case1(): n = 4 m = 4 includes = [(1, 2), (2, 3), (3, 4), (4, 1)] assert has_circular_dependency(n, m, includes) == \\"YES\\" def test_has_circular_dependency_case2(): n = 4 m = 3 includes = [(1, 2), (2, 3), (3, 4)] assert has_circular_dependency(n, m, includes) == \\"NO\\" def test_has_circular_dependency_case3(): n = 5 m = 5 includes = [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)] assert has_circular_dependency(n, m, includes) == \\"YES\\" def test_has_circular_dependency_case4(): n = 6 m = 6 includes = [(1, 2), (2, 3), (4, 5), (5, 6), (6, 4), (3, 1)] assert has_circular_dependency(n, m, includes) == \\"YES\\" def test_has_circular_dependency_case5(): n = 3 m = 2 includes = [(1, 2), (2, 3)] assert has_circular_dependency(n, m, includes) == \\"NO\\" def test_has_circular_dependency_case6(): n = 1 m = 0 includes = [] assert has_circular_dependency(n, m, includes) == \\"NO\\" # Here we add a testing framework to execute our tests. # Use pytest to execute: pytest -v test_solution.py","solution":"from collections import defaultdict def has_circular_dependency(n, m, includes): graph = defaultdict(list) for a, b in includes: graph[a].append(b) # Depth First Search to detect cycles def dfs(node, visited, stack): visited.add(node) stack.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, visited, stack): return True elif neighbor in stack: return True stack.remove(node) return False visited = set() for i in range(1, n + 1): if i not in visited: if dfs(i, visited, set()): return \\"YES\\" return \\"NO\\""},{"question":"def min_operations_to_unify(s: str) -> int: Returns the smallest number of operations required to make all the letters in the string the same. An operation consists of choosing any two adjacent letters and changing one of them to match the other. >>> min_operations_to_unify(\\"abba\\") 1 >>> min_operations_to_unify(\\"bbba\\") 1 >>> min_operations_to_unify(\\"ababab\\") 3 >>> min_operations_to_unify(\\"aaaa\\") 0 >>> min_operations_to_unify(\\"bbbb\\") 0 >>> min_operations_to_unify(\\"a\\") 0 >>> min_operations_to_unify(\\"b\\") 0 >>> min_operations_to_unify(\\"abababababab\\") 6","solution":"def min_operations_to_unify(s): Returns the smallest number of operations required to make all the letters in the string the same. An operation consists of choosing any two adjacent letters and changing one of them to match the other. if not s: return 0 operations = 0 for i in range(1, len(s)): if s[i] != s[i - 1]: operations += 1 return (operations + 1) // 2"},{"question":"def check_string(input_string: str) -> str: Returns \\"YES\\" if the uppercase letter is a vowel and the rest of the string consists of only lowercase vowels, otherwise returns \\"NO\\". >>> check_string(\\"Aaeeiou\\") == \\"YES\\" >>> check_string(\\"Aeioxyz\\") == \\"NO\\" >>> check_string(\\"Baaeeio\\") == \\"NO\\" >>> check_string(\\"Eeeioua\\") == \\"YES\\"","solution":"def check_string(input_string): Returns \\"YES\\" if the uppercase letter is a vowel and the rest of the string consists of only lowercase vowels, otherwise returns \\"NO\\". vowels = {'A', 'E', 'I', 'O', 'U'} lowercase_vowels = {'a', 'e', 'i', 'o', 'u'} if len(input_string) != 7: return \\"NO\\" upper_case_letter = input_string[0] rest_of_string = input_string[1:] if upper_case_letter in vowels and all(char in lowercase_vowels for char in rest_of_string): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def analyze_weather(records: List[str]) -> Tuple[int, int, float]: Analyze weather records to identify trends. Arguments: records -- A list of strings, where each string contains a day of the month, a temperature in Celsius, and a boolean value indicating if it was sunny. Returns: A tuple containing: - The total number of sunny days. - The highest temperature recorded. - The average temperature of sunny days, or 0 if there are no sunny days. Example: >>> records = [\\"1,22,True\\", \\"2,25,False\\", \\"3,18,True\\", \\"4,30,False\\", \\"1,20,True\\"] >>> analyze_weather(records) (3, 30, 20.0) pass def test_analyze_weather_basic(): records = [\\"1,22,True\\", \\"2,25,False\\", \\"3,18,True\\", \\"4,30,False\\", \\"1,20,True\\"] assert analyze_weather(records) == (3, 30, 20.0) def test_analyze_weather_no_sunny_days(): records = [\\"1,22,False\\", \\"2,25,False\\", \\"3,18,False\\"] assert analyze_weather(records) == (0, 25, 0) def test_analyze_weather_single_record(): records = [\\"1,22,True\\"] assert analyze_weather(records) == (1, 22, 22.0) def test_analyze_weather_duplicates(): records = [\\"1,22,True\\", \\"1,22,True\\"] assert analyze_weather(records) == (2, 22, 22.0) def test_analyze_weather_mixed_temperatures(): records = [\\"1,22,True\\", \\"2,-10,False\\", \\"3,50,True\\", \\"4,0,True\\", \\"5,8,False\\"] assert analyze_weather(records) == (3, 50, 24.0)","solution":"from typing import List, Tuple def analyze_weather(records: List[str]) -> Tuple[int, int, float]: total_sunny_days = 0 highest_temperature = float('-inf') sunny_temps = [] for record in records: day, temp, is_sunny = record.split(',') temp = int(temp) is_sunny = is_sunny == 'True' # Record the highest temperature if temp > highest_temperature: highest_temperature = temp # Count sunny days and store sunny temperatures if is_sunny: total_sunny_days += 1 sunny_temps.append(temp) # Calculate the average temperature of sunny days if sunny_temps: avg_sunny_temp = sum(sunny_temps) / len(sunny_temps) else: avg_sunny_temp = 0 return total_sunny_days, highest_temperature, round(avg_sunny_temp, 1)"},{"question":"from typing import List from itertools import combinations def count_ways_to_arrange_books(n: int, m: int, book_numbers: List[int]) -> int: Counts the number of ways to choose and arrange m books in ascending order from n books. >>> count_ways_to_arrange_books(6, 4, [2, 5, 19, 7, 11, 23]) 15 >>> count_ways_to_arrange_books(5, 3, [9, 3, 15, 1, 8]) 10 return len(list(combinations(book_numbers, m))) def process_datasets(datasets: List[List[int]]) -> List[int]: Processes multiple datasets and returns the number of ways to arrange books for each dataset. >>> datasets = [[6, 4, [2, 5, 19, 7, 11, 23]], [5, 3, [9, 3, 15, 1, 8]], [0, 0]] >>> process_datasets(datasets) [15, 10] results = [] for dataset in datasets: n = dataset[0] m = dataset[1] book_numbers = dataset[2:] if n == 0 and m == 0: break results.append(count_ways_to_arrange_books(n, m, book_numbers)) return results # Example usage datasets = [ [6, 4, 2, 5, 19, 7, 11, 23], [5, 3, 9, 3, 15, 1, 8], [0, 0] ] print(process_datasets(datasets))","solution":"from itertools import combinations def count_ways_to_arrange_books(n, m, book_numbers): Counts the number of ways to choose and arrange m books in ascending order from n books. return len(list(combinations(book_numbers, m))) def process_datasets(datasets): Processes multiple datasets and returns the number of ways to arrange books for each dataset. results = [] for dataset in datasets: n = dataset[0] m = dataset[1] book_numbers = dataset[2:] if n == 0 and m == 0: break results.append(count_ways_to_arrange_books(n, m, book_numbers)) return results # Example usage datasets = [ [6, 4, 2, 5, 19, 7, 11, 23], [5, 3, 9, 3, 15, 1, 8], [0, 0] ] print(process_datasets(datasets))"},{"question":"def find_last_child(N: int, M: int) -> int: Finds the number of the child who will receive the last sweet. >>> find_last_child(5, 2) 2 >>> find_last_child(7, 19) 5 >>> find_last_child(3, 6) 3 pass def last_sweets(T: int, cases: List[Tuple[int, int]]) -> List[int]: Processes multiple test cases for finding the last child who receives the sweet. >>> last_sweets(3, [(5, 2), (7, 19), (3, 6)]) [2, 5, 3] >>> last_sweets(1, [(1, 10)]) [1] >>> last_sweets(1, [(10**18, 10**18)]) [10**18] >>> last_sweets(4, [(8, 5), (6, 19), (10, 25), (10, 10)]) [5, 1, 5, 10] >>> last_sweets(2, [(4, 10), (5, 10)]) [2, 5] pass","solution":"def find_last_child(N, M): Finds the number of the child who will receive the last sweet. Parameters: N (int): The number of children in the circle. M (int): The number of sweets to distribute. Returns: int: The number of the child who will receive the last sweet. # The child who receives the last sweet can be found by (M - 1) % N + 1 return (M - 1) % N + 1 def last_sweets(T, cases): Processes multiple test cases for finding the last child who receives the sweet. Parameters: T (int): The number of test cases. cases (list of tuples): Each tuple contains two integers N and M. Returns: list of int: The results for each test case. results = [] for N, M in cases: results.append(find_last_child(N, M)) return results"},{"question":"def maximum_enjoyment_from_string(input_str: str) -> int: Given a string input describing the number of museums, paths, enjoyment values for each museum, and paths between museums, determine the maximum total enjoyment Alice can achieve. >>> input_str = \\"4 3n10 20 30 40n0 1n1 2n2 3\\" >>> maximum_enjoyment_from_string(input_str) 100 >>> input_str = \\"5 6n1 2 3 4 5n0 1n0 2n1 3n2 3n3 4n1 4\\" >>> maximum_enjoyment_from_string(input_str) 15 >>> input_str = \\"3 2n7 8 9n0 1n1 2\\" >>> maximum_enjoyment_from_string(input_str) 24","solution":"def maximum_enjoyment(n, m, enjoyment_values, paths): from collections import defaultdict from itertools import permutations def dfs(start, graph, visited): stack = [start] total_enjoyment = 0 while stack: node = stack.pop() if node not in visited: visited.add(node) total_enjoyment += enjoyment_values[node] for neighbor in graph[node]: if neighbor not in visited: stack.append(neighbor) return total_enjoyment graph = defaultdict(list) for a, b in paths: graph[a].append(b) graph[b].append(a) max_enjoyment = 0 for start in range(n): visited = set() max_enjoyment = max(max_enjoyment, dfs(start, graph, visited)) return max_enjoyment # Helper function to parse input strings def parse_input(input_str): lines = input_str.strip().split('n') n, m = map(int, lines[0].split()) enjoyment_values = list(map(int, lines[1].split())) paths = [tuple(map(int, line.split())) for line in lines[2:]] return n, m, enjoyment_values, paths # Adding a function to process string inputs for testing def maximum_enjoyment_from_string(input_str): n, m, enjoyment_values, paths = parse_input(input_str) return maximum_enjoyment(n, m, enjoyment_values, paths)"},{"question":"from typing import List, Tuple def is_spanning_tree_possible(n: int, m: int, bridges: List[Tuple[int, int]]) -> str: Determine if it's possible to connect all cities using the given bridges forming a spanning tree without cycles. Args: n : int : Number of cities m : int : Number of allowed bridges bridges : List[Tuple[int, int]] : Each tuple represents an allowed bridge between two cities Returns: str : \\"Yes\\" or \\"No\\" whether it's possible or not Example: >>> is_spanning_tree_possible(3, 3, [(1, 2), (2, 3), (3, 1)]) 'No' >>> is_spanning_tree_possible(4, 3, [(1, 2), (2, 3), (3, 4)]) 'Yes' pass def solve(T: int, scenarios: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[str]: Solve the multiple scenarios of the spanning tree problem. Args: T : int : Number of scenarios scenarios : List[Tuple[int, int, List[Tuple[int, int]]]] : List of scenarios, each consisting of (number of cities, number of bridges, list of bridges) Returns: List[str] : List of \\"Yes\\" or \\"No\\" for each scenario pass # Example usage: T = 3 scenarios = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) ] print(solve(T, scenarios)) # Output should be ['No', 'Yes', 'No']","solution":"def is_spanning_tree_possible(n, m, bridges): from collections import defaultdict, deque if m != n - 1: return \\"No\\" graph = defaultdict(list) for u, v in bridges: graph[u].append(v) graph[v].append(u) visited = set() def bfs(start): queue = deque([start]) visited.add(start) while queue: node = queue.popleft() for neighbor in graph[node]: if neighbor not in visited: visited.add(neighbor) queue.append(neighbor) bfs(1) return \\"Yes\\" if len(visited) == n else \\"No\\" def solve(T, scenarios): results = [] for scenario in scenarios: n, m, bridges = scenario results.append(is_spanning_tree_possible(n, m, bridges)) return results # Example usage: T = 3 scenarios = [ (3, 3, [(1, 2), (2, 3), (3, 1)]), (4, 3, [(1, 2), (2, 3), (3, 4)]), (4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) ] print(solve(T, scenarios)) # Output should be ['No', 'Yes', 'No']"},{"question":"def allocate_tables(N, M, table_sizes, R, booking_requests): Allocates tables based on booking requests. Parameters: N: int : Maximum number of guests for any table M: int : Number of tables table_sizes: list of int : Sizes of each table R: int : Number of booking requests booking_requests: list of tuples : Each tuple contains number of guests and time slot Returns: list of int : Indices of allocated tables or -1 if booking is rejected >>> N = 5 >>> M = 3 >>> table_sizes = [2, 4, 6] >>> R = 4 >>> booking_requests = [(5, 12), (3, 12), (2, 12), (6, 13)] >>> allocate_tables(N, M, table_sizes, R, booking_requests) [2, 1, 0, 2] >>> N = 5 >>> M = 1 >>> table_sizes = [5] >>> R = 3 >>> booking_requests = [(5, 12), (4, 12), (5, 13)] >>> allocate_tables(N, M, table_sizes, R, booking_requests) [0, -1, 0] >>> N = 5 >>> M = 2 >>> table_sizes = [3, 4] >>> R = 3 >>> booking_requests = [(5, 12), (3, 14), (4, 14)] >>> allocate_tables(N, M, table_sizes, R, booking_requests) [-1, 0, 1] >>> N = 5 >>> M = 2 >>> table_sizes = [3, 3] >>> R = 3 >>> booking_requests = [(3, 12), (3, 12), (3, 13)] >>> allocate_tables(N, M, table_sizes, R, booking_requests) [0, 1, 0] >>> N = 5 >>> M = 2 >>> table_sizes = [3, 4] >>> R = 3 >>> booking_requests = [(3, 0), (4, 0), (2, 0)] >>> allocate_tables(N, M, table_sizes, R, booking_requests) [0, 1, -1]","solution":"def allocate_tables(N, M, table_sizes, R, booking_requests): Allocates tables based on booking requests. Parameters: N: int : Maximum number of guests for any table M: int : Number of tables table_sizes: list of int : Sizes of each table R: int : Number of booking requests booking_requests: list of tuples : Each tuple contains number of guests and time slot Returns: list of int : Indices of allocated tables or -1 if booking is rejected table_availability = [{} for _ in range(M)] results = [] for guests, time_slot in booking_requests: allocated = False for idx in range(M): if table_sizes[idx] >= guests and time_slot not in table_availability[idx]: table_availability[idx][time_slot] = True results.append(idx) allocated = True break if not allocated: results.append(-1) return results # Example usage N = 5 M = 3 table_sizes = [2, 4, 6] R = 4 booking_requests = [ (5, 12), (3, 12), (2, 12), (6, 13), ] print(allocate_tables(N, M, table_sizes, R, booking_requests)) # should return [2, 1, 0, 2]"},{"question":"def can_be_palindrome_by_one_reverse(N: int, S: str) -> str: Determines whether it is possible to make the string S a palindrome by reversing exactly one contiguous substring of S. >>> can_be_palindrome_by_one_reverse(4, '1234') 'No' >>> can_be_palindrome_by_one_reverse(5, '12321') 'Yes' >>> can_be_palindrome_by_one_reverse(6, '123321') 'Yes' >>> can_be_palindrome_by_one_reverse(3, '121') 'Yes'","solution":"def can_be_palindrome_by_one_reverse(N, S): Determines whether it is possible to make the string S a palindrome by reversing exactly one contiguous substring of S. if S == S[::-1]: return \\"Yes\\" for i in range(N): for j in range(i+1, N+1): new_S = S[:i] + S[i:j][::-1] + S[j:] if new_S == new_S[::-1]: return \\"Yes\\" return \\"No\\""},{"question":"def find_average_after_removal(n: int, num_list: List[int]) -> Union[float, str]: Given a list of integers, find and remove the smallest and largest integers from the list, and then return the average of the remaining integers. If all integers in the list are the same, return \\"All elements are the same\\". If the list has fewer than 3 integers, return \\"Not enough numbers\\". >>> find_average_after_removal(5, [4, 1, 7, 2, 6]) 4.0 >>> find_average_after_removal(3, [2, 2, 2]) 'All elements are the same' >>> find_average_after_removal(2, [1, 2]) 'Not enough numbers' >>> find_average_after_removal(4, [3, 1, 2, 2]) 2.0","solution":"def find_average_after_removal(n, num_list): if n < 3: return \\"Not enough numbers\\" if all(x == num_list[0] for x in num_list): return \\"All elements are the same\\" smallest = min(num_list) largest = max(num_list) num_list.remove(smallest) num_list.remove(largest) if not num_list: return \\"Not enough numbers\\" return sum(num_list) / len(num_list) # Example Usage: # n = 5 # num_list = [4, 1, 7, 2, 6] # result = find_average_after_removal(n, num_list) # print(result) # Expected Output: 4.0"},{"question":"import sys from typing import List, Tuple MOD = 1000000007 def count_valid_sequences(N: int, prerequisites: List[Tuple[int, int]]) -> int: Compute the number of valid sequences in which all tasks can be executed while respecting the prerequisite constraints. pass def solve(test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[int]: Solve the problem for multiple test cases. pass def test_count_valid_sequences(): assert count_valid_sequences(3, [(1, 2), (2, 3)]) == 1 assert count_valid_sequences(3, []) == 6 assert count_valid_sequences(4, [(1, 2), (1, 3), (3, 4)]) == 3 assert count_valid_sequences(4, [(1, 2), (1, 3), (3, 4), (2, 4)]) == 2 assert count_valid_sequences(2, [(1, 2), (2, 1)]) == 0 # Invalid prerequisite cycle def test_solve(): test_cases = [ (3, 2, [(1, 2), (2, 3)]), (3, 0, []) ] assert solve(test_cases) == [1, 6]","solution":"MOD = 1000000007 def count_valid_sequences(N, prerequisites): from collections import defaultdict, deque # Create adjacency list and in-degree list adj_list = defaultdict(list) in_degree = [0] * (N + 1) for a, b in prerequisites: adj_list[a].append(b) in_degree[b] += 1 # Use Kahn's algorithm to perform a topological sort and count paths queue = deque() for i in range(1, N + 1): if in_degree[i] == 0: queue.append(i) num_valid_sequences = 0 current_sequence = [] def backtrack(): nonlocal num_valid_sequences if len(current_sequence) == N: num_valid_sequences = (num_valid_sequences + 1) % MOD return for i in range(1, N + 1): if in_degree[i] == 0 and i not in current_sequence: current_sequence.append(i) for neighbor in adj_list[i]: in_degree[neighbor] -= 1 backtrack() current_sequence.pop() for neighbor in adj_list[i]: in_degree[neighbor] += 1 backtrack() return num_valid_sequences def solve(test_cases): results = [] for N, M, prereqs in test_cases: results.append(count_valid_sequences(N, prereqs)) return results"},{"question":"def digital_root(n: int) -> int: Returns the digital root of n. Digital root is obtained by repeatedly summing the digits of n until a single-digit value is obtained. Args: n (int): A positive integer Returns: int: The digital root of n >>> digital_root(9875) 2 >>> digital_root(29) 2 >>> digital_root(5) 5 >>> digital_root(99999) 9 >>> digital_root(10**18) 1 >>> digital_root(999999999999999999) 9","solution":"def digital_root(n): Returns the digital root of n. Digital root is obtained by repeatedly summing the digits of n until a single-digit value is obtained. Args: n (int): A positive integer Returns: int: The digital root of n while n >= 10: n = sum(int(digit) for digit in str(n)) return n"},{"question":"def count_paths(R: int, C: int, S: int, grid: List[List[int]]) -> int: Find the number of unique paths from the top-left corner (first row, first column) to the bottom-right corner (last row, last column) where the sum of cell values on the path does not exceed S. You can only move right or down. >>> R, C, S = 3, 3, 10 >>> grid = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] >>> count_paths(R, C, S, grid) 0 >>> R, C, S = 2, 2, 3 >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> count_paths(R, C, S, grid) 2 >>> R, C, S = 2, 2, 100 >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> count_paths(R, C, S, grid) 2 >>> R, C, S = 1, 1, 0 >>> grid = [[0]] >>> count_paths(R, C, S, grid) 1 >>> R, C, S = 2, 2, 1 >>> grid = [ ... [1, 1], ... [1, 1] ... ] >>> count_paths(R, C, S, grid) 0 # Your code here","solution":"def count_paths(R, C, S, grid): memo = {} def unique_paths(r, c, current_sum): if current_sum > S: return 0 if r == R - 1 and c == C - 1: return 1 if (r, c, current_sum) in memo: return memo[(r, c, current_sum)] right_paths = 0 down_paths = 0 if c + 1 < C: right_paths = unique_paths(r, c + 1, current_sum + grid[r][c+1]) if r + 1 < R: down_paths = unique_paths(r + 1, c, current_sum + grid[r+1][c]) memo[(r, c, current_sum)] = right_paths + down_paths return memo[(r, c, current_sum)] return unique_paths(0, 0, grid[0][0]) # Example usage: R, C, S = 3, 3, 10 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] print(count_paths(R, C, S, grid)) # Output: 0, since none of the paths have a sum <= 10"},{"question":"def count_predefined_words(N: int, M: int, predefined_words: List[str], articles: List[str]) -> List[List[int]]: Counts the occurrences of predefined words in each article. Args: N (int): Number of predefined words. M (int): Number of articles. predefined_words (list of str): List of predefined words. articles (list of str): List of articles. Returns: list of list of int: Each sublist contains the count of predefined words in the respective article.","solution":"def count_predefined_words(N, M, predefined_words, articles): Counts the occurrences of predefined words in each article. Args: N (int): Number of predefined words. M (int): Number of articles. predefined_words (list of str): List of predefined words. articles (list of str): List of articles. Returns: list of list of int: Each sublist contains the count of predefined words in the respective article. result = [] for article in articles: words = article.split() counts = [words.count(word) for word in predefined_words] result.append(counts) return result # Example usage: N, M = 3, 2 predefined_words = [\\"science\\", \\"research\\", \\"data\\"] articles = [ \\"in science research often leads to new data breakthroughs in various fields\\", \\"analyzing research data is crucial for scientific progress and innovation\\" ] print(count_predefined_words(N, M, predefined_words, articles))"},{"question":"from typing import List def filter_primes(numbers: List[int]) -> List[int]: Filters and returns a list of prime numbers from the given list of positive integers. >>> filter_primes([2, 3, 4, 5, 10, 13, 17]) [2, 3, 5, 13, 17] >>> filter_primes([1, 4, 6, 8, 9]) [] >>> filter_primes([19, 22, 23, 24, 29]) [19, 23, 29]","solution":"from typing import List def is_prime(n: int) -> bool: Checks if a number is prime. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i+2) == 0: return False i += 6 return True def filter_primes(numbers: List[int]) -> List[int]: Filters and returns a list of prime numbers from the given list of positive integers. return [num for num in numbers if is_prime(num)]"},{"question":"def verify_transactions(transactions): Verify if the total amount for each transaction is correct based on a list of item prices. Args: transactions (list of tuples): Each transaction tuple contains a list of integers representing item prices and an integer representing the total amount paid. Returns: list of str: \\"Correct\\" if the total is correctly calculated, otherwise \\"Incorrect\\". Examples: >>> verify_transactions([ >>> ([100, 200, 300], 600), >>> ([150, 150, 150], 450), >>> ([20, 30, 10], 60), >>> ([500, 500], 999) >>> ]) ['Correct', 'Correct', 'Correct', 'Incorrect'] >>> verify_transactions([ >>> ([10, 20, 30], 60), >>> ([1000, 2000, 3000], 7000), >>> ([15, 15, 15], 45) >>> ]) ['Correct', 'Incorrect', 'Correct']","solution":"def verify_transactions(transactions): Verify if the total amount for each transaction is correct based on a list of item prices. Args: transactions (list of tuples): Each transaction tuple contains a list of integers representing item prices and an integer representing the total amount paid. Returns: list of str: \\"Correct\\" if the total is correctly calculated, otherwise \\"Incorrect\\". results = [] for items, total in transactions: if sum(items) == total: results.append(\\"Correct\\") else: results.append(\\"Incorrect\\") return results"},{"question":"def can_water_all_plants(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[str]: Determines if Alex can water all the plants within the given time for each test case. Parameters: T (int): Number of test cases. test_cases (list of tuples): Each tuple contains (n, t, water_requirements) where n is the number of plants, t is the total time available, water_requirements is a list of water requirements for each plant. Returns: List of strings: \\"YES\\" if it's possible to water all plants within the given time, otherwise \\"NO\\". pass def test_can_water_all_plants(): T = 2 test_cases = [ (3, 10, [3, 4, 4]), (4, 8, [2, 3, 4, 5]) ] expected_output = [\\"NO\\", \\"NO\\"] assert can_water_all_plants(T, test_cases) == expected_output def test_case_all_yes(): T = 1 test_cases = [ (3, 12, [3, 4, 4]) ] expected_output = [\\"YES\\"] assert can_water_all_plants(T, test_cases) == expected_output def test_case_all_no(): T = 1 test_cases = [ (3, 5, [3, 4, 4]) ] expected_output = [\\"NO\\"] assert can_water_all_plants(T, test_cases) == expected_output def test_multiple_cases(): T = 3 test_cases = [ (1, 5, [5]), # YES (2, 5, [2, 4]), # NO (4, 15, [3, 4, 5, 2]) # YES ] expected_output = [\\"YES\\", \\"NO\\", \\"YES\\"] assert can_water_all_plants(T, test_cases) == expected_output","solution":"def can_water_all_plants(T, test_cases): Determines if Alex can water all the plants within the given time for each test case. Parameters: T (int) : Number of test cases. test_cases (list of tuples) : Each tuple contains (n, t, water_requirements) where n is the number of plants, t is the total time available, water_requirements is a list of water requirements for each plant. Returns: List of strings: \\"YES\\" if it's possible to water all plants within the given time, otherwise \\"NO\\". results = [] for case in test_cases: n, t, water_requirements = case total_water_needed = sum(water_requirements) if total_water_needed <= t: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def case_insensitive_sort(words: List[str]) -> List[str]: Returns the list of words sorted in a case-insensitive manner, retaining their original case when two words compare equal ignoring case. :param words: List of words >>> case_insensitive_sort(['banana', 'Apple', 'Banana', 'apple', 'Mango']) ['Apple', 'apple', 'banana', 'Banana', 'Mango'] >>> case_insensitive_sort(['zzz', 'ZZz', 'AAA']) ['AAA', 'zzz', 'ZZz'] def test_case_insensitive_sort_basic(): input_words = ['banana', 'Apple', 'Banana', 'apple', 'Mango'] expected_output = ['Apple', 'apple', 'banana', 'Banana', 'Mango'] assert case_insensitive_sort(input_words) == expected_output def test_case_insensitive_sort_identical_words(): input_words = ['zzz', 'ZZz', 'AAA'] expected_output = ['AAA', 'zzz', 'ZZz'] assert case_insensitive_sort(input_words) == expected_output def test_case_insensitive_sort_mixed_length_words(): input_words = ['a', 'A', 'abc', 'Abc', 'b', 'B'] expected_output = ['a', 'A', 'abc', 'Abc', 'b', 'B'] assert case_insensitive_sort(input_words) == expected_output def test_case_insensitive_sort_same_word_different_cases(): input_words = ['apple', 'Apple', 'APPLE'] expected_output = ['apple', 'Apple', 'APPLE'] assert case_insensitive_sort(input_words) == expected_output def test_case_insensitive_sort_single_word(): input_words = ['apple'] expected_output = ['apple'] assert case_insensitive_sort(input_words) == expected_output def test_case_insensitive_sort_empty_list(): input_words = [] expected_output = [] assert case_insensitive_sort(input_words) == expected_output","solution":"def case_insensitive_sort(words): Returns the list of words sorted in a case-insensitive manner, retaining their original case when two words compare equal ignoring case. :param words: List of words return sorted(words, key=str.lower)"},{"question":"import heapq from typing import List, Tuple, Union def process_input_and_find_paths(input_data: str) -> List[Union[int, str]]: Determine the shortest travel time from the Start Building to the Target Building in the given city graph. Args: - input_data: A string that contains the number of buildings, roads, and queries followed by road data and queries. Returns: - A list of shortest travel times for each query. If no valid path exists, return \\"NO PATH\\". Examples: >>> process_input_and_find_paths(\\"4 4 3n1 2 4n1 3 2n2 3 5n3 4 1n1 4n2 3n3 2n0 0 0\\") [3, 5, \\"NO PATH\\"] >>> process_input_and_find_paths(\\"3 2 1n1 2 1n2 3 1n3 1n0 0 0\\") [\\"NO PATH\\"] def dijkstra(graph: List[List[Tuple[int, int]]], start: int, end: int, n: int) -> Union[int, str]: Dijkstra's algorithm to find the shortest path from start to end. def find_shortest_paths(num_buildings: int, roads: List[Tuple[int, int, int]], queries: List[Tuple[int, int]]) -> List[Union[int, str]]: Returns shortest paths for each query.","solution":"import heapq def dijkstra(graph, start, end, n): Dijkstra's algorithm to find the shortest path from start to end. INF = float('inf') dist = [INF] * (n + 1) dist[start] = 0 priority_queue = [(0, start)] while priority_queue: current_dist, current_node = heapq.heappop(priority_queue) if current_dist > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_dist + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return dist[end] if dist[end] != INF else \\"NO PATH\\" def find_shortest_paths(num_buildings, roads, queries): Returns shortest paths for each query. graph = [[] for _ in range(num_buildings + 1)] for u, v, w in roads: graph[u].append((v, w)) results = [] for s, t in queries: result = dijkstra(graph, s, t, num_buildings) results.append(result) return results def process_input_and_find_paths(input_data): output = [] lines = input_data.strip().split(\\"n\\") i = 0 while i < len(lines): n, m, q = map(int, lines[i].strip().split()) if n == 0 and m == 0 and q == 0: break i += 1 roads = [] for _ in range(m): u, v, w = map(int, lines[i].strip().split()) roads.append((u, v, w)) i += 1 queries = [] for _ in range(q): s, t = map(int, lines[i].strip().split()) queries.append((s, t)) i += 1 results = find_shortest_paths(n, roads, queries) output.extend(results) return output"},{"question":"def count_greater_than_k(lst: List[int], queries: List[int]) -> List[int]: Given a list of integers and queries, return a list of counts of elements greater than each queried value. Parameters: lst (list of int): List of integers. queries (list of int): List of query values. Returns: list of int: Counts of elements greater than each queried value. Example: >>> count_greater_than_k([1, 5, 3, 7, 9], [4, 6, 10]) [3, 2, 0] >>> count_greater_than_k([10, 6, 4, 8, 2, 12], [5, 3, 8, 11]) [4, 5, 2, 1]","solution":"def count_greater_than_k(lst, queries): Returns a list of counts of elements greater than each queried value. Parameters: lst (list of int): List of integers. queries (list of int): List of query values. Returns: list of int: Counts of elements greater than each queried value. lst.sort() # Sort the list for binary search result = [] for k in queries: # Binary search to find the first element greater than k low, high = 0, len(lst) while low < high: mid = (low + high) // 2 if lst[mid] > k: high = mid else: low = mid + 1 result.append(len(lst) - low) return result"},{"question":"from typing import List, Union def find_majority_element(lst: List[int]) -> Union[int, str]: Returns the majority element of the list if it exists, otherwise returns \\"No majority element\\". >>> find_majority_element([3, 3, 4, 2, 3, 3, 5, 3]) 3 >>> find_majority_element([1, 2, 3, 4]) \\"No majority element\\" >>> find_majority_element([1, 1, 1, 1, 1, 1]) 1 >>> find_majority_element([1, 1, 2, 2, 2, 2, 2, 1]) 2 >>> find_majority_element([]) \\"No majority element\\" >>> find_majority_element([0]) 0 pass def process_test_cases(test_cases: List[str]) -> List[Union[int, str]]: Processes multiple test cases. >>> process_test_cases([\\"3 3 4 2 3 3 5 3\\", \\"1 2 3 4\\", \\"1 1 1 1 1 1\\", \\"1 1 2 2 2 2 2 1\\", \\"\\"]) [3, \\"No majority element\\", 1, 2, \\"No majority element\\"] pass","solution":"def find_majority_element(lst): Returns the majority element of the list if it exists, otherwise returns \\"No majority element\\". candidate, count = None, 0 for num in lst: if count == 0: candidate, count = num, 1 elif num == candidate: count += 1 else: count -= 1 # Verify if candidate is a majority element if lst.count(candidate) > len(lst) // 2: return candidate else: return \\"No majority element\\" def process_test_cases(test_cases): Processes multiple test cases. results = [] for test in test_cases: lst = list(map(int, test.split())) results.append(find_majority_element(lst)) return results"},{"question":"def review_order(no_of_articles, max_articles_to_review, articles): Determine the order in which Ravi should review the articles based on priority and ID. Args: no_of_articles (int): Number of articles. max_articles_to_review (int): Maximum articles Ravi can review. articles (list of tuples): Each tuple contains (article_id, priority_level). Returns: list: List of article IDs in the order Ravi should review them. from solution import review_order def test_example_case(): assert review_order(5, 3, [(101, 5), (102, 3), (103, 5), (104, 2), (105, 4)]) == [101, 103, 105] def test_same_priority_different_ids(): assert review_order(4, 2, [(200, 10), (100, 10), (300, 5), (400, 6)]) == [100, 200] def test_max_articles_less_than_total(): assert review_order(6, 4, [(150, 7), (120, 9), (130, 6), (110, 9), (140, 7), (170, 5)]) == [110, 120, 140, 150] def test_all_same_priority(): assert review_order(4, 2, [(1, 5), (2, 5), (3, 5), (4, 5)]) == [1, 2] def test_max_articles_equals_total(): assert review_order(3, 3, [(10, 10), (20, 9), (30, 8)]) == [10, 20, 30] def test_single_article(): assert review_order(1, 1, [(50, 7)]) == [50]","solution":"def review_order(no_of_articles, max_articles_to_review, articles): Determine the order in which Ravi should review the articles based on priority and ID. Args: no_of_articles (int): Number of articles. max_articles_to_review (int): Maximum articles Ravi can review. articles (list of tuples): Each tuple contains (article_id, priority_level). Returns: list: List of article IDs in the order Ravi should review them. # Sort the articles first by priority (descending) and then by ID (ascending) sorted_articles = sorted(articles, key=lambda x: (-x[1], x[0])) # Extract the article IDs for the top K articles review_list = [article[0] for article in sorted_articles[:max_articles_to_review]] return review_list # Example usage print(review_order(5, 3, [(101, 5), (102, 3), (103, 5), (104, 2), (105, 4)])) # Output: [101, 103, 105]"},{"question":"from typing import List def two_sum(nums: List[int], target: int) -> bool: Determine if there are two distinct elements in the array that sum up to the target value. Args: nums: List[int] - a list of integers target: int - target integer Returns: bool - True if there are two distinct elements that sum up to target, otherwise False Examples: >>> two_sum([2, 7, 11, 15, 1], 9) True >>> two_sum([2, 7, 11, 15, 1], 10) False >>> two_sum([-1, -2, -3, -4, -5], -8) True >>> two_sum([-1, -2, -3, -4, -5], -10) False >>> two_sum([0, 1, 2, 3, 4, 5], 5) True >>> two_sum([0, 1, 2, 3, 4, 5], 10) False >>> two_sum([1], 1) False >>> two_sum([1], 2) False >>> two_sum([], 0) False >>> two_sum([1, 3, 4, 2, 8, 5], 6) True >>> two_sum([1, 3, 2, 3], 6) True","solution":"def two_sum(nums, target): Determine if there are two distinct elements in the array that sum up to the target value. Args: nums: List[int] - a list of integers target: int - target integer Returns: bool - True if there are two distinct elements that sum up to target, otherwise False num_set = set() for num in nums: if target - num in num_set: return True num_set.add(num) return False"},{"question":"def last_knight_remaining(n: int, k: int) -> int: Determine the number of the knight who will be the last one remaining. Parameters: n (int): The total number of knights. k (int): The step count for each attack. Returns: int: The number of the last remaining knight. Examples: >>> last_knight_remaining(7, 3) 4 >>> last_knight_remaining(5, 2) 3 from solution import last_knight_remaining def test_example_1(): assert last_knight_remaining(7, 3) == 4 def test_example_2(): assert last_knight_remaining(5, 2) == 3 def test_minimum_values(): assert last_knight_remaining(1, 1) == 1 def test_k_equals_n(): assert last_knight_remaining(10, 10) == 8 def test_large_values(): assert last_knight_remaining(100000, 1) == 100000 def test_k_equals_1(): assert last_knight_remaining(10, 1) == 10 def test_n_equals_k(): assert last_knight_remaining(5, 5) == 2","solution":"def last_knight_remaining(n, k): Returns the number of the last remaining knight in the tournament. Parameters: n (int): The total number of knights. k (int): The step count for each attack. Returns: int: The number of the last remaining knight. knights = list(range(1, n + 1)) index = 0 while len(knights) > 1: index = (index + k - 1) % len(knights) knights.pop(index) return knights[0]"},{"question":"def min_subset_sum_difference(n: int, values: List[int]) -> int: Calculate the minimum possible difference between the sums of two groups of items with given values. :param n: Number of items :param values: List of values of the items :return: Minimum possible difference >>> min_subset_sum_difference(4, [1, 2, 3, 4]) 0 >>> min_subset_sum_difference(3, [1, 5, 7]) 1","solution":"def min_subset_sum_difference(n, values): Calculate the minimum possible difference between the sums of two groups of items with given values. :param n: Number of items :param values: List of values of the items :return: Minimum possible difference total_sum = sum(values) target = total_sum // 2 dp = [False] * (target + 1) dp[0] = True for value in values: for i in range(target, value - 1, -1): if dp[i - value]: dp[i] = True for i in range(target, -1, -1): if dp[i]: group1_sum = i break group2_sum = total_sum - group1_sum return abs(group1_sum - group2_sum)"},{"question":"def min_days_to_produce_gadgets(n: int, m: int, capacities: List[int]) -> int: Determines the minimum number of days required to produce a total of m gadgets. Parameters: n (int): Number of machines m (int): Total number of gadgets required capacities (List[int]): Number of gadgets each machine can produce per day Returns: int: Minimum number of days required to produce m gadgets Examples: >>> min_days_to_produce_gadgets(3, 10, [1, 2, 3]) 2 >>> min_days_to_produce_gadgets(4, 25, [5, 5, 5, 5]) 2","solution":"def min_days_to_produce_gadgets(n, m, capacities): Determines the minimum number of days required to produce a total of m gadgets. Parameters: n (int): Number of machines m (int): Total number of gadgets required capacities (List[int]): Number of gadgets each machine can produce per day Returns: int: Minimum number of days required to produce m gadgets total_capacity_per_day = sum(capacities) min_days = (m + total_capacity_per_day - 1) // total_capacity_per_day # Ceiling division return min_days"},{"question":"def can_rearrange_strictly_monotonic(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if the per-unit revenue for each day can be rearranged to show a strict monotonic trend (increasing or decreasing) for a given number of test cases. >>> can_rearrange_strictly_monotonic(3, [(5, [2, 3, 1, 5, 4]), (4, [1, 2, 3, 4]), (3, [5, 5, 5])]) [\\"Yes\\", \\"Yes\\", \\"No\\"] >>> can_rearrange_strictly_monotonic(2, [(4, [4, 3, 2, 1]), (5, [10, 20, 30, 40, 50])]) [\\"Yes\\", \\"Yes\\"] >>> can_rearrange_strictly_monotonic(1, [(6, [1, 2, 2, 3, 4, 5])]) [\\"No\\"] >>> can_rearrange_strictly_monotonic(2, [(3, [7, 8, 9]), (4, [-1, -2, -3, -4])]) [\\"Yes\\", \\"Yes\\"] >>> can_rearrange_strictly_monotonic(1, [(2, [3, 3])]) [\\"No\\"]","solution":"def can_rearrange_strictly_monotonic(t, test_cases): results = [] for i in range(t): n = test_cases[i][0] array = test_cases[i][1] # Check for strictly increasing rearrangement sorted_array = sorted(array) if all(sorted_array[j] < sorted_array[j + 1] for j in range(n - 1)): results.append(\\"Yes\\") else: # Check for strictly decreasing rearrangement sorted_array = sorted(array, reverse=True) if all(sorted_array[j] > sorted_array[j + 1] for j in range(n - 1)): results.append(\\"Yes\\") else: results.append(\\"No\\") return results"},{"question":"def count_palindromic_substrings(s: str) -> int: Count all distinct palindromic substrings of a given string. >>> count_palindromic_substrings(\\"ababa\\") == 5 >>> count_palindromic_substrings(\\"abc\\") == 3 >>> count_palindromic_substrings(\\"aaa\\") == 3 >>> count_palindromic_substrings(\\"a\\") == 1 >>> count_palindromic_substrings(\\"abcd\\") == 4 >>> count_palindromic_substrings(\\"aaaa\\") == 4","solution":"def count_palindromic_substrings(s: str) -> int: Count all distinct palindromic substrings of a given string. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() for i in range(len(s)): for j in range(i, len(s)): substring = s[i:j+1] if is_palindrome(substring): palindromic_substrings.add(substring) return len(palindromic_substrings)"},{"question":"def can_form_palindrome(s: str) -> str: Given a string \`s\`, check if it is possible to rearrange the characters of \`s\` to form a palindrome. A palindrome is a string that reads the same backward as forward. :param s: The input string consisting of lowercase English letters. :return: \\"YES\\" if the characters of \`s\` can be rearranged to form a palindrome, otherwise \\"NO\\". Example: >>> can_form_palindrome(\\"aabb\\") \\"YES\\" >>> can_form_palindrome(\\"abc\\") \\"NO\\"","solution":"def can_form_palindrome(s): Checks if the characters of the given string can be rearranged to form a palindrome. :param s: The input string consisting of lowercase English letters. :return: \\"YES\\" if the string can be rearranged to form a palindrome, otherwise \\"NO\\". from collections import Counter # Count the frequency of each character in the string char_count = Counter(s) # Count how many characters have an odd frequency odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # If more than one character has an odd frequency, it cannot form a palindrome return \\"YES\\" if odd_count <= 1 else \\"NO\\""},{"question":"def min_removals_to_make_unique(s: str) -> int: Determine the smallest number of characters you need to remove from S to make all remaining characters of the string different. >>> min_removals_to_make_unique(\\"aaa\\") 2 >>> min_removals_to_make_unique(\\"abcabc\\") 3 >>> min_removals_to_make_unique(\\"abcdefg\\") 0","solution":"def min_removals_to_make_unique(s): from collections import Counter char_count = Counter(s) removals = 0 for count in char_count.values(): if count > 1: removals += count - 1 return removals"},{"question":"from typing import List def lengthOfLIS(nums: List[int]) -> int: Function to find the length of the longest increasing subsequence. pass def process_input(data: List[str]) -> List[int]: Processes the input data and returns the lengths of the longest increasing subsequences for each dataset. pass def main(): import sys input = sys.stdin.read data = input().strip().split('n') result = process_input(data) for res in result: print(res) import pytest def test_lengthOfLIS(): assert lengthOfLIS([5, 1, 8, 3, 7, 9]) == 4 assert lengthOfLIS([3, 10, 2, 1]) == 2 assert lengthOfLIS([1, 2, 3, 4, 5]) == 5 assert lengthOfLIS([5, 4, 3, 2, 1]) == 1 assert lengthOfLIS([]) == 0 assert lengthOfLIS([10, 9, 2, 5, 3, 7, 101, 18]) == 4 def test_process_input(): input_data = [ \\"6\\", \\"5 1 8 3 7 9\\", \\"4\\", \\"3 10 2 1\\" ] assert process_input(input_data) == [4, 2] input_data = [ \\"5\\", \\"1 2 3 4 5\\", \\"5\\", \\"5 4 3 2 1\\" ] assert process_input(input_data) == [5, 1]","solution":"def lengthOfLIS(nums): Function to find the length of the longest increasing subsequence. if not nums: return 0 dp = [1] * len(nums) for i in range(1, len(nums)): for j in range(i): if nums[i] > nums[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) def process_input(data): Processes the input data and returns the lengths of the longest increasing subsequences for each dataset. result = [] i = 0 while i < len(data): n = int(data[i]) nums = list(map(int, data[i+1].split())) result.append(lengthOfLIS(nums)) i += 2 return result def main(): import sys input = sys.stdin.read data = input().strip().split('n') result = process_input(data) for res in result: print(res)"},{"question":"def is_palindrome(arr: List[int]) -> bool: Returns true if the given array is a palindrome, and false otherwise. >>> is_palindrome([1, 2, 3, 2, 1]) True >>> is_palindrome([1, 2, 3, 4, 5]) False","solution":"def is_palindrome(arr): Returns true if the given array is a palindrome, and false otherwise. Args: arr: list of integers Returns: bool: True if arr is a palindrome, False otherwise return arr == arr[::-1]"},{"question":"def max_mana(n: int, mana: List[int], connections: List[Tuple[int, int]]) -> int: Calculate the maximum amount of mana that can be accumulated starting from any animal. Args: n (int): The number of animals. mana (List[int]): The initial mana of each animal. connections (List[Tuple[int, int]]): The list of pairs indicating direct mana transfer capability. Returns: int: The maximum amount of mana that can be accumulated starting from any animal. Example: >>> n = 5 >>> mana = [3, 2, 1, 10, 5] >>> connections = [(1, 2), (1, 3), (3, 4), (3, 5)] >>> max_mana(n, mana, connections) 21 >>> n = 4 >>> mana = [5, 1, 4, 7] >>> connections = [(1, 2), (2, 3), (2, 4)] >>> max_mana(n, mana, connections) 17","solution":"from collections import defaultdict def max_mana(n, mana, connections): graph = defaultdict(list) for u, v in connections: graph[u-1].append(v-1) graph[v-1].append(u-1) def dfs(node, parent): current_mana = mana[node] for neighbor in graph[node]: if neighbor != parent: current_mana += dfs(neighbor, node) return current_mana max_mana_accumulated = 0 for i in range(n): max_mana_accumulated = max(max_mana_accumulated, dfs(i, -1)) return max_mana_accumulated # Example usage: n = 5 mana = [3, 2, 1, 10, 5] connections = [(1, 2), (1, 3), (3, 4), (3, 5)] print(max_mana(n, mana, connections)) # 21"},{"question":"from typing import List, Tuple def count_unique_pairs(nums: List[int], target: int) -> int: Find the number of unique pairs of integers in the list that add up to the target sum. A pair (a, b) is considered unique if there is no other pair (a', b') where a' = b and b' = a. >>> count_unique_pairs([1, 5, 7, -1, 5], 6)? 2 >>> count_unique_pairs([1, 1, 1, 1], 2)? 1 pass def parse_input(input_str: str) -> Tuple[int, List[int], int]: Parse the input string into number of integers, list of integers, and target sum. >>> parse_input(\\"5n1 5 7 -1 5n6\\") (5, [1, 5, 7, -1, 5], 6) >>> parse_input(\\"4n1 1 1 1n2\\") (4, [1, 1, 1, 1], 2) pass","solution":"def count_unique_pairs(nums, target): seen = set() pairs = set() for num in nums: complement = target - num if complement in seen: pairs.add((min(num, complement), max(num, complement))) seen.add(num) return len(pairs) def parse_input(input_str): lines = input_str.split(\\"n\\") n = int(lines[0]) nums = list(map(int, lines[1].split())) target = int(lines[2]) return n, nums, target"},{"question":"def max_gold(n: int, m: int, grid: List[List[int]]) -> int: Function to determine the maximum amount of gold that can be collected moving from the top-left corner to the bottom-right corner of the grid, moving only to the right or down. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (list of list of int): The grid containing the amount of gold in each cell. Returns: int: The maximum amount of gold that can be collected. >>> max_gold(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_gold(1, 1, [[5]]) 5 >>> max_gold(1, 4, [[1, 2, 3, 4]]) 10 >>> max_gold(4, 1, [[1], [2], [3], [4]]) 10 >>> max_gold(3, 3, [[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]]) 5000 >>> max_gold(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 # Your code here","solution":"def max_gold(n, m, grid): Function to determine the maximum amount of gold that can be collected moving from the top-left corner to the bottom-right corner of the grid, moving only to the right or down. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (list of list of int): The grid containing the amount of gold in each cell. Returns: int: The maximum amount of gold that can be collected. dp = [[0] * m for _ in range(n)] dp[0][0] = grid[0][0] for i in range(1, m): dp[0][i] = dp[0][i-1] + grid[0][i] for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] for i in range(1, n): for j in range(1, m): dp[i][j] = grid[i][j] + max(dp[i-1][j], dp[i][j-1]) return dp[n-1][m-1]"},{"question":"def daily_temperatures(temperatures): For each day, determine how many days you have to wait until a warmer temperature. If there is no future day with a warmer temperature, output 0 for that day. pass def process_input(input_string): Process the input dataset and return the daily temperatures output for each dataset. pass if __name__ == \\"__main__\\": input_data = \\"73 74 75 71 69 72 76 73n40 50 60 30 20 10n0\\" print(process_input(input_data))","solution":"def daily_temperatures(temperatures): For each day, determine how many days you have to wait until a warmer temperature. If there is no future day with a warmer temperature, output 0 for that day. # Initialize a list with 0's, same length as temperatures res = [0] * len(temperatures) # Stack to store the indexes of temperatures stack = [] for i in range(len(temperatures)): # While stack has elements and the current temperature is greater than the temperature at the index stored in the stack while stack and temperatures[i] > temperatures[stack[-1]]: prev_day = stack.pop() res[prev_day] = i - prev_day stack.append(i) return res def process_input(input_string): lines = input_string.strip().split('n') results = [] for line in lines: if line == '0': break temperatures = list(map(int, line.split())) results.append(' '.join(map(str, daily_temperatures(temperatures)))) return 'n'.join(results)"},{"question":"def can_assign_superheroes(n: int, m: int, k: int) -> str: Determines if it is possible to assign superheroes to combat zones such that each zone has at least k superheroes. :param n: Number of superheroes :param m: Number of combat zones :param k: Minimum superheroes required per zone :return: 'POSSIBLE' or 'IMPOSSIBLE' >>> can_assign_superheroes(6, 2, 3) 'POSSIBLE' >>> can_assign_superheroes(5, 3, 2) 'IMPOSSIBLE' >>> can_assign_superheroes(10, 5, 2) 'POSSIBLE'","solution":"def can_assign_superheroes(n, m, k): Determines if it is possible to assign superheroes to combat zones such that each zone has at least k superheroes. :param n: Number of superheroes :param m: Number of combat zones :param k: Minimum superheroes required per zone :return: 'POSSIBLE' or 'IMPOSSIBLE' # Check if the total superheroes can cover the required number of superheroes for all zones if n >= m * k: return \\"POSSIBLE\\" else: return \\"IMPOSSIBLE\\""},{"question":"def calculate_wait_time(T: int, Q: int) -> int: Calculate the waiting time based on the given hour of the day and queue length. Parameters: T (int): The hour of the day (0 <= T < 24) Q (int): The length of the queue (0 <= Q <= 1000) Returns: int: The calculated waiting time Examples: >>> calculate_wait_time(10, 5) 20 >>> calculate_wait_time(15, 10) 19 # your code here pass # Sample unit tests def test_morning_hours(): assert calculate_wait_time(10, 5) == 20 assert calculate_wait_time(0, 10) == 20 assert calculate_wait_time(11, 0) == 11 def test_afternoon_hours(): assert calculate_wait_time(12, 5) == 5 assert calculate_wait_time(15, 10) == 19 assert calculate_wait_time(17, 0) == 15 def test_evening_hours(): assert calculate_wait_time(18, 5) == 30 assert calculate_wait_time(20, 0) == 0 assert calculate_wait_time(23, 10) == 10 def test_edge_cases(): assert calculate_wait_time(0, 0) == 0 assert calculate_wait_time(23, 0) == 0 def test_invalid_hours(): try: calculate_wait_time(24, 5) except ValueError as e: assert str(e) == \\"T must be between 0 and 23 inclusive\\" try: calculate_wait_time(-1, 5) except ValueError as e: assert str(e) == \\"T must be between 0 and 23 inclusive\\"","solution":"def calculate_wait_time(T: int, Q: int) -> int: Calculate the waiting time based on the given hour of the day and queue length. Parameters: T (int): The hour of the day (0 <= T < 24) Q (int): The length of the queue (0 <= Q <= 1000) Returns: int: The calculated waiting time if 0 <= T < 12: return 2 * Q + T elif 12 <= T < 18: return Q + 3 * (T - 12) elif 18 <= T < 24: return Q * (24 - T) else: raise ValueError(\\"T must be between 0 and 23 inclusive\\")"},{"question":"def find_fastest_times(n, r, submissions, queries): Given the number of participants (n), the number of rounds (r), the list of submission times for each round, and a list of query rounds, returns the fastest submission time for each query round. pass def test_find_fastest_times(): # Test case for example in the problem statement n = 3 r = 4 submissions = [ [5, 3, 8], # round 1 [7, 2, 4], # round 2 [6, 9, 1], # round 3 [3, 5, 7] # round 4 ] queries = [1, 2, 4] expected = [3, 2, 3] assert find_fastest_times(n, r, submissions, queries) == expected def test_single_round_and_single_query(): n = 5 r = 1 submissions = [ [12, 7, 5, 9, 8] # round 1 ] queries = [1] expected = [5] assert find_fastest_times(n, r, submissions, queries) == expected def test_multiple_rounds_and_all_queries(): n = 2 r = 2 submissions = [ [5, 10], # round 1 [3, 1] # round 2 ] queries = [1, 2] expected = [5, 1] assert find_fastest_times(n, r, submissions, queries) == expected def test_large_input(): n = 3 r = 3 submissions = [ [1000000000, 1000000000, 1000000000], # round 1 [999999999, 1000000000, 999999998], # round 2 [500000000, 1000000000, 700000000] # round 3 ] queries = [1, 2, 3] expected = [1000000000, 999999998, 500000000] assert find_fastest_times(n, r, submissions, queries) == expected def test_mixed_values(): n = 4 r = 3 submissions = [ [10, 5, 20, 1], # round 1 [25, 22, 11, 13], # round 2 [7, 500, 23, 100] # round 3 ] queries = [2, 1, 3] expected = [11, 1, 7] assert find_fastest_times(n, r, submissions, queries) == expected","solution":"def find_fastest_times(n, r, submissions, queries): Given the number of participants (n), the number of rounds (r), the list of submission times for each round, and a list of query rounds, returns the fastest submission time for each query round. # Precompute the fastest submission time for each round min_times = [min(round_times) for round_times in submissions] # Respond to each query with the precomputed fastest times results = [min_times[q - 1] for q in queries] return results"},{"question":"def find_max_scenic_path(n, scenic_values, m, paths): Finds the path in the park with the maximum total scenic value. Args: n (int): The number of landmarks in the park. scenic_values (List[int]): A list of scenic values for each landmark. m (int): The number of direct paths between landmarks. paths (List[Tuple[int, int]]): A list of tuples representing the direct paths between landmarks. Returns: int: The maximum total scenic value of a path in the park. Examples: >>> find_max_scenic_path(5, [5, -3, 2, 6, 4], 4, [(1, 2), (2, 3), (3, 4), (4, 5)]) 14 >>> find_max_scenic_path(6, [-1, -2, -3, -4, -5, -6], 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)]) -1 >>> find_max_scenic_path(3, [7, 8, 9], 3, [(1, 2), (2, 3), (1, 3)]) 24","solution":"def find_max_scenic_path(n, scenic_values, m, paths): from collections import defaultdict import sys # Create an adjacency list graph = defaultdict(list) for u, v in paths: graph[u-1].append(v-1) graph[v-1].append(u-1) # Initialize variables to store the maximum scenic value visited = [False] * n max_scenic_value = -sys.maxsize def dfs(node, current_value): nonlocal max_scenic_value visited[node] = True current_value += scenic_values[node] max_scenic_value = max(max_scenic_value, current_value) for neighbor in graph[node]: if not visited[neighbor]: dfs(neighbor, current_value) visited[node] = False current_value -= scenic_values[node] # Call DFS for each node for i in range(n): dfs(i, 0) return max_scenic_value"},{"question":"class CustomList: def __init__(self): self.list = [] self.added_numbers = [] def add(self, x): self.list.append(x) self.added_numbers.append(x) def remove(self, k): value_to_remove = self.added_numbers[k-1] self.added_numbers[k-1] = None self.list.remove(value_to_remove) def get_max(self): return max(self.list) if self.list else None def process_queries(queries): Handle queries on a list of integers. 1. \\"1 x\\" - add the integer x to the list. 2. \\"2 k\\" - remove the k-th added integer from the list. 3. \\"3\\" - print the current maximum integer in the list. Args: queries (List[str]): List of query strings. Returns: List[int]: The results of all queries of type 3. Examples: >>> process_queries([\\"1 5\\", \\"1 3\\", \\"3\\", \\"2 1\\", \\"3\\", \\"1 7\\", \\"3\\"]) [5, 3, 7] >>> process_queries([\\"1 10\\", \\"3\\"]) [10]","solution":"class CustomList: def __init__(self): self.list = [] self.added_numbers = [] def add(self, x): self.list.append(x) self.added_numbers.append(x) def remove(self, k): value_to_remove = self.added_numbers[k-1] self.added_numbers[k-1] = None self.list.remove(value_to_remove) def get_max(self): return max(self.list) if self.list else None def process_queries(queries): clist = CustomList() results = [] for query in queries: parts = query.split() if parts[0] == \\"1\\": clist.add(int(parts[1])) elif parts[0] == \\"2\\": clist.remove(int(parts[1])) elif parts[0] == \\"3\\": results.append(clist.get_max()) return results"},{"question":"def survey_results(n: int, responses: str) -> List[int]: Determines the cumulative number of students who \\"like\\" the drink after each survey response. :param n: Number of survey responses :param responses: String of length n with each character either 'L' or 'D' :return: List of integers representing cumulative count of \\"like\\" responses >>> survey_results(5, 'LLLLL') [1, 2, 3, 4, 5] >>> survey_results(5, 'DDDDD') [0, 0, 0, 0, 0] >>> survey_results(5, 'LDLLD') [1, 1, 2, 3, 3] >>> survey_results(1, 'L') [1] >>> survey_results(1, 'D') [0] >>> survey_results(6, 'LDLDLD') [1, 1, 2, 2, 3, 3] from typing import List","solution":"def survey_results(n, responses): Determines the cumulative number of students who \\"like\\" the drink after each survey response. :param n: Number of survey responses :param responses: String of length n with each character either 'L' or 'D' :return: List of integers representing cumulative count of \\"like\\" responses cumulative_likes = [] current_likes = 0 for response in responses: if response == 'L': current_likes += 1 cumulative_likes.append(current_likes) return cumulative_likes"},{"question":"from typing import List, Tuple def max_score_difference(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: You are given an array of integers representing the score of different players in a game. Your task is to find the player with the highest score difference with respect to the player with the minimum score who is not the overall minimum. Specifically, you need to find the player who has the highest score and subtract from it the score of the player who is the second lowest (i.e., the lowest score that is greater than the overall minimum score). If there is no such player (e.g., when all players have the same score or there is only one unique score in the list), return -1. >>> max_score_difference(3, [(5, [10, 20, 20, 30, 40]), (4, [25, 25, 25, 25]), (6, [10, 10, 20, 20, 30, 40])]) [30, -1, 30] >>> max_score_difference(1, [(4, [15, 15, 15, 15])]) [-1] >>> max_score_difference(1, [(2, [1, 1])]) [-1] >>> max_score_difference(1, [(2, [1, 100])]) [99] >>> max_score_difference(1, [(6, [7, 8, 5, 5, 9, 5])]) [4] >>> max_score_difference(1, [(100, [201] * 50 + [202] * 50)]) [1] >>> max_score_difference(1, [(3, [10, 20, 20])]) [10]","solution":"def max_score_difference(T, test_cases): results = [] for i in range(T): n, scores = test_cases[i] unique_scores = sorted(set(scores)) if len(unique_scores) < 2: results.append(-1) else: min_score = unique_scores[0] second_min_score = unique_scores[1] max_score = unique_scores[-1] results.append(max_score - min_score) return results"},{"question":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string): self.history.append(self.text) self.text += string def delete(self, k): self.history.append(self.text) self.text = self.text[:-k] def print_char(self, k): print(self.text[k-1]) def undo(self): if self.history: self.text = self.history.pop() def process_operations(operations): Perform a list of operations on the SimpleTextEditor and return the results of print operations. >>> process_operations([ ... \\"append abc\\", ... \\"append def\\", ... \\"print 6\\", ... \\"delete 3\\", ... \\"print 3\\", ... \\"undo\\", ... \\"print 6\\", ... \\"undo\\" ... ]) ['f', 'c', 'f']","solution":"class SimpleTextEditor: def __init__(self): self.text = \\"\\" self.history = [] def append(self, string): self.history.append(self.text) self.text += string def delete(self, k): self.history.append(self.text) self.text = self.text[:-k] def print_char(self, k): print(self.text[k-1]) def undo(self): if self.history: self.text = self.history.pop() def process_operations(operations): editor = SimpleTextEditor() output = [] for op in operations: if op.startswith(\\"append\\"): _, string = op.split(maxsplit=1) editor.append(string) elif op.startswith(\\"delete\\"): _, k = op.split() editor.delete(int(k)) elif op.startswith(\\"print\\"): _, k = op.split() output.append(editor.text[int(k) - 1]) elif op == \\"undo\\": editor.undo() return output # Sample use including debug prints if __name__ == \\"__main__\\": n = 8 operations = [ \\"append abc\\", \\"append def\\", \\"print 6\\", \\"delete 3\\", \\"print 3\\", \\"undo\\", \\"print 6\\", \\"undo\\" ] results = process_operations(operations) for res in results: print(res)"},{"question":"def find_subarray_with_diff(A: List[int], K: int) -> List[int]: Returns the subarray where the difference between the maximum and minimum elements is exactly K. >>> find_subarray_with_diff([1, 7, 5, 9, 2], 6) [1, 7] >>> find_subarray_with_diff([4, 3, 2, 1], 5) [] >>> find_subarray_with_diff([10, 5, 2, 7, 8, 7], 5) [10, 5] >>> find_subarray_with_diff([1, 6, 2, 3, 7], 5) [1, 6] >>> find_subarray_with_diff([1, 1, 1, 1, 1], 0) [1] >>> find_subarray_with_diff([1, 2, 3, 4, 5], 10) [] >>> find_subarray_with_diff([1, 2, 3, 4, 5, 6], 5) [1, 2, 3, 4, 5, 6] >>> find_subarray_with_diff([5], 0) [5]","solution":"def find_subarray_with_diff(A, K): Returns the subarray where the difference between the maximum and minimum elements is exactly K. N = len(A) # Maintain sliding window maximum and minimum from collections import deque max_deque = deque() min_deque = deque() l = 0 # Iterate over the array for r in range(N): # Keep max_deque decreasing while max_deque and A[max_deque[-1]] <= A[r]: max_deque.pop() max_deque.append(r) # Keep min_deque increasing while min_deque and A[min_deque[-1]] >= A[r]: min_deque.pop() min_deque.append(r) # Check if the current window [l, r] is invalid while A[max_deque[0]] - A[min_deque[0]] > K: if max_deque[0] == l: max_deque.popleft() if min_deque[0] == l: min_deque.popleft() l += 1 # Check if the current window [l, r] is valid if A[max_deque[0]] - A[min_deque[0]] == K: return A[l:r+1] return []"},{"question":"def generate_binary_sequence(n: int) -> str: Generate a binary sequence of length \`n\` with equal number of zeroes and ones, without containing \\"000\\" or \\"111\\" as a substring. >>> generate_binary_sequence(6) == '010101' >>> generate_binary_sequence(4) in ('0101', '1010')","solution":"def generate_binary_sequence(n): Generate a binary sequence of length \`n\` with equal number of zeroes and ones, without containing \\"000\\" or \\"111\\" as a substring. half = n // 2 sequence = '01' * half return sequence"},{"question":"def check_tram_routes_overlap(n: int, routes: List[Tuple[int, int, int, int]]) -> str: Function to determine if any pair of tram routes overlap completely. Parameters: n (int): The number of tram routes. routes (List[Tuple[int, int, int, int]]): A list of tuples containing the coordinates of the start and end points of each route. Returns: str: \\"YES\\" if there exists a pair of routes that overlap completely otherwise \\"NO\\". Example: >>> check_tram_routes_overlap(4, [(0, 0, 5, 5), (1, 1, 4, 4), (0, 0, 5, 5), (-1, -1, -5, -5)]) \\"YES\\" >>> check_tram_routes_overlap(3, [(0, 0, 5, 5), (1, 1, 4, 4), (2, 2, 6, 6)]) \\"NO\\"","solution":"def check_tram_routes_overlap(n, routes): Function to determine if any pair of tram routes overlap completely. # Normalize all routes such that start point is always the one with a lower (x, y) value normalized_routes = [] for x1, y1, x2, y2 in routes: if (x1, y1) > (x2, y2): x1, y1, x2, y2 = x2, y2, x1, y1 normalized_routes.append((x1, y1, x2, y2)) # Use a set to check for duplicate routes seen_routes = set() for route in normalized_routes: if route in seen_routes: return \\"YES\\" seen_routes.add(route) return \\"NO\\""},{"question":"def find_words_on_one_row(words: List[str]) -> List[str]: Given a list of words, return the words that can be typed using letters of the alphabet on only one row of an American QWERTY keyboard. >>> find_words_on_one_row(['Hello', 'Alaska', 'Dad', 'Peace', 'Key']) ['Alaska', 'Dad'] >>> find_words_on_one_row(['type', 'ROW', 'CHECK']) ['type', 'ROW'] >>> find_words_on_one_row(['only', 'WORDS', 'here']) [] >>> find_words_on_one_row(['asdf', 'qwer', 'zxcv']) ['asdf', 'qwer', 'zxcv'] >>> find_words_on_one_row(['AaBbCc', 'qwerty']) ['qwerty'] >>> find_words_on_one_row([]) []","solution":"def find_words_on_one_row(words): Given a list of words, return the words that can be typed using letters of the alphabet on only one row of an American QWERTY keyboard. # Define the sets for the rows top_row = set(\\"qwertyuiop\\") home_row = set(\\"asdfghjkl\\") bottom_row = set(\\"zxcvbnm\\") result = [] for word in words: # Convert word to lowercase for case insensitive comparison lower_word = set(word.lower()) # Check if the word can be typed using one of the rows if lower_word.issubset(top_row) or lower_word.issubset(home_row) or lower_word.issubset(bottom_row): result.append(word) return result"},{"question":"def is_palindrome_permutation(s: str) -> bool: Determine if any permutation of the string can be arranged into a palindrome. Ignore spaces and case. >>> is_palindrome_permutation(\\"Tact Coa\\") == True >>> is_palindrome_permutation(\\"Able was I ere I saw Elba\\") == True >>> is_palindrome_permutation(\\"No lemon no melon\\") == True >>> is_palindrome_permutation(\\"Hello\\") == False >>> is_palindrome_permutation(\\"racecar\\") == True >>> is_palindrome_permutation(\\"race car\\") == True >>> is_palindrome_permutation(\\"\\") == True >>> is_palindrome_permutation(\\"a\\") == True >>> is_palindrome_permutation(\\"ab\\") == False >>> is_palindrome_permutation(\\"A man a plan a canal Panama\\") == True pass def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") result = [] for line in data: line = line.strip() if line == '.': break if is_palindrome_permutation(line): result.append(\\"yes\\") else: result.append(\\"no\\") for res in result: print(res)","solution":"def is_palindrome_permutation(s): Determines if any permutation of the string can be arranged into a palindrome. Ignores spaces and is case-insensitive. s = s.replace(\\" \\", \\"\\").lower() char_count = {} # Count the occurrences of each character for char in s: if char in char_count: char_count[char] += 1 else: char_count[char] = 1 odd_count = 0 # A string can be rearranged as a palindrome if at most one character has an odd count for count in char_count.values(): if count % 2 != 0: odd_count += 1 return odd_count <= 1 def main(): import sys input = sys.stdin.read data = input().strip().split(\\"n\\") result = [] for line in data: line = line.strip() if line == '.': break if is_palindrome_permutation(line): result.append(\\"yes\\") else: result.append(\\"no\\") for res in result: print(res)"},{"question":"def is_palindrome(s: str) -> str: Determine if the string is a palindrome ignoring case sensitivity and alphabetic character positions. >>> is_palindrome(\\"AmanaplanacanalPanama\\") \\"YES\\" >>> is_palindrome(\\"HelloWorld\\") \\"NO\\" >>> is_palindrome(\\"\\") \\"YES\\" >>> is_palindrome(\\"a\\") \\"YES\\" >>> is_palindrome(\\"A\\") \\"YES\\" >>> is_palindrome(\\"MadAm\\") \\"YES\\" >>> is_palindrome(\\"RaceCarPython\\") \\"NO\\" >>> is_palindrome(\\"12321\\") \\"YES\\" >>> is_palindrome(\\"1a2b2a1\\") \\"YES\\" >>> is_palindrome(\\"12345\\") \\"NO\\"","solution":"def is_palindrome(s): Returns \\"YES\\" if the string \`s\` is a palindrome ignoring case sensitivity, otherwise returns \\"NO\\". s = s.lower() # Convert string to lowercase return \\"YES\\" if s == s[::-1] else \\"NO\\""},{"question":"from typing import List def parse_input(n: int, c: int, employee_lines: List[str]) -> int: Find the minimal number of employees that need to be selected to ensure that at least one member from any committee is selected. >>> parse_input(5, 3, [\\"1 2 1 2\\", \\"1 1 3\\", \\"2 1 1\\", \\"2 2 2 3\\", \\"2 0\\"]) 2 >>> parse_input(4, 2, [\\"1 1 1\\", \\"2 1 2\\", \\"1 1 2\\", \\"2 1 1\\"]) 2 >>> parse_input(1, 1, [\\"1 1 1\\"]) 1 >>> parse_input(3, 2, [\\"1 2 1 2\\", \\"2 2 1 2\\", \\"3 2 1 2\\"]) 1 >>> parse_input(2, 1, [\\"1 0\\", \\"2 1 1\\"]) 1","solution":"from itertools import combinations def minimal_employees_to_cover_committees(n, c, employees): committees = [set() for _ in range(c)] for idx, emp in enumerate(employees): for committee in emp[2:]: committees[committee-1].add(idx+1) selected_employees = set() def is_covered(selected): for committee in committees: if not any(emp in selected for emp in committee): return False return True for size in range(1, n+1): for comb in combinations(range(1, n+1), size): if is_covered(comb): return len(comb) return n # Function to be used in testing def parse_input(n, c, employee_lines): employees = [list(map(int, line.split())) for line in employee_lines] return minimal_employees_to_cover_committees(n, c, employees)"},{"question":"def longest_subsequence(s: str, words: List[str]) -> int: Determine the length of the longest string that can be formed by deleting some characters of the given string so that it becomes a subsequence of a word in the dictionary. >>> longest_subsequence(\\"abppplee\\", [\\"able\\", \\"ale\\", \\"apple\\", \\"bale\\", \\"kangaroo\\", \\"app\\"]) 5 >>> longest_subsequence(\\"abcdef\\", [\\"fed\\", \\"abc\\", \\"abf\\", \\"ace\\"]) 3","solution":"def is_subsequence(sub, main): it = iter(main) return all(char in it for char in sub) def longest_subsequence(s, words): longest = 0 for word in words: if is_subsequence(word, s): longest = max(longest, len(word)) return longest"},{"question":"from typing import List def is_path_exists(R: int, C: int, Sr: int, Sc: int, Tr: int, Tc: int, grid: List[str]) -> str: Determine if there is a path from (Sr, Sc) to (Tr, Tc) through free cells and find the minimum number of steps. >>> is_path_exists(5, 5, 1, 1, 5, 5, [\\".....\\", \\".B...\\", \\"..B..\\", \\"B....\\", \\".....\\"]) 'YES 8' >>> is_path_exists(3, 3, 1, 1, 3, 3, [\\".B.\\", \\"B.B\\", \\".B.\\"]) 'NO' >>> is_path_exists(2, 2, 1, 1, 2, 2, [\\"..\\", \\"..\\"]) 'YES 2' >>> is_path_exists(3, 3, 1, 1, 3, 3, [\\"B.B\\", \\"B.B\\", \\"B.B\\"]) 'NO' >>> is_path_exists(10, 10, 1, 1, 10, 10, [\\"..........\\", \\".BBBBBBBB.\\", \\"..........\\", \\".BBBBBBBB.\\", \\"..........\\", \\".BBBBBBBB.\\", \\"..........\\", \\".BBBBBBBB.\\", \\"..........\\", \\"..........\\"]) 'YES 18'","solution":"from collections import deque def is_path_exists(R, C, Sr, Sc, Tr, Tc, grid): Sr, Sc, Tr, Tc = Sr - 1, Sc - 1, Tr - 1, Tc - 1 if grid[Sr][Sc] == 'B' or grid[Tr][Tc] == 'B': return \\"NO\\" directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(Sr, Sc)]) visited = set([(Sr, Sc)]) steps = 0 while queue: for _ in range(len(queue)): x, y = queue.popleft() if (x, y) == (Tr, Tc): return f\\"YES {steps}\\" for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) steps += 1 return \\"NO\\""},{"question":"def check_special_candy_packets(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determine if there exists at least one quadruplet (i,j,k,l) such that the sum of the weights of packets at indices i, j equals the sum of the weights of packets at indices k, l and (i, j) is not (k, l). pass def process_input(input_data: str) -> Tuple[int, List[Tuple[int, List[int]]]]: Parse the input data. >>> input_data = \\"2n4n1 3 2 4n5n1 5 5 1 1n\\" >>> process_input(input_data) (2, [(4, [1, 3, 2, 4]), (5, [1, 5, 5, 1, 1])]) pass # Unit Tests from solution import check_special_candy_packets, process_input def test_basic(): input_data = \\"2n4n1 3 2 4n5n1 5 5 1 1n\\" t, test_cases = process_input(input_data) results = check_special_candy_packets(t, test_cases) assert results == [\\"YES\\", \\"YES\\"] def test_no_special_pairs(): input_data = \\"2n3n1 2 4n4n1 2 3 7n\\" t, test_cases = process_input(input_data) results = check_special_candy_packets(t, test_cases) assert results == [\\"NO\\", \\"NO\\"] def test_all_equal_weights(): input_data = \\"1n4n1 1 1 1n\\" t, test_cases = process_input(input_data) results = check_special_candy_packets(t, test_cases) assert results == [\\"YES\\"] def test_large_input(): input_data = \\"1n6n1 2 3 4 5 5n\\" t, test_cases = process_input(input_data) results = check_special_candy_packets(t, test_cases) assert results == [\\"YES\\"] def test_varied_weights(): input_data = \\"1n5n2 2 1 1 3n\\" t, test_cases = process_input(input_data) results = check_special_candy_packets(t, test_cases) assert results == [\\"YES\\"]","solution":"def check_special_candy_packets(t, test_cases): results = [] for case in test_cases: n, weights = case sums = {} found = False for i in range(n): for j in range(i + 1, n): s = weights[i] + weights[j] if s in sums: sums[s].append((i, j)) if len(sums[s]) > 1: results.append(\\"YES\\") found = True break else: sums[s] = [(i, j)] if found: break if not found: results.append(\\"NO\\") return results # Reading input values def process_input(input_data): lines = input_data.strip().split(\\"n\\") t = int(lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(lines[index]) weights = list(map(int, lines[index + 1].split())) test_cases.append((n, weights)) index += 2 return t, test_cases"},{"question":"def max_non_adjacent_sum(cards): Given a list of integers representing card values, this function returns the maximum sum of non-adjacent card values. def find_max_sums(test_cases): Given a list of test cases, where each test case is a tuple containing an integer n (number of cards) and a list of n integers (card values), this function returns a list of integers representing the maximum sum of non-adjacent cards for each test case. # Example Usage # test_cases = [(5, [3, 2, 5, 10, 7]), (3, [2, 1, 3]), (4, [3, 2, 7, 10])] # print(find_max_sums(test_cases)) # Output: [15, 5, 13] # Unit Test def test_single_set(): assert find_max_sums([(5, [3, 2, 5, 10, 7])]) == [15] def test_multiple_sets(): assert find_max_sums([(3, [2, 1, 3]), (4, [3, 2, 7, 10])]) == [5, 13] def test_no_cards(): assert find_max_sums([(0, [])]) == [0] def test_single_card(): assert find_max_sums([(1, [10])]) == [10] def test_two_cards(): assert find_max_sums([(2, [2, 1])]) == [2] def test_all_zeros(): assert find_max_sums([(3, [0, 0, 0])]) == [0] def test_alternating_large_small(): assert find_max_sums([(4, [1, 100, 1, 100])]) == [200]","solution":"def max_non_adjacent_sum(cards): Given a list of integers representing card values, this function returns the maximum sum of non-adjacent card values. if not cards: return 0 n = len(cards) if n == 1: return cards[0] dp = [0] * n dp[0] = cards[0] dp[1] = max(cards[0], cards[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + cards[i]) return dp[-1] def find_max_sums(test_cases): results = [] for n, cards in test_cases: results.append(max_non_adjacent_sum(cards)) return results # Example Usage: # test_cases = [(5, [3, 2, 5, 10, 7]), (3, [2, 1, 3]), (4, [3, 2, 7, 10])] # print(find_max_sums(test_cases)) # Output: [15, 5, 13]"},{"question":"def second_largest_unique(numbers: List[int]) -> int: Returns the second largest unique number in the list. If there is no such number, returns -1. >>> second_largest_unique([4, 1, 2, 3, 1, 2]) 3 >>> second_largest_unique([10, 20, 20, 8, 4, 8]) 10 >>> second_largest_unique([5, 3, 5]) 3 >>> second_largest_unique([7]) -1","solution":"def second_largest_unique(numbers): Returns the second largest unique number in the list. If there is no such number, returns -1. unique_numbers = set(numbers) if len(unique_numbers) < 2: return -1 sorted_unique_numbers = sorted(unique_numbers, reverse=True) return sorted_unique_numbers[1]"},{"question":"from typing import List, Tuple def is_strobogrammatic(num_str: str) -> bool: Check if a given number string is strobogrammatic. >>> is_strobogrammatic(\\"69\\") True >>> is_strobogrammatic(\\"962\\") False pass def strobogrammatic_count(low: str, high: str) -> int: Count the number of strobogrammatic numbers in the range [low, high]. >>> strobogrammatic_count(\\"50\\", \\"100\\") 3 >>> strobogrammatic_count(\\"0\\", \\"9\\") 3 pass def solve(test_cases: List[Tuple[str, str]]) -> List[int]: Solves multiple test cases of counting strobogrammatic numbers in a given range. >>> solve([(\\"50\\", \\"100\\"), (\\"0\\", \\"9\\")]) [3, 3] >>> solve([(\\"0\\", \\"1\\"), (\\"8\\", \\"88\\")]) [2, 4] pass","solution":"def is_strobogrammatic(num_str): mapping = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'} rotated = [] for char in reversed(num_str): if char not in mapping: return False rotated.append(mapping[char]) return \\"\\".join(rotated) == num_str def strobogrammatic_count(low, high): count = 0 for num in range(int(low), int(high) + 1): if is_strobogrammatic(str(num)): count += 1 return count def solve(test_cases): results = [] for low, high in test_cases: count = strobogrammatic_count(low, high) results.append(count) return results"},{"question":"def minimum_moves_to_reach_largest(n: int, m: int, grid: List[List[int]]) -> int: Given a grid of size n by m filled with unique integers, finds the minimum number of moves required to reach the cell with the largest integer starting from the cell with the smallest integer. In each move, you can go to an adjacent cell (up, down, left, or right). >>> n, m = 3, 3 >>> grid = [ ... [1, 3, 9], ... [8, 5, 2], ... [4, 7, 6] ... ] >>> minimum_moves_to_reach_largest(n, m, grid) 2 >>> n, m = 1, 2 >>> grid = [ ... [2, 1] ... ] >>> minimum_moves_to_reach_largest(n, m, grid) 1","solution":"def minimum_moves_to_reach_largest(n, m, grid): # Create a dictionary to store the position of each number in the grid. position_dict = {} for i in range(n): for j in range(m): position_dict[grid[i][j]] = (i, j) # Find the position of the smallest and largest numbers in the grid. min_pos = position_dict[min(position_dict.keys())] max_pos = position_dict[max(position_dict.keys())] # Calculate the minimum number of moves using the Manhattan distance. min_moves = abs(min_pos[0] - max_pos[0]) + abs(min_pos[1] - max_pos[1]) return min_moves"},{"question":"def felic_sequence(n: int) -> str: Generate a Felic Sequence of length n or determine if it's impossible. >>> felic_sequence(3) \\"2 1 3\\" >>> felic_sequence(4) \\"1 3 2 4\\" >>> felic_sequence(2) \\"Impossible\\" pass","solution":"def felic_sequence(n): Generate a Felic Sequence of length n or determine if it's impossible. if n == 2: return \\"Impossible\\" sequence = [] if n % 2 == 1: for i in range(2, n+1, 2): sequence.append(i) for i in range(1, n+1, 2): sequence.append(i) else: for i in range(1, n+1, 2): sequence.append(i) for i in range(2, n+1, 2): sequence.append(i) return \\" \\".join(map(str, sequence))"},{"question":"def determine_winner(n: int, sequence: List[int]) -> str: Determines the winning player in the game. Alex wins if there is at least one zero in the sequence; otherwise, Bryn wins. Args: n (int): The length of the sequence. sequence (list of int): The elements of the sequence. Returns: str: \\"Alex\\" if Alex wins, otherwise \\"Bryn\\". >>> determine_winner(5, [1, -1, 0, 2, 3]) \\"Alex\\" >>> determine_winner(3, [1, 2, 3]) \\"Bryn\\" >>> determine_winner(3, [0, 0, 0]) \\"Bryn\\" >>> determine_winner(7, [-4, 0, 0, 0, 2, 1, 0]) \\"Alex\\" >>> determine_winner(5, [1000000000, -1000000000, 500, -500, 1]) \\"Bryn\\"","solution":"def determine_winner(n, sequence): Determines the winning player in the game. Alex wins if there is at least one zero in the sequence; otherwise, Bryn wins. Args: n (int): The length of the sequence. sequence (list of int): The elements of the sequence. Returns: str: \\"Alex\\" if Alex wins, otherwise \\"Bryn\\". # Check if there is at least one zero in the sequence if 0 in sequence: return \\"Alex\\" else: return \\"Bryn\\""},{"question":"def max_rect_in_grid(matrix: List[List[int]]) -> int: Find the maximum size of a rectangular block of available spaces in the given grid. >>> max_rect_in_grid([ [0, 1, 1, 0, 0], [0, 1, 1, 0, 0], [1, 0, 0, 1, 1], [0, 0, 0, 1, 0] ]) 4 >>> max_rect_in_grid([ [1, 0, 1, 0, 0] ]) 2","solution":"def max_rect_in_grid(matrix): if not matrix: return 0 max_area = 0 rows = len(matrix) cols = len(matrix[0]) heights = [0] * (cols + 1) for row in matrix: for i in range(cols): if row[i] == 0: heights[i] += 1 else: heights[i] = 0 stack = [-1] for i in range(cols + 1): while heights[i] < heights[stack[-1]]: h = heights[stack.pop()] w = i - stack[-1] - 1 max_area = max(max_area, h * w) stack.append(i) return max_area"},{"question":"def common_snacks(T: int, test_cases: List[Tuple[List[str], List[str], List[str]]]) -> List[str]: Find the common snacks among three lists of favorite snacks for T test cases. Args: T (int): The number of test cases. test_cases (List[Tuple[List[str], List[str], List[str]]]): Each test case is a tuple of three lists representing the favorite snacks of Alex, Bob, and Charlie. Returns: List[str]: The common snacks loved by all three friends in each test case, sorted lexicographically. If none, return 'None'. Example: >>> common_snacks(2, [ [\\"3 popcorn chips soda\\".split(), \\"3 chips popcorn candy\\".split(), \\"4 popcorn chips candy pretzels\\".split()], [\\"2 nachos pizza\\".split(), \\"3 burger pizza nachos\\".split(), \\"3 fries pizza nachos\\".split()] ]) ['chips popcorn', 'nachos pizza'] >>> common_snacks(1, [ [\\"3 popcorn chips soda\\".split(), \\"3 candy chocolate gum\\".split(), \\"4 pretzels cookies muffins\\".split()] ]) ['None']","solution":"def common_snacks(T, test_cases): result = [] for i in range(T): alex_snacks = set(test_cases[i][0][1:]) bob_snacks = set(test_cases[i][1][1:]) charlie_snacks = set(test_cases[i][2][1:]) common = sorted(alex_snacks & bob_snacks & charlie_snacks) if common: result.append(' '.join(common)) else: result.append(\\"None\\") return result def process_input(input_str): lines = input_str.strip().split('n') T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): alex = lines[index].split() bob = lines[index+1].split() charlie = lines[index+2].split() test_cases.append((alex, bob, charlie)) index += 3 return T, test_cases def formatted_output(output_list): return 'n'.join(output_list)"},{"question":"def find_initial_position(n: int, k: int) -> int: Determines the initial position of the carousel that will display the target image first. Parameters: n (int): Total number of images. k (int): Position of the target image (1-based index). Returns: int: Initial position of the carousel (0-based index) that will display the target image first. Examples: >>> find_initial_position(5, 3) 2 >>> find_initial_position(8, 1) 0","solution":"def find_initial_position(n, k): Determines the initial position of the carousel that will display the target image first. Parameters: n (int): Total number of images. k (int): Position of the target image (1-based index). Returns: int: Initial position of the carousel (0-based index) that will display the target image first. # converting 1-based index to 0-based index return k - 1"},{"question":"def min_operations_to_non_decreasing_sequence(n: int, sequence: List[int], a: int, b: int) -> int: This function returns the minimum number of operations needed to make the sequence non-decreasing by making any elements zero either by \`a\` or \`b\` operations for even and odd numbers respectively. >>> min_operations_to_non_decreasing_sequence(5, [4, 2, 5, 3, 6], 2, 3) 5 >>> min_operations_to_non_decreasing_sequence(4, [-1, -3, 2, 6], 1, 2) 2","solution":"def min_operations_to_non_decreasing_sequence(n, sequence, a, b): This function returns the minimum number of operations needed to make the sequence non-decreasing by making any elements zero either by \`a\` or \`b\` operations for even and odd numbers respectively. # Create an array to store the minimum operations needed for each prefix of the array dp = [0] * n # Initialize the total cost to to make the first element zero (if required) dp[0] = 0 for i in range(1, n): dp[i] = dp[i-1] if sequence[i] < sequence[i-1]: if sequence[i] % 2 == 0: dp[i] += a else: dp[i] += b sequence[i] = 0 # make it zero return dp[-1]"},{"question":"def is_subsequence(s: str, word: str) -> bool: Check if word is a subsequence of the string s. # Implement this function def count_subsequences(s: str, words: List[str]) -> int: Count how many words in the words list are subsequences of s. # Implement this function def main(input_str: str) -> int: Given input string in the specified format, return the number of words that are subsequences of the main string s. Example usage: >>> main(\\"abpcplean3nalenapplenmonkey\\") 2 >>> main(\\"abcdefn5nanbncdnabcnabcdef\\") 5 # Implement this function from typing import List def test_is_subsequence(): assert is_subsequence(\\"abpcplea\\", \\"ale\\") == True assert is_subsequence(\\"abpcplea\\", \\"apple\\") == True assert is_subsequence(\\"abpcplea\\", \\"monkey\\") == False assert is_subsequence(\\"abcdef\\", \\"a\\") == True assert is_subsequence(\\"abcdef\\", \\"z\\") == False def test_count_subsequences(): assert count_subsequences(\\"abpcplea\\", [\\"ale\\", \\"apple\\", \\"monkey\\"]) == 2 assert count_subsequences(\\"abcdef\\", [\\"a\\", \\"b\\", \\"cd\\", \\"abc\\", \\"abcdef\\"]) == 5 assert count_subsequences(\\"xyz\\", [\\"xzy\\", \\"xy\\", \\"yz\\", \\"zxy\\"]) == 2 def test_main(): input_str1 = \\"abpcplean3nalenapplenmonkey\\" assert main(input_str1) == 2 input_str2 = \\"abcdefn5nanbncdnabcnabcdef\\" assert main(input_str2) == 5 input_str3 = \\"xyzn4nxzynxynyznzxy\\" assert main(input_str3) == 2","solution":"def is_subsequence(s, word): Check if word is a subsequence of string s. it = iter(s) return all(char in it for char in word) def count_subsequences(s, words): Count how many words in the list are subsequences of s. return sum(1 for word in words if is_subsequence(s, word)) def main(input_str): lines = input_str.strip().split('n') s = lines[0] n = int(lines[1]) words = lines[2:2+n] return count_subsequences(s, words)"},{"question":"def matrix_multiply(m, n, p, A, B): Computes the resulting matrix C from the multiplication of two matrices A and B. Parameters: m (int): number of rows in matrix A n (int): number of columns in matrix A and rows in matrix B p (int): number of columns in matrix B A (List[List[int]]): matrix A B (List[List[int]]): matrix B Returns: List[List[int]]: resulting matrix C Example: >>> matrix_multiply(2, 3, 3, [[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12], [13, 14, 15]]) [[66, 72, 78], [156, 171, 186]] >>> matrix_multiply(3, 2, 2, [[1, 2], [3, 4], [5, 6]], [[7, 8], [9, 10]]) [[25, 28], [57, 64], [89, 100]]","solution":"def matrix_multiply(m, n, p, A, B): Multiplies two matrices A and B. # Initialize resulting matrix C with zeros C = [[0] * p for _ in range(m)] # Perform matrix multiplication for i in range(m): for j in range(p): for k in range(n): C[i][j] += A[i][k] * B[k][j] return C"},{"question":"def is_valid_password(password: str) -> bool: Validates if the provided password meets the following security criteria: 1. It must contain at least one lowercase letter. 2. It must contain at least one uppercase letter. 3. It must contain at least one digit. 4. It must be at least 8 characters long. 5. It must not contain any spaces. >>> is_valid_password('Password123') True >>> is_valid_password('password123') False >>> is_valid_password('PASSWORD123') False >>> is_valid_password('Password') False >>> is_valid_password('Short1') False >>> is_valid_password('Pass word1') False >>> is_valid_password('Valid1Password') True >>> is_valid_password('A1b2C3d4') True >>> is_valid_password('a1b2c3d4') False >>> is_valid_password('Abcdefgh') False","solution":"def is_valid_password(password): Checks if the given password is valid based on the following conditions: 1. It must contain at least one lowercase letter. 2. It must contain at least one uppercase letter. 3. It must contain at least one digit. 4. It must be at least 8 characters long. 5. It must not contain any spaces. if len(password) < 8: return False has_lower = any(char.islower() for char in password) has_upper = any(char.isupper() for char in password) has_digit = any(char.isdigit() for char in password) has_space = any(char.isspace() for char in password) return has_lower and has_upper and has_digit and not has_space"},{"question":"def minimum_cost_to_light(n: int, m: int, k: int, edges: List[List[int]], important_nodes: List[int], s: int, t: int) -> int: Function to find the minimum magical cost to light up node t starting from node s. :param n: Number of nodes :param m: Number of edges :param k: Number of important nodes :param edges: List of edges [u, v, w] :param important_nodes: List of important nodes :param s: Starting node :param t: Target important node :return: Minimum cost to light up t from s pass","solution":"import heapq def minimum_cost_to_light(n, m, k, edges, important_nodes, s, t): Function to find the minimum magical cost to light up node t starting from node s. :param n: Number of nodes :param m: Number of edges :param k: Number of important nodes :param edges: List of edges [u, v, w] :param important_nodes: List of important nodes :param s: Starting node :param t: Target important node :return: Minimum cost to light up t from s # Graph representation graph = {i: [] for i in range(1, n+1)} for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Dijkstra's algorithm to find the shortest path from s to all nodes def dijkstra(start): min_heap = [(0, start)] # (distance, node) distances = {i: float('inf') for i in range(1, n+1)} distances[start] = 0 while min_heap: current_dist, u = heapq.heappop(min_heap) if current_dist > distances[u]: continue for v, weight in graph[u]: dist = current_dist + weight if dist < distances[v]: distances[v] = dist heapq.heappush(min_heap, (dist, v)) return distances distances_from_s = dijkstra(s) # The minimum cost to reach target important node t from starting node s min_cost = distances_from_s[t] return min_cost"},{"question":"def final_string_length(s: str) -> int: Returns the length of the string after performing all possible adjacent pair removals. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the remaining string after all possible operations. >>> final_string_length(\\"abbaca\\") 2 >>> final_string_length(\\"aabccba\\") 1","solution":"def final_string_length(s): Returns the length of the string after performing all possible adjacent pair removals. Args: s (str): The input string consisting of lowercase English letters. Returns: int: The length of the remaining string after all possible operations. stack = [] for char in s: if stack and stack[-1] == char: stack.pop() else: stack.append(char) return len(stack)"},{"question":"def autocomplete(n: int, snippets: List[str], current_input: str) -> str: Suggest the most appropriate snippet based on the current input. If there are multiple possible completions, suggest the snippet which comes first alphabetically. If no snippet starts with the input, return 'No suggestion'. >>> autocomplete(3, [\\"hello world\\", \\"hi there\\", \\"how are you\\"], \\"he\\") \\"hello world\\" >>> autocomplete(4, [\\"example snippet\\", \\"another one\\", \\"yet another\\", \\"sample text\\"], \\"yet\\") \\"yet another\\" >>> autocomplete(2, [\\"example snippet\\", \\"another one\\"], \\"nonexistent\\") \\"No suggestion\\" >>> autocomplete(3, [\\"banana bread\\", \\"apple pie\\", \\"orange juice\\"], \\"\\") \\"apple pie\\" >>> autocomplete(3, [\\"good morning\\", \\"good night\\", \\"good afternoon\\"], \\"good night\\") \\"good night\\" >>> autocomplete(3, [\\"abcdefg\\", \\"abchijk\\", \\"abclmnop\\"], \\"abc\\") \\"abcdefg\\" >>> autocomplete(1, [\\"unique snippet\\"], \\"\\") \\"unique snippet\\" >>> autocomplete(0, [], \\"input\\") \\"No suggestion\\"","solution":"def autocomplete(n, snippets, current_input): suggestions = [snippet for snippet in snippets if snippet.startswith(current_input)] if not suggestions: return \\"No suggestion\\" return min(suggestions) # Example usage n = 3 snippets = [\\"hello world\\", \\"hi there\\", \\"how are you\\"] current_input = \\"he\\" print(autocomplete(n, snippets, current_input)) # Output should be \\"hello world\\""},{"question":"from typing import List, Union def create_balanced_schedule(n: int, preferences: List[str]) -> Union[str, List[str]]: Determine if it is possible to create a balanced schedule for a coding marathon. A balanced schedule is defined as one where the difference between the number of participants in any two parts of the day does not exceed one. Args: n (int): The number of participants. preferences (List[str]): List of preferences of the participants. Each element is either \\"morning\\", \\"afternoon\\", or \\"evening\\". Returns: Union[str, List[str]]: \\"NO\\" if a balanced schedule is not possible. Otherwise, returns a list where the first element is \\"YES\\" followed by the schedule. Example: >>> create_balanced_schedule(6, [\\"morning\\", \\"evening\\", \\"afternoon\\", \\"morning\\", \\"evening\\", \\"afternoon\\"]) [\\"YES\\", \\"morning\\", \\"evening\\", \\"afternoon\\", \\"morning\\", \\"evening\\", \\"afternoon\\"] >>> create_balanced_schedule(5, [\\"morning\\", \\"morning\\", \\"morning\\", \\"afternoon\\", \\"evening\\"]) \\"NO\\"","solution":"def create_balanced_schedule(n, preferences): from collections import Counter # Count the prefences preference_count = Counter(preferences) morning_count = preference_count['morning'] afternoon_count = preference_count['afternoon'] evening_count = preference_count['evening'] # Check if balanced schedule is possible if max(morning_count, afternoon_count, evening_count) - min(morning_count, afternoon_count, evening_count) > 1: return \\"NO\\" return [\\"YES\\"] + preferences"},{"question":"def max_sum_of_two_largest(n: int, sequence: List[int]) -> int: Given a sequence of 'n' integers, this function finds the maximum possible sum of the two largest integers in any contiguous subarray. >>> max_sum_of_two_largest(6, [1, 2, 3, 4, 5, 6]) 11 >>> max_sum_of_two_largest(5, [9, 1, 5, 3, 8]) 17 >>> max_sum_of_two_largest(4, [10, 20, 10, 20]) 40 pass def test_max_sum_of_two_largest(): assert max_sum_of_two_largest(6, [1, 2, 3, 4, 5, 6]) == 11 assert max_sum_of_two_largest(5, [9, 1, 5, 3, 8]) == 17 assert max_sum_of_two_largest(4, [10, 20, 10, 20]) == 40 assert max_sum_of_two_largest(2, [1, 100]) == 101 assert max_sum_of_two_largest(3, [1, 1, 1]) == 2 if __name__ == \\"__main__\\": test_max_sum_of_two_largest() print(\\"All tests passed!\\")","solution":"def max_sum_of_two_largest(n, sequence): Given a sequence of 'n' integers, this function finds the maximum possible sum of the two largest integers in any contiguous subarray. max1, max2 = 0, 0 for num in sequence: if num > max1: max1, max2 = num, max1 elif num > max2: max2 = num return max1 + max2"},{"question":"def sort_employees(employee_list): Sorts the employees by their salary in non-decreasing order. If two employees have the same salary, sorts by their names in lexicographical order. >>> sort_employees([(\\"Alice\\", 3000), (\\"Bob\\", 4000), (\\"Eve\\", 3000), (\\"Charlie\\", 4000), (\\"David\\", 3500)]) [(\\"Alice\\", 3000), (\\"Eve\\", 3000), (\\"David\\", 3500), (\\"Bob\\", 4000), (\\"Charlie\\", 4000)] >>> sort_employees([(\\"Alice\\", 3000)]) [(\\"Alice\\", 3000)] pass def format_employee_list(employee_list): Formats the sorted employee list into the desired output format. >>> format_employee_list([(\\"Alice\\", 3000)]) 'Alice 3000' >>> format_employee_list([(\\"Alice\\", 3000), (\\"Eve\\", 3000), (\\"David\\", 3500)]) 'Alice 3000nEve 3000nDavid 3500' pass","solution":"def sort_employees(employee_list): Sorts the employees by their salary in non-decreasing order. If two employees have the same salary, sorts by their names in lexicographical order. sorted_employees = sorted(employee_list, key=lambda x: (x[1], x[0])) return sorted_employees def format_employee_list(employee_list): Formats the sorted employee list into the desired output format. return \\"n\\".join(f\\"{name} {salary}\\" for name, salary in employee_list)"},{"question":"def max_non_overlapping_events(n, events): Computes the maximum number of non-overlapping events that can be attended. >>> max_non_overlapping_events(5, [(1, 4), (2, 3), (3, 5), (7, 9), (6, 8)]) 3 >>> max_non_overlapping_events(0, []) 0 >>> max_non_overlapping_events(3, [(1, 2), (3, 4), (5, 6)]) 3 >>> max_non_overlapping_events(3, [(1, 5), (2, 6), (3, 7)]) 1 >>> max_non_overlapping_events(4, [(1, 3), (2, 4), (3, 5), (5, 7)]) 3","solution":"def max_non_overlapping_events(n, events): Computes the maximum number of non-overlapping events that can be attended. :param n: int - number of events :param events: list of tuples, where each tuple contains (start, end) times of an event :return: int - maximum number of non-overlapping events if n == 0: return 0 # Sort events by their end time events.sort(key=lambda x: x[1]) # Initialize variables count = 1 last_end_time = events[0][1] # Iterate through the events checking for overlaps for i in range(1, n): if events[i][0] >= last_end_time: count += 1 last_end_time = events[i][1] return count # Reading input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) events = [(int(data[i]), int(data[i + 1])) for i in range(1, len(data), 2)] print(max_non_overlapping_events(n, events))"},{"question":"def min_deletions(s: str) -> int: Returns the minimum number of deletions needed so that no two consecutive characters are the same. >>> min_deletions(\\"AABB\\") 2 >>> min_deletions(\\"ABABAB\\") 0 >>> min_deletions(\\"AAA\\") 2 >>> min_deletions(\\"BBBB\\") 3","solution":"def min_deletions(s): Returns the minimum number of deletions needed so that no two consecutive characters are the same. deletions = 0 for i in range(1, len(s)): if s[i] == s[i - 1]: deletions += 1 return deletions"},{"question":"def has_triplet_sum(arr, target): Determines if there exists a triplet in the array that sums up to the target value. >>> has_triplet_sum([1, 2, 3, 4, 5, 6], 10) True >>> has_triplet_sum([-1, 0, 1, 2], 0) True >>> has_triplet_sum([1, 2, 3, 4, 5, 6], 20) False >>> has_triplet_sum([0, 0, 0, 0], 1) False # implementation here def process_test_cases(test_cases): Processes multiple test cases to determine if they have a triplet sum equal to the target. >>> process_test_cases([(6, 10, [1, 2, 3, 4, 5, 6]), (4, 0, [-1, 0, 1, 2])]) [True, True] >>> process_test_cases([(4, 12, [1, 1, 1, 1]), (5, 7, [5, 5, 5, 5, 5])]) [False, False] # implementation here","solution":"def has_triplet_sum(arr, target): Determines if there exists a triplet in the array that sums up to the target value. arr.sort() n = len(arr) for i in range(n - 2): left, right = i + 1, n - 1 while left < right: triplet_sum = arr[i] + arr[left] + arr[right] if triplet_sum == target: return True elif triplet_sum < target: left += 1 else: right -= 1 return False def process_test_cases(test_cases): results = [] for case in test_cases: n, target, arr = case result = has_triplet_sum(arr, target) results.append(result) return results"},{"question":"def game_outcome(N: int) -> str: Determines the outcome of the game for a given N. Returns \\"First\\" if the first player wins, \\"Second\\" if the second player wins. >>> game_outcome(2) 'First' >>> game_outcome(3) 'Second' >>> game_outcome(4) 'First' >>> game_outcome(5) 'Second' >>> game_outcome(6) 'First' >>> game_outcome(7) 'Second' >>> game_outcome(8) 'First' def solve(t: int, cases: List[int]) -> List[str]: Solve multiple test cases of the game. Args: t: An integer, the number of test cases. cases: A list of integers, each representing the given N for that test case. Returns: A list of strings, each representing the outcome (\\"First\\" or \\"Second\\") for each test case. >>> solve(3, [2, 3, 4]) ['First', 'Second', 'First'] >>> solve(5, [7, 8, 9, 10, 11]) ['Second', 'First', 'Second', 'First', 'Second'] >>> solve(1, [2]) ['First'] >>> solve(1, [3]) ['Second'] >>> solve(2, [1, 1000000]) ['Second', 'First'] # Edge cases, though N should start from 2 as per prompt.","solution":"def game_outcome(N): Determines the outcome of the game for a given N. Returns \\"First\\" if the first player wins, \\"Second\\" if the second player wins. return \\"First\\" if N % 2 == 0 else \\"Second\\" def solve(t, cases): Solve multiple test cases of the game. Args: t: An integer, the number of test cases. cases: A list of integers, each representing the given N for that test case. Returns: A list of strings, each representing the outcome (\\"First\\" or \\"Second\\") for each test case. results = [] for N in cases: results.append(game_outcome(N)) return results"},{"question":"def evaluate_expression(expression: str) -> int: Evaluate a mathematical expression containing integer numbers, the operators + and -, and parentheses. Return the result. >>> evaluate_expression(\\"(-1+(2-3)+(4-5))\\") -3 >>> evaluate_expression(\\"1 + (2 + 3) - (4 - (5 + 6))\\") 13 >>> evaluate_expression(\\"- (3 + (2 - 1))\\") -4 pass","solution":"def evaluate_expression(expression: str) -> int: def evaluate(tokens): stack = [] current_number = 0 sign = 1 result = 0 while tokens: token = tokens.pop(0) if token.isdigit(): current_number = (current_number * 10) + int(token) elif token in \\"+-\\": result += sign * current_number current_number = 0 sign = 1 if token == '+' else -1 elif token == '(': result += sign * evaluate(tokens) current_number = 0 elif token == ')': result += sign * current_number return result result += sign * current_number return result tokens = list(expression.replace(' ', '')) return evaluate(tokens)"},{"question":"def restore_ip_addresses(s: str) -> List[str]: Return all possible valid IP address combinations from a given string of digits. >>> restore_ip_addresses(\\"25525511135\\") [\\"255.255.11.135\\", \\"255.255.111.35\\"] >>> restore_ip_addresses(\\"0000\\") [\\"0.0.0.0\\"] >>> restore_ip_addresses(\\"1111\\") [\\"1.1.1.1\\"]","solution":"def restore_ip_addresses(s): def is_valid(segment): return 0 <= int(segment) <= 255 and (segment == \\"0\\" or segment[0] != \\"0\\") def backtrack(start=0, end=1, current_parts=None): if current_parts is None: current_parts = [] if len(current_parts) == 4 and start == len(s): result.append(\\".\\".join(current_parts)) return elif len(current_parts) == 4: return for end in range(start + 1, min(len(s) + 1, start + 4)): segment = s[start:end] if is_valid(segment): backtrack(end, end + 1, current_parts + [segment]) result = [] backtrack() return result"},{"question":"def max_fully_satisfied_children(n: int, k: int, demands: List[int]) -> int: Determines the maximum number of fully satisfied children after distributing the given candies. >>> max_fully_satisfied_children(4, 7, [2, 3, 5, 1]) 3 >>> max_fully_satisfied_children(5, 10, [3, 3, 3, 3, 3]) 3 >>> max_fully_satisfied_children(3, 1, [1, 2, 3]) 1","solution":"def max_fully_satisfied_children(n, k, demands): Determines the maximum number of fully satisfied children after distributing the given candies. # Sort the demands in ascending order demands.sort() satisfied_children = 0 for demand in demands: if k >= demand: # Satisfy this child's demand k -= demand satisfied_children += 1 else: # Cannot satisfy further demands break return satisfied_children"},{"question":"def max_square_area(n: int, m: int) -> int: Computes the maximum possible total area of identical squares that can fit inside a rectangle of dimensions n x m. Args: n (int): The length of the rectangle. m (int): The width of the rectangle. Returns: int: The maximum area of the squares that can fit inside the rectangle. Examples: >>> max_square_area(6, 5) 25 >>> max_square_area(10, 4) 16","solution":"def max_square_area(n, m): Computes the maximum possible total area of identical squares that can fit inside a rectangle of dimensions n x m. Args: n (int): The length of the rectangle. m (int): The width of the rectangle. Returns: int: The maximum area of the squares that can fit inside the rectangle. # Find the side of the largest square that can fit completely into the rectangle side_length_of_square = min(n, m) # The largest possible square area that fits max_area = side_length_of_square ** 2 return max_area"},{"question":"def format_time(n: int) -> str: Convert seconds to a time string in the format HH:MM:SS Parameters: n (int): Total seconds Returns: str: Time in HH:MM:SS format pass def test_format_time_zero_seconds(): assert format_time(0) == \\"00:00:00\\" def test_format_time_only_seconds(): assert format_time(59) == \\"00:00:59\\" def test_format_time_only_minutes(): assert format_time(60) == \\"00:01:00\\" assert format_time(3599) == \\"00:59:59\\" # edge case just before an hour def test_format_time_only_hours(): assert format_time(3600) == \\"01:00:00\\" assert format_time(86399) == \\"23:59:59\\" # edge case just before a day def test_format_time_combined(): assert format_time(3661) == \\"01:01:01\\" # mixed components def test_format_time_large_number(): assert format_time(10000000) == \\"2777:46:40\\" # large n value","solution":"def format_time(n): Convert seconds to a time string in the format HH:MM:SS Parameters: n (int): Total seconds Returns: str: Time in HH:MM:SS format hours = n // 3600 minutes = (n % 3600) // 60 seconds = n % 60 return f\\"{hours:02}:{minutes:02}:{seconds:02}\\""},{"question":"def generate_perfect_binary_tree_labels(n: int) -> List[int]: Generate labels for a perfect binary tree with n levels such that the labels represent an in-order traversal. Params: - n (int): Number of levels in the binary tree. Returns: - List of integers representing node labels in level-order traversal.","solution":"def generate_perfect_binary_tree_labels(n): Generate labels for a perfect binary tree with n levels such that the labels represent an in-order traversal. Params: - n (int): Number of levels in the binary tree. Returns: - List of integers representing node labels in level-order traversal. def inorder_labels(root_index, nodes): Generate in-order labels recursively. Params: - root_index (int): The root index of the current subtree in a perfect binary tree. - nodes (list of int): A list where in-order indices will be stored. if root_index <= len(nodes): left_index = 2 * root_index right_index = 2 * root_index + 1 inorder_labels(left_index, nodes) # Traverse left subtree nodes[root_index - 1] = inorder_labels.current_label # Assign current label to the current root inorder_labels.current_label += 1 # Increment label for the subtree inorder_labels(right_index, nodes) # Traverse right subtree total_nodes = 2**n - 1 nodes = [0] * total_nodes inorder_labels.current_label = 1 # Start labeling from 1 inorder_labels(1, nodes) return nodes"},{"question":"def can_prepare_dish(required, available): Determines if all required ingredients are available in the kitchen. :param required: List of required ingredient names. :param available: List of available ingredient names. :return: \\"YES\\" if all required ingredients are available, otherwise \\"NO\\". >>> can_prepare_dish([\\"flour\\", \\"sugar\\", \\"eggs\\", \\"butter\\"], [\\"sugar\\", \\"flour\\", \\"eggs\\", \\"milk\\", \\"butter\\"]) \\"YES\\" >>> can_prepare_dish([\\"tomato\\", \\"onion\\", \\"garlic\\"], [\\"onion\\", \\"garlic\\", \\"potato\\"]) \\"NO\\" >>> can_prepare_dish([\\"salt\\", \\"pepper\\"], [\\"salt\\"]) \\"NO\\" >>> can_prepare_dish([], [\\"sugar\\", \\"flour\\", \\"eggs\\", \\"milk\\", \\"butter\\"]) \\"YES\\" >>> can_prepare_dish([\\"flour\\", \\"sugar\\", \\"eggs\\", \\"butter\\"], []) \\"NO\\" >>> can_prepare_dish([\\"flour\\", \\"sugar\\", \\"eggs\\", \\"butter\\"], [\\"flour\\", \\"sugar\\", \\"eggs\\", \\"butter\\"]) \\"YES\\"","solution":"def can_prepare_dish(required, available): Determines if all required ingredients are available in the kitchen. :param required: List of required ingredient names. :param available: List of available ingredient names. :return: \\"YES\\" if all required ingredients are available, otherwise \\"NO\\". required_set = set(required) available_set = set(available) if required_set.issubset(available_set): return \\"YES\\" else: return \\"NO\\""},{"question":"def find_max_block_size(n: int, grid: List[List[int]]) -> int: Calculate the maximum block size in the grid-like map of the city. >>> find_max_block_size(4, [[3, 3, 4, 4], [3, 2, 2, 4], [3, 2, 4, 1], [0, 0, 1, 1]]) 4 >>> find_max_block_size(1, [[5]]) 1 >>> find_max_block_size(3, [[7, 7, 7], [7, 7, 7], [7, 7, 7]]) 9 >>> find_max_block_size(2, [[1, 2], [3, 4]]) 1 >>> find_max_block_size(5, [[1, 1, 2, 2, 3], [1, 2, 2, 3, 3], [3, 3, 2, 1, 1], [3, 1, 1, 1, 2], [2, 2, 3, 2, 2]]) 5","solution":"def find_max_block_size(n, grid): def dfs(x, y, height): if x < 0 or x >= n or y < 0 or y >= n or grid[x][y] != height: return 0 grid[x][y] = -1 # mark as visited size = 1 for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]: size += dfs(x + dx, y + dy, height) return size max_block_size = 0 for i in range(n): for j in range(n): if grid[i][j] != -1: # not visited height = grid[i][j] max_block_size = max(max_block_size, dfs(i, j, height)) return max_block_size"},{"question":"def max_visitors(n: int, times: List[Tuple[str, str]]) -> int: Determine the maximum number of visitors present in the park at any given time during the day. >>> max_visitors(5, [(\\"05:00\\", \\"06:00\\"), (\\"06:00\\", \\"10:00\\"), (\\"07:00\\", \\"08:30\\"), (\\"08:00\\", \\"09:00\\"), (\\"08:15\\", \\"09:30\\")]) == 4 >>> max_visitors(3, [(\\"05:00\\", \\"06:00\\"), (\\"06:00\\", \\"07:00\\"), (\\"07:00\\", \\"08:00\\")]) == 1 >>> max_visitors(3, [(\\"05:00\\", \\"09:00\\"), (\\"05:00\\", \\"09:00\\"), (\\"05:00\\", \\"09:00\\")]) == 3 >>> max_visitors(3, [(\\"05:00\\", \\"07:00\\"), (\\"06:00\\", \\"08:00\\"), (\\"07:00\\", \\"09:00\\")]) == 2 >>> max_visitors(2, [(\\"05:00\\", \\"21:00\\"), (\\"05:01\\", \\"21:01\\")]) == 2 >>> max_visitors(1, [(\\"05:00\\", \\"21:00\\")]) == 1 >>> max_visitors(3, [(\\"08:00\\", \\"09:00\\"), (\\"08:00\\", \\"09:00\\"), (\\"08:00\\", \\"09:00\\")]) == 3 pass","solution":"def max_visitors(n, times): events = [] for entry, exit in times: events.append((entry, 1)) events.append((exit, -1)) events.sort() max_visitors = 0 current_visitors = 0 for time, visitor_change in events: current_visitors += visitor_change max_visitors = max(max_visitors, current_visitors) return max_visitors"},{"question":"def process_game_logs(n, logs): Process the game logs and sum up the resources for each player, then output the total resources collected by each player in alphabetical order of their names. Each player's resources should be sorted by the resource type character. >>> process_game_logs(5, [\\"alice A 3 B 4\\", \\"bob A 2\\", \\"alice C 1\\", \\"bob B 1\\", \\"charlie A 5\\"]) [\\"alice A 3 B 4 C 1\\", \\"bob A 2 B 1\\", \\"charlie A 5\\"] >>> process_game_logs(3, [\\"emma A 10\\", \\"david B 5 A 3\\", \\"emma B 2 C 4\\"]) [\\"david A 3 B 5\\", \\"emma A 10 B 2 C 4\\"]","solution":"def process_game_logs(n, logs): from collections import defaultdict player_resources = defaultdict(lambda: defaultdict(int)) # Process each log entry for log in logs: parts = log.split() player_name = parts[0] resource_info = parts[1:] # Update the resources for the player for i in range(0, len(resource_info), 2): resource = resource_info[i] quantity = int(resource_info[i + 1]) player_resources[player_name][resource] += quantity # Prepare output in the required format result = [] for player in sorted(player_resources.keys()): resources = player_resources[player] resources_str = \\"\\" for resource_type in sorted(resources.keys()): resources_str += f\\" {resource_type} {resources[resource_type]}\\" result.append(f\\"{player}{resources_str}\\") return result"},{"question":"def max_power(n: int, power_values: List[int]) -> int: Given the power values of the stones arranged in a line, determine the maximum possible total power value the player can collect. Parameters: n (int): Number of stones. power_values (list of int): Power values of the stones. Returns: int: Maximum possible total power value. Examples: >>> max_power(5, [4, 3, 2, 5, 1]) 9 >>> max_power(6, [1, 2, 3, 4, 5, 6]) 21","solution":"def max_power(n, power_values): Returns the maximum possible total power value the player can collect. Parameters: n (int): Number of stones. power_values (list of int): Power values of the stones. Returns: int: Maximum possible total power value. if n == 0: return 0 # Initialize an array to store the maximum power value that can be # collected up to each stone dp = [0] * n dp[0] = power_values[0] for i in range(1, n): for j in range(i): if power_values[i] > power_values[j]: dp[i] = max(dp[i], dp[j] + power_values[i]) # Always consider the case where the current stone is the first stone picked dp[i] = max(dp[i], power_values[i]) return max(dp)"},{"question":"def count_distinct_substrings(s: str) -> int: Returns the number of distinct substrings in the given string \`s\`. >>> count_distinct_substrings(\\"a\\") 1 >>> count_distinct_substrings(\\"ab\\") 3 >>> count_distinct_substrings(\\"aaa\\") 3 >>> count_distinct_substrings(\\"abc\\") 6 >>> count_distinct_substrings(\\"abac\\") 9 >>> count_distinct_substrings(\\"abcd\\") 10","solution":"def count_distinct_substrings(s): Returns the number of distinct substrings in the given string \`s\`. n = len(s) substrings = set() # Generate all possible substrings and store in a set to ensure uniqueness for i in range(n): for j in range(i + 1, n + 1): substrings.add(s[i:j]) return len(substrings)"},{"question":"def check_perfect_score(n: int, scores: List[int]) -> str: Determines if any student has scored a perfect score of 100. Parameters: n (int): The number of student scores (1  n  100). scores (List[int]): A list of n integers representing the scores of the students (0  score  100). Returns: str: \\"Perfect Score Achieved\\" if at least one student has scored 100, otherwise \\"No Perfect Score\\". Examples: >>> check_perfect_score(3, [99, 100, 87]) 'Perfect Score Achieved' >>> check_perfect_score(4, [75, 85, 90, 95]) 'No Perfect Score' >>> check_perfect_score(1, [100]) 'Perfect Score Achieved' from typing import List def test_check_perfect_score_example_1(): assert check_perfect_score(3, [99, 100, 87]) == \\"Perfect Score Achieved\\" def test_check_perfect_score_example_2(): assert check_perfect_score(4, [75, 85, 90, 95]) == \\"No Perfect Score\\" def test_check_perfect_score_example_3(): assert check_perfect_score(1, [100]) == \\"Perfect Score Achieved\\" def test_check_perfect_score_all_perfect(): assert check_perfect_score(5, [100, 100, 100, 100, 100]) == \\"Perfect Score Achieved\\" def test_check_perfect_score_none_perfect(): assert check_perfect_score(5, [99, 98, 97, 96, 95]) == \\"No Perfect Score\\" def test_check_perfect_score_single_score_no_perfect(): assert check_perfect_score(1, [99]) == \\"No Perfect Score\\"","solution":"def check_perfect_score(n, scores): Returns whether any student has scored a perfect score of 100. Parameters: n (int): The number of student scores (1  n  100). scores (list of int): A list of n integers representing the scores of the students (0  score  100). Returns: str: \\"Perfect Score Achieved\\" if at least one student has scored 100, otherwise \\"No Perfect Score\\". for score in scores: if score == 100: return \\"Perfect Score Achieved\\" return \\"No Perfect Score\\""},{"question":"from typing import List from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 else: return 1 def largest_number(n: int, numbers: List[int]) -> str: Form the largest possible integer by concatenating the numbers together. >>> largest_number(3, [10, 2, 9]) '9102' >>> largest_number(4, [54, 546, 548, 60]) '6054854654' pass def process_input(n: int, numbers: List[int]) -> str: return largest_number(n, numbers) # Test cases def test_single_number(): assert process_input(1, [1]) == \\"1\\" def test_two_numbers(): assert process_input(2, [10, 2]) == \\"210\\" def test_multiple_numbers(): assert process_input(3, [10, 2, 9]) == \\"9210\\" assert process_input(4, [54, 546, 548, 60]) == \\"6054854654\\" assert process_input(3, [3, 30, 34]) == \\"34330\\" assert process_input(3, [121, 12]) == \\"12121\\" def test_large_numbers(): assert process_input(3, [123456789, 987654321, 123456789]) == \\"987654321123456789123456789\\" def test_multiple_same_numbers(): assert process_input(5, [1, 1, 1, 1, 1]) == \\"11111\\" def test_large_list(): n = 100 numbers = [i for i in range(1, 101)] assert process_input(n, numbers) == ''.join(sorted(map(str, numbers), key=cmp_to_key(lambda x, y: -1 if x + y > y + x else 1)))","solution":"from functools import cmp_to_key def compare(x, y): if x + y > y + x: return -1 else: return 1 def largest_number(n, numbers): numbers = [str(number) for number in numbers] numbers.sort(key=cmp_to_key(compare)) return ''.join(numbers) def process_input(n, numbers): return largest_number(n, numbers) if __name__ == \\"__main__\\": import sys input = sys.stdin.read().split() n = int(input[0]) numbers = list(map(int, input[1:])) print(process_input(n, numbers))"},{"question":"def min_difference(skill_levels): Returns the minimum possible difference in the total skill levels of two teams. >>> min_difference([3, 1, 4, 2]) == 0 >>> min_difference([10, 20, 15, 5, 25]) == 5 >>> min_difference([1, 1, 1, 1]) == 0 >>> min_difference([1, 6, 11, 5]) == 1 >>> min_difference([1, 1, 2, 2, 3, 3]) == 0 >>> min_difference([5, 8, 13, 27]) == 1 >>> min_difference([40, 20]) == 20","solution":"def min_difference(skill_levels): Returns the minimum possible difference in the total skill levels of two teams. total_sum = sum(skill_levels) n = len(skill_levels) # Use dynamic programming to find the closest sum to half of total_sum. dp = [0] * (total_sum // 2 + 1) for skill in skill_levels: for j in range(total_sum // 2, skill - 1, -1): dp[j] = max(dp[j], dp[j - skill] + skill) return total_sum - 2 * dp[total_sum // 2]"},{"question":"from typing import List, Tuple def can_create_harmonious_council(n: int, regions: List[Tuple[int, int]]) -> str: Determine if it is possible to create a harmonious council with an equal number of elves and dwarves. >>> can_create_harmonious_council(3, [(4, 2), (1, 3), (3, 4)]) 'YES' >>> can_create_harmonious_council(2, [(5, 6), (1, 2)]) 'NO' >>> can_create_harmonious_council(1, [(4, 4)]) 'YES' >>> can_create_harmonious_council(1, [(3, 5)]) 'NO' >>> can_create_harmonious_council(4, [(1, 1), (2, 2), (3, 3), (4, 4)]) 'YES' >>> can_create_harmonious_council(3, [(1, 2), (2, 3), (3, 5)]) 'NO'","solution":"def can_create_harmonious_council(n, regions): from itertools import combinations # Iterate over all possible subsets of regions for r in range(1, n + 1): for subset in combinations(regions, r): elf_sum = sum(region[0] for region in subset) dwarf_sum = sum(region[1] for region in subset) if elf_sum == dwarf_sum: return \\"YES\\" return \\"NO\\""},{"question":"def employee_with_most_activities(n: int, logs: List[str]) -> Tuple[int, int]: Given a list of activity logs with employee IDs and timestamps, returns the employee_id with the highest number of activities in any hour and the count of those activities. Examples: >>> employee_with_most_activities(6, [\\"1,2023-10-11 15:00\\", \\"2,2023-10-11 15:05\\", \\"1,2023-10-11 15:10\\", \\"2,2023-10-11 15:15\\", \\"3,2023-10-11 16:00\\", \\"1,2023-10-11 16:10\\"]) (1, 3) >>> employee_with_most_activities(5, [\\"3,2023-10-11 17:00\\", \\"2,2023-10-11 17:15\\", \\"2,2023-10-11 17:30\\", \\"2,2023-10-11 17:40\\", \\"3,2023-10-11 17:50\\"]) (2, 3) pass # Test cases def test_single_log_single_employee(): assert employee_with_most_activities(1, [\\"1,2023-10-11 15:00\\"]) == (1, 1) def test_single_hour_multiple_employees(): logs = [ \\"1,2023-10-11 15:00\\", \\"2,2023-10-11 15:05\\", \\"1,2023-10-11 15:10\\", \\"2,2023-10-11 15:15\\", \\"3,2023-10-11 15:20\\" ] assert employee_with_most_activities(5, logs) == (1, 2) def test_multiple_hours_different_employees(): logs = [ \\"3,2023-10-11 17:00\\", \\"2,2023-10-11 17:15\\", \\"2,2023-10-11 17:30\\", \\"2,2023-10-11 17:40\\", \\"3,2023-10-11 17:50\\" ] assert employee_with_most_activities(5, logs) == (2, 3) def test_tie_different_hours(): logs = [ \\"1,2023-10-11 15:00\\", \\"1,2023-10-11 15:20\\", \\"1,2023-10-11 16:00\\", \\"2,2023-10-11 16:20\\", \\"2,2023-10-11 16:30\\", \\"3,2023-10-11 16:40\\" ] assert employee_with_most_activities(6, logs) == (1, 2) def test_tie_same_hour(): logs = [ \\"1,2023-10-11 15:00\\", \\"2,2023-10-11 15:05\\", \\"1,2023-10-11 15:10\\", \\"2,2023-10-11 15:15\\" ] assert employee_with_most_activities(4, logs) == (1, 2) def test_multiple_hours_same_employee(): logs = [ \\"1,2023-10-11 15:00\\", \\"1,2023-10-11 15:30\\", \\"1,2023-10-11 16:00\\", \\"1,2023-10-11 16:30\\", \\"1,2023-10-11 16:45\\" ] assert employee_with_most_activities(5, logs) == (1, 3)","solution":"from collections import defaultdict def employee_with_most_activities(n, logs): activity_count = defaultdict(lambda: defaultdict(int)) # Parse logs and count activities for log in logs: employee_id, timestamp = log.split(',') date, time = timestamp.split(' ') hour_slot = f'{date} {time[:2]}:00' activity_count[hour_slot][int(employee_id)] += 1 # Determine the employee with the most activities in any hour max_activities = 0 employee_id_with_max_activities = float('inf') for hour_slot in activity_count: for employee_id in activity_count[hour_slot]: activities = activity_count[hour_slot][employee_id] if activities > max_activities: max_activities = activities employee_id_with_max_activities = employee_id elif activities == max_activities: employee_id_with_max_activities = min(employee_id_with_max_activities, employee_id) return employee_id_with_max_activities, max_activities"},{"question":"def count_non_decreasing_subarrays(arr: List[int]) -> int: Returns the number of non-decreasing subarrays in the given array. >>> count_non_decreasing_subarrays([1, 2, 3, 2, 2]) 9 >>> count_non_decreasing_subarrays([4, 3, 2, 1]) 4","solution":"def count_non_decreasing_subarrays(arr): Returns the number of non-decreasing subarrays in the given array. n = len(arr) if n == 0: return 0 count = 0 length = 1 for i in range(1, n): if arr[i] >= arr[i - 1]: length += 1 else: count += length * (length + 1) // 2 length = 1 count += length * (length + 1) // 2 return count"},{"question":"def count_palindromic_substrings(s: str) -> int: Returns the number of palindromic substrings in the string s. >>> count_palindromic_substrings(\\"abc\\") 3 >>> count_palindromic_substrings(\\"aaa\\") 6 pass def palindromic_substrings_count(t: int, strings: List[str]) -> List[int]: For each test string in strings, counts the number of palindromic substrings. >>> palindromic_substrings_count(2, [\\"abc\\", \\"aaa\\"]) [3, 6] pass","solution":"def count_palindromic_substrings(s): Returns the number of palindromic substrings in the string s. n = len(s) count = 0 # A 2D array to store the palindromic substring status dp = [[False] * n for _ in range(n)] # Every single character is a palindrome for i in range(n): dp[i][i] = True count += 1 # Check for substrings of length 2 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True count += 1 # Check for substrings of length greater than 2 for length in range(3, n + 1): # length of substring for i in range(n - length + 1): j = i + length - 1 if s[i] == s[j] and dp[i + 1][j - 1]: dp[i][j] = True count += 1 return count def palindromic_substrings_count(t, strings): For each test string in strings, counts the number of palindromic substrings. results = [] for s in strings: results.append(count_palindromic_substrings(s)) return results"},{"question":"def min_moves_to_symmetrical(n: int, s: str) -> int: Returns the minimum number of moves required to make the binary string symmetrical. >>> min_moves_to_symmetrical(5, \\"01100\\") 1 >>> min_moves_to_symmetrical(4, \\"1001\\") 0","solution":"def min_moves_to_symmetrical(n, s): Returns the minimum number of moves required to make the binary string symmetrical. Parameters: n (int): Length of the binary string. s (str): Binary string consisting of '0's and '1's. Returns: int: Minimum number of moves required. moves = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: moves += 1 return moves"},{"question":"def find_max_busy_index(n: int, m: int, streets: List[Tuple[int, int, int]]) -> int: Determines the highest \\"busy-ness\\" index that can be removed while maintaining the connectivity of the city. Args: n (int): The number of intersections. m (int): The number of streets. streets (List[Tuple[int, int, int]]): A list of tuples where each tuple contains two intersections and a busy-ness index. Returns: int: The highest \\"busy-ness\\" index that can be removed while maintaining connectivity or -1 if no such street exists. Examples: >>> find_max_busy_index(4, 4, [(1, 2, 5), (2, 3, 3), (3, 4, 2), (1, 4, 1)]) 5 >>> find_max_busy_index(4, 5, [(1, 2, 3), (1, 3, 4), (1, 4, 2), (2, 4, 1), (3, 4, 5)]) 5 >>> find_max_busy_index(3, 3, [(1, 2, 1), (2, 3, 1), (1, 3, 1)]) 1 >>> find_max_busy_index(3, 2, [(1, 2, 1), (2, 3, 2)]) -1 >>> find_max_busy_index(5, 6, [(1, 2, 3), (1, 3, 1), (2, 3, 2), (2, 4, 5), (3, 5, 4), (4, 5, 6)]) 6","solution":"def find_max_busy_index(n, m, streets): Determines the highest \\"busy-ness\\" index that can be removed while maintaining the connectivity of the city. from collections import defaultdict from itertools import chain import heapq def find(parent, i): if parent[i] == i: return i else: return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 streets.sort(key=lambda x: x[2], reverse=True) for index, street in enumerate(streets): parent = list(range(n)) rank = [0] * n temp_streets = streets[:index] + streets[index+1:] for u, v, _ in temp_streets: union(parent, rank, u-1, v-1) connected = True root = find(parent, 0) for i in range(1, n): if find(parent, i) != root: connected = False break if connected: return street[2] return -1 # Example usage: n = 4 m = 4 streets = [ (1, 2, 5), (2, 3, 3), (3, 4, 2), (1, 4, 1) ] print(find_max_busy_index(n, m, streets)) # Output: 5"},{"question":"def min_moves_to_same_color(n: int, colors: List[int]) -> int: Determines the minimum number of moves needed to make all balls the same color. Parameters: n (int): Number of distinct colors. colors (list of int): List of ball counts for each color. Returns: int: Minimum number of moves. Examples: >>> min_moves_to_same_color(3, [1, 2, 3]) 3 >>> min_moves_to_same_color(4, [5, 5, 5, 5]) 15","solution":"def min_moves_to_same_color(n, colors): Determines the minimum number of moves needed to make all balls the same color. Parameters: n (int): Number of distinct colors. colors (list of int): List of ball counts for each color. Returns: int: Minimum number of moves. total_balls = sum(colors) max_color_count = max(colors) return total_balls - max_color_count"},{"question":"import math from heapq import heappop, heappush from typing import List, Tuple def min_road_length(n: int, intersections: List[Tuple[int, int]]) -> float: Compute the minimum total length of roads required to connect all intersections. >>> min_road_length(4, [(0, 0), (0, 1), (1, 0), (1, 1)]) 3.00 >>> min_road_length(1, [(0, 0)]) 0.00 >>> min_road_length(2, [(0, 0), (3, 4)]) 5.00","solution":"import math from heapq import heappop, heappush def euclidean_distance(x1, y1, x2, y2): return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2) def min_road_length(n, intersections): if n <= 1: return 0 adj = {i: [] for i in range(n)} # adjacency list for i in range(n): for j in range(i + 1, n): dist = euclidean_distance(intersections[i][0], intersections[i][1], intersections[j][0], intersections[j][1]) adj[i].append((dist, j)) adj[j].append((dist, i)) visited = [False] * n min_heap = [(0, 0)] # (cost, node) total_length = 0 edges_used = 0 while edges_used < n: cost, node = heappop(min_heap) if visited[node]: continue visited[node] = True total_length += cost edges_used += 1 for next_cost, neighbor in adj[node]: if not visited[neighbor]: heappush(min_heap, (next_cost, neighbor)) return round(total_length, 2) # Example function calls n = 4 intersections = [(0, 0), (0, 1), (1, 0), (1, 1)] print(min_road_length(n, intersections)) # Output: 3.00"},{"question":"import re def find_misspelled_words(paragraph: str, dictionary: List[str]) -> List[str]: Identifies and returns unique misspelled words in the order they appear in the paragraph. :param paragraph: A string containing the paragraph of text. :param dictionary: A list of correctly spelled words. :return: A list of unique misspelled words. >>> find_misspelled_words(\\"The quick brown fox jumpd over the lazt dog.\\", [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumped\\", \\"over\\", \\"lazy\\", \\"dog\\"]) [\\"jumpd\\", \\"lazt\\"] >>> find_misspelled_words(\\"Speling correctly is very importent.\\", [\\"spelling\\", \\"correctly\\", \\"is\\", \\"very\\", \\"important\\"]) [\\"speling\\", \\"importent\\"] >>> find_misspelled_words(\\"The quick brown fox jumped over the lazy dog.\\", [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumped\\", \\"over\\", \\"lazy\\", \\"dog\\"]) [] >>> find_misspelled_words(\\"Thes qwick bruwn focks jmpd ovr teh lezy doggo.\\", [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumped\\", \\"over\\", \\"lazy\\", \\"dog\\"]) [\\"thes\\", \\"qwick\\", \\"bruwn\\", \\"focks\\", \\"jmpd\\", \\"ovr\\", \\"teh\\", \\"lezy\\", \\"doggo\\"] >>> find_misspelled_words(\\"The quick Brown FOX jumpd OvEr the LAZY dog.\\", [\\"the\\", \\"quick\\", \\"brown\\", \\"fox\\", \\"jumped\\", \\"over\\", \\"lazy\\", \\"dog\\"]) [\\"jumpd\\"]","solution":"import re def find_misspelled_words(paragraph, dictionary): Identifies and returns unique misspelled words in the order they appear in the paragraph. :param paragraph: A string containing the paragraph of text. :param dictionary: A list of correctly spelled words. :return: A list of unique misspelled words. # Normalize dictionary to lowercase correct_words = set(word.lower() for word in dictionary) # Extract words from paragraph words = re.findall(r'bw+b', paragraph.lower()) # Find misspelled words misspelled_words = [] seen_words = set() for word in words: if word not in correct_words and word not in seen_words: misspelled_words.append(word) seen_words.add(word) return misspelled_words"},{"question":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list where each tuple consists of two integers representing the start and end times of an event. Returns: int: The maximum number of non-overlapping events. >>> max_non_overlapping_events([(1, 3), (2, 5), (4, 6), (6, 8), (5, 7)]) == 3 >>> max_non_overlapping_events([]) == 0 >>> max_non_overlapping_events([(1, 4), (2, 5), (3, 6)]) == 1 >>> max_non_overlapping_events([(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_events([(1, 3)]) == 1 >>> max_non_overlapping_events([(1, 2), (2, 3), (3, 4), (4, 5), (2, 5)]) == 4","solution":"def max_non_overlapping_events(events): Determines the maximum number of non-overlapping events that can be attended. Parameters: events (list of tuples): A list where each tuple consists of two integers representing the start and end times of an event. Returns: int: The maximum number of non-overlapping events. # Sort events by their end time events.sort(key=lambda x: x[1]) # Initialize variables max_events = 0 last_end_time = -1 # Iterate through the events for start, end in events: if start >= last_end_time: # If the current event starts after or when the last event ends, attend it max_events += 1 last_end_time = end return max_events"},{"question":"def longest_sequence(n: int, m: int, grid: List[str]) -> int: Determine the length of the longest sequence of cells in the grid such that: 1. The cells are in a straight line (horizontal, vertical, or diagonal). 2. All cells in this sequence contain the same letter. >>> longest_sequence(4, 5, [\\"aaaaa\\", \\"babba\\", \\"ccccd\\", \\"ecccd\\"]) 5 >>> longest_sequence(3, 3, [\\"abc\\", \\"abc\\", \\"abc\\"]) 3","solution":"def longest_sequence(n, m, grid): def check_sequence(x, y, dx, dy): char = grid[x][y] length = 0 while 0 <= x < n and 0 <= y < m and grid[x][y] == char: x += dx y += dy length += 1 return length max_length = 0 directions = [(0, 1), (1, 0), (1, 1), (1, -1)] for i in range(n): for j in range(m): for dx, dy in directions: length = check_sequence(i, j, dx, dy) if length > max_length: max_length = length return max_length"},{"question":"def can_form_consecutive_sequence(n: int, numbers: List[int]) -> str: Determines if the list of numbers can be rearranged to form a consecutive sequence. >>> can_form_consecutive_sequence(5, [4, 2, 1, 3, 5]) \\"YES\\" >>> can_form_consecutive_sequence(6, [10, 7, 8, 6, 9, 11]) \\"YES\\" >>> can_form_consecutive_sequence(4, [7, 10, 8, 6]) \\"NO\\" >>> can_form_consecutive_sequence(1, [1000]) \\"YES\\" >>> can_form_consecutive_sequence(2, [-1000000000, -999999999]) \\"YES\\" >>> can_form_consecutive_sequence(2, [-1000000000, 1000000000]) \\"NO\\"","solution":"def can_form_consecutive_sequence(n, numbers): Determines if the list of numbers can be rearranged to form a consecutive sequence. :param n: int - number of elements in the list :param numbers: List[int] - list of n distinct integers :return: str - \\"YES\\" if the numbers can be rearranged to form a consecutive sequence, else \\"NO\\" min_num = min(numbers) max_num = max(numbers) if max_num - min_num == n - 1: return \\"YES\\" else: return \\"NO\\""},{"question":"def apply_promotions(n, m, initial_inventory, promotions): Apply a list of promotions to the initial inventory levels and return the final inventory levels. Args: n (int): Number of products. m (int): Number of promotions. initial_inventory (list of int): Initial inventory levels for each product. promotions (list of tuple): List of promotions, where each promotion is a tuple (L, R, D). Returns: list of int: Final inventory levels after applying all promotions. pass # Test cases def test_apply_promotions1(): n = 5 m = 3 initial_inventory = [10, 20, 30, 40, 50] promotions = [(1, 3, 5), (2, 5, 10), (3, 4, 2)] expected_result = [15, 35, 47, 52, 60] assert apply_promotions(n, m, initial_inventory, promotions) == expected_result def test_apply_promotions2(): n = 4 m = 2 initial_inventory = [5, 7, 9, 11] promotions = [(1, 2, 3), (3, 4, 4)] expected_result = [8, 10, 13, 15] assert apply_promotions(n, m, initial_inventory, promotions) == expected_result def test_apply_promotions_no_promotions(): n = 4 m = 0 initial_inventory = [5, 7, 9, 11] promotions = [] expected_result = [5, 7, 9, 11] assert apply_promotions(n, m, initial_inventory, promotions) == expected_result def test_apply_promotions_single_product(): n = 1 m = 1 initial_inventory = [5] promotions = [(1, 1, 10)] expected_result = [15] assert apply_promotions(n, m, initial_inventory, promotions) == expected_result def test_apply_promotions_large_range(): n = 10 m = 2 initial_inventory = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] promotions = [(1, 10, 1), (1, 10, 2)] expected_result = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13] assert apply_promotions(n, m, initial_inventory, promotions) == expected_result","solution":"def apply_promotions(n, m, initial_inventory, promotions): Apply a list of promotions to the initial inventory levels and return the final inventory levels. Args: n (int): Number of products. m (int): Number of promotions. initial_inventory (list of int): Initial inventory levels for each product. promotions (list of tuple): List of promotions, where each promotion is a tuple (L, R, D). Returns: list of int: Final inventory levels after applying all promotions. # Convert from 1-based index to 0-based index for easier manipulation final_inventory = initial_inventory.copy() for L, R, D in promotions: for i in range(L - 1, R): final_inventory[i] += D return final_inventory"},{"question":"def numDecodings(s: str) -> int: Determines the number of distinct valid decoded messages from a numeric string. >>> numDecodings(\\"123\\") 3 >>> numDecodings(\\"226\\") 3","solution":"def numDecodings(s: str) -> int: if not s or s[0] == '0': return 0 n = len(s) dp = [0] * (n + 1) dp[0] = 1 dp[1] = 1 for i in range(2, n + 1): # Check the last single digit if s[i - 1] != '0': dp[i] += dp[i - 1] # Check the last two digits two_digit = int(s[i - 2:i]) if 10 <= two_digit <= 26: dp[i] += dp[i - 2] return dp[n] # Output examples print(numDecodings(\\"123\\")) # 3 print(numDecodings(\\"226\\")) # 3"},{"question":"def find_word_max_length(word: str, grid: List[str]) -> int: Determines the maximum length of the word that can be formed using the rules. The word can be formed by moving one step in any of the eight possible directions (horizontal, vertical, or diagonal). If the word cannot be formed, the result should be 0. >>> find_word_max_length(\\"HELLO\\", [ ... \\"HHOE\\", ... \\"LHLH\\", ... \\"OOOL\\" ... ]) == 5 >>> find_word_max_length(\\"WORLD\\", [ ... \\"AAAA\\", ... \\"BBBB\\", ... \\"CCCC\\" ... ]) == 0 >>> find_word_max_length(\\"A\\", [ ... \\"AAAA\\", ... \\"AAAA\\", ... \\"AAAA\\" ... ]) == 1 >>> find_word_max_length(\\"HELLO\\", [ ... \\"HHEL\\", ... \\"LHLH\\", ... \\"OOOO\\" ... ]) == 5 >>> find_word_max_length(\\"ABCDEFGHIJ\\", [ ... \\"ABCDEFGHIJ\\", ... \\"ABCDEFGHIJ\\", ... \\"ABCDEFGHIJ\\", ... \\"ABCDEFGHIJ\\" ... ]) == 10","solution":"def find_word_max_length(word, grid): R, C = len(grid), len(grid[0]) len_word = len(word) # Directions for 8 possible moves (right, left, down, up, and diagonals) directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] def dfs(x, y, index): if index == len_word: return index max_length = index for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < R and 0 <= ny < C and grid[nx][ny] == word[index]: max_length = max(max_length, dfs(nx, ny, index + 1)) return max_length max_length = 0 for i in range(R): for j in range(C): if grid[i][j] == word[0]: max_length = max(max_length, dfs(i, j, 1)) return max_length # Sample Input word = \\"HELLO\\" grid = [ \\"HHOE\\", \\"LHLH\\", \\"OOOL\\" ] print(find_word_max_length(word, grid)) # Expected: 5"},{"question":"def count_grades(scores): Given a list of scores, returns the counts of grades A, B, C, D, and F. Args: scores (list): List of integers representing the scores. Returns: tuple: A tuple containing the counts of grades A, B, C, D, and F. Example: >>> count_grades([85, 92, 88, 74, 56, 79, 100, 63]) (2, 2, 2, 1, 1) >>> count_grades([90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]) (11, 0, 0, 0, 0) >>> count_grades([0, 10, 20, 30, 40, 50, 59]) (0, 0, 0, 0, 7) Test Cases: >>> scores = [85, 92, 88, 74, 56, 79, 100, 63] >>> count_grades(scores) (2, 2, 2, 1, 1) >>> scores = [90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100] >>> count_grades(scores) (11, 0, 0, 0, 0) >>> scores = [0, 10, 20, 30, 40, 50, 59] >>> count_grades(scores) (0, 0, 0, 0, 7) >>> scores = [89, 79, 69, 59] >>> count_grades(scores) (0, 1, 1, 1, 1) >>> scores = [90, 80, 70, 60] >>> count_grades(scores) (1, 1, 1, 1, 0) >>> scores = [100, 89, 55, 76, 65, 88, 92, 70] >>> count_grades(scores) (2, 2, 2, 1, 1) >>> scores = [] >>> count_grades(scores) (0, 0, 0, 0, 0)","solution":"def count_grades(scores): Given a list of scores, returns the counts of grades A, B, C, D, and F. # Initialize counts for each letter grade counts = {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'F': 0} for score in scores: if 90 <= score <= 100: counts['A'] += 1 elif 80 <= score <= 89: counts['B'] += 1 elif 70 <= score <= 79: counts['C'] += 1 elif 60 <= score <= 69: counts['D'] += 1 elif 0 <= score <= 59: counts['F'] += 1 # Return the counts in the order of A, B, C, D, F return counts['A'], counts['B'], counts['C'], counts['D'], counts['F'] # Example usage: # number_of_students = 8 # scores = [85, 92, 88, 74, 56, 79, 100, 63] # counts = count_grades(scores) # print(counts) # Output should be (2, 2, 2, 1, 1)"},{"question":"import math from functools import reduce def lcm(a: int, b: int) -> int: Function to return the least common multiple of two numbers. >>> lcm(1, 1) 1 >>> lcm(2, 3) 6 >>> lcm(4, 5) 20 >>> lcm(6, 8) 24 >>> lcm(12, 15) 60 def smallest_multiple(numbers: List[int]) -> int: Returns the smallest multiple that is evenly divisible by all numbers in the list. >>> smallest_multiple([3, 5, 7]) 105 >>> smallest_multiple([1, 2, 3, 4, 5]) 60 >>> smallest_multiple([6, 8, 9]) 72 >>> smallest_multiple([5, 10, 15]) 30 >>> smallest_multiple([2, 3, 4, 6]) 12","solution":"import math from functools import reduce def lcm(a, b): Function to return the least common multiple of two numbers return a * b // math.gcd(a, b) def smallest_multiple(numbers): Returns the smallest multiple that is evenly divisible by all numbers in the list. return reduce(lcm, numbers)"},{"question":"import re from typing import List def is_palindrome(s: str) -> bool: Checks if a given string is a palindrome. >>> is_palindrome(\\"A man, a plan, a canal, Panama\\") == True >>> is_palindrome(\\"racecar\\") == True >>> is_palindrome(\\"Hello, World!\\") == False >>> is_palindrome(\\"This isn't a palindrome\\") == False def check_palindromes(num_cases: int, cases: List[str]) -> List[str]: Checks multiple strings to determine if each is a palindrome. >>> check_palindromes(2, [\\"Was it a car or a cat I saw\\", \\"No lemon, no melon\\"]) == [\\"YES\\", \\"YES\\"] >>> check_palindromes(2, [\\"This isn't a palindrome\\", \\"Neither is this\\"]) == [\\"NO\\", \\"NO\\"]","solution":"import re def is_palindrome(s): Checks if a given string is a palindrome. # Convert to lowercase s = s.lower() # Remove non-alphanumeric characters s = re.sub(r'[^a-z0-9]', '', s) # Check if the string is a palindrome return s == s[::-1] def check_palindromes(num_cases, cases): results = [] for i in range(num_cases): results.append(\\"YES\\" if is_palindrome(cases[i]) else \\"NO\\") return results"},{"question":"def count_unique_characters(s: str) -> int: Returns the number of unique characters in the input string s. Args: s (str): The input string containing only lowercase alphabet characters. Returns: int: The count of unique characters in the input string. pass # Test cases def test_count_unique_characters(): assert count_unique_characters(\\"hello\\") == 4 assert count_unique_characters(\\"abc\\") == 3 assert count_unique_characters(\\"aaaaaa\\") == 1 assert count_unique_characters(\\"abcdef\\") == 6 assert count_unique_characters(\\"aabbccddeeff\\") == 6 assert count_unique_characters(\\"\\") == 0 assert count_unique_characters(\\"abcdefghijklmnopqrstuvwxyz\\") == 26 assert count_unique_characters(\\"thequickbrownfoxjumpsoverthelazydog\\") == 26","solution":"def count_unique_characters(s: str) -> int: Returns the number of unique characters in the input string s. Args: s (str): The input string containing only lowercase alphabet characters. Returns: int: The count of unique characters in the input string. return len(set(s))"},{"question":"def max_non_overlapping_sessions(N: int, time_slots: List[Tuple[int, int]]) -> int: Returns the maximum number of non-overlapping sessions that can be scheduled. >>> max_non_overlapping_sessions(5, [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)]) == 3 >>> max_non_overlapping_sessions(3, [(1, 2), (3, 4), (5, 6)]) == 3 >>> max_non_overlapping_sessions(3, [(1, 5), (2, 6), (3, 7)]) == 1 >>> max_non_overlapping_sessions(4, [(1, 3), (2, 4), (3, 5), (4, 6)]) == 2 >>> max_non_overlapping_sessions(3, [(0, 1000000), (1, 2), (999999, 1000000)]) == 2 pass","solution":"def max_non_overlapping_sessions(N, time_slots): Returns the maximum number of non-overlapping sessions that can be scheduled. :param N: Integer, number of professors. :param time_slots: List of tuples, where each tuple contains two integers, start and end times. :return: Integer, maximum number of non-overlapping sessions. # Sort the time slots by their end time time_slots.sort(key=lambda x: x[1]) last_end_time = -1 count = 0 for start, end in time_slots: if start > last_end_time: last_end_time = end count += 1 return count # To use the function: # input_data = [(1, 4), (3, 5), (0, 6), (5, 7), (8, 9)] # N = 5 # print(max_non_overlapping_sessions(N, input_data)) # Output: 3"},{"question":"def rotate_matrix_90_clockwise(matrix): Rotate an NxN matrix 90 degrees clockwise. Args: matrix: A list of lists representing the NxN matrix. Returns: A new list of lists representing the rotated matrix. Example: >>> rotate_matrix_90_clockwise([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) [[7, 4, 1], [8, 5, 2], [9, 6, 3]] >>> rotate_matrix_90_clockwise([[1, 2], [3, 4]]) [[3, 1], [4, 2]] from solution import rotate_matrix_90_clockwise def test_small_matrix(): matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] rotated_matrix = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert rotate_matrix_90_clockwise(matrix) == rotated_matrix def test_larger_matrix(): matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16] ] rotated_matrix = [ [13, 9, 5, 1], [14, 10, 6, 2], [15, 11, 7, 3], [16, 12, 8, 4] ] assert rotate_matrix_90_clockwise(matrix) == rotated_matrix def test_single_element_matrix(): matrix = [[1]] rotated_matrix = [[1]] assert rotate_matrix_90_clockwise(matrix) == rotated_matrix def test_two_by_two_matrix(): matrix = [ [1, 2], [3, 4] ] rotated_matrix = [ [3, 1], [4, 2] ] assert rotate_matrix_90_clockwise(matrix) == rotated_matrix","solution":"def rotate_matrix_90_clockwise(matrix): N = len(matrix) # Create a new matrix to hold the rotated values rotated_matrix = [[0] * N for _ in range(N)] # Perform the rotation for i in range(N): for j in range(N): rotated_matrix[j][N - i - 1] = matrix[i][j] return rotated_matrix"},{"question":"def count_peak_points(n: int, altitudes: List[int]) -> int: Counts the number of peak points in the given array of altitudes. Parameters: n (int): The number of locations on the trail. altitudes (list of int): List of altitudes of the locations. Returns: int: The number of peak points. def test_single_peak(): assert count_peak_points(5, [1, 3, 2, 1, 4]) == 1 def test_multiple_peaks(): assert count_peak_points(8, [1, 2, 3, 1, 5, 6, 4, 2]) == 2 def test_no_peaks(): assert count_peak_points(4, [1, 2, 2, 1]) == 0 def test_plateaus(): assert count_peak_points(6, [2, 2, 3, 3, 2, 1]) == 0 def test_min_length(): assert count_peak_points(3, [1, 2, 1]) == 1 def test_all_same(): assert count_peak_points(5, [2, 2, 2, 2, 2]) == 0","solution":"def count_peak_points(n, altitudes): Counts the number of peak points in the given array of altitudes. Parameters: n (int): The number of locations on the trail. altitudes (list of int): List of altitudes of the locations. Returns: int: The number of peak points. if n < 3: return 0 peak_count = 0 for i in range(1, n - 1): if altitudes[i] > altitudes[i - 1] and altitudes[i] > altitudes[i + 1]: peak_count += 1 return peak_count def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) altitudes = list(map(int, data[1:])) result = count_peak_points(n, altitudes) print(result)"},{"question":"def max_length_strictly_increasing_subsequence(array: List[int]) -> int: Given an array of integers, find the maximum length of a subsequence such that all elements of the subsequence are strictly increasing and all elements are either odd or even. >>> max_length_strictly_increasing_subsequence([1, 2, 3, 5, 7, 8, 10, 12, 15]) 5 >>> max_length_strictly_increasing_subsequence([2, 4, 6, 8, 10, 12, 14]) 7 def solve(test_cases: List[List[int]]) -> List[int]: For each test case, in a new line, print the maximum length of a strictly increasing subsequence of either only odd or only even numbers. >>> solve([[1, 2, 3, 5, 7, 8, 10, 12, 15], [2, 4, 6, 8, 10, 12, 14], [10, 1, 22, 3, 33, 4, 44], [1, 3, 5, 7, 9], [2, 3, 2, 1, 6]]) [5, 7, 3, 5, 2]","solution":"def max_length_strictly_increasing_subsequence(array): odd_subsequence = [] even_subsequence = [] for num in array: if num % 2 == 0: if not even_subsequence or num > even_subsequence[-1]: even_subsequence.append(num) else: if not odd_subsequence or num > odd_subsequence[-1]: odd_subsequence.append(num) return max(len(odd_subsequence), len(even_subsequence)) def solve(test_cases): results = [] for array in test_cases: results.append(max_length_strictly_increasing_subsequence(array)) return results"},{"question":"from typing import List def min_operations_to_palindrome(n: int, s: str) -> int: Returns the minimum number of operations required to convert a given string into a palindrome. :param n: Length of the string. :param s: The string itself. :return: The minimum number of operations. Examples: >>> min_operations_to_palindrome(3, \\"aba\\") 0 >>> min_operations_to_palindrome(5, \\"abcba\\") 0 >>> min_operations_to_palindrome(4, \\"abca\\") 1","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations required to convert a given string into a palindrome. :param n: Length of the string. :param s: The string itself. :return: The minimum number of operations. operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates a simple arithmetic expression consisting of non-negative integers and addition and subtraction operators. Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of evaluating the expression. Examples: >>> evaluate_expression(\\"3+2-5+10\\") 10 >>> evaluate_expression(\\"20-4-2+8\\") 22 >>> evaluate_expression(\\"1000+2000-500\\") 2500","solution":"def evaluate_expression(expression): Evaluates a simple arithmetic expression consisting of non-negative integers and addition and subtraction operators. Args: expression (str): A string representing the arithmetic expression. Returns: int: The result of evaluating the expression. import re tokens = re.findall(r'd+|[+-]', expression) total = int(tokens[0]) index = 1 while index < len(tokens): if tokens[index] == '+': total += int(tokens[index + 1]) elif tokens[index] == '-': total -= int(tokens[index + 1]) index += 2 return total"},{"question":"def trap_rain_water(heights: List[List[int]]) -> int: Given an m x n grid filled with non-negative integers representing the height of cells, determine the maximum possible amount of water that can be trapped between these cells after a heavy rain. Water can only be trapped by cells with a lower height on all sides of it (horizontally or vertically). >>> trap_rain_water([ [1, 4, 3, 1, 3, 2], [3, 2, 1, 3, 2, 4], [2, 3, 3, 2, 3, 1] ]) 4 >>> trap_rain_water([ [5, 5, 5, 5], [5, 1, 1, 5], [5, 1, 1, 5], [5, 5, 5, 5] ]) 16","solution":"from typing import List import heapq def trap_rain_water(heights: List[List[int]]) -> int: if not heights or not heights[0]: return 0 m, n = len(heights), len(heights[0]) visited = [[False] * n for _ in range(m)] min_heap = [] # Push all the boundary cells into the heap for i in range(m): for j in (0, n-1): heapq.heappush(min_heap, (heights[i][j], i, j)) visited[i][j] = True for j in range(n): for i in (0, m-1): heapq.heappush(min_heap, (heights[i][j], i, j)) visited[i][j] = True total_water = 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] while min_heap: height, x, y = heapq.heappop(min_heap) for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and not visited[nx][ny]: visited[nx][ny] = True trapped_water = max(0, height - heights[nx][ny]) total_water += trapped_water heapq.heappush(min_heap, (max(height, heights[nx][ny]), nx, ny)) return total_water"},{"question":"def remove_duplicates(lst): Removes duplicates from the list while preserving the order of first occurrence. seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result def process_input(input_string): Process the input string to split it into integers, remove duplicates and return the result as a space-separated string. >>> process_input(\\"1 2 2 3 4 1 5 3 6\\") \\"1 2 3 4 5 6\\" >>> process_input(\\"7 7 7 7 7\\") \\"7\\" >>> process_input(\\"10 -1 -1 10 -5 0 -5 10\\") \\"10 -1 -5 0\\" >>> process_input(\\"5\\") \\"5\\" >>> process_input(\\"8 8 8 8 8\\") \\"8\\" >>> process_input(\\"\\") \\"\\" >>> process_input(\\"1 -1 1 -1\\") \\"1 -1\\"","solution":"def remove_duplicates(lst): Removes duplicates from the list while preserving the order of first occurrence. lst: List of integers returns: List of integers with duplicates removed seen = set() result = [] for num in lst: if num not in seen: seen.add(num) result.append(num) return result def process_input(input_string): Process the input string to split it into integers, remove duplicates and return the result as a space-separated string. input_string: String with integers separated by spaces returns: String with duplicates removed, preserving the order of first appearance lst = list(map(int, input_string.strip().split())) unique_list = remove_duplicates(lst) return \\" \\".join(map(str, unique_list))"},{"question":"def count_participants(paths): Counts the number of participants who took the left path, the right path, and those who haven't chosen any path. Parameters: paths (list): List of participants' names with possible suffixes \\"_L\\" or \\"_R\\". Returns: tuple: A tuple containing three integers - (left_count, right_count, no_path_count) >>> count_participants([\\"Daniel_L\\", \\"Sophia_R\\", \\"Emma_L\\", \\"Olivia\\", \\"Liam_R\\"]) == (2, 2, 1) >>> count_participants([\\"Ava\\", \\"Lucas_L\\", \\"Mia_R\\"]) == (1, 1, 1) >>> count_participants([]) == (0, 0, 0) >>> count_participants([\\"A\\"*50 + \\"_L\\", \\"B\\"*50, \\"C\\"*50 + \\"_R\\"]) == (1, 1, 1) >>> count_participants([\\"Daniel_R\\", \\"Sophia_R\\", \\"Emma_R\\"]) == (0, 3, 0) >>> count_participants([\\"Daniel_L\\", \\"Sophia_L\\", \\"Emma_L\\"]) == (3, 0, 0)","solution":"def count_participants(paths): Counts the number of participants who took the left path, the right path, and those who haven't chosen any path. Parameters: paths (list): List of participants' names with possible suffixes \\"_L\\" or \\"_R\\". Returns: tuple: A tuple containing three integers - (left_count, right_count, no_path_count) left_count = 0 right_count = 0 no_path_count = 0 for name in paths: if name.endswith(\\"_L\\"): left_count += 1 elif name.endswith(\\"_R\\"): right_count += 1 else: no_path_count += 1 return left_count, right_count, no_path_count"},{"question":"def toll_booth(n: int, vehicles: List[int]) -> str: Implement an automated toll system. Vehicles pass through a toll gate, and each vehicle can either have an electronic pass or pay in cash. The toll rate is 5 for vehicles with an electronic pass and 10 for those paying in cash. The toll booth initially has no money. Args: n (int): number of vehicles passing through the toll gate vehicles (List[int]): type of payment each vehicle is making, where 1 denotes an electronic pass and 2 denotes paying in cash Returns: str: \\"SUCCESS\\" if the toll booth can process each vehicle correctly, otherwise \\"FAIL\\" Examples: >>> toll_booth(5, [2, 1, 2, 2, 1]) 'FAIL' >>> toll_booth(6, [1, 2, 1, 1, 2, 2]) 'SUCCESS'","solution":"def toll_booth(n, vehicles): cash_in_hand = 0 for vehicle in vehicles: if vehicle == 1: cash_in_hand += 5 elif vehicle == 2: if cash_in_hand >= 5: cash_in_hand += 10 cash_in_hand -= 5 else: return \\"FAIL\\" return \\"SUCCESS\\""},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Returns the minimum number of changes required to transform the given sequence into a palindrome >>> min_operations_to_palindrome(5, \\"abcca\\") 1 >>> min_operations_to_palindrome(7, \\"racecar\\") 0 >>> min_operations_to_palindrome(1, \\"a\\") 0 >>> min_operations_to_palindrome(4, \\"abba\\") 0 >>> min_operations_to_palindrome(3, \\"aba\\") 0 >>> min_operations_to_palindrome(4, \\"abcd\\") 2 >>> min_operations_to_palindrome(6, \\"abccba\\") 0 >>> min_operations_to_palindrome(6, \\"abccda\\") 1","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of changes required to transform the given sequence into a palindrome. Parameters: n (int): The length of the sequence. s (str): The sequence of tiles as a string. Returns: int: Minimum number of operations required to make the sequence a palindrome. count = 0 l, r = 0, n - 1 while l < r: if s[l] != s[r]: count += 1 l += 1 r -= 1 return count"},{"question":"from typing import List, Tuple def find_positions(nums: List[int], target: int) -> Tuple[int, int]: Identify the first and last positions of a given target integer in a sorted list of integers. >>> find_positions([5, 7, 7, 8, 8, 10], 8) (3, 4) >>> find_positions([5, 7, 7, 8, 8, 10], 6) (-1, -1) >>> find_positions([2, 2], 2) (0, 1) def test_find_positions(): nums = [5, 7, 7, 8, 8, 10] target = 8 assert find_positions(nums, target) == (3, 4) def test_find_positions_not_found(): nums = [5, 7, 7, 8, 8, 10] target = 6 assert find_positions(nums, target) == (-1, -1) def test_find_positions_all_elements_match(): nums = [2, 2] target = 2 assert find_positions(nums, target) == (0, 1) def test_find_positions_single_element(): nums = [1] target = 1 assert find_positions(nums, target) == (0, 0) def test_find_positions_single_element_not_found(): nums = [1] target = 2 assert find_positions(nums, target) == (-1, -1) def test_find_positions_beginning(): nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 1 assert find_positions(nums, target) == (0, 0) def test_find_positions_end(): nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] target = 10 assert find_positions(nums, target) == (9, 9) def test_find_positions_multiple_occurrences(): nums = [1, 2, 3, 3, 3, 3, 4, 5] target = 3 assert find_positions(nums, target) == (2, 5)","solution":"from typing import List, Tuple def find_first_position(nums: List[int], target: int) -> int: left, right = 0, len(nums) - 1 first_pos = -1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 elif nums[mid] > target: right = mid - 1 else: first_pos = mid right = mid - 1 # continue searching in the left half return first_pos def find_last_position(nums: List[int], target: int) -> int: left, right = 0, len(nums) - 1 last_pos = -1 while left <= right: mid = (left + right) // 2 if nums[mid] < target: left = mid + 1 elif nums[mid] > target: right = mid - 1 else: last_pos = mid left = mid + 1 # continue searching in the right half return last_pos def find_positions(nums: List[int], target: int) -> Tuple[int, int]: first_position = find_first_position(nums, target) last_position = find_last_position(nums, target) if first_position == -1 or last_position == -1: return (-1, -1) return (first_position, last_position)"},{"question":"from itertools import permutations from typing import List, Tuple def find_valid_sequences(n: int, m: int, orders: List[Tuple[int, int]]) -> None: A wizard is experimenting with magical potions to gain new powers. He has collected a series of potion bottles, each labeled with a unique integer ranging from 1 to n. The wizard aims to drink the potions in a specific sequence to maximize his magical abilities. However, not all sequences are allowed; each potion has specific potions that must be drunk before it for maximum effect. The function finds all valid sequences. Input: - n: An integer representing the number of potions. - m: An integer representing the number of magical orders. - orders: A list of tuples, where each tuple contains two integers a and b, indicating that potion a must be drunk before potion b. Output: Print all valid sequences, one sequence per line. Sequences must be printed in lexicographical order. If there's no valid sequence, print \\"No valid sequence\\". Example: >>> find_valid_sequences(3, 2, [(1, 2), (1, 3)]) 1 2 3 1 3 2 >>> find_valid_sequences(3, 3, [(1, 2), (2, 3), (1, 3)]) 1 2 3 import pytest def capture_output(function, *args, **kwargs): import sys from io import StringIO saved_stdout = sys.stdout try: out = StringIO() sys.stdout = out function(*args, **kwargs) return out.getvalue().strip() finally: sys.stdout = saved_stdout def test_case_1(): n = 3 m = 2 orders = [(1, 2), (1, 3)] expected_output = \\"1 2 3n1 3 2\\" output = capture_output(find_valid_sequences, n, m, orders) assert output == expected_output def test_case_2(): n = 3 m = 3 orders = [(1, 2), (2, 3), (1, 3)] expected_output = \\"1 2 3\\" output = capture_output(find_valid_sequences, n, m, orders) assert output == expected_output def test_case_3(): n = 2 m = 1 orders = [(1, 2)] expected_output = \\"1 2\\" output = capture_output(find_valid_sequences, n, m, orders) assert output == expected_output def test_case_4(): n = 3 m = 0 orders = [] expected_output = \\"1 2 3n1 3 2n2 1 3n2 3 1n3 1 2n3 2 1\\" output = capture_output(find_valid_sequences, n, m, orders) assert output == expected_output def test_case_5(): n = 3 m = 3 orders = [(1, 2), (2, 3), (3, 1)] expected_output = \\"No valid sequence\\" output = capture_output(find_valid_sequences, n, m, orders) assert output == expected_output","solution":"from itertools import permutations def find_valid_sequences(n, m, orders): # Create a list of all potions potions = list(range(1, n + 1)) # Create a map to store dependencies must_be_before = {i: set() for i in potions} for a, b in orders: must_be_before[b].add(a) valid_sequences = [] # Check all possible permutations for perm in permutations(potions): is_valid = True for b in range(n): for a in must_be_before[perm[b]]: if perm.index(a) > b: is_valid = False break if not is_valid: break if is_valid: valid_sequences.append(perm) if not valid_sequences: print(\\"No valid sequence\\") else: for seq in sorted(valid_sequences): print(\\" \\".join(map(str, seq))) # Example usage if __name__ == \\"__main__\\": n = 3 m = 2 orders = [(1, 2), (1, 3)] find_valid_sequences(n, m, orders)"},{"question":"def smallest_palindrome(s: str) -> str: Transform the input string s into the lexicographically smallest possible palindrome by rearranging its characters, or return \\"IMPOSSIBLE\\" if it's not possible. >>> smallest_palindrome(\\"civic\\") 'civic' >>> smallest_palindrome(\\"ivicc\\") 'civic' >>> smallest_palindrome(\\"hello\\") 'IMPOSSIBLE' >>> smallest_palindrome(\\"aabb\\") 'abba' >>> smallest_palindrome(\\"aabbcc\\") 'abccba' >>> smallest_palindrome(\\"a\\") 'a' >>> smallest_palindrome(\\"aa\\") 'aa' >>> smallest_palindrome(\\"abc\\") 'IMPOSSIBLE' >>> smallest_palindrome(\\"aaa\\") 'aaa' >>> smallest_palindrome(\\"abcdedcba\\") 'abcdedcba'","solution":"def smallest_palindrome(s): from collections import Counter # Count frequency of each character char_count = Counter(s) odd_count = sum(1 for count in char_count.values() if count % 2 != 0) # A valid palindrome can have at most one character with odd frequency if odd_count > 1: return \\"IMPOSSIBLE\\" # Construct the first half of the palindrome half_palindrome = [] middle_char = \\"\\" for char in sorted(char_count.keys()): count = char_count[char] if count % 2 != 0: middle_char = char half_palindrome.append(char * (count // 2)) first_half = ''.join(half_palindrome) return first_half + middle_char + first_half[::-1]"},{"question":"def can_transfer_in_15_minutes(bus_schedules): Analyzes the bus schedules to determine if a transfer can be made at every stop within 15 minutes. Args: bus_schedules (list of list of str): A list containing schedules for each bus. Each schedule is a list of stop times in 'HH:MM' format. Returns: str: \\"Transfer possible at every stop\\" or \\"Transfer not possible at every stop\\" based on the analysis. Examples: >>> can_transfer_in_15_minutes([ ... [\\"08:00\\", \\"09:45\\", \\"11:30\\"], ... [\\"08:10\\", \\"09:50\\", \\"10:40\\", \\"11:55\\"] ... ]) 'Transfer possible at every stop' >>> can_transfer_in_15_minutes([ ... [\\"07:00\\", \\"08:30\\"], ... [\\"07:50\\", \\"10:10\\"] ... ]) 'Transfer not possible at every stop' pass from solution import can_transfer_in_15_minutes def test_transfer_possible(): bus_schedules = [ [\\"08:00\\", \\"09:45\\", \\"11:30\\"], [\\"08:10\\", \\"09:50\\", \\"10:40\\", \\"11:55\\"] ] assert can_transfer_in_15_minutes(bus_schedules) == \\"Transfer possible at every stop\\" def test_transfer_not_possible(): bus_schedules = [ [\\"07:00\\", \\"08:30\\"], [\\"07:50\\", \\"10:10\\"] ] assert can_transfer_in_15_minutes(bus_schedules) == \\"Transfer not possible at every stop\\" def test_multiple_buses(): bus_schedules = [ [\\"07:00\\", \\"08:10\\", \\"09:20\\"], [\\"07:10\\", \\"08:15\\", \\"09:25\\"], [\\"07:05\\", \\"08:20\\", \\"09:30\\"] ] assert can_transfer_in_15_minutes(bus_schedules) == \\"Transfer possible at every stop\\" def test_edge_case_exact_15_minutes(): bus_schedules = [ [\\"08:00\\", \\"09:00\\", \\"10:00\\"], [\\"08:15\\", \\"09:15\\", \\"10:15\\"] ] assert can_transfer_in_15_minutes(bus_schedules) == \\"Transfer possible at every stop\\" def test_edge_case_more_than_50_stops(): bus_schedules = [ [\\"{:02d}:00\\".format(i) for i in range(1, 51)], [\\"{:02d}:10\\".format(i) for i in range(1, 51)] ] assert can_transfer_in_15_minutes(bus_schedules) == \\"Transfer possible at every stop\\"","solution":"def can_transfer_in_15_minutes(bus_schedules): Analyses the bus schedules to determine if a transfer can be made at every stop within 15 minutes. Args: bus_schedules (list of list of str): A list containing schedules for each bus. Each schedule is a list of stop times in 'HH:MM' format. Returns: str: \\"Transfer possible at every stop\\" or \\"Transfer not possible at every stop\\" based on the analysis. def time_difference(t1, t2): Calculates the time difference in minutes between two given times in 'HH:MM' format. Args: t1 (str): First time in 'HH:MM' format. t2 (str): Second time in 'HH:MM' format. Returns: int: Difference in minutes between t1 and t2. h1, m1 = map(int, t1.split(':')) h2, m2 = map(int, t2.split(':')) return (h2 - h1) * 60 + (m2 - m1) num_buses = len(bus_schedules) for i in range(len(bus_schedules[0])): # Loop over each stop of the first bus stop_times = [] for schedule in bus_schedules: if i < len(schedule): stop_times.append(schedule[i]) for j in range(1, len(stop_times)): if time_difference(stop_times[j-1], stop_times[j]) > 15: return \\"Transfer not possible at every stop\\" return \\"Transfer possible at every stop\\""},{"question":"def triple_step_sequence(k: int) -> int: Returns the k-th element in the Triple Step Sequence. >>> triple_step_sequence(0) == 0 >>> triple_step_sequence(1) == 1 >>> triple_step_sequence(2) == 2 >>> triple_step_sequence(3) == 3 >>> triple_step_sequence(4) == 6 >>> triple_step_sequence(5) == 7 >>> triple_step_sequence(10) == 274","solution":"def triple_step_sequence(k): Returns the k-th element in the Triple Step Sequence. if k == 0: return 0 elif k == 1: return 1 elif k == 2: return 2 a = [0] * (k + 1) a[0] = 0 a[1] = 1 a[2] = 2 for i in range(3, k + 1): a[i] = a[i-1] + a[i-2] + a[i-3] return a[k]"},{"question":"def smallest_missing_integer(m: int, b: List[int]) -> int: Returns the smallest non-negative integer not present in the array. :param m: Length of the array b (integer). :param b: List of integers. :return: The smallest non-negative integer not present in the array (integer). >>> smallest_missing_integer(5, [0, 2, 1, 5, 3]) == 4 >>> smallest_missing_integer(4, [1, 2, 3, 4]) == 0 >>> smallest_missing_integer(5, [0, 1, 2, 3, 4]) == 5 >>> smallest_missing_integer(5, [0, 1, 3, 4, 5]) == 2 >>> smallest_missing_integer(5, [1000000000, 1000000001, 1000000002, 1000000003, 1000000004]) == 0 >>> smallest_missing_integer(0, []) == 0 >>> smallest_missing_integer(1, [0]) == 1 >>> smallest_missing_integer(3, [100000, 100001, 100002]) == 0","solution":"def smallest_missing_integer(m, b): Returns the smallest non-negative integer not present in the array. :param m: Length of the array b (integer). :param b: List of integers. :return: The smallest non-negative integer not present in the array (integer). present = set(b) i = 0 while i in present: i += 1 return i"},{"question":"from typing import List, Tuple def is_prime(number: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(15) False pass def check_magical_sequence(arr: List[int]) -> Tuple[bool, List[int]]: Check if the array can be rearranged into a magical arithmetic sequence. >>> check_magical_sequence([2, 5, 8, 11]) (True, [2, 5, 8, 11]) >>> check_magical_sequence([1, 6, 10]) (False, []) pass def magical_sequence(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Given a number of test cases, determine for each case if the array can be rearranged into a magical arithmetic sequence and return the results as a list of strings. >>> magical_sequence(2, [(4, [2, 5, 8, 11]), (3, [1, 6, 10])]) [\\"Yes 2 5 8 11\\", \\"No\\"] >>> magical_sequence(1, [(4, [3, 3, 3, 3])]) [\\"Yes 3 3 3 3\\"] pass","solution":"def is_prime(number): Check if a number is a prime number. if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def check_magical_sequence(arr): Check if the array can be rearranged into a magical arithmetic sequence. arr = sorted(arr) n = len(arr) if n < 2: return False, [] diff = arr[1] - arr[0] if diff != 0 and not is_prime(diff): return False, [] for i in range(2, n): current_diff = arr[i] - arr[i-1] if current_diff != diff: return False, [] return True, arr def magical_sequence(t, test_cases): results = [] for case in test_cases: n, arr = case possible, sequence = check_magical_sequence(arr) if possible: results.append(f\\"Yes {' '.join(map(str, sequence))}\\") else: results.append(\\"No\\") return results # Example usage: # t = 2 # test_cases = [(4, [2, 5, 8, 11]), (3, [1, 6, 10])] # print(magical_sequence(t, test_cases))"},{"question":"def min_toggles_to_all_on(n: int, initial: List[int], edges: List[Tuple[int, int]]) -> int: Determine the minimum number of toggles required to turn all nodes \\"on\\" in a tree. :param n: Number of nodes in the tree :param initial: List of integers representing the initial states of the nodes (0 for \\"off\\" and 1 for \\"on\\") :param edges: List of pairs of integers indicating edges between nodes in the tree :return: The minimum number of toggles required to turn all nodes \\"on\\" >>> min_toggles_to_all_on(6, [0, 0, 1, 0, 1, 0], [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)]) 3 >>> min_toggles_to_all_on(4, [1, 0, 0, 1], [(1, 2), (2, 3), (3, 4)]) 1 from typing import List, Tuple def test_example_1(): n = 6 initial = [0, 0, 1, 0, 1, 0] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6)] assert min_toggles_to_all_on(n, initial, edges) == 3 def test_example_2(): n = 4 initial = [1, 0, 0, 1] edges = [(1, 2), (2, 3), (3, 4)] assert min_toggles_to_all_on(n, initial, edges) == 1 def test_all_nodes_initially_on(): n = 3 initial = [1, 1, 1] edges = [(1, 2), (1, 3)] assert min_toggles_to_all_on(n, initial, edges) == 0 def test_all_nodes_initially_off(): n = 3 initial = [0, 0, 0] edges = [(1, 2), (1, 3)] assert min_toggles_to_all_on(n, initial, edges) == 1 def test_large_trivial_case(): n = 1 initial = [0] edges = [] assert min_toggles_to_all_on(n, initial, edges) == 1 def test_large_case(): n = 10 initial = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1] edges = [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7), (4, 8), (4, 9), (5, 10)] assert min_toggles_to_all_on(n, initial, edges) == 5","solution":"def min_toggles_to_all_on(n, initial, edges): from collections import defaultdict, deque tree = defaultdict(list) for u, v in edges: tree[u-1].append(v-1) tree[v-1].append(u-1) visited = [False] * n toggle_count = 0 def dfs(node): nonlocal toggle_count stack = deque([(node, False)]) while stack: current, toggled = stack.pop() if visited[current]: continue visited[current] = True if toggled: initial[current] ^= 1 if initial[current] == 0: toggle_count += 1 initial[current] = 1 toggled = True else: toggled = False for neighbor in tree[current]: if not visited[neighbor]: stack.append((neighbor, toggled)) dfs(0) return toggle_count"},{"question":"def is_prime(number): Returns True if the given number is prime, otherwise False. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False def fibonacci_primes(n): Returns the first n prime numbers in the Fibonacci sequence. >>> fibonacci_primes(5) [2, 3, 5, 13, 89] >>> fibonacci_primes(1) [2] >>> fibonacci_primes(0) []","solution":"def is_prime(number): Returns True if the given number is prime, otherwise False. if number <= 1: return False if number == 2: return True if number % 2 == 0: return False for i in range(3, int(number**0.5) + 1, 2): if number % i == 0: return False return True def fibonacci_primes(n): Returns the first n prime numbers in the Fibonacci sequence. fib_sequence = [1, 1] primes = [] i = 2 max_fib_index = 10000 while len(primes) < n and i < max_fib_index: next_fib = fib_sequence[-1] + fib_sequence[-2] fib_sequence.append(next_fib) if is_prime(next_fib): primes.append(next_fib) i += 1 return primes"},{"question":"def find_cluster_diff(T: int, cases: List[Tuple[int, List[int]]]) -> List[int]: Determine the difference between the size of the largest and smallest cluster formed. T: int The number of test cases. cases: List[Tuple[int, List[int]]] Each tuple contains the maximum difference allowed within a cluster (K) and a list of integers representing the measurements. Returns a list of integers representing the difference between the size of the largest and the smallest cluster for each test case. Example: >>> find_cluster_diff(2, [(2, [4, 1, 3, 5, 7]), (3, [5, 3, 10, 15, 20, 2])]) [0, 2] def test_find_cluster_diff(): T = 2 cases = [ (2, [4, 1, 3, 5, 7]), (3, [5, 3, 10, 15, 20, 2]) ] expected = [0, 2] assert find_cluster_diff(T, cases) == expected def test_single_value_clusters(): T = 1 cases = [ (1, [1, 3, 5, 7]) ] expected = [0] assert find_cluster_diff(T, cases) == expected def test_large_gap_clusters(): T = 1 cases = [ (2, [1, 2, 10, 11, 20, 21]) ] expected = [0] assert find_cluster_diff(T, cases) == expected def test_all_measurements_same(): T = 1 cases = [ (1000, [5, 5, 5, 5, 5]) ] expected = [0] assert find_cluster_diff(T, cases) == expected def test_no_clusters(): T = 1 cases = [ (1, [1, 5, 10]) ] expected = [0] assert find_cluster_diff(T, cases) == expected def test_single_measurement(): T = 1 cases = [ (5, [1]) ] expected = [0] assert find_cluster_diff(T, cases) == expected","solution":"def find_cluster_diff(T, cases): results = [] for case in cases: K, measurements = case measurements.sort() clusters = [] current_cluster = [] for measurement in measurements: if not current_cluster or measurement - current_cluster[-1] <= K: current_cluster.append(measurement) else: clusters.append(current_cluster) current_cluster = [measurement] if current_cluster: clusters.append(current_cluster) cluster_sizes = [len(cluster) for cluster in clusters] max_size = max(cluster_sizes) min_size = min(cluster_sizes) results.append(max_size - min_size) return results"},{"question":"def remove_chars_with_k_occurrences(s: str, k: int) -> str: Returns the string s after removing all characters that occur exactly k times. :param s: input string :param k: integer :return: modified string >>> remove_chars_with_k_occurrences(\\"abcabc\\", 2) '' >>> remove_chars_with_k_occurrences(\\"aaabbbccc\\", 1) 'aaabbbccc'","solution":"def remove_chars_with_k_occurrences(s, k): Returns the string s after removing all characters that occur exactly k times. :param s: input string :param k: integer :return: modified string from collections import Counter # Count occurrences of each character char_count = Counter(s) # Build the resulting string result = ''.join([char for char in s if char_count[char] != k]) return result"},{"question":"def minimum_positive_number_not_sum_twos_fives() -> int: Returns the smallest positive integer that cannot be represented as the sum of any number of 2's and 5's. >>> minimum_positive_number_not_sum_twos_fives() 1","solution":"def minimum_positive_number_not_sum_twos_fives(): Returns the smallest positive integer that cannot be represented as the sum of any number of 2's and 5's. # According to the problem constraints we need to find the smallest positive number # that cannot be represented as some combination of 2's and 5's. # After manually checking small combinations: # We find that the smallest number that cannot be represented as 2a + 5b is 1. return 1"},{"question":"def factorial(n: int) -> int: Calculate the factorial of a given integer n. >>> factorial(0) 1 >>> factorial(1) 1 >>> factorial(5) 120 >>> factorial(10) 3628800 >>> factorial(15) 1307674368000","solution":"def factorial(n): Returns the factorial of n. if n == 0: return 1 result = 1 for i in range(1, n + 1): result *= i return result"},{"question":"def get_remaining_cards(t: int, test_cases: list) -> list: Returns the remaining cards in the deck after a series of draws. >>> t = 2 >>> test_cases = [ ... (5, [\\"2 of hearts\\", \\"3 of hearts\\", \\"4 of hearts\\", \\"5 of hearts\\", \\"6 of hearts\\"]), ... (3, [\\"A of spades\\", \\"K of spades\\", \\"Q of spades\\"]) ... ] >>> get_remaining_cards(t, test_cases) [ [ \\"7 of hearts\\", \\"8 of hearts\\", \\"9 of hearts\\", \\"10 of hearts\\", \\"J of hearts\\", \\"Q of hearts\\", \\"K of hearts\\", \\"A of hearts\\", \\"2 of diamonds\\", \\"3 of diamonds\\", \\"4 of diamonds\\", \\"5 of diamonds\\", \\"6 of diamonds\\", \\"7 of diamonds\\", \\"8 of diamonds\\", \\"9 of diamonds\\", \\"10 of diamonds\\", \\"J of diamonds\\", \\"Q of diamonds\\", \\"K of diamonds\\", \\"A of diamonds\\", \\"2 of clubs\\", \\"3 of clubs\\", \\"4 of clubs\\", \\"5 of clubs\\", \\"6 of clubs\\", \\"7 of clubs\\", \\"8 of clubs\\", \\"9 of clubs\\", \\"10 of clubs\\", \\"J of clubs\\", \\"Q of clubs\\", \\"K of clubs\\", \\"A of clubs\\", \\"2 of spades\\", \\"3 of spades\\", \\"4 of spades\\", \\"5 of spades\\", \\"6 of spades\\", \\"7 of spades\\", \\"8 of spades\\", \\"9 of spades\\", \\"10 of spades\\", \\"J of spades\\", \\"Q of spades\\", \\"K of spades\\", \\"A of spades\\" ], [ \\"2 of hearts\\", \\"3 of hearts\\", \\"4 of hearts\\", \\"5 of hearts\\", \\"6 of hearts\\", \\"7 of hearts\\", \\"8 of hearts\\", \\"9 of hearts\\", \\"10 of hearts\\", \\"J of hearts\\", \\"Q of hearts\\", \\"K of hearts\\", \\"A of hearts\\", \\"2 of diamonds\\", \\"3 of diamonds\\", \\"4 of diamonds\\", \\"5 of diamonds\\", \\"6 of diamonds\\", \\"7 of diamonds\\", \\"8 of diamonds\\", \\"9 of diamonds\\", \\"10 of diamonds\\", \\"J of diamonds\\", \\"Q of diamonds\\", \\"K of diamonds\\", \\"A of diamonds\\", \\"2 of clubs\\", \\"3 of clubs\\", \\"4 of clubs\\", \\"5 of clubs\\", \\"6 of clubs\\", \\"7 of clubs\\", \\"8 of clubs\\", \\"9 of clubs\\", \\"10 of clubs\\", \\"J of clubs\\", \\"Q of clubs\\", \\"K of clubs\\", \\"A of clubs\\", \\"2 of spades\\", \\"3 of spades\\", \\"4 of spades\\", \\"5 of spades\\", \\"6 of spades\\", \\"7 of spades\\", \\"8 of spades\\", \\"9 of spades\\", \\"10 of spades\\", \\"J of spades\\" ] ]","solution":"def get_remaining_cards(t, test_cases): ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A'] suits = ['hearts', 'diamonds', 'clubs', 'spades'] all_cards = [f\\"{rank} of {suit}\\" for suit in suits for rank in ranks] results = [] for i in range(t): d = test_cases[i][0] drawn_cards = test_cases[i][1] remaining_cards = [card for card in all_cards if card not in drawn_cards] results.append(remaining_cards) return results"},{"question":"def max_difference_subsequences(N, A): Returns the maximum difference between the sum of elements of any two non-overlapping subsequences of the array A. >>> max_difference_subsequences(4, [2, 3, 5, 1]) 8 >>> max_difference_subsequences(5, [4, 7, 1, 8, 6]) 18 from solution import max_difference_subsequences def test_example_1(): assert max_difference_subsequences(4, [2, 3, 5, 1]) == 8 def test_example_2(): assert max_difference_subsequences(5, [4, 7, 1, 8, 6]) == 18 def test_one_element(): assert max_difference_subsequences(1, [1000]) == 1000 def test_all_same_elements(): assert max_difference_subsequences(4, [1, 1, 1, 1]) == 4 def test_mixed_elements(): assert max_difference_subsequences(6, [1, 2, 3, 4, 5, 6]) == 21","solution":"def max_difference_subsequences(N, A): Returns the maximum difference between the sum of elements of any two non-overlapping subsequences of the array A. A.sort(reverse=True) max_sum = sum(A) return max_sum"},{"question":"from typing import List def group_strings_by_first_char(strings: List[str]) -> List[str]: Groups strings by their first character in a case-insensitive manner while maintaining the order of appearance. Args: strings (List[str]): A list of strings where each string is to be grouped by its first character, case-insensitively. Returns: List[str]: A list where each group's first character is followed by corresponding strings. Example: >>> group_strings_by_first_char([\\"apple\\", \\"Almond\\", \\"banana\\", \\"apricot\\", \\"berry\\", \\"cherry\\", \\"end\\"]) ['a', 'apple', 'Almond', 'apricot', 'b', 'banana', 'berry', 'c', 'cherry']","solution":"def group_strings_by_first_char(strings): Groups strings by their first character in a case-insensitive manner while maintaining the order of appearance. from collections import OrderedDict groups = OrderedDict() for string in strings: if string == \\"end\\": break first_char = string[0].lower() if first_char not in groups: groups[first_char] = [] groups[first_char].append(string) result = [] for key, group in groups.items(): result.append(key) result.extend(group) return result"},{"question":"def smallest_substring(N: int, K: int, S: str) -> str: Find the lexicographically smallest substring of length K. >>> smallest_substring(7, 3, \\"abdcabc\\") 'abc' >>> smallest_substring(5, 4, \\"wxyzx\\") 'wxyz' >>> smallest_substring(6, 2, \\"abcdaa\\") 'aa'","solution":"def smallest_substring(N, K, S): Function to find the lexicographically smallest substring of length K. Parameters: N (int): Length of the string S K (int): Length of the required substring S (str): The input string Returns: str: The lexicographically smallest substring of length K min_substr = S[:K] for i in range(1, N - K + 1): current_substr = S[i:i + K] if current_substr < min_substr: min_substr = current_substr return min_substr"},{"question":"def can_fill_garden(n: int, m: int, k: int) -> str: Determines if the garden bed of dimensions n x m can be completely filled with flowers of length k. Args: n (int): Number of rows in the garden bed. m (int): Number of columns in the garden bed. k (int): Length of each type of flower bed available. Returns: str: \\"YES\\" if the garden bed can be completely filled, otherwise \\"NO\\". Examples: >>> can_fill_garden(3, 6, 3) \\"YES\\" >>> can_fill_garden(4, 7, 2) \\"NO\\"","solution":"def can_fill_garden(n, m, k): Determines if the garden bed of dimensions n x m can be completely filled with flowers of length k. if m % k == 0: return \\"YES\\" else: return \\"NO\\""},{"question":"def max_trapped_water(heights: List[int]) -> int: Given a list of integers representing the heights of buildings, calculates the maximum amount of water that can be trapped between them after a rain. >>> max_trapped_water([0, 1, 0, 2, 1, 0, 1, 3, 2, 1, 2, 1]) == 6 >>> max_trapped_water([4, 2, 0, 3, 2, 5]) == 9 >>> max_trapped_water([1, 0, 2]) == 1 >>> max_trapped_water([4, 2, 3]) == 1 >>> max_trapped_water([0, 0, 0, 0]) == 0 >>> max_trapped_water([2, 1, 2]) == 1 >>> max_trapped_water([5, 4, 3, 2, 1, 2, 3, 4, 5]) == 16 >>> max_trapped_water([]) == 0","solution":"def max_trapped_water(heights): Given a list of integers representing the heights of buildings, calculates the maximum amount of water that can be trapped between them after a rain. if not heights: return 0 n = len(heights) left_max = [0] * n right_max = [0] * n left_max[0] = heights[0] for i in range(1, n): left_max[i] = max(left_max[i-1], heights[i]) right_max[n-1] = heights[n-1] for i in range(n-2, -1, -1): right_max[i] = max(right_max[i+1], heights[i]) trapped_water = 0 for i in range(n): trapped_water += min(left_max[i], right_max[i]) - heights[i] return trapped_water"},{"question":"def rotate_array(arr: List[int], k: int) -> List[int]: Rotates the array k positions to the right. :param arr: List of integers representing the array :param k: Integer representing the number of positions to rotate the array :return: A new list with the array rotated k positions to the right >>> rotate_array([1, 2, 3, 4, 5], 2) [4, 5, 1, 2, 3] >>> rotate_array([10, 20, 30, 40, 50, 60], 0) [10, 20, 30, 40, 50, 60] >>> rotate_array([7, 8, 9], 3) [7, 8, 9] >>> rotate_array([-1, -2, -3, -4, -5], 2) [-4, -5, -1, -2, -3] >>> rotate_array([-1, 2, -3, 4, -5], 3) [-3, 4, -5, -1, 2]","solution":"def rotate_array(arr, k): Rotates the array k positions to the right. :param arr: List of integers representing the array :param k: Integer representing the number of positions to rotate the array :return: A new list with the array rotated k positions to the right n = len(arr) k = k % n # To handle cases where k >= n return arr[-k:] + arr[:-k]"},{"question":"def minimum_number_of_teams(n: int, departments: List[int]) -> int: Determine the minimum number of teams required such that no two employees from the same department are in the same team. :param n: Number of employees :param departments: List of departments each employee belongs to :return: Minimum number of teams required >>> minimum_number_of_teams(5, [1, 2, 3, 1, 2]) 2 >>> minimum_number_of_teams(7, [4, 4, 4, 3, 3, 1, 1]) 3 pass","solution":"def minimum_number_of_teams(n, departments): Returns the minimum number of teams required such that no two employees from the same department are in the same team. :param n: Number of employees :param departments: List of departments each employee belongs to :return: Minimum number of teams required from collections import Counter department_counts = Counter(departments) return max(department_counts.values())"},{"question":"def find_valid_sequence(n: int, times: List[int], k: int, prohibited_pairs: List[Tuple[int, int]]) -> str: Determine a valid sequence of performances such that no prohibited pairs are adjacent and the total setup and teardown time is minimized. >>> find_valid_sequence(4, [2, 3, 5, 1], 2, [(1, 3), (2, 4)]) in [ \\"2 1 4 3\\", \\"3 1 4 2\\", \\"4 3 1 2\\", \\"3 4 1 2\\", \\"1 2 4 3\\", \\"4 2 1 3\\", \\"2 3 4 1\\", \\"2 4 1 3\\", \\"4 1 3 2\\", \\"1 4 3 2\\", \\"1 2 3 4\\", \\"2 3 1 4\\" ] True >>> find_valid_sequence(3, [10, 20, 30], 1, [(2, 3)]) in [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"3 1 2\\", \\"2 3 1\\", \\"3 2 1\\"] True >>> find_valid_sequence(3, [10, 20, 30], 3, [(1, 2), (2, 3), (1, 3)]) '-1' >>> find_valid_sequence(1, [1], 0, []) '1' >>> find_valid_sequence(3, [1, 2, 3], 0, []) in [\\"1 2 3\\", \\"1 3 2\\", \\"2 1 3\\", \\"3 1 2\\", \\"2 3 1\\", \\"3 2 1\\"] True","solution":"import itertools def find_valid_sequence(n, times, k, prohibited_pairs): def is_valid_sequence(seq, prohibited_pairs_set): for i in range(1, len(seq)): if (seq[i-1], seq[i]) in prohibited_pairs_set or (seq[i], seq[i-1]) in prohibited_pairs_set: return False return True indices = list(range(1, n+1)) prohibited_pairs_set = set(tuple(pair) for pair in prohibited_pairs) for perm in itertools.permutations(indices): if is_valid_sequence(perm, prohibited_pairs_set): return \\" \\".join(map(str, perm)) return \\"-1\\" # Example for reference if __name__ == \\"__main__\\": n = 4 times = [2, 3, 5, 1] k = 2 prohibited_pairs = [(1, 3), (2, 4)] print(find_valid_sequence(n, times, k, prohibited_pairs)) # One possible output: \\"2 1 4 3\\""},{"question":"def process_operations(n, operations): Processes a list of operations on an initially empty list of integers and returns the final state of the list. Parameters: n (int): Number of operations to perform. operations (list of str): List of operations as strings. Returns: list: Final state of the list of integers, or \\"empty\\" if the list is empty. >>> process_operations(5, [\\"insert 3\\", \\"insert 4\\", \\"double\\", \\"delete 8\\", \\"decrement\\"]) [5, 7] >>> process_operations(2, [\\"insert 1\\", \\"delete 1\\"]) \\"empty\\" import pytest from solution import process_operations def test_insert_operations(): assert process_operations(3, [\\"insert 1\\", \\"insert 2\\", \\"insert 3\\"]) == [1, 2, 3] def test_delete_operations(): assert process_operations(4, [\\"insert 1\\", \\"insert 2\\", \\"insert 3\\", \\"delete 2\\"]) == [1, 3] assert process_operations(3, [\\"insert 1\\", \\"insert 2\\", \\"delete 3\\"]) == [1, 2] # no deletion since 3 not present def test_mixed_operations(): ops = [\\"insert 1\\", \\"insert 2\\", \\"insert 3\\", \\"delete 2\\", \\"double\\", \\"decrement\\"] assert process_operations(6, ops) == [1, 5] def test_double_operations(): assert process_operations(2, [\\"insert 1\\", \\"double\\"]) == [2] assert process_operations(3, [\\"insert 1\\", \\"insert 2\\", \\"double\\"]) == [2, 4] def test_decrement_operations(): assert process_operations(2, [\\"insert 1\\", \\"decrement\\"]) == [0] assert process_operations(3, [\\"insert 2\\", \\"insert 3\\", \\"decrement\\"]) == [1, 2] def test_empty_list_case(): assert process_operations(2, [\\"insert 1\\", \\"delete 1\\"]) == \\"empty\\" assert process_operations(4, [\\"insert 2\\", \\"insert 2\\", \\"delete 2\\", \\"delete 2\\"]) == \\"empty\\"","solution":"def process_operations(n, operations): Processes a list of operations on an initially empty list of integers and returns the final state of the list. Parameters: n (int): Number of operations to perform. operations (list of str): List of operations as strings. Returns: list: Final state of the list of integers, or \\"empty\\" if the list is empty. result = [] for operation in operations: parts = operation.split() command = parts[0] if command == \\"insert\\": result.append(int(parts[1])) elif command == \\"delete\\": x = int(parts[1]) if x in result: result.remove(x) elif command == \\"double\\": result = [x * 2 for x in result] elif command == \\"decrement\\": result = [x - 1 for x in result] return result if result else \\"empty\\""},{"question":"def sum_of_diameters(n: int) -> int: Returns the sum of the diameters of all possible rooted binary trees with exactly n nodes. >>> sum_of_diameters(1) 0 >>> sum_of_diameters(2) 0 >>> sum_of_diameters(3) 3 * (3 - 2) >>> sum_of_diameters(4) 4 * (4 - 2) >>> sum_of_diameters(10) 10 * (10 - 2) >>> sum_of_diameters(100) 100 * (100 - 2)","solution":"def sum_of_diameters(n): Returns the sum of the diameters of all possible rooted binary trees with exactly n nodes. if n < 3: return 0 return (n * (n - 2))"},{"question":"from typing import List, Tuple def maximize_benefit(n: int, T: int, projects: List[Tuple[int, int]]) -> int: A company has several projects, each with a specific benefit and completion time. You are tasked with selecting a subset of these projects to maximize the total benefit while ensuring that the total time required does not exceed a given limit. :param n: int - the number of projects :param T: int - the maximum total time available :param projects: List[Tuple[int, int]] - a list of tuples where each tuple contains two integers \`t_i\` and \`b_i\` representing the time required and the benefit of the i-th project respectively. :return: int - the maximum total benefit that can be achieved without exceeding the total available time T. >>> maximize_benefit(3, 50, [(10, 60), (20, 100), (30, 120)]) 220 >>> maximize_benefit(4, 10, [(5, 10), (4, 40), (6, 30), (3, 50)]) 90","solution":"def maximize_benefit(n, T, projects): dp = [0] * (T + 1) for t, b in projects: for time in range(T, t - 1, -1): dp[time] = max(dp[time], dp[time - t] + b) return dp[T] # Reading input function for the purpose of testing the solution in one go. def read_input(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) T = int(data[1]) projects = [] for i in range(n): t = int(data[2 + 2*i]) b = int(data[2 + 2*i + 1]) projects.append((t, b)) return n, T, projects if __name__ == \\"__main__\\": n, T, projects = read_input() print(maximize_benefit(n, T, projects))"},{"question":"from typing import List def longest_increasing_subsequence(n: int, widths: List[int]) -> List[int]: This function calculates the length of the longest increasing subsequence of books after each book is added. >>> longest_increasing_subsequence(5, [1, 3, 2, 4, 3]) [1, 2, 2, 3, 3] >>> longest_increasing_subsequence(4, [4, 5, 6, 7]) [1, 2, 3, 4] >>> longest_increasing_subsequence(6, [10, 20, 10, 30, 20, 50]) [1, 2, 2, 3, 3, 4]","solution":"import bisect def longest_increasing_subsequence(n, widths): This function calculates the length of the longest increasing subsequence of books after each book is added. lis = [] # This will keep track of the longest increasing subsequence found so far. lis_lengths = [] # This will store the lengths of the LIS after each book is added. for width in widths: # Find the position where this book could be placed in the LIS. pos = bisect.bisect_left(lis, width) # If this width is larger than all elements in the LIS, we add it to the end if pos == len(lis): lis.append(width) else: # Otherwise, we replace the element at the found position. lis[pos] = width # Append the new length of LIS to the result list. lis_lengths.append(len(lis)) return lis_lengths"},{"question":"def largestSquareSubmatrix(matrix) -> int: Find the size of the largest square submatrix that contains only 1s. >>> largestSquareSubmatrix([[1, 1, 0, 1], [1, 1, 1, 1], [1, 1, 1, 0]]) 2 >>> largestSquareSubmatrix([[1, 0], [0, 1]]) 1","solution":"def largestSquareSubmatrix(matrix): Finds the size of the largest square submatrix that contains only 1s. if not matrix or not matrix[0]: return 0 n = len(matrix) m = len(matrix[0]) dp = [[0] * m for _ in range(n)] max_square_len = 0 for i in range(n): for j in range(m): if matrix[i][j] == 1: dp[i][j] = 1 if i > 0 and j > 0: dp[i][j] += min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) max_square_len = max(max_square_len, dp[i][j]) return max_square_len"},{"question":"def hut_flags(n, m, commands): Determines the final state of each flag after all commands have been executed. Args: n (int): Number of huts. m (int): Number of commands. commands (List[str]): List of commands. Returns: List[int]: The final state of each hut's flag (1 if raised, 0 if lowered). >>> hut_flags(5, 4, ['raise 1', 'toggle 2 4', 'lower 3', 'toggle 3 5']) [1, 1, 1, 0, 1] >>> hut_flags(5, 1, ['raise 3']) [0, 0, 1, 0, 0] >>> hut_flags(5, 2, ['raise 3', 'lower 3']) [0, 0, 0, 0, 0] >>> hut_flags(5, 1, ['toggle 1 5']) [1, 1, 1, 1, 1] >>> hut_flags(5, 4, ['raise 1', 'toggle 2 3', 'toggle 3 4', 'lower 1']) [0, 1, 0, 1, 0] >>> hut_flags(3, 3, ['raise 1', 'raise 2', 'raise 3', 'lower 1', 'lower 2', 'lower 3']) [0, 0, 0]","solution":"def hut_flags(n, m, commands): flags = [0] * n for command in commands: parts = command.split() action = parts[0] if action == 'raise': x = int(parts[1]) - 1 flags[x] = 1 elif action == 'lower': x = int(parts[1]) - 1 flags[x] = 0 elif action == 'toggle': l = int(parts[1]) - 1 r = int(parts[2]) - 1 for i in range(l, r + 1): flags[i] = 1 - flags[i] return flags"},{"question":"def max_minerals(matrix): Given a 2D list representing the mineral quantities in a grid, computes the maximum quantity of minerals the robot can collect from the top-left to the bottom-right corner. def process_input(input_data): Processes the input data and returns a list of matrices representing the datasets. def space_mining_robots(input_data): Main function to process the input data and output the maximum minerals for each dataset. matrices = process_input(input_data) results = [max_minerals(matrix) for matrix in matrices] return results # Example Usage: # input_data = 3 4 # 1 3 1 2 # 1 5 1 3 # 4 2 1 4 # 2 2 # 2 4 # 0 3 # 0 0 # # print(space_mining_robots(input_data)) # Expected Output: [17, 9] # Unit Test def test_max_minerals(): matrix1 = [ [1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 4], ] matrix2 = [ [2, 4], [0, 3], ] assert max_minerals(matrix1) == 17 assert max_minerals(matrix2) == 9 def test_process_input(): input_data = \\"3 4n1 3 1 2n1 5 1 3n4 2 1 4n2 2n2 4n0 3n0 0n\\" expected = [ [ [1, 3, 1, 2], [1, 5, 1, 3], [4, 2, 1, 4], ], [ [2, 4], [0, 3], ] ] assert process_input(input_data) == expected def test_space_mining_robots(): input_data = \\"3 4n1 3 1 2n1 5 1 3n4 2 1 4n2 2n2 4n0 3n0 0n\\" expected_output = [17, 9] assert space_mining_robots(input_data) == expected_output","solution":"def max_minerals(matrix): Given a 2D list representing the mineral quantities in a grid, computes the maximum quantity of minerals the robot can collect from the top-left to the bottom-right corner. if not matrix: return 0 n = len(matrix) m = len(matrix[0]) # Create a dp table with the same dimensions as the matrix. dp = [[0] * m for _ in range(n)] # Starting point dp[0][0] = matrix[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j-1] + matrix[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i-1][0] + matrix[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j] return dp[n-1][m-1] def process_input(input_data): Processes the input data and returns a list of matrices representing the datasets. lines = input_data.strip().split('n') matrices = [] i = 0 while i < len(lines): n, m = map(int, lines[i].split()) if n == 0 and m == 0: break matrix = [] for row in range(n): matrix.append(list(map(int, lines[i + row + 1].split()))) matrices.append(matrix) i += n + 1 return matrices def space_mining_robots(input_data): Main function to process the input data and output the maximum minerals for each dataset. matrices = process_input(input_data) results = [max_minerals(matrix) for matrix in matrices] return results"},{"question":"import heapq def sum_largest_k_donations(n: int, k: int, donations: List[int]) -> int: Determine the sum of the largest k donations from a stream of donations. >>> sum_largest_k_donations(5, 3, [100, 200, 50, 150, 300]) 650 >>> sum_largest_k_donations(1, 1, [500]) 500 >>> sum_largest_k_donations(4, 2, [300, 300, 300, 300]) 600 >>> sum_largest_k_donations(5, 1, [20, 100, 50, 200, 150]) 200 >>> sum_largest_k_donations(3, 3, [1, 2, 3]) 6 >>> sum_largest_k_donations(5, 2, [10**9, 10**9 - 1, 10**9 - 2, 10**9 - 3, 10**9 - 4]) 2 * 10**9 - 1","solution":"import heapq def sum_largest_k_donations(n, k, donations): # Using a min heap to keep track of the largest k donations min_heap = [] total = 0 for donation in donations: if len(min_heap) < k: heapq.heappush(min_heap, donation) total += donation elif donation > min_heap[0]: total -= heapq.heappushpop(min_heap, donation) total += donation return total"},{"question":"def has_negative_weight_cycle(n: int, edges: List[Tuple[int, int, int]]) -> bool: Detects if a graph has a negative weight cycle using the Bellman-Ford algorithm. >>> has_negative_weight_cycle(5, [(1, 2, 4), (2, 3, 5), (3, 4, 6), (4, 5, 2), (5, 1, 1)]) False >>> has_negative_weight_cycle(6, [(1, 2, 4), (2, 3, 3), (3, 1, -10), (1, 4, 5), (4, 5, 3), (5, 6, 2), (6, 4, -8), (4, 3, 1)]) True >>> has_negative_weight_cycle(3, [(1, 2, -2), (2, 3, 2), (3, 1, 1)]) False >>> has_negative_weight_cycle(4, [(1, 2, 9999), (2, 3, 9999), (3, 4, 9999), (4, 1, 10000)]) False >>> has_negative_weight_cycle(5, [(1, 2, 4), (2, 3, 5), (3, 4, -9), (4, 2, 1), (3, 5, 2)]) True","solution":"def has_negative_weight_cycle(n, edges): Detects if a graph has a negative weight cycle using the Bellman-Ford algorithm. Parameters: n (int): Number of vertices edges (List[Tuple[int, int, int]]): List of edges where each edge is represented as (u, v, w) Returns: bool: True if there is a negative weight cycle, False otherwise # Initialize distances array dist = [float('inf')] * (n + 1) dist[1] = 0 # You can start Bellman-Ford from any arbitrary vertex # Relax edges up to n-1 times for _ in range(n - 1): for u, v, w in edges: if dist[u] != float('inf') and dist[u] + w < dist[v]: dist[v] = dist[u] + w # Check for negative weight cycle for u, v, w in edges: if dist[u] != float('inf') and dist[u] + w < dist[v]: return True return False"},{"question":"def longest_substring_with_k_distinct(s: str, k: int) -> int: Returns the length of the longest substring with exactly k distinct characters. If there is no such substring, returns 0. >>> longest_substring_with_k_distinct(\\"abcba\\", 2) 3 >>> longest_substring_with_k_distinct(\\"aa\\", 1) 2 >>> longest_substring_with_k_distinct(\\"abc\\", 4) 0","solution":"def longest_substring_with_k_distinct(s, k): Returns the length of the longest substring with exactly k distinct characters. If there is no such substring, returns 0. from collections import defaultdict n = len(s) if n == 0 or k == 0: return 0 char_count = defaultdict(int) left = 0 max_length = 0 distinct_count = 0 for right in range(n): if char_count[s[right]] == 0: distinct_count += 1 char_count[s[right]] += 1 while distinct_count > k: char_count[s[left]] -= 1 if char_count[s[left]] == 0: distinct_count -= 1 left += 1 if distinct_count == k: max_length = max(max_length, right - left + 1) return max_length # Example usage print(longest_substring_with_k_distinct(\\"abcba\\", 2)) # Output: 3"},{"question":"def calculate_complexities(input_string: str) -> List[str]: Write a program that calculates the complexity of a nested loop structure in terms of Big-O notation. >>> calculate_complexities(\\"1n1 n 1 1 m 2n\\") ['O((n-1)/1(m-1)/2)'] >>> calculate_complexities(\\"2n1 n 1 1 m 2n0 n 2 0 m 2n\\") ['O((n-1)/1(m-1)/2)', 'O((n-0)/2(m-0)/2)'] from typing import List def test_complexity_single_structure(): input_string = \\"1n1 n 1 1 m 2n\\" expected_output = [\\"O((n-1)/1(m-1)/2)\\"] assert calculate_complexities(input_string) == expected_output def test_complexity_multiple_structures(): input_string = \\"2n1 n 1 1 m 2n0 n 2 0 m 2n\\" expected_output = [\\"O((n-1)/1(m-1)/2)\\", \\"O((n-0)/2(m-0)/2)\\"] assert calculate_complexities(input_string) == expected_output def test_complexity_complex_structure(): input_string = \\"1n0 n 3 1 m 4 2 k 1n\\" expected_output = [\\"O((n-0)/3(m-1)/4(k-2)/1)\\"] assert calculate_complexities(input_string) == expected_output def test_complexity_uneven_step_structure(): input_string = \\"1n1 n 2 2 m 5n\\" expected_output = [\\"O((n-1)/2(m-2)/5)\\"] assert calculate_complexities(input_string) == expected_output def test_complexity_minimal_structure(): input_string = \\"1n0 10 1n\\" expected_output = [\\"O((10-0)/1)\\"] assert calculate_complexities(input_string) == expected_output","solution":"def big_o_complexity(loop_structures): complexities = [] for loops in loop_structures: complexity = \\"O(\\" terms = [] for loop in loops: s, e, u = loop start_diff = f'({e} - {s})' term = f'{start_diff}/{u}' terms.append(term) complexity += \\"\\".join(terms) + \\")\\" complexities.append(complexity) return complexities # Helper function to parse the input def parse_input(input_string): lines = input_string.strip().split('n') T = int(lines[0]) loop_structures = [] for i in range(1, T+1): loop_rep = lines[i].strip().split() loops = [(loop_rep[j], loop_rep[j+1], loop_rep[j+2]) for j in range(0, len(loop_rep), 3)] loop_structures.append(loops) return loop_structures def calculate_complexities(input_string): loop_structures = parse_input(input_string) return big_o_complexity(loop_structures)"},{"question":"from typing import List, Tuple def final_position(x: int, y: int, commands: List[str]) -> Tuple[int, int]: Returns the final coordinates of the robot after executing given commands. Parameters: x (int): The starting x-coordinate of the robot. y (int): The starting y-coordinate of the robot. commands (List[str]): A list of commands where each command is one of \\"N\\", \\"S\\", \\"E\\", or \\"W\\". Returns: Tuple[int, int]: The final coordinates of the robot. Examples: >>> final_position(0, 0, [\\"N\\", \\"E\\", \\"E\\", \\"S\\", \\"W\\"]) (1, 0) >>> final_position(5, 5, [\\"S\\", \\"S\\", \\"S\\"]) (5, 2)","solution":"from typing import List, Tuple def final_position(x: int, y: int, commands: List[str]) -> Tuple[int, int]: Returns the final coordinates of the robot after executing given commands. Parameters: x (int): The starting x-coordinate of the robot. y (int): The starting y-coordinate of the robot. commands (List[str]): A list of commands where each command is one of \\"N\\", \\"S\\", \\"E\\", or \\"W\\". Returns: Tuple[int, int]: The final coordinates of the robot. for command in commands: if command == \\"N\\": y += 1 elif command == \\"S\\": y -= 1 elif command == \\"E\\": x += 1 elif command == \\"W\\": x -= 1 return (x, y)"},{"question":"def longest_substring_with_k_distinct(T: int, test_cases: List[Tuple[int, str]]) -> List[int]: Given a string S and an integer K, find the length of the longest substring that contains exactly K distinct characters for each test case. Parameters: T (int): The number of test cases. test_cases (List[Tuple[int, str]]): A list of tuples, where each tuple contains an integer K and a string S. Returns: List[int]: A list of integers representing the length of the longest substring with exactly K distinct characters for each test case. >>> longest_substring_with_k_distinct(2, [(2, 'abcba'), (3, 'abaccc')]) [3, 6] >>> longest_substring_with_k_distinct(1, [(1, 'aaaa')]) [4]","solution":"def longest_substring_with_k_distinct(T, test_cases): def find_longest_substring_with_k_distinct_characters(k, s): n = len(s) if k == 0 or n == 0: return 0 start = 0 max_length = 0 char_frequency = {} for end in range(n): if s[end] in char_frequency: char_frequency[s[end]] += 1 else: char_frequency[s[end]] = 1 while len(char_frequency) > k: char_frequency[s[start]] -= 1 if char_frequency[s[start]] == 0: del char_frequency[s[start]] start += 1 if len(char_frequency) == k: max_length = max(max_length, end - start + 1) return max_length results = [] for case in test_cases: k, s = case results.append(find_longest_substring_with_k_distinct_characters(k, s)) return results"},{"question":"from typing import List, Tuple def can_distribute_water(N: int, M: int, connections: List[Tuple[int, int, int]], consumption: List[int]) -> str: Determine if it is possible to distribute water to all houses without exceeding the capacities of the pipes. :param N: integer, number of houses :param M: integer, number of water pipes :param connections: list of tuples, each containing three integers u, v, and c representing a water pipe between house u and house v with capacity c :param consumption: list of integers, the water consumption of each house :return: string, \\"Possible\\" if water can be distributed without exceeding pipe capacities, otherwise \\"Impossible\\" >>> can_distribute_water(4, 4, [(1, 2, 10), (2, 3, 15), (3, 4, 10), (4, 1, 5)], [5, 10, 20, 15]) 'Impossible' >>> can_distribute_water(3, 3, [(1, 2, 10), (2, 3, 15), (3, 1, 10)], [5, 5, 5]) 'Possible' def test_can_distribute_water(): assert can_distribute_water(4, 4, [(1, 2, 10), (2, 3, 15), (3, 4, 10), (4, 1, 5)], [5, 10, 20, 15]) == \\"Impossible\\" assert can_distribute_water(3, 3, [(1, 2, 10), (2, 3, 15), (3, 1, 10)], [5, 5, 5]) == \\"Possible\\" assert can_distribute_water(2, 1, [(1, 2, 8)], [4, 4]) == \\"Possible\\" assert can_distribute_water(5, 5, [(1, 2, 5), (2, 3, 5), (3, 4, 5), (4, 5, 5), (5, 1, 5)], [4, 4, 4, 4, 4]) == \\"Possible\\" assert can_distribute_water(3, 2, [(1, 2, 5), (2, 3, 6)], [3, 9, 8]) == \\"Impossible\\"","solution":"def can_distribute_water(N, M, connections, consumption): from collections import defaultdict, deque graph = defaultdict(list) for u, v, c in connections: graph[u].append((v, c)) graph[v].append((u, c)) total_demand = sum(consumption) def bfs(): visited = [False] * (N + 1) queue = deque([(1, float('inf'))]) visited[1] = True total_supply = 0 while queue: current, flow = queue.popleft() total_supply += min(flow, consumption[current-1]) for neighbor, capacity in graph[current]: if not visited[neighbor] and capacity > 0: visited[neighbor] = True queue.append((neighbor, min(flow, capacity))) return total_supply return \\"Possible\\" if bfs() >= total_demand else \\"Impossible\\""},{"question":"def min_players_for_tournament(M: int, P: int) -> int: Determines the minimum number of players needed to invite initially such that a tournament with M levels can be completed while ensuring each level balances perfectly. Parameters: M (int): Number of levels. P (int): Number of players. Returns: int: Minimum number of players needed to invite initially. >>> min_players_for_tournament(3, 7) 8 >>> min_players_for_tournament(4, 9) 16 Unit Test: def test_min_players_for_tournament(): from solution import min_players_for_tournament # Example tests assert min_players_for_tournament(3, 7) == 8 assert min_players_for_tournament(4, 9) == 16 # Additional tests assert min_players_for_tournament(1, 1) == 1 assert min_players_for_tournament(1, 2) == 2 assert min_players_for_tournament(1, 3) == 4 assert min_players_for_tournament(10, 1025) == 2048 assert min_players_for_tournament(10, 2**10) == 1024 # Boundary tests assert min_players_for_tournament(10**4, 1) == 1 assert min_players_for_tournament(10**4, 10**9) == 2 ** math.ceil(math.log2(10**9))","solution":"import math def min_players_for_tournament(M, P): Determines the minimum number of players needed to invite initially such that a tournament with M levels can be completed while ensuring each level balances perfectly. Parameters: M (int): Number of levels. P (int): Number of players. Returns: int: Minimum number of players needed to invite initially. if M < 1 or P < 1: return -1 # as a safeguard for unexpected inputs # Calculate the smallest power of 2 greater than or equal to P min_power_of_2 = 2 ** math.ceil(math.log2(P)) return min_power_of_2"},{"question":"def min_subarray_sum(n: int, m: int, a: List[int]) -> int: Determine the minimum possible sum of a subarray of length exactly m. >>> min_subarray_sum(6, 3, [4, -1, 2, -1, -4, 3]) -3 >>> min_subarray_sum(5, 2, [1, 2, 3, 4, 5]) 3 >>> min_subarray_sum(4, 1, [-5, -2, -3, -1]) -5 def process_queries(t: int, queries: List[Tuple[int, int, List[int]]]) -> List[int]: Process multiple queries to determine the minimum possible sum of a subarray of length exactly m for each query. Args: t: Integer, number of queries queries: List of tuples, where each tuple contains: - Two integers n and m - A list of n integers representing the array Returns: List of integers, where each integer is the result for the corresponding query >>> process_queries(3, [(6, 3, [4, -1, 2, -1, -4, 3]), (5, 2, [1, 2, 3, 4, 5]), (4, 1, [-5, -2, -3, -1])]) [-3, 3, -5] import pytest def test_process_queries_example(): t = 3 queries = [ (6, 3), [4, -1, 2, -1, -4, 3], (5, 2), [1, 2, 3, 4, 5], (4, 1), [-5, -2, -3, -1], ] expected = [-3, 3, -5] assert process_queries(t, queries) == expected def test_process_queries_minimum_length_subarray(): t = 1 queries = [ (1, 1), [0], ] expected = [0] assert process_queries(t, queries) == expected def test_process_queries_subarray_length_equal_to_array_length(): t = 1 queries = [ (5, 5), [-1, -2, -3, -4, -5], ] expected = [-15] assert process_queries(t, queries) == expected def test_process_queries_all_positive(): t = 1 queries = [ (4, 2), [1, 2, 3, 4], ] expected = [3] assert process_queries(t, queries) == expected def test_process_queries_m_greater_than_n(): t = 1 queries = [ (4, 5), [1, 2, 3, 4], ] expected = [-1] assert process_queries(t, queries) == expected def test_single_query_large_array(): import random random.seed(0) t = 1 n, m = 1000, 10 a = random.choices(range(-1000, 1001), k=n) queries = [(n, m), a] result = process_queries(t, queries) assert isinstance(result[0], int) assert len(result) == 1","solution":"def min_subarray_sum(n, m, a): # If the length of the subarray needed is greater than the total length, return -1 if m > n: return -1 # Find the sum of the first subarray of length m current_sum = sum(a[:m]) min_sum = current_sum # Traverse the array using the sliding window approach for i in range(m, n): current_sum = current_sum - a[i - m] + a[i] if current_sum < min_sum: min_sum = current_sum return min_sum def process_queries(t, queries): results = [] for i in range(t): n, m = queries[i*2] a = queries[i*2 + 1] result = min_subarray_sum(n, m, a) results.append(result) return results"},{"question":"def can_select_subsequence(s: str) -> str: Determines if Aria can select a subsequence such that the entire string cannot be transformed into a palindrome. >>> can_select_subsequence(\\"abcba\\") \\"NO\\" >>> can_select_subsequence(\\"abcd\\") \\"YES\\" >>> can_select_subsequence(\\"aabb\\") \\"NO\\" >>> can_select_subsequence(\\"a\\") \\"NO\\" >>> can_select_subsequence(\\"ab\\") \\"YES\\" >>> can_select_subsequence(\\"abcabcabc\\") \\"YES\\" >>> can_select_subsequence(\\"a\\" * 100000 + \\"b\\" * 100000) \\"NO\\"","solution":"def can_select_subsequence(s): Determines if Aria can select a subsequence in which the string cannot be made a palindrome. # A string can always be rearranged to a palindrome if it contains at most one character with an odd count frequency. frequency = {} for char in s: if char in frequency: frequency[char] += 1 else: frequency[char] = 1 odd_count = sum(1 for count in frequency.values() if count % 2 == 1) # If there are two or more characters with an odd frequency, it is impossible to rearrange them into a palindrome. if odd_count >= 2: return \\"YES\\" else: return \\"NO\\""},{"question":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns a list of merged intervals. Parameters: intervals (List[List[int]]): A list of intervals, where each interval is represented as a list of two integers [start, end]. Returns: List[List[int]]: A list of merged non-overlapping intervals. Example: >>> merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) [[1, 6], [8, 10], [15, 18]] >>> merge_intervals([[1, 4], [4, 5]]) [[1, 5]] def test_merge_intervals_disjoint(): assert merge_intervals([[1, 2], [3, 4], [5, 6]]) == [[1, 2], [3, 4], [5, 6]] def test_merge_intervals_overlap(): assert merge_intervals([[1, 3], [2, 6], [8, 10], [15, 18]]) == [[1, 6], [8, 10], [15, 18]] def test_merge_intervals_touching(): assert merge_intervals([[1, 4], [4, 5]]) == [[1, 5]] def test_merge_intervals_complex(): assert merge_intervals([[1, 4], [0, 4], [7, 10], [8, 11]]) == [[0, 4], [7, 11]] def test_merge_intervals_empty(): assert merge_intervals([]) == [] def test_merge_intervals_single_interval(): assert merge_intervals([[1, 10]]) == [[1, 10]] def test_merge_intervals_nested(): assert merge_intervals([[1, 10], [2, 5], [6, 7], [8, 9]]) == [[1, 10]] def test_merge_intervals_unsorted(): assert merge_intervals([[6, 7], [2, 3], [4, 5], [1, 10]]) == [[1, 10]]","solution":"from typing import List def merge_intervals(intervals: List[List[int]]) -> List[List[int]]: Merges overlapping intervals and returns a list of merged intervals. if not intervals: return [] # Sort the intervals by the starting time intervals.sort(key=lambda x: x[0]) merged = [] for interval in intervals: # If merged list is empty or current interval does not overlap with the last merged interval, add it to merged list if not merged or merged[-1][1] < interval[0]: merged.append(interval) else: # There is overlap, merge intervals by updating the end time of the last merged interval merged[-1][1] = max(merged[-1][1], interval[1]) return merged"},{"question":"def capture_creatures(n, m, k, creatures, paths, artifacts, start): Benjamin is going to capture magical creatures in the Enchanted Valley. There are n magical creatures and m bidirectional paths in the Enchanted Valley. Each creature is initially located at a different spot and can move along the paths to different places. Each creature has a certain capture requirement: a specific magical power threshold that needs to be met to capture that creature. Benjamin has a collection of magical artifacts that provide different amounts of magical power when used. Benjamin starts at location s and his primary objective is to capture as many creatures as possible. Benjamin can move freely along the paths, using the artifacts to meet or exceed each creature's capture requirement when he encounters it. Input The first line contains three integers n, m, and k (1  n  100, 0  m  200, 0  k  100), representing the number of creatures, the number of paths, and the number of magical artifacts Benjamin possesses, respectively. Each of the following n lines contains two integers c and p (1  c  n, 1  p  100), representing the initial location and capture power requirement of a creature. Each of the following m lines contains two integers u and v (1  u, v  n), denoting a path between location u and location v. The next line contains k integers (1  ai  100), representing the magical power provided by each artifact Benjamin has. The last line contains a single integer s (1  s  n), denoting Benjamin's starting position. Output Print an integer denoting the maximum number of creatures Benjamin can capture during his journey. Examples: >>> capture_creatures(3, 3, 5, [(1, 10), (2, 20), (3, 5)], [(1, 2), (2, 3), (1, 3)], [15, 10, 5, 25, 5], 1) 2 >>> capture_creatures(4, 3, 4, [(1, 30), (2, 40), (3, 25), (4, 10)], [(1, 2), (2, 3), (3, 4)], [20, 15, 30, 5], 1) 2 >>> capture_creatures(2, 0, 2, [(1, 10), (2, 20)], [], [15, 10], 1) 1 >>> capture_creatures(2, 1, 0, [(1, 10), (2, 20)], [(1, 2)], [], 1) 0 >>> capture_creatures(3, 2, 3, [(1, 10), (2, 20), (3, 5)], [(1, 2), (2, 3)], [30, 25, 15], 1) 3","solution":"def capture_creatures(n, m, k, creatures, paths, artifacts, start): from collections import defaultdict, deque # Adjacency list for graph representation graph = defaultdict(list) for u, v in paths: graph[u].append(v) graph[v].append(u) # Sort artifacts in descending order to use the most powerful ones first artifacts.sort(reverse=True) # BFS to find the shortest path from start to any node def bfs(start): dist = {i: float('inf') for i in range(1, n+1)} dist[start] = 0 queue = deque([start]) while queue: node = queue.popleft() for neighbor in graph[node]: if dist[neighbor] == float('inf'): dist[neighbor] = dist[node] + 1 queue.append(neighbor) return dist # Distance from start to all other nodes using BFS distances = bfs(start) # Sort creatures based on their distance to the starting point creatures.sort(key=lambda x: distances[x[0]]) # Try to capture as many creatures as possible captured = 0 artifact_idx = 0 for loc, power_req in creatures: if artifact_idx >= len(artifacts): break if artifacts[artifact_idx] >= power_req: captured += 1 artifact_idx += 1 return captured"},{"question":"def longest_consecutive_ones(M: int, N: int, grid: List[List[int]]) -> int: Determines the longest sequence of consecutive ones in the grid, either horizontally, vertically, or diagonally. >>> longest_consecutive_ones(3, 4, [[1, 1, 0, 1], [0, 1, 1, 0], [1, 1, 0, 1]]) 3 >>> longest_consecutive_ones(2, 2, [[0, 0], [0, 0]]) 0","solution":"def longest_consecutive_ones(M, N, grid): def check_direction(x, y, dx, dy): length, max_length = 0, 0 while 0 <= x < M and 0 <= y < N: if grid[x][y] == 1: length += 1 max_length = max(max_length, length) else: length = 0 x += dx y += dy return max_length max_sequence = 0 # Check horizontally and vertically for i in range(M): max_sequence = max(max_sequence, check_direction(i, 0, 0, 1)) # Horizontal for j in range(N): max_sequence = max(max_sequence, check_direction(0, j, 1, 0)) # Vertical # Check both diagonals for i in range(M): max_sequence = max(max_sequence, check_direction(i, 0, 1, 1)) # Main diagonal from left edge max_sequence = max(max_sequence, check_direction(i, 0, 1, -1)) # Anti-diagonal from left edge for j in range(N): max_sequence = max(max_sequence, check_direction(0, j, 1, 1)) # Main diagonal from top edge max_sequence = max(max_sequence, check_direction(0, j, 1, -1)) # Anti-diagonal from top edge return max_sequence # Function to read input, execute the above function, and output result if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() M = int(data[0]) N = int(data[1]) grid = [] index = 2 for i in range(M): grid.append([int(data[index + j]) for j in range(N)]) index += N print(longest_consecutive_ones(M, N, grid))"},{"question":"def min_subarrays_to_cover_peaks(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Given an array of integers, determine the minimum number of contiguous subarrays needed to cover all the peaks in the array. A peak is defined as an element that is greater than its immediate neighbors (i.e., an element a[i] is a peak if its greater than a[i-1] and a[i+1]). >>> min_subarrays_to_cover_peaks(1, [(5, [1, 3, 2, 4, 1])]) [2] >>> min_subarrays_to_cover_peaks(1, [(6, [1, 2, 3, 4, 5, 6])]) [0] >>> min_subarrays_to_cover_peaks(1, [(8, [1, 3, 2, 4, 1, 5, 2, 6])]) [3] >>> min_subarrays_to_cover_peaks(3, [(5, [1, 3, 2, 4, 1]), (6, [1, 2, 3, 4, 5, 6]), (8, [1, 3, 2, 4, 1, 5, 2, 6])]) [2, 0, 3]","solution":"def min_subarrays_to_cover_peaks(t, test_cases): results = [] def find_peaks(arr): peaks = [] n = len(arr) for i in range(1, n - 1): if arr[i] > arr[i - 1] and arr[i] > arr[i + 1]: peaks.append(i) return peaks for test_case in test_cases: n, arr = test_case peaks = find_peaks(arr) results.append(len(peaks)) return results"},{"question":"def min_operations(S: str) -> int: Determine the minimum number of operations required to make all characters in the string the same. >>> min_operations(\\"aabb\\") == 2 >>> min_operations(\\"aaaa\\") == 0 >>> min_operations(\\"a\\") == 0 >>> min_operations(\\"abcd\\") == 3 >>> min_operations(\\"aaabbbccc\\") == 6 >>> min_operations(\\"aaabbc\\") == 3 >>> min_operations(\\"a\\"*50000 + \\"b\\"*50000) == 50000","solution":"def min_operations(S: str) -> int: Determine the minimum number of operations required to make all characters in the string the same. from collections import Counter # Count the frequency of each character in the string char_count = Counter(S) # Find the character with the maximum frequency max_freq = max(char_count.values()) # The minimum number of operations is the total length of the string minus the maximum frequency return len(S) - max_freq"},{"question":"def longest_subarray_with_same_values(arr): Returns the length of the longest subarray with identical elements. >>> longest_subarray_with_same_values([4, 4, 4, 3, 3, 3, 3, 1, 1, 2]) 4 >>> longest_subarray_with_same_values([1, 2, 2, 2, 2, 3, 3, 3, 4, 4, 4, 4, 4]) 5 >>> longest_subarray_with_same_values([10, 10, 10, 20]) 3","solution":"def longest_subarray_with_same_values(arr): Returns the length of the longest subarray with identical elements. if not arr: return 0 max_length = 1 current_length = 1 for i in range(1, len(arr)): if arr[i] == arr[i - 1]: current_length += 1 else: max_length = max(max_length, current_length) current_length = 1 max_length = max(max_length, current_length) # Final check for the last recurring element return max_length"},{"question":"def minimize_difference(N: int, A: List[int]) -> int: Return the minimized difference between the maximum and minimum energy levels after any number of swaps. Parameters: N (int): The number of trees. A (List[int]): The initial magical energy levels of the trees. Returns: int: The minimized difference between the maximum and minimum energy levels. Examples: >>> minimize_difference(5, [3, 1, 4, 1, 5]) 4 >>> minimize_difference(3, [2, 2, 2]) 0 >>> minimize_difference(3, [1, 1000000000, 500000000]) 999999999 >>> minimize_difference(1, [42]) 0 >>> minimize_difference(4, [-10, -20, -30, -40]) 30","solution":"def minimize_difference(N, A): Return the minimized difference between the maximum and minimum energy levels after any number of swaps. Parameters: N (int): The number of trees. A (list of int): The initial magical energy levels of the trees. Returns: int: The minimized difference between the maximum and minimum energy levels. # After any number of swaps, the maximum and minimum energy levels can only change positions, # i.e., sorting the array will give us the minimum and the maximum in the respective positions. min_energy = min(A) max_energy = max(A) return max_energy - min_energy"},{"question":"def min_absolute_difference(n: int, power_values: List[int]) -> int: Finds the minimum possible absolute difference between the sums of two subsets of given power values. Parameters: n (int): Number of stones. power_values (list): List of power values for each stone. Returns: int: Minimum possible absolute difference. >>> min_absolute_difference(4, [1, 2, 3, 4]) 0 >>> min_absolute_difference(1, [10]) 10","solution":"def min_absolute_difference(n, power_values): Finds the minimum possible absolute difference between the sums of two subsets of given power values. Parameters: n (int): Number of stones. power_values (list): List of power values for each stone. Returns: int: Minimum possible absolute difference. from itertools import combinations total_sum = sum(power_values) min_diff = float('inf') for i in range(n + 1): for subset in combinations(power_values, i): subset_sum = sum(subset) other_sum = total_sum - subset_sum min_diff = min(min_diff, abs(subset_sum - other_sum)) return min_diff"},{"question":"def longest_increasing_subarray(arr): Returns the length of the longest increasing contiguous subarray. >>> longest_increasing_subarray([1, 2, 2, 5, 6, 3, 7]) 3 >>> longest_increasing_subarray([3, 3, 3, 3, 3]) 1 from solution import longest_increasing_subarray def test_example_1(): assert longest_increasing_subarray([1, 2, 2, 5, 6, 3, 7]) == 3 def test_example_2(): assert longest_increasing_subarray([3, 3, 3, 3, 3]) == 1 def test_single_element(): assert longest_increasing_subarray([5]) == 1 def test_all_increasing(): assert longest_increasing_subarray([1, 2, 3, 4, 5]) == 5 def test_all_decreasing(): assert longest_increasing_subarray([5, 4, 3, 2, 1]) == 1 def test_peaks_and_valleys(): assert longest_increasing_subarray([1, 3, 2, 4, 3, 5]) == 2 def test_longest_at_end(): assert longest_increasing_subarray([1, 2, 1, 2, 3, 4]) == 4","solution":"def longest_increasing_subarray(arr): Returns the length of the longest increasing contiguous subarray. n = len(arr) if n == 0: return 0 max_length = 1 current_length = 1 for i in range(1, n): if arr[i] > arr[i - 1]: current_length += 1 max_length = max(max_length, current_length) else: current_length = 1 return max_length # Example usage: # arr = [1, 2, 2, 5, 6, 3, 7] # print(longest_increasing_subarray(arr)) # Output: 3"},{"question":"def min_subarray_sum_diff(arr: List[int]) -> int: Returns the minimum absolute difference between the sums of two subarrays of equal length. >>> min_subarray_sum_diff([1, 2, 3, 4]) 0 >>> min_subarray_sum_diff([1, 3, 2, 4, 6, 5]) 1 >>> min_subarray_sum_diff([10, 20]) 10","solution":"from typing import List from itertools import combinations def min_subarray_sum_diff(arr: List[int]) -> int: Returns the minimum absolute difference between the sums of two subarrays of equal length. N = len(arr) half = N // 2 total_sum = sum(arr) min_diff = float('inf') # Generate all combinations of half the array's length for comb in combinations(arr, half): sub_sum = sum(comb) diff = abs(total_sum - 2 * sub_sum) min_diff = min(min_diff, diff) return min_diff"},{"question":"def minimum_road_length(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: Determine the total minimum road length needed to connect all villages directly or indirectly. Parameters: n (int): The number of villages. m (int): The number of roads. roads (List[Tuple[int, int, int]]): Each tuple contains three integers u, v, and w representing a road between villages u and v of length w. Returns: int: The minimum possible total length of the roads required to ensure all villages are reachable from one another. Example: >>> minimum_road_length(4, 5, [(1, 2, 4), (1, 3, 3), (2, 3, 2), (2, 4, 3), (3, 4, 5)]) 8 >>> minimum_road_length(2, 1, [(1, 2, 1)]) 1","solution":"class UnionFind: def __init__(self, n): self.parent = list(range(n)) self.rank = [0] * n def find(self, u): if self.parent[u] != u: self.parent[u] = self.find(self.parent[u]) # Path compression return self.parent[u] def union(self, u, v): root_u = self.find(u) root_v = self.find(v) if root_u != root_v: if self.rank[root_u] > self.rank[root_v]: self.parent[root_v] = root_u elif self.rank[root_u] < self.rank[root_v]: self.parent[root_u] = root_v else: self.parent[root_v] = root_u self.rank[root_u] += 1 def minimum_road_length(n, m, roads): uf = UnionFind(n) mst_weight = 0 edges = sorted(roads, key=lambda x: x[2]) for u, v, w in edges: if uf.find(u - 1) != uf.find(v - 1): uf.union(u - 1, v - 1) mst_weight += w return mst_weight"},{"question":"from typing import List def findLHS(nums: List[int]) -> int: Finds the length of the longest harmonious subsequence in the array nums. >>> findLHS([1, 3, 2, 2, 5, 2, 3, 7]) 5 >>> findLHS([1, 1, 1, 1]) 0","solution":"from collections import Counter def findLHS(nums): Finds the length of the longest harmonious subsequence in the array nums. num_count = Counter(nums) max_length = 0 for num in num_count: if num + 1 in num_count: max_length = max(max_length, num_count[num] + num_count[num + 1]) return max_length"},{"question":"def minimum_total_road_length(N, M, roads): Determine the minimum total length of roads required to keep the campus connected. Parameters: N (int): The number of buildings. M (int): The number of possible roads. roads (List[Tuple[int, int, int]]): The list of roads where each road is represented by a tuple (u, v, w) indicating a road between building u and building v with length w. Returns: int: The minimum total length of roads required to keep the campus connected. Example: >>> minimum_total_road_length(4, 5, [(1, 2, 10), (1, 3, 6), (1, 4, 5), (2, 3, 15), (3, 4, 4)]) 19 pass def parse_and_solve(input_string): Parse input and call the main function. Parameters: input_string (str): The input string representing the buildings and roads. Returns: int: The minimum total length of roads required to keep the campus connected. Example: >>> input_data = \\"4 5n1 2 10n1 3 6n1 4 5n2 3 15n3 4 4\\" >>> parse_and_solve(input_data) 19 lines = input_string.strip().split('n') N, M = map(int, lines[0].split()) roads = [] for line in lines[1:]: u, v, w = map(int, line.split()) roads.append((u, v, w)) return minimum_total_road_length(N, M, roads) def test_minimum_total_road_length(): input_data = \\"4 5n1 2 10n1 3 6n1 4 5n2 3 15n3 4 4\\" assert parse_and_solve(input_data) == 19 def test_single_road(): input_data = \\"2 1n1 2 5\\" assert parse_and_solve(input_data) == 5 def test_no_road(): input_data = \\"1 0\\" assert parse_and_solve(input_data) == 0 def test_complex_case(): input_data = \\"5 7n1 2 10n1 3 20n1 4 30n2 4 15n3 4 6n2 3 25n4 5 8\\" assert parse_and_solve(input_data) == 39 def test_case_with_multiple_minimum_spanning_trees(): input_data = \\"4 5n1 2 1n1 3 1n1 4 1n2 3 1n3 4 1\\" assert parse_and_solve(input_data) == 3","solution":"def minimum_total_road_length(N, M, roads): This function takes the number of buildings N, number of roads M, and a list of roads. Each road is represented by a tuple (u, v, w) where u and v are the buildings connected by the road and w is the length of the road. The function returns the minimum total length of roads required to keep the campus connected. parent = list(range(N)) # Function to find the representative of a set def find(x): if parent[x] != x: parent[x] = find(parent[x]) return parent[x] # Function to union two sets def union(x, y): rootX = find(x) rootY = find(y) if rootX != rootY: parent[rootY] = rootX # Sort the roads by length roads.sort(key=lambda x: x[2]) total_length = 0 edges_used = 0 for u, v, w in roads: if find(u - 1) != find(v - 1): union(u - 1, v - 1) total_length += w edges_used += 1 if edges_used == N - 1: break return total_length # Helper function to parse input and call the main function def parse_and_solve(input_string): lines = input_string.strip().split('n') N, M = map(int, lines[0].split()) roads = [] for line in lines[1:]: u, v, w = map(int, line.split()) roads.append((u, v, w)) return minimum_total_road_length(N, M, roads)"},{"question":"def next_permutation(s: str) -> str: Generate the lexicographically next permutation of the input string s. If no such permutation exists, return the string sorted in non-descending order. pass def process_test_cases(test_cases: List[str]) -> List[str]: Process a list of test cases and return a list of results where each result is the lexicographically next permutation of the corresponding input string. If it doesn't exist, the string is sorted in non-descending order. pass # Unit Test from solution import next_permutation, process_test_cases def test_next_permutation(): assert next_permutation(\\"dacb\\") == \\"dbac\\" assert next_permutation(\\"dcba\\") == \\"abcd\\" assert next_permutation(\\"abcd\\") == \\"abdc\\" assert next_permutation(\\"aabb\\") == \\"abab\\" assert next_permutation(\\"cba\\") == \\"abc\\" assert next_permutation(\\"bca\\") == \\"cab\\" def test_process_test_cases(): assert process_test_cases([\\"dacb\\", \\"dcba\\"]) == [\\"dbac\\", \\"abcd\\"] assert process_test_cases([\\"abcd\\"]) == [\\"abdc\\"] assert process_test_cases([\\"aabb\\", \\"bbaa\\"]) == [\\"abab\\", \\"aabb\\"] def test_edge_cases(): assert next_permutation(\\"a\\") == \\"a\\" assert next_permutation(\\"aa\\") == \\"aa\\" assert next_permutation(\\"ba\\") == \\"ab\\" assert next_permutation(\\"zy\\") == \\"yz\\" assert next_permutation(\\"az\\") == \\"za\\" def test_large_input(): # Test for efficiency and handling of large input strings large_string = \\"a\\" * 500 + \\"b\\" * 500 next_perm = \\"a\\" * 499 + \\"b\\" + \\"a\\" + \\"b\\" * 499 assert next_permutation(large_string) == next_perm","solution":"def next_permutation(s): Generate the lexicographically next permutation of the input string s. If no such permutation exists, return the string sorted in non-descending order. # Convert the string to a list for easy manipulation s = list(s) # Step 1: Find the rightmost character which is smaller than its next character i = len(s) - 2 while i >= 0 and s[i] >= s[i + 1]: i -= 1 # If no such character is found, the string is in descending order if i == -1: s.sort() return ''.join(s) # Step 2: Find the smallest character on right side of the pivot which is larger than s[i] j = len(s) - 1 while s[j] <= s[i]: j -= 1 # Step 3: Swap the characters at i and j s[i], s[j] = s[j], s[i] # Step 4: Reverse the suffix starting from i+1 s = s[:i + 1] + s[i + 1:][::-1] return ''.join(s) def process_test_cases(test_cases): results = [] for case in test_cases: results.append(next_permutation(case)) return results"},{"question":"def find_missing_positive_integer(arr: List[int]) -> int: This function returns the smallest positive integer missing from the array. >>> find_missing_positive_integer([3, 4, -1, 1, 2]) == 5 >>> find_missing_positive_integer([-1, -2, -3]) == 1 >>> find_missing_positive_integer([1, 2, 3, 4, 5]) == 6 >>> find_missing_positive_integer([0, 2, 3, 4, 5]) == 1 >>> find_missing_positive_integer([2, 3, 3, 4, 1]) == 5 >>> find_missing_positive_integer(list(range(1, 100001)) + [-1, -2, -3, -4, -5]) == 100001","solution":"def find_missing_positive_integer(arr): This function returns the smallest positive integer missing from the array. n = len(arr) # Step 1: Move all non-positive numbers to the left side and count the number of positives j = 0 for i in range(n): if arr[i] <= 0: arr[i], arr[j] = arr[j], arr[i] # Swap j += 1 # Now consider the subarray from j to n-1 pos_arr = arr[j:] pos_count = n - j # Step 2: Use the index as a hash key for i in range(pos_count): num = abs(pos_arr[i]) if num - 1 < pos_count and pos_arr[num - 1] > 0: pos_arr[num - 1] = -pos_arr[num - 1] # Step 3: Find the first index which has a positive value for i in range(pos_count): if pos_arr[i] > 0: return i + 1 return pos_count + 1"},{"question":"def find_split_index(arr: List[int]) -> int: Alice has an integer array nums[] of N integers. She needs to split the array into two non-empty subarrays such that the maximum element in the left subarray is less than or equal to the minimum element in the right subarray. Find the index at which Alice should split the array to satisfy this condition. Return the index of the smallest such position. If no such index exists, return -1. >>> find_split_index([5, 0, 3, 8, 6]) == 3 >>> find_split_index([1, 1, 1, 1, 1]) == 1 >>> find_split_index([1, 2, 3, 4, 5]) == 1 >>> find_split_index([10, 20, 30, 40, 50]) == 1 >>> find_split_index([50, 40, 30, 20, 10]) == -1 from solution import find_split_index def test_find_split_index_case_1(): assert find_split_index([5, 0, 3, 8, 6]) == 3 def test_find_split_index_case_2(): assert find_split_index([1, 1, 1, 1, 1]) == 1 def test_find_split_index_case_3(): assert find_split_index([1, 2, 3, 4, 5]) == 1 def test_find_split_index_case_4(): assert find_split_index([10, 20, 30, 40, 50]) == 1 def test_find_split_index_case_5(): assert find_split_index([50, 40, 30, 20, 10]) == -1 def test_find_split_index_case_6(): assert find_split_index([-10, -5, 0, 5, 10]) == 1 def test_find_split_index_case_7(): assert find_split_index([3, 3, 4, 4, 5, 5]) == 1 def test_find_split_index_no_valid_split(): assert find_split_index([5, 4, 3, 2, 1]) == -1 def test_find_split_index_min_valid_input(): assert find_split_index([1, 2]) == 1","solution":"def find_split_index(arr): This function finds the smallest index to split the array into two non-empty subarrays such that the maximum element in the left subarray is less than or equal to the minimum element in the right subarray. If no such index exists, the function returns -1. n = len(arr) if n < 2: return -1 left_max = [0] * n right_min = [0] * n left_max[0] = arr[0] for i in range(1, n): left_max[i] = max(left_max[i-1], arr[i]) right_min[n-1] = arr[n-1] for i in range(n-2, -1, -1): right_min[i] = min(right_min[i+1], arr[i]) for i in range(1, n): if left_max[i-1] <= right_min[i]: return i return -1"},{"question":"from typing import List, Tuple def max_books_checked_out(events: List[Tuple[int, str, int]]) -> int: Determines the maximum number of books checked out at the same time. >>> max_books_checked_out([(1, 'borrow', 101), (2, 'borrow', 102), (3, 'return', 101), (4, 'borrow', 103), (5, 'borrow', 104), (6, 'return', 104), (7, 'borrow', 105)]) 3 >>> max_books_checked_out([(1, 'borrow', 101)]) 1 >>> max_books_checked_out([(1, 'borrow', 101), (2, 'return', 101)]) 1 >>> max_books_checked_out([(1, 'borrow', 101), (2, 'borrow', 102), (3, 'borrow', 103)]) 3 >>> max_books_checked_out([(1, 'borrow', 101), (1, 'return', 101), (2, 'borrow', 102)]) 1 >>> max_books_checked_out([(1, 'borrow', 101), (2, 'borrow', 102), (3, 'return', 101), (4, 'return', 102)]) 2","solution":"def max_books_checked_out(events): Determines the maximum number of books checked out at the same time. Parameters: events (List[Tuple[int, str, int]]): A list of events where each event is a tuple of (timestamp, action, book_id). Returns: int: The maximum number of books that were checked out at the same time. checked_out_books = set() max_books = 0 for timestamp, action, book_id in events: if action == 'borrow': checked_out_books.add(book_id) elif action == 'return': checked_out_books.remove(book_id) max_books = max(max_books, len(checked_out_books)) return max_books"},{"question":"def min_transit_changes(n: int, start: int, end: int, matrix: List[List[int]]) -> int: Determine the minimum number of transit changes required to travel from a start city to an end city. :param n: number of cities :param start: starting city :param end: destination city :param matrix: connectivity matrix :return: minimum number of transit changes required or -1 if unreachable >>> min_transit_changes(4, 1, 3, [ ... [0, 1, 0, 0], ... [1, 0, 1, 1], ... [0, 1, 0, 1], ... [0, 1, 1, 0] ... ]) 2 >>> min_transit_changes(3, 1, 2, [ ... [0, 0, 0], ... [0, 0, 1], ... [0, 1, 0] ... ]) -1 import pytest from solution import min_transit_changes def test_example_1(): n = 4 start = 1 end = 3 matrix = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] assert min_transit_changes(n, start, end, matrix) == 2 def test_example_2(): n = 3 start = 1 end = 2 matrix = [ [0, 0, 0], [0, 0, 1], [0, 1, 0] ] assert min_transit_changes(n, start, end, matrix) == -1 def test_same_start_end(): n = 3 start = 1 end = 1 matrix = [ [0, 1, 0], [1, 0, 1], [0, 1, 0] ] assert min_transit_changes(n, start, end, matrix) == 0 def test_direct_link(): n = 3 start = 1 end = 2 matrix = [ [0, 1, 0], [1, 0, 0], [0, 0, 0] ] assert min_transit_changes(n, start, end, matrix) == 1 def test_no_connection(): n = 2 start = 1 end = 2 matrix = [ [0, 0], [0, 0] ] assert min_transit_changes(n, start, end, matrix) == -1","solution":"from collections import deque def min_transit_changes(n, start, end, matrix): start -= 1 end -= 1 if start == end: return 0 visited = [False] * n queue = deque([(start, 0)]) visited[start] = True while queue: current, changes = queue.popleft() for neighbor in range(n): if matrix[current][neighbor] == 1 and not visited[neighbor]: if neighbor == end: return changes + 1 visited[neighbor] = True queue.append((neighbor, changes + 1)) return -1 # Sample usage n = 4 start = 1 end = 3 matrix = [ [0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0] ] print(min_transit_changes(n, start, end, matrix)) # Output: 2"},{"question":"def smallest_permutation(S: str) -> List[str]: Returns the smallest lexicographical permutations for each substring length k from 1 to N. Args: S (str): The input string Returns: List[str]: A list containing the lexicographically smallest permutations for each k from 1 to N Examples: >>> smallest_permutation(\\"abcde\\") [\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\", \\"abcde\\"] >>> smallest_permutation(\\"a\\") [\\"a\\"] >>> smallest_permutation(\\"aaabc\\") [\\"a\\", \\"aa\\", \\"aaa\\", \\"aaab\\", \\"aaabc\\"] >>> smallest_permutation(\\"bacd\\") [\\"b\\", \\"ab\\", \\"abc\\", \\"abcd\\"] >>> smallest_permutation(\\"xy\\") [\\"x\\", \\"xy\\"]","solution":"from itertools import permutations def smallest_permutation(S): Returns smallest lexicographical permutations for each substring length k from 1 to N. N = len(S) results = [] # Loop through each K from 1 to N for k in range(1, N + 1): substr = S[:k] # Find all unique permutations for the substring perms = sorted(set(''.join(p) for p in permutations(substr))) # Get the lexicographically smallest permutation smallest_perm = perms[0] results.append(smallest_perm) return results"},{"question":"from typing import List, Union def find_combination(n: int, arr: List[int], t: int) -> Union[List[int], int]: Find a combination of elements in the array that sum up to the target t. Parameters: n (int): Size of the array. arr (List of int): List of integers in the array. t (int): Target sum. Returns: List of int: A list containing the combination of elements that sum up to t or -1 if no combination exists. >>> find_combination(5, [2, 3, 7, 8, 10], 10) [2, 8] >>> find_combination(4, [1, 2, 5, 9], 21) -1 >>> find_combination(3, [1, 3, 5], 0) []","solution":"from itertools import combinations def find_combination(n, arr, t): Find a combination of elements in the array that sum up to the target t. Parameters: n (int): Size of the array. arr (list of int): List of integers in the array. t (int): Target sum. Returns: list of int: A list containing the combination of elements that sum up to t or -1 if no combination exists. # Handle special case where target is 0 if t == 0: return [] # Try combinations of all possible lengths for r in range(1, n + 1): for combo in combinations(arr, r): if sum(combo) == t: return list(combo) return -1"},{"question":"def largest_block_size(grid, M, N): Find the size of the largest block of connected 1s in the grid. >>> largest_block_size([list('1100'), list('1100'), list('0010'), list('0001')], 4, 4) 4 >>> largest_block_size([list('101'), list('010'), list('101')], 3, 3) 1 def process_test_cases(test_cases): Process multiple test cases to find the largest block size for each grid. >>> process_test_cases([(4, 4, ['1100', '1100', '0010', '0001']), (3, 3, ['101', '010', '101'])]) [4, 1]","solution":"def largest_block_size(grid, M, N): def dfs(i, j): if i < 0 or j < 0 or i >= M or j >= N or grid[i][j] == '0': return 0 grid[i][j] = '0' # Mark the cell as visited size = 1 # Explore all 4 possible directions size += dfs(i + 1, j) size += dfs(i - 1, j) size += dfs(i, j + 1) size += dfs(i, j - 1) return size max_size = 0 for i in range(M): for j in range(N): if grid[i][j] == '1': max_size = max(max_size, dfs(i, j)) return max_size def process_test_cases(test_cases): results = [] for grid_info in test_cases: M, N, grid = grid_info grid = [list(row) for row in grid] results.append(largest_block_size(grid, M, N)) return results # Example usage: # test_cases = [ # (4, 4, ['1100', '1100', '0010', '0001']), # (3, 3, ['101', '010', '101']), # ] # print(process_test_cases(test_cases))"},{"question":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1: ListNode, l2: ListNode) -> ListNode: Add two numbers represented by two linked lists and return the sum as a linked list. The digits are stored in reverse order, and each of their nodes contains a single digit. >>> list_from_linked_list(addTwoNumbers(linked_list_from_list([2, 4, 3]), linked_list_from_list([5, 6, 4]))) [7, 0, 8] >>> list_from_linked_list(addTwoNumbers(linked_list_from_list([9, 9, 9, 9]), linked_list_from_list([9, 9, 9, 9]))) [8, 9, 9, 9, 1] >>> list_from_linked_list(addTwoNumbers(linked_list_from_list([5]), linked_list_from_list([5]))) [0, 1] >>> list_from_linked_list(addTwoNumbers(linked_list_from_list([1]), linked_list_from_list([9, 9]))) [0, 0, 1] >>> list_from_linked_list(addTwoNumbers(linked_list_from_list([]), linked_list_from_list([1, 2, 3]))) [1, 2, 3]","solution":"class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def addTwoNumbers(l1, l2): dummy = ListNode() current = dummy carry = 0 while l1 or l2 or carry: val1 = l1.val if l1 else 0 val2 = l2.val if l2 else 0 total = val1 + val2 + carry carry = total // 10 current.next = ListNode(total % 10) current = current.next if l1: l1 = l1.next if l2: l2 = l2.next return dummy.next def linked_list_from_list(lst): if not lst: return None head = ListNode(lst[0]) current = head for value in lst[1:]: current.next = ListNode(value) current = current.next return head def list_from_linked_list(node): result = [] while node: result.append(node.val) node = node.next return result"},{"question":"from typing import List def count_flower_regions(garden: List[List[int]]) -> int: This function takes a 2D list representing a garden and returns the number of distinct flower regions. >>> count_flower_regions([[1, 1, 2, 2, 3], [1, 2, 2, 3, 3], [4, 4, 4, 3, 1], [4, 1, 1, 5, 5]]) 7 >>> count_flower_regions([[1, 1], [1, 1]]) 1 >>> count_flower_regions([[1]]) 1 >>> count_flower_regions([[1, 2], [3, 4]]) 4 >>> count_flower_regions([[7, 7, 7], [7, 7, 7], [7, 7, 7]]) 1","solution":"def count_flower_regions(garden): This function takes a 2D list representing a garden and returns the number of distinct flower regions. if not garden: return 0 m, n = len(garden), len(garden[0]) visited = [[False] * n for _ in range(m)] def dfs(x, y, flower_type): if x < 0 or y < 0 or x >= m or y >= n: return if garden[x][y] != flower_type or visited[x][y]: return visited[x][y] = True dfs(x + 1, y, flower_type) dfs(x - 1, y, flower_type) dfs(x, y + 1, flower_type) dfs(x, y - 1, flower_type) regions = 0 for i in range(m): for j in range(n): if not visited[i][j]: regions += 1 dfs(i, j, garden[i][j]) return regions # Example usage m, n = 4, 5 garden = [ [1, 1, 2, 2, 3], [1, 2, 2, 3, 3], [4, 4, 4, 3, 1], [4, 1, 1, 5, 5] ] print(count_flower_regions(garden)) # Output: 7"},{"question":"import re from typing import List def validate_phone_numbers(n: int, phone_numbers: List[str]) -> List[str]: Validates a list of phone numbers based on the given rules. Parameters: n (int): Number of phone numbers to validate phone_numbers (list of str): The phone numbers in string format Returns: list of str: List of \\"VALID\\" or \\"INVALID\\" for each phone number results = [] pattern = re.compile(r\\"^+d{1,3} d{4,10}\\") for number in phone_numbers: if pattern.match(number): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results # Test cases def test_validate_phone_numbers_all_valid(): numbers = [\\"+123 4567890\\", \\"+1 2345\\", \\"+12 1234567890\\"] expected = [\\"VALID\\", \\"VALID\\", \\"VALID\\"] assert validate_phone_numbers(len(numbers), numbers) == expected def test_validate_phone_numbers_all_invalid(): numbers = [\\"+1234 56789\\", \\"+123 12345678901\\", \\"+ 12345\\", \\"+12 123\\"] expected = [\\"INVALID\\", \\"INVALID\\", \\"INVALID\\", \\"INVALID\\"] assert validate_phone_numbers(len(numbers), numbers) == expected def test_validate_phone_numbers_mixed(): numbers = [\\"+123 4567890\\", \\"+1234 56789\\", \\"+12 1234567890\\", \\"+1 234\\"] expected = [\\"VALID\\", \\"INVALID\\", \\"VALID\\", \\"INVALID\\"] assert validate_phone_numbers(len(numbers), numbers) == expected def test_validate_phone_numbers_min_max_valid(): numbers = [\\"+1 1234\\", \\"+999 1234567890\\"] expected = [\\"VALID\\", \\"VALID\\"] assert validate_phone_numbers(len(numbers), numbers) == expected def test_validate_phone_numbers_edge_cases(): numbers = [\\"+\\", \\"+123 \\"] expected = [\\"INVALID\\", \\"INVALID\\"] assert validate_phone_numbers(len(numbers), numbers) == expected","solution":"import re def validate_phone_numbers(n, phone_numbers): Validates a list of phone numbers based on the given rules. Parameters: n (int): Number of phone numbers to validate phone_numbers (list of str): The phone numbers in string format Returns: list of str: List of \\"VALID\\" or \\"INVALID\\" for each phone number results = [] pattern = re.compile(r\\"^+d{1,3} d{4,10}\\") for number in phone_numbers: if pattern.match(number): results.append(\\"VALID\\") else: results.append(\\"INVALID\\") return results"},{"question":"from typing import List def contains_duplicates(nums: List[int]) -> bool: Returns True if the list contains any duplicates, otherwise False. >>> contains_duplicates([1, 2, 3, 4, 5]) False >>> contains_duplicates([1, 2, 3, 2, 5]) True >>> contains_duplicates([1, 1, 1, 1]) True >>> contains_duplicates([1]) False >>> contains_duplicates([]) False >>> contains_duplicates(list(range(10000))) False >>> contains_duplicates(list(range(10000)) + [9999]) True","solution":"def contains_duplicates(nums): Returns True if the list contains any duplicates, otherwise False. return len(nums) != len(set(nums))"},{"question":"def decode_tablets(inputs): Given the input tablets, decode the symbols and their respective frequencies sorted as specified. pass # Ensure you have the necessary imports # from typing import List Unit Test: def test_example1(): inputs = [\\"7\\", \\"AABBBCC\\", \\"9\\", \\"ZZA978AA9\\", \\"DONE\\"] expected_output = [\\"B 3\\", \\"A 2\\", \\"C 2\\", \\"A 3\\", \\"9 2\\", \\"Z 2\\", \\"7 1\\", \\"8 1\\"] assert decode_tablets(inputs) == expected_output def test_example2(): inputs = [\\"5\\", \\"ABCDE\\", \\"10\\", \\"AAAAABBBB\\", \\"DONE\\"] expected_output = [\\"A 1\\", \\"B 1\\", \\"C 1\\", \\"D 1\\", \\"E 1\\", \\"A 5\\", \\"B 4\\"] assert decode_tablets(inputs) == expected_output def test_with_digits(): inputs = [\\"6\\", \\"123322\\", \\"4\\", \\"0077\\", \\"DONE\\"] expected_output = [\\"2 3\\", \\"3 2\\", \\"1 1\\", \\"0 2\\", \\"7 2\\"] assert decode_tablets(inputs) == expected_output def test_single_tablet(): inputs = [\\"3\\", \\"AAA\\", \\"DONE\\"] expected_output = [\\"A 3\\"] assert decode_tablets(inputs) == expected_output def test_mixed_symbols(): inputs = [\\"8\\", \\"A1B1C1D1\\", \\"DONE\\"] expected_output = [\\"1 4\\", \\"A 1\\", \\"B 1\\", \\"C 1\\", \\"D 1\\"] assert decode_tablets(inputs) == expected_output","solution":"def decode_tablets(inputs): Given the input tablets, decode the symbols and their respective frequencies sorted as specified. outputs = [] i = 0 while i < len(inputs): if inputs[i] == \\"DONE\\": break N = int(inputs[i]) symbols = inputs[i + 1] symbol_count = {} for symbol in symbols: if symbol in symbol_count: symbol_count[symbol] += 1 else: symbol_count[symbol] = 1 sorted_symbols = sorted(symbol_count.items(), key=lambda x: (-x[1], x[0])) for sym, count in sorted_symbols: outputs.append(f\\"{sym} {count}\\") i += 2 return outputs"},{"question":"def submarine_directions(t: int, distances: List[Tuple[int, int, int, int]]) -> List[str]: Returns the direction the submarine should move to maximize the time until it encounters an obstacle. Parameters: t (int): Number of time points. distances (List[Tuple[int, int, int, int]]): List of tuples representing the distances to nearest obstacles in the order (front, back, left, right). Returns: List[str]: A list of characters representing the direction to move at each time point ('F', 'B', 'L', or 'R'). >>> submarine_directions(3, [(3, 4, 2, 5), (6, 1, 3, 6), (5, 5, 5, 5)]) ['R', 'F', 'F'] >>> submarine_directions(1, [(5, 3, 5, 2)]) ['F']","solution":"def submarine_directions(t, distances): Returns the direction the submarine should move to maximize the time until it encounters an obstacle. Parameters: t (int): Number of time points. distances (List[Tuple[int, int, int, int]]): List of tuples representing the distances to nearest obstacles in the order (front, back, left, right). Returns: List[str]: A list of characters representing the direction to move at each time point ('F', 'B', 'L', or 'R'). directions = [] for i in range(t): f, b, l, r = distances[i] max_distance = max(f, b, l, r) if f == max_distance: directions.append('F') elif b == max_distance: directions.append('B') elif l == max_distance: directions.append('L') elif r == max_distance: directions.append('R') return directions"},{"question":"def rob_houses(houses): Given a list of non-negative integers representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. >>> rob_houses([1, 2, 9, 4]) 10 >>> rob_houses([0, 0, 0, 0]) 0 >>> rob_houses([5]) 5 >>> rob_houses([5, 10]) 10 >>> rob_houses([10, 1, 10, 1, 10]) 30 >>> rob_houses([100, 1, 100, 1, 100, 1, 100]) 400 >>> rob_houses([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) 30 >>> rob_houses([1, 3, 1, 3, 100]) 103","solution":"def rob_houses(houses): Given a list of non-negative integers representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police. n = len(houses) if n == 0: return 0 if n == 1: return houses[0] dp = [0] * n dp[0] = houses[0] dp[1] = max(houses[0], houses[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + houses[i]) return dp[-1] # For the input example mentioned in the question n = 4 houses = [1, 2, 9, 4] print(rob_houses(houses)) # Output should be 10"},{"question":"def transform_string(s: str) -> str: Transforms the input string s by replacing each vowel with the next vowel in the sequence. >>> transform_string(\\"hello\\") 'hillu' >>> transform_string(\\"programming\\") 'prugremmong' >>> transform_string(\\"a\\") 'e' >>> transform_string(\\"b\\") 'b' >>> transform_string(\\"bcdfghjklmnpqrstvwxyz\\") 'bcdfghjklmnpqrstvwxyz' >>> transform_string(\\"aeiou\\") 'eioua' >>> transform_string(\\"a1b!e@i#ou%\\") 'e1b!i@o#ua%' >>> transform_string(\\"a\\" * 100000) 'e' * 100000","solution":"def transform_string(s): Transforms the input string s by replacing each vowel with the next vowel in the sequence. vowels = 'aeiou' next_vowel = {'a': 'e', 'e': 'i', 'i': 'o', 'o': 'u', 'u': 'a'} transformed_chars = [] for char in s: if char in vowels: transformed_chars.append(next_vowel[char]) else: transformed_chars.append(char) return ''.join(transformed_chars)"},{"question":"def max_non_overlapping_contests(n: int, k: int) -> int: Returns the maximum number of non-overlapping contests that can be organized with given number of participants (n) and segment length (k). >>> max_non_overlapping_contests(10, 10) 1 >>> max_non_overlapping_contests(10, 3) 3 >>> max_non_overlapping_contests(8, 4) 2","solution":"def max_non_overlapping_contests(n, k): Returns the maximum number of non-overlapping contests that can be organized with given number of participants (n) and segment length (k). return n // k"},{"question":"def collect_treasure(grid, start_row, start_col): Returns the maximum treasure value the player can collect starting from the specified cell. >>> collect_treasure([ [0, 2, 0, 3], [0, 3, 1, 0], [4, 0, 0, 2], [0, 1, 2, 0] ], 1, 1) 6 >>> collect_treasure([ [1, 2, 3], [4, 5, 6], [7, 8, 9] ], 0, 0) 45 >>> collect_treasure([ [0, 0, 0], [0, 5, 0], [0, 0, 0] ], 1, 1) 5 >>> collect_treasure([ [1, 0, 2], [0, 0, 0], [3, 0, 4] ], 0, 0) 1 >>> collect_treasure([ [0, 1, 0], [2, 0, 0], [0, 0, 3], [4, 0, 0] ], 3, 0) 4","solution":"def collect_treasure(grid, start_row, start_col): Returns the maximum treasure value the player can collect starting from the specified cell. N = len(grid) visited = [[False] * N for _ in range(N)] def dfs(row, col): if row < 0 or col < 0 or row >= N or col >= N or visited[row][col] or grid[row][col] == 0: return 0 visited[row][col] = True total_value = grid[row][col] # Explore all four directions total_value += dfs(row + 1, col) total_value += dfs(row - 1, col) total_value += dfs(row, col + 1) total_value += dfs(row, col - 1) return total_value # Start DFS from the specified cell return dfs(start_row, start_col)"},{"question":"def can_collect_gemstones(required: str, available: str) -> str: Determine if it's possible to collect all required gemstones from the available gemstones. >>> can_collect_gemstones(\\"aaabbc\\", \\"abbccddee\\") \\"NO\\" >>> can_collect_gemstones(\\"abcd\\", \\"abcabcabcabcddd\\") \\"YES\\" >>> can_collect_gemstones(\\"a\\", \\"b\\") \\"NO\\"","solution":"def can_collect_gemstones(required, available): from collections import Counter required_count = Counter(required) available_count = Counter(available) for gem in required_count: if required_count[gem] > available_count.get(gem, 0): return \\"NO\\" return \\"YES\\""},{"question":"def merge_presentation_sequences(d: int, k: int, departments: List[List[int]]) -> List[int]: Merges all the department's proposed sequences into one single sequence such that each sequence respects the chronological order of each department and no more than k presentations are taken from any single department. :param d: Number of departments :param k: Maximum number of presentations from any department :param departments: List of lists where each sublist contains proposed sequence of presentations by that department :return: A list representing a valid consolidated sequence of presentations >>> merge_presentation_sequences(3, 2, [[101, 102, 103, 104, 105], [201, 202, 203], [301, 302, 303, 304]]) [101, 102, 201, 202, 301, 302] >>> merge_presentation_sequences(2, 1, [[401, 402, 403, 404], [501, 502, 503, 504, 505]]) [401, 501]","solution":"def merge_presentation_sequences(d, k, departments): Merges all the department's proposed sequences into one single sequence such that each sequence respects the chronological order of each department and no more than k presentations are taken from any single department. :param d: Number of departments :param k: Maximum number of presentations from any department :param departments: List of lists where each sublist contains proposed sequence of presentations by that department :return: A list representing a valid consolidated sequence of presentations # This will hold the selected presentations in order result = [] # Iterate through each department for department in departments: # Add at most k presentations from each department to the result result.extend(department[:k]) return result"},{"question":"def qualifies_for_discount(n: int, t: int, amounts: List[int]) -> str: Determines if a customer qualifies for a discount based on their shopping history. :param n: Number of days :param t: Threshold value :param amounts: List of amounts spent each day :return: \\"YES\\" if customer qualifies for discount, \\"NO\\" otherwise >>> qualifies_for_discount(5, 3, [10, 12, 9, 11, 10]) \\"YES\\" >>> qualifies_for_discount(4, 2, [8, 5, 12, 10]) \\"NO\\"","solution":"def qualifies_for_discount(n, t, amounts): Determines if a customer qualifies for a discount based on their shopping history. :param n: Number of days :param t: Threshold value :param amounts: List of amounts spent each day :return: \\"YES\\" if customer qualifies for discount, \\"NO\\" otherwise for i in range(n - 1): if abs(amounts[i] - amounts[i + 1]) > t: return \\"NO\\" return \\"YES\\""},{"question":"def shortest_interesting_subarray(n: int, k: int, a: List[int]) -> int: Determine the length of the shortest subarray that has exactly k distinct elements. Args: n (int): The length of the array. k (int): The number of distinct elements required in the subarray. a (List[int]): The array of integers. Returns: int: The length of the shortest interesting subarray, or -1 if no such subarray exists. Examples: >>> shortest_interesting_subarray(7, 2, [1, 2, 1, 3, 4, 2, 3]) 2 >>> shortest_interesting_subarray(5, 3, [1, 2, 3, 2, 2]) 3 >>> shortest_interesting_subarray(1, 1, [1]) 1 >>> shortest_interesting_subarray(5, 1, [2, 2, 2, 2, 2]) 1 >>> shortest_interesting_subarray(3, 4, [1, 2, 3]) -1 >>> shortest_interesting_subarray(6, 6, [1, 2, 3, 4, 5, 6]) 6 >>> shortest_interesting_subarray(10, 2, [1, 2, 1, 1, 1, 1, 1, 1, 2, 1]) 2 pass","solution":"def shortest_interesting_subarray(n, k, a): from collections import defaultdict freq = defaultdict(int) distinct_count = 0 min_length = float('inf') left = 0 for right in range(n): if freq[a[right]] == 0: distinct_count += 1 freq[a[right]] += 1 while distinct_count >= k: min_length = min(min_length, right - left + 1) freq[a[left]] -= 1 if freq[a[left]] == 0: distinct_count -= 1 left += 1 return min_length if min_length != float('inf') else -1"},{"question":"def organize_marathon(n: int, m: int, segments: List[Tuple[int, int]]) -> str: Determine if it is possible to set up water stations without overlays, and whether each segment should cover the clockwise or anticlockwise portion between the given checkpoints. >>> organize_marathon(5, 2, [(1, 3), (2, 5)]) 'ca' >>> organize_marathon(6, 3, [(1, 4), (2, 6), (3, 5)]) 'acc' >>> organize_marathon(4, 2, [(1, 2), (2, 3)]) 'cc' >>> organize_marathon(4, 2, [(2, 1), (3, 2)]) 'aa'","solution":"def organize_marathon(n, m, segments): def clockwise_dist(a, b, n): return (b - a) % n def anticlockwise_dist(a, b, n): return (a - b) % n result = [] for a, b in segments: cw_dist = clockwise_dist(a, b, n) acw_dist = anticlockwise_dist(a, b, n) if cw_dist <= acw_dist: result.append('c') else: result.append('a') return ''.join(result) # Sample call for testing n = 5 m = 2 segments = [(1, 3), (2, 5)] print(organize_marathon(n, m, segments)) # Expected output \\"ca\\""},{"question":"def nearest_taller_tree_to_right(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[List[int]]: For each tree, find the nearest tree to the right that immediately exceeds it in height. >>> nearest_taller_tree_to_right(2, [(6, [3, 1, 4, 2, 5, 2]), (5, [6, 5, 4, 3, 2])]) [[4, 4, 5, 5, -1, -1], [-1, -1, -1, -1, -1]] >>> nearest_taller_tree_to_right(1, [(1, [5])]) [[-1]] >>> nearest_taller_tree_to_right(1, [(4, [3, 3, 3, 3])]) [[-1, -1, -1, -1]] >>> nearest_taller_tree_to_right(1, [(5, [5, 4, 3, 2, 1])]) [[-1, -1, -1, -1, -1]] >>> nearest_taller_tree_to_right(1, [(5, [1, 2, 3, 4, 5])]) [[2, 3, 4, 5, -1]]","solution":"def nearest_taller_tree_to_right(t, test_cases): results = [] for case in test_cases: n, heights = case result = [-1] * n stack = [] for i in range(n - 1, -1, -1): while stack and heights[stack[-1]] <= heights[i]: stack.pop() if stack: result[i] = heights[stack[-1]] stack.append(i) results.append(result) return results"},{"question":"def can_cover_room(l, w, t_l, t_w): Determines if a room of size l x w can be perfectly covered by tiles of size t_l x t_w. Args: l (int): Length of the room. w (int): Width of the room. t_l (int): Length of the tile. t_w (int): Width of the tile. Returns: str: \\"yes\\" if the room can be perfectly covered with the tiles, \\"no\\" otherwise. >>> can_cover_room(6, 8, 3, 4) \\"yes\\" >>> can_cover_room(5, 7, 3, 2) \\"no\\" >>> can_cover_room(9, 9, 3, 3) \\"yes\\" >>> can_cover_room(10, 15, 4, 5) \\"no\\"","solution":"def can_cover_room(l, w, t_l, t_w): Determines if a room of size l x w can be perfectly covered by tiles of size t_l x t_w. Args: l (int): Length of the room. w (int): Width of the room. t_l (int): Length of the tile. t_w (int): Width of the tile. Returns: str: \\"yes\\" if the room can be perfectly covered with the tiles, \\"no\\" otherwise. if (l % t_l == 0 and w % t_w == 0) or (l % t_w == 0 and w % t_l == 0): return \\"yes\\" else: return \\"no\\""},{"question":"def solve(N: int, Q: int, problems: List[int], queries: List[Tuple[int, int]]) -> List[int]: Returns a list of sums of problems solved over given ranges from the queries. Args: N: int : Number of days Q: int : Number of queries problems: List[int] : List of problems solved each day queries: List[Tuple[int, int]] : List of L and R pairs (1-based index) Returns: List[int] : List of sums for each query range Example: >>> solve(5, 3, [2, 4, 3, 1, 6], [(1, 3), (2, 4), (3, 5)]) [9, 8, 10] >>> solve(5, 1, [2, 4, 3, 1, 6], [(1, 5)]) [16] >>> solve(5, 5, [2, 4, 3, 1, 6], [(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)]) [2, 4, 3, 1, 6] >>> solve(5, 3, [0, 0, 0, 0, 0], [(1, 3), (2, 4), (3, 5)]) [0, 0, 0]","solution":"def solve(N, Q, problems, queries): Returns a list of sums of problems solved over given ranges from the queries. Args: N: int : Number of days Q: int : Number of queries problems: List[int] : List of problems solved each day queries: List[Tuple[int, int]] : List of L and R pairs (1-based index) Returns: List[int] : List of sums for each query range # Create prefix sum array prefix_sum = [0] * (N + 1) for i in range(1, N + 1): prefix_sum[i] = prefix_sum[i - 1] + problems[i - 1] # Process each query results = [] for (L, R) in queries: sum_in_range = prefix_sum[R] - prefix_sum[L - 1] results.append(sum_in_range) return results"},{"question":"def max_projects_assigned(n: int, employee_skills: List[int], project_requirements: List[int]) -> int: Determines the maximum number of projects that can be successfully assigned based on employee skill levels and project skill requirements. Parameters: n (int): The number of projects and employees. employee_skills (list of int): Skill levels of employees. project_requirements (list of int): Skill requirements of projects. Returns: int: The maximum number of projects that can be successfully assigned. >>> max_projects_assigned(5, [4, 2, 3, 1, 5], [3, 2, 1, 5, 4]) 5 >>> max_projects_assigned(4, [3, 1, 4, 1], [2, 3, 1, 2]) 3","solution":"def max_projects_assigned(n, employee_skills, project_requirements): Determines the maximum number of projects that can be successfully assigned based on employee skill levels and project skill requirements. Parameters: n (int): The number of projects and employees. employee_skills (list of int): Skill levels of employees. project_requirements (list of int): Skill requirements of projects. Returns: int: The maximum number of projects that can be successfully assigned. # Sort employee skills and project requirements in ascending order employee_skills.sort() project_requirements.sort() # Initialize counters for project assignment i = 0 j = 0 count = 0 # Iterate through employees and projects while i < n and j < n: if employee_skills[i] >= project_requirements[j]: # If the employee's skill level meets or exceeds the project requirement, assign the project count += 1 j += 1 # Move to the next project # Move to the next employee i += 1 return count"},{"question":"from typing import List, Tuple def min_subarray_length_with_sum(arr: List[int], X: int) -> int: Given an array of integers, find the minimum length of a contiguous subarray that sums to a target value X. If no such subarray exists, return 0. >>> min_subarray_length_with_sum([1, 2, 3, 4, 5], 11) 3 >>> min_subarray_length_with_sum([1, 2, 3, 4, 5, 6, 7], 10) 2 >>> min_subarray_length_with_sum([0, -1, 2, 1], 2) 2 >>> min_subarray_length_with_sum([1, 2, 3], 10) 0 pass def get_min_lengths_for_test_cases(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Processes multiple test cases and returns a list of minimum lengths for contiguous subarrays that sum to the target value. pass","solution":"def min_subarray_length_with_sum(arr, X): Given an array of integers, find the minimum length of a contiguous subarray that sums to a target value X. If no such subarray exists, return 0. n = len(arr) min_len = float('inf') curr_sum = 0 start = 0 for end in range(n): curr_sum += arr[end] while curr_sum >= X: min_len = min(min_len, end - start + 1) curr_sum -= arr[start] start += 1 return min_len if min_len != float('inf') else 0 def get_min_lengths_for_test_cases(test_cases): Processes multiple test cases and returns a list of minimum lengths for contiguous subarrays that sum to the target value. results = [] for case in test_cases: N, X, array = case result = min_subarray_length_with_sum(array, X) results.append(result) return results"},{"question":"def maximize_array_sum(n, k, arr): Maximizes the sum of the array by reversing subarrays at most k times. Args: n (int): Number of elements in the array. k (int): Maximum number of operations allowed. arr (list): The initial array of integers. Returns: int: The maximum possible sum of the array after at most k operations. Examples: >>> maximize_array_sum(5, 2, [1, -2, 3, -4, 5]) 15 >>> maximize_array_sum(3, 1, [-1, 2, -3]) 2","solution":"def maximize_array_sum(n, k, arr): Maximizes the sum of the array by reversing subarrays at most k times. Args: n (int): Number of elements in the array. k (int): Maximum number of operations allowed. arr (list): The initial array of integers. Returns: int: The maximum possible sum of the array after at most k operations. # The core idea here is that reversing an array always results in the same elements # and therefore the maximum possible sum is the sum of the non-negative elements. # As long as k > 0, we can always turn the array into its optimal form by # reversing arbitrary subarrays, since reversing an array does not change the sum # of its elements. # We only need to find the sum of positive elements. max_sum = sum(x for x in arr if x > 0) return max_sum if max_sum != 0 else max(arr)"},{"question":"from typing import List, Dict, Tuple def analyze_grades(test_cases: List[Dict[str, List]]) -> List[str]: Analyze grade records of students and perform specific calculations based on given queries. Args: test_cases (List[Dict[str, List]]): List of dictionaries containing students and their grades, and the queries to be answered. Returns: List[str]: Results for each query in all test cases. >>> test_cases = [ ... {'students': [('Alice', 78), ('Bob', 85), ('Charlie', 90)], ... 'queries': ['MAX_GRADE', 'MIN_GRADE', 'AVERAGE_GRADE']}, ... {'students': [('David', 92), ('Eva', 88)], ... 'queries': ['MIN_GRADE', 'MAX_GRADE']} ... ] >>> analyze_grades(test_cases) ['Charlie', 'Alice', '84', 'Eva', 'David'] pass def process_input_output(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 students = [] for _ in range(N): name = data[index] grade = int(data[index + 1]) students.append((name, grade)) index += 2 Q = int(data[index]) index += 1 queries = [] for _ in range(Q): queries.append(data[index]) index += 1 test_cases.append({'students': students, 'queries': queries}) results = analyze_grades(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": process_input_output() def test_analyze_grades(): test_cases = [ { 'students': [('Alice', 78), ('Bob', 85), ('Charlie', 90)], 'queries': ['MAX_GRADE', 'MIN_GRADE', 'AVERAGE_GRADE'] }, { 'students': [('David', 92), ('Eva', 88)], 'queries': ['MIN_GRADE', 'MAX_GRADE'] } ] results = analyze_grades(test_cases) assert results == ['Charlie', 'Alice', '84', 'Eva', 'David'] def test_tie_grades(): test_cases = [ { 'students': [('Alice', 90), ('Bob', 90), ('Charlie', 85)], 'queries': ['MAX_GRADE', 'MIN_GRADE'] } ] results = analyze_grades(test_cases) assert results == ['Alice', 'Charlie'] def test_single_student(): test_cases = [ { 'students': [('Alice', 100)], 'queries': ['MAX_GRADE', 'MIN_GRADE', 'AVERAGE_GRADE'] } ] results = analyze_grades(test_cases) assert results == ['Alice', 'Alice', '100'] def test_multiple_queries(): test_cases = [ { 'students': [('Alice', 70), ('Bob', 80), ('Charlie', 90)], 'queries': ['MIN_GRADE', 'AVERAGE_GRADE', 'MAX_GRADE', 'MIN_GRADE', 'MAX_GRADE'] } ] results = analyze_grades(test_cases) assert results == ['Alice', '80', 'Charlie', 'Alice', 'Charlie']","solution":"def analyze_grades(test_cases): results = [] for case in test_cases: students = case['students'] queries = case['queries'] names_grades = sorted(students, key=lambda x: x[0]) sorted_by_grades_desc = sorted(names_grades, key=lambda x: -x[1]) sorted_by_grades_asc = sorted(names_grades, key=lambda x: x[1]) for query in queries: if query == \\"MAX_GRADE\\": results.append(sorted_by_grades_desc[0][0]) elif query == \\"MIN_GRADE\\": results.append(sorted_by_grades_asc[0][0]) elif query == \\"AVERAGE_GRADE\\": total_grades = sum(grade for name, grade in students) avg_grade = total_grades // len(students) results.append(str(avg_grade)) return results def process_input_output(): import sys input = sys.stdin.read data = input().split() index = 0 T = int(data[index]) index += 1 test_cases = [] for _ in range(T): N = int(data[index]) index += 1 students = [] for _ in range(N): name = data[index] grade = int(data[index + 1]) students.append((name, grade)) index += 2 Q = int(data[index]) index += 1 queries = [] for _ in range(Q): queries.append(data[index]) index += 1 test_cases.append({'students': students, 'queries': queries}) results = analyze_grades(test_cases) for result in results: print(result) if __name__ == \\"__main__\\": process_input_output()"},{"question":"def max_stamp_values(test_cases: List[Tuple[int, int, List[int]]]) -> List[int]: Determines the maximum sum of the stamp values Aayush can carry given several test cases. Parameters: - test_cases: List of test cases, where each test case is a tuple containing: * An integer n: The number of stamps * An integer k: The maximum number of stamps Aayush can carry * A list of integers stamp_values: The values of each stamp Returns: - A list of integers representing the maximum sum of the stamp values Aayush can carry for each test case. Example: >>> max_stamp_values([(5, 3, [10, 40, 20, 30, 50])]) [120] >>> max_stamp_values([(4, 4, [15, 25, 35, 45])]) [120] >>> max_stamp_values([(6, 2, [5, 100, 50, 60, 70, 80])]) [180]","solution":"def max_stamp_values(test_cases): Determines the maximum sum of the stamp values Aayush can carry given several test cases. Parameters: - test_cases: List of test cases, where each test case is a tuple containing: * An integer n: The number of stamps * An integer k: The maximum number of stamps Aayush can carry * A list of integers stamp_values: The values of each stamp Returns: - A list of integers representing the maximum sum of the stamp values Aayush can carry for each test case. results = [] for n, k, stamp_values in test_cases: # Sort the stamp values in descending order to maximize the sum of the top k values stamp_values.sort(reverse=True) # Take the first k values and sum them up max_sum = sum(stamp_values[:k]) results.append(max_sum) return results # Example Input t = 3 test_cases = [ (5, 3, [10, 40, 20, 30, 50]), (4, 4, [15, 25, 35, 45]), (6, 2, [5, 100, 50, 60, 70, 80]) ] # Example Output print(max_stamp_values(test_cases)) # Output should be [120, 120, 180]"},{"question":"from typing import List def length_of_longest_substring_two_distinct(s: str) -> int: Given a string s, return the length of the longest contiguous substring that contains at most two distinct characters. >>> length_of_longest_substring_two_distinct(\\"eceba\\") 3 >>> length_of_longest_substring_two_distinct(\\"ccaabbb\\") 5 >>> length_of_longest_substring_two_distinct(\\"aaaaa\\") 5 # Implementation goes here def process_test_cases(T: int, test_cases: List[str]) -> List[int]: Process multiple test cases for length_of_longest_substring_two_distinct. >>> process_test_cases(3, [\\"eceba\\", \\"ccaabbb\\", \\"aaaaa\\"]) [3, 5, 5] >>> process_test_cases(2, [\\"ab\\", \\"abaccc\\"]) [2, 4] >>> process_test_cases(1, [\\"abcabcabc\\"]) [2] # Implementation goes here","solution":"def length_of_longest_substring_two_distinct(s): Given a string s, return the length of the longest contiguous substring that contains at most two distinct characters. if not s: return 0 n = len(s) left = 0 right = 0 max_len = 0 char_count = {} while right < n: char_count[s[right]] = char_count.get(s[right], 0) + 1 while len(char_count) > 2: char_count[s[left]] -= 1 if char_count[s[left]] == 0: del char_count[s[left]] left += 1 max_len = max(max_len, right - left + 1) right += 1 return max_len def process_test_cases(T, test_cases): results = [] for s in test_cases: results.append(length_of_longest_substring_two_distinct(s)) return results"},{"question":"def max_difficulty_rating(t, test_cases): Compute the maximum possible total difficulty rating of problems that can be solved while following the prerequisites. Args: t (int): The number of test cases. test_cases (List): List of test cases, where each test case contains: - an integer \`n\` (number of problems) - a list of n pairs (category, difficulty rating) Returns: List[int]: List of maximum possible total difficulty ratings for each test case. Examples: >>> max_difficulty_rating(3, [ 3, [\\"Beginner\\", \\"3\\", \\"Intermediate\\", \\"5\\", \\"Advanced\\", \\"8\\"], 4, [\\"Beginner\\", \\"2\\", \\"Beginner\\", \\"3\\", \\"Intermediate\\", \\"4\\", \\"Advanced\\", \\"9\\"], 3, [\\"Intermediate\\", \\"1\\", \\"Intermediate\\", \\"6\\", \\"Advanced\\", \\"10\\"] ]) [16, 18, 0] >>> max_difficulty_rating(1, [ 2, [\\"Intermediate\\", \\"2\\", \\"Advanced\\", \\"5\\"] ]) [0]","solution":"def max_difficulty_rating(t, test_cases): results = [] for i in range(t): n = test_cases[i*2] problems = test_cases[i*2 + 1] beginner_ratings = [] intermediate_ratings = [] advanced_ratings = [] for j in range(0, len(problems), 2): category = problems[j] rating = int(problems[j+1]) if category == \\"Beginner\\": beginner_ratings.append(rating) elif category == \\"Intermediate\\": intermediate_ratings.append(rating) elif category == \\"Advanced\\": advanced_ratings.append(rating) if beginner_ratings: max_beginner = sum(beginner_ratings) if intermediate_ratings: max_intermediate = sum(intermediate_ratings) if advanced_ratings: max_advanced = sum(advanced_ratings) results.append(max_beginner + max_intermediate + max_advanced) else: results.append(max_beginner + max_intermediate) else: results.append(max_beginner) else: results.append(0) return results"},{"question":"def count_even_keypad_numbers(n): Determine the number of N-digit even numbers that can be formed using only the digits from 1 to 9. >>> count_even_keypad_numbers(1) 4 >>> count_even_keypad_numbers(2) 32 >>> count_even_keypad_numbers(3) 256","solution":"def count_even_keypad_numbers(n): Returns the count of N-digit numbers that are even using the digits 1-9. if n == 1: return 4 # Only the keys {2, 4, 6, 8} are valid single-digit even numbers. # Number of choices for the last digit (since it must be even) even_digit_choices = 4 # (2, 4, 6, 8) # Number of choices for all other (n-1) digits other_digit_choices = 8 # (1, 2, 3, 4, 5, 6, 7, 8, 9), 9 choices in total minus the fact that # first digit can't be zero, so effectively 8 choices. return even_digit_choices * (other_digit_choices ** (n - 1))"},{"question":"def longest_palindromic_substring_length(s: str) -> int: Returns the length of the longest palindromic substring in the given string. >>> longest_palindromic_substring_length(\\"babad\\") 3 >>> longest_palindromic_substring_length(\\"cbbd\\") 2 >>> longest_palindromic_substring_length(\\"a\\") 1 >>> longest_palindromic_substring_length(\\"ac\\") 1 >>> longest_palindromic_substring_length(\\"forgeeksskeegfor\\") 10 >>> longest_palindromic_substring_length(\\"abcdefg\\") 1 >>> longest_palindromic_substring_length(\\"aaabbaaa\\") 8","solution":"def longest_palindromic_substring_length(s): Returns the length of the longest palindromic substring in s. n = len(s) if n == 0: return 0 dp = [[False] * n for _ in range(n)] max_length = 1 for i in range(n): dp[i][i] = True start = 0 for i in range(n - 1): if s[i] == s[i + 1]: dp[i][i + 1] = True start = i max_length = 2 for length in range(3, n + 1): for i in range(n - length + 1): j = i + length - 1 if dp[i+1][j-1] and s[i] == s[j]: dp[i][j] = True if length > max_length: start = i max_length = length return max_length"},{"question":"from typing import List def maxGold(n: int, gold: List[int]) -> int: Given the number of houses and the amount of gold in each house, determine the maximum amount of gold the thief can rob without triggering any alarms. >>> maxGold(5, [1, 2, 3, 1, 5]) 9 >>> maxGold(4, [2, 7, 9, 3]) 11 >>> maxGold(3, [100, 1, 100]) 200 >>> maxGold(0, []) 0 >>> maxGold(1, [10]) 10 def main(test_cases: List[List[int]]) -> List[int]: Process multiple test cases to determine the maximum amount of gold the thief can rob for each test case. >>> main([[5, [1, 2, 3, 1, 5]], [4, [2, 7, 9, 3]], [3, [100, 1, 100]], [0, []], [1, [10]]]) [9, 11, 200, 0, 10]","solution":"from typing import List def maxGold(n: int, gold: List[int]) -> int: if n == 0: return 0 if n == 1: return gold[0] # dp[i] will be the maximum amount of gold that can be collected from the first i+1 houses dp = [0] * n dp[0] = gold[0] dp[1] = max(gold[0], gold[1]) for i in range(2, n): dp[i] = max(dp[i-1], dp[i-2] + gold[i]) return dp[-1] def main(test_cases: List[List[int]]) -> List[int]: results = [] for case in test_cases: n, gold = case[0], case[1] results.append(maxGold(n, gold)) return results"},{"question":"def longest_distinct_subarray(arr: List[int]) -> int: Returns the length of the longest contiguous subarray with all distinct elements. Args: arr (List[int]): List of integers. Returns: int: Length of the longest contiguous subarray with all distinct elements. Examples: >>> longest_distinct_subarray([5, 1, 3, 5, 2, 3, 4, 1]) 5 >>> longest_distinct_subarray([-1, -2, -3, -1, -2, -3, -4, -5]) 5","solution":"def longest_distinct_subarray(arr): Returns the length of the longest contiguous subarray with all distinct elements. n = len(arr) if n == 0: return 0 max_length = 0 start_idx = 0 seen_elements = {} for end_idx in range(n): if arr[end_idx] in seen_elements: start_idx = max(start_idx, seen_elements[arr[end_idx]] + 1) seen_elements[arr[end_idx]] = end_idx max_length = max(max_length, end_idx - start_idx + 1) return max_length"},{"question":"def max_happy_children(n: int, m: int, children_needs: List[int], cookies: List[int]) -> int: Function to calculate the maximum number of children that can be made happy with the given cookies. :param n: int : number of children :param m: int : number of cookies :param children_needs: list of int : minimum size of the cookie accepted by each child :param cookies: list of int : sizes of the cookies available :return: int : the maximum number of happy children >>> max_happy_children(3, 4, [1, 2, 3], [2, 2, 3, 4]) 3 >>> max_happy_children(2, 3, [1, 2], [1, 1, 1]) 1 >>> max_happy_children(3, 3, [2, 3, 4], [1, 1, 1]) 0 >>> max_happy_children(3, 3, [1, 2, 3], [3, 2, 1]) 3 >>> max_happy_children(5, 2, [1, 2, 3, 4, 5], [4, 2]) 2 >>> max_happy_children(3, 5, [1, 2, 3], [1, 2, 2, 3, 4]) 3","solution":"def max_happy_children(n, m, children_needs, cookies): Function to calculate the maximum number of children that can be made happy with the given cookies. :param n: int : number of children :param m: int : number of cookies :param children_needs: list of int : minimum size of the cookie accepted by each child :param cookies: list of int : sizes of the cookies available :return: int : the maximum number of happy children # Sort the children needs and cookies array children_needs.sort() cookies.sort() # Initialize counters for children and cookies i = 0 j = 0 happy_children = 0 # Traverse through both arrays while i < n and j < m: if cookies[j] >= children_needs[i]: # If the current cookie can satisfy the current child happy_children += 1 i += 1 # Move to the next cookie in either case j += 1 return happy_children"},{"question":"from collections import defaultdict import sys sys.setrecursionlimit(10**6) def calculate_maximum_path_sum(input_str: str) -> int: Calculate the maximum possible sum of weights on a simple path between any two vertices in the tree. >>> input_str = \\"5n1 2 3n2 3 4n2 4 2n3 5 6\\" >>> calculate_maximum_path_sum(input_str) 13 >>> input_str = \\"2n1 2 5\\" >>> calculate_maximum_path_sum(input_str) 5 >>> input_str = \\"3n1 2 4n1 3 6\\" >>> calculate_maximum_path_sum(input_str) 10 >>> input_str = \\"4n1 2 999999999n2 3 888888888n3 4 777777777\\" >>> calculate_maximum_path_sum(input_str) 2666666664","solution":"from collections import defaultdict import sys sys.setrecursionlimit(10**6) def find_farthest_node(tree, start_node, n): def dfs(node, parent, distance): farthest_node[0], farthest_dist[0] = (node, distance) if distance > farthest_dist[0] else (farthest_node[0], farthest_dist[0]) for neighbor, weight in tree[node]: if neighbor != parent: dfs(neighbor, node, distance + weight) farthest_node = [-1] farthest_dist = [-1] dfs(start_node, -1, 0) return farthest_node[0], farthest_dist[0] def maximum_path_sum(n, edges): tree = defaultdict(list) for u, v, w in edges: tree[u].append((v, w)) tree[v].append((u, w)) # Find the farthest node from any node (say node 1) node_A, _ = find_farthest_node(tree, 1, n) # Use that node to find the farthest node from it (node B), and the distance node_B, max_distance = find_farthest_node(tree, node_A, n) return max_distance # Function to read data, parse it, and then calculate the answer def calculate_maximum_path_sum(input_str): input_lines = input_str.strip().split(\\"n\\") n = int(input_lines[0]) edges = [] for i in range(1, n): u, v, w = map(int, input_lines[i].split()) edges.append((u, v, w)) return maximum_path_sum(n, edges)"},{"question":"def is_palindromic_prime(n: int) -> str: Check if the given number is a palindromic prime. A palindromic number is a number that remains the same when its digits are reversed. A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself. Args: n (int): The number that needs to be checked (1  n  10^6). Returns: str: \\"YES\\" if the given number is a palindromic prime, else \\"NO\\". Examples: >>> is_palindromic_prime(2) 'YES' >>> is_palindromic_prime(131) 'YES' >>> is_palindromic_prime(12) 'NO' >>> is_palindromic_prime(9339) 'NO' from solution import is_palindromic_prime def test_palindromic_prime(): assert is_palindromic_prime(2) == \\"YES\\" assert is_palindromic_prime(131) == \\"YES\\" assert is_palindromic_prime(12) == \\"NO\\" assert is_palindromic_prime(9339) == \\"NO\\" def test_palindromic_not_prime(): assert is_palindromic_prime(22) == \\"NO\\" assert is_palindromic_prime(44) == \\"NO\\" def test_prime_not_palindromic(): assert is_palindromic_prime(13) == \\"NO\\" assert is_palindromic_prime(23) == \\"NO\\" def test_large_palindromic_prime(): assert is_palindromic_prime(13131) == \\"NO\\" assert is_palindromic_prime(10301) == \\"YES\\"","solution":"def is_palindrome(n): Returns True if n is a palindrome, False otherwise. return str(n) == str(n)[::-1] def is_prime(n): Returns True if n is a prime number, False otherwise. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindromic_prime(n): Returns \\"YES\\" if n is a palindromic prime number, \\"NO\\" otherwise. if is_palindrome(n) and is_prime(n): return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def segment_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a list of queries specifying start and end indices, returns the sum of elements for each segment defined by the queries. >>> segment_sum([1, 2, 3, 4, 5], [(1, 3)]) [9] >>> segment_sum([1, 2, 3, 4, 5], [(1, 3), (0, 2), (2, 4)]) [9, 6, 12] >>> segment_sum([1, 2, 3, 4, 5], [(0, 4)]) [15]","solution":"from typing import List, Tuple def segment_sum(arr: List[int], queries: List[Tuple[int, int]]) -> List[int]: Given an array of integers and a list of queries specifying start and end indices, returns the sum of elements for each segment defined by the queries. # Calculate prefix sums prefix_sums = [0] * (len(arr) + 1) for i in range(1, len(arr) + 1): prefix_sums[i] = prefix_sums[i - 1] + arr[i - 1] results = [] for l, r in queries: results.append(prefix_sums[r + 1] - prefix_sums[l]) return results"},{"question":"def min_moves_to_square(T: int, orders: List[Tuple[int, int]]) -> Union[List[int], str]: Calculates the minimum number of moves required to reshape each rectangular plot into a square. Args: T: An integer denoting the number of orders. orders: A list of tuples, each containing two integers L and W, denoting the length and width of the plot. Returns: A list of integers representing the minimum number of moves required for each order to reshape it into a square. If T is not in the range [1, 10], returns \\"Invalid Test\\". If L or W are not in the range [1, 1000], returns \\"Invalid Input\\". >>> min_moves_to_square(3, [(5, 8), (6, 6), (4, 2)]) [3, 0, 2] >>> min_moves_to_square(2, [(1, 1), (3, 7)]) [0, 4] >>> min_moves_to_square(0, [(5, 8)]) \\"Invalid Test\\" >>> min_moves_to_square(11, [(5, 8)]) \\"Invalid Test\\" >>> min_moves_to_square(1, [(1001, 5)]) \\"Invalid Input\\" >>> min_moves_to_square(1, [(5, 0)]) \\"Invalid Input\\" >>> min_moves_to_square(1, [(-1, 5)]) \\"Invalid Input\\" >>> min_moves_to_square(1, [(5, 1001)]) \\"Invalid Input\\" >>> min_moves_to_square(1, [(1000, 1000)]) [0] >>> min_moves_to_square(1, [(1, 1000)]) [999] >>> min_moves_to_square(1, [(1000, 1)]) [999]","solution":"def min_moves_to_square(T, orders): Returns the minimum number of moves required to reshape each plot into a square. :param T: Number of orders :param orders: List of tuples containing the length and width of the plots :return: List of moves required for each order if T < 1 or T > 10: return \\"Invalid Test\\" results = [] for L, W in orders: if L < 1 or L > 1000 or W < 1 or W > 1000: return \\"Invalid Input\\" results.append(abs(L - W)) return results"},{"question":"def find_schedule(d: int, totalTasks: int, min_max_tasks: List[Tuple[int, int]]) -> Tuple[str, Optional[List[int]]]: Function to determine if it's possible to create a valid schedule for Alice. Args: - d: Number of days - totalTasks: Total number of tasks Alice needs to solve - min_max_tasks: List of tuples where each tuple contains the minimum and maximum number of tasks Alice can solve each day Returns: - A tuple where the first element is a string \\"POSSIBLE\\" or \\"IMPOSSIBLE\\". If \\"POSSIBLE\\", the second element is a list of integers representing the number of tasks solved each day. If \\"IMPOSSIBLE\\", the second element is None. pass def test_find_schedule_possible_cases(): d = 3 totalTasks = 10 min_max_tasks = [(2, 5), (1, 4), (1, 3)] result = find_schedule(d, totalTasks, min_max_tasks) assert result[0] == \\"POSSIBLE\\" assert sum(result[1]) == totalTasks assert all(min_tasks <= tasks <= max_tasks for (min_tasks, max_tasks), tasks in zip(min_max_tasks, result[1])) d = 4 totalTasks = 19 min_max_tasks = [(3, 6), (2, 5), (1, 4), (2, 6)] result = find_schedule(d, totalTasks, min_max_tasks) assert result[0] == \\"POSSIBLE\\" assert sum(result[1]) == totalTasks assert all(min_tasks <= tasks <= max_tasks for (min_tasks, max_tasks), tasks in zip(min_max_tasks, result[1])) def test_find_schedule_impossible_cases(): d = 2 totalTasks = 20 min_max_tasks = [(5, 8), (5, 7)] result = find_schedule(d, totalTasks, min_max_tasks) assert result == \\"IMPOSSIBLE\\" d = 1 totalTasks = 17 min_max_tasks = [(0, 15)] result = find_schedule(d, totalTasks, min_max_tasks) assert result == \\"IMPOSSIBLE\\" def test_find_schedule_edge_cases(): d = 1 totalTasks = 0 min_max_tasks = [(0, 0)] result = find_schedule(d, totalTasks, min_max_tasks) assert result[0] == \\"POSSIBLE\\" assert sum(result[1]) == totalTasks assert all(min_tasks <= tasks <= max_tasks for (min_tasks, max_tasks), tasks in zip(min_max_tasks, result[1])) d = 1 totalTasks = 15 min_max_tasks = [(15, 15)] result = find_schedule(d, totalTasks, min_max_tasks) assert result[0] == \\"POSSIBLE\\" assert sum(result[1]) == totalTasks assert all(min_tasks <= tasks <= max_tasks for (min_tasks, max_tasks), tasks in zip(min_max_tasks, result[1]))","solution":"def find_schedule(d, totalTasks, min_max_tasks): Function to determine if it's possible to create a valid schedule for Alice. min_tasks_sum = sum(min_tasks for min_tasks, _ in min_max_tasks) max_tasks_sum = sum(max_tasks for _, max_tasks in min_max_tasks) if totalTasks < min_tasks_sum or totalTasks > max_tasks_sum: return \\"IMPOSSIBLE\\" schedule = [min_tasks for min_tasks, _ in min_max_tasks] surplus = totalTasks - min_tasks_sum for i in range(d): max_increase = min(surplus, min_max_tasks[i][1] - min_max_tasks[i][0]) schedule[i] += max_increase surplus -= max_increase return \\"POSSIBLE\\", schedule # This block is only for testing/showcasing the function if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() d = int(data[0]) totalTasks = int(data[1]) min_max_tasks = [(int(data[i*2 + 2]), int(data[i*2 + 3])) for i in range(d)] result = find_schedule(d, totalTasks, min_max_tasks) if result == \\"IMPOSSIBLE\\": print(\\"IMPOSSIBLE\\") else: print(result[0]) print(\\" \\".join(map(str, result[1])))"},{"question":"from collections import deque from typing import List def min_operations(n: int) -> int: Returns the minimum number of operations required to transform n into 1. Allowed operations are: 1. Subtract 1 (i.e., n = n - 1) 2. Divide by 2 if the number is even (i.e., n = n / 2) 3. Divide by 3 if the number is divisible by 3 (i.e., n = n / 3) >>> min_operations(10) 3 >>> min_operations(15) 4 >>> min_operations(1) 0 >>> min_operations(6) 2 >>> min_operations(3) 1 >>> min_operations(17) 5 >>> min_operations(1000000) 19 pass","solution":"from collections import deque def min_operations(n): Returns the minimum number of operations required to transform n into 1. if n == 1: return 0 # Use a dictionary to keep track of the minimum number of operations for each number operations = {n: 0} queue = deque([n]) while queue: current = queue.popleft() # For operations Subtract 1 if current - 1 not in operations: operations[current - 1] = operations[current] + 1 queue.append(current - 1) if current - 1 == 1: return operations[1] # For operations Divide by 2 if current % 2 == 0 and current // 2 not in operations: operations[current // 2] = operations[current] + 1 queue.append(current // 2) if current // 2 == 1: return operations[1] # For operations Divide by 3 if current % 3 == 0 and current // 3 not in operations: operations[current // 3] = operations[current] + 1 queue.append(current // 3) if current // 3 == 1: return operations[1] return operations[1]"},{"question":"def is_transformation_possible(n: int, m: int, grid: List[str]) -> str: Determine if the king's wish to transform the grid completely into farming land can be fulfilled. >>> is_transformation_possible(3, 3, [\\"FWF\\", \\"WWW\\", \\"FFF\\"]) \\"POSSIBLE\\" >>> is_transformation_possible(3, 3, [\\"FWW\\", \\"WWW\\", \\"FFF\\"]) \\"IMPOSSIBLE\\" >>> is_transformation_possible(4, 4, [\\"FFFF\\", \\"FWFW\\", \\"FWFW\\", \\"FFFF\\"]) \\"POSSIBLE\\" >>> is_transformation_possible(1, 1, [\\"F\\"]) \\"POSSIBLE\\" >>> is_transformation_possible(1, 1, [\\"W\\"]) \\"IMPOSSIBLE\\" >>> is_transformation_possible(3, 3, [\\"FFF\\", \\"FFF\\", \\"FFF\\"]) \\"POSSIBLE\\" >>> is_transformation_possible(3, 3, [\\"FFF\\", \\"FWF\\", \\"FFF\\"]) \\"POSSIBLE\\"","solution":"def is_transformation_possible(n, m, grid): def is_adjacent_to_farming_land(i, j): directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] for di, dj in directions: ni, nj = i + di, j + dj if 0 <= ni < n and 0 <= nj < m and grid[ni][nj] == 'F': return True return False for i in range(n): for j in range(m): if grid[i][j] == 'W' and not is_adjacent_to_farming_land(i, j): return \\"IMPOSSIBLE\\" return \\"POSSIBLE\\""},{"question":"def count_paths(m: int, n: int, special_cells: List[Tuple[int, int]]) -> int: Calculates the number of distinct paths from the top-left to the bottom-right corner of an m x n grid without stepping on any special cells. Args: m (int): The number of rows in the grid. n (int): The number of columns in the grid. special_cells (List[Tuple[int, int]]): A list of coordinates of special cells which are to be avoided. Returns: int: The number of distinct paths from the top-left to the bottom-right corner. Example: >>> count_paths(3, 3, [(2, 2)]) 2 >>> count_paths(4, 4, [(2, 2), (3, 3), (4, 2)]) 2 >>> count_paths(3, 3, []) 6 >>> count_paths(2, 2, [(1, 2), (2, 1)]) 0 >>> count_paths(1, 1, []) 1 >>> count_paths(10, 10, []) 48620 # Pre-calculated value","solution":"def count_paths(m, n, special_cells): Calculates the number of distinct paths from the top-left to the bottom-right corner of an m x n grid without stepping on any special cells. # Initialize grid grid = [[0] * n for _ in range(m)] # Mark special cells for x, y in special_cells: grid[x - 1][y - 1] = -1 # Starting point grid[0][0] = 1 # Dynamic programming to fill the grid for i in range(m): for j in range(n): # Ignore the cell if it is a special cell if grid[i][j] == -1: continue # Add paths from the top cell if we are not on the first row if i > 0 and grid[i - 1][j] != -1: grid[i][j] += grid[i - 1][j] # Add paths from the left cell if we are not on the first column if j > 0 and grid[i][j - 1] != -1: grid[i][j] += grid[i][j - 1] # Result is the bottom-right corner of the grid return grid[m - 1][n - 1] if grid[m - 1][n - 1] != -1 else 0"},{"question":"def count_ways(N: int) -> int: Given a positive integer N, determine the number of distinct ways to organize the rows of plants such that the number of plants in any row is either equal to or one more than the number of plants in the previous row. Output the result modulo 1000000007. >>> count_ways(5) 7 >>> count_ways(1) 1 >>> count_ways(3) 3","solution":"def count_ways(N): MOD = 1000000007 ways = [0] * (N + 1) ways[0] = 1 # There's one way to arrange 0 plants for i in range(1, N + 1): for j in range(i, N + 1): ways[j] = (ways[j] + ways[j - i]) % MOD return ways[N] # Example usage: # print(count_ways(5)) # Should return 7"},{"question":"def max_contiguous_subarray_sum(n: int, popularity: List[int]) -> int: Returns the maximum sum of popularity scores of any contiguous subarray. Parameters: n (int): Number of books popularity (list of int): List of popularity scores of the books Returns: int: Maximum sum of popularity scores of any contiguous subarray >>> max_contiguous_subarray_sum(5, [1, -3, 2, 1, -1]) == 3 >>> max_contiguous_subarray_sum(3, [-2, -3, -1]) == -1 >>> max_contiguous_subarray_sum(6, [4, -1, 2, 1, -5, 4]) == 6","solution":"def max_contiguous_subarray_sum(n, popularity): Returns the maximum sum of popularity scores of any contiguous subarray. Parameters: n (int): Number of books popularity (list of int): List of popularity scores of the books Returns: int: Maximum sum of popularity scores of any contiguous subarray max_so_far = popularity[0] max_ending_here = popularity[0] for i in range(1, n): max_ending_here = max(popularity[i], max_ending_here + popularity[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def max_stack_size(operations: List[str]) -> int: Determine the maximum size of the stack after performing a sequence of operations. Each operation is either \\"push x\\" (where x is an integer to be added to the stack) or \\"pop\\" (removing the top element of the stack if the stack is not empty). Parameters: operations (List[str]): A list of operations to be performed on the stack. Returns: int: The maximum size of the stack after all operations. Examples: >>> max_stack_size([\\"push 1\\", \\"push 2\\", \\"pop\\", \\"push 3\\", \\"push 4\\"]) 3 >>> max_stack_size([\\"push 5\\", \\"push 6\\", \\"pop\\", \\"pop\\"]) 2","solution":"def max_stack_size(operations): stack = [] max_size = 0 for operation in operations: if operation.startswith(\\"push\\"): _, value = operation.split() stack.append(int(value)) elif operation == \\"pop\\" and stack: stack.pop() max_size = max(max_size, len(stack)) return max_size"},{"question":"def min_operations_to_special_string(s: str) -> int: Determines the minimum number of operations required to transform the given string s into a special string, where no two adjacent characters are the same. >>> min_operations_to_special_string(\\"ab\\") 0 >>> min_operations_to_special_string(\\"aa\\") 1 >>> min_operations_to_special_string(\\"abcabc\\") 0 >>> min_operations_to_special_string(\\"aabb\\") 2 >>> min_operations_to_special_string(\\"a\\") 0 >>> min_operations_to_special_string(\\"aaa\\") 2 def process_cases(t: int, cases: List[str]) -> List[int]: Processes multiple test cases and outputs the minimum number of operations required for each case to transform the string into a special string. >>> process_cases(3, [\\"ab\\", \\"aa\\", \\"abcabc\\"]) [0, 1, 0] >>> process_cases(2, [\\"aabb\\", \\"a\\"]) [2, 0] >>> process_cases(2, [\\"aaa\\", \\"bc\\"]) [2, 0] >>> process_cases(1, [\\"qwerty\\"]) [0] >>> process_cases(1, [\\"a\\"]) [0] >>> process_cases(1, [\\"zxy\\"]) [0] >>> process_cases(1, [\\"zzzzzzzzzz\\"]) [9] >>> process_cases(2, [\\"baabaa\\", \\"cdeeff\\"]) [2, 2]","solution":"def min_operations_to_special_string(s): Determines the minimum number of operations required to transform the given string s into a special string, where no two adjacent characters are the same. n = len(s) operations = 0 for i in range(1, n): if s[i] == s[i - 1]: operations += 1 # directly assuming the next valid char will be different from the current and previous one. # replacing s[i] with another character is assumed implicitly. return operations def process_cases(t, cases): Processes multiple test cases and outputs the minimum number of operations required for each case to transform the string into a special string. results = [] for case in cases: results.append(min_operations_to_special_string(case)) return results"},{"question":"from typing import List, Tuple def max_intertwining_chain(datasets: List[List[Tuple[int, int]]]) -> List[int]: Determines the maximum number of plants that can intertwine in a single chain for each dataset. >>> parse_input(\\"4n10 5n8 4n6 3n4 2n0n\\") [[(10, 5), (8, 4), (6, 3), (4, 2)]] >>> parse_input(\\"4n10 5n8 4n6 3n4 2n3n15 10n10 7n8 5n0n\\") [[(10, 5), (8, 4), (6, 3), (4, 2)], [(15, 10), (10, 7), (8, 5)]] >>> max_intertwining_chain(parse_input(\\"4n10 5n8 4n6 3n4 2n0n\\")) [4] >>> max_intertwining_chain(parse_input(\\"3n15 10n10 7n8 5n0n\\")) [3] # Implement function here def parse_input(input_str: str) -> List[List[Tuple[int, int]]]: Parses the input string into the appropriate format. # Implement function here def test_max_intertwining_chain_1(): input_str = \\"4n10 5n8 4n6 3n4 2n0n\\" datasets = parse_input(input_str) results = max_intertwining_chain(datasets) assert results == [4] def test_max_intertwining_chain_2(): input_str = \\"3n15 10n10 7n8 5n0n\\" datasets = parse_input(input_str) results = max_intertwining_chain(datasets) assert results == [3] def test_max_intertwining_chain_3(): input_str = \\"4n10 5n8 6n6 3n4 4n0n\\" datasets = parse_input(input_str) results = max_intertwining_chain(datasets) assert results == [2] def test_max_intertwining_chain_multiple_datasets(): input_str = \\"4n10 5n8 4n6 3n4 2n3n15 10n10 7n8 5n0n\\" datasets = parse_input(input_str) results = max_intertwining_chain(datasets) assert results == [4, 3] def test_parse_input(): input_str = \\"4n10 5n8 4n6 3n4 2n3n15 10n10 7n8 5n0n\\" datasets = parse_input(input_str) assert datasets == [ [(10, 5), (8, 4), (6, 3), (4, 2)], [(15, 10), (10, 7), (8, 5)] ]","solution":"def max_intertwining_chain(datasets): results = [] def longest_chain(plants): plants.sort() dp = [1] * len(plants) for i in range(len(plants)): for j in range(i): if plants[j][0] < plants[i][0] and plants[j][1] < plants[i][1]: dp[i] = max(dp[i], dp[j] + 1) return max(dp) if plants else 0 for plants in datasets: results.append(longest_chain(plants)) return results def parse_input(input_str): datasets = [] lines = input_str.strip().split(\\"n\\") idx = 0 while idx < len(lines): p = int(lines[idx]) if p == 0: break plants = [] for _ in range(p): idx += 1 length, thickness = map(int, lines[idx].split()) plants.append((length, thickness)) datasets.append(plants) idx += 1 return datasets"},{"question":"def min_solutions_to_even_concentration(n: int, concentrations: List[int]) -> int: In a certain laboratory, scientists are testing a new way of combining chemical solutions. Each of these solutions has a specific concentration level, measured in integers from 1 to 100. The scientists want to mix these solutions in a way that the total concentration level is an even number. This function takes an integer n and a list of concentrations and returns the minimum number of solutions needed to get an even total concentration. If this is not possible, it returns -1. :param n: Number of solutions :param concentrations: List of concentration levels of the solutions :return: Minimum number of solutions to get an even total concentration or -1 if not possible. >>> min_solutions_to_even_concentration(5, [1, 3, 5, 7, 9]) -1 >>> min_solutions_to_even_concentration(6, [2, 4, 6, 8, 10, 12]) 1 >>> min_solutions_to_even_concentration(4, [1, 2, 3, 5]) 2","solution":"def min_solutions_to_even_concentration(n, concentrations): This function takes an integer n and a list of concentrations and returns the minimum number of solutions needed to get an even total concentration. If this is not possible, it returns -1. :param n: Number of solutions :param concentrations: List of concentration levels of the solutions :return: Minimum number of solutions to get an even total concentration or -1 if not possible odd_count = sum(1 for c in concentrations if c % 2 != 0) even_count = n - odd_count # if there are no odd numbers, return 1 because any single even number will do if odd_count == 0: return 1 # if there are no even numbers, return -1 because it's impossible to get an even sum using only odd numbers if even_count == 0: return -1 # Otherwise, we need at least one even number and combine with odd numbers for an even sum return 2"},{"question":"def count_root_nodes(n: int, parents: List[int]) -> int: Counts root nodes in a forest represented by a parent array. Args: n : int : the number of vertices in the forest parents : List[int] : a list of integers where each element represents the parent of the vertex at that index Returns: int : the number of root nodes in the forest >>> count_root_nodes(5, [-1, 0, 0, -1, 1]) 2 >>> count_root_nodes(3, [-1, -1, -1]) 3 >>> count_root_nodes(4, [-1, 0, 1, 2]) 1 >>> count_root_nodes(1, [0]) 0 >>> count_root_nodes(6, [-1, 0, 1, -1, 3, 4]) 2","solution":"def count_root_nodes(n, parents): Counts root nodes in a forest represented by a parent array. Args: n : int : the number of vertices in the forest parents : List[int] : a list of integers where each element represents the parent of the vertex at that index Returns: int : the number of root nodes in the forest return sum(1 for parent in parents if parent == -1)"},{"question":"def min_operations_to_equal_elements(N, arr): Determine the minimum number of operations required to make all elements of the array equal. In one operation, you can set an element equal to its adjacent element's value. Args: N (int): The number of elements in the array. arr (List[int]): The array of integers. Returns: int: The minimum number of operations required to make all elements of the array equal. Examples: >>> min_operations_to_equal_elements(3, [4, 3, 2]) 2 >>> min_operations_to_equal_elements(4, [1, 4, 3, 3]) 3 >>> min_operations_to_equal_elements(5, [5, 5, 5, 5, 5]) 0 >>> min_operations_to_equal_elements(6, [10, 1, 1, 10, 10, 1]) 6","solution":"def min_operations_to_equal_elements(N, arr): Returns the minimum number of operations required to make all elements of the array equal. from collections import Counter # Count the frequency of each element in the array frequency = Counter(arr) # Find the element with the maximum frequency max_frequency = max(frequency.values()) # To make all elements equal to the most frequent element, we need to change all other elements # So the minimum number of operations required is N - max_frequency return N - max_frequency"},{"question":"def fibonacci(n: int) -> int: Compute the N-th Fibonacci number. The Fibonacci sequence is a series of numbers in which each number is the sum of the two preceding ones, usually starting with 0 and 1. In mathematical terms, the sequence Fn of Fibonacci numbers is defined by the recurrence relation: F(n) = F(n-1) + F(n-2) with seed values F(0) = 0, F(1) = 1. The input consists of one integer N (0  N  30). Returns the N-th Fibonacci number. >>> fibonacci(5) 5 >>> fibonacci(10) 55 from solution import fibonacci def test_fibonacci_base_cases(): assert fibonacci(0) == 0 assert fibonacci(1) == 1 def test_fibonacci_small_numbers(): assert fibonacci(2) == 1 assert fibonacci(3) == 2 assert fibonacci(4) == 3 assert fibonacci(5) == 5 def test_fibonacci_medium_numbers(): assert fibonacci(10) == 55 assert fibonacci(15) == 610 assert fibonacci(20) == 6765 def test_fibonacci_upper_bounds(): assert fibonacci(30) == 832040","solution":"def fibonacci(n): Returns the n-th Fibonacci number. if n == 0: return 0 elif n == 1: return 1 else: a, b = 0, 1 for _ in range(2, n + 1): a, b = b, a + b return b"},{"question":"from typing import List def maxLength(arr: List[str]) -> int: Given a list of strings, find the length of the longest unique string that can be constructed by concatenating any number of strings from the input list. >>> maxLength([\\"un\\", \\"iq\\", \\"ue\\"]) 4 >>> maxLength([\\"cha\\",\\"r\\",\\"act\\",\\"ers\\"]) 6 >>> maxLength([\\"abcdefghijklmnopqrstuvwxyz\\"]) 26 pass def test_example_1(): assert maxLength([\\"un\\", \\"iq\\", \\"ue\\"]) == 4 def test_example_2(): assert maxLength([\\"cha\\",\\"r\\",\\"act\\",\\"ers\\"]) == 6 def test_example_3(): assert maxLength([\\"abcdefghijklmnopqrstuvwxyz\\"]) == 26 def test_single_characters(): assert maxLength([\\"a\\", \\"ab\\", \\"bc\\", \\"b\\"]) == 3 def test_no_unique_string(): assert maxLength([\\"aa\\", \\"bb\\", \\"cc\\"]) == 0 def test_mixed_length_strings(): assert maxLength([\\"a\\", \\"abc\\", \\"defg\\", \\"hijkl\\", \\"mnopqr\\", \\"st\\", \\"uvwx\\", \\"yz\\"]) == 26 def test_empty_string_in_list(): assert maxLength([\\"\\", \\"ab\\", \\"cd\\", \\"ef\\"]) == 6","solution":"from typing import List def maxLength(arr: List[str]) -> int: def dfs(start, current): if len(current) != len(set(current)): return 0 max_length = len(current) for i in range(start, len(arr)): max_length = max(max_length, dfs(i + 1, current + arr[i])) return max_length return dfs(0, \\"\\")"},{"question":"def form_teams(n: int, m: int) -> (int, int): Determines the optimal way to form teams and the number of players left without a team. Parameters: n (int): Total number of players. m (int): Maximum number of players in a team. Returns: tuple: (Number of teams, Number of leftover players) Examples: >>> form_teams(10, 3) (3, 1) >>> form_teams(15, 5) (3, 0) >>> form_teams(7, 2) (3, 1) from solution import form_teams def test_form_teams_example1(): assert form_teams(10, 3) == (3, 1) def test_form_teams_example2(): assert form_teams(15, 5) == (3, 0) def test_form_teams_example3(): assert form_teams(7, 2) == (3, 1) def test_form_teams_single_player(): assert form_teams(1, 1) == (1, 0) assert form_teams(1, 2) == (0, 1) def test_form_teams_equal_players_and_team_size(): assert form_teams(8, 8) == (1, 0) def test_form_teams_more_players_than_team_size(): assert form_teams(20, 4) == (5, 0) def test_form_teams_maximum_team_size_larger_than_players(): assert form_teams(10, 20) == (0, 10)","solution":"def form_teams(n, m): Returns the maximum number of teams and the number of players left without a team. Parameters: n (int): Total number of players. m (int): Maximum number of players in a team. Returns: tuple: (Number of teams, Number of leftover players) teams = n // m leftover = n % m return (teams, leftover)"},{"question":"def aggregate_orders(n: int, orders: List[Tuple[str, int]]) -> List[Tuple[str, int]]: Aggregates the orders and returns a summary of the total units ordered for each item code. Args: n (int): The number of orders. orders (list): A list containing tuples of (item_code, number_of_units). Returns: list: A list of tuples containing (item_code, total_units). Examples: >>> aggregate_orders(5, [(\\"A12\\", 5), (\\"B34\\", 10), (\\"A12\\", 3), (\\"C56\\", 2), (\\"B34\\", 7)]) [(\\"A12\\", 8), (\\"B34\\", 17), (\\"C56\\", 2)] >>> aggregate_orders(3, [(\\"X1\\", 1), (\\"X2\\", 2), (\\"X1\\", 4)]) [(\\"X1\\", 5), (\\"X2\\", 2)]","solution":"def aggregate_orders(n, orders): Aggregates the orders and returns a summary of the total units ordered for each item code. Args: n (int): The number of orders. orders (list): A list containing tuples of (item_code, number_of_units). Returns: list: A list of tuples containing (item_code, total_units). from collections import OrderedDict order_summary = OrderedDict() for item_code, units in orders: if item_code in order_summary: order_summary[item_code] += units else: order_summary[item_code] = units return list(order_summary.items()) # Example usage: # orders = [ # (\\"A12\\", 5), # (\\"B34\\", 10), # (\\"A12\\", 3), # (\\"C56\\", 2), # (\\"B34\\", 7) # ] # result = aggregate_orders(5, orders) # print(result) # Output: [('A12', 8), ('B34', 17), ('C56', 2)]"},{"question":"def has_even_index_pair_within_k(arr: List[int], k: int) -> str: Determine if there are two distinct indices i and j in the array such that arr[i] and arr[j] are both even numbers, and the absolute difference between i and j is at most k. :param arr: List of integers :param k: Integer, maximum allowed difference between indices :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" >>> has_even_index_pair_within_k([2, 3, 4, 6, 8], 2) \\"YES\\" >>> has_even_index_pair_within_k([1, 3, 5, 7], 1) \\"NO\\" >>> has_even_index_pair_within_k([1, 2, 3, 4, 6, 5], 3) \\"YES\\" >>> has_even_index_pair_within_k([1, 3, 5, 7], 10) \\"NO\\" >>> has_even_index_pair_within_k([2, 4, 6, 8], 2) \\"YES\\" >>> has_even_index_pair_within_k([2, 4, 6, 8], 10) \\"YES\\" >>> has_even_index_pair_within_k([2], 1) \\"NO\\" >>> has_even_index_pair_within_k([2, 3, 4, 1, 6, 1, 8], 1) \\"NO\\" >>> has_even_index_pair_within_k([2, 4, 6, 8, 10], 1) \\"YES\\" >>> has_even_index_pair_within_k([2, 4, 6, 8, 10], 0) \\"NO\\"","solution":"def has_even_index_pair_within_k(arr, k): Determine if there are two distinct indices i and j in the array such that arr[i] and arr[j] are both even numbers, and the absolute difference between i and j is at most k. :param arr: List of integers :param k: Integer, maximum allowed difference between indices :return: \\"YES\\" if such a pair exists, otherwise \\"NO\\" even_indices = [i for i in range(len(arr)) if arr[i] % 2 == 0] for idx, i in enumerate(even_indices): for j in even_indices[idx + 1:]: if abs(i - j) <= k: return \\"YES\\" return \\"NO\\""},{"question":"def min_cost_to_connect_parks(n: int, m: int, connections: List[Tuple[int, int, int]]) -> int: Calculate the minimum total cost to connect all parks based on given connections. Parameters: n (int): number of parks. m (int): number of potential connections. connections (List[Tuple[int, int, int]]): list of potential connections represented by tuples (ui, vi, wi). Returns: int: Minimum total cost to connect all parks, or -1 if it is not possible. >>> min_cost_to_connect_parks(4, 5, [(1, 2, 1), (2, 3, 2), (3, 4, 3), (4, 1, 4), (1, 3, 5)]) 6 >>> min_cost_to_connect_parks(4, 3, [(1, 2, 3), (2, 3, 4), (4, 4, 1)]) -1","solution":"def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): xroot = find(parent, x) yroot = find(parent, y) if rank[xroot] < rank[yroot]: parent[xroot] = yroot elif rank[xroot] > rank[yroot]: parent[yroot] = xroot else: parent[yroot] = xroot rank[xroot] += 1 def min_cost_to_connect_parks(n, m, connections): # Kruskal's algorithm # Step 1: Sort all the edges in non-decreasing order of their weight connections = sorted(connections, key=lambda x: x[2]) parent = [] rank = [] # Step 2: Create n disjoint sets (one for each vertex) for node in range(n): parent.append(node) rank.append(0) result = 0 # To store the minimum cost to connect all parks num_edges = 0 # To keep the count of edges chosen # Step 3: Pick the smallest edge and increment the index for the next iteration for connection in connections: u, v, w = connection x = find(parent, u-1) y = find(parent, v-1) # If including this edge does not cause a cycle, include it in the result # and increment the count of edges in the result if x != y: result += w union(parent, rank, x, y) num_edges += 1 # If we already have n-1 edges, stop the process if num_edges == n - 1: break # Check if the graph is connected (i.e., has exactly n-1 edges) if num_edges != n - 1: return -1 return result"},{"question":"def factorial(n): Returns the factorial of a given positive integer n. >>> factorial(1) == 1 >>> factorial(2) == 2 >>> factorial(3) == 6 >>> factorial(4) == 24 >>> factorial(5) == 120 >>> factorial(6) == 720 >>> factorial(7) == 5040 >>> factorial(0) == 1 >>> factorial(10) == 3628800","solution":"def factorial(n): Returns the factorial of a given positive integer n. if n < 0: raise ValueError(\\"Factorial is not defined for negative integers\\") if n == 0: return 1 fact = 1 for i in range(1, n + 1): fact *= i return fact"},{"question":"def max_blooming_flowers(test_cases): Calculate the maximum number of different flower types blooming on any single day. Args: test_cases (List[List[Tuple[int, int]]]): List of test cases, each containing a list of tuples with blooming start and stop days. Returns: List[int]: List of maximum number of different flower types blooming on any single day for each test case. def parse_input(input_str): Parse the input string to extract the test cases. Args: input_str (str): Input string representing the number of test cases and blooming ranges for each test case. Returns: List[List[Tuple[int, int]]]: Parsed test cases. def format_output(results): Format the output results as a string. Args: results (List[int]): List of results for each test case. Returns: str: Formatted output string. def main(input_str): Main function to process the input and produce the output. Args: input_str (str): Input string representing the number of test cases and blooming ranges for each test case. Returns: str: Formatted output string representing the maximum number of different flower types blooming on any single day for each test case. import pytest from solution import max_blooming_flowers, parse_input, format_output, main def test_max_blooming_flowers(): test_cases = [ [(1, 4), (2, 5), (3, 6)], [(5, 8), (6, 7)] ] assert max_blooming_flowers(test_cases) == [3, 2] def test_parse_input(): input_str = \\"2n3n1 4n2 5n3 6n2n5 8n6 7n\\" expected_output = [ [(1, 4), (2, 5), (3, 6)], [(5, 8), (6, 7)] ] assert parse_input(input_str) == expected_output def test_format_output(): results = [3, 2] assert format_output(results) == \\"3n2\\" def test_main(): input_str = \\"2n3n1 4n2 5n3 6n2n5 8n6 7n\\" expected_output = \\"3n2\\" assert main(input_str) == expected_output","solution":"def max_blooming_flowers(test_cases): results = [] for case in test_cases: events = [] for bloom in case: start, end = bloom events.append((start, 1)) # 1 represents a flower starts blooming events.append((end + 1, -1)) # -1 represents a flower stops blooming events.sort() max_blooming = 0 current_blooming = 0 for event in events: current_blooming += event[1] max_blooming = max(max_blooming, current_blooming) results.append(max_blooming) return results def parse_input(input_str): lines = input_str.strip().split(\\"n\\") T = int(lines[0]) test_cases = [] index = 1 for _ in range(T): N = int(lines[index]) case = [] for i in range(N): start, end = map(int, lines[index + 1 + i].split()) case.append((start, end)) test_cases.append(case) index += N + 1 return test_cases def format_output(results): return \\"n\\".join(map(str, results)) def main(input_str): test_cases = parse_input(input_str) results = max_blooming_flowers(test_cases) return format_output(results)"},{"question":"def has_two_sum(arr: List[int], k: int) -> str: Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. >>> has_two_sum([1, 2, 3, 4, 5], 9) 'YES' >>> has_two_sum([1, 4, 45, 6, 10, 8], 10) 'YES' >>> has_two_sum([1, 1, 1, 1, 1, 1], 3) 'NO' >>> has_two_sum([10**5, -10**5, 1, 2, 3], 0) 'YES' >>> has_two_sum([1, 2, 4, 5], 10) 'NO' >>> has_two_sum([-1, -2, -3, -4, -5], -8) 'YES' >>> has_two_sum([100000, -100000], 0) 'YES' >>> has_two_sum([1, 2, 3], 5) 'YES'","solution":"def has_two_sum(arr, k): Determines if there are two distinct indices i and j in the array such that arr[i] + arr[j] == k. :param arr: List of integers :param k: Target integer :return: \\"YES\\" if such indices exist, \\"NO\\" otherwise seen = set() for num in arr: if k - num in seen: return \\"YES\\" seen.add(num) return \\"NO\\""},{"question":"def longest_increasing_streak(N: int, distances: List[int]) -> int: Find the length of the longest streak of increasing running distances Samantha ran. >>> longest_increasing_streak(7, [4, 5, 2, 3, 7, 6, 8]) 3 >>> longest_increasing_streak(5, [1, 2, 3, 4, 5]) 5 >>> longest_increasing_streak(4, [5, 4, 3, 2]) 1 >>> longest_increasing_streak(8, [1, 3, 2, 4, 2, 3, 4, 5]) 4 >>> longest_increasing_streak(2, [2, 3]) 2 >>> longest_increasing_streak(9, [1, 3, 2, 4, 3, 5, 4, 6, 5]) 2","solution":"def longest_increasing_streak(N, distances): longest_streak = 0 current_streak = 1 for i in range(1, N): if distances[i] > distances[i - 1]: current_streak += 1 else: if current_streak > longest_streak: longest_streak = current_streak current_streak = 1 if current_streak > longest_streak: longest_streak = current_streak return longest_streak"},{"question":"def compressString(s: str) -> str: Compresses the given string using Run Length Encoding (RLE). If the compressed string is not shorter than the original, it returns the original string. >>> compressString(\\"aaabbbcc\\") 'a3b3c2' >>> compressString(\\"abc\\") 'abc' >>> compressString(\\"aabbcc\\") 'aabbcc' >>> compressString(\\"aaaaaa\\") 'a6' pass","solution":"def compressString(s: str) -> str: if not s: return s compressed = [] count = 1 for i in range(1, len(s)): if s[i] == s[i - 1]: count += 1 else: compressed.append(s[i - 1] + str(count)) count = 1 compressed.append(s[-1] + str(count)) compressed_string = ''.join(compressed) return compressed_string if len(compressed_string) < len(s) else s"},{"question":"def min_moves(start, end): Returns the minimum number of moves required for a character to move from the starting position to the destination position on an 8x8 grid. Parameters: start (tuple): A tuple (r1, c1) representing the starting position. end (tuple): A tuple (r2, c2) representing the destination position. Returns: int: The minimum number of moves required to reach the destination. pass # Unit tests def test_min_moves_same_position(): assert min_moves((1, 1), (1, 1)) == 0 def test_min_moves_diagonal_move(): assert min_moves((1, 1), (8, 8)) == 7 assert min_moves((2, 3), (5, 5)) == 3 def test_min_moves_horizontal_move(): assert min_moves((1, 1), (1, 8)) == 7 def test_min_moves_vertical_move(): assert min_moves((1, 1), (8, 1)) == 7 def test_min_moves_mixed_moves(): assert min_moves((1, 2), (7, 8)) == 6 assert min_moves((5, 5), (1, 8)) == 4","solution":"def min_moves(start, end): Returns the minimum number of moves required for a character to move from the starting position to the destination position on an 8x8 grid. Parameters: start (tuple): A tuple (r1, c1) representing the starting position. end (tuple): A tuple (r2, c2) representing the destination position. Returns: int: The minimum number of moves required to reach the destination. # Extract row and column for start and end positions r1, c1 = start r2, c2 = end # Calculate the difference in rows and columns row_diff = abs(r2 - r1) col_diff = abs(c2 - c1) # Return the maximum of row_diff and col_diff as the minimum number of moves return max(row_diff, col_diff)"},{"question":"def min_flips_to_alternate(s: str) -> int: Determine the minimum number of characters that need to be flipped to make the binary string alternating. A binary string is alternating if no two adjacent characters are the same. Parameters: s (str): The binary string to be analyzed. Returns: int: The minimum number of flips required to make the string alternating. Examples: >>> min_flips_to_alternate(\\"100110\\") 2 >>> min_flips_to_alternate(\\"11111\\") 2 >>> min_flips_to_alternate(\\"0101\\") 0 >>> min_flips_to_alternate(\\"101010\\") 0 >>> min_flips_to_alternate(\\"0000\\") 2 >>> min_flips_to_alternate(\\"000\\") 1 >>> min_flips_to_alternate(\\"111\\") 1 >>> min_flips_to_alternate(\\"1\\") 0 >>> min_flips_to_alternate(\\"0\\") 0","solution":"def min_flips_to_alternate(s): n = len(s) pattern1 = \\"01\\" * (n // 2) + \\"0\\" * (n % 2) pattern2 = \\"10\\" * (n // 2) + \\"1\\" * (n % 2) flip_count1 = sum(1 for i in range(n) if s[i] != pattern1[i]) flip_count2 = sum(1 for i in range(n) if s[i] != pattern2[i]) return min(flip_count1, flip_count2)"},{"question":"def is_right_angled_triangle(x1: int, y1: int, x2: int, y2: int, x3: int, y3: int) -> str: Determines if a triangle with given vertices is right-angled. Args: x1, y1, x2, y2, x3, y3: coordinates of the vertices of the triangle. Returns: \\"YES\\" if the triangle is right-angled, otherwise \\"NO\\". Examples: >>> is_right_angled_triangle(0, 0, 3, 0, 0, 4) 'YES' >>> is_right_angled_triangle(0, 0, 1, 1, 2, 2) 'NO' pass def check_triangles(triangles: list) -> list: Checks a list of triangles to determine if each is right-angled. Args: triangles: list of tuples, each containing the coordinates of the vertices of a triangle. Returns: A list of strings, each being \\"YES\\" if the corresponding triangle is right-angled, otherwise \\"NO\\". Examples: >>> check_triangles([(0, 0, 3, 0, 0, 4), (0, 0, 1, 1, 2, 2), (1, 1, 4, 1, 1, 5)]) ['YES', 'NO', 'YES'] pass from solution import is_right_angled_triangle, check_triangles def test_is_right_angled_triangle(): assert is_right_angled_triangle(0, 0, 3, 0, 0, 4) == \\"YES\\" assert is_right_angled_triangle(0, 0, 1, 1, 2, 2) == \\"NO\\" assert is_right_angled_triangle(1, 1, 4, 1, 1, 5) == \\"YES\\" assert is_right_angled_triangle(0, 0, 1, 0, 0, 1) == \\"YES\\" assert is_right_angled_triangle(-5, -5, -5, 5, 5, 5) == \\"YES\\" def test_check_triangles(): triangles = [ (0, 0, 3, 0, 0, 4), (0, 0, 1, 1, 2, 2), (1, 1, 4, 1, 1, 5) ] assert check_triangles(triangles) == [\\"YES\\", \\"NO\\", \\"YES\\"]","solution":"def is_right_angled_triangle(x1, y1, x2, y2, x3, y3): # function to calculate square of distance between two points def dist_sq(x1, y1, x2, y2): return (x2 - x1) ** 2 + (y2 - y1) ** 2 # distances squared d1 = dist_sq(x1, y1, x2, y2) d2 = dist_sq(x2, y2, x3, y3) d3 = dist_sq(x3, y3, x1, y1) # Check using pythagorean theorem if d1 + d2 == d3 or d2 + d3 == d1 or d3 + d1 == d2: return \\"YES\\" else: return \\"NO\\" def check_triangles(triangles): result = [] for triangle in triangles: result.append(is_right_angled_triangle(*triangle)) return result"},{"question":"def min_bricks(n: int, m: int, widths: List[int]) -> int: Determine the minimum number of bricks needed to achieve the target width, or -1 if it's impossible to build the wall with the given bricks. :param n: Number of different brick widths :param m: Target width of the wall :param widths: List of widths of the available bricks :return: Minimum number of bricks needed to achieve the target width, or -1 if it's impossible >>> min_bricks(3, 10, [1, 2, 3]) 4 >>> min_bricks(4, 7, [2, 3, 5, 6]) 2 >>> min_bricks(1, 10, [3]) -1 >>> min_bricks(1, 5, [5]) 1 >>> min_bricks(3, 6, [2, 2, 2]) 3 >>> min_bricks(2, 100, [1, 5]) 20 >>> min_bricks(3, 0, [1, 2, 3]) 0 >>> min_bricks(5, 8, [1, 3, 3, 5, 5]) 2","solution":"def min_bricks(n, m, widths): Determine the minimum number of bricks needed to achieve the target width, or -1 if it's impossible to build the wall with the given bricks. # Initialize dp array with a large value dp = [float('inf')] * (m + 1) dp[0] = 0 # Fill dp array for i in range(1, m + 1): for w in widths: if i - w >= 0: dp[i] = min(dp[i], dp[i - w] + 1) return dp[m] if dp[m] != float('inf') else -1"},{"question":"def pair_with_target_sum(nums, target): Finds two numbers in the list such that they add up to the target and returns their indices as a tuple. If no such pair exists, returns (-1, -1). >>> pair_with_target_sum([2, 7, 11, 15], 9) (0, 1) >>> pair_with_target_sum([1, 2, 3, 4, 5, 6], 10) (3, 5) >>> pair_with_target_sum([1, 2, 3], 7) (-1, -1) >>> pair_with_target_sum([], 5) (-1, -1) >>> pair_with_target_sum([10**9, 1, 2, 10**9], 10**9 + 1) (0, 1) pass from solution import pair_with_target_sum def test_pair_with_target_sum_found(): assert pair_with_target_sum([2, 7, 11, 15], 9) == (0, 1) def test_pair_with_target_sum_found_larger_list(): assert pair_with_target_sum([1, 2, 3, 4, 5, 6], 10) == (3, 5) def test_pair_with_target_sum_not_found(): assert pair_with_target_sum([1, 2, 3], 7) == (-1, -1) def test_pair_with_target_sum_single_element(): assert pair_with_target_sum([5], 5) == (-1, -1) def test_pair_with_target_sum_empty_list(): assert pair_with_target_sum([], 5) == (-1, -1) def test_pair_with_target_sum_multiple_pairs(): assert pair_with_target_sum([1, 2, 3, 2, 1], 4) == (0, 2) def test_pair_with_target_sum_large_values(): assert pair_with_target_sum([10**9, 1, 2, 10**9], 10**9 + 1) == (0, 1) assert pair_with_target_sum([10**9, 2, 3, 10**9], 10**9 + 3) == (0, 2) def test_pair_with_target_sum_last_pair(): assert pair_with_target_sum([1, 2, 3, 4, 6], 10) == (3, 4)","solution":"def pair_with_target_sum(nums, target): Finds two numbers in the list such that they add up to the target and returns their indices as a tuple. If no such pair exists, returns (-1, -1). num_to_index = {} for index, num in enumerate(nums): diff = target - num if diff in num_to_index: return (num_to_index[diff], index) num_to_index[num] = index return (-1, -1)"},{"question":"def min_cost_to_align_cows(n: int, directions: str, costs: List[int]) -> int: Determines the minimum total cost required to make all the cows face the same direction. Parameters: n (int): The number of cows. directions (str): A string where 'L' indicates a cow facing left and 'R' indicates a cow facing right. costs (list): A list of integers where the i-th integer is the cost associated with turning the i-th cow. Returns: int: The minimum total cost required for all the cows to face the same direction. Examples: >>> min_cost_to_align_cows(5, \\"LRRRL\\", [1, 2, 3, 4, 5]) 6 >>> min_cost_to_align_cows(3, \\"LLL\\", [3, 2, 1]) 0","solution":"def min_cost_to_align_cows(n, directions, costs): Determines the minimum total cost required to make all the cows face the same direction. Parameters: n (int): The number of cows. directions (str): A string where 'L' indicates a cow facing left and 'R' indicates a cow facing right. costs (list): A list of integers where the i-th integer is the cost associated with turning the i-th cow. Returns: int: The minimum total cost required for all the cows to face the same direction. cost_to_L = sum(cost for direction, cost in zip(directions, costs) if direction == 'R') cost_to_R = sum(cost for direction, cost in zip(directions, costs) if direction == 'L') return min(cost_to_L, cost_to_R)"},{"question":"def decode_messages(encoded_messages): Decodes a list of encoded messages according to the unique civilization rules. Args: encoded_messages (list of str): List of encoded messages. Returns: list of str: Decoded messages. def process_input(n, messages): return decode_messages(messages) # Test cases def test_decode_single_message_example_1(): assert decode_messages([\\"bcdef\\"]) == [\\"dipyi\\"] def test_decode_single_message_example_2(): assert decode_messages([\\"z\\"]) == [\\"s\\"] def test_decode_single_message_example_3(): assert decode_messages([\\"abc\\"]) == [\\"adi\\"] def test_decode_multiple_messages(): assert decode_messages([\\"bcdef\\", \\"z\\", \\"abc\\"]) == [\\"dipyi\\", \\"s\\", \\"adi\\"] def test_decode_single_character(): assert decode_messages([\\"a\\"]) == [\\"a\\"] assert decode_messages([\\"b\\"]) == [\\"d\\"] assert decode_messages([\\"c\\"]) == [\\"i\\"] def test_process_input(): assert process_input(3, [\\"bcdef\\", \\"z\\", \\"abc\\"]) == [\\"dipyi\\", \\"s\\", \\"adi\\"]","solution":"def decode_messages(encoded_messages): Decodes a list of encoded messages according to the unique civilization rules. Args: encoded_messages (list of str): List of encoded messages. Returns: list of str: Decoded messages. def char_to_pos(char): Converts a character to its position in the alphabet. return ord(char) - ord('a') + 1 def pos_to_char(pos): Converts a position back to a character. return chr(pos + ord('a') - 1) def decode_character(char): Decodes a single character according to the rules. pos = char_to_pos(char) squared = pos * pos if 1 <= squared <= 26: return pos_to_char(squared) else: digit_sum = sum(int(d) for d in str(squared)) return pos_to_char(digit_sum) decoded_messages = [] for message in encoded_messages: decoded_message = ''.join(decode_character(char) for char in message) decoded_messages.append(decoded_message) return decoded_messages def process_input(n, messages): return decode_messages(messages)"},{"question":"def determine_bird_species(n, k, query, reset): Determines the number of distinct bird species in a forest with n sections using a sliding window of size k for recent species observation. :param n: Number of sections in the forest :param k: Memory window size for recent observations :param query: Function to query the species of bird in a given section (returns 'Y' or 'N') :param reset: Function to reset the memory of recent observations :return: Number of distinct bird species in the forest >>> def fake_query(i): ... responses = {1: 'N', 2: 'N', 3: 'Y', 4: 'N', (2, 1): 'Y', (3, 1): 'N', (3, 2): 'Y', (4, 3): 'N'} ... return responses[i] >>> def fake_reset(): ... pass >>> determine_bird_species(4, 2, fake_query, fake_reset) == 3 True","solution":"def determine_bird_species(n, k, query, reset): Determines the number of distinct bird species in a forest with n sections using a sliding window of size k for recent species observation. :param n: Number of sections in the forest :param k: Memory window size for recent observations :param query: Function to query the species of bird in a given section (returns 'Y' or 'N') :param reset: Function to reset the memory of recent observations :return: Number of distinct bird species in the forest distinct_species = 0 seen_species = set() for start in range(1, n+1, k): reset() for i in range(start, min(start + k, n+1)): response = query(i) if response == 'N': distinct_species += 1 seen_species.add(i) return distinct_species"},{"question":"def max_cars_parked(n: int, slots: str) -> int: Given the current state of a parking lot, determine the maximum number of cars that can be parked in the empty slots so no two cars are parked next to each other. >>> max_cars_parked(5, '10001') 1 >>> max_cars_parked(10, '0000000000') 5 >>> max_cars_parked(8, '10101010') 0 def test_max_cars_parked(): assert max_cars_parked(5, '10001') == 1 assert max_cars_parked(10, '0000000000') == 5 assert max_cars_parked(8, '10101010') == 0 assert max_cars_parked(6, '100100') == 1 assert max_cars_parked(7, '1000000') == 3 assert max_cars_parked(1, '0') == 1 assert max_cars_parked(1, '1') == 0 assert max_cars_parked(3, '010') == 0 assert max_cars_parked(7, '0101010') == 0","solution":"def max_cars_parked(n, slots): Returns the maximum number of cars that can be parked in the empty slots so no two cars are parked next to each other. count = 0 i = 0 while i < n: if slots[i] == '0': # Check if this slot can be parked if (i == 0 or slots[i-1] == '0') and (i == n-1 or slots[i+1] == '0'): count += 1 i += 1 # Skip the next slot to avoid parking two cars next to each other i += 1 return count"},{"question":"def sieve_of_eratosthenes(n): Returns a list of primes up to n (inclusive) using the Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p] == True: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] def generate_primes(n): Generates the first n prime numbers. >>> generate_primes(5) [2, 3, 5, 7, 11] pass def primes_product(queries): For a given list of queries where each query provides two positions in the sequence of consecutive prime numbers, return the product of the prime numbers at those respective positions. >>> primes_product([(2, 4)]) [21] >>> primes_product([(2, 4), (1, 3), (5, 5)]) [21, 10, 121] pass","solution":"def sieve_of_eratosthenes(n): Returns a list of primes up to n (inclusive) using the Sieve of Eratosthenes algorithm. is_prime = [True] * (n + 1) p = 2 while (p * p <= n): if is_prime[p] == True: for i in range(p * p, n + 1, p): is_prime[i] = False p += 1 return [p for p in range(2, n + 1) if is_prime[p]] def generate_primes(n): Generates the first n prime numbers. upper_bound = n * 15 # Use an upper bound to ensure enough primes primes = sieve_of_eratosthenes(upper_bound) return primes[:n] def primes_product(queries): For a given list of queries where each query provides two positions in the sequence of consecutive prime numbers, return the product of the prime numbers at those respective positions. max_position = max(max(p1, p2) for p1, p2 in queries) primes = generate_primes(max_position) results = [] for p1, p2 in queries: product = primes[p1 - 1] * primes[p2 - 1] results.append(product) return results"},{"question":"def rankings(problem_data: List[str], user_data: List[str]) -> List[str]: Rankings of users by their accumulated points, with ties broken alphabetically by username. >>> problem_data = [\\"problem1 100\\", \\"problem2 200\\", \\"problem3 150\\"] >>> user_data = [\\"userA problem1 problem2\\", \\"userB problem1 problem3\\"] >>> rankings(problem_data, user_data) [\\"userA 300\\", \\"userB 250\\"] >>> problem_data = [\\"challenge1 250\\", \\"challenge2 100\\"] >>> user_data = [\\"user1 challenge1\\", \\"user2 challenge1 challenge2\\", \\"user3\\"] >>> rankings(problem_data, user_data) [\\"user2 350\\", \\"user1 250\\", \\"user3 0\\"] >>> problem_data = [\\"task1 50\\", \\"task2 75\\", \\"task3 100\\", \\"task4 25\\"] >>> user_data = [\\"alice task1 task2 task3\\", \\"bob task2 task4\\"] >>> rankings(problem_data, user_data) [\\"alice 225\\", \\"bob 100\\"] >>> problem_data = [\\"task1 50\\", \\"task2 75\\"] >>> user_data = [\\"bob task1 task2\\", \\"alice task1 task2\\"] >>> rankings(problem_data, user_data) [\\"alice 125\\", \\"bob 125\\"] >>> problem_data = [\\"task1 50\\", \\"task2 75\\"] >>> user_data = [\\"alice\\", \\"bob\\"] >>> rankings(problem_data, user_data) [\\"alice 0\\", \\"bob 0\\"] >>> problem_data = [\\"task1 200\\", \\"task2 50\\"] >>> user_data = [\\"alice task1\\", \\"bob task2 task1\\", \\"charlie task2\\"] >>> rankings(problem_data, user_data) [\\"bob 250\\", \\"alice 200\\", \\"charlie 50\\"]","solution":"def rankings(problem_data, user_data): # dictionary to store problem point values problem_points = {} for problem in problem_data: identifier, point = problem.split() problem_points[identifier] = int(point) # dictionary to store user scores user_scores = {} for user in user_data: details = user.split() username = details[0] solved_problems = details[1:] score = sum(problem_points[problem] for problem in solved_problems) user_scores[username] = score # sort users first by score descending then by name ascending sorted_users = sorted(user_scores.items(), key=lambda x: (-x[1], x[0])) # format the output result = [] for username, score in sorted_users: result.append(f\\"{username} {score}\\") return result"},{"question":"def process_queries(N: int, A: List[int], queries: List[Tuple]) -> List[int]: Given an array A of N integers, write a function to answer Q queries. Each query can be of the following two types: 1. X L R - Replace each element in the segment from index L to R (inclusive) with the integer X. 2. S L R - Return the sum of all elements in the segment from index L to R (inclusive). INPUT: - N: Number of elements in the array. - A: List of integers representing the elements of the array. - Queries: List of tuples representing the queries. OUTPUT: - For each query of the second type, output the sum of the specified segment of the array. Constraints: 1  N, Q  10^5 1  Ai, X  10^4 1  L, R  N >>> N, A = 5, [1, 2, 3, 4, 5] >>> queries = [('S', 1, 3), ('X', 2, 4, 100), ('S', 1, 5)] >>> process_queries(N, A, queries) [6, 306]","solution":"class SegmentTree: def __init__(self, data): self.n = len(data) self.data = data self.tree = [0] * (4 * self.n) self.lazy = [None] * (4 * self.n) self.__build(0, 0, self.n - 1) def __build(self, node, start, end): if start == end: self.tree[node] = self.data[start] else: mid = (start + end) // 2 self.__build(2 * node + 1, start, mid) self.__build(2 * node + 2, mid + 1, end) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def __update_range(self, node, start, end, L, R, val): if self.lazy[node] is not None: self.tree[node] = (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] = self.lazy[node] self.lazy[2 * node + 2] = self.lazy[node] self.lazy[node] = None if start > end or start > R or end < L: return if start >= L and end <= R: self.tree[node] = (end - start + 1) * val if start != end: self.lazy[2 * node + 1] = val self.lazy[2 * node + 2] = val return mid = (start + end) // 2 self.__update_range(2 * node + 1, start, mid, L, R, val) self.__update_range(2 * node + 2, mid + 1, end, L, R, val) self.tree[node] = self.tree[2 * node + 1] + self.tree[2 * node + 2] def __query_range(self, node, start, end, L, R): if self.lazy[node] is not None: self.tree[node] = (end - start + 1) * self.lazy[node] if start != end: self.lazy[2 * node + 1] = self.lazy[node] self.lazy[2 * node + 2] = self.lazy[node] self.lazy[node] = None if start > end or start > R or end < L: return 0 if start >= L and end <= R: return self.tree[node] mid = (start + end) // 2 leftSum = self.__query_range(2 * node + 1, start, mid, L, R) rightSum = self.__query_range(2 * node + 2, mid + 1, end, L, R) return leftSum + rightSum def update(self, L, R, val): self.__update_range(0, 0, self.n - 1, L - 1, R - 1, val) def query(self, L, R): return self.__query_range(0, 0, self.n - 1, L - 1, R - 1) def process_queries(N, A, queries): segment_tree = SegmentTree(A) result = [] for query in queries: if query[0] == 'S': _, L, R = query result.append(segment_tree.query(L, R)) elif query[0] == 'X': _, L, R, X = query segment_tree.update(L, R, X) return result"},{"question":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> bool: Determine if there exist two distinct indices i and j in the list such that the sum of the elements at these indices equals the target. >>> find_pair_with_sum([2, 7, 11, 15], 9) True >>> find_pair_with_sum([3, 2, 4], 6) True >>> find_pair_with_sum([3, 3], 7) False >>> find_pair_with_sum([-1, -2, -3, -4, -5], -8) True >>> find_pair_with_sum([0, 1, 2, 3, 4, 5], 5) True >>> find_pair_with_sum([1, 2, 3, 4], 8) False >>> find_pair_with_sum([-1, -2, -3, -4, -5], -10) False >>> find_pair_with_sum([0, 0, 0, 0], 1) False >>> find_pair_with_sum([1, -1], 0) True >>> find_pair_with_sum([1, 1], 2) True >>> find_pair_with_sum([-1, -1], -2) True >>> find_pair_with_sum([0, 0], 0) True","solution":"from typing import List def find_pair_with_sum(nums: List[int], target: int) -> bool: Returns True if there exist two distinct indices i and j in nums such that nums[i] + nums[j] == target. Returns False otherwise. seen = set() for num in nums: if target - num in seen: return True seen.add(num) return False"},{"question":"import heapq def min_merge_cost(n: int, quantities: List[int]) -> int: Given n batches with their initial quantities, this function calculates the minimum cost required to combine all batches into one using a priority queue. Args: n: int - number of batches quantities: list of int - list containing quantities in batches Returns: int - minimum cost to combine all batches into one >>> min_merge_cost(5, [1, 2, 3, 4, 5]) 33 >>> min_merge_cost(1, [5]) 0 >>> min_merge_cost(2, [5, 7]) 12 >>> min_merge_cost(4, [2, 2, 2, 2]) 16 >>> min_merge_cost(3, [1000000000, 1000000000, 1000000000]) 5000000000","solution":"import heapq def min_merge_cost(n, quantities): Given n batches with their initial quantities, this function calculates the minimum cost required to combine all batches into one using a priority queue. Args: n: int - number of batches quantities: list of int - list containing quantities in batches Returns: int - minimum cost to combine all batches into one if n == 1: return 0 # Use a min-heap to keep track of the smallest batches heapq.heapify(quantities) total_cost = 0 # Keep merging until only one batch remains while len(quantities) > 1: # Extract the two smallest batches first = heapq.heappop(quantities) second = heapq.heappop(quantities) # Merge them and add the cost merge_cost = first + second total_cost += merge_cost # Push the merged batch back to the heap heapq.heappush(quantities, merge_cost) return total_cost"},{"question":"def make_palindrome_in_min_moves(t: int, cases: List[str]) -> List[int]: Koa the Koala has a string S consisting of the first 10 lowercase English alphabet letters (i.e., from 'a' to 'j'). In one move Koa can: 1. Select a substring of S of length exactly k (1  k  |S|) which is a palindrome (i.e., it reads the same backward as forward). 2. Reverse this substring. Koa wants to know the smallest number of moves she has to do to make string S read the same backward as forward (a palindrome) or determine that there is no way to make it a palindrome. For each test case: Print on a single line the smallest number of moves to make S a palindrome or -1 if there is no way to make it a palindrome. >>> make_palindrome_in_min_moves(4, [\\"aba\\", \\"abac\\", \\"racecar\\", \\"abcdedcba\\"]) [0, 1, 0, 0] >>> make_palindrome_in_min_moves(1, [\\"deed\\"]) [0] >>> make_palindrome_in_min_moves(1, [\\"a\\"]) [0] >>> make_palindrome_in_min_moves(1, [\\"abc\\"]) [-1] >>> make_palindrome_in_min_moves(1, [\\"abcbba\\"]) [1] >>> make_palindrome_in_min_moves(1, [\\"abcba\\"]) [0] # Function for provided input parsing and handling def run_solution(input_string: str) -> List[int]: input_lines = input_string.strip().split(\\"n\\") t = int(input_lines[0]) cases = input_lines[1:t+1] return make_palindrome_in_min_moves(t, cases)","solution":"def make_palindrome_in_min_moves(t, cases): def min_moves_to_palindrome(s): n = len(s) l, r = 0, n - 1 moves = 0 while l < r: if s[l] != s[r]: # Single character replacement case if s[l+1:r+1] == s[l+1:r+1][::-1]: moves += 1 l += 1 elif s[l:r] == s[l:r][::-1]: moves += 1 r -= 1 else: return -1 l += 1 r -= 1 return moves results = [] for case in cases: results.append(min_moves_to_palindrome(case)) return results # Function for provided input parsing and handling def run_solution(input_string): input_lines = input_string.strip().split(\\"n\\") t = int(input_lines[0]) cases = input_lines[1:t+1] return make_palindrome_in_min_moves(t, cases)"},{"question":"def rank_bands(band_scores): Ranks bands in descending order of their total scores. In case of ties, maintains the order of the input. Args: band_scores (list of tuples): Each tuple contains the name of the band (string) and four integers representing the scores given by the judges. Returns: list of strings: The names of the bands, sorted by descending order of their total scores. pass def parse_input(input_data): Parses the multiline input string to extract band scores. Args: input_data (str): The multiline string with band scores ending with \\"END\\". Returns: list of tuples: Each tuple contains the name of the band (string) and four integers as scores. pass def main(input_data): band_scores = parse_input(input_data) rankings = rank_bands(band_scores) return rankings if __name__ == \\"__main__\\": input_data = The Rockers 80 92 85 88 Jazz Masters 75 85 90 80 Blues Brothers 90 87 85 90 Pop Stars 70 80 75 85 Folk Singers 88 91 92 89 END print(main(input_data))","solution":"def rank_bands(band_scores): Ranks bands in descending order of their total scores. In case of ties, maintains the order of the input. Args: band_scores (list of tuples): Each tuple contains the name of the band (string) and four integers representing the scores given by the judges. Returns: list of strings: The names of the bands, sorted by descending order of their total scores. scores_with_total = [(name, sum(scores)) for name, *scores in band_scores] sorted_scores = sorted(scores_with_total, key=lambda x: x[1], reverse=True) return [name for name, _ in sorted_scores] def parse_input(input_data): Parses the multiline input string to extract band scores. Args: input_data (str): The multiline string with band scores ending with \\"END\\". Returns: list of tuples: Each tuple contains the name of the band (string) and four integers as scores. lines = input_data.strip().split('n') band_scores = [] for line in lines: if line.strip() == \\"END\\": break parts = line.rsplit(' ', 4) band_name = parts[0] scores = list(map(int, parts[1:])) band_scores.append((band_name, *scores)) return band_scores def main(input_data): band_scores = parse_input(input_data) rankings = rank_bands(band_scores) return rankings"},{"question":"def longest_non_consecutive_subsequence_length(S: str) -> int: Returns the length of the longest subsequence where no two consecutive characters are the same. >>> longest_non_consecutive_subsequence_length(\\"aabb\\") 2 >>> longest_non_consecutive_subsequence_length(\\"abcabc\\") 6","solution":"def longest_non_consecutive_subsequence_length(S): Returns the length of the longest subsequence where no two consecutive characters are the same. if not S: return 0 # Initialize the length of the longest subsequence and the previous character longest_length = 1 prev_char = S[0] # Iterate through the string starting from the second character for char in S[1:]: if char != prev_char: longest_length += 1 prev_char = char return longest_length"},{"question":"def is_perfect_fibonacci(k: int) -> str: Determines if a given number k is a perfect Fibonacci number. :param k: int, the number to be checked (1  k  10^9) :return: str, \\"YES\\" if k is a perfect Fibonacci number, otherwise \\"NO\\" >>> is_perfect_fibonacci(5) 'YES' >>> is_perfect_fibonacci(7) 'NO' >>> is_perfect_fibonacci(1) 'YES' >>> is_perfect_fibonacci(13) 'YES' >>> is_perfect_fibonacci(21) 'YES' >>> is_perfect_fibonacci(22) 'NO' >>> is_perfect_fibonacci(144) 'YES' >>> is_perfect_fibonacci(145) 'NO' >>> is_perfect_fibonacci(377) 'YES' >>> is_perfect_fibonacci(1000) 'NO' >>> is_perfect_fibonacci(6765) 'YES' >>> is_perfect_fibonacci(10946) 'YES'","solution":"def is_perfect_fibonacci(k): Determines if a given number k is a perfect Fibonacci number. :param k: int, the number to be checked (1  k  10^9) :return: str, \\"YES\\" if k is a perfect Fibonacci number, otherwise \\"NO\\" if k == 1: return \\"YES\\" a, b = 1, 1 while b < k: a, b = b, a + b return \\"YES\\" if b == k else \\"NO\\""},{"question":"def calculate_polygon_area(vertices): Calculate the area of a polygon given its vertices using the Shoelace formula. # Implement the Shoelace formula to calculate the polygon area def process_input(input_string): Process multi-dataset input string and return a list of results for each polygon dataset. >>> input_string = \\"4n0 0n4 0n4 3n0 3n3n0 0n4 0n2 3n0\\" >>> process_input(input_string) == [\\"12.000000\\", \\"6.000000\\"] >>> input_string = \\"3n0 0n4 0n2 2n0\\" >>> process_input(input_string) == [\\"4.000000\\"] # Parse the input string and calculate the area for each polygon # Unit Test def test_calculate_polygon_area(): # Test case 1 vertices = [(0, 0), (4, 0), (4, 3), (0, 3)] assert abs(calculate_polygon_area(vertices) - 12.000000) < 1e-6 # Test case 2 vertices = [(0, 0), (4, 0), (2, 3)] assert abs(calculate_polygon_area(vertices) - 6.000000) < 1e-6 # Test case 3: Triangle with vertices (0, 0), (4, 0), and (2, 2) vertices = [(0, 0), (4, 0), (2, 2)] assert abs(calculate_polygon_area(vertices) - 4.000000) < 1e-6 # Testing the process_input function with various inputs def test_process_input(): input_string = \\"4n0 0n4 0n4 3n0 3n3n0 0n4 0n2 3n0\\" expected_output = [\\"12.000000\\", \\"6.000000\\"] assert process_input(input_string) == expected_output input_string = \\"3n0 0n4 0n2 2n0\\" expected_output = [\\"4.000000\\"] assert process_input(input_string) == expected_output input_string = \\"6n0 0n4 0n4 2n2 2n2 4n0 4n0\\" expected_output = [\\"12.000000\\"] assert process_input(input_string) == expected_output input_string = \\"0\\" expected_output = [] assert process_input(input_string) == expected_output","solution":"def calculate_polygon_area(vertices): Calculate the area of a polygon given its vertices using the Shoelace formula. n = len(vertices) area = 0.0 for i in range(n): x1, y1 = vertices[i] x2, y2 = vertices[(i + 1) % n] area += x1 * y2 - y1 * x2 return abs(area) / 2.0 def process_input(input_string): Process multi-dataset input string and return a list of results for each polygon dataset. lines = input_string.strip().splitlines() results = [] index = 0 while index < len(lines): n = int(lines[index]) if n == 0: break vertices = [] for i in range(1, n + 1): x, y = map(int, lines[index + i].split()) vertices.append((x, y)) area = calculate_polygon_area(vertices) results.append(f\\"{area:.6f}\\") index += n + 1 return results"},{"question":"from typing import List, Tuple def sieve_of_eratosthenes(n): Generate a list of booleans representing whether numbers are prime up to n. is_prime = [True] * (n+1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n+1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers return is_prime def count_twin_primes(L, R, is_prime): Count the number of twin prime pairs in the range [L, R]. Args: L (int): lower bound of the range. R (int): upper bound of the range. is_prime (List[bool]): list indicating prime status of numbers up to R. Returns: int: the number of twin prime pairs in the specified range. count = 0 for num in range(max(2, L), R - 1): if is_prime[num] and is_prime[num + 2]: count += 1 return count def twin_prime_pairs(t: int, ranges: List[Tuple[int, int]]) -> List[int]: Compute the number of twin prime pairs for multiple test cases. Args: t (int): the number of test cases. ranges (List[Tuple[int, int]]): list of (L, R) tuples representing the ranges. Returns: List[int]: a list containing the number of twin prime pairs for each test case. max_R = max(r[1] for r in ranges) is_prime = sieve_of_eratosthenes(max_R) results = [] for L, R in ranges: results.append(count_twin_primes(L, R, is_prime)) return results # Unit Test def test_example_case(): assert twin_prime_pairs(3, [(1, 10), (11, 20), (1, 100)]) == [2, 2, 8] def test_no_twin_primes(): assert twin_prime_pairs(1, [(14, 16)]) == [0] def test_single_digit_range(): assert twin_prime_pairs(1, [(1, 10)]) == [2] def test_large_range(): assert twin_prime_pairs(1, [(1, 1000)]) == [35] def test_full_range(): assert twin_prime_pairs(1, [(1, 1000000)]) == [8169] def test_partial_range_with_large_R(): assert twin_prime_pairs(1, [(999983, 1000000)]) == [0] def test_range_with_known_twin_primes(): assert twin_prime_pairs(1, [(29, 43)]) == [2]","solution":"def sieve_of_eratosthenes(n): Generate a list of booleans representing whether numbers are prime up to n. is_prime = [True] * (n+1) p = 2 while (p * p <= n): if (is_prime[p] == True): for i in range(p * p, n+1, p): is_prime[i] = False p += 1 is_prime[0], is_prime[1] = False, False # 0 and 1 are not prime numbers return is_prime def count_twin_primes(L, R, is_prime): count = 0 for num in range(max(2, L), R - 1): if is_prime[num] and is_prime[num + 2]: count += 1 return count def twin_prime_pairs(t, ranges): max_R = max(r[1] for r in ranges) is_prime = sieve_of_eratosthenes(max_R) results = [] for L, R in ranges: results.append(count_twin_primes(L, R, is_prime)) return results"},{"question":"def lexicographically_smallest_string(inputs: List[str]) -> List[str]: Returns the lexicographically smallest string that can be obtained after performing any number of character move operations on the input strings. >>> lexicographically_smallest_string([\\"cba\\", \\"acb\\", \\"zxy\\", \\"0\\"]) [\\"abc\\", \\"abc\\", \\"xyz\\"] >>> lexicographically_smallest_string([\\"bca\\", \\"xyz\\", \\"cba\\", \\"0\\"]) [\\"abc\\", \\"xyz\\", \\"abc\\"] >>> lexicographically_smallest_string([\\"c\\", \\"a\\", \\"b\\", \\"0\\"]) [\\"c\\", \\"a\\", \\"b\\"] >>> lexicographically_smallest_string([\\"0\\"]) [] >>> lexicographically_smallest_string([\\"a\\", \\"b\\", \\"c\\", \\"0\\"]) [\\"a\\", \\"b\\", \\"c\\"] >>> lexicographically_smallest_string([\\"abc\\", \\"xyz\\", \\"mno\\", \\"0\\"]) [\\"abc\\", \\"xyz\\", \\"mno\\"] >>> lexicographically_smallest_string([\\"cba\\", \\"zyx\\", \\"fed\\", \\"0\\"]) [\\"abc\\", \\"xyz\\", \\"def\\"] >>> lexicographically_smallest_string([\\"cab\\", \\"bac\\", \\"acb\\", \\"0\\"]) [\\"abc\\", \\"abc\\", \\"abc\\"]","solution":"def lexicographically_smallest_string(inputs): Returns the lexicographically smallest string that can be obtained after performing any number of character move operations on the input strings. results = [] for s in inputs: if s == \\"0\\": break results.append(''.join(sorted(s))) return results"},{"question":"def fibonacci_tree_depth(n: int) -> int: Returns the minimum depth of any Fibonacci Tree that can contain a leaf with the given number n. >>> fibonacci_tree_depth(3) 4 >>> fibonacci_tree_depth(21) 8 >>> fibonacci_tree_depth(144) 12","solution":"def fibonacci_tree_depth(n): Returns the minimum depth of any Fibonacci Tree that can contain a leaf with the given number n. if n == 1: return 1 fib1, fib2 = 1, 1 depth = 2 # Since both F(1)=1 and F(2)=1, we start from depth 2 while fib2 < n: fib1, fib2 = fib2, fib1 + fib2 depth += 1 return depth"},{"question":"def is_zigzag(arr: List[int]) -> bool: Determine if the array has any two consecutive integers that follow the zigzag pattern of alternating between increasing and decreasing. :param arr: List[int] - List of integers :return: bool - True if the array contains at least one zigzag pair, False otherwise. >>> is_zigzag([4, 7, 3, 6, 2]) == True >>> is_zigzag([1, 2, 3, 4]) == False >>> is_zigzag([5, 1, 6, 2]) == True >>> is_zigzag([1]) == False >>> is_zigzag([]) == False >>> is_zigzag([10, 5, 10, 5, 10]) == True >>> is_zigzag([10, 20, 30]) == False >>> is_zigzag([-1, -2, -1]) == True >>> is_zigzag([0, 1, -1, 1]) == True >>> is_zigzag([2, 2, 2, 2]) == False","solution":"def is_zigzag(arr): Determine if the array has any two consecutive integers that follow the zigzag pattern of alternating between increasing and decreasing. :param arr: List[int] - List of integers :return: bool - True if the array contains at least one zigzag pair, False otherwise. # If the array has less than 2 elements, it cannot be a zigzag if len(arr) < 2: return False for i in range(1, len(arr)-1): if (arr[i] > arr[i-1] and arr[i] > arr[i+1]) or (arr[i] < arr[i-1] and arr[i] < arr[i+1]): return True return False"},{"question":"from typing import List def is_prime(n: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(4) False def max_non_overlapping_subarrays_with_prime_sum(arr: List[int]) -> int: Find the maximum number of non-overlapping subarrays such that the sum of each subarray is a prime number. >>> max_non_overlapping_subarrays_with_prime_sum([2, 3, 5, 7, 11]) 5 >>> max_non_overlapping_subarrays_with_prime_sum([4, 6, 8, 10, 12, 14]) 0 >>> max_non_overlapping_subarrays_with_prime_sum([1, 2, 3, 4, 5, 6, 7]) 4 >>> max_non_overlapping_subarrays_with_prime_sum([4, 6, 9, 15]) 0 def test_is_prime(): assert is_prime(2) == True assert is_prime(3) == True assert is_prime(4) == False assert is_prime(5) == True assert is_prime(10) == False assert is_prime(13) == True def test_max_non_overlapping_subarrays_with_prime_sum(): assert max_non_overlapping_subarrays_with_prime_sum([2, 3, 5, 7, 11]) == 5 assert max_non_overlapping_subarrays_with_prime_sum([4, 6, 8, 10, 12, 14]) == 0 assert max_non_overlapping_subarrays_with_prime_sum([1, 2, 3, 4, 5, 6, 7]) == 4 assert max_non_overlapping_subarrays_with_prime_sum([4, 6, 9, 15]) == 0 assert max_non_overlapping_subarrays_with_prime_sum([1, 1, 1, 1, 1, 1, 1]) == 0 assert max_non_overlapping_subarrays_with_prime_sum([2, 4, 3, 6, 5]) == 3","solution":"from math import isqrt def is_prime(n): if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def max_non_overlapping_subarrays_with_prime_sum(arr): prime_sums = [is_prime(x) for x in arr] return sum(prime_sums)"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): Find the maximum path sum in a binary tree. >>> tree = build_tree([1, [2, None, None], [3, None, None]]) >>> max_path_sum(tree) 6 >>> tree = build_tree([-10, [9, None, None], [20, [15, None, None], [7, None, None]]]) >>> max_path_sum(tree) 42 >>> tree = build_tree([-3, [-2, None, None], [-1, None, None]]) >>> max_path_sum(tree) -1 >>> tree = build_tree([0, [-1, None, None], [1, None, None]]) >>> max_path_sum(tree) 1 >>> tree = build_tree([1]) >>> max_path_sum(tree) 1 pass def build_tree(lst): Helper function to build a tree from a nested list representation. pass","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def max_path_sum(root): def helper(node): nonlocal max_sum if not node: return 0 left_gain = max(helper(node.left), 0) right_gain = max(helper(node.right), 0) # Price of the current path price_newpath = node.val + left_gain + right_gain # Update max_sum if price_newpath is better max_sum = max(max_sum, price_newpath) # For recursion, return the max gain if continue the same path return node.val + max(left_gain, right_gain) max_sum = float('-inf') helper(root) return max_sum def build_tree(lst): if not lst: return None root_val = lst[0] left_lst = lst[1] if len(lst) > 1 else None right_lst = lst[2] if len(lst) > 2 else None root = TreeNode(root_val) if left_lst: root.left = build_tree(left_lst) if right_lst: root.right = build_tree(right_lst) return root"},{"question":"def sort_words_by_length(words_str: str) -> list: Sort words by their length. If two words have the same length, they appear in the order they were provided in the input. Parameters: words_str (str): A string containing words separated by spaces. Returns: list: A list of words sorted by their length. >>> sort_words_by_length(\\"apple banana cherry date\\") ['date', 'apple', 'banana', 'cherry'] >>> sort_words_by_length(\\"a ab abc abcd\\") ['a', 'ab', 'abc', 'abcd'] def format_sorted_words(sorted_words: list) -> str: Formats the sorted words list into a string with each word on a new line. Parameters: sorted_words (list): A list of words sorted by their length. Returns: str: A formatted string with each word on a new line. >>> format_sorted_words([\\"date\\", \\"apple\\", \\"banana\\", \\"cherry\\"]) 'datenapplenbananancherry' >>> format_sorted_words([\\"a\\", \\"ab\\", \\"abc\\", \\"abcd\\"]) 'anabnabcnabcd'","solution":"def sort_words_by_length(words_str): Sort words by their length. If two words have the same length, they appear in the order they were provided in the input. Parameters: words_str (str): A string containing words separated by spaces. Returns: list: A list of words sorted by their length. words = words_str.split() sorted_words = sorted(words, key=len) return sorted_words def format_sorted_words(sorted_words): Formats the sorted words list into a string with each word on a new line. Parameters: sorted_words (list): A list of words sorted by their length. Returns: str: A formatted string with each word on a new line. return \\"n\\".join(sorted_words) # Example usage: # words = \\"apple banana cherry date\\" # sorted_words = sort_words_by_length(words) # result = format_sorted_words(sorted_words) # print(result)"},{"question":"def is_palindromic_score(score_a: str, score_b: str) -> str: Checks if the concatenation of scores of player A and player B forms a palindromic string. >>> is_palindromic_score('123', '321') \\"YES\\" >>> is_palindromic_score('123', '456') \\"NO\\"","solution":"def is_palindromic_score(score_a, score_b): Checks if the concatenation of scores of player A and player B forms a palindromic string. concatenated_score = score_a + score_b return \\"YES\\" if concatenated_score == concatenated_score[::-1] else \\"NO\\""},{"question":"def can_travel(n, maxDistance, coordinates, start, end): Determines if it's possible to travel from the start system to the destination system within given fuel constraints, using intermediate systems as refuel points. Args: n: int - the number of star systems (2  n  100) maxDistance: int - maximum distance a spaceship can travel without refueling (1  maxDistance  1000) coordinates: list of tuples - each containing three integers representing the x, y, z coordinates of each star system (10^3  x, y, z  10^3) start: int - the index of the start star system (1-based) end: int - the index of the destination star system (1-based) Returns: 'YES' if it's possible to travel from the start to the destination system. 'NO' otherwise. Examples: >>> can_travel(4, 100, [(0, 0, 0), (100, 0, 0), (50, 86, 0), (-30, 100, 100)], 1, 4) \\"NO\\" >>> can_travel(5, 150, [(0, 0, 0), (100, 100, 0), (200, 200, 0), (150, 250, 0), (300, 250, 0)], 1, 5) \\"YES\\" from solution import can_travel def test_example1(): n = 4 maxDistance = 100 coordinates = [(0, 0, 0), (100, 0, 0), (50, 86, 0), (-30, 100, 100)] start, end = 1, 4 assert can_travel(n, maxDistance, coordinates, start, end) == \\"NO\\" def test_example2(): n = 5 maxDistance = 150 coordinates = [(0, 0, 0), (100, 100, 0), (200, 200, 0), (150, 250, 0), (300, 250, 0)] start, end = 1, 5 assert can_travel(n, maxDistance, coordinates, start, end) == \\"YES\\" def test_no_possible_connections(): n = 3 maxDistance = 50 coordinates = [(0, 0, 0), (100, 100, 0), (200, 200, 0)] start, end = 1, 3 assert can_travel(n, maxDistance, coordinates, start, end) == \\"NO\\" def test_direct_connection(): n = 2 maxDistance = 1000 coordinates = [(0, 0, 0), (100, 0, 0)] start, end = 1, 2 assert can_travel(n, maxDistance, coordinates, start, end) == \\"YES\\" def test_indirect_connection(): n = 4 maxDistance = 150 coordinates = [(0, 0, 0), (100, 100, 0), (200, 200, 0), (300, 300, 0)] start, end = 1, 4 assert can_travel(n, maxDistance, coordinates, start, end) == \\"YES\\"","solution":"import math def can_travel(n, maxDistance, coordinates, start, end): def euclidean_distance(point1, point2): return math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2 + (point1[2] - point2[2]) ** 2) # Create graph adjacency list graph = {i: [] for i in range(n)} for i in range(n): for j in range(i + 1, n): distance = euclidean_distance(coordinates[i], coordinates[j]) if distance <= maxDistance: graph[i].append(j) graph[j].append(i) # BFS to check if we can reach from start to end start -= 1 end -= 1 queue = [start] visited = [False] * n visited[start] = True while queue: current = queue.pop(0) if current == end: return \\"YES\\" for neighbor in graph[current]: if not visited[neighbor]: visited[neighbor] = True queue.append(neighbor) return \\"NO\\""},{"question":"from typing import List def count_redistributions(n: int, candies: List[int]) -> int: In a magical forest, there are n unicorns. Each unicorn has some number of magical candies. Every day, unicorns perform a ritual where they exchange candies in a specific manner to maintain balance. The rules of the ritual are as follows: 1. Each unicorn can give exactly one candy to another unicorn. 2. Each unicorn can receive at most one candy from another unicorn. 3. The goal is to find out how many different ways the candies can be redistributed among the unicorns so that the total number of candies remains unchanged. Args: n: int - the number of unicorns (1  n  100). candies: List[int] - the initial number of candies each unicorn has (0  ai  100). Returns: int: the number of different ways the candies can be redistributed. Examples: >>> count_redistributions(3, [1, 2, 1]) 6 >>> count_redistributions(4, [2, 2, 2, 2]) 24 >>> count_redistributions(2, [0, 1]) 0","solution":"from math import factorial def count_redistributions(n, candies): if n < 2: return 0 sum_candies = sum(candies) max_candies = max(candies) if max_candies > (sum_candies - max_candies): return 0 return factorial(n)"},{"question":"def first_missing_positive(nums: List[int]) -> int: Find the smallest missing positive integer from the list. Args: nums: List[int] - A list of integers. Returns: int - The smallest positive integer missing from the list. >>> first_missing_positive([3, 4, -1, 1]) 2 >>> first_missing_positive([1, 2, 0]) 3 >>> first_missing_positive([7, 8, 9, 11, 12]) 1 >>> first_missing_positive([-3, -4, -2, -1]) 1 >>> first_missing_positive([3, 4, -1, 1, -5, 2]) 5 >>> first_missing_positive([1, 1, 2, 2, 3, 3, 4, 4, 5, 5]) 6 >>> first_missing_positive([1]) 2 >>> first_missing_positive([-1]) 1 >>> first_missing_positive([2]) 1 >>> first_missing_positive([]) 1","solution":"def first_missing_positive(nums): Find the smallest missing positive integer from the list. Args: nums: List[int] - A list of integers. Returns: int - The smallest positive integer missing from the list. n = len(nums) for i in range(n): while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]: nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1] for i in range(n): if nums[i] != i + 1: return i + 1 return n + 1"},{"question":"def compute_sum(a: int, b: int, s: str) -> int: Generate a sequence based on the characters in the string s and compute the sum of the sequence. Parameters: a (int): The integer to use for '0' characters. b (int): The integer to use for '1' characters. s (str): The binary string to use for generating the sequence. Returns: int: The sum of the resulting sequence.","solution":"def compute_sum(a, b, s): Generate a sequence based on the characters in the string s and compute the sum of the sequence. Parameters: a (int): The integer to use for '0' characters. b (int): The integer to use for '1' characters. s (str): The binary string to use for generating the sequence. Returns: int: The sum of the resulting sequence. result = [] for char in s: if char == '0': result.append(a) elif char == '1': result.append(b) return sum(result)"},{"question":"def find_anagram_pairs(words: List[str]) -> List[Tuple[int, int]]: Implement a function find_anagram_pairs that takes a list of strings as input and returns a list of tuples where each tuple contains indices of two strings that are anagrams of each other in the original list. Ignore punctuation and capitalization. >>> find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"enlist\\", \\"inlets\\", \\"google\\", \\"gogole\\"]) [(0, 1), (0, 2), (0, 3), (1, 2), (1, 3), (2, 3), (4, 5)] >>> find_anagram_pairs([]) [] >>> find_anagram_pairs([\\"apple\\", \\"banana\\", \\"carrot\\"]) [] >>> find_anagram_pairs([\\"Dormitory\\", \\"dirty room\\", \\"Dirty-rooM!\\", \\"astronomer\\", \\"Moon Starer\\", \\"Hello\\"]) [(0, 1), (0, 2), (1, 2), (3, 4)] >>> find_anagram_pairs([\\"Listen\\", \\"Silent\\", \\"EnLiSt\\"]) [(0, 1), (0, 2), (1, 2)] >>> find_anagram_pairs([\\"anagram\\", \\"Nag a ram\\", \\"garden\\", \\"danger\\"]) [(0, 1), (2, 3)]","solution":"import re from collections import defaultdict def normalize_string(s): Normalize the string by removing all non-alphabetic characters and sorting. s = re.sub(r'[^a-zA-Z]', '', s) # Remove non-alphabetic characters return ''.join(sorted(s.lower())) # Sort characters and make lowercase def find_anagram_pairs(words): Find pairs of indices of anagram strings in the given list of words. normalized_map = defaultdict(list) # Map normalized string to list of indices for index, word in enumerate(words): normalized_word = normalize_string(word) normalized_map[normalized_word].append(index) result = [] for indices in normalized_map.values(): if len(indices) > 1: # If there are multiple words with the same normalized form for i in range(len(indices)): for j in range(i + 1, len(indices)): result.append((indices[i], indices[j])) return result"},{"question":"def shortest_subarray_length_with_sum_at_least(arr: List[int], s: int) -> int: Determine the length of the shortest subarray such that the sum of its elements is at least a given value. If no such subarray exists, return -1. >>> shortest_subarray_length_with_sum_at_least([1, 2, 3, 4, 5], 11) 3 >>> shortest_subarray_length_with_sum_at_least([1, 1, 1, 1, 1], 10) -1","solution":"def shortest_subarray_length_with_sum_at_least(arr, s): n = len(arr) min_length = n + 1 current_sum = 0 start = 0 for end in range(n): current_sum += arr[end] while current_sum >= s: min_length = min(min_length, end - start + 1) current_sum -= arr[start] start += 1 return min_length if min_length <= n else -1 # Example Usage # arr = [1, 2, 3, 4, 5] # s = 11 # print(shortest_subarray_length_with_sum_at_least(arr, s)) # Output: 3"},{"question":"def count_local_peaks(matrix: List[List[int]]) -> int: Counts the number of local peaks in the given matrix. A cell is considered a local peak if it is greater than all of its 4 neighboring cells (up, down, left, and right). :param matrix: List of lists representing the matrix of terrain heights. :return: Number of local peaks in the matrix. >>> count_local_peaks([ ... [1, 2, 1], ... [2, 1, 2], ... [1, 2, 1] ... ]) == 4 >>> count_local_peaks([ ... [3, 3], ... [3, 3] ... ]) == 0 >>> count_local_peaks([ ... [1, 2, 3, 2, 1], ... [2, 3, 4, 3, 2], ... [3, 4, 5, 4, 3], ... [2, 3, 4, 3, 2], ... [1, 2, 3, 2, 1] ... ]) == 1 >>> count_local_peaks([ ... [10] ... ]) == 1 >>> count_local_peaks([ ... [1, 0, 1], ... [0, 2, 0], ... [1, 0, 1] ... ]) == 5 >>> count_local_peaks([]) == 0 >>> count_local_peaks([[1, 3, 2]]) == 1 >>> count_local_peaks([[3], [2], [1]]) == 1","solution":"def count_local_peaks(matrix): Counts the number of local peaks in the given matrix. A cell is considered a local peak if it is greater than all of its 4 neighboring cells (up, down, left, and right). :param matrix: List of lists representing the matrix of terrain heights. :return: Number of local peaks in the matrix. if not matrix: return 0 N = len(matrix) M = len(matrix[0]) local_peaks = 0 for i in range(N): for j in range(M): current = matrix[i][j] is_peak = True # Check all four neighboring cells (up, down, left, right) for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]: ni, nj = i + di, j + dj if 0 <= ni < N and 0 <= nj < M: if matrix[ni][nj] >= current: is_peak = False break if is_peak: local_peaks += 1 return local_peaks # Reading input from standard input if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) matrix = [] for i in range(N): row = list(map(int, data[2 + i * M: 2 + (i + 1) * M])) matrix.append(row) print(count_local_peaks(matrix))"},{"question":"def min_cost_to_make_equal(M: int, elements: List[int]) -> int: Returns the minimum cost required to make all elements in the array equal. :param M: int, number of elements in the array :param elements: list of int, the array elements :return: int, minimum cost to make all elements equal >>> min_cost_to_make_equal(4, [2, 3, 1, 4]) 5 >>> min_cost_to_make_equal(5, [1, 2, 3, 4, 5]) 6 >>> min_cost_to_make_equal(3, [1, 1, 1]) 0 >>> min_cost_to_make_equal(3, [5, 2, 3]) 3 >>> min_cost_to_make_equal(4, [2, 2, 2, 2]) 0 >>> min_cost_to_make_equal(2, [1, 100]) 99 >>> min_cost_to_make_equal(6, [10, 20, 30, 40, 50, 60]) 90 from typing import List","solution":"def min_cost_to_make_equal(M, elements): Returns the minimum cost required to make all elements in the array equal. :param M: int, number of elements in the array :param elements: list of int, the array elements :return: int, minimum cost to make all elements equal elements.sort() median = elements[M // 2] cost = 0 for elem in elements: cost += abs(elem - median) return cost"},{"question":"def can_be_palindrome_by_one_change(s: str) -> str: Determine if the given string can be made a palindrome by changing at most one character. >>> can_be_palindrome_by_one_change(\\"abca\\") \\"Yes\\" >>> can_be_palindrome_by_one_change(\\"racecar\\") \\"Yes\\" >>> can_be_palindrome_by_one_change(\\"abcdef\\") \\"No\\" from solution import can_be_palindrome_by_one_change def test_can_be_palindrome_by_one_change_palindrome_string(): assert can_be_palindrome_by_one_change(\\"racecar\\") == \\"Yes\\" def test_can_be_palindrome_by_one_change_almost_palindrome_string(): assert can_be_palindrome_by_one_change(\\"abca\\") == \\"Yes\\" def test_can_be_palindrome_by_one_change_not_possible(): assert can_be_palindrome_by_one_change(\\"abcdef\\") == \\"No\\" def test_can_be_palindrome_by_one_change_single_character(): assert can_be_palindrome_by_one_change(\\"a\\") == \\"Yes\\" def test_can_be_palindrome_by_one_change_two_characters_not_palindrome(): assert can_be_palindrome_by_one_change(\\"ab\\") == \\"Yes\\" def test_can_be_palindrome_by_one_change_two_characters_palindrome(): assert can_be_palindrome_by_one_change(\\"aa\\") == \\"Yes\\" def test_can_be_palindrome_by_one_change_large_input(): assert can_be_palindrome_by_one_change(\\"a\\" * 50000 + \\"b\\" + \\"a\\" * 49999) == \\"Yes\\"","solution":"def can_be_palindrome_by_one_change(s): Determine if the given string can be made a palindrome by changing at most one character. n = len(s) mismatch_count = 0 # Compare characters from the beginning and the end toward the middle for i in range(n // 2): if s[i] != s[n - i - 1]: mismatch_count += 1 if mismatch_count > 1: return \\"No\\" return \\"Yes\\""},{"question":"class MovieManager: A class to manage a list of movies with operations to add, delete, query, and find the earliest movie. Methods: add(name: str, year: int): Adds or updates a movie with given name and release year. delete(name: str): Deletes a movie with the given name from the list. query(name: str) -> Union[int, str]: Returns the release year of the movie with the given name or \\"NOT FOUND\\". earliest() -> str: Returns the name and release year of the earliest released movie or \\"EMPTY\\". Example: >>> manager = MovieManager() >>> manager.add(\\"Inception\\", 2010) >>> manager.add(\\"Interstellar\\", 2014) >>> manager.query(\\"Inception\\") 2010 >>> manager.earliest() 'Inception 2010' >>> manager.delete(\\"Interstellar\\") >>> manager.earliest() 'Inception 2010' >>> manager.query(\\"Tenet\\") 'NOT FOUND' def __init__(self): pass def add(self, name, year): pass def delete(self, name): pass def query(self, name): pass def earliest(self): pass def test_add_and_query(): manager = MovieManager() manager.add(\\"Inception\\", 2010) manager.add(\\"Interstellar\\", 2014) manager.add(\\"Dunkirk\\", 2017) assert manager.query(\\"Inception\\") == 2010 assert manager.query(\\"Interstellar\\") == 2014 assert manager.query(\\"Dunkirk\\") == 2017 assert manager.query(\\"Tenet\\") == \\"NOT FOUND\\" def test_add_update_and_query(): manager = MovieManager() manager.add(\\"Inception\\", 2010) manager.add(\\"Inception\\", 2012) # Update release year assert manager.query(\\"Inception\\") == 2012 def test_delete_and_query(): manager = MovieManager() manager.add(\\"Inception\\", 2010) manager.delete(\\"Inception\\") assert manager.query(\\"Inception\\") == \\"NOT FOUND\\" def test_delete_non_existent_movie(): manager = MovieManager() manager.delete(\\"NonExistentMovie\\") # Should not raise an error def test_earliest_single_movie(): manager = MovieManager() manager.add(\\"Inception\\", 2010) assert manager.earliest() == \\"Inception 2010\\" def test_earliest_multiple_movies(): manager = MovieManager() manager.add(\\"Inception\\", 2010) manager.add(\\"Interstellar\\", 2014) manager.add(\\"Dunkirk\\", 2017) assert manager.earliest() == \\"Inception 2010\\" manager.add(\\"Memento\\", 2000) assert manager.earliest() == \\"Memento 2000\\" def test_earliest_after_deletion(): manager = MovieManager() manager.add(\\"Inception\\", 2010) manager.add(\\"Memento\\", 2000) manager.delete(\\"Memento\\") assert manager.earliest() == \\"Inception 2010\\" def test_earliest_empty_list(): manager = MovieManager() assert manager.earliest() == \\"EMPTY\\"","solution":"class MovieManager: def __init__(self): self.movies = {} self.add_order = [] def add(self, name, year): if name in self.movies: self.movies[name] = year else: self.movies[name] = year self.add_order.append(name) def delete(self, name): if name in self.movies: del self.movies[name] self.add_order.remove(name) def query(self, name): return self.movies.get(name, \\"NOT FOUND\\") def earliest(self): if not self.movies: return \\"EMPTY\\" earliest_year = min(self.movies.values()) for name in self.add_order: if self.movies[name] == earliest_year: return f\\"{name} {earliest_year}\\""},{"question":"def merge(arr, l, m, r): Merge function for the merge sort algorithm. Merges two subarrays of arr[]. First subarray is arr[l..m] Second subarray is arr[m+1..r] >>> arr = [12, 11, 13, 5, 6, 7, 14, 9, 15, 2] >>> merge_sort(arr, 0, len(arr) - 1) >>> print(arr) [2, 5, 6, 7, 9, 11, 12, 13, 14, 15] pass def merge_sort(arr, l, r): if l < r: m = (l + r) // 2 merge_sort(arr, l, m) merge_sort(arr, m + 1, r) merge(arr, l, m, r) def test_merge_sort(): arr = [12, 11, 13, 5, 6, 7, 14, 9, 15, 2] merge_sort(arr, 0, len(arr) - 1) assert arr == [2, 5, 6, 7, 9, 11, 12, 13, 14, 15] def test_merge_sort_single_element(): arr = [1] merge_sort(arr, 0, len(arr) - 1) assert arr == [1] def test_merge_sort_sorted(): arr = [1, 2, 3, 4, 5] merge_sort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 5] def test_merge_sort_reverse(): arr = [5, 4, 3, 2, 1] merge_sort(arr, 0, len(arr) - 1) assert arr == [1, 2, 3, 4, 5] def test_merge_sort_duplicates(): arr = [4, 4, 3, 3, 2, 2, 1, 1] merge_sort(arr, 0, len(arr) - 1) assert arr == [1, 1, 2, 2, 3, 3, 4, 4] def test_merge_sort_large_input(): arr = list(range(100000, 0, -1)) expected = list(range(1, 100001)) merge_sort(arr, 0, len(arr) - 1) assert arr == expected","solution":"def merge(arr, l, m, r): Merges two subarrays of arr[]. First subarray is arr[l..m] Second subarray is arr[m+1..r] n1 = m - l + 1 n2 = r - m # Create temporary arrays L = [0] * n1 R = [0] * n2 # Copy data to temporary arrays L[] and R[] for i in range(n1): L[i] = arr[l + i] for j in range(n2): R[j] = arr[m + 1 + j] # Merge the temporary arrays back into arr[l..r] i = 0 j = 0 k = l while i < n1 and j < n2: if L[i] <= R[j]: arr[k] = L[i] i += 1 else: arr[k] = R[j] j += 1 k += 1 # Copy the remaining elements of L[], if there are any while i < n1: arr[k] = L[i] i += 1 k += 1 # Copy the remaining elements of R[], if there are any while j < n2: arr[k] = R[j] j += 1 k += 1 def merge_sort(arr, l, r): if l < r: m = (l + r) // 2 merge_sort(arr, l, m) merge_sort(arr, m + 1, r) merge(arr, l, m, r)"},{"question":"def is_knight_reachable(t: int, test_cases: List[Tuple[int, int, int, int, int]]) -> List[str]: Determine if a knight can move from its starting position to a target position on an 8x8 chessboard in exactly \`n\` steps for multiple test cases. Args: t: The number of test cases. test_cases: A list of tuples, each containing: - n: Number of steps to reach destination - sx: Starting x-coordinate of the knight - sy: Starting y-coordinate of the knight - tx: Target x-coordinate of the knight - ty: Target y-coordinate of the knight Returns: A list of strings, where each string is \\"YES\\" if the knight can reach the target position in exactly \`n\` steps, and \\"NO\\" otherwise. >>> is_knight_reachable(3, [(1, 0, 0, 2, 1), (2, 0, 0, 3, 1), (3, 1, 1, 2, 2)]) [\\"YES\\", \\"YES\\", \\"NO\\"] >>> is_knight_reachable(2, [(1, 0, 0, 3, 3), (4, 0, 0, 0, 7)]) [\\"NO\\", \\"NO\\"]","solution":"def is_knight_reachable(t, test_cases): def bfs_knight_steps(sx, sy, tx, ty, n): directions = [ (2, 1), (2, -1), (-2, 1), (-2, -1), (1, 2), (1, -2), (-1, 2), (-1, -2) ] queue = [(sx, sy, 0)] # (x, y, steps) visited = set((sx, sy)) while queue: x, y, steps = queue.pop(0) if steps == n: if (x, y) == (tx, ty): return True continue for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx <= 7 and 0 <= ny <= 7 and (nx, ny) not in visited: queue.append((nx, ny, steps + 1)) visited.add((nx, ny)) return False results = [] for case in test_cases: n, sx, sy, tx, ty = case if bfs_knight_steps(sx, sy, tx, ty, n): results.append(\\"YES\\") else: results.append(\\"NO\\") return results # Example usage t = 3 test_cases = [ (1, 0, 0, 2, 1), (2, 0, 0, 3, 1), (3, 1, 1, 2, 2) ] print(is_knight_reachable(t, test_cases)) # Output: [\\"YES\\", \\"YES\\", \\"NO\\"]"},{"question":"def find_central_hub(n: int, m: int, roads: List[Tuple[int, int, int]]) -> int: On Pathland's vast network of roads, there are n locations connected by m bidirectional roads. The government of Pathland has decided to improve access by ensuring there is a single central hub that has the shortest possible maximum distance to all other locations. This function finds the location with the minimum of the maximum shortest paths to all other locations. Parameters: n (int): The number of locations. m (int): The number of roads. roads (List[Tuple[int, int, int]]): List of tuples representing roads where each tuple contains three integers u, v, and w Returns: int: The location of the hub such that the maximum distance from this location to any other location is the smallest possible. Examples: >>> find_central_hub(5, 6, [(1, 2, 3), (2, 3, 2), (3, 4, 4), (4, 5, 1), (5, 1, 5), (2, 4, 1)]) 2 >>> find_central_hub(4, 3, [(1, 2, 1), (2, 3, 1), (3, 4, 1)]) 2","solution":"import heapq def find_central_hub(n, m, roads): # Initialize graph as an adjacency list graph = [[] for _ in range(n + 1)] for u, v, w in roads: graph[u].append((v, w)) graph[v].append((u, w)) def dijkstra(source): distances = [float('inf')] * (n + 1) distances[source] = 0 min_heap = [(0, source)] while min_heap: current_distance, node = heapq.heappop(min_heap) if current_distance > distances[node]: continue for neighbor, weight in graph[node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(min_heap, (distance, neighbor)) return distances[1:] min_max_distance = float('inf') best_location = -1 for i in range(1, n + 1): distances = dijkstra(i) max_distance = max(distances) if max_distance < min_max_distance: min_max_distance = max_distance best_location = i elif max_distance == min_max_distance: best_location = min(best_location, i) return best_location"},{"question":"def sort_words(words: List[str]) -> List[str]: Sorts a list of words first by their length in ascending order, and then lexicographically if they have the same length. Parameters: words (list): A list of strings, each word containing lowercase English letters only. Returns: list: The sorted list of words. >>> sort_words([\\"watson\\", \\"turing\\", \\"is\\", \\"the\\", \\"greatest\\"]) [\\"is\\", \\"the\\", \\"turing\\", \\"watson\\", \\"greatest\\"] >>> sort_words([\\"apple\\", \\"app\\", \\"banana\\", \\"bat\\"]) [\\"app\\", \\"bat\\", \\"apple\\", \\"banana\\"] >>> sort_words([\\"to\\", \\"be\\", \\"or\\", \\"not\\", \\"to\\", \\"be\\"]) [\\"be\\", \\"be\\", \\"or\\", \\"to\\", \\"to\\", \\"not\\"] >>> sort_words([\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeeee\\"]) [\\"a\\", \\"bb\\", \\"ccc\\", \\"dddd\\", \\"eeeee\\"] >>> sort_words([\\"same\\", \\"size\\", \\"word\\"]) [\\"same\\", \\"size\\", \\"word\\"]","solution":"def sort_words(words): Sorts a list of words first by their length in ascending order, and then lexicographically if they have the same length. Parameters: words (list): A list of strings, each word containing lowercase English letters only. Returns: list: The sorted list of words. return sorted(words, key=lambda x: (len(x), x))"},{"question":"def find_operations(t: int, test_cases: List[int]) -> List[Tuple[int, List[Tuple[int, int]]]]: For each test case, find the sequence of operations to transform the array b to consist of exactly n unique values. Args: t: The number of test cases. test_cases: A list containing the length of the array b for each test case. Returns: A list of tuples, each containing the number of operations and a list of pairs of indices involved in each operation. Example: >>> find_operations(2, [3, 4]) [(2, [(1, 2), (1, 3)]), (3, [(1, 2), (1, 3), (1, 4)])] from solution import find_operations def test_example_cases(): t = 2 test_cases = [3, 4] expected = [ (2, [(1, 2), (1, 3)]), (3, [(1, 2), (1, 3), (1, 4)]) ] assert find_operations(t, test_cases) == expected def test_single_case_min_n(): t = 1 test_case = [2] expected = [(1, [(1, 2)])] assert find_operations(t, [2]) == expected def test_single_case_large_n(): t = 1 n = 5 expected = [(4, [(1, 2), (1, 3), (1, 4), (1, 5)])] assert find_operations(t, [5]) == expected def test_multiple_cases(): t = 3 test_cases = [3, 2, 5] expected = [ (2, [(1, 2), (1, 3)]), (1, [(1, 2)]), (4, [(1, 2), (1, 3), (1, 4), (1, 5)]) ] assert find_operations(t, test_cases) == expected","solution":"def find_operations(t, test_cases): results = [] for n in test_cases: operations = [(1, i) for i in range(2, n+1)] results.append((n-1, operations)) return results"},{"question":"def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80, 1]) == 6 >>> longest_increasing_subsequence([10]) == 1 >>> longest_increasing_subsequence([10, 9, 8, 7, 6, 5]) == 1 >>> longest_increasing_subsequence([1, 2, 3, 4, 5, 6]) == 6 >>> longest_increasing_subsequence([1, 5, 1, 5, 1, 5]) == 2 >>> longest_increasing_subsequence([4, 10, 4, 3, 8, 9]) == 3 >>> longest_increasing_subsequence([i for i in range(1000)]) == 1000","solution":"from typing import List def longest_increasing_subsequence(arr: List[int]) -> int: Returns the length of the longest increasing subsequence in the array. if not arr: return 0 n = len(arr) dp = [1] * n for i in range(1, n): for j in range(i): if arr[i] > arr[j]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def check_zero_in_number(n: int) -> str: Checks whether any digit of the number n is 0. Returns \\"YES\\" if any digit is 0, otherwise returns \\"NO\\". >>> check_zero_in_number(405) \\"YES\\" >>> check_zero_in_number(123456789) \\"NO\\" >>> check_zero_in_number(70701) \\"YES\\" >>> check_zero_in_number(0) \\"YES\\" >>> check_zero_in_number(987654321987654321) \\"NO\\"","solution":"def check_zero_in_number(n): Checks whether any digit of the number n is 0. Returns \\"YES\\" if any digit is 0, otherwise returns \\"NO\\". for digit in str(n): if digit == '0': return \\"YES\\" return \\"NO\\""},{"question":"def max_groups(Q: int, scenarios: List[Tuple[int, int, int]]) -> List[int]: Determine the maximum number of groups that can be created. Each group consists of 2 Warriors, 1 Mage, and 1 Healer. Args: Q (int): Number of scenarios. scenarios (List[Tuple[int, int, int]]): List of tuples containing the number of Warriors, Mages, and Healers in each scenario. Returns: List[int]: List containing the maximum number of groups for each scenario. >>> max_groups(3, [(6, 3, 2), (4, 5, 6), (10, 3, 3)]) [2, 2, 3] >>> max_groups(4, [(0, 0, 0), (2, 1, 1), (9, 5, 10), (7, 2, 1)]) [0, 1, 4, 1] from typing import List, Tuple def test_scenario_1(): Q = 3 scenarios = [(6, 3, 2), (4, 5, 6), (10, 3, 3)] assert max_groups(Q, scenarios) == [2, 2, 3] def test_scenario_2(): Q = 4 scenarios = [(0, 0, 0), (2, 1, 1), (9, 5, 10), (7, 2, 1)] assert max_groups(Q, scenarios) == [0, 1, 4, 1] def test_scenario_with_excess_healers(): Q = 2 scenarios = [(8, 2, 10), (4, 4, 1)] assert max_groups(Q, scenarios) == [2, 1] def test_empty_scenario(): Q = 0 scenarios = [] assert max_groups(Q, scenarios) == [] def test_minimum_input_values(): Q = 1 scenarios = [(0, 0, 0)] assert max_groups(Q, scenarios) == [0] def test_maximum_input_values(): Q = 1 scenarios = [(1000, 1000, 1000)] assert max_groups(Q, scenarios) == [500]","solution":"def max_groups(Q, scenarios): result = [] for scenario in scenarios: w, m, h = scenario # Determine the maximum number of groups using the limiting factor groups = min(w // 2, m, h) result.append(groups) return result"},{"question":"from typing import List def min_steps_to_reach_end(N: int, M: int, grid: List[str]) -> int: Determine the minimum number of steps required for the robot to reach the bottom-right corner of the warehouse. Args: N (int): Number of rows in the warehouse grid. M (int): Number of columns in the warehouse grid. grid (List[str]): The warehouse grid layout, where each string represents a row. Returns: int: Minimum number of steps required to reach the bottom-right corner or -1 if it is not possible. >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\".#.\\", \\"...\\"]) == 4 >>> min_steps_to_reach_end(3, 3, [\\"...\\", \\"#\\", \\"...\\"]) == -1 >>> min_steps_to_reach_end(2, 5, [\\".....\\", \\"...\\"]) == 5 def test_min_steps_example_1(): N = 3 M = 3 grid = [ \\"...\\", \\".#.\\", \\"...\\" ] assert min_steps_to_reach_end(N, M, grid) == 4 def test_min_steps_example_2(): N = 3 M = 3 grid = [ \\"...\\", \\"#\\", \\"...\\" ] assert min_steps_to_reach_end(N, M, grid) == -1 def test_min_steps_example_3(): N = 2 M = 5 grid = [ \\".....\\", \\"...\\" ] assert min_steps_to_reach_end(N, M, grid) == 5 def test_min_steps_blocked_start(): N = 3 M = 3 grid = [ \\"#..\\", \\".#.\\", \\"...\\" ] assert min_steps_to_reach_end(N, M, grid) == -1 def test_min_steps_blocked_end(): N = 3 M = 3 grid = [ \\"...\\", \\".#.\\", \\"..#\\" ] assert min_steps_to_reach_end(N, M, grid) == -1 def test_min_steps_empty_grid(): N = 1 M = 1 grid = [ \\".\\" ] assert min_steps_to_reach_end(N, M, grid) == 0","solution":"from collections import deque def min_steps_to_reach_end(N, M, grid): if grid[0][0] == '#' or grid[N-1][M-1] == '#': return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] visited = [[False for _ in range(M)] for _ in range(N)] queue = deque([(0, 0, 0)]) # (row, col, steps) visited[0][0] = True while queue: row, col, steps = queue.popleft() if row == N-1 and col == M-1: return steps for dr, dc in directions: new_row, new_col = row + dr, col + dc if 0 <= new_row < N and 0 <= new_col < M and not visited[new_row][new_col] and grid[new_row][new_col] == '.': visited[new_row][new_col] = True queue.append((new_row, new_col, steps + 1)) return -1"},{"question":"def minimum_moves(n, m, warehouse, start, target): Maya is designing a pathfinding algorithm for a robot in a warehouse. The warehouse can be represented as a grid of size n  m where each cell is either an empty cell or an obstacle. The robot can move up, down, left, or right by exactly one cell per move but cannot move diagonally or through obstacles. Given the starting and target positions of the robot, Maya wants to calculate the minimum number of moves required for the robot to reach the target position or determine if its impossible. Args: n (int): Number of rows in the warehouse grid. m (int): Number of columns in the warehouse grid. warehouse (List[str]): The warehouse grid represented as a list of strings. start (Tuple[int, int]): The starting position of the robot. target (Tuple[int, int]): The target position of the robot. Returns: int: The minimum number of moves required for the robot to reach the target position, or -1 if it's impossible. Examples: >>> minimum_moves(5, 5, [\\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\"], (0, 0), (4, 4)) 8 >>> minimum_moves(5, 5, [\\".....\\", \\"#\\", \\"#\\", \\"#\\", \\".....\\"], (0, 0), (4, 4)) -1 pass from typing import List, Tuple from solution import minimum_moves def test_minimum_moves_example_1(): n, m = 5, 5 warehouse = [ \\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\" ] start = (0, 0) target = (4, 4) assert minimum_moves(n, m, warehouse, start, target) == 8 def test_minimum_moves_example_2(): n, m = 5, 5 warehouse = [ \\".....\\", \\"#\\", \\"#\\", \\"#\\", \\".....\\" ] start = (0, 0) target = (4, 4) assert minimum_moves(n, m, warehouse, start, target) == -1 def test_minimum_moves_no_obstacles(): n, m = 3, 3 warehouse = [ \\"...\\", \\"...\\", \\"...\\" ] start = (0, 0) target = (2, 2) assert minimum_moves(n, m, warehouse, start, target) == 4 def test_minimum_moves_start_is_target(): n, m = 3, 3 warehouse = [ \\"...\\", \\"...\\", \\"...\\" ] start = (1, 1) target = (1, 1) assert minimum_moves(n, m, warehouse, start, target) == 0 def test_minimum_moves_completely_blocked(): n, m = 3, 3 warehouse = [ \\".#.\\", \\"#\\", \\".#.\\" ] start = (0, 0) target = (2, 2) assert minimum_moves(n, m, warehouse, start, target) == -1","solution":"from collections import deque def minimum_moves(n, m, warehouse, start, target): # Initialize queue with the starting point queue = deque([((start[0], start[1]), 0)]) visited = set() visited.add((start[0], start[1])) directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] # Up, Down, Left, Right while queue: (current_x, current_y), distance = queue.popleft() # Check if we have reached the target if (current_x, current_y) == (target[0], target[1]): return distance # Explore all possible directions for dx, dy in directions: new_x, new_y = current_x + dx, current_y + dy if 0 <= new_x < n and 0 <= new_y < m and warehouse[new_x][new_y] == '.' and (new_x, new_y) not in visited: queue.append(((new_x, new_y), distance + 1)) visited.add((new_x, new_y)) return -1 # Example usage: n, m = 5, 5 warehouse = [ \\".....\\", \\"..#..\\", \\"..#..\\", \\"..#..\\", \\".....\\" ] start = (0, 0) target = (4, 4) print(minimum_moves(n, m, warehouse, start, target)) # Output: 8"},{"question":"def can_obtain_by_rotation(n: int, matrix1: List[List[int]], matrix2: List[List[int]]) -> str: Determines if matrix2 can be obtained by rotating matrix1 by 0, 90, 180, or 270. >>> can_obtain_by_rotation(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[7, 4, 1], [8, 5, 2], [9, 6, 3]]) \\"YES\\" >>> can_obtain_by_rotation(2, [[1, 2], [3, 4]], [[4, 3], [2, 1]]) \\"NO\\" from solution import can_obtain_by_rotation def test_can_obtain_by_rotation_90_degrees(): n = 3 matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [7, 4, 1], [8, 5, 2], [9, 6, 3] ] assert can_obtain_by_rotation(n, matrix1, matrix2) == \\"YES\\" def test_can_obtain_by_rotation_180_degrees(): n = 2 matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [4, 3], [2, 1] ] assert can_obtain_by_rotation(n, matrix1, matrix2) == \\"YES\\" def test_no_rotation_needed(): n = 1 matrix1 = [ [1] ] matrix2 = [ [1] ] assert can_obtain_by_rotation(n, matrix1, matrix2) == \\"YES\\" def test_no_possible_rotation(): n = 2 matrix1 = [ [1, 2], [3, 4] ] matrix2 = [ [1, 3], [2, 4] ] assert can_obtain_by_rotation(n, matrix1, matrix2) == \\"NO\\" def test_identical_matrices(): n = 3 matrix1 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] matrix2 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert can_obtain_by_rotation(n, matrix1, matrix2) == \\"YES\\"","solution":"def can_obtain_by_rotation(n, matrix1, matrix2): Determines if matrix2 can be obtained by rotating matrix1 by 0, 90, 180, or 270. # Function to rotate matrix by 90 degrees clockwise def rotate_90(matrix): return list(zip(*matrix[::-1])) # Convert tuples to lists after rotation for comparison def convert_tuple_list(matrix): return [list(row) for row in matrix] # Rotate matrix1 by 0, 90, 180, 270 and check for equality with matrix2 if matrix1 == matrix2: return \\"YES\\" rotated = rotate_90(matrix1) if convert_tuple_list(rotated) == matrix2: return \\"YES\\" rotated = rotate_90(rotated) if convert_tuple_list(rotated) == matrix2: return \\"YES\\" rotated = rotate_90(rotated) if convert_tuple_list(rotated) == matrix2: return \\"YES\\" return \\"NO\\""},{"question":"from typing import List, Tuple def longest_increasing_subsequence(sequence: List[int]) -> Tuple[int, List[int]]: Compute the length of the longest strictly increasing subsequence and return one of such subsequences from the given sequence of numbers. Args: sequence (List[int]): The sequence of integers. Returns: Tuple[int, List[int]]: A tuple containing the length of the longest increasing subsequence and the subsequence itself. Examples: >>> longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) (6, [10, 22, 33, 50, 60, 80]) >>> longest_increasing_subsequence([5]) (1, [5]) >>> longest_increasing_subsequence([1, 2, 3, 4, 5]) (5, [1, 2, 3, 4, 5]) >>> longest_increasing_subsequence([5, 4, 3, 2, 1]) (1, [5]) >>> longest_increasing_subsequence([3, 10, 2, 1, 20]) (3, [3, 10, 20]) >>> longest_increasing_subsequence([]) (0, []) pass def test_lis_example(): assert longest_increasing_subsequence([10, 22, 9, 33, 21, 50, 41, 60, 80]) == (6, [10, 22, 33, 50, 60, 80]) def test_lis_single_element(): assert longest_increasing_subsequence([5]) == (1, [5]) def test_lis_all_increasing(): assert longest_increasing_subsequence([1, 2, 3, 4, 5]) == (5, [1, 2, 3, 4, 5]) def test_lis_all_decreasing(): assert longest_increasing_subsequence([5, 4, 3, 2, 1]) == (1, [5]) def test_lis_mixed(): assert longest_increasing_subsequence([3, 10, 2, 1, 20]) == (3, [3, 10, 20]) def test_lis_multiple_lis(): result = longest_increasing_subsequence([3, 4, 1, 2, 5]) assert result[0] == 3 assert result[1] in [[3, 4, 5], [1, 2, 5]] def test_lis_empty(): assert longest_increasing_subsequence([]) == (0, [])","solution":"def longest_increasing_subsequence(sequence): Returns the length and one longest increasing subsequence from the given sequence of numbers. if not sequence: return 0, [] n = len(sequence) lis = [1] * n prev_index = [-1] * n for i in range(1, n): for j in range(0, i): if sequence[i] > sequence[j] and lis[i] < lis[j] + 1: lis[i] = lis[j] + 1 prev_index[i] = j max_length = max(lis) max_index = lis.index(max_length) lis_sequence = [] while max_index != -1: lis_sequence.append(sequence[max_index]) max_index = prev_index[max_index] lis_sequence.reverse() return max_length, lis_sequence # Example usage n = 9 sequence = [10, 22, 9, 33, 21, 50, 41, 60, 80] print(longest_increasing_subsequence(sequence))"},{"question":"def is_prime(n: int) -> bool: Determines if the given number is prime. >>> is_prime(2) == True True >>> is_prime(4) == False True >>> is_prime(7) == True True >>> is_prime(1) == False True >>> is_prime(11) == True True >>> is_prime(15) == False True def primes_in_test_cases(T: int, test_cases: List[int]) -> List[str]: For each number in the test cases, returns \\"YES\\" if the number is prime, otherwise \\"NO\\". >>> primes_in_test_cases(3, [2, 4, 7]) [\\"YES\\", \\"NO\\", \\"YES\\"] >>> primes_in_test_cases(2, [1, 5]) [\\"NO\\", \\"YES\\"] >>> primes_in_test_cases(4, [8, 9, 10, 11]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] >>> primes_in_test_cases(1, [97]) [\\"YES\\"]","solution":"def is_prime(n): Determines if the given number is prime. if n <= 1: return False if n == 2: return True if n % 2 == 0: return False for i in range(3, int(n**0.5) + 1, 2): if n % i == 0: return False return True def primes_in_test_cases(T, test_cases): For each number in the test cases, prints \\"YES\\" if the number is prime, otherwise \\"NO\\". results = [] for i in range(T): if is_prime(test_cases[i]): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List def max_beads(n: int, L: int, power_levels: List[int]) -> int: Determine the maximum number of beads that can be chosen such that the sum of their power levels does not exceed the limit L. >>> max_beads(5, 10, [1, 2, 3, 4, 5]) 4 >>> max_beads(4, 15, [5, 5, 5, 5]) 3 >>> max_beads(3, 5, [1, 1, 1]) 3","solution":"def max_beads(n, L, power_levels): from itertools import combinations max_count = 0 for i in range(1, n + 1): for combination in combinations(power_levels, i): if sum(combination) <= L: max_count = max(max_count, len(combination)) return max_count # Example usage: # n = 3 # L = 5 # power_levels = [1, 1, 1] # max_beads(n, L, power_levels) should return 3"},{"question":"from collections import deque def min_steps_to_target(N, M, grid, start, target): Determine the minimum number of steps required for a delivery truck to reach its target destination from a starting point in a grid. >>> min_steps_to_target(5, 5, [ ... [0, 1, 0, 0, 0], ... [0, 1, 0, 1, 0], ... [0, 0, 0, 1, 0], ... [1, 1, 0, 0, 0], ... [0, 0, 0, 0, 0] ... ], (0, 0), (4, 4)) 8 >>> min_steps_to_target(3, 3, [ ... [0, 1, 0], ... [1, 1, 0], ... [0, 0, 0] ... ], (0, 0), (2, 2)) -1 >>> min_steps_to_target(3, 3, [ ... [0, 1, 0], ... [1, 1, 1], ... [0, 0, 0] ... ], (0, 0), (2, 2)) -1 >>> min_steps_to_target(2, 2, [ ... [0, 1], ... [0, 0] ... ], (0, 0), (1, 1)) 2","solution":"from collections import deque def min_steps_to_target(N, M, grid, start, target): if grid[start[0]][start[1]] == 1 or grid[target[0]][target[1]] == 1: return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(start[0], start[1], 0)]) # (row, col, distance) visited = set() visited.add((start[0], start[1])) while queue: x, y, dist = queue.popleft() if (x, y) == (target[0], target[1]): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and (nx, ny) not in visited and grid[nx][ny] == 0: queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1"},{"question":"def cumulative_sum_sequence(n: int, a: List[int]) -> List[int]: Generates the cumulative sum sequence b from the input sequence a. Parameters: n (int): The number of elements in the sequence. a (list of int): The input sequence of integers. Returns: list of int: The cumulative sum sequence. Examples: >>> cumulative_sum_sequence(5, [1, -2, 3, -1, 2]) [1, -1, 2, 1, 3] >>> cumulative_sum_sequence(1, [5]) [5] >>> cumulative_sum_sequence(3, [1, 2, 3]) [1, 3, 6] >>> cumulative_sum_sequence(4, [-1, -2, -3, -4]) [-1, -3, -6, -10] >>> cumulative_sum_sequence(6, [1, -1, 1, -1, 1, -1]) [1, 0, 1, 0, 1, 0] >>> cumulative_sum_sequence(4, [0, 0, 0, 0]) [0, 0, 0, 0]","solution":"def cumulative_sum_sequence(n, a): Generates the cumulative sum sequence b from the input sequence a. Parameters: n (int): The number of elements in the sequence. a (list of int): The input sequence of integers. Returns: list of int: The cumulative sum sequence. b = [0] * n for i in range(n): if i == 0: b[i] = a[i] else: b[i] = b[i - 1] + a[i] return b"},{"question":"from typing import List def is_almost_palindrome(s: str) -> bool: Check if a string can be converted to a palindrome by removing exactly one character. pass def solve(test_cases: List[str]) -> List[str]: Process the list of test cases and determine if each string is an \\"almost palindrome\\". >>> solve([\\"abca\\", \\"racecar\\", \\"abccba\\"]) [\\"YES\\", \\"NO\\", \\"NO\\"] >>> solve([\\"a\\", \\"abc\\", \\"aab\\", \\"bba\\", \\"cbbcc\\"]) [\\"NO\\", \\"NO\\", \\"YES\\", \\"YES\\", \\"YES\\"] >>> solve([\\"\\", \\"zz\\", \\"zaz\\", \\"abaz\\"]) [\\"NO\\", \\"NO\\", \\"NO\\", \\"YES\\"] pass","solution":"def is_almost_palindrome(s): Check if a string can be converted to a palindrome by removing exactly one character. def is_palindrome_range(i, j): Check if string is palindrome between indexes i and j inclusive. while i < j: if s[i] != s[j]: return False i += 1 j -= 1 return True left, right = 0, len(s) - 1 while left < right: if s[left] != s[right]: # Two cases: remove left or remove right return is_palindrome_range(left + 1, right) or is_palindrome_range(left, right - 1) left += 1 right -= 1 return False def solve(test_cases): Process the list of test cases and determine if each string is an \\"almost palindrome\\". results = [] for s in test_cases: if is_almost_palindrome(s): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def maxSafePopulation(populations: List[int], safety: List[int]) -> int: Returns the maximum sum of populations of the safe houses. >>> maxSafePopulation([10, 20, 30, 40, 50], [1, 0, 1, 0, 1]) 90 >>> maxSafePopulation([5, 6, 7, 8, 9, 10], [0, 0, 0, 0, 0, 0]) 0 >>> maxSafePopulation([15, 15, 15, 15], [1, 1, 1, 1]) 60 >>> maxSafePopulation([5, 10, 15, 20, 25, 30], [0, 1, 0, 1, 0, 1]) 60 >>> maxSafePopulation([100], [1]) 100 >>> maxSafePopulation([], []) 0","solution":"def maxSafePopulation(populations, safety): Returns the maximum sum of populations of the safe houses. :param populations: List[int], list of integers representing the population of each house. :param safety: List[int], list of integers where 0 indicates an unsafe house and 1 indicates a safe house. :return: int, the maximum sum of populations of the safe houses. total_population_of_safe_houses = sum(population for population, is_safe in zip(populations, safety) if is_safe == 1) return total_population_of_safe_houses"},{"question":"class GardenKeeper: def __init__(self, flowers): self.flowers = flowers def add_flowers(self, a, b, k): for i in range(a, b+1): self.flowers[i] += k def max_flowers(self, a, b): Find the maximum number of flowers in a given segment. Args: a (int): start index of the segment. b (int): end index of the segment. Returns: int: maximum number of flowers in the segment. >>> keeper = GardenKeeper([2, 3, 4, 1]) >>> keeper.add_flowers(0, 2, 2) >>> keeper.max_flowers(0, 3) 6 >>> keeper.max_flowers(1, 3) 4 return max(self.flowers[a:b+1]) def garden_queries(n, flowers, queries): Handle garden queries to add flowers and get the maximum number of flowers in segments. Args: n (int): the length of the garden array. flowers (List[int]): the initial numbers of flowers in the garden. queries (List[List[int]]): the list of queries to be executed. Returns: List[int]: results for the maximum queries. >>> n = 4 >>> flowers = [2, 3, 4, 1] >>> queries = [ ... [2, 1, 3], ... [1, 0, 2, 2], ... [2, 0, 3] ... ] >>> garden_queries(n, flowers, queries) [4, 6] keeper = GardenKeeper(flowers) results = [] for query in queries: if query[0] == 1: _, a, b, k = query keeper.add_flowers(a, b, k) elif query[0] == 2: _, a, b = query results.append(keeper.max_flowers(a, b)) return results","solution":"class GardenKeeper: def __init__(self, flowers): self.flowers = flowers def add_flowers(self, a, b, k): for i in range(a, b+1): self.flowers[i] += k def max_flowers(self, a, b): return max(self.flowers[a:b+1]) def garden_queries(n, flowers, queries): keeper = GardenKeeper(flowers) results = [] for query in queries: if query[0] == 1: _, a, b, k = query keeper.add_flowers(a, b, k) elif query[0] == 2: _, a, b = query results.append(keeper.max_flowers(a, b)) return results"},{"question":"def can_reach_exit(m: int, n: int, maze: List[str], sx: int, sy: int, ex: int, ey: int, portals: List[Tuple[int, int, int, int]]) -> str: Determine if friends can reach the exit cell from the starting cell using allowed moves and teleportation portals. Parameters: m (int): number of rows in the maze n (int): number of columns in the maze maze (List[str]): m x n grid representing the maze layout sx (int): starting cell row (1-based index) sy (int): starting cell column (1-based index) ex (int): exit cell row (1-based index) ey (int): exit cell column (1-based index) portals (List[Tuple[int, int, int, int]]): list of teleportation portal pairs Returns: str: \\"YES\\" if friends can reach the exit cell, otherwise \\"NO\\" Examples: >>> m, n = 5, 5 >>> maze = [\\".....\\", \\".#.#.\\", \\".\\", \\".....\\", \\".....\\"] >>> sx, sy, ex, ey, portals = 1, 1, 5, 5, [(2, 2, 4, 4), (5, 5, 3, 3)] >>> can_reach_exit(m, n, maze, sx, sy, ex, ey, portals) \\"YES\\" >>> m, n = 3, 4 >>> maze = [\\"\\", \\"#.\\", \\"#.\\"] >>> sx, sy, ex, ey, portals = 1, 2, 3, 4, [] >>> can_reach_exit(m, n, maze, sx, sy, ex, ey, portals) \\"NO\\"","solution":"from collections import deque def can_reach_exit(m, n, maze, sx, sy, ex, ey, portals): # Adjust coordinates from 1-based to 0-based sx -= 1 sy -= 1 ex -= 1 ey -= 1 portals = [(a1-1, b1-1, a2-1, b2-1) for a1, b1, a2, b2 in portals] # Directions for 8 possible moves (horizontally, vertically, and diagonally) directions = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)] # Portal dictionary for quick lookup portal_dict = {} for a1, b1, a2, b2 in portals: if (a1, b1) not in portal_dict: portal_dict[(a1, b1)] = [] if (a2, b2) not in portal_dict: portal_dict[(a2, b2)] = [] portal_dict[(a1, b1)].append((a2, b2)) portal_dict[(a2, b2)].append((a1, b1)) # BFS Initialization queue = deque([(sx, sy)]) visited = set() visited.add((sx, sy)) # BFS Loop while queue: x, y = queue.popleft() # If we reached the exit if (x, y) == (ex, ey): return \\"YES\\" # Check all 8 possible moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and maze[nx][ny] == '.' and (nx, ny) not in visited: visited.add((nx, ny)) queue.append((nx, ny)) # Check teleportation portals if (x, y) in portal_dict: for tx, ty in portal_dict[(x, y)]: if (tx, ty) not in visited: visited.add((tx, ty)) queue.append((tx, ty)) return \\"NO\\""},{"question":"import math import sys def find_X(interact): Figure out a target integer 1  X  10^6 using gcd queries. This function should call \`interact(query)\` up to 15 times and determine the value of X. Queries should be issued in the format \`? Q\` (1  Q  10^12) and the response should be interpreted as the gcd(X, Q). Once confident of the value of X, the function should return the determined value. Args: interact (function): Function to interact with the game environment by making queries. Returns: int: The determined value of X. def interact(query): Function to interact with the game environment by making a gcd query. This should be implemented to handle the interaction logic specific to the platform. Args: query (int): The query value for which the gcd(X, Q) should be determined. Returns: int: Response representing gcd(X, query). def play_game(): Main function to play the game for T games where T is the number of games. It should call \`find_X(interact)\` for each game and print the determined values. T = int(input().strip()) for _ in range(T): X = find_X(interact) print(f\\"! {X}\\") sys.stdout.flush() def interact_mock(sequence): answers = {2: 2, 3: 3, 5: 5, 7: 7, 11: 1, 13: 1, 17: 1, 19: 1, 23: 1, 29: 1, 31: 1, 37: 1, 41: 1, 43: 1, 47: 1} def inner(query): return answers[query] return inner def test_find_X_correct(): interact = interact_mock([2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]) X = find_X(interact) assert X == 1 def mock_interact_10(query): responses = { 2: 2, 3: 1, 5: 5, } return responses.get(query, 1) def test_find_X_10(): X = find_X(mock_interact_10) assert X == 10 # Function to test the solution if __name__ == \\"__main__\\": test_find_X_correct() test_find_X_10() print(\\"All tests passed!\\")","solution":"import math import sys def find_X(interact): # We will use a range of numbers to try as queries queries = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] # To store gcd results with known queries accumulated_gcd = 0 for query in queries: gcd_result = interact(query) accumulated_gcd = math.gcd(accumulated_gcd, gcd_result) if accumulated_gcd == 1: break # The accumulated_gcd should be the value of X return accumulated_gcd def interact(query): print(f\\"? {query}\\") sys.stdout.flush() response = int(input().strip()) return response def play_game(): T = int(input().strip()) for _ in range(T): X = find_X(interact) print(f\\"! {X}\\") sys.stdout.flush() if __name__ == '__main__': play_game()"},{"question":"def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if is_prime[p]] return prime_numbers def find_prime_pair(n, m): Find a pair of prime numbers p1 and p2 such that |p1 - p2| = n and p1 + p2  m. >>> p1, p2 = find_prime_pair(2, 10) >>> abs(p1 - p2) == 2 and p1 + p2 <= 10 True >>> p1, p2 = find_prime_pair(4, 20) >>> abs(p1 - p2) == 4 and p1 + p2 <= 20 True # Complete the function implementation # Test cases def test_find_prime_pair_1(): p1, p2 = find_prime_pair(2, 10) assert abs(p1 - p2) == 2 assert p1 + p2 <= 10 def test_find_prime_pair_2(): p1, p2 = find_prime_pair(4, 20) assert abs(p1 - p2) == 4 assert p1 + p2 <= 20 def test_find_prime_pair_3(): p1, p2 = find_prime_pair(6, 30) assert abs(p1 - p2) == 6 assert p1 + p2 <= 30 def test_find_prime_pair_4(): p1, p2 = find_prime_pair(10, 50) assert abs(p1 - p2) == 10 assert p1 + p2 <= 50 def test_find_prime_pair_5(): p1, p2 = find_prime_pair(8, 40) assert abs(p1 - p2) == 8 assert p1 + p2 <= 40","solution":"def sieve_of_eratosthenes(limit): is_prime = [True] * (limit + 1) p = 2 while (p * p <= limit): if (is_prime[p] == True): for i in range(p * p, limit + 1, p): is_prime[i] = False p += 1 prime_numbers = [p for p in range(2, limit + 1) if is_prime[p]] return prime_numbers def find_prime_pair(n, m): primes = sieve_of_eratosthenes(m) primes_set = set(primes) for p1 in primes: p2 = p1 + n if p2 in primes_set and p1 + p2 <= m: return p1, p2 # Example usage print(find_prime_pair(2, 10)) # Output: (3, 5) or (5, 7) print(find_prime_pair(4, 20)) # Output: (7, 11) or (13, 17)"},{"question":"def find_three_numbers(arr, target): Determines if there are three distinct elements in the sorted array that add up to the target sum. Parameters: arr (list): sorted array of positive integers target (int): target sum Returns: tuple: a tuple of three distinct elements that add up to the target, or \`None\` if no such combination exists. pass # Example Test Cases if __name__ == \\"__main__\\": print(find_three_numbers([1, 2, 3, 4, 5, 6], 10)) # Output: (1, 3, 6) print(find_three_numbers([1, 2, 4, 5, 6, 8], 15)) # Output: (1, 6, 8) print(find_three_numbers([1, 2, 3, 4, 5, 6], 20)) # Output: None print(find_three_numbers([1, 3, 5, 7, 9], 14)) # Output: None","solution":"def find_three_numbers(arr, target): Determines if there are three distinct elements in the sorted array that add up to the target sum. Parameters: arr (list): sorted array of positive integers target (int): target sum Returns: tuple: a tuple of three distinct elements that add up to the target, or \`None\` if no such combination exists. n = len(arr) for i in range(n-2): left, right = i + 1, n - 1 while left < right: current_sum = arr[i] + arr[left] + arr[right] if current_sum == target: return (arr[i], arr[left], arr[right]) elif current_sum < target: left += 1 else: right -= 1 return None"},{"question":"def nth_number_in_sequence(V: int, N: int) -> int: Returns the N-th number in the sequence starting with V. Each next number is the product of the previous number and its (1-based) position index. >>> nth_number_in_sequence(2, 4) 48 >>> nth_number_in_sequence(3, 5) 360","solution":"def nth_number_in_sequence(V, N): Returns the N-th number in the sequence starting with V. Each next number is the product of the previous number and its (1-based) position index. result = V # Start with the initial value V for i in range(2, N + 1): result *= i return result"},{"question":"from typing import List, Tuple def min_path_cost(grid: List[List[int]]) -> int: Calculate the minimum cost to reach the bottom-right corner of the board from the top-left corner. >>> min_path_cost([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 7 >>> min_path_cost([[0]]) 0 >>> min_path_cost([[1, 2], [1, 1]]) 3 pass def solve_game(T: int, test_cases: List[Tuple[int, List[List[int]]]]) -> List[int]: Process multiple test cases and return the minimum cost for each. >>> solve_game(1, [(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]])]) [7] >>> solve_game(2, [(3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]), (2, [[1, 2], [1, 1]])]) [7, 3] pass","solution":"def min_path_cost(grid): n = len(grid) # Create a dp array to store the minimum path cost dp = [[0] * n for _ in range(n)] dp[0][0] = grid[0][0] # Initialize the first row and first column for i in range(1, n): dp[i][0] = dp[i-1][0] + grid[i][0] dp[0][i] = dp[0][i-1] + grid[0][i] # Fill the dp array with the minimum path cost for i in range(1, n): for j in range(1, n): dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j] return dp[n-1][n-1] def solve_game(T, test_cases): results = [] for case in test_cases: n, grid = case min_cost = min_path_cost(grid) results.append(min_cost) return results # Example usage if __name__ == \\"__main__\\": T = 1 test_cases = [ (3, [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ]) ] print(solve_game(T, test_cases)) # Expected output: [7]"},{"question":"def can_reorder_cards(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Determines if each deck of cards can be reordered such that the absolute difference between any two adjacent cards is exactly 1. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each containing the number of cards and the list of cards. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. >>> can_reorder_cards(2, [(3, [2, 3, 4]), (4, [1, 3, 5, 6])]) [\\"YES\\", \\"NO\\"] >>> can_reorder_cards(1, [(2, [10, 11])]) [\\"YES\\"] >>> can_reorder_cards(1, [(2, [10, 12])]) [\\"NO\\"] >>> can_reorder_cards(1, [(5, [1, 2, 3, 4, 5])]) [\\"YES\\"] >>> can_reorder_cards(1, [(5, [5, 3, 2, 4, 1])]) [\\"YES\\"] >>> can_reorder_cards(1, [(4, [8, 7, 6, 9])]) [\\"YES\\"] >>> can_reorder_cards(1, [(4, [8, 7, 5, 9])]) [\\"NO\\"] >>> can_reorder_cards(1, [(2, [1, 2])]) [\\"YES\\"] >>> can_reorder_cards(1, [(2, [1, 3])]) [\\"NO\\"]","solution":"def can_reorder_cards(t, test_cases): Determines if each deck of cards can be reordered such that the absolute difference between any two adjacent cards is exactly 1. Parameters: t (int): Number of test cases. test_cases (list): List of tuples, each containing the number of cards and the list of cards. Returns: list: List of strings \\"YES\\" or \\"NO\\" for each test case. results = [] for case in test_cases: n, cards = case cards.sort() is_possible = all(cards[i + 1] - cards[i] == 1 for i in range(n - 1)) results.append(\\"YES\\" if is_possible else \\"NO\\") return results"},{"question":"def access_control(input_data): Determines which badges have access to specific areas based on their access level. Input ----- The input is provided in the following format: n m id1 access_level1 id2 access_level2 ... idn access_leveln area_id required_access_level ----- The first line contains two integers n and m, separated by a space, where n is the number of badges and m is the number of areas. The following n lines each contain a badge identifier (id) and the access level associated with that badge, separated by a space. The last m lines each contain an area identifier and the required access level for that area. Output ----- For each area, output the badge identifiers that can access the area, in a single line separated by a space. If no badge can access the area, output \\"No access\\". Example ------- Input 3 2 123 2 456 3 789 1 A 2 B 3 Output 123 456 456 ----- Test Cases ---------- >>> input_data = \\"3 2n123 2n456 3n789 1nA 2nB 3\\" >>> print(access_control(input_data)) \\"123 456n456\\" >>> input_data = \\"2 1n123 1n456 1nA 2\\" >>> print(access_control(input_data)) \\"No access\\" >>> input_data = \\"2 1n123 3n456 3nA 2\\" >>> print(access_control(input_data)) \\"123 456\\" >>> input_data = \\"1 1n123 2nA 2\\" >>> print(access_control(input_data)) \\"123\\" >>> input_data = \\"4 3n123 1n456 2n789 3n101 4nA 1nB 2nC 4\\" >>> print(access_control(input_data)) \\"123 456 789 101n456 789 101n101\\"","solution":"def access_control(input_data): Determines which badges have access to specific areas based on their access level. lines = input_data.strip().split('n') n, m = map(int, lines[0].split()) # Parse badge information badges = {} for i in range(1, n+1): badge_id, access_level = lines[i].split() badges[badge_id] = int(access_level) result = [] # Parse area information and determine access for i in range(n+1, n+m+1): area_id, required_access_level = lines[i].split() required_access_level = int(required_access_level) # Find badge IDs that meet the access level requirement access_list = [badge_id for badge_id, access_level in badges.items() if access_level >= required_access_level] if access_list: result.append(\\" \\".join(access_list)) else: result.append(\\"No access\\") return \\"n\\".join(result)"},{"question":"def decode_message(test_cases): Decodes each test case by summing the digits of the string S. Args: test_cases (list of str): A list of strings where each string contains only digits (0-9). Returns: list of int: A list of integers where each integer is the sum of the digits of the corresponding string in test_cases. Examples: >>> decode_message(['123']) [6] >>> decode_message(['123', '456', '7890']) [6, 15, 24] >>> decode_message(['0', '00', '000']) [0, 0, 0] >>> decode_message(['1', '12', '123', '1234']) [1, 3, 6, 10] >>> decode_message(['123456789']) [45] >>> decode_message(['1111', '2222', '3333']) [4, 8, 12]","solution":"def decode_message(test_cases): Decodes each test case by summing the digits of the string S. Args: test_cases (list of str): A list of strings where each string contains only digits (0-9). Returns: list of int: A list of integers where each integer is the sum of the digits of the corresponding string in test_cases. results = [] for case in test_cases: digit_sum = sum(int(digit) for digit in case) results.append(digit_sum) return results"},{"question":"# Function Definition def count_interesting_numbers(n: int) -> int: Count numbers that can be split into two non-empty parts that together sum up to the original number. >>> count_interesting_numbers(10) 10 >>> count_interesting_numbers(20) 20 >>> count_interesting_numbers(100) 100 >>> count_interesting_numbers(1000000) 1000000 # Unit Test def test_single_number(): assert count_interesting_numbers(1) == 1 def test_small_range(): assert count_interesting_numbers(10) == 10 assert count_interesting_numbers(20) == 20 def test_medium_range(): assert count_interesting_numbers(100) == 100 def test_large_range(): assert count_interesting_numbers(1000) == 1000 assert count_interesting_numbers(1000000) == 1000000","solution":"def count_interesting_numbers(n): Count numbers that can be split into two non-empty parts that together sum up to the original number. For any n >= 1, all numbers from 1 to n are interesting because each number itself can be split into two parts. return n"},{"question":"def is_symmetric(n: int, m: int, board: List[str]) -> str: Determine if the current pattern on the LED display board is symmetrical. >>> is_symmetric(4, 4, [\\"X..X\\", \\".XX.\\", \\".XX.\\", \\"X..X\\"]) \\"YES\\" >>> is_symmetric(3, 5, [\\"XX..X\\", \\"X..X.\\", \\"XXX..\\"]) \\"NO\\"","solution":"def is_symmetric(n, m, board): def is_vertical_symmetric(): for i in range(n): for j in range(m // 2): if board[i][j] != board[i][m - 1 - j]: return False return True def is_horizontal_symmetric(): for i in range(n // 2): for j in range(m): if board[i][j] != board[n - 1 - i][j]: return False return True def is_rotational_symmetric(): for i in range(n): for j in range(m): if board[i][j] != board[n - 1 - i][m - 1 - j]: return False return True if is_vertical_symmetric() or is_horizontal_symmetric() or is_rotational_symmetric(): return \\"YES\\" else: return \\"NO\\" # Example usage: # n, m = 4, 4 # board = [ # \\"X..X\\", # \\".XX.\\", # \\".XX.\\", # \\"X..X\\" # ] # print(is_symmetric(n, m, board)) # should output \\"YES\\""},{"question":"def max_magic_powers(N, powers, Q, queries): Returns the maximum magic powers for given ranges in queries. Parameters: N (int): The number of trees. powers (list): A list containing the magic power of each tree. Q (int): The number of queries. queries (list): A list containing the ranges for each query as tuples (L, R). Returns: list: A list of maximum magic powers for each range provided in queries. Example: >>> max_magic_powers(5, [10, 20, 30, 40, 50], 3, [(1, 3), (2, 5), (3, 4)]) [30, 50, 40]","solution":"def max_magic_powers(N, powers, Q, queries): Returns the maximum magic powers for given ranges in queries. Parameters: N (int): The number of trees. powers (list): A list containing the magic power of each tree. Q (int): The number of queries. queries (list): A list containing the ranges for each query as tuples (L, R). Returns: list: A list of maximum magic powers for each range provided in queries. result = [] for L, R in queries: max_power = max(powers[L-1:R]) result.append(max_power) return result"},{"question":"def apply_updates_and_calculate_sums(n, m, k, sequence, updates, ranges): This function applies the given updates to a sequence and then calculates the sum of elements for the specified ranges in the updated sequence. Parameters: n (int): Length of the sequence. m (int): Number of ranges. k (int): Number of updates. sequence (List[int]): Initial sequence of integers. updates (List[Tuple[int, int]]): List of updates where each update is a tuple (p_i, v_i). ranges (List[Tuple[int, int]]): List of ranges where each range is a tuple (l_j, r_j). Returns: List[int]: List of sums for each range in the updated sequence. Examples: >>> apply_updates_and_calculate_sums(5, 3, 2, [1, 2, 3, 4, 5], [(2, 10), (4, 20)], [(1, 3), (2, 5), (3, 5)]) [14, 38, 28] >>> apply_updates_and_calculate_sums(1, 1, 1, [100], [(1, 200)], [(1, 1)]) [200] >>> apply_updates_and_calculate_sums(3, 2, 0, [1, 2, 3], [], [(1, 2), (2, 3)]) [3, 5] >>> apply_updates_and_calculate_sums(3, 1, 3, [1, 1, 1], [(1, 10), (2, 10), (3, 10)], [(1, 3)]) [30] >>> apply_updates_and_calculate_sums(2, 1, 2, [1000000000, 1000000000], [(1, 1), (2, 1)], [(1, 2)]) [2]","solution":"def apply_updates_and_calculate_sums(n, m, k, sequence, updates, ranges): # Apply the updates to the original sequence for p_i, v_i in updates: sequence[p_i - 1] = v_i # Calculate the sums for each range results = [] for l_j, r_j in ranges: range_sum = sum(sequence[l_j - 1:r_j]) results.append(range_sum) return results"},{"question":"import math from typing import List, Tuple def calculate_speaker_positions(n: int, r: int) -> List[Tuple[float, float]]: Returns a list of tuples representing the coordinates of each speaker. Parameters: n (int): Number of speakers r (int): Radius of the circle Returns: List[Tuple[float, float]]: List of coordinates of each speaker accurate to three decimal places. Examples: >>> calculate_speaker_positions(6, 10) [(10.000, 0.000), (5.000, 8.660), (-5.000, 8.660), (-10.000, 0.000), (-5.000, -8.660), (5.000, -8.660)] >>> calculate_speaker_positions(4, 5) [(5.000, 0.000), (0.000, 5.000), (-5.000, 0.000), (0.000, -5.000)] # Unit tests def test_calculate_speaker_positions(): assert calculate_speaker_positions(6, 10) == [ (10.000, 0.000), (5.000, 8.660), (-5.000, 8.660), (-10.000, 0.000), (-5.000, -8.660), (5.000, -8.660) ] assert calculate_speaker_positions(4, 5) == [ (5.000, 0.000), (0.000, 5.000), (-5.000, 0.000), (0.000, -5.000) ] assert calculate_speaker_positions(3, 1) == [ (1.000, 0.000), (-0.500, 0.866), (-0.500, -0.866) ] assert calculate_speaker_positions(5, 3) == [ (3.000, 0.000), (0.927, 2.853), (-2.427, 1.763), (-2.427, -1.763), (0.927, -2.853) ] assert calculate_speaker_positions(10, 1) == [ (1.000, 0.000), (0.809, 0.588), (0.309, 0.951), (-0.309, 0.951), (-0.809, 0.588), (-1.000, 0.000), (-0.809, -0.588), (-0.309, -0.951), (0.309, -0.951), (0.809, -0.588) ]","solution":"import math def calculate_speaker_positions(n, r): Returns a list of tuples representing the coordinates of each speaker. Arguments: n -- Number of speakers r -- Radius of the circle Each coordinate is accurate to three decimal places. positions = [] for i in range(n): angle = i * 2 * math.pi / n # Calculate the angle for each speaker x = r * math.cos(angle) y = r * math.sin(angle) positions.append((round(x, 3), round(y, 3))) return positions"},{"question":"def evaluate_expression(expression: str) -> int: Evaluates an arithmetic expression string containing only positive integers, addition (+), multiplication (*), and parentheses (), and returns the result as an integer. >>> evaluate_expression(\\"2+3*4\\") 14 >>> evaluate_expression(\\"10+(2*5)+3\\") 23 >>> evaluate_expression(\\"((1+3)*3)+10\\") 22 >>> evaluate_expression(\\"5*(3+(2+1))\\") 30 >>> evaluate_expression(\\"2+2*2\\") 6 >>> evaluate_expression(\\"2*(2+2)\\") 8 from solution import evaluate_expression def test_simple_addition(): assert evaluate_expression(\\"2+3\\") == 5 def test_addition_and_multiplication(): assert evaluate_expression(\\"2+3*4\\") == 14 def test_parentheses_evaluation(): assert evaluate_expression(\\"10+(2*5)+3\\") == 23 def test_nested_parentheses(): assert evaluate_expression(\\"((1+3)*3)+10\\") == 22 def test_complex_expression(): assert evaluate_expression(\\"5*(3+(2+1))\\") == 30 def test_single_number(): assert evaluate_expression(\\"7\\") == 7 def test_no_parentheses_multiplication_first(): assert evaluate_expression(\\"2+2*2\\") == 6 def test_parentheses_prioritization(): assert evaluate_expression(\\"2*(2+2)\\") == 8 def test_multiple_operations(): assert evaluate_expression(\\"2+2*2*2+2\\") == 12 def test_large_numbers(): assert evaluate_expression(\\"100+200*300\\") == 60100","solution":"def evaluate_expression(expression): Evaluates an arithmetic expression string and returns the result as an integer. Supports +, *, and parentheses. def evaluate(tokens): stack = [] num = 0 sign = '+' while tokens: token = tokens.pop(0) if token.isdigit(): num = num * 10 + int(token) if token == '(': num = evaluate(tokens) if not token.isdigit() or not tokens: if sign == '+': stack.append(num) elif sign == '*': stack[-1] *= num sign = token num = 0 if token == ')': break return sum(stack) tokens = list(expression) return evaluate(tokens)"},{"question":"def minimal_total_travel_distance(n: int, m: int, bins: List[Tuple[int, int]]) -> int: Determines the minimal total travel distance for optimal placement of recycling centers. Parameters: n (int): The size of the grid. m (int): The number of bins. bins (list of tuple): A list of tuples representing the coordinates of the bins. Returns: int: The minimal total travel distance. >>> minimal_total_travel_distance(5, 3, [(1, 2), (2, 4), (3, 3)]) == 4 >>> minimal_total_travel_distance(5, 1, [(2, 3)]) == 0 >>> minimal_total_travel_distance(5, 3, [(2, 2), (2, 2), (2, 2)]) == 0 >>> minimal_total_travel_distance(5, 3, [(1, 1), (1, 2), (1, 3)]) == 2 >>> minimal_total_travel_distance(5, 4, [(1, 1), (1, 5), (5, 1), (5, 5)]) == 16","solution":"def minimal_total_travel_distance(n, m, bins): Determines the minimal total travel distance for optimal placement of recycling centers. Parameters: n (int): The size of the grid. m (int): The number of bins. bins (list of tuple): A list of tuples representing the coordinates of the bins. Returns: int: The minimal total travel distance. if m == 1: return 0 x_coords = sorted([x for x, y in bins]) y_coords = sorted([y for x, y in bins]) median_x = x_coords[m // 2] median_y = y_coords[m // 2] total_distance = sum(abs(x - median_x) + abs(y - median_y) for x, y in bins) return total_distance"},{"question":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Computes the sum of all numbers formed by root-to-leaf paths in the given binary tree. >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> root.left.left = TreeNode(4) >>> sumNumbers(root) 137 >>> root = TreeNode(4) >>> root.left = TreeNode(9) >>> root.right = TreeNode(0) >>> root.left.left = TreeNode(5) >>> root.left.right = TreeNode(1) >>> sumNumbers(root) 1026 >>> root = TreeNode(5) >>> sumNumbers(root) 5 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.right = TreeNode(3) >>> sumNumbers(root) 25 >>> root = TreeNode(1) >>> root.left = TreeNode(2) >>> root.left.left = TreeNode(3) >>> sumNumbers(root) 123","solution":"class TreeNode: def __init__(self, val=0, left=None, right=None): self.val = val self.left = left self.right = right def sumNumbers(root): Computes the sum of all numbers formed by root-to-leaf paths in the given binary tree. def dfs(node, current_number): if not node: return 0 current_number = current_number * 10 + node.val # If the node is a leaf, return the current_number if not node.left and not node.right: return current_number # If not leaf, continue DFS on children left_sum = dfs(node.left, current_number) right_sum = dfs(node.right, current_number) return left_sum + right_sum return dfs(root, 0)"},{"question":"def count_distinct_palindromic_substrings(S: str) -> int: Find the number of distinct non-empty substrings in the given string S that are also palindromes. >>> count_distinct_palindromic_substrings(\\"ababa\\") 5 >>> count_distinct_palindromic_substrings(\\"abcd\\") 4 >>> count_distinct_palindromic_substrings(\\"aaaa\\") 4 pass def distinct_palindromic_substrings_for_multiple_cases(cases): Returns a list of counts of distinct non-empty palindromic substrings for each string in the cases list. >>> cases = [\\"ababa\\", \\"abcd\\", \\"aaaa\\"] >>> distinct_palindromic_substrings_for_multiple_cases(cases) [5, 4, 4] pass from solution import count_distinct_palindromic_substrings, distinct_palindromic_substrings_for_multiple_cases def test_count_distinct_palindromic_substrings_case1(): assert count_distinct_palindromic_substrings(\\"ababa\\") == 5 def test_count_distinct_palindromic_substrings_case2(): assert count_distinct_palindromic_substrings(\\"abcd\\") == 4 def test_count_distinct_palindromic_substrings_case3(): assert count_distinct_palindromic_substrings(\\"aaaa\\") == 4 def test_distinct_palindromic_substrings_for_multiple_cases(): cases = [\\"ababa\\", \\"abcd\\", \\"aaaa\\"] assert distinct_palindromic_substrings_for_multiple_cases(cases) == [5, 4, 4] def test_edge_case_empty_string(): assert count_distinct_palindromic_substrings(\\"\\") == 0 def test_edge_case_single_character(): assert count_distinct_palindromic_substrings(\\"a\\") == 1 def test_edge_case_all_same_characters(): assert count_distinct_palindromic_substrings(\\"bbbbbb\\") == 6","solution":"def count_distinct_palindromic_substrings(S: str) -> int: Returns the number of distinct non-empty palindromic substrings in the given string S. def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() n = len(S) for i in range(n): # Odd-length palindromes l, r = i, i while l >= 0 and r < n and S[l] == S[r]: palindromic_substrings.add(S[l:r+1]) l -= 1 r += 1 # Even-length palindromes l, r = i, i + 1 while l >= 0 and r < n and S[l] == S[r]: palindromic_substrings.add(S[l:r+1]) l -= 1 r += 1 return len(palindromic_substrings) def distinct_palindromic_substrings_for_multiple_cases(cases): return [count_distinct_palindromic_substrings(case) for case in cases]"},{"question":"def shortest_distance(M: int, N: int, grid: List[List[str]]) -> int: Find the shortest distance between any two special plants in a given grid. You can only move horizontally or vertically between adjacent cells. The function should take the number of rows (M), the number of columns (N), and a grid of size MxN as input, and return the shortest distance between any two plants. >>> shortest_distance(5, 5, [ ['O', 'O', 'O', 'O', 'O'], ['O', 'P', 'O', 'O', 'O'], ['O', 'O', 'P', 'O', 'O'], ['O', 'O', 'O', 'P', 'O'], ['P', 'O', 'O', 'O', 'O'] ]) 2 >>> shortest_distance(5, 5, [ ['O', 'O', 'O', 'O', 'O'], ['O', 'P', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O'] ]) -1 >>> shortest_distance(5, 5, [ ['P', 'O', 'O', 'O', 'P'], ['O', 'O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O'], ['O', 'O', 'O', 'O', 'O'], ['P', 'O', 'O', 'O', 'P'] ]) 4","solution":"from collections import deque def shortest_distance(M, N, grid): def bfs(start): queue = deque([start]) distances = [[float('inf')] * N for _ in range(M)] distances[start[0]][start[1]] = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] while queue: x, y = queue.popleft() current_distance = distances[x][y] for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < M and 0 <= ny < N and distances[nx][ny] == float('inf'): distances[nx][ny] = current_distance + 1 if grid[nx][ny] == 'P': return distances[nx][ny] queue.append((nx, ny)) return float('inf') plants = [(i, j) for i in range(M) for j in range(N) if grid[i][j] == 'P'] if len(plants) < 2: return -1 shortest = float('inf') for plant in plants: distance = bfs(plant) if distance < shortest: shortest = distance return shortest if shortest != float('inf') else -1"},{"question":"def max_apples(orchard): Find the maximum number of apples that can be collected from any sub-rectangle of the orchard. >>> max_apples([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> max_apples([[1, 0, 2, 3], [4, 5, 1, 2]]) 18","solution":"def max_apples(orchard): n = len(orchard) m = len(orchard[0]) # Calculate prefix sums prefix_sum = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): prefix_sum[i][j] = orchard[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] max_apples = 0 # Iterate over all possible sub-rectangles for i1 in range(1, n + 1): for j1 in range(1, m + 1): for i2 in range(i1, n + 1): for j2 in range(j1, m + 1): # Calculate the sum of the sub-rectangle (i1, j1) to (i2, j2) sub_rect_sum = (prefix_sum[i2][j2] - prefix_sum[i1-1][j2] - prefix_sum[i2][j1-1] + prefix_sum[i1-1][j1-1]) max_apples = max(max_apples, sub_rect_sum) return max_apples"},{"question":"def largest_prime_less_than(n: int) -> int: Find the largest prime number that is smaller than a given integer n. >>> largest_prime_less_than(10) 7 >>> largest_prime_less_than(30) 29 >>> largest_prime_less_than(20) 19","solution":"def largest_prime_less_than(n): Find the largest prime number less than a given integer n. if n <= 2: raise ValueError(\\"Input must be greater than 2\\") # Sieve of Eratosthenes algorithm to find all primes less than n sieve = [True] * n sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(n ** 0.5) + 1): if sieve[start]: for multiple in range(start * start, n, start): sieve[multiple] = False # Find the largest prime less than n for i in range(n - 1, 1, -1): if sieve[i]: return i return None"},{"question":"from typing import List def is_balanced(B: int, T: int, data: List[List[int]]) -> List[str]: Determine if each monthly report from all branches is Balanced or Not Balanced. Parameters: B (int): The number of branches. T (int): The threshold value. data (List[List[int]]): List containing the number of monthly reports for each branch followed by the sales figures. Returns: List[str]: A list containing \\"Balanced\\" or \\"Not Balanced\\" for each branch. Example: >>> B = 2 >>> T = 5 >>> data = [ >>> 3, >>> [10, 15, 12, 14], >>> [20, 19, 17, 15], >>> [25, 20, 20, 18], >>> 2, >>> [10, 10, 10, 10], >>> [12, 10, 18, 10] >>> ] >>> is_balanced(B, T, data) ['Balanced', 'Not Balanced'] from solution import is_balanced def test_balanced_single_branch_all_reports_balanced(): B = 1 T = 5 data = [ 3, [10, 15, 12, 14], [20, 19, 17, 15], [25, 23, 20, 22] ] assert is_balanced(B, T, data) == [\\"Balanced\\"] def test_not_balanced_single_branch_one_report_not_balanced(): B = 1 T = 5 data = [ 3, [10, 15, 12, 14], [20, 19, 17, 15], [30, 23, 20, 22] ] assert is_balanced(B, T, data) == [\\"Not Balanced\\"] def test_balanced_multiple_branches_mixed_reports(): B = 2 T = 10 data = [ 2, [10, 15, 12, 14], [20, 30, 25, 24], 3, [5, 8, 6, 9], [7, 8, 10, 6], [12, 16, 8, 10] ] assert is_balanced(B, T, data) == [\\"Balanced\\", \\"Balanced\\"] def test_not_balanced_multiple_branches_varied_reports(): B = 2 T = 5 data = [ 2, [10, 15, 12, 14], [20, 30, 25, 24], 2, [5, 8, 6, 9], [12, 18, 10, 10] ] assert is_balanced(B, T, data) == [\\"Not Balanced\\", \\"Not Balanced\\"] def test_edge_case_zero_sales_figures(): B = 1 T = 0 data = [ 2, [0, 0, 0, 0], [0, 0, 0, 0] ] assert is_balanced(B, T, data) == [\\"Balanced\\"] def test_edge_case_large_sales_figures_and_threshold(): B = 1 T = 10000 data = [ 2, [0, 10000, 5000, 7000], [1000, 9000, 3000, 8000] ] assert is_balanced(B, T, data) == [\\"Balanced\\"]","solution":"def is_balanced(B, T, data): results = [] start = 0 for _ in range(B): M = data[start] monthly_reports = data[start + 1: start + 1 + M] balanced = True for report in monthly_reports: max_sale = max(report) min_sale = min(report) if max_sale - min_sale > T: balanced = False break if balanced: results.append(\\"Balanced\\") else: results.append(\\"Not Balanced\\") start = start + 1 + M return results"},{"question":"def min_abs_difference(n: int, sequence: List[int]) -> int: Split a sequence into two non-empty contiguous subsequences such that the absolute difference of their sums is minimized. >>> min_abs_difference(5, [1, 3, 2, 4, 6]) 4 >>> min_abs_difference(4, [5, 8, 2, 9]) 2 >>> min_abs_difference(3, [1, 1, 1]) 1 >>> min_abs_difference(6, [1, 2, 3, 4, 5, 6]) 1 from typing import List def test_case_1(): assert min_abs_difference(5, [1, 3, 2, 4, 6]) == 4 def test_case_2(): assert min_abs_difference(4, [5, 8, 2, 9]) == 2 def test_case_3(): assert min_abs_difference(3, [1, 1, 1]) == 1 def test_case_4(): assert min_abs_difference(6, [1, 2, 3, 4, 5, 6]) == 1 def test_case_5(): assert min_abs_difference(2, [1, 999]) == 998 def test_case_6(): assert min_abs_difference(5, [1, 1, 1, 1, 1]) == 1 def test_case_7(): assert min_abs_difference(10, [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]) == 10","solution":"def min_abs_difference(n, sequence): total_sum = sum(sequence) prefix_sum = 0 min_diff = float('inf') for i in range(n - 1): prefix_sum += sequence[i] remaining_sum = total_sum - prefix_sum current_diff = abs(prefix_sum - remaining_sum) min_diff = min(min_diff, current_diff) return min_diff"},{"question":"from typing import List def max_square_subgrid_sum(grid: List[List[int]]) -> int: Find the maximum sum of a square subgrid of a given grid. Args: grid (List[List[int]]): A 2D list representing the grid filled with non-negative integers. Returns: int: The maximum sum of a subgrid that satisfies the constraints. Examples: >>> max_square_subgrid_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 45 >>> max_square_subgrid_sum([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) 136 >>> max_square_subgrid_sum([[1, 2], [3, 4]]) 10 >>> max_square_subgrid_sum([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) 0 >>> max_square_subgrid_sum([[1000, 1000, 1000], [1000, 1000, 1000], [1000, 1000, 1000]]) 9000","solution":"def max_square_subgrid_sum(grid): N = len(grid) M = len(grid[0]) max_sum = 0 prefix_sum = [[0] * (M + 1) for _ in range(N + 1)] # Fill prefix_sum array for i in range(1, N+1): for j in range(1, M+1): prefix_sum[i][j] = grid[i-1][j-1] + prefix_sum[i-1][j] + prefix_sum[i][j-1] - prefix_sum[i-1][j-1] max_side = min(N, M) # Calculate maximum square subgrid sum for k in range(1, max_side + 1): for i in range(k, N + 1): for j in range(k, M + 1): current_sum = (prefix_sum[i][j] - prefix_sum[i - k][j] - prefix_sum[i][j - k] + prefix_sum[i - k][j - k]) max_sum = max(max_sum, current_sum) return max_sum"},{"question":"def can_make_recipe(n, recipe_ingredients, m, kitchen_ingredients): Determine whether you have enough ingredients to make the recipe. >>> can_make_recipe( ... 2, ... [(\\"butter\\", 100), (\\"salt\\", 50)], ... 2, ... [(\\"butter\\", 150), (\\"salt\\", 50)] ... ) == \\"Yes\\" >>> can_make_recipe( ... 3, ... [(\\"milk\\", 500), (\\"sugar\\", 200), (\\"flour\\", 300)], ... 3, ... [(\\"milk\\", 500), (\\"sugar\\", 300), (\\"flour\\", 100)] ... ) == \\"No\\" >>> can_make_recipe( ... 1, ... [(\\"sugar\\", 200)], ... 2, ... [(\\"sugar\\", 300), (\\"salt\\", 100)] ... ) == \\"Yes\\" >>> can_make_recipe( ... 2, ... [(\\"sugar\\", 200), (\\"milk\\", 100)], ... 1, ... [(\\"sugar\\", 300)] ... ) == \\"No\\" >>> can_make_recipe( ... 1, ... [(\\"flour\\", 100)], ... 1, ... [(\\"flour\\", 100)] ... ) == \\"Yes\\"","solution":"def can_make_recipe(n, recipe_ingredients, m, kitchen_ingredients): recipe_dict = {ingredient: qty for ingredient, qty in recipe_ingredients} kitchen_dict = {ingredient: qty for ingredient, qty in kitchen_ingredients} for ingredient, required_qty in recipe_dict.items(): if kitchen_dict.get(ingredient, 0) < required_qty: return \\"No\\" return \\"Yes\\""},{"question":"def min_removed_parentheses(s: str) -> str: This function removes the minimum number of parentheses to make the input string valid. Args: s (str): The input string containing only '(' and ')'. Returns: str: The resulting valid parentheses string after minimum deletions. Examples: >>> min_removed_parentheses(\\"()())\\") in {\\"()()\\", \\"(())\\"} True >>> min_removed_parentheses(\\"((\\") \\"\\" >>> min_removed_parentheses(\\")()(\\") in {\\"()\\", \\"\\"} True","solution":"def min_removed_parentheses(s): This function removes the minimum number of parentheses to make the input string valid. stack = [] to_remove = set() # Identify the parentheses to be removed for i, char in enumerate(s): if char == '(': stack.append(i) elif char == ')': if stack: stack.pop() else: to_remove.add(i) # Add any leftover '(' indices to the removal set to_remove = to_remove.union(set(stack)) # Build the valid string by skipping indices in the to_remove set result = ''.join([char for i, char in enumerate(s) if i not in to_remove]) return result"},{"question":"def categorize_transactions(filename: str): Categorize transactions into expenses, income, and transfer, and output the total amount for each category. Example usage: >>> categorize_transactions('transactions.csv') 225.50 2500.00 300.00 import os from io import StringIO import sys def create_test_file(filename, content): with open(filename, 'w') as f: f.write(content) def test_categorize_transactions(): filename = 'test_transactions.csv' content = 1,expense,150.00,2023-04-01 10:20:30 2,income,2000.00,2023-04-01 12:45:00 3,expense,75.50,2023-04-01 14:30:00 4,transfer,300.00,2023-04-02 09:10:00 5,income,500.00,2023-04-03 11:00:00 create_test_file(filename, content) try: # Capture the output captured_output = StringIO() sys.stdout = captured_output categorize_transactions(filename) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split('n') assert output[0] == '225.50' assert output[1] == '2500.00' assert output[2] == '300.00' finally: os.remove(filename) def test_categorize_transactions_empty(): filename = 'test_transactions_empty.csv' content = \\"\\" create_test_file(filename, content) try: # Capture the output captured_output = StringIO() sys.stdout = captured_output categorize_transactions(filename) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split('n') assert output[0] == '0.00' assert output[1] == '0.00' assert output[2] == '0.00' finally: os.remove(filename) def test_categorize_transactions_single_entry(): filename = 'test_transactions_single.csv' content = \\"1,income,1000.00,2023-04-01 11:00:00\\" create_test_file(filename, content) try: # Capture the output captured_output = StringIO() sys.stdout = captured_output categorize_transactions(filename) sys.stdout = sys.__stdout__ output = captured_output.getvalue().strip().split('n') assert output[0] == '0.00' assert output[1] == '1000.00' assert output[2] == '0.00' finally: os.remove(filename)","solution":"def categorize_transactions(filename): expense_total = 0.0 income_total = 0.0 transfer_total = 0.0 with open(filename, 'r') as f: for line in f: if line.strip(): # Skip empty lines _, transaction_type, amount, _ = line.strip().split(',') amount = float(amount) if transaction_type == 'expense': expense_total += amount elif transaction_type == 'income': income_total += amount elif transaction_type == 'transfer': transfer_total += amount print(f\\"{expense_total:.2f}\\") print(f\\"{income_total:.2f}\\") print(f\\"{transfer_total:.2f}\\")"},{"question":"import heapq def shortest_path(n: int, m: int, edges: List[Tuple[int, int, int]]) -> int: Finds the shortest path in a weighted directed graph with the possibility of zero-weight edges. Parameters: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (List[Tuple[int, int, int]]): List of tuples representing edges where each tuple contains three integers u, v, and w representing a directed edge from u to v with weight w. Returns: int: The minimum distance from node 1 to node n. If no path exists, return -1. Examples: >>> shortest_path(4, 5, [(1, 2, 1), (2, 3, 1), (3, 4, 1), (1, 3, 3), (1, 4, 0)]) 0 >>> shortest_path(5, 6, [(1, 2, 1), (1, 3, 1), (2, 4, 2), (3, 4, 2), (4, 5, 3), (1, 5, 10)]) 6 >>> shortest_path(3, 2, [(1, 2, 1), (2, 3, 1)]) 2 >>> shortest_path(1, 0, []) 0 >>> shortest_path(4, 3, [(1, 2, 1), (2, 3, 1), (3, 2, 1)]) -1","solution":"import heapq def shortest_path(n, m, edges): Finds the shortest path in a weighted directed graph with the possibility of zero-weight edges. Parameters: n (int): The number of nodes in the graph. m (int): The number of edges in the graph. edges (list of tuples): Each tuple contains three integers u, v, and w representing a directed edge from u to v with weight w. Returns: int: The minimum distance from node 1 to node n. If no path exists, return -1. graph = {i: [] for i in range(1, n + 1)} for u, v, w in edges: graph[u].append((v, w)) # Dijkstra's algorithm pq = [(0, 1)] # (cost, node) distances = {i: float('inf') for i in range(1, n + 1)} distances[1] = 0 while pq: current_dist, u = heapq.heappop(pq) if current_dist > distances[u]: continue for v, weight in graph[u]: distance = current_dist + weight if distance < distances[v]: distances[v] = distance heapq.heappush(pq, (distance, v)) return distances[n] if distances[n] != float('inf') else -1"},{"question":"def max_treasure(n: int, m: int, grid: List[List[int]]) -> int: Determine the maximum amount of treasure that can be collected when starting from the top-left corner and reaching the bottom-right corner of the grid. >>> max_treasure(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_treasure(2, 2, [[1, 2], [1, 1]]) 4 from solution import max_treasure def test_example1(): n, m = 3, 3 grid = [ [1, 3, 1], [1, 5, 1], [4, 2, 1] ] assert max_treasure(n, m, grid) == 12 def test_example2(): n, m = 2, 2 grid = [ [1, 2], [1, 1] ] assert max_treasure(n, m, grid) == 4 def test_single_cell(): n, m = 1, 1 grid = [ [5] ] assert max_treasure(n, m, grid) == 5 def test_row_grid(): n, m = 1, 4 grid = [ [1, 2, 3, 4] ] assert max_treasure(n, m, grid) == 10 def test_column_grid(): n, m = 4, 1 grid = [ [1], [2], [3], [4] ] assert max_treasure(n, m, grid) == 10 def test_large_grid(): n, m = 3, 3 grid = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] assert max_treasure(n, m, grid) == 29 def test_zero_treasures(): n, m = 2, 2 grid = [ [0, 0], [0, 0] ] assert max_treasure(n, m, grid) == 0","solution":"def max_treasure(n, m, grid): # Create a dp table to store the maximum treasure that can be collected up to each cell dp = [[0] * m for _ in range(n)] # Initialize the first cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, m): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, n): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, n): for j in range(1, m): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right cell contains the maximum treasure that can be collected return dp[-1][-1]"},{"question":"import heapq from typing import List class BalancedMinHeap: A class to represent a balanced min-heap data structure. def __init__(self): self.heap = [] def insert(self, x: int) -> None: Insert an integer into the heap. heapq.heappush(self.heap, x) def extract_min(self) -> int: Extract the minimum element from the heap. If the heap is empty, return -1. if not self.heap: return -1 return heapq.heappop(self.heap) def process_operations(operations: List[str]) -> str: Process a series of operations and maintain the properties of the heap. >>> process_operations([ ... \\"insert 5\\", ... \\"insert 2\\", ... \\"insert 3\\", ... \\"extractMin\\", ... \\"insert 8\\", ... \\"extractMin\\", ... \\"insert 1\\", ... \\"extractMin\\", ... \\"extractMin\\", ... \\"extractMin\\"]) '2n3n1n5n-1' heap = BalancedMinHeap() result = [] for operation in operations: if operation.startswith(\\"insert\\"): _, value = operation.split() heap.insert(int(value)) elif operation == \\"extractMin\\": result.append(str(heap.extract_min())) return \\"n\\".join(result) def test_basic_operations(): operations = [ \\"insert 5\\", \\"insert 2\\", \\"insert 3\\", \\"extractMin\\", ] result = process_operations(operations) assert result == \\"2\\" def test_mixed_operations(): operations = [ \\"insert 10\\", \\"insert 4\\", \\"extractMin\\", \\"insert 3\\", \\"extractMin\\", \\"extractMin\\" ] result = process_operations(operations) assert result == \\"4n3n10\\" def test_extract_from_empty_heap(): operations = [ \\"extractMin\\", \\"insert 1\\", \\"extractMin\\", \\"extractMin\\" ] result = process_operations(operations) assert result == \\"-1n1n-1\\" def test_advanced_operations(): operations = [ \\"insert 5\\", \\"insert -1\\", \\"insert 100\\", \\"extractMin\\", \\"extractMin\\", \\"extractMin\\", \\"extractMin\\" ] result = process_operations(operations) assert result == \\"-1n5n100n-1\\"","solution":"import heapq class BalancedMinHeap: def __init__(self): self.heap = [] def insert(self, x): heapq.heappush(self.heap, x) def extract_min(self): if not self.heap: return -1 return heapq.heappop(self.heap) def process_operations(operations): heap = BalancedMinHeap() result = [] for operation in operations: if operation.startswith(\\"insert\\"): _, value = operation.split() heap.insert(int(value)) elif operation == \\"extractMin\\": result.append(str(heap.extract_min())) return \\"n\\".join(result)"},{"question":"def min_days_to_complete_projects(N: int, M: int, project_times: List[int]) -> int: Returns the minimum number of days required to complete all projects. :param N: The number of projects. :param M: The number of hours Gleb can work each day. :param project_times: A list of integers where each entry represents the amount of time required to complete each project. :return: The minimum number of days required to complete all projects. >>> min_days_to_complete_projects(3, 8, [5, 2, 4]) 2 >>> min_days_to_complete_projects(4, 3, [3, 3, 3, 3]) 4 >>> min_days_to_complete_projects(5, 6, [2, 5, 8, 4, 9]) 5","solution":"def min_days_to_complete_projects(N, M, project_times): Returns the minimum number of days required to complete all projects. days = 0 day_hours_left = M for time in project_times: if time <= day_hours_left: day_hours_left -= time else: days += 1 day_hours_left = M - time if day_hours_left < M: days += 1 # This covers any last residual hours spent on projects return days"},{"question":"def perfect_pattern(grid: List[List[int]], n: int) -> Union[List[List[int]], str]: Determine if it is possible to complete the grid to form a perfect pattern. If so, returns the completed grid. Otherwise, returns \\"NO SOLUTION\\". >>> perfect_pattern([[4, 9, 2], [3, 5, 0], [0, 1, 6]], 3) [[4, 9, 2], [3, 5, 7], [8, 1, 6]] or \\"NO SOLUTION\\" >>> perfect_pattern([[1, 2], [0, 4]], 2) \\"NO SOLUTION\\" >>> perfect_pattern([[1, 0], [0, 4]], 2) [[1, 3], [2, 4]] or \\"NO SOLUTION\\" >>> perfect_pattern([[16, 2, 3, 13], [5, 0, 0, 8], [9, 0, 0, 6], [4, 14, 15, 0]], 4) [[16, 2, 3, 13], [5, 11, 10, 8], [9, 7, 12, 6], [4, 14, 15, 1]] or \\"NO SOLUTION\\"","solution":"def perfect_pattern(grid, n): def is_valid(grid): target_sum = sum(grid[0]) diag1, diag2 = 0, 0 for i in range(n): if sum(grid[i]) != target_sum: return False if sum(grid[j][i] for j in range(n)) != target_sum: return False diag1 += grid[i][i] diag2 += grid[i][n-1-i] return diag1 == target_sum and diag2 == target_sum def solve(grid, empty_cells, idx): if idx == len(empty_cells): if is_valid(grid): return True return False x, y = empty_cells[idx] for num in range(1, n*n + 1): used = any(num in row for row in grid) if not used: grid[x][y] = num if solve(grid, empty_cells, idx + 1): return True grid[x][y] = 0 return False empty_cells = [(i, j) for i in range(n) for j in range(n) if grid[i][j] == 0] if solve(grid, empty_cells, 0): return grid return \\"NO SOLUTION\\" def main(input_str): lines = input_str.strip().split('n') n = int(lines[0]) grid = [list(map(int, line.split())) for line in lines[1:]] result = perfect_pattern(grid, n) if result == \\"NO SOLUTION\\": print(result) else: for row in result: print(\\" \\".join(map(str, row))) # Sample usage input_str = 3 4 9 2 3 5 0 0 1 6 main(input_str)"},{"question":"def max_positive_improvement(test_cases): For each test case, find the maximum positive improvement in song ranking over multiple days. Parameters: test_cases: A list of tuples where each tuple contains: - An integer N representing the number of days. - A list of N integers representing the song ranking on each day. Returns: A list of integers where each integer represents the maximum positive improvement for the corresponding test case. from max_positive_improvement import max_positive_improvement def test_basic_improvement(): input_data = [ (5, [5, 4, 3, 2, 1]), (4, [8, 7, 5, 5]) ] expected = [4, 3] output = max_positive_improvement(input_data) assert output == expected def test_no_improvement(): input_data = [ (3, [1, 2, 3]), (4, [10, 10, 10, 10]) ] expected = [0, 0] output = max_positive_improvement(input_data) assert output == expected def test_single_day(): input_data = [ (1, [1]), (1, [10]) ] expected = [0, 0] output = max_positive_improvement(input_data) assert output == expected def test_large_improvement(): input_data = [ (6, [6, 5, 4, 3, 2, 1]), (6, [10, 20, 30, 40, 50, 60]) ] expected = [5, 0] output = max_positive_improvement(input_data) assert output == expected def test_case_with_duplicates(): input_data = [ (5, [10, 9, 8, 8, 7]) ] expected = [3] output = max_positive_improvement(input_data) assert output == expected def test_complex_case(): input_data = [ (10, [10, 9, 2, 3, 4, 5, 6, 7, 8, 1]), ] expected = [9] output = max_positive_improvement(input_data) assert output == expected","solution":"def max_positive_improvement(test_cases): For each test case, find the maximum positive improvement in song ranking over multiple days. Parameters: test_cases: A list of tuples where each tuple contains: - An integer N representing the number of days. - A list of N integers representing the song ranking on each day. Returns: A list of integers where each integer represents the maximum positive improvement for the corresponding test case. results = [] for N, rankings in test_cases: max_improvement = 0 for i in range(N): for j in range(i + 1, N): improvement = rankings[i] - rankings[j] if improvement > max_improvement: max_improvement = improvement results.append(max_improvement) return results"},{"question":"def calculate_checked_out_time(logs: [(int, str)]) -> int: Calculates the total duration a book was checked out. Args: logs: List of tuples where each tuple consists of (timestamp, action: 'check-out' or 'check-in') Returns: Total duration in seconds for which the book was checked out pass # Example usage: # logs = [(1, 'check-out'), (10, 'check-in'), (15, 'check-out'), (25, 'check-in')] # print(calculate_checked_out_time(logs)) # Output: 19 # logs = [(1, 'check-out'), (20, 'check-in'), (30, 'check-out'), (40, 'check-out')] # print(calculate_checked_out_time(logs)) # Output: 19","solution":"def calculate_checked_out_time(logs: [(int, str)]) -> int: Calculates the total duration a book was checked out. Args: logs: List of tuples where each tuple consists of (timestamp, action) Returns: Total duration in seconds for which the book was checked out total_checked_out_time = 0 last_check_out_time = None for timestamp, action in logs: if action == 'check-out': last_check_out_time = timestamp elif action == 'check-in' and last_check_out_time is not None: total_checked_out_time += (timestamp - last_check_out_time) last_check_out_time = None # If the book is still checked out at the end of the logs if last_check_out_time is not None: total_checked_out_time += (logs[-1][0] - last_check_out_time) return total_checked_out_time"},{"question":"def minimum_seats_required(talks): Determine the minimum number of seats required such that no two guests attend any of the listed talks simultaneously. Params: - talks (list of tuples): List of tuples where each tuple contains the start and end time of a talk. Returns: - int: The minimum number of seats required. from solution import minimum_seats_required def test_no_talks(): assert minimum_seats_required([]) == 0 def test_single_talk(): assert minimum_seats_required([(1, 2)]) == 1 def test_non_overlapping_talks(): assert minimum_seats_required([(1, 2), (3, 4), (5, 6)]) == 1 def test_overlapping_talks(): assert minimum_seats_required([(1, 3), (2, 4), (3, 5)]) == 2 def test_mixed_talks(): assert minimum_seats_required([(1, 3), (2, 5), (4, 6), (7, 8)]) == 2 def test_all_day_talks(): assert minimum_seats_required([(0, 10**9), (0, 10**9), (0, 10**9)]) == 3","solution":"def minimum_seats_required(talks): Determine the minimum number of seats required such that no two guests attend any of the listed talks simultaneously. Params: - talks (list of tuples): List of tuples where each tuple contains the start and end time of a talk. Returns: - int: The minimum number of seats required. if not talks: return 0 # Separate out the start and end times events = [] for start, end in talks: events.append((start, 'start')) events.append((end, 'end')) # Sort the events; in case of tie, end times should come before start times events.sort(key=lambda x: (x[0], x[1] == 'start')) max_seats = 0 current_seats = 0 # Traverse through the sorted events for time, event in events: if event == 'start': current_seats += 1 max_seats = max(max_seats, current_seats) else: current_seats -= 1 return max_seats"},{"question":"from typing import List def word_ladder_length(start: str, target: str, words: List[str]) -> int: Given the words list, the start word, and the target word, determine the length of the shortest transformation sequence from the start word to the target word. If no such sequence exists, return 0. >>> word_ladder_length(\\"hit\\", \\"cog\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 5 >>> word_ladder_length(\\"hit\\", \\"bag\\", [\\"hot\\", \\"dot\\", \\"dog\\", \\"lot\\", \\"log\\", \\"cog\\"]) 0","solution":"from collections import deque def word_ladder_length(start, target, words): if target not in words: return 0 words = set(words) queue = deque([(start, 1)]) alpha = 'abcdefghijklmnopqrstuvwxyz' while queue: word, length = queue.popleft() if word == target: return length for i in range(len(word)): for char in alpha: new_word = word[:i] + char + word[i+1:] if new_word in words: words.remove(new_word) queue.append((new_word, length + 1)) return 0"},{"question":"def min_operations_to_mirror_array(arr): Calculate the minimum number of operations to make the array a mirror array. Args: arr: List[int] - a list of integers Returns: int - the minimum number of operations required to transform the list into a mirror array Examples: >>> min_operations_to_mirror_array([4, 1, 1, 4]) 0 >>> min_operations_to_mirror_array([3, 2, 1]) 1 >>> min_operations_to_mirror_array([1, 2, 3, 4, 5]) 2","solution":"def min_operations_to_mirror_array(arr): Calculate the minimum number of operations to make the array a mirror array. n = len(arr) operations = 0 for i in range(n // 2): if arr[i] != arr[n - i - 1]: operations += 1 return operations # Read inputs def main(): import sys input = sys.stdin.read data = input().split() n = int(data[0]) arr = list(map(int, data[1:])) result = min_operations_to_mirror_array(arr) print(result)"},{"question":"def min_max_length_of_subarrays(t, test_cases): Returns the minimum possible maximum length of subarrays after splitting the array into three contiguous subarrays. >>> min_max_length_of_subarrays(1, [(8, [1, 3, 5, 2, 2, 6, 9, 8])]) [3] >>> min_max_length_of_subarrays(1, [(6, [10, 20, 30, 40, 50, 60])]) [2]","solution":"def min_max_length_of_subarrays(t, test_cases): Returns the minimum possible maximum length of subarrays after splitting the array into three contiguous subarrays. results = [] for case in test_cases: n, array = case # Calculate prefix sums to find the total sum of the array easily prefix_sum = [0] * (n + 1) for i in range(n): prefix_sum[i + 1] = prefix_sum[i] + array[i] min_max_length = float('inf') for i in range(1, n - 1): for j in range(i + 1, n): # Lengths of subarrays len1 = i len2 = j - i len3 = n - j max_len = max(len1, len2, len3) min_max_length = min(min_max_length, max_len) results.append(min_max_length) return results"},{"question":"from typing import List, Tuple def find_max_sum_path(N: int, nodes: List[Tuple[int, int, int]]) -> List[int]: Find the path from the root to any leaf that has the maximum sum of weights. If there are multiple paths with the same maximum sum, return the one which lexicographically smallest when viewed as sequences of node identifiers. Args: N (int): The number of nodes. nodes (List[Tuple[int, int, int]]): List of tuples with node id, weight, and parent id. Returns: List[int]: Path from root to leaf with maximum sum of weights. Examples: >>> find_max_sum_path(5, [(1, 10, 0), (2, 5, 1), (3, 20, 1), (4, 2, 3), (5, 1, 3)]) [1, 3, 4] >>> find_max_sum_path(4, [(1, 100, 0), (2, 50, 1), (3, 50, 1), (4, 1, 2)]) [1, 2, 4] >>> find_max_sum_path(1, [(1, 100, 0)]) [1] pass def parse_input(input_str: str) -> Tuple[int, List[Tuple[int, int, int]]]: Parse the input from a string into the required format. lines = input_str.strip().split(\\"n\\") N = int(lines[0]) nodes = [tuple(map(int, line.split())) for line in lines[1:]] return N, nodes def main(input_str: str): N, nodes = parse_input(input_str) max_sum_path = find_max_sum_path(N, nodes) print(\\" \\".join(map(str, max_sum_path))) # Unit tests def test_find_max_sum_path(): input_str = \\"5n1 10 0n2 5 1n3 20 1n4 2 3n5 1 3\\" N, nodes = parse_input(input_str) assert find_max_sum_path(N, nodes) == [1, 3, 4] def test_find_max_sum_path_multiple_paths(): input_str = \\"4n1 100 0n2 50 1n3 50 1n4 1 2\\" N, nodes = parse_input(input_str) assert find_max_sum_path(N, nodes) == [1, 2, 4] def test_find_max_sum_path_single_node(): input_str = \\"1n1 100 0\\" N, nodes = parse_input(input_str) assert find_max_sum_path(N, nodes) == [1] from io import StringIO import sys def test_main(capfd): input_str = \\"5n1 10 0n2 5 1n3 20 1n4 2 3n5 1 3\\" sys.stdin = StringIO(input_str) main(input_str) captured = capfd.readouterr() assert captured.out.strip() == \\"1 3 4\\" input_str = \\"4n1 100 0n2 50 1n3 50 1n4 1 2\\" sys.stdin = StringIO(input_str) main(input_str) captured = capfd.readouterr() assert captured.out.strip() == \\"1 2 4\\"","solution":"from collections import defaultdict import heapq def find_max_sum_path(N, nodes): # Create adjacency list and weight dictionary tree = defaultdict(list) weight = {} root = None for node in nodes: id_i, weight_i, parent_i = node weight[id_i] = weight_i if parent_i == 0: root = id_i else: tree[parent_i].append(id_i) # Use a max heap to find the path with the maximum weight sum max_heap = [(-weight[root], [root])] max_sum_path = [] while max_heap: curr_sum, path = heapq.heappop(max_heap) curr_sum = -curr_sum current_node = path[-1] if not tree[current_node]: # If it's a leaf node if not max_sum_path or curr_sum > weight_sum_path(max_sum_path, weight) or (curr_sum == weight_sum_path(max_sum_path, weight) and path < max_sum_path): max_sum_path = path else: for child in sorted(tree[current_node]): new_path = path + [child] heapq.heappush(max_heap, (-(curr_sum + weight[child]), new_path)) return max_sum_path def weight_sum_path(path, weight): return sum(weight[node] for node in path) def parse_input(input_str): lines = input_str.strip().split(\\"n\\") N = int(lines[0]) nodes = [tuple(map(int, line.split())) for line in lines[1:]] return N, nodes def main(input_str): N, nodes = parse_input(input_str) max_sum_path = find_max_sum_path(N, nodes) print(\\" \\".join(map(str, max_sum_path)))"},{"question":"def can_reach(n: int, m: int, l: int, walls: List[Tuple[int, int, int, int]]) -> str: Determine if Bob can reach from (1,1) to (n,m) without crossing any walls. >>> can_reach(5, 5, 2, [(2, 1, 2, 3), (3, 2, 4, 2)]) == \\"YES\\" >>> can_reach(3, 3, 1, [(1, 2, 3, 2)]) == \\"NO\\" >>> can_reach(4, 4, 0, []) == \\"YES\\" >>> can_reach(1000, 1000, 0, []) == \\"YES\\" >>> can_reach(4, 4, 4, [(1, 2, 1, 3), (2, 1, 3, 1), (3, 1, 3, 2), (2, 3, 3, 3)]) == \\"NO\\" >>> can_reach(4, 4, 1, [(2, 1, 2, 3)]) == \\"YES\\" >>> can_reach(5, 5, 3, [(2, 1, 2, 5), (3, 2, 3, 5), (4, 1, 4, 3)]) == \\"NO\\"","solution":"from collections import deque def can_reach(n, m, l, walls): grid = [[0] * (m + 1) for _ in range(n + 1)] for r1, c1, r2, c2 in walls: if r1 == r2: # horizontal wall for c in range(min(c1, c2), max(c1, c2) + 1): grid[r1][c] = 1 elif c1 == c2: # vertical wall for r in range(min(r1, r2), max(r1, r2) + 1): grid[r][c1] = 1 def is_valid_move(x, y): return 1 <= x <= n and 1 <= y <= m and grid[x][y] == 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(1, 1)]) grid[1][1] = 1 while queue: x, y = queue.popleft() if x == n and y == m: return \\"YES\\" for dx, dy in directions: nx, ny = x + dx, y + dy if is_valid_move(nx, ny): grid[nx][ny] = 1 queue.append((nx, ny)) return \\"NO\\""},{"question":"def min_message_transmissions(n, m, user_channels, channel_users, sender, channel, message): Determine the minimum number of message transmissions needed to deliver a message to all users in a specified channel. Args: n (int): Number of users. m (int): Number of channels. user_channels (dict): A dictionary with user IDs as keys and a list of channel IDs as values. channel_users (dict): A dictionary with channel IDs as keys and a list of user IDs as values. sender (int): The user ID of the sender. channel (int): The channel ID through which the message is sent. message (str): The content of the message. Returns: int: The minimum number of message transmissions required. >>> user_channels = {1: [1, 2], 2: [1], 3: [2]} >>> channel_users = {1: [1, 2], 2: [2, 3]} >>> min_message_transmissions(3, 2, user_channels, channel_users, 1, 1, \\"HelloWorld\\") 1 >>> user_channels = {1: [1]} >>> channel_users = {1: [1]} >>> min_message_transmissions(1, 1, user_channels, channel_users, 1, 1, \\"HelloWorld\\") 0 pass","solution":"def min_message_transmissions(n, m, user_channels, channel_users, sender, channel, message): from collections import deque, defaultdict # Initialize the graph of users and the sets for visited and distances graph = defaultdict(list) visited = set() distance = {i: float('inf') for i in range(1, n+1)} # Build the users graph based on common channels for user, channels in user_channels.items(): for ch in channels: for user_in_channel in channel_users[ch]: if user_in_channel != user: graph[user].append(user_in_channel) graph[user_in_channel].append(user) # Perform BFS to find minimum number of transmissions queue = deque([(sender, 0)]) visited.add(sender) distance[sender] = 0 while queue: current_user, dist = queue.popleft() for neighbor in graph[current_user]: if neighbor not in visited: visited.add(neighbor) distance[neighbor] = dist + 1 queue.append((neighbor, dist+1)) # Find maximum distance in the target channel transmissions = max(distance[user] for user in channel_users[channel]) return transmissions # Example usage n = 3 m = 2 user_channels = { 1: [1,2], 2: [1], 3: [2] } channel_users = { 1: [1,2], 2: [2,3] } sender = 1 channel = 1 message = \\"HelloWorld\\" print(min_message_transmissions(n, m, user_channels, channel_users, sender, channel, message)) # Output: 1"},{"question":"def check_security_code(s: str) -> str: Returns \\"Valid\\" if the string s meets all the requirements: 1. The string must contain at least one uppercase letter. 2. The string must contain at least one lowercase letter. 3. The string must contain at least one digit. 4. The string must not contain any special characters. 5. The string must have a minimum length of 8 characters and a maximum length of 15 characters. Otherwise, it returns \\"Invalid\\". >>> check_security_code(\\"Aa1xyz89\\") \\"Valid\\" >>> check_security_code(\\"aa1xyz89\\") \\"Invalid\\" >>> check_security_code(\\"A1xyz89\\") \\"Invalid\\" >>> check_security_code(\\"Aaa1xyz\\") \\"Invalid\\" >>> check_security_code(\\"Aa1abcde\\") \\"Valid\\" >>> check_security_code(\\"Aa1abcdefghijk\\") \\"Valid\\" >>> check_security_code(\\"Aa1abcdefghijklmnopqrstuvwxyz\\") \\"Invalid\\" >>> check_security_code(\\"Aaaabcdef\\") \\"Invalid\\" >>> check_security_code(\\"ABCDEFGHI\\") \\"Invalid\\" >>> check_security_code(\\"abcdefghi\\") \\"Invalid\\" >>> check_security_code(\\"123456789\\") \\"Invalid\\"","solution":"def check_security_code(s): Returns \\"Valid\\" if the string s meets all the requirements: 1. The string must contain at least one uppercase letter. 2. The string must contain at least one lowercase letter. 3. The string must contain at least one digit. 4. The string must not contain any special characters. 5. The string must have a minimum length of 8 characters and a maximum length of 15 characters. Otherwise, it returns \\"Invalid\\". if not (8 <= len(s) <= 15): return \\"Invalid\\" has_upper = any(c.isupper() for c in s) has_lower = any(c.islower() for c in s) has_digit = any(c.isdigit() for c in s) has_special = any(not c.isalnum() for c in s) if has_upper and has_lower and has_digit and not has_special: return \\"Valid\\" return \\"Invalid\\""},{"question":"def largest_product_of_three(arr): Given an array of integers, finds three distinct elements that give the largest product when multiplied together. >>> largest_product_of_three([1, 2, 3, 4, 5]) == set([3, 4, 5]) >>> largest_product_of_three([-10, -10, 1, 3, 2, 4]) == set([-10, -10, 4]) >>> largest_product_of_three([-1, -2, -3, -4, -5]) == set([-1, -2, -3]) >>> largest_product_of_three([-10, -10, 5, 2, 3]) == set([-10, -10, 5]) >>> largest_product_of_three([-10, 0, 1, 3, 2, 4]) == set([2, 3, 4]) >>> largest_product_of_three([3, 4, 1]) == set([3, 4, 1])","solution":"def largest_product_of_three(arr): Given an array of integers, finds three distinct elements that give the largest product when multiplied together. # Sort the array. arr.sort() # The maximum product of three can either be: # - The product of the three largest numbers. # - The product of the two smallest (most negative) numbers and the largest number. max1 = arr[-1] * arr[-2] * arr[-3] max2 = arr[0] * arr[1] * arr[-1] if max1 > max2: return [arr[-3], arr[-2], arr[-1]] else: return [arr[0], arr[1], arr[-1]]"},{"question":"def game_winner(A: int, B: int) -> str: Determines the winner of the game with two piles of stones. :param A: Number of stones in pile A :param B: Number of stones in pile B :return: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" >>> game_winner(2, 1) \\"Alice\\" >>> game_winner(1, 1) \\"Alice\\" >>> game_winner(2, 2) \\"Bob\\" >>> game_winner(3, 1) \\"Alice\\" >>> game_winner(1, 0) \\"Alice\\" >>> game_winner(2147483647, 2147483647) \\"Alice\\" >>> game_winner(2147483646, 2147483646) \\"Bob\\" >>> game_winner(1000000000, 999999999) \\"Alice\\" >>> game_winner(0, 0) \\"Bob\\" >>> game_winner(1, 2) \\"Alice\\"","solution":"def game_winner(A, B): Determines the winner of the game with two piles of stones. :param A: Number of stones in pile A :param B: Number of stones in pile B :return: \\"Alice\\" if Alice wins, otherwise \\"Bob\\" if A == B: return \\"Bob\\" if A % 2 == 0 else \\"Alice\\" else: return \\"Alice\\""},{"question":"class TicketBookingSystem: def __init__(self, n): Initialize ticket booking system with n events, initially all tickets are set to zero. pass def book(self, e, t): Book t tickets for event e. pass def available(self, e): Check how many tickets are available for event e. pass def run_ticket_booking_system(n, queries): Runs a sequence of ticket booking system operations. Parameters: n (int): Number of events. queries (List[str]): List of queries containing 'book' and 'available' operations. Returns: List[int]: Results of 'available' queries. Example: >>> run_ticket_booking_system(3, [ ... \\"book 1 100\\", ... \\"book 2 200\\", ... \\"available 1\\", ... \\"available 2\\", ... \\"book 1 50\\", ... \\"available 1\\", ... \\"available 3\\" ... ]) [100, 200, 150, 0] pass import pytest def test_initial_ticket_availability(): system = TicketBookingSystem(3) assert system.available(1) == 0 assert system.available(2) == 0 assert system.available(3) == 0 def test_booking_tickets(): system = TicketBookingSystem(3) system.book(1, 100) assert system.available(1) == 100 system.book(2, 200) assert system.available(2) == 200 system.book(1, 50) assert system.available(1) == 150 def test_maximum_tickets_booking(): system = TicketBookingSystem(3) system.book(1, 9000) assert system.available(1) == 9000 system.book(1, 2000) # attempts to book over 10000 assert system.available(1) == 10000 def test_run_ticket_booking_system(): queries = [ \\"book 1 100\\", \\"book 2 200\\", \\"available 1\\", \\"available 2\\", \\"book 1 50\\", \\"available 1\\", \\"available 3\\" ] expected_output = [100, 200, 150, 0] assert run_ticket_booking_system(3, queries) == expected_output if __name__ == \\"__main__\\": pytest.main()","solution":"class TicketBookingSystem: def __init__(self, n): self.events = [0] * n def book(self, e, t): if self.events[e-1] + t <= 10000: self.events[e-1] += t else: self.events[e-1] = 10000 def available(self, e): return self.events[e-1] def run_ticket_booking_system(n, queries): system = TicketBookingSystem(n) results = [] for query in queries: parts = query.split() if parts[0] == \\"book\\": e, t = int(parts[1]), int(parts[2]) system.book(e, t) elif parts[0] == \\"available\\": e = int(parts[1]) results.append(system.available(e)) return results"},{"question":"def detect_unusual_activity(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[str]: Detects unusual activity in given sequences of movements. Args: T: The number of test cases. test_cases: A list of tuples, where each tuple contains an integer N and a list of N integers. Returns: A list of strings. Each string is either \\"Unusual activity detected!\\" if the sequence is unusual, or \\"All clear!\\" if the sequence is normal. >>> detect_unusual_activity(3, [(5, [1, 2, 3, 4, 5]), (6, [2, 3, 3, 4, 5, 6]), (4, [7, 8, 8, 7])]) [\\"All clear!\\", \\"Unusual activity detected!\\", \\"Unusual activity detected!\\"] >>> detect_unusual_activity(1, [(4, [1, 1, 2, 3])]) [\\"Unusual activity detected!\\"] from typing import List, Tuple def test_detect_unusual_activity(): assert detect_unusual_activity(3, [ (5, [1, 2, 3, 4, 5]), (6, [2, 3, 3, 4, 5, 6]), (4, [7, 8, 8, 7]) ]) == [\\"All clear!\\", \\"Unusual activity detected!\\", \\"Unusual activity detected!\\"] def test_single_case_clear(): assert detect_unusual_activity(1, [ (5, [1, 2, 3, 4, 5]) ]) == [\\"All clear!\\"] def test_single_case_unusual(): assert detect_unusual_activity(1, [ (4, [1, 1, 2, 3]) ]) == [\\"Unusual activity detected!\\"] def test_long_sequence_clear(): assert detect_unusual_activity(1, [ (10, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) ]) == [\\"All clear!\\"] def test_long_sequence_unusual(): assert detect_unusual_activity(1, [ (10, [0, 1, 2, 2, 4, 5, 6, 7, 8, 9]) ]) == [\\"Unusual activity detected!\\"]","solution":"def detect_unusual_activity(T, test_cases): results = [] for i in range(T): N, movements = test_cases[i] unusual_detected = False for j in range(1, N): if movements[j] == movements[j - 1]: unusual_detected = True break if unusual_detected: results.append(\\"Unusual activity detected!\\") else: results.append(\\"All clear!\\") return results"},{"question":"from typing import List, Tuple def find_flavors(total_money: int, flavors: List[int]) -> Tuple[int, int]: Returns the 1-based indices of the two flavors that add up to total_money. >>> find_flavors(4, [1, 4, 5, 3, 2]) (1, 4) >>> find_flavors(4, [2, 2, 4, 3]) (1, 2) def ice_cream_parlor(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[Tuple[int, int]]: Processes a list of test cases and finds the flavors for each case. t: number of test cases test_cases: a list of tuples (total_money, n, flavors) Returns a list of results for each test case >>> ice_cream_parlor(2, [(4, 5, [1, 4, 5, 3, 2]), (4, 4, [2, 2, 4, 3])]) [(1, 4), (1, 2)]","solution":"def find_flavors(total_money, flavors): Returns the 1-based indices of the two flavors that add up to total_money. flavor_map = {} for index, price in enumerate(flavors): complement = total_money - price if complement in flavor_map: return flavor_map[complement] + 1, index + 1 flavor_map[price] = index return None def ice_cream_parlor(t, test_cases): Processes a list of test cases and finds the flavors for each case. t: number of test cases test_cases: a list of tuples (total_money, n, flavors) Returns a list of results for each test case results = [] for total_money, n, flavors in test_cases: results.append(find_flavors(total_money, flavors)) return results"},{"question":"def calculate_average_temperature_variation(temperature_readings): Calculates the average temperature variation over a month. Args: temperature_readings: List of tuples where each tuple contains two floats representing the high and low temperature of a day. Returns: Float: Average temperature variation over the month. from solution import calculate_average_temperature_variation def test_average_temperature_variation_example(): temperature_readings = [ (15.5, 3.2), (21.1, 14.0), (19.9, 9.5), (10.5, -3.0) ] # (15.5-3.2) + (21.1-14.0) + (19.9-9.5) + (10.5+3.0) = 12.3 + 7.1 + 10.4 + 13.5 = 43.3 # Average = 43.3 / 4 = 10.825 assert round(calculate_average_temperature_variation(temperature_readings), 2) == 10.82 def test_no_variation(): temperature_readings = [ (10.0, 10.0), (8.0, 8.0), (15.0, 15.0) ] assert calculate_average_temperature_variation(temperature_readings) == 0.0 def test_single_day_reading(): temperature_readings = [ (20.0, 10.0) ] assert calculate_average_temperature_variation(temperature_readings) == 10.0 def test_all_negative_temperatures(): temperature_readings = [ (-10.0, -20.0), (-5.0, -15.0), (-8.0, -18.0) ] # (-10 - -20) + (-5 - -15) + (-8 - -18) = 10 + 10 + 10 = 30 # Average = 30 / 3 = 10.0 assert calculate_average_temperature_variation(temperature_readings) == 10.0 def test_mixed_temperatures(): temperature_readings = [ (10.5, -3.0), (-12.0, -20.0), (25.3, 5.7) ] # (10.5 - -3) + (-12 - -20) + (25.3 - 5.7) = 13.5 + 8 + 19.6 = 41.1 # Average = 41.1 / 3 = 13.7 assert round(calculate_average_temperature_variation(temperature_readings), 2) == 13.70","solution":"def calculate_average_temperature_variation(temperature_readings): Calculates the average temperature variation over a month. Args: temperature_readings: List of tuples where each tuple contains two floats representing the high and low temperature of a day. Returns: Float: Average temperature variation over the month. total_variation = 0.0 days = len(temperature_readings) for high, low in temperature_readings: variation = high - low total_variation += variation return total_variation / days"},{"question":"def encode_string(text: str) -> str: Encodes the string by replacing spaces with underscores and reversing the words. >>> encode_string(\\"hello world\\") == \\"olleh_dlrow\\" >>> encode_string(\\"programming is fun\\") == \\"gnimmargorp_si_nuf\\" >>> encode_string(\\"python challenge\\") == \\"nohtyp_egnellahc\\"","solution":"def encode_string(text): Encodes the string by replacing spaces with underscores and reversing the words. words = text.split(' ') reversed_words = [word[::-1] for word in words] return '_'.join(reversed_words)"},{"question":"def min_subarrays_needed(n: int, T: int, arr: List[int]) -> int: This function returns the minimum number of subarrays needed such that the sum of each subarray is as close to the target value T as possible. >>> min_subarrays_needed(5, 10, [1, 7, 3, 6, 2]) == 2 >>> min_subarrays_needed(4, 8, [4, 4, 4, 4]) == 2 >>> min_subarrays_needed(3, 15, [5, 5, 5]) == 1 from typing import List def test_example_case_1(): assert min_subarrays_needed(5, 10, [1, 7, 3, 6, 2]) == 2 def test_example_case_2(): assert min_subarrays_needed(4, 8, [4, 4, 4, 4]) == 2 def test_example_case_3(): assert min_subarrays_needed(3, 15, [5, 5, 5]) == 1 def test_case_with_single_element(): assert min_subarrays_needed(1, 5, [5]) == 1 def test_case_with_elements_greater_than_T(): assert min_subarrays_needed(3, 5, [6, 7, 8]) == 3 def test_case_with_large_T(): assert min_subarrays_needed(4, 100, [25, 25, 25, 25]) == 1 def test_edge_case_with_minimum_inputs(): assert min_subarrays_needed(1, 1, [1]) == 1","solution":"def min_subarrays_needed(n, T, arr): This function returns the minimum number of subarrays needed such that the sum of each subarray is as close to the target value T as possible. # Sort the array to make it easier to group numbers close to target sum arr.sort(reverse=True) subarrays = [] for num in arr: placed = False for subarray in subarrays: if sum(subarray) + num <= T: subarray.append(num) placed = True break if not placed: subarrays.append([num]) return len(subarrays) # Example Usage if __name__ == \\"__main__\\": # Example input n, T = 5, 10 arr = [1, 7, 3, 6, 2] print(min_subarrays_needed(n, T, arr)) # Output should be 2"},{"question":"def min_increasing_subsequences(M: int, B: List[int]) -> int: Returns the minimum number of strictly increasing contiguous subsequences. :param M: The length of the sequence :param B: The sequence of integers :return: The minimum number of strictly increasing contiguous subsequences >>> min_increasing_subsequences(5, [4, 2, 3, 1, 5]) 3 >>> min_increasing_subsequences(6, [1, 2, 3, 4, 5, 6]) 1 >>> min_increasing_subsequences(7, [10, 20, 30, 20, 40, 50, 30]) 3","solution":"def min_increasing_subsequences(M, B): Returns the minimum number of strictly increasing contiguous subsequences. if M == 0: return 0 count = 1 for i in range(1, M): if B[i] <= B[i - 1]: count += 1 return count"},{"question":"def count_distinct_substrings(n: int, s: str, k: int) -> int: Returns the number of distinct substrings of length k in the string s. >>> count_distinct_substrings(7, \\"abcdefg\\", 3) 5 >>> count_distinct_substrings(5, \\"aabaa\\", 2) 3","solution":"def count_distinct_substrings(n, s, k): Returns the number of distinct substrings of length k in the string s. distinct_substrings = set() for i in range(n - k + 1): substring = s[i:i + k] distinct_substrings.add(substring) return len(distinct_substrings)"},{"question":"import heapq from collections import defaultdict def dijkstra(n, edges, start, target): Calculate the minimum travel time from a given starting node to a target node using Dijkstra's algorithm. >>> dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 3), (5, 4, 2)], 1, 4) 7 >>> dijkstra(4, [(1, 2, 3), (2, 3, 4)], 1, 4) -1 >>> dijkstra(1, [], 1, 1) 0 >>> dijkstra(2, [(1, 2, 4)], 1, 2) 4 >>> dijkstra(6, [(1, 2, 7), (1, 3, 9), (1, 6, 14), (2, 3, 10), (2, 4, 15), (3, 4, 11), (3, 6, 2), (6, 5, 9), (4, 5, 6)], 1, 5) 20","solution":"import heapq from collections import defaultdict def dijkstra(n, edges, start, target): # Create the adjacency list graph = defaultdict(list) for u, v, w in edges: graph[u].append((v, w)) graph[v].append((u, w)) # Priority queue to keep track of minimum distances pq = [(0, start)] distances = {node: float('inf') for node in range(1, n + 1)} distances[start] = 0 visited = set() while pq: current_distance, current_node = heapq.heappop(pq) if current_node in visited: continue visited.add(current_node) for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < distances[neighbor]: distances[neighbor] = distance heapq.heappush(pq, (distance, neighbor)) return distances[target] if distances[target] != float('inf') else -1 # Example usage assert dijkstra(5, [(1, 2, 2), (1, 3, 4), (2, 3, 1), (3, 4, 7), (2, 5, 3), (5, 4, 2)], 1, 4) == 7"},{"question":"def distribute_tasks(n: int, capacities: List[int], m: int) -> Union[str, Tuple[str, List[int]]]: Distribute m tasks across n servers. Args: n (int): Number of servers. capacities (list): List of capacities for the servers. m (int): Number of tasks. Returns: Union[str, Tuple[str, List[int]]]: \\"Possible\\" followed by the task distribution or \\"Impossible\\". >>> distribute_tasks(3, [4, 2, 1], 6) (\\"Possible\\", [4, 2, 0]) >>> distribute_tasks(3, [3, 1, 2], 7) \\"Impossible\\"","solution":"def distribute_tasks(n, capacities, m): Distribute m tasks across n servers. Args: n (int): Number of servers. capacities (list): List of capacities for the servers. m (int): Number of tasks. Returns: str: \\"Possible\\" followed by the task distribution or \\"Impossible\\". if sum(capacities) < m: return \\"Impossible\\" result = [0] * n for i in range(n): if m > capacities[i]: result[i] = capacities[i] m -= capacities[i] else: result[i] = m m = 0 break return \\"Possible\\" if m == 0 else \\"Impossible\\", result if m == 0 else [] # Example usage: n = 3 capacities = [4, 2, 1] m = 6 print(distribute_tasks(n, capacities, m)) # Output: Possible [4, 2, 0] n = 3 capacities = [3, 1, 2] m = 7 print(distribute_tasks(n, capacities, m)) # Output: Impossible"},{"question":"def smallest_missing_positive(n, arr): Returns the smallest positive integer that does not occur in the list \`arr\`. >>> smallest_missing_positive(10, [3, 4, -1, 1, 6, 2, 7, 5, 8, -5]) 9 >>> smallest_missing_positive(5, [1, 2, 3, 4, 5]) 6 >>> smallest_missing_positive(6, [1, 2, 4, 5, 6, 7]) 3 >>> smallest_missing_positive(4, [-1, -2, -3, -4]) 1 >>> smallest_missing_positive(7, [-1, 1, 2, -2, 4, 5, 3]) 6 >>> smallest_missing_positive(1, [1]) 2 >>> smallest_missing_positive(1, [2]) 1 >>> smallest_missing_positive(10, [5, 6, 7, 8, 9, 10, 11, 12, 13, 14]) 1","solution":"def smallest_missing_positive(n, arr): Returns the smallest positive integer that does not occur in the list \`arr\`. present = [False] * (n + 1) for num in arr: if 1 <= num <= n: present[num] = True for i in range(1, n + 1): if not present[i]: return i return n + 1"},{"question":"def check_valid_sentence(sentence: str) -> str: Checks if the input string forms a valid sentence. A valid sentence should start with an uppercase letter, have a space after each comma (except no comma or space at the end), and end with a period. >>> check_valid_sentence(\\"Hello, world, this, is, an, example.\\") \\"VALID\\" >>> check_valid_sentence(\\"goodbye,world,see,you,later\\") \\"INVALID\\" >>> check_valid_sentence(\\"Another,Bad Example,\\") \\"INVALID\\" >>> check_valid_sentence(\\"This, is, a, valid, test\\") \\"INVALID\\" >>> check_valid_sentence(\\"Hello,world,this,is,incorrect.\\") \\"INVALID\\" >>> long_sentence = \\"A,\\" * 199 + \\"Z.\\" >>> check_valid_sentence(long_sentence) \\"INVALID\\" >>> check_valid_sentence(\\"Hello1, world2, this, is, invalid1.\\") \\"INVALID\\" >>> check_valid_sentence(\\"Thisisaverylongwordexceedingtwentychars, valid.\\") \\"INVALID\\" >>> check_valid_sentence(\\"A.\\") \\"VALID\\" >>> check_valid_sentence(\\"Hello, world.\\") \\"VALID\\" >>> sentence = \\"A\\"+\\"a\\"*19 + \\".\\" >>> check_valid_sentence(sentence) \\"VALID\\"","solution":"def check_valid_sentence(sentence): Checks if the input string forms a valid sentence. # Ensure the first letter is uppercase and ends with a period if not sentence[0].isupper() or not sentence.endswith('.'): return \\"INVALID\\" # Check specific comma and space pattern words = sentence[:-1].split(', ') # If split doesn't match the original length, it means the commas are not followed by spaces properly if len(', '.join(words) + '.') != len(sentence): return \\"INVALID\\" # Ensure all words are alphabetical and within length constraints for word in words: if not word.isalpha() or not (1 <= len(word) <= 20): return \\"INVALID\\" # Check for overall length if len(sentence) > 200: return \\"INVALID\\" return \\"VALID\\""},{"question":"def can_achieve_configuration(n, m, k): Determine if Lena can achieve a grid where every cell contains exactly k using subrectangle increments. Parameters: n (int): the number of rows in the grid. m (int): the number of columns in the grid. k (int): the target number to achieve in each cell. Returns: str: \\"YES\\" if it is possible to achieve the configuration, otherwise \\"NO\\". Examples: >>> can_achieve_configuration(2, 3, 2) \\"NO\\" >>> can_achieve_configuration(4, 4, 16) \\"YES\\" def test_example1(): assert can_achieve_configuration(2, 3, 2) == \\"NO\\" def test_example2(): assert can_achieve_configuration(4, 4, 16) == \\"YES\\" def test_k_is_multiple_of_product(): assert can_achieve_configuration(2, 3, 6) == \\"YES\\" def test_k_is_not_multiple_of_product(): assert can_achieve_configuration(5, 5, 23) == \\"NO\\" def test_smallest_grid(): assert can_achieve_configuration(1, 1, 1) == \\"YES\\" assert can_achieve_configuration(1, 1, 2) == \\"YES\\" def test_large_k(): assert can_achieve_configuration(10, 10, 1000000000) == \\"YES\\" assert can_achieve_configuration(10, 10, 999999999) == \\"NO\\"","solution":"def can_achieve_configuration(n, m, k): Determine if Lena can achieve a grid where every cell contains exactly k using subrectangle increments. Parameters: n (int): the number of rows in the grid. m (int): the number of columns in the grid. k (int): the target number to achieve in each cell. Returns: str: \\"YES\\" if it is possible to achieve the configuration, otherwise \\"NO\\". if k % (n * m) == 0: return \\"YES\\" return \\"NO\\""},{"question":"def max_stackable_boxes(n: int, boxes: List[Tuple[int, int]]) -> int: Find the maximum number of boxes that can be stacked where each box is strictly smaller in both dimensions than the box below it. >>> max_stackable_boxes(5, [(4, 5), (3, 4), (2, 3), (1, 2), (3, 2)]) 4 >>> max_stackable_boxes(1, [(1, 1)]) 1","solution":"def max_stackable_boxes(n, boxes): # Sort the boxes based on height (primary) and width (secondary) boxes.sort(key=lambda x: (x[0], x[1])) # Initialize an array for dynamic programming dp = [1] * n # Apply the LIS-based logic on the sorted boxes for i in range(n): for j in range(i): if boxes[i][0] > boxes[j][0] and boxes[i][1] > boxes[j][1]: dp[i] = max(dp[i], dp[j] + 1) return max(dp)"},{"question":"def shortest_subarray_with_evans_odds(n: int, x: int, y: int, a: List[int]) -> int: Find the length of the shortest subarray that contains at least x even numbers and at least y odd numbers. >>> shortest_subarray_with_evans_odds(7, 2, 3, [1, 2, 3, 4, 5, 6, 7]) 5 >>> shortest_subarray_with_evans_odds(5, 3, 1, [2, 4, 6, 8, 10]) -1","solution":"def shortest_subarray_with_evans_odds(n, x, y, a): def is_even(num): return num % 2 == 0 shortest_length = float('inf') left = 0 even_count = 0 odd_count = 0 for right in range(n): if is_even(a[right]): even_count += 1 else: odd_count += 1 while even_count >= x and odd_count >= y: shortest_length = min(shortest_length, right - left + 1) if is_even(a[left]): even_count -= 1 else: odd_count -= 1 left += 1 if shortest_length == float('inf'): return -1 return shortest_length # Example usage: # print(shortest_subarray_with_evans_odds(7, 2, 3, [1, 2, 3, 4, 5, 6, 7])) # Output: 5 # print(shortest_subarray_with_evans_odds(5, 3, 1, [2, 4, 6, 8, 10])) # Output: -1"},{"question":"import heapq from collections import defaultdict def shortest_travel_times(n: int, m: int, routes: List[Tuple[int, int, int]]) -> List[int]: Calculate the shortest travel times from planet 1 to all other planets in the star system. Args: n : int : Number of planets m : int : Number of space routes routes : List[Tuple[int, int, int]] : Each tuple contains three integers u, v, and l, where u and v denote the planets connected by the route and l denotes the travel time. Returns: List[int] : A list of n-1 integers, where the i-th integer denotes the shortest travel time from planet 1 to planet i+1. If a planet is not reachable from planet 1, output -1 for that planet instead. Example: >>> shortest_travel_times(5, 7, [(1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (3, 5, 7), (4, 5, 1)]) [4, 2, 5, 6] >>> shortest_travel_times(4, 2, [(1, 2, 3), (3, 4, 5)]) [3, -1, -1] from solution import shortest_travel_times def test_basic_case(): n, m = 5, 7 routes = [ (1, 2, 4), (1, 3, 2), (2, 3, 5), (2, 4, 10), (3, 4, 3), (3, 5, 7), (4, 5, 1) ] assert shortest_travel_times(n, m, routes) == [4, 2, 5, 6] def test_disconnected_nodes(): n, m = 4, 2 routes = [ (1, 2, 3), (3, 4, 5) ] assert shortest_travel_times(n, m, routes) == [3, -1, -1] def test_single_path(): n, m = 4, 3 routes = [ (1, 2, 3), (2, 3, 4), (3, 4, 5) ] assert shortest_travel_times(n, m, routes) == [3, 7, 12] def test_direct_routes(): n, m = 3, 2 routes = [ (1, 2, 1), (2, 3, 1) ] assert shortest_travel_times(n, m, routes) == [1, 2] def test_large_weights(): n, m = 3, 3 routes = [ (1, 2, 1000000000), (2, 3, 1000000000), (1, 3, 1000000000) ] assert shortest_travel_times(n, m, routes) == [1000000000, 1000000000] def test_no_routes(): n, m = 2, 0 routes = [] assert shortest_travel_times(n, m, routes) == [-1]","solution":"import heapq from collections import defaultdict def shortest_travel_times(n, m, routes): graph = defaultdict(list) for u, v, l in routes: graph[u].append((v, l)) graph[v].append((u, l)) dist = {i: float('inf') for i in range(1, n + 1)} dist[1] = 0 priority_queue = [(0, 1)] # (distance, node) while priority_queue: current_distance, current_node = heapq.heappop(priority_queue) if current_distance > dist[current_node]: continue for neighbor, weight in graph[current_node]: distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(priority_queue, (distance, neighbor)) return [dist[i] if dist[i] != float('inf') else -1 for i in range(2, n + 1)]"},{"question":"def is_valid_binary_string(s: str) -> str: Returns \\"VALID\\" if the binary string s is valid according to the criteria, otherwise returns \\"INVALID\\". pass def validate_binary_strings(test_cases: List[str]) -> List[str]: results = [] for s in test_cases: results.append(is_valid_binary_string(s)) return results if __name__ == '__main__': from typing import List import sys input = sys.stdin.read data = input().split() T = int(data[0]) test_cases = data[1:T+1] results = validate_binary_strings(test_cases) for result in results: print(result)","solution":"def is_valid_binary_string(s): Returns \\"VALID\\" if the binary string s is valid according to the criteria, otherwise returns \\"INVALID\\". i = 0 n = len(s) while i < n: count_1 = 0 count_0 = 0 # Count consecutive 1's while i < n and s[i] == '1': count_1 += 1 i += 1 # Count consecutive 0's while i < n and s[i] == '0': count_0 += 1 i += 1 if count_1 != count_0 or (count_1 == 0 and count_0 == 0): return \\"INVALID\\" return \\"VALID\\" def validate_binary_strings(test_cases): results = [] for s in test_cases: results.append(is_valid_binary_string(s)) return results"},{"question":"def find_employee_projects(employee_projects: List[Tuple[int, int]], queries: List[int]) -> List[str]: This function takes a list of employee-project pairs and a list of queries for employee IDs. It returns the project IDs the employee is involved in. >>> find_employee_projects([(101, 202), (101, 303), (102, 202), (103, 303)], [101, 104]) ['202 303', 'No Data'] >>> find_employee_projects([(101, 1000), (101, 1001), (102, 202), (102, 203)], [102, 101]) ['202 203', '1000 1001'] >>> find_employee_projects([(101, 500), (101, 600), (103, 303)], [101, 103, 105]) ['500 600', '303', 'No Data'] >>> find_employee_projects([(100, 700), (100, 800), (101, 900)], [100, 101]) ['700 800', '900'] >>> find_employee_projects([], [101]) ['No Data']","solution":"def find_employee_projects(employee_projects, queries): This function takes a list of employee-project pairs and a list of queries for employee IDs. It returns the projects each queried employee is involved in. from collections import defaultdict # Dictionary to store the projects for each employee employee_dict = defaultdict(set) # Parse the employee-project pairs and fill the dictionary for emp_id, proj_id in employee_projects: employee_dict[emp_id].add(proj_id) results = [] # Process each query to get the projects for query in queries: if query in employee_dict: results.append(\\" \\".join(map(str, sorted(employee_dict[query])))) else: results.append(\\"No Data\\") return results"},{"question":"def is_palindrome(s: str) -> bool: Check if the given string s is a palindrome. >>> is_palindrome(\\"Was it a car or a cat I saw\\") True >>> is_palindrome(\\"Hello, World!\\") False pass def check_palindromes(input_lines: List[str]) -> List[str]: Given a list of input strings, check each one if it's a palindrome and return a corresponding list of results. >>> check_palindromes([ ... \\"Was it a car or a cat I saw\\", ... \\"Madam In Eden, Im Adam\\", ... \\"Hello, World!\\", ... \\"END\\"]) [\\"Palindrome\\", \\"Palindrome\\", \\"Not a Palindrome\\"] pass","solution":"def is_palindrome(s): Check if the given string s is a palindrome. # Remove all non-alphanumeric characters and convert to lower case normalized = ''.join(char.lower() for char in s if char.isalnum()) # Compare the normalized string with its reverse return normalized == normalized[::-1] def check_palindromes(input_lines): Given a list of input strings, check each one if it's a palindrome and return a corresponding list of results. results = [] for line in input_lines: if line.strip() == \\"END\\": break if is_palindrome(line): results.append(\\"Palindrome\\") else: results.append(\\"Not a Palindrome\\") return results"},{"question":"def checkSubarraySum(nums: List[int], k: int) -> bool: Determine if there exists a contiguous subarray of length at least 2 that sums up to an integer multiple of a given number k. Args: nums (List[int]): List of integers. k (int): The integer to check multiples of. Returns: bool: True if such a subarray exists, otherwise False. Examples: >>> checkSubarraySum([23, 2, 4, 6, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 6) True >>> checkSubarraySum([23, 2, 6, 4, 7], 13) False","solution":"def checkSubarraySum(nums, k): # Checking for the presence of a subarray with at least 2 elements if len(nums) < 2: return False # Dictionary to store the remainder and index remainder_dict = {0: -1} total_sum = 0 for i, num in enumerate(nums): total_sum += num remainder = total_sum % k if k != 0 else total_sum if remainder in remainder_dict: if i - remainder_dict[remainder] > 1: return True else: remainder_dict[remainder] = i return False"},{"question":"from typing import List, Tuple def manage_inventory(N: int, initial_stock: List[int], transactions: List[Tuple[str, int, int]]) -> List[int]: Manages the inventory of desserts based on the given transactions. Parameters: N (int): Number of dessert types. initial_stock (list of int): Initial number of units for each dessert type. transactions (list of tuples): Each tuple contains a transaction in the form ('S' or 'R', dessert_type_index, units) Returns: list of int: Final number of units for each type of dessert. >>> manage_inventory(3, [10, 4, 7], [('S', 1, 5), ('R', 2, 2), ('S', 3, 3), ('R', 1, 1), ('S', 2, 10)]) [14, 12, 10] >>> manage_inventory(2, [5, 8], [('R', 1, 2), ('S', 2, 4), ('R', 2, 1)]) [3, 11] >>> manage_inventory(3, [10, 20, 30], []) [10, 20, 30] >>> manage_inventory(2, [5, 5], [('S', 1, 5), ('S', 2, 10), ('S', 1, 3)]) [13, 15] >>> manage_inventory(2, [20, 30], [('R', 1, 5), ('R', 2, 10), ('R', 1, 3)]) [12, 20]","solution":"def manage_inventory(N, initial_stock, transactions): Manages the inventory of desserts based on the given transactions. Parameters: N (int): Number of dessert types. initial_stock (list of int): Initial number of units for each dessert type. transactions (list of tuples): Each tuple contains a transaction in the form ('S' or 'R', dessert_type_index, units) Returns: list of int: Final number of units for each type of dessert. # Initialize stock based on initial values stock = initial_stock[:] # Process each transaction for transaction in transactions: type_trx, dessert_type, units = transaction if type_trx == 'S': stock[dessert_type - 1] += units elif type_trx == 'R': stock[dessert_type - 1] -= units return stock"},{"question":"def count_primes_in_range(A: int, B: int) -> int: Returns the number of prime numbers in the given range [A, B] inclusive. >>> count_primes_in_range(10, 20) 4 >>> count_primes_in_range(1, 10) 4 >>> count_primes_in_range(10, 10) 0 >>> count_primes_in_range(11, 11) 1 >>> count_primes_in_range(1, 1) 0 >>> count_primes_in_range(17, 29) 4 >>> count_primes_in_range(50, 60) 2 >>> count_primes_in_range(1, 1000000) > 0","solution":"def count_primes_in_range(A, B): Returns the number of prime numbers in the given range [A, B] inclusive. if A > B: return 0 sieve = [True] * (B + 1) sieve[0] = sieve[1] = False # 0 and 1 are not primes for start in range(2, int(B**0.5) + 1): if sieve[start]: for multiple in range(start*start, B+1, start): sieve[multiple] = False count = 0 for number in range(A, B+1): if sieve[number]: count += 1 return count"},{"question":"def detect_cycle(n: int, m: int, connections: List[Tuple[int, int]]) -> str: Determine whether the proposed set of subway lines contains any cycles. >>> detect_cycle(4, 3, [(1, 2), (2, 3), (3, 4)]) \\"NO\\" >>> detect_cycle(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) \\"YES\\" >>> detect_cycle(2, 1, [(1, 2)]) \\"NO\\" >>> detect_cycle(3, 0, []) \\"NO\\" >>> detect_cycle(6, 4, [(1, 2), (2, 3), (4, 5), (5, 6)]) \\"NO\\" >>> detect_cycle(6, 7, [(1, 2), (2, 3), (3, 4), (4, 2), (5, 6), (6, 3), (4, 5)]) \\"YES\\" from typing import List, Tuple","solution":"def detect_cycle(n, m, connections): from collections import defaultdict def dfs(node, parent): visited.add(node) for neighbor in graph[node]: if neighbor not in visited: if dfs(neighbor, node): return True elif neighbor != parent: return True return False graph = defaultdict(list) for u, v in connections: graph[u].append(v) graph[v].append(u) visited = set() for station in range(1, n + 1): if station not in visited: if dfs(station, -1): return \\"YES\\" return \\"NO\\""},{"question":"def is_treasure_code(sequence: List[int]) -> str: Determines if there exists a permutation of the sequence that can be arranged in a strictly increasing followed by strictly decreasing order. >>> is_treasure_code([1, 3, 5, 5, 3, 1]) == \\"YES\\" >>> is_treasure_code([1, 2, 3]) == \\"YES\\" >>> is_treasure_code([3, 3, 3]) == \\"NO\\" >>> is_treasure_code([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == \\"YES\\" >>> is_treasure_code([1, 2, 1, 2, 1, 2, 1, 2]) == \\"NO\\"","solution":"def is_treasure_code(sequence): Determines if there exists a permutation of the sequence that can be arranged in a strictly increasing followed by strictly decreasing order. Parameters: sequence (list of int): A list of integers representing the sequence. Returns: str: \\"YES\\" if such a permutation exists, \\"NO\\" otherwise. from collections import Counter # Create a frequency counter counter = Counter(sequence) # Traverse through the elements in sorted order and ensure that this element # never appears more than twice (once in increasing and once in decreasing) increasing_part = set() for key in sorted(counter): freq = counter[key] if freq > 2: return \\"NO\\" increasing_part.add(key) return \\"YES\\""},{"question":"def min_swaps_to_sort(arr: List[int]) -> int: Given the initial sequence of power levels of the wizards, determine the minimum number of swaps required to arrange the wizards in non-decreasing order. >>> min_swaps_to_sort([5, 4, 3, 2, 1]) 10 >>> min_swaps_to_sort([1, 5, 3, 2, 4]) 4 >>> min_swaps_to_sort([2, 3, 1]) 2 >>> min_swaps_to_sort([1]) 0 >>> min_swaps_to_sort([1, 2, 3, 4, 5]) 0 >>> min_swaps_to_sort([4, 3, 2, 1]) 6 >>> min_swaps_to_sort([1000000000, 999999999, 123456789, 10]) 6","solution":"def merge_count_split_inv(arr, temp_arr, left, mid, right): i = left # Starting index for left subarray j = mid + 1 # Starting index for right subarray k = left # Starting index to be sorted inv_count = 0 while i <= mid and j <= right: if arr[i] <= arr[j]: temp_arr[k] = arr[i] i += 1 else: temp_arr[k] = arr[j] inv_count += (mid-i + 1) # Number of inversions j += 1 k += 1 while i <= mid: temp_arr[k] = arr[i] i += 1 k += 1 while j <= right: temp_arr[k] = arr[j] j += 1 k += 1 for i in range(left, right + 1): arr[i] = temp_arr[i] return inv_count def merge_sort_and_count(arr, temp_arr, left, right): inv_count = 0 if left < right: mid = (left + right)//2 inv_count += merge_sort_and_count(arr, temp_arr, left, mid) inv_count += merge_sort_and_count(arr, temp_arr, mid + 1, right) inv_count += merge_count_split_inv(arr, temp_arr, left, mid, right) return inv_count def min_swaps_to_sort(arr): n = len(arr) temp_arr = [0]*n return merge_sort_and_count(arr, temp_arr, 0, n-1)"},{"question":"def count_buildings_reaching_k(n: int, m: int, streets: list, k: int) -> int: Calculate the number of buildings that can start from and reach exactly k other buildings. >>> count_buildings_reaching_k(4, 4, [(1, 2), (2, 3), (3, 4), (1, 3)], 2) 1 >>> count_buildings_reaching_k(5, 3, [(1, 2), (2, 3), (4, 5)], 1) 2 >>> count_buildings_reaching_k(5, 0, [], 0) 5 >>> count_buildings_reaching_k(4, 6, [(1, 2), (1, 3), (1, 4), (2, 3), (3, 4), (2, 4)], 3) 1 >>> count_buildings_reaching_k(5, 5, [(1, 2), (2, 3), (3, 4), (4, 5), (5, 1)], 3) 0","solution":"def count_buildings_reaching_k(n, m, streets, k): from collections import defaultdict, deque def bfs_count_reachable(start): visited = set() queue = deque([start]) while queue: node = queue.popleft() for neighbour in adj_list[node]: if neighbour not in visited: visited.add(neighbour) queue.append(neighbour) return len(visited) adj_list = defaultdict(list) for u, v in streets: adj_list[u].append(v) count = 0 for building in range(1, n+1): if bfs_count_reachable(building) == k: count += 1 return count"},{"question":"def winner_of_the_game(t: int, test_cases: List[str]) -> List[str]: Determine who will win the game if both Alice and Bob play optimally >>> winner_of_the_game(3, [\\"aaaa\\", \\"bobob\\", \\"abcde\\"]) [\\"Bob\\", \\"Alice\\", \\"Alice\\"] >>> winner_of_the_game(1, [\\"a\\"]) [\\"Alice\\"] >>> winner_of_the_game(2, [\\"ab\\", \\"bc\\"]) [\\"Bob\\", \\"Bob\\"] >>> winner_of_the_game(4, [\\"x\\", \\"yy\\", \\"yyy\\", \\"zzzz\\"]) [\\"Alice\\", \\"Bob\\", \\"Alice\\", \\"Bob\\"] >>> winner_of_the_game(2, [\\"test\\", \\"game\\"]) [\\"Bob\\", \\"Bob\\"]","solution":"def winner_of_the_game(t, test_cases): results = [] for s in test_cases: # Alice wins if the length of the string is odd, Bob wins if the length is even if len(s) % 2 != 0: results.append(\\"Alice\\") else: results.append(\\"Bob\\") return results"},{"question":"def decode_message(k: int, message: str) -> str: Decodes the given message by shifting each letter by k positions backwards in the alphabet. >>> decode_message(2, 'cde') == 'abc' >>> decode_message(5, 'zab') == 'uvw'","solution":"def decode_message(k, message): Decodes the given message by shifting each letter by k positions backwards in the alphabet. Parameters: k (int): the number of positions to shift each letter backwards. message (str): the encrypted message composed of lowercase Latin letters. Returns: str: the decoded message. decoded_message = [] for char in message: new_char = chr((ord(char) - ord('a') - k) % 26 + ord('a')) decoded_message.append(new_char) return ''.join(decoded_message)"},{"question":"from typing import List def longest_palindrome_length(s: str) -> int: Returns the length of the longest palindrome that can be formed using the characters in the given string s. pass # Replace this with the implementation def process_inputs(test_cases: List[str]) -> List[int]: For each test case, returns the length of the longest palindrome that can be formed using the characters of the given string. >>> process_inputs([\\"abccccdd\\"]) [7] >>> process_inputs([\\"aabb\\"]) [4] pass # Replace this with the implementation def test_case_1(): assert process_inputs([\\"abccccdd\\"]) == [7] def test_case_2(): assert process_inputs([\\"aabb\\"]) == [4] def test_multiple_cases(): assert process_inputs([\\"abccccdd\\", \\"aabb\\"]) == [7, 4] def test_single_character(): assert process_inputs([\\"a\\"]) == [1] def test_no_repeating_characters(): assert process_inputs([\\"abcdefg\\"]) == [1] def test_all_characters_even_count(): assert process_inputs([\\"aabbcc\\"]) == [6] def test_mixed_even_odd_characters(): assert process_inputs([\\"aabbccd\\"]) == [7] def test_large_input(): input_str = 'a' * 1000 assert process_inputs([input_str]) == [1000]","solution":"def longest_palindrome_length(s): Returns the length of the longest palindrome that can be formed using the characters in the given string s. from collections import Counter char_count = Counter(s) length = 0 odd_count_found = False for count in char_count.values(): if count % 2 == 0: length += count else: length += count - 1 odd_count_found = True # If there was any character with an odd count, we can put one of them in the middle of the palindrome if odd_count_found: length += 1 return length def process_inputs(test_cases): results = [] for s in test_cases: results.append(longest_palindrome_length(s)) return results"},{"question":"def max_altitude_gain(n: int, altitudes: List[int]) -> int: Calculate the maximum altitude gain possible for Thomas' hike. Thomas can only move from left to right. Parameters: n (int): Number of peaks altitudes (list of int): List of altitudes of the peaks Returns: int: Maximum altitude gain >>> max_altitude_gain(5, [2, 4, 3, 6, 5]) 4 >>> max_altitude_gain(7, [10, 1, 3, 2, 5, 4, 7]) 6 >>> max_altitude_gain(4, [1, 2, 3, 4]) 3 >>> max_altitude_gain(4, [4, 3, 2, 1]) 0 >>> max_altitude_gain(1, [5]) 0 >>> max_altitude_gain(2, [1, 5]) 4 >>> max_altitude_gain(2, [5, 1]) 0 pass","solution":"def max_altitude_gain(n, altitudes): This function calculates the maximum altitude gain possible for Thomas' hike. Thomas can only move from left to right. Parameters: n (int): Number of peaks altitudes (list of int): List of altitudes of the peaks Returns: int: Maximum altitude gain # Initialize the minimum altitude encountered so far. min_altitude = altitudes[0] max_gain = 0 for altitude in altitudes: # Update the maximum gain max_gain = max(max_gain, altitude - min_altitude) # Update the minimum altitude min_altitude = min(min_altitude, altitude) return max_gain"},{"question":"def draw_symmetric_shapes(T: int, shapes: List[int]) -> str: Generates symmetric shapes using vertical lines of stars for given values of N. >>> draw_symmetric_shapes(1, [3]) '*n**n*n' >>> draw_symmetric_shapes(2, [3, 5]) '*n**n*nn*n**n***n**n*n' >>> draw_symmetric_shapes(1, [1]) '*n'","solution":"def draw_symmetric_shapes(T, shapes): results = [] for N in shapes: shape = [] mid = (N // 2) + 1 for i in range(1, mid + 1): shape.append('*' * i) for i in range(mid - 1, 0, -1): shape.append('*' * i) results.append('n'.join(shape)) return 'nn'.join(results)"},{"question":"def longest_patrol_route(N: int, M: int, heights: List[List[int]]) -> int: Function to find the length of the longest valid patrol route in the ice field. >>> longest_patrol_route(3, 3, [[1, 2, 4], [6, 5, 2], [3, 8, 7]]) == 4 >>> longest_patrol_route(4, 5, [[1, 2, 3, 2, 1], [6, 7, 4, 3, 5], [3, 1, 8, 9, 7], [2, 1, 4, 6, 5]]) == 6 >>> longest_patrol_route(1, 5, [[1, 2, 3, 4, 5]]) == 5 >>> longest_patrol_route(5, 1, [[1], [3], [2], [4], [5]]) == 3 >>> longest_patrol_route(3, 3, [[5, 5, 5], [5, 5, 5], [5, 5, 5]]) == 1 >>> longest_patrol_route(2, 2, [[1000000000, 2], [1, 1000000000]]) == 2 pass","solution":"def longest_patrol_route(N, M, heights): Function to find the length of the longest valid patrol route in the ice field. Parameters: N (int): Number of rows. M (int): Number of columns. heights (List[List[int]]): 2D-list representing heights. Returns: int: Length of the longest valid patrol route. def dfs(x, y): if memo[x][y] != -1: return memo[x][y] directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] max_length = 1 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < N and 0 <= ny < M and heights[nx][ny] > heights[x][y]: max_length = max(max_length, 1 + dfs(nx, ny)) memo[x][y] = max_length return max_length memo = [[-1] * M for _ in range(N)] longest_route = 0 for i in range(N): for j in range(M): longest_route = max(longest_route, dfs(i, j)) return longest_route"},{"question":"def sort_strings_by_length(test_cases): Sorts strings based on their lengths in descending order. If two strings have the same length, they maintain their original order. :param test_cases: List of test cases where each test case is a tuple (N, list_of_strings) :return: A list of sorted strings for each test case. >>> sort_strings_by_length([(4, [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"grapefruit\\"]), (3, [\\"car\\", \\"bike\\", \\"bus\\"])]) [\\"grapefruit banana apple kiwi\\", \\"bike car bus\\"] >>> sort_strings_by_length([(2, [\\"a\\", \\"ab\\"])]) [\\"ab a\\"] >>> sort_strings_by_length([(3, [\\"car\\", \\"bar\\", \\"star\\"])]) [\\"star car bar\\"] >>> sort_strings_by_length([(5, [\\"elephant\\", \\"dog\\", \\"hippopotamus\\", \\"cat\\", \\"giraffe\\"])]) [\\"hippopotamus elephant giraffe dog cat\\"] pass def parse_input(input_data): Parses the input data and returns the list of test cases. :param input_data: The input data as a string. :return: A list of tuples representing test cases. >>> parse_input(\\"2n4napplenbananankiwingrapefruitn3ncarnbikenbus\\") [(4, [\\"apple\\", \\"banana\\", \\"kiwi\\", \\"grapefruit\\"]), (3, [\\"car\\", \\"bike\\", \\"bus\\"])] pass","solution":"def sort_strings_by_length(test_cases): Sorts strings based on their lengths in descending order. If two strings have the same length, they maintain their original order. :param test_cases: List of test cases where each test case is a tuple (N, list_of_strings) :return: A list of sorted strings for each test case. sorted_cases = [] for case in test_cases: N, strings = case sorted_strings = sorted(strings, key=lambda x: (-len(x), strings.index(x))) sorted_cases.append(\\" \\".join(sorted_strings)) return sorted_cases def parse_input(input_data): Parses the input data and returns the list of test cases. :param input_data: The input data as a string. :return: A list of tuples representing test cases. lines = input_data.strip().split('n') num_test_cases = int(lines[0]) index = 1 test_cases = [] for _ in range(num_test_cases): N = int(lines[index]) strings = lines[index + 1: index + 1 + N] test_cases.append((N, strings)) index += 1 + N return test_cases"},{"question":"from typing import List def max_contiguous_revenue(N: int, R: List[int]) -> int: Returns the highest possible total revenue from any contiguous subsequence of booths. Args: N (int): The number of game booths. R (List[int]): The revenue of each game booth. Returns: int: The highest possible total revenue from any contiguous subsequence of booths. Examples: >>> max_contiguous_revenue(4, [4, -1, 2, 1]) 6 >>> max_contiguous_revenue(5, [1, 2, 3, -2, 5]) 9 >>> max_contiguous_revenue(3, [-2, 1, 3]) 4","solution":"def max_contiguous_revenue(N, R): Returns the highest possible total revenue from any contiguous subsequence of booths. max_current = max_global = R[0] for i in range(1, N): max_current = max(R[i], max_current + R[i]) if max_current > max_global: max_global = max_current return max_global"},{"question":"def max_non_overlapping_square_sum(n: int, grid: List[List[int]]) -> int: Find the largest sum of integers by selecting a subset of non-overlapping squares from the grid. >>> max_non_overlapping_square_sum(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 >>> max_non_overlapping_square_sum(2, [[10, 10], [10, 10]]) == 40 pass from typing import List def test_case_1(): assert max_non_overlapping_square_sum(3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == 45 def test_case_2(): assert max_non_overlapping_square_sum(2, [[10, 10], [10, 10]]) == 40 def test_case_3(): assert max_non_overlapping_square_sum(4, [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]) == 16 def test_case_4(): assert max_non_overlapping_square_sum(1, [[10000]]) == 10000 def test_case_5(): assert max_non_overlapping_square_sum(2, [[1, 2], [3, 4]]) == 10 def test_case_6(): assert max_non_overlapping_square_sum(3, [[100, 200, 300], [400, 500, 600], [700, 800, 900]]) == 4500","solution":"def max_non_overlapping_square_sum(n, grid): max_sum = 0 for size in range(1, n + 1): for i in range(n - size + 1): for j in range(n - size + 1): current_sum = sum([grid[x][j:j+size] for x in range(i, i + size)], []) max_sum = max(max_sum, sum(current_sum)) return max_sum # Example usage: # n = 3 # grid = [ # [1, 2, 3], # [4, 5, 6], # [7, 8, 9] # ] # print(max_non_overlapping_square_sum(n, grid)) # Output should be 45"},{"question":"def count_ride_matches(n: int, m: int, ride_thrills: List[int], friend_prefs: List[int]) -> List[int]: Returns a list where each element is the count of rides matching the corresponding friend's thrill level. :param n: Number of rides :param m: Number of friends :param ride_thrills: List of integers representing the thrill ratings of the rides :param friend_prefs: List of integers representing the thrill levels of the friends :return: List of integers where each element is the count of rides matching the corresponding friend's thrill level >>> count_ride_matches(5, 3, [5, 3, 7, 5, 8], [5, 7, 2]) [2, 1, 0] >>> count_ride_matches(4, 1, [2, 2, 2, 2], [2]) [4] >>> count_ride_matches(4, 2, [1, 3, 5, 7], [2, 4]) [0, 0] >>> count_ride_matches(6, 3, [1, 2, 3, 3, 2, 1], [1, 2, 3]) [2, 2, 2] >>> count_ride_matches(10, 2, [5]*5 + [1]*5, [5, 1]) [5, 5]","solution":"def count_ride_matches(n, m, ride_thrills, friend_prefs): Returns a list where each element is the count of rides matching the corresponding friend's thrill level. # Create a dictionary to count the frequencies of each thrill level in ride_thrills thrill_count = {} for thrill in ride_thrills: if thrill in thrill_count: thrill_count[thrill] += 1 else: thrill_count[thrill] = 1 # Create a list to store the result of matches for each friend result = [] for pref in friend_prefs: if pref in thrill_count: result.append(thrill_count[pref]) else: result.append(0) return result"},{"question":"def can_partition(nums): Determines if the list nums can be partitioned into two subsets with equal sum. >>> can_partition([1, 5, 11, 5]) True >>> can_partition([1, 2, 3, 5]) False def partition_list(input_list): Takes lists of integers as input and returns the partition possibility for each list. >>> partition_list([[1, 5, 11, 5], [1, 2, 3, 5]]) [\\"true\\", \\"false\\"] >>> partition_list([[1], [1, 1], [1, 2, 3, 4, 5, 6, 7], [100, 100, 100, 100, 100, 100, 100]]) [\\"false\\", \\"true\\", \\"true\\", \\"false\\"]","solution":"def can_partition(nums): Determines if the list nums can be partitioned into two subsets with equal sum. total_sum = sum(nums) if total_sum % 2 != 0: return False target_sum = total_sum // 2 n = len(nums) dp = [False] * (target_sum + 1) dp[0] = True for num in nums: for i in range(target_sum, num - 1, -1): dp[i] = dp[i] or dp[i - num] return dp[target_sum] def partition_list(input_list): Takes lists of integers as input and returns the partition possibility for each list. results = [] for nums in input_list: if can_partition(nums): results.append(\\"true\\") else: results.append(\\"false\\") return results"},{"question":"def find_winner(n: int, k: int, votes: List[List[int]]) -> Union[int, str]: Determines the overall winner based on majority votes across multiple voting stations. Args: n (int): Number of voting stations. k (int): Number of candidates. votes (list of lists of int): List of votes from each station. Returns: int or str: The winning candidate number if there's a winner, otherwise \\"Tie\\". >>> find_winner(3, 3, [[1, 2, 3, 1], [1, 1, 2, 2], [3, 1, 1, 1]]) 1 >>> find_winner(2, 2, [[1, 2], [2, 2, 1]]) 2 >>> find_winner(2, 3, [[1, 2, 3], [2, 2, 3]]) \\"Tie\\" from typing import List, Union def test_example_1(): n = 3 k = 3 votes = [ [1, 2, 3, 1], [1, 1, 2, 2], [3, 1, 1, 1] ] assert find_winner(n, k, votes) == 1 def test_example_2(): n = 2 k = 2 votes = [ [1, 2], [2, 2, 1] ] assert find_winner(n, k, votes) == 2 def test_example_3(): n = 2 k = 3 votes = [ [1, 2, 3], [2, 2, 3] ] assert find_winner(n, k, votes) == \\"Tie\\" def test_tie_case(): n = 3 k = 2 votes = [ [1, 2], [1, 2], [1, 2] ] assert find_winner(n, k, votes) == \\"Tie\\" def test_single_station(): n = 1 k = 3 votes = [ [1, 2, 3, 1, 1] ] assert find_winner(n, k, votes) == 1 def test_single_candidate(): n = 2 k = 1 votes = [ [1, 1, 1], [1, 1] ] assert find_winner(n, k, votes) == 1","solution":"def find_winner(n, k, votes): Determines the overall winner based on majority votes across multiple voting stations. Args: n (int): Number of voting stations. k (int): Number of candidates. votes (list of lists of int): List of votes from each station. Returns: int or str: The winning candidate number if there's a winner, otherwise \\"Tie\\". from collections import defaultdict # Initialize vote counter for each candidate total_votes = defaultdict(int) # Aggregate votes from all stations for station_votes in votes: for vote in station_votes: total_votes[vote] += 1 # Calculate total number of votes total_number_of_votes = sum(total_votes.values()) # Find if any candidate has more than half of the total votes half_votes = total_number_of_votes / 2 for candidate in range(1, k+1): if total_votes[candidate] > half_votes: return candidate return \\"Tie\\""},{"question":"def pyramid_blocks(L: int) -> int: Returns the total number of blocks required to build a pyramid with L levels. >>> pyramid_blocks(1) 1 >>> pyramid_blocks(3) 6 >>> pyramid_blocks(5) 15 >>> pyramid_blocks(10) 55 >>> pyramid_blocks(100000) 5000050000 >>> pyramid_blocks(0) 0","solution":"def pyramid_blocks(L): Returns the total number of blocks required to build a pyramid with L levels. return L * (L + 1) // 2"},{"question":"def items_to_restock(N: int, T: int, items: List[Tuple[str, int]]) -> List[str]: Determine which items need restocking based on a minimum stock threshold. Parameters: - N: int, the number of different items - T: int, the minimum stock threshold - items: List[Tuple[str, int]], a list of tuples where each tuple contains the item ID and quantity Returns: - List[str], a list of item IDs that need restocking >>> items_to_restock(5, 10, [(\\"item1\\", 5), (\\"item2\\", 15), (\\"item3\\", 8), (\\"item4\\", 10), (\\"item5\\", 0)]) [\\"item1\\", \\"item3\\", \\"item5\\"] >>> items_to_restock(3, 5, [(\\"itemA\\", 3), (\\"itemB\\", 6), (\\"itemC\\", 2)]) [\\"itemA\\", \\"itemC\\"] from typing import List, Tuple def test_items_to_restock_empty_list(): assert items_to_restock(0, 10, []) == [] def test_items_to_restock_no_restock_needed(): items = [(\\"item1\\", 10), (\\"item2\\", 15), (\\"item3\\", 20)] assert items_to_restock(3, 10, items) == [] def test_items_to_restock_some_restock_needed(): items = [(\\"item1\\", 5), (\\"item2\\", 15), (\\"item3\\", 8), (\\"item4\\", 10), (\\"item5\\", 0)] assert items_to_restock(5, 10, items) == [\\"item1\\", \\"item3\\", \\"item5\\"] def test_items_to_restock_all_restock_needed(): items = [(\\"itemA\\", 2), (\\"itemB\\", 3), (\\"itemC\\", 1), (\\"itemD\\", 4)] assert items_to_restock(4, 5, items) == [\\"itemA\\", \\"itemB\\", \\"itemC\\", \\"itemD\\"] def test_items_to_restock_mixed_thresholds(): items = [(\\"item1\\", 1), (\\"item2\\", 5), (\\"item3\\", 6), (\\"item4\\", 7)] assert items_to_restock(4, 6, items) == [\\"item1\\", \\"item2\\"] def test_items_to_restock_exact_threshold(): items = [(\\"itemX\\", 5), (\\"itemY\\", 5), (\\"itemZ\\", 5)] assert items_to_restock(3, 5, items) == [] def test_items_to_restock_single_item(): items = [(\\"itemL\\", 3)] assert items_to_restock(1, 5, items) == [\\"itemL\\"]","solution":"def items_to_restock(N, T, items): Determine which items need restocking based on a minimum stock threshold. Parameters: - N: int, the number of different items - T: int, the minimum stock threshold - items: List[Tuple[str, int]], a list of tuples where each tuple contains the item ID and quantity Returns: - List[str], a list of item IDs that need restocking restock_list = [] for item_id, quantity in items: if quantity < T: restock_list.append(item_id) return restock_list"},{"question":"def find_swapped_flowers(original, corrupted): Identifies the two swapped flowers by comparing the original and corrupted sequences. Args: - original (list of int): The original sequence of flowers. - corrupted (list of int): The corrupted sequence of flowers. Returns: - Tuple of two integers representing the types of flowers that were swapped. # Your code here def process_test_cases(test_cases): Processes multiple test cases to determine the swapped flowers for each case. Args: - test_cases (list of tuples): Each tuple contains the original and corrupted sequences. Returns: - List of tuples: Each tuple contains two integers representing the types of flowers that were swapped. # Your code here # Unit tests def test_find_swapped_flowers(): assert find_swapped_flowers([1, 2, 3, 4, 5], [1, 3, 2, 4, 5]) == (2, 3) assert find_swapped_flowers([6, 7, 8, 9, 10], [6, 7, 8, 10, 9]) == (9, 10) assert find_swapped_flowers([1, 2, 3, 4, 5], [5, 2, 3, 4, 1]) == (1, 5) assert find_swapped_flowers([3, 1, 2], [1, 3, 2]) == (1, 3) def test_process_test_cases(): test_cases = [ ([1, 2, 3, 4, 5], [1, 3, 2, 4, 5]), ([6, 7, 8, 9, 10], [6, 7, 8, 10, 9]) ] assert process_test_cases(test_cases) == [(2, 3), (9, 10)] test_cases = [ ([1, 2, 3], [1, 3, 2]), ([1, 2, 3, 4, 5, 6], [1, 2, 6, 4, 5, 3]) ] assert process_test_cases(test_cases) == [(2, 3), (3, 6)]","solution":"def find_swapped_flowers(original, corrupted): Identifies the two swapped flowers by comparing the original and corrupted sequences. Args: - original (list of int): The original sequence of flowers. - corrupted (list of int): The corrupted sequence of flowers. Returns: - Tuple of two integers representing the types of flowers that were swapped. swapped = [] for o, c in zip(original, corrupted): if o != c: swapped.append(o) swapped.append(c) if len(swapped) == 4: break return tuple(set(swapped)) def process_test_cases(test_cases): Processes multiple test cases to determine the swapped flowers for each case. Args: - test_cases (list of tuples): Each tuple contains the original and corrupted sequences. Returns: - List of tuples: Each tuple contains two integers representing the types of flowers that were swapped. results = [] for original, corrupted in test_cases: results.append(find_swapped_flowers(original, corrupted)) return results"},{"question":"def min_additions_to_prevent_adjacent_duplicates(s: str) -> int: Given a string s, this function returns the minimum number of characters that need to be added to ensure no two adjacent characters are the same. >>> min_additions_to_prevent_adjacent_duplicates(\\"aab\\") 1 >>> min_additions_to_prevent_adjacent_duplicates(\\"aabb\\") 2 >>> min_additions_to_prevent_adjacent_duplicates(\\"abcd\\") 0 def test_min_additions_to_prevent_adjacent_duplicates(): from solution import min_additions_to_prevent_adjacent_duplicates assert min_additions_to_prevent_adjacent_duplicates(\\"aab\\") == 1 assert min_additions_to_prevent_adjacent_duplicates(\\"aabb\\") == 2 assert min_additions_to_prevent_adjacent_duplicates(\\"abcd\\") == 0 assert min_additions_to_prevent_adjacent_duplicates(\\"aaa\\") == 2 assert min_additions_to_prevent_adjacent_duplicates(\\"ababa\\") == 0 assert min_additions_to_prevent_adjacent_duplicates(\\"aaabbb\\") == 4 assert min_additions_to_prevent_adjacent_duplicates(\\"a\\") == 0 assert min_additions_to_prevent_adjacent_duplicates(\\"aaaaaaa\\") == 6","solution":"def min_additions_to_prevent_adjacent_duplicates(s): Given a string s, this function returns the minimum number of characters that need to be added to ensure no two adjacent characters are the same. additions = 0 # Iterate through the string and count necessary additions for i in range(1, len(s)): if s[i] == s[i - 1]: additions += 1 return additions"},{"question":"def min_insertions_to_palindrome(S: str) -> int: Returns the minimum number of character insertions required to transform S into a palindrome. >>> min_insertions_to_palindrome(\\"abcb\\") == 1 >>> min_insertions_to_palindrome(\\"race\\") == 3 >>> min_insertions_to_palindrome(\\"a\\") == 0 >>> min_insertions_to_palindrome(\\"aa\\") == 0 >>> min_insertions_to_palindrome(\\"ab\\") == 1 >>> min_insertions_to_palindrome(\\"abc\\") == 2 >>> min_insertions_to_palindrome(\\"abcd\\") == 3 >>> min_insertions_to_palindrome(\\"aba\\") == 0 >>> min_insertions_to_palindrome(\\"abca\\") == 1 >>> min_insertions_to_palindrome(\\"abcba\\") == 0 >>> min_insertions_to_palindrome(\\"deified\\") == 0","solution":"def min_insertions_to_palindrome(S): Returns the minimum number of insertions required to transform S into a palindrome. n = len(S) # Create a table to store results of subproblems dp = [[0] * n for _ in range(n)] # Fill the table for gap in range(1, n): for l in range(n - gap): h = l + gap if S[l] == S[h]: dp[l][h] = dp[l + 1][h - 1] else: dp[l][h] = min(dp[l][h - 1], dp[l + 1][h]) + 1 # The result is the number of insertions for the full string return dp[0][n-1]"},{"question":"def smallest_k_with_N_prime_factors(N: int) -> int: Given a positive integer \`N\`, find the smallest integer \`k\` such that \`k\` contains exactly \`N\` distinct prime factors. >>> smallest_k_with_N_prime_factors(1) == 2 >>> smallest_k_with_N_prime_factors(2) == 6 >>> smallest_k_with_N_prime_factors(3) == 30 >>> smallest_k_with_N_prime_factors(4) == 210 >>> smallest_k_with_N_prime_factors(5) == 2310 >>> smallest_k_with_N_prime_factors(10) == 6469693230","solution":"def smallest_k_with_N_prime_factors(N): Returns the smallest integer k such that k contains exactly N distinct prime factors. # List of first N distinct prime numbers primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29] # To find the smallest integer with exactly N distinct prime factors, we need to # multiply the first N prime numbers k = 1 for i in range(N): k *= primes[i] return k"},{"question":"def longest_consecutive_substring_length(S: str) -> int: Find the length of the longest substring of \`S\` that only consists of consecutive identical characters. >>> longest_consecutive_substring_length(\\"aaabbCCCCdaa\\") == 4 >>> longest_consecutive_substring_length(\\"helloo\\") == 2 >>> longest_consecutive_substring_length(\\"abcdefg\\") == 1 >>> longest_consecutive_substring_length(\\"a\\") == 1 >>> longest_consecutive_substring_length(\\"aaaaa\\") == 5","solution":"def longest_consecutive_substring_length(S): if not S: return 0 max_length = 1 current_length = 1 for i in range(1, len(S)): if S[i] == S[i - 1]: current_length += 1 if current_length > max_length: max_length = current_length else: current_length = 1 return max_length"},{"question":"def longest_arithmetic_subsequence_length(b): Determine the length of the longest arithmetic subsequence in the array b. Args: b (List[int]): The input array of integers. Returns: int: The length of the longest arithmetic subsequence. Example: >>> longest_arithmetic_subsequence_length([1, 5, 7, 8, 9]) 3 >>> longest_arithmetic_subsequence_length([2, 4, 6, 8, 10, 12]) 6 >>> longest_arithmetic_subsequence_length([1, 3, 5, 7]) 4 >>> longest_arithmetic_subsequence_length([5, 1, 4]) 2 pass def process_input(t, test_cases): Process multiple test cases to determine the length of the longest arithmetic subsequences. Args: t (int): The number of test cases. test_cases (List[Tuple[int, List[int]]]): A list of tuples, where each tuple contains an integer m (length of the array) and an array of integers. Returns: List[int]: A list of integers representing the length of the longest arithmetic subsequences for each test case. Examples: >>> process_input(4, [(5, [1, 5, 7, 8, 9]), (6, [2, 4, 6, 8, 10, 12]), (4, [1, 3, 5, 7]), (3, [5, 1, 4])]) [3, 6, 4, 2] >>> process_input(1, [(4, [1, 2, 3, 4])]) [4] pass","solution":"def longest_arithmetic_subsequence_length(b): n = len(b) if n == 1: return 1 lengths = {} max_length = 1 for i in range(n): for j in range(i + 1, n): diff = b[j] - b[i] if (i, diff) in lengths: lengths[(j, diff)] = lengths[(i, diff)] + 1 else: lengths[(j, diff)] = 2 max_length = max(max_length, lengths[(j, diff)]) return max_length def process_input(t, test_cases): results = [] for i in range(t): m, b = test_cases[i] results.append(longest_arithmetic_subsequence_length(b)) return results"},{"question":"def max_subarray_sum(nums): Returns the largest sum of a continuous subarray. Input: List[int] Output: int Example: >>> max_subarray_sum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) 6 >>> max_subarray_sum([1]) 1 >>> max_subarray_sum([-1, -2, -3, -4]) -1","solution":"def max_subarray_sum(nums): Returns the largest sum of a continuous subarray. max_sum = float('-inf') current_sum = 0 for num in nums: current_sum = max(num, current_sum + num) if current_sum > max_sum: max_sum = current_sum return max_sum def main(): import sys input = sys.stdin.read data = input().split() N = int(data[0]) nums = list(map(int, data[1:1+N])) print(max_subarray_sum(nums))"},{"question":"def find_combination(n: int) -> str: Returns the combination of distinct prime numbers and their respective powers that results in the given number n. If it's not possible, returns \\"Not Possible\\". Examples: >>> find_combination(60) \\"2^2 * 3^1 * 5^1\\" >>> find_combination(31) \\"Not Possible\\"","solution":"from sympy import isprime, primerange def find_combination(n): Returns the combination of distinct prime numbers and their respective powers that results in the given number n. If it's not possible, returns \\"Not Possible\\". def prime_factors(n): factors = {} for prime in primerange(2, n + 1): while n % prime == 0: if prime in factors: factors[prime] += 1 else: factors[prime] = 1 n //= prime if n == 1: break return factors if isprime(n): return \\"Not Possible\\" factors = prime_factors(n) if len(factors) == 1 and list(factors.values())[0] == 1: return \\"Not Possible\\" result = \\" * \\".join(f\\"{prime}^{power}\\" for prime, power in sorted(factors.items())) return result"},{"question":"def determine_winner(S: str, X: str) -> str: Determines the winner of the game. Alice and Bob love playing with strings. They have a string \`S\` consisting of lowercase English letters. They play a game where they take turns performing the following move: - Choose a non-empty substring of \`S\` and replace all its occurrences in \`S\` with a given character \`C\`. The player who cannot make a valid move loses the game. Each player can only use any of the vowels {a, e, i, o, u} as the character \`C\` for replacement. The function determines the winner if both players play optimally given the initial string state \`S\` and who goes first. Parameters: S (str): The initial string. X (str): The player who goes first ('A' for Alice or 'B' for Bob). Returns: str: 'A' if Alice wins, or 'B' if Bob wins. Examples: >>> determine_winner(\\"abracadabra\\", \\"A\\") 'A' >>> determine_winner(\\"abracadabra\\", \\"B\\") 'B' from solution import determine_winner def test_winner_alice_start(): assert determine_winner(\\"abracadabra\\", \\"A\\") == \\"A\\" assert determine_winner(\\"abracadabra\\", \\"B\\") == \\"B\\" def test_winner_bob_start(): assert determine_winner(\\"banana\\", \\"A\\") == \\"A\\" assert determine_winner(\\"banana\\", \\"B\\") == \\"B\\" def test_winner_no_vowels_alice_start(): assert determine_winner(\\"bcdfg\\", \\"A\\") == \\"B\\" assert determine_winner(\\"bcdfg\\", \\"B\\") == \\"A\\" def test_winner_all_vowels_alice_start(): assert determine_winner(\\"aeiouaeiou\\", \\"A\\") == \\"A\\" assert determine_winner(\\"aeiouaeiou\\", \\"B\\") == \\"B\\" def test_winner_single_char(): assert determine_winner(\\"a\\", \\"A\\") == \\"A\\" assert determine_winner(\\"a\\", \\"B\\") == \\"B\\" assert determine_winner(\\"b\\", \\"A\\") == \\"B\\" assert determine_winner(\\"b\\", \\"B\\") == \\"A\\"","solution":"def determine_winner(S, X): Determines the winner of the game. Parameters: S (str): The initial string. X (char): The player who goes first ('A' for Alice or 'B' for Bob). Returns: char: 'A' if Alice wins, or 'B' if Bob wins. # If the optimal strategy involves turns, we realize that an even number of total turns means first player wins, # and an odd number of total turns means second player wins if they both play optimally. # Count frequency of vowels in string S vowels = 'aeiou' vowel_count = {v: 0 for v in vowels} for char in S: if char in vowels: vowel_count[char] += 1 # If no vowels are present, the first mover always loses because they have no valid move. total_vowels = sum(vowel_count.values()) if total_vowels == 0: return 'B' if X == 'A' else 'A' # If there are vowels, the first player wins since they can always make a move and there are enough moves to force a win. return X"},{"question":"def prime_factors(n: int) -> str: Returns the prime factorization of n in the format p1^k1 * p2^k2 * ... * pl^kl, where pi is a prime factor and ki is its multiplicity. >>> prime_factors(28) '2^2 * 7^1' >>> prime_factors(1000000) '2^6 * 5^6' >>> prime_factors(17) '17^1' >>> prime_factors(13) '13^1' >>> prime_factors(18) '2^1 * 3^2' >>> prime_factors(999983) '999983^1' >>> prime_factors(1024) '2^10'","solution":"def prime_factors(n): Returns the prime factorization of n in the format p1^k1 * p2^k2 * ... * pl^kl, where pi is a prime factor and ki is its multiplicity. factorization = [] # Handle 2 separately for efficiency count = 0 while n % 2 == 0: n //= 2 count += 1 if count > 0: factorization.append((2, count)) # Check odd factors from 3 onwards factor = 3 while factor * factor <= n: count = 0 while n % factor == 0: n //= factor count += 1 if count > 0: factorization.append((factor, count)) factor += 2 # If n is still greater than 1, then it is a prime factor if n > 1: factorization.append((n, 1)) # Generate result string in desired format result = ' * '.join(f\\"{p}^{k}\\" for p, k in factorization) return result"},{"question":"def does_pattern_match(P: str, S: str) -> int: Determines if the sequence S contains the exact pattern P at least once. Args: P (str): The pattern to unlock the door. S (str): The sequence of button presses attempted. Returns: int: 1 if the sequence S contains the exact pattern P at least once, otherwise 0. >>> does_pattern_match(\\"RGB\\", \\"RRRGBYBBG\\") 1 >>> does_pattern_match(\\"BRY\\", \\"YBRBYBBR\\") 0 >>> does_pattern_match(\\"YB\\", \\"YBBYRYY\\") 1","solution":"def does_pattern_match(P, S): Determines if the sequence S contains the exact pattern P at least once. Args: P (str): The pattern to unlock the door. S (str): The sequence of button presses attempted. Returns: int: 1 if the sequence S contains the exact pattern P at least once, otherwise 0. return 1 if P in S else 0"},{"question":"def garden_arrangement(n: int, m: int, k: int) -> str: Given dimensions n and m for the garden and k different flower types, determine if it is possible to fill the garden such that no two adjacent flowers (vertically or horizontally) have the same type. If possible, return the arrangement. Otherwise, return \\"NO\\". >>> garden_arrangement(3, 3, 2) (\\"YES\\", [[1, 2, 1], [2, 1, 2], [1, 2, 1]]) >>> garden_arrangement(2, 2, 4) (\\"YES\\", [[1, 2], [3, 4]]) >>> garden_arrangement(4, 4, 1) \\"NO\\"","solution":"def garden_arrangement(n, m, k): Given dimensions n and m for the garden and k different flower types, determine if it is possible to fill the garden such that no two adjacent flowers (vertically or horizontally) have the same type. If possible, return the arrangement. Otherwise, return \\"NO\\". if k < 2: # If k < 2, it's not possible to satisfy the condition for n, m > 1 return \\"NO\\" arrangement = [[0] * m for _ in range(n)] for i in range(n): for j in range(m): arrangement[i][j] = (i + j) % k + 1 return \\"YES\\", arrangement # Example Use Case # print(garden_arrangement(3, 3, 2))"},{"question":"def custom_sort(arr: List[int]) -> List[int]: Sorts a list of integers based on a custom sorting criterion. The sorting criterion: - A number x comes before a number y if the number of '1's in the binary representation of x is less than the number of '1's in the binary representation of y. - If two numbers have the same number of '1's, they are sorted in ascending order. >>> custom_sort([3, 7, 8, 9, 6]) [8, 3, 6, 9, 7] >>> custom_sort([]) [] >>> custom_sort([5]) [5] >>> custom_sort([1, 1, 1]) [1, 1, 1] >>> custom_sort([2, 4, 8, 16]) [2, 4, 8, 16] >>> custom_sort([1023, 1000, 100]) [100, 1000, 1023] >>> custom_sort([31, 32, 33, 34]) [32, 33, 34, 31] >>> custom_sort([0, 0, 0]) [0, 0, 0] >>> custom_sort([1048575, 524287, 0]) [0, 524287, 1048575]","solution":"def custom_sort(arr): Sorts the list of integers based on the custom sorting criterion. The sorting criterion: - A number x comes before a number y if the number of '1's in the binary representation of x is less than the number of '1's in the binary representation of y. - If two numbers have the same number of '1's, they are sorted in ascending order. :param arr: List[int] - A list of non-negative integers. :return: List[int] - The sorted list of integers. return sorted(arr, key=lambda x: (bin(x).count('1'), x))"},{"question":"class Book: Class representing a book with attributes: - title: str - author: str - genre: str - year: int def __init__(self, title: str, author: str, genre: str, year: int): pass class Library: Class representing a library containing books with functionalities: - add_book: Adds a Book object to the library. - remove_book: Removes a book with the given title from the library. - search_by_title: Searches for a book by its title and returns its details. - search_by_author: Searches for books by an author and returns a list of those books. - list_books_sorted_by_year: Lists all books sorted by the year of publication. def __init__(self): pass def add_book(self, book: Book): pass def remove_book(self, title: str): pass def search_by_title(self, title: str): pass def search_by_author(self, author: str): pass def list_books_sorted_by_year(self): pass # Example usage: # Creating book instances book1 = Book(\\"The Catcher in the Rye\\", \\"J.D. Salinger\\", \\"Fiction\\", 1951) book2 = Book(\\"To Kill a Mockingbird\\", \\"Harper Lee\\", \\"Fiction\\", 1960) book3 = Book(\\"1984\\", \\"George Orwell\\", \\"Dystopian\\", 1949) # Creating library instance and adding books library = Library() library.add_book(book1) library.add_book(book2) library.add_book(book3) # Removing a book library.remove_book(\\"1984\\") # Searching for a book by title print(library.search_by_title(\\"The Catcher in the Rye\\")) # Searching for books by author print(library.search_by_author(\\"Harper Lee\\")) # Listing books sorted by year print(library.list_books_sorted_by_year())","solution":"class Book: def __init__(self, title, author, genre, year): self.title = title self.author = author self.genre = genre self.year = year def __str__(self): return f\\"{self.title} by {self.author}, genre: {self.genre}, published: {self.year}\\" class Library: def __init__(self): self.books = [] def add_book(self, book): self.books.append(book) def remove_book(self, title): self.books = [book for book in self.books if book.title != title] def search_by_title(self, title): for book in self.books: if book.title == title: return str(book) return \\"Book not found\\" def search_by_author(self, author): return [str(book) for book in self.books if book.author == author] def list_books_sorted_by_year(self): return [str(book) for book in sorted(self.books, key=lambda x: x.year)]"},{"question":"def min_operations_to_palindrome(n: int, s: str) -> int: Returns the minimum number of operations required to transform the given string into a palindrome. >>> min_operations_to_palindrome(5, 'abced') 2 >>> min_operations_to_palindrome(3, 'abc') 1","solution":"def min_operations_to_palindrome(n, s): Returns the minimum number of operations required to transform the given string into a palindrome. operations = 0 for i in range(n // 2): if s[i] != s[n - i - 1]: operations += 1 return operations"},{"question":"def can_rearrange(n: int, d: int, a: List[int]) -> str: Determines if it is possible to rearrange the sequence such that the difference between every two consecutive elements is either d or -d. Parameters: n (int): Length of the sequence. d (int): The required difference between consecutive elements. a (list): The sequence of integers. Returns: str: \\"YES\\" and one possible rearrangement if possible, otherwise \\"NO\\". >>> can_rearrange(4, 2, [4, 2, 6, 8]) == \\"YESn2 4 6 8\\" >>> can_rearrange(3, 5, [3, 8, 13]) == \\"YESn3 8 13\\" >>> can_rearrange(3, 2, [1, 3, 6]) == \\"NO\\"","solution":"def can_rearrange(n, d, a): Determines if it is possible to rearrange the sequence such that the difference between every two consecutive elements is either d or -d. Parameters: n (int): Length of the sequence. d (int): The required difference between consecutive elements. a (list): The sequence of integers. Returns: str: \\"YES\\" and one possible rearrangement if possible, otherwise \\"NO\\". a.sort() for i in range(1, n): if abs(a[i] - a[i - 1]) != d: return \\"NO\\" return \\"YESn\\" + \\" \\".join(map(str, a))"},{"question":"def canPlaceFlowers(flowerbed: List[int], n: int) -> bool: Determines if a given number of new flowers can be planted in the garden row without violating the no-adjacent-flowers rule. >>> canPlaceFlowers([1, 0, 0, 0, 1], 1) True >>> canPlaceFlowers([1, 0, 0, 0, 1], 2) False >>> canPlaceFlowers([0, 0, 1, 0, 0, 0, 0, 1], 2) True","solution":"def canPlaceFlowers(flowerbed, n): length = len(flowerbed) count = 0 for i in range(length): if flowerbed[i] == 0: prev = (i == 0) or (flowerbed[i - 1] == 0) next = (i == length - 1) or (flowerbed[i + 1] == 0) if prev and next: flowerbed[i] = 1 count += 1 if count >= n: return True return count >= n"},{"question":"from typing import List def assign_participants_to_rooms(n: int, room_capacities: List[int], m: int) -> str: Determines if it is possible to assign all participants to rooms without exceeding the capacities. Parameters: n (int): number of rooms room_capacities (List[int]): capacities of each room m (int): number of participants Returns: str: 'YES' if all participants can be assigned to the rooms, 'NO' otherwise >>> assign_participants_to_rooms(3, [2, 1, 3], 5) 'YES' >>> assign_participants_to_rooms(2, [1, 1], 3) 'NO'","solution":"def assign_participants_to_rooms(n, room_capacities, m): Determines if it is possible to assign all participants to rooms without exceeding the capacities. Parameters: n (int): number of rooms room_capacities (List[int]): capacities of each room m (int): number of participants Returns: str: 'YES' if all participants can be assigned to the rooms, 'NO' otherwise total_capacity = sum(room_capacities) if total_capacity >= m: return \\"YES\\" else: return \\"NO\\""},{"question":"def minimum_total_time(n: int, m: int, h: int, skills: List[int], difficulties: List[int], times: List[int]) -> int: Determine the minimum possible total time required to complete all tasks. Args: n (int): Number of developers m (int): Number of tasks h (int): Maximum number of tasks each developer can help with skills (List[int]): Skill levels of the developers difficulties (List[int]): Difficulty levels of the tasks times (List[int]): Estimated completion times of the tasks Returns: int: Minimum possible total time required to complete all tasks Examples: >>> minimum_total_time(3, 3, 1, [5, 4, 6], [3, 5, 2], [10, 20, 5]) 35 >>> minimum_total_time(4, 2, 2, [8, 3, 5, 7], [5, 3], [15, 10]) 25 pass from typing import List def test_minimum_total_time_no_tasks_help_limit_zero(): n, m, h = 3, 3, 0 skills = [5, 4, 6] difficulties = [3, 5, 2] times = [10, 20, 5] assert minimum_total_time(n, m, h, skills, difficulties, times) == 35 def test_minimum_total_time_overflow_help_limit(): n, m, h = 4, 2, 2 skills = [8, 3, 5, 7] difficulties = [5, 3] times = [15, 10] assert minimum_total_time(n, m, h, skills, difficulties, times) == 25 def test_minimum_total_time_all_devs_help(): n, m, h = 3, 3, 1 skills = [5, 4, 6] difficulties = [3, 5, 2] times = [10, 20, 5] assert minimum_total_time(n, m, h, skills, difficulties, times) == 35 def test_minimum_total_time_max_help(): n, m, h = 3, 3, 10 skills = [5, 4, 6] difficulties = [3, 5, 2] times = [10, 20, 5] assert minimum_total_time(n, m, h, skills, difficulties, times) == 35 def test_minimum_total_time_large_numbers(): n, m, h = 3, 3, 2 skills = [10**9, 10**9, 10**9] difficulties = [10**9, 1, 10**9] times = [10**9, 1, 10**9] assert minimum_total_time(n, m, h, skills, difficulties, times) == 1 + 2 * 10**9","solution":"import heapq def minimum_total_time(n, m, h, skills, difficulties, times): developers = list(skills) tasks = list(zip(difficulties, times)) # Developers sorted by their skills in descending order developers.sort(reverse=True) # Tasks sorted by difficulty levels in ascending order tasks.sort() min_time = 0 assigned_tasks_count = [0] * n task_queue = [] task_index = 0 for dev_skill in developers: while task_index < m and tasks[task_index][0] <= dev_skill: heapq.heappush(task_queue, tasks[task_index][1]) task_index += 1 # Developers can help with \`h\` number of tasks at most for _ in range(h): if task_queue: min_time += heapq.heappop(task_queue) # Any remaining tasks in the task_queue are added to the min_time while task_queue: min_time += heapq.heappop(task_queue) return min_time"},{"question":"def simulate_stack_operations(operations: List[str]) -> List[str]: Simulates a stack based on a sequence of operations and returns the stack content after every operation. >>> simulate_stack_operations([\\"push 3\\", \\"push 5\\", \\"pop\\", \\"push 2\\"]) [\\"3\\", \\"3 5\\", \\"3\\", \\"3 2\\"] >>> simulate_stack_operations([\\"pop\\"]) [\\"EMPTY\\"] >>> simulate_stack_operations([\\"push 7\\", \\"push 8\\", \\"pop\\", \\"pop\\", \\"pop\\"]) [\\"7\\", \\"7 8\\", \\"7\\", \\"EMPTY\\", \\"EMPTY\\"]","solution":"def simulate_stack_operations(operations): Simulates a stack based on a sequence of operations and prints the stack content after every operation. The input is a list of operations (strings), and the function prints the stack state after each operation. stack = [] results = [] for operation in operations: if operation.startswith(\\"push\\"): _, x = operation.split() x = int(x) stack.append(x) elif operation == \\"pop\\": if stack: stack.pop() if stack: results.append(\\" \\".join(map(str, stack))) else: results.append(\\"EMPTY\\") return results"},{"question":"def unique_circular_arrangements(N: int) -> int: Returns the number of unique circular seating arrangements for N members, modulo 1000000007. >>> unique_circular_arrangements(3) 2 >>> unique_circular_arrangements(4) 6 >>> unique_circular_arrangements(5) 24","solution":"MOD = 1000000007 def unique_circular_arrangements(N): Returns the number of unique circular seating arrangements for N members, modulo 1000000007. if N < 3: return 0 # Calculate (N-1)! % 1000000007 using iterative method result = 1 for i in range(2, N): result = (result * i) % MOD return result"},{"question":"import math def count_permutations(n: int) -> int: Calculates the total number of unique arrangements (permutations) of n distinct books. >>> count_permutations(3) 6 >>> count_permutations(5) 120 pass","solution":"import math def count_permutations(n): Calculates the total number of unique arrangements (permutations) of n distinct books. Parameters: n (int): the number of books Returns: int: the total number of permutations return math.factorial(n)"},{"question":"def count_clusters(n, m, grid): Determine the number of unique clusters of occupied squares in the given grid. A cluster is defined as a group of occupied squares that are adjacent to each other, either horizontally or vertically. Parameters: n (int): The number of rows in the grid. m (int): The number of columns in the grid. grid (list of list of str): The grid representation where 'X' denotes an occupied square and '.' denotes an empty square. Returns: int: The number of unique clusters of occupied squares. Example: >>> count_clusters(4, 5, [ ... ['X', 'X', '.', '.', 'X'], ... ['X', '.', '.', '.', '.'], ... ['.', '.', 'X', 'X', 'X'], ... ['.', '.', '.', '.', 'X'] ... ]) 3 >>> count_clusters(3, 3, [ ... ['X', 'X', 'X'], ... ['X', 'X', 'X'], ... ['X', 'X', 'X'] ... ]) 1 pass # Unit Test def test_count_clusters(): assert count_clusters(4, 5, [ ['X', 'X', '.', '.', 'X'], ['X', '.', '.', '.', '.'], ['.', '.', 'X', 'X', 'X'], ['.', '.', '.', '.', 'X'] ]) == 3 assert count_clusters(3, 3, [ ['X', 'X', 'X'], ['X', 'X', 'X'], ['X', 'X', 'X'] ]) == 1 assert count_clusters(3, 3, [ ['X', '.', 'X'], ['.', 'X', '.'], ['X', '.', 'X'] ]) == 5 assert count_clusters(2, 2, [ ['.', '.'], ['.', '.'] ]) == 0 assert count_clusters(1, 4, [ ['X', '.', 'X', 'X'] ]) == 2 assert count_clusters(5, 5, [ ['.', '.', '.', '.', '.'], ['X', 'X', '.', '.', 'X'], ['X', '.', 'X', 'X', 'X'], ['.', 'X', 'X', '.', '.'], ['.', '.', '.', '.', '.'] ]) == 2 if __name__ == \\"__main__\\": import pytest pytest.main([__file__])","solution":"def count_clusters(n, m, grid): def dfs(x, y): if x < 0 or x >= n or y < 0 or y >= m or grid[x][y] != 'X': return grid[x][y] = '.' # Mark the cell as visited dfs(x+1, y) dfs(x-1, y) dfs(x, y+1) dfs(x, y-1) clusters = 0 for i in range(n): for j in range(m): if grid[i][j] == 'X': clusters += 1 dfs(i, j) return clusters # Example usage if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() n = int(data[0]) m = int(data[1]) grid = [list(data[i + 2]) for i in range(n)] print(count_clusters(n, m, grid))"},{"question":"def max_plants_watered(m: int, n: int, k: int) -> int: Returns the maximum number of distinct plants the gardener can water. >>> max_plants_watered(2, 2, 3) 4 >>> max_plants_watered(3, 3, 6) 7 >>> max_plants_watered(1, 1, 0) 1 >>> max_plants_watered(4, 4, 16) 16 >>> max_plants_watered(3, 3, 20) 9 >>> max_plants_watered(5, 5, 0) 1 >>> max_plants_watered(1, 100, 99) 100 >>> max_plants_watered(100, 1, 99) 100 >>> max_plants_watered(100, 100, 10000) 10000","solution":"def max_plants_watered(m, n, k): Returns the maximum number of distinct plants the gardener can water. # If the number of moves is greater than or equal to cells in the grid if k >= m * n: return m * n def dfs(x, y, k, visited): # Base cases if x < 0 or y < 0 or x >= m or y >= n or k < 0 or (x, y) in visited: return 0 visited.add((x, y)) max_plants = 1 # Explore all 4 directions up = dfs(x - 1, y, k - 1, visited.copy()) down = dfs(x + 1, y, k - 1, visited.copy()) left = dfs(x, y - 1, k - 1, visited.copy()) right = dfs(x, y + 1, k - 1, visited.copy()) max_plants += max(up, down, left, right) return max_plants return dfs(0, 0, k, set())"},{"question":"from typing import List def find_max_sum_subsequence(arr: List[int]) -> List[int]: Given an array of integers, find a subsequence of the array that has the maximum possible sum and where the integers in the subsequence appear in non-decreasing order. In case of multiple subsequences with the same maximum sum, return the one with the smallest lexicographical order. >>> find_max_sum_subsequence([3, 1, 2, 101, 10, 2]) [3, 101] >>> find_max_sum_subsequence([10, 20, 30, 10, 20]) [10, 20, 30] >>> find_max_sum_subsequence([5]) [5] >>> find_max_sum_subsequence([-1, -2, -3, -4]) [-1] >>> find_max_sum_subsequence([-1, 2, -3, 4, -5, 6]) [2, 4, 6] >>> find_max_sum_subsequence([5, 5, 5, 5]) [5, 5, 5, 5] >>> find_max_sum_subsequence([1000, 999, 998, 997, 996]) [1000] >>> find_max_sum_subsequence([-1000, -999, -998, -997, -996]) [-996] >>> find_max_sum_subsequence([1, -1, 2, -2, 3, -3, 4]) [1, 2, 3, 4] >>> find_max_sum_subsequence([3, 3, 3, 3, 3]) [3, 3, 3, 3, 3]","solution":"def find_max_sum_subsequence(arr): n = len(arr) dp = arr[:] # Initialize dp array with original array values parent = [-1] * n # Stores the index of the previous element in the subsequence # Process each element to find the increasing subsequence with max sum ending at each index for i in range(1, n): for j in range(i): if arr[i] >= arr[j] and dp[i] < dp[j] + arr[i]: dp[i] = dp[j] + arr[i] parent[i] = j # Find index of maximum value in dp array max_sum_index = dp.index(max(dp)) # Reconstruct the subsequence subsequence = [] while max_sum_index != -1: subsequence.append(arr[max_sum_index]) max_sum_index = parent[max_sum_index] # Reverse to get the correct order subsequence.reverse() return subsequence"},{"question":"from typing import List, Tuple def count_unique_events(event_log: List[Tuple[int, str]], start_time: int, end_time: int) -> int: Counts the number of unique event types that occurred within a specified time window. :param event_log: List of tuples where each tuple contains an integer timestamp and a string event type. :param start_time: Integer representing the start time of the window. :param end_time: Integer representing the end time of the window. :return: An integer representing the number of unique event types within the specified time window. >>> event_log = [ ... (1, \\"login\\"), ... (2, \\"logout\\"), ... (3, \\"purchase\\"), ... (4, \\"login\\"), ... (5, \\"logout\\"), ... ] >>> start_time = 2 >>> end_time = 5 >>> count_unique_events(event_log, start_time, end_time) 3 >>> event_log = [ ... (10, \\"view\\"), ... (20, \\"click\\"), ... (30, \\"view\\"), ... (40, \\"signup\\"), ... (50, \\"click\\"), ... ] >>> start_time = 15 >>> end_time = 45 >>> count_unique_events(event_log, start_time, end_time) 3 # Your code here","solution":"from typing import List, Tuple def count_unique_events(event_log: List[Tuple[int, str]], start_time: int, end_time: int) -> int: Counts the number of unique event types that occurred within a specified time window. :param event_log: List of tuples where each tuple contains an integer timestamp and a string event type. :param start_time: Integer representing the start time of the window. :param end_time: Integer representing the end time of the window. :return: An integer representing the number of unique event types within the specified time window. unique_events = set() for timestamp, event_type in event_log: if start_time <= timestamp < end_time: unique_events.add(event_type) elif timestamp >= end_time: break return len(unique_events)"},{"question":"def max_subarray_sum(arr, k): Returns the maximum sum of any subarray of size k. Parameters: arr (list): List of integers representing the array. k (int): Size of the subarray. Returns: int: The maximum sum of any subarray of size k. Example: >>> max_subarray_sum([1, 2, 3, -2, 5, -1, 6, 7], 3) 12 >>> max_subarray_sum([1, -2, 3, 10, -4, 7, 2, -5], 2) 13","solution":"def max_subarray_sum(arr, k): Returns the maximum sum of any subarray of size k. Parameters: arr (list): List of integers representing the array. k (int): Size of the subarray. Returns: int: The maximum sum of any subarray of size k. n = len(arr) if k > n: return None # Edge case when k is larger than the array size # Initialize the sum of the first subarray of size k max_sum = sum(arr[:k]) current_sum = max_sum # Iterate through the array, updating the sum of the current subarray of size k for i in range(k, n): current_sum += arr[i] - arr[i - k] if current_sum > max_sum: max_sum = current_sum return max_sum"},{"question":"def maximize_time_interval(n: int, tasks: list[int]) -> int: Returns the maximum interval between the first and last task in the sorted list after reversing exactly one contiguous subsegment. n: int, the number of tasks. tasks: list of int, distinct integers representing processing times of the tasks. Example: >>> maximize_time_interval(5, [3, 5, 4, 2, 1]) 4 >>> maximize_time_interval(3, [1, 3, 2]) 2","solution":"def maximize_time_interval(n, tasks): Returns the maximum interval between the first and last task in the sorted list after reversing exactly one contiguous subsegment. n: int, the number of tasks. tasks: list of int, distinct integers representing processing times of the tasks. if n == 1: return 0 max_interval = 0 for i in range(n): for j in range(i, n): reversed_tasks = tasks[:i] + tasks[i:j+1][::-1] + tasks[j+1:] max_interval = max(max_interval, max(reversed_tasks) - min(reversed_tasks)) return max_interval"},{"question":"import math from typing import List def is_prime(n: int) -> bool: Returns True if n is a prime number, else False. def is_palindrome(n: int) -> bool: Returns True if n is a palindrome, else False. def next_palindromic_prime(n: int) -> int: Returns the next palindromic prime number greater than n. def find_next_palindromic_primes(test_cases: List[int]) -> List[int]: For each test case, find the next palindromic prime greater than N. Args: test_cases: list of integers representing each test case Returns: list of integers representing the next palindromic prime for each test case","solution":"import math def is_prime(n): Returns True if n is a prime number, else False. if n <= 1: return False if n <= 3: return True if n % 2 == 0 or n % 3 == 0: return False i = 5 while i * i <= n: if n % i == 0 or n % (i + 2) == 0: return False i += 6 return True def is_palindrome(n): Returns True if n is a palindrome, else False. return str(n) == str(n)[::-1] def next_palindromic_prime(n): Returns the next palindromic prime number greater than n. n += 1 while True: if is_palindrome(n) and is_prime(n): return n n += 1 def find_next_palindromic_primes(test_cases): For each test case, find the next palindromic prime greater than N. Args: test_cases: list of integers representing each test case Returns: list of integers representing the next palindromic prime for each test case return [next_palindromic_prime(tc) for tc in test_cases]"},{"question":"def longest_palindrome(s: str) -> str: Write a function that takes a string as input and returns the longest palindrome that can be formed by deleting or reordering characters within the input string. >>> longest_palindrome(\\"aabb\\") in [\\"abba\\", \\"baab\\"] True >>> longest_palindrome(\\"racecar\\") == \\"racecar\\" True >>> longest_palindrome(\\"abcdedcba\\") == \\"abcdedcba\\" True >>> longest_palindrome(\\"abcde\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] True from solution import longest_palindrome def test_abcde(): assert longest_palindrome(\\"abcde\\") in [\\"a\\", \\"b\\", \\"c\\", \\"d\\", \\"e\\"] def test_aabb(): assert longest_palindrome(\\"aabb\\") in [\\"abba\\", \\"baab\\"] def test_racecar(): assert longest_palindrome(\\"racecar\\") == \\"racecar\\" def test_abcdedcba(): assert longest_palindrome(\\"abcdedcba\\") == \\"abcdedcba\\" def test_single_char(): assert longest_palindrome(\\"a\\") == \\"a\\" def test_empty_string(): assert longest_palindrome(\\"\\") == \\"\\" def test_multiple_same_chars(): assert longest_palindrome(\\"aaaa\\") == \\"aaaa\\" assert longest_palindrome(\\"aaa\\") == \\"aaa\\" def test_mixed_case_max_len_palindrome(): assert longest_palindrome(\\"aabbcc\\") in [\\"abccba\\", \\"bccbcb\\", \\"ccaacc\\"] assert longest_palindrome(\\"xxyyzz\\") in [\\"xyzzyx\\", \\"yxzzxy\\", \\"zzxyyx\\"]","solution":"def longest_palindrome(s): Returns the longest palindrome that can be formed by deleting or reordering characters within the input string. from collections import Counter count = Counter(s) left_half = [] middle = None for char, freq in count.items(): quotient, remainder = divmod(freq, 2) left_half.append(char * quotient) if remainder == 1: if middle is None or char > middle: middle = char left_half = ''.join(left_half) palindrome = left_half + (middle if middle else '') + left_half[::-1] return palindrome"},{"question":"def longest_common_subsequence(A: str, B: str) -> int: Compute the length of the longest common subsequence of two strings A and B. A subsequence is a sequence derived from another sequence by deleting some or no elements without changing the order of the remaining elements. Args: A (str): The first string. B (str): The second string. Returns: int: The length of the longest common subsequence of A and B. Examples: >>> longest_common_subsequence(\\"AGGTAB\\", \\"GXTXAYB\\") 4 >>> longest_common_subsequence(\\"ABC\\", \\"DEF\\") 0 >>> longest_common_subsequence(\\"\\", \\"ABC\\") 0 >>> longest_common_subsequence(\\"DEF\\", \\"\\") 0 >>> longest_common_subsequence(\\"\\", \\"\\") 0 >>> longest_common_subsequence(\\"ABC\\", \\"ABC\\") 3 >>> longest_common_subsequence(\\"ABC\\", \\"AC\\") 2 >>> longest_common_subsequence(\\"ABCDEF\\", \\"ADEF\\") 4 >>> longest_common_subsequence(\\"BDCABA\\", \\"ABCBDAB\\") 4","solution":"def longest_common_subsequence(A, B): Returns the length of the longest common subsequence of two strings A and B. n = len(A) m = len(B) # Create a 2D array to store the lengths of longest common subsequence. dp = [[0] * (m + 1) for _ in range(n + 1)] # Fill the dp array for i in range(1, n + 1): for j in range(1, m + 1): if A[i - 1] == B[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m]"},{"question":"def longest_peak_subarray(t: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]: Find the length of the longest \\"peak subarray\\" in nums for each test case. A subarray of the array is called a \\"peak subarray\\" if the first element of the subarray is smaller than the last element of the subarray. Args: t : int : the number of test cases test_cases : List[Tuple[int, List[int]]] : list of tuples where each tuple contains an integer n, the number of elements in the array nums, and the array nums itself Returns: List[int] : a list of integers representing the length of the longest \\"peak subarray\\" for each test case Example: >>> longest_peak_subarray(1, [(5, [1, 2, 3, 4, 5])]) [5] >>> longest_peak_subarray(1, [(6, [4, 3, 2, 1, 2, 3])]) [3] >>> longest_peak_subarray(1, [(7, [5, 1, 2, 1, 2, 1, 2])]) [2]","solution":"def longest_peak_subarray(t, test_cases): results = [] for case in test_cases: n, nums = case max_len = 0 current_len = 1 for i in range(1, n): if nums[i] > nums[i-1]: current_len += 1 if current_len > max_len: max_len = current_len else: current_len = 1 results.append(max_len) return results # Helper function for the input format def parse_input(input_str): input_lines = input_str.strip().split(\\"n\\") t = int(input_lines[0]) test_cases = [] index = 1 for _ in range(t): n = int(input_lines[index]) nums = list(map(int, input_lines[index+1].split())) test_cases.append((n, nums)) index += 2 return t, test_cases # To handle the input/output def main(input_str): t, test_cases = parse_input(input_str) results = longest_peak_subarray(t, test_cases) for result in results: print(result)"},{"question":"from typing import List def findUniqueNumber(arr: List[int]) -> int: Find the number that appears only once in a list where every other number appears twice. Args: arr: List[int] - List of non-negative integers Returns: int - The unique number that appears only once def test_single_element(): assert findUniqueNumber([99]) == 99 def test_all_elements_appear_twice_but_one(): assert findUniqueNumber([4, 1, 2, 1, 2]) == 4 assert findUniqueNumber([2, 2, 3, 5, 3]) == 5 def test_elements_with_large_values(): assert findUniqueNumber([1000000, 1, 2, 1, 2]) == 1000000 def test_elements_with_min_values(): assert findUniqueNumber([0, 0, 1]) == 1 def test_more_complex_cases(): assert findUniqueNumber([4, 5, 4, 6, 7, 6, 7]) == 5 assert findUniqueNumber([10, 20, 20, 30, 30, 10, 11]) == 11 def test_large_input(): nums = [x for x in range(1, 10001)] * 2 + [123456] assert findUniqueNumber(nums) == 123456","solution":"def findUniqueNumber(arr): Find the number that appears only once in a list where every other number appears twice. Args: arr: List[int] - List of non-negative integers Returns: int - The unique number that appears only once unique_number = 0 for num in arr: unique_number ^= num return unique_number"},{"question":"def game_winner(n: int) -> str: Determines if Alice can guarantee a win given n stones. Parameters: n (int): The initial number of stones (1  n  10^5) Returns: str: \\"Alice\\" if Alice can guarantee a win, otherwise \\"Bob\\"","solution":"def game_winner(n): Determines if Alice can guarantee a win given n stones. Parameters: n (int): The initial number of stones (1  n  10^5) Returns: str: \\"Alice\\" if Alice can guarantee a win, otherwise \\"Bob\\" # Initialize memoization table to store results of subproblems dp = [False] * (n + 1) # Base cases if n == 1: return \\"Alice\\" if n == 2: return \\"Bob\\" if n == 3: return \\"Alice\\" if n == 4: return \\"Alice\\" # Fill the dp table for i in range(1, n + 1): if i >= 1 and not dp[i - 1]: dp[i] = True elif i >= 3 and not dp[i - 3]: dp[i] = True elif i >= 4 and not dp[i - 4]: dp[i] = True return \\"Alice\\" if dp[n] else \\"Bob\\""},{"question":"def sliding_window_maximum(n: int, temperatures: List[int], k: int) -> List[int]: Determines the highest temperatures seen within each sliding window as it slides from the start to the end of the list. :param n: Number of recorded temperatures. :param temperatures: List of recorded temperatures. :param k: Size of the sliding window. :return: List of the highest temperatures in each sliding window position. >>> sliding_window_maximum(8, [23, 45, 12, 56, 34, 75, 68, 90], 3) [45, 56, 56, 75, 75, 90] >>> sliding_window_maximum(5, [1, 2, 3, 4, 5], 2) [2, 3, 4, 5]","solution":"from collections import deque def sliding_window_maximum(n, temperatures, k): Determines the highest temperatures within each sliding window. :param n: Number of recorded temperatures (integer). :param temperatures: List of integers representing temperatures. :param k: Size of the sliding window (integer). :return: List of integers representing maximum temperatures in each window. if n <= 0 or k <= 0 or k > n: return [] dq = deque() result = [] for i in range(n): # Remove elements not within the sliding window while dq and dq[0] <= i - k: dq.popleft() # Remove elements not larger than current element while dq and temperatures[dq[-1]] <= temperatures[i]: dq.pop() dq.append(i) # Start adding max temperatures to result list after the first window is processed if i >= k - 1: result.append(temperatures[dq[0]]) return result"},{"question":"def custom_sort(custom_order: str, n: int, strings: List[str]) -> List[str]: Sorts the list of strings based on the custom alphabet order. Parameters: - custom_order (str): A string containing all 26 letters in the desired order. - n (int): Number of strings in the list. - strings (list of str): The list of strings to be sorted. Returns: - list of str: The sorted list of strings. >>> custom_sort(\\"zyxwvutsrqponmlkjihgfedcba\\", 5, [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"]) [\\"elderberry\\", \\"date\\", \\"cherry\\", \\"banana\\", \\"apple\\"] >>> custom_sort(\\"abcdefghijklmnopqrstuvwxyz\\", 3, [\\"cat\\", \\"bat\\", \\"rat\\"]) [\\"bat\\", \\"cat\\", \\"rat\\"] pass # Unit tests def test_custom_sort_example1(): custom_order = \\"zyxwvutsrqponmlkjihgfedcba\\" n = 5 strings = [\\"apple\\", \\"banana\\", \\"cherry\\", \\"date\\", \\"elderberry\\"] expected = [\\"elderberry\\", \\"date\\", \\"cherry\\", \\"banana\\", \\"apple\\"] assert custom_sort(custom_order, n, strings) == expected def test_custom_sort_example2(): custom_order = \\"abcdefghijklmnopqrstuvwxyz\\" n = 3 strings = [\\"cat\\", \\"bat\\", \\"rat\\"] expected = [\\"bat\\", \\"cat\\", \\"rat\\"] assert custom_sort(custom_order, n, strings) == expected def test_custom_sort_reversed_alphabet(): custom_order = \\"abcdefghijklmnopqrstuvwxyz\\"[::-1] n = 3 strings = [\\"dog\\", \\"cat\\", \\"apple\\"] expected = [\\"dog\\", \\"cat\\", \\"apple\\"] assert custom_sort(custom_order, n, strings) == expected def test_custom_sort_single_word(): custom_order = \\"zyxwvutsrqponmlkjihgfedcba\\" n = 1 strings = [\\"banana\\"] expected = [\\"banana\\"] assert custom_sort(custom_order, n, strings) == expected def test_custom_sort_empty_list(): custom_order = \\"zyxwvutsrqponmlkjihgfedcba\\" n = 0 strings = [] expected = [] assert custom_sort(custom_order, n, strings) == expected","solution":"def custom_sort(custom_order, n, strings): Sorts the list of strings based on the custom alphabet order. Parameters: - custom_order (str): A string containing all 26 letters in the desired order. - n (int): Number of strings in the list. - strings (list of str): The list of strings to be sorted. Returns: - list of str: The sorted list of strings. # Create a dictionary for custom order ranking rank = {char: i for i, char in enumerate(custom_order)} # Sort the list of strings based on custom order sorted_strings = sorted(strings, key=lambda word: [rank[char] for char in word]) return sorted_strings"},{"question":"def sort_books_by_attribute(books, queries): Sorts a list of books according to specified attributes. Parameters: books (list of dict): A list of dictionaries, each containing 'title', 'genre', and 'pages'. queries (list of str): A list of attributes by which to sort the books. Returns: list of list: A list where each element is a list of book titles sorted according to one of the queries. Example: >>> books = [ ... {\\"title\\": \\"TheHobbit\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 310}, ... {\\"title\\": \\"WarAndPeace\\", \\"genre\\": \\"History\\", \\"pages\\": 1225}, ... {\\"title\\": \\"1984\\", \\"genre\\": \\"Dystopian\\", \\"pages\\": 328}, ... {\\"title\\": \\"ToKillAMockingbird\\", \\"genre\\": \\"Fiction\\", \\"pages\\": 281}, ... ] >>> queries = [\\"title\\", \\"pages\\"] >>> sort_books_by_attribute(books, queries) [['1984', 'TheHobbit', 'ToKillAMockingbird', 'WarAndPeace'], ['ToKillAMockingbird', 'TheHobbit', '1984', 'WarAndPeace']] # Unit tests def test_sort_by_title(): books = [ {\\"title\\": \\"TheHobbit\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 310}, {\\"title\\": \\"WarAndPeace\\", \\"genre\\": \\"History\\", \\"pages\\": 1225}, {\\"title\\": \\"1984\\", \\"genre\\": \\"Dystopian\\", \\"pages\\": 328}, {\\"title\\": \\"ToKillAMockingbird\\", \\"genre\\": \\"Fiction\\", \\"pages\\": 281}, ] queries = [\\"title\\"] expected = [[\\"1984\\", \\"TheHobbit\\", \\"ToKillAMockingbird\\", \\"WarAndPeace\\"]] assert sort_books_by_attribute(books, queries) == expected def test_sort_by_pages(): books = [ {\\"title\\": \\"TheHobbit\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 310}, {\\"title\\": \\"WarAndPeace\\", \\"genre\\": \\"History\\", \\"pages\\": 1225}, {\\"title\\": \\"1984\\", \\"genre\\": \\"Dystopian\\", \\"pages\\": 328}, {\\"title\\": \\"ToKillAMockingbird\\", \\"genre\\": \\"Fiction\\", \\"pages\\": 281}, ] queries = [\\"pages\\"] expected = [[\\"ToKillAMockingbird\\", \\"TheHobbit\\", \\"1984\\", \\"WarAndPeace\\"]] assert sort_books_by_attribute(books, queries) == expected def test_sort_by_genre(): books = [ {\\"title\\": \\"HarryPotter\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 223}, {\\"title\\": \\"TheGreatGatsby\\", \\"genre\\": \\"Classic\\", \\"pages\\": 218}, {\\"title\\": \\"MobyDick\\", \\"genre\\": \\"Adventure\\", \\"pages\\": 822}, ] queries = [\\"genre\\"] expected = [[\\"MobyDick\\", \\"TheGreatGatsby\\", \\"HarryPotter\\"]] assert sort_books_by_attribute(books, queries) == expected def test_multiple_queries(): books = [ {\\"title\\": \\"TheHobbit\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 310}, {\\"title\\": \\"WarAndPeace\\", \\"genre\\": \\"History\\", \\"pages\\": 1225}, {\\"title\\": \\"1984\\", \\"genre\\": \\"Dystopian\\", \\"pages\\": 328}, {\\"title\\": \\"ToKillAMockingbird\\", \\"genre\\": \\"Fiction\\", \\"pages\\": 281}, ] queries = [\\"title\\", \\"pages\\"] expected = [ [\\"1984\\", \\"TheHobbit\\", \\"ToKillAMockingbird\\", \\"WarAndPeace\\"], [\\"ToKillAMockingbird\\", \\"TheHobbit\\", \\"1984\\", \\"WarAndPeace\\"] ] assert sort_books_by_attribute(books, queries) == expected","solution":"def sort_books_by_attribute(books, queries): Sorts a list of books according to specified attributes. Parameters: books (list of dict): A list of dictionaries, each containing 'title', 'genre', and 'pages'. queries (list of str): A list of attributes by which to sort the books. Returns: list of list: A list where each element is a list of book titles sorted according to one of the queries. results = [] for query in queries: if query == \\"title\\": sorted_books = sorted(books, key=lambda x: x['title']) elif query == \\"genre\\": sorted_books = sorted(books, key=lambda x: x['genre']) elif query == \\"pages\\": sorted_books = sorted(books, key=lambda x: x['pages']) results.append([book['title'] for book in sorted_books]) return results # Example usage: # books = [ # {\\"title\\": \\"TheHobbit\\", \\"genre\\": \\"Fantasy\\", \\"pages\\": 310}, # {\\"title\\": \\"WarAndPeace\\", \\"genre\\": \\"History\\", \\"pages\\": 1225}, # {\\"title\\": \\"1984\\", \\"genre\\": \\"Dystopian\\", \\"pages\\": 328}, # {\\"title\\": \\"ToKillAMockingbird\\", \\"genre\\": \\"Fiction\\", \\"pages\\": 281}, # ] # queries = [\\"title\\", \\"pages\\"] # print(sort_books_by_attribute(books, queries))"},{"question":"def optimal_egg_drop(N: int, K: int) -> int: Determines the minimum number of attempts needed to find the highest floor from which an egg can be dropped without breaking. Args: N (int): Number of floors K (int): Number of eggs Returns: int: Minimum number of attempts needed >>> optimal_egg_drop(100, 2) 14 >>> optimal_egg_drop(10, 1) 10 >>> optimal_egg_drop(10, 2) 4 >>> optimal_egg_drop(1, 1) 1 >>> optimal_egg_drop(2, 2) 2 >>> optimal_egg_drop(100, 1) 100 >>> optimal_egg_drop(10, 3) 4 >>> optimal_egg_drop(1000, 3) 19 >>> optimal_egg_drop(15, 3) 5 >>> optimal_egg_drop(7, 2) 4","solution":"def optimal_egg_drop(N, K): Determines the minimum number of attempts needed to find the highest floor from which an egg can be dropped without breaking. Args: N (int): Number of floors K (int): Number of eggs Returns: int: Minimum number of attempts needed # Create a table where dp[i][j] represents minimum number of attempts # needed for i floors using j eggs. dp = [[0 for x in range(K + 1)] for x in range(N + 1)] # We have one attempt with one egg to test each floor for i in range(1, N + 1): dp[i][1] = i # With one floor, only one attempt is needed regardless of number of eggs for j in range(1, K + 1): dp[1][j] = 1 # Fill the rest of the table using optimal substructure property for j in range(2, K + 1): for i in range(2, N + 1): dp[i][j] = float('inf') for x in range(1, i + 1): res = 1 + max(dp[x - 1][j - 1], dp[i - x][j]) if res < dp[i][j]: dp[i][j] = res return dp[N][K]"},{"question":"def longest_common_subsequence(nums1, nums2): Determine the length of the longest common subsequence (LCS) of nums1 and nums2. >>> longest_common_subsequence([1, 3, 4, 1, 2, 1], [3, 2, 1, 4, 1, 2, 1]) 5 >>> longest_common_subsequence([1, 2, 3, 4], [1, 3, 4, 2]) 3 n, m = len(nums1), len(nums2) # Create a (n+1) x (m+1) DP table dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] def test_longest_common_subsequence(): assert longest_common_subsequence([1, 3, 4, 1, 2, 1], [3, 2, 1, 4, 1, 2, 1]) == 5 assert longest_common_subsequence([1, 2, 3, 4], [1, 3, 4, 2]) == 3 assert longest_common_subsequence([1, 1, 1, 1], [1, 1, 1, 1]) == 4 assert longest_common_subsequence([1, 2, 3, 4], [5, 6, 7, 8]) == 0 assert longest_common_subsequence([1], [1]) == 1 assert longest_common_subsequence([3, 9, 8, 3, 9, 7, 9, 7, 0], [3, 3, 9, 9, 9, 1, 7, 2, 0, 3]) == 6 # Running the tests if __name__ == \\"__main__\\": test_longest_common_subsequence() print(\\"All tests passed!\\")","solution":"def longest_common_subsequence(nums1, nums2): Returns the length of the longest common subsequence of nums1 and nums2. n, m = len(nums1), len(nums2) # Create a (n+1) x (m+1) DP table dp = [[0] * (m + 1) for _ in range(n + 1)] for i in range(1, n + 1): for j in range(1, m + 1): if nums1[i - 1] == nums2[j - 1]: dp[i][j] = dp[i - 1][j - 1] + 1 else: dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) return dp[n][m] # Example usage # Reading input from standard input as described in the problem statement import sys input = sys.stdin.read def main(): data = input().split() n = int(data[0]) m = int(data[1]) nums1 = list(map(int, data[2:n+2])) nums2 = list(map(int, data[n+2:n+2+m])) print(longest_common_subsequence(nums1, nums2)) if __name__ == \\"__main__\\": main()"},{"question":"from typing import List, Tuple def compute_levels(n: int, edges: List[Tuple[int, int]]) -> List[Tuple[int, int]]: Computes the number of nodes at each level. Parameters: n (int): Number of nodes. edges (list of tuples): Each tuple represents an edge between two nodes (u, v). Returns: List of tuples: Each tuple contains (level, number of nodes at that level). Examples: >>> compute_levels(5, [(1, 2), (1, 3), (2, 4), (3, 5)]) [(0, 1), (1, 2), (2, 2)] >>> compute_levels(7, [(1, 2), (1, 3), (2, 4), (3, 5), (3, 6), (6, 7)]) [(0, 1), (1, 2), (2, 3), (3, 1)] >>> compute_levels(1, []) [(0, 1)] >>> compute_levels(2, [(1, 2)]) [(0, 1), (1, 1)] >>> compute_levels(9, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (5, 7), (5, 8), (6, 9)]) [(0, 1), (1, 2), (2, 3), (3, 3)]","solution":"from collections import deque, defaultdict def compute_levels(n, edges): Computes the number of nodes at each level. Parameters: n (int): Number of nodes. edges (list of tuples): Each tuple represents an edge between two nodes (u, v). Returns: List of tuples: Each tuple contains (level, number of nodes at that level). # Create adjacency list adj_list = defaultdict(list) for u, v in edges: adj_list[u].append(v) adj_list[v].append(u) # BFS to determine levels levels = [-1] * (n + 1) # -1 means unvisited levels[1] = 0 # Level of node 1 queue = deque([1]) while queue: node = queue.popleft() current_level = levels[node] for neighbor in adj_list[node]: if levels[neighbor] == -1: levels[neighbor] = current_level + 1 queue.append(neighbor) # Count nodes at each level level_count = defaultdict(int) for level in levels: if level != -1: level_count[level] += 1 # Get sorted levels and counts result = sorted(level_count.items()) return result"},{"question":"def can_make_elements_equal(n: int, arr: List[int]) -> str: Determines if it is possible to make all elements of the array equal by incrementing or decrementing elements by 1. Args: n : int : number of elements in the array arr : list[int] : the array of integers Returns: str : \\"YES\\" if it is possible to make all elements equal, \\"NO\\" otherwise >>> can_make_elements_equal(4, [1, 3, 2, 1]) \\"YES\\" >>> can_make_elements_equal(3, [1, 4, 7]) \\"NO\\"","solution":"def can_make_elements_equal(n, arr): Determines if it is possible to make all elements of the array equal by incrementing or decrementing elements by 1. Args: n : int : number of elements in the array arr : list[int] : the array of integers Returns: str : \\"YES\\" if it is possible to make all elements equal, \\"NO\\" otherwise # Calculate the unique set of differences between elements unique_elements = set(arr) if len(unique_elements) <= 2: return \\"YES\\" if len(unique_elements) == 3: unique_list = sorted(unique_elements) if unique_list[2] - unique_list[0] == 2: return \\"YES\\" return \\"NO\\""},{"question":"def is_prime(number: int) -> bool: Check if a number is a prime number. >>> is_prime(2) True >>> is_prime(3) True >>> is_prime(4) False >>> is_prime(5) True >>> is_prime(11) True >>> is_prime(16) False pass def sum_of_digits(n: int) -> int: Returns the sum of the digits of n. >>> sum_of_digits(123) 6 >>> sum_of_digits(0) 0 >>> sum_of_digits(49) 13 >>> sum_of_digits(99999) 45 pass def smallest_number_with_prime_digit_sum(M: int) -> int: Given an integer M, find the smallest integer N (N  M) such that the sum of the digits of N is a prime number. >>> smallest_number_with_prime_digit_sum(10) 11 >>> smallest_number_with_prime_digit_sum(28) 29 >>> smallest_number_with_prime_digit_sum(100) 101 >>> smallest_number_with_prime_digit_sum(1) 2 >>> smallest_number_with_prime_digit_sum(13) 14 >>> smallest_number_with_prime_digit_sum(37) 38 pass","solution":"def is_prime(number): Check if a number is a prime number. if number <= 1: return False if number <= 3: return True if number % 2 == 0 or number % 3 == 0: return False i = 5 while i * i <= number: if number % i == 0 or number % (i + 2) == 0: return False i += 6 return True def sum_of_digits(n): Returns the sum of the digits of n. return sum(int(digit) for digit in str(n)) def smallest_number_with_prime_digit_sum(M): Given an integer M, find the smallest integer N (N  M) such that the sum of the digits of N is a prime number. N = M while True: if is_prime(sum_of_digits(N)): return N N += 1"},{"question":"def minimize_adjacent_difference(arr: List[int]) -> List[int]: Reorders the input array such that the absolute difference between any adjacent elements is minimized. Args: arr (list): List of integers. Returns: list: The reordered list with minimized adjacent differences. >>> minimize_adjacent_difference([4, 2, 1, 10, 5]) [1, 2, 4, 5, 10] >>> minimize_adjacent_difference([7, 11, 2]) [2, 7, 11] >>> minimize_adjacent_difference([3, 1, 4, 1, 5, 9, 2, 6, 5]) [1, 1, 2, 3, 4, 5, 5, 6, 9] >>> minimize_adjacent_difference([-1, 2, -4, 3, 0]) [-4, -1, 0, 2, 3] >>> minimize_adjacent_difference([1000000000, -1000000000]) [-1000000000, 1000000000] >>> minimize_adjacent_difference([1, 2]) [1, 2] >>> minimize_adjacent_difference([5, 1]) [1, 5] >>> minimize_adjacent_difference([3, 3, 3]) [3, 3, 3] >>> minimize_adjacent_difference([5, 5, 8, 8, 8, 1]) [1, 5, 5, 8, 8, 8]","solution":"def minimize_adjacent_difference(arr): Reorders the input array such that the absolute difference between any adjacent elements is minimized. Args: arr (list): List of integers. Returns: list: The reordered list with minimized adjacent differences. arr.sort() return arr"},{"question":"class EmployeeDatabase: def __init__(self): self.employees = {} def add_employee(self, eid, rating): self.employees[eid] = rating def remove_employee(self, eid): if eid in self.employees: del self.employees[eid] def query_employees(self, rmin, rmax): pass def handle_events(n, events): Handle a series of employee record management events. :param n: Number of events :param events: List of events of format [1 eid r] for adding employees, [2 eid] for removing employees, or [3 rmin rmax] for querying. :return: List of query results for events of type 3 >>> handle_events(7, [[1, 101, 5], [1, 102, 3], [1, 103, 8], [3, 4, 6], [2, 101], [1, 104, 4], [3, 2, 5]]) [1, 2] >>> handle_events(4, [[1, 201, 10], [1, 202, 15], [3, 10, 15], [2, 201]]) [2] >>> handle_events(5, [[1, 301, 25], [1, 302, 30], [1, 303, 35], [2, 301], [3, 20, 30]]) [1] >>> handle_events(6, [[1, 401, 9], [1, 402, 11], [1, 403, 12], [1, 404, 6], [3, 5, 10], [3, 11, 12]]) [2, 2] >>> handle_events(9, [[1, 501, 5], [1, 502, 6], [1, 503, 7], [1, 504, 8], [1, 505, 9], [3, 6, 8], [3, 5, 10], [2, 503], [3, 5, 10]]) [3, 5, 4] db = EmployeeDatabase() results = [] for event in events: if event[0] == 1: # Add employee _, eid, rating = event db.add_employee(eid, rating) elif event[0] == 2: # Remove employee _, eid = event db.remove_employee(eid) elif event[0] == 3: # Query employees _, rmin, rmax = event results.append(db.query_employees(rmin, rmax)) return results","solution":"class EmployeeDatabase: def __init__(self): self.employees = {} def add_employee(self, eid, rating): self.employees[eid] = rating def remove_employee(self, eid): if eid in self.employees: del self.employees[eid] def query_employees(self, rmin, rmax): return sum(1 for rating in self.employees.values() if rmin <= rating <= rmax) def handle_events(n, events): db = EmployeeDatabase() results = [] for event in events: if event[0] == 1: # Add employee _, eid, rating = event db.add_employee(eid, rating) elif event[0] == 2: # Remove employee _, eid = event db.remove_employee(eid) elif event[0] == 3: # Query employees _, rmin, rmax = event results.append(db.query_employees(rmin, rmax)) return results"},{"question":"def lexicographically_smallest_array(n: int, k: int, arr: List[int]) -> List[int]: Returns the lexicographically smallest array possible after exactly k reverse operations. >>> lexicographically_smallest_array(5, 1, [4, 3, 2, 1, 5]) [1, 2, 3, 4, 5] >>> lexicographically_smallest_array(6, 2, [3, 1, 2, 5, 4, 6]) [1, 2, 3, 4, 5, 6] >>> lexicographically_smallest_array(4, 3, [9, 8, 7, 6]) [6, 7, 8, 9] >>> lexicographically_smallest_array(4, 1, [1, 2, 3, 4]) [1, 2, 3, 4] >>> lexicographically_smallest_array(7, 4, [7, 4, 6, 5, 3, 1, 2]) [1, 2, 3, 4, 5, 6, 7] >>> lexicographically_smallest_array(1, 1, [1]) [1]","solution":"def lexicographically_smallest_array(n, k, arr): Returns the lexicographically smallest array possible after exactly k reverse operations. if k > 1: return sorted(arr) else: smallest_arr = arr[:] for i in range(n): for j in range(i + 1, n + 1): new_arr = arr[:i] + arr[i:j][::-1] + arr[j:] if new_arr < smallest_arr: smallest_arr = new_arr return smallest_arr"},{"question":"def smallest_lex_string(k: int, S: str) -> str: Returns the lexicographically smallest string that can be obtained by performing at most k operations on the string S. Parameters: k (int): Maximum number of allowed operations. S (str): Input string consisting of lowercase English letters. Returns: str: Lexicographically smallest string possible with at most k operations. >>> smallest_lex_string(2, 'bcda') 'aada' >>> smallest_lex_string(1, 'aaa') 'aaa' >>> smallest_lex_string(1, 'b') 'a' >>> smallest_lex_string(3, 'xyz') 'aaa' >>> smallest_lex_string(100, 'abacabadabacaba') 'aaaaaaaaaaaaaaa'","solution":"def smallest_lex_string(k, S): Returns the lexicographically smallest string that can be obtained by performing at most k operations on the string S. Parameters: k (int): Maximum number of allowed operations. S (str): Input string consisting of lowercase English letters. Returns: str: Lexicographically smallest string possible with at most k operations. n = len(S) s_list = list(S) # Start from the beginning of the string and try to make the smallest change for i in range(n): if k == 0: break if s_list[i] != 'a': s_list[i] = 'a' k -= 1 return ''.join(s_list)"},{"question":"def digital_root(n: int) -> int: Compute the digital root of a non-negative integer n. The digital root is the single digit obtained by repeatedly summing the digits of the number until a single digit is obtained. >>> digital_root(942) 6 >>> digital_root(12345) 6 >>> digital_root(99999) 9 >>> digital_root(123) 6 def test_digital_root_single_digit(): assert digital_root(0) == 0 assert digital_root(7) == 7 def test_digital_root_multiple_digits(): assert digital_root(942) == 6 assert digital_root(12345) == 6 assert digital_root(99999) == 9 assert digital_root(123) == 6 def test_digital_root_large_number(): assert digital_root(10**1000 - 1) == 9 # Digital root of all 9s is 9 def test_digital_root_mixed_cases(): assert digital_root(528491) == 2 assert digital_root(1001) == 2","solution":"def digital_root(n: int) -> int: Compute the digital root of a non-negative integer n. while n >= 10: n = sum(int(digit) for digit in str(n)) return n # An alternative approach using number theory properties (modular arithmetic) # def digital_root(n: int) -> int: # if n == 0: # return 0 # return (n - 1) % 9 + 1"},{"question":"def can_redistribute_contents(T: int, cases: list) -> list: Determines if it's possible to redistribute container contents to make all containers have the same amount. >>> can_redistribute_contents(2, [(5, [1, 2, 3, 4, 5]), (4, [1, 1, 1, 1])]) == [\\"POSSIBLE\\", \\"POSSIBLE\\"] >>> can_redistribute_contents(1, [(3, [1, 2, 4])]) == [\\"IMPOSSIBLE\\"]","solution":"def can_redistribute_contents(T, cases): Determines if it's possible to redistribute container contents to make all containers have the same amount. Args: T (int): Number of test cases. cases (list): List of tuples where each tuple contains an integer N and a list of N integers. Returns: list: List of strings \\"POSSIBLE\\" or \\"IMPOSSIBLE\\" for each test case. results = [] for N, contents in cases: total_content = sum(contents) if total_content % N == 0: results.append(\\"POSSIBLE\\") else: results.append(\\"IMPOSSIBLE\\") return results"},{"question":"def find_minimum_final_value(n: int, arr: List[int]) -> int: Returns the minimum possible value of the last remaining element after optimal sequence of moves. Parameters: n (int): The number of elements in the array. arr (List[int]): The array of integers. Returns: int: The minimum possible value of the last remaining element. Examples: >>> find_minimum_final_value(3, [1, 2, 3]) 6 >>> find_minimum_final_value(4, [1, 3, 5, 7]) 16","solution":"def find_minimum_final_value(n, arr): Returns the minimum possible value of the last remaining element after optimal sequence of moves. # Optimal strategy involves summing up all elements in the array return sum(arr)"},{"question":"from typing import List def floristry_inventory(operations: List[str]) -> List[str]: Simulate the inventory management system for a floristry with given operations. operations: List of inventory operations in format: - \\"add <flower_name> <count>\\" - \\"sell <flower_name> <count>\\" - \\"restock <flower_name> <count>\\" returns: Final inventory list in alphabetical order as strings in format \\"<flower_name> <count>\\" Example: >>> operations = [ ... \\"add Rose 10\\", ... \\"add Tulip 5\\", ... \\"sell Rose 3\\", ... \\"restock Tulip 8\\", ... \\"add Lily 7\\" ... ] >>> floristry_inventory(operations) ['Lily 7', 'Rose 7', 'Tulip 13'] # Your code here Unit Test: from solution import floristry_inventory def test_example_case(): operations = [ \\"add Rose 10\\", \\"add Tulip 5\\", \\"sell Rose 3\\", \\"restock Tulip 8\\", \\"add Lily 7\\" ] expected = [ \\"Lily 7\\", \\"Rose 7\\", \\"Tulip 13\\" ] assert floristry_inventory(operations) == expected def test_add_new_flowers(): operations = [ \\"add Daffodil 15\\", \\"add Daisy 12\\" ] expected = [ \\"Daffodil 15\\", \\"Daisy 12\\" ] assert floristry_inventory(operations) == expected def test_sell_flowers(): operations = [ \\"add Sunflower 20\\", \\"sell Sunflower 5\\", \\"sell Sunflower 10\\" ] expected = [ \\"Sunflower 5\\" ] assert floristry_inventory(operations) == expected def test_restock_flowers(): operations = [ \\"add Poppy 4\\", \\"restock Poppy 6\\" ] expected = [ \\"Poppy 10\\" ] assert floristry_inventory(operations) == expected def test_case_sensitivity(): operations = [ \\"add rose 10\\", \\"add Rose 5\\", \\"sell rose 4\\", \\"restock Rose 10\\" ] expected = [ \\"Rose 15\\", \\"rose 6\\" ] assert floristry_inventory(operations) == expected","solution":"def floristry_inventory(operations): inventory = {} for operation in operations: parts = operation.split() command = parts[0] name = parts[1] count = int(parts[2]) if command == \\"add\\": if name not in inventory: inventory[name] = 0 inventory[name] += count elif command == \\"sell\\": if name in inventory: inventory[name] -= count elif command == \\"restock\\": if name in inventory: inventory[name] += count sorted_inventory = sorted(inventory.items()) final_inventory = [\\"{} {}\\".format(name, count) for name, count in sorted_inventory] return final_inventory"},{"question":"def stick_game_winner(sticks: list) -> str: Determines the winner of the stick game given a list of stick lengths. If you will win, return 'first'; if your friend will win, return 'second'. >>> stick_game_winner([1, 2, 3]) 'first' >>> stick_game_winner([1, 1, 1, 1]) 'second'","solution":"def stick_game_winner(sticks): Determines the winner of the stick game. Returns 'first' if the starting player wins, 'second' otherwise. # If the number of sticks is odd, the first player will always win. # If the number of sticks is even, the second player will always win. if len(sticks) % 2 == 1: return \\"first\\" else: return \\"second\\""},{"question":"def min_possible_sum(n: int, sequence: List[int]) -> int: Returns the minimum possible sum of the sequence after performing any number of allowed operations. The allowed operations are: - Choose a subsequence of k elements in the sequence where k is a power of 2 (i.e., 1, 2, 4, 8, ...), - Replace the chosen subsequence with a single element which is the sum of all elements in this subsequence. >>> min_possible_sum(1, [5]) == 5 >>> min_possible_sum(4, [7, 3, 9, 1]) == 20 >>> min_possible_sum(3, [5, 6, 7]) == 18 >>> min_possible_sum(3, [10000, 10000, 10000]) == 30000 >>> min_possible_sum(5, [4, 2, 7, 3, 6]) == 22 return sum(sequence)","solution":"def min_possible_sum(n, sequence): Returns the minimum possible sum of the sequence after performing any number of allowed operations. The allowed operations are: - Choose a subsequence of k elements in the sequence where k is a power of 2 (i.e., 1, 2, 4, 8, ...), - Replace the chosen subsequence with a single element which is the sum of all elements in this subsequence. :param n: integer, length of the sequence :param sequence: list of integers, the sequence elements :return: integer, the minimum possible sum of the sequence return sum(sequence)"},{"question":"def process_operations(operations: List[str]) -> List[str]: Process a series of operations on a book warehouse and output results for 'kth' operations. Args: operations (List[str]): List of operations in the format \\"add x\\", \\"remove x\\", \\"kth k\\", or \\"end\\". Returns: List[str]: List of results for 'kth' operations. Example: >>> operations = [ ... \\"add 5\\", ... \\"add 1\\", ... \\"add 3\\", ... \\"kth 2\\", ... \\"remove 3\\", ... \\"kth 2\\", ... \\"end\\" ... ] >>> process_operations(operations) [\\"3\\", \\"5\\"] import bisect class BookWarehouse: def __init__(self): self.books = [] def add(self, x): bisect.insort(self.books, x) def remove(self, x): index = bisect.bisect_left(self.books, x) if index != len(self.books) and self.books[index] == x: self.books.pop(index) def kth(self, k): return self.books[k-1] import sys output = [] warehouse = BookWarehouse() for operation in operations: if operation.startswith(\\"add \\"): _, x = operation.split() warehouse.add(int(x)) elif operation.startswith(\\"remove \\"): _, x = operation.split() warehouse.remove(int(x)) elif operation.startswith(\\"kth \\"): _, k = operation.split() output.append(str(warehouse.kth(int(k)))) elif operation == \\"end\\": break return output # Example unit tests to verify the solution def test_process_operations(): operations = [ \\"add 5\\", \\"add 1\\", \\"add 3\\", \\"kth 2\\", \\"remove 3\\", \\"kth 2\\", \\"end\\" ] assert process_operations(operations) == [\\"3\\", \\"5\\"] operations = [ \\"add 10\\", \\"add 20\\", \\"add 30\\", \\"kth 1\\", \\"kth 3\\", \\"remove 20\\", \\"kth 2\\", \\"end\\" ] assert process_operations(operations) == [\\"10\\", \\"30\\", \\"30\\"] operations = [ \\"add 42\\", \\"kth 1\\", \\"remove 42\\", \\"end\\" ] assert process_operations(operations) == [\\"42\\"] operations = [ \\"add 50\\", \\"remove 50\\", \\"add 60\\", \\"kth 1\\", \\"end\\" ] assert process_operations(operations) == [\\"60\\"] operations = [ \\"add 70\\", \\"add 70\\", \\"kth 1\\", \\"kth 2\\", \\"remove 70\\", \\"kth 1\\", \\"end\\" ] assert process_operations(operations) == [\\"70\\", \\"70\\", \\"70\\"] operations = [ \\"add 1\\", \\"add 2\\", \\"add 3\\", \\"add 4\\", \\"add 5\\", \\"add 6\\", \\"kth 6\\", \\"end\\" ] assert process_operations(operations) == [\\"6\\"]","solution":"import bisect class BookWarehouse: def __init__(self): self.books = [] def add(self, x): bisect.insort(self.books, x) def remove(self, x): index = bisect.bisect_left(self.books, x) if index != len(self.books) and self.books[index] == x: self.books.pop(index) def kth(self, k): return self.books[k-1] def process_operations(operations): import sys output = [] warehouse = BookWarehouse() for operation in operations: if operation.startswith(\\"add \\"): _, x = operation.split() warehouse.add(int(x)) elif operation.startswith(\\"remove \\"): _, x = operation.split() warehouse.remove(int(x)) elif operation.startswith(\\"kth \\"): _, k = operation.split() output.append(str(warehouse.kth(int(k)))) elif operation == \\"end\\": break return output"},{"question":"def minimum_cuts(width: int, height: int) -> int: Calculate the minimum number of cuts needed to split the rectangular chocolate bar into 1x1 squares. Parameters: width (int): The width of the chocolate bar. height (int): The height of the chocolate bar. Returns: int: The minimum number of cuts. Examples: >>> minimum_cuts(2, 3) 5 >>> minimum_cuts(4, 4) 15 >>> minimum_cuts(5, 7) 34 >>> minimum_cuts(1, 1) 0 >>> minimum_cuts(1, 5) 4 import pytest from solution import minimum_cuts def test_example_case_1(): assert minimum_cuts(2, 3) == 5 def test_example_case_2(): assert minimum_cuts(4, 4) == 15 # 16 - 1 def test_example_case_3(): assert minimum_cuts(5, 7) == 34 def test_single_square(): assert minimum_cuts(1, 1) == 0 # Already 1x1 def test_large_case(): assert minimum_cuts(1000000, 1000000) == 999999999999 def test_edge_case_small_dimensions(): assert minimum_cuts(1, 5) == 4 # 5 cuts to get 5 small pieces # Run tests pytest.main()","solution":"def minimum_cuts(width, height): Calculate the minimum number of cuts needed to split the rectangular chocolate bar into 1x1 squares. Parameters: width (int): The width of the chocolate bar. height (int): The height of the chocolate bar. Returns: int: The minimum number of cuts. return width * height - 1"},{"question":"def product_of_nonzero_elements(n: int, arr: List[int]) -> int: Returns the product of all non-zero elements in the array. If all elements are zero, returns 0. >>> product_of_nonzero_elements(5, [1, 2, 3, 4, 0]) 24 >>> product_of_nonzero_elements(4, [0, 0, 0, 0]) 0 >>> product_of_nonzero_elements(3, [-1, -2, -3]) 6 from typing import List def test_product_with_zeros_mixed(): assert product_of_nonzero_elements(5, [1, 2, 3, 4, 0]) == 24 def test_all_zeroes(): assert product_of_nonzero_elements(4, [0, 0, 0, 0]) == 0 def test_no_zeroes(): assert product_of_nonzero_elements(3, [-1, -2, -3]) == -6 assert product_of_nonzero_elements(3, [1, 2, 3]) == 6 def test_single_element(): assert product_of_nonzero_elements(1, [0]) == 0 assert product_of_nonzero_elements(1, [5]) == 5 def test_single_nonzero_element_among_zeroes(): assert product_of_nonzero_elements(5, [0, 0, 0, 0, 5]) == 5 assert product_of_nonzero_elements(5, [0, 0, 0, 0, -5]) == -5","solution":"def product_of_nonzero_elements(n, arr): Returns the product of all non-zero elements in the array. If all elements are zero, returns 0. product = 1 non_zero_found = False for num in arr: if num != 0: product *= num non_zero_found = True return product if non_zero_found else 0"},{"question":"from collections import deque from typing import List def shortest_path_in_grid(m: int, n: int, grid: List[List[int]], sx: int, sy: int, tx: int, ty: int) -> int: Find the length of the shortest path from the start position to the target position in a grid. Args: m (int): number of rows in the grid n (int): number of columns in the grid grid (List[List[int]]): the grid itself where 0 represents passable cell and 1 represents an obstacle sx (int): starting x-coordinate sy (int): starting y-coordinate tx (int): target x-coordinate ty (int): target y-coordinate Returns: int: the length of the shortest path from (sx, sy) to (tx, ty). If no valid path exists, return -1 Examples: >>> shortest_path_in_grid(5, 5, [ [0, 1, 0, 0, 0], [0, 1, 0, 1, 0], [0, 0, 0, 1, 0], [0, 1, 1, 1, 0], [0, 0, 0, 0, 0]], 0, 0, 4, 4) 8 >>> shortest_path_in_grid(3, 3, [ [0, 1, 0], [0, 1, 0], [0, 0, 0]], 0, 0, 2, 2) 4","solution":"from collections import deque def shortest_path_in_grid(m, n, grid, sx, sy, tx, ty): if grid[sx][sy] == 1 or grid[tx][ty] == 1: return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] queue = deque([(sx, sy, 0)]) visited = set((sx, sy)) while queue: x, y, dist = queue.popleft() if (x, y) == (tx, ty): return dist for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: visited.add((nx, ny)) queue.append((nx, ny, dist + 1)) return -1"},{"question":"def encode_string(s: str) -> str: Encode a string by replacing each character in it with its corresponding letter in the alphabet after shifting by 3 places. If the character is at the end of the alphabet, it wraps around to the beginning. Non-alphabet characters remain unchanged. Examples: >>> encode_string(\\"abc\\") \\"def\\" >>> encode_string(\\"xyz\\") \\"abc\\" >>> encode_string(\\"Hello, World!\\") \\"Khoor, Zruog!\\" # Your code here # Unit tests def test_encode_string_all_lowercase(): assert encode_string(\\"abc\\") == \\"def\\" assert encode_string(\\"xyz\\") == \\"abc\\" def test_encode_string_all_uppercase(): assert encode_string(\\"ABC\\") == \\"DEF\\" assert encode_string(\\"XYZ\\") == \\"ABC\\" def test_encode_string_mixed_case(): assert encode_string(\\"Hello, World!\\") == \\"Khoor, Zruog!\\" def test_encode_string_with_non_alpha(): assert encode_string(\\"123 @#\\") == \\"123 @#\\" assert encode_string(\\"!@#ABCxyz789\\") == \\"!@#DEFabc789\\" def test_encode_string_empty(): assert encode_string(\\"\\") == \\"\\" def test_encode_string_long_string(): long_input = \\"a\\" * 100000 assert encode_string(long_input) == \\"d\\" * 100000","solution":"def encode_string(s: str) -> str: def shift_char(c): if 'a' <= c <= 'z': return chr((ord(c) - ord('a') + 3) % 26 + ord('a')) elif 'A' <= c <= 'Z': return chr((ord(c) - ord('A') + 3) % 26 + ord('A')) else: return c return ''.join(shift_char(c) for c in s)"},{"question":"def pair_sum_exists(n: int, k: int, arr: List[int]) -> str: Check if there exist two elements in the array whose sum is equal to a given integer K. If such a pair exists, output 'YES'; otherwise, output 'NO'. >>> pair_sum_exists(5, 10, [3, 4, 5, 6, 7]) 'YES' >>> pair_sum_exists(4, 8, [1, 2, 3, 9]) 'NO'","solution":"def pair_sum_exists(n, k, arr): Returns 'YES' if there are two distinct elements in arr whose sum is equal to k. Otherwise, returns 'NO'. seen = set() for number in arr: if k - number in seen: return \\"YES\\" seen.add(number) return \\"NO\\" def from_input_string(input_string): lines = input_string.strip().split('n') n, k = map(int, lines[0].split()) arr = list(map(int, lines[1].split())) return n, k, arr def to_input_string(inputs): n, k, arr = inputs return f\\"{n} {k}n{' '.join(map(str, arr))}\\" def from_output_string(output_string): return output_string.strip() def to_output_string(output): return output"},{"question":"def min_difficulty_subarray(N: int, S: int, difficulties: List[int]) -> int: Returns the minimum sum of difficulties of a contiguous subarray that is at least S. >>> min_difficulty_subarray(5, 15, [1, 2, 3, 4, 5]) 15 >>> min_difficulty_subarray(7, 20, [2, 1, 5, 2, 8, 1, 5]) 21 >>> min_difficulty_subarray(5, 100, [1, 2, 3, 4, 5]) -1 from min_difficulty_subarray import min_difficulty_subarray def test_example_1(): assert min_difficulty_subarray(5, 15, [1, 2, 3, 4, 5]) == 15 def test_example_2(): assert min_difficulty_subarray(7, 20, [2, 1, 5, 2, 8, 1, 5]) == 21 def test_example_3(): assert min_difficulty_subarray(5, 100, [1, 2, 3, 4, 5]) == -1 def test_exact_threshold(): assert min_difficulty_subarray(4, 10, [3, 4, 2, 1]) == 10 def test_no_possible_subarray(): assert min_difficulty_subarray(3, 50, [5, 10, 15]) == -1 def test_single_element_meets_threshold(): assert min_difficulty_subarray(5, 4, [1, 2, 3, 4, 5]) == 4 def test_large_input_with_minimal_threshold(): assert min_difficulty_subarray(100000, 1, [1]*100000) == 1","solution":"def min_difficulty_subarray(N, S, difficulties): Returns the minimum sum of difficulties of a contiguous subarray that is at least S. min_length = float('inf') current_sum = 0 left = 0 for right in range(N): current_sum += difficulties[right] while current_sum >= S: min_length = min(min_length, current_sum) current_sum -= difficulties[left] left += 1 return min_length if min_length != float('inf') else -1 # Example usage: # N, S = map(int, input().split()) # difficulties = list(map(int, input().split())) # print(min_difficulty_subarray(N, S, difficulties))"},{"question":"from typing import List def longest_valid_substring(S: str, K: int) -> str: This function returns the longest substring of S that contains no more than K different characters. If there are multiple substrings of the same maximum length, return the one that appears first. Parameters: S (str): The input string. K (int): The maximum number of different characters allowed in the substring. Returns: str: The longest valid substring. # Your code here return \\"\\" # Unit tests def test_sample_case_1(): assert longest_valid_substring(\\"abcba\\", 2) == \\"bcb\\" def test_single_char_string(): assert longest_valid_substring(\\"a\\", 1) == \\"a\\" assert longest_valid_substring(\\"a\\", 0) == \\"\\" def test_all_unique_chars(): assert longest_valid_substring(\\"abcdef\\", 3) == \\"abc\\" assert longest_valid_substring(\\"abcdef\\", 6) == \\"abcdef\\" def test_multiple_valid_substrings_of_same_length(): assert longest_valid_substring(\\"aabbcc\\", 2) == \\"aabb\\" assert longest_valid_substring(\\"aabbcc\\", 1) == \\"aa\\" def test_large_input(): S = \\"a\\" * 10**5 K = 1 assert longest_valid_substring(S, K) == \\"a\\" * 10**5 def test_zero_k(): assert longest_valid_substring(\\"abc\\", 0) == \\"\\" def test_same_char_repeated(): assert longest_valid_substring(\\"aaaaaa\\", 1) == \\"aaaaaa\\" assert longest_valid_substring(\\"aaaaaa\\", 2) == \\"aaaaaa\\" def test_multiple_char_string(): assert longest_valid_substring(\\"abaccc\\", 2) == \\"accc\\" def test_alternate_chars_string(): assert longest_valid_substring(\\"ababab\\", 2) == \\"ababab\\" assert longest_valid_substring(\\"ababab\\", 1) == \\"a\\" def test_non_contiguous_valid_substrings(): assert longest_valid_substring(\\"aabacbebebe\\", 3) == \\"cbebebe\\"","solution":"def longest_valid_substring(S, K): This function returns the longest substring of S that contains no more than K different characters. If there are multiple substrings of the same maximum length, return the one that appears first. Parameters: S (str): The input string. K (int): The maximum number of different characters allowed in the substring. Returns: str: The longest valid substring. n = len(S) if K == 0: return \\"\\" start = 0 max_len = 0 max_substr = \\"\\" char_count = {} for end in range(n): char_count[S[end]] = char_count.get(S[end], 0) + 1 while len(char_count) > K: char_count[S[start]] -= 1 if char_count[S[start]] == 0: del char_count[S[start]] start += 1 current_len = end - start + 1 if current_len > max_len: max_len = current_len max_substr = S[start:end + 1] return max_substr"},{"question":"def is_valid_grid(N: int, M: int, grid: List[List[str]]) -> None: Determine if the provided grid satisfies both conditions. 1. All rows and all columns must contain at least one \`1\`. 2. Each \`1\` in the grid must be part of at least one \`2x2\` subgrid of \`1\`s. Args: N (int): Number of rows in the grid. M (int): Number of columns in the grid. grid (List[List[str]]): Grid containing '0's and '1's. Prints: str: \\"YES\\" if the grid is valid, otherwise \\"NO\\". >>> grid = [ ... ['1', '0', '1'], ... ['0', '1', '0'], ... ['1', '0', '1'] ... ] >>> is_valid_grid(3, 3, grid) NO >>> grid = [ ... ['1', '1', '1'], ... ['1', '1', '1'], ... ['1', '1', '1'] ... ] >>> is_valid_grid(3, 3, grid) YES # Implement the function according to the rules # Example Usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [] index = 2 for _ in range(N): grid.append(data[index:index + M]) index += M is_valid_grid(N, M, grid)","solution":"def is_valid_grid(N, M, grid): # Function to check if row contains at least one '1' def contains_one_in_all_rows(): for row in grid: if '1' not in row: return False return True # Function to check if column contains at least one '1' def contains_one_in_all_columns(): for col in range(M): if all(grid[row][col] == '0' for row in range(N)): return False return True # Function to check if each '1' is part of at least one 2x2 subgrid of '1's def each_one_in_2x2_subgrid(): for i in range(N - 1): for j in range(M - 1): if grid[i][j] == '1' or grid[i+1][j] == '1' or grid[i][j+1] == '1' or grid[i+1][j+1] == '1': if grid[i][j] == '1' and grid[i+1][j] == '1' and grid[i][j+1] == '1' and grid[i+1][j+1] == '1': return True return False if contains_one_in_all_rows() and contains_one_in_all_columns() and each_one_in_2x2_subgrid(): print(\\"YES\\") else: print(\\"NO\\") # Example Usage: if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) M = int(data[1]) grid = [] index = 2 for _ in range(N): grid.append(data[index:index + M]) index += M is_valid_grid(N, M, grid)"},{"question":"def calculate_billing(data): Calculates the billing amount for each parcel based on its delivery mode and weight. >>> calculate_billing([(4, 10), (3, 5), (1, 2), (2, 8)]) [2000, 2000, 2000, 5600] >>> calculate_billing([(1, 0), (2, 0), (3, 0), (4, 0)]) [0, 0, 0, 0] >>> calculate_billing([(1, 1), (2, 2), (3, 3), (4, 4)]) [1000, 1400, 1200, 800] >>> calculate_billing([(3, 7), (4, 7), (1, 7), (2, 7)]) [2800, 1400, 7000, 4900] >>> calculate_billing([(1, 100), (2, 50), (3, 10), (4, 0)]) [100000, 35000, 4000, 0]","solution":"def calculate_billing(data): Calculates the billing amount for each parcel based on its delivery mode and weight. Parameters: data (list of tuples): Each tuple contains (m, w) where m is the delivery mode and w is the weight in kg. Returns: list of int: Billing amount for each parcel. # Prices per kg for each mode. Index 0 is a placeholder to make the mapping direct prices = [0, 1000, 700, 400, 200] result = [] for m, w in data: cost = prices[m] * w result.append(cost) return result"},{"question":"def max_square_subgrid(R: int, C: int, K: int, grid: List[str]) -> int: You are given a grid with R rows and C columns. Each cell in the grid contains either '0' or '1'. You can change any '1' in the grid to '0', but you can only do this operation K times. The goal is to find the maximum size of a square subgrid that contains only '0's after performing at most K changes from '1' to '0'. >>> max_square_subgrid(4, 5, 3, [ \\"01101\\", \\"11001\\", \\"01110\\", \\"11000\\" ]) 3 >>> max_square_subgrid(3, 3, 1, [ \\"010\\", \\"100\\", \\"111\\" ]) 2 >>> max_square_subgrid(3, 3, 0, [ \\"000\\", \\"000\\", \\"000\\" ]) 3","solution":"def max_square_subgrid(R, C, K, grid): def can_form_square_of_size(size): # A helper function to check if we can have a square of the given size prefix_sum = [[0] * (C + 1) for _ in range(R + 1)] # Creating prefix sum matrix for easier subgrid sum calculation for i in range(1, R + 1): for j in range(1, C + 1): prefix_sum[i][j] = int(grid[i - 1][j - 1] == '1') + prefix_sum[i - 1][j] + prefix_sum[i][j - 1] - prefix_sum[i - 1][j - 1] # Checking every possible top-left corner of the square of size \`size\` for i in range(size, R + 1): for j in range(size, C + 1): num_ones = prefix_sum[i][j] - prefix_sum[i - size][j] - prefix_sum[i][j - size] + prefix_sum[i - size][j - size] if num_ones <= K: return True return False # Binary search for the maximum size of the square subgrid low, high = 1, min(R, C) result = 0 while low <= high: mid = (low + high) // 2 if can_form_square_of_size(mid): result = mid low = mid + 1 else: high = mid - 1 return result # Implementation for input/output if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() R = int(data[0]) C = int(data[1]) K = int(data[2]) grid = data[3:] print(max_square_subgrid(R, C, K, grid))"},{"question":"def maximum_treasure(n, L, treasures, edges): Determine the maximum amount of treasure that can be collected within the given path length limit. Args: n (int): Number of rooms. L (int): Maximum total length of pathways that can be traversed. treasures (List[int]): List containing the amount of treasure in each room. edges (List[Tuple[int, int, int]]): List of tuples representing the pathways, where each tuple consists of two rooms connected by the pathway and the length of the pathway. Returns: int: The maximum amount of treasure that can be collected. Examples: >>> n = 4 >>> L = 10 >>> treasures = [5, 10, 15, 20] >>> edges = [(1, 2, 5), (1, 3, 4), (2, 3, 3), (3, 4, 1)] >>> maximum_treasure(n, L, treasures, edges) 50 pass","solution":"import heapq def maximum_treasure(n, L, treasures, edges): graph = [[] for _ in range(n)] for u, v, l in edges: graph[u-1].append((l, v-1)) graph[v-1].append((l, u-1)) pq = [(0, 0)] # (current length, current node) max_treasures = 0 visited = [False] * n current_length = [float('inf')] * n current_length[0] = 0 while pq: length, node = heapq.heappop(pq) if visited[node]: continue visited[node] = True max_treasures += treasures[node] for next_length, next_node in graph[node]: if not visited[next_node] and length + next_length <= L and length + next_length < current_length[next_node]: current_length[next_node] = length + next_length heapq.heappush(pq, (length + next_length, next_node)) return max_treasures # Example usage n = 4 L = 10 treasures = [5, 10, 15, 20] edges = [(1, 2, 5), (1, 3, 4), (2, 3, 3), (3, 4, 1)] print(maximum_treasure(n, L, treasures, edges)) # Output: 50"},{"question":"def find_free_cabin_platform(heights: List[int]) -> int: Identifies the first \\"free-standing\\" platform. A platform is considered \\"free-standing\\" if it is greater than the platform immediately before it and the platform immediately after it. :param heights: List of integers representing the heights of platforms. :return: Index of the first \\"free-standing\\" platform or -1 if none exists. >>> find_free_cabin_platform([3, 2, 6, 5, 3, 7, 8]) 2 >>> find_free_cabin_platform([1, 2, 3, 4, 5]) -1","solution":"def find_free_cabin_platform(heights): Identifies the first \\"free-standing\\" platform. A platform is considered \\"free-standing\\" if it is greater than the platform immediately before it and the platform immediately after it. :param heights: List of integers representing the heights of platforms. :return: Index of the first \\"free-standing\\" platform or -1 if none exists. for i in range(1, len(heights) - 1): if heights[i] > heights[i - 1] and heights[i] > heights[i + 1]: return i return -1"},{"question":"def max_magical_energy(n: int, energies: List[int]) -> int: Finds the maximum possible magical energy the magician can absorb by choosing an optimal start and stop section. Parameters: n (int): Number of sections in the river. energies (list of int): Energies of each section. Returns: int: Maximum magical energy that can be absorbed. Examples: >>> assert max_magical_energy(5, [-1, 2, 3, -2, 4]) == 7 >>> assert max_magical_energy(3, [-5, -3, -1]) == -1 >>> assert max_magical_energy(6, [2, 3, 4, -1, -2, 1]) == 9 >>> assert max_magical_energy(4, [-8, -3, -6, -2]) == -2 >>> assert max_magical_energy(5, [1, 2, 3, 4, 5]) == 15 >>> assert max_magical_energy(1, [42]) == 42 >>> assert max_magical_energy(1, [-42]) == -42 >>> assert max_magical_energy(7, [1, -3, 2, 1, -1, 3, -5]) == 5","solution":"def max_magical_energy(n, energies): Finds the maximum possible magical energy the magician can absorb by choosing an optimal start and stop section. Parameters: n (int): Number of sections in the river. energies (list of int): Energies of each section. Returns: int: Maximum magical energy that can be absorbed. # Implementation of Kadane's Algorithm for maximum subarray sum max_ending_here = max_so_far = energies[0] for i in range(1, n): max_ending_here = max(energies[i], max_ending_here + energies[i]) max_so_far = max(max_so_far, max_ending_here) return max_so_far"},{"question":"def are_circular_permutations(s1: str, s2: str) -> bool: Determines if two strings are circular permutations of each other. >>> are_circular_permutations(\\"abc\\", \\"bca\\") True >>> are_circular_permutations(\\"abc\\", \\"abc\\") True >>> are_circular_permutations(\\"abc\\", \\"cab\\") True >>> are_circular_permutations(\\"abc\\", \\"def\\") False pass def check_circular_permutations(n: int, test_cases: [(str, str)]) -> [str]: Check multiple test cases to determine if pairs of strings are circular permutations of each other. >>> check_circular_permutations(4, [(\\"abc\\", \\"bca\\"), (\\"abc\\", \\"abc\\"), (\\"abc\\", \\"cab\\"), (\\"abc\\", \\"def\\")]) [\\"YES\\", \\"YES\\", \\"YES\\", \\"NO\\"] >>> check_circular_permutations(2, [(\\"abcd\\", \\"bcda\\"), (\\"abcd\\", \\"abdc\\")]) [\\"YES\\", \\"NO\\"] >>> check_circular_permutations(3, [(\\"abcd\\", \\"dabc\\"), (\\"abcd\\", \\"cdab\\"), (\\"abcd\\", \\"abcd\\")]) [\\"YES\\", \\"YES\\", \\"YES\\"] >>> check_circular_permutations(1, [(\\"abcdefg\\", \\"efgabcd\\")]) [\\"YES\\"] >>> check_circular_permutations(1, [(\\"abcdefg\\", \\"gfedcba\\")]) [\\"NO\\"] pass","solution":"def are_circular_permutations(s1, s2): Determines if two strings are circular permutations of each other. if len(s1) != len(s2): return False concatenated_s1 = s1 + s1 return s2 in concatenated_s1 def check_circular_permutations(n, test_cases): results = [] for s1, s2 in test_cases: if are_circular_permutations(s1, s2): results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"from typing import List, Tuple def shortest_path(grid: List[List[int]], m: int, n: int, start: Tuple[int, int], end: Tuple[int, int]) -> int: Find the shortest path from start to end in the given grid. :param grid: List[List[int]]: The grid representation (0=empty space, 1=obstacle) :param m: int: Number of rows in the grid :param n: int: Number of columns in the grid :param start: Tuple[int, int]: Start cell (sx, sy) :param end: Tuple[int, int]: Destination cell (dx, dy) :return: int: Length of the shortest path from start to end, -1 if no such path exists pass # Example usage if __name__ == \\"__main__\\": grid_example = [ [0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0] ] m_example = 5 n_example = 6 start_example = (0, 0) end_example = (4, 5) print(shortest_path(grid_example, m_example, n_example, start_example, end_example))","solution":"from collections import deque def shortest_path(grid, m, n, start, end): Find the shortest path from start to end in the given grid. :param grid: List[List[int]]: The grid representation (0=empty space, 1=obstacle) :param m: int: Number of rows in the grid :param n: int: Number of columns in the grid :param start: Tuple[int, int]: Start cell (sx, sy) :param end: Tuple[int, int]: Destination cell (dx, dy) :return: int: Length of shortest path from start to end, -1 if no such path exists sx, sy = start dx, dy = end if start == end: return 0 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] visited = set() queue = deque([(sx, sy, 0)]) # (x, y, distance) visited.add((sx, sy)) while queue: x, y, dist = queue.popleft() for direction in directions: nx, ny = x + direction[0], y + direction[1] if 0 <= nx < m and 0 <= ny < n and (nx, ny) not in visited and grid[nx][ny] == 0: if (nx, ny) == (dx, dy): return dist + 1 queue.append((nx, ny, dist + 1)) visited.add((nx, ny)) return -1 # Example usage if __name__ == \\"__main__\\": grid_example = [ [0, 0, 0, 0, 1, 0], [0, 1, 1, 0, 1, 0], [0, 1, 0, 0, 0, 0], [1, 0, 0, 1, 1, 0], [0, 1, 0, 0, 0, 0] ] m_example = 5 n_example = 6 start_example = (0, 0) end_example = (4, 5) print(shortest_path(grid_example, m_example, n_example, start_example, end_example))"},{"question":"def largest_square_area(matrices): Finds the largest square sub-matrix containing only 'X' characters for each input matrix. Parameters: matrices (List[Tuple[int, List[str]]]): A list of tuples where each tuple contains an integer N and a list of N strings representing the matrix. Returns: List[int]: A list of integers where each integer is the area of the largest square sub-matrix containing only 'X' characters for each input matrix. pass # Unit tests def test_single_test_case_4x4(): matrices = [(4, [\\"XXXX\\", \\"XOOO\\", \\"XXOO\\", \\"XXXX\\"])] assert largest_square_area(matrices) == [4] def test_single_test_case_3x3(): matrices = [(3, [\\"XOX\\", \\"OOO\\", \\"XOX\\"])] assert largest_square_area(matrices) == [1] def test_multiple_test_cases(): matrices = [ (4, [\\"XXXX\\", \\"XOOO\\", \\"XXOO\\", \\"XXXX\\"]), (3, [\\"XOX\\", \\"OOO\\", \\"XOX\\"]) ] assert largest_square_area(matrices) == [4, 1] def test_all_Os(): matrices = [(3, [\\"OOO\\", \\"OOO\\", \\"OOO\\"])] assert largest_square_area(matrices) == [0] def test_entire_Xs(): matrices = [(3, [\\"XXX\\", \\"XXX\\", \\"XXX\\"])] assert largest_square_area(matrices) == [9] def test_mixed_Xs_and_Os(): matrices = [ (5, [\\"XOXOX\\", \\"OXOXO\\", \\"XOXOX\\", \\"OXOXO\\", \\"XOXOX\\"]), (2, [\\"XO\\", \\"OX\\"]) ] assert largest_square_area(matrices) == [1, 1] def test_single_element(): matrices = [ (1, [\\"X\\"]), (1, [\\"O\\"]) ] assert largest_square_area(matrices) == [1, 0]","solution":"def largest_square_area(matrices): Finds the largest square sub-matrix containing only 'X' characters for each input matrix. Parameters: matrices (List[Tuple[int, List[str]]]): A list of tuples where each tuple contains an integer N and a list of N strings representing the matrix. Returns: List[int]: A list of integers where each integer is the area of the largest square sub-matrix containing only 'X' characters for each input matrix. results = [] for N, matrix in matrices: if N == 0: results.append(0) continue dp = [[0]*N for _ in range(N)] max_side_length = 0 for i in range(N): for j in range(N): if matrix[i][j] == 'X': if i == 0 or j == 0: dp[i][j] = 1 else: dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1 max_side_length = max(max_side_length, dp[i][j]) area = max_side_length ** 2 results.append(area) return results"},{"question":"def count_vowels_and_consonants(s: str) -> Tuple[int, int]: Returns the number of vowels and consonants in the string s. >>> count_vowels_and_consonants(\\"hello\\") (2, 3) >>> count_vowels_and_consonants(\\"programming\\") (3, 8) >>> count_vowels_and_consonants(\\"abracadabra\\") (5, 6)","solution":"def count_vowels_and_consonants(s): Returns the number of vowels and consonants in the string s. vowels = set(\\"aeiou\\") number_of_vowels = sum(1 for char in s if char in vowels) number_of_consonants = len(s) - number_of_vowels return (number_of_vowels, number_of_consonants)"},{"question":"def min_operations_to_reduce_to_one(n: int) -> int: Returns the minimum number of operations required to reduce n to 1. >>> min_operations_to_reduce_to_one(10) 3 >>> min_operations_to_reduce_to_one(27) 3 >>> min_operations_to_reduce_to_one(1) 0","solution":"def min_operations_to_reduce_to_one(n): Returns the minimum number of operations required to reduce n to 1. if n == 1: return 0 dp = [0] * (n + 1) for i in range(2, n + 1): dp[i] = dp[i - 1] + 1 if i % 2 == 0: dp[i] = min(dp[i], dp[i // 2] + 1) if i % 3 == 0: dp[i] = min(dp[i], dp[i // 3] + 1) return dp[n]"},{"question":"def find_closest_submatrix_sum(matrix: List[List[int]]) -> int: Finds the submatrix with the sum closest to zero. Args: matrix (list of list of ints): The input matrix. Returns: int: The sum of the elements of the submatrix which is closest to zero. Examples: >>> find_closest_submatrix_sum([[1]]) 1 >>> find_closest_submatrix_sum([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) 1 >>> find_closest_submatrix_sum([[1, -2, 3], [-4, 5, -6], [7, -8, 9]]) 0 >>> find_closest_submatrix_sum([[1, 2, -3], [-1, -2, 3], [1, 2, -3]]) 0 >>> find_closest_submatrix_sum([[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]]) -1 pass from typing import List def test_single_element(): matrix = [[1]] assert find_closest_submatrix_sum(matrix) == 1 def test_all_positives(): matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] assert find_closest_submatrix_sum(matrix) == 1 def test_mix_positive_negative(): matrix = [[1, -2, 3], [-4, 5, -6], [7, -8, 9]] assert find_closest_submatrix_sum(matrix) == 0 def test_zero_submatrix(): matrix = [[1, 2, -3], [-1, -2, 3], [1, 2, -3]] assert find_closest_submatrix_sum(matrix) == 0 def test_already_closest_negative(): matrix = [[-1, -2, -3], [-4, -5, -6], [-7, -8, -9]] assert find_closest_submatrix_sum(matrix) == -1","solution":"def find_closest_submatrix_sum(matrix): Finds the submatrix with the sum closest to zero. Args: matrix (list of list of ints): The input matrix. Returns: int: The sum of the elements of the submatrix which is closest to zero. m = len(matrix) n = len(matrix[0]) closest_sum = float('inf') closest_val = None # Precompute cumulative sums for the matrix cum_matrix = [[0]*n for _ in range(m)] cum_matrix[0][0] = matrix[0][0] for i in range(1, m): cum_matrix[i][0] = cum_matrix[i-1][0] + matrix[i][0] for j in range(1, n): cum_matrix[0][j] = cum_matrix[0][j-1] + matrix[0][j] for i in range(1, m): for j in range(1, n): cum_matrix[i][j] = matrix[i][j] + cum_matrix[i-1][j] + cum_matrix[i][j-1] - cum_matrix[i-1][j-1] for r1 in range(m): for r2 in range(r1, m): for c1 in range(n): for c2 in range(c1, n): cur_sum = cum_matrix[r2][c2] if r1 > 0: cur_sum -= cum_matrix[r1-1][c2] if c1 > 0: cur_sum -= cum_matrix[r2][c1-1] if r1 > 0 and c1 > 0: cur_sum += cum_matrix[r1-1][c1-1] if abs(cur_sum) < abs(closest_sum): closest_sum = cur_sum closest_val = cur_sum # If we find a sum that is exactly zero, we can return immediately if closest_val == 0: return closest_val return closest_val"},{"question":"from typing import List, Tuple def dijkstra(graph, start, end, get_weight): ... def shortest_paths(n: int, m: int, connections: List[Tuple[int, int, int, int, int]], queries: List[Tuple[int, int]]) -> List[str]: Determine the shortest paths between devices in a network with variable weights. Args: n (int): The number of devices (nodes). m (int): The number of connections (edges). connections (List[Tuple[int, int, int, int, int]]): List of connections where each connection is represented by 5 integers (a, b, l, u, f). queries (List[Tuple[int, int]]): List of queries where each query consists of two integers (x, y). Returns: List[str]: The list containing the minimum and maximum time weights for the shortest path from x to y for each query. If there is no path between x and y, returns \\"NO PATH\\". Example: >>> process_input(\\"4 4 2n1 2 4 10 1n2 3 3 5 0n2 4 1 2 1n3 4 2 7 0n1 3n1 4n0 0 0\\") [\\"7 15\\", \\"5 12\\"] def process_input(input_str: str) -> List[str]: ...","solution":"import heapq import sys def dijkstra(graph, start, end, get_weight): n = len(graph) dist = [sys.maxsize] * n dist[start] = 0 queue = [(0, start)] while queue: current_distance, current_node = heapq.heappop(queue) if current_distance > dist[current_node]: continue for neighbor, weight_range in graph[current_node]: min_weight, max_weight = weight_range weight = get_weight(min_weight, max_weight) distance = current_distance + weight if distance < dist[neighbor]: dist[neighbor] = distance heapq.heappush(queue, (distance, neighbor)) return dist[end] if dist[end] != sys.maxsize else \\"NO PATH\\" def shortest_paths(n, m, connections, queries): graph_min = [[] for _ in range(n)] graph_max = [[] for _ in range(n)] for a, b, l, u, f in connections: graph_min[a - 1].append((b - 1, (l, l))) graph_max[a - 1].append((b - 1, (u, u))) if f == 1: graph_min[b - 1].append((a - 1, (l, l))) graph_max[b - 1].append((a - 1, (u, u))) results = [] for x, y in queries: min_weight = dijkstra(graph_min, x - 1, y - 1, lambda l, u: l) max_weight = dijkstra(graph_max, x - 1, y - 1, lambda l, u: u) if min_weight == \\"NO PATH\\" or max_weight == \\"NO PATH\\": results.append(\\"NO PATH\\") else: results.append(f\\"{min_weight} {max_weight}\\") return results def process_input(input_str): input_lines = input_str.strip().split('n') idx = 0 results = [] while idx < len(input_lines): n, m, q = map(int, input_lines[idx].split()) if n == 0 and m == 0 and q == 0: break idx += 1 connections = [] for _ in range(m): a, b, l, u, f = map(int, input_lines[idx].split()) connections.append((a, b, l, u, f)) idx += 1 queries = [] for _ in range(q): x, y = map(int, input_lines[idx].split()) queries.append((x, y)) idx += 1 results.extend(shortest_paths(n, m, connections, queries)) return results"},{"question":"def apply_operations(operations: List[int], threshold: int) -> int: Apply a sequence of operations with a threshold constraint. Parameters: operations (list of int): The list of operations to apply. threshold (int): The threshold value which the total should not exceed. Returns: int: The final value after applying the operations constrained by the threshold. # Write your code here from typing import List def test_operations_below_threshold(): assert apply_operations([2, -3, 5, -2, 10], 100) == 38 assert apply_operations([1, 1, 1, 1, -2], 10) == 10 def test_operations_reaching_threshold(): assert apply_operations([100, -3, 5], 50) == 50 assert apply_operations([2, -5, 5, 10], 25) == 25 def test_operations_initially_exceeding_threshold(): assert apply_operations([50, -1, 2, -3, 4], 10) == 10 assert apply_operations([20, 30, -5], 45) == 45 def test_operations_no_effect_after_threshold(): assert apply_operations([5, 10, -3, 2], 10) == 10 assert apply_operations([6, 7, -8, 1], 10) == 10 def test_operations_no_operations(): assert apply_operations([], 10) == 1 assert apply_operations([], 1000) == 1 def test_operations_single_operation(): assert apply_operations([10], 50) == 11 assert apply_operations([-10], 50) == 10","solution":"def apply_operations(operations, threshold): Apply a sequence of operations with a threshold constraint. Parameters: operations (list of int): The list of operations to apply. threshold (int): The threshold value which the total should not exceed. Returns: int: The final value after applying the operations constrained by the threshold. total = 1 for op in operations: if abs(total) >= threshold: return threshold if op > 0: total += op else: total *= abs(op) if total >= threshold: return threshold return total"},{"question":"def can_all_receive_power(t: int, test_cases: List[Tuple[int, List[Tuple[int, int]]]]) -> List[str]: Determines if every contact point on the circuit board can receive power from any given contact point. Args: t (int): Number of test cases. test_cases (List[Tuple[int, List[Tuple[int, int]]]]): List of test cases where each test case contains the number of switches and a list of tuples denoting the connected contact points. Returns: List[str]: List of \\"YES\\" or \\"NO\\" for each test case. >>> can_all_receive_power(2, [(4, [(1, 2), (2, 3), (3, 4), (4, 5)]), (3, [(8, 9), (9, 10), (10, 11)])]) ['YES', 'NO'] >>> can_all_receive_power(1, [(3, [(8, 9), (9, 10), (11, 12)])]) ['NO']","solution":"def can_all_receive_power(t, test_cases): def find(parent, i): if parent[i] == i: return i return find(parent, parent[i]) def union(parent, rank, x, y): root_x = find(parent, x) root_y = find(parent, y) if root_x != root_y: if rank[root_x] > rank[root_y]: parent[root_y] = root_x elif rank[root_x] < rank[root_y]: parent[root_x] = root_y else: parent[root_y] = root_x rank[root_x] += 1 results = [] for n, switches in test_cases: if n == 0: results.append(\\"NO\\") continue parent = {} rank = {} for x, y in switches: if x not in parent: parent[x] = x rank[x] = 0 if y not in parent: parent[y] = y rank[y] = 0 union(parent, rank, x, y) roots = set(find(parent, node) for node in parent) if len(roots) == 1: results.append(\\"YES\\") else: results.append(\\"NO\\") return results"},{"question":"def fill_puzzle(grid, N): Fill the given N x N grid with numbers from 1 to N according to the given rules, or determine if it's impossible. >>> fill_puzzle([[1, 0, 3], [0, 0, 0], [2, 3, 0]], 3) 1 2 3 3 1 2 2 3 1 >>> fill_puzzle([[1, 2, 0], [2, 3, 1], [0, 1, 2]], 3) NO SOLUTION pass","solution":"def is_safe(grid, N, row, col, num): Check if it's safe to place num in grid[row][col] for x in range(N): if grid[row][x] == num or grid[x][col] == num: return False # Check for adjacent cells if row > 0 and grid[row - 1][col] == num: return False if row < N - 1 and grid[row + 1][col] == num: return False if col > 0 and grid[row][col - 1] == num: return False if col < N - 1 and grid[row][col + 1] == num: return False return True def solve_grid(grid, N): for row in range(N): for col in range(N): if grid[row][col] == 0: for num in range(1, N + 1): if is_safe(grid, N, row, col, num): grid[row][col] = num if solve_grid(grid, N): return True grid[row][col] = 0 return False return True def fill_puzzle(grid, N): if solve_grid(grid, N): for row in grid: print(' '.join(map(str, row))) return print(\\"NO SOLUTION\\") if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() N = int(data[0]) grid = [] index = 1 for i in range(N): row = [] for j in range(N): row.append(int(data[index])) index += 1 grid.append(row) fill_puzzle(grid, N)"},{"question":"from typing import List def count_peaks(grid: List[List[int]]) -> int: Given an M x N grid where each cell contains a value that represents the height of a terrain, find the total number of peaks in the grid. A cell is considered a \\"peak\\" if its value is greater than the values of its adjacent cells (up, down, left, right). >>> count_peaks([ [1, 2, 1], [4, 3, 4], [1, 5, 1] ]) 3 >>> count_peaks([ [10, 10, 10], [10, 11, 10], [10, 10, 10] ]) 1 >>> count_peaks([ [1, 1, 1, 1], [1, 2, 2, 1], [1, 2, 2, 1], [1, 1, 1, 1] ]) 0 >>> count_peaks([ [8] ]) 1 >>> count_peaks([ [1, 2], [3, 4] ]) 1","solution":"def count_peaks(grid): M = len(grid) N = len(grid[0]) peaks = 0 def is_peak(i, j): current = grid[i][j] # Up if i > 0 and grid[i - 1][j] >= current: return False # Down if i < M - 1 and grid[i + 1][j] >= current: return False # Left if j > 0 and grid[i][j - 1] >= current: return False # Right if j < N - 1 and grid[i][j + 1] >= current: return False return True for i in range(M): for j in range(N): if is_peak(i, j): peaks += 1 return peaks"},{"question":"def min_palindromic_length(n: int) -> int: Given the number of tree types n, return the minimum number of trees needed to form a palindromic sequence that includes all tree types at least once. >>> min_palindromic_length(1) 1 >>> min_palindromic_length(3) 5","solution":"def min_palindromic_length(n): Given the number of tree types n, return the minimum number of trees needed to form a palindromic sequence that includes all tree types at least once. if n == 1: return 1 else: return 2 * n - 1 # Example usage print(min_palindromic_length(1)) # Expected output: 1 print(min_palindromic_length(3)) # Expected output: 5"},{"question":"from typing import List def min_moves_to_reach_end(M: int, N: int, grid: List[List[int]]) -> int: A treasure hunter is on an MxN grid. She starts at the top-left corner of the grid and wants to reach the bottom-right corner. Each cell of the grid contains a value that represents the maximum number of steps she can move right or down from that cell in a single move. The function aims to determine the minimum number of moves required to reach the bottom-right corner of the grid. If it is not possible to reach the destination, it returns -1. >>> min_moves_to_reach_end(3, 3, [[2, 1, 1], [1, 1, 1], [1, 1, 1]]) 3 >>> min_moves_to_reach_end(3, 3, [[1, 1, 1], [1, 1, 1], [1, 1, 1]]) 4 >>> min_moves_to_reach_end(2, 2, [[1, 0], [1, 1]]) 2 >>> min_moves_to_reach_end(3, 3, [[2, 0, 0], [0, 0, 0], [0, 0, 1]]) -1 pass","solution":"from collections import deque def min_moves_to_reach_end(M, N, grid): # Directions we can move: down and right directions = [(1, 0), (0, 1)] visited = [[False] * N for _ in range(M)] queue = deque([(0, 0, 0)]) # (current_row, current_col, current_distance) visited[0][0] = True while queue: r, c, dist = queue.popleft() if r == M-1 and c == N-1: return dist steps = grid[r][c] for dr, dc in directions: for i in range(1, steps+1): nr, nc = r + dr * i, c + dc * i if 0 <= nr < M and 0 <= nc < N and not visited[nr][nc]: visited[nr][nc] = True queue.append((nr, nc, dist+1)) return -1"},{"question":"def max_submatrix_sum(M: int, N: int, matrix: List[List[int]]) -> int: Returns the maximum value of any sub-matrix in the given MxN matrix. >>> M, N, matrix = 3, 3, [[1, 2, 3], [4, 5, 6], [7, 8, 9]] >>> max_submatrix_sum(M, N, matrix) 45 >>> M, N, matrix = 2, 4, [[1, 2, 3, 4], [5, 6, 7, 8]] >>> max_submatrix_sum(M, N, matrix) 36","solution":"def max_submatrix_sum(M, N, matrix): Returns the maximum value of any sub-matrix in the given MxN matrix. def calculate_prefix_sums(matrix): prefix_sums = [[0] * (N + 1) for _ in range(M + 1)] for i in range(1, M + 1): for j in range(1, N + 1): prefix_sums[i][j] = ( matrix[i-1][j-1] + prefix_sums[i-1][j] + prefix_sums[i][j-1] - prefix_sums[i-1][j-1] ) return prefix_sums # Calculate prefix sums for the matrix prefix_sums = calculate_prefix_sums(matrix) # Initialize the maximum sub-matrix sum max_sum = float('-inf') # Iterate over all possible top-left and bottom-right coordinates for sub-matrices for r1 in range(1, M + 1): for r2 in range(r1, M + 1): for c1 in range(1, N + 1): for c2 in range(c1, N + 1): # Calculate sub-matrix sum using prefix sums sub_matrix_sum = ( prefix_sums[r2][c2] - prefix_sums[r1-1][c2] - prefix_sums[r2][c1-1] + prefix_sums[r1-1][c1-1] ) # Update maximum sum found max_sum = max(max_sum, sub_matrix_sum) return max_sum"},{"question":"def is_ramanujan_number(N: int) -> str: Check if the number N can be expressed as the sum of two cubes in exactly two different ways. >>> is_ramanujan_number(1729) \\"Yes 1 12 9 10\\" >>> is_ramanujan_number(4104) \\"Yes 2 16 9 15\\" >>> is_ramanujan_number(1000) \\"No\\" >>> is_ramanujan_number(13832) \\"Yes 2 24 18 20\\" >>> is_ramanujan_number(13831) \\"No\\" pass def process_test_cases(test_cases: List[int]) -> List[str]: Process multiple test cases and determine if each number can be expressed as the sum of two cubes in exactly two different ways. >>> process_test_cases([1729, 4104]) [\\"Yes 1 12 9 10\\", \\"Yes 2 16 9 15\\"] >>> process_test_cases([1000, 13832]) [\\"No\\", \\"Yes 2 24 18 20\\"] >>> process_test_cases([1, 2, 3, 4, 5]) [\\"No\\", \\"No\\", \\"No\\", \\"No\\", \\"No\\"] pass","solution":"def is_ramanujan_number(N): Check if the number N can be expressed as the sum of two cubes in exactly two different ways. from collections import defaultdict cubes = defaultdict(list) for i in range(1, int(pow(N, 1/3)) + 1): for j in range(i, int(pow(N, 1/3)) + 1): sum_of_cubes = i**3 + j**3 if sum_of_cubes > N: break cubes[sum_of_cubes].append((i, j)) if N in cubes and len(cubes[N]) > 1: a, b = cubes[N][0] c, d = cubes[N][1] return f\\"Yes {a} {b} {c} {d}\\" else: return \\"No\\" def process_test_cases(test_cases): results = [] for N in test_cases: results.append(is_ramanujan_number(N)) return results"},{"question":"def max_candies(n: int, k: int, candies: List[int]) -> int: Returns the maximum number of candies Alex can collect by choosing candies from at most k jars. Parameters: n (int): The number of candy jars. k (int): The maximum number of jars Alex can pick from. candies (list of int): The number of candies in each jar. Returns: int: The maximum number of candies Alex can collect. Example: >>> max_candies(5, 3, [1, 2, 3, 4, 5]) 12 >>> max_candies(4, 2, [10, 20, 30, 40]) 70 pass from solution import max_candies def test_max_candies_example1(): assert max_candies(5, 3, [1, 2, 3, 4, 5]) == 12 def test_max_candies_example2(): assert max_candies(4, 2, [10, 20, 30, 40]) == 70 def test_max_candies_example3(): assert max_candies(6, 1, [15, 7, 5, 18, 2, 12]) == 18 def test_max_candies_min_values(): assert max_candies(1, 1, [1]) == 1 def test_max_candies_all_same_candies(): assert max_candies(5, 2, [4, 4, 4, 4, 4]) == 8 def test_max_candies_max_values(): n = 100000 k = 50000 candies = [i for i in range(n, 0, -1)] assert max_candies(n, k, candies) == sum(range(n, n - k, -1)) def test_max_candies_edge_case(): assert max_candies(5, 5, [1, 2, 3, 4, 5]) == 15","solution":"def max_candies(n, k, candies): Returns the maximum number of candies Alex can collect by choosing candies from at most k jars. Parameters: n (int): The number of candy jars. k (int): The maximum number of jars Alex can pick from. candies (list of int): The number of candies in each jar. Returns: int: The maximum number of candies Alex can collect. # Sort the candies in descending order candies_sorted = sorted(candies, reverse=True) # Sum up the top k jars max_candies_collected = sum(candies_sorted[:k]) return max_candies_collected"},{"question":"def calculate_score(number_of_questions, correct_answers): Calculate the total score for a participant based on the number of questions and correct answers in a round. :param number_of_questions: Total number of questions in the round :param correct_answers: Number of correct answers provided by the participant :return: Total score of the participant for that round >>> calculate_score(10, 10) 25 >>> calculate_score(8, 5) 13 >>> calculate_score(7, 3) 6","solution":"def calculate_score(number_of_questions, correct_answers): Calculate the total score for a participant based on the number of questions and correct answers in a round. :param number_of_questions: Total number of questions in the round :param correct_answers: Number of correct answers provided by the participant :return: Total score of the participant for that round score = correct_answers * 2 if correct_answers == number_of_questions: score += 5 elif correct_answers > number_of_questions / 2: score += 3 return score if __name__ == \\"__main__\\": import sys input_data = sys.stdin.read().strip().split() number_of_questions = int(input_data[0]) correct_answers = int(input_data[1]) print(calculate_score(number_of_questions, correct_answers))"},{"question":"def count_distinct_palindromic_substrings(s: str) -> int: Given a string of lowercase English letters, determine the number of distinct substrings that can be formed which read the same forwards and backwards (palindromic substrings). >>> count_distinct_palindromic_substrings(\\"a\\") 1 >>> count_distinct_palindromic_substrings(\\"aa\\") 2 >>> count_distinct_palindromic_substrings(\\"abaaa\\") 5 >>> count_distinct_palindromic_substrings(\\"abacdfgdcaba\\") 7 >>> count_distinct_palindromic_substrings(\\"abcdefg\\") 7 >>> count_distinct_palindromic_substrings(\\"aaaaa\\") 5 >>> count_distinct_palindromic_substrings(\\"racecar\\") 7","solution":"def count_distinct_palindromic_substrings(s): def is_palindrome(sub): return sub == sub[::-1] palindromic_substrings = set() n = len(s) for i in range(n): for j in range(i, n): sub = s[i:j+1] if is_palindrome(sub): palindromic_substrings.add(sub) return len(palindromic_substrings)"},{"question":"def can_distribute_sweets(n: int, m: int) -> str: Determines if it is possible to distribute sweets to n children such that no two consecutive children receive the same type of sweet. Parameters: n (int): The number of children. m (int): The number of different types of sweets. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. >>> can_distribute_sweets(3, 2) \\"YES\\" >>> can_distribute_sweets(4, 1) \\"NO\\" from solution import can_distribute_sweets def test_possible_distributions(): assert can_distribute_sweets(3, 2) == \\"YES\\" assert can_distribute_sweets(10, 5) == \\"YES\\" assert can_distribute_sweets(7, 2) == \\"YES\\" assert can_distribute_sweets(1, 1) == \\"YES\\" def test_impossible_distributions(): assert can_distribute_sweets(4, 1) == \\"NO\\" assert can_distribute_sweets(10, 1) == \\"NO\\" assert can_distribute_sweets(10000, 1) == \\"NO\\" assert can_distribute_sweets(2, 1) == \\"NO\\"","solution":"def can_distribute_sweets(n, m): Determines if it is possible to distribute sweets to n children such that no two consecutive children receive the same type of sweet. Parameters: n (int): The number of children. m (int): The number of different types of sweets. Returns: str: \\"YES\\" if possible, \\"NO\\" otherwise. if m == 1 and n > 1: return \\"NO\\" return \\"YES\\""},{"question":"def longest_consecutive_sequence(nums: List[int]) -> int: Returns the length of the longest consecutive elements sequence. >>> longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) 4 >>> longest_consecutive_sequence([9, 1, 4, 7, 3, -1, 0, 5, 8, 6]) 7 >>> longest_consecutive_sequence([]) 0 >>> longest_consecutive_sequence([10]) 1 >>> longest_consecutive_sequence([10, 20, 30, 40]) 1 >>> longest_consecutive_sequence([1, 2, 2, 3, 4]) 4 >>> longest_consecutive_sequence(list(range(1, 10000))) 9999","solution":"def longest_consecutive_sequence(nums): Returns the length of the longest consecutive elements sequence. if not nums: return 0 nums_set = set(nums) longest_streak = 0 for num in nums_set: # only try to build sequences from numbers that are not following up to another number if num - 1 not in nums_set: current_num = num current_streak = 1 # count the length of the sequence while current_num + 1 in nums_set: current_num += 1 current_streak += 1 longest_streak = max(longest_streak, current_streak) return longest_streak # Example usage: nums = [100, 4, 200, 1, 3, 2] print(longest_consecutive_sequence(nums)) # Output: 4"},{"question":"def length_of_longest_substring(s: str) -> int: Returns the length of the longest substring with all unique characters. >>> length_of_longest_substring(\\"abcabcbb\\") 3 >>> length_of_longest_substring(\\"bbbbb\\") 1 >>> length_of_longest_substring(\\"pwwkew\\") 3","solution":"def length_of_longest_substring(s): Returns the length of the longest substring with all unique characters. char_index_map = {} longest = 0 start_index = 0 for current_index, char in enumerate(s): if char in char_index_map and char_index_map[char] >= start_index: start_index = char_index_map[char] + 1 char_index_map[char] = current_index longest = max(longest, current_index - start_index + 1) return longest"},{"question":"def count_islands(grid: List[str]) -> int: Count the number of separate islands in the grid. Args: grid (List[str]): The grid representation with rows as strings. Returns: int: The number of separate islands. >>> count_islands([\\".#..\\", \\"..#.\\", \\"#.\\"]) 2 >>> count_islands([\\"..#...\\", \\"....\\", \\"...#..\\", \\".#..\\", \\"..#.\\"]) 3 >>> count_islands([\\"...\\", \\"...\\", \\"...\\"]) 0 >>> count_islands([\\"#\\", \\"#\\", \\"#\\"]) 1 >>> count_islands([\\"#\\"]) 1 >>> count_islands([\\"#.#.#\\"]) 3 >>> count_islands([\\"#\\",\\".\\",\\"#\\",\\".\\",\\"#\\"]) 3","solution":"def count_islands(grid): Count the number of separate islands in the grid. Args: grid (List[str]): The grid representation with rows as strings. Returns: int: The number of separate islands. N = len(grid) M = len(grid[0]) if N > 0 else 0 def dfs(i, j): if i < 0 or i >= N or j < 0 or j >= M or grid[i][j] != '#': return grid[i][j] = '.' # Mark the land cell as visited dfs(i - 1, j) # up dfs(i + 1, j) # down dfs(i, j - 1) # left dfs(i, j + 1) # right island_count = 0 grid = [list(row) for row in grid] for i in range(N): for j in range(M): if grid[i][j] == '#': island_count += 1 dfs(i, j) return island_count"},{"question":"def minimum_operations_to_single_node(n: int, edges: List[Tuple[int, int]]) -> int: Returns the minimum number of operations required to transform the tree into a single node. Parameters: n (int): Number of nodes in the tree. edges (list of tuples): List of edges in the tree. Returns: int: Minimum number of operations required. >>> minimum_operations_to_single_node(2, [(1, 2)]) 1 >>> minimum_operations_to_single_node(3, [(1, 2), (1, 3)]) 2 >>> minimum_operations_to_single_node(5, [(1, 2), (1, 3), (3, 4), (3, 5)]) 4 import unittest class TestMinimumOperations(unittest.TestCase): def test_minimum_operations_small_tree(self): self.assertEqual(minimum_operations_to_single_node(2, [(1, 2)]), 1) self.assertEqual(minimum_operations_to_single_node(3, [(1, 2), (1, 3)]), 2) def test_minimum_operations_medium_tree(self): self.assertEqual(minimum_operations_to_single_node(5, [(1, 2), (1, 3), (3, 4), (3, 5)]), 4) def test_minimum_operations_large_tree(self): nodes = 100000 edges = [(i, i + 1) for i in range(1, nodes)] self.assertEqual(minimum_operations_to_single_node(nodes, edges), 99999)","solution":"def minimum_operations_to_single_node(n, edges): Returns the minimum number of operations required to transform the tree into a single node. Parameters: n (int): Number of nodes in the tree. edges (list of tuples): List of edges in the tree. Returns: int: Minimum number of operations required. # The minimum number of operations to reduce a tree with N nodes # to a single node is always N-1. return n - 1"},{"question":"def largest_palindrome_less_than(N: int) -> int: Write a function that takes an integer \`N\` and returns the largest integer that is a palindrome and less than \`N\`. Constraints: 1  N  10^9 >>> largest_palindrome_less_than(100) 99 >>> largest_palindrome_less_than(12321) 12221 >>> largest_palindrome_less_than(10) 9 >>> largest_palindrome_less_than(9) 8 >>> largest_palindrome_less_than(1) \\"No palindrome less than 1\\" >>> largest_palindrome_less_than(1000000) 999999","solution":"def largest_palindrome_less_than(N): Returns the largest palindrome integer that is less than N. for num in range(N-1, 0, -1): if str(num) == str(num)[::-1]: return num return \\"No palindrome less than 1\\""},{"question":"from typing import List def min_hours_to_ripe_all(grid: List[List[int]]) -> int: Determine the minimum number of hours required until all the crops in the grid become ripe. Args: grid (List[List[int]]): A 2D list representing the initial state of the grid. Returns: int: The minimum number of hours required for all the crops to become ripe, or -1 if it's impossible. Example: >>> min_hours_to_ripe_all([ ... [1, 0, 0], ... [0, 1, 0], ... [0, 0, 0] ... ]) 2 >>> min_hours_to_ripe_all([ ... [1, 1], ... [1, 0] ... ]) 1 >>> min_hours_to_ripe_all([ ... [1, 1], ... [1, 1] ... ]) 0 >>> min_hours_to_ripe_all([ ... [0, 0], ... [0, 0] ... ]) -1 >>> min_hours_to_ripe_all([ ... [1] ... ]) 0 >>> min_hours_to_ripe_all([ ... [0] ... ]) -1 >>> min_hours_to_ripe_all([ ... [1, 0, 0, 1], ... [0, 1, 0, 0], ... [0, 0, 1, 0], ... [1, 0, 0, 0] ... ]) 2","solution":"from collections import deque def min_hours_to_ripe_all(grid): n = len(grid) if not grid: return -1 queue = deque() total_ripe = 0 # Initialize the queue with all ripe crops for i in range(n): for j in range(n): if grid[i][j] == 1: queue.append((i, j)) total_ripe += 1 if total_ripe == 0: # No initial ripe crop to start the process return -1 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] hours = 0 while queue: size = len(queue) for _ in range(size): x, y = queue.popleft() for d in directions: new_x, new_y = x + d[0], y + d[1] if 0 <= new_x < n and 0 <= new_y < n and grid[new_x][new_y] == 0: grid[new_x][new_y] = 1 queue.append((new_x, new_y)) total_ripe += 1 if queue: hours += 1 for row in grid: if 0 in row: return -1 if total_ripe == n * n: return hours else: return -1"},{"question":"def can_transform(s: str) -> str: Determines if it's possible to transform the string into a string with no adjacent repeating characters by deleting at most one character. # Implementation goes here def solve(T: int, strings: List[str]) -> List[str]: Solves the problem for T test cases. # Implementation goes here if __name__ == \\"__main__\\": import sys input = sys.stdin.read data = input().split() T = int(data[0]) strings = data[1:] result = solve(T, strings) for res in result: print(res) # Tests for can_transform def test_can_transform(): assert can_transform(\\"abccba\\") == \\"YES\\" assert can_transform(\\"aaabb\\") == \\"NO\\" assert can_transform(\\"abcde\\") == \\"YES\\" assert can_transform(\\"aab\\") == \\"YES\\" assert can_transform(\\"a\\") == \\"YES\\" assert can_transform(\\"aa\\") == \\"YES\\" assert can_transform(\\"aaa\\") == \\"NO\\" assert can_transform(\\"abccbaaa\\") == \\"NO\\" # Tests for solve def test_solve(): assert solve(3, [\\"abccba\\", \\"aaabb\\", \\"abcde\\"]) == [\\"YES\\", \\"NO\\", \\"YES\\"] assert solve(1, [\\"aab\\"]) == [\\"YES\\"] assert solve(2, [\\"a\\", \\"aa\\"]) == [\\"YES\\", \\"YES\\"] assert solve(1, [\\"aaa\\"]) == [\\"NO\\"]","solution":"def can_transform(s): Determines if it's possible to transform the string into a string with no adjacent repeating characters by deleting at most one character. def is_valid(s): for i in range(len(s) - 1): if s[i] == s[i + 1]: return False return True if is_valid(s): return \\"YES\\" for i in range(len(s)): if is_valid(s[:i] + s[i + 1:]): return \\"YES\\" return \\"NO\\" def solve(T, strings): results = [] for s in strings: results.append(can_transform(s)) return results"},{"question":"def minWateringSessions(flower_beds): Calculate the minimum number of distinct watering sessions required to water all the flower beds without any overlaps. >>> minWateringSessions([(1, 4), (2, 5), (6, 8), (7, 9)]) 2 >>> minWateringSessions([(1, 3), (2, 4), (3, 5)]) 2 >>> minWateringSessions([(1, 2), (3, 4), (5, 6)]) 1 >>> minWateringSessions([(1, 5), (3, 6), (5, 7)]) 2","solution":"def minWateringSessions(flower_beds): if not flower_beds: return 0 # Sort the flower beds by their start time flower_beds.sort() # List to hold the end times of current watering sessions end_times = [] for start, end in flower_beds: placed = False # Try to find a session where this flower bed can be watered for i in range(len(end_times)): if start >= end_times[i]: end_times[i] = end placed = True break if not placed: end_times.append(end) return len(end_times)"},{"question":"from typing import List, Tuple def update_grid(R: int, C: int, operations: List[Tuple[int, int, int, int]]) -> List[List[int]]: Update the grid according to the given operations and return the final state of the grid. Parameters: R (int): Number of rows in the grid. C (int): Number of columns in the grid. operations (List[Tuple[int, int, int, int]]): List of operations to be performed on the grid. Returns: List[List[int]]: The final state of the grid after all operations have been performed. >>> update_grid(3, 3, [(1, 1, 2, 2), (2, 2, 3, 3), (1, 2, 2, 3), (2, 1, 3, 2)]) [[1, 2, 1], [2, 4, 2], [1, 2, 1]] >>> update_grid(3, 3, [(1, 1, 2, 2)]) [[1, 1, 0], [1, 1, 0], [0, 0, 0]]","solution":"def update_grid(R, C, operations): # Initialize a grid with all elements set to 0 grid = [[0] * C for _ in range(R)] # Perform each operation for (i, j, k, l) in operations: # Convert to zero-indexed for internal representation for row in range(i-1, k): for col in range(j-1, l): grid[row][col] += 1 return grid"},{"question":"def can_cut_exactly_n_rectangles(w: int, h: int, n: int) -> str: Determines if it is possible to cut exactly \`n\` smaller rectangles with integer dimensions from a \`w x h\` rectangle. >>> can_cut_exactly_n_rectangles(5, 3, 15) \\"YES\\" >>> can_cut_exactly_n_rectangles(7, 3, 22) \\"NO\\" >>> can_cut_exactly_n_rectangles(1, 1, 1) \\"YES\\"","solution":"def can_cut_exactly_n_rectangles(w, h, n): Determines if it's possible to cut exactly n smaller rectangles with integer dimensions from a w x h rectangle. # The total number of smaller rectangles that can be obtained is w * h. if n <= 0: return \\"NO\\" total_smaller_rectangles = w * h return \\"YES\\" if n <= total_smaller_rectangles else \\"NO\\""},{"question":"def count_overgrown_flowers(gardens): Count the number of overgrown flowers in the garden. >>> count_overgrown_flowers([ ([ \\"F.WF\\", \\"W..W\\", \\"F.WF\\" ], 3, 4), ([ \\"FW\\", \\"WF\\" ], 2, 2) ]) [2, 2]","solution":"def count_overgrown_flowers(gardens): def is_overgrown(garden, r, c, x, y): directions = [(-1, -1), (-1, 0), (-1, 1), (0, -1), (0, 1), (1, -1), (1, 0), (1, 1)] weeds_count = 0 for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < r and 0 <= ny < c and garden[nx][ny] == 'W': weeds_count += 1 return weeds_count >= 2 results = [] for garden, r, c in gardens: overgrown_count = 0 for i in range(r): for j in range(c): if garden[i][j] == 'F' and is_overgrown(garden, r, c, i, j): overgrown_count += 1 results.append(overgrown_count) return results"},{"question":"def evaluate_rpn(expression: str) -> int: Evaluates a Reverse Polish Notation (RPN) expression and returns the result as an integer. Args: expression (str): A string representing the RPN expression. Returns: int: The result of the RPN expression. >>> evaluate_rpn(\\"3 4 + 2 * 7 /\\") 2 >>> evaluate_rpn(\\"5 1 2 + 4 * + 3 -\\") 14 >>> evaluate_rpn(\\"2 3 1 * + 9 -\\") -4 >>> evaluate_rpn(\\"4 13 5 / +\\") 6","solution":"def evaluate_rpn(expression): Evaluates a Reverse Polish Notation (RPN) expression and returns the result as an integer. Args: expression (str): A string representing the RPN expression. Returns: int: The result of the RPN expression. stack = [] tokens = expression.split() for token in tokens: if token in {'+', '-', '*', '/'}: b = stack.pop() a = stack.pop() if token == '+': stack.append(a + b) elif token == '-': stack.append(a - b) elif token == '*': stack.append(a * b) elif token == '/': # Integer division that truncates towards zero. stack.append(int(a / b)) else: stack.append(int(token)) return stack[0]"},{"question":"from typing import List def minimum_moves_to_escape_dungeon(n: int, m: int, grid: List[str]) -> int: Returns the minimum number of moves to escape the dungeon or -1 if it's impossible. >>> minimum_moves_to_escape_dungeon(4, 4, ['....', '..', '.#..', '.#..']) 6 >>> minimum_moves_to_escape_dungeon(3, 3, ['..#', '#..', '..#']) -1 pass # Your implementation here # Unit tests def test_example_1(): n, m = 4, 4 grid = [ \\"....\\", \\"..\\", \\".#..\\", \\".#..\\" ] assert minimum_moves_to_escape_dungeon(n, m, grid) == 6 def test_example_2(): n, m = 3, 3 grid = [ \\"..#\\", \\"#..\\", \\"..#\\" ] assert minimum_moves_to_escape_dungeon(n, m, grid) == -1 def test_single_block_grid(): n, m = 1, 1 grid = [\\".\\"] assert minimum_moves_to_escape_dungeon(n, m, grid) == 0 def test_unreachable_bottom_right(): n, m = 2, 2 grid = [ \\".#\\", \\"#.\\" ] assert minimum_moves_to_escape_dungeon(n, m, grid) == -1 def test_larger_grid(): n, m = 5, 5 grid = [ \\".....\\", \\".#.\\", \\".#.#.\\", \\".#.#.\\", \\".....\\" ] assert minimum_moves_to_escape_dungeon(n, m, grid) == 8 def test_grid_with_all_blocked(): n, m = 2, 2 grid = [ \\"\\", \\"\\" ] assert minimum_moves_to_escape_dungeon(n, m, grid) == -1","solution":"from collections import deque def minimum_moves_to_escape_dungeon(n, m, grid): Returns the minimum number of moves to escape the dungeon or -1 if it's impossible. if grid[0][0] == '#' or grid[n-1][m-1] == '#': return -1 directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] queue = deque([(0, 0, 0)]) # (row, col, move_count) visited = set() visited.add((0, 0)) while queue: x, y, moves = queue.popleft() if x == n-1 and y == m-1: return moves for dx, dy in directions: nx, ny = x + dx, y + dy if 0 <= nx < n and 0 <= ny < m and (nx, ny) not in visited and grid[nx][ny] == '.': visited.add((nx, ny)) queue.append((nx, ny, moves + 1)) return -1"},{"question":"def are_anagrams(str1: str, str2: str) -> str: Returns 'YES' if str1 and str2 are anagrams, 'NO' otherwise. >>> are_anagrams(\\"listen\\", \\"silent\\") \\"YES\\" >>> are_anagrams(\\"apple\\", \\"pale\\") \\"NO\\" def process_input(input_lines: List[str]) -> List[str]: Processes a list of pairs of strings and returns a list of results indicating whether each pair are anagrams. >>> process_input([\\"listen silent\\", \\"triangle integral\\", \\"apple pale\\"]) [\\"YES\\", \\"YES\\", \\"NO\\"]","solution":"def are_anagrams(str1, str2): Returns 'YES' if str1 and str2 are anagrams, 'NO' otherwise. return 'YES' if sorted(str1) == sorted(str2) else 'NO' def process_input(input_lines): results = [] for pair in input_lines: str1, str2 = pair.split() results.append(are_anagrams(str1, str2)) return results"},{"question":"def calculate_total_revenue(n: int, projects_data: List[List[int]]) -> List[int]: Calculate the total revenue generated by each sales representative. :param n: int - Number of sales representatives :param projects_data: list of lists - Each inner list contains the number of projects followed by the revenue for each project. :return: list of int - Total revenue for each sales representative Examples: >>> calculate_total_revenue(3, [[2, 100, 200], [1, 150], [0]]) [300, 150, 0] >>> calculate_total_revenue(2, [[3, 300, 250, 100], [2, 500, 300]]) [650, 800]","solution":"def calculate_total_revenue(n, projects_data): Calculate the total revenue generated by each sales representative. :param n: int - Number of sales representatives :param projects_data: list of lists - Each inner list contains the number of projects followed by the revenue for each project. :return: list of int - Total revenue for each sales representative total_revenues = [] for projects in projects_data: k = projects[0] if k == 0: total_revenues.append(0) else: revenue = sum(projects[1:]) total_revenues.append(revenue) return total_revenues"},{"question":"def is_valid_palindrome(s: str) -> str: Determines if the given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): Input string. Returns: str: \\"YES\\" if the input string is a valid palindrome, \\"NO\\" otherwise. >>> is_valid_palindrome(\\"A man, a plan, a canal: Panama\\") \\"YES\\" >>> is_valid_palindrome(\\"race a car\\") \\"NO\\"","solution":"def is_valid_palindrome(s): Determines if the given string is a valid palindrome, considering only alphanumeric characters and ignoring cases. Parameters: s (str): Input string. Returns: str: \\"YES\\" if the input string is a valid palindrome, \\"NO\\" otherwise. # Convert to lowercase and filter out non-alphanumeric characters filtered_chars = [char.lower() for char in s if char.isalnum()] # Check if the filtered string is equal to its reverse is_palindrome = filtered_chars == filtered_chars[::-1] return \\"YES\\" if is_palindrome else \\"NO\\""},{"question":"def max_groups(n: int, k: int, m: int, skills: List[int]) -> int: Returns the maximum number of valid groups that can be formed where each group has either exactly \`k\` members or any number of members between \`k\` and \`m\` inclusive. :param n: int - number of players :param k: int - minimum size of a group :param m: int - maximum size of a group :param skills: List[int] - the skill levels of the players :return: int - maximum number of valid groups >>> max_groups(8, 3, 4, [1, 2, 3, 4, 5, 6, 7, 8]) 2 >>> max_groups(10, 3, 5, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) 2","solution":"def max_groups(n, k, m, skills): Returns the maximum number of valid groups that can be formed where each group has either exactly \`k\` members or any number of members between \`k\` and \`m\` inclusive. :param n: int - number of players :param k: int - minimum size of a group :param m: int - maximum size of a group :param skills: List[int] - the skill levels of the players :return: int - maximum number of valid groups # Sort skills in descending order skills.sort(reverse=True) max_groups = 0 i = 0 while i + k <= n: if i + m <= n: i += m else: i += k max_groups += 1 return max_groups"},{"question":"def polycarp_subarray_problem(n: int, m: int, k: int, arr: List[int]) -> List[Union[str, List[int]]]: Determine if it's possible to make the length of the largest contiguous subarray consisting of equal integers at least k by changing at most m elements. Parameters: n (int): Length of the array. m (int): Maximum number of elements that can be changed. k (int): Desired minimum length of the contiguous subarray of equal integers. arr (List[int]): The array of integers. Returns: List[Union[str, List[int]]]: If it is possible to achieve p  k, returns \\"YES\\" and the resulting array, otherwise returns \\"NO\\". >>> polycarp_subarray_problem(6, 2, 3, [1, 1, 2, 2, 3, 3]) ['YES', [1, 1, 1, 2, 3, 3]] >>> polycarp_subarray_problem(5, 3, 4, [5, 5, 5, 6, 6]) ['YES', [5, 5, 5, 5, 6]] >>> polycarp_subarray_problem(4, 1, 2, [2, 2, 2, 2]) ['YES', [2, 2, 2, 2]] >>> polycarp_subarray_problem(7, 1, 5, [1, 2, 3, 4, 5, 6, 7]) ['NO'] pass # Unit Tests def test_example_1(): n = 6 m = 2 k = 3 arr = [1, 1, 2, 2, 3, 3] result = polycarp_subarray_problem(n, m, k, arr) assert result[0] == \\"YES\\" assert len(result[1]) == n assert result[1][:3] == [1, 1, 1] def test_example_2(): n = 5 m = 3 k = 4 arr = [5, 5, 5, 6, 6] result = polycarp_subarray_problem(n, m, k, arr) assert result[0] == \\"YES\\" assert len(result[1]) == n assert result[1][:4] == [5, 5, 5, 5] def test_example_3(): n = 4 m = 1 k = 2 arr = [2, 2, 2, 2] result = polycarp_subarray_problem(n, m, k, arr) assert result[0] == \\"YES\\" assert len(result[1]) == n assert result[1] == arr def test_example_4(): n = 7 m = 1 k = 5 arr = [1, 2, 3, 4, 5, 6, 7] result = polycarp_subarray_problem(n, m, k, arr) assert result[0] == \\"NO\\"","solution":"def find_subarray(arr, n, m, k): for i in range(n): changes = 0 j = i while j < n and (changes < m or arr[j] == arr[i]): if arr[j] != arr[i]: changes += 1 j += 1 if (j - i) >= k: result = list(arr) for x in range(i, j): result[x] = arr[i] return \\"YES\\", result return \\"NO\\", [] def polycarp_subarray_problem(n, m, k, arr): status, solution_arr = find_subarray(arr, n, m, k) if status == \\"YES\\": return [\\"YES\\", solution_arr] else: return [\\"NO\\"] if __name__ == \\"__main__\\": n = 5 m = 3 k = 4 arr = [5, 5, 5, 6, 6] print(polycarp_subarray_problem(n, m, k, arr)) n = 7 m = 1 k = 5 arr = [1, 2, 3, 4, 5, 6, 7] print(polycarp_subarray_problem(n, m, k, arr))"},{"question":"def is_beautiful_sequence(N: int, sequence: List[int]) -> str: Determines if the given sequence is beautiful according to the problem's conditions. A sequence is considered beautiful if there exists some integer K (K >= 2), such that every subsequence of length K is strictly increasing or strictly decreasing. Parameters: N (int): The number of elements in the sequence. sequence (List[int]): The sequence of N distinct integers. Returns: str: \\"YES\\" if the sequence is beautiful, otherwise \\"NO\\". >>> is_beautiful_sequence(4, [2, 1, 4, 3]) 'YES' >>> is_beautiful_sequence(5, [1, 3, 4, 2, 5]) 'NO'","solution":"def is_beautiful_sequence(N, sequence): Determines if the given sequence is beautiful according to the problem's conditions. A sequence is considered beautiful if there exists some integer K (K >= 2), such that every subsequence of length K is strictly increasing or strictly decreasing. Parameters: N (int): The number of elements in the sequence. sequence (List[int]): The sequence of N distinct integers. Returns: str: \\"YES\\" if the sequence is beautiful, otherwise \\"NO\\". # A single-element sequence is trivially beautiful. if N < 2: return \\"YES\\" # Initialize flags for checking alternation between increasing and decreasing is_increasing = sequence[0] < sequence[1] found_pattern = True for i in range(1, N-1): next_is_increasing = sequence[i] < sequence[i+1] if next_is_increasing == is_increasing: found_pattern = False break is_increasing = next_is_increasing return \\"YES\\" if found_pattern else \\"NO\\""},{"question":"def max_treasure(r: int, c: int, grid: List[List[int]]) -> int: Determine the maximum amount of treasure Ella can collect given the grid layout. Args: r (int): number of rows in the grid. c (int): number of columns in the grid. grid (List[List[int]]): 2D list representing the treasure in each cell of the grid. Returns: int: The maximum amount of treasure that can be collected. Example: >>> max_treasure(3, 3, [[1, 3, 1], [1, 5, 1], [4, 2, 1]]) 12 >>> max_treasure(2, 2, [[1, 2], [3, 4]]) 8","solution":"def max_treasure(r, c, grid): # Create a 2D array to store the maximum treasure up to each cell dp = [[0] * c for _ in range(r)] # Initial cell dp[0][0] = grid[0][0] # Fill the first row for j in range(1, c): dp[0][j] = dp[0][j - 1] + grid[0][j] # Fill the first column for i in range(1, r): dp[i][0] = dp[i - 1][0] + grid[i][0] # Fill the rest of the dp table for i in range(1, r): for j in range(1, c): dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j] # The bottom-right corner is the answer return dp[r - 1][c - 1]"},{"question":"def is_valid_number(s: str) -> str: Determine if the given string is a valid number representation. >>> is_valid_number(\\"123\\") \\"valid\\" >>> is_valid_number(\\"-0.678\\") \\"valid\\" >>> is_valid_number(\\"7.89e+20\\") \\"valid\\" >>> is_valid_number(\\"123e\\") \\"invalid\\" >>> is_valid_number(\\"--45\\") \\"invalid\\"","solution":"import re def is_valid_number(s: str) -> str: Determine if the given string is a valid number representation. :param s: String to be checked :return: 'valid' if the string represents a valid number based on the defined rules, otherwise 'invalid' number_regex = re.compile(r'^[+-]?(d+(.d*)?|.d+)([eE][+-]?d+)?') if number_regex.match(s): return \\"valid\\" else: return \\"invalid\\""},{"question":"def lexicographically_smallest_string(n: int, k: int, s: str) -> str: Return the lexicographically smallest string that can be obtained by removing exactly k characters from the original string s. >>> lexicographically_smallest_string(7, 3, 'abcdxyz') 'abcd' >>> lexicographically_smallest_string(5, 2, 'acdbx') 'abx'","solution":"def lexicographically_smallest_string(n, k, s): # We are to remove k characters from the string s stack = [] to_remove = k for char in s: while stack and to_remove > 0 and stack[-1] > char: stack.pop() to_remove -= 1 stack.append(char) # If there are still characters to remove while to_remove > 0: stack.pop() to_remove -= 1 return ''.join(stack)"},{"question":"def unique_paths_with_obstacles(m: int, n: int, grid: List[List[int]]) -> int: Returns the number of unique paths the robot can take to reach the destination without hitting any obstacles. >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 1, 0], [0, 0, 0]]) == 2 >>> unique_paths_with_obstacles(3, 3, [[0, 0, 0], [0, 0, 0], [0, 0, 0]]) == 6 >>> unique_paths_with_obstacles(3, 3, [[0, 1, 0], [0, 0, 0], [0, 0, 0]]) == 3 >>> unique_paths_with_obstacles(1, 1, [[0]]) == 1 >>> unique_paths_with_obstacles(1, 1, [[1]]) == 0 >>> unique_paths_with_obstacles(1, 4, [[0, 0, 1, 0]]) == 0 >>> unique_paths_with_obstacles(4, 1, [[0], [0], [1], [0]]) == 0 >>> unique_paths_with_obstacles(100, 100, [[0] * 100 for _ in range(100)]) > 0 >>> unique_paths_with_obstacles(5, 5, [[1] * 5 for _ in range(5)]) == 0","solution":"def unique_paths_with_obstacles(m, n, grid): Returns the number of unique paths the robot can take to reach the destination without hitting any obstacles. # Create a 2D DP array with the same dimensions as the grid dp = [[0] * n for _ in range(m)] # Initialize the starting position if grid[0][0] == 1: return 0 # If the starting cell has an obstacle, return 0 dp[0][0] = 1 # Fill the first row for j in range(1, n): if grid[0][j] == 0: dp[0][j] = dp[0][j - 1] # Fill the first column for i in range(1, m): if grid[i][0] == 0: dp[i][0] = dp[i - 1][0] # Compute paths for other cells for i in range(1, m): for j in range(1, n): if grid[i][j] == 0: dp[i][j] = dp[i - 1][j] + dp[i][j - 1] return dp[m - 1][n - 1]"},{"question":"from typing import List def count_unique_anagrams(s: str) -> int: Returns the count of unique anagrams that can be formed from the string s. >>> count_unique_anagrams(\\"abc\\") 6 >>> count_unique_anagrams(\\"aabb\\") 6 pass def process_input(input_lines: List[str]) -> List[int]: Process a list of input strings to calculate the number of unique anagrams for each string. >>> process_input([\\"abc\\", \\"aabb\\", \\"*\\"]) [6, 6] >>> process_input([\\"abcd\\", \\"aaaa\\", \\"abab\\", \\"abc\\", \\"*\\"]) [24, 1, 6, 6] pass","solution":"from math import factorial from collections import Counter def count_unique_anagrams(s): Returns the count of unique anagrams that can be formed from the string s. # Calculate the factorial of the length of the string n_fact = factorial(len(s)) # Calculate the product of the factorials of the frequency counts of each character freq_counts = Counter(s) denom = 1 for count in freq_counts.values(): denom *= factorial(count) # The result is n_fact divided by denom return n_fact // denom def process_input(input_lines): results = [] for line in input_lines: if line == '*': break results.append(count_unique_anagrams(line)) return results"},{"question":"def can_align_robots_on_straight_line(n: int, coordinates: List[Tuple[int, int]]) -> str: Determines if all given robots can align themselves on a straight line with equal distance between adjacent robots. Args: n: int - number of robots coordinates: list of tuples - list containing (x, y) coordinates of robots Returns: str - \\"Yes\\" if it is possible to align all robots on a straight line with equal distance, \\"No\\" otherwise. Examples: >>> can_align_robots_on_straight_line(3, [(1, 1), (3, 1), (2, 1)]) \\"Yes\\" >>> can_align_robots_on_straight_line(4, [(0, 0), (2, 2), (4, 0), (6, 2)]) \\"No\\"","solution":"def can_align_robots_on_straight_line(n, coordinates): Determines if all given robots can align themselves on a straight line. Args: n: int - number of robots coordinates: list of tuples - list containing (x, y) coordinates of robots Returns: str - \\"Yes\\" if it is possible to align all robots on a straight line, \\"No\\" otherwise. if n == 2: return \\"Yes\\" # Any two points are always collinear # Calculate slope between the first point and every other point x0, y0 = coordinates[0] x1, y1 = coordinates[1] dx = x1 - x0 dy = y1 - y0 for i in range(2, n): xi, yi = coordinates[i] if dx * (yi - y0) != dy * (xi - x0): return \\"No\\" return \\"Yes\\""},{"question":"def island_perimeter(grid: List[List[int]]) -> int: Find the perimeter of the island in the given grid. >>> island_perimeter([ ... [0, 1, 0, 0], ... [1, 1, 1, 0], ... [0, 1, 0, 0], ... [1, 1, 0, 0] ... ]) 16 >>> island_perimeter([ ... [0, 1, 0], ... [1, 1, 1], ... [0, 1, 0] ... ]) 12 >>> island_perimeter([ ... [1] ... ]) 4 >>> island_perimeter([ ... [1, 0], ... [0, 1] ... ]) 8 >>> island_perimeter([ ... [1, 1], ... [1, 1] ... ]) 8","solution":"def island_perimeter(grid): n = len(grid) m = len(grid[0]) perimeter = 0 directions = [(0, 1), (1, 0), (0, -1), (-1, 0)] for i in range(n): for j in range(m): if grid[i][j] == 1: # Check all 4 directions for dx, dy in directions: ni, nj = i + dx, j + dy # Increase perimeter if adjacent cell is water or out of bounds if ni < 0 or ni >= n or nj < 0 or nj >= m or grid[ni][nj] == 0: perimeter += 1 return perimeter"},{"question":"def longest_balanced_substring(n: int, s: str) -> int: Returns the length of the longest balanced substring in the input string s, where a balanced string contains an equal number of 'a' and 'b' characters. Parameters: n (int): The length of the string. s (str): The input string containing characters 'a' and 'b'. Returns: int: The length of the longest balanced substring. >>> longest_balanced_substring(6, \\"aababb\\") 6 >>> longest_balanced_substring(8, \\"aabbbaaa\\") 6 >>> longest_balanced_substring(2, \\"ab\\") 2 >>> longest_balanced_substring(8, \\"abababab\\") 8 >>> longest_balanced_substring(4, \\"aaaa\\") 0 >>> longest_balanced_substring(4, \\"bbbb\\") 0","solution":"def longest_balanced_substring(n, s): Returns the length of the longest balanced substring in input string s. Parameters: n (int): The length of the string. s (str): The input string containing characters 'a' and 'b'. Returns: int: The length of the longest balanced substring. max_length = 0 balance = 0 balance_map = {0: -1} # Initialize with balance 0 at index -1 for i in range(n): if s[i] == 'a': balance += 1 else: balance -= 1 if balance in balance_map: # Calculate the length of the balanced substring current_length = i - balance_map[balance] max_length = max(max_length, current_length) else: # Store the first occurrence of this balance balance_map[balance] = i return max_length"},{"question":"def count_segments_with_sum(n: int, target: int, books: List[int]) -> int: Counts the number of distinct segments whose sum is equal to the target value. Parameters: n (int): Number of books. target (int): Target sum value. books (list of int): List of positive integers representing the attributes of the books. Returns: int: The number of distinct segments whose sum is equal to the target value. >>> count_segments_with_sum(5, 6, [1, 2, 3, 2, 1]) 2 >>> count_segments_with_sum(6, 5, [1, 1, 1, 1, 1, 1]) 2","solution":"def count_segments_with_sum(n, target, books): Counts the number of distinct segments whose sum is equal to the target value. Parameters: n (int): Number of books. target (int): Target sum value. books (list of int): List of positive integers representing the attributes of the books. Returns: int: The number of distinct segments whose sum is equal to the target value. count = 0 current_sum = 0 sum_map = {0: 1} for book in books: current_sum += book if current_sum - target in sum_map: count += sum_map[current_sum - target] if current_sum not in sum_map: sum_map[current_sum] = 0 sum_map[current_sum] += 1 return count # Example usage n = 5 target = 6 books = [1, 2, 3, 2, 1] print(count_segments_with_sum(n, target, books)) # Output should be 2"},{"question":"def detect_conflicts(test_cases: List[List[Tuple[int, int]]]) -> List[str]: Determine if there are any conflicting events in the list of events for each test case. >>> detect_conflicts([[(1, 3), (2, 4), (5, 6)], [(1, 2), (3, 4)]]) [\\"YES\\", \\"NO\\"] pass def parse_input(input_string: str) -> List[List[Tuple[int, int]]]: Parse the input string and return a list of test cases where each test case is a list of events represented as tuples. >>> parse_input(\\"2n3n1 3n2 4n5 6n2n1 2n3 4n\\") [[(1, 3), (2, 4), (5, 6)], [(1, 2), (3, 4)]] pass def main(input_string: str) -> List[str]: Main function to get the input string and return the list of results for each test case. >>> main(\\"2n3n1 3n2 4n5 6n2n1 2n3 4n\\") [\\"YES\\", \\"NO\\"] pass","solution":"def detect_conflicts(test_cases): results = [] for events in test_cases: events.sort(key=lambda x: x[0]) conflict_found = False for i in range(1, len(events)): if events[i][0] < events[i-1][1]: conflict_found = True break results.append(\\"YES\\" if conflict_found else \\"NO\\") return results def parse_input(input_string): lines = input_string.strip().split(\\"n\\") T = int(lines[0]) line_index = 1 test_cases = [] for _ in range(T): N = int(lines[line_index]) line_index += 1 events = [] for _ in range(N): S, E = map(int, lines[line_index].split()) events.append((S, E)) line_index += 1 test_cases.append(events) return test_cases def main(input_string): test_cases = parse_input(input_string) return detect_conflicts(test_cases)"},{"question":"from typing import List def sort_bubble_ids(bubble_ids: List[str]) -> List[str]: Sorts the bubble IDs in the custom order: descending by the letter and ascending by the number part. Parameters: bubble_ids (List[str]): List of bubble IDs. Returns: List[str]: Sorted list of bubble IDs. pass # Test cases def test_example_case(): bubble_ids = [\\"B123\\", \\"A456\\", \\"A123\\", \\"D789\\", \\"B456\\"] expected = [\\"D789\\", \\"B123\\", \\"B456\\", \\"A123\\", \\"A456\\"] assert sort_bubble_ids(bubble_ids) == expected def test_single_entry(): bubble_ids = [\\"A100\\"] expected = [\\"A100\\"] assert sort_bubble_ids(bubble_ids) == expected def test_all_same_letter(): bubble_ids = [\\"A300\\", \\"A100\\", \\"A200\\"] expected = [\\"A100\\", \\"A200\\", \\"A300\\"] assert sort_bubble_ids(bubble_ids) == expected def test_all_same_number(): bubble_ids = [\\"B300\\", \\"A300\\", \\"C300\\"] expected = [\\"C300\\", \\"B300\\", \\"A300\\"] assert sort_bubble_ids(bubble_ids) == expected def test_large_numbers(): bubble_ids = [\\"B1234567890\\", \\"A123456789\\", \\"A1234567890\\", \\"B1234567889\\"] expected = [\\"B1234567889\\", \\"B1234567890\\", \\"A123456789\\", \\"A1234567890\\"] assert sort_bubble_ids(bubble_ids) == expected def test_duplicates(): bubble_ids = [\\"A1\\", \\"A1\\", \\"B1\\"] expected = [\\"B1\\", \\"A1\\", \\"A1\\"] assert sort_bubble_ids(bubble_ids) == expected def test_no_digits(): bubble_ids = [] expected = [] assert sort_bubble_ids(bubble_ids) == expected","solution":"def sort_bubble_ids(bubble_ids): Sorts the bubble IDs in the custom order: descending by the letter and ascending by the number part. Parameters: bubble_ids (List[str]): List of bubble IDs. Returns: List[str]: Sorted list of bubble IDs. return sorted(bubble_ids, key=lambda x: (-ord(x[0]), int(x[1:])))"},{"question":"def count_arrangements(N: int, M: int) -> int: Compute the number of distinct valid arrangements of stones modulo (10^9 + 7). Given N stones and M different colors, arrange them such that no two adjacent stones are of the same color. Args: N : int : number of stones M : int : number of colors Returns: int : number of distinct valid arrangements modulo (10^9 + 7) >>> count_arrangements(3, 3) 12 >>> count_arrangements(2, 3) 6 >>> count_arrangements(1, 5) 5","solution":"def count_arrangements(N, M): MOD = 10**9 + 7 # If there is only one stone, there are M ways to arrange it. if N == 1: return M # If there is more than one stone, use the combinatorial logic. # First stone has M options. # For each subsequent stone, we have (M - 1) options (it should not be the same as the previous one). result = M * pow(M - 1, N - 1, MOD) return result % MOD"},{"question":"def determine_winner(n: int, m: int) -> str: Determines which player (Alice or Bob) will make the pieces meet or if they never meet. Args: - n (int): number of rows of the board. - m (int): number of columns of the board. Returns: - str: \\"Alice\\" if Alice's move makes the pieces meet, \\"Bob\\" if Bob's move makes the pieces meet, or \\"Never\\". Examples: >>> determine_winner(4, 4) \\"Bob\\" >>> determine_winner(2, 3) \\"Alice\\" >>> determine_winner(5, 5) \\"Bob\\"","solution":"def determine_winner(n, m): Determines which player (Alice or Bob) will make the pieces meet or if they never meet. Args: - n (int): number of rows of the board. - m (int): number of columns of the board. Returns: - str: \\"Alice\\" if Alice's move makes the pieces meet, \\"Bob\\" if Bob's move makes the pieces meet, or \\"Never\\". # When the sum of (n - 1) + (m - 1) is even, Bob wins because Alice makes the move first. # When the sum of (n - 1) + (m - 1) is odd, Alice wins because Alice makes the move first. steps = (n - 1) + (m - 1) if steps % 2 == 0: return \\"Bob\\" else: return \\"Alice\\""},{"question":"def can_cover_grid(m: int, n: int, a: int, b: int) -> str: Determines if the entire grid (m x n) can be covered exactly with tiles (a x b) without any gaps or overlaps. >>> can_cover_grid(6, 6, 2, 3) 'YES' >>> can_cover_grid(7, 3, 3, 2) 'NO' >>> can_cover_grid(8, 4, 4, 2) 'YES'","solution":"def can_cover_grid(m, n, a, b): Determines if the entire grid (m x n) can be covered exactly with tiles (a x b) without any gaps or overlaps. if m % a == 0 and n % b == 0: return \\"YES\\" return \\"NO\\""}]`),j={name:"App",components:{PoemCard:R},data(){return{searchQuery:"",visibleCount:4,poemsData:S,isLoading:!1}},computed:{filteredPoems(){const i=this.searchQuery.trim().toLowerCase();return i?this.poemsData.filter(e=>e.question&&e.question.toLowerCase().includes(i)||e.solution&&e.solution.toLowerCase().includes(i)):this.poemsData},displayedPoems(){return this.searchQuery.trim()?this.filteredPoems:this.filteredPoems.slice(0,this.visibleCount)},hasMorePoems(){return!this.searchQuery.trim()&&this.visibleCount<this.poemsData.length}},methods:{async loadMore(){this.isLoading=!0,await new Promise(i=>setTimeout(i,1e3)),this.visibleCount+=4,this.isLoading=!1}}},E={class:"search-container"},D={class:"card-container"},O={key:0,class:"empty-state"},z=["disabled"],I={key:0},C={key:1};function F(i,e,u,c,r,a){const p=h("PoemCard");return s(),n("section",null,[e[4]||(e[4]=t("div",{class:"top-banner"},[t("div",{class:"top-banner-title"},[t("div",{class:"top-banner-title-text"},"prompts chat")])],-1)),t("div",E,[e[3]||(e[3]=t("span",{class:"search-icon"},"",-1)),g(t("input",{type:"text",class:"search-input","onUpdate:modelValue":e[0]||(e[0]=o=>r.searchQuery=o),placeholder:"Search..."},null,512),[[b,r.searchQuery]]),r.searchQuery?(s(),n("button",{key:0,class:"clear-search",onClick:e[1]||(e[1]=o=>r.searchQuery="")},"  ")):l("",!0)]),t("div",D,[(s(!0),n(y,null,x(a.displayedPoems,(o,f)=>(s(),v(p,{key:f,poem:o},null,8,["poem"]))),128)),a.displayedPoems.length===0?(s(),n("div",O,' No results found for "'+_(r.searchQuery)+'". ',1)):l("",!0)]),a.hasMorePoems?(s(),n("button",{key:0,class:"load-more-button",disabled:r.isLoading,onClick:e[2]||(e[2]=(...o)=>a.loadMore&&a.loadMore(...o))},[r.isLoading?(s(),n("span",C,"Loading...")):(s(),n("span",I,"See more"))],8,z)):l("",!0)])}const P=d(j,[["render",F],["__scopeId","data-v-e17a1cc5"]]),Y=JSON.parse('{"title":"","description":"","frontmatter":{"page":true},"headers":[],"relativePath":"grok/15.md","filePath":"grok/15.md"}'),B={name:"grok/15.md"},G=Object.assign(B,{setup(i){return(e,u)=>(s(),n("div",null,[w(P)]))}});export{Y as __pageData,G as default};
